Project Path: arc_AssetRipper_AssetRipper_pirre0d4

Source Tree:

```txt
arc_AssetRipper_AssetRipper_pirre0d4
├── AssetRipper.slnx
├── LICENSE.md
├── Localizations
│   ├── LICENSE
│   ├── README.md
│   ├── ar.json
│   ├── de.json
│   ├── el.json
│   ├── en_US.json
│   ├── es.json
│   ├── fa.json
│   ├── fr.json
│   ├── id.json
│   ├── it.json
│   ├── ja.json
│   ├── ko.json
│   ├── nl.json
│   ├── pl.json
│   ├── pt_BR.json
│   ├── ro.json
│   ├── ru.json
│   ├── th.json
│   ├── tr.json
│   ├── uk.json
│   ├── zh_Hans.json
│   └── zh_Hant.json
├── Media
│   └── Images
│       ├── 2D_Logo
│       │   ├── AssetRipperLogo.kra
│       │   ├── AssetRipperLogo.png
│       │   ├── AssetRipperLogoBackground.png
│       │   └── AssetRipperLogoTransparent.png
│       └── LogoReimagined
│           ├── LogoReimagined.blend
│           ├── LogoReimagined.png
│           ├── LogoReimaginedBackground.png
│           ├── LogoReimaginedBackgroundTransparent.png
│           └── LogoReimaginedTransparent.png
├── README.md
├── Source
│   ├── AssetRipper.AssemblyDumper
│   │   ├── AST
│   │   │   ├── DictionaryNode.cs
│   │   │   ├── FieldNode.cs
│   │   │   ├── KeyNode.cs
│   │   │   ├── ListNode.cs
│   │   │   ├── Node.cs
│   │   │   ├── PPtrNode.cs
│   │   │   ├── PairNode.cs
│   │   │   ├── PrimitiveNode.cs
│   │   │   ├── SingleNode.cs
│   │   │   ├── TypeNode.cs
│   │   │   └── ValueNode.cs
│   │   ├── AssemblyBuilder.cs
│   │   ├── AssetRipper.AssemblyDumper.csproj
│   │   ├── Attributes
│   │   │   ├── AssemblyAttributeCreator.cs
│   │   │   ├── AttributeCreator.cs
│   │   │   ├── CompilerInjectedAttributeCreator.cs
│   │   │   └── ModuleAttributeCreator.cs
│   │   ├── CachedReferenceImporter.cs
│   │   ├── ClassProperty.cs
│   │   ├── Documentation
│   │   │   ├── ClassDocumenter.cs
│   │   │   ├── DocumentationHandler.cs
│   │   │   ├── EnumTypeDocumenter.cs
│   │   │   ├── HistoryBaseExtensions.cs
│   │   │   ├── IdEnumDocumenter.cs
│   │   │   ├── InjectedDocumenter.cs
│   │   │   ├── InterfaceDocumenter.Properties.cs
│   │   │   ├── InterfaceDocumenter.Types.cs
│   │   │   ├── InterfaceDocumenter.cs
│   │   │   ├── SeeXmlTagGenerator.cs
│   │   │   ├── StringBuilderExtensions.cs
│   │   │   ├── StringExtensions.cs
│   │   │   ├── UnityVersionRangeExtensions.cs
│   │   │   ├── UnityVersionRangeUtils.cs
│   │   │   ├── VersionedListDocumenter.cs
│   │   │   ├── XmlNodeExtensions.cs
│   │   │   └── XmlUtils.cs
│   │   ├── Enums
│   │   │   ├── EnumDefinitionBase.cs
│   │   │   ├── MergedEnumDefinition.cs
│   │   │   └── SingleEnumDefinition.cs
│   │   ├── Extensions
│   │   │   ├── CilInstructionCollectionExtensions.cs
│   │   │   ├── DictionaryExtensions.cs
│   │   │   ├── EnumHistoryExtensions.cs
│   │   │   ├── EnumMemberHistoryExtensions.cs
│   │   │   ├── TypeSignatureExtensions.cs
│   │   │   └── UnityVersionExtensions.cs
│   │   ├── Fields
│   │   │   └── FixedSizeBufferCreator.cs
│   │   ├── GeneratedInterfaceUtils.cs
│   │   ├── GenericTypeResolver.cs
│   │   ├── Groups
│   │   │   ├── ClassGroup.cs
│   │   │   ├── ClassGroupBase.cs
│   │   │   ├── GeneratedClassInstance.cs
│   │   │   └── SubclassGroup.cs
│   │   ├── InjectedClassProperty.cs
│   │   ├── InjectedInterfaceProperty.cs
│   │   ├── InjectedTypes
│   │   │   ├── AudioClipHelper.cs
│   │   │   ├── CopyValuesHelper.cs
│   │   │   ├── EqualityComparisonHelper.cs
│   │   │   ├── FetchDependenciesEnumerableBase.cs
│   │   │   ├── HashHelper.cs
│   │   │   ├── MonoBehaviourHelper.cs
│   │   │   ├── PPtrHelper.cs
│   │   │   ├── TypelessDataHelper.cs
│   │   │   └── WalkingHelper.cs
│   │   ├── InterfaceProperty.cs
│   │   ├── Methods
│   │   │   ├── ConstructorUtils.cs
│   │   │   ├── EqualityMethods.cs
│   │   │   ├── MethodCreator.cs
│   │   │   ├── MethodUtils.cs
│   │   │   └── PropertyCreator.cs
│   │   ├── NodeType.cs
│   │   ├── Notes.md
│   │   ├── Passes
│   │   │   ├── DebuggerExtensions.cs
│   │   │   ├── NullableAnnotation.cs
│   │   │   ├── NullableExtensions.cs
│   │   │   ├── Pass000_ProcessTpk.cs
│   │   │   ├── Pass001_MergeMovedGroups.cs
│   │   │   ├── Pass002_RenameSubnodes.cs
│   │   │   ├── Pass003_FixTextureImporterNodes.cs
│   │   │   ├── Pass004_FillNameToIdDictionary.cs
│   │   │   ├── Pass005_SplitAbstractClasses.cs
│   │   │   ├── Pass007_ExtractSubclasses.ClassData.cs
│   │   │   ├── Pass007_ExtractSubclasses.Injections.cs
│   │   │   ├── Pass007_ExtractSubclasses.SubclassCandidate.cs
│   │   │   ├── Pass007_ExtractSubclasses.cs
│   │   │   ├── Pass008_DivideAmbiguousPPtr.cs
│   │   │   ├── Pass009_CreateGroups.cs
│   │   │   ├── Pass010_InitializeInterfacesAndFactories.cs
│   │   │   ├── Pass011_ApplyInheritance.cs
│   │   │   ├── Pass012_ApplyCorrectTypeAttributes.cs
│   │   │   ├── Pass013_UnifyFieldsOfAbstractTypes.cs
│   │   │   ├── Pass015_AddFields.cs
│   │   │   ├── Pass039_InjectEnumValues.cs
│   │   │   ├── Pass040_AddEnums.cs
│   │   │   ├── Pass041_NativeEnums.cs
│   │   │   ├── Pass045_AddMarkerInterfaces.cs
│   │   │   ├── Pass052_InterfacePropertiesAndMethods.cs
│   │   │   ├── Pass053_HasMethodsAndNullableAttributes.cs
│   │   │   ├── Pass054_AssignPropertyHistories.cs
│   │   │   ├── Pass055_CreateEnumProperties.cs
│   │   │   ├── Pass058_InjectChineseTextureProperties.cs
│   │   │   ├── Pass061_AddConstructors.cs
│   │   │   ├── Pass062_FillConstructors.cs
│   │   │   ├── Pass063_CreateEmptyMethods.cs
│   │   │   ├── Pass080_PPtrConversions.cs
│   │   │   ├── Pass081_CreatePPtrProperties.cs
│   │   │   ├── Pass100_FillReadMethods.cs
│   │   │   ├── Pass101_FillWriteMethods.cs
│   │   │   ├── Pass102_IgnoreFieldInMetaFilesMethods.cs
│   │   │   ├── Pass103_FillDependencyMethods.DependencyMethodContext.cs
│   │   │   ├── Pass103_FillDependencyMethods.DictionaryNodeHelper.cs
│   │   │   ├── Pass103_FillDependencyMethods.ListNodeHelper.cs
│   │   │   ├── Pass103_FillDependencyMethods.NodeHelper.cs
│   │   │   ├── Pass103_FillDependencyMethods.PPtrNodeHelper.cs
│   │   │   ├── Pass103_FillDependencyMethods.PairNodeHelper.cs
│   │   │   ├── Pass103_FillDependencyMethods.ParentContext.cs
│   │   │   ├── Pass103_FillDependencyMethods.TypeNodeHelper.cs
│   │   │   ├── Pass103_FillDependencyMethods.cs
│   │   │   ├── Pass104_ResetMethods.cs
│   │   │   ├── Pass105_CopyValuesMethods.CopyMethodType.cs
│   │   │   ├── Pass105_CopyValuesMethods.cs
│   │   │   ├── Pass108_WalkMethods.cs
│   │   │   ├── Pass110_ClassNameAndIdOverrides.cs
│   │   │   ├── Pass201_GuidConversionOperators.cs
│   │   │   ├── Pass202_VectorExplicitConversions.cs
│   │   │   ├── Pass203_OffsetPtrImplicitConversions.cs
│   │   │   ├── Pass204_Hash128ExplicitConversion.cs
│   │   │   ├── Pass205_ColorExplicitConversions.cs
│   │   │   ├── Pass206_BoneWeights4ExplicitConversions.cs
│   │   │   ├── Pass300_NamedInterface.cs
│   │   │   ├── Pass301_SourcePrefabProperty.cs
│   │   │   ├── Pass400_EqualityComparison.cs
│   │   │   ├── Pass410_SetValuesMethods.cs
│   │   │   ├── Pass500_PPtrFixes.cs
│   │   │   ├── Pass501_MonoBehaviourImplementation.cs
│   │   │   ├── Pass502_FixGuidAndHashYaml.cs
│   │   │   ├── Pass504_FixShaderName.cs
│   │   │   ├── Pass505_FixOldAudioClip.cs
│   │   │   ├── Pass506_FixUnityConnectSettings.cs
│   │   │   ├── Pass507_InjectedProperties.cs
│   │   │   ├── Pass508_LazySceneObjectIdentifier.cs
│   │   │   ├── Pass510_FixComponentPairWalking.cs
│   │   │   ├── Pass555_CreateCommonString.cs
│   │   │   ├── Pass556_CreateClassIDTypeEnum.cs
│   │   │   ├── Pass557_CreateSourceTpkClass.cs
│   │   │   ├── Pass558_TypeCache.cs
│   │   │   ├── Pass920_InterfaceInheritance.cs
│   │   │   ├── Pass940_MakeAssetFactory.cs
│   │   │   ├── Pass941_MakeFieldHashes.cs
│   │   │   ├── Pass998_SaveAssembly.cs
│   │   │   ├── Pass999_Documentation.cs
│   │   │   ├── PropertyInjector.cs
│   │   │   ├── TypeSignatureStruct.cs
│   │   │   └── ValidNameGenerator.cs
│   │   ├── Program.cs
│   │   ├── Properties
│   │   │   └── AssemblyInfo.cs
│   │   ├── PropertyBase.cs
│   │   ├── SharedState.cs
│   │   ├── Types
│   │   │   ├── EnumCreator.cs
│   │   │   ├── EnumUnderlyingType.cs
│   │   │   ├── ExceptionCreator.cs
│   │   │   ├── FunctionPointerCreator.cs
│   │   │   ├── FunctionPointerStructCreator.cs
│   │   │   ├── InterfaceCreator.cs
│   │   │   ├── InterfaceUtils.cs
│   │   │   ├── StaticClassCreator.cs
│   │   │   ├── StructCreator.cs
│   │   │   └── TypeDefinitionExtensions.cs
│   │   ├── UniqueNameFactory.cs
│   │   ├── UniversalClass.cs
│   │   ├── UniversalCommonString.cs
│   │   ├── UniversalNode.cs
│   │   ├── UniversalNodeComparer.cs
│   │   └── Usings.cs
│   ├── AssetRipper.AssemblyDumper.Downloader
│   │   ├── AssetRipper.AssemblyDumper.Downloader.csproj
│   │   └── Program.cs
│   ├── AssetRipper.AssemblyDumper.NativeEnumExtractor
│   │   ├── AssetRipper.AssemblyDumper.NativeEnumExtractor.csproj
│   │   └── Program.cs
│   ├── AssetRipper.AssemblyDumper.NuGetFixer
│   │   ├── AssetRipper.AssemblyDumper.NuGetFixer.csproj
│   │   └── Program.cs
│   ├── AssetRipper.AssemblyDumper.Recompiler
│   │   ├── AssetRipper.AssemblyDumper.Recompiler.csproj
│   │   └── Program.cs
│   ├── AssetRipper.AssemblyDumper.Tests
│   │   ├── AssetRipper.AssemblyDumper.Tests.csproj
│   │   ├── TypeSignatureNameTests.cs
│   │   ├── Usings.cs
│   │   └── VersionedListTests.cs
│   ├── AssetRipper.AssemblyDumper.Utils
│   │   ├── AssetRipper.AssemblyDumper.Utils.csproj
│   │   ├── IDeepCloneable.cs
│   │   ├── VersionedList.cs
│   │   ├── VersionedListConverterFactory.cs
│   │   └── VersionedList`1.cs
│   ├── AssetRipper.Assets
│   │   ├── AssetRipper.Assets.csproj
│   │   ├── Bundles
│   │   │   ├── Bundle.cs
│   │   │   ├── DefaultGameInitializer.cs
│   │   │   ├── GameBundle.FromPaths.cs
│   │   │   ├── GameBundle.cs
│   │   │   ├── IDependencyProvider.cs
│   │   │   ├── IGameInitializer.cs
│   │   │   ├── IResourceProvider.cs
│   │   │   ├── ProcessedBundle.cs
│   │   │   ├── SerializedBundle.cs
│   │   │   └── VirtualBundle.cs
│   │   ├── Cloning
│   │   │   ├── AssetEqualityComparer.cs
│   │   │   ├── DefaultAssetResolver.cs
│   │   │   ├── IAssetResolver.cs
│   │   │   ├── PPtrConverter.cs
│   │   │   └── SingleReplacementAssetResolver.cs
│   │   ├── Collections
│   │   │   ├── AssetCollection.cs
│   │   │   ├── ProcessedAssetCollection.cs
│   │   │   ├── SceneDefinition.cs
│   │   │   ├── SerializedAssetCollection.cs
│   │   │   └── VirtualAssetCollection.cs
│   │   ├── Debugging
│   │   │   ├── AssetKeyValuePair.cs
│   │   │   ├── DebuggingWalker.cs
│   │   │   ├── FieldNameValuePair.cs
│   │   │   ├── UnityAssetBaseProxy.cs
│   │   │   ├── UnityAssetBaseWithCollection.cs
│   │   │   └── UnityObjectBaseProxy.cs
│   │   ├── EmptyAsset.cs
│   │   ├── Exceptions
│   │   │   └── IncorrectByteCountException.cs
│   │   ├── Generics
│   │   │   ├── AccessDictionary.cs
│   │   │   ├── AccessDictionaryBase.cs
│   │   │   ├── AccessList.cs
│   │   │   ├── AccessListBase.cs
│   │   │   ├── AccessPair.cs
│   │   │   ├── AccessPairBase.cs
│   │   │   ├── AssetDictionary.cs
│   │   │   ├── AssetList.cs
│   │   │   ├── AssetPair.cs
│   │   │   ├── PPtrAccessList.cs
│   │   │   └── ReadOnlyArraySegment.cs
│   │   ├── IDeepCloneable.cs
│   │   ├── INamed.cs
│   │   ├── IO
│   │   │   ├── AssetFactoryBase.cs
│   │   │   └── Writing
│   │   │       ├── AssetWriter.cs
│   │   │       └── IAssetWritable.cs
│   │   ├── IUnityAssetBase.cs
│   │   ├── IUnityObjectBase.cs
│   │   ├── Metadata
│   │   │   ├── AssetInfo.cs
│   │   │   ├── IPPtr.cs
│   │   │   ├── NullPPtr.cs
│   │   │   └── PPtr.cs
│   │   ├── NullObject.cs
│   │   ├── StringPathExtensions.cs
│   │   ├── Traversal
│   │   │   └── AssetWalker.cs
│   │   ├── UnityAssetBase.cs
│   │   ├── UnityObjectBase.PathDetails.cs
│   │   ├── UnityObjectBase.cs
│   │   └── Usings.cs
│   ├── AssetRipper.Assets.Tests
│   │   ├── AccessListTests.cs
│   │   ├── AssetEqualityTests.cs
│   │   ├── AssetListTests.cs
│   │   ├── AssetResolutionTests.cs
│   │   ├── AssetRipper.Assets.Tests.csproj
│   │   ├── FileResolutionTests.cs
│   │   ├── GameBundleTests.cs
│   │   ├── GameObjectCopyValuesTests.cs
│   │   ├── PPtrAccessListTests.cs
│   │   ├── PPtrTests.cs
│   │   ├── ProcessedBundleTests.cs
│   │   ├── SceneDefinitionTests.cs
│   │   ├── TransformCopyValuesTests.cs
│   │   └── Usings.cs
│   ├── AssetRipper.DocExtraction
│   │   ├── AssemblyParser.cs
│   │   ├── AssetRipper.DocExtraction.csproj
│   │   ├── DataStructures
│   │   │   ├── ClassHistory.cs
│   │   │   ├── ComplexTypeHistory.cs
│   │   │   ├── DataMemberHistory.cs
│   │   │   ├── EnumHistory.cs
│   │   │   ├── EnumMemberHistory.cs
│   │   │   ├── HistoryBase.cs
│   │   │   ├── HistoryFile.cs
│   │   │   ├── StructHistory.cs
│   │   │   └── TypeHistory.cs
│   │   ├── DocumentationExtractor.cs
│   │   ├── Extensions
│   │   │   ├── AttributeExtractionExtensions.cs
│   │   │   ├── ConstantExtensions.cs
│   │   │   ├── DictionaryExtensions.cs
│   │   │   ├── ElementTypeExtensions.cs
│   │   │   ├── HasCustomAttributeExtensions.cs
│   │   │   ├── PropertyDefinitionExtensions.cs
│   │   │   └── TypeDefinitionExtensions.cs
│   │   ├── JsonSourceGenerationContext.cs
│   │   ├── Metadata
│   │   │   ├── ClassDocumentation.cs
│   │   │   ├── ComplexTypeDocumentation.cs
│   │   │   ├── DataMemberDocumentation.cs
│   │   │   ├── DocumentationBase.cs
│   │   │   ├── DocumentationFile.cs
│   │   │   ├── EnumDocumentation.cs
│   │   │   ├── EnumMemberDocumentation.cs
│   │   │   ├── FullName.cs
│   │   │   ├── StructDocumentation.cs
│   │   │   └── TypeDocumentation.cs
│   │   ├── Usings.cs
│   │   └── XmlDocumentParser.cs
│   ├── AssetRipper.DocExtraction.ConsoleApp
│   │   ├── AssetRipper.DocExtraction.ConsoleApp.csproj
│   │   ├── Program.cs
│   │   └── Usings.cs
│   ├── AssetRipper.Export
│   │   ├── AssetRipper.Export.csproj
│   │   ├── Configuration
│   │   │   ├── AudioExportFormat.cs
│   │   │   ├── EngineResourceDataContext.cs
│   │   │   ├── ExportSettings.cs
│   │   │   ├── FullConfiguration.cs
│   │   │   ├── ImageExportFormat.cs
│   │   │   ├── LightmapTextureExportFormat.cs
│   │   │   ├── ScriptExportMode.cs
│   │   │   ├── ScriptLanguageVersion.cs
│   │   │   ├── SerializedSettings.cs
│   │   │   ├── SerializedSettingsContext.cs
│   │   │   ├── ShaderExportMode.cs
│   │   │   ├── SpriteExportMode.cs
│   │   │   ├── TerrainExportMode.cs
│   │   │   └── TextExportMode.cs
│   │   └── ObjectHandlerStack.cs
│   ├── AssetRipper.Export.Modules.Audio
│   │   ├── AssetRipper.Export.Modules.Audio.csproj
│   │   ├── AudioClipDecoder.cs
│   │   └── AudioConverter.cs
│   ├── AssetRipper.Export.Modules.Models
│   │   ├── AssetRipper.Export.Modules.Models.csproj
│   │   ├── GlbCoordinateConversion.cs
│   │   ├── GlbLevelBuilder.cs
│   │   ├── GlbMeshBuilder.cs
│   │   ├── GlbMeshType.cs
│   │   ├── GlbSubMeshBuilder.cs
│   │   ├── GlbTerrainBuilder.cs
│   │   ├── GlbWriter.cs
│   │   ├── MeshDataExtensions.cs
│   │   ├── VertexColor1Texture8.cs
│   │   └── VertexVariable.cs
│   ├── AssetRipper.Export.Modules.Textures
│   │   ├── AssetRipper.Export.Modules.Textures.csproj
│   │   ├── BmpWriter.cs
│   │   ├── CrunchHandler.cs
│   │   ├── DirectBitmap.cs
│   │   ├── DirectBitmap`1.cs
│   │   ├── EmptyDirectBitmap.cs
│   │   ├── SpriteConverter.cs
│   │   ├── TerrainHeatmap.cs
│   │   ├── TextureConverter.cs
│   │   └── Usings.cs
│   ├── AssetRipper.Export.PrimaryContent
│   │   ├── AssetRipper.Export.PrimaryContent.csproj
│   │   ├── Audio
│   │   │   ├── AudioContentExtractor.cs
│   │   │   └── AudioExportCollection.cs
│   │   ├── BinaryAssetContentExtractor.cs
│   │   ├── DefaultJsonWalker.cs
│   │   ├── DeletedAssets
│   │   │   ├── DeletedAssetsExportCollection.cs
│   │   │   └── DeletedAssetsExporter.cs
│   │   ├── EmptyContentExtractor.cs
│   │   ├── EmptyExportCollection.cs
│   │   ├── ExportCollectionBase.cs
│   │   ├── IContentExtractor.cs
│   │   ├── JsonContentExtractor.cs
│   │   ├── Models
│   │   │   ├── GlbExportCollection.cs
│   │   │   ├── GlbMeshExporter.cs
│   │   │   ├── GlbModelExporter.cs
│   │   │   ├── GlbNavMeshExporter.cs
│   │   │   ├── GlbPrefabModelExportCollection.cs
│   │   │   ├── GlbSceneModelExportCollection.cs
│   │   │   └── GlbTerrainExporter.cs
│   │   ├── MultipleExportCollection.cs
│   │   ├── PrimaryContentExporter.cs
│   │   ├── Scripts
│   │   │   ├── ScriptContentExtractor.cs
│   │   │   └── ScriptExportCollection.cs
│   │   ├── SingleExportCollection.cs
│   │   ├── Textures
│   │   │   ├── TerrainHeatmapExportCollection.cs
│   │   │   ├── TerrainHeatmapExporter.cs
│   │   │   └── TextureExporter.cs
│   │   └── Usings.cs
│   ├── AssetRipper.Export.UnityProjects
│   │   ├── AnimatorControllers
│   │   │   ├── AnimatorControllerExportCollection.cs
│   │   │   └── AnimatorControllerExporter.cs
│   │   ├── AssetExportCollection.cs
│   │   ├── AssetRipper.Export.UnityProjects.csproj
│   │   ├── Audio
│   │   │   ├── AudioClipExportCollection.cs
│   │   │   ├── AudioClipExporter.cs
│   │   │   ├── AudioExportCollection.cs
│   │   │   ├── NativeAudioExportCollection.cs
│   │   │   ├── NativeAudioExporter.cs
│   │   │   ├── YamlAudioExportCollection.cs
│   │   │   └── YamlAudioExporter.cs
│   │   ├── AudioMixers
│   │   │   ├── AudioMixerExportCollection.cs
│   │   │   └── AudioMixerExporter.cs
│   │   ├── BinaryAssetExporter.cs
│   │   ├── DeletedAssets
│   │   │   ├── DeletedAssetsExportCollection.cs
│   │   │   └── DeletedAssetsExporter.cs
│   │   ├── DummyAssetExporter.cs
│   │   ├── EmptyExportCollection.cs
│   │   ├── EngineAssets
│   │   │   ├── EngineAssetsExporter.cs
│   │   │   ├── EngineAssetsFactory.cs
│   │   │   └── PredefinedAssetCache.cs
│   │   ├── ExportCollection.cs
│   │   ├── ExportHandler.cs
│   │   ├── ExportIdHandler.cs
│   │   ├── Extensions
│   │   │   └── OcclusionCullingDataExtensions.cs
│   │   ├── FailExportCollection.cs
│   │   ├── IAssetExporter.cs
│   │   ├── IExportCollection.cs
│   │   ├── IExportContainer.cs
│   │   ├── IPostExporter.cs
│   │   ├── InvariantStreamWriter.cs
│   │   ├── Meta.cs
│   │   ├── MetaPtr.cs
│   │   ├── Miscellaneous
│   │   │   ├── FontAssetExportCollection.cs
│   │   │   ├── FontAssetExporter.cs
│   │   │   ├── MovieTextureAssetExportCollection.cs
│   │   │   ├── MovieTextureAssetExporter.cs
│   │   │   ├── TextAssetExportCollection.cs
│   │   │   ├── TextAssetExporter.cs
│   │   │   ├── VideoClipExportCollection.cs
│   │   │   └── VideoClipExporter.cs
│   │   ├── PathIdMapping
│   │   │   ├── PathIdMapExporter.cs
│   │   │   ├── SerializedAssetInfo.cs
│   │   │   ├── SerializedFileInfo.cs
│   │   │   ├── SerializedGameInfo.cs
│   │   │   └── SerializedGameInfoSerializerContext.cs
│   │   ├── Project
│   │   │   ├── AssetsExportCollection.cs
│   │   │   ├── DefaultYamlExporter.cs
│   │   │   ├── EditorBuildSettingsExportCollection.cs
│   │   │   ├── ManagerAssetExporter.cs
│   │   │   ├── ManagerExportCollection.cs
│   │   │   ├── PackageManifest.cs
│   │   │   ├── PackageManifestPostExporter.cs
│   │   │   ├── PackageManifestSerializerContext.cs
│   │   │   ├── PrefabExportCollection.cs
│   │   │   ├── ProjectVersionPostExporter.cs
│   │   │   ├── ProjectYamlWalker.cs
│   │   │   ├── SceneAssetExportCollection.cs
│   │   │   ├── SceneAssetExporter.cs
│   │   │   ├── SceneExportCollection.cs
│   │   │   ├── SceneYamlExporter.cs
│   │   │   ├── ScriptableObjectExporter.cs
│   │   │   ├── ScriptableObjectGroupExporter.cs
│   │   │   ├── StreamingAssetsPostExporter.cs
│   │   │   ├── UnityPatches.cs
│   │   │   ├── YamlExporterBase.cs
│   │   │   ├── YamlStreamedAssetExportCollection.cs
│   │   │   └── YamlStreamedAssetExporter.cs
│   │   ├── ProjectAssetContainer.cs
│   │   ├── ProjectExporter.Overrides.cs
│   │   ├── ProjectExporter.cs
│   │   ├── RawAssets
│   │   │   ├── UnknownExportCollection.cs
│   │   │   ├── UnknownObjectExporter.cs
│   │   │   ├── UnreadableExportCollection.cs
│   │   │   └── UnreadableObjectExporter.cs
│   │   ├── RedirectExportCollection.cs
│   │   ├── Scripts
│   │   │   ├── AssemblyData.cs
│   │   │   ├── AssemblyDataFile.cs
│   │   │   ├── AssemblyDataSerializerContext.cs
│   │   │   ├── AssemblyDefinitions
│   │   │   │   ├── AssemblyDefinitionAsset.cs
│   │   │   │   ├── AssemblyDefinitionDetails.cs
│   │   │   │   ├── AssemblyDefinitionExporter.cs
│   │   │   │   └── AssemblyDefinitionSerializerContext.cs
│   │   │   ├── AssemblyExportType.cs
│   │   │   ├── AssemblyResolverExtensions.cs
│   │   │   ├── CecilAssemblyResolver.cs
│   │   │   ├── DllPostExporter.cs
│   │   │   ├── EmptyScript.cs
│   │   │   ├── EmptyScriptExportCollection.cs
│   │   │   ├── MonoScriptInfo.cs
│   │   │   ├── ReferenceAssemblies.cs
│   │   │   ├── ScriptDecompiler.cs
│   │   │   ├── ScriptExportCollection.cs
│   │   │   ├── ScriptExportCollectionBase.cs
│   │   │   ├── ScriptExporter.cs
│   │   │   └── ScriptHashing.cs
│   │   ├── Shaders
│   │   │   ├── DummyShaderTextExporter.cs
│   │   │   ├── PropertyType.cs
│   │   │   ├── RequiredProperty.cs
│   │   │   ├── ShaderExportCollection.cs
│   │   │   ├── ShaderExporterBase.cs
│   │   │   ├── SimpleShaderExporter.cs
│   │   │   ├── TemplateJson.cs
│   │   │   ├── TemplateJsonSerializerContext.cs
│   │   │   ├── TemplateList.cs
│   │   │   ├── TemplateShader.cs
│   │   │   ├── Templates
│   │   │   │   ├── Default.txt
│   │   │   │   ├── SingleColor.txt
│   │   │   │   ├── SingleTexture.txt
│   │   │   │   ├── Templates.json
│   │   │   │   └── TransparentDiffuse.txt
│   │   │   ├── YamlShaderExportCollection.cs
│   │   │   └── YamlShaderExporter.cs
│   │   ├── SingleRedirectExportCollection.cs
│   │   ├── SkipExportCollection.cs
│   │   ├── StrippedAssetExtensions.cs
│   │   ├── Terrains
│   │   │   ├── TerrainYamlExportCollection.cs
│   │   │   └── TerrainYamlExporter.cs
│   │   ├── Textures
│   │   │   ├── Enums
│   │   │   │   └── KTXBaseInternalFormat.cs
│   │   │   ├── Extensions
│   │   │   │   └── Texture2DExtensions.cs
│   │   │   ├── ImporterFactory.cs
│   │   │   ├── LightmapTextureAssetExporter.cs
│   │   │   ├── RawTextureExportCollection.cs
│   │   │   ├── RawTextureExporter.cs
│   │   │   ├── TextureArrayAssetExportCollection.cs
│   │   │   ├── TextureArrayAssetExporter.cs
│   │   │   ├── TextureAssetExporter.cs
│   │   │   ├── TextureExportCollection.cs
│   │   │   └── YamlSpriteExporter.cs
│   │   ├── Usings.cs
│   │   └── YamlWalker.cs
│   ├── AssetRipper.GUI.Free
│   │   ├── AssetRipper.GUI.Free.csproj
│   │   ├── Program.cs
│   │   ├── appsettings.Development.json
│   │   └── appsettings.json
│   ├── AssetRipper.GUI.Licensing
│   │   ├── AssetRipper.GUI.Licensing.csproj
│   │   ├── LicenseNotFoundException.cs
│   │   └── Licenses.cs
│   ├── AssetRipper.GUI.Licensing.SourceGenerator
│   │   ├── AssetRipper.GUI.Licensing.SourceGenerator.csproj
│   │   └── LicensesGenerator.cs
│   ├── AssetRipper.GUI.Localizations
│   │   ├── AssetRipper.GUI.Localizations.csproj
│   │   ├── LanguageCodes.cs
│   │   └── Localization.cs
│   ├── AssetRipper.GUI.Localizations.SourceGenerator
│   │   ├── AssetRipper.GUI.Localizations.SourceGenerator.csproj
│   │   ├── DictionarySerializerContext.cs
│   │   ├── LanguageCodesGenerator.cs
│   │   └── LocalizationGenerator.cs
│   ├── AssetRipper.GUI.SourceGenerator
│   │   ├── AssetRipper.GUI.SourceGenerator.csproj
│   │   ├── DictionarySerializerContext.cs
│   │   ├── Paths.cs
│   │   ├── Program.cs
│   │   ├── PropertyData.cs
│   │   └── SettingsPageGenerator.cs
│   ├── AssetRipper.GUI.Web
│   │   ├── AppJsonSerializerContext.cs
│   │   ├── Arguments.cs
│   │   ├── AssetRipper.GUI.Web.csproj
│   │   ├── DefaultPage.cs
│   │   ├── Dialogs.cs
│   │   ├── Documentation
│   │   │   ├── ClearDocumentTagsTransformer.cs
│   │   │   ├── ClearOperationTagsTransformer.cs
│   │   │   ├── DocumentationExtensions.cs
│   │   │   ├── DocumentationPaths.cs
│   │   │   ├── InsertionMetadata.cs
│   │   │   ├── InsertionOperationTransformer.cs
│   │   │   ├── NullSerializerContext.cs
│   │   │   └── SortDocumentPathsTransformer.cs
│   │   ├── ErrorHandlingMiddleware.cs
│   │   ├── GameFileLoader.cs
│   │   ├── HttpClientBuilder.cs
│   │   ├── OnlineDependencies.cs
│   │   ├── Pages
│   │   │   ├── Accordian.cs
│   │   │   ├── AccordianItem.cs
│   │   │   ├── Assets
│   │   │   │   ├── AssetAPI.cs
│   │   │   │   ├── AssetHtmlTab.cs
│   │   │   │   ├── AudioTab.cs
│   │   │   │   ├── DependenciesTab.cs
│   │   │   │   ├── DevelopmentTab.cs
│   │   │   │   ├── FontTab.cs
│   │   │   │   ├── HexTab.cs
│   │   │   │   ├── ImageTab.cs
│   │   │   │   ├── InformationTab.cs
│   │   │   │   ├── JsonTab.cs
│   │   │   │   ├── ModelTab.cs
│   │   │   │   ├── TextTab.cs
│   │   │   │   ├── VideoTab.cs
│   │   │   │   ├── ViewPage.cs
│   │   │   │   └── YamlTab.cs
│   │   │   ├── Bundles
│   │   │   │   ├── BundleAPI.cs
│   │   │   │   └── ViewPage.cs
│   │   │   ├── ByteArrayExtensions.cs
│   │   │   ├── Collections
│   │   │   │   ├── CollectionAPI.cs
│   │   │   │   └── ViewPage.cs
│   │   │   ├── Commands.cs
│   │   │   ├── CommandsPage.cs
│   │   │   ├── DataExtensions.cs
│   │   │   ├── FailedFiles
│   │   │   │   ├── FailedFileAPI.cs
│   │   │   │   └── ViewPage.cs
│   │   │   ├── FormCollectionExtensions.cs
│   │   │   ├── HexTable.cs
│   │   │   ├── HtmlExtensions.cs
│   │   │   ├── HtmlTab.cs
│   │   │   ├── ICommand.cs
│   │   │   ├── IndexPage.cs
│   │   │   ├── LicensesPage.cs
│   │   │   ├── PremiumFeaturesPage.cs
│   │   │   ├── PrivacyPage.cs
│   │   │   ├── Resources
│   │   │   │   ├── ResourceAPI.cs
│   │   │   │   └── ViewPage.cs
│   │   │   ├── SaveButton.cs
│   │   │   ├── Scenes
│   │   │   │   ├── SceneAPI.cs
│   │   │   │   └── ViewPage.cs
│   │   │   ├── Search
│   │   │   │   ├── SearchAPI.cs
│   │   │   │   └── ViewPage.cs
│   │   │   └── Settings
│   │   │       ├── ConfigurationFilesPage.DataStorageTab.cs
│   │   │       ├── ConfigurationFilesPage.ListsTab.cs
│   │   │       ├── ConfigurationFilesPage.SingletonsTab.cs
│   │   │       ├── ConfigurationFilesPage.cs
│   │   │       ├── DropDown
│   │   │       │   ├── AudioExportFormatDropDownSetting.cs
│   │   │       │   ├── BundledAssetsExportModeDropDownSetting.cs
│   │   │       │   ├── DropDownItem.cs
│   │   │       │   ├── DropDownSetting.cs
│   │   │       │   ├── ImageExportFormatDropDownSetting.cs
│   │   │       │   ├── LightmapTextureExportFormatDropDownSetting.cs
│   │   │       │   ├── ScriptContentLevelDropDownSetting.cs
│   │   │       │   ├── ScriptExportModeDropDownSetting.cs
│   │   │       │   ├── ScriptLanguageVersionDropDownSetting.cs
│   │   │       │   ├── ShaderExportModeDropDownSetting.cs
│   │   │       │   ├── SpriteExportModeDropDownSetting.cs
│   │   │       │   ├── StreamingAssetsModeDropDownSetting.cs
│   │   │       │   ├── TerrainExportModeDropDownSetting.cs
│   │   │       │   └── TextExportModeDropDownSetting.cs
│   │   │       ├── SettingsPage.cs
│   │   │       └── SettingsPage.g.cs
│   │   ├── Paths
│   │   │   ├── AssetPath.cs
│   │   │   ├── BundlePath.cs
│   │   │   ├── CollectionPath.cs
│   │   │   ├── FailedFilePath.cs
│   │   │   ├── IPath.cs
│   │   │   ├── PathExtensions.cs
│   │   │   ├── PathLinking.cs
│   │   │   ├── PathSerializerContext.cs
│   │   │   ├── ResourcePath.cs
│   │   │   ├── ScenePath.cs
│   │   │   └── StringExtensions.cs
│   │   ├── RoutingExtensions.cs
│   │   ├── StaticContent
│   │   │   ├── css
│   │   │   │   └── site.css
│   │   │   ├── favicon.ico
│   │   │   └── js
│   │   │       ├── commands_page.js
│   │   │       ├── mesh_preview.js
│   │   │       └── site.js
│   │   ├── StaticContentLoader.cs
│   │   ├── Usings.cs
│   │   ├── VuePage.cs
│   │   ├── WebApplicationLauncher.cs
│   │   └── WelcomeMessage.cs
│   ├── AssetRipper.GUI.Web.Tests
│   │   ├── AssetRipper.GUI.Web.Tests.csproj
│   │   ├── BundlePathTests.cs
│   │   └── Usings.cs
│   ├── AssetRipper.IO.Files
│   │   ├── AssetRipper.IO.Files.csproj
│   │   ├── AssetType.cs
│   │   ├── BuildTarget.cs
│   │   ├── BundleFiles
│   │   │   ├── Archive
│   │   │   │   ├── ArchiveBundle.cs
│   │   │   │   ├── ArchiveBundleHeader.cs
│   │   │   │   ├── ArchiveBundleScheme.cs
│   │   │   │   └── README.md
│   │   │   ├── BundleFlags.cs
│   │   │   ├── BundleHeader.cs
│   │   │   ├── BundleVersion.cs
│   │   │   ├── CompressionType.cs
│   │   │   ├── DirectoryInfo.cs
│   │   │   ├── FileStream
│   │   │   │   ├── BlocksInfo.cs
│   │   │   │   ├── BundleFileBlockReader.cs
│   │   │   │   ├── FileStreamBundleFile.cs
│   │   │   │   ├── FileStreamBundleHeader.cs
│   │   │   │   ├── FileStreamBundleScheme.cs
│   │   │   │   ├── FileStreamNode.cs
│   │   │   │   ├── NodeFlags.cs
│   │   │   │   ├── StorageBlock.cs
│   │   │   │   └── StorageBlockFlags.cs
│   │   │   ├── Hash128.cs
│   │   │   ├── LzmaCompression.cs
│   │   │   ├── Node.cs
│   │   │   ├── RawWeb
│   │   │   │   ├── BundleScene.cs
│   │   │   │   ├── Raw
│   │   │   │   │   ├── RawBundleFile.cs
│   │   │   │   │   ├── RawBundleHeader.cs
│   │   │   │   │   └── RawBundleScheme.cs
│   │   │   │   ├── RawWebBundleFile.cs
│   │   │   │   ├── RawWebBundleHeader.cs
│   │   │   │   ├── RawWebNode.cs
│   │   │   │   └── Web
│   │   │   │       ├── WebBundleFile.cs
│   │   │   │       ├── WebBundleHeader.cs
│   │   │   │       └── WebBundleScheme.cs
│   │   │   └── ZstdCompression.cs
│   │   ├── CompressedFiles
│   │   │   ├── Brotli
│   │   │   │   ├── BrotliFile.cs
│   │   │   │   └── BrotliFileScheme.cs
│   │   │   ├── CompressedFile.cs
│   │   │   └── GZip
│   │   │       ├── GZipFile.cs
│   │   │       └── GZipFileScheme.cs
│   │   ├── Converters
│   │   │   └── SerializedFileMetadataConverter.cs
│   │   ├── Exceptions
│   │   │   ├── DecompressionFailedException.cs
│   │   │   ├── InvalidFormatException.cs
│   │   │   └── UnsupportedBundleDecompression.cs
│   │   ├── Extensions
│   │   │   └── StreamExtensions.cs
│   │   ├── FailedFile.cs
│   │   ├── FileBase.cs
│   │   ├── FileContainer.cs
│   │   ├── FileSystem.cs
│   │   ├── FileSystem.g.cs
│   │   ├── IScheme.cs
│   │   ├── LocalFileSystem.cs
│   │   ├── LocalFileSystem.g.cs
│   │   ├── ResourceFiles
│   │   │   └── ResourceFile.cs
│   │   ├── Scheme.cs
│   │   ├── SchemeReader.cs
│   │   ├── SerializedFiles
│   │   │   ├── FileIdentifiers
│   │   │   │   ├── EndianExtensions.cs
│   │   │   │   ├── FileIdentifier_1.cs
│   │   │   │   ├── FileIdentifier_1.g.cs
│   │   │   │   ├── FileIdentifier_5.cs
│   │   │   │   ├── FileIdentifier_5.g.cs
│   │   │   │   ├── FileIdentifier_6.cs
│   │   │   │   ├── FileIdentifier_6.g.cs
│   │   │   │   ├── IFileIdentifier.cs
│   │   │   │   └── IFileIdentifier.g.cs
│   │   │   ├── FormatVersion.cs
│   │   │   ├── Header
│   │   │   │   ├── ISerializedFileHeader.g.cs
│   │   │   │   ├── SerializedFileHeader_1.g.cs
│   │   │   │   ├── SerializedFileHeader_22.g.cs
│   │   │   │   └── SerializedFileHeader_9.g.cs
│   │   │   ├── IO
│   │   │   │   ├── ISerializedReadable.cs
│   │   │   │   ├── ISerializedWritable.cs
│   │   │   │   ├── SerializedReader.cs
│   │   │   │   └── SerializedWriter.cs
│   │   │   ├── LocalSerializedObjectIdentifiers
│   │   │   │   ├── ILocalSerializedObjectIdentifier.g.cs
│   │   │   │   ├── LocalSerializedObjectIdentifier_1.g.cs
│   │   │   │   └── LocalSerializedObjectIdentifier_14.g.cs
│   │   │   ├── ObjectInformation
│   │   │   │   ├── IObjectInfo.g.cs
│   │   │   │   ├── ObjectInfo_1.g.cs
│   │   │   │   ├── ObjectInfo_11.g.cs
│   │   │   │   ├── ObjectInfo_14.g.cs
│   │   │   │   ├── ObjectInfo_15.g.cs
│   │   │   │   ├── ObjectInfo_16.g.cs
│   │   │   │   ├── ObjectInfo_17.g.cs
│   │   │   │   └── ObjectInfo_22.g.cs
│   │   │   ├── Parser
│   │   │   │   ├── FileIdentifier.cs
│   │   │   │   ├── LocalSerializedObjectIdentifier.cs
│   │   │   │   ├── ObjectInfo.cs
│   │   │   │   ├── SerializedFileHeader.cs
│   │   │   │   ├── SerializedFileMetadata.cs
│   │   │   │   ├── SerializedType.cs
│   │   │   │   ├── SerializedTypeBase.cs
│   │   │   │   ├── SerializedTypeReference.cs
│   │   │   │   └── TypeTrees
│   │   │   │       ├── CommonString.cs
│   │   │   │       ├── TypeTree.cs
│   │   │   │       └── TypeTreeNode.cs
│   │   │   ├── SerializedFile.cs
│   │   │   ├── SerializedFileBuilder.cs
│   │   │   ├── SerializedFileException.cs
│   │   │   ├── SerializedFileScheme.cs
│   │   │   ├── TransferInstructionFlags.cs
│   │   │   ├── TransferMetaFlags.cs
│   │   │   └── TypeTrees
│   │   │       ├── CommonString.cs
│   │   │       ├── ITypeTree.cs
│   │   │       ├── ITypeTreeNode.cs
│   │   │       ├── ITypeTreeNode.g.cs
│   │   │       ├── ReadOnlyList.cs
│   │   │       ├── TypeTree.cs
│   │   │       ├── TypeTreeDumper.cs
│   │   │       ├── TypeTreeNode_1.g.cs
│   │   │       ├── TypeTreeNode_10.g.cs
│   │   │       ├── TypeTreeNode_19.g.cs
│   │   │       ├── TypeTree_1.cs
│   │   │       ├── TypeTree_10.cs
│   │   │       ├── TypeTree_19.cs
│   │   │       └── TypeTree_New.cs
│   │   ├── SpecialFileNames.cs
│   │   ├── Streams
│   │   │   ├── MultiFileStream.cs
│   │   │   ├── PartialStream.cs
│   │   │   ├── RandomAccessStream.cs
│   │   │   ├── Smart
│   │   │   │   ├── SmartStream.SmartRefCount.cs
│   │   │   │   ├── SmartStream.cs
│   │   │   │   └── SmartStreamType.cs
│   │   │   └── SplitNameComparer.cs
│   │   ├── Usings.cs
│   │   ├── Utf8Truncation.cs
│   │   ├── VirtualFileSystem.cs
│   │   ├── VirtualFileSystem.g.cs
│   │   └── WebFiles
│   │       ├── WebFile.cs
│   │       ├── WebFileEntry.cs
│   │       └── WebFileScheme.cs
│   ├── AssetRipper.IO.Files.SourceGenerator
│   │   ├── AssetRipper.IO.Files.SourceGenerator.csproj
│   │   ├── Formats
│   │   │   └── SerializedFile
│   │   │       ├── FileIdentifier
│   │   │       │   ├── FileIdentifier.json
│   │   │       │   ├── Version1.json
│   │   │       │   ├── Version5.json
│   │   │       │   └── Version6.json
│   │   │       ├── LocalSerializedObjectIdentifier
│   │   │       │   ├── LocalSerializedObjectIdentifier.json
│   │   │       │   ├── Version1.json
│   │   │       │   └── Version14.json
│   │   │       ├── ObjectInfo
│   │   │       │   ├── ObjectInfo.json
│   │   │       │   ├── Version1.json
│   │   │       │   ├── Version11.json
│   │   │       │   ├── Version14.json
│   │   │       │   ├── Version15.json
│   │   │       │   ├── Version16.json
│   │   │       │   ├── Version17.json
│   │   │       │   └── Version22.json
│   │   │       ├── SerializedFileHeader
│   │   │       │   ├── SerializedFileHeader.json
│   │   │       │   ├── Version1.json
│   │   │       │   ├── Version22.json
│   │   │       │   └── Version9.json
│   │   │       └── TypeTreeNode
│   │   │           ├── TypeTreeNode.json
│   │   │           ├── Version1.json
│   │   │           ├── Version10.json
│   │   │           ├── Version19.json
│   │   │           └── VersionIndependent.json
│   │   ├── Generator.cs
│   │   ├── InternalSerializerContext.cs
│   │   ├── Json
│   │   │   ├── EnumField.cs
│   │   │   ├── FieldDefinition.cs
│   │   │   ├── FormatDeclaration.cs
│   │   │   ├── PropertyDocumentation.cs
│   │   │   ├── SpecialDetails.cs
│   │   │   ├── StringType.cs
│   │   │   ├── TypeDeclaration.cs
│   │   │   ├── TypeDefinition.cs
│   │   │   └── VersionIdentifier.cs
│   │   ├── ParameterExtensions.cs
│   │   ├── PrimitiveHandler.cs
│   │   ├── Program.cs
│   │   ├── SerializedFileClassGenerator.cs
│   │   ├── TypeExtensions.cs
│   │   └── Usings.cs
│   ├── AssetRipper.IO.Files.Tests
│   │   ├── AssetRipper.IO.Files.Tests.csproj
│   │   ├── BrotliFileSchemeTest.cs
│   │   ├── FileStreamTests.cs
│   │   ├── GZipFileTests.cs
│   │   ├── GetUniqueNameTests.cs
│   │   ├── LzmaCompressionTests.cs
│   │   ├── RandomData.cs
│   │   ├── SerializedFileTests.cs
│   │   ├── SmartStreamTests.cs
│   │   ├── Usings.cs
│   │   ├── VirtualFileSystemTests.cs
│   │   └── WebFileTests.cs
│   ├── AssetRipper.Import
│   │   ├── AssetCreation
│   │   │   ├── GameAssetFactory.cs
│   │   │   ├── RawDataObject.cs
│   │   │   ├── TypeTreeObject.cs
│   │   │   ├── UnknownObject.cs
│   │   │   └── UnreadableObject.cs
│   │   ├── AssetRipper.Import.csproj
│   │   ├── AssetRipperRuntimeInformation.cs
│   │   ├── Configuration
│   │   │   ├── CoreConfiguration.cs
│   │   │   ├── DataEntry.cs
│   │   │   ├── DataInstance.cs
│   │   │   ├── DataSerializer.cs
│   │   │   ├── DataSet.cs
│   │   │   ├── DataStorage.cs
│   │   │   ├── ImportSettings.cs
│   │   │   ├── ImportSettingsContext.cs
│   │   │   ├── JsonDataInstance.cs
│   │   │   ├── JsonDataSerializer.cs
│   │   │   ├── JsonDataSet.cs
│   │   │   ├── ListDataStorage.cs
│   │   │   ├── ParsableDataInstance.cs
│   │   │   ├── ParsableDataSerializer.cs
│   │   │   ├── ParsableDataSet.cs
│   │   │   ├── ScriptContentLevel.cs
│   │   │   ├── SingletonDataStorage.cs
│   │   │   ├── StreamingAssetsMode.cs
│   │   │   ├── StringDataInstance.cs
│   │   │   ├── StringDataSerializer.cs
│   │   │   ├── StringDataSet.cs
│   │   │   └── UnityVersionJsonConverter.cs
│   │   ├── Logging
│   │   │   ├── CleanFileLogger.cs
│   │   │   ├── ConsoleLogger.cs
│   │   │   ├── FileLogger.cs
│   │   │   ├── FileLoggerBase.cs
│   │   │   ├── ILogger.cs
│   │   │   ├── LogCategory.cs
│   │   │   ├── LogType.cs
│   │   │   └── Logger.cs
│   │   ├── Structure
│   │   │   ├── Assembly
│   │   │   │   ├── Managers
│   │   │   │   │   ├── BaseManager.Resolver.cs
│   │   │   │   │   ├── BaseManager.cs
│   │   │   │   │   ├── IAssemblyManager.cs
│   │   │   │   │   ├── IL2CppManager.cs
│   │   │   │   │   ├── MethodOverrideNameFixer.cs
│   │   │   │   │   ├── ModuleExtensions.cs
│   │   │   │   │   └── MonoManager.cs
│   │   │   │   ├── MonoBehaviourExtensions.cs
│   │   │   │   ├── MonoScriptExtensions.cs
│   │   │   │   ├── ScriptIdentifier.cs
│   │   │   │   ├── ScriptingBackend.cs
│   │   │   │   ├── Serializable
│   │   │   │   │   ├── EndianSpanReaderExtensions.cs
│   │   │   │   │   ├── SerializablePair.cs
│   │   │   │   │   ├── SerializableStructure.cs
│   │   │   │   │   ├── SerializableTypeExtensions.cs
│   │   │   │   │   ├── SerializableValue.cs
│   │   │   │   │   └── UnloadedStructure.cs
│   │   │   │   └── TypeTrees
│   │   │   │       ├── SerializableTreeType.cs
│   │   │   │       └── TypeTreeNodeStruct.cs
│   │   │   ├── GameInitializer.CustomResourceProvider.cs
│   │   │   ├── GameInitializer.EngineResourceInjector.cs
│   │   │   ├── GameInitializer.StructureDependencyProvider.cs
│   │   │   ├── GameInitializer.VersionChanger.cs
│   │   │   ├── GameInitializer.cs
│   │   │   ├── GameStructure.cs
│   │   │   ├── KeyValuePairListExtensions.cs
│   │   │   ├── Platforms
│   │   │   │   ├── AndroidGameStructure.cs
│   │   │   │   ├── LinuxGameStructure.cs
│   │   │   │   ├── MacGameStructure.cs
│   │   │   │   ├── MixedGameStructure.cs
│   │   │   │   ├── PS4GameStructure.cs
│   │   │   │   ├── PlatformChecker.cs
│   │   │   │   ├── PlatformGameStructure.cs
│   │   │   │   ├── SwitchGameStructure.cs
│   │   │   │   ├── WebGLGameStructure.cs
│   │   │   │   ├── WebPlayerGameStructure.cs
│   │   │   │   ├── WiiUGameStructure.cs
│   │   │   │   ├── WindowsGameStructure.cs
│   │   │   │   └── iOSGameStructure.cs
│   │   │   └── ZipExtractor.cs
│   │   ├── Usings.cs
│   │   └── Utils
│   │       └── ExecutingDirectory.cs
│   ├── AssetRipper.Numerics
│   │   ├── AssetRipper.Numerics.csproj
│   │   ├── BoneWeight1.cs
│   │   ├── BoneWeight4.cs
│   │   ├── Color32.cs
│   │   ├── ColorFloat.cs
│   │   ├── DiscontinuousRange.cs
│   │   ├── GeometricMath.cs
│   │   ├── IComparableExtensions.cs
│   │   ├── QuaternionExtensions.cs
│   │   ├── Range.cs
│   │   ├── RectangleFExtensions.cs
│   │   ├── RelativeDistanceMethods.cs
│   │   ├── Transformation.cs
│   │   ├── Usings.cs
│   │   ├── Vector2i.cs
│   │   ├── Vector3Extensions.cs
│   │   ├── Vector3i.cs
│   │   └── VectorExtensions.cs
│   ├── AssetRipper.Numerics.Tests
│   │   ├── AssetRipper.Numerics.Tests.csproj
│   │   ├── BoneWeight4Tests.cs
│   │   ├── Color32Tests.cs
│   │   ├── ColorFloatTests.cs
│   │   ├── DiscontinuousRangeTests.cs
│   │   ├── MathTests.cs
│   │   ├── QuaternionTests.cs
│   │   ├── RangeTests.cs
│   │   ├── RelativeDistanceTests.cs
│   │   ├── TransformationTests.cs
│   │   └── Usings.cs
│   ├── AssetRipper.Processing
│   │   ├── AnimationClips
│   │   │   ├── AnimationClipConverter.CurveData.cs
│   │   │   ├── AnimationClipConverter.cs
│   │   │   ├── CustomCurveResolver.cs
│   │   │   ├── Editor
│   │   │   │   ├── StreamedCurveKey.cs
│   │   │   │   └── StreamedFrame.cs
│   │   │   └── PathChecksumCache.cs
│   │   ├── AnimatorControllers
│   │   │   ├── AnimatorControllerProcessor.cs
│   │   │   ├── AnimatorStateContext.cs
│   │   │   ├── AnimatorStateMachineContext.cs
│   │   │   ├── BidirectionalDictionary.cs
│   │   │   └── VirtualAnimationFactory.cs
│   │   ├── Assemblies
│   │   │   ├── AssemblyManagerExtensions.cs
│   │   │   ├── AttributePolyfillGenerator.cs
│   │   │   ├── CustomAttributeExtensions.cs
│   │   │   ├── EmbeddedAssembly.cs
│   │   │   ├── ForwardingAssemblyGenerator.cs
│   │   │   ├── InternalsVisibileToPublicKeyRemover.cs
│   │   │   ├── MethodStubbingProcessor.cs
│   │   │   ├── MonoExplicitPropertyRepairProcessor.cs
│   │   │   ├── NullRefReturnProcessor.cs
│   │   │   ├── NullableRemovalProcessor.cs
│   │   │   ├── ObfuscationRepairProcessor.cs
│   │   │   ├── RemoveAssemblyKeyFileAttributeProcessor.cs
│   │   │   ├── SafeAssemblyPublicizingProcessor.cs
│   │   │   └── UnmanagedConstraintRecoveryProcessor.cs
│   │   ├── AssetGroup.cs
│   │   ├── AssetRipper.Processing.csproj
│   │   ├── AudioMixers
│   │   │   ├── AudioEffectsDefinitions.cs
│   │   │   ├── AudioMixerProcessor.cs
│   │   │   └── GuidIndexTable.cs
│   │   ├── Configuration
│   │   │   ├── BundledAssetsExportMode.cs
│   │   │   └── ProcessingSettings.cs
│   │   ├── DeletedAssetsInformation.cs
│   │   ├── Editor
│   │   │   ├── EditorFormatConverter.cs
│   │   │   ├── EditorFormatConverterAsync.cs
│   │   │   ├── EditorFormatProcessor.cs
│   │   │   └── OriginalPathHelper.cs
│   │   ├── GameData.cs
│   │   ├── IAssetProcessor.cs
│   │   ├── LightingDataProcessor.cs
│   │   ├── MainAssetProcessor.cs
│   │   ├── Notes.md
│   │   ├── Prefabs
│   │   │   ├── GameObjectHierarchyObject.cs
│   │   │   ├── PrefabHierarchyObject.cs
│   │   │   ├── PrefabProcessor.cs
│   │   │   └── SceneHierarchyObject.cs
│   │   ├── Scenes
│   │   │   ├── SceneDefinitionProcessor.cs
│   │   │   └── SceneHelpers.cs
│   │   ├── ScriptableObject
│   │   │   ├── ScriptableObjectGroup.cs
│   │   │   └── ScriptableObjectProcessor.cs
│   │   ├── Textures
│   │   │   ├── SpriteInformationObject.cs
│   │   │   ├── SpriteProcessor.ObjectFactory.cs
│   │   │   └── SpriteProcessor.cs
│   │   ├── TraversalHelperMethods.cs
│   │   └── Usings.cs
│   ├── AssetRipper.Processing.SourceGenerator
│   │   ├── AssetRipper.Processing.SourceGenerator.csproj
│   │   ├── PolyfillGenerator.cs
│   │   └── Polyfills.cs
│   ├── AssetRipper.SerializationLogic
│   │   ├── AsmUtils.cs
│   │   ├── AssetRipper.SerializationLogic.csproj
│   │   ├── EngineTypePredicates.cs
│   │   ├── Extensions
│   │   │   ├── FieldDefinitionExtensions.cs
│   │   │   ├── HasCustomAttributesExtensions.cs
│   │   │   ├── MethodDefinitionExtensions.cs
│   │   │   ├── ResolutionExtensions.cs
│   │   │   ├── TypeDefinitionExtensions.cs
│   │   │   └── TypeDescriptorExtensions.cs
│   │   ├── FieldSerializer.Logic.cs
│   │   ├── FieldSerializer.cs
│   │   ├── MonoType.cs
│   │   ├── MonoUtils.cs
│   │   ├── Notes.md
│   │   ├── PrimitiveType.cs
│   │   ├── ResolutionException.cs
│   │   ├── SerializablePointerType.cs
│   │   ├── SerializablePrimitiveType.cs
│   │   ├── SerializableType.cs
│   │   └── Usings.cs
│   ├── AssetRipper.SerializationLogic.Tests
│   │   ├── AssetRipper.SerializationLogic.Tests.csproj
│   │   ├── CyclicalReferenceTests.cs
│   │   ├── EmptySerializableClass.cs
│   │   ├── FieldSerializationTests.cs
│   │   ├── ReferenceAssemblies.cs
│   │   ├── ReferenceAssembliesTests.cs
│   │   ├── SerializableClassGenerator.cs
│   │   ├── SerializableTypes.cs
│   │   └── Usings.cs
│   ├── AssetRipper.SourceGenerated.Extensions
│   │   ├── AABBExtensions.cs
│   │   ├── AnimationClipExtensions.cs
│   │   ├── AnimationCurveExtensions.cs
│   │   ├── AnimationExtensions.cs
│   │   ├── AnimatorControllerExtensions.cs
│   │   ├── AnimatorControllerParameterExtensions.cs
│   │   ├── AnimatorExtensions.cs
│   │   ├── AnimatorOverrideControllerExtensions.cs
│   │   ├── AnimatorStateMachineExtensions.cs
│   │   ├── ArrayExtensions.cs
│   │   ├── AssetBundleExtensions.cs
│   │   ├── AssetCreator.cs
│   │   ├── AssetRipper.SourceGenerated.Extensions.csproj
│   │   ├── AudioClipExtensions.cs
│   │   ├── AudioCompressionFormatExtentions.cs
│   │   ├── AvatarConstantExtensions.cs
│   │   ├── AvatarExtensions.cs
│   │   ├── BlendShapeDataExtensions.cs
│   │   ├── BlendTreeExtensions.cs
│   │   ├── BlendTreeNodeConstantExtensions.cs
│   │   ├── BoneWeights4Extensions.cs
│   │   ├── Bounds.cs
│   │   ├── BufferBindingExtensions.cs
│   │   ├── BuildTargetGroup.cs
│   │   ├── BuiltinShaderSettingsExtensions.cs
│   │   ├── ByteArrayExtensions.cs
│   │   ├── CameraExtensions.cs
│   │   ├── ChannelInfoExtensions.cs
│   │   ├── ClassIDTypeExtention.cs
│   │   ├── ClipExtensions.cs
│   │   ├── CollisionModuleExtensions.cs
│   │   ├── ColorRGBA32Extensions.cs
│   │   ├── ColorRGBAfExtensions.cs
│   │   ├── CompressedAnimationCurveExtensions.cs
│   │   ├── CompressedMeshExtensions.cs
│   │   ├── ConstantClipExtensions.cs
│   │   ├── ControllerConstantExtensions.cs
│   │   ├── CrashReportingSettingsExtensions.cs
│   │   ├── CubemapArrayExtensions.cs
│   │   ├── CustomDataModuleExtensions.cs
│   │   ├── DenseClipExtensions.cs
│   │   ├── EditorSettingsExtensions.cs
│   │   ├── EmissionModuleExtensions.cs
│   │   ├── EndianWriterExtensions.cs
│   │   ├── EnlightenSceneMappingExtensions.cs
│   │   ├── EnumerableExtensions.cs
│   │   ├── Enums
│   │   │   ├── AnimationClip
│   │   │   │   ├── Bones
│   │   │   │   │   ├── ArmType.cs
│   │   │   │   │   ├── BoneType.cs
│   │   │   │   │   ├── FingerDoFType.cs
│   │   │   │   │   ├── FingerType.cs
│   │   │   │   │   ├── LimbType.cs
│   │   │   │   │   ├── MuscleType.cs
│   │   │   │   │   └── TDoFBoneType.cs
│   │   │   │   ├── GenericBinding
│   │   │   │   │   ├── BindingCustomType.cs
│   │   │   │   │   └── TransformType.cs
│   │   │   │   └── HumanoidMuscleType.cs
│   │   │   ├── Keyframe
│   │   │   │   └── TangentMode
│   │   │   │       ├── TangentMode.cs
│   │   │   │       ├── TangentMode2.cs
│   │   │   │       └── TangentMode5.cs
│   │   │   └── Shader
│   │   │       ├── GPUPlatform.cs
│   │   │       ├── GpuProgramType
│   │   │       │   ├── ShaderGpuProgramType.cs
│   │   │       │   ├── ShaderGpuProgramType53.cs
│   │   │       │   └── ShaderGpuProgramType55.cs
│   │   │       ├── SerializedShader
│   │   │       │   ├── BlendMode.cs
│   │   │       │   ├── BlendOp.cs
│   │   │       │   ├── ColorWriteMask.cs
│   │   │       │   ├── CullMode.cs
│   │   │       │   ├── FogMode.cs
│   │   │       │   ├── SerializedPassType.cs
│   │   │       │   ├── SerializedPropertyFlag.cs
│   │   │       │   ├── SerializedPropertyType.cs
│   │   │       │   ├── StencilComp.cs
│   │   │       │   ├── StencilOp.cs
│   │   │       │   ├── StencilType.cs
│   │   │       │   ├── ZClip.cs
│   │   │       │   ├── ZTest.cs
│   │   │       │   └── ZWrite.cs
│   │   │       ├── ShaderChannel
│   │   │       │   ├── ShaderChannel.cs
│   │   │       │   ├── ShaderChannel2018.cs
│   │   │       │   ├── ShaderChannel4.cs
│   │   │       │   └── ShaderChannel5.cs
│   │   │       ├── ShaderParamType.cs
│   │   │       ├── ShaderType.cs
│   │   │       ├── VertexComponent.cs
│   │   │       └── VertexFormat
│   │   │           ├── VertexChannelFormat.cs
│   │   │           ├── VertexFormat.cs
│   │   │           ├── VertexFormat2017.cs
│   │   │           └── VertexFormat2019.cs
│   │   ├── ExternalForcesModuleExtensions.cs
│   │   ├── ExternalVersionControlExtensions.cs
│   │   ├── FlareExtensions.cs
│   │   ├── FloatCurveExtensions.cs
│   │   ├── FloatExtensions.cs
│   │   ├── FmodSoundTypeExtensions.cs
│   │   ├── FontExtensions.cs
│   │   ├── GISettingsExtensions.cs
│   │   ├── GLTextureSettingsExtensions.cs
│   │   ├── GUIStyleExtensions.cs
│   │   ├── GameObjectExtensions.cs
│   │   ├── GenericBindingExtensions.cs
│   │   ├── GraphicsFormatExtensions.cs
│   │   ├── GraphicsSettingsExtensions.cs
│   │   ├── GuidExtensions.cs
│   │   ├── HashSetExtensions.cs
│   │   ├── HeightmapExtensions.cs
│   │   ├── IDictionaryExtensions.cs
│   │   ├── IEnumerableExtensions.cs
│   │   ├── IHVImageFormatImporterExtensions.cs
│   │   ├── IReadOnlyListExtensions.cs
│   │   ├── ImageTextureExtensions.cs
│   │   ├── IndexFormatExtensions.cs
│   │   ├── InheritVelocityModuleExtensions.cs
│   │   ├── InputAxisExtensions.cs
│   │   ├── KeyframeExtensions.Float.cs
│   │   ├── KeyframeExtensions.Quaternionf.cs
│   │   ├── KeyframeExtensions.Vector3f.cs
│   │   ├── LODExtensions.cs
│   │   ├── LODGroupExtensions.cs
│   │   ├── LayerConstantExtensions.cs
│   │   ├── LightExtensions.cs
│   │   ├── LightmapBakeModeExtensions.cs
│   │   ├── LightmapEditorSettingsExtensions.cs
│   │   ├── LightmapSettingsExtensions.cs
│   │   ├── LightsModuleExtensions.cs
│   │   ├── LineParametersExtensions.cs
│   │   ├── MaterialExtensions.cs
│   │   ├── Matrix4x4fExtensions.cs
│   │   ├── MatrixParameterExtensions.cs
│   │   ├── MeshBlendShapeChannelExtensions.cs
│   │   ├── MeshBlendShapeExtensions.cs
│   │   ├── MeshColliderExtensions.cs
│   │   ├── MeshData.cs
│   │   ├── MeshExtensions.cs
│   │   ├── MeshFilterExtensions.cs
│   │   ├── MeshHelper.cs
│   │   ├── MeshOutlineGenerator.cs
│   │   ├── MinMaxCurveExtensions.cs
│   │   ├── MinMaxGradientExtensions.cs
│   │   ├── MonoBehaviourExtensions.cs
│   │   ├── MonoScriptExtensions.cs
│   │   ├── MultiModeParameterExtensions.cs
│   │   ├── MuscleClipInfoExtensions.cs
│   │   ├── NavMeshAgentExtensions.cs
│   │   ├── NavMeshBuildSettingsExtensions.cs
│   │   ├── NavMeshObstacleExtensions.cs
│   │   ├── NavMeshSettingsExtensions.cs
│   │   ├── NoiseModuleExtensions.cs
│   │   ├── PPtrCurveExtensions.cs
│   │   ├── PPtrExtensions.cs
│   │   ├── PackedFloatVectorExtensions.cs
│   │   ├── PackedIntVectorExtensions.cs
│   │   ├── PackedQuatVectorExtensions.cs
│   │   ├── PackingSettingsExtensions.cs
│   │   ├── ParticleSystemEmissionBurstExtensions.cs
│   │   ├── ParticleSystemExtensions.cs
│   │   ├── ParticleSystemForceFieldParametersExtensions.cs
│   │   ├── ParticleSystemRendererExtensions.cs
│   │   ├── Physics2DSettingsExtensions.cs
│   │   ├── PhysicsJobOptions2DExtensions.cs
│   │   ├── PhysicsManagerExtensions.cs
│   │   ├── PlatformShaderDefinesExtensions.cs
│   │   ├── PluginImporterExtensions.cs
│   │   ├── PrefabInstanceExtensions.cs
│   │   ├── PropertyNameExtensions.cs
│   │   ├── QualitySettingExtensions.cs
│   │   ├── QualitySettingsExtensions.cs
│   │   ├── QuaternionCurveExtensions.cs
│   │   ├── QuaternionfExtensions.cs
│   │   ├── RectfExtensions.cs
│   │   ├── RendererExtensions.cs
│   │   ├── Rigidbody2DExtensions.cs
│   │   ├── RigidbodyExtensions.cs
│   │   ├── RuntimeAnimatorControllerExtensions.cs
│   │   ├── SerializedPassExtensions.cs
│   │   ├── SerializedPlayerSubProgramExtensions.cs
│   │   ├── SerializedProgramExtensions.cs
│   │   ├── SerializedPropertyExtensions.cs
│   │   ├── SerializedShaderFloatValueExtensions.cs
│   │   ├── SerializedShaderRTBlendStateExtensions.cs
│   │   ├── SerializedShaderStateExtensions.cs
│   │   ├── SerializedShaderVectorValueExtensions.cs
│   │   ├── SerializedStencilOpExtensions.cs
│   │   ├── SerializedSubProgramExtensions.cs
│   │   ├── ShaderBindChannelExtensions.cs
│   │   ├── ShaderErrorExtensions.cs
│   │   ├── ShaderExtensions.cs
│   │   ├── ShadowSettingsExtensions.cs
│   │   ├── ShapeModuleExtensions.cs
│   │   ├── SpriteAtlasDataExtensions.cs
│   │   ├── SpriteAtlasExtensions.cs
│   │   ├── SpriteBoneExtensions.cs
│   │   ├── SpriteExtensions.cs
│   │   ├── SpriteMetaDataExtensions.cs
│   │   ├── SpriteRenderDataExtensions.cs
│   │   ├── SpriteRendererExtensions.cs
│   │   ├── SpriteSheetMetaDataExtensions.cs
│   │   ├── StateBehavioursPairExtensions.cs
│   │   ├── StateConstantExtensions.cs
│   │   ├── StateMachineConstantExtensions.cs
│   │   ├── StateMotionPairExtensions.cs
│   │   ├── StaticBatchInfoExtensions.cs
│   │   ├── StreamInfoExtensions.cs
│   │   ├── StreamedClipExtensions.cs
│   │   ├── StreamedResourceExtensions.cs
│   │   ├── StreamingInfoExtensions.cs
│   │   ├── SubEmitterDataExtensions.cs
│   │   ├── SubMeshData.cs
│   │   ├── SubMeshExtensions.cs
│   │   ├── SwitchSwizzle.cs
│   │   ├── TagManagerConstants.cs
│   │   ├── TagManagerExtensions.cs
│   │   ├── TerrainDataExtensions.cs
│   │   ├── TerrainExtensions.cs
│   │   ├── TextWriterExtensions.cs
│   │   ├── Texture2DArrayExtensions.cs
│   │   ├── Texture2DExtensions.cs
│   │   ├── Texture3DExtensions.cs
│   │   ├── TextureFormatExtensions.cs
│   │   ├── TextureImporterExtensions.cs
│   │   ├── TextureParameterExtensions.cs
│   │   ├── TextureSettingsExtensions.cs
│   │   ├── TextureUsageModeExtensions.cs
│   │   ├── TierGraphicsSettingsEditorExtensions.cs
│   │   ├── TierSettingsExtensions.cs
│   │   ├── TrailModuleExtensions.cs
│   │   ├── TransformExtensions.cs
│   │   ├── TransitionConstantExtensions.cs
│   │   ├── TriangleEnumerable.cs
│   │   ├── TriggerModuleExtensions.cs
│   │   ├── UAVParameterExtensions.cs
│   │   ├── UVInfo.cs
│   │   ├── UVModuleExtensions.cs
│   │   ├── UnityConnectSettingsExtensions.cs
│   │   ├── UnityObjectBaseExtensions.cs
│   │   ├── UnityPropertySheetExtensions.cs
│   │   ├── UnityVersionExtensions.cs
│   │   ├── Usings.cs
│   │   ├── ValueConstantExtensions.cs
│   │   ├── Vector2fExtensions.cs
│   │   ├── Vector3CurveExtensions.cs
│   │   ├── Vector3fExtensions.cs
│   │   ├── Vector4fExtensions.cs
│   │   ├── VectorParameterExtensions.cs
│   │   ├── VertexDataBlob.cs
│   │   ├── VertexDataExtensions.cs
│   │   └── VideoClipExtensions.cs
│   ├── AssetRipper.SourceGenerated.Extensions.SourceGenerator
│   │   ├── AssetRipper.SourceGenerated.Extensions.SourceGenerator.csproj
│   │   ├── ClassIDType.cs
│   │   └── CreateMethodGenerator.cs
│   ├── AssetRipper.Tests
│   │   ├── AssetRipper.Tests.csproj
│   │   ├── CompressedMeshTests.cs
│   │   ├── DictionaryTests.cs
│   │   ├── ExportIdHandlerTests.cs
│   │   ├── ExportTests.cs
│   │   ├── MeshDataExtensions.cs
│   │   ├── MeshDataTests.cs
│   │   ├── PackedBitVectorTests
│   │   │   ├── FloatVectorTests.cs
│   │   │   ├── IntVectorTests.cs
│   │   │   └── QuatVectorTests.cs
│   │   ├── PathIDCalculationTests.cs
│   │   ├── ScriptHashingTests.cs
│   │   ├── SerializableStructureTests.cs
│   │   ├── StrippedAssetTests.cs
│   │   ├── TextureImporterTests.cs
│   │   ├── TpkTests.cs
│   │   ├── Traversal
│   │   │   ├── ColorRGB.cs
│   │   │   ├── ComponentListObject.cs
│   │   │   ├── CustomInjectedObjectBase.PrimitiveHelper.cs
│   │   │   ├── CustomInjectedObjectBase.Walk.cs
│   │   │   ├── CustomInjectedObjectBase.WalkType.cs
│   │   │   ├── CustomInjectedObjectBase.cs
│   │   │   ├── DefaultJsonWalkerTests.cs
│   │   │   ├── DefaultYamlWalkerTests.cs
│   │   │   ├── DictionaryObject.cs
│   │   │   ├── EditorFieldAttribute.cs
│   │   │   ├── GuidDictionaryObject.cs
│   │   │   ├── ListObject.cs
│   │   │   ├── PairListObject.cs
│   │   │   ├── PairObject.cs
│   │   │   ├── ParentObject.cs
│   │   │   ├── PrimitiveListObject.cs
│   │   │   ├── ReleaseFieldAttribute.cs
│   │   │   ├── SerializedVersionObject.cs
│   │   │   ├── SimpleObject.cs
│   │   │   ├── StaticSquaredDictionaryObject.cs
│   │   │   ├── StringDictionaryObject.cs
│   │   │   ├── SubclassObject.cs
│   │   │   ├── VectorXY.cs
│   │   │   └── YamlWalkerTests.cs
│   │   ├── TypeTreeNodeStructTests.cs
│   │   ├── UVInfoTests.cs
│   │   ├── Usings.cs
│   │   └── VertexDataBlobTests.cs
│   ├── AssetRipper.Tools.CabMapGenerator
│   │   ├── Arguments.cs
│   │   ├── AssetRipper.Tools.CabMapGenerator.csproj
│   │   ├── DictionarySerializerContext.cs
│   │   └── Program.cs
│   ├── AssetRipper.Tools.DependenceGrapher
│   │   ├── Arguments.cs
│   │   ├── AssetRipper.Tools.DependenceGrapher.csproj
│   │   ├── DictionarySerializerContext.cs
│   │   ├── Filters
│   │   │   ├── ClassIDFilter.cs
│   │   │   ├── ClassNameFilter.cs
│   │   │   ├── IAssetFilter.cs
│   │   │   ├── NameFilter.cs
│   │   │   └── PathIDFilter.cs
│   │   ├── ObjectExtensions.cs
│   │   └── Program.cs
│   ├── AssetRipper.Tools.FileExtractor
│   │   ├── AssetRipper.Tools.FileExtractor.csproj
│   │   ├── Program.cs
│   │   └── README.md
│   ├── AssetRipper.Tools.JsonSerializer
│   │   ├── AssetRipper.Tools.JsonSerializer.csproj
│   │   ├── JsonAsset.cs
│   │   ├── JsonAssetFactory.cs
│   │   ├── JsonObjectSerializerContext.cs
│   │   ├── PrimitiveType.cs
│   │   ├── Program.cs
│   │   ├── SerializableArray.cs
│   │   ├── SerializableEntry.cs
│   │   ├── SerializablePair.cs
│   │   ├── SerializablePrimitive.cs
│   │   ├── SerializableType.cs
│   │   └── SerializableTypelessData.cs
│   ├── AssetRipper.Tools.MonoBehaviourTester
│   │   ├── AssetRipper.Tools.MonoBehaviourTester.csproj
│   │   └── Program.cs
│   ├── AssetRipper.Tools.RawTextureExtractor
│   │   ├── AssetRipper.Tools.RawTextureExtractor.csproj
│   │   └── Program.cs
│   ├── AssetRipper.Tools.SystemTester
│   │   ├── AssetRipper.Tools.SystemTester.csproj
│   │   ├── Program.cs
│   │   └── README.md
│   ├── AssetRipper.Tools.TypeTreeExtractor
│   │   ├── AssetRipper.Tools.TypeTreeExtractor.csproj
│   │   └── Program.cs
│   ├── AssetRipper.Web
│   │   ├── AssetRipper.Web.csproj
│   │   ├── Content
│   │   │   ├── HtmlPage.cs
│   │   │   ├── JavaScript.cs
│   │   │   ├── StyleSheet.cs
│   │   │   └── WebContent.cs
│   │   └── Extensions
│   │       ├── HttpResponseExtensions.cs
│   │       └── QueryCollectionExtensions.cs
│   ├── AssetRipper.Yaml
│   │   ├── AssetRipper.Yaml.csproj
│   │   ├── Emitter.cs
│   │   ├── Extensions
│   │   │   ├── ReverseHexString.cs
│   │   │   ├── YamlArrayExtensions.cs
│   │   │   └── YamlSerializedVersionExtensions.cs
│   │   ├── MappingStyle.cs
│   │   ├── MetaType.cs
│   │   ├── ScalarStyle.cs
│   │   ├── ScalarType.cs
│   │   ├── SequenceStyle.cs
│   │   ├── YAMLDocument.cs
│   │   ├── YAMLMappingNode.cs
│   │   ├── YAMLNode.cs
│   │   ├── YAMLNodeType.cs
│   │   ├── YAMLSequenceNode.cs
│   │   ├── YAMLTag.cs
│   │   ├── YAMLWriter.cs
│   │   ├── YamlEscaping.cs
│   │   ├── YamlScalarNode.Base.cs
│   │   ├── YamlScalarNode.BoolListNode.cs
│   │   ├── YamlScalarNode.BooleanNode.cs
│   │   ├── YamlScalarNode.CharListNode.cs
│   │   ├── YamlScalarNode.Creation.cs
│   │   ├── YamlScalarNode.FloatingPointHexNode.cs
│   │   ├── YamlScalarNode.NumericListNode.cs
│   │   ├── YamlScalarNode.NumericNode.cs
│   │   └── YamlScalarNode.StringNode.cs
│   ├── AssetRipper.Yaml.Tests
│   │   ├── AssetRipper.Yaml.Tests.csproj
│   │   ├── FlowMappingTests.cs
│   │   ├── HexTests.cs
│   │   └── YamlScalarNodeTests.cs
│   ├── Directory.Build.props
│   ├── Licenses
│   │   ├── AsmResolver.md
│   │   ├── AssetStudio.md
│   │   ├── Cpp2IL.md
│   │   ├── Crunch.md
│   │   ├── Fmod5Sharp.md
│   │   ├── ILSpy.md
│   │   ├── Lz4.md
│   │   ├── Moq.md
│   │   ├── NAudio.md
│   │   ├── NAudioVorbis.md
│   │   ├── NUnit.md
│   │   ├── NVorbis.md
│   │   ├── SharpCompress.md
│   │   ├── SharpGLTF.md
│   │   ├── Smolv.md
│   │   ├── SourceGenerator.Foundations.md
│   │   ├── SpirV.md
│   │   ├── Texture2DDecoder.md
│   │   ├── darkfx.md
│   │   ├── oqo0.SwaggerThemes.md
│   │   ├── uTinyRipper.md
│   │   └── uTinyRipperExporter.md
│   ├── Smolv
│   │   ├── OpData.cs
│   │   ├── Original-Cpp-Notes.md
│   │   ├── README.md
│   │   ├── Smolv.csproj
│   │   ├── SmolvDecoder.cs
│   │   └── SpvOp.cs
│   ├── SpirV
│   │   ├── Disassembler.cs
│   │   ├── EnumExtensions.cs
│   │   ├── Instruction.cs
│   │   ├── Module.cs
│   │   ├── OperandType.cs
│   │   ├── ParsedInstruction.cs
│   │   ├── README.md
│   │   ├── Reader.cs
│   │   ├── SpirV.Core.Grammar.cs
│   │   ├── SpirV.Meta.cs
│   │   ├── SpirV.csproj
│   │   └── Types.cs
│   ├── UnityEngine
│   │   ├── Behaviour.cs
│   │   ├── Bounds.cs
│   │   ├── BoundsInt.cs
│   │   ├── Color.cs
│   │   ├── Color32.cs
│   │   ├── Component.cs
│   │   ├── GameObject.cs
│   │   ├── LayerMask.cs
│   │   ├── Matrix4x4.cs
│   │   ├── MonoBehaviour.cs
│   │   ├── Object.cs
│   │   ├── Quaternion.cs
│   │   ├── README.md
│   │   ├── Rect.cs
│   │   ├── RectInt.cs
│   │   ├── Rendering
│   │   │   └── SphericalHarmonicsL2.cs
│   │   ├── SerializeField.cs
│   │   ├── SerializeReference.cs
│   │   ├── UnityEngine.csproj
│   │   ├── Vector2.cs
│   │   ├── Vector2Int.cs
│   │   ├── Vector3.cs
│   │   ├── Vector3Int.cs
│   │   └── Vector4.cs
│   └── generate.bat
├── docs
│   ├── api
│   │   └── index.md
│   ├── articles
│   │   ├── CommonIssues.md
│   │   ├── Credits.md
│   │   ├── Downloads.md
│   │   ├── PremiumFeatures.md
│   │   ├── Requirements.md
│   │   ├── RoadMap.md
│   │   ├── RunningOnMac.md
│   │   ├── images
│   │   │   └── RunningOnMac
│   │   │       ├── 001.png
│   │   │       ├── 002.png
│   │   │       ├── 003.png
│   │   │       ├── 004.png
│   │   │       ├── 005.png
│   │   │       ├── 006.png
│   │   │       ├── 007.png
│   │   │       ├── 008.png
│   │   │       ├── 009.png
│   │   │       ├── 010.png
│   │   │       ├── 011.png
│   │   │       ├── 012.png
│   │   │       ├── 013.png
│   │   │       ├── 014.png
│   │   │       ├── 015.png
│   │   │       ├── 016.png
│   │   │       ├── 017.png
│   │   │       ├── 018.png
│   │   │       └── 019.png
│   │   ├── intro.md
│   │   └── toc.yml
│   ├── docfx.json
│   ├── index.md
│   ├── templates
│   │   └── darkfx
│   │       ├── partials
│   │       │   ├── affix.tmpl.partial
│   │       │   ├── footer.tmpl.partial
│   │       │   └── head.tmpl.partial
│   │       └── styles
│   │           ├── main.css
│   │           └── toggle-theme.js
│   └── toc.yml
└── nuget.config

```

`AssetRipper.slnx`:

```slnx
<Solution>
  <Folder Name="/Solution Items/">
    <File Path=".github/CONTRIBUTING.md" />
    <File Path=".gitignore" />
    <File Path="LICENSE.md" />
    <File Path="nuget.config" />
    <File Path="README.md" />
    <File Path="Source/.editorconfig" />
    <File Path="Source/Directory.Build.props" />
    <File Path="Source/generate.bat" />
  </Folder>
  <Folder Name="/Solution Items/Docs/">
    <File Path="docs/articles/CommonIssues.md" />
    <File Path="docs/articles/Credits.md" />
    <File Path="docs/articles/Downloads.md" />
    <File Path="docs/articles/PremiumFeatures.md" />
    <File Path="docs/articles/Requirements.md" />
    <File Path="docs/articles/RoadMap.md" />
    <File Path="docs/articles/RunningOnMac.md" />
    <File Path="docs/articles/toc.yml" />
    <File Path="docs/docfx.json" />
    <File Path="docs/index.md" />
  </Folder>
  <Folder Name="/Solution Items/IssueTemplates/">
    <File Path=".github/ISSUE_TEMPLATE/bug_report.yaml" />
    <File Path=".github/ISSUE_TEMPLATE/config.yaml" />
    <File Path=".github/ISSUE_TEMPLATE/enhancement.yaml" />
    <File Path=".github/ISSUE_TEMPLATE/other.yaml" />
    <File Path=".github/ISSUE_TEMPLATE/question.yaml" />
  </Folder>
  <Folder Name="/Solution Items/Licenses/">
    <File Path="Source/Licenses/AsmResolver.md" />
    <File Path="Source/Licenses/AssetStudio.md" />
    <File Path="Source/Licenses/Cpp2IL.md" />
    <File Path="Source/Licenses/Crunch.md" />
    <File Path="Source/Licenses/darkfx.md" />
    <File Path="Source/Licenses/Fmod5Sharp.md" />
    <File Path="Source/Licenses/ILSpy.md" />
    <File Path="Source/Licenses/Lz4.md" />
    <File Path="Source/Licenses/NAudio.md" />
    <File Path="Source/Licenses/NAudioVorbis.md" />
    <File Path="Source/Licenses/NVorbis.md" />
    <File Path="Source/Licenses/SharpCompress.md" />
    <File Path="Source/Licenses/SharpGLTF.md" />
    <File Path="Source/Licenses/SharpZipLib.md" />
    <File Path="Source/Licenses/Smolv.md" />
    <File Path="Source/Licenses/SpirV.md" />
    <File Path="Source/Licenses/uTinyRipper.md" />
    <File Path="Source/Licenses/uTinyRipperExporter.md" />
  </Folder>
  <Folder Name="/Solution Items/Localizations/">
    <File Path="Localizations/en_US.json" />
    <File Path="Localizations/LICENSE" />
    <File Path="Localizations/README.md" />
  </Folder>
  <Folder Name="/Solution Items/Workflows/">
    <File Path=".github/dependabot.yml" />
    <File Path=".github/workflows/analysis.yml" />
    <File Path=".github/workflows/cla.yml" />
    <File Path=".github/workflows/docfx_build.yml" />
    <File Path=".github/workflows/greetings.yml" />
    <File Path=".github/workflows/publish.yml" />
    <File Path=".github/workflows/test.yml" />
  </Folder>
  <Project Path="Source/AssetRipper.AssemblyDumper.Downloader/AssetRipper.AssemblyDumper.Downloader.csproj" />
  <Project Path="Source/AssetRipper.AssemblyDumper.NativeEnumExtractor/AssetRipper.AssemblyDumper.NativeEnumExtractor.csproj" />
  <Project Path="Source/AssetRipper.AssemblyDumper.NuGetFixer/AssetRipper.AssemblyDumper.NuGetFixer.csproj" />
  <Project Path="Source/AssetRipper.AssemblyDumper.Recompiler/AssetRipper.AssemblyDumper.Recompiler.csproj" />
  <Project Path="Source/AssetRipper.AssemblyDumper.Tests/AssetRipper.AssemblyDumper.Tests.csproj" />
  <Project Path="Source/AssetRipper.AssemblyDumper.Utils/AssetRipper.AssemblyDumper.Utils.csproj" />
  <Project Path="Source/AssetRipper.AssemblyDumper/AssetRipper.AssemblyDumper.csproj" />
  <Project Path="Source/AssetRipper.Assets.Tests/AssetRipper.Assets.Tests.csproj" />
  <Project Path="Source/AssetRipper.Assets/AssetRipper.Assets.csproj" />
  <Project Path="Source/AssetRipper.DocExtraction.ConsoleApp/AssetRipper.DocExtraction.ConsoleApp.csproj" />
  <Project Path="Source/AssetRipper.DocExtraction/AssetRipper.DocExtraction.csproj" />
  <Project Path="Source/AssetRipper.Export.Modules.Audio/AssetRipper.Export.Modules.Audio.csproj" />
  <Project Path="Source/AssetRipper.Export.Modules.Models/AssetRipper.Export.Modules.Models.csproj" />
  <Project Path="Source/AssetRipper.Export.Modules.Textures/AssetRipper.Export.Modules.Textures.csproj" />
  <Project Path="Source/AssetRipper.Export.PrimaryContent/AssetRipper.Export.PrimaryContent.csproj" />
  <Project Path="Source/AssetRipper.Export.UnityProjects/AssetRipper.Export.UnityProjects.csproj" />
  <Project Path="Source/AssetRipper.Export/AssetRipper.Export.csproj" />
  <Project Path="Source/AssetRipper.GUI.Free/AssetRipper.GUI.Free.csproj" />
  <Project Path="Source/AssetRipper.GUI.Licensing.SourceGenerator/AssetRipper.GUI.Licensing.SourceGenerator.csproj" />
  <Project Path="Source/AssetRipper.GUI.Licensing/AssetRipper.GUI.Licensing.csproj" />
  <Project Path="Source/AssetRipper.GUI.Localizations.SourceGenerator/AssetRipper.GUI.Localizations.SourceGenerator.csproj" />
  <Project Path="Source/AssetRipper.GUI.Localizations/AssetRipper.GUI.Localizations.csproj" />
  <Project Path="Source/AssetRipper.GUI.SourceGenerator/AssetRipper.GUI.SourceGenerator.csproj" />
  <Project Path="Source/AssetRipper.GUI.Web.Tests/AssetRipper.GUI.Web.Tests.csproj" />
  <Project Path="Source/AssetRipper.GUI.Web/AssetRipper.GUI.Web.csproj" />
  <Project Path="Source/AssetRipper.Import/AssetRipper.Import.csproj" />
  <Project Path="Source/AssetRipper.IO.Files.SourceGenerator/AssetRipper.IO.Files.SourceGenerator.csproj" />
  <Project Path="Source/AssetRipper.IO.Files.Tests/AssetRipper.IO.Files.Tests.csproj" />
  <Project Path="Source/AssetRipper.IO.Files/AssetRipper.IO.Files.csproj" />
  <Project Path="Source/AssetRipper.Numerics.Tests/AssetRipper.Numerics.Tests.csproj" />
  <Project Path="Source/AssetRipper.Numerics/AssetRipper.Numerics.csproj" />
  <Project Path="Source/AssetRipper.Processing.SourceGenerator/AssetRipper.Processing.SourceGenerator.csproj" />
  <Project Path="Source/AssetRipper.Processing/AssetRipper.Processing.csproj" />
  <Project Path="Source/AssetRipper.SerializationLogic.Tests/AssetRipper.SerializationLogic.Tests.csproj" />
  <Project Path="Source/AssetRipper.SerializationLogic/AssetRipper.SerializationLogic.csproj" />
  <Project Path="Source/AssetRipper.SourceGenerated.Extensions.SourceGenerator/AssetRipper.SourceGenerated.Extensions.SourceGenerator.csproj" />
  <Project Path="Source/AssetRipper.SourceGenerated.Extensions/AssetRipper.SourceGenerated.Extensions.csproj" />
  <Project Path="Source/AssetRipper.Tests/AssetRipper.Tests.csproj" />
  <Project Path="Source/AssetRipper.Tools.CabMapGenerator/AssetRipper.Tools.CabMapGenerator.csproj" />
  <Project Path="Source/AssetRipper.Tools.DependenceGrapher/AssetRipper.Tools.DependenceGrapher.csproj" />
  <Project Path="Source/AssetRipper.Tools.FileExtractor/AssetRipper.Tools.FileExtractor.csproj" />
  <Project Path="Source/AssetRipper.Tools.JsonSerializer/AssetRipper.Tools.JsonSerializer.csproj" />
  <Project Path="Source/AssetRipper.Tools.MonoBehaviourTester/AssetRipper.Tools.MonoBehaviourTester.csproj" />
  <Project Path="Source/AssetRipper.Tools.RawTextureExtractor/AssetRipper.Tools.RawTextureExtractor.csproj" />
  <Project Path="Source/AssetRipper.Tools.SystemTester/AssetRipper.Tools.SystemTester.csproj" />
  <Project Path="Source/AssetRipper.Tools.TypeTreeExtractor/AssetRipper.Tools.TypeTreeExtractor.csproj" />
  <Project Path="Source/AssetRipper.Web/AssetRipper.Web.csproj" />
  <Project Path="Source/AssetRipper.Yaml.Tests/AssetRipper.Yaml.Tests.csproj" />
  <Project Path="Source/AssetRipper.Yaml/AssetRipper.Yaml.csproj" />
  <Project Path="Source/Smolv/Smolv.csproj" />
  <Project Path="Source/SpirV/SpirV.csproj" />
  <Project Path="Source/UnityEngine/UnityEngine.csproj" />
</Solution>

```

`LICENSE.md`:

```md
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
```

`Localizations/LICENSE`:

```
MIT License

Copyright (c) 2023 ds5678

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Localizations/README.md`:

```md
# Localizations

## How to submit translations

We have a translation platform for those of you who speak another language to work on translating the GUI into your native language. You can get started at https://weblate.samboy.dev/engage/assetripper/.

You'll need to sign up to start translating to a new language, or you can suggest translations for an existing language without an account (but someone with an account will have to manually verify your suggestions). This will send an email to the address you provide. Be sure check your spam folder, as Gmail can sometimes put the emails there.

## Licensing

Unlike the rest of AssetRipper, localizations are MIT-licensed for ease of contributing.

```

`Localizations/ar.json`:

```json
{
    "all": "الكل",
    "appreciation_message": "شكرًا لك على دعمك لـ AssetRipper!",
    "asset_ripper_free": "AssetRipper المجاني",
    "asset_ripper_premium": "AssetRipper بريميوم",
    "asset_tab_dependencies": "التبعيات",
    "asset_tab_font": "الخط",
    "audio_format_native": "خام",
    "asset_tab_audio_duration_unknown": "<غير معروف>",
    "asset_tab_audio_pause": "يوقف",
    "asset_tab_audio_play": "تشغيل",
    "asset_tab_development": "التطوير",
    "asset_tab_model": "نموذج",
    "audio_clip": "AudioClip",
    "audio_export_title": "تنسيق تصدير الصوت",
    "assembly_name": "اسم الجمعية",
    "asset_bundle_name": "اسم حزمة الأصول",
    "asset_tab_audio": "الصوت",
    "assets": "Assets",
    "asset_tab_image": "صورة",
    "asset_tab_information": "معلومات",
    "asset_tab_text": "نص",
    "asset_tab_hex": "هيكس",
    "audio_format_default": "افتراضي",
    "audio_format_default_description": "تصدير الأصول بنوع المحتوى المضمن داخل FSB. يتم تصدير معظم أنواع الصوت بصيغة WAV، ويتم تصدير بعضها بصيغة OGG.",
    "audio_format_native_description": "صوت FSB خام. لا يمكن استيراده إلى Unity، لذا استخدم هذا فقط إذا كنت مستخدمًا متقدمًا.",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "تصدير كأصل Yaml وملف resS. هذا خيار آمن ويعتبر النسخة الاحتياطية عند حدوث مشاكل.",
    "bundle": "حزمة",
    "bundled_assets_export_direct_export": "تصدير مباشر",
    "bundled_assets_export_direct_export_description": "يتم تصدير الحزمة دون تجميع assets.",
    "bundled_assets_export_group_by_asset_type": "التجميع حسب نوع الـ Asset",
    "bundled_assets_export_group_by_asset_type_description": "تُعامل الحزم بنفس طريقة assets من الملفات الأخرى.",
    "bundled_assets_export_group_by_bundle_name": "التجميع حسب اسم الحزمة",
    "audio_format_force_wav": "تحويل إلى WAV",
    "an_error_occured_during_decompilation": "حدث خطأ أثناء فك التجميع.",
    "asset_tab_video": "فيديو",
    "audio_format_force_wav_description": "تحويل جميع ملفات الصوت إلى ملفات WAV. لا يُنصح بذلك عند الاستيراد إلى Unity، حيث قد يعيد ضغط الملفات مما يؤدي إلى فقدان الجودة.",
    "error_exporting_with_reason": "فشل في تصدير محتوى اللعبة: {0}",
    "lightmap_texture_export_title": "تنسيق تصدير نسيج خريطة الإضاءة",
    "lightmap_texture_format_description": "هذا يؤثر على جميع نسيج خريطة الإضاءة المصدرة.",
    "mesh_format_native": "Yaml",
    "file_id": "معرف الملف",
    "class_id_type_number": "رقم نوع معرف الفئة",
    "class_name": "اسم الفئة",
    "collection": "مجموعة",
    "loading_step_load_assemblies": "جارٍ تحميل التجميعات",
    "failed_files": "الملفات الفاشلة",
    "bundled_assets_export_group_by_bundle_name_description": "يتم تجميع assets المجمعة حسب اسم asset bundle الخاص بها.",
    "bundled_assets_export_title": "وضع تصدير الـ Assets المجمعة",
    "bundles": "حزم",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "csharp_type": "نوع #C",
    "data": "بيانات",
    "default_version": "الإصدار الافتراضي",
    "donation_message": "إذا أعجبك AssetRipper، يرجى التفكير في التبرع:",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_auto_experimental": "تلقائي - تجريبي",
    "c_sharp_langage_version_config_auto_safe": "تلقائي - آمن",
    "c_sharp_langage_version_config_latest": "#C الأحدث",
    "c_sharp_language_version_config_description": "إصدار لغة #C الذي سيتم استخدامه عند فك ترجمة السكربتات.",
    "channels": "قنوات",
    "check_log_for_more_details": "تحقق من السجل لمزيد من التفاصيل",
    "class": "فئة",
    "class_id_type_name": "اسم نوع معرف الفئة",
    "error_importing_with_reason": "فشل في تحميل محتوى اللعبة: {0}",
    "experimental": "تجريبي",
    "export_complete": "اكتمل التصدير!",
    "export_deleting_old_files": "جارٍ مسح الملفات الموجودة...",
    "export_in_progress": "جارٍ تصدير ملفات الـ Asset\n{0}%\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "جارٍ تصدير ملفات الـ Asset\n0.0٪\n؟/؟",
    "export_preparing": "جارٍ التحضير للتصدير...\nقد يستغرق هذا دقيقة.",
    "loading_step_detect_platform": "جارٍ جمع الملفات واكتشاف هيكل اللعبة",
    "loading_step_generate_dummy_dll": "جارٍ إنشاء تجميعات Mono من IL2Cpp",
    "loading_step_initialize_layout": "جارٍ تهيئة تخطيط الـ Asset",
    "c_sharp_langage_version_config_12_0": "C# 12",
    "collections": "مجموعة",
    "commands": "أوامر",
    "config_options": "خيارات التكوين",
    "config_screen_drag_drop_prompt": "يرجى ملاحظة أن بعض تغييرات الإعدادات قد تسبب أخطاء أو تمنعها.\n بمجرد أن تكون جاهزًا، اسحب وأفلت ملف/مجلد لعبتك في هذه النافذة، أو استخدم القائمة في الأعلى يسارًا لفتح شيء يدويًا.",
    "configuration_files": "ملفات التكوين",
    "configuration_files_lists": "قوائم",
    "loading_step_begin_scheme_processing": "بدء معالجة المخطط",
    "loading_step_create_file_collection": "جارٍ إنشاء مجموعة الملفات",
    "configuration_files_singletons": "الوحدات المفردة",
    "count": "العدد",
    "enable_asset_deduplication": "تمكين إزالة تكرار الـ Asset",
    "enable_prefab_outlining": "تمكين تحديد حدود الـ Prefab",
    "enable_static_mesh_separation": "تمكين فصل الشبكة الثابتة",
    "error": "خطأ",
    "licenses": "التراخيص",
    "load": "تحميل",
    "loading_game_content_from": "جارٍ تحميل محتوى اللعبة من {0}\n{1}",
    "loading_step_load_assets_from_file": "جارٍ تحميل الـ Assets من {0}",
    "format": "تنسيق",
    "frequency": "التردد",
    "game_object": "GameObject",
    "create_subfolder": "إنشاء مجلد فرعي",
    "guid": "GUID",
    "height": "الارتفاع",
    "home": "الرئيسية",
    "image_export_title": "تنسيق تصدير الصورة",
    "image_format_description": "هذا يؤثر على جميع الصور المصدرة.",
    "json": "Json",
    "length": "الطول",
    "loading_step_locate_key_functions": "جارٍ مسح الملف الثنائي IL2Cpp للوظائف المكتبية",
    "export_primary_content": "تصدير المحتوى الأساسي",
    "export_unity_project": "تصدير مشروع Unity",
    "c_sharp_langage_version_config_2": "C# 2",
    "filter": "تصفية"
}

```

`Localizations/de.json`:

```json
{
    "asset_tab_audio": "Audio",
    "asset_tab_audio_duration_unknown": "<Unbekannt>",
    "asset_tab_audio_pause": "Pausieren",
    "asset_tab_audio_play": "Abspielen",
    "asset_tab_basic": "Allgemeine Info",
    "asset_tab_image": "Bild",
    "asset_tab_text": "Text",
    "asset_tab_yaml": "Yaml",
    "audio_export_title": "Audio-Exportformat",
    "audio_format_default": "Standard",
    "audio_format_default_description": "Exportiert Assets als den in die FSB-Datei eingebetteten Inhaltstyp. Die meisten Audiotypen werden als WAV exportiert, einige als OGG.",
    "audio_format_force_wav": "In WAV konvertieren",
    "audio_format_force_wav_description": "Konvertiert alle Audiodateien in WAV-Dateien. Nicht empfohlen für den Import in Unity, da die Dateien möglicherweise neu komprimiert werden, was zu Qualitätsverlusten führt.",
    "audio_format_native": "Raw (rohformat)",
    "audio_format_native_description": "„Rohes“ FSB-Audioformat. Kann nicht in Unity importiert werden, sollte also nur von fortgeschrittenen Benutzern verwendet werden.",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "Export als yaml-Asset und resS-Datei. Dies ist eine sichere Option und wird als Backup verwendet, wenn etwas schief geht.",
    "bundled_assets_export_direct_export": "Direkter Export",
    "bundled_assets_export_direct_export_description": "Assets in Bundles werden ohne Gruppierung exportiert.",
    "bundled_assets_export_group_by_asset_type": "Nach Asset-Typ gruppieren",
    "bundled_assets_export_group_by_asset_type_description": "Assets in Bundles werden behandelt, wie Assets aus anderen Dateien.",
    "bundled_assets_export_group_by_bundle_name": "Nach Bundle-Name gruppieren",
    "bundled_assets_export_group_by_bundle_name_description": "Assets in Bundles werden nach dem Namen ihres Asset-Bundles gruppiert.",
    "bundled_assets_export_title": "Bundled Assets Exportmodus",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "Automatisch - Experimentell",
    "c_sharp_langage_version_config_auto_safe": "Automatisch - Sicher",
    "c_sharp_langage_version_config_latest": "Aktuellste C#-Version",
    "c_sharp_language_version_config_description": "Die C#-Sprachversion, die beim Dekompilieren von Skripts verwendet wird.",
    "check_log_for_more_details": "Weitere Details stehen im Protokoll geschrieben",
    "config_options": "Konfigurationsoptionen",
    "config_screen_drag_drop_prompt": "Bitte beachten: einige Einstellungsänderungen können Fehler verursachen oder verhindern.\nZum Fortfahren: Spiel-Datei bzw. -Ordner per Drag-and-Drop in dieses Fenster ziehen oder per Menü oben links manuell öffnen.",
    "enable_prefab_outlining": "Prefab-Gliederung aktivieren",
    "enable_static_mesh_separation": "Aufteilung statischer Meshes aktivieren",
    "error": "Fehler",
    "error_exporting_with_reason": "Export von Spielinhalten fehlgeschlagen: {0}",
    "error_importing_with_reason": "Fehler beim Laden von Spielinhalten: {0}",
    "export_complete": "Export vollständig abgeschlossen!",
    "export_deleting_old_files": "Vorhandene Dateien werden entfernt …",
    "export_in_progress": "Asset-Dateien werden exportiert\n{0} %\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "Asset-Dateien werden exportiert\n0.0 % \n?/?",
    "export_preparing": "Export wird vorbereitet …\nDies könnte ein paar Minuten dauern.",
    "ignore_engine_assets": "Engine Assets ignorieren",
    "image_export_title": "Bild-Exportformat",
    "image_format_description": "Wirkt sich auf alle exportierten Bilder aus",
    "loading_game_content_from": "Spielinhalte werden geladen {0}\n{1}",
    "loading_step_begin_scheme_processing": "Schema-Verarbeitung beginnt",
    "loading_step_create_file_collection": "Dateisammlung wird erstellet",
    "loading_step_detect_platform": "Dateien werden Gesammelt und die Spielstruktur wird identifiziert",
    "loading_step_generate_dummy_dll": "Mono-Assemblies werden aus IL2CPP generiert",
    "loading_step_initialize_layout": "Asset-Layout wird initialisiert",
    "loading_step_load_assemblies": "Assemblies werden geladen",
    "loading_step_load_assets_from_file": "Assets aus {0} werden geladen",
    "loading_step_locate_key_functions": "IL2CPP-Binärdatei wird nach Bibliotheken-Funktionen durchsucht",
    "loading_step_parse_archive": "Archivdatei {0} wird analysiert",
    "loading_step_parse_bundle": "Bundle {0} wird analysiert",
    "loading_step_parse_il2cpp_metadata": "IL2CPP-Metadaten werden analysiert",
    "loading_step_parse_resource": "Ressourcendatei {0} wird analysiert",
    "loading_step_parse_serialized": "Serialisierte Datei {0} wird analysiert",
    "loading_step_parse_web": "Webdatei {0} wird analysiert",
    "loading_step_pre_processing": "Dateien werden vorverarbeitet",
    "loading_step_restore_attributes": "Attributen in generierten Assemblies werden wiederhergestellt",
    "loose_file_saved_at": "Lose Datei gespeichert unter {0}",
    "menu_export": "Exportieren",
    "menu_export_all": "Alle Dateien exportieren",
    "menu_export_selected": "Ausgewählte Datei exportieren",
    "menu_export_selected_type": "Alle Dateien des ausgewählten Typs exportieren",
    "menu_file": "Datei",
    "menu_file_exit": "Beenden",
    "menu_file_open_file": "Datei öffnen",
    "menu_file_open_folder": "Ordner öffnen",
    "menu_file_reset": "Zurücksetzen",
    "menu_language": "Sprache",
    "mesh_export_title": "Mesh-Exportformat",
    "mesh_format_glb": "GLB",
    "mesh_format_glb_description": "Eine hochwertige Alternative zu FBX, die Open Source ist. Binäre Version von GLTF. Enthält nur Mesh-Daten. Kann Fehler verursachen. Unity kann Assets dieses Typs nicht importieren.",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "Ein robustes Dateiformat für Meshes im Editor. Kann von einer Vielzahl von Unity-Paketen in andere Formate konvertiert werden.",
    "no_game_files_found": "Kein Unity-Spiel oder Asset-Bundle wurde in den bereitgestellten Dateien gefunden.",
    "not_implemented_yet": "Noch nicht implementiert",
    "script_content_level_0": "Level 0",
    "script_content_level_0_description": "Scripts werden nicht exportiert.",
    "script_content_level_1": "Level 1",
    "script_content_level_1_description": "Methoden werden von dekompilierten Export entfernt.",
    "script_content_level_2": "Level 2",
    "script_content_level_2_description": "Standard. Exportiert vollständige Methoden für Mono-Spiele und Dummy-Methoden für IL2Cpp-Spiele.",
    "script_content_level_3": "Level 3",
    "script_content_level_3_description": "IL2Cpp-Methoden werden sicher wiederhergestellt, wenn möglich.",
    "script_content_level_4": "Level 4",
    "script_content_level_4_description": "IL2Cpp-Methoden werden ohne Rücksicht auf Erfolgswahrscheinlichkeit wiederhergestellt.",
    "script_content_level_title": "Skript-Inhaltslevel",
    "script_export_format_decompiled": "Dekompiliert",
    "script_export_format_decompiled_description": "Der ILSpy-Decompiler wird zur Erstellung von CS-Skripten verwendet. Zuverlässige Methode. Allerdings auch zeitaufwändig und enthält viele Kompilierfehler.",
    "script_export_format_dll_with_renaming": "DLL-Export mit Umbenennung",
    "script_export_format_dll_without_renaming": "DLL-Export ohne Umbenennung",
    "script_export_format_dll_without_renaming_description": "Assemblies werden in ihrer kompilierten Dll-Form exportiert. Unity wird wahrscheinlich spezielle Assemblies wie Assembly-CSharp überschreiben.",
    "script_export_format_hybrid": "Hybrid",
    "script_export_format_hybrid_description": "Spezielle Assemblies wie Assembly-CSharp werden dekompiliert. Andere Assemblies werden in ihrer kompilierten Dll-Form exportiert.",
    "script_export_title": "Skript-Exportformat",
    "script_language_version_title": "C#-Sprachversion",
    "select_asset_to_view_info": "Asset links auswählen, um die Informationen darüber anzuzeigen",
    "shader_asset_export_title": "Shader-Exportformat",
    "shader_asset_format_decompile": "Dekompilieren",
    "shader_asset_format_decompile_description": "Exportiert den Shader zu ShaderLab. Höchstexperimentell, führt wahrscheinlich zu Fehlern. Unterstützt nur DX11, nicht DX9.",
    "shader_asset_format_disassembly": "Disassemblierung",
    "shader_asset_format_disassembly_description": "Export der Shader als Disassemblierung. Experimentell und Fehleranfällig. Lässt sich nicht im Editor kompilieren.",
    "shader_asset_format_dummy": "Dummy-Shader",
    "shader_asset_format_dummy_description": "Export der Shader als Dummy-Shader. Obwohl dies Daten wie die Eigenschaften und FallBack beibehält, wird allgemeiner, farbdeckender Shader-Code verwendet.",
    "shader_asset_format_yaml": "Yaml-Asset",
    "shader_asset_format_yaml_description": "Export der Shader als Yaml-Asset. Experimentell und nur zur Ansicht im Editor verwendbar. Der Editor kann diese Dateien unvorhersehbar beschädigen.",
    "skip_streaming_assets": "StreamingAssets-Ordner überspringen",
    "sprite_export_title": "Sprite-Exportformat",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Im Sprite-Format von Unity exportieren. Kann nicht außerhalb von Unity angezeigt werden.",
    "sprite_format_texture": "Textur",
    "sprite_format_texture_description": "Export als Bild des Sprite-Sheets. Kann außerhalb von Unity angezeigt werden, der Export ist jedoch langsamer.",
    "sprite_format_yaml": "Yaml",
    "sprite_format_yaml_description": "Export als yaml-Assets, die im Editor angezeigt werden können. Dies ist der einzige Modus, der eine präzise Wiederherstellung aller Metadaten von Sprites gewährleistet.",
    "success": "Erfolgreich!",
    "terrain_export_title": "Terrain-Exportformat",
    "terrain_format_heatmap": "Heightmap",
    "terrain_format_heatmap_description": "Export einer Heatmap der Höhe des Terrains in allen Bereichen. Nur dann nützlich, wenn Details unwichtig sind oder das Gelände nicht als 3D-Modell benötigt wird.",
    "terrain_format_mesh": "3D-Mesh",
    "terrain_format_mesh_description": "Export des Terrains als 3D-Mesh im GLB-Format, das mit einer Vielzahl von 3D-Editoren bearbeitet werden kann.",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "Export im nativen Terrain-Format von Unity. Die nützlichste Option, wenn zurück in Unity hineinimportiert werden soll.",
    "text_asset_export_title": "TextAsset-Exportformat",
    "text_asset_format_binary": "Bytes",
    "text_asset_format_binary_description": "Export der reinen Bytes des Text-Assets mit der Erweiterung .bytes.",
    "text_asset_format_parse": "Parsen",
    "text_asset_format_parse_description": "Export als einfache Textdatei, jedoch soll versucht werden, die richtige Dateierweiterung zu erraten (z. B. erhalten JSON-Dateien die Erweiterung .json)",
    "text_asset_format_text": "Einfacher Text",
    "text_asset_format_text_description": "Export als eine einfache Textdatei (.txt)",
    "welcome_title": "Willkommen beim AssetRipper",
    "an_error_occured_during_decompilation": "Bei der Dekompilierung ist ein Fehler aufgetreten.",
    "appreciation_message": "Danke, dass Sie AssetRipper unterstützen!",
    "asset_tab_dependencies": "Abhängigkeiten",
    "asset_tab_font": "Schriftart",
    "assembly_name": "Assembly Name",
    "asset_bundle_name": "Asset Bundle Name",
    "asset_tab_development": "Entwicklung",
    "asset_tab_information": "Informationen"
}

```

`Localizations/el.json`:

```json
{
    "asset_tab_audio_play": "Αναπαραγωγή",
    "asset_tab_audio_pause": "Παύση",
    "asset_tab_information": "Πληροφορίες",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_latest": "Πιο πρόσφατη έκδοση C#",
    "channels": "Κανάλια",
    "class": "Κλάση",
    "class_name": "Όνομα Κλάσης",
    "collection": "Συλλογή",
    "collections": "Συλλογές",
    "check_log_for_more_details": "Ελέγξτε το αρχείο καταγραφής για περισσότερες λεπτομέρειες",
    "commands": "Εντολές",
    "config_options": "Ρυθμίσεις",
    "configuration_files_lists": "Λίστες",
    "donation_message": "Αν σας αρέσει το AssetRipper, σκεφτείτε να κάνετε δωρεά:",
    "error": "Σφάλμα",
    "experimental": "Πειραματικό",
    "format": "Μορφή",
    "frequency": "Συχνότητα",
    "height": "Ύψος",
    "home": "Αρχική",
    "image_export_title": "Μορφή Εξαγωγής Εικόνας",
    "licenses": "Άδειες",
    "load": "Φόρτωση",
    "menu_export": "Εξαγωγή",
    "menu_export_all": "Εξαγωγή Όλων",
    "menu_export_selected": "Εξαγωγή Επιλεγμένου Αρχείου",
    "menu_file": "Αρχείο",
    "menu_file_exit": "Έξοδος",
    "menu_file_open_file": "Άνοιγμα Αρχείου",
    "menu_file_reset": "Επαναφορά",
    "menu_import": "Εισαγωγή",
    "menu_language": "Γλώσσα",
    "menu_load": "Φόρτωση",
    "menu_view": "Προβολή",
    "mesh_format_native": "Yaml",
    "mesh_format_glb": "GLB",
    "name": "Όνομα",
    "loading_step_detect_platform": "Συλλογή Αρχείων και Ανίχνευση Της Δομής Του Παιχνιδιού",
    "no_files_loaded": "Κανένα Αρχείο Φορτωμένο",
    "original_path": "Αρχική Διαδρομή",
    "path": "Διαδρομή",
    "path_id": "ID Διαδρομής",
    "remove": "Αφαίρεση",
    "replace": "Αντικατάσταση",
    "save": "Αποθήκευση",
    "scene": "Σκηνή",
    "script_content_level_0": "Επίπεδο 0",
    "script_content_level_1": "Επίπεδο 1",
    "script_content_level_2": "Επίπεδο 2",
    "script_content_level_3": "Επίπεδο 3",
    "script_content_level_4": "Επίπεδο 4",
    "script_language_version_title": "Έκδοση Γλώσσας C#",
    "select_file": "Επιλογή Αρχείου",
    "select_folder": "Επιλογή Φακέλου",
    "settings": "Ρυθμίσεις",
    "sprite_format_yaml": "Yaml",
    "success": "Επιτυχία!",
    "terrain_format_native": "Yaml",
    "text_asset_format_text": "Απλό Κείμενο",
    "view_loaded_files": "Προβολή Φορτωμένων Αρχείων",
    "welcome": "Καλώς Ήρθες",
    "width": "Πλάτος",
    "yaml": "Yaml",
    "skip_streaming_assets": "Παράλειψη Φακέλου StreamingAssets",
    "asset_tab_audio": "Ήχος",
    "asset_tab_audio_duration_unknown": "<Άγνωστο>",
    "asset_tab_font": "Γραμματοσειρά",
    "asset_tab_text": "Κείμενο",
    "asset_tab_image": "Εικόνα",
    "audio_format_force_wav": "Μετατροπή σε WAV",
    "appreciation_message": "Ευχαριστούμε που υποστήριξες το AssetRipper!",
    "audio_format_yaml": "Yaml",
    "bundled_assets_export_direct_export": "Άμεση Εξαγωγή",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_auto_experimental": "Αυτόματο - Πειραματικό",
    "c_sharp_langage_version_config_auto_safe": "Αυτόματο - Ασφαλές",
    "c_sharp_language_version_config_description": "Η έκδοση της γλώσσας C# που θα χρησιμοποιηθεί για την διαδικασία decompiling των scripts.",
    "an_error_occured_during_decompilation": "Παρουσιάστηκε κάποιο σφάλμα κατά την διαδικασία decompilation.",
    "audio_format_default": "Προεπιλογή",
    "data": "Δεδομένα",
    "default_version": "Προεπιλεγμέη Έκδοση",
    "error_exporting_with_reason": "Αποτυχία εξαγωγής περιεχομένου παιχνιδιού: {0}",
    "error_importing_with_reason": "Αποτυχία φόρτωσης περιεχομένου παιχνιδιού: {0}",
    "export_complete": "Η Εξαγωγή Ολοκληρώθηκε!",
    "export_deleting_old_files": "Διαγραφή υπαρχόντων αρχείων...",
    "image_format_description": "Αυτό επηρεάζει όλες τις εξαγόμενες εικόνες.",
    "json": "Json",
    "length": "Μήκος",
    "loading_game_content_from": "Φόρτωση Περιεχομένου Παιχνιδιού Από {0}\n{1}",
    "menu_file_open_folder": "Άνοιγμα Φακέλου",
    "not_implemented_yet": "Δεν Έχει Φτιαχτεί Ακόμα",
    "save_settings_to_disk": "Αποθήκευση Ρυθμίσεων στον Δίσκο",
    "settings_can_only_be_changed_before_loading_files": "Οι ρυθμίσεις μπορούν να αλλαχθούν μόνο πριν την φόρτωση αρχείων.",
    "size": "Μέγεθος",
    "sprite_format_native": "Unity",
    "text_asset_format_text_description": "Εξαγωγή ως αρχείο απλού κειμένου (.txt).",
    "warning_this_directory_is_not_empty_all_content_will_be_deleted": "Προσοχή: αυτός ο κατάλογος δεν είναι κενός. Όλα τα περιεχόμενα θα διαγραφτούν.",
    "export_preparing": "Προετοιμασία για Εξαγωγή...\nΑυτό μπορεί να πάρει λίγο χρόνο.",
    "loading_step_create_file_collection": "Δημιουργία Συλλογής Αρχείων",
    "audio_export_title": "Μορφή Εξαγωγής Ήχου",
    "count": "Μέτρημα/Αριθμός",
    "csharp_type": "Τύπος C#",
    "script_export_format_dll_with_renaming": "Εξαγωγή DLL Με Μετονομασία",
    "script_export_format_dll_without_renaming": "Εξαγωγή DLL Χωρίς Μετονομασία",
    "script_export_title": "Μορφή Εξαγωγής Script",
    "asset_tab_hex": "Δεκαεξαδικό",
    "audio_clip": "Κομμάτι Ήχου (AudioClip)",
    "audio_format_force_wav_description": "Μετατροπή όλων των αρχείων ήχου σε αρχεία WAV. Δεν συνιστάται αν είναι να τα βάλεις στο Unity, καθώς μπορεί να επανασυμπιέσει αρχεία, προκαλώντας απώλεια ποιότητας.",
    "asset_ripper_free": "AssetRipper Δωρεάν",
    "asset_ripper_premium": "AssetRipper Premium",
    "assembly_name": "Όνομα Assembly",
    "asset_bundle_name": "Όνομα Asset Bundle",
    "asset_tab_dependencies": "Εξαρτήσεις",
    "assets": "Assets",
    "export_in_progress": "Εξαγωγή Asset Αρχείων\n{0}%\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "Εξαγωγή Asset Αρχείων\n0.0%\n?/?",
    "failed_files": "Απετυχημένα Αρχεία",
    "guid": "GUID",
    "game_object": "Αντικείμενο Παιχνιδιού (GameObject)",
    "namespace": "Namespace",
    "export_unity_project": "Εξαγωγή Unity Project",
    "export_primary_content": "Εξαγωγή Πρωτεύοντος Περιεχομένου"
}

```

`Localizations/en_US.json`:

```json
{
    "all": "All",
    "an_error_occured_during_decompilation": "An error occurred during decompilation.",
    "appreciation_message": "Thank you for supporting AssetRipper!",
    "assembly_name": "Assembly Name",
    "asset_bundle_name": "Asset Bundle Name",
    "asset_ripper_free": "AssetRipper Free",
    "asset_ripper_premium": "AssetRipper Premium",
    "asset_tab_audio": "Audio",
    "asset_tab_audio_duration_unknown": "<Unknown>",
    "asset_tab_audio_pause": "Pause",
    "asset_tab_audio_play": "Play",
    "asset_tab_dependencies": "Dependencies",
    "asset_tab_development": "Development",
    "asset_tab_font": "Font",
    "asset_tab_hex": "Hex",
    "asset_tab_image": "Image",
    "asset_tab_information": "Information",
    "asset_tab_model": "Model",
    "asset_tab_text": "Text",
    "asset_tab_video": "Video",
    "assets": "Assets",
    "audio_clip": "AudioClip",
    "audio_export_title": "Audio Export Format",
    "audio_format_default": "Default",
    "audio_format_default_description": "Export assets as the content type embedded inside the FSB. Most audio types are exported as WAV, some are exported as OGG.",
    "audio_format_force_wav": "Convert to WAV",
    "audio_format_force_wav_description": "Convert all audio files to WAV files. Not recommended if importing into Unity, as it may recompress files, causing a loss of quality.",
    "audio_format_native": "Raw",
    "audio_format_native_description": "Raw FSB Audio. Cannot be imported into Unity, so only use this if you're an advanced user.",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "Export as a yaml asset and resS file. This is a safe option and is the backup when things go wrong.",
    "bundle": "Bundle",
    "bundled_assets_export_direct_export": "Direct Export",
    "bundled_assets_export_direct_export_description": "Bundled assets are exported without grouping.",
    "bundled_assets_export_group_by_asset_type": "Group By Asset Type",
    "bundled_assets_export_group_by_asset_type_description": "Bundled assets are treated the same as assets from other files.",
    "bundled_assets_export_group_by_bundle_name": "Group By Bundle Name",
    "bundled_assets_export_group_by_bundle_name_description": "Bundled assets are grouped by their asset bundle name.",
    "bundled_assets_export_title": "Bundled Assets Export Mode",
    "bundles": "Bundles",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_12_0": "C# 12",
    "c_sharp_langage_version_config_13_0": "C# 13",
    "c_sharp_langage_version_config_14_0": "C# 14",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "Automatic - Experimental",
    "c_sharp_langage_version_config_auto_safe": "Automatic - Safe",
    "c_sharp_langage_version_config_latest": "C# Latest",
    "c_sharp_language_version_config_description": "The C# language version to be used when decompiling scripts.",
    "channels": "Channels",
    "check_log_for_more_details": "Check log for more details",
    "class": "Class",
    "class_id_type_name": "Class ID Type Name",
    "class_id_type_number": "Class ID Type Number",
    "class_name": "Class Name",
    "collection": "Collection",
    "collections": "Collections",
    "commands": "Commands",
    "config_options": "Configuration Options",
    "config_screen_drag_drop_prompt": "Please note that some setting changes may cause or prevent errors.\nOnce you're ready, drag-and-drop your game file/folder onto this window, or use the menu in the upper-left to open something manually.",
    "configuration_files": "Configuration Files",
    "configuration_files_lists": "Lists",
    "configuration_files_singletons": "Singletons",
    "count": "Count",
    "create_subfolder": "Create Subfolder",
    "csharp_type": "C# Type",
    "data": "Data",
    "default_version": "Default Version",
    "donation_message": "If you like AssetRipper, please consider donating:",
    "enable_asset_deduplication": "Enable Asset Deduplication",
    "enable_prefab_outlining": "Enable Prefab Outlining",
    "enable_static_mesh_separation": "Enable Static Mesh Separation",
    "enter_search_query": "Enter a search query to find assets.",
    "error": "Error",
    "error_exporting_with_reason": "Failed to export game content: {0}",
    "error_importing_with_reason": "Failed to load game content: {0}",
    "experimental": "Experimental",
    "export_complete": "Export Complete!",
    "export_deleting_old_files": "Clearing out existing files...",
    "export_directory_delete_user_confirmation": "The selected export directory already exists and everything it contains will be deleted. Are you sure you want to continue?",
    "export_in_progress": "Exporting Asset Files\n{0}%\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "Exporting Asset Files\n0.0%\n?/?",
    "export_preparing": "Preparing for Export...\nThis might take a minute.",
    "export_primary_content": "Export Primary Content",
    "export_unity_project": "Export Unity Project",
    "export_unreadable_assets": "Export Unreadable Assets",
    "failed_files": "Failed Files",
    "file_id": "File ID",
    "format": "Format",
    "frequency": "Frequency",
    "filter": "Filter",
    "game_object": "GameObject",
    "guid": "GUID",
    "height": "Height",
    "home": "Home",
    "image_export_title": "Image Export Format",
    "image_format_description": "This affects all exported images.",
    "install_unity_editor": "Install Unity Editor",
    "install_unity_hub": "Install Unity Hub",
    "json": "Json",
    "length": "Length",
    "licenses": "Licenses",
    "lightmap_texture_export_title": "Lightmap Texture Export Format",
    "lightmap_texture_format_description": "This affects all exported lightmap textures.",
    "load": "Load",
    "loading_game_content_from": "Loading Game Content From {0}\n{1}",
    "loading_step_begin_scheme_processing": "Starting Scheme Processing",
    "loading_step_create_file_collection": "Creating File Collection",
    "loading_step_detect_platform": "Collecting Files and Detecting Game Structure",
    "loading_step_generate_dummy_dll": "Generating Mono Assemblies from IL2Cpp",
    "loading_step_initialize_layout": "Initializing Asset Layout",
    "loading_step_load_assemblies": "Loading Assemblies",
    "loading_step_load_assets_from_file": "Loading Assets from {0}",
    "loading_step_locate_key_functions": "Scanning IL2Cpp Binary for Library Functions",
    "loading_step_parse_archive": "Parsing Archive File {0}",
    "loading_step_parse_bundle": "Parsing Bundle {0}",
    "loading_step_parse_il2cpp_metadata": "Parsing IL2Cpp Metadata",
    "loading_step_parse_resource": "Parsing Resource File {0}",
    "loading_step_parse_serialized": "Parsing Serialized File {0}",
    "loading_step_parse_web": "Parsing Web File {0}",
    "loading_step_pre_processing": "Pre-Processing Files",
    "loading_step_restore_attributes": "Restoring Attributes on Generated Assemblies",
    "loose_file_saved_at": "Loose file saved at {0}",
    "main_asset": "Main Asset",
    "menu_development": "Development",
    "menu_export": "Export",
    "menu_export_all": "Export All Files",
    "menu_export_selected": "Export Selected File",
    "menu_file": "File",
    "menu_file_exit": "Exit",
    "menu_file_open_file": "Open File",
    "menu_file_open_folder": "Open Folder",
    "menu_file_reset": "Reset",
    "menu_import": "Import",
    "menu_language": "Language",
    "menu_load": "Load",
    "menu_view": "View",
    "mesh": "Mesh",
    "mesh_export_title": "Mesh Export Format",
    "mesh_format_glb": "GLB",
    "mesh_format_glb_description": "A high-quality, open-source alternative to FBX. Binary version of GLTF. Only contains mesh data. Can cause errors. Unity cannot import assets of this type.",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "A robust format for using meshes in the editor. Can be converted to other formats by a variety of Unity packages.",
    "name": "Name",
    "namespace": "Namespace",
    "no_data_has_been_loaded_for_this_key": "No data has been loaded for this key.",
    "no_files_loaded": "No Files Loaded",
    "no_game_files_found": "No Unity game or asset bundle was found in the dropped files.",
    "no_meshes_found": "No Meshes Found",
    "no_results_found": "No results found.",
    "no_shaders_found": "No Shaders Found",
    "no_static_meshes_found": "No Static Meshes Found",
    "not_available_in_the_free_edition": "Not available in the free edition.",
    "not_implemented_yet": "Not Implemented Yet",
    "not_supported": "Not Supported",
    "open_api_json": "OpenAPI JSON",
    "original_path": "Original Path",
    "override_path": "Override Path",
    "parent": "Parent",
    "path": "Path",
    "path_id": "Path ID",
    "premium_feature_notice": "Premium feature",
    "premium_features": "Premium Features",
    "privacy": "Privacy",
    "publicize_assemblies": "Publicize Assemblies",
    "remove": "Remove",
    "remove_nullable_attributes": "Remove Nullable Attributes",
    "replace": "Replace",
    "resources": "Resources",
    "results": "Results",
    "save": "Save",
    "save_raw_data": "Save Raw Data",
    "save_settings_to_disk": "Save Settings to Disk",
    "scene": "Scene",
    "script": "Script",
    "search": "Search",
    "search_placeholder": "Enter asset name or class...",
    "script_content_level_0": "Level 0",
    "script_content_level_0_description": "Scripts are not exported.",
    "script_content_level_1": "Level 1",
    "script_content_level_1_description": "Methods are stripped from decompiled export.",
    "script_content_level_2": "Level 2",
    "script_content_level_2_description": "Default. This exports full methods for Mono games and dummy methods for IL2Cpp games.",
    "script_content_level_3": "Level 3",
    "script_content_level_3_description": "IL2Cpp methods are safely recovered where possible.",
    "script_content_level_4": "Level 4",
    "script_content_level_4_description": "IL2Cpp methods are recovered without regard to safety.",
    "script_content_level_title": "Script Content Level",
    "script_export_format_decompiled": "Decompilation",
    "script_export_format_decompiled_description": "The ILSpy decompiler is used to generate CS scripts. This is reliable. However, it's also time-consuming and contains many compile errors.",
    "script_export_format_dll_with_renaming": "Dll Export With Renaming",
    "script_export_format_dll_without_renaming": "Dll Export Without Renaming",
    "script_export_format_dll_without_renaming_description": "Assemblies are exported in their compiled Dll form. Unity will likely overwrite special assemblies like Assembly-CSharp.",
    "script_export_format_hybrid": "Hybrid",
    "script_export_format_hybrid_description": "Special assemblies like Assembly-CSharp are decompiled. Other assemblies are exported in their compiled Dll form.",
    "script_export_title": "Script Export Format",
    "script_language_version_title": "C# Language Version",
    "scripts_use_fully_qualified_type_names": "Scripts use fully-qualified type names",
    "select_file": "Select File",
    "select_files": "Select Files",
    "select_folder": "Select Folder",
    "select_folders": "Select Folders",
    "settings": "Settings",
    "settings_can_only_be_changed_before_loading_files": "Settings can only be changed before loading files.",
    "shader": "Shader",
    "shader_asset_export_title": "Shader Export Format",
    "shader_asset_format_decompile": "Decompilation",
    "shader_asset_format_decompile_description": "Export the shader to ShaderLab. Very experimental and almost certainly will have errors. Only supports DX11, not DX9.",
    "shader_asset_format_disassembly": "Disassembly",
    "shader_asset_format_disassembly_description": "Export the shader as disassembly. Experimental and prone to breakage. This does not compile in the editor.",
    "shader_asset_format_dummy": "Dummy Shader",
    "shader_asset_format_dummy_description": "Export the shader as a dummy shader. Although it preserves data like the properties and fallback, it uses general, opaque shader code.",
    "shader_asset_format_yaml": "Yaml Asset",
    "shader_asset_format_yaml_description": "Export the shader as a yaml asset. Experimental and only usable for viewing in the editor. The editor can randomly corrupt these files.",
    "shader_decompilation": "Shader Decompilation",
    "size": "Size",
    "skip_streaming_assets": "Skip StreamingAssets Folder",
    "sprite_export_title": "Sprite Export Format",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Export in the Unity sprite format. Cannot be viewed outside of Unity.",
    "sprite_format_texture": "Texture",
    "sprite_format_texture_description": "Export as an image of the sprite sheet. Can be viewed outside of Unity, but slower to export.",
    "sprite_format_yaml": "Yaml",
    "sprite_format_yaml_description": "Export as yaml assets which can be viewed in the editor. This is the only mode that ensures a precise recovery of all metadata of sprites.",
    "stack_trace": "Stack Trace",
    "static_mesh_separation": "Static Mesh Separation",
    "submesh_count": "Submesh Count",
    "success": "Success!",
    "supported": "Supported",
    "swagger_documentation": "Swagger Documentation",
    "target_version_for_version_changing": "Target Version For Version Changing",
    "terrain_export_title": "Terrain Export Format",
    "terrain_format_heatmap": "Heightmap",
    "terrain_format_heatmap_description": "Export a heatmap of the height of the terrain at each location. Only really useful if you don't care about the details or having the terrain in 3D.",
    "terrain_format_mesh": "3D Mesh",
    "terrain_format_mesh_description": "Export the terrain as a 3D mesh in GLB format, suitable for viewing with a wide range of 3D editors.",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "Export in the native Unity terrain format. Most useful option if you plan to re-import back into Unity.",
    "text_asset_export_title": "TextAsset Export Format",
    "text_asset_format_binary": "Bytes",
    "text_asset_format_binary_description": "Export the raw data of the text asset as a BYTES file.",
    "text_asset_format_parse": "Parse",
    "text_asset_format_parse_description": "Export as a plain text file, but try to guess the correct file extension (e.g. JSON files get the .json extension).",
    "text_asset_format_text": "Plain Text",
    "text_asset_format_text_description": "Export as a plain text file (.txt).",
    "texture": "Texture",
    "there_are_no_keys_for_this_data_type": "There are no keys for this data type.",
    "transform": "Transform",
    "vertex_count": "Vertex Count",
    "view_loaded_files": "View Loaded Files",
    "warning_this_directory_is_not_empty_all_content_will_be_deleted": "Warning: this directory is not empty. All content will be deleted.",
    "welcome": "Welcome",
    "width": "Width",
    "yaml": "Yaml"
}
```

`Localizations/es.json`:

```json
{
    "an_error_occured_during_decompilation": "Ha ocurrido un error durante la descompilación.",
    "appreciation_message": "¡Gracias por apoyar AssetRipper!",
    "assembly_name": "Nombre del ensamblado",
    "asset_bundle_name": "Nombre del paquete de activos",
    "asset_ripper_free": "AssetRipper Free",
    "asset_ripper_premium": "AssetRipper Premium",
    "asset_tab_audio": "Audio",
    "asset_tab_audio_duration_unknown": "<Desconocido>",
    "asset_tab_audio_pause": "Pausa",
    "asset_tab_audio_play": "Reproducir",
    "asset_tab_dependencies": "Dependencias",
    "asset_tab_development": "Desarrollo",
    "asset_tab_font": "Tipografía",
    "asset_tab_hex": "Hex",
    "asset_tab_image": "Imagen",
    "asset_tab_information": "Información",
    "asset_tab_text": "Texto",
    "assets": "Activos",
    "audio_clip": "AudioClip",
    "audio_export_title": "Formato de exportación del audio",
    "audio_format_default": "Por defecto",
    "audio_format_default_description": "Exportar activos como el tipo de contenido incrustado dentro del FSB. La mayoría de audios se exportan como WAV, y otros como OGG.",
    "audio_format_force_wav": "Convertir a WAV",
    "audio_format_force_wav_description": "Convertir todos los archivos de audio a archivos WAV. No se recomienda si se importa a Unity, ya que puede recomprimir archivos y provocar una pérdida de calidad.",
    "audio_format_native": "Sin procesar",
    "audio_format_native_description": "Audio FSB sin procesar. No se puede importar en Unity, así que úsalo solo si eres un usuario avanzado.",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "Exportar como un activo yaml y resS. Esta es una opción segura y es la copia de seguridad cuando las cosas van mal.",
    "bundle": "Paquete",
    "bundled_assets_export_direct_export": "Exportación directa",
    "bundled_assets_export_direct_export_description": "Los activos agrupados se exportan sin agrupar.",
    "bundled_assets_export_group_by_asset_type": "Agrupar por tipo de activo",
    "bundled_assets_export_group_by_asset_type_description": "Los activos agrupados se tratan igual que los activos correspondientes a otros archivos.",
    "bundled_assets_export_group_by_bundle_name": "Agrupar por nombre de paquete",
    "bundled_assets_export_group_by_bundle_name_description": "Los activos agrupados se agrupan por su nombre de paquete de activos.",
    "bundled_assets_export_title": "Modo de exportación de activos agrupados",
    "bundles": "Paquetes",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "Automatico - Experimental",
    "c_sharp_langage_version_config_auto_safe": "Automatico - Seguro",
    "c_sharp_langage_version_config_latest": "Versión de C# más reciente",
    "c_sharp_language_version_config_description": "La versión del lenguaje C# que se utilizará al descompilar scripts.",
    "channels": "Canales",
    "check_log_for_more_details": "Comprobar registro para obtener más detalles",
    "class": "Clase",
    "class_id_type_name": "Nombre de tipo de ID de clase",
    "class_id_type_number": "Número de tipo de ID de clase",
    "class_name": "Nombre de clase",
    "collection": "Colección",
    "collections": "Colecciones",
    "commands": "Comandos",
    "config_options": "Opciones de configuración",
    "config_screen_drag_drop_prompt": "Por favor, ten en cuenta que algunos cambios de configuración pueden causar o evitar errores.\nUna vez que estés listo, arrastra y suelta tu archivo/carpeta del juego en esta ventana, o utiliza el menú de la parte superior izquierda para seleccionar algo manualmente.",
    "configuration_files": "Archivos de configuración",
    "configuration_files_lists": "Listas",
    "configuration_files_singletons": "Singletons",
    "count": "Contador",
    "csharp_type": "Tipo de C#",
    "data": "Datos",
    "default_version": "Versión por defecto",
    "donation_message": "Si te gusta AssetRipper, por favor considera donar:",
    "enable_prefab_outlining": "Habilitar Prefab Outlining",
    "error": "Error",
    "error_exporting_with_reason": "Error al exportar el contenido del juego: {0}",
    "error_importing_with_reason": "Error al cargar el contenido del juego: {0}",
    "experimental": "Experimental",
    "export_complete": "¡Exportación terminada!",
    "export_deleting_old_files": "Borrando archivos existentes...",
    "export_in_progress": "Exportando archivos de activos\n{0}%\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "Exportando archivos de activos\n0.0%\n?/?",
    "export_preparing": "Preparando la exportación...\nEsto puede tomar un tiempo.",
    "format": "Formato",
    "frequency": "Frecuencia",
    "game_object": "GameObject",
    "guid": "GUID",
    "height": "Alto",
    "home": "Inicio",
    "image_export_title": "Formato de exportación de imágenes",
    "image_format_description": "Esto afecta a todas las imágenes exportadas.",
    "json": "Json",
    "length": "Longitud",
    "licenses": "Licencias",
    "load": "Cargar",
    "loading_game_content_from": "Cargando contenido del juego desde {0}\n{1}",
    "loading_step_begin_scheme_processing": "Iniciando procesamiento de esquema",
    "loading_step_create_file_collection": "Creando colección de archivos",
    "loading_step_detect_platform": "Reuniendo archivos y detectando la estructura del juego",
    "loading_step_generate_dummy_dll": "Generando Ensamblados Mono a partir de IL2Cpp",
    "loading_step_initialize_layout": "Inicializando orden de assets",
    "loading_step_load_assemblies": "Cargando Ensamblados",
    "loading_step_load_assets_from_file": "Cargando assets de {0}",
    "loading_step_locate_key_functions": "Escaneando binario IL2Cpp en busca de funciones de biblioteca",
    "loading_step_parse_archive": "Analizando archivo {0}",
    "loading_step_parse_bundle": "Analizando paquete {0}",
    "loading_step_parse_il2cpp_metadata": "Analizando metadatos IL2Cpp",
    "loading_step_parse_resource": "Analizando archivo de recursos {0}",
    "loading_step_parse_serialized": "Analizando archivo serializado {0}",
    "loading_step_parse_web": "Analizando archivo Web {0}",
    "loading_step_pre_processing": "Preprocesando archivos",
    "loading_step_restore_attributes": "Restaurar atributos en ensamblados generados",
    "loose_file_saved_at": "Archivo suelto guardado en {0}",
    "main_asset": "Asset principal",
    "menu_export": "Exportar",
    "menu_export_all": "Exportar todo",
    "menu_export_selected": "Exportar selección",
    "menu_file": "Archivo",
    "menu_file_exit": "Salir",
    "menu_file_open_file": "Abrir archivo",
    "menu_file_open_folder": "Abrir carpeta",
    "menu_file_reset": "Reiniciar",
    "menu_import": "Importar",
    "menu_language": "Idioma",
    "menu_load": "Cargar",
    "menu_view": "Ver",
    "mesh": "Malla",
    "mesh_export_title": "Formato de exportación de malla",
    "mesh_format_glb": "GLB",
    "mesh_format_glb_description": "Una alternativa de código abierto y alta calidad a FBX. Versión binaria de GLTF. Sólo contiene datos de malla. Puede causar errores. Unity no puede importar assets de este tipo.",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "Un formato robusto para usar mallas en el editor. Puede ser convertido a otros formatos por una variedad de paquetes de Unity.",
    "name": "Nombre",
    "namespace": "Espacio de nombres",
    "no_data_has_been_loaded_for_this_key": "No se han cargado datos para esta clave.",
    "no_files_loaded": "No se han cargado archivos",
    "no_game_files_found": "No se pudo encontrar ningún juego de Unity o Asset Bundles en los archivos seleccionados.",
    "not_implemented_yet": "No implementado aún",
    "original_path": "Ruta original",
    "parent": "Padre",
    "path": "Ruta",
    "path_id": "ID de ruta",
    "privacy": "Privacidad",
    "remove": "Eliminar",
    "replace": "Reemplazar",
    "resources": "Recursos",
    "save": "Guardar",
    "scene": "Escena",
    "script": "Script",
    "script_content_level_0": "Nivel 0",
    "script_content_level_0_description": "Los scripts no son exportados.",
    "script_content_level_1": "Nivel 1",
    "script_content_level_1_description": "Los métodos son removidos de los scripts decompilados.",
    "script_content_level_2": "Level 2",
    "script_content_level_2_description": "Opción establecida por defecto. Se exportarán los métodos completos para juegos Mono y métodos ficticios para juegos IL2Cpp.",
    "script_content_level_3": "Nivel 3",
    "script_content_level_3_description": "Los métodos IL2Cpp son recuperados de forma segura, donde sea posible.",
    "script_content_level_4": "Nivel 4",
    "script_content_level_4_description": "Los métodos IL2Cpp son recuperados sin considerar seguridad.",
    "script_content_level_title": "Nivel de contenido de scripts",
    "script_export_format_decompiled": "Descompilación",
    "script_export_format_decompiled_description": "El descompilador ILSpy se utiliza para generar scripts CS de forma fiable. Sin embargo, también consume mucho tiempo y contiene muchos errores de compilación.",
    "script_export_format_dll_with_renaming": "Exportación DLL con renombrado",
    "script_export_format_dll_without_renaming": "DLL sin renombrar",
    "script_export_format_dll_without_renaming_description": "Los ensamblados se exportan en su forma DLL compilada. Es probable que Unity sobrescriba ensamblados especiales como Assembly-CSharp.",
    "script_export_format_hybrid": "Híbrido",
    "script_export_format_hybrid_description": "Los ensamblados especiales como Assembly-CSharp se descompilan. Otros ensamblados se exportan en su forma DLL compilada.",
    "script_export_title": "Formato de exportación de scripts",
    "script_language_version_title": "Versión del lenguaje C#",
    "select_file": "Seleccionar archivo",
    "select_folder": "Seleccionar carpeta",
    "settings": "Configuración",
    "settings_can_only_be_changed_before_loading_files": "Los ajustes solo se pueden cambiar antes de procesar los archivos.",
    "shader": "Sombreador (Shader)",
    "shader_asset_export_title": "Formato de exportación del sombreador (shader)",
    "shader_asset_format_decompile": "Descompilación",
    "shader_asset_format_decompile_description": "Exporta el sombreador (shader) a ShaderLab. Muy experimental y casi seguro que tendrá errores. Sólo soporta DX11, no DX9.",
    "shader_asset_format_disassembly": "Desensamblado",
    "shader_asset_format_disassembly_description": "Exportar el shader como desensamblado. Función experimental y propensa a errores. No compilable en el editor.",
    "shader_asset_format_dummy": "Sombreador (shader) ficticio",
    "shader_asset_format_dummy_description": "Exportar el sombreador (shader) como un sombreador ficticio. Aunque conserva datos como las propiedades y el sombreador alternativo, utiliza un código de sombreador general y opaco.",
    "shader_asset_format_yaml": "Asset Yaml",
    "shader_asset_format_yaml_description": "Exporta el sombreador (shader) como un activo Yaml. Experimental y sólo utilizable para ver en el editor. El editor puede corromper aleatoriamente estos archivos.",
    "skip_streaming_assets": "Omitir Carpeta StreamingAssets",
    "sprite_export_title": "Formato de exportación de sprites",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Exportar en el formato nativo de sprites de Unity. No generan imágenes, por lo que no se pueden modificar fuera de Unity.",
    "sprite_format_texture": "Textura",
    "sprite_format_texture_description": "Exportar como una imagen de la capa de sprites (Atlas). Se puede visualizar fuera de Unity, pero la exportación es más lenta.",
    "sprite_format_yaml": "Yaml",
    "sprite_format_yaml_description": "Exporta como assets Yaml que se pueden ver en el editor. Este es el único modo que garantiza una recuperación precisa de todos los metadatos de los sprites.",
    "submesh_count": "Conteo de submallas",
    "success": "¡Éxito!",
    "terrain_export_title": "Formato de exportación del terreno",
    "terrain_format_heatmap": "Mapa de Altura (Heightmap)",
    "terrain_format_heatmap_description": "Exportar un mapa de altura del terreno en cada ubicación. Solo es realmente útil si no te importan los detalles o tener el terreno en 3D.",
    "terrain_format_mesh": "Malla 3D",
    "terrain_format_mesh_description": "Exporta el terreno como una malla 3D en formato GLB, adecuada para su visualización con una amplia gama de editores 3D.",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "Exporta en el formato de terreno nativo de Unity. Opción más útil si planeas reimportar de nuevo a Unity.",
    "text_asset_export_title": "Formato de exportación de assets de texto",
    "text_asset_format_binary": "Bytes",
    "text_asset_format_binary_description": "Exportar los bytes del asset de texto sin procesar con la extensión .bytes.",
    "text_asset_format_parse": "Analizar",
    "text_asset_format_parse_description": "Exporta como un archivo de texto sin formato, pero intenta adivinar la extensión de archivo correcta (por ejemplo, los archivos JSON obtienen la extensión .json).",
    "text_asset_format_text": "Texto plano",
    "text_asset_format_text_description": "Exportar como archivo de texto plano (.txt).",
    "texture": "Textura",
    "there_are_no_keys_for_this_data_type": "No hay claves para este tipo de datos.",
    "transform": "Transform",
    "vertex_count": "Recuento de vértices",
    "view_loaded_files": "Ver archivos cargados",
    "warning_this_directory_is_not_empty_all_content_will_be_deleted": "Advertencia: este directorio no está vacío. Se eliminará todo el contenido.",
    "welcome": "Bienvenido",
    "width": "Ancho",
    "yaml": "Yaml",
    "size": "Tamaño",
    "asset_tab_model": "Modelo",
    "enable_asset_deduplication": "Activar deduplicación de Assets",
    "lightmap_texture_export_title": "Formato de exportación para texturas Lightmap",
    "lightmap_texture_format_description": "Esto afectará a todas las texturas lightmap exportadas.",
    "save_settings_to_disk": "Guardar configuración en el disco",
    "export_primary_content": "Exportar contenido principal",
    "export_unity_project": "Exportar proyecto de Unity",
    "stack_trace": "Seguimiento de pila",
    "enable_static_mesh_separation": "Habilitar Separación de Malla Estática",
    "failed_files": "Archivos que fallaron",
    "c_sharp_langage_version_config_12_0": "C# 12",
    "not_available_in_the_free_edition": "No disponible en la versión gratuita.",
    "asset_tab_video": "Vídeo",
    "open_api_json": "OpenAPI JSON",
    "save_raw_data": "Guardar datos en bruto",
    "swagger_documentation": "Documentación Swagger",
    "target_version_for_version_changing": "Versión de destino para cambio de versión",
    "file_id": "ID de archivo",
    "override_path": "Ruta de sobrescritura",
    "publicize_assemblies": "Publicar ensamblados",
    "remove_nullable_attributes": "Eliminar atributos anulables",
    "premium_feature_notice": "Característica premium",
    "create_subfolder": "Crear subcarpeta",
    "scripts_use_fully_qualified_type_names": "Los scripts usan un tipo de nombre enteramente cualificado",
    "select_files": "Seleccionar archivos",
    "select_folders": "Seleccionar carpetas"
}

```

`Localizations/fa.json`:

```json
{
    "an_error_occured_during_decompilation": "خطایی در حین دیکامپایل رخ داد.",
    "appreciation_message": "با تشکر از شما برای حمایت از اسِت ریپِر!",
    "assembly_name": "نام مجمع",
    "asset_bundle_name": "نام بسته دارایی",
    "asset_ripper_free": "اسِت ریپِر رایگان",
    "asset_ripper_premium": "اسِت ریپِر پیشرفته",
    "asset_tab_audio": "صوتی",
    "asset_tab_audio_pause": "توقف",
    "asset_tab_audio_play": "پخش",
    "asset_tab_dependencies": "وابستگی‌ها",
    "asset_tab_development": "توسعه",
    "asset_tab_font": "فونت",
    "asset_tab_hex": "هگز",
    "asset_tab_image": "تصویر",
    "asset_tab_information": "اطلاعات",
    "asset_tab_model": "مدل",
    "asset_tab_text": "متن",
    "asset_tab_video": "ویدیو",
    "assets": "دارایی‌ها",
    "audio_clip": "کلیپ صوتی",
    "audio_export_title": "فرمت صادرات صوتی",
    "audio_format_default": "پیش‌فرض",
    "audio_format_force_wav": "تبدیل به وی‌ای‌وی",
    "audio_format_force_wav_description": "همه فایل‌های صوتی را به وی‌ای‌وی تبدیل کنید. برای وارد کردن به یونیتی توصیه نمی‌شود زیرا ممکن است فایل‌ها دوباره فشرده شوند و کیفیت کاهش یابد.",
    "audio_format_native": "خام",
    "audio_format_yaml_description": "به‌صورت دارایی یامِل و فایل رِسِس صادر کنید. این یک گزینه امن است و در مواقع بروز مشکلات پشتیبان محسوب می‌شود.",
    "bundle": "بسته",
    "bundled_assets_export_direct_export": "صادرات مستقیم",
    "bundled_assets_export_group_by_asset_type": "گروه‌بندی بر اساس نوع دارایی",
    "bundled_assets_export_group_by_asset_type_description": "دارایی‌های بسته‌بندی‌شده همانند دارایی‌های سایر فایل‌ها رفتار می‌شوند.",
    "bundled_assets_export_group_by_bundle_name": "گروه‌بندی بر اساس نام بسته",
    "bundled_assets_export_title": "حالت صادرات دارایی‌های بسته‌بندی‌شده",
    "bundles": "بسته‌ها",
    "c_sharp_langage_version_config_auto_experimental": "خودکار - تجربی",
    "c_sharp_langage_version_config_auto_safe": "خودکار - امن",
    "channels": "کانال‌ها",
    "check_log_for_more_details": "برای جزئیات بیشتر به گزارش مراجعه کنید.",
    "class": "کلاس",
    "class_id_type_name": "نام نوع ID کلاس",
    "class_id_type_number": "شماره نوع ID کلاس",
    "class_name": "نام کلاس",
    "collection": "مجموعه",
    "collections": "مجموعه‌ها",
    "commands": "دستورات",
    "config_options": "گزینه‌های تنظیمات",
    "configuration_files": "فایل‌های تنظیمات",
    "configuration_files_lists": "لیست‌ها",
    "count": "تعداد",
    "csharp_type": "نوع C#",
    "data": "داده‌ها",
    "default_version": "نسخه پیش‌فرض",
    "donation_message": "اگر از AssetRipper خوشتان آمده است، لطفاً حمایت مالی کنید:",
    "enable_asset_deduplication": "فعال‌سازی حذف تکرار دارایی‌ها",
    "enable_prefab_outlining": "فعال‌سازی مشخص کردن جزئیات پیش‌ساخته",
    "enable_static_mesh_separation": "فعال‌سازی جداسازی مش استاتیک",
    "error": "خطا",
    "error_exporting_with_reason": "صدور محتوای بازی ناموفق بود: {0}",
    "export_deleting_old_files": "پاکسازی فایل‌های موجود...",
    "audio_format_default_description": "دارایی‌ها را به همان فرمتی که در اف‌اس‌بی جاسازی شده است، صادر کنید. بیشتر فایل‌های صوتی به وی‌ای‌وی و برخی به او‌جی‌جی صادر می‌شوند.",
    "audio_format_native_description": "صدای خام اف‌اس‌بی. نمی‌توان به یونیتی وارد کرد، فقط برای کاربران پیشرفته استفاده شود.",
    "bundled_assets_export_direct_export_description": "دارایی‌های بسته‌بندی‌شده بدون گروه‌بندی صادر می‌شوند.",
    "bundled_assets_export_group_by_bundle_name_description": "دارایی‌های بسته‌بندی‌شده بر اساس نام بسته دارایی گروه‌بندی می‌شوند.",
    "c_sharp_langage_version_config_latest": "C# آخرین نسخه",
    "c_sharp_language_version_config_description": "نسخه زبان C# که هنگام کدگشایی اسکریپت‌ها استفاده می‌شود.",
    "config_screen_drag_drop_prompt": "توجه: برخی تغییرات تنظیمات ممکن است باعث بروز یا جلوگیری از خطاها شود.\nزمانی که آماده هستید، فایل/پوشه بازی خود را روی این پنجره بکشید یا از منوی بالا سمت چپ برای باز کردن دستی استفاده کنید.",
    "experimental": "تجربی",
    "export_complete": "صدور کامل شد!",
    "export_preparing": "آماده‌سازی برای صدور...\nاین فرآیند ممکن است کمی طول بکشد.",
    "audio_format_yaml": "یامل"
}

```

`Localizations/fr.json`:

```json
{
    "asset_tab_audio": "Audio",
    "asset_tab_audio_duration_unknown": "<Inconnu>",
    "asset_tab_audio_pause": "Pause",
    "asset_tab_audio_play": "Lecture",
    "asset_tab_basic": "Informations de base",
    "asset_tab_image": "Image",
    "asset_tab_text": "Texte",
    "asset_tab_yaml": "Yaml",
    "audio_export_title": "Format d'Export pour l'Audio",
    "audio_format_default": "Défaut",
    "audio_format_default_description": "Exportez les éléments en tant que type de contenus intégrés dans le FSB. La plupart des types audio sont exportés au format WAV, certains sont exportés au format OGG.",
    "audio_format_force_wav": "Convertir vers WAV",
    "audio_format_force_wav_description": "Convertis tous les fichiers audio en fichiers WAV. Cette opération n'est pas recommandée lors de l'importation dans Unity, car elle peut recompresser les fichiers, entraînant une perte de qualité.",
    "audio_format_native": "Brut",
    "audio_format_native_description": "Audio FSB brut. Ne peut pas être importé dans Unity, donc à seulement utiliser si tu es un utilisateur avancé.",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "Exporter en tant qu'asset yaml et ficher resS. C'est une option sûr et est une sauvegarde quand les choses vont mal.",
    "bundled_assets_export_direct_export": "Export Direct",
    "bundled_assets_export_direct_export_description": "Les assets empaquetés sont exportés sans être groupés.",
    "bundled_assets_export_group_by_asset_type": "Grouper par type d'Assets",
    "bundled_assets_export_group_by_asset_type_description": "Les assets empaquetés sont traités de la même manière que les assets d'autres fichiers.",
    "bundled_assets_export_group_by_bundle_name": "Grouper par Noms de Paquets",
    "bundled_assets_export_group_by_bundle_name_description": "Les assets empaquetés sont groupés par le nom des paquets.",
    "bundled_assets_export_title": "Mode d'Export pour les Assets Empaquetés",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "Automatique - Expérimental",
    "c_sharp_langage_version_config_auto_safe": "Automatique - Sûr",
    "c_sharp_langage_version_config_latest": "C# Dernière version",
    "c_sharp_language_version_config_description": "La version du langage C# à utiliser lors de la décompilation des scripts.",
    "check_log_for_more_details": "Consulter le journal pour plus de détails",
    "config_options": "Options de Configuration",
    "config_screen_drag_drop_prompt": "Veuillez noter que certains changements des paramètres peuvent provoquer ou empêcher des erreurs.\nUne fois que vous êtes prêt, glissez-déposez le fichier/dossier du jeu dans cette fenêtre, ou utilisez le menu en haut à gauche pour ouvrir quelque chose manuellement.",
    "enable_prefab_outlining": "Activer les contours préfabriqués",
    "enable_static_mesh_separation": "Activer la Séparation des Mesh Statiques",
    "error": "Erreur",
    "error_exporting_with_reason": "Échec de l'exportation du contenu du jeu : {0}",
    "error_importing_with_reason": "Échec du chargement du contenu du jeu : {0}",
    "export_complete": "Exportation terminée !",
    "export_deleting_old_files": "Effacer les fichiers existants...",
    "export_in_progress": "Exportation de fichiers d'actifs\n{0}%\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "Exportation des Fichiers Asset \n0.0%\n ?/ ?",
    "export_preparing": "Préparation à l'exportation...\nCela peut prendre une minute.",
    "ignore_engine_assets": "Ignorer les actifs du moteur",
    "image_export_title": "Format d'Export pour les Images",
    "image_format_description": "Cela affecte toutes les images exportées.",
    "loading_game_content_from": "Chargement du contenu du jeu à partir de {0}\n{1}",
    "loading_step_begin_scheme_processing": "Lancement du traitement des schémas",
    "loading_step_create_file_collection": "Création d'une collection de fichiers",
    "loading_step_detect_platform": "Collecte des fichiers et détection de la structure du jeu",
    "loading_step_generate_dummy_dll": "Génération d'assemblages mono à partir d'IL2Cpp",
    "loading_step_initialize_layout": "Initialisation de la présentation des actifs",
    "loading_step_load_assemblies": "Chargement des assemblages",
    "loading_step_load_assets_from_file": "Chargement des actifs de {0}",
    "loading_step_locate_key_functions": "Recherche de Fonctions Binaire dans la Bibliothèque IL2CPP",
    "loading_step_parse_archive": "Lecture du fichier d'archive {0}",
    "loading_step_parse_bundle": "Lecture du bundle {0}",
    "loading_step_parse_il2cpp_metadata": "Analyse des métadonnées IL2CPP",
    "loading_step_parse_resource": "Analyse du fichier de ressources {0}",
    "loading_step_parse_serialized": "Analyse du fichier sérialisé {0}",
    "loading_step_parse_web": "Lecture du fichier web {0}",
    "loading_step_pre_processing": "Fichiers de prétraitement",
    "loading_step_restore_attributes": "Restauration des attributs sur les assemblages générés",
    "loose_file_saved_at": "Fichier perdu enregistré à {0}",
    "menu_export": "Exporter",
    "menu_export_all": "Exporter tous les fichiers",
    "menu_export_selected": "Exporter le fichier sélectionné",
    "menu_export_selected_type": "Exporter tous les fichiers du type sélectionné",
    "menu_file": "Fichier",
    "menu_file_exit": "Quitter",
    "menu_file_open_file": "Ouvrir un fichier",
    "menu_file_open_folder": "Ouvrir un dossier",
    "menu_file_reset": "Réinitialiser",
    "menu_language": "Langue",
    "mesh_export_title": "Format d'Export pour les Mesh",
    "mesh_format_glb": "GLB",
    "mesh_format_glb_description": "Une alternative open-source de haute qualité à FBX. Version binaire de GLTF. Contient seulement des données mesh. Peut causer des erreurs. Unity ne peut pas importer d'assets de ce type.",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "Un format robuste pour l'utilisation de maillages dans l'éditeur. Peut être converti en d'autres formats par divers packages Unity.",
    "no_game_files_found": "Aucun jeu Unity ou ensemble de ressources n'a été trouvé dans les fichiers déposés.",
    "not_implemented_yet": "Pas Encore Implémenté",
    "script_content_level_0": "Niveau 0",
    "script_content_level_0_description": "Les scripts ne sont pas exportés.",
    "script_content_level_1": "Niveau 1",
    "script_content_level_1_description": "Les méthodes sont retirées de l'exportation décompilée.",
    "script_content_level_2": "Niveau 2",
    "script_content_level_2_description": "Par défaut. Ceci exporte les méthodes complètes pour les jeux Mono et les méthodes factices pour les jeux IL2Cpp.",
    "script_content_level_3": "Niveau 3",
    "script_content_level_3_description": "Les méthodes IL2Cpp sont récupérées en toute sécurité lorsque cela est possible.",
    "script_content_level_4": "Niveau 4",
    "script_content_level_4_description": "Les méthodes IL2Cpp sont récupérées sans tenir compte de la sécurité.",
    "script_content_level_title": "Niveau de Contenu des Scripts",
    "script_export_format_decompiled": "Décompilé",
    "script_export_format_decompiled_description": "Le décompilateur ILSpy est utilisé pour générer des scripts CS. Il est fiable. Cependant, il prend du temps et contient de nombreuses erreurs de compilation.",
    "script_export_format_dll_with_renaming": "Exportation de Dll avec renommage",
    "script_export_format_dll_without_renaming": "Exportation en Dll sans renommage",
    "script_export_format_dll_without_renaming_description": "Les assemblages sont exportés sous leur forme Dll compilée. Unity écrasera probablement les assemblages spéciaux comme Assembly-CSharp.",
    "script_export_format_hybrid": "Hybride",
    "script_export_title": "Format d'Export pour les Scripts",
    "script_language_version_title": "Version du Langage C#",
    "select_asset_to_view_info": "Sélectionnez un actif sur la gauche pour obtenir des informations à son sujet",
    "shader_asset_export_title": "Format d'Export pour les Shaders",
    "shader_asset_format_decompile": "Décompiler",
    "shader_asset_format_decompile_description": "Exporter le shader vers ShaderLab. Très expérimental, il est presque certain qu'il y aura des erreurs. Ne supporte que DX11, pas DX9.",
    "shader_asset_format_disassembly": "Désassemblage",
    "shader_asset_format_disassembly_description": "Exporter le shader en tant que désassemblage. Expérimental est susceptible de se casser. Cela ne compile pas dans l'éditeur.",
    "shader_asset_format_dummy": "Shader Factice",
    "shader_asset_format_dummy_description": "Exportez le shader en tant que shader factice. Bien qu'il préserve les données telles que les propriétés et les valeurs de secours, il utilise un code de shader général et opaque.",
    "shader_asset_format_yaml": "Élément Yaml",
    "shader_asset_format_yaml_description": "Exporter le shader en tant que fichier yaml. Expérimental est uniquement utilisable dans l'éditeur. L'éditeur peut corrompre ces fichiers de manière aléatoire.",
    "skip_streaming_assets": "Passer le dossier StreamingAssets",
    "sprite_export_title": "Format d'Export pour les Sprites",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Exporter au format sprite Unity. Ne peut pas être visualisé en dehors d'Unity.",
    "sprite_format_texture": "Texture",
    "sprite_format_texture_description": "Exporter sous forme d'image de la feuille de sprites. Peut être visualisé en dehors d'Unity, mais plus lent à exporter.",
    "sprite_format_yaml": "Yaml",
    "sprite_format_yaml_description": "Exporter en tant qu'élément yaml permet d'être lu dans un éditeur. C'est le seul mode qui permet une récupération précise de toutes les métadonnées des sprites.",
    "success": "Succès !",
    "terrain_export_title": "Format d'exportation du terrain",
    "terrain_format_heatmap": "Carte des hauteurs",
    "terrain_format_heatmap_description": "Exporter une heatmap des hauteurs du terrain à toutes les localisations. Seulement très utilise si vous ne faites pas gaffe aux détails ou avoir le terrain en 3D.",
    "terrain_format_mesh": "Mesh 3D",
    "terrain_format_mesh_description": "Exportez le terrain sous forme de maillage 3D au format GLB, qui peut être visualisé avec une large gamme d'éditeurs 3D.",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "Exporter au format de terrain natif Unity. Option la plus utile si vous prévoyez de réimporter dans Unity.",
    "text_asset_export_title": "Format d'Export pour les TextAssets",
    "text_asset_format_binary": "Octets",
    "text_asset_format_binary_description": "Exportez les données brutes de l’élément texte sous forme de fichier BYTES.",
    "text_asset_format_parse": "Analyser",
    "text_asset_format_parse_description": "Exportez sous forme de fichier texte brut, mais essayez de deviner l'extension de fichier correcte (par exemple, les fichiers JSON obtiennent l'extension .json).",
    "text_asset_format_text": "Texte Brut",
    "text_asset_format_text_description": "Exporter sous forme de fichier texte brut (.txt).",
    "welcome_title": "Bienvenue Dans AssetRipper",
    "default_version": "Version par défaut",
    "height": "Hauteur",
    "script_export_format_hybrid_description": "Les assemblages spéciaux comme Assembly-CSharp sont décompilés. Les autres assemblages sont exportés sous leur forme Dll compilée.",
    "view_loaded_files": "Voir les fichiers chargés",
    "welcome": "Bienvenue",
    "width": "Largeur",
    "donation_message": "Si vous aimez AssetRipper, s'il vous plaît faire un don :",
    "no_files_loaded": "Aucun fichier chargé",
    "export_primary_content": "Exporter le contenu principal",
    "lightmap_texture_export_title": "Format d'exportation de texture Lightmap",
    "an_error_occured_during_decompilation": "Une erreur s'est produite lors de la décompilation.",
    "appreciation_message": "Merci de soutenir AssetRipper !",
    "asset_ripper_free": "AssetRipper Gratuit",
    "asset_ripper_premium": "AssetRipper Premium",
    "asset_tab_dependencies": "Dépendances",
    "asset_tab_font": "Police d'écriture",
    "bundles": "Paquets",
    "channels": "Chaînes",
    "length": "Longueur",
    "submesh_count": "Nombre de sous-mailles",
    "failed_files": "Fichiers échoués",
    "game_object": "Objet de jeu",
    "lightmap_texture_format_description": "Affecte toutes les textures de lightmap exportées.",
    "main_asset": "Principal Asset",
    "menu_import": "Importer",
    "menu_load": "Charger",
    "menu_view": "Afficher",
    "mesh": "Maillage",
    "name": "Nom",
    "namespace": "Espace de noms",
    "no_data_has_been_loaded_for_this_key": "Aucune donnée n'a été chargée pour cette clé.",
    "assembly_name": "Nom de l'assembly",
    "asset_bundle_name": "Nom du paquet de l'Asset",
    "asset_tab_development": "Développement",
    "asset_tab_hex": "Hexadécimale",
    "asset_tab_information": "Information",
    "assets": "Assets",
    "audio_clip": "Extrait audio",
    "privacy": "Confidentialité",
    "resources": "Ressources",
    "save": "Sauvegarder",
    "asset_tab_model": "Modèle",
    "bundle": "Paquet",
    "class": "Classe",
    "class_id_type_name": "Nom du Type de la Classe ID",
    "class_id_type_number": "Numéro de la Classe ID",
    "class_name": "Nom de la Classe",
    "collection": "Collection",
    "collections": "Collections",
    "commands": "Commandes",
    "configuration_files": "Fichiers de configuration",
    "configuration_files_lists": "Listes",
    "configuration_files_singletons": "Seul Element",
    "count": "Compter",
    "csharp_type": "Type C# ( CSHARP)",
    "data": "Donnée",
    "enable_asset_deduplication": "Activer la déduplication des Assets",
    "experimental": "Expérimentale",
    "format": "Format",
    "frequency": "Fréquence",
    "open_api_json": "OpenAPI JSON",
    "original_path": "Chemin d'origine",
    "parent": "Parent",
    "path": "Chemin",
    "path_id": "ID du chemin",
    "remove": "Retirer",
    "replace": "Remplacer",
    "save_raw_data": "Enregistrer les données brutes",
    "save_settings_to_disk": "Enregistrer les paramètres sur le disque",
    "scene": "Scène",
    "script": "Script",
    "select_file": "Sélectionner le fichier",
    "select_folder": "Sélectionner un dossier",
    "settings": "Paramètres",
    "settings_can_only_be_changed_before_loading_files": "Les paramètres ne peuvent être modifiés qu'avant le chargement des fichiers.",
    "shader": "Shader",
    "swagger_documentation": "Documentation de Swagger",
    "yaml": "Yaml",
    "guid": "Lignes directrices (GUID)",
    "home": "Accueil",
    "json": "Json",
    "licenses": "Licenses",
    "load": "Chargement",
    "export_unity_project": "Exporter le Projet Unity",
    "size": "Taille",
    "target_version_for_version_changing": "Version cible pour le changement de version",
    "texture": "Texture",
    "there_are_no_keys_for_this_data_type": "Il n'y a pas de clés pour ce type de données.",
    "transform": "Transformer",
    "vertex_count": "Nombre de sommets",
    "warning_this_directory_is_not_empty_all_content_will_be_deleted": "Attention : ce répertoire n'est pas vide. Tout le contenu sera supprimé."
}

```

`Localizations/id.json`:

```json
{}

```

`Localizations/it.json`:

```json
{
    "audio_export_title": "Formato di esportazione dei file audio",
    "audio_format_default": "Predefinito",
    "audio_format_default_description": "Esporta gli asset come il tipo di contenuto integrato all'interno dell'FSB. La maggior parte dei file audio viene esportata come file WAV, alcuni invece vengono esportati come file OGG.",
    "audio_format_force_wav": "Converti in formato WAV",
    "audio_format_force_wav_description": "Converti tutti i file audio in file WAV. Non raccomandato nel caso in cui si volesse importare i file su Unity in quanto alcuni file potrebbero esser ricompressi, causando così perdita di qualità.",
    "audio_format_native": "Non elaborato",
    "audio_format_native_description": "FIle audio FSB non elaborato. Non può essere importato su Unity, quindi usalo solo se sei un utente esperto.",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "Esporta i file audio come asset yaml e file resS. Questa è un'opzione sicura e funge da alternativa nel caso in cui le cose non vadano per il verso giusto.",
    "bundled_assets_export_direct_export": "Esportazione diretta",
    "bundled_assets_export_direct_export_description": "Gli asset in bundle vengono esportati senza essere raggruppati.",
    "bundled_assets_export_group_by_asset_type": "Raggruppa per tipo di asset",
    "bundled_assets_export_group_by_asset_type_description": "Gli asset in bundle vengono trattati allo stesso modo degli asset provenienti da altri file.",
    "bundled_assets_export_group_by_bundle_name": "Raggruppa per nome del bundle",
    "bundled_assets_export_group_by_bundle_name_description": "Gli asset in bundle sono raggruppati in base al nome dei loro bundle.",
    "bundled_assets_export_title": "Modalità di esportazione delle risorse in bundle",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "Automatico - Sperimentale",
    "c_sharp_langage_version_config_auto_safe": "Automatico - Sicuro",
    "c_sharp_langage_version_config_latest": "C# ultima versione",
    "c_sharp_language_version_config_description": "La versione del linguaggio C# da utilizzare durante la decompilazione degli script.",
    "config_options": "Opzioni di configurazione",
    "enable_static_mesh_separation": "Attiva la separazione delle mesh statiche",
    "ignore_engine_assets": "Ignora gli asset dell'engine",
    "image_export_title": "Formato di esportazione delle immagini",
    "image_format_description": "Si applica a tutte le immagini esportate",
    "mesh_export_title": "Formato di esportazione dei modelli",
    "mesh_format_glb": "GLB",
    "mesh_format_glb_description": "Un'alternativa a FBX di alta qualità e a sorgente aperta. Una versione in codice binario di GLTF. Contiene solo i dati della mesh. Può causare errori. Unity non è in grado di importare asset di questo tipo.",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "Un formato robusto per utilizzare le mesh nell'editor. Può esser convertito in altri formati da diversi pacchetti per Unity.",
    "script_content_level_0": "Livello 0",
    "script_content_level_0_description": "Gli script non vengono esportati.",
    "script_content_level_1": "Livello 1",
    "script_content_level_1_description": "I metodi vengono rimossi dall'esportazione decompilata.",
    "script_content_level_2": "Livello 2",
    "script_content_level_2_description": "Predefinito. Esporta metodi completi per i giochi Mono e metodi fittizi per i giochi IL2Cpp.",
    "script_content_level_3": "Livello 3",
    "script_content_level_3_description": "I metodi IL2Cpp vengono recuperati in modo sicuro, ove possibile.",
    "script_content_level_4": "Livello 4",
    "script_content_level_4_description": "I metodi IL2Cpp vengono recuperati senza tener conto della sicurezza.",
    "script_content_level_title": "Livello dei contenuti degli script",
    "script_export_format_decompiled": "Decompilati",
    "script_export_format_decompiled_description": "Il decompilatore ILSpy viene utilizzato per generare gli script CS. È affidabile. Tuttavia, richiede molto tempo e contiene molti errori di compilazione.",
    "script_export_format_dll_with_renaming": "Esportazione dll con rinominazione",
    "script_export_format_dll_without_renaming": "Esportazione dll senza rinominazione",
    "script_export_format_dll_without_renaming_description": "Gli assembly vengono esportati nella loro forma dll compilata. Unity probabilmente sovrascriverà gli assembly speciali come Assembly-CSharp.",
    "script_export_format_hybrid": "Ibrido",
    "script_export_format_hybrid_description": "Gli assembly speciali, come Assembly-CSharp, vengono decompilati. Gli altri assembly vengono esportati nella loro forma dll compilata.",
    "script_export_title": "Formato di esportazione degli script",
    "script_language_version_title": "Versione del linguaggio C#",
    "shader_asset_export_title": "Formato di esportazione degli shader",
    "shader_asset_format_decompile": "Decompilate",
    "shader_asset_format_decompile_description": "Esportare le shader in ShaderLab. Molto sperimentale e quasi certamente produrrà errori. Supporta solo DX11, non DX9.",
    "shader_asset_format_disassembly": "Disassemblate",
    "shader_asset_format_disassembly_description": "Esporta le shader come disassemblate. Sperimentale e prono a problemi. Non vengono compilate nell'editor.",
    "shader_asset_format_dummy": "Shader fittizia",
    "shader_asset_format_dummy_description": "Esportare le shader come shader fittizie. Benché conservino i dati come le Properties e il FallBack, utilizza un codice generico di shader opaca.",
    "shader_asset_format_yaml": "Asset Yaml",
    "shader_asset_format_yaml_description": "Esporta le shader come asset yaml. Sperimentale e utilizzabile solo per la visualizzazione nell'editor. L'editor può corrompere casualmente questi file.",
    "skip_streaming_assets": "Salta l'elaborazione della cartella StreamingAssets",
    "sprite_export_title": "Formato di esportazione degli sprite",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Esporta nel formato degli sprite di Unity. Non può esser visualizzato al di fuori di Unity.",
    "sprite_format_texture": "Texture",
    "sprite_format_texture_description": "Esporta come un immagine dello Sprite Sheet. Può essere visualizzato al di fuori di Unity, ma è più lento da esportare.",
    "sprite_format_yaml": "Yaml",
    "sprite_format_yaml_description": "Esporta come asset yaml che possono essere visualizzate nell'editor. Questa è l'unica modalità che assicura un recupero accurato di tutti i metadati degli sprite.",
    "terrain_export_title": "Formato di esportazione dei terreni",
    "terrain_format_heatmap": "Heightmap",
    "terrain_format_heatmap_description": "Esporta una mappa di calore dell'altezza del terreno in ogni posizione. Utile solo se non ti interessano i dettagli e non ti serve il terreno in 3D.",
    "terrain_format_mesh": "Mesh 3D",
    "terrain_format_mesh_description": "Esporta il terreno come una mesh 3D in formato GLB, adatto per esser visualizzato con un'ampia gamma di editor 3D.",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "Esporta i terreni nel formato nativo di Unity. L'opzione più utile se prevedi di reimportare nuovamente i terreni su Unity.",
    "text_asset_export_title": "Formato di esportazione dei file di testo",
    "text_asset_format_binary": "Byte",
    "text_asset_format_binary_description": "Esporta i byte non elaborati degli asset di testo con estensione .bytes.",
    "text_asset_format_parse": "Analizzato",
    "text_asset_format_parse_description": "Esporta come file di testo non formattato, ma cerca di ipotizzare l'estensione corretta del file (ad esempio, i file JSON hanno l'estensione .json).",
    "text_asset_format_text": "Testo non formattato",
    "text_asset_format_text_description": "Esporta come file di testo non formattato (\".txt\").",
    "welcome_title": "Benvenuto in AssetRipper"
}

```

`Localizations/ja.json`:

```json
{
    "asset_tab_audio": "オーディオ",
    "asset_tab_audio_duration_unknown": "<不明>",
    "asset_tab_audio_pause": "一時停止",
    "asset_tab_audio_play": "再生",
    "asset_tab_basic": "基本情報",
    "asset_tab_image": "画像",
    "asset_tab_text": "テキスト",
    "asset_tab_yaml": "Yaml",
    "audio_export_title": "オーディオのエクスポート形式",
    "audio_format_default": "既定",
    "audio_format_default_description": "FSB に埋め込まれたコンテンツタイプとしてアセットをエクスポートします。ほとんどのオーディオタイプは WAV としてエクスポートされますが、一部は OGG としてエクスポートされます。",
    "audio_format_force_wav": "WAV に変換",
    "audio_format_force_wav_description": "すべてのオーディオファイルを WAV ファイルに変換します。Unity にインポートする場合、ファイルが圧縮され品質が低下する可能性があるため、推奨されません。",
    "audio_format_native": "Raw",
    "audio_format_native_description": "生の FSB オーディオ。Unity にインポートできないため、上級者のユーザーのみ推奨します。",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "yaml アセットと resS ファイルとしてエクスポートします。これは安全なオプションであり、問題が発生した場合のバックアップとなります。",
    "bundled_assets_export_direct_export": "直接でエクスポート",
    "bundled_assets_export_direct_export_description": "バンドルされたアセットをグループ化せずにエクスポートします。",
    "bundled_assets_export_group_by_asset_type": "アセットタイプでグループ",
    "bundled_assets_export_group_by_asset_type_description": "バンドルされたアセットは、他のファイルからのアセットと同じように扱われます。",
    "bundled_assets_export_group_by_bundle_name": "バンドル名でグループ",
    "bundled_assets_export_group_by_bundle_name_description": "バンドルされたアセットをアセットバンドル名でグループ化します。",
    "bundled_assets_export_title": "バンドルされたアセットのエクスポートモード",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "自動検出 - 実験的",
    "c_sharp_langage_version_config_auto_safe": "自動 - 安全",
    "c_sharp_langage_version_config_latest": "C# 最新",
    "c_sharp_language_version_config_description": "スクリプトをデコンパイルする際に使用する C# 言語のバージョン。",
    "check_log_for_more_details": "詳細はログを確認してください",
    "config_options": "構成オプション",
    "config_screen_drag_drop_prompt": "設定の変更によってはエラーが発生する場合がありますのでご注意ください。\n準備ができたら、ゲームファイル/フォルダーをこのウィンドウにドラッグ&ドロップするか、左上のメニューを使用して手動で開いてください。",
    "enable_prefab_outlining": "Prefab Outlining を有効にする",
    "enable_static_mesh_separation": "Static Mesh Separation を有効にする",
    "error": "エラー",
    "error_exporting_with_reason": "ゲームコンテンツのエクスポートに失敗しました: {0}",
    "error_importing_with_reason": "ゲームコンテンツの読み込みに失敗しました: {0}",
    "export_complete": "エクスポートが完了しました!",
    "export_deleting_old_files": "既存のファイルを整理しています...",
    "export_in_progress": "アセットファイルをエクスポートしています\n{0}%\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "アセットファイルをエクスポートしています\n0.0%\n?/?",
    "export_preparing": "エクスポート準備中...\nしばらくお待ち下さい。",
    "ignore_engine_assets": "Engine Assetsを無視する",
    "image_export_title": "画像のエクスポート形式",
    "image_format_description": "これはエクスポートされたすべての画像に影響します。",
    "loading_game_content_from": "{0} からゲームコンテンツを読み込んでいます\n{1}",
    "loading_step_begin_scheme_processing": "スキーム処理をしています",
    "loading_step_create_file_collection": "ファイルコレクションを作成しています",
    "loading_step_detect_platform": "ファイルの収集とゲーム構成を検出しています",
    "loading_step_generate_dummy_dll": "IL2CPP から Mono アセンブリを生成しています",
    "loading_step_initialize_layout": "アセットレイアウトを初期化しています",
    "loading_step_load_assemblies": "アセンブリを読み込んでいます",
    "loading_step_load_assets_from_file": "{0} からアセットを読み込んでいます",
    "loading_step_locate_key_functions": "IL2CPP バイナリのライブラリ関数をスキャンしています",
    "loading_step_parse_archive": "アーカイブファイルを解析中 {0}",
    "loading_step_parse_bundle": "バンドルを解析中 {0}",
    "loading_step_parse_il2cpp_metadata": "IL2CPP メタデータを解析中",
    "loading_step_parse_resource": "リソースファイルを解析中 {0}",
    "loading_step_parse_serialized": "シリアライズファイルを解析中 {0}",
    "loading_step_parse_web": "Web ファイルを解析中 {0}",
    "loading_step_pre_processing": "ファイルを前処理しています",
    "loading_step_restore_attributes": "生成されたアセンブリの属性を復元しています",
    "loose_file_saved_at": "ファイル群 (Loose file) は {0} に保存されました",
    "menu_export": "エクスポート",
    "menu_export_all": "すべてのファイルをエクスポート",
    "menu_export_selected": "選択しているファイルをエクスポート",
    "menu_export_selected_type": "選択した種類のファイル",
    "menu_file": "ファイル",
    "menu_file_exit": "終了",
    "menu_file_open_file": "ファイルを開く",
    "menu_file_open_folder": "フォルダーを開く",
    "menu_file_reset": "リセット",
    "menu_language": "言語",
    "mesh_export_title": "Mesh のエクスポート形式",
    "mesh_format_glb": "GLB",
    "mesh_format_glb_description": "FBX に代わる高品質でオープンソースな代替で、GLTF のバイナリバージョンです。Mesh データのみを含みます。これはエラーが発生する可能性があり、Unity ではこのタイプのアセットをインポートできません。",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "Unity Editor で Mesh を使用するための堅牢な形式です。様々な Unity パッケージで他の形式に変換できます。",
    "no_game_files_found": "ドロップされたファイル内に Unity のゲームまたはアセットバンドルは見つかりませんでした。",
    "not_implemented_yet": "まだ実装されていません",
    "script_content_level_0": "レベル 0",
    "script_content_level_0_description": "スクリプトはエクスポートされません。",
    "script_content_level_1": "レベル 1",
    "script_content_level_1_description": "メソッドはデコンパイルされたエクスポートから削除されます。",
    "script_content_level_2": "レベル 2",
    "script_content_level_2_description": "既定、Mono のゲームの完全なメソッドと IL2CPP のゲームのダミーメソッドをエクスポートします。",
    "script_content_level_3": "レベル 3",
    "script_content_level_3_description": "IL2CPP メソッドが可能な限り安全に回復されます。",
    "script_content_level_4": "レベル 4",
    "script_content_level_4_description": "IL2CPP メソッドの安全性に関係なく回復します。",
    "script_content_level_title": "スクリプト出力レベル",
    "script_export_format_decompiled": "デコンパイル",
    "script_export_format_decompiled_description": "C#スクリプトの生成にILSpyを使用します。信頼性は高いですが、完璧な状態ではない可能性があります。",
    "script_export_format_dll_with_renaming": "DLL(Renameingあり)",
    "script_export_format_dll_without_renaming": "DLL(Renamingなし)",
    "script_export_format_dll_without_renaming_description": "(実験的機能)DLL形式でエクスポートします。全く動作しない可能性があります。",
    "script_export_format_hybrid": "Hybrid",
    "script_export_title": "Script出力形式",
    "script_language_version_title": "C#バージョン",
    "select_asset_to_view_info": "アセット情報を表示するには、左側のリストを選択してください。",
    "shader_asset_export_title": "Shader出力形式",
    "shader_asset_format_decompile": "Decompile",
    "shader_asset_format_decompile_description": "(実験的機能)シェーダーをShaderLab形式にデコンパイルしてエクスポートします。高確率で破損したシェーダーを出力します。DX11のみをサポートしています。",
    "shader_asset_format_disassembly": "Disassembly",
    "shader_asset_format_disassembly_description": "(実験的機能)シェーダーをディスアセンブルした状態でエクスポートします。破損したシェーダーを出力する可能性があります。",
    "shader_asset_format_dummy": "ダミー",
    "shader_asset_format_dummy_description": "ダミーシェーダーとしてエクスポートします。",
    "shader_asset_format_yaml": "Yaml",
    "shader_asset_format_yaml_description": "(実験的機能)シェーダーをyamlとしてエクスポートします。Unity以外では使用できません。エディタがファイルを破損させる可能性があります。",
    "skip_streaming_assets": "StreamingAssetsフォルダーを除外",
    "sprite_export_title": "Sprite出力形式",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Unityのスプライト形式でエクスポートします。Unity以外では使用できません。",
    "sprite_format_texture": "テクスチャ",
    "sprite_format_texture_description": "スプライトシート画像として出力します。",
    "sprite_format_yaml": "Yaml",
    "sprite_format_yaml_description": "Unityエディタで使用できる形式です。スプライトの全メタデータを正確に復元できる唯一のモードです。",
    "success": "成功",
    "terrain_export_title": "Terrain出力形式",
    "terrain_format_heatmap": "3D Mesh",
    "terrain_format_heatmap_description": "地形の高さをハイトマップとしてエクスポートします。",
    "terrain_format_mesh": "3D Mesh",
    "terrain_format_mesh_description": "GLB形式の3Dメッシュとしてエクスポートします。",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "Unityのネイティブ形式でエクスポートします。",
    "text_asset_export_title": "TextAsset出力形式",
    "text_asset_format_binary": "バイナリ",
    "text_asset_format_binary_description": "バイナリ(.bytes)としてエクスポートします。",
    "text_asset_format_parse": "停止",
    "text_asset_format_parse_description": "パースした状態でエクスポートします。(パースした形式とは関係なくすべてプレーンテキスト形式(.txt)としてエクスポートされます)",
    "text_asset_format_text": "プレーンテキスト",
    "text_asset_format_text_description": "プレーンテキスト(.txt)としてエクスポートします",
    "welcome_title": "AssetRipperへようこそ",
    "warning_this_directory_is_not_empty_all_content_will_be_deleted": "警告：このディレクトリは空ではありません、すべての内容が削除されます。",
    "lightmap_texture_format_description": "これはエクスポートされたすべてのライトマップテクスチャに影響します。",
    "menu_import": "インポート",
    "size": "大きさ",
    "asset_tab_information": "情報",
    "failed_files": "失敗したファイル",
    "settings_can_only_be_changed_before_loading_files": "設定はファイル読み込む前にのみ変更できます。",
    "asset_tab_model": "モデル",
    "experimental": "実験的",
    "format": "形式",
    "frequency": "周波数",
    "game_object": "ゲームオブジェクト",
    "licenses": "ライセンス",
    "load": "読み込む",
    "no_files_loaded": "ファイルが読み込まれていません",
    "save": "保存",
    "remove": "削除",
    "privacy": "プライバシー",
    "replace": "置換",
    "resources": "リソース",
    "save_raw_data": "生データを保存",
    "save_settings_to_disk": "設定をディスクに保存",
    "scene": "シーン",
    "script": "スクリプト",
    "settings": "設定",
    "select_folder": "フォルダーを選択",
    "select_file": "ファイルを選択",
    "target_version_for_version_changing": "変更する目標バージョン",
    "width": "広さ",
    "welcome": "ようこそ",
    "view_loaded_files": "読み込まれたファイルを表示",
    "vertex_count": "頂点数",
    "transform": "変換",
    "export_unity_project": "Unity プロジェクトをエクスポート",
    "menu_load": "読み込む",
    "menu_view": "表示",
    "export_primary_content": "プライマリコンテンツのエクスポート",
    "override_path": "上書きのパス",
    "file_id": "ファイル ID",
    "no_data_has_been_loaded_for_this_key": "このキーにはデータが読み込まれていません。",
    "c_sharp_langage_version_config_13_0": "C# 13",
    "c_sharp_langage_version_config_14_0": "C# 14",
    "configuration_files": "構成ファイル",
    "configuration_files_singletons": "シングルトン",
    "export_directory_delete_user_confirmation": "選択したエクスポートディレクトリは既に存在しており、そこに含まれるすべての内容が削除されます。続行してもよろしいですか?",
    "install_unity_editor": "Unity Editor をインストール",
    "install_unity_hub": "Unity Hub をインストール",
    "menu_development": "開発",
    "lightmap_texture_export_title": "ライトマップテクスチャのエクスポート形式",
    "no_meshes_found": "Mesh は見つかりませんでした",
    "no_shaders_found": "シェーダーは見つかりませんでした",
    "no_static_meshes_found": "Static Mesh は見つかりませんでした",
    "not_supported": "非対応",
    "open_api_json": "OpenAPI JSON",
    "original_path": "元のパス",
    "premium_features": "Premium の機能",
    "publicize_assemblies": "集会を宣伝",
    "remove_nullable_attributes": "Null 許容属性を削除",
    "assembly_name": "アセンブリ名",
    "asset_bundle_name": "アセットバンドル名",
    "asset_tab_development": "開発",
    "asset_tab_hex": "Hex",
    "asset_ripper_free": "AssetRipper Free",
    "an_error_occured_during_decompilation": "デコンパイル中にエラーが発生しました。",
    "appreciation_message": "AssetRipper にご支援いただき感謝します!",
    "asset_ripper_premium": "AssetRipper Premium",
    "asset_tab_dependencies": "依存関係",
    "asset_tab_font": "フォント",
    "assets": "アセット",
    "csharp_type": "C# タイプ",
    "premium_feature_notice": "Premium の機能",
    "c_sharp_langage_version_config_12_0": "C# 12",
    "not_available_in_the_free_edition": "無料版では使用できません。",
    "path_id": "パス ID",
    "path": "パス",
    "asset_tab_video": "動画",
    "default_version": "既定のバージョン",
    "count": "数",
    "data": "データ",
    "enable_asset_deduplication": "アセットの重複除去を有効にする",
    "guid": "GUID",
    "height": "高さ",
    "home": "ホーム",
    "json": "Json",
    "audio_clip": "オーディオクリップ",
    "bundles": "バンドル",
    "name": "名前",
    "donation_message": "AssetRipper が気に入ったら寄付をご検討ください:",
    "all": "すべて",
    "bundle": "バンドル",
    "class_id_type_number": "クラス ID タイプ番号",
    "class_name": "クラス名",
    "collection": "コレクション",
    "collections": "コレクション",
    "commands": "コマンド",
    "configuration_files_lists": "一覧",
    "channels": "チャンネル",
    "class": "クラス",
    "class_id_type_name": "クラス ID タイプ名",
    "export_unreadable_assets": "読み取り不可能なアセットをエクスポート",
    "filter": "フィルター",
    "length": "長さ",
    "create_subfolder": "サブフォルダーを作成",
    "main_asset": "メインアセット",
    "mesh": "Mesh",
    "namespace": "名前空間",
    "parent": "親"
}

```

`Localizations/ko.json`:

```json
{
    "welcome_title": "AssetRipper에 오신 것을 환영합니다.",
    "image_export_title": "Image 추출 형식",
    "shader_asset_export_title": "Shader 추출 형식",
    "audio_format_force_wav": "WAV 확장자로 변환",
    "text_asset_export_title": "TextAsset 추출 형식",
    "script_content_level_title": "Script 추출 수준",
    "script_language_version_title": "C# 언어 버전",
    "skip_streaming_assets": "StreamingAssets 폴더를 제외",
    "config_options": "환경 설정",
    "mesh_export_title": "Mesh 추출 형식",
    "sprite_export_title": "Sprite 추출 형식",
    "audio_export_title": "오디오 추출 형식",
    "terrain_export_title": "Terrain 추출 형식",
    "audio_format_native": ".raw",
    "script_export_title": "Script 추출 형식",
    "mesh_format_glb": ".glb",
    "audio_format_yaml": ".yaml",
    "c_sharp_language_version_config_description": "스크립트를 디컴파일할 때 사용할 C# 언어 버전입니다.",
    "config_screen_drag_drop_prompt": "일부 설정 변경으로 인해 오류를 발생시키거나 막을 수 있습니다.\n준비가 되면 게임 파일/폴더를 이 창으로 끌어다 놓거나 왼쪽 상단에 있는 메뉴를 사용하여 수동으로 열 수 있습니다.",
    "export_primary_content": "주요 콘텐츠 추출하기",
    "export_unity_project": "유니티 프로젝트 추출하기",
    "lightmap_texture_export_title": "Lightmap 텍스처 추출 형식",
    "lightmap_texture_format_description": "이는 모든 추출된 Lightmap 텍스처에 영향을 미칩니다.",
    "loading_step_detect_platform": "파일 수집 및 게임 형식 감지",
    "loading_step_initialize_layout": "에셋 레이아웃 초기화",
    "loading_step_load_assets_from_file": "{0}에서 에셋 로딩중",
    "loading_step_locate_key_functions": "라이브러리 기능를 위한 IL2Cpp 바이너리 스캔",
    "loading_step_parse_archive": "아카이브 파일 파싱중 {0}",
    "loading_step_parse_bundle": "번들 파싱중 {0}",
    "loading_step_parse_il2cpp_metadata": "IL2Cpp 메타데이터 파싱중",
    "loading_step_parse_resource": "리소스 파일 파싱중 {0}",
    "loading_step_parse_serialized": "직렬 파일 파싱중 {0}",
    "loading_step_parse_web": "웹 파일 파싱중 {0}",
    "loading_step_pre_processing": "파일 사전 처리중",
    "loading_step_generate_dummy_dll": "IL2Cpp에서 Mono 어셈블리 생성",
    "assembly_name": "Assembly 이름",
    "c_sharp_langage_version_config_3": "C# 3",
    "an_error_occured_during_decompilation": "디컴파일 중에 오류가 발생했습니다.",
    "appreciation_message": "AssetRipper를 도와주셔서 감사합니다!",
    "asset_bundle_name": "에셋 번들 이름",
    "asset_ripper_free": "AssetRipper 무료",
    "asset_ripper_premium": "AssetRipper 프리미엄",
    "asset_tab_audio_duration_unknown": "<알 수 없음>",
    "asset_tab_audio_play": "재생",
    "asset_tab_dependencies": "종속성",
    "asset_tab_development": "개발",
    "asset_tab_font": "폰트",
    "asset_tab_hex": "헥스",
    "asset_tab_image": "이미지",
    "asset_tab_information": "정보",
    "assets": "에셋",
    "audio_clip": "오디오 클립",
    "audio_format_force_wav_description": "모든 오디오 파일을 WAV 파일로 변환합니다. 유니티에 넣을 경우 파일을 다시 압축하여 품질이 저하될 수 있으므로 권장되지 않습니다.",
    "audio_format_yaml_description": "yaml 에셋과 resS 파일로 내보냅니다. 이건 안전한 옵션이며 문제가 발생했을 때의 백업입니다.",
    "bundle": "번들",
    "bundled_assets_export_direct_export": "다이렉트 추출",
    "bundled_assets_export_group_by_bundle_name_description": "번들 에셋이 이름별로 그룹화됩니다.",
    "bundled_assets_export_direct_export_description": "번들 에셋이 그룹화 없이 추출됩니다.",
    "bundles": "번들",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "자동 - 실험기능",
    "c_sharp_langage_version_config_auto_safe": "자동 - 안전모드",
    "c_sharp_langage_version_config_latest": "C# 최신 버전",
    "channels": "채널",
    "class": "클래스",
    "class_id_type_name": "클래스 ID 형식 이름",
    "class_id_type_number": "클래스 ID 형식 숫자",
    "class_name": "클래스 이름",
    "collection": "컬렉션",
    "collections": "컬렉션들",
    "commands": "커맨드",
    "configuration_files": "구성 파일",
    "configuration_files_lists": "리스트",
    "check_log_for_more_details": "자세한 내용은 로그를 확인하세요",
    "configuration_files_singletons": "싱글톤",
    "count": "카운트",
    "csharp_type": "C# 형식",
    "data": "데이터",
    "height": "높이",
    "default_version": "기본 버전",
    "donation_message": "AssetRipper가 마음에 드신다면 기부도 할 수 있어요:",
    "enable_asset_deduplication": "중복된 에셋 삭제 활성화",
    "enable_prefab_outlining": "Prefab Outlining 활성화",
    "enable_static_mesh_separation": "Static Mesh 분리 활성화",
    "error": "오류",
    "error_exporting_with_reason": "게임 컨텐츠 추출 실패: {0}",
    "error_importing_with_reason": "게임 컨텐츠 로드 실패: {0}",
    "experimental": "실험",
    "export_complete": "추출 성공!",
    "export_deleting_old_files": "기존 파일 지우는 중...",
    "export_in_progress": "에셋 파일 추출중\n{0}%\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "에셋 파일 추출중\n0.0%\n?/?",
    "export_preparing": "추출 준비중...\n1분 정도 소요됩니다.",
    "format": "포맷",
    "frequency": "빈도",
    "game_object": "게임 오브젝트",
    "guid": "GUID",
    "home": "홈",
    "image_format_description": "이는 모든 추출된 이미지에 영향을 미칩니다.",
    "json": "Json",
    "length": "길이",
    "licenses": "라이선스",
    "load": "로드",
    "loading_game_content_from": "{0}에서 게임 콘텐츠 로딩중\n{1}",
    "loading_step_begin_scheme_processing": "시작 프로세스 처리중",
    "loading_step_create_file_collection": "파일 컬렉션 생성",
    "loading_step_load_assemblies": "어셈블리 로딩중",
    "audio_format_default": "기본",
    "audio_format_native_description": "순수 FSB 오디오. 유니티에 넣을 수 없으므로 고급 사용자인 경우에만 사용하세요.",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "bundled_assets_export_group_by_bundle_name": "번들 이름으로 그룹화",
    "bundled_assets_export_group_by_asset_type_description": "번들 에셋이 다른 파일의 에셋과 동일하게 취급됩니다.",
    "bundled_assets_export_title": "번들 에셋 추출 모드",
    "c_sharp_langage_version_config_2": "C# 2",
    "asset_tab_text": "텍스트",
    "bundled_assets_export_group_by_asset_type": "에셋 형식으로 그룹화",
    "asset_tab_audio_pause": "일시 정지",
    "asset_tab_audio": "오디오",
    "audio_format_default_description": "FSB 내에 포함된 콘텐츠 유형으로 에셋을 추출합니다. 대부분 오디오들은 WAV 형식으로 추출되고 일부는 OGG로 내보내집니다.",
    "loading_step_restore_attributes": "생성된 어셈블리 속성 복원"
}

```

`Localizations/nl.json`:

```json
{
    "bundled_assets_export_group_by_asset_type": "Groeperen op Asset Type",
    "bundled_assets_export_group_by_asset_type_description": "Bundled assets worden op dezelfde manier behandeld als assets uit andere bestanden.",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_language_version_config_description": "De C# taalversie die moet worden gebruikt bij het decompileren van scripts.",
    "config_screen_drag_drop_prompt": "Houd er rekening mee dat sommige wijzigingen in de instellingen fouten kunnen veroorzaken of voorkomen.\nZodra je klaar bent, sleep de gamebestand/map naar dit venster, of gebruik het menu linksboven om handmatig iets te openen.",
    "assembly_name": "Assemblynaam",
    "asset_bundle_name": "Asset Bundle Naam",
    "asset_tab_audio": "Geluid",
    "asset_tab_audio_duration_unknown": "<Onbekend>",
    "asset_tab_audio_pause": "Pauzeren",
    "asset_tab_audio_play": "Afspelen",
    "asset_tab_basic": "Basis informatie",
    "asset_tab_development": "Ontwikkeling",
    "asset_tab_hex": "Hex",
    "asset_tab_image": "Afbeelding",
    "asset_tab_information": "Informatie",
    "asset_tab_text": "Tekst",
    "asset_tab_yaml": "YAML",
    "assets": "Assets",
    "audio_clip": "AudioClip",
    "audio_format_default": "Standaard",
    "audio_format_default_description": "Exporteer assets als het inhoudstype dat is ingebed in de FSB. De meeste audiotypen worden geëxporteerd als WAV, sommige worden geëxporteerd als OGG.",
    "audio_format_force_wav": "Converteren naar WAV",
    "audio_format_force_wav_description": "Converteer alle audiobestanden naar WAV bestanden. Niet aanbevolen bij het importeren in Unity, omdat hierdoor bestanden opnieuw kunnen worden gecomprimeerd, waardoor kwaliteitsverlies ontstaat.",
    "audio_format_native": "Rauw",
    "audio_format_native_description": "Rauw FSB Geluid. Kan niet in Unity worden geïmporteerd, dus gebruik dit alleen als je een gevorderde gebruiker bent.",
    "bundle": "Bundle",
    "bundled_assets_export_direct_export_description": "Bundled assets worden zonder groepering geëxporteerd.",
    "bundled_assets_export_group_by_bundle_name": "Groeperen op Bundle Naam",
    "bundled_assets_export_group_by_bundle_name_description": "Bundled assets worden gegroepeerd op basis van de naam van de Asset Bundle.",
    "bundled_assets_export_title": "Bundled Assets Exportmodus",
    "bundles": "Bundles",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "Automatisch - Experimenteel",
    "c_sharp_langage_version_config_auto_safe": "Automatisch - Veilig",
    "c_sharp_langage_version_config_latest": "C# Laatste versie",
    "channels": "Channels",
    "check_log_for_more_details": "Controleer het log bestand voor meer details.",
    "class": "Class",
    "class_id_type_name": "Class ID Type Naam",
    "class_id_type_number": "Class ID Type Nummer",
    "class_name": "Class Naam",
    "collection": "Collection",
    "collections": "Collections",
    "count": "Count",
    "csharp_type": "C# Type",
    "data": "Data",
    "default_version": "Standaardversie",
    "donation_message": "Als u AssetRipper handig vondt of de ontwikkelaar wilt steunen, overweeg dan om te doneren:",
    "enable_prefab_outlining": "Prefab Outlining inschakelen",
    "audio_export_title": "Geluid Exportformaat",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "config_options": "Configuratie Opties",
    "audio_format_yaml": "YAML",
    "audio_format_yaml_description": "Exporteer als een YAML asset en resS bestand. Dit is een veilige optie en een back-up als er iets misgaat.",
    "bundled_assets_export_direct_export": "Directe Export",
    "welcome_title": "Welkom bij AssetRipper"
}

```

`Localizations/pl.json`:

```json
{
    "asset_tab_audio": "Dźwięk",
    "asset_tab_audio_duration_unknown": "<Nieznany>",
    "asset_tab_audio_pause": "Pauza",
    "asset_tab_audio_play": "Graj",
    "asset_tab_basic": "Podstawowe Informacje",
    "asset_tab_image": "Obraz",
    "asset_tab_text": "Tekst",
    "asset_tab_yaml": "YAML",
    "audio_export_title": "Format Eksportu Dźwięku",
    "audio_format_default": "Domyślny",
    "audio_format_default_description": "Eksportuj zasoby jako typ zawartości osadzony w FSB. Większość typów audio jest eksportowana jako WAV, niektóre są eksportowane jako OGG.",
    "audio_format_force_wav": "Konwersja do formatu WAV",
    "audio_format_force_wav_description": "Konwersja wszystkich plików audio do plików WAV. Niezalecane w przypadku importowania do Unity, ponieważ może to spowodować ponowną kompresję plików, powodując utratę jakości.",
    "audio_format_native": "Surowe",
    "audio_format_native_description": "Nieprzetworzony dźwięk FSB. Nie można zaimportować do Unity, więc używaj tego tylko, jeśli jesteś zaawansowanym użytkownikiem.",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "Eksportuj jako zasób yaml i plik resS. Jest to bezpieczna opcja i stanowi kopię zapasową, gdy coś pójdzie nie tak.",
    "bundled_assets_export_direct_export": "Bezpośredni Eksport",
    "bundled_assets_export_direct_export_description": "Zasoby w pakiecie są eksportowane bez grupowania.",
    "bundled_assets_export_group_by_asset_type": "Grupuj Według Typu Zasobów",
    "bundled_assets_export_group_by_asset_type_description": "Zasoby w pakiecie są traktowane tak samo jak zasoby z innych plików.",
    "bundled_assets_export_group_by_bundle_name": "Grupuj Według Nazwy Pakietu",
    "bundled_assets_export_group_by_bundle_name_description": "Zasoby w pakietach są grupowane według nazwy pakietu zasobów.",
    "bundled_assets_export_title": "Tryb Eksportu Zasobów w Pakietach",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "Automatyczne - Eksperymentalne",
    "c_sharp_langage_version_config_auto_safe": "Automatyczne - Bezpieczne",
    "c_sharp_langage_version_config_latest": "Najnowszy C#",
    "c_sharp_language_version_config_description": "Wersja języka C# używana podczas dekompilacji skryptów.",
    "check_log_for_more_details": "Więcej szczegółów w dzienniku",
    "config_options": "Opcje Konfiguracji",
    "config_screen_drag_drop_prompt": "Należy pamiętać, że niektóre zmiany ustawień mogą powodować lub zapobiegać błędom.\nGdy będziesz gotowy, przeciągnij i upuść plik/folder gry do tego okna lub użyj menu w lewym górnym rogu, aby otworzyć coś ręcznie.",
    "enable_prefab_outlining": "Włącz Obrysowanie Prefabów",
    "enable_static_mesh_separation": "Włącz Separację Statycznych Siatek",
    "error": "Błąd",
    "error_exporting_with_reason": "Nie udało się wyeksportować zawartości gry: {0}",
    "error_importing_with_reason": "Nie udało się załadować zawartości gry: {0}",
    "export_complete": "Eksport Zakończony!",
    "export_deleting_old_files": "Czyszczenie istniejących plików...",
    "export_in_progress": "Eksportowanie Plików Zasobów\n{0}%\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "Eksportowanie Plików Zasobów\n0.0%\n?/?",
    "export_preparing": "Przygotowanie do Eksportu...\nMoże to zająć chwilę.",
    "ignore_engine_assets": "Zignoruj Engine Assets",
    "image_export_title": "Format Eksportu Obrazu",
    "image_format_description": "To wpływa na wszystkie wyeksportowane obrazy.",
    "loading_game_content_from": "Ładowanie Zawartości Gry Z {0}\n{1}",
    "loading_step_begin_scheme_processing": "Rozpoczęcie Przetwarzania Schematu",
    "loading_step_create_file_collection": "Tworzenie Kolekcji Plików",
    "loading_step_detect_platform": "Zbieranie Plików i Wykrywanie Struktury Gry",
    "loading_step_generate_dummy_dll": "Generowanie Podzespołów Mono z IL2Cpp",
    "loading_step_initialize_layout": "Inicjowanie Układu Zasobów",
    "loading_step_load_assemblies": "Ładowanie Podzespołów",
    "loading_step_load_assets_from_file": "Ładowanie Zasobów z {0}",
    "loading_step_locate_key_functions": "Skanowanie Pliku Binarnego IL2Cpp w Poszukiwaniu Funkcji Bibliotecznych",
    "loading_step_parse_archive": "Analizowanie Pliku Archiwum {0}",
    "loading_step_parse_bundle": "Analizowanie Pakietu {0}",
    "loading_step_parse_il2cpp_metadata": "Analiza Metadanych IL2Cpp",
    "loading_step_parse_resource": "Analizowanie Pliku Zasobów {0}",
    "loading_step_parse_serialized": "Analizowanie Pliku Serializowanego {0}",
    "loading_step_parse_web": "Analizowanie Pliku Sieci Web {0}",
    "loading_step_pre_processing": "Pliki Wstępnego Przetwarzania",
    "loading_step_restore_attributes": "Przywracanie Atrybutów Wygenerowanych Podzespołów",
    "loose_file_saved_at": "Luźny plik zapisano w {0}",
    "menu_export": "Eksport",
    "menu_export_all": "Eksportuj Wszystkie Pliki",
    "menu_export_selected": "Eksportuj Wybrany Plik",
    "menu_export_selected_type": "Eksportuj wszystkie pliki danego typu",
    "menu_file": "Plik",
    "menu_file_exit": "Wyjdź",
    "menu_file_open_file": "Otwórz Plik",
    "menu_file_open_folder": "Otwórz Folder",
    "menu_file_reset": "Resetuj",
    "menu_language": "Język",
    "mesh_export_title": "Format Eksportu Siatki",
    "mesh_format_glb": "GLB",
    "mesh_format_glb_description": "Wysokiej jakości, open-source'owa alternatywa dla FBX. Binarna wersja GLTF. Zawiera tylko dane siatki. Może powodować błędy. Unity nie może importować zasobów tego typu.",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "Stabilny format do używania siatek w edytorze. Może być konwertowany do innych formatów przez różne pakiety Unity.",
    "no_game_files_found": "W upuszczonych plikach nie znaleziono żadnej gry Unity ani pakietu zasobów.",
    "not_implemented_yet": "Jeszcze Nie Zaimplementowano",
    "script_content_level_0": "Poziom 0",
    "script_content_level_0_description": "Skrypty nie są eksportowane.",
    "script_content_level_1": "Poziom 1",
    "script_content_level_1_description": "Metody są usuwane z dekompilowanego eksportu.",
    "script_content_level_2": "Poziom 2",
    "script_content_level_2_description": "Domyślne. Eksportuje pełne metody dla gier Mono oraz metody zastępcze dla gier IL2Cpp.",
    "script_content_level_3": "Poziom 3",
    "script_content_level_3_description": "Metody IL2Cpp są bezpiecznie odzyskiwane tam, gdzie to możliwe.",
    "script_content_level_4": "Poziom 4",
    "script_content_level_4_description": "Metody IL2Cpp są odzyskiwane bez względu na bezpieczeństwo.",
    "script_content_level_title": "Poziom Zawartości Skryptów",
    "script_export_format_decompiled": "Dekompilacja",
    "script_export_format_decompiled_description": "Dekompilator ILSpy jest używany do generowania skryptów CS. Jest on niezawodny. Jest jednak czasochłonny i zawiera wiele błędów kompilacji.",
    "script_export_format_dll_with_renaming": "Eksport Dll Ze Zmianą Nazw",
    "script_export_format_dll_without_renaming": "Eksport Dll Bez Zmiany Nazw",
    "script_export_format_dll_without_renaming_description": "Podzespoły są eksportowane w postaci skompilowanych plików Dll. Unity prawdopodobnie nadpisze specjalne podzespoły, takie jak Assembly-CSharp.",
    "script_export_format_hybrid": "Hybrydowy",
    "script_export_title": "Format Eksportu Skryptu",
    "script_language_version_title": "Wersja języka C#",
    "select_asset_to_view_info": "Wybierz zasób po lewej stronie, aby wyświetlić informacje na jego temat",
    "shader_asset_export_title": "Format Eksportu Shadera",
    "shader_asset_format_decompile": "Dekompilacja",
    "shader_asset_format_decompile_description": "Eksportuj shader do ShaderLab. Bardzo eksperymentalne i prawie na pewno będzie zawierał błędy. Obsługuje tylko DX11, nie DX9.",
    "shader_asset_format_disassembly": "Demontaż",
    "shader_asset_format_disassembly_description": "Eksportuj shader jako disassembly. Eksperymentalne i podatne na uszkodzenia. Nie kompiluje się w edytorze.",
    "shader_asset_format_dummy": "Shader Zastępczy",
    "shader_asset_format_dummy_description": "Eksportuj shader jako shader zastępczy. Chociaż zachowuje dane, takie jak właściwości i fallback, używa ogólnego, nieprzezroczystego kodu shaderów.",
    "shader_asset_format_yaml": "Zasoby Yaml",
    "shader_asset_format_yaml_description": "Eksportuj shader jako zasób yaml. Eksperymentalne i nadaje się tylko do przeglądania w edytorze. Edytor może losowo uszkodzić te pliki.",
    "skip_streaming_assets": "Pomiń Folder StreamingAssets",
    "sprite_export_title": "Format Eksportu Sprite'a",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Eksportuj używając formatu sprite'ów Unity. Nie może być wyświetlany poza Unity.",
    "sprite_format_texture": "Tekstury",
    "sprite_format_texture_description": "Eksportuj jako obraz zestawu sprite'ów. Może być oglądany poza Unity, ale wolniej eksportowany.",
    "sprite_format_yaml": "Yaml",
    "sprite_format_yaml_description": "Eksportuj jako zasoby yaml, które można przeglądać w edytorze. Jest to jedyny tryb, który zapewnia dokładne odzyskanie wszystkich metadanych sprite'ów.",
    "success": "Sukces!",
    "terrain_export_title": "Format Eksportu Terenu",
    "terrain_format_heatmap": "Mapa wysokości",
    "terrain_format_heatmap_description": "Eksportuj mapę cieplną wysokości terenu w każdej lokalizacji. Przydatne tylko wtedy, gdy nie zależy ci na szczegółach lub posiadaniu terenu w 3D.",
    "terrain_format_mesh": "Siatka 3D",
    "terrain_format_mesh_description": "Eksportuj teren jako siatkę 3D w formacie GLB, odpowiednią do wyświetlania w szerokiej gamie edytorów 3D.",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "Eksportuj w natywnym formacie terenu Unity. Najbardziej przydatna opcja, jeśli planujesz ponowny import do Unity.",
    "text_asset_export_title": "Format Eksportu Zasobu Tekstu",
    "text_asset_format_binary": "Bajtów",
    "text_asset_format_binary_description": "Eksportuj surowe dane zasobu tekstowego jako plik BYTES.",
    "text_asset_format_parse": "Analizuj",
    "text_asset_format_parse_description": "Eksportuj jako zwykły plik tekstowy, ale spróbuj odgadnąć prawidłowe rozszerzenie pliku (np. pliki JSON otrzymują rozszerzenie .json).",
    "text_asset_format_text": "Zwykły Tekst",
    "text_asset_format_text_description": "Eksportuj jako zwykły plik tekstowy (.txt).",
    "welcome_title": "Witaj w AssetRipper",
    "c_sharp_langage_version_config_13_0": "C# 13",
    "c_sharp_langage_version_config_14_0": "C# 14",
    "assembly_name": "Nazwa Podzespołu",
    "asset_bundle_name": "Nazwa Pakietu Zasobów",
    "c_sharp_langage_version_config_12_0": "C# 12",
    "class": "Klasa",
    "appreciation_message": "Dziękujemy za wsparcie AssetRipper!",
    "asset_ripper_free": "Darmowy AssetRipper",
    "an_error_occured_during_decompilation": "Wystąpił błąd podczas dekompilacji.",
    "asset_ripper_premium": "AssetRipper Premium",
    "asset_tab_font": "Czcionka",
    "asset_tab_hex": "Hex",
    "asset_tab_information": "Informacja",
    "assets": "Zasoby",
    "asset_tab_development": "Rozwój",
    "audio_clip": "Klip Dźwiękowy",
    "asset_tab_video": "Wideo",
    "asset_tab_model": "Model",
    "all": "Wszystko",
    "asset_tab_dependencies": "Zależności",
    "bundles": "Pakiety",
    "channels": "Kanały",
    "override_path": "Nadpisz Ścieżkę",
    "file_id": "ID Pliku",
    "main_asset": "Główny Zasób",
    "script": "Skrypt",
    "scene": "Scena",
    "save": "Zapisz",
    "not_available_in_the_free_edition": "Niedostępne w darmowej wersji.",
    "save_raw_data": "Zapisz Surowe Dane",
    "save_settings_to_disk": "Zapisz Ustawienia na Dysk",
    "menu_load": "Załaduj",
    "export_directory_delete_user_confirmation": "Wybrany katalog eksportu już istnieje, a cała jego zawartość zostanie usunięta. Czy na pewno chcesz kontynuować?",
    "install_unity_editor": "Zainstaluj Edytor Unity",
    "install_unity_hub": "Zainstaluj Unity Hub",
    "lightmap_texture_export_title": "Format Eksportu Mapy Świateł",
    "menu_development": "Rozwój",
    "menu_view": "Widok",
    "not_supported": "Nie Wspierane",
    "namespace": "Przestrzeń Nazw",
    "no_data_has_been_loaded_for_this_key": "Nie załadowano danych dla tego klucza.",
    "no_files_loaded": "Nie Załadowano Żadnych Plików",
    "no_meshes_found": "Nie Znaleziono Żadnej Siatki",
    "no_shaders_found": "Nie Znaleziono Żadnego Shadera",
    "no_static_meshes_found": "Nie Znaleziono Żadnej Statycznej Siatki",
    "premium_features": "Funkcje Premium",
    "failed_files": "Błędne Pliki",
    "load": "Załaduj",
    "menu_import": "Importuj",
    "parent": "Rodzic",
    "privacy": "Prywatność",
    "path": "Ścieżka",
    "path_id": "ID Ścieżki",
    "premium_feature_notice": "Funkcja premium",
    "class_id_type_name": "Nazwa Typu ID Klasy",
    "data": "Dane",
    "csharp_type": "Typ C#",
    "guid": "GUID",
    "height": "Wysokość",
    "home": "Dom",
    "experimental": "Eksperymentalne",
    "format": "Format",
    "game_object": "Obiekt Gry",
    "frequency": "Częstotliwość",
    "json": "Json",
    "lightmap_texture_format_description": "To wpływa na wszystkie wyeksportowane mapy świateł.",
    "name": "Nazwa",
    "collection": "Kolekcja",
    "collections": "Kolekcje",
    "commands": "Komendy",
    "configuration_files": "Pliki Konfiguracyjne",
    "configuration_files_lists": "Listy",
    "configuration_files_singletons": "Singletony",
    "count": "Liczba",
    "create_subfolder": "Stwórz Podfolder",
    "bundle": "Pakiet",
    "class_id_type_number": "Numer Typu ID Klasy",
    "donation_message": "Jeśli podoba Ci się AssetRipper, rozważ wsparcie projektu darowizną:",
    "enable_asset_deduplication": "Włącz Deduplikację Zasobów",
    "export_unreadable_assets": "Eksportuj Nieczytelne Zasoby",
    "filter": "Filtr",
    "class_name": "Nazwa Klasy",
    "default_version": "Domyślna Wersja",
    "original_path": "Oryginalna Ścieżka",
    "replace": "Zamień",
    "open_api_json": "OpenAPI JSON",
    "resources": "Zasoby Dynamiczne",
    "export_primary_content": "Eksportuj Podstawową Zawartość",
    "export_unity_project": "Eksportuj Projekt Unity",
    "length": "Długość",
    "licenses": "Licencje",
    "mesh": "Siatka",
    "stack_trace": "Ślad Stosu",
    "target_version_for_version_changing": "Docelowa Wersja Do Zmiany Wersji",
    "texture": "Tekstura",
    "vertex_count": "Liczba Wierzchołków",
    "transform": "Przekształcenie",
    "view_loaded_files": "Pokaż Załadowane Pliki",
    "welcome": "Witaj",
    "yaml": "Yaml",
    "scripts_use_fully_qualified_type_names": "Skrypty używają w pełni kwalifikowanych nazw typów",
    "swagger_documentation": "Dokumentacja Swaggera",
    "static_mesh_separation": "Separacja Statycznej Siatki",
    "shader_decompilation": "Dekompilacja Shadera",
    "supported": "Wspierane",
    "remove": "Usuń",
    "select_file": "Wybierz Plik",
    "size": "Rozmiar",
    "select_folder": "Wybierz Folder",
    "submesh_count": "Liczba Podsiatek",
    "there_are_no_keys_for_this_data_type": "Nie ma kluczy dla tego typu danych.",
    "warning_this_directory_is_not_empty_all_content_will_be_deleted": "Ostrzeżenie: ten katalog nie jest pusty. Cała zawartość zostanie usunięta.",
    "script_export_format_hybrid_description": "Specjalne podzespoły, takie jak Assembly-CSharp, są dekompilowane. Pozostałe podzespoły są eksportowane w postaci skompilowanych plików Dll.",
    "publicize_assemblies": "Upublicznij Podzespoły",
    "remove_nullable_attributes": "Usuń Atrybuty Nullable",
    "select_files": "Wybierz Pliki",
    "select_folders": "Wybierz Foldery",
    "settings": "Ustawienia",
    "shader": "Shader",
    "settings_can_only_be_changed_before_loading_files": "Ustawienia mogą zostać zmienione tylko przed załadowaniem plików.",
    "width": "Szerokość"
}

```

`Localizations/pt_BR.json`:

```json
{
    "an_error_occured_during_decompilation": "Um erro ocorreu durante a descompilação.",
    "assembly_name": "Nome do Assembly",
    "asset_bundle_name": "Nome do Pacote de Asset",
    "asset_ripper_free": "AssetRipper Gratuito",
    "asset_ripper_premium": "AssetRipper Premium",
    "asset_tab_audio": "Áudio",
    "asset_tab_audio_duration_unknown": "<Desconhecido>",
    "asset_tab_audio_pause": "Pausar",
    "asset_tab_audio_play": "Reproduzir",
    "asset_tab_basic": "Informações Básicas",
    "asset_tab_dependencies": "Dependências",
    "asset_tab_development": "Desenvolvimento",
    "asset_tab_font": "Fonte",
    "asset_tab_hex": "Hex",
    "asset_tab_image": "Imagem",
    "asset_tab_information": "Informação",
    "asset_tab_text": "Texto",
    "asset_tab_yaml": "Yaml",
    "assets": "Assets",
    "audio_clip": "AudioClip",
    "audio_export_title": "Formato de Exportação de Áudio",
    "audio_format_default": "Padrão",
    "audio_format_default_description": "Exporta assets como o tipo de conteúdo embutido dentro do FSB. A maioria dos tipos de áudio são exportados como WAV, alguns como OGG.",
    "audio_format_force_wav": "Converter para WAV",
    "audio_format_force_wav_description": "Converte todos os arquivos de áudio para arquivos WAV. Não recomendado ao importar na Unity, pois pode recomprimir arquivos, causando perda de qualidade.",
    "audio_format_native": "Bruto",
    "audio_format_native_description": "Áudio FSB bruto. Não pode ser importado na Unity, então use apenas se você for um usuário avançado.",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "Exporta como um asset yaml e arquivo resS. Esta é uma opção segura e serve como backup quando as coisas dão errado.",
    "bundle": "Pacote",
    "bundled_assets_export_direct_export": "Exportação Direta",
    "bundled_assets_export_direct_export_description": "Assets empacotados são exportados sem agrupamento.",
    "bundled_assets_export_group_by_asset_type": "Agrupar por Tipo de Asset",
    "bundled_assets_export_group_by_asset_type_description": "Assets empacotados são tratados da mesma forma que assets de outros arquivos.",
    "bundled_assets_export_group_by_bundle_name": "Agrupar por Nome do Pacote",
    "bundled_assets_export_group_by_bundle_name_description": "Assets empacotados são agrupados pelo nome de seu pacote de assets.",
    "bundled_assets_export_title": "Modo de Exportação de Assets Empacotados",
    "bundles": "Pacotes",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "Automático - Experimental",
    "c_sharp_langage_version_config_auto_safe": "Automático - Seguro",
    "c_sharp_langage_version_config_latest": "C# Mais Recente",
    "c_sharp_language_version_config_description": "A versão da linguagem C# que será utilizada ao descompilar scripts.",
    "channels": "Canais",
    "check_log_for_more_details": "Verifique o log para mais detalhes",
    "class": "Classe",
    "class_id_type_name": "Nome do Tipo de ID da Classe",
    "class_id_type_number": "Número do Tipo de ID de Classe",
    "class_name": "Nome da Classe",
    "collection": "Coleção",
    "collections": "Coleções",
    "commands": "Comandos",
    "config_options": "Opções de Configuração",
    "config_screen_drag_drop_prompt": "Por favor, observe que algumas alterações nas configurações podem causar ou prevenir erros.\nQuando estiver pronto, arraste e solte o arquivo/pasta do seu jogo nesta janela, ou use o menu no canto superior esquerdo para abrir manualmente.",
    "count": "Contagem",
    "csharp_type": "Tipo do C#",
    "data": "Dados",
    "default_version": "Versão Padrão",
    "donation_message": "Se você gosta do AssetRipper, por favor, considere fazer uma doação:",
    "enable_prefab_outlining": "Ativar Contorno de Prefab",
    "enable_static_mesh_separation": "Ativar Separação de Malha Estática",
    "error": "Erro",
    "error_exporting_with_reason": "Falha ao exportar conteúdo do jogo: {0}",
    "error_importing_with_reason": "Falha ao carregar conteúdo do jogo: {0}",
    "export_complete": "Exportação Concluída!",
    "export_deleting_old_files": "Excluindo arquivos existentes...",
    "export_in_progress": "Exportando Arquivos dos Assets\n{0}%\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "Exportando Arquivos dos Assets\n0.0%\n?/?",
    "export_preparing": "Preparando para Exportar...\nIsso pode levar um minuto.",
    "format": "Formato",
    "frequency": "Frequência",
    "game_object": "GameObject",
    "guid": "GUID",
    "height": "Altura",
    "home": "Início",
    "ignore_engine_assets": "Ignorar Assets da Engine",
    "image_export_title": "Formato de Exportação de Imagem",
    "image_format_description": "Isso afeta todas as imagens exportadas.",
    "json": "Json",
    "length": "Comprimento",
    "licenses": "Licenças",
    "loading_game_content_from": "Carregando Conteúdo do Jogo de {0}\n{1}",
    "loading_step_begin_scheme_processing": "Iniciando Processamento do Esquema",
    "loading_step_create_file_collection": "Criando Coleção de Arquivos",
    "loading_step_detect_platform": "Coletando Arquivos e Detectando a Estrutura do Jogo",
    "loading_step_generate_dummy_dll": "Gerando Assemblies Mono a Partir do IL2Cpp",
    "loading_step_initialize_layout": "Inicializando Layout do Asset",
    "loading_step_load_assemblies": "Carregando Assemblies",
    "loading_step_load_assets_from_file": "Carregando Assets de {0}",
    "loading_step_locate_key_functions": "Escaneando o Binário IL2Cpp para Funções da Biblioteca",
    "loading_step_parse_archive": "Analisando Arquivo {0}",
    "loading_step_parse_bundle": "Analisando Pacote {0}",
    "loading_step_parse_il2cpp_metadata": "Analisando Metadados IL2Cpp",
    "loading_step_parse_resource": "Analisando Arquivo de Recursos {0}",
    "loading_step_parse_serialized": "Analisando Arquivo Serializado {0}",
    "loading_step_parse_web": "Analisando Arquivo Web {0}",
    "loading_step_pre_processing": "Pré-processando Arquivos",
    "loading_step_restore_attributes": "Restaurando Atributos nos Assemblies Gerados",
    "loose_file_saved_at": "Arquivo solto salvo em {0}",
    "main_asset": "Asset Principal",
    "menu_export": "Exportar",
    "menu_export_all": "Exportar Todos os Arquivos",
    "menu_export_selected": "Exportar Arquivo Selecionado",
    "menu_export_selected_type": "Exportar Todos os Arquivos do Tipo Selecionado",
    "menu_file": "Arquivo",
    "menu_file_exit": "Sair",
    "menu_file_open_file": "Abrir Arquivo",
    "menu_file_open_folder": "Abrir Pasta",
    "menu_file_reset": "Redefinir",
    "menu_language": "Idioma",
    "menu_load": "Carregar",
    "mesh": "Malha",
    "mesh_export_title": "Formato de Exportação de Malha",
    "mesh_format_glb": "GLB",
    "mesh_format_glb_description": "Uma alternativa de alta qualidade e de código aberto ao FBX. Versão binária do GLTF. Contém apenas dados de malha. Pode causar erros. A Unity não pode importar assets deste tipo.",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "Um formato robusto para usar malhas no editor. Pode ser convertido para outros formatos por uma variedade de pacotes da Unity.",
    "name": "Nome",
    "namespace": "Namespace",
    "no_files_loaded": "Nenhum Arquivo Carregado",
    "no_game_files_found": "Nenhum jogo Unity ou pacote de asset foi encontrado nos arquivos fornecidos.",
    "not_implemented_yet": "Ainda Não Implementado",
    "original_path": "Caminho Original",
    "parent": "Pai",
    "path": "Caminho",
    "path_id": "ID do Caminho",
    "privacy": "Privacidade",
    "resources": "Recursos",
    "save": "Salvar",
    "scene": "Cena",
    "script": "Script",
    "script_content_level_0": "Nível 0",
    "script_content_level_0_description": "Scripts não são exportados.",
    "script_content_level_1": "Nível 1",
    "script_content_level_1_description": "Métodos são removidos da exportação descompilada.",
    "script_content_level_2": "Nível 2",
    "script_content_level_2_description": "Padrão. Exporta métodos completos para jogos Mono e métodos fictícios para jogos IL2Cpp.",
    "script_content_level_3": "Nível 3",
    "script_content_level_3_description": "Métodos IL2Cpp são recuperados com segurança sempre que possível.",
    "script_content_level_4": "Nível 4",
    "script_content_level_4_description": "Métodos IL2Cpp são recuperados sem consideração à segurança.",
    "script_content_level_title": "Nível de Conteúdo do Script",
    "script_export_format_decompiled": "Descompilação",
    "script_export_format_decompiled_description": "O descompilador ILSpy é usado para gerar scripts CS. É confiável. No entanto, também é demorado e contém muitos erros de compilação.",
    "script_export_format_dll_with_renaming": "Exportar DLL com Renomeação",
    "script_export_format_dll_without_renaming": "Exportar DLL sem Renomeação",
    "script_export_format_dll_without_renaming_description": "Assemblies são exportados em sua forma compilada de DLL. A Unity provavelmente substituirá assemblies especiais como Assembly-CSharp.",
    "script_export_format_hybrid": "Híbrido",
    "script_export_format_hybrid_description": "Assemblies especiais como Assembly-CSharp são descompilados. Outros assemblies são exportados em sua forma compilada de DLL.",
    "script_export_title": "Formato de Exportação de Script",
    "script_language_version_title": "Versão da Linguagem C#",
    "select_asset_to_view_info": "Selecione um asset à esquerda para ver informações sobre ele",
    "settings": "Configurações",
    "settings_can_only_be_changed_before_loading_files": "As configurações só podem ser alteradas antes de carregar arquivos.",
    "shader": "Shader",
    "shader_asset_export_title": "Formato de Exportação de Shader",
    "shader_asset_format_decompile": "Descompilação",
    "shader_asset_format_decompile_description": "Exporta o shader para ShaderLab. Muito experimental e quase certamente terá erros. Suporta apenas DX11, não DX9.",
    "shader_asset_format_disassembly": "Desmontagem",
    "shader_asset_format_disassembly_description": "Exporta o shader como desmontagem. Experimental e suscetível a falhas. Não compilará no editor.",
    "shader_asset_format_dummy": "Shader Fictício",
    "shader_asset_format_dummy_description": "Exporta o shader como um shader fictício. Embora preserve dados como propriedades e fallback, ele utiliza código de shader geral e opaco.",
    "shader_asset_format_yaml": "Asset Yaml",
    "shader_asset_format_yaml_description": "Exporta o shader como um asset yaml. Experimental e apenas utilizável para visualização no editor. O editor pode corromper aleatoriamente esses arquivos.",
    "skip_streaming_assets": "Pular Pasta StreamingAssets",
    "sprite_export_title": "Formato de Exportação de Sprite",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Exporta no formato de sprite da Unity. Não pode ser visualizado fora da Unity.",
    "sprite_format_texture": "Textura",
    "sprite_format_texture_description": "Exporta como uma imagem da folha de sprites. Pode ser visualizado fora do Unity, mas é mais lento para exportar.",
    "sprite_format_yaml": "Yaml",
    "sprite_format_yaml_description": "Exporta como assets yaml que podem ser visualizados no editor. Este é o único modo que garante uma recuperação precisa de todos os metadados dos sprites.",
    "submesh_count": "Contagem de Submalha",
    "success": "Sucesso!",
    "terrain_export_title": "Formato de Exportação de Terreno",
    "terrain_format_heatmap": "Mapa de Altura",
    "terrain_format_heatmap_description": "Exporta um mapa de calor da altura do terreno em cada localização. Apenas realmente útil se você não se importar com os detalhes ou de ter o terreno em 3D.",
    "terrain_format_mesh": "Malha 3D",
    "terrain_format_mesh_description": "Exporta o terreno como uma malha 3D no formato GLB, adequado para visualização com uma ampla variedade de editores 3D.",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "Exporta no formato nativo de terreno da Unity. Opção mais útil se planeja reimportar de volta para a Unity.",
    "text_asset_export_title": "Formato de Exportação de TextAsset",
    "text_asset_format_binary": "Bytes",
    "text_asset_format_binary_description": "Exporta os dados brutos do asset de texto como um arquivo BYTES.",
    "text_asset_format_parse": "Analisar",
    "text_asset_format_parse_description": "Exporta como um arquivo de texto simples, mas tenta adivinhar a extensão de arquivo correta (por exemplo, arquivos JSON recebem a extensão .json).",
    "text_asset_format_text": "Texto Simples",
    "text_asset_format_text_description": "Exporta como um arquivo de texto simples (.txt).",
    "texture": "Textura",
    "transform": "Transformação",
    "vertex_count": "Contagem de Vértices",
    "view_loaded_files": "Ver Arquivos Carregados",
    "welcome": "Bem-vindo",
    "welcome_title": "Bem-vindo ao AssetRipper",
    "width": "Largura",
    "yaml": "Yaml",
    "stack_trace": "Rastreamento de Pilha",
    "target_version_for_version_changing": "Versão de Destino para Alteração de Versão",
    "override_path": "Substituir Caminho",
    "file_id": "ID do Arquivo",
    "remove": "Remover",
    "replace": "Substituir",
    "save_settings_to_disk": "Salvar Configurações No Disco",
    "lightmap_texture_export_title": "Formato de Exportação da Textura Lightmap",
    "lightmap_texture_format_description": "Isso afeta todas as texturas lightmap exportadas.",
    "select_file": "Selecionar Arquivo",
    "failed_files": "Arquivos com Falha",
    "premium_feature_notice": "Recurso premium",
    "save_raw_data": "Salvar Dados Brutos",
    "swagger_documentation": "Documentação Swagger",
    "c_sharp_langage_version_config_12_0": "C# 12",
    "enable_asset_deduplication": "Ativar Desduplicação de Assets",
    "experimental": "Funcionalidade Experimental",
    "no_data_has_been_loaded_for_this_key": "Nenhum dado foi carregado para esta chave.",
    "appreciation_message": "Obrigado por apoiar o AssetRipper!",
    "asset_tab_video": "Vídeo",
    "menu_import": "Importar",
    "menu_view": "Visualização",
    "select_folder": "Selecionar Pasta",
    "size": "Tamanho",
    "asset_tab_model": "Modelo",
    "create_subfolder": "Criar Subpasta",
    "load": "Carregar",
    "configuration_files": "Arquivos de Configuração",
    "configuration_files_lists": "Listas",
    "configuration_files_singletons": "Instâncias Únicas",
    "open_api_json": "API Aberta em JSON",
    "publicize_assemblies": "Tornar Assemblies Públicos",
    "remove_nullable_attributes": "Remover Atributos Anuláveis",
    "scripts_use_fully_qualified_type_names": "Os scripts usam nomes de tipos totalmente qualificados",
    "select_files": "Selecionar Arquivos",
    "not_available_in_the_free_edition": "Não disponível na edição gratuita.",
    "select_folders": "Selecionar Pastas",
    "there_are_no_keys_for_this_data_type": "Não há chaves para esse tipo de dados.",
    "warning_this_directory_is_not_empty_all_content_will_be_deleted": "Atenção: este diretório não está vazio. Todo o conteúdo será excluído.",
    "export_primary_content": "Exportar Conteúdo Principal",
    "export_unity_project": "Exportar Projeto Unity"
}

```

`Localizations/ro.json`:

```json
{
    "asset_tab_audio": "Audio",
    "asset_tab_audio_duration_unknown": "<Necunoscut>",
    "lightmap_texture_export_title": "Format de export textură lightmap",
    "lightmap_texture_format_description": "Aceasta afectează toate texturile lightmap exportate.",
    "loading_step_create_file_collection": "Creare colecție de fișiere",
    "loading_step_initialize_layout": "Inițializare aspect resurse",
    "loading_step_load_assets_from_file": "Încărcare resurse din {0}",
    "loading_step_parse_archive": "Analizare fișier arhivă {0}",
    "loading_step_parse_bundle": "Analizare pachet {0}",
    "loading_step_parse_il2cpp_metadata": "Analizare metadata IL2Cpp",
    "loading_step_parse_resource": "Analizare fișier resurse {0}",
    "loading_step_parse_serialized": "Analizare fișier serializat {0}",
    "loading_step_parse_web": "Analizare fișier web {0}",
    "loading_step_pre_processing": "Preprocesare fișiere",
    "main_asset": "Resursa principală",
    "menu_export": "Exportă",
    "menu_export_all": "Exportă toate fișierele",
    "menu_export_selected": "Exportă fișierele selectate",
    "menu_file": "Fișiere",
    "menu_file_exit": "Ieșire",
    "menu_file_open_file": "Deschide fișierul",
    "menu_file_open_folder": "Deschide folderul",
    "menu_file_reset": "Resetează",
    "menu_import": "Importă",
    "menu_load": "Încarcă",
    "menu_view": "Vizualizare",
    "mesh": "Mesh",
    "mesh_export_title": "Format de Exportare Mesh",
    "mesh_format_glb": "GLB",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "Un format robust pentru utilizarea mesh-urilor în editor. Poate fi convertit în alte formate printr-o varietate de pachete Unity.",
    "name": "Nume",
    "no_data_has_been_loaded_for_this_key": "Nu s-au încărcat date pentru această cheie.",
    "no_files_loaded": "Niciun fișier încărcat",
    "not_implemented_yet": "Nu este încă implementat",
    "original_path": "Calea originală",
    "parent": "Părinte",
    "path": "Cale",
    "path_id": "ID Cale",
    "privacy": "Confidențialitate",
    "remove": "Elimină",
    "replace": "Înlocuiește",
    "resources": "Resurse",
    "loading_step_load_assemblies": "Încărcare Assemblies",
    "loading_step_restore_attributes": "Restaurare atributelor Assembli generate",
    "namespace": "Spațiu de nume",
    "save_raw_data": "Salvează date brute",
    "save_settings_to_disk": "Salvează setările pe disc",
    "scene": "Scenă",
    "script": "Script",
    "script_content_level_0": "Nivel 0",
    "script_content_level_1": "Nivel 1",
    "script_content_level_1_description": "Metodele sunt eliminate din exportul decompilat.",
    "script_content_level_2": "Nivel 2",
    "script_content_level_3": "Nivel 3",
    "script_content_level_3_description": "Metodele IL2Cpp sunt recuperate în siguranță acolo unde este posibil.",
    "script_content_level_4": "Nivel 4",
    "script_content_level_4_description": "Metodele IL2Cpp sunt recuperate fără a ține cont de siguranță.",
    "script_content_level_title": "Nivel de Conținut al Scriptului",
    "script_export_format_decompiled": "Decompilare",
    "script_export_format_dll_with_renaming": "Export DLL cu redenumire",
    "script_export_format_dll_without_renaming": "Export DLL fără redenumire",
    "script_export_format_hybrid": "Hibrid",
    "script_export_title": "Format de Export al Scriptului",
    "script_language_version_title": "Versiune Limbaj C#",
    "select_file": "Selectează fișier",
    "select_folder": "Selectează folder",
    "settings": "Setări",
    "size": "Dimensiune",
    "sprite_format_texture": "Textură",
    "submesh_count": "Număr Submesh-uri",
    "success": "Succes!",
    "target_version_for_version_changing": "Versiune Țintă pentru Schimbarea Versiunii",
    "terrain_export_title": "Format de Export Terrain",
    "terrain_format_heatmap": "Heightmap",
    "terrain_format_heatmap_description": "Exportă un heatmap al înălțimii terenului la fiecare locație. Util numai dacă nu îți pasă de detalii sau de a avea terenul în 3D.",
    "terrain_format_mesh": "Mesh 3D",
    "terrain_format_mesh_description": "Exportă terenul ca un mesh 3D în format GLB, potrivit pentru vizualizare cu o gamă largă de editoare 3D.",
    "text_asset_export_title": "Format de Export TextAsset",
    "script_export_format_hybrid_description": "Asamblările speciale, cum ar fi Assembly-CSharp, sunt decompilate. Alte asamblări sunt exportate în forma lor compilată DLL.",
    "text_asset_format_binary": "Bytes",
    "text_asset_format_binary_description": "Exportă datele brute ale asset-ului de text ca fișier BYTES.",
    "text_asset_format_parse_description": "Exportă ca fișier text simplu, dar încearcă să ghicească extensia corectă a fișierului (de exemplu, fișierele JSON primesc extensia .json).",
    "text_asset_format_text": "Text Simplu",
    "text_asset_format_text_description": "Exportă ca fișier text simplu (.txt).",
    "texture": "Textură",
    "there_are_no_keys_for_this_data_type": "Nu există chei pentru acest tip de date.",
    "vertex_count": "Număr Vertex-uri",
    "warning_this_directory_is_not_empty_all_content_will_be_deleted": "Atenție: acest director nu este gol. Tot conținutul va fi șters.",
    "welcome": "Salut",
    "yaml": "Yaml",
    "text_asset_format_parse": "Analiza",
    "transform": "Transform",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Exportă în formatul sprite Unity. Nu poate fi vizualizat în afara Unity.",
    "settings_can_only_be_changed_before_loading_files": "Setările pot fi schimbate doar înainte de încărcarea fișierelor.",
    "shader": "Shader",
    "shader_asset_export_title": "Format de Export Shader",
    "shader_asset_format_decompile": "Decompilare",
    "shader_asset_format_decompile_description": "Exportă shader-ul în ShaderLab. Foarte experimental și aproape cu siguranță va avea erori. Suportă doar DX11, nu DX9.",
    "shader_asset_format_disassembly_description": "Exportă shader-ul ca disassembly. Experimental și predispus la defecțiuni. Acesta nu se compilează în editor.",
    "shader_asset_format_disassembly": "Disassembly",
    "shader_asset_format_dummy": "Shader Fals",
    "shader_asset_format_dummy_description": "Exportă shader-ul ca shader fals. Deși păstrează date precum proprietățile și fallback-ul, folosește cod shader general și opac.",
    "shader_asset_format_yaml": "Asset Yaml",
    "shader_asset_format_yaml_description": "Exportă shader-ul ca asset yaml. Experimental și utilizabil doar pentru vizualizare în editor. Editorul poate corupe aleatoriu aceste fișiere.",
    "skip_streaming_assets": "Omitere folder StreamingAssets",
    "sprite_export_title": "Format de Export Sprite",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "\"Exportă în formatul nativ Unity pentru teren. Opțiunea cea mai utilă dacă intenționezi să reimporti în Unity.",
    "asset_bundle_name": "Numele pachetului de resurse",
    "asset_tab_development": "Dezvoltare",
    "assembly_name": "Numele Assembly",
    "bundle": "Pachet",
    "bundled_assets_export_direct_export": "Export direct",
    "bundled_assets_export_direct_export_description": "Resursele grupate sunt exportate fără a fi grupate.",
    "bundled_assets_export_group_by_asset_type": "Grupare după tipul resursei",
    "bundles": "Pachete",
    "appreciation_message": "Îți mulțumim pentru că susții AssetRipper!",
    "asset_ripper_free": "AssetRipper Gratuit",
    "asset_ripper_premium": "AssetRipper Premium",
    "asset_tab_audio_pause": "Pauză",
    "asset_tab_audio_play": "Redare",
    "asset_tab_dependencies": "Dependențe",
    "asset_tab_font": "Font",
    "asset_tab_hex": "Hex",
    "asset_tab_image": "Imagine",
    "asset_tab_information": "Informație",
    "asset_tab_text": "Text",
    "assets": "Resurse",
    "audio_clip": "Clip Audio",
    "audio_export_title": "Format de export audio",
    "audio_format_default": "Normal",
    "audio_format_force_wav": "Conversie în WAV",
    "audio_format_force_wav_description": "Convertește toate fișierele audio în fișiere WAV. Nu este recomandat pentru import în Unity, deoarece poate recomprima fișierele, cauzând pierderi de calitate.",
    "audio_format_native": "Brut",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "Exportă ca resursă yaml și fișier resS. Aceasta este o opțiune sigură și este soluția de rezervă când lucrurile merg prost.",
    "bundled_assets_export_group_by_asset_type_description": "Resursele grupate sunt tratate la fel ca resursele din alte fișiere.",
    "bundled_assets_export_group_by_bundle_name": "Grupare după numele pachetului",
    "bundled_assets_export_title": "Mod de export al resurselor grupate",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "Automat - Experimental",
    "c_sharp_langage_version_config_auto_safe": "Automat - Sigur",
    "c_sharp_langage_version_config_latest": "C# Ultima versiune",
    "channels": "Canale",
    "check_log_for_more_details": "Verifică jurnalul pentru mai multe detalii",
    "class_id_type_number": "Număr Tip ID Clasă",
    "class_name": "Nume Clasă",
    "collection": "Colecție",
    "collections": "Colecții",
    "commands": "Comenzi",
    "config_options": "Opțiuni de configurare",
    "configuration_files": "Configurare Fișiere",
    "configuration_files_lists": "Liste",
    "count": "Număr",
    "csharp_type": "Tip C#",
    "data": "Date",
    "default_version": "Versiune implicită",
    "donation_message": "Dacă îți place AssetRipper, te rugăm să iei în considerare o donație:",
    "enable_asset_deduplication": "Activează deduplicarea resurselor",
    "enable_prefab_outlining": "Activează conturarea prefaburilor",
    "error": "Eroare",
    "error_exporting_with_reason": "Nu s-a reușit exportul conținutului jocului: {0}",
    "error_importing_with_reason": "Nu s-a reușit încărcarea conținutului jocului: {0}",
    "experimental": "Experimental",
    "export_complete": "Export Complet!",
    "export_in_progress": "Exportare Fișiere Resurse\n{0}%\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "Exportare Fișiere Resurse\n0.0%\n?/?",
    "export_preparing": "Pregătire pentru export...\nAcest lucru poate dura un minut.",
    "format": "Format",
    "frequency": "Frecvență",
    "game_object": "GameObject",
    "guid": "GUID",
    "height": "Înălțime",
    "home": "Acasă",
    "image_export_title": "Format de export imagine",
    "image_format_description": "Aceasta afectează toate imaginile exportate.",
    "json": "Json",
    "length": "Lungime",
    "licenses": "Licențe",
    "load": "Încarcă",
    "loading_game_content_from": "Încărcare conținut joc din {0}\n{1}",
    "an_error_occured_during_decompilation": "A apărut o eroare în timpul decompilării.",
    "class": "Clasă",
    "class_id_type_name": "Nume Tip ID Clasă",
    "audio_format_default_description": "Exportă resursele ca tipul de conținut încorporat în FSB. Majoritatea tipurilor de audio sunt exportate ca WAV, unele sunt exportate ca OGG.",
    "audio_format_native_description": "Audio FSB brut. Nu poate fi importat în Unity, deci folosiți doar dacă sunteți un utilizator avansat.",
    "width": "Lățime",
    "bundled_assets_export_group_by_bundle_name_description": "Resursele grupate sunt grupate după numele pachetului de resurse.",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_language_version_config_description": "Versiunea limbajului C# care va fi utilizată la decompilarea scripturilor.",
    "config_screen_drag_drop_prompt": "Rețineți că unele modificări ale setărilor pot cauza sau preveni erori.\nOdată ce sunteți gata, trageți și eliberați fișierul/jocul dvs. în această fereastră sau folosiți meniul din colțul din stânga sus pentru a deschide ceva manual.",
    "export_deleting_old_files": "Ștergerea fișierelor existente...",
    "loading_step_detect_platform": "Colectare fișiere și detectare structurii jocului",
    "loading_step_generate_dummy_dll": "Generare Assemblies Mono din IL2Cpp",
    "loading_step_locate_key_functions": "Scanare binar IL2Cpp pentru funcții din bibliotecă",
    "loose_file_saved_at": "Fișierul liber a fost salvat la {0}",
    "menu_language": "Limbă",
    "mesh_format_glb_description": "O alternativă de înaltă calitate și open-source la FBX. Versiunea binară a GLTF. Conține doar datele mesh-ului. Poate cauza erori. Unity nu poate importa resurse de acest tip.",
    "no_game_files_found": "Nu au fost găsite fișiere de joc Unity sau bundle-uri de resurse în fișierele selectate.",
    "save": "Salvează",
    "sprite_format_texture_description": "\"Exportă ca imagine a sprite-ului. Poate fi vizualizat în afara Unity, dar mai lent la export.",
    "sprite_format_yaml": "Yaml",
    "script_content_level_0_description": "Scripturile nu sunt exportate.",
    "script_content_level_2_description": "Implicit. Acest nivel exportează metode complete pentru jocurile Mono și metode fictive pentru jocurile IL2Cpp.",
    "script_export_format_decompiled_description": "Decompilatorul ILSpy este folosit pentru a genera scripturi CS. Acesta este de încredere. Totuși, este și consumator de timp și conține multe erori de compilare.",
    "sprite_format_yaml_description": "Exportă ca assets yaml care pot fi vizualizate în editor. Acesta este singurul mod care asigură o recuperare precisă a tuturor metadatelor sprite-urilor.",
    "view_loaded_files": "Vizualizează fișierele încărcate",
    "enable_static_mesh_separation": "Activeaza Separare Static Mesh",
    "script_export_format_dll_without_renaming_description": "Asamblările sunt exportate în forma lor compilat DLL. Unity va suprascrie probabil asamblările speciale cum ar fi Assembly-CSharp.",
    "export_primary_content": "Exportați conținutul principal",
    "export_unity_project": "Exporteaza Proiectul Unity",
    "stack_trace": "Urmărirea stivei",
    "swagger_documentation": "Documentația Swagger",
    "loading_step_begin_scheme_processing": "Pornirea procesării schemei",
    "failed_files": "Fișiere eșuate",
    "c_sharp_langage_version_config_12_0": "C# 12",
    "configuration_files_singletons": "Singletons",
    "not_available_in_the_free_edition": "Nu este disponibil în ediția gratuită.",
    "open_api_json": "OpenAPI JSON",
    "asset_tab_video": "Video",
    "asset_tab_model": "Model"
}

```

`Localizations/ru.json`:

```json
{
    "asset_tab_audio": "Аудио",
    "asset_tab_audio_duration_unknown": "<Неизвестно>",
    "asset_tab_audio_pause": "Пауза",
    "asset_tab_audio_play": "Воспроизвести",
    "asset_tab_basic": "Основная информация",
    "asset_tab_image": "Изображение",
    "asset_tab_text": "Текст",
    "asset_tab_yaml": "Yaml",
    "audio_export_title": "Формат экспорта Аудио",
    "audio_format_default": "По умолчанию",
    "audio_format_default_description": "Экспорт активов как типа контента, встроенного в FSB. Большинство типов аудио экспортируются как WAV, некоторые экспортируются как OGG.",
    "audio_format_force_wav": "Конвертировать в WAV",
    "audio_format_force_wav_description": "Преобразование всех аудиофайлов в файлы WAV. Не рекомендуется при импорте в Unity, так как это может привести к повторному сжатию файлов, что приведет к потере качества.",
    "audio_format_native": "Необработанный",
    "audio_format_native_description": "Необработанный звук FSB. Невозможно импортировать в Unity, поэтому используйте его, только если вы опытный пользователь.",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "Экспортируйте как ассет yaml и файл resS. Это безопасный вариант и запасной вариант, когда что-то пойдет не так.",
    "bundled_assets_export_direct_export": "Прямой Экспорт",
    "bundled_assets_export_direct_export_description": "Связанные ассеты экспортируются без группировки.",
    "bundled_assets_export_group_by_asset_type": "Группировать по типу ассетов",
    "bundled_assets_export_group_by_asset_type_description": "Связанные ассеты обрабатываются так же, как ресурсы из других файлов.",
    "bundled_assets_export_group_by_bundle_name": "Группировать по названию бандла",
    "bundled_assets_export_group_by_bundle_name_description": "Связанные ассеты сгруппированы по имени их пакета ассетов.",
    "bundled_assets_export_title": "Режим экспорта связанных ассетов",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "Автоматический - Экспериментальный",
    "c_sharp_langage_version_config_auto_safe": "Автоматический - Безопасный",
    "c_sharp_langage_version_config_latest": "Последний C#",
    "c_sharp_language_version_config_description": "Версия языка C#, используемая при декомпиляции скриптов.",
    "check_log_for_more_details": "Проверьте логи для более подробной информации",
    "config_options": "Настройки конфигурации",
    "config_screen_drag_drop_prompt": "Обратите внимание, что некоторые изменения настроек могут вызвать или предотвратить ошибки.\n Когда будете готовы, перетащите файл/папку с игрой в это окно или воспользуйтесь меню в левом верхнем углу, чтобы открыть что-нибудь вручную.",
    "enable_prefab_outlining": "Включить обводку префабов",
    "enable_static_mesh_separation": "Включить разделение статических мешей",
    "error": "Ошибка",
    "error_exporting_with_reason": "Не удалось экспортировать игровой контент: {0}",
    "error_importing_with_reason": "Не удалось загрузить игровой контент: {0}",
    "export_complete": "Экспорт Завершён!",
    "export_deleting_old_files": "Удаление существующих файлов...",
    "export_in_progress": "Экспорт файлов\n {0}%\n {1}/{2}",
    "export_in_progress_no_file_count_yet": "Экспорт файлов\n 0,0%\n ?/?",
    "export_preparing": "Подготовка к экспорту...\n Это может занять минуту.",
    "ignore_engine_assets": "Игнорировать ассеты движка",
    "image_export_title": "Формат экспорта изображений",
    "image_format_description": "Влияет на все экспортированные изображения.",
    "loading_game_content_from": "Загрузка контента игры из {0}\n{1}",
    "loading_step_begin_scheme_processing": "Запуск обработки схемы",
    "loading_step_create_file_collection": "Создание коллекции файлов",
    "loading_step_detect_platform": "Сбор файлов и определение структуры игры",
    "loading_step_generate_dummy_dll": "Создание Mono Assemblies из IL2CPP",
    "loading_step_initialize_layout": "Инициализация макета ассетов",
    "loading_step_load_assemblies": "Загрузка скриптов",
    "loading_step_load_assets_from_file": "Загрузка ассетов из {0}",
    "loading_step_locate_key_functions": "Сканирование двоичного файла IL2CPP для библиотечных функций",
    "loading_step_parse_archive": "Анализ архива {0}",
    "loading_step_parse_bundle": "Анализ бандла {0}",
    "loading_step_parse_il2cpp_metadata": "Анализ Метаданных IL2CPP",
    "loading_step_parse_resource": "Анализ файла ресурсов {0}",
    "loading_step_parse_serialized": "Анализ Сериализованного файла {0}",
    "loading_step_parse_web": "Анализ веб-файла {0}",
    "loading_step_pre_processing": "Предварительная обработка файлов",
    "loading_step_restore_attributes": "Восстановление атрибутов сгенерированных файлов",
    "loose_file_saved_at": "Свободный файл сохранен в {0}",
    "menu_export": "Экспорт",
    "menu_export_all": "Экспорт всех файлов",
    "menu_export_selected": "Экспортировать Выбранные Файлы",
    "menu_export_selected_type": "Экспортировать Файлы Выбранного Типа",
    "menu_file": "Файл",
    "menu_file_exit": "Выйти",
    "menu_file_open_file": "Открыть файл",
    "menu_file_open_folder": "Открыть папку",
    "menu_file_reset": "Сбросить",
    "menu_language": "Язык",
    "mesh_export_title": "Формат экспорта Мешей",
    "mesh_format_glb": "GLB",
    "mesh_format_glb_description": "Высококачественная альтернатива FBX с открытым исходным кодом. Бинарная версия GLTF. Содержит только данные сетки. Может вызвать ошибки. Unity не может импортировать ассеты этого типа.",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "Надежный формат для использования meshes в редакторе. Может быть преобразован в другие форматы с помощью различных пакетов Unity.",
    "no_game_files_found": "В данных файлах не было найдено ни игры, ни набора ресурсов Unity.",
    "not_implemented_yet": "Еще не реализовано",
    "script_content_level_0": "Уровень 0",
    "script_content_level_0_description": "Скрипты не экспортируются.",
    "script_content_level_1": "Уровень 1",
    "script_content_level_1_description": "Методы удаляются из декомпилированного экспорта.",
    "script_content_level_2": "Уровень 2",
    "script_content_level_2_description": "По умолчанию. Это экспортирует полные методы для игр Mono и методы пустышки для игр IL2Cpp.",
    "script_content_level_3": "Уровень 3",
    "script_content_level_3_description": "Методы IL2Cpp безопасно восстанавливаются, где это возможно.",
    "script_content_level_4": "Уровень 4",
    "script_content_level_4_description": "Методы IL2Cpp восстанавливаются без учета безопасности.",
    "script_content_level_title": "Уровень контента скриптов",
    "script_export_format_decompiled": "Декомпиляция",
    "script_export_format_decompiled_description": "Декомпилятор ILSpy используется для генерации скриптов CS. Это надежно. Однако это также отнимает много времени и содержит много ошибок компиляции.",
    "script_export_format_dll_with_renaming": "Экспорт Dll с переименованием",
    "script_export_format_dll_without_renaming": "Экспорт Dll без переименования",
    "script_export_format_dll_without_renaming_description": "Сборки экспортируются в скомпилированном виде Dll. Экспериментальный. Может вообще не работать.",
    "script_export_format_hybrid": "Гибрид",
    "script_export_title": "Формат экспорта скриптов",
    "script_language_version_title": "Версия языка С#",
    "select_asset_to_view_info": "Выберите файл слева, чтобы просмотреть информацию о нем.",
    "shader_asset_export_title": "Формат экспорта шейдеров",
    "shader_asset_format_decompile": "Декомпиляция",
    "shader_asset_format_decompile_description": "Экспортируйте шейдер в ShaderLab. Очень экспериментально и почти наверняка будут ошибки. Поддерживает только DX11, а не DX9.",
    "shader_asset_format_disassembly": "Дизассемблированный",
    "shader_asset_format_disassembly_description": "Экспортируйте шейдер как дизассемблированный. Экспериментальный и склонный к поломке. Не компилируется в редакторе.",
    "shader_asset_format_dummy": "Шейдер пустышка",
    "shader_asset_format_dummy_description": "Экспортирует шейдер как пустышку. Несмотря на то, что он сохраняет такие данные, как Properties и FallBack, он использует общий непрозрачный код шейдера.",
    "shader_asset_format_yaml": "Yaml Файл",
    "shader_asset_format_yaml_description": "Экспортируйте шейдер как yaml asset. Экспериментальный и пригодный только для просмотра в редакторе. Редактор может случайным образом повредить эти файлы.",
    "skip_streaming_assets": "Пропустить папку StreamingAssets",
    "sprite_export_title": "Формат экспорта спрайтов",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Экспорт в формате спрайта Unity. Нельзя просмотреть вне Unity.",
    "sprite_format_texture": "Текстуры",
    "sprite_format_texture_description": "Экспортируйте как изображение листа спрайтов. Можно просматривать за пределами Unity, но медленнее экспортировать.",
    "sprite_format_yaml": "Yaml",
    "sprite_format_yaml_description": "Экспортируйте как ассеты yaml, которые можно просмотреть в редакторе. Это единственный режим, обеспечивающий точное восстановление всех метаданных спрайтов.",
    "success": "Готово!",
    "terrain_export_title": "Формат экспорта Terrain",
    "terrain_format_heatmap": "Карта высот",
    "terrain_format_heatmap_description": "Экспортируйте тепловую карту высоты местности в каждом месте. Только действительно полезно, если вы не заботитесь о деталях или о местности в 3D.",
    "terrain_format_mesh": "3D Меш",
    "terrain_format_mesh_description": "Экспортируйте ландшафт в виде 3D-сетки в формате GLB, который подходит для просмотра в различных 3D-редакторах.",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "Экспорт в собственный формат ландшафта Unity. Самый полезный вариант, если вы планируете повторно импортировать обратно в Unity.",
    "text_asset_export_title": "Формат экспорта TextAsset",
    "text_asset_format_binary": "Байты",
    "text_asset_format_binary_description": "Экспортируйте необработанные байты текстового ассета с расширением .bytes.",
    "text_asset_format_parse": "Анализ",
    "text_asset_format_parse_description": "Экспортируйте как обычный текстовый файл, но попытается угадать правильное расширение файла (например, файлы JSON получают расширение .json).",
    "text_asset_format_text": "Обычный текст",
    "text_asset_format_text_description": "Экспорт в виде текстового файла (.txt).",
    "welcome_title": "Добро пожаловать в AssetRipper",
    "width": "Ширина",
    "game_object": "Игровой объект",
    "donation_message": "Если Вам понравился Asset Ripper, вы можете поддержать проект:",
    "name": "Имя",
    "no_files_loaded": "Файлы не загружены",
    "shader": "Шейдер",
    "class": "Класс",
    "collection": "Коллекция",
    "collections": "Коллекции",
    "channels": "Каналы",
    "count": "Количество",
    "csharp_type": "Тип C#",
    "default_version": "Изначальная версия",
    "height": "Высота",
    "home": "Домой",
    "namespace": "Пространство имен",
    "path": "Путь",
    "privacy": "Приватность",
    "resources": "Ресурсы",
    "save": "Сохранить",
    "scene": "Сцена",
    "script": "Скрипт",
    "menu_load": "Загрузка",
    "menu_view": "Вид",
    "original_path": "Исходный путь",
    "replace": "Заменить",
    "save_settings_to_disk": "Сохранить настройки на диск",
    "parent": "Родитель",
    "remove": "Удалить",
    "select_folder": "Выбор папки",
    "settings": "Настройки",
    "size": "Размер",
    "view_loaded_files": "Просмотр загруженных файлов",
    "settings_can_only_be_changed_before_loading_files": "Настройки могут быть изменены только перед загрузкой файлов.",
    "menu_import": "Импорт",
    "no_data_has_been_loaded_for_this_key": "Для этого ключа не было загружено никаких данных.",
    "select_file": "Выбор файла",
    "texture": "Текстура",
    "there_are_no_keys_for_this_data_type": "Нет ключей для этого типа данных.",
    "warning_this_directory_is_not_empty_all_content_will_be_deleted": "Предупреждение: эта директория не пустая. Всё содержимое будет удалено.",
    "an_error_occured_during_decompilation": "Во время декомпиляции произошла ошибка.",
    "appreciation_message": "Благодарим вас за поддержку AssetRipper!",
    "asset_tab_dependencies": "Зависимости",
    "asset_tab_font": "Шрифт",
    "commands": "Команды",
    "experimental": "Экспериментально",
    "format": "Формат",
    "frequency": "Частота",
    "length": "Длина",
    "licenses": "Лицензии",
    "load": "Загрузка",
    "configuration_files": "Конфигурационные файлы",
    "configuration_files_lists": "Списки",
    "welcome": "Добро пожаловать",
    "assembly_name": "Название Сборки",
    "asset_tab_development": "Разработка",
    "asset_tab_information": "Информация",
    "assets": "Ресурсы",
    "bundle": "Пакет",
    "bundles": "Пакеты",
    "class_name": "Имя Класса",
    "data": "Данные",
    "asset_tab_video": "Видео"
}

```

`Localizations/th.json`:

```json
{
    "asset_ripper_free": "AssetRipper ฟรี",
    "asset_ripper_premium": "AssetRipper ขั้นสูง",
    "asset_tab_audio_duration_unknown": "<ไม่ทราบ>",
    "an_error_occured_during_decompilation": "เกิดข้อผิดพลาดระหว่างการถอดรหัส",
    "asset_tab_audio_pause": "หยุดชั่วคราว",
    "asset_tab_font": "ฟ้อน",
    "asset_tab_image": "ภาพ",
    "asset_tab_model": "3D",
    "asset_tab_text": "ข้อความ",
    "audio_export_title": "รูปแบบการส่งออกเสียง",
    "audio_format_force_wav": "บันทึกเป็น WAV",
    "asset_tab_development": "การพัฒนา",
    "audio_format_native": "Raw",
    "assembly_name": "ภาษา Assembly",
    "asset_bundle_name": "Asset Bundle",
    "asset_tab_hex": "เลขฐาน 16",
    "asset_tab_dependencies": "การพึ่งพา",
    "assets": "Assets",
    "audio_clip": "AudioClip",
    "bundles": "Bundles",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "อัตโนมัติ - ทดลอง",
    "c_sharp_langage_version_config_latest": "C# ล่าสุด",
    "c_sharp_language_version_config_description": "เวอร์ชันภาษา C# ที่จะใช้ในการถอดรหัสสคริปต์",
    "channels": "ช่อง",
    "data": "ข้อมูล",
    "error": "ล้มเหลว",
    "json": "Json",
    "load": "โหลด",
    "loading_step_load_assemblies": "กำลังโหลดส่วนประกอบ",
    "menu_export": "ส่งออก",
    "menu_file": "ไฟล์",
    "menu_file_exit": "ออก",
    "menu_file_open_file": "เปิดไฟล์",
    "menu_file_open_folder": "เปิดโฟลเดอร์",
    "menu_file_reset": "คืนค่าเริ่มต้น",
    "menu_import": "นำเข้า",
    "menu_language": "ภาษา",
    "menu_view": "ภาพรวม",
    "mesh": "Mesh",
    "mesh_export_title": "รูปแบบการส่งออก Mesh",
    "mesh_format_glb": "GLB",
    "mesh_format_native": "Yaml",
    "save": "บันทึก",
    "remove": "ลบ",
    "scene": "Scene",
    "script": "Script",
    "asset_tab_audio": "เสียง",
    "appreciation_message": "ขอบคุณที่สนับสนุนโครงการของเรา",
    "asset_tab_audio_play": "เล่น",
    "audio_format_default": "ค่าเริ่มต้น",
    "c_sharp_langage_version_config_1": "C# 1",
    "asset_tab_information": "ข้อมูล",
    "bundled_assets_export_title": "วิธีการส่งออก",
    "c_sharp_langage_version_config_auto_safe": "อัตโนมัติ - ปลอดภัย",
    "csharp_type": "ประเภท C#",
    "format": "รูปแบบ",
    "licenses": "ใบอนุญาต",
    "menu_export_all": "ส่งออกทุกไฟล์",
    "menu_export_selected": "ส่งออกไฟล์ที่เลือก",
    "menu_load": "โหลด",
    "name": "ชื่อ",
    "no_files_loaded": "ไม่มีไฟล์ที่โหลด",
    "bundle": "Bundle",
    "audio_format_default_description": "ส่งออกสินทรัพย์เป็นประเภทเนื้อหาที่ฝังอยู่ภายในไฟล์ FSB ไฟล์เสียงส่วนใหญ่จะถูกส่งออกในรูปแบบ WAV ในขณะที่บางประเภทจะถูกส่งออกเป็น OGG",
    "audio_format_force_wav_description": "แปลงไฟล์เสียงทั้งหมดเป็นไฟล์ WAV ไม่แนะนำหากต้องการนำเข้าไฟล์ไปยัง Unity เนื่องจาก Unity อาจบีบอัดไฟล์ใหม่ ซึ่งอาจทำให้คุณภาพเสียงลดลง",
    "audio_format_native_description": "ไฟล์เสียงแบบ Raw FSB ไม่สามารถนำเข้าใน Unity ได้ ใช้เฉพาะในกรณีที่เป็นผู้ใช้งานขั้นสูงเท่านั้น",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "ส่งออกเป็นไฟล์สินทรัพย์ Yaml และไฟล์ resS ตัวเลือกนี้ปลอดภัยและใช้เป็นแผนสำรองเมื่อเกิดปัญหา",
    "bundled_assets_export_direct_export": "ส่งออกโดยตรง",
    "bundled_assets_export_direct_export_description": "สินทรัพย์ที่ถูกรวมไว้จะถูกส่งออกโดยไม่มีการจัดกลุ่ม",
    "bundled_assets_export_group_by_asset_type": "จัดกลุ่มตามประเภทสินทรัพย์",
    "bundled_assets_export_group_by_asset_type_description": "สินทรัพย์ที่ถูกรวมไว้จะถูกจัดการเหมือนกับสินทรัพย์จากไฟล์อื่นๆ",
    "bundled_assets_export_group_by_bundle_name": "จัดกลุ่มตามชื่อของบันเดิล",
    "bundled_assets_export_group_by_bundle_name_description": "สินทรัพย์ที่ถูกรวมไว้จะถูกจัดกลุ่มตามชื่อของบันเดิลสินค้า",
    "check_log_for_more_details": "ตรวจสอบบันทึกเพื่อดูรายละเอียดเพิ่มเติม",
    "class": "Class",
    "class_id_type_name": "Class ID Type Name",
    "class_id_type_number": "Class ID Type Number",
    "class_name": "Class Name",
    "collection": "สะสม",
    "shader_asset_format_dummy": "Dummy Shader",
    "sprite_format_native": "Unity",
    "skip_streaming_assets": "ข้ามโฟลเดอร์ StreamingAssets",
    "size": "ขนาด",
    "shader_asset_format_yaml": "Yaml Asset",
    "text_asset_export_title": "รูปแบบการส่งออกของ TextAsset",
    "terrain_format_native_description": "ส่งออกในรูปแบบเทอร์เรนพื้นฐานของ Unity เป็นตัวเลือกที่มีประโยชน์ที่สุดหากคุณวางแผนที่จะนำเข้าไฟล์กลับไปยัง Unity อีกครั้ง",
    "sprite_export_title": "รูปแบบการส่งออกของ Sprite",
    "shader_asset_format_yaml_description": "ส่งออกเชเดอร์เป็นไฟล์สินทรัพย์ YAML เป็นฟีเจอร์ทดลองและสามารถใช้งานได้เฉพาะในตัวแก้ไขเท่านั้น โดยตัวแก้ไขอาจทำให้ไฟล์เหล่านี้เสียหายได้โดยบังเอิญ",
    "shader_asset_format_dummy_description": "ส่งออกเชเดอร์เป็นเชเดอร์จำลอง ถึงแม้ว่าจะรักษาข้อมูลบางอย่างเช่น พร็อพเพอร์ตี้และฟอลล์แบ็ค แต่จะใช้โค้ดเชเดอร์ทั่วไปที่เป็นโปร่งแสง",
    "config_screen_drag_drop_prompt": "โปรดทราบว่าการเปลี่ยนแปลงการตั้งค่าบางอย่างอาจทำให้เกิดหรือป้องกันข้อผิดพลาดได้\nเมื่อคุณพร้อมแล้ว ให้ลากและวางไฟล์/โฟลเดอร์เกมของคุณลงในหน้าต่างนี้ หรือใช้เมนูที่ด้านซ้ายบนเพื่อเปิดบางอย่างด้วยตนเอง"
}

```

`Localizations/tr.json`:

```json
{
    "asset_tab_audio": "Ses",
    "asset_tab_audio_duration_unknown": "<Bilinmiyor>",
    "asset_tab_audio_pause": "Duraklat",
    "asset_tab_audio_play": "Oynat",
    "asset_tab_basic": "Temel Bilgiler",
    "asset_tab_image": "Resim",
    "asset_tab_text": "Metin",
    "asset_tab_yaml": "Yaml",
    "audio_export_title": "Ses Dışa Aktarma Formatı",
    "audio_format_default": "Varsayılan",
    "audio_format_default_description": "Assetleri FSB'nin içine gömülü içerik türü olarak dışa aktarın. Çoğu ses türü WAV olarak, bazıları OGG olarak dışa aktarılır.",
    "audio_format_force_wav": "WAV'a Dönüştür",
    "audio_format_force_wav_description": "Tüm ses dosyalarını WAV'a dönüştür. Tekrar sıkıştırma kalite kaybına neden olabileceğinden Unity'ye aktarılması önerilmez.",
    "audio_format_native": "Ham",
    "audio_format_native_description": "Ham FSB Ses. Unity'ye aktarılamaz, dolayısıyla bunu ileri düzey kullanıcıysanız kullanın.",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "Yaml asset ve resS dosyası olarak dışa aktarın. Bu güvenli bir seçenektir ve işler ters giderse yedektedir.",
    "bundled_assets_export_direct_export": "Doğrudan Dışa Aktar",
    "bundled_assets_export_direct_export_description": "Paketlenmiş assetler gruplandırılmadan dışa aktarılır.",
    "bundled_assets_export_group_by_asset_type": "Asset Türüne Göre Grupla",
    "bundled_assets_export_group_by_asset_type_description": "Paketlenmiş assetler diğer dosyalardaki assetlerle aynı işlemden geçirilir.",
    "bundled_assets_export_group_by_bundle_name": "Paket Adına Göre Grupla",
    "bundled_assets_export_group_by_bundle_name_description": "Paketlenmiş assetler, asset paket adlarına göre gruplandırılır.",
    "bundled_assets_export_title": "Paketlenmiş Assetleri Dışa Aktarma Modu",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "Otomatik - Deneysel",
    "c_sharp_langage_version_config_auto_safe": "Otomatik - Güvenli",
    "c_sharp_langage_version_config_latest": "C# Son Sürüm",
    "c_sharp_language_version_config_description": "Kodlar derlenirken kullanılacak C# dil sürümü.",
    "check_log_for_more_details": "Ayrıntılar için kaydı inceleyebilirsiniz",
    "config_options": "Yapılandırma Seçenekleri",
    "config_screen_drag_drop_prompt": "Bazı ayar değişikliklerinin hatalara neden olabileceğini veya hataları önleyebileceğini lütfen unutmayın.\nHazır olduğunuzda, oyun dosyanızı/klasörünüzü bu pencereye sürükleyip bırakın veya manuel olarak açmak için sol üstteki menüyü kullanın.",
    "enable_prefab_outlining": "Prefab Taslağı Etkinleştir",
    "enable_static_mesh_separation": "Sabit Mesh Ayırmayı Etkinleştir",
    "error": "Hata",
    "error_exporting_with_reason": "Oyun içeriği dışa aktarılamadı: {0}",
    "error_importing_with_reason": "Oyun içeriği yüklenemedi: {0}",
    "export_complete": "Dışa Aktarıldı!",
    "export_deleting_old_files": "Mevcut dosyalar temizleniyor..",
    "export_in_progress": "Asset Dosyaları Dışa Aktarımı\n{0}%\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "Asset Dosyaları Dışa Aktarımı\n0.0%\n?/?",
    "export_preparing": "Dışa Aktarma için Hazırlanıyor..\nBu bir dakika sürebilir.",
    "image_export_title": "Resim Dışa Aktarma Formatı",
    "image_format_description": "Dışa aktarılan tüm resimleri etkiler",
    "loading_game_content_from": "{0} İçeriği Yükleniyor\n{1}",
    "loading_step_begin_scheme_processing": "Şema İşleme Başlatılıyor",
    "loading_step_create_file_collection": "Dosya Koleksiyonu Oluşturuluyor",
    "loading_step_detect_platform": "Dosyaları Toplama ve Oyun Yapısını Tespit Etme",
    "loading_step_generate_dummy_dll": "IL2CPP'den Mono Derlemeleri Oluşturma",
    "loading_step_initialize_layout": "Asset Düzeni Hazırlanıyor",
    "loading_step_load_assemblies": "Assembli'ler Yükleniyor",
    "loading_step_load_assets_from_file": "{0}'dan Asset'ler Yükleniyor",
    "loading_step_locate_key_functions": "IL2CPP İkilisinin Kütüphane İşlevleri için Taranması",
    "loading_step_parse_archive": "{0} Arşiv Dosyası Ayrıştırılıyor",
    "loading_step_parse_bundle": "{0} Paketi Ayrıştırılıyor",
    "loading_step_parse_il2cpp_metadata": "IL2CPP Meta Verileri Ayrıştırılıyor",
    "loading_step_parse_resource": "{0} Kaynak Dosyası Ayrıştırılıyor",
    "loading_step_parse_serialized": "{0} Dizeleştirilmiş Dosya Ayrıştırılıyor",
    "loading_step_parse_web": "{0} Web Dosyası Ayrıştırılıyor",
    "loading_step_pre_processing": "Ön İşleme Dosyaları",
    "loading_step_restore_attributes": "Oluşturulan Assembly'lerde Öznitelikleri Geri Yükleme",
    "loose_file_saved_at": "Loose dosya {0} konumuna kaydedildi",
    "menu_export": "Dışa aktar",
    "menu_export_all": "Tüm dosyaları dışa aktar",
    "menu_export_selected": "Seçilen Dosyayı Dışa Aktar",
    "menu_export_selected_type": "Seçilen Türdeki Bütün Dosyaları Dışa Aktar",
    "menu_file": "Dosya",
    "menu_file_exit": "Çıkış",
    "menu_file_open_file": "Dosya Aç",
    "menu_file_open_folder": "Klasör Aç",
    "menu_file_reset": "Sıfırla",
    "menu_language": "Dil",
    "mesh_export_title": "Mesh Dışa Aktarma Formatı",
    "mesh_format_glb": "GLB",
    "mesh_format_glb_description": "FBX'e yüksek kaliteli, açık kaynaklı bir alternatif. GLTF'nin binary sürümü. Sadece mesh verisi içerir. Hatalara neden olabilir. Unity bu tür assetleri içe aktaramaz.",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "Düzenleyicide mesh kullanmak için güçlü bir format. Çeşitli Unity paketleri diğer formatlara dönüştürülebilir.",
    "no_game_files_found": "Dosyalarda Unity oyunu veya asset paketi bulunamadı.",
    "not_implemented_yet": "Henüz Uygulanmadı",
    "script_content_level_0": "Seviye 0",
    "script_content_level_0_description": "Betikler dışa aktarılmaz.",
    "script_content_level_1": "Seviye 1",
    "script_content_level_1_description": "Metodlar derlenmemiş dışa aktarımdan çıkarılır.",
    "script_content_level_2": "Seviye 2",
    "script_content_level_2_description": "Varsayılan. Mono oyunlar için tam yöntemleri ve IL2Cpp oyunlar için yapay yöntemleri dışa aktarır.",
    "script_content_level_3": "Seviye 3",
    "script_content_level_3_description": "IL2Cpp metodları mümkün olan yerlerde güvenle kurtarılır.",
    "script_content_level_4": "Seviye 4",
    "script_content_level_4_description": "IL2Cpp yöntemleri, güvenlik göz ardı edilerek kurtarılır.",
    "script_content_level_title": "Script İçerik Seviyesi",
    "script_export_format_decompiled": "Derlenmiş",
    "script_export_format_decompiled_description": "CS komut dosyaları oluşturmak için ILSpy derleyicisi kullanılır. Güvenlidir ancak, aynı zamanda zaman kaybına neden olur ve birçok hata içerir.",
    "script_export_format_dll_with_renaming": "Yeniden Adlandırmayla Dll Dışa Aktarma",
    "script_export_format_dll_without_renaming": "Yeniden Adlandırmadan Dll Dışa Aktarma",
    "script_export_format_dll_without_renaming_description": "Assembly'ler derlenmiş Dll formunda dışa aktarılır. Deneyseldir. Hiç çalışmayabilir.",
    "script_export_format_hybrid": "Hibrit",
    "script_export_title": "Script Dışa Aktarma Formatı",
    "script_language_version_title": "C# Dil Sürümü",
    "select_asset_to_view_info": "Hakkında bilgi görüntülemek için sol taraftan Asset seçin",
    "shader_asset_export_title": "Gölgelendirici Dışa Aktarma Formatı",
    "shader_asset_format_decompile": "Derlemeyi Çöz",
    "shader_asset_format_decompile_description": "Gölgelendiriciyi ShaderLab'a aktarın. Oldukça deneyseldir ve neredeyse hatalar kaçınılmazdır. Sadece DX11'i destekler, DX9'u desteklemez.",
    "shader_asset_format_disassembly": "Söküm",
    "shader_asset_format_disassembly_description": "Gölgelendiriciyi söküm olarak dışa aktarın. Deneyseldir ve bozulabilir. Bu, düzenleyicide derlenmez.",
    "shader_asset_format_dummy": "Yapay Gölgelendirici",
    "shader_asset_format_dummy_description": "Gölgelendiriciyi yapay gölgelendirici olarak dışa aktarın. Özellikler ve FallBack gibi verileri korur ancak genel, opak gölgelendirici kodu kullanır.",
    "shader_asset_format_yaml": "Yaml Asset",
    "shader_asset_format_yaml_description": "Gölgelendiriciyi yaml asset olarak dışa aktarın. Deneyseldir ve yalnızca düzenleyicide görüntülemek için kullanılabilir. Düzenleyici bu dosyaları rastgele bozabilir.",
    "skip_streaming_assets": "StreamingAssets Klasörünü Atla",
    "sprite_export_title": "Sprite Dışa Aktarma Formatı",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Unity sprite formatında dışa aktarın. Unity haricinde görüntülenemez.",
    "sprite_format_texture": "Texture",
    "sprite_format_texture_description": "Sprite Sheet'in resmi olarak dışa aktarın. Unity haricinde görüntülenebilir, fakat dışa aktarması daha yavaştır.",
    "sprite_format_yaml": "Yaml",
    "sprite_format_yaml_description": "Düzenleyicide görülebilir yaml assetleri olarak dışa aktarın. Bu, spriteların tüm meta verilerinin eksiksiz kurtarılmasını sağlayan tek moddur.",
    "success": "Başarılı!",
    "terrain_export_title": "Arazi Dışa Aktarma Formatı",
    "terrain_format_heatmap": "Yükseklik Haritası",
    "terrain_format_heatmap_description": "Her konumdaki arazi yüksekliğinin ısı haritasını dışa aktarın. Sadece ayrıntıları veya arazinin 3D olmasını önemsemiyorsanız çok kullanışlıdır.",
    "terrain_format_mesh": "3D Mesh",
    "terrain_format_mesh_description": "Araziyi, çeşitli 3D düzenleyicilerle görüntülemeye uygun GLB formatında 3D mesh olarak dışa aktarın.",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "Yerel Unity arazi formatında dışa aktarın. Unity'ye tekrar aktarmak için en kullanışlı seçenek.",
    "text_asset_export_title": "TextAsset Dışa Aktarma Formatı",
    "text_asset_format_binary": "Bayt",
    "text_asset_format_binary_description": "Metin asset'inin ham baytlarını .bytes uzantısı ile dışa aktarın.",
    "text_asset_format_parse": "Ayrıştırma",
    "text_asset_format_parse_description": "Düz metin dosyası olarak dışa aktarın, ancak doğru dosya uzantısını tahmin etmeye çalışın (örneğin JSON dosyaları .json uzantısına sahip olur)",
    "text_asset_format_text": "Düz Metin",
    "text_asset_format_text_description": "Düz metin dosyası (.txt) olarak dışa aktar",
    "welcome_title": "AssetRipper'a Hoşgeldiniz"
}

```

`Localizations/uk.json`:

```json
{
    "asset_tab_audio": "Аудіо",
    "asset_tab_audio_duration_unknown": "<Невідомо>",
    "asset_tab_audio_pause": "Пауза",
    "asset_tab_audio_play": "Грати",
    "asset_tab_basic": "Основна інформація",
    "asset_tab_image": "Зображення",
    "asset_tab_text": "Текст",
    "asset_tab_yaml": "YAML",
    "audio_export_title": "Формат експорту аудіо",
    "bundled_assets_export_direct_export": "Прямий експорт",
    "bundled_assets_export_group_by_asset_type": "Групувати за типом асета",
    "bundled_assets_export_group_by_asset_type_description": "Bundled assets обробляються так само як і ресурси з інших файлів.",
    "bundled_assets_export_group_by_bundle_name": "Групувати за назвою пакета",
    "bundled_assets_export_group_by_bundle_name_description": "Ассети згруповано за їх назвами asset bundle.",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "Автоматично - Експериментальна",
    "c_sharp_langage_version_config_auto_safe": "Автоматично - Безпечна",
    "c_sharp_langage_version_config_latest": "C# Остання",
    "c_sharp_language_version_config_description": "Версія C# яка буде використана під час декомпіляції скриптів.",
    "config_options": "Параметри конфігурації",
    "enable_static_mesh_separation": "Увімкнути відділення статичних мешів",
    "error": "Помилка",
    "error_exporting_with_reason": "Не вдалося експортувати вміст гри: {0}",
    "error_importing_with_reason": "Не вдалося завантажити вміст гри: {0}",
    "export_complete": "Експорт завершено!",
    "export_deleting_old_files": "Очищення існуючих файлів...",
    "export_in_progress": "Експорт асетів\n{0}%\n{1}/{2}",
    "export_in_progress_no_file_count_yet": "Експорт асетів\n0,0%\n?/?",
    "export_preparing": "Підготовка до експорту...\nЦе може зайняти хвилину.",
    "ignore_engine_assets": "Ігнорувати ассети рушія",
    "image_export_title": "Формат експорту зображень",
    "loading_game_content_from": "Завантаження ігрового вмісту з {0}\n{1}",
    "loading_step_begin_scheme_processing": "Початок обробки схеми",
    "loading_step_create_file_collection": "Створення колекції файлів",
    "loading_step_detect_platform": "Збір файлів і визначення структури гри",
    "loading_step_generate_dummy_dll": "Генерація збірок Mono з IL2CPP",
    "loading_step_initialize_layout": "Ініціалізація макету асетів",
    "loading_step_load_assemblies": "Завантаження Assemblies",
    "loading_step_load_assets_from_file": "Завантаження Асетів із {0}",
    "loading_step_locate_key_functions": "Сканування двійкового файлу IL2CPP на наявність бібліотечних функцій",
    "loading_step_parse_archive": "Парсинг архівного файлу {0}",
    "loading_step_parse_bundle": "Парсинг пакета {0}",
    "loading_step_parse_il2cpp_metadata": "Аналіз метаданих IL2CPP",
    "loading_step_parse_resource": "Парсинг файлу ресурсів {0}",
    "loading_step_parse_serialized": "Парсинг серіалізованого файлу {0}",
    "loading_step_parse_web": "Парсинг Веб-файлу {0}",
    "loading_step_pre_processing": "Попередня обробка файлів",
    "loading_step_restore_attributes": "Відновлення атрибутів згенерованих Assemblies",
    "menu_export": "Експорт",
    "menu_export_all": "Експортувати всі файли",
    "menu_export_selected": "Експортувати вибраний файл",
    "menu_export_selected_type": "Експортувати всі файли вибраного типу",
    "menu_file": "Файл",
    "menu_file_exit": "Вийти",
    "menu_file_open_file": "Відкрити файл",
    "menu_file_open_folder": "Відкрити папку",
    "menu_file_reset": "Скинути",
    "menu_language": "Мова",
    "mesh_export_title": "Формат експорту мешу",
    "no_game_files_found": "У зазначених вами файлах не знайдено Unity гри або asset bundle.",
    "script_content_level_title": "Рівень вмісту скриптів",
    "script_export_title": "Формат експорту скриптів",
    "script_language_version_title": "Версія мови C#",
    "select_asset_to_view_info": "Виберіть асет ліворуч, щоб переглянути інформацію про нього",
    "shader_asset_export_title": "Формат експорту шейдерів",
    "skip_streaming_assets": "Пропустити папку StreamingAssets",
    "sprite_export_title": "Формат експорту спрайтів",
    "success": "Успіх!",
    "terrain_export_title": "Формат експорту Terrain",
    "text_asset_export_title": "Формат експорту тексту",
    "welcome_title": "Вітаємо в AssetRipper",
    "terrain_format_mesh_description": "Експортувати рельєф у вигляді 3D-сітки у форматі GLB, придатному для перегляду за допомогою широкого спектру 3D-редакторів.",
    "terrain_format_native": "Yaml",
    "stack_trace": "Відстеження стека",
    "terrain_format_heatmap_description": "Експортувати теплову карту висоти місцевості в кожному місці. Це дійсно корисно, якщо вам не важливі деталі або якщо ви не хочете мати місцевість у форматі 3D.",
    "terrain_format_mesh": "3D Mesh",
    "terrain_format_native_description": "Експортувати у власному форматі ландшафту Unity. Найкорисніша опція, якщо ви плануєте повторно імпортувати назад до Unity.",
    "override_path": "Перевизначити шлях",
    "script_content_level_3": "Рівень 3",
    "script_content_level_3_description": "Методи IL2Cpp безпечно відновлюються, де це можливо.",
    "script_content_level_4": "Рівень 4",
    "script_content_level_4_description": "Методи IL2Cpp відновлюються не дивлячись на небезпеку.",
    "script_export_format_dll_with_renaming": "Експорт DLL з перейменуванням",
    "script_export_format_dll_without_renaming": "Експорт DLL без перейменування",
    "script_export_format_hybrid": "Гібрид",
    "select_file": "Виберіть Файл",
    "select_folder": "Виберіть папку",
    "shader_asset_format_disassembly": "Дізассемблювання",
    "shader_asset_format_disassembly_description": "Експорт шейдерів як Disassembly. Експериментальний і схильний до поломок. Не компілюється в редакторі.",
    "text_asset_format_binary": "Байти",
    "text_asset_format_text": "Звичайний текст",
    "texture": "Текстура",
    "view_loaded_files": "Перегляд завантажених файлів",
    "welcome": "Ласкаво просимо",
    "audio_format_native_description": "Необроблений FSB Audio. Неможливо імпортувати в Unity, тому використовуйте це, лише якщо ви досвідчений користувач.",
    "audio_format_force_wav_description": "Конвертувати всі аудіофайли у WAV. Не рекомендується при імпорті в Unity, оскільки він може перекомпресувати файли, що призведе до втрати якості.",
    "script_content_level_2_description": "За замовчуванням. Це експортує повні методи для ігор Mono та фіктивні методи для ігор IL2Cpp.",
    "script_export_format_decompiled_description": "Декомпілятор ILSpy використовується для створення CS скриптів. Це надійно. Однак це також займає багато часу та містить багато помилок компіляції.",
    "script_export_format_dll_without_renaming_description": "Збірки експортуються у скомпільованому вигляді DLL. Unity, ймовірно, перезапише спеціальні збірки, такі як Assembly-CSharp.",
    "script_export_format_hybrid_description": "Спеціальні збірки, такі як Assembly-CSharp, декомпілюються. Інші збірки експортуються у скомпільованому вигляді DLL.",
    "settings": "Параметри",
    "shader_asset_format_decompile": "Декомпіляція",
    "shader_asset_format_decompile_description": "Експорт шейдеру в ShaderLab. Дуже експериментально та майже завжди буде мати помилки. Підтримує тільки DX11, не DX9.",
    "text_asset_format_text_description": "Експортувати як звичайний текстовий файл (.txt).",
    "lightmap_texture_export_title": "Формат експорту Lightmap текстури",
    "lightmap_texture_format_description": "Це впливає на всі експортовані lightmap текстури.",
    "menu_load": "Завантажити",
    "shader_asset_format_dummy": "Фіктивний шейдер",
    "size": "Розмір",
    "shader_asset_format_yaml_description": "Експортувати шейдер як yaml-актив. Експериментальний і придатний лише для перегляду у редакторі. Редактор може випадково пошкодити ці файли.",
    "failed_files": "Помилка файлів",
    "script_export_format_decompiled": "Декомпіляція",
    "shader": "Шейдер",
    "shader_asset_format_yaml": "Yaml Актив",
    "width": "Ширина",
    "yaml": "Yaml",
    "settings_can_only_be_changed_before_loading_files": "Параметри можна змінити лише перед завантаженням файлів.",
    "an_error_occured_during_decompilation": "Виникла помилка під час декомпіляції.",
    "appreciation_message": "Дякуємо за підтримку AssetRipper!",
    "asset_ripper_free": "AssetRipper Free",
    "asset_ripper_premium": "AssetRipper Premium",
    "asset_tab_dependencies": "Залежності",
    "asset_tab_font": "Шрифт",
    "audio_format_default_description": "Експорт активів як типу вмісту, вбудованого в FSB. Більшість типів аудіо експортується як WAV, деякі експортуються як OGG.",
    "audio_format_yaml_description": "Експорт як ресурс yaml і файл resS. Це безпечний і резервний варіант, коли щось піде не так.",
    "audio_format_yaml": "YAML",
    "asset_tab_video": "Відео",
    "audio_format_default": "За замовчуванням",
    "audio_format_force_wav": "Конвертувати у WAV",
    "configuration_files": "Конфігураційні файли",
    "bundled_assets_export_direct_export_description": "Bundled assets експортуються без групування.",
    "bundled_assets_export_title": "Режим експорту Bundled Assets",
    "bundles": "Пакети (Bundles)",
    "path": "Шлях",
    "experimental": "Експерементально",
    "guid": "GUID",
    "height": "Висота",
    "mesh_format_native_description": "Надійний формат для використання мешу в редакторі. Можна конвертувати в інші формати різними пакетами Unity.",
    "script_content_level_0_description": "Скрипти не експортуються.",
    "sprite_format_yaml": "Yaml",
    "audio_format_native": "Необроблений",
    "c_sharp_langage_version_config_12_0": "C# 12",
    "channels": "Канали",
    "check_log_for_more_details": "Перевірте журнал з логами для детальної інформації",
    "class_id_type_name": "Назва типу ідентифікатора класу",
    "config_screen_drag_drop_prompt": "Зауважте, що деякі зміни налаштувань можуть спричинити або запобігти помилкам.\nКоли ви будете готові, перетягніть файл/папку вашої гри в це вікно або скористайтеся меню у верхньому лівому куті, щоб відкрити щось вручну.",
    "configuration_files_lists": "Списки",
    "configuration_files_singletons": "Синглтони",
    "count": "Кількість",
    "csharp_type": "Тип C#",
    "data": "Дані",
    "default_version": "Версія за замовчуванням",
    "donation_message": "Якщо Вам сподобався AssetRipper, ви можете підтримати проект:",
    "enable_asset_deduplication": "Увімкнути дедублікацію активів",
    "enable_prefab_outlining": "Увімкнути Prefab Outlining",
    "format": "Формат",
    "frequency": "Частота",
    "game_object": "Ігровий об'єкт (GameObject)",
    "home": "Додому",
    "image_format_description": "Це впливає на всі експортовані зображення.",
    "length": "Довжина",
    "licenses": "Ліцензії",
    "load": "Завантажити",
    "json": "Jsоn",
    "loose_file_saved_at": "Відсутній файл збережено в {0}",
    "mesh_format_glb_description": "Високоякісна альтернатива FBX з відкритим кодом. Бінарна версія GLTF. Містить лише дані мешу. Може викликати помилки. Unity не може імпортувати активи цього типу.",
    "mesh_format_native": "Yalm",
    "name": "Ім'я",
    "not_available_in_the_free_edition": "Недоступно у безкоштовній версії.",
    "script_content_level_1_description": "Методи видаляються з декомпільованого експорту.",
    "script_content_level_2": "Рівень 2",
    "text_asset_format_parse": "Аналіз",
    "text_asset_format_parse_description": "Експортувати як звичайний текстовий файл, але спробуйте вгадати правильне розширення файлу (наприклад, JSON-файли мають розширення .json).",
    "shader_asset_format_dummy_description": "Експортувати шейдер як фіктивний шейдер. Хоча при цьому зберігаються такі дані, як властивості та запасні варіанти, використовується загальний, непрозорий код шейдера.",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Експорт у форматі спрайту Unity. Неможливо переглянути за межами Unity.",
    "sprite_format_texture": "Текстура",
    "sprite_format_texture_description": "Експортувати як зображення аркуша спрайтів. Можна переглядати за межами Unity, але експорт повільніше.",
    "sprite_format_yaml_description": "Експорт як yaml-активи, які можна переглянути в редакторі. Це єдиний режим, який забезпечує точне відновлення всіх метаданих спрайтів.",
    "submesh_count": "Підрахунок субмешу",
    "swagger_documentation": "Документація Swagger",
    "target_version_for_version_changing": "Цільова версія для зміни версії",
    "terrain_format_heatmap": "Карта висот (Heightmap)",
    "text_asset_format_binary_description": "Експортувати необроблені дані текстового ресурсу як файл у форматі BYTES.",
    "warning_this_directory_is_not_empty_all_content_will_be_deleted": "Увага: ця директорія не порожня. Весь вміст буде видалено.",
    "asset_tab_development": "Розробка",
    "asset_tab_information": "Інформація",
    "assembly_name": "Назва Збірки",
    "asset_bundle_name": "Назва Asset Bundle",
    "asset_tab_hex": "Hex",
    "bundle": "Пакет (Bundle)",
    "main_asset": "Головні Асети",
    "asset_tab_model": "Модель",
    "audio_clip": "АудіоКліп",
    "class": "Клас",
    "assets": "Активи",
    "class_id_type_number": "Номер типу ідентифікатора класу",
    "class_name": "Ім'я Класу",
    "collection": "Колекція",
    "collections": "Колекції",
    "commands": "Команди",
    "menu_import": "Імпорт",
    "menu_view": "Вигляд",
    "mesh": "Меш (Mesh)",
    "mesh_format_glb": "GLB",
    "namespace": "Простір імен(Namespace)",
    "no_data_has_been_loaded_for_this_key": "Немає даних для цього ключа.",
    "no_files_loaded": "Файли не завантажено",
    "not_implemented_yet": "Ще не реалізовано",
    "original_path": "Оригінальний шлях",
    "path_id": "Ідентифікатор шляху",
    "open_api_json": "ОpenAPI JSОN",
    "parent": "Батько",
    "privacy": "Конфіденційність",
    "remove": "Видалити",
    "replace": "Замінити",
    "resources": "Ресурси",
    "save": "Зберегти",
    "save_raw_data": "Зберегти необроблену інформацію",
    "save_settings_to_disk": "Зберегти параметри на диск",
    "scene": "Сцена",
    "script": "Скрипт",
    "script_content_level_0": "Рівень 0",
    "script_content_level_1": "Рівень 1",
    "there_are_no_keys_for_this_data_type": "Для цього типу даних немає ключів.",
    "transform": "Перетворення (Transform)",
    "vertex_count": "Кількість вершин",
    "export_primary_content": "Експорт основного контенту",
    "export_unity_project": "Експортувати проєкт Unity",
    "premium_feature_notice": "Преміум-функція",
    "create_subfolder": "Створити субпапки",
    "publicize_assemblies": "Оприлюднювати Assemblies",
    "remove_nullable_attributes": "Видалити нульові атрибути",
    "scripts_use_fully_qualified_type_names": "Скрипти використовують повні імена типів",
    "select_files": "Вибрати файли",
    "select_folders": "Вибрати папки",
    "file_id": "ID файлу"
}

```

`Localizations/zh_Hans.json`:

```json
{
    "asset_tab_audio": "音频（Audio）",
    "asset_tab_audio_duration_unknown": "<未知>",
    "asset_tab_audio_pause": "暂停",
    "asset_tab_audio_play": "播放",
    "asset_tab_basic": "基本信息",
    "asset_tab_image": "图像（Image）",
    "asset_tab_text": "文本（Text）",
    "asset_tab_yaml": "Yaml",
    "audio_export_title": "音频（Audio）导出格式",
    "audio_format_default": "默认",
    "audio_format_default_description": "将资源导出为嵌入在 FSB 中的内容类型。大多数音频类型都导出为 WAV，部分导出为 OGG。",
    "audio_format_force_wav": "转换成 WAV",
    "audio_format_force_wav_description": "将所有音频文件转换为 WAV 文件。 不建议在导入 Unity 时使用，以避免重复压缩造成的音质损失。",
    "audio_format_native": "原始格式（Raw）",
    "audio_format_native_description": "原始 FSB 音频。无法导入至 Unity，仅建议高级用户使用。",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "导出为 Yaml 资源和 resS 文件。这是一项安全设置，出现问题时可以将其作为备份。",
    "bundled_assets_export_direct_export": "直接导出",
    "bundled_assets_export_direct_export_description": "捆绑资源（Bundled Assets）已在未分组的情况下导出。",
    "bundled_assets_export_group_by_asset_type": "按资源类型（Asset Type）分组",
    "bundled_assets_export_group_by_asset_type_description": "捆绑资源（Bundled Assets）的处理方式与来自其他文件中的资源（Assets）相同。",
    "bundled_assets_export_group_by_bundle_name": "按包名（Bundle Name）分组",
    "bundled_assets_export_group_by_bundle_name_description": "捆绑资源（Bundled Assets）已按其资源包名（Asset Bundle Name）分组。",
    "bundled_assets_export_title": "捆绑资源（Bundled Assets）导出模式",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "自动 - 实验性",
    "c_sharp_langage_version_config_auto_safe": "自动 - 安全",
    "c_sharp_langage_version_config_latest": "C# 最新版本",
    "c_sharp_language_version_config_description": "反编译脚本时所用的 C# 语言版本。",
    "check_log_for_more_details": "查看日志以获取更多信息",
    "config_options": "配置选项",
    "config_screen_drag_drop_prompt": "请注意，更改某些设置可能会导致或预防错误发生。\n准备好后，将你的游戏文件/文件夹拖放到此窗口中，或使用左上角的菜单手动打开它们。",
    "enable_prefab_outlining": "启用显示预制件（Prefab）轮廓",
    "enable_static_mesh_separation": "启用静态网格（Static Mesh）分离",
    "error": "错误",
    "error_exporting_with_reason": "导出游戏内容失败: {0}",
    "error_importing_with_reason": "载入游戏内容失败: {0}",
    "export_complete": "导出完成！",
    "export_deleting_old_files": "正在清理已有文件...",
    "export_in_progress": "正在导出资源文件\n{0} %\n{1} / {2}",
    "export_in_progress_no_file_count_yet": "正在导出资源文件\n0.0%\n?/?",
    "export_preparing": "正在准备导出...\n这可能需要几分钟。",
    "ignore_engine_assets": "忽略引擎资源（Engine Assets）",
    "image_export_title": "图片（Image）导出格式",
    "image_format_description": "这会对所有导出的图片（Image）生效。",
    "loading_game_content_from": "正在从 {0} 读取游戏内容\n{1}",
    "loading_step_begin_scheme_processing": "开始处理方案",
    "loading_step_create_file_collection": "正在创建文件合集",
    "loading_step_detect_platform": "正在收集文件并检测游戏架构",
    "loading_step_generate_dummy_dll": "正在从 IL2Cpp 生成 Mono 程序集",
    "loading_step_initialize_layout": "正在初始化资源布局",
    "loading_step_load_assemblies": "正在加载程序集",
    "loading_step_load_assets_from_file": "正在从 {0} 读取资源",
    "loading_step_locate_key_functions": "正在扫描库函数的 IL2Cpp 二进制文件",
    "loading_step_parse_archive": "正在解析 Archive 文件 {0}",
    "loading_step_parse_bundle": "正在解析 Bundle 资源 {0}",
    "loading_step_parse_il2cpp_metadata": "正在解析 IL2Cpp 元数据",
    "loading_step_parse_resource": "正在解析资源文件 {0}",
    "loading_step_parse_serialized": "正在解析已序列化的文件 {0}",
    "loading_step_parse_web": "正在解析 Web 文件 {0}",
    "loading_step_pre_processing": "正在预处理文件",
    "loading_step_restore_attributes": "正在恢复已生成程序集的属性",
    "loose_file_saved_at": "已将松散文件（Loose File）保存至 {0}",
    "menu_export": "导出",
    "menu_export_all": "导出所有文件",
    "menu_export_selected": "导出选中文件",
    "menu_export_selected_type": "导出所选类型的所有文件",
    "menu_file": "文件",
    "menu_file_exit": "退出程序",
    "menu_file_open_file": "打开文件",
    "menu_file_open_folder": "打开文件夹",
    "menu_file_reset": "重置",
    "menu_language": "语言",
    "mesh_export_title": "网格（Mesh）导出格式",
    "mesh_format_glb": "GLB",
    "mesh_format_glb_description": "FBX 的高品质开源替代格式。它是 GLTF 的二进制版本，只包含 Mesh 数据。可能会导致错误。 Unity 无法导入这种类型的资源。",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "一种在 Unity 编辑器中使用网格（Mesh）的强大格式。可以通过各种各样的 Unity 包转换成其他格式。",
    "no_game_files_found": "在导入的文件中未找到 Unity 游戏或Asset Bundle。",
    "not_implemented_yet": "尚未实现",
    "script_content_level_0": "0级",
    "script_content_level_0_description": "脚本未导出。",
    "script_content_level_1": "1级",
    "script_content_level_1_description": "从反编译导出中移除方法（Strip Method）。",
    "script_content_level_2": "2级",
    "script_content_level_2_description": "默认。这会导出 Mono 游戏的完整方法和 IL2Cpp 游戏的虚拟方法。",
    "script_content_level_3": "3级",
    "script_content_level_3_description": "尽可能安全地恢复 IL2Cpp 方法。",
    "script_content_level_4": "4级",
    "script_content_level_4_description": "在不考虑安全性的情况下恢复 IL2Cpp 方法。",
    "script_content_level_title": "脚本（Script）内容级别",
    "script_export_format_decompiled": "反编译",
    "script_export_format_decompiled_description": "ILSpy 反编译器用于生成 C# 源码。 这是可靠的，但非常耗时并且可能会包含许多编译错误。",
    "script_export_format_dll_with_renaming": "导出重命名后的 DLL",
    "script_export_format_dll_without_renaming": "导出未重命名的 DLL",
    "script_export_format_dll_without_renaming_description": "程序集以编译的 DLL 格式导出。Unity 可能会覆写特殊的程序集（如 Assembly-CSharp）。",
    "script_export_format_hybrid": "混合",
    "script_export_title": "脚本（Script）导出格式",
    "script_language_version_title": "C# 语言版本",
    "select_asset_to_view_info": "从左侧选择资源以查看其相关信息",
    "shader_asset_export_title": "着色器（Shader）导出格式",
    "shader_asset_format_decompile": "反编译",
    "shader_asset_format_decompile_description": "将着色器（Shader）导出为 ShaderLab。非常实验性，几乎肯定会有错误。仅支持 DX11，不支持 DX9。",
    "shader_asset_format_disassembly": "反汇编",
    "shader_asset_format_disassembly_description": "将着色器（Shader）反汇编并导出。 此选项为实验性且容易损坏。这不会在 Unity Editor 中编译。",
    "shader_asset_format_dummy": "虚拟着色器（Dummy Shader）",
    "shader_asset_format_dummy_description": "将着色器（Shader）导出为虚拟着色器（Dummy Shader）。 尽管它保留了 Properties 和 FallBack 等数据，但它使用了通用且不透明的着色器（Shader）代码。",
    "shader_asset_format_yaml": "Yaml 资源",
    "shader_asset_format_yaml_description": "将着色器（Shader）导出为 Yaml 资源。实验性功能，仅可用于在 Unity Editor 中查看。Unity Editor 的预设行为可能会损坏这些文件。",
    "skip_streaming_assets": "跳过 SteamingAssets 目录",
    "sprite_export_title": "精灵（Sprite）导出格式",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "导出为 Unity 精灵（Sprite）格式。不能在 Unity 外查看。",
    "sprite_format_texture": "纹理（Texture）",
    "sprite_format_texture_description": "导出为 Sprite Sheet 格式的图片。 可以在 Unity 外查看，但导出速度更慢。",
    "sprite_format_yaml": "Yaml",
    "sprite_format_yaml_description": "导出成能够在文字编辑器中查看的 Yaml 资源格式。这是确保能精准恢复所有精灵（Sprites）元数据的唯一模式。",
    "success": "成功！",
    "terrain_export_title": "地形（Terrain）导出格式",
    "terrain_format_heatmap": "高度贴图（Heightmap）",
    "terrain_format_heatmap_description": "根据每个位置的地形 （Terrain）高度导出热图（Heatmap）。这只在您不关心细节或是拥有 3D 地形时才真正有用。",
    "terrain_format_mesh": "3D 网格（3D Mesh）",
    "terrain_format_mesh_description": "将地形（Terrain）导出为 GLB 格式的 3D 网格（3D Mesh），适用于使用各种 3D 编辑器查看。",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "导出为原生的 Unity 地形（Terrain）格式。此选项最适用于会将其重新导入至 Unity 的情况。",
    "text_asset_export_title": "文本资源（TextAsset）导出格式",
    "text_asset_format_binary": "字节（Bytes）",
    "text_asset_format_binary_description": "将原始的文本资源（Text Asset）导出为二进制数据（不对 Text Asset 的实际格式进行猜测）。",
    "text_asset_format_parse": "解析（Parse）",
    "text_asset_format_parse_description": "导出为纯文本（Plain Text）文件，并尝试猜测其正确的文件扩展名（例如：JSON 文件会用 .json 扩展名）。",
    "text_asset_format_text": "纯文本（Plain Text）",
    "text_asset_format_text_description": "导出为纯文本文件（.txt）。",
    "welcome_title": "欢迎使用 AssetRipper",
    "donation_message": "如果您喜欢 AssetRipper，请考虑捐助我们：",
    "script": "脚本（Script）",
    "script_export_format_hybrid_description": "特殊的程序集（如 Assembly-CSharp）进行反编译。其他程序集以编译的 DLL 格式导出。",
    "audio_clip": "音频剪辑（AudioClip）",
    "bundle": "包（Bundle）",
    "bundles": "包（Bundles）",
    "asset_tab_information": "信息（Info）",
    "assets": "资源（Assets）",
    "asset_tab_development": "开发（Development）",
    "asset_tab_hex": "十六进制（Hex）",
    "assembly_name": "程序集名（Assembly Name）",
    "asset_bundle_name": "资源包名（Asset Bundle Name）",
    "default_version": "默认版本",
    "licenses": "许可",
    "csharp_type": "C# 类型",
    "game_object": "游戏对象（GameObject）",
    "format": "格式",
    "home": "主页",
    "height": "高度",
    "length": "长度",
    "json": "JSON",
    "data": "数据（Data）",
    "class": "类（Class）",
    "class_name": "类名（Class Name）",
    "count": "数量（Count）",
    "guid": "全局唯一标识符（GUID）",
    "mesh": "网格（Mesh）",
    "original_path": "源路径",
    "scene": "场景（Scene）",
    "privacy": "隐私（Privacy）",
    "path": "路径",
    "parent": "父项（Parent）",
    "resources": "资源（Resources）",
    "save": "保存",
    "no_files_loaded": "未加载任何文件",
    "namespace": "命名空间（Namespace）",
    "name": "名称（Name）",
    "main_asset": "主要资源（Main Asset）",
    "path_id": "路径 ID（Path ID）",
    "shader": "着色器（Shader）",
    "submesh_count": "子网格数（Submesh Count）",
    "texture": "纹理（Texture）",
    "welcome": "欢迎",
    "width": "宽度",
    "yaml": "Yaml",
    "vertex_count": "顶点数（Vertex Count）",
    "view_loaded_files": "查看已导入文件",
    "transform": "变换（Transform）",
    "collections": "合集",
    "collection": "合集",
    "frequency": "频率",
    "channels": "声道",
    "class_id_type_name": "类 ID 类型名（Class ID Type Name）",
    "class_id_type_number": "类 ID 类型号（Class ID Type Number）",
    "settings_can_only_be_changed_before_loading_files": "仅可在加载文件前修改设置。",
    "an_error_occured_during_decompilation": "反编译时出现错误。",
    "appreciation_message": "感谢您支持 AssetRipper！",
    "asset_tab_font": "字体（Font）",
    "asset_tab_dependencies": "依赖项（Dependencies）",
    "asset_ripper_free": "AssetRipper 自由分发版",
    "asset_ripper_premium": "AssetRipper 高级版",
    "configuration_files": "配置文件",
    "configuration_files_lists": "列表（List）",
    "configuration_files_singletons": "单项（Singletons）",
    "lightmap_texture_export_title": "光照贴图（Lightmap）导出格式",
    "lightmap_texture_format_description": "这会对所有导出的光照贴图（Lightmap）生效。",
    "load": "载入",
    "no_data_has_been_loaded_for_this_key": "未为此键加载任何数据。",
    "save_raw_data": "保存原始数据",
    "save_settings_to_disk": "将设置保存到本地",
    "settings": "设置",
    "target_version_for_version_changing": "要更改到的目标版本",
    "failed_files": "失败的文件",
    "commands": "命令",
    "asset_tab_model": "模型（Model）",
    "enable_asset_deduplication": "启用清除重复资源（Asset）",
    "experimental": "实验性",
    "menu_import": "导入",
    "menu_load": "载入",
    "menu_view": "查看",
    "open_api_json": "OpenAPI JSON 文档",
    "remove": "移除",
    "replace": "替换",
    "select_file": "选择文件",
    "select_folder": "选择文件夹",
    "size": "大小",
    "swagger_documentation": "Swagger 文档",
    "there_are_no_keys_for_this_data_type": "该数据类型并无任何键。",
    "warning_this_directory_is_not_empty_all_content_will_be_deleted": "警告：该目录非空，目录内的所有内容将会被删除。",
    "export_primary_content": "导出主要内容",
    "export_unity_project": "导出为 Unity 项目",
    "asset_tab_video": "视频（Video）",
    "stack_trace": "堆栈跟踪",
    "c_sharp_langage_version_config_12_0": "C# 12",
    "not_available_in_the_free_edition": "在自由分发版中不可用。",
    "override_path": "重载路径",
    "premium_feature_notice": "高级功能",
    "create_subfolder": "创建子文件夹",
    "select_folders": "选择多个文件夹",
    "publicize_assemblies": "公开化程序集的私有成员",
    "scripts_use_fully_qualified_type_names": "在脚本中使用完整的（fully-qualified）类型名",
    "select_files": "选择多个文件",
    "remove_nullable_attributes": "移除可为空的属性（Attribute）",
    "file_id": "文件 ID",
    "c_sharp_langage_version_config_13_0": "C# 13",
    "c_sharp_langage_version_config_14_0": "C# 14",
    "export_directory_delete_user_confirmation": "所选导出目录已存在，将会删除其中所有内容。要继续吗？",
    "export_unreadable_assets": "导出无法读取的资源（Asset）",
    "filter": "筛选",
    "install_unity_editor": "安装 Unity 编辑器",
    "install_unity_hub": "安装 Unity Hub",
    "menu_development": "开发",
    "no_shaders_found": "未找到着色器（Shader）",
    "no_meshes_found": "未找到网格（Mesh）",
    "no_static_meshes_found": "未找到静态网格（Static Mesh）",
    "not_supported": "不被支持",
    "premium_features": "更多高级功能",
    "shader_decompilation": "反编译着色器（Shader）",
    "static_mesh_separation": "分离静态网格（Static Mesh）",
    "supported": "已支持",
    "all": "全部"
}

```

`Localizations/zh_Hant.json`:

```json
{
    "asset_tab_audio": "音訊",
    "asset_tab_audio_duration_unknown": "<長度不明>",
    "asset_tab_audio_pause": "暫停",
    "asset_tab_audio_play": "播放",
    "asset_tab_basic": "基本資訊",
    "asset_tab_image": "圖片",
    "asset_tab_text": "文字",
    "asset_tab_yaml": "Yaml",
    "audio_export_title": "音訊匯出格式",
    "audio_format_default": "預設",
    "audio_format_default_description": "將資源匯出為嵌入在 FSB 的內容類型。大部分音訊類型匯出為 WAV，部分匯出為 OGG。",
    "audio_format_force_wav": "轉換成 WAV",
    "audio_format_force_wav_description": "將所有音訊檔轉換為 WAV 檔案。不建議在匯入 Unity 時使用，以避免重新壓縮造成品質損失。",
    "audio_format_native": "原始 (Raw)",
    "audio_format_native_description": "未經處理的 FSB 音訊。無法匯入 Unity 中，所以只有進階使用者才可以使用。",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "導出為 yaml 資產和 resS 文件。 這是一個安全的選擇，問題出現時也可以當備份。",
    "bundled_assets_export_direct_export": "直接匯出",
    "bundled_assets_export_direct_export_description": "Bundled assets在不分組的情況下導出。",
    "bundled_assets_export_group_by_asset_type": "按Asset分組",
    "bundled_assets_export_group_by_asset_type_description": "Bundled assets 的處理方式與其他文件中的assets相同。",
    "bundled_assets_export_group_by_bundle_name": "按Bundle名稱分組",
    "bundled_assets_export_group_by_bundle_name_description": "Bundled asset按其asset名稱分組。",
    "bundled_assets_export_title": "Bundled Assets 導出模式",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_auto_experimental": "自動 - 實驗性",
    "c_sharp_langage_version_config_auto_safe": "自動 - 安全",
    "c_sharp_langage_version_config_latest": "最新版本的 C#",
    "c_sharp_language_version_config_description": "反編譯時要使用的 C# 語言版本。",
    "check_log_for_more_details": "檢查紀錄以獲得更多細節",
    "config_options": "配置選項",
    "config_screen_drag_drop_prompt": "請注意，更改某些設定可能會導致或避開錯誤。\n準備就緒後，將遊戲檔案或資料夾拖曳到此視窗，或使用左上角的選單手動打開某些內容。",
    "enable_prefab_outlining": "啟用預設大綱",
    "enable_static_mesh_separation": "啟用靜態網格體分離",
    "error": "錯誤",
    "error_exporting_with_reason": "匯出此遊戲內容時發生錯誤： {0}",
    "error_importing_with_reason": "讀取此遊戲內容時發生錯誤： {0}",
    "export_complete": "匯出完成！",
    "export_deleting_old_files": "正在清除已經存在的檔案...",
    "export_in_progress": "正在匯出資源檔案\n{0} %\n{1} / {2}",
    "export_in_progress_no_file_count_yet": "正在匯出資源檔案\n0.0%\n?/?",
    "export_preparing": "正在準備匯出...\n這可能需要花費一些時間。",
    "image_export_title": "圖片匯出格式",
    "image_format_description": "影響所有匯出的圖片",
    "loading_game_content_from": "正在從 {0} 讀取遊戲內容\n{1}",
    "loading_step_begin_scheme_processing": "正在啟用 Scheme Processing",
    "loading_step_create_file_collection": "正在建立檔案叢集",
    "loading_step_detect_platform": "正在收集檔案並偵測遊戲架構",
    "loading_step_generate_dummy_dll": "從 IL2CPP 產生 Mono 架構的 Assembly 檔案",
    "loading_step_initialize_layout": "正在初始化資源架構",
    "loading_step_load_assemblies": "正在讀取 Assembly 檔案",
    "loading_step_load_assets_from_file": "正在從 {0} 讀取資源",
    "loading_step_locate_key_functions": "正在掃描 IL2CPP 函式庫",
    "loading_step_parse_archive": "正在解析 Archive 檔案 {0}",
    "loading_step_parse_bundle": "正在解析 Bundle 檔案 {0}",
    "loading_step_parse_il2cpp_metadata": "正在解析 IL2CPP Metadata",
    "loading_step_parse_resource": "正在解析資源檔案 {0}",
    "loading_step_parse_serialized": "正在解析已序列化檔案 {0}",
    "loading_step_parse_web": "正在解析 Web 檔案 {0}",
    "loading_step_pre_processing": "正在預處理檔案",
    "loading_step_restore_attributes": "正在恢復已產生的 Assembly 檔案的屬性",
    "loose_file_saved_at": "已將鬆散文件 (Loose File) 保存至 {0}",
    "menu_export": "匯出",
    "menu_export_all": "匯出所有檔案",
    "menu_export_selected": "匯出選取的檔案",
    "menu_export_selected_type": "匯出選取的檔案類型中的所有檔案",
    "menu_file": "檔案",
    "menu_file_exit": "退出 AssetRipper",
    "menu_file_open_file": "開啟檔案",
    "menu_file_open_folder": "開啟資料夾",
    "menu_file_reset": "重設",
    "menu_language": "語言",
    "mesh_export_title": "Mesh 匯出格式",
    "mesh_format_glb": "GLB",
    "mesh_format_glb_description": "FBX 的高品質開源替代格式。它是 GLTF 的二進制版本，只包含 Mesh 資料。可能會導致錯誤。Unity 無法匯入這種類型的資產。",
    "mesh_format_native": "Yaml",
    "mesh_format_native_description": "在編輯器中使用網格的強大格式。 可以通過各種unity包轉換成其他格式。",
    "no_game_files_found": "在拖入的檔案中找不到 Unity 遊戲或資源包。",
    "not_implemented_yet": "尚未實作",
    "script_content_level_0": "層級 0",
    "script_content_level_0_description": "不會匯出程式碼。",
    "script_content_level_1": "層級 1",
    "script_content_level_1_description": "透過反編譯匯出函式 (Method)。",
    "script_content_level_2": "層級 2",
    "script_content_level_2_description": "預設。這會匯出 Mono 架構的遊戲的完整函式 (Method) 或是 IL2Cpp 架構的遊戲的虛擬函式 (Method)。",
    "script_content_level_3": "層級 3",
    "script_content_level_3_description": "盡可能安全地恢復 IL2Cpp 的函式 (Method)。",
    "script_content_level_4": "層級 4",
    "script_content_level_4_description": "盡可能地恢復 IL2Cpp 的函式 (Method)，但不保證安全性。",
    "script_content_level_title": "指令碼內容層級",
    "script_export_format_decompiled": "反編譯",
    "script_export_format_decompiled_description": "ILSpy 反編譯器用於產生 C# 程式碼。這是可靠的。而代價是它非常耗時且包含許多編譯錯誤。",
    "script_export_format_dll_with_renaming": "匯出 DLL 並重新命名",
    "script_export_format_dll_without_renaming": "匯出 DLL 而沒有重新命名",
    "script_export_format_dll_without_renaming_description": "Assembly 檔案以其已編譯的 Dll 格式匯出。這個選項是實驗性的。可能毫無作用。",
    "script_export_format_hybrid": "Hybrid",
    "script_export_title": "指令碼匯出格式",
    "script_language_version_title": "C# 語言版本",
    "select_asset_to_view_info": "在左側選擇資源以查看它的相關資訊",
    "shader_asset_export_title": "Shader 匯出格式",
    "shader_asset_format_decompile": "反編譯",
    "shader_asset_format_decompile_description": "將 Shader 匯出為 ShaderLab。此選項非常實驗性，幾乎肯定會有錯誤。僅支持 DX11，不支持 DX9。",
    "shader_asset_format_disassembly": "反組譯",
    "shader_asset_format_disassembly_description": "將 Shader 反組譯後匯出。此選項為實驗性且容易破損。這不會在編輯器中編譯。",
    "shader_asset_format_dummy": "虛擬 Shader",
    "shader_asset_format_dummy_description": "將 Shader 匯出為虛擬 Shader。 儘管它保留了 Properties 和 FallBack 等資料，但它使用了通用且不透明的 Shader code。",
    "shader_asset_format_yaml": "Yaml 資源",
    "shader_asset_format_yaml_description": "將 Shader 匯出為 Yaml 資產。此選項為實驗性。僅可用於在編輯器中查看。編輯器的預設行為可能損壞這些文件。",
    "skip_streaming_assets": "跳過 StreamingAssets 目錄",
    "sprite_export_title": "Sprite 匯出格式",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "匯出為 Unity Sprite 格式。不能在 Unity 外檢視。",
    "sprite_format_texture": "紋理 (Texture)",
    "sprite_format_texture_description": "匯出成 Sprite Sheet 格式的圖片。可以在 Unity 外檢視，但匯出速度更慢。",
    "sprite_format_yaml": "Yaml",
    "sprite_format_yaml_description": "匯出成能夠在文字編輯器中查看的 Yaml 資產格式。這是確保能精準恢復所有 Sprites Metadata 的唯一模式。",
    "success": "成功！",
    "terrain_export_title": "Terrain 匯出格式",
    "terrain_format_heatmap": "高度圖 (Heightmap)",
    "terrain_format_heatmap_description": "根據每個位置的地形 (Terrain) 高度匯出熱點圖 (Heatmap)。這只在您不關心細節或是擁有 3D 地形時才真正有用。",
    "terrain_format_mesh": "3D Mesh",
    "terrain_format_mesh_description": "將 Terrain 匯出成 GLB 格式的 3D Mesh，適合使用各種 3D 編輯器查看。",
    "terrain_format_native": "Yaml",
    "terrain_format_native_description": "匯出為原生的 Unity Terrain 格式。如果您計劃重新匯入 Unity，此選項最適合使用。",
    "text_asset_export_title": "TextAsset 匯出格式",
    "text_asset_format_binary": "Bytes",
    "text_asset_format_binary_description": "將文字資產的原始資料 (Raw Bytes) 以副檔名 .bytes 的方式直接匯出 (不會猜測其文字資產的實際格式)。",
    "text_asset_format_parse": "剖析 (Parse)",
    "text_asset_format_parse_description": "匯出為純文字檔案，並嘗試猜測正確的檔案格式。 (例：JSON 格式檔案將會以 .json 作為副檔名)",
    "text_asset_format_text": "純文字",
    "text_asset_format_text_description": "匯出為純文字檔案 (.txt)",
    "welcome_title": "歡迎來到 AssetRipper",
    "asset_tab_font": "字型",
    "asset_ripper_free": "AssetRipper 免費版",
    "asset_bundle_name": "資源包名（Asset Bundle Name）",
    "asset_tab_hex": "十六進制（Hex）",
    "an_error_occured_during_decompilation": "在反編譯期間發生錯誤。",
    "appreciation_message": "感謝您對 AssetRipper 的支持！",
    "asset_tab_video": "影檔",
    "asset_tab_information": "資訊",
    "asset_tab_model": "模型",
    "all": "全部"
}

```

`README.md`:

```md
# AssetRipper

[![](https://img.shields.io/github/downloads/AssetRipper/AssetRipper/total.svg)](https://github.com/AssetRipper/AssetRipper/releases)
[![](https://img.shields.io/github/downloads/AssetRipper/AssetRipper/latest/total.svg)](https://github.com/AssetRipper/AssetRipper/releases/latest)
[![](https://img.shields.io/github/v/release/AssetRipper/AssetRipper)](https://github.com/AssetRipper/AssetRipper/releases/latest)
[![](https://weblate.samboy.dev/widgets/assetripper/-/gui/svg-badge.svg)](http://weblate.samboy.dev/engage/assetripper/)

AssetRipper is a tool for extracting assets from Unity serialized files (*CAB-*\*, *\*.assets*, *\*.sharedAssets*, etc.) and asset bundles (*\*.unity3d*, *\*.bundle*, etc.) and converting them into the native Unity engine format.

AssetRipper supports Unity versions from `3.5.0` to `6000.5.X`. However, support quality may vary slightly for different Unity versions.

# Premium Edition

[Patreon](https://www.patreon.com/ds5678) supporters at the `Premium` tier or higher receive access to the premium edition of AssetRipper. This edition includes additional [features and improvements](https://assetripper.github.io/AssetRipper/articles/PremiumFeatures.html).

# Donations

Your support helps maintain and improve AssetRipper. If you find this tool useful, please consider donating:

- [GitHub Sponsors](https://github.com/sponsors/ds5678)
- [Patreon](https://www.patreon.com/ds5678)
- [PayPal](https://paypal.me/ds5678)

Patreon donors receive special roles on our [Discord server](https://discord.gg/XqXa53W2Yh).

# Links

[Website](https://assetripper.github.io/AssetRipper/)

[Downloads](https://assetripper.github.io/AssetRipper/articles/Downloads.html)

[Road Map](https://assetripper.github.io/AssetRipper/articles/RoadMap.html)

[Credits](https://assetripper.github.io/AssetRipper/articles/Credits.html)

# Discord [![](https://img.shields.io/discord/867514400701153281?color=blue&label=AssetRipper)](https://discord.gg/XqXa53W2Yh)

The development of this project has a dedicated [Discord server](https://discord.gg/XqXa53W2Yh).

# Legal Disclaimers

AssetRipper is licensed under the [GNU General Public License v3.0](LICENSE.md).

Please be aware that using or distributing the output from this software may be against copyright legislation in your jurisdiction. You are responsible for ensuring that you're not breaking any laws.

This software is not sponsored by or affiliated with Unity Technologies or its affiliates. "Unity" is a registered trademark of Unity Technologies or its affiliates in the U.S. and elsewhere.

```

`Source/AssetRipper.AssemblyDumper.Downloader/AssetRipper.AssemblyDumper.Downloader.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.AssemblyDumper.Downloader\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.AssemblyDumper.Downloader\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="SharpCompress" Version="0.44.4" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.AssemblyDumper.Downloader/Program.cs`:

```cs
using SharpCompress.Archives;
using SharpCompress.Archives.Zip;
using System.Diagnostics;
using System.Net.Http;

namespace AssetRipper.AssemblyDumper.Downloader;

internal static class Program
{
	static async Task Main()
	{
		const string BinDirectory = "../../";
		const string ProjectDirectory = BinDirectory + "AssetRipper.AssemblyDumper/";
		string[] outputFolders =
		[
			ProjectDirectory + "Debug/",
			ProjectDirectory + "Release/",
		];
		(string, string)[] files =
		[
			("type_tree.tpk", @"https://nightly.link/AssetRipper/Tpk/workflows/type_tree_tpk/master/brotli_file.zip"),
			("engine_assets.tpk", @"https://nightly.link/AssetRipper/Tpk/workflows/engine_assets_tpk/master/brotli_file.zip"),
		];

		foreach ((string fileName, string url) in files)
		{
			Console.WriteLine($"Downloading {fileName}...");
			MemoryStream stream = await Download(url);
			Console.WriteLine($"Decompressing {fileName}...");
			byte[] data = DecompressZipFile(stream);
			Debug.Assert(data.Length > 0, "Decompressed data is empty.");
			foreach (string outputFolder in outputFolders)
			{
				Directory.CreateDirectory(outputFolder);
				string outputPath = outputFolder + fileName;
				Console.WriteLine($"Writing {outputPath}...");
				File.WriteAllBytes(outputPath, data);
			}
		}

		Console.WriteLine("Done!");
	}

	private static async Task<MemoryStream> Download(string url)
	{
		Stream stream;
		using (HttpClient client = new())
		{
			stream = await client.GetStreamAsync(url);
		}
		MemoryStream result = new();
		await stream.CopyToAsync(result);
		result.Position = 0;
		return result;
	}

	private static byte[] DecompressZipFile(Stream inputStream)
	{
		using ZipArchive archive = ZipArchive.Open(inputStream);
		ZipArchiveEntry entry = archive.Entries.Where(entry => !entry.IsDirectory).Single();
		using MemoryStream outputStream = new();
		entry.WriteTo(outputStream);
		return outputStream.ToArray();
	}
}

```

`Source/AssetRipper.AssemblyDumper.NativeEnumExtractor/AssetRipper.AssemblyDumper.NativeEnumExtractor.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.AssemblyDumper.NativeEnumExtractor\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.AssemblyDumper.NativeEnumExtractor\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AsmResolver.DotNet" Version="6.0.0-beta.5" />
		<PackageReference Include="AsmResolver.Symbols.Pdb" Version="6.0.0-beta.5" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.DocExtraction\AssetRipper.DocExtraction.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.AssemblyDumper.NativeEnumExtractor/Program.cs`:

```cs
using AsmResolver;
using AsmResolver.PE.DotNet.Metadata.Tables;
using AsmResolver.Symbols.Pdb;
using AsmResolver.Symbols.Pdb.Leaves;
using AsmResolver.Symbols.Pdb.Msf;
using AsmResolver.Symbols.Pdb.Records;
using AssetRipper.DocExtraction.MetaData;

namespace AssetRipper.AssemblyDumper.NativeEnumExtractor;

internal class Program
{
	//private static IErrorListener ErrorListener { get; } = EmptyErrorListener.Instance;
	private static IErrorListener ErrorListener { get; } = new DiagnosticBag();
	//private static IErrorListener ErrorListener { get; } = ThrowErrorListener.Instance;

	static void Main(string[] args)
	{
		string path = args[0];
		string unityVersion = args[1];
		MsfFile file = MsfFile.FromFile(path);
		PdbImage image = PdbImage.FromFile(file, new PdbReaderParameters(ErrorListener));
		//WriteSymbolsToFile(image.Symbols, "symbols.txt");
		PrintUnknownTypes(image.Symbols);
		List<UserDefinedTypeSymbol> complexTypes = GetComplexTypes(image.Symbols);
		HashSet<EnumTypeRecord> enumRecords = GetEnumRecords(image.Symbols);
		List<ConstantSymbol> constants = GetNonEnumConstants(image.Symbols);
		DocumentationFile documentationFile = MakeDocumentationFile(enumRecords, unityVersion);
		documentationFile.SaveAsJson("native_enums.json");
		Console.WriteLine($"{image.Symbols.Count} symbols!");
	}

	private static DocumentationFile MakeDocumentationFile(IEnumerable<EnumTypeRecord> records, string unityVersion)
	{
		DocumentationFile file = new();
		file.UnityVersion = unityVersion;
		foreach (EnumTypeRecord record in records)
		{
			EnumDocumentation? documentation = ParseEnumRecord(record);
			if (documentation is not null)
			{
				file.Enums.Add(documentation);
			}
		}
		return file;
	}

	private static HashSet<EnumTypeRecord> GetEnumRecords(IList<ICodeViewSymbol> symbols)
	{
		HashSet<EnumTypeRecord> records = new();
		foreach (ICodeViewSymbol symbol in symbols)
		{
			if (symbol is ConstantSymbol constantSymbol && constantSymbol.ConstantType is EnumTypeRecord enumRecord)
			{
				records.Add(enumRecord);
			}
		}
		return records;
	}

	private static List<ConstantSymbol> GetNonEnumConstants(IList<ICodeViewSymbol> symbols)
	{
		List<ConstantSymbol> records = [];
		foreach (ICodeViewSymbol symbol in symbols)
		{
			if (symbol is ConstantSymbol constantSymbol
				&& constantSymbol.ConstantType is not null and not EnumTypeRecord
				&& IsValidName(constantSymbol.Name.ToString().Trim()))
			{
				records.Add(constantSymbol);
			}
		}
		return records;
	}

	private static List<UserDefinedTypeSymbol> GetComplexTypes(IList<ICodeViewSymbol> symbols)
	{
		List<UserDefinedTypeSymbol> records = [];
		foreach (ICodeViewSymbol symbol in symbols)
		{
			if (symbol is UserDefinedTypeSymbol constantSymbol
				&& constantSymbol.SymbolType is ClassTypeRecord)
			{
				records.Add(constantSymbol);
			}
		}
		return records;
	}

	private static bool IsValidName(string? name)
	{
		return !string.IsNullOrEmpty(name) && !name.Contains('<') && !name.StartsWith("std::", StringComparison.Ordinal);
	}

	private static void PrintUnknownTypes(IList<ICodeViewSymbol> symbols)
	{
		foreach ((CodeViewSymbolType type, HashSet<int> sizes) in GetUnknownTypes(symbols))
		{
			Console.WriteLine($"Unknown Type: {type}");
			Console.WriteLine($"Sizes: {string.Join(", ", sizes)}");
			Console.WriteLine();
		}
	}

	private static Dictionary<CodeViewSymbolType, HashSet<int>> GetUnknownTypes(IList<ICodeViewSymbol> symbols)
	{
		Dictionary<CodeViewSymbolType, HashSet<int>> unknownTypes = new();
		foreach (ICodeViewSymbol symbol in symbols)
		{
			if (symbol is UnknownSymbol unknownSymbol)
			{
				if (!unknownTypes.TryGetValue(unknownSymbol.CodeViewSymbolType, out HashSet<int>? sizes))
				{
					sizes = [];
					unknownTypes.Add(unknownSymbol.CodeViewSymbolType, sizes);
				}
				sizes.Add(unknownSymbol.Data.Length);
			}
		}
		return unknownTypes;
	}

	private static void WriteSymbolsToFile(IList<ICodeViewSymbol> symbols, string path)
	{
		using FileStream stream = File.Create(path);
		using StreamWriter writer = new(stream);
		foreach (ICodeViewSymbol symbol in symbols)
		{
			switch (symbol)
			{
				case ConstantSymbol constantSymbol:
					writer.WriteLine($"Constant, Value: {constantSymbol.Value} Type: {constantSymbol.ConstantType?.LeafKind} Name: {constantSymbol.Name}");
					break;
				case PublicSymbol publicSymbol:
					if (publicSymbol.IsCode)
					{
						Console.WriteLine($"Public Code: {publicSymbol.Name}");
					}
					writer.WriteLine($"Public, Function: {publicSymbol.IsFunction} Name: {publicSymbol.Name}");
					break;
				case UserDefinedTypeSymbol userDefinedTypeSymbol:
					writer.WriteLine($"User Defined Type, {userDefinedTypeSymbol.SymbolType?.LeafKind} Name: {userDefinedTypeSymbol.Name}");
					break;
				case UnknownSymbol unknownSymbol:
					writer.WriteLine($"Unknown, Type: {unknownSymbol.CodeViewSymbolType} Size: {unknownSymbol.Data.Length}");
					break;
			}
		}
	}

	private static EnumDocumentation? ParseEnumRecord(EnumTypeRecord record)
	{
		if (record.Fields is null)
		{
			return null;
		}

		string cppName = record.Name;
		if (cppName.Contains('<') || cppName.Contains('>'))
		{
			return null;//No generics or anonymous enums
		}
		string[] nameSegments = cppName.Split("::", StringSplitOptions.RemoveEmptyEntries);

		EnumDocumentation documentation = new();
		documentation.Name = nameSegments[^1];
		documentation.FullName = string.Join('.', nameSegments);
		documentation.ElementType = ((SimpleTypeRecord)record.BaseType!).Kind switch
		{
			SimpleTypeKind.SignedCharacter => ElementType.I1,
			SimpleTypeKind.UnsignedCharacter => ElementType.U1,
			SimpleTypeKind.SByte => ElementType.I1,
			SimpleTypeKind.Byte => ElementType.U1,
			SimpleTypeKind.Int16Short or SimpleTypeKind.Int16 => ElementType.I2,
			SimpleTypeKind.UInt16Short or SimpleTypeKind.UInt16 => ElementType.U2,
			SimpleTypeKind.Int32Long or SimpleTypeKind.Int32 => ElementType.I4,
			SimpleTypeKind.UInt32Long or SimpleTypeKind.UInt32 => ElementType.U4,
			SimpleTypeKind.Int64Quad or SimpleTypeKind.Int64 => ElementType.I8,
			SimpleTypeKind.UInt64Quad or SimpleTypeKind.UInt64 => ElementType.U8,
			_ => throw new NotSupportedException(),
		};

		foreach (EnumerateField field in record.Fields!.Entries.Cast<EnumerateField>())
		{
			EnumMemberDocumentation enumMember = new();
			enumMember.Name = field.Name;
			enumMember.Value = field.Value switch
			{
				byte b => unchecked((sbyte)b),
				ushort us => unchecked((short)us),
				uint ui => unchecked((int)ui),
				ulong ul => unchecked((long)ul),
				sbyte sb => sb,
				short s => s,
				int i => i,
				long l => l,
				char c => unchecked((short)c),
				_ => throw new NotSupportedException()
			};
			documentation.Members.Add(enumMember.Name, enumMember);
		}

		return documentation;
	}
}

```

`Source/AssetRipper.AssemblyDumper.NuGetFixer/AssetRipper.AssemblyDumper.NuGetFixer.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.AssemblyDumper.NuGetFixer\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.AssemblyDumper.NuGetFixer\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="SharpCompress" Version="0.44.4" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.AssemblyDumper.NuGetFixer/Program.cs`:

```cs
using SharpCompress.Archives;
using SharpCompress.Archives.Zip;
using SharpCompress.Readers;
using SharpCompress.Readers.Zip;
using System.Xml.Linq;

namespace AssetRipper.AssemblyDumper.NuGetFixer;

internal static class Program
{
	static void Main(string[] args)
	{
		string nupkgFolder = args[0];
		string version = args[1];
		string nupkgFileName = $"AssetRipper.SourceGenerated.{version}.nupkg";
		string nupkgFilePath = Path.Combine(nupkgFolder, nupkgFileName);

		string tempDirectory = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
		Directory.CreateDirectory(tempDirectory);

		string packageDirectory = Path.Combine(tempDirectory, "package");
		Directory.CreateDirectory(packageDirectory);
		ExtractZip(nupkgFilePath, packageDirectory);

		// Modify the .nuspec file
		{
			string nuspecFilePath = Directory.GetFiles(packageDirectory, "*.nuspec", SearchOption.TopDirectoryOnly).Single();
			RemoveDependencyReferences(nuspecFilePath);
		}

		// Repackage the .nupkg file
		{
			string newNupkgFilePath = Path.Combine(AppContext.BaseDirectory, nupkgFileName);
			if (File.Exists(newNupkgFilePath))
			{
				File.Delete(newNupkgFilePath);
			}

			CreateZip(newNupkgFilePath, packageDirectory);
		}

		// Clean up the temporary directory
		Directory.Delete(tempDirectory, true);

		Console.WriteLine("Dependency references removed successfully.");
	}

	static void RemoveDependencyReferences(string nuspecFilePath)
	{
		XDocument doc = XDocument.Load(nuspecFilePath);

		XElement dependenciesElement = doc.GetChild("package")
			.GetChild("metadata")
			.GetChild("dependencies");
		foreach (XElement framework in dependenciesElement.Elements())
		{
			framework.Elements().Remove();
		}

		doc.Save(nuspecFilePath);
	}

	private static void CreateZip(string zipFilePath, string sourceDirectory)
	{
		using ZipArchive archive = ZipArchive.Create();
		using FileStream stream = File.Create(zipFilePath);
		archive.AddAllFromDirectory(sourceDirectory);
		archive.SaveTo(stream);
	}

	private static void ExtractZip(string zipFilePath, string targetDirectory)
	{
		using FileStream stream = File.OpenRead(zipFilePath);
		using ZipReader reader = ZipReader.Open(stream);
		reader.WriteAllToDirectory(targetDirectory, new SharpCompress.Common.ExtractionOptions()
		{
			ExtractFullPath = true,
			Overwrite = true
		});
	}

	private static XElement GetChild(this XContainer parent, string localName)
	{
		return parent.Elements().Single(x => x.Name.LocalName == localName);
	}
}

```

`Source/AssetRipper.AssemblyDumper.Recompiler/AssetRipper.AssemblyDumper.Recompiler.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.AssemblyDumper.Recompiler\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.AssemblyDumper.Recompiler\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.ICSharpCode.Decompiler" Version="10.0.0.8284-preview3" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.AssemblyDumper.Recompiler/Program.cs`:

```cs
using ICSharpCode.Decompiler;
using ICSharpCode.Decompiler.CSharp;
using ICSharpCode.Decompiler.CSharp.ProjectDecompiler;
using ICSharpCode.Decompiler.Metadata;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Recompiler;

internal static class Program
{
	private static int Year { get; } = DateTime.Now.Year;
	private static string? Version { get; set; }
	private static string CsProjContent => $"""
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net10.0</TargetFramework>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<Nullable>enable</Nullable>
		<AotCompatible>true</AotCompatible>
		<RootNamespace>AssetRipper</RootNamespace>

		<AssemblyName>AssetRipper.SourceGenerated</AssemblyName>
		<Copyright>Copyright © {Year}</Copyright>
		<Authors>ds5678</Authors>
		<Company>AssetRipper</Company>
		<Version>{Version}</Version>
		<AssemblyVersion>$(Version)</AssemblyVersion>

		<PackageId>AssetRipper.SourceGenerated</PackageId>
		<PackageTags>C# unity unity3d</PackageTags>
		<RepositoryUrl>https://github.com/AssetRipper/AssetRipper</RepositoryUrl>
		<PackageLicenseExpression>GPL-3.0-or-later</PackageLicenseExpression>
		<RepositoryType>git</RepositoryType>
		<PackageProjectUrl>https://github.com/AssetRipper/AssetRipper</PackageProjectUrl>
		<Copyright>Copyright (c) {Year} ds5678</Copyright>
		<Description>Internal source generated library for AssetRipper</Description>
		<GeneratePackageOnBuild>true</GeneratePackageOnBuild>
		<GenerateDocumentationFile>true</GenerateDocumentationFile>
		<DocumentationFile>bin\AssetRipper.SourceGenerated.xml</DocumentationFile>

		<NoWarn>1591,8600,8601,8602,8603,8604</NoWarn>
	</PropertyGroup>

	<ItemGroup>
		<Using Remove="@(Using)" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\..\..\..\AssetRipper.Assets\AssetRipper.Assets.csproj" />
		<ProjectReference Include="..\..\..\..\AssetRipper.Numerics\AssetRipper.Numerics.csproj" />
	</ItemGroup>

</Project>
""";
	static void Main(string[] args)
	{
		Stopwatch stopwatch = Stopwatch.StartNew();
		string assemblyPath = args[0];
		string outputDirectory = args[1];
		Version = args[2];
		ClearOrCreateDirectory(outputDirectory);
		UniversalAssemblyResolver resolver = new UniversalAssemblyResolver(assemblyPath, true, ".NETCoreApp, Version=10.0");
		WholeProjectDecompiler decompiler = new WholeProjectDecompiler(resolver);
		decompiler.Settings.SetLanguageVersion(LanguageVersion.Latest);
		decompiler.Settings.UseSdkStyleProjectFormat = true;
		decompiler.Settings.UseNestedDirectoriesForNamespaces = true;
		decompiler.ProgressIndicator = new ProgressIndicator();
		decompiler.DecompileProject(new PEFile(assemblyPath), outputDirectory, TextWriter.Null);
		DeleteBadFilesAndDirectories(outputDirectory);
		WriteCsProjFile(outputDirectory);
		stopwatch.Stop();
		Console.WriteLine($"Done in {stopwatch.ElapsedMilliseconds / 1000} seconds!");
	}

	private static void DeleteBadFilesAndDirectories(string outputDirectory)
	{
		Directory.Delete(Path.Combine(outputDirectory, "Properties"), true);
	}

	private static void WriteCsProjFile(string outputDirectory)
	{
		File.WriteAllText(Path.Combine(outputDirectory, "AssetRipper.SourceGenerated.csproj"), CsProjContent);
	}

	private static void ClearOrCreateDirectory(string directory)
	{
		if (Directory.Exists(directory))
		{
			Directory.Delete(directory, true);
		}
		Directory.CreateDirectory(directory);
	}

	private sealed class ProgressIndicator : IProgress<DecompilationProgress>
	{
		private readonly Lock lockObject = new();
		public void Report(DecompilationProgress value)
		{
			lock (lockObject)
			{
				Console.WriteLine($"{value.UnitsCompleted}/{value.TotalUnits} File: {value.Status}");
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper.Tests/AssetRipper.AssemblyDumper.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<IsPackable>false</IsPackable>
		<OutputPath>..\0Bins\Other\AssetRipper.AssemblyDumper.Tests\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.AssemblyDumper.Tests\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
		<PackageReference Include="NUnit" Version="4.4.0" />
		<PackageReference Include="NUnit3TestAdapter" Version="6.1.0" />
		<PackageReference Include="NUnit.Analyzers" Version="4.11.2">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.AssemblyDumper\AssetRipper.AssemblyDumper.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.AssemblyDumper.Tests/TypeSignatureNameTests.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using System.Text;

namespace AssetRipper.AssemblyDumper.Tests;

internal class TypeSignatureNameTests
{
	private ModuleDefinition module;
	private ReferenceImporter importer;

	[SetUp]
	public void Setup()
	{
		module = new ModuleDefinition("test", KnownCorLibs.SystemPrivateCoreLib_v5_0_0_0);
		importer = new ReferenceImporter(module);
	}

	[Test]
	public void AsmByteArrayName()
	{
		TypeSignature type = module.CorLibTypeFactory.Byte.MakeSzArrayType();
		Assert.That(type.Name, Is.EqualTo("Byte[]"));
	}

	[Test]
	public void AsmListTest()
	{
		TypeSignature list = importer.ImportTypeSignature(typeof(List<>));
		GenericInstanceTypeSignature stringList = list.MakeGenericInstanceType(module.CorLibTypeFactory.String);
		Assert.That(stringList.Name, Is.EqualTo("List`1<System.String>"));
		Assert.That(list.Name, Is.EqualTo("List`1"));
	}

	[Test]
	public void ByteArrayTest()
	{
		TypeSignature type = module.CorLibTypeFactory.Byte.MakeSzArrayType();
		Assert.That(GetName(type), Is.EqualTo("Byte_Array"));
	}

	[Test]
	public void DictionaryTest()
	{
		TypeSignature dictionary = importer.ImportTypeSignature(typeof(Dictionary<,>));
		Assert.That(GetName(dictionary), Is.EqualTo("Dictionary"));
	}

	[Test]
	public void DictionaryInstanceTest()
	{
		TypeSignature dictionary = importer.ImportTypeSignature(typeof(Dictionary<,>));
		GenericInstanceTypeSignature intStringDictionary = dictionary.MakeGenericInstanceType(module.CorLibTypeFactory.Int32, module.CorLibTypeFactory.String);
		Assert.That(GetName(intStringDictionary), Is.EqualTo("Dictionary_Int32_String"));
	}

	[Test]
	public void ListInstanceTest()
	{
		TypeSignature list = importer.ImportTypeSignature(typeof(List<>));
		GenericInstanceTypeSignature stringList = list.MakeGenericInstanceType(module.CorLibTypeFactory.String);
		Assert.That(GetName(stringList), Is.EqualTo("List_String"));
	}

	[Test]
	public void ListListInstanceTest()
	{
		TypeSignature list = importer.ImportTypeSignature(typeof(List<>));
		GenericInstanceTypeSignature stringList = list.MakeGenericInstanceType(module.CorLibTypeFactory.String);
		GenericInstanceTypeSignature stringListList = list.MakeGenericInstanceType(stringList);
		Assert.That(GetName(stringListList), Is.EqualTo("List_List_String"));
	}

	private static string GetName(TypeSignature type)
	{
		if (type is CorLibTypeSignature)
		{
			return type.Name ?? "";
		}
		else if (type is TypeDefOrRefSignature normalType)
		{
			string asmName = normalType.Name;
			int index = asmName.IndexOf('`');
			return index > -1 ? asmName.Substring(0, index) : asmName;
		}
		else if (type is SzArrayTypeSignature arrayType)
		{
			return $"{GetName(arrayType.BaseType)}_Array";
		}
		else if (type is GenericInstanceTypeSignature genericInstanceType)
		{
			string baseTypeName = GetName(genericInstanceType.GenericType.ToTypeSignature());
			StringBuilder sb = new StringBuilder();
			sb.Append(baseTypeName);
			foreach (TypeSignature typeArgument in genericInstanceType.TypeArguments)
			{
				sb.Append('_');
				sb.Append(GetName(typeArgument));
			}
			return sb.ToString();
		}
		else
		{
			throw new NotSupportedException($"GetName not support for {type.FullName} of type {type.GetType()}");
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper.Tests/Usings.cs`:

```cs
global using NUnit.Framework;
global using System;
```

`Source/AssetRipper.AssemblyDumper.Tests/VersionedListTests.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.Primitives;

namespace AssetRipper.AssemblyDumper.Tests;

internal class VersionedListTests
{
	[Test]
	public void DivisionTest()
	{
		VersionedList<int> integers = new()
		{
			{ new UnityVersion(3), 3 },
			{ new UnityVersion(4), 4 },
			{ new UnityVersion(5), 5 },
			{ new UnityVersion(2017), 7 },
		};
		Assert.That(integers.Count, Is.EqualTo(4));
		Assert.That(integers[2].Key, Is.EqualTo(new UnityVersion(5)));
		Assert.That(integers[3].Key, Is.EqualTo(new UnityVersion(2017)));

		integers.Divide(new UnityVersion(5));
		Assert.That(integers.Count, Is.EqualTo(4));
		Assert.That(integers[2].Key, Is.EqualTo(new UnityVersion(5)));
		Assert.That(integers[3].Key, Is.EqualTo(new UnityVersion(2017)));

		integers.Divide(new UnityVersion(2017));
		Assert.That(integers.Count, Is.EqualTo(4));
		Assert.That(integers[2].Key, Is.EqualTo(new UnityVersion(5)));
		Assert.That(integers[3].Key, Is.EqualTo(new UnityVersion(2017)));

		integers.Divide(new UnityVersion(6));
		Assert.That(integers.Count, Is.EqualTo(5));
		Assert.That(integers[2].Key, Is.EqualTo(new UnityVersion(5)));
		Assert.That(integers[3].Key, Is.EqualTo(new UnityVersion(6)));
		Assert.That(integers[4].Key, Is.EqualTo(new UnityVersion(2017)));
	}

	[Test]
	public void MergeTest1()
	{
		VersionedList<string> list1 = new()
		{
			{ new UnityVersion(3), "" },
			{ new UnityVersion(4), null },
			{ new UnityVersion(5), "Five" },
			{ new UnityVersion(2017), "Seven" },
		};
		VersionedList<string> list2 = new()
		{
			{ new UnityVersion(3, 5), "" },
			{ new UnityVersion(4), null },
			{ new UnityVersion(4, 5), "" },
			{ new UnityVersion(4, 7), null },
			{ new UnityVersion(2017), "Seven" },
		};

		VersionedList<string> merged = VersionedList.Merge(list1, list2);

		Assert.That(merged.Count, Is.EqualTo(6));
		Assert.That(merged[0].Key, Is.EqualTo(new UnityVersion(3)));
		Assert.That(merged[0].Value, Is.EqualTo(""));
		Assert.That(merged[1].Key, Is.EqualTo(new UnityVersion(4)));
		Assert.That(merged[1].Value, Is.EqualTo(null));
		Assert.That(merged[2].Key, Is.EqualTo(new UnityVersion(4, 5)));
		Assert.That(merged[2].Value, Is.EqualTo(""));
		Assert.That(merged[3].Key, Is.EqualTo(new UnityVersion(4, 7)));
		Assert.That(merged[3].Value, Is.EqualTo(null));
		Assert.That(merged[4].Key, Is.EqualTo(new UnityVersion(5)));
		Assert.That(merged[4].Value, Is.EqualTo("Five"));
		Assert.That(merged[5].Key, Is.EqualTo(new UnityVersion(2017)));
		Assert.That(merged[5].Value, Is.EqualTo("Seven"));
	}
}

```

`Source/AssetRipper.AssemblyDumper.Utils/AssetRipper.AssemblyDumper.Utils.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.AssemblyDumper.Utils\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.AssemblyDumper.Utils\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.Primitives" Version="3.2.0" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Numerics\AssetRipper.Numerics.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.AssemblyDumper.Utils/IDeepCloneable.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Utils;

public interface IDeepCloneable<T>
{
	T DeepClone();
}

```

`Source/AssetRipper.AssemblyDumper.Utils/VersionedList.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.Primitives;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Utils;

public static class VersionedList
{
	public static VersionedList<T> Merge<T>(VersionedList<T> first, VersionedList<T> second) where T : class
	{
		VersionedList<T> result = new();
		int i = 0;
		int j = 0;
		UnityVersion currentVersion;
		if (first.Count == 0)
		{
			if (second.Count == 0)
			{
				currentVersion = UnityVersion.MinVersion;
			}
			else
			{
				currentVersion = second[0].Key;
			}
		}
		else if (second.Count == 0)
		{
			currentVersion = first[0].Key;
		}
		else
		{
			UnityVersion firstMinVersion = first[0].Key;
			UnityVersion secondMinVersion = second[0].Key;
			currentVersion = firstMinVersion < secondMinVersion ? firstMinVersion : secondMinVersion;
		}
		while (true)
		{
			if (i == first.Count)
			{
				if (j == second.Count)
				{
					break;
				}
				else
				{
					result.AddIfDifferent(second[j]);
					j++;
					continue;
				}
			}
			else if (j == second.Count)
			{
				result.AddIfDifferent(first[i]);
				i++;
				continue;
			}

			Range<UnityVersion> firstRange = first.GetRange(i);
			Range<UnityVersion> secondRange = second.GetRange(j);

			if (firstRange.Intersects(secondRange, out Range<UnityVersion> intersection))
			{
				if (intersection.Start == currentVersion)
				{
					T? value = EnsureAtLeastOneNull(first[i].Value, second[j].Value);
					result.AddIfDifferent(intersection.Start, value);
					currentVersion = intersection.End;
					if (firstRange.End == intersection.End)
					{
						i++;
					}
					if (secondRange.End == intersection.End)
					{
						j++;
					}
				}
				else if (firstRange.Start == currentVersion)
				{
					result.AddIfDifferent(currentVersion, first[i].Value);
					currentVersion = intersection.Start;
				}
				else
				{
					Debug.Assert(secondRange.Start == currentVersion);
					result.AddIfDifferent(currentVersion, second[j].Value);
					currentVersion = intersection.Start;
				}
			}
			else if (firstRange.Start == currentVersion)
			{
				result.AddIfDifferent(currentVersion, first[i].Value);
				currentVersion = firstRange.End;
				i++;
			}
			else
			{
				Debug.Assert(secondRange.Start == currentVersion);
				result.AddIfDifferent(currentVersion, second[j].Value);
				currentVersion = secondRange.End;
				j++;
			}
		}
		return result;
	}

	private static void AddIfDifferent<T>(this VersionedList<T> list, KeyValuePair<UnityVersion, T?> pair)
	{
		list.AddIfDifferent(pair.Key, pair.Value);
	}

	private static void AddIfDifferent<T>(this VersionedList<T> list, UnityVersion version, T? value)
	{
		if (list.Count == 0 || !EqualityComparer<T>.Default.Equals(list[^1].Value, value))
		{
			list.Add(version, value);
		}
	}

	private static T? EnsureAtLeastOneNull<T>(T? first, T? second) where T : class
	{
		if (first is not null)
		{
			if (second is not null && !EqualityComparer<T>.Default.Equals(first, second))
			{
				throw new Exception("Both values are not null");
			}
			return first;
		}
		else
		{
			return second;
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper.Utils/VersionedListConverterFactory.cs`:

```cs
using AssetRipper.Primitives;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AssetRipper.AssemblyDumper.Utils;

public class VersionedListConverterFactory : JsonConverterFactory
{
	public override bool CanConvert(Type typeToConvert)
	{
		return typeToConvert.IsGenericType && typeToConvert.GetGenericTypeDefinition() == typeof(VersionedList<>);
	}

	public override JsonConverter CreateConverter(
		Type type,
		JsonSerializerOptions options)
	{
		Type valueType = type.GetGenericArguments()[0];

		JsonConverter converter = (JsonConverter)Activator.CreateInstance(
			typeof(VersionedListConverterInner<>).MakeGenericType([valueType]),
			BindingFlags.Instance | BindingFlags.Public,
			binder: null,
			args: [options],
			culture: null)!;

		return converter;
	}

	private class VersionedListConverterInner<TValue> : JsonConverter<VersionedList<TValue>>
	{
		private readonly JsonConverter<TValue?> _valueConverter;
		private readonly Type _valueType;

		public VersionedListConverterInner(JsonSerializerOptions options)
		{
			// For performance, use the existing converter if available.
			_valueConverter = (JsonConverter<TValue?>)options
				.GetConverter(typeof(TValue?));

			// Cache the key and value types.
			_valueType = typeof(TValue);
		}

		public override VersionedList<TValue> Read(
			ref Utf8JsonReader reader,
			Type typeToConvert,
			JsonSerializerOptions options)
		{
			if (reader.TokenType != JsonTokenType.StartObject)
			{
				throw new JsonException();
			}

			VersionedList<TValue> dictionary = [];

			while (reader.Read())
			{
				if (reader.TokenType == JsonTokenType.EndObject)
				{
					return dictionary;
				}

				// Get the key.
				if (reader.TokenType != JsonTokenType.PropertyName)
				{
					throw new JsonException();
				}

				string? propertyName = reader.GetString();

				UnityVersion key;
				if (propertyName is null)
				{
					throw new JsonException("Unable to parse UnityVersion from null string.");
				}
				else
				{
					try
					{
						key = UnityVersion.Parse(propertyName);
					}
					catch (Exception e)
					{
						throw new JsonException($"Unable to convert \"{propertyName}\" to UnityVersion.", e);
					}
				}

				// Get the value.
				TValue? value;
				if (_valueConverter != null)
				{
					reader.Read();
					value = _valueConverter.Read(ref reader, _valueType, options)!;
				}
				else
				{
					value = JsonSerializer.Deserialize<TValue>(ref reader, options)!;
				}

				// Add to dictionary.
				dictionary.Add(key, value);
			}

			throw new JsonException();
		}

		public override void Write(
			Utf8JsonWriter writer,
			VersionedList<TValue> dictionary,
			JsonSerializerOptions options)
		{
			writer.WriteStartObject();

			foreach ((UnityVersion key, TValue? value) in dictionary)
			{
				var propertyName = key.ToString();
				writer.WritePropertyName
					(options.PropertyNamingPolicy?.ConvertName(propertyName) ?? propertyName);

				if (_valueConverter != null)
				{
					_valueConverter.Write(writer, value, options);
				}
				else
				{
					JsonSerializer.Serialize(writer, value, options);
				}
			}

			writer.WriteEndObject();
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper.Utils/VersionedList`1.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.Primitives;
using System.Collections;
using System.Text.Json.Serialization;

namespace AssetRipper.AssemblyDumper.Utils;

[JsonConverter(typeof(VersionedListConverterFactory))]
public sealed class VersionedList<T> : IList<KeyValuePair<UnityVersion, T?>>
{
	private readonly List<KeyValuePair<UnityVersion, T?>> _list = new();
	private readonly Func<T?, T?> cloneFactory;

	public VersionedList()
	{
		if (typeof(T).IsAssignableTo(typeof(IDeepCloneable<T>)))
		{
			cloneFactory = (original) =>
			{
				//boxing could happen here
				return original is null ? default : ((IDeepCloneable<T>)original).DeepClone();
			};
		}
		else if (typeof(T).IsAssignableTo(typeof(ValueType)) || typeof(T) == typeof(string))
		{
			cloneFactory = (original) => original;
		}
		else
		{
			cloneFactory = (_) => throw new NotSupportedException();
		}
	}

	public VersionedList(Func<T?, T?> cloneFactory)
	{
		this.cloneFactory = cloneFactory;
	}

	public KeyValuePair<UnityVersion, T?> this[int index]
	{
		get => _list[index];
		set
		{
			if (index > 0 && value.Key <= this[index - 1].Key)
			{
				throw new ArgumentException(null, nameof(value));
			}
			if (index < Count - 1 && value.Key >= this[index + 1].Key)
			{
				throw new ArgumentException(null, nameof(value));
			}
			_list[index] = value;
		}
	}

	public int Count => _list.Count;

	public int Capacity { get => _list.Capacity; set => _list.Capacity = value; }

	public bool IsReadOnly => false;

	/// <summary>
	/// Throws if <see cref="Count"/> == 0
	/// </summary>
	private UnityVersion MostRecentVersion => this[^1].Key;

	public void Add(KeyValuePair<UnityVersion, T?> pair)
	{
		if (Count > 0 && pair.Key <= MostRecentVersion)
		{
			throw new Exception($"Version {pair.Key} was not greater than the most recent version {MostRecentVersion}");
		}
		else
		{
			_list.Add(pair);
		}
	}

	public void Add(UnityVersion version, T? item) => Add(new KeyValuePair<UnityVersion, T?>(version, item));

	public void Clear() => _list.Clear();

	public bool Contains(KeyValuePair<UnityVersion, T?> item) => _list.Contains(item);

	public void CopyTo(KeyValuePair<UnityVersion, T?>[] array, int arrayIndex) => _list.CopyTo(array, arrayIndex);

	public T? GetItemForVersion(UnityVersion version)
	{
		if (Count == 0 || this[0].Key > version)
		{
			return default;
		}

		for (int i = 0; i < Count - 1; i++)
		{
			if (this[i].Key <= version && version < this[i + 1].Key)
			{
				return this[i].Value;
			}
		}

		return this[Count - 1].Value;
	}

	public T? GetLastValue()
	{
		return Count != 0 ? _list[Count - 1].Value : throw new InvalidOperationException();
	}

	public Range<UnityVersion> GetRange(int index)
	{
		return index == Count - 1
			? new Range<UnityVersion>(this[index].Key, UnityVersion.MaxVersion)
			: new Range<UnityVersion>(this[index].Key, this[index + 1].Key);
	}

	public Range<UnityVersion> GetRangeForItem(T item)
	{
		for (int i = 0; i < Count; i++)
		{
			if (EqualityComparer<T>.Default.Equals(this[i].Value, item))
			{
				return GetRange(i);
			}
		}

		throw new Exception($"Item not found: {item}");
	}

	public int IndexOf(KeyValuePair<UnityVersion, T?> item) => _list.IndexOf(item);

	public void Insert(int index, KeyValuePair<UnityVersion, T?> item)
	{
		if (index == Count)
		{
			Add(item);
		}
		else
		{
			throw new NotSupportedException();
		}
	}

	public bool Remove(KeyValuePair<UnityVersion, T?> item)
	{
		if (Count > 0 && EqualityComparer<KeyValuePair<UnityVersion, T?>>.Default.Equals(item, this[^1]))
		{
			_list.RemoveAt(Count - 1);
			return true;
		}
		else
		{
			return false;
		}
	}

	public void RemoveAt(int index)
	{
		if (index == Count - 1)
		{
			Pop();
		}
		else
		{
			throw new NotSupportedException();
		}
	}

	public void Pop()
	{
		if (Count > 0)
		{
			_list.RemoveAt(Count - 1);
		}
		else
		{
			throw new InvalidOperationException();
		}
	}

	public void Divide(UnityVersion divisionPoint)
	{
		if (Count == 0)
		{
			throw new InvalidOperationException();
		}

		if (divisionPoint < this[0].Key)
		{
			throw new ArgumentOutOfRangeException(nameof(divisionPoint), divisionPoint, null);
		}

		int insertionIndex = -1;
		T? clone = default;

		for (int i = 0; i < Count - 1; i++)
		{
			KeyValuePair<UnityVersion, T?> currentPair = this[i];
			if (currentPair.Key <= divisionPoint && divisionPoint < this[i + 1].Key)
			{
				if (currentPair.Key == divisionPoint)
				{
					return;
				}
				else
				{
					insertionIndex = i + 1;
					clone = currentPair.Value is null ? default : cloneFactory(currentPair.Value);
					break;
				}
			}
		}

		if (insertionIndex < 0)
		{
			insertionIndex = Count;
			KeyValuePair<UnityVersion, T?> lastPair = this[Count - 1];
			if (lastPair.Key == divisionPoint)
			{
				return;
			}
			clone = lastPair.Value is null ? default : cloneFactory(lastPair.Value);
		}

		_list.Insert(insertionIndex, new KeyValuePair<UnityVersion, T?>(divisionPoint, clone));
	}

	public VersionedList<T> GetSubList(Range<UnityVersion> range)
	{
		VersionedList<T> result = new();
		for (int i = 0; i < Count; i++)
		{
			Range<UnityVersion> currentRange = GetRange(i);
			if (currentRange.Intersects(range, out Range<UnityVersion> intersection))
			{
				result.Add(intersection.Start, this[i].Value);
			}
		}
		return result;
	}

	public IEnumerator<KeyValuePair<UnityVersion, T?>> GetEnumerator() => _list.GetEnumerator();

	IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable)_list).GetEnumerator();

	public IEnumerable<UnityVersion> Keys => _list.Select(x => x.Key);

	public IEnumerable<T?> Values => _list.Select(x => x.Value);

	public override string ToString()
	{
		return $"{nameof(Count)} = {Count}";
	}
}

```

`Source/AssetRipper.AssemblyDumper/AST/DictionaryNode.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.Assets.Generics;

namespace AssetRipper.AssemblyDumper.AST;

internal sealed class DictionaryNode : SingleNode<PairNode>
{
	private static readonly Lazy<IMethodDefOrRef> defaultConstructor = new(() => SharedState.Instance.Importer.ImportDefaultConstructor(typeof(AssetDictionary<,>)));
	private static readonly Lazy<IMethodDefOrRef> getCount = new(() => ImportMethod(typeof(AssetDictionary<,>), "get_" + nameof(AssetDictionary<,>.Count)));
	private static readonly Lazy<IMethodDefOrRef> setCapacity = new(() => ImportMethod(typeof(AssetDictionary<,>), "set_" + nameof(AssetDictionary<,>.Capacity)));
	private static readonly Lazy<IMethodDefOrRef> clear = new(() => ImportMethod(typeof(AssetDictionary<,>), nameof(AssetDictionary<,>.Clear)));
	private static readonly Lazy<IMethodDefOrRef> addNew = new(() => ImportMethod(typeof(AssetDictionary<,>), nameof(AssetDictionary<,>.AddNew)));
	private static readonly Lazy<IMethodDefOrRef> getPair = new(() => ImportMethod(typeof(AssetDictionary<,>), nameof(AssetDictionary<,>.GetPair)));
	public DictionaryNode(GenericInstanceTypeSignature typeSignature, Node? parent = null) : base(parent)
	{
		TypeSignature = typeSignature;
		GenericInstanceTypeSignature pairType = SharedState.Instance.Importer.ImportType(typeof(AssetPair<,>)).MakeGenericInstanceType(
			typeSignature.TypeArguments[0],
			typeSignature.TypeArguments[1]);
		Child = new PairNode(pairType, this);
	}

	public override GenericInstanceTypeSignature TypeSignature { get; }

	public TypeSignature KeyTypeSignature => Child.Key.TypeSignature;

	public TypeSignature ValueTypeSignature => Child.Value.TypeSignature;

	/// <summary>
	/// <see cref="AssetDictionary{TKey, TValue}"/> does not implement <see cref="IEquatable{T}"/>.
	/// </summary>
	public override bool Equatable => false;

	public IMethodDefOrRef DefaultConstructor => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, defaultConstructor.Value);
	public IMethodDefOrRef GetCount => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, getCount.Value);
	public IMethodDefOrRef SetCapacity => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, setCapacity.Value);
	public IMethodDefOrRef Clear => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, clear.Value);
	public IMethodDefOrRef AddNew => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, addNew.Value);
	public IMethodDefOrRef GetPair => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, getPair.Value);
}

```

`Source/AssetRipper.AssemblyDumper/AST/FieldNode.cs`:

```cs
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.AST;

internal sealed class FieldNode : SingleNode<Node>
{
	public FieldNode(ClassProperty property, Node? parent = null) : base(parent)
	{
		Debug.Assert(property.BackingField is not null);
		Property = property;
		Child = Create(TypeSignature, this);
	}

	public ClassProperty Property { get; }

	public FieldDefinition Field => Property.BackingField!;
	public override TypeSignature TypeSignature => Field.Signature!.FieldType;
}

```

`Source/AssetRipper.AssemblyDumper/AST/KeyNode.cs`:

```cs
namespace AssetRipper.AssemblyDumper.AST;

internal sealed class KeyNode : SingleNode<Node>
{
	public KeyNode(TypeSignature typeSignature, Node? parent = null) : base(parent)
	{
		Child = Create(typeSignature, this);
	}

	public override TypeSignature TypeSignature => Child.TypeSignature;
}

```

`Source/AssetRipper.AssemblyDumper/AST/ListNode.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.Assets.Generics;

namespace AssetRipper.AssemblyDumper.AST;

internal sealed class ListNode : SingleNode<Node>
{
	private static readonly Lazy<IMethodDefOrRef> defaultConstructor = new(() => SharedState.Instance.Importer.ImportDefaultConstructor(typeof(AssetList<>)));
	private static readonly Lazy<IMethodDefOrRef> getCount = new(() => ImportMethod(typeof(AssetList<>), "get_" + nameof(AssetList<>.Count)));
	private static readonly Lazy<IMethodDefOrRef> setCapacity = new(() => ImportMethod(typeof(AssetList<>), "set_" + nameof(AssetList<>.Capacity)));
	private static readonly Lazy<IMethodDefOrRef> getItem = new(() => ImportMethod(typeof(AssetList<>), "get_Item"));
	private static readonly Lazy<IMethodDefOrRef> clear = new(() => ImportMethod(typeof(AssetList<>), nameof(AssetList<>.Clear)));
	private static readonly Lazy<IMethodDefOrRef> add = new(() => ImportMethod(typeof(AssetList<>), nameof(AssetList<>.Add)));
	private static readonly Lazy<IMethodDefOrRef> addNew = new(() => ImportMethod(typeof(AssetList<>), nameof(AssetList<>.AddNew)));

	public ListNode(GenericInstanceTypeSignature typeSignature, Node? parent = null) : base(parent)
	{
		TypeSignature = typeSignature;
		Child = Create(typeSignature.TypeArguments[0], this);
	}

	public override GenericInstanceTypeSignature TypeSignature { get; }
	public TypeSignature ElementTypeSignature => TypeSignature.TypeArguments[0];
	/// <summary>
	/// <see cref="AssetList{T}"/> does not implement <see cref="IEquatable{T}"/>.
	/// </summary>
	public override bool Equatable => false;

	public IMethodDefOrRef DefaultConstructor => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, defaultConstructor.Value);
	public IMethodDefOrRef GetCount => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, getCount.Value);
	public IMethodDefOrRef SetCapacity => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, setCapacity.Value);
	public IMethodDefOrRef GetItem => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, getItem.Value);
	public IMethodDefOrRef Clear => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, clear.Value);
	public IMethodDefOrRef Add => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, add.Value);
	public IMethodDefOrRef AddNew => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, addNew.Value);
}

```

`Source/AssetRipper.AssemblyDumper/AST/Node.cs`:

```cs
using AssetRipper.Assets.Generics;

namespace AssetRipper.AssemblyDumper.AST;

internal abstract class Node
{
	public Node(Node? parent = null)
	{
		Parent = parent;
	}

	public Node? Parent { get; }

	public abstract TypeSignature TypeSignature { get; }
	public virtual IReadOnlyList<Node> Children => [];
	public virtual bool AnyPPtrs => Children.Any(c => c.AnyPPtrs);
	/// <summary>
	/// If true, the <see cref="TypeSignature"/> inherits from <see cref="IEquatable{T}"/> and is suitable to evaluate equality using <see cref="IEquatable{T}.Equals(T)"/>.
	/// </summary>
	/// <remarks>
	/// Even though <see cref="AssetPair{TKey, TValue}"/> inherits from <see cref="IEquatable{T}"/>, it might not be suitable to equate.
	/// It uses <see cref="EqualityComparer{T}.Default"/> to compare the keys and values.
	/// </remarks>
	public virtual bool Equatable => Children.All(c => c.Equatable);

	public static Node Create(TypeSignature type, Node parent)
	{
		switch (type)
		{
			case CorLibTypeSignature or SzArrayTypeSignature:
				return new PrimitiveNode(type, parent);
			case TypeDefOrRefSignature typeDefOrRefSignature:
				if (typeDefOrRefSignature.Type is TypeDefinition typeDefinition)
				{
					GeneratedClassInstance instance = SharedState.Instance.TypesToInstances[typeDefinition];
					return instance.Group.IsPPtr
						? new PPtrNode(instance, parent)
						: new TypeNode(instance, parent);
				}
				else
				{
					return new PrimitiveNode(type, parent);//Utf8String
				}
			case GenericInstanceTypeSignature genericInstanceTypeSignature:
				return (genericInstanceTypeSignature.GenericType.Name?.ToString()) switch
				{
					$"{nameof(AssetDictionary<,>)}`2" => new DictionaryNode(genericInstanceTypeSignature, parent),
					$"{nameof(AssetList<>)}`1" => new ListNode(genericInstanceTypeSignature, parent),
					$"{nameof(AssetPair<,>)}`2" => new PairNode(genericInstanceTypeSignature, parent),
					_ => throw new NotSupportedException(),
				};
			default:
				throw new NotImplementedException();
		}
	}

	private protected static IMethodDefOrRef ImportMethod(Type type, string name)
	{
		return SharedState.Instance.Importer.ImportMethod(type, m => m.Name == name);
	}
}

```

`Source/AssetRipper.AssemblyDumper/AST/PPtrNode.cs`:

```cs
namespace AssetRipper.AssemblyDumper.AST;

internal sealed class PPtrNode : Node
{
	public PPtrNode(GeneratedClassInstance pptrType, Node parent) : base(parent)
	{
		ClassInstance = pptrType;
	}

	public GeneratedClassInstance ClassInstance { get; }

	public override TypeSignature TypeSignature => ClassInstance.Type.ToTypeSignature();

	public override bool AnyPPtrs => true;

	public override bool Equatable => false;
}

```

`Source/AssetRipper.AssemblyDumper/AST/PairNode.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.Assets.Generics;

namespace AssetRipper.AssemblyDumper.AST;

internal sealed class PairNode : Node
{
	private static readonly Lazy<IMethodDefOrRef> defaultConstructor = new(() => SharedState.Instance.Importer.ImportDefaultConstructor(typeof(AssetPair<,>)));
	private static readonly Lazy<IMethodDefOrRef> getKey = new(() => ImportMethod(typeof(AssetPair<,>), "get_" + nameof(AssetPair<,>.Key)));
	private static readonly Lazy<IMethodDefOrRef> setKey = new(() => ImportMethod(typeof(AssetPair<,>), "set_" + nameof(AssetPair<,>.Key)));
	private static readonly Lazy<IMethodDefOrRef> getValue = new(() => ImportMethod(typeof(AssetPair<,>), "get_" + nameof(AssetPair<,>.Value)));
	private static readonly Lazy<IMethodDefOrRef> setValue = new(() => ImportMethod(typeof(AssetPair<,>), "set_" + nameof(AssetPair<,>.Value)));
	private static readonly Lazy<IMethodDefOrRef> implicitConversion = new(() => ImportMethod(typeof(AssetPair<,>), "op_Implicit"));

	public PairNode(GenericInstanceTypeSignature typeSignature, Node? parent = null) : base(parent)
	{
		TypeSignature = typeSignature;
		Key = new(typeSignature.TypeArguments[0], this);
		Value = new(typeSignature.TypeArguments[1], this);
	}

	public KeyNode Key { get; }
	public ValueNode Value { get; }

	public override IReadOnlyList<Node> Children => [Key, Value];

	public override bool AnyPPtrs => Key.AnyPPtrs || Value.AnyPPtrs;

	public override bool Equatable => Key.Equatable && Value.Equatable;

	public override GenericInstanceTypeSignature TypeSignature { get; }

	public IMethodDefOrRef DefaultConstructor => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, defaultConstructor.Value);
	public IMethodDefOrRef GetKey => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, getKey.Value);
	public IMethodDefOrRef SetKey => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, setKey.Value);
	public IMethodDefOrRef GetValue => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, getValue.Value);
	public IMethodDefOrRef SetValue => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, setValue.Value);
	public IMethodDefOrRef ImplicitConversion => MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, TypeSignature, implicitConversion.Value);
}

```

`Source/AssetRipper.AssemblyDumper/AST/PrimitiveNode.cs`:

```cs
namespace AssetRipper.AssemblyDumper.AST;

internal sealed class PrimitiveNode : Node
{
	public PrimitiveNode(TypeSignature typeSignature, Node parent) : base(parent)
	{
		TypeSignature = typeSignature;
	}

	public override TypeSignature TypeSignature { get; }

	public override bool AnyPPtrs => false;

	/// <summary>
	/// Byte arrays do not implement <see cref="IEquatable{T}"/>, but other primitive types do.
	/// </summary>
	public override bool Equatable => TypeSignature is not SzArrayTypeSignature;
}

```

`Source/AssetRipper.AssemblyDumper/AST/SingleNode.cs`:

```cs
namespace AssetRipper.AssemblyDumper.AST;

internal abstract class SingleNode<TChild> : Node where TChild : Node
{
	public SingleNode(Node? parent = null) : base(parent)
	{
	}

	public TChild Child { get; set; } = null!;

	public sealed override IReadOnlyList<Node> Children => [Child];

	public sealed override bool AnyPPtrs => Child.AnyPPtrs;

	public override bool Equatable => Child.Equatable;
}

```

`Source/AssetRipper.AssemblyDumper/AST/TypeNode.cs`:

```cs
namespace AssetRipper.AssemblyDumper.AST;

internal sealed class TypeNode : Node
{
	public TypeNode(GeneratedClassInstance classInstance, Node? parent = null) : base(parent)
	{
		ClassInstance = classInstance;
		List<FieldNode> children = new();
		foreach (ClassProperty property in classInstance.Properties.Where(p => p.BackingField is not null))
		{
			children.Add(new FieldNode(property, this));
		}
		Children = children.Count > 0 ? children : [];
	}

	public GeneratedClassInstance ClassInstance { get; }

	public override IReadOnlyList<FieldNode> Children { get; }

	public override TypeSignature TypeSignature => ClassInstance.Type.ToTypeSignature();

	/// <summary>
	/// We generate the equality comparison for the type if it has no PPtrs.
	/// </summary>
	public override bool Equatable => !AnyPPtrs;
}

```

`Source/AssetRipper.AssemblyDumper/AST/ValueNode.cs`:

```cs
namespace AssetRipper.AssemblyDumper.AST;

internal sealed class ValueNode : SingleNode<Node>
{
	public ValueNode(TypeSignature typeSignature, Node? parent = null) : base(parent)
	{
		Child = Create(typeSignature, this);
	}

	public override TypeSignature TypeSignature => Child.TypeSignature;
}

```

`Source/AssetRipper.AssemblyDumper/AssemblyBuilder.cs`:

```cs
namespace AssetRipper.AssemblyDumper;

public class AssemblyBuilder
{
	public CachedReferenceImporter Importer { get; }
	public AssemblyDefinition Assembly { get; }
	public ModuleDefinition Module { get; }

	public AssemblyBuilder(string assemblyName, Version version, AssemblyReference corLib)
	{
		Assembly = new AssemblyDefinition(assemblyName, version);
		Module = new ModuleDefinition(assemblyName, corLib);
		Assembly.Modules.Add(Module);
		Importer = new CachedReferenceImporter(Module);
	}
}

```

`Source/AssetRipper.AssemblyDumper/AssetRipper.AssemblyDumper.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.AssemblyDumper\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.AssemblyDumper\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AsmResolver.DotNet" Version="6.0.0-beta.5" />
		<PackageReference Include="AssetRipper.Checksum" Version="1.1.0" />
		<PackageReference Include="AssetRipper.CIL" Version="1.2.2" />
		<PackageReference Include="AssetRipper.Tpk.TypeTrees.Json" Version="1.1.0" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.AssemblyDumper.Utils\AssetRipper.AssemblyDumper.Utils.csproj" />
		<ProjectReference Include="..\AssetRipper.Assets\AssetRipper.Assets.csproj" />
		<ProjectReference Include="..\AssetRipper.DocExtraction\AssetRipper.DocExtraction.csproj" />
		<ProjectReference Include="..\AssetRipper.IO.Files\AssetRipper.IO.Files.csproj" />
		<ProjectReference Include="..\AssetRipper.Numerics\AssetRipper.Numerics.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.AssemblyDumper/Attributes/AssemblyAttributeCreator.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Versioning;

namespace AssetRipper.AssemblyDumper.Attributes;

public static class AssemblyAttributeCreator
{
	/// <summary>
	/// <see cref="AssemblyCompanyAttribute"/>
	/// </summary>
	public static CustomAttribute AddAssemblyCompanyAttribute(this AssemblyBuilder builder, string parameter)
	{
		return builder.AddSingleStringAttribute<AssemblyCompanyAttribute>(parameter);
	}

	/// <summary>
	/// <see cref="AssemblyConfigurationAttribute"/>
	/// </summary>
	public static CustomAttribute AddAssemblyConfigurationAttribute(this AssemblyBuilder builder, string parameter)
	{
		return builder.AddSingleStringAttribute<AssemblyConfigurationAttribute>(parameter);
	}

	/// <summary>
	/// <see cref="AssemblyFileVersionAttribute"/>
	/// </summary>
	public static CustomAttribute AddAssemblyFileVersionAttribute(this AssemblyBuilder builder, string parameter)
	{
		return builder.AddSingleStringAttribute<AssemblyFileVersionAttribute>(parameter);
	}

	/// <summary>
	/// <see cref="AssemblyInformationalVersionAttribute"/>
	/// </summary>
	public static CustomAttribute AddAssemblyInformationalVersionAttribute(this AssemblyBuilder builder, string parameter)
	{
		return builder.AddSingleStringAttribute<AssemblyInformationalVersionAttribute>(parameter);
	}

	/// <summary>
	/// <see cref="AssemblyProductAttribute"/>
	/// </summary>
	public static CustomAttribute AddAssemblyProductAttribute(this AssemblyBuilder builder, string parameter)
	{
		return builder.AddSingleStringAttribute<AssemblyProductAttribute>(parameter);
	}

	/// <summary>
	/// <see cref="AssemblyTitleAttribute"/>
	/// </summary>
	public static CustomAttribute AddAssemblyTitleAttribute(this AssemblyBuilder builder, string parameter)
	{
		return builder.AddSingleStringAttribute<AssemblyTitleAttribute>(parameter);
	}

	/// <summary>
	/// <see cref="InternalsVisibleToAttribute"/>
	/// </summary>
	public static CustomAttribute AddInternalsVisibleToAttribute(this AssemblyBuilder builder, AssemblyDescriptor targetAssembly)
	{
		return builder.AddSingleStringAttribute<InternalsVisibleToAttribute>(targetAssembly.Name ?? throw new ArgumentException(nameof(targetAssembly)));
	}

	/// <summary>
	/// <see cref="RuntimeCompatibilityAttribute"/>
	/// </summary>
	public static CustomAttribute AddRuntimeCompatibilityAttribute(this AssemblyBuilder builder, bool wrapNonExceptionThrows = true)
	{
		IMethodDefOrRef constructor = builder.Importer.ImportDefaultConstructor<RuntimeCompatibilityAttribute>();
		CustomAttribute attribute = builder.Assembly.AddCustomAttribute(constructor);
		attribute.AddNamedArgument(
			builder.Importer.Boolean,
			nameof(RuntimeCompatibilityAttribute.WrapNonExceptionThrows),
			builder.Importer.Boolean,
			wrapNonExceptionThrows,
			CustomAttributeArgumentMemberType.Property);
		return attribute;
	}

	/// <summary>
	/// <see cref="TargetFrameworkAttribute"/>
	/// </summary>
	public static CustomAttribute AddTargetFrameworkAttribute(this AssemblyBuilder builder)
	{
		return builder.AddSingleStringAttribute<TargetFrameworkAttribute>(builder.Module.OriginalTargetRuntime.ToString());
	}

	/// <summary>
	/// <see cref="TargetFrameworkAttribute"/>
	/// </summary>
	public static CustomAttribute AddTargetFrameworkAttribute(this AssemblyBuilder builder, string displayName)
	{
		CustomAttribute attribute = builder.AddTargetFrameworkAttribute();
		attribute.AddNamedArgument(builder.Importer.String, nameof(TargetFrameworkAttribute.FrameworkDisplayName), builder.Importer.String, displayName, CustomAttributeArgumentMemberType.Property);
		return attribute;
	}

	private static CustomAttribute AddSingleStringAttribute<T>(this AssemblyBuilder builder, string parameterValue) where T : Attribute
	{
		IMethodDefOrRef constructor = builder.Importer.ImportConstructor<T>(1);
		return builder.Assembly.AddCustomAttribute(constructor, (builder.Importer.String, parameterValue));
	}
}

```

`Source/AssetRipper.AssemblyDumper/Attributes/AttributeCreator.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;

namespace AssetRipper.AssemblyDumper.Attributes;

public static class AttributeCreator
{
	public static TypeDefinition CreateDefaultAttribute(CachedReferenceImporter importer, string @namespace, string name)
	{
		ITypeDefOrRef systemAttributeReference = importer.ImportType<Attribute>();

		TypeDefinition attributeDefinition = new TypeDefinition(@namespace, name, TypeAttributes.Public | TypeAttributes.BeforeFieldInit, systemAttributeReference);

		importer.TargetModule.TopLevelTypes.Add(attributeDefinition);
		attributeDefinition.AddDefaultConstructor(importer);

		return attributeDefinition;
	}

	public static CustomAttribute AddAttributeTargetsAttribute(this TypeDefinition attributeDefinition, CachedReferenceImporter importer, AttributeTargets targets)
	{
		IMethodDefOrRef constructorMethod = importer.ImportMethod<AttributeUsageAttribute>(
				c => c.IsConstructor && c.Parameters.Count == 1 && c.Parameters[0].ParameterType.Name == nameof(AttributeTargets));

		TypeSignature attributeTargetsReference = importer.ImportTypeSignature<AttributeTargets>();

		return attributeDefinition.AddCustomAttribute(constructorMethod, attributeTargetsReference, targets);
	}

	public static void AddAttributeTargetsAttribute(this TypeDefinition attributeDefinition, CachedReferenceImporter importer, AttributeTargets targets, bool allowMultiple, bool inherited)
	{
		CustomAttribute customAttribute = attributeDefinition.AddAttributeTargetsAttribute(importer, targets);
		customAttribute.AddNamedArgument(importer.Boolean, "AllowMultiple", importer.Boolean, allowMultiple, CustomAttributeArgumentMemberType.Property);
		customAttribute.AddNamedArgument(importer.Boolean, "Inherited", importer.Boolean, inherited, CustomAttributeArgumentMemberType.Property);
	}

	public static TypeDefinition CreateSingleValueAttribute(CachedReferenceImporter importer, string @namespace, string name, string fieldName, TypeSignature fieldType, bool hasDefaultConstructor, out MethodDefinition singleParamConstructor)
	{
		ITypeDefOrRef systemAttributeReference = importer.ImportType<Attribute>();
		IMethodDefOrRef defaultAttributeConstructor = importer.ImportDefaultConstructor<Attribute>();

		var attributeDefinition = new TypeDefinition(@namespace, name, TypeAttributes.Public | TypeAttributes.BeforeFieldInit, systemAttributeReference);

		importer.TargetModule.TopLevelTypes.Add(attributeDefinition);
		if (hasDefaultConstructor)
		{
			var defaultConstructor = new MethodDefinition(
				".ctor",
				MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RuntimeSpecialName,
				MethodSignature.CreateInstance(importer.Void)
			);

			var defaultProcessor = defaultConstructor.CilMethodBody!.Instructions;
			defaultProcessor.Add(CilOpCodes.Ldarg_0);
			defaultProcessor.Add(CilOpCodes.Call, defaultAttributeConstructor);
			defaultProcessor.Add(CilOpCodes.Ret);

			attributeDefinition.Methods.Add(defaultConstructor);
		}

		var field = new FieldDefinition(fieldName, FieldAttributes.Public | FieldAttributes.InitOnly, new FieldSignature(fieldType));
		attributeDefinition.Fields.Add(field);

		singleParamConstructor = attributeDefinition.AddEmptyConstructor();
		singleParamConstructor.AddParameter(fieldType);

		var instructions = singleParamConstructor.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, defaultAttributeConstructor);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Stfld, field);
		instructions.Add(CilOpCodes.Ret);

		return attributeDefinition;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Attributes/CompilerInjectedAttributeCreator.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;

namespace AssetRipper.AssemblyDumper.Attributes;

public static class CompilerInjectedAttributeCreator
{
	//https://github.com/dotnet/roslyn/blob/main/docs/features/nullable-metadata.md
	public static TypeDefinition CreateEmbeddedAttribute(CachedReferenceImporter importer, out MethodDefinition constructor)
	{
		TypeDefinition type = AttributeCreator.CreateDefaultAttribute(importer, "Microsoft.CodeAnalysis", "EmbeddedAttribute");
		type.Attributes = type.Attributes & ~TypeAttributes.VisibilityMask | TypeAttributes.NotPublic | TypeAttributes.Sealed;
		constructor = type.GetDefaultConstructor();
		type.AddCompilerGeneratedAttribute(importer);
		type.AddCustomAttribute(constructor);//The embedded attribute is attributed with itself
		return type;
	}

	public static TypeDefinition CreateNullableContextAttribute(CachedReferenceImporter importer, MethodDefinition embeddedAttributeConstructor)
	{
		TypeDefinition type = AttributeCreator.CreateSingleValueAttribute(
			importer,
			"System.Runtime.CompilerServices",
			"NullableContextAttribute",
			"Flag",
			importer.UInt8,
			false,
			out _);
		type.Attributes = type.Attributes & ~TypeAttributes.VisibilityMask | TypeAttributes.NotPublic | TypeAttributes.Sealed;
		type.AddCompilerGeneratedAttribute(importer);
		type.AddCustomAttribute(embeddedAttributeConstructor);
		type.AddAttributeTargetsAttribute(
			importer,
			AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Interface | AttributeTargets.Delegate,
			false,
			false);
		return type;
	}

	public static TypeDefinition CreateNullableAttribute(CachedReferenceImporter importer, MethodDefinition embeddedAttributeConstructor)
	{
		TypeDefinition type = AttributeCreator.CreateSingleValueAttribute(
			importer,
			"System.Runtime.CompilerServices",
			"NullableAttribute",
			"NullableFlags",
			importer.UInt8.MakeSzArrayType(),
			false,
			out _);
		type.Attributes = type.Attributes & ~TypeAttributes.VisibilityMask | TypeAttributes.NotPublic | TypeAttributes.Sealed;
		type.AddCompilerGeneratedAttribute(importer);
		type.AddCustomAttribute(embeddedAttributeConstructor);
		type.AddAttributeTargetsAttribute(
			importer,
			AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter,
			false,
			false);


		IMethodDefOrRef defaultAttributeConstructor = importer.ImportDefaultConstructor<Attribute>();
		MethodDefinition singleByteConstructor = type.AddEmptyConstructor();
		singleByteConstructor.AddParameter(importer.UInt8);

		FieldDefinition field = type.Fields.Single();//byte[]

		var instructions = singleByteConstructor.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, defaultAttributeConstructor);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldc_I4_1);
		instructions.Add(CilOpCodes.Newarr, importer.UInt8.ToTypeDefOrRef());
		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldc_I4_0);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Stelem_I1);
		instructions.Add(CilOpCodes.Stfld, field);
		instructions.Add(CilOpCodes.Ret);

		return type;
	}

	/// <summary>
	/// Applies the <see cref="System.Runtime.CompilerServices.CompilerGeneratedAttribute"/>
	/// </summary>
	/// <param name="_this">The entity on which to apply the attribute</param>
	/// <param name="importer">The importer for the module containing the entity</param>
	/// <returns>The resulting custom attribute</returns>
	public static CustomAttribute AddCompilerGeneratedAttribute(this IHasCustomAttribute _this, CachedReferenceImporter importer)
	{
		IMethodDefOrRef constructor = importer.ImportDefaultConstructor<System.Runtime.CompilerServices.CompilerGeneratedAttribute>();
		CustomAttribute attribute = _this.AddCustomAttribute(constructor);
		return attribute;
	}

	/// <summary>
	/// Applies the <see cref="System.Runtime.CompilerServices.ExtensionAttribute"/>
	/// </summary>
	/// <param name="_this">The entity on which to apply the attribute</param>
	/// <param name="importer">The importer for the module containing the entity</param>
	/// <returns>The resulting custom attribute</returns>
	public static CustomAttribute AddExtensionAttribute(this IHasCustomAttribute _this, CachedReferenceImporter importer)
	{
		IMethodDefOrRef constructor = importer.ImportDefaultConstructor<System.Runtime.CompilerServices.ExtensionAttribute>();
		CustomAttribute attribute = _this.AddCustomAttribute(constructor);
		return attribute;
	}

	public static CustomAttribute AddMemberNotNullWhenAttribute(this IHasCustomAttribute _this, CachedReferenceImporter importer, bool returnValue, string memberName)
	{
		IMethodDefOrRef constructor = importer.ImportConstructor<MemberNotNullWhenAttribute>(
			m => m.Parameters.Count == 2 && m.Parameters[1].ParameterType is CorLibTypeSignature);
		CustomAttribute attribute = _this.AddCustomAttribute(constructor);
		attribute.AddFixedArgument(importer.Boolean, returnValue);
		attribute.AddFixedArgument(importer.String, memberName);
		return attribute;
	}

	public static CustomAttribute AddNotNullWhenAttribute(this IHasCustomAttribute _this, CachedReferenceImporter importer, bool returnValue)
	{
		IMethodDefOrRef constructor = importer.ImportConstructor<NotNullWhenAttribute>(1);
		CustomAttribute attribute = _this.AddCustomAttribute(constructor);
		attribute.AddFixedArgument(importer.Boolean, returnValue);
		return attribute;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Attributes/ModuleAttributeCreator.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using System.Security;

namespace AssetRipper.AssemblyDumper.Attributes;

public static class ModuleAttributeCreator
{
	/// <summary>
	/// <see cref="UnverifiableCodeAttribute"/>
	/// </summary>
	public static CustomAttribute AddUnverifiableCodeAttribute(this AssemblyBuilder builder)
	{
		IMethodDefOrRef constructor = builder.Importer.ImportDefaultConstructor<UnverifiableCodeAttribute>();
		return builder.Module.AddCustomAttribute(constructor);
	}
}

```

`Source/AssetRipper.AssemblyDumper/CachedReferenceImporter.cs`:

```cs
using AssetRipper.AssemblyDumper.Types;

namespace AssetRipper.AssemblyDumper;

public sealed class CachedReferenceImporter
{
	private readonly Dictionary<Type, ITypeDefOrRef> cachedTypeReferences = new();
	private readonly Dictionary<Type, TypeSignature> cachedTypeSignatureReferences = new();
	private readonly Dictionary<Type, TypeDefinition> cachedTypeDefinitions = new();
	private readonly HashSet<ModuleDefinition> referenceModules = new();

	public ReferenceImporter UnderlyingImporter { get; }
	public ModuleDefinition TargetModule => UnderlyingImporter.TargetModule;

	public CorLibTypeSignature Void => TargetModule.CorLibTypeFactory.Void;
	public CorLibTypeSignature Char => TargetModule.CorLibTypeFactory.Char;
	public CorLibTypeSignature Boolean => TargetModule.CorLibTypeFactory.Boolean;
	public CorLibTypeSignature Int8 => TargetModule.CorLibTypeFactory.SByte;
	public CorLibTypeSignature UInt8 => TargetModule.CorLibTypeFactory.Byte;
	public CorLibTypeSignature Int16 => TargetModule.CorLibTypeFactory.Int16;
	public CorLibTypeSignature UInt16 => TargetModule.CorLibTypeFactory.UInt16;
	public CorLibTypeSignature Int32 => TargetModule.CorLibTypeFactory.Int32;
	public CorLibTypeSignature UInt32 => TargetModule.CorLibTypeFactory.UInt32;
	public CorLibTypeSignature Int64 => TargetModule.CorLibTypeFactory.Int64;
	public CorLibTypeSignature UInt64 => TargetModule.CorLibTypeFactory.UInt64;
	public CorLibTypeSignature Single => TargetModule.CorLibTypeFactory.Single;
	public CorLibTypeSignature Double => TargetModule.CorLibTypeFactory.Double;
	public CorLibTypeSignature String => TargetModule.CorLibTypeFactory.String;
	public CorLibTypeSignature IntPtr => TargetModule.CorLibTypeFactory.IntPtr;
	public CorLibTypeSignature UIntPtr => TargetModule.CorLibTypeFactory.UIntPtr;
	public CorLibTypeSignature TypedReference => TargetModule.CorLibTypeFactory.TypedReference;
	public CorLibTypeSignature Object => TargetModule.CorLibTypeFactory.Object;

	public CachedReferenceImporter(ModuleDefinition module)
	{
		UnderlyingImporter = new ReferenceImporter(module);
	}

	public void AddReferenceModule(ModuleDefinition referenceModule) => referenceModules.Add(referenceModule);

	public TypeDefinition? LookupType<T>() => LookupType(typeof(T));
	public TypeDefinition? LookupType(Type type)
	{
		if (!cachedTypeDefinitions.TryGetValue(type, out TypeDefinition? typeDefinition)
			&& TryGetTypeDefinitionMatch(referenceModules, type.FullName!, out typeDefinition))
		{
			cachedTypeDefinitions.Add(type, typeDefinition);
		}
		return typeDefinition;
	}
	/// <summary>
	/// Does not use caching
	/// </summary>
	/// <param name="fullName"></param>
	/// <returns></returns>
	public TypeDefinition? LookupType(string fullName)
	{
		TryLookupType(fullName, out TypeDefinition? typeDefinition);
		return typeDefinition;
	}

	public bool TryLookupType<T>([NotNullWhen(true)] out TypeDefinition? typeDefinition)
	{
		typeDefinition = LookupType<T>();
		return typeDefinition != null;
	}
	public bool TryLookupType(Type type, [NotNullWhen(true)] out TypeDefinition? typeDefinition)
	{
		typeDefinition = LookupType(type);
		return typeDefinition != null;
	}
	/// <summary>
	/// Does not use caching
	/// </summary>
	/// <param name="fullName"></param>
	/// <param name="typeDefinition"></param>
	/// <returns></returns>
	public bool TryLookupType(string fullName, [NotNullWhen(true)] out TypeDefinition? typeDefinition)
	{
		return TryGetTypeDefinitionMatch(referenceModules, fullName, out typeDefinition);
	}

	public MethodDefinition LookupMethod<T>(Func<MethodDefinition, bool> filter) => LookupMethod(typeof(T), filter);
	public MethodDefinition LookupMethod(Type type, Func<MethodDefinition, bool> filter)
	{
		TypeDefinition typeDefinition = LookupType(type) ?? throw new ArgumentException($"Module for {type.FullName} not referenced", nameof(type));
		return typeDefinition.Methods.Single(filter);
	}

	public FieldDefinition LookupField<T>(string name) => LookupField(typeof(T), name);
	public FieldDefinition LookupField(Type type, string name)
	{
		TypeDefinition typeDefinition = LookupType(type) ?? throw new ArgumentException($"Module for {type.FullName} not referenced", nameof(type));
		return typeDefinition.GetFieldByName(name);
	}

	public IMethodDefOrRef ImportMethod<T>(Func<MethodDefinition, bool> filter) => UnderlyingImporter.ImportMethod(LookupMethod<T>(filter));
	public IMethodDefOrRef ImportMethod(Type type, Func<MethodDefinition, bool> filter) => UnderlyingImporter.ImportMethod(LookupMethod(type, filter));

	public IFieldDescriptor ImportField<T>(string name) => UnderlyingImporter.ImportField(LookupField<T>(name));
	public IFieldDescriptor ImportField(Type type, string name) => UnderlyingImporter.ImportField(LookupField(type, name));

	public ITypeDefOrRef ImportType<T>() => ImportType(typeof(T));
	public ITypeDefOrRef ImportType(Type type)
	{
		if (!cachedTypeReferences.TryGetValue(type, out ITypeDefOrRef? result))
		{
			result = TryLookupType(type, out TypeDefinition? typeDefinition)
				? UnderlyingImporter.ImportType(typeDefinition)
				: UnderlyingImporter.ImportType(type);
			cachedTypeReferences.Add(type, result);
		}
		return result;
	}

	public TypeSignature ImportTypeSignature<T>() => ImportTypeSignature(typeof(T));
	public TypeSignature ImportTypeSignature(Type type)
	{
		if (!cachedTypeSignatureReferences.TryGetValue(type, out TypeSignature? result))
		{
			result = TryLookupType(type, out TypeDefinition? typeDefinition)
				? UnderlyingImporter.ImportTypeSignature(typeDefinition.ToTypeSignature())
				: UnderlyingImporter.ImportTypeSignature(type);
			cachedTypeSignatureReferences.Add(type, result);
		}
		return result;
	}

	private static bool TryGetTypeDefinitionMatch(IEnumerable<ModuleDefinition> modules, string fullName, [NotNullWhen(true)] out TypeDefinition? type)
	{
		foreach (ModuleDefinition module in modules)
		{
			if (TryGetTypeDefinitionMatch(module, fullName, out type))
			{
				return true;
			}
		}
		type = null;
		return false;
	}

	private static bool TryGetTypeDefinitionMatch(ModuleDefinition module, string fullName, [NotNullWhen(true)] out TypeDefinition? type)
	{
		for (int i = 0; i < module.TopLevelTypes.Count; i++)
		{
			if (module.TopLevelTypes[i].FullName == fullName)
			{
				type = module.TopLevelTypes[i];
				return true;
			}
		}
		for (int i = 0; i < module.TopLevelTypes.Count; i++)
		{
			if (TryGetTypeDefinitionMatch(module.TopLevelTypes[i], fullName, out type))
			{
				return true;
			}
		}
		type = null;
		return false;
	}

	private static bool TryGetTypeDefinitionMatch(TypeDefinition parent, string fullName, [NotNullWhen(true)] out TypeDefinition? type)
	{
		for (int i = 0; i < parent.NestedTypes.Count; i++)
		{
			if (parent.NestedTypes[i].FullName == fullName)
			{
				type = parent.NestedTypes[i];
				return true;
			}
		}
		for (int i = 0; i < parent.NestedTypes.Count; i++)
		{
			if (TryGetTypeDefinitionMatch(parent.NestedTypes[i], fullName, out type))
			{
				return true;
			}
		}
		type = null;
		return false;
	}
}
```

`Source/AssetRipper.AssemblyDumper/ClassProperty.cs`:

```cs
namespace AssetRipper.AssemblyDumper;

internal class ClassProperty : PropertyBase
{
	public ClassProperty(PropertyDefinition definition, FieldDefinition? backingField, InterfaceProperty @base, GeneratedClassInstance @class) : base(definition)
	{
		BackingField = backingField;
		if (!IsInjected && backingField?.Name is not null)
		{
			ReleaseNode = @class.Class.ReleaseRootNode?.TryGetSubNodeByName(backingField.Name);
			EditorNode = @class.Class.EditorRootNode?.TryGetSubNodeByName(backingField.Name);
			if (ReleaseNode is null && EditorNode is null)
			{
				throw new Exception($"Failed to find node: {@class.Name}.{backingField.Name} on {@class.VersionRange}");
			}
		}
		Class = @class;
		Base = @base;
		Base.AddImplementation(this);
	}

	public UniversalNode? ReleaseNode { get; }

	public UniversalNode? EditorNode { get; }

	public string? OriginalFieldName => ReleaseNode?.OriginalName ?? EditorNode?.OriginalName;

	public FieldDefinition? BackingField { get; }

	public InterfaceProperty Base { get; }

	public GeneratedClassInstance Class { get; }

	[MemberNotNullWhen(false, nameof(BackingField))]
	public bool IsAbsent => BackingField is null;

	[MemberNotNullWhen(true, nameof(BackingField))]
	public bool IsPresent => !IsAbsent;

	[MemberNotNullWhen(true, nameof(ReleaseNode))]
	[MemberNotNullWhen(false, nameof(EditorNode))]
	public bool IsReleaseOnly => ReleaseNode is not null && EditorNode is null;

	[MemberNotNullWhen(false, nameof(ReleaseNode))]
	[MemberNotNullWhen(true, nameof(EditorNode))]
	public bool IsEditorOnly => ReleaseNode is null && EditorNode is not null;

	[MemberNotNullWhen(true, nameof(BackingField))]
	public bool HasBackingFieldInDeclaringType
	{
		get
		{
			return BackingField is not null && BackingField.DeclaringType == Class.Type;
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/ClassDocumenter.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.DocExtraction.MetaData;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.AssemblyDumper.Documentation;

internal static class ClassDocumenter
{
	public static void AddClassDocumentation(GeneratedClassInstance instance)
	{
		AddDocumentationFromHistory(instance);

		AddClassTypeDocumentation(instance);

		if (instance.Class.EditorRootNode is not null || instance.Class.ReleaseRootNode is not null)
		{
			foreach (ClassProperty classProperty in instance.Properties)
			{
				AddPropertyDocumentation(instance, classProperty);
			}
		}
	}

	private static void AddClassTypeDocumentation(GeneratedClassInstance instance)
	{
		if (instance.Group is ClassGroup)
		{
			DocumentationHandler.AddTypeDefinitionLine(instance.Type, $"Type ID: {instance.Class.OriginalTypeID}");
		}

		if (instance.Type.Name != instance.Class.OriginalName)
		{
			DocumentationHandler.AddTypeDefinitionLine(instance.Type, $"Original Name: \"{instance.Class.OriginalName.EscapeXml()}\"");
		}

		DocumentationHandler.AddTypeDefinitionLine(instance.Type, $"Serialized Version: {instance.GetSerializedVersion()}");

		if (instance.Class.IsReleaseOnly)
		{
			DocumentationHandler.AddTypeDefinitionLine(instance.Type, "Release Only");
		}

		if (instance.Class.IsEditorOnly)
		{
			DocumentationHandler.AddTypeDefinitionLine(instance.Type, "Editor Only");
		}

		if (instance.Class.IsStripped)
		{
			DocumentationHandler.AddTypeDefinitionLine(instance.Type, "Stripped");
		}
		DocumentationHandler.AddTypeDefinitionLine(instance.Type, UnityVersionRangeUtils.GetUnityVersionRangeString(instance.VersionRange));
	}

	private static void AddPropertyDocumentation(GeneratedClassInstance instance, ClassProperty classProperty)
	{
		if (classProperty.BackingField?.Name is null)
		{
			DocumentationHandler.AddPropertyDefinitionLine(classProperty, "Not present in this version range");
			return;
		}

		UniversalNode? releaseNode;
		UniversalNode? editorNode;
		if (classProperty.IsInjected)
		{
			releaseNode = null;
			editorNode = null;
		}
		else
		{
			string fieldName = classProperty.BackingField.Name;

			releaseNode = instance.GetReleaseFieldByName(fieldName);
			editorNode = instance.GetEditorFieldByName(fieldName);
			UniversalNode mainNode = releaseNode ?? editorNode ?? throw new Exception($"In {instance.Name}, could not find nodes for {fieldName}");

			if (mainNode.Name != mainNode.OriginalName)
			{
				DocumentationHandler.AddPropertyDefinitionLine(classProperty, $"Original field name: \"{XmlUtils.EscapeXmlInvalidCharacters(mainNode.OriginalName)}\"");
			}

			if (mainNode.TypeName != mainNode.OriginalTypeName)
			{
				DocumentationHandler.AddPropertyDefinitionLine(classProperty, $"Original type: \"{XmlUtils.EscapeXmlInvalidCharacters(mainNode.OriginalTypeName)}\"");
			}
		}

		if (classProperty.HasEnumVariant)
		{
			DocumentationHandler.AddPropertyDefinitionLineNotSpecial(classProperty, "Enum variant available.");
		}
		else if (classProperty.SpecialDefinition is not null)
		{
			DocumentationHandler.AddPropertyDefinitionLineNotSpecial(classProperty, "PPtr variant available.");
		}

		if (!classProperty.IsInjected)
		{
			DocumentationHandler.AddPropertyDefinitionLine(classProperty, releaseNode is null ? "Editor Only" : $"Release Flags: {GetMetaFlagString(releaseNode.MetaFlag)}");
			DocumentationHandler.AddPropertyDefinitionLine(classProperty, editorNode is null ? "Release Only" : $"Editor Flags: {GetMetaFlagString(editorNode.MetaFlag)}");
		}
	}

	private static UniversalNode? GetReleaseFieldByName(this GeneratedClassInstance instance, string fieldName)
	{
		return instance.Class.ReleaseRootNode?.SubNodes.SingleOrDefault(n => n.Name == fieldName);
	}

	private static UniversalNode? GetEditorFieldByName(this GeneratedClassInstance instance, string fieldName)
	{
		return instance.Class.EditorRootNode?.SubNodes.SingleOrDefault(n => n.Name == fieldName);
	}

	private static string GetMetaFlagString(TransferMetaFlags flag)
	{
		return string.Join(" | ", flag.Split());
	}

	private static void AddDocumentationFromHistory(GeneratedClassInstance instance)
	{
		if (instance.History is not null)
		{
			VersionedListDocumenter.AddSet(instance.Type, instance.History.NativeName.GetSubList(instance.VersionRange), "Native Name: ");
			VersionedListDocumenter.AddSet(instance.Type, instance.History.DocumentationString.GetSubList(instance.VersionRange), "Summary: ");
			VersionedListDocumenter.AddList(instance.Type, instance.History.ObsoleteMessage.GetSubList(instance.VersionRange), "Obsolete Message: ");
		}

		foreach (ClassProperty classProperty in instance.Properties)
		{
			if (classProperty.History is not null)
			{
				VersionedList<string> nativeNameSubList = classProperty.History.NativeName.GetSubList(instance.VersionRange);
				VersionedList<FullNameRecord> managedTypeSubList = classProperty.History.TypeFullName.GetSubList(instance.VersionRange);
				VersionedList<string> docStringSubList = classProperty.History.DocumentationString.GetSubList(instance.VersionRange);
				VersionedList<string> obsoleteMessageSubList = classProperty.History.ObsoleteMessage.GetSubList(instance.VersionRange);

				VersionedListDocumenter.AddSet(classProperty.Definition, nativeNameSubList, "Native Name: ");
				VersionedListDocumenter.AddList(classProperty.Definition, managedTypeSubList, "Managed Type: ");
				VersionedListDocumenter.AddSet(classProperty.Definition, docStringSubList, "Summary: ");
				VersionedListDocumenter.AddList(classProperty.Definition, obsoleteMessageSubList, "Obsolete Message: ");

				if (classProperty.SpecialDefinition is not null)
				{
					VersionedListDocumenter.AddSet(classProperty.SpecialDefinition, nativeNameSubList, "Native Name: ");
					VersionedListDocumenter.AddList(classProperty.SpecialDefinition, managedTypeSubList, "Managed Type: ");
					VersionedListDocumenter.AddSet(classProperty.SpecialDefinition, docStringSubList, "Summary: ");
					VersionedListDocumenter.AddList(classProperty.SpecialDefinition, obsoleteMessageSubList, "Obsolete Message: ");
				}

				if (classProperty.HasBackingFieldInDeclaringType)
				{
					VersionedListDocumenter.AddSet(classProperty.BackingField, nativeNameSubList, "Native Name: ");
					VersionedListDocumenter.AddList(classProperty.BackingField, managedTypeSubList, "Managed Type: ");
					VersionedListDocumenter.AddSet(classProperty.BackingField, docStringSubList, "Summary: ");
					VersionedListDocumenter.AddList(classProperty.BackingField, obsoleteMessageSubList, "Obsolete Message: ");
				}
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/DocumentationHandler.cs`:

```cs
using System.Text;
using System.Xml;

namespace AssetRipper.AssemblyDumper.Documentation;

internal static class DocumentationHandler
{
	private static readonly Dictionary<TypeDefinition, List<string>> typeDefinitionDocumentation = new();
	private static readonly Dictionary<MethodDefinition, List<string>> methodDefinitionDocumentation = new();
	private static readonly Dictionary<PropertyDefinition, List<string>> propertyDefinitionDocumentation = new();
	private static readonly Dictionary<FieldDefinition, List<string>> fieldDefinitionDocumentation = new();
	private static readonly Dictionary<EventDefinition, List<string>> eventDefinitionDocumentation = new();

	public static void MakeDocumentationFile()
	{
		XmlDocument document = XmlUtils.CreateNewDocument();
		XmlElement docElement = document.AddChildElement(document, "doc");
		docElement.AddAssemblyName(document, SharedState.AssemblyName);

		XmlElement membersElement = docElement.AddChildElement(document, "members");

		foreach ((TypeDefinition type, List<string> lines) in typeDefinitionDocumentation)
		{
			membersElement.AddTypeMember(document, type).AddSummary(document, GetSummary(lines));
		}
		foreach ((MethodDefinition type, List<string> lines) in methodDefinitionDocumentation)
		{
			membersElement.AddMethodMember(document, type).AddSummary(document, GetSummary(lines));
		}
		foreach ((PropertyDefinition type, List<string> lines) in propertyDefinitionDocumentation)
		{
			membersElement.AddPropertyMember(document, type).AddSummary(document, GetSummary(lines));
		}
		foreach ((FieldDefinition type, List<string> lines) in fieldDefinitionDocumentation)
		{
			membersElement.AddFieldMember(document, type).AddSummary(document, GetSummary(lines));
		}
		foreach ((EventDefinition type, List<string> lines) in eventDefinitionDocumentation)
		{
			membersElement.AddEventMember(document, type).AddSummary(document, GetSummary(lines));
		}

		document.SaveWithTabs($"{SharedState.AssemblyName}.xml");
	}

	private static void SaveWithTabs(this XmlDocument document, string path)
	{
		XmlWriterSettings settings = new XmlWriterSettings();
		settings.Indent = true;
		settings.IndentChars = "\t";
		using FileStream stream = File.Create(path);
		XmlWriter writer = XmlWriter.Create(stream, settings);
		document.Save(writer);
	}

	public static void AddTypeDefinitionLine(TypeDefinition type, string line)
	{
		List<string> lines = typeDefinitionDocumentation.GetOrAdd(type);
		lines.Add(line);
	}

	public static void AddMethodDefinitionLine(MethodDefinition method, string line)
	{
		List<string> lines = methodDefinitionDocumentation.GetOrAdd(method);
		lines.Add(line);
	}

	public static void AddPropertyDefinitionLine(PropertyDefinition property, string line)
	{
		List<string> lines = propertyDefinitionDocumentation.GetOrAdd(property);
		lines.Add(line);
	}

	public static void AddPropertyDefinitionLine(PropertyBase property, string line)
	{
		AddPropertyDefinitionLine(property.Definition, line);
		if (property.SpecialDefinition is not null)
		{
			AddPropertyDefinitionLine(property.SpecialDefinition, line);
		}
	}

	public static void AddPropertyDefinitionLine(ClassProperty property, string line)
	{
		AddPropertyDefinitionLine((PropertyBase)property, line);
		if (property.HasBackingFieldInDeclaringType)
		{
			AddFieldDefinitionLine(property.BackingField, line);
		}
	}

	public static void AddPropertyDefinitionLineNotSpecial(ClassProperty property, string line)
	{
		AddPropertyDefinitionLine(property.Definition, line);
		if (property.HasBackingFieldInDeclaringType)
		{
			AddFieldDefinitionLine(property.BackingField, line);
		}
	}

	public static void AddFieldDefinitionLine(FieldDefinition field, string line)
	{
		List<string> lines = fieldDefinitionDocumentation.GetOrAdd(field);
		lines.Add(line);
	}

	public static void AddEventDefinitionLine(EventDefinition @event, string line)
	{
		List<string> lines = eventDefinitionDocumentation.GetOrAdd(@event);
		lines.Add(line);
	}

	private static string GetSummary(List<string> lines)
	{
		if (lines.Count == 0)
		{
			return "";
		}

		StringBuilder sb = new();
		sb.AppendLineAndThreeTabs();
		sb.Append(lines[0]);
		for (int i = 1; i < lines.Count; i++)
		{
			sb.AppendBreakTag();
			sb.AppendLineAndThreeTabs();
			sb.Append(lines[i]);
		}
		sb.AppendLineAndThreeTabs();
		return sb.ToString();
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/EnumTypeDocumenter.cs`:

```cs
using AssetRipper.AssemblyDumper.Enums;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.DocExtraction.DataStructures;

namespace AssetRipper.AssemblyDumper.Documentation;

internal static class EnumTypeDocumenter
{
	public static void AddEnumTypeDocumentation(TypeDefinition type, EnumDefinitionBase definition)
	{
		string fullNameList = string.Join(", ", definition.FullNames.Select(fullName => $"\"{XmlUtils.EscapeXmlInvalidCharacters(fullName)}\""));
		DocumentationHandler.AddTypeDefinitionLine(type, $"Full Names: {fullNameList}");
		if (definition is SingleEnumDefinition singleEnumDefinition)
		{
			EnumHistory history = singleEnumDefinition.History;

			if (!string.IsNullOrEmpty(history.InjectedDocumentation))
			{
				DocumentationHandler.AddTypeDefinitionLine(type, "Summary: " + history.InjectedDocumentation);
			}

			VersionedListDocumenter.AddSet(type, history.DocumentationString, "Summary: ");
			VersionedListDocumenter.AddList(type, history.ObsoleteMessage, "Obsolete Message: ");

			UnityVersion minimumVersion = definition.MinimumVersion;
			foreach ((string memberName, EnumMemberHistory memberHistory) in history.Members)
			{
				if (memberHistory.TryGetUniqueValue(out _, out IEnumerable<KeyValuePair<string, long>>? pairs))
				{
					FieldDefinition field = type.GetFieldByName(memberName);
					if (!string.IsNullOrEmpty(memberHistory.InjectedDocumentation))
					{
						DocumentationHandler.AddFieldDefinitionLine(field, "Summary: " + memberHistory.InjectedDocumentation);
					}
					VersionedListDocumenter.AddSet(field, memberHistory.DocumentationString, "Summary: ");
					VersionedListDocumenter.AddList(field, memberHistory.ObsoleteMessage, "Obsolete Message: ");
					DocumentationHandler.AddFieldDefinitionLine(field, memberHistory.GetVersionRange().GetUnionedRanges().GetString(minimumVersion));
				}
				else
				{
					foreach ((string fieldName, long value) in pairs)
					{
						FieldDefinition field = type.GetFieldByName(fieldName);
						if (!string.IsNullOrEmpty(memberHistory.InjectedDocumentation))
						{
							DocumentationHandler.AddFieldDefinitionLine(field, "Summary: " + memberHistory.InjectedDocumentation);
						}
						VersionedListDocumenter.AddSet(field, memberHistory.DocumentationString, "Summary: ");
						VersionedListDocumenter.AddList(field, memberHistory.ObsoleteMessage, "Obsolete Message: ");
						DocumentationHandler.AddFieldDefinitionLine(field,
							GetVersionRange(memberHistory.Exists, memberHistory.Value, value).GetUnionedRanges().GetString(minimumVersion));
					}
				}
			}

			//SharedState.Instance.MinVersion isn't used here because enums don't have the version type stripped.
			DocumentationHandler.AddTypeDefinitionLine(type, history.GetVersionRange().GetUnionedRanges().GetString(SharedState.Instance.MinSourceVersion));
		}
	}

	private static IEnumerable<UnityVersionRange> GetVersionRange(VersionedList<bool> existence, VersionedList<long> values, long value)
	{
		int existenceIndex = 0;
		int valuesIndex = 0;
		while (existenceIndex < existence.Count && valuesIndex < values.Count)
		{
			if (!existence[existenceIndex].Value) //Field does not exist in this range.
			{
				existenceIndex++;
				continue;
			}
			if (values[valuesIndex].Value != value) //Value does not match in this range.
			{
				valuesIndex++;
				continue;
			}

			UnityVersionRange valuesRange = values.GetRange(valuesIndex);
			UnityVersionRange existenceRange = existence.GetRange(existenceIndex);
			if (valuesRange.End <= existenceRange.Start) //Value range is lagging behind existence range.
			{
				valuesIndex++;
				continue;
			}
			if (existenceRange.End <= valuesRange.Start) //Existence range is lagging behind value range.
			{
				existenceIndex++;
				continue;
			}

			//At this point, the value range intersects the existence range, the field exists, and the value matches.

			UnityVersionRange intersection = valuesRange.MakeIntersection(existenceRange);
			yield return intersection;

			if (valuesRange.End <= existenceRange.End) //Existence range may still have space to intersect with the next value range.
			{
				valuesIndex++;
			}
			else // Vice versa.
			{
				existenceIndex++;
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/HistoryBaseExtensions.cs`:

```cs
using AssetRipper.DocExtraction.DataStructures;

namespace AssetRipper.AssemblyDumper.Documentation;

internal static class HistoryBaseExtensions
{

	public static IEnumerable<UnityVersionRange> GetVersionRange(this HistoryBase history)
	{
		if (history.Exists.Count == 0)
		{
			yield return default;
		}
		else if (history.Exists.Count == 1)
		{
			yield return new UnityVersionRange(history.Exists[0].Key, UnityVersion.MaxVersion);
		}
		else
		{
			for (int i = 0; i < history.Exists.Count; i++)
			{
				if (history.Exists[i].Value)
				{
					yield return history.Exists.GetRange(i);
				}
			}
		}
	}
}
```

`Source/AssetRipper.AssemblyDumper/Documentation/IdEnumDocumenter.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Documentation;

internal static class IdEnumDocumenter
{
	public static void AddIdEnumDocumentation()
	{
		foreach ((FieldDefinition field, ClassGroup group) in Passes.Pass556_CreateClassIDTypeEnum.FieldGroupDictionary)
		{
			DocumentationHandler.AddFieldDefinitionLine(field, SeeXmlTagGenerator.MakeCRef(group.Interface));
			DocumentationHandler.AddFieldDefinitionLine(field, SeeXmlTagGenerator.MakeCRef(group.GetOrCreateMainClass()));
			DocumentationHandler.AddFieldDefinitionLine(field, InterfaceDocumenter.GetUnityVersionString(group));
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/InjectedDocumenter.cs`:

```cs
using AssetRipper.AssemblyDumper.Passes;
using AssetRipper.AssemblyDumper.Types;

namespace AssetRipper.AssemblyDumper.Documentation;

internal static class InjectedDocumenter
{
	public static void AddDocumentation()
	{
		Dictionary<int, string> classTypeSummaries = new()
		{
		};
		Dictionary<int, List<(string, string)>> classPropertySummaries = new()
		{
			{ 1032 , new()
				{
					( Pass507_InjectedProperties.TargetSceneName , "The scene this asset references." ),
				}
			},
			{ 4 , new()
				{
					( "RootOrder_C4" , $"The index of this {SeeXmlTagGenerator.MakeCRefForClassInterface(4)} in its father's children. If a transform has no father, its root order should be 0." ),
				}
			},
		};
		Dictionary<string, string> subClassTypeSummaries = new()
		{
			{ "SceneObjectIdentifier" , $"A subset of {SeeXmlTagGenerator.MakeHRef(@"https://docs.unity3d.com/ScriptReference/GlobalObjectId.html", "GlobalObjectId")}." },
		};
		Dictionary<string, List<(string, string)>> subClassPropertySummaries = new()
		{
			{ "SceneObjectIdentifier" , new()
				{
					( "TargetObject" , $"The local file ID of the object." ),
					( "TargetPrefab" , "The prefab instance id of the object. For normal game objects, this prefab id is 0." ),
					( Pass508_LazySceneObjectIdentifier.TargetObjectName , "An object in the scene to be referenced. If not null, it will replace TargetObject during Yaml export." ),
					( Pass508_LazySceneObjectIdentifier.TargetPrefabName , "A prefab instance to be referenced. If not null, it will replace TargetPrefab during Yaml export." ),
				}
			},
			{ "SpriteRenderData" , new()
				{
					( "TextureRect" , "Actual sprite rectangle inside atlas texture (or in original texture for non atlas sprite)." ),
					( "TextureRect" , "It is a retangle of cropped image if tight mode is used. Otherwise, its size matches the original size." ),
					( "TextureRectOffset" , $"Offset of actual (cropped) sprite rectangle relative to {SeeXmlTagGenerator.MakeCRefForClassInterfaceProperty(213, "Rect")}." ),
					( "TextureRectOffset" , "Unity crops rectangle to save atlas space if tight mode is used." ),
					( "TextureRectOffset" , "The final atlas image is a cropped version of a rectangle that the developer specified in the original texture." ),
					( "TextureRectOffset" , $"In other words, this value shows how much Unity cropped the {SeeXmlTagGenerator.MakeCRefForClassInterfaceProperty(213, "Rect")} from the bottom-left corner." ),
				}
			},
			{ "SubMesh" , new()
				{
					( "FirstByte" , "Offset in the index buffer." ),
					( "FirstVertex" , "Offset in the vertex list." ),
				}
			},
		};
		AddDocumentationForDictionaries(classTypeSummaries, classPropertySummaries, subClassTypeSummaries, subClassPropertySummaries);
	}

	private static void AddDocumentationForDictionaries(
		Dictionary<int, string> classTypeSummaries,
		Dictionary<int, List<(string, string)>> classPropertySummaries,
		Dictionary<string, string> subClassTypeSummaries,
		Dictionary<string, List<(string, string)>> subClassPropertySummaries)
	{
		foreach ((int id, string summary) in classTypeSummaries)
		{
			ClassGroup group = SharedState.Instance.ClassGroups[id];
			DocumentationHandler.AddTypeDefinitionLine(group.Interface, summary);
			foreach (TypeDefinition type in group.Types)
			{
				DocumentationHandler.AddTypeDefinitionLine(type, summary);
			}
		}
		foreach ((int id, List<(string, string)> documentationDictionary) in classPropertySummaries)
		{
			ClassGroup group = SharedState.Instance.ClassGroups[id];
			AddDocumentationToGroup(group, documentationDictionary);
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				AddDocumentationToInstance(instance, documentationDictionary);
			}
		}
		foreach ((string subClass, string summary) in subClassTypeSummaries)
		{
			SubclassGroup group = SharedState.Instance.SubclassGroups[subClass];
			DocumentationHandler.AddTypeDefinitionLine(group.Interface, summary);
			foreach (TypeDefinition type in group.Types)
			{
				DocumentationHandler.AddTypeDefinitionLine(type, summary);
			}
		}
		foreach ((string subClass, List<(string, string)> documentationDictionary) in subClassPropertySummaries)
		{
			SubclassGroup group = SharedState.Instance.SubclassGroups[subClass];
			AddDocumentationToGroup(group, documentationDictionary);
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				AddDocumentationToInstance(instance, documentationDictionary);
			}
		}
	}

	private static void AddDocumentationToInstance(GeneratedClassInstance instance, List<(string, string)> documentationDictionary)
	{
		TypeDefinition type = instance.Type;
		foreach ((string propertyName, string summary) in documentationDictionary)
		{
			ClassProperty? classProperty = instance.Properties.FirstOrDefault(p => p.Definition.Name == propertyName);
			if (classProperty is not null)
			{
				DocumentationHandler.AddPropertyDefinitionLine(classProperty.Definition, summary);
				if (classProperty.SpecialDefinition is not null)
				{
					DocumentationHandler.AddPropertyDefinitionLine(classProperty.SpecialDefinition, summary);
				}
				if (classProperty.BackingField is not null)
				{
					DocumentationHandler.AddFieldDefinitionLine(classProperty.BackingField, summary);
				}
			}
			else
			{
				PropertyDefinition property = type.Properties.First(p => p.Name == propertyName);
				DocumentationHandler.AddPropertyDefinitionLine(property, summary);
				if (type.TryGetFieldByName($"m_{propertyName}", out FieldDefinition? field))
				{
					DocumentationHandler.AddFieldDefinitionLine(field, summary);
				}
			}
		}
	}

	private static void AddDocumentationToGroup(ClassGroupBase group, List<(string, string)> documentationDictionary)
	{
		foreach ((string propertyName, string summary) in documentationDictionary)
		{
			InterfaceProperty? classProperty = group.InterfaceProperties.FirstOrDefault(p => p.Definition.Name == propertyName);
			if (classProperty is not null)
			{
				DocumentationHandler.AddPropertyDefinitionLine(classProperty.Definition, summary);
				if (classProperty.SpecialDefinition is not null)
				{
					DocumentationHandler.AddPropertyDefinitionLine(classProperty.SpecialDefinition, summary);
				}
			}
			else
			{
				PropertyDefinition property = group.Interface.Properties.First(p => p.Name == propertyName);
				DocumentationHandler.AddPropertyDefinitionLine(property, summary);
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/InterfaceDocumenter.Properties.cs`:

```cs
using AssetRipper.DocExtraction.Extensions;

namespace AssetRipper.AssemblyDumper.Documentation;

internal static partial class InterfaceDocumenter
{
	private static void AddInterfacePropertyDocumentation(ClassGroupBase group)
	{
		foreach (InterfaceProperty interfaceProperty in group.InterfaceProperties)
		{
			if (!interfaceProperty.ReleaseOnlyRange.IsEmpty())
			{
				if (interfaceProperty.ReleaseOnlyMethod is null)
				{
					DocumentationHandler.AddPropertyDefinitionLine(interfaceProperty, "Release Only");
				}
				else
				{
					string versionString = interfaceProperty.ReleaseOnlyRange.GetString(interfaceProperty.Group.MinimumVersion);
					DocumentationHandler.AddPropertyDefinitionLine(interfaceProperty, $"Sometimes Release Only: {versionString}");
					DocumentationHandler.AddMethodDefinitionLine(interfaceProperty.ReleaseOnlyMethod, versionString);
				}
			}

			if (!interfaceProperty.EditorOnlyRange.IsEmpty())
			{
				if (interfaceProperty.EditorOnlyMethod is null)
				{
					DocumentationHandler.AddPropertyDefinitionLine(interfaceProperty, "Editor Only");
				}
				else
				{
					string versionString = interfaceProperty.EditorOnlyRange.GetString(interfaceProperty.Group.MinimumVersion);
					DocumentationHandler.AddPropertyDefinitionLine(interfaceProperty, $"Sometimes Editor Only: {versionString}");
					DocumentationHandler.AddMethodDefinitionLine(interfaceProperty.EditorOnlyMethod, versionString);
				}
			}

			if (interfaceProperty.HasMethod is not null)
			{
				string versionString = interfaceProperty.PresentRange.GetString(group.MinimumVersion);
				DocumentationHandler.AddMethodDefinitionLine(interfaceProperty.HasMethod, versionString);
				DocumentationHandler.AddPropertyDefinitionLine(interfaceProperty, versionString);
			}
			else
			{
				DocumentationHandler.AddPropertyDefinitionLine(interfaceProperty, interfaceProperty.Definition.IsValueType() ? "Not absent" : "Not null");
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/InterfaceDocumenter.Types.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Documentation;

internal static partial class InterfaceDocumenter
{
	private static void AddInterfaceTypeDocumentation(ClassGroupBase group)
	{
		if (group is ClassGroup classGroup)
		{
			DocumentationHandler.AddTypeDefinitionLine(group.Interface, $"Interface for the {string.Join(", ", classGroup.Names)} classes.");
			HashSet<int> typeIDs = classGroup.Classes.Select(c => c.OriginalTypeID).ToHashSet();
			if (typeIDs.Count == 1)
			{
				DocumentationHandler.AddTypeDefinitionLine(group.Interface, $"Type ID: {typeIDs.First()}");
			}
			else
			{
				DocumentationHandler.AddTypeDefinitionLine(group.Interface, $"Type IDs: {string.Join(", ", typeIDs)}");
			}
			if (group.Types.All(t => t.IsAbstract))
			{
				DocumentationHandler.AddTypeDefinitionLine(group.Interface, "Abstract");
			}
			else if (group.Types.Any(t => t.IsAbstract))
			{
				string rangeString = group.Instances
					.Where(i => i.Type.IsAbstract)
					.Select(i => i.VersionRange)
					.GetUnionedRanges()
					.GetString(SharedState.Instance.MinVersion);
				DocumentationHandler.AddTypeDefinitionLine(group.Interface, $"Abstract: {rangeString}");
			}
		}
		else
		{
			DocumentationHandler.AddTypeDefinitionLine(group.Interface, $"Interface for the {group.Name} classes.");
		}
		if (group.Instances.All(instance => instance.Class.IsReleaseOnly))
		{
			DocumentationHandler.AddTypeDefinitionLine(group.Interface, "Release Only");
		}
		if (group.Instances.All(instance => instance.Class.IsEditorOnly))
		{
			DocumentationHandler.AddTypeDefinitionLine(group.Interface, "Editor Only");
		}
		DocumentationHandler.AddTypeDefinitionLine(group.Interface, GetSerializedVersionString(group));
		DocumentationHandler.AddTypeDefinitionLine(group.Interface, GetUnityVersionString(group));
	}

	internal static string GetUnityVersionString(ClassGroupBase group)
	{
		return group.Instances
			.Select(instance => instance.VersionRange)
			.GetUnionedRanges()
			.GetString(SharedState.Instance.MinVersion);
	}

	private static string GetSerializedVersionString(ClassGroupBase group)
	{
		group.GetSerializedVersions(out int minimum, out int maximum);
		return minimum == maximum
			? $"Serialized Version: {minimum}"
			: $"Serialized Versions: {minimum} to {maximum}";
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/InterfaceDocumenter.cs`:

```cs
using AssetRipper.DocExtraction.DataStructures;

namespace AssetRipper.AssemblyDumper.Documentation;

internal static partial class InterfaceDocumenter
{
	public static void AddInterfaceDocumentation(ClassGroupBase group)
	{
		AddDocumentationFromHistory(group);
		AddInterfaceTypeDocumentation(group);
		AddInterfacePropertyDocumentation(group);
	}

	private static void AddDocumentationFromHistory(ClassGroupBase group)
	{
		if (group.History is not null)
		{
			VersionedListDocumenter.AddSet(group.Interface, group.History.NativeName, "Native Name: ");
			VersionedListDocumenter.AddSet(group.Interface, group.History.DocumentationString, "Summary: ");
			VersionedListDocumenter.AddList(group.Interface, group.History.ObsoleteMessage, "Obsolete Message: ");
		}

		foreach (InterfaceProperty interfaceProperty in group.InterfaceProperties)
		{
			if (interfaceProperty.History is not null)
			{
				AddPropertyDocumentationFromHistory(interfaceProperty.Definition, interfaceProperty.History);

				if (interfaceProperty.SpecialDefinition is not null)
				{
					AddPropertyDocumentationFromHistory(interfaceProperty.SpecialDefinition, interfaceProperty.History);
				}
			}
			if (interfaceProperty.SpecialDefinition is not null)
			{
				if (interfaceProperty.HasEnumVariant)
				{
					DocumentationHandler.AddPropertyDefinitionLine(interfaceProperty.Definition, "Enum variant available.");
				}
				else
				{
					DocumentationHandler.AddPropertyDefinitionLine(interfaceProperty.Definition, "PPtr variant available.");
				}
			}
		}
	}

	private static void AddPropertyDocumentationFromHistory(PropertyDefinition property, DataMemberHistory history)
	{
		VersionedListDocumenter.AddSet(property, history.NativeName, "Native Name: ");
		VersionedListDocumenter.AddList(property, history.TypeFullName, "Managed Type: ");
		VersionedListDocumenter.AddSet(property, history.DocumentationString, "Summary: ");
		VersionedListDocumenter.AddList(property, history.ObsoleteMessage, "Obsolete Message: ");
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/SeeXmlTagGenerator.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Documentation;

internal static class SeeXmlTagGenerator
{
	private static string MakeCRef(string interior)
	{
		return $"<see cref=\"{interior}\"/>";
	}

	public static string MakeCRef(Type type)
	{
		return MakeCRef(XmlUtils.GetStringReference(type));
	}

	public static string MakeCRef(TypeDefinition type)
	{
		return MakeCRef(XmlUtils.GetStringReference(type));
	}

	public static string MakeCRef(PropertyDefinition property)
	{
		return MakeCRef(XmlUtils.GetStringReference(property));
	}

	public static string MakeCRefForClassInterface(int classID)
	{
		return MakeCRef(SharedState.Instance.ClassGroups[classID].Interface);
	}

	public static string MakeCRefForClassInterfaceProperty(int classID, string propertyName)
	{
		return MakeCRef(SharedState.Instance.ClassGroups[classID].Interface.Properties.First(p => p.Name == propertyName));
	}

	public static string MakeCRefForSubclassInterface(string name)
	{
		return MakeCRef(SharedState.Instance.SubclassGroups[name].Interface);
	}

	public static string MakeHRef(string link)
	{
		return $"<see href=\"{link}\"/>";
	}

	public static string MakeHRef(string link, string displayText)
	{
		return $"<see href=\"{link}\">{displayText}</see>";
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/StringBuilderExtensions.cs`:

```cs
using AssetRipper.Numerics;
using System.Text;

namespace AssetRipper.AssemblyDumper.Documentation;

internal static class StringBuilderExtensions
{
	public static void AppendLineAndThreeTabs(this StringBuilder sb) => sb.Append("\n\t\t\t");
	public static void AppendBreakTag(this StringBuilder sb) => sb.Append("<br />");
	public static void AppendUnityVersionRange(this StringBuilder sb, Range<UnityVersion> range, UnityVersion minimumVersion)
	{
		sb.Append(range.Start == minimumVersion ? "Min" : range.Start.ToCleanString('.'));
		sb.Append(" to ");
		sb.Append(range.End == UnityVersion.MaxVersion ? "Max" : range.End.ToCleanString('.'));
	}
	public static void AppendUnityVersionRanges(this StringBuilder sb, IReadOnlyList<UnityVersionRange> ranges, UnityVersion minimumVersion)
	{
		sb.AppendUnityVersionRange(ranges[0], minimumVersion);
		for (int i = 1; i < ranges.Count; i++)
		{
			sb.Append(", ");
			sb.AppendUnityVersionRange(ranges[i], minimumVersion);
		}
	}
	public static void AppendUnityVersionRanges(this StringBuilder sb, DiscontinuousRange<UnityVersion> range, UnityVersion minimumVersion)
	{
		if (!range.IsEmpty())
		{
			sb.AppendUnityVersionRange(range[0], minimumVersion);
			for (int i = 1; i < range.Count; i++)
			{
				sb.Append(", ");
				sb.AppendUnityVersionRange(range[i], minimumVersion);
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/StringExtensions.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Documentation;

internal static class StringExtensions
{
	public static string EscapeXml(this string str)
	{
		return XmlUtils.EscapeXmlInvalidCharacters(str);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/UnityVersionRangeExtensions.cs`:

```cs
using AssetRipper.Numerics;
using System.Text;

namespace AssetRipper.AssemblyDumper.Documentation;

internal static class UnityVersionRangeExtensions
{
	public static IReadOnlyList<UnityVersionRange> GetUnionedRanges(this IEnumerable<UnityVersionRange> ranges)
	{
		List<UnityVersionRange> unionedRanges = new();
		foreach (UnityVersionRange range in ranges)
		{
			if (unionedRanges.Count > 0 && unionedRanges[unionedRanges.Count - 1].CanUnion(range))
			{
				unionedRanges[unionedRanges.Count - 1] = unionedRanges[unionedRanges.Count - 1].MakeUnion(range);
			}
			else
			{
				unionedRanges.Add(range);
			}
		}
		return unionedRanges;
	}

	public static string GetString(this IReadOnlyList<UnityVersionRange> ranges, UnityVersion minimumVersion)
	{
		StringBuilder sb = new();
		sb.AppendUnityVersionRanges(ranges, minimumVersion);
		return sb.ToString();
	}

	public static string GetString(this DiscontinuousRange<UnityVersion> range, UnityVersion minimumVersion)
	{
		StringBuilder sb = new();
		sb.AppendUnityVersionRanges(range, minimumVersion);
		return sb.ToString();
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/UnityVersionRangeUtils.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Documentation;

internal static class UnityVersionRangeUtils
{
	public static string GetUnityVersionRangeString(UnityVersionRange range)
	{
		string start = range.Start == UnityVersion.MinVersion || range.Start == SharedState.Instance.MinVersion
			? "Min"
			: range.Start.ToCleanString('.');
		string end = range.End == UnityVersion.MaxVersion
			? "Max"
			: range.End.ToCleanString('.');
		return $"{start} to {end}";
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/VersionedListDocumenter.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;

namespace AssetRipper.AssemblyDumper.Documentation;

internal static class VersionedListDocumenter
{
	public static void AddList<T>(TypeDefinition type, VersionedList<T> versionedList, string prefix)
	{
		foreach (string? str in GetContentFromList(versionedList, prefix))
		{
			AddMultiLineString(type, str);
		}
	}

	public static void AddList<T>(FieldDefinition field, VersionedList<T> versionedList, string prefix)
	{
		foreach (string? str in GetContentFromList(versionedList, prefix))
		{
			AddMultiLineString(field, str);
		}
	}

	public static void AddList<T>(PropertyDefinition property, VersionedList<T> versionedList, string prefix)
	{
		foreach (string? str in GetContentFromList(versionedList, prefix))
		{
			AddMultiLineString(property, str);
		}
	}

	public static void AddSet<T>(TypeDefinition type, VersionedList<T> versionedList, string prefix)
	{
		foreach (string? str in GetContentFromSet(versionedList, prefix))
		{
			AddMultiLineString(type, str);
		}
	}

	public static void AddSet<T>(FieldDefinition field, VersionedList<T> versionedList, string prefix)
	{
		foreach (string? str in GetContentFromSet(versionedList, prefix))
		{
			AddMultiLineString(field, str);
		}
	}

	public static void AddSet<T>(PropertyDefinition property, VersionedList<T> versionedList, string prefix)
	{
		foreach (string? str in GetContentFromSet(versionedList, prefix))
		{
			AddMultiLineString(property, str);
		}
	}

	private static void AddMultiLineString(TypeDefinition type, string? str)
	{
		if (string.IsNullOrEmpty(str))
		{
			return;
		}
		else if (!str.Contains('\n'))
		{
			DocumentationHandler.AddTypeDefinitionLine(type, str.Trim().EscapeXml());
		}
		else
		{
			foreach (string line in str.Split('\n', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries))
			{
				DocumentationHandler.AddTypeDefinitionLine(type, line.EscapeXml());
			}
		}
	}

	private static void AddMultiLineString(FieldDefinition field, string? str)
	{
		if (string.IsNullOrEmpty(str))
		{
			return;
		}
		else if (!str.Contains('\n'))
		{
			DocumentationHandler.AddFieldDefinitionLine(field, str.Trim().EscapeXml());
		}
		else
		{
			foreach (string line in str.Split('\n', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries))
			{
				DocumentationHandler.AddFieldDefinitionLine(field, line.EscapeXml());
			}
		}
	}

	private static void AddMultiLineString(PropertyDefinition property, string? str)
	{
		if (string.IsNullOrEmpty(str))
		{
			return;
		}
		else if (!str.Contains('\n'))
		{
			DocumentationHandler.AddPropertyDefinitionLine(property, str.Trim().EscapeXml());
		}
		else
		{
			foreach (string line in str.Split('\n', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries))
			{
				DocumentationHandler.AddPropertyDefinitionLine(property, line.EscapeXml());
			}
		}
	}

	private static IEnumerable<string?> GetContentFromList<T>(VersionedList<T> versionedList, string prefix)
	{
		if (versionedList.Count == 1)
		{
			yield return MaybePrefixString(versionedList[0].Value?.ToString(), prefix);
		}
		else
		{
			Dictionary<StringWrapper, LinkedList<UnityVersionRange>> summaries = new();
			for (int i = 0; i < versionedList.Count; i++)
			{
				string? summary = versionedList[i].Value?.ToString();
				if (!summaries.TryGetValue(summary, out LinkedList<UnityVersionRange>? rangeList))
				{
					rangeList = new();
					summaries.Add(summary, rangeList);
				}
				rangeList.AddLast(versionedList.GetRange(i));
			}
			if (summaries.Count == 0)
			{
			}
			else if (summaries.Count == 1)
			{
				yield return MaybePrefixString(summaries.Single().Key.String, prefix);
			}
			else
			{
				foreach ((StringWrapper summary, LinkedList<UnityVersionRange> list) in summaries)
				{
					yield return $"{prefix}{list.GetUnionedRanges().GetString(SharedState.Instance.MinVersion)}";
					yield return summary.String ?? "null";
				}
			}
		}
	}

	private static IEnumerable<string?> GetContentFromSet<T>(VersionedList<T> versionedList, string prefix)
	{
		if (versionedList.Count == 1)
		{
			yield return MaybePrefixString(versionedList[0].Value?.ToString(), prefix);
		}
		else
		{
			Dictionary<StringWrapper, LinkedList<UnityVersionRange>> summaries = new();
			for (int i = 0; i < versionedList.Count; i++)
			{
				string? summary = versionedList[i].Value?.ToString();
				if (!summaries.TryGetValue(summary, out LinkedList<UnityVersionRange>? rangeList))
				{
					rangeList = new();
					summaries.Add(summary, rangeList);
				}
				rangeList.AddLast(versionedList.GetRange(i));
			}
			if (summaries.Count == 0)
			{
			}
			else if (summaries.Count == 1)
			{
				yield return MaybePrefixString(summaries.Single().Key.String, prefix);
			}
			else
			{
				foreach ((StringWrapper summary, LinkedList<UnityVersionRange> list) in summaries)
				{
					yield return MaybePrefixString(summary.String, prefix);
				}
			}
		}
	}

	[return: NotNullIfNotNull(nameof(str))]
	private static string? MaybePrefixString(string? str, string prefix)
	{
		return str is null ? null : $"{prefix}{str}";
	}

	private readonly record struct StringWrapper(string? String)
	{
		public static implicit operator string?(StringWrapper wrapper) => wrapper.String;
		public static implicit operator StringWrapper(string? @string) => new StringWrapper(@string);
	}
}
```

`Source/AssetRipper.AssemblyDumper/Documentation/XmlNodeExtensions.cs`:

```cs
using System.Xml;

namespace AssetRipper.AssemblyDumper.Documentation;

internal static class XmlNodeExtensions
{
	internal static void AddAssemblyName(this XmlNode docElement, XmlDocument document, string assemblyName)
	{
		XmlElement assemblyElement = docElement.AddChildElement(document, "assembly");
		XmlElement nameElement = assemblyElement.AddChildElement(document, "name");
		nameElement.InnerXml = assemblyName;
	}

	internal static XmlElement AddInheritDoc(this XmlNode memberElement, XmlDocument document)
	{
		return memberElement.AddChildElement(document, "inheritdoc");
	}

	internal static XmlElement AddMember(this XmlNode membersElement, XmlDocument document, string memberName)
	{
		XmlElement memberElement = membersElement.AddChildElement(document, "member");
		XmlAttribute attribute = document.CreateAttribute("name");
		attribute.InnerXml = memberName;
		memberElement.Attributes.Append(attribute);
		return memberElement;
	}

	internal static XmlElement AddSummary(this XmlNode memberElement, XmlDocument document, string summaryContent)
	{
		XmlElement summaryElement = memberElement.AddChildElement(document, "summary");
		summaryElement.InnerXml = summaryContent;
		return summaryElement;
	}

	internal static XmlElement AddChildElement(this XmlNode parent, XmlDocument document, string name)
	{
		XmlElement element = document.CreateElement(name);
		parent.AppendChild(element);
		return element;
	}

	internal static XmlElement AddTypeMember(this XmlNode membersElement, XmlDocument document, TypeDefinition type)
	{
		return membersElement.AddMember(document, XmlUtils.GetStringReference(type));
	}

	internal static XmlElement AddMethodMember(this XmlNode membersElement, XmlDocument document, MethodDefinition method)
	{
		return membersElement.AddMember(document, XmlUtils.GetStringReference(method));
	}

	internal static XmlElement AddPropertyMember(this XmlNode membersElement, XmlDocument document, PropertyDefinition property)
	{
		return membersElement.AddMember(document, XmlUtils.GetStringReference(property));
	}

	internal static XmlElement AddFieldMember(this XmlNode membersElement, XmlDocument document, FieldDefinition field)
	{
		return membersElement.AddMember(document, XmlUtils.GetStringReference(field));
	}

	internal static XmlElement AddEventMember(this XmlNode membersElement, XmlDocument document, EventDefinition @event)
	{
		return membersElement.AddMember(document, XmlUtils.GetStringReference(@event));
	}
}

```

`Source/AssetRipper.AssemblyDumper/Documentation/XmlUtils.cs`:

```cs
using System.Xml;

namespace AssetRipper.AssemblyDumper.Documentation;

internal static class XmlUtils
{
	internal static XmlDocument CreateNewDocument()
	{
		XmlDocument document = new XmlDocument();
		document.AppendChild(document.CreateXmlDeclaration("1.0", null, null));
		return document;
	}

	internal static string EscapeXmlInvalidCharacters(string originalString)
	{
		return System.Security.SecurityElement.Escape(originalString);
	}

	internal static string GetStringReference(Type type)
	{
		return $"T:{type.FullName}";
	}

	internal static string GetStringReference(TypeDefinition type)
	{
		return $"T:{type.FullName}";
	}

	internal static string GetStringReference(PropertyDefinition property)
	{
		return $"P:{property.DeclaringType?.FullName}.{property.Name}";
	}

	//If the name of the item itself has periods, they're replaced by the hash-sign ('#').
	//It's assumed that no item has a hash-sign directly in its name.
	//For example, the fully qualified name of the String constructor is "System.String.#ctor".
	internal static string GetStringReference(FieldDefinition field)
	{
		return $"F:{field.DeclaringType?.FullName}.{((string?)field.Name)?.Replace('.', '#')}";
	}

	internal static string GetStringReference(EventDefinition @event)
	{
		return $"E:{@event.DeclaringType?.FullName}.{@event.Name}";
	}

	internal static string GetStringReference(MethodDefinition method)
	{
		//@ is used instead of & for by-ref parameters.
		return $"M:{method.DeclaringType?.FullName}.{method.Name}{GetParameterString(method.Signature)}".Replace('&', '@');

		static string GetParameterString(MethodSignature? signature)
		{
			return signature is null || signature.ParameterTypes.Count == 0
				? string.Empty
				: $"({string.Join(',', signature.ParameterTypes.Select(t => t.FullName))})";
		}
	}

	internal static string GetStringReference(string @namespace)
	{
		return $"N:{@namespace}";
	}
}

```

`Source/AssetRipper.AssemblyDumper/Enums/EnumDefinitionBase.cs`:

```cs
using AssetRipper.DocExtraction.DataStructures;
using System.Collections;

namespace AssetRipper.AssemblyDumper.Enums;

internal abstract class EnumDefinitionBase
{
	public abstract string Name { get; }
	public abstract bool MatchesFullName(string fullName);
	public abstract IOrderedEnumerable<KeyValuePair<string, long>> GetOrderedFields();
	public abstract IEnumerable<string> FullNames { get; }
	public abstract bool IsFlagsEnum { get; }
	public abstract ElementType ElementType { get; }
	public abstract UnityVersion MinimumVersion { get; }

	public static Dictionary<string, IReadOnlyList<EnumDefinitionBase>> Create(IEnumerable<EnumHistory> histories)
	{
		Dictionary<string, List<EnumHistory>> dictionary = new();
		foreach (EnumHistory history in histories)
		{
			if (!dictionary.TryGetValue(history.Name, out List<EnumHistory>? list))
			{
				list = new();
				dictionary.Add(history.Name, list);
			}
			list.Add(history);
		}
		Dictionary<string, IReadOnlyList<EnumDefinitionBase>> result = new();
		foreach ((string name, List<EnumHistory> list) in dictionary)
		{
			if (list.Count == 1)
			{
				result.Add(name, new[] { new SingleEnumDefinition(list[0]) });
			}
			else
			{
				List<List<EnumHistory>> boxes = new();
				foreach (EnumHistory history in list)
				{
					List<EnumHistory>? box = boxes.FirstOrDefault(b => HaveSameFields(b[0], history));
					if (box is not null)
					{
						box.Add(history);
					}
					else
					{
						boxes.Add(new() { history });
					}
				}
				List<EnumDefinitionBase> definitions = new(list.Count);
				foreach (List<EnumHistory> box in boxes)
				{
					if (box.Count == 1)
					{
						definitions.Add(new SingleEnumDefinition(box[0]));
					}
					else
					{
						definitions.Add(new MergedEnumDefinition(box));
					}
				}
				result.Add(name, definitions);
			}
		}
		return result;
	}

	private static bool HaveSameFields(EnumHistory x, EnumHistory y)
	{
		return x.GetOrderedFields().SequenceEqual(y.GetOrderedFields());
	}

	private protected sealed class SingleEnumerable<T> : IEnumerable<T>
	{
		public SingleEnumerable(T value)
		{
			Value = value;
		}
		public T Value { get; }
		public IEnumerator<T> GetEnumerator()
		{
			yield return Value;
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Enums/MergedEnumDefinition.cs`:

```cs
using AssetRipper.DocExtraction.DataStructures;
using AssetRipper.DocExtraction.Extensions;

namespace AssetRipper.AssemblyDumper.Enums;

internal sealed class MergedEnumDefinition : EnumDefinitionBase
{
	internal MergedEnumDefinition(List<EnumHistory> histories)
	{
		Histories = histories;
	}

	public IEnumerable<EnumHistory> Histories { get; }

	public override string Name => Histories.First().Name;

	public override IEnumerable<string> FullNames => Histories.Select(history => history.FullName);

	public override bool IsFlagsEnum => Histories.Any(v => v.IsFlagsEnum);

	public override ElementType ElementType
	{
		get
		{
			bool first = true;
			ElementType type = default;
			foreach (EnumHistory history in Histories)
			{
				if (first)
				{
					if (history.TryGetMergedElementType(out ElementType otherType))
					{
						type = otherType;
						first = false;
					}
					else
					{
						return ElementType.I8;
					}
				}
				else
				{
					if (history.TryGetMergedElementType(out ElementType otherType))
					{
						type = type.Merge(otherType);
					}
					else
					{
						return ElementType.I8;
					}
				}
			}
			return type;
		}
	}

	public override UnityVersion MinimumVersion => Histories.Min(v => v.MinimumVersion);

	public override bool MatchesFullName(string fullName)
	{
		return FullNames.Contains(fullName);
	}

	public override IOrderedEnumerable<KeyValuePair<string, long>> GetOrderedFields()
	{
		return Histories.First().GetOrderedFields();
	}
}
```

`Source/AssetRipper.AssemblyDumper/Enums/SingleEnumDefinition.cs`:

```cs
using AssetRipper.DocExtraction.DataStructures;

namespace AssetRipper.AssemblyDumper.Enums;

internal sealed class SingleEnumDefinition : EnumDefinitionBase
{
	public SingleEnumDefinition(EnumHistory history)
	{
		History = history;
	}

	public EnumHistory History { get; }
	public override string Name => History.Name;
	public override IEnumerable<string> FullNames => new SingleEnumerable<string>(History.FullName);

	public override bool MatchesFullName(string fullName)
	{
		return History.FullName == fullName;
	}

	public override IOrderedEnumerable<KeyValuePair<string, long>> GetOrderedFields() => History.GetOrderedFields();

	public override bool IsFlagsEnum => History.IsFlagsEnum;

	public override ElementType ElementType => History.GetMergedElementType();

	public override UnityVersion MinimumVersion => History.MinimumVersion;
}

```

`Source/AssetRipper.AssemblyDumper/Extensions/CilInstructionCollectionExtensions.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;

namespace AssetRipper.AssemblyDumper.Extensions;

internal static class CilInstructionCollectionExtensions
{
	public static void AddNotSupportedException(this CilInstructionCollection instructions)
	{
		IMethodDefOrRef constructor = SharedState.Instance.Importer.ImportDefaultConstructor<NotSupportedException>();
		instructions.Add(CilOpCodes.Newobj, constructor);
		instructions.Add(CilOpCodes.Throw);
	}

	/*public static void AddLogStatement(this CilInstructionCollection instructions, string text)
	{
		Func<MethodDefinition, bool> func = m => m.IsStatic && m.Name == nameof(Logger.Info) && m.Parameters.Count == 1 && m.Parameters[0].ParameterType.Name == "String";
		IMethodDefOrRef writeMethod = SharedState.Instance.Importer.ImportMethod(typeof(Logger), func);
		instructions.Add(CilOpCodes.Ldstr, text);
		instructions.Add(CilOpCodes.Call, writeMethod);
	}*/
}

```

`Source/AssetRipper.AssemblyDumper/Extensions/DictionaryExtensions.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Extensions;

internal static class DictionaryExtensions
{
	public static TValue GetOrAdd<TKey, TValue>(this Dictionary<TKey, TValue> dict, TKey key)
		where TKey : notnull
		where TValue : new()
	{
		if (!dict.TryGetValue(key, out TValue? value))
		{
			value = new TValue();
			dict.Add(key, value);
		}
		return value;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Extensions/EnumHistoryExtensions.cs`:

```cs
using AssetRipper.DocExtraction.DataStructures;

namespace AssetRipper.AssemblyDumper.Extensions;

internal static class EnumHistoryExtensions
{
	public static IEnumerable<KeyValuePair<string, long>> GetFields(this EnumHistory history)
	{
		foreach (EnumMemberHistory member in history.Members.Values)
		{
			if (member.TryGetUniqueValue(out long value, out IEnumerable<KeyValuePair<string, long>>? pairs))
			{
				yield return new KeyValuePair<string, long>(member.Name, value);
			}
			else
			{
				foreach (KeyValuePair<string, long> pair in pairs)
				{
					yield return pair;
				}
			}
		}
	}

	public static IOrderedEnumerable<KeyValuePair<string, long>> GetOrderedFields(this EnumHistory history)
	{
		return history.GetFields().Order(EnumFieldComparer.Instance);
	}

	public static ElementType GetMergedElementType(this EnumHistory history)
	{
		return history.TryGetMergedElementType(out ElementType type) ? type : ElementType.I8;
	}

	private sealed class EnumFieldComparer : IComparer<KeyValuePair<string, long>>
	{
		private EnumFieldComparer() { }

		public static EnumFieldComparer Instance { get; } = new();

		int IComparer<KeyValuePair<string, long>>.Compare(KeyValuePair<string, long> x, KeyValuePair<string, long> y)
		{
			return Compare(x, y);
		}

		/// <summary>
		/// Compare two enum fields
		/// </summary>
		/// <param name="x"></param>
		/// <param name="y"></param>
		/// <returns>
		/// <paramref name="x"/> &lt; <paramref name="y"/> : -1<br/>
		/// <paramref name="x"/> == <paramref name="y"/> : 0<br/>
		/// <paramref name="x"/> &gt; <paramref name="y"/> : 1<br/>
		/// </returns>
		public static int Compare(KeyValuePair<string, long> x, KeyValuePair<string, long> y)
		{
			if (x.Value != y.Value)
			{
				return x.Value < y.Value ? -1 : 1;
			}
			else
			{
				return x.Key.CompareTo(y.Key);
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Extensions/EnumMemberHistoryExtensions.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.DocExtraction.DataStructures;

namespace AssetRipper.AssemblyDumper.Extensions;

internal static class EnumMemberHistoryExtensions
{
	public static IEnumerable<KeyValuePair<string, long>> GetFields(this EnumMemberHistory member)
	{
		if (IsUnique(member.Value, out long uniqueValue))
		{
			yield return new KeyValuePair<string, long>(member.Name, uniqueValue);
		}
		else
		{
			foreach (long value in member.Value.Values.Where(v => v != -1).ToHashSet())
			{
				string fieldName = GetEnumFieldName(member.Name, value);
				yield return new KeyValuePair<string, long>(fieldName, value);
			}
		}
	}

	public static bool TryGetUniqueValue(
		this EnumMemberHistory member,
		out long value,
		[NotNullWhen(false)] out IEnumerable<KeyValuePair<string, long>>? fields)
	{
		if (IsUnique(member.Value, out long uniqueValue))
		{
			value = uniqueValue;
			fields = null;
			return true;
		}
		else
		{
			value = default;
			fields = ToEnumerable(member.Name, member.Value.Values.ToHashSet());
			return false;
		}

		static IEnumerable<KeyValuePair<string, long>> ToEnumerable(string memberName, HashSet<long> values)
		{
			foreach (long value in values.Where(v => v != -1))
			{
				string fieldName = GetEnumFieldName(memberName, value);
				yield return new KeyValuePair<string, long>(fieldName, value);
			}
		}
	}

	private static bool IsUnique(VersionedList<long> list, out long value)
	{
		if (list.Count is 1)
		{
			value = list[0].Value;
			return true;
		}
		else if (list.Count == 2 && list[1].Value is -1)
		{
			//This member was made obsolete and given a value of -1.
			value = list[0].Value;
			return true;
		}
		else if (list.Count == 2 && list[0].Value == unchecked(-list[1].Value))
		{
			//This member was made obsolete and given a value of -1 * its original value.
			value = list[0].Value;
			return true;
		}
		else
		{
			value = default;
			return false;
		}
	}

	private static string GetEnumFieldName(string name, long value)
	{
		return value switch
		{
			long.MinValue => $"{name}_MinS64",
			long.MaxValue => $"{name}_MaxS64",
			int.MinValue => $"{name}_MinS32",
			int.MaxValue => $"{name}_MaxS32",
			short.MinValue => $"{name}_MinS16",
			short.MaxValue => $"{name}_MaxS16",
			sbyte.MinValue => $"{name}_MinS8",
			sbyte.MaxValue => $"{name}_MaxS8",
			uint.MaxValue => $"{name}_MaxU32",
			ushort.MaxValue => $"{name}_MaxU16",
			byte.MaxValue => $"{name}_MaxU8",
			< 0 => $"{name}_N{-value}",
			_ => $"{name}_{value}",
		};
	}
}

```

`Source/AssetRipper.AssemblyDumper/Extensions/TypeSignatureExtensions.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Extensions;

internal static class TypeSignatureExtensions
{
	public static bool IsUtf8String(this TypeSignature signature)
	{
		return signature is TypeDefOrRefSignature { Name: nameof(Utf8String) } signature2 && signature2.Namespace == typeof(Utf8String).Namespace;
	}
	public static bool IsIntegerPrimitive(this TypeSignature signature, out ElementType elementType)
	{
		if (signature is CorLibTypeSignature corLibTypeSignature)
		{
			elementType = corLibTypeSignature.ElementType;
			return elementType is
				ElementType.U1 or
				ElementType.U2 or
				ElementType.U4 or
				ElementType.U or
				ElementType.U8 or
				ElementType.I1 or
				ElementType.I2 or
				ElementType.I4 or
				ElementType.I or
				ElementType.I8;
		}
		else
		{
			elementType = default;
			return false;
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Extensions/UnityVersionExtensions.cs`:

```cs
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Extensions;

internal static class UnityVersionExtensions
{
	public static UnityVersion StripTypeNumber(this UnityVersion version)
	{
		return new UnityVersion(version.Major, version.Minor, version.Build, version.Type);
	}

	public static UnityVersion StripType(this UnityVersion version)
	{
		return new UnityVersion(version.Major, version.Minor, version.Build);
	}

	public static UnityVersion StripBuild(this UnityVersion version)
	{
		return new UnityVersion(version.Major, version.Minor);
	}

	public static UnityVersion StripMinor(this UnityVersion version)
	{
		return new UnityVersion(version.Major);
	}

	public static string ToCleanString(this UnityVersion version, char separator)
	{
		if (version.Type is UnityVersionType.Alpha && version.TypeNumber is 0)
		{
			if (version.Build is 0)
			{
				if (version.Minor is 0)
				{
					return version.Major.ToString();
				}
				else
				{
					return $"{version.Major}{separator}{version.Minor}";
				}
			}
			else
			{
				return $"{version.Major}{separator}{version.Minor}{separator}{version.Build}";
			}
		}
		else
		{
			if (separator == '_')
			{
				return $"{version.Major}_{version.Minor}_{version.Build}_{version.Type.ToCharacter()}{version.TypeNumber}";
			}
			else
			{
				Debug.Assert(separator == '.');
				return $"{version.Major}.{version.Minor}.{version.Build}{version.Type.ToCharacter()}{version.TypeNumber}";
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Fields/FixedSizeBufferCreator.cs`:

```cs
using AssetRipper.AssemblyDumper.Types;
using System.Runtime.CompilerServices;

namespace AssetRipper.AssemblyDumper.Fields;

/// <summary>
/// Helper class for creating fixed size buffer fields<br/>
/// <seealso href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code#fixed-size-buffers"/>
/// </summary>
/// <remarks>
/// The array type must be bool, byte, char, short, int, long, sbyte, ushort, uint, ulong, float, or double.
/// </remarks>
public static class FixedSizeBufferCreator
{
	public static FieldDefinition AddFixedSizeBufferField(this TypeDefinition declaringType, AssemblyBuilder builder, CorLibTypeSignature arrayElementType, string fieldName, int length)
	{
		uint size = (uint)(length * GetSize(arrayElementType));
		TypeDefinition nestedType = MakeNestedType(declaringType, builder, arrayElementType, fieldName, size);
		FieldDefinition field = declaringType.AddField(fieldName, nestedType.ToTypeSignature());
		IMethodDefOrRef attributeConstructor = builder.Importer.ImportMethod<FixedBufferAttribute>(m => m.IsConstructor && !m.IsStatic && m.Parameters.Count == 2);
		field.AddCustomAttribute(attributeConstructor,
			(builder.Importer.ImportTypeSignature<Type>(), arrayElementType),
			(builder.Importer.Int32, length));
		return field;
	}

	private static string GetNestedTypeName(string fieldName) => $"<{fieldName}>e__FixedBuffer";

	private static TypeDefinition MakeNestedType(TypeDefinition parentType, AssemblyBuilder builder, CorLibTypeSignature arrayElementType, string fieldName, uint size)
	{
		TypeDefinition nestedType = StructCreator.CreateEmptyStruct(builder, parentType, GetNestedTypeName(fieldName));
		nestedType.ClassLayout = new ClassLayout(0, size);
		nestedType.AddField("FixedElementField", arrayElementType);
		nestedType.AddCustomAttribute(builder.Importer.ImportDefaultConstructor<CompilerGeneratedAttribute>());
		nestedType.AddCustomAttribute(builder.Importer.ImportDefaultConstructor<UnsafeValueTypeAttribute>());
		return nestedType;
	}

	private static IMethodDefOrRef ImportDefaultConstructor<T>(this CachedReferenceImporter importer)
	{
		return importer.ImportMethod<T>(m => m.IsConstructor && !m.IsStatic && m.Parameters.Count == 0);
	}

	private static int GetSize(CorLibTypeSignature type)
	{
		return type.ElementType switch
		{
			ElementType.U1 => 1,
			ElementType.U2 => 2,
			ElementType.U4 => 4,
			ElementType.U8 => 8,
			ElementType.I1 => 1,
			ElementType.I2 => 2,
			ElementType.I4 => 4,
			ElementType.I8 => 8,
			ElementType.R4 => 4,
			ElementType.R8 => 8,
			ElementType.Boolean => 1,
			ElementType.Char => 2,
			_ => throw new ArgumentOutOfRangeException(nameof(type)),
		};
	}
}

```

`Source/AssetRipper.AssemblyDumper/GeneratedInterfaceUtils.cs`:

```cs
using AssetRipper.Assets;
using System.Reflection;
using MethodAttributes = System.Reflection.MethodAttributes;

namespace AssetRipper.AssemblyDumper;

internal static class GeneratedInterfaceUtils
{
	private static HashSet<string> BlackListedPropertyNamesForSubclassGroup { get; }
		= GetPublicOrProtectedPropertyNames(typeof(UnityAssetBase)).Append(nameof(INamed.Name)).ToHashSet();

	private static HashSet<string> BlackListedPropertyNamesForClassGroup { get; }
		= GetPublicOrProtectedPropertyNames(typeof(UnityObjectBase)).Union(BlackListedPropertyNamesForSubclassGroup).ToHashSet();

	public static string GetPropertyNameFromFieldName(string fieldName, ClassGroupBase group)
	{
		if (IsBlackListed(fieldName, group))
		{
			throw new Exception($"Field uses a blacklisted name");
		}

		string result = fieldName;
		if (result.StartsWith("m_", StringComparison.Ordinal))
		{
			result = result.Substring(2);
		}

		if (result.StartsWith('_'))
		{
			result = $"P{result}";
		}
		else if (char.IsDigit(result[0]))
		{
			result = $"P_{result}";
		}
		else if (char.IsLower(result[0]))
		{
			result = $"{char.ToUpperInvariant(result[0])}{result.Substring(1)}";
		}

		if (!group.IsSealed)
		{
			result = $"{result}_C{group.ID}";
		}

		if (IsBlackListed(result, group))
		{
			result = $"{result}_R";
		}
		else if (result == fieldName)
		{
			result = $"P_{result}";
		}

		return result;
	}

	public static string GetHasMethodName(string propertyNameWithTypeSuffix)
	{
		return $"Has_{propertyNameWithTypeSuffix}";
	}

	public static string GetReleaseOnlyMethodName(string propertyNameWithTypeSuffix)
	{
		return $"IsReleaseOnly_{propertyNameWithTypeSuffix}";
	}

	public static string GetEditorOnlyMethodName(string propertyNameWithTypeSuffix)
	{
		return $"IsEditorOnly_{propertyNameWithTypeSuffix}";
	}

	public static void FillWithSimpleBooleanReturn(this CilInstructionCollection instructions, bool returnTrue)
	{
		if (returnTrue)
		{
			instructions.Add(CilOpCodes.Ldc_I4_1);
		}
		else
		{
			instructions.Add(CilOpCodes.Ldc_I4_0);
		}

		instructions.Add(CilOpCodes.Ret);
	}

	private static bool IsBlackListed(string name, ClassGroupBase group)
	{
		return (group is SubclassGroup
			? BlackListedPropertyNamesForSubclassGroup.Contains(name)
			: BlackListedPropertyNamesForClassGroup.Contains(name))
			|| name == group.Interface.Name
			|| group.Types.Any(t => t.Name == name);
	}

	private static IEnumerable<string> GetPublicOrProtectedPropertyNames(Type type)
	{
		foreach (PropertyInfo property in type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
		{
			if (property.GetIndexParameters().Length == 0 && IsPublicOrProtected(property))
			{
				yield return property.Name;
			}
		}

		static bool IsPublicOrProtected(PropertyInfo property)
		{
			foreach (MethodInfo accessor in property.GetAccessors())
			{
				if (IsPublicOrProtected(accessor))
				{
					return true;
				}
			}
			return false;

			static bool IsPublicOrProtected(MethodInfo method)
			{
				return (method.Attributes & MethodAttributes.MemberAccessMask) is MethodAttributes.Public or MethodAttributes.Family or MethodAttributes.FamORAssem;
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/GenericTypeResolver.cs`:

```cs
using AssetRipper.Assets.Generics;

namespace AssetRipper.AssemblyDumper;

internal static class GenericTypeResolver
{
	public static GenericInstanceTypeSignature ResolveDictionaryType(UniversalNode node, UnityVersion version)
	{
		UniversalNode pairNode = node.SubNodes![0] //Array
			.SubNodes![1]; //Pair

		GenericInstanceTypeSignature genericKvp = ResolvePairType(pairNode, version);

		return SharedState.Instance.Importer.ImportType(typeof(AssetDictionary<,>)).MakeGenericInstanceType(genericKvp.TypeArguments[0], genericKvp.TypeArguments[1]);
	}

	public static TypeSignature ResolveVectorType(UniversalNode vectorNode, UnityVersion version)
	{
		return ResolveArrayType(vectorNode.SubNodes![0], version);
	}

	public static TypeSignature ResolveArrayType(UniversalNode arrayNode, UnityVersion version)
	{
		UniversalNode contentNode = arrayNode.SubNodes![1];
		TypeSignature elementType = ResolveNode(contentNode, version);

		if (elementType is CorLibTypeSignature { ElementType: ElementType.U1 })
		{
			return elementType.MakeSzArrayType();
		}
		else if (elementType is SzArrayTypeSignature)
		{
			throw new NotSupportedException();
		}

		return SharedState.Instance.Importer.ImportType(typeof(AssetList<>)).MakeGenericInstanceType(elementType);
	}

	public static SzArrayTypeSignature MakeAndImportArrayType(this ITypeDefOrRef type)
	{
		return MakeAndImportArrayType(type.ToTypeSignature());
	}

	public static SzArrayTypeSignature MakeAndImportArrayType(this TypeSignature typeSignature)
	{
		return new SzArrayTypeSignature(SharedState.Instance.Importer.UnderlyingImporter.ImportTypeSignature(typeSignature));
	}

	public static GenericInstanceTypeSignature ResolvePairType(UniversalNode pairNode, UnityVersion version)
	{
		return ResolvePairType(pairNode.SubNodes![0], pairNode.SubNodes[1], version);
	}
	public static GenericInstanceTypeSignature ResolvePairType(UniversalNode first, UniversalNode second, UnityVersion version)
	{
		TypeSignature firstType = ResolveNode(first, version);
		TypeSignature secondType = ResolveNode(second, version);

		if (firstType is SzArrayTypeSignature || secondType is SzArrayTypeSignature)
		{
			throw new Exception("Arrays not supported in pairs/dictionaries");
		}

		//Construct a KeyValuePair
		ITypeDefOrRef kvpType = SharedState.Instance.Importer.ImportType(typeof(AssetPair<,>));
		GenericInstanceTypeSignature genericKvp = kvpType.MakeGenericInstanceType(firstType, secondType);
		return genericKvp;
	}

	public static TypeSignature ResolveNode(UniversalNode node, UnityVersion version)
	{
		return node.NodeType switch
		{
			NodeType.Pair => ResolvePairType(node, version),
			NodeType.Map => ResolveDictionaryType(node, version),
			NodeType.Vector => ResolveVectorType(node, version),
			NodeType.TypelessData => SharedState.Instance.Importer.UInt8.MakeSzArrayType(),
			NodeType.Array => ResolveArrayType(node, version),
			NodeType.Type => SharedState.Instance.SubclassGroups[node.TypeName].GetTypeForVersion(version).ToTypeSignature(),
			_ => node.NodeType.ToPrimitiveTypeSignature(),
		};
	}
}

```

`Source/AssetRipper.AssemblyDumper/Groups/ClassGroup.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Groups;

internal sealed class ClassGroup : ClassGroupBase
{
	public override int ID { get; }

	public override bool IsSealed => Instances.All(instance => instance.Type.IsSealed);

	public override string Name => Instances[Instances.Count - 1].Name;

	public override string Namespace => SharedState.GetClassNamespace(ID);

	public IEnumerable<string> Names => Instances.Select(instance => instance.Name).Distinct();

	public ClassGroup(int id, TypeDefinition @interface) : base(@interface)
	{
		ID = id;
	}

	public override bool UniformlyNamed => Instances.All(instance => instance.Name == Instances[0].Name);
}

```

`Source/AssetRipper.AssemblyDumper/Groups/ClassGroupBase.cs`:

```cs
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.DocExtraction.DataStructures;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Groups;

internal abstract class ClassGroupBase
{
	private TypeDefinition? mainClass;
	public List<GeneratedClassInstance> Instances { get; } = new();
	public TypeDefinition Interface { get; }
	public List<InterfaceProperty> InterfaceProperties { get; } = new();
	public ComplexTypeHistory? History { get; set; }

	public abstract string Name { get; }
	public abstract string Namespace { get; }
	public abstract int ID { get; }
	public abstract bool IsSealed { get; }
	public abstract bool UniformlyNamed { get; }
	public virtual bool IsPPtr => false;
	public virtual bool IsString => false;
	public UnityVersion MinimumVersion => Instances[0].VersionRange.Start;
	public IEnumerable<UniversalClass> Classes => Instances.Select(x => x.Class);
	public IEnumerable<TypeDefinition> Types => Instances.Select(x => x.Type);

	protected ClassGroupBase(TypeDefinition @interface)
	{
		Interface = @interface ?? throw new ArgumentNullException(nameof(@interface));
	}

	public TypeDefinition GetOrCreateMainClass()
	{
		mainClass ??= Instances.Count == 1 ? Instances[0].Type : StaticClassCreator.CreateEmptyStaticClass(Interface.DeclaringModule!, Namespace, Name);
		return mainClass;
	}

	public UniversalClass GetClassForVersion(UnityVersion version)
	{
		return GetInstanceForVersion(version).Class;
	}

	public TypeDefinition GetTypeForVersion(UnityVersion version)
	{
		return GetInstanceForVersion(version).Type;
	}

	public GeneratedClassInstance GetInstanceForVersion(UnityVersion version)
	{
		Debug.Assert(Instances.Count != 0, "No classes available");
		foreach (GeneratedClassInstance instance in Instances)
		{
			if (instance.VersionRange.Contains(version))
			{
				return instance;
			}
		}
		throw new Exception($"No instance found for {version}");
	}

	public TypeDefinition GetSingularTypeOrInterface()
	{
		return Instances.Count == 1
			? Instances[0].Type
			: Interface;
	}

	public override string ToString() => Name;

	public void GetSerializedVersions(out int minimum, out int maximum)
	{
		minimum = 1;
		maximum = 1;
		foreach (GeneratedClassInstance instance in Instances)
		{
			int instanceVersion = instance.GetSerializedVersion();
			if (instanceVersion < minimum)
			{
				minimum = instanceVersion;
			}
			else if (instanceVersion > maximum)
			{
				maximum = instanceVersion;
			}
		}
	}

	public void InitializeHistory(HistoryFile historyFile)
	{
		History = null;

		foreach (GeneratedClassInstance instance in Instances)
		{
			instance.InitializeHistory(historyFile);
		}

		ComplexTypeHistory? firstHistory = Instances[0].History;
		if (firstHistory is not null)
		{
			for (int i = 1; i < Instances.Count; i++)
			{
				ComplexTypeHistory? subsequentHistory = Instances[i].History;
				if (firstHistory != subsequentHistory)
				{
					return;
				}
			}
			History = firstHistory;
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Groups/GeneratedClassInstance.cs`:

```cs
using AssetRipper.DocExtraction.DataStructures;
using AssetRipper.Numerics;

namespace AssetRipper.AssemblyDumper.Groups;

internal sealed class GeneratedClassInstance
{
	public string Name => Class.Name;
	public UniversalClass Class { get; }
	public TypeDefinition Type { get; set; }
	public Range<UnityVersion> VersionRange { get; set; }
	public GeneratedClassInstance? Base { get; set; }
	public List<GeneratedClassInstance> Derived { get; } = new();
	public ComplexTypeHistory? History { get; set; }
	public List<ClassProperty> Properties { get; } = new();
	public ClassGroupBase Group { get; }

	public GeneratedClassInstance(ClassGroupBase group, UniversalClass @class, TypeDefinition type, UnityVersion startVersion, UnityVersion endVersion)
	{
		Class = @class;
		Type = type;
		VersionRange = new Range<UnityVersion>(startVersion, endVersion);
		Group = group;
	}

	public override string ToString() => $"{Name} {VersionRange.Start} : {VersionRange.End}";

	public int GetSerializedVersion()
	{
		return Class.EditorRootNode is not null
			? Class.EditorRootNode.Version
			: Class.ReleaseRootNode is not null
				? Class.ReleaseRootNode.Version
				: 1;
	}

	public bool InheritsFromType(int id)
	{
		return Class.OriginalTypeID == id || (Base?.InheritsFromType(id) ?? false);
	}

	public bool InheritsFromAssetImporter() => InheritsFromType(1003);//The id for AssetImporter

	public void InitializeHistory(HistoryFile historyFile)
	{
		if (Group is SubclassGroup)
		{
			TryGetSubclass(Name, VersionRange.Start, historyFile, out ComplexTypeHistory? history);
			History = history;
		}
		else
		{
			TryGetClass(Name, VersionRange.Start, historyFile, out ClassHistory? classHistory);
			History = classHistory;
		}
	}

	private static bool TryGetClass(string name, UnityVersion version, HistoryFile historyFile, [NotNullWhen(true)] out ClassHistory? history)
	{
		if (TryGetClassFullName($"UnityEngine.{name}", version, historyFile, out history) && history.InheritsFromUnityEngineObject(version, historyFile))
		{
			return true;
		}
		else if (TryGetClassFullName($"UnityEditor.{name}", version, historyFile, out history) && history.InheritsFromUnityEngineObject(version, historyFile))
		{
			return true;
		}
		else
		{
			foreach ((_, ClassHistory classHistory) in historyFile.Classes)
			{
				if (MatchesNameAndExists(classHistory, name, version) && classHistory.InheritsFromUnityEngineObject(version, historyFile))
				{
					history = classHistory;
					return true;
				}
			}
			history = null;
			return false;
		}
	}

	private static bool TryGetSubclass(string name, UnityVersion version, HistoryFile historyFile, [NotNullWhen(true)] out ComplexTypeHistory? history)
	{
		if (TryGetClassFullName($"UnityEngine.{name}", version, historyFile, out ClassHistory? @class) && !@class.InheritsFromUnityEngineObject(version, historyFile))
		{
			history = @class;
			return true;
		}
		else if (TryGetClassFullName($"UnityEditor.{name}", version, historyFile, out @class) && !@class.InheritsFromUnityEngineObject(version, historyFile))
		{
			history = @class;
			return true;
		}
		if (TryGetStructFullName($"UnityEngine.{name}", version, historyFile, out StructHistory? @struct))
		{
			history = @struct;
			return true;
		}
		else if (TryGetStructFullName($"UnityEditor.{name}", version, historyFile, out @struct))
		{
			history = @struct;
			return true;
		}
		else
		{
			foreach ((_, ClassHistory classHistory) in historyFile.Classes)
			{
				if (MatchesNameAndExists(classHistory, name, version) && !classHistory.InheritsFromUnityEngineObject(version, historyFile))
				{
					history = classHistory;
					return true;
				}
			}
			foreach ((_, StructHistory structHistory) in historyFile.Structs)
			{
				if (MatchesNameAndExists(structHistory, name, version))
				{
					history = structHistory;
					return true;
				}
			}
			history = null;
			return false;
		}
	}

	private static bool MatchesNameAndExists(HistoryBase history, string name, UnityVersion version)
	{
		return (history.Name == name || history.NativeName.GetItemForVersion(version) == name)
			&& history.ExistsOnVersion(version);
	}

	private static bool TryGetClassFullName(string fullName, UnityVersion version, HistoryFile historyFile, [NotNullWhen(true)] out ClassHistory? history)
	{
		if (historyFile.Classes.TryGetValue(fullName, out ClassHistory? potentialHistory) && potentialHistory.ExistsOnVersion(version))
		{
			history = potentialHistory;
			return true;
		}
		else
		{
			history = null;
			return false;
		}
	}

	private static bool TryGetStructFullName(string fullName, UnityVersion version, HistoryFile historyFile, [NotNullWhen(true)] out StructHistory? history)
	{
		if (historyFile.Structs.TryGetValue(fullName, out StructHistory? potentialHistory) && potentialHistory.ExistsOnVersion(version))
		{
			history = potentialHistory;
			return true;
		}
		else
		{
			history = null;
			return false;
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Groups/SubclassGroup.cs`:

```cs
using AssetRipper.AssemblyDumper.Passes;

namespace AssetRipper.AssemblyDumper.Groups;

internal sealed class SubclassGroup : ClassGroupBase
{
	public override string Name { get; }

	public override int ID => -1;

	public override bool IsSealed => true;

	public override string Namespace => SharedState.GetSubclassNamespace(Name);

	public override bool UniformlyNamed => true;

	public override bool IsPPtr => Name.StartsWith("PPtr_", StringComparison.Ordinal);

	public override bool IsString => Name == Pass002_RenameSubnodes.Utf8StringName;

	public SubclassGroup(string name, TypeDefinition @interface) : base(@interface)
	{
		Name = name;
	}
}

```

`Source/AssetRipper.AssemblyDumper/InjectedClassProperty.cs`:

```cs
namespace AssetRipper.AssemblyDumper;

internal class InjectedClassProperty : ClassProperty
{
	public InjectedClassProperty(PropertyDefinition definition, FieldDefinition? backingField, InterfaceProperty @base, GeneratedClassInstance @class) : base(definition, backingField, @base, @class)
	{
	}

	public override bool IsInjected => true;
}

```

`Source/AssetRipper.AssemblyDumper/InjectedInterfaceProperty.cs`:

```cs
namespace AssetRipper.AssemblyDumper;

internal class InjectedInterfaceProperty : InterfaceProperty
{
	public InjectedInterfaceProperty(PropertyDefinition definition, ClassGroupBase group) : base(definition, group)
	{
	}

	public override bool IsInjected => true;
}

```

`Source/AssetRipper.AssemblyDumper/InjectedTypes/AudioClipHelper.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.ResourceFiles;

#nullable disable

namespace AssetRipper.AssemblyDumper.InjectedTypes;

internal static class AudioClipHelper
{
	internal static byte[] ReadOldByteArray(this UnityObjectBase audioClip, ref EndianSpanReader reader, int m_Stream)
	{
		return m_Stream == 2 //AudioClipLoadType.Streaming
			? ReadStreamedByteArray(audioClip, ref reader)
			: ReadAlignedByteArray(ref reader);
	}

	private static byte[] ReadAlignedByteArray(ref EndianSpanReader reader)
	{
		int count = reader.ReadInt32();
		byte[] result = reader.ReadBytesExact(count).ToArray();
		reader.Align();
		return result;
	}

	private static byte[] ReadStreamedByteArray(UnityObjectBase audioClip, ref EndianSpanReader reader)
	{
		uint size = reader.ReadUInt32();
		uint offset = reader.ReadUInt32();
		string resourceFileName = audioClip.Collection.Name + ".resS";
		if (TryFindResourceFile(audioClip, resourceFileName, out ResourceFile resourceFile))
		{
			byte[] result = new byte[size];
			resourceFile.Stream.Position = offset;
			resourceFile.Stream.ReadExactly(result);
			return result;
		}
		else
		{
			return Array.Empty<byte>();
		}
	}

	private static bool TryFindResourceFile(UnityObjectBase audioClip, string resourceFileName, out ResourceFile resourceFile)
	{
		resourceFile = audioClip.Collection.Bundle.ResolveResource(resourceFileName);
		return resourceFile is not null;
	}
}

#nullable enable
```

`Source/AssetRipper.AssemblyDumper/InjectedTypes/CopyValuesHelper.cs`:

```cs
#nullable disable

using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.AssemblyDumper.InjectedTypes;

internal static class CopyValuesHelper
{
	public static T[] DuplicateArray<T>(T[] array)
	{
		if (array is null || array.Length == 0)
		{
			return Array.Empty<T>();
		}
		else
		{
			T[] copy = new T[array.Length];
			Array.Copy(array, copy, array.Length);
			return copy;
		}
	}
	public static T[][] DuplicateArrayArray<T>(T[][] array)
	{
		if (array is null || array.Length == 0)
		{
			return Array.Empty<T[]>();
		}
		else
		{
			T[][] copy = new T[array.Length][];
			for (int i = 0; i < array.Length; i++)
			{
				copy[i] = DuplicateArray(array[i]);
			}
			return copy;
		}
	}
	public static PPtr ConvertPPtr<T>(IPPtr sourcePPtr, PPtrConverter converter) where T : IUnityObjectBase
	{
		PPtr pptr = new(sourcePPtr.FileID, sourcePPtr.PathID);
		if (converter.SourceCollection != converter.TargetCollection || converter.Resolver.GetType() != typeof(DefaultAssetResolver))
		{
			return converter.Convert<T>(pptr);
		}
		else
		{
			return pptr;
		}
	}
	public static void CopyCapacityFrom_Dictionary<TTargetKey, TTargetValue, TSourceKey, TSourceValue>(AssetDictionary<TTargetKey, TTargetValue> target, AccessDictionaryBase<TSourceKey, TSourceValue> source)
		where TTargetKey : notnull, new()
		where TTargetValue : notnull, new()
		where TSourceKey : notnull
		where TSourceValue : notnull
	{
		if (source is null or { Count: 0 })
		{
			target.Clear();
		}
		else if (target.Count < source.Count)
		{
			for (int i = target.Count; i < source.Count; i++)
			{
				target.AddNew();
			}
		}
		else if (target.Count > source.Count)
		{
			for (int i = target.Count - 1; i >= source.Count; i--)
			{
				target.RemoveAt(i);
			}
		}
		target.Capacity = target.Count;
	}
	public static void CopyCapacityFrom_List<TTarget, TSource>(AssetList<TTarget> target, AccessListBase<TSource> source)
		where TTarget : notnull, new()
		where TSource : notnull
	{
		if (source is null or { Count: 0 })
		{
			target.Clear();
		}
		else if (target.Count < source.Count)
		{
			for (int i = target.Count; i < source.Count; i++)
			{
				target.AddNew();
			}
		}
		else if (target.Count > source.Count)
		{
			for (int i = target.Count - 1; i >= source.Count; i--)
			{
				target.RemoveAt(i);
			}
		}
		target.Capacity = target.Count;
	}
}

#nullable enable

```

`Source/AssetRipper.AssemblyDumper/InjectedTypes/EqualityComparisonHelper.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;
using System.Runtime.CompilerServices;

#nullable disable

namespace AssetRipper.AssemblyDumper.InjectedTypes;

internal static class EqualityComparisonHelper
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool? GetNull() => null;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool? GetTrue() => true;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool? GetFalse() => false;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsNull(this bool? value) => value == null;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsNotNull(this bool? value) => value != null;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsTrue(this bool? value) => value == true;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsFalse(this bool? value) => value == false;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool? ToTrilean(this bool value) => value;

	public static bool ByteArrayEquals(byte[] x, byte[] y)
	{
		return x.AsSpan().SequenceEqual(y);
	}

	// eg string, int, bool, Vector3f
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool EquatableEquals<T>(T x, T y) where T : IEquatable<T>
	{
		return x.Equals(y);
	}

	// eg AssetList<float>, AssetList<Utf8String>, or AssetList<Vector3f>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool EquatableListEquals<T>(AssetList<T> x, AssetList<T> y) where T : IEquatable<T>, new()
	{
		return RuntimeHelpers.IsReferenceOrContainsReferences<T>()
			? x.SequenceEqual(y)
			: x.GetSpan().SequenceEqual(y.GetSpan());
	}

	public static bool EquatableListListEquals<T>(AssetList<AssetList<T>> x, AssetList<AssetList<T>> y) where T : IEquatable<T>, new()
	{
		if (x.Count != y.Count)
		{
			return false;
		}

		for (int i = 0; i < x.Count; i++)
		{
			if (!EquatableListEquals(x[i], y[i]))
			{
				return false;
			}
		}
		return true;
	}

	public static bool EquatablePairEquals<TKey, TValue>(AssetPair<TKey, TValue> x, AssetPair<TKey, TValue> y) where TKey : IEquatable<TKey>, new() where TValue : IEquatable<TValue>, new()
	{
		return x.Key.Equals(y.Key) && x.Value.Equals(y.Value);
	}

	public static bool EquatableDictionaryEquals<TKey, TValue>(AssetDictionary<TKey, TValue> x, AssetDictionary<TKey, TValue> y) where TKey : IEquatable<TKey>, new() where TValue : IEquatable<TValue>, new()
	{
		if (x.Count != y.Count)
		{
			return false;
		}

		for (int i = 0; i < x.Count; i++)
		{
			if (!EquatablePairEquals(x.GetPair(i), y.GetPair(i)))
			{
				return false;
			}
		}
		return true;
	}

	public static bool EquatableDictionaryListEquals<TKey, TValueElement>(AssetDictionary<TKey, AssetList<TValueElement>> x, AssetDictionary<TKey, AssetList<TValueElement>> y) where TKey : IEquatable<TKey>, new() where TValueElement : IEquatable<TValueElement>, new()
	{
		if (x.Count != y.Count)
		{
			return false;
		}

		for (int i = 0; i < x.Count; i++)
		{
			if (!x.GetKey(i).Equals(y.GetKey(i)) || !EquatableListEquals(x.GetValue(i), y.GetValue(i)))
			{
				return false;
			}
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool? AssetEquals<T>(T x, T y, AssetEqualityComparer comparer) where T : IUnityAssetBase
	{
		return x.AddToEqualityComparer(y, comparer);
	}

	// eg AssetList<ChildAnimatorState>
	public static bool? AssetListEquals<T>(AssetList<T> x, AssetList<T> y, AssetEqualityComparer comparer) where T : new()
	{
		if (x.Count != y.Count)
		{
			return false;
		}

		bool? result = true;
		for (int i = 0; i < x.Count; i++)
		{
			switch (GenericAssetEquals(x[i], y[i], comparer))
			{
				case false:
					return false;
				case null:
					result = null;
					break;
			}
		}
		return result;
	}

	public static bool? AssetPairEquals<TKey, TValue>(AssetPair<TKey, TValue> x, AssetPair<TKey, TValue> y, AssetEqualityComparer comparer)
		where TKey : new()
		where TValue : new()
	{
		bool? keyResult = GenericAssetEquals(x.Key, y.Key, comparer);
		if (keyResult == false)
		{
			return false;
		}
		bool? valueResult = GenericAssetEquals(x.Value, y.Value, comparer);
		if (valueResult == false)
		{
			return false;
		}

		if (keyResult == null || valueResult == null)
		{
			return null;
		}
		return true;
	}

	public static bool? AssetDictionaryEquals<TKey, TValue>(AssetDictionary<TKey, TValue> x, AssetDictionary<TKey, TValue> y, AssetEqualityComparer comparer)
		where TKey : new()
		where TValue : new()
	{
		if (x.Count != y.Count)
		{
			return false;
		}

		bool? result = true;
		for (int i = 0; i < x.Count; i++)
		{
			switch (AssetPairEquals(x.GetPair(i), y.GetPair(i), comparer))
			{
				case false:
					return false;
				case null:
					result = null;
					break;
			}
		}
		return result;
	}

	public static bool? AssetPairListEquals<TKey, TValue>(AssetList<AssetPair<TKey, TValue>> x, AssetList<AssetPair<TKey, TValue>> y, AssetEqualityComparer comparer)
		where TKey : new()
		where TValue : new()
	{
		if (x.Count != y.Count)
		{
			return false;
		}

		bool? result = true;
		for (int i = 0; i < x.Count; i++)
		{
			switch (AssetPairEquals(x[i], y[i], comparer))
			{
				case false:
					return false;
				case null:
					result = null;
					break;
			}
		}
		return result;
	}

	public static bool? AssetDictionaryListEquals<TKey, TValueElement>(AssetDictionary<TKey, AssetList<TValueElement>> x, AssetDictionary<TKey, AssetList<TValueElement>> y, AssetEqualityComparer comparer)
		where TKey : new()
		where TValueElement : new()
	{
		if (x.Count != y.Count)
		{
			return false;
		}

		bool? result = true;
		for (int i = 0; i < x.Count; i++)
		{
			switch (GenericAssetEquals(x.GetKey(i), y.GetKey(i), comparer))
			{
				case false:
					return false;
				case null:
					result = null;
					break;
			}
			switch (AssetListEquals(x.GetValue(i), y.GetValue(i), comparer))
			{
				case false:
					return false;
				case null:
					result = null;
					break;
			}
		}
		return result;
	}

	public static bool? AssetDictionaryPairEquals<TPairKey, TPairValue, TValue>(AssetDictionary<AssetPair<TPairKey, TPairValue>, TValue> x, AssetDictionary<AssetPair<TPairKey, TPairValue>, TValue> y, AssetEqualityComparer comparer)
		where TPairKey : new()
		where TPairValue : new()
		where TValue : new()
	{
		if (x.Count != y.Count)
		{
			return false;
		}

		bool? result = true;
		for (int i = 0; i < x.Count; i++)
		{
			switch (AssetPairEquals(x.GetKey(i), y.GetKey(i), comparer))
			{
				case false:
					return false;
				case null:
					result = null;
					break;
			}
			switch (GenericAssetEquals(x.GetValue(i), y.GetValue(i), comparer))
			{
				case false:
					return false;
				case null:
					result = null;
					break;
			}
		}
		return result;
	}

	private static bool? GenericAssetEquals<T>(T x, T y, AssetEqualityComparer comparer)
	{
		if (typeof(T).IsAssignableTo(typeof(IUnityAssetBase)))
		{
			return ((IUnityAssetBase)x).AddToEqualityComparer((IUnityAssetBase)y, comparer);
		}
		else
		{
			return EqualityComparer<T>.Default.Equals(x, y);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool? MaybeAddDependentComparison(IPPtr x, IPPtr y, AssetEqualityComparer comparer)
	{
		return comparer.MaybeAddDependentComparison(x, y);
	}

	public static bool? MonoBehaviourStructureEquals(IUnityAssetBase x, IUnityAssetBase y, AssetEqualityComparer comparer)
	{
		return (x, y) switch
		{
			(not null, not null) => x.AddToEqualityComparer(y, comparer),
			(null, null) => true,
			_ => false,
		};
	}
}

#nullable enable
```

`Source/AssetRipper.AssemblyDumper/InjectedTypes/FetchDependenciesEnumerableBase.cs`:

```cs
#nullable disable

using AssetRipper.Assets.Metadata;
using System.Collections;

namespace AssetRipper.AssemblyDumper.InjectedTypes;

internal abstract class FetchDependenciesEnumerableBase : IEnumerable<(string, PPtr)>, IEnumerator<(string, PPtr)>
{
	private bool _hasBeenUsed;

	protected (string, PPtr) _current;

	private readonly int _initialThreadId;

	protected FetchDependenciesEnumerableBase()
	{
		_initialThreadId = Environment.CurrentManagedThreadId;
	}

	public (string, PPtr) Current => _current;

	object IEnumerator.Current => Current;

	void IDisposable.Dispose()
	{
	}

	public IEnumerator<(string, PPtr)> GetEnumerator()
	{
		FetchDependenciesEnumerableBase result;
		if (!_hasBeenUsed && _initialThreadId == Environment.CurrentManagedThreadId)
		{
			result = this;
		}
		else
		{
			result = CreateNew();
		}
		_hasBeenUsed = true;
		return result;
	}

	IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

	public abstract bool MoveNext();

	void IEnumerator.Reset() => throw new NotSupportedException();

	private protected abstract FetchDependenciesEnumerableBase CreateNew();
}

#nullable enable

```

`Source/AssetRipper.AssemblyDumper/InjectedTypes/HashHelper.cs`:

```cs
#nullable disable

namespace AssetRipper.AssemblyDumper.InjectedTypes;

internal static class HashHelper
{
	public static string ToString(byte bytes__0, byte bytes__1, byte bytes__2, byte bytes__3, byte bytes__4, byte bytes__5, byte bytes__6, byte bytes__7, byte bytes__8, byte bytes__9, byte bytes_10, byte bytes_11, byte bytes_12, byte bytes_13, byte bytes_14, byte bytes_15)
	{
		//Not sure if this depends on Endianess
		//If it does, it might be best to split Hash at Unity 5
		uint Data0 = bytes__0 | (uint)bytes__1 << 8 | (uint)bytes__2 << 16 | (uint)bytes__3 << 24;
		uint Data1 = bytes__4 | (uint)bytes__5 << 8 | (uint)bytes__6 << 16 | (uint)bytes__7 << 24;
		uint Data2 = bytes__8 | (uint)bytes__9 << 8 | (uint)bytes_10 << 16 | (uint)bytes_11 << 24;
		uint Data3 = bytes_12 | (uint)bytes_13 << 8 | (uint)bytes_14 << 16 | (uint)bytes_15 << 24;
		string str = $"{Data0:x8}{Data1:x8}{Data2:x8}{Data3:x8}";
		return str;
	}
}

```

`Source/AssetRipper.AssemblyDumper/InjectedTypes/MonoBehaviourHelper.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;

#nullable disable

namespace AssetRipper.AssemblyDumper.InjectedTypes;

internal static class MonoBehaviourHelper
{
	private const string FieldName = "m_Structure";

	public static void MaybeWalkStructureEditor(IUnityObjectBase asset, IUnityAssetBase structure, AssetWalker walker)
	{
		if (structure != null)
		{
			walker.DivideAsset(asset);
			if (walker.EnterField(asset, FieldName))
			{
				structure.WalkEditor(walker);
				walker.ExitField(asset, FieldName);
			}
		}
	}

	public static void MaybeWalkStructureRelease(IUnityObjectBase asset, IUnityAssetBase structure, AssetWalker walker)
	{
		if (structure != null)
		{
			walker.DivideAsset(asset);
			if (walker.EnterField(asset, FieldName))
			{
				structure.WalkRelease(walker);
				walker.ExitField(asset, FieldName);
			}
		}
	}

	public static void MaybeWalkStructureStandard(IUnityObjectBase asset, IUnityAssetBase structure, AssetWalker walker)
	{
		if (structure != null)
		{
			walker.DivideAsset(asset);
			if (walker.EnterField(asset, FieldName))
			{
				structure.WalkStandard(walker);
				walker.ExitField(asset, FieldName);
			}
		}
	}

	public static IEnumerable<(string, PPtr)> MaybeAppendStructureDependencies(IEnumerable<(string, PPtr)> dependencies, IUnityAssetBase structure)
	{
		return structure == null ? dependencies : dependencies.Concat(structure.FetchDependencies());
	}

	public static void ResetStructure(IUnityAssetBase structure)
	{
		structure?.Reset();
	}

	public static void CopyStructureValues(ref IUnityAssetBase structure, IUnityAssetBase source, PPtrConverter converter)
	{
		if (structure != null)
		{
			structure.CopyValues(source, converter);
		}
		else if (source is null)
		{
			// Both are null, so everything is fine.
		}
		else if (source is IDeepCloneable cloneable)
		{
			structure = cloneable.DeepClone(converter);
		}
		else
		{
			throw new NotSupportedException("Structure is not cloneable");
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/InjectedTypes/PPtrHelper.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;

#nullable disable

namespace AssetRipper.AssemblyDumper.InjectedTypes;

internal static class PPtrHelper
{
	public static PPtr ForceCreatePPtr(AssetCollection collection, IUnityObjectBase asset)
	{
		return collection.ForceCreatePPtr(asset);
	}
	public static bool TryGetAsset<T>(AssetCollection collection, int fileID, long pathID, [NotNullWhen(true)] out T asset) where T : IUnityObjectBase
	{
		return collection.TryGetAsset(fileID, pathID, out asset);
	}
}

#nullable enable
```

`Source/AssetRipper.AssemblyDumper/InjectedTypes/TypelessDataHelper.cs`:

```cs
using AssetRipper.IO.Endian;

#nullable disable

namespace AssetRipper.AssemblyDumper.InjectedTypes;

internal static class TypelessDataHelper
{
	public static byte[] ReadByteArray(ref EndianSpanReader reader, int count)
	{
		return reader.ReadBytesExact(count).ToArray();
	}
}

```

`Source/AssetRipper.AssemblyDumper/InjectedTypes/WalkingHelper.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Traversal;

#nullable disable

namespace AssetRipper.AssemblyDumper.InjectedTypes;

internal static class WalkingHelper
{
	public static void WalkComponentPairRelease<T>(int classID, T component, AssetWalker walker) where T : IUnityAssetBase
	{
		KeyValuePair<int, T> pair = new KeyValuePair<int, T>(classID, component);
		if (walker.EnterPair(pair))
		{
			walker.VisitPrimitive(pair.Key);
			walker.DividePair(pair);
			component.WalkRelease(walker);
			walker.ExitPair(pair);
		}
	}

	public static void WalkComponentPairEditor<T>(int classID, T component, AssetWalker walker) where T : IUnityAssetBase
	{
		KeyValuePair<int, T> pair = new KeyValuePair<int, T>(classID, component);
		if (walker.EnterPair(pair))
		{
			walker.VisitPrimitive(pair.Key);
			walker.DividePair(pair);
			component.WalkEditor(walker);
			walker.ExitPair(pair);
		}
	}

	public static void WalkComponentPairStandard<T>(int classID, T component, AssetWalker walker) where T : IUnityAssetBase
	{
		KeyValuePair<int, T> pair = new KeyValuePair<int, T>(classID, component);
		if (walker.EnterPair(pair))
		{
			walker.VisitPrimitive(pair.Key);
			walker.DividePair(pair);
			component.WalkStandard(walker);
			walker.ExitPair(pair);
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/InterfaceProperty.cs`:

```cs
using AssetRipper.Numerics;

namespace AssetRipper.AssemblyDumper;

internal class InterfaceProperty : PropertyBase
{
	private readonly List<ClassProperty> implementations = new();
	private DiscontinuousRange<UnityVersion>? presentRange;
	private DiscontinuousRange<UnityVersion>? absentRange;
	private DiscontinuousRange<UnityVersion>? releaseOnlyRange;
	private DiscontinuousRange<UnityVersion>? editorOnlyRange;
	private DiscontinuousRange<UnityVersion>? notReleaseOnlyRange;
	private DiscontinuousRange<UnityVersion>? notEditorOnlyRange;

	public InterfaceProperty(PropertyDefinition definition, ClassGroupBase group) : base(definition)
	{
		Group = group;
	}

	public DiscontinuousRange<UnityVersion> PresentRange
	{
		get
		{
			presentRange ??= CalculateRange(p => p.IsPresent);
			return presentRange.Value;
		}
	}

	public DiscontinuousRange<UnityVersion> AbsentRange
	{
		get
		{
			absentRange ??= CalculateRange(p => p.IsAbsent);
			return absentRange.Value;
		}
	}

	public IReadOnlyList<ClassProperty> Implementations => implementations;

	public ClassGroupBase Group { get; }

	public DiscontinuousRange<UnityVersion> ReleaseOnlyRange
	{
		get
		{
			releaseOnlyRange ??= CalculateRange(p => p.IsReleaseOnly);
			return releaseOnlyRange.Value;
		}
	}

	public DiscontinuousRange<UnityVersion> EditorOnlyRange
	{
		get
		{
			editorOnlyRange ??= CalculateRange(p => p.IsEditorOnly);
			return editorOnlyRange.Value;
		}
	}

	public DiscontinuousRange<UnityVersion> NotReleaseOnlyRange
	{
		get
		{
			notReleaseOnlyRange ??= CalculateRange(p => !p.IsReleaseOnly);
			return notReleaseOnlyRange.Value;
		}
	}

	public DiscontinuousRange<UnityVersion> NotEditorOnlyRange
	{
		get
		{
			notEditorOnlyRange ??= CalculateRange(p => !p.IsEditorOnly);
			return notEditorOnlyRange.Value;
		}
	}

	internal void AddImplementation(ClassProperty implementation)
	{
		implementations.Add(implementation);
		presentRange = null;
		absentRange = null;
		releaseOnlyRange = null;
		editorOnlyRange = null;
		notReleaseOnlyRange = null;
		notEditorOnlyRange = null;
	}

	private DiscontinuousRange<UnityVersion> CalculateRange(Func<ClassProperty, bool> predicate)
	{
		return new DiscontinuousRange<UnityVersion>(implementations.Where(predicate).Select(static p => p.Class.VersionRange));
	}
}

```

`Source/AssetRipper.AssemblyDumper/Methods/ConstructorUtils.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Methods;

public static class ConstructorUtils
{
	/// <summary>
	/// Imports the default constructor for a type. Throws an exception if one doesn't exist.
	/// </summary>
	public static IMethodDefOrRef ImportDefaultConstructor<T>(this CachedReferenceImporter importer)
	{
		return importer.ImportConstructor<T>(0);
	}

	/// <summary>
	/// Imports the default constructor for a type. Throws an exception if one doesn't exist.
	/// </summary>
	public static IMethodDefOrRef ImportDefaultConstructor(this CachedReferenceImporter importer, Type type)
	{
		return importer.ImportConstructor(type, 0);
	}

	/// <summary>
	/// Gets the constructor with that number of parameters. Throws an exception if there's not exactly one.
	/// </summary>
	public static MethodDefinition GetConstructor(this TypeDefinition _this, int numParameters)
	{
		return _this.Methods.Single(m => !m.IsStatic && m.IsConstructor && m.Parameters.Count == numParameters);
	}

	/// <summary>
	/// Imports the constructor with that number of parameters. Throws an exception if there's not exactly one.
	/// </summary>
	public static IMethodDefOrRef ImportConstructor<T>(this CachedReferenceImporter importer, int numParameters)
	{
		return importer.ImportMethod<T>(m => !m.IsStatic && m.IsConstructor && m.Parameters.Count == numParameters);
	}

	/// <summary>
	/// Imports the constructor with that number of parameters. Throws an exception if there's not exactly one.
	/// </summary>
	public static IMethodDefOrRef ImportConstructor(this CachedReferenceImporter importer, Type type, int numParameters)
	{
		return importer.ImportMethod(type, m => !m.IsStatic && m.IsConstructor && m.Parameters.Count == numParameters);
	}

	/// <summary>
	/// Imports the constructor with that number of parameters. Throws an exception if there's not exactly one.
	/// </summary>
	public static IMethodDefOrRef ImportConstructor<T>(this CachedReferenceImporter importer, Func<MethodDefinition, bool> func)
	{
		return importer.ImportMethod<T>(m => !m.IsStatic && m.IsConstructor && func.Invoke(m));
	}

	public static MethodDefinition AddEmptyConstructor(this TypeDefinition typeDefinition, bool isStaticConstructor = false)
	{
		return isStaticConstructor
			? typeDefinition.AddMethod(
				".cctor",
				MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RuntimeSpecialName | MethodAttributes.Static,
				typeDefinition.DeclaringModule!.CorLibTypeFactory.Void)
			: typeDefinition.AddMethod(
				".ctor",
				MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RuntimeSpecialName,
				typeDefinition.DeclaringModule!.CorLibTypeFactory.Void);
	}

	/// <summary>
	/// Warning: base class must also have a default constructor
	/// </summary>
	public static MethodDefinition AddDefaultConstructor(this TypeDefinition typeDefinition, CachedReferenceImporter importer)
	{
		MethodDefinition defaultConstructor = typeDefinition.AddEmptyConstructor();
		CilInstructionCollection instructions = defaultConstructor.CilMethodBody!.Instructions;

		IMethodDefOrRef baseConstructor;
		if (typeDefinition.BaseType is null)
		{
			baseConstructor = importer.ImportDefaultConstructor<object>();
		}
		else
		{
			if (typeDefinition.BaseType is TypeDefinition baseType)
			{
				baseConstructor = baseType.GetDefaultConstructor();
			}
			else
			{
				MethodDefinition baseConstructorDefinition = importer.LookupType(typeDefinition.BaseType.FullName)?.GetDefaultConstructor()
					?? throw new Exception($"Could not get default constructor for {typeDefinition.BaseType.FullName}");
				baseConstructor = importer.UnderlyingImporter.ImportMethod(baseConstructorDefinition);
			}
		}

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, baseConstructor);
		instructions.Add(CilOpCodes.Ret);

		instructions.OptimizeMacros();

		return defaultConstructor;
	}
}
```

`Source/AssetRipper.AssemblyDumper/Methods/EqualityMethods.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Methods;

public static class EqualityMethods
{
	public static void AddDefaultEqualityOperators(
		this TypeDefinition type,
		CachedReferenceImporter importer,
		out MethodDefinition equalityMethod,
		out MethodDefinition inequalityMethod)
	{
		equalityMethod = type.AddDefaultEqualityOperator(importer);
		inequalityMethod = type.AddDefaultInequalityOperator(importer, equalityMethod);
	}

	public static void MakeEqualityComparerGenericMethods(
		TypeSignature typeParameter,
		CachedReferenceImporter importer,
		out IMethodDefOrRef defaultReference,
		out IMethodDefOrRef equalsReference)
	{
		GenericInstanceTypeSignature genericSignature = importer.ImportType(typeof(EqualityComparer<>)).MakeGenericInstanceType(typeParameter);
		MethodDefinition defaultDefinition = importer.LookupMethod(typeof(EqualityComparer<>), m => m.Name == $"get_{nameof(EqualityComparer<>.Default)}");
		MethodDefinition equalsDefinition = importer.LookupMethod(typeof(EqualityComparer<>), m => m.Name == nameof(EqualityComparer<>.Equals));
		defaultReference = MethodUtils.MakeMethodOnGenericType(importer, genericSignature, defaultDefinition);
		equalsReference = MethodUtils.MakeMethodOnGenericType(importer, genericSignature, equalsDefinition);
	}

	private static MethodDefinition AddDefaultEqualityOperator(this TypeDefinition type, CachedReferenceImporter importer)
	{
		//Goal:
		//return EqualityComparer<TheClass>.Default.Equals(left, right);

		MethodDefinition method = type.AddMethod(
			"op_Equality",
			MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.Static,
			importer.Boolean);
		method.AddParameter(type.ToTypeSignature(), "left");
		method.AddParameter(type.ToTypeSignature(), "right");

		MakeEqualityComparerGenericMethods(type.ToTypeSignature(), importer, out IMethodDefOrRef defaultReference, out IMethodDefOrRef equalsReference);

		CilInstructionCollection instructions = method.GetInstructions();
		instructions.Add(CilOpCodes.Call, defaultReference);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Callvirt, equalsReference);
		instructions.Add(CilOpCodes.Ret);
		return method;
	}

	private static MethodDefinition AddDefaultInequalityOperator(this TypeDefinition type, CachedReferenceImporter importer, MethodDefinition equalityMethod)
	{
		MethodDefinition method = type.AddMethod(
			"op_Inequality",
			MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.Static,
			importer.Boolean);
		method.AddParameter(type.ToTypeSignature(), "left");
		method.AddParameter(type.ToTypeSignature(), "right");

		CilInstructionCollection instructions = method.GetInstructions();
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Call, equalityMethod);
		instructions.Add(CilOpCodes.Ldc_I4_0);
		instructions.Add(CilOpCodes.Ceq);
		instructions.Add(CilOpCodes.Ret);
		return method;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Methods/MethodCreator.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Methods;

public static class MethodCreator
{
	/// <summary>
	/// Creates an empty conversion method
	/// </summary>
	/// <param name="declaringType"></param>
	/// <param name="parameterType"></param>
	/// <param name="returnType"></param>
	/// <param name="isImplicit"></param>
	/// <returns>A new method with the correct name, return type, and parameter, but with an empty method body</returns>
	public static MethodDefinition AddEmptyConversion(this TypeDefinition declaringType, TypeSignature parameterType, TypeSignature returnType, bool isImplicit)
	{
		MethodDefinition conversion = declaringType.AddMethod(
			isImplicit ? "op_Implicit" : "op_Explicit",
			MethodAttributes.Public |
			MethodAttributes.HideBySig |
			MethodAttributes.SpecialName |
			MethodAttributes.Static,
			returnType);

		conversion.AddParameter(parameterType, "value");

		return conversion;
	}

	/// <summary>
	/// Creates a parameterless extern method
	/// </summary>
	/// <param name="declaringType">The type this method will be added to</param>
	/// <param name="returnType">The return type signature of this method</param>
	/// <param name="name">The name of this method and the native export it references</param>
	/// <param name="moduleReference">The native module this method references</param>
	/// <param name="attributes">The implementation attributes for this method</param>
	/// <returns></returns>
	public static MethodDefinition AddExternalMethod(this TypeDefinition declaringType, TypeSignature returnType, string? name, ModuleReference moduleReference, ImplementationMapAttributes attributes)
	{
		MethodSignature signature = MethodSignature.CreateStatic(returnType);
		MethodDefinition method = new MethodDefinition(
			name,
			MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.PInvokeImpl,
			signature);
		method.PreserveSignature = true;
		method.ImplementationMap = new ImplementationMap(
			moduleReference,
			null,
			attributes);
		declaringType.Methods.Add(method);
		return method;
	}

	public static ParameterDefinition GetOrAddReturnTypeParameterDefinition(this MethodDefinition method)
	{
		if (method.ParameterDefinitions.Count > 0 && method.ParameterDefinitions[0].Sequence == 0)
		{
			return method.ParameterDefinitions[0];
		}
		else
		{
			ParameterDefinition parameterDefinition = new ParameterDefinition(0, default, default);
			method.ParameterDefinitions.Insert(0, parameterDefinition);
			return parameterDefinition;
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Methods/MethodUtils.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Methods;

public static class MethodUtils
{
	public static IMethodDefOrRef MakeConstructorOnGenericType(CachedReferenceImporter importer, GenericInstanceTypeSignature instanceType, int paramCount)
	{
		MethodDefinition constructorDefinition = importer.LookupType(instanceType.GenericType.FullName)!.GetConstructor(paramCount);
		return MakeMethodOnGenericType(importer, instanceType, constructorDefinition);
	}

	public static IMethodDefOrRef MakeMethodOnGenericType(CachedReferenceImporter importer, GenericInstanceTypeSignature instanceType, IMethodDefOrRef definition)
	{
		IMethodDefOrRef? importedMethod = importer.UnderlyingImporter.ImportMethod(definition);
		return new MemberReference(instanceType.ToTypeDefOrRef(), importedMethod.Name, importedMethod.Signature);
	}

	public static IMethodDefOrRef MakeMethodOnGenericType(CachedReferenceImporter importer, GenericInstanceTypeSignature instanceType, Func<IMethodDefOrRef, bool> filter)
	{
		IMethodDefOrRef methodDefinition = importer.LookupType(instanceType.GenericType.FullName)!.Methods.Single(filter);
		return MakeMethodOnGenericType(importer, instanceType, methodDefinition);
	}

	public static MethodSpecification MakeGenericInstanceMethod(CachedReferenceImporter importer, IMethodDefOrRef method, params TypeSignature[] typeArguments)
	{
		return MakeGenericInstanceMethod(importer, method, new GenericInstanceMethodSignature(typeArguments));
	}

	private static MethodSpecification MakeGenericInstanceMethod(CachedReferenceImporter importer, IMethodDefOrRef method, GenericInstanceMethodSignature instanceMethodSignature)
	{
		return importer.UnderlyingImporter.ImportMethod(new MethodSpecification(method, instanceMethodSignature));
	}
}

```

`Source/AssetRipper.AssemblyDumper/Methods/PropertyCreator.cs`:

```cs
using AssetRipper.AssemblyDumper.Attributes;

namespace AssetRipper.AssemblyDumper.Methods;

public static class PropertyCreator
{
	public static PropertyDefinition AddFullProperty(this TypeDefinition type, string propertyName, MethodAttributes methodAttributes, TypeSignature returnTypeSignature, PropertyAttributes propertyAttributes = PropertyAttributes.None)
	{
		PropertyDefinition property = type.AddEmptyProperty(propertyName, methodAttributes, returnTypeSignature, propertyAttributes);
		property.AddGetMethod(propertyName, methodAttributes, returnTypeSignature);
		property.AddSetMethod(propertyName, methodAttributes, returnTypeSignature);
		return property;
	}

	public static PropertyDefinition ImplementFullProperty(this TypeDefinition type, string propertyName, MethodAttributes methodAttributes, TypeSignature? returnTypeSignature, FieldDefinition? field, PropertyAttributes propertyAttributes = PropertyAttributes.None)
	{
		TypeSignature returnType = returnTypeSignature ?? field?.Signature!.FieldType ?? throw new Exception($"{nameof(returnTypeSignature)} and {nameof(field)} cannot both be null");
		PropertyDefinition property = type.AddFullProperty(propertyName, methodAttributes, returnType, propertyAttributes);
		property.FillGetter(field, returnType);
		property.FillSetter(field);
		return property;
	}

	public static PropertyDefinition AddGetterProperty(this TypeDefinition type, string propertyName, MethodAttributes methodAttributes, TypeSignature returnTypeSignature, PropertyAttributes propertyAttributes = PropertyAttributes.None)
	{
		PropertyDefinition property = type.AddEmptyProperty(propertyName, methodAttributes, returnTypeSignature, propertyAttributes);
		property.AddGetMethod(propertyName, methodAttributes, returnTypeSignature);
		return property;
	}

	public static PropertyDefinition ImplementGetterProperty(this TypeDefinition type, string propertyName, MethodAttributes methodAttributes, TypeSignature? returnTypeSignature, FieldDefinition? field, PropertyAttributes propertyAttributes = PropertyAttributes.None)
	{
		TypeSignature returnType = returnTypeSignature ?? field?.Signature!.FieldType ?? throw new Exception($"{nameof(returnTypeSignature)} and {nameof(field)} cannot both be null");
		PropertyDefinition property = type.AddGetterProperty(propertyName, methodAttributes, returnType, propertyAttributes);
		property.FillGetter(field, returnType);
		return property;
	}

	private static PropertyDefinition AddEmptyProperty(this TypeDefinition type, string propertyName, MethodAttributes methodAttributes, TypeSignature returnTypeSignature, PropertyAttributes propertyAttributes = PropertyAttributes.None)
	{
		bool isStatic = (methodAttributes & MethodAttributes.Static) != 0;
		PropertySignature methodSignature =
			isStatic ?
			PropertySignature.CreateStatic(returnTypeSignature) :
			PropertySignature.CreateInstance(returnTypeSignature);

		PropertyDefinition property = new PropertyDefinition(propertyName, propertyAttributes, methodSignature);
		type.Properties.Add(property);

		return property;
	}

	private static MethodDefinition AddGetMethod(this PropertyDefinition property, string propertyName, MethodAttributes methodAttributes, TypeSignature returnType)
	{
		if (property.GetMethod != null)
		{
			throw new ArgumentException("Property already has a get method", nameof(property));
		}

		MethodDefinition getter = property.DeclaringType!.AddMethod($"get_{propertyName}", methodAttributes, returnType);
		property.Semantics.Add(new MethodSemantics(getter, MethodSemanticsAttributes.Getter));
		return getter;
	}

	private static MethodDefinition AddSetMethod(this PropertyDefinition property, string propertyName, MethodAttributes methodAttributes, TypeSignature returnType)
	{
		if (property.SetMethod != null)
		{
			throw new ArgumentException("Property already has a set method", nameof(property));
		}

		TypeDefinition declaringType = property.DeclaringType!;
		MethodDefinition setter = declaringType.AddMethod($"set_{propertyName}", methodAttributes, declaringType.DeclaringModule!.CorLibTypeFactory.Void);
		setter.AddParameter(returnType, "value");
		property.Semantics.Add(new MethodSemantics(setter, MethodSemanticsAttributes.Setter));
		return setter;
	}

	private static MethodDefinition FillGetter(this PropertyDefinition property, FieldDefinition? field, TypeSignature returnType)
	{
		MethodDefinition getter = property.GetMethod!;

		CilInstructionCollection instructions = getter.CilMethodBody!.Instructions;
		if (field != null)
		{
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, field);
			if (returnType is SzArrayTypeSignature arrayType)
			{
				SignatureComparer comparer = new SignatureComparer();
				if (!comparer.Equals(arrayType, field.Signature!.FieldType))
				{
					CilLocalVariable local = new CilLocalVariable(arrayType);
					getter.CilMethodBody.LocalVariables.Add(local);
					instructions.Add(CilOpCodes.Stloc, local);
					instructions.Add(CilOpCodes.Ldloc, local);
				}
			}
		}
		else
		{
			instructions.AddDefaultValue(returnType);
		}
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
		return getter;
	}

	private static MethodDefinition FillSetter(this PropertyDefinition property, FieldDefinition? field)
	{
		MethodDefinition setter = property.SetMethod!;

		CilInstructionCollection instructions = setter.CilMethodBody!.Instructions;
		if (field != null)
		{
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldarg_1); //value
			instructions.Add(CilOpCodes.Stfld, field);
		}
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
		return setter;
	}

	public static PropertyDefinition ImplementFullAutoProperty(
		this TypeDefinition declaringType,
		string propertyName,
		MethodAttributes methodAttributes,
		TypeSignature propertyType,
		CachedReferenceImporter importer,
		out FieldDefinition field,
		PropertyAttributes propertyAttributes = PropertyAttributes.None)
	{
		field = CreateBackingField(declaringType, propertyName, propertyType, importer);
		PropertyDefinition property = declaringType.ImplementFullProperty(propertyName, methodAttributes, propertyType, field, propertyAttributes);
		property.GetMethod!.AddCompilerGeneratedAttribute(importer);
		property.SetMethod!.AddCompilerGeneratedAttribute(importer);
		return property;
	}

	public static PropertyDefinition ImplementGetterAutoProperty(
		this TypeDefinition declaringType,
		string propertyName,
		MethodAttributes methodAttributes,
		TypeSignature propertyType,
		CachedReferenceImporter importer,
		out FieldDefinition field,
		PropertyAttributes propertyAttributes = PropertyAttributes.None)
	{
		field = CreateBackingField(declaringType, propertyName, propertyType, importer);
		PropertyDefinition property = declaringType.ImplementGetterProperty(propertyName, methodAttributes, propertyType, field, propertyAttributes);
		property.GetMethod!.AddCompilerGeneratedAttribute(importer);
		return property;
	}

	private static FieldDefinition CreateBackingField(TypeDefinition declaringType, string propertyName, TypeSignature fieldType, CachedReferenceImporter importer)
	{
		FieldDefinition field = declaringType.AddField($"<{propertyName}>k__BackingField", fieldType, false, Visibility.Private);
		field.AddCompilerGeneratedAttribute(importer);
		return field;
	}
}

```

`Source/AssetRipper.AssemblyDumper/NodeType.cs`:

```cs
namespace AssetRipper.AssemblyDumper;

public enum NodeType
{
	Type,
	Boolean,
	Character,
	String,
	Int8,
	Int16,
	Int32,
	Int64,
	UInt8,
	UInt16,
	UInt32,
	UInt64,
	Single,
	Double,
	Vector,
	Array,
	Pair,
	Map,
	TypelessData,
}

public static class NodeTypeExtensions
{
	public static string ToPrimitiveTypeName(this NodeType type)
	{
		return type switch
		{
			NodeType.Boolean => nameof(Boolean),
			NodeType.Character => nameof(Char),
			NodeType.Int8 => nameof(SByte),
			NodeType.UInt8 => nameof(Byte),
			NodeType.Int16 => nameof(Int16),
			NodeType.UInt16 => nameof(UInt16),
			NodeType.Int32 => nameof(Int32),
			NodeType.UInt32 => nameof(UInt32),
			NodeType.Int64 => nameof(Int64),
			NodeType.UInt64 => nameof(UInt64),
			NodeType.Single => nameof(Single),
			NodeType.Double => nameof(Double),
			NodeType.String => nameof(Utf8String),
			_ => throw new NotSupportedException(type.ToString()),
		};
	}

	public static bool IsPrimitive(this NodeType type)
	{
		return type is
			NodeType.Boolean or
			NodeType.Character or
			NodeType.Int8 or
			NodeType.UInt8 or
			NodeType.Int16 or
			NodeType.UInt16 or
			NodeType.Int32 or
			NodeType.UInt32 or
			NodeType.Int64 or
			NodeType.UInt64 or
			NodeType.Single or
			NodeType.Double or
			NodeType.String;
	}

	public static TypeSignature ToPrimitiveTypeSignature(this NodeType type)
	{
		return type switch
		{
			NodeType.Boolean => SharedState.Instance.Importer.Boolean,
			NodeType.Character => SharedState.Instance.Importer.Char,
			NodeType.Int8 => SharedState.Instance.Importer.Int8,
			NodeType.Int16 => SharedState.Instance.Importer.Int16,
			NodeType.Int32 => SharedState.Instance.Importer.Int32,
			NodeType.Int64 => SharedState.Instance.Importer.Int64,
			NodeType.UInt8 => SharedState.Instance.Importer.UInt8,
			NodeType.UInt16 => SharedState.Instance.Importer.UInt16,
			NodeType.UInt32 => SharedState.Instance.Importer.UInt32,
			NodeType.UInt64 => SharedState.Instance.Importer.UInt64,
			NodeType.Single => SharedState.Instance.Importer.Single,
			NodeType.Double => SharedState.Instance.Importer.Double,
			NodeType.String => SharedState.Instance.Importer.ImportType<Utf8String>().ToTypeSignature(),
			_ => throw new NotSupportedException(type.ToString()),
		};
	}
}

```

`Source/AssetRipper.AssemblyDumper/Notes.md`:

```md
# Notes

## Important Versions

```cs
/// <summary>
/// 2.1.0 and greater
/// The alignment concept was first introduced only in v2.1.0
/// </summary>
public bool IsAlign { get; }
/// <summary>
/// 2017.1 and greater
/// </summary>
public bool IsAlignArrays { get; }
/// <summary>
/// 4.5.0 and greater
/// </summary>
public bool IsStructSerializable { get; }
```
```

`Source/AssetRipper.AssemblyDumper/Passes/DebuggerExtensions.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class DebuggerExtensions
{
	private static IMethodDefOrRef? debuggerBrowsableConstructor;

	private static IMethodDefOrRef DebuggerBrowsableConstructor
	{
		get
		{
			debuggerBrowsableConstructor ??= SharedState.Instance.Importer.ImportConstructor<DebuggerBrowsableAttribute>(1);
			return debuggerBrowsableConstructor;
		}
	}

	public static CustomAttribute AddDebuggerBrowsableNeverAttribute(this FieldDefinition field)
	{
		return field.AddDebuggerBrowsableNeverAttributeInternal();
	}

	public static CustomAttribute AddDebuggerBrowsableNeverAttribute(this PropertyDefinition field)
	{
		return field.AddDebuggerBrowsableNeverAttributeInternal();
	}

	private static CustomAttribute AddDebuggerBrowsableNeverAttributeInternal(this IHasCustomAttribute hasCustomAttribute)
	{
		return hasCustomAttribute.AddCustomAttribute(DebuggerBrowsableConstructor,
			(SharedState.Instance.Importer.Int32, (int)DebuggerBrowsableState.Never));
	}

	public static CustomAttribute AddDebuggerDisplayAttribute(this TypeDefinition type, string value)
	{
		return type.AddCustomAttribute(SharedState.Instance.Importer.ImportConstructor<DebuggerDisplayAttribute>(1),
			(SharedState.Instance.Importer.String, value));
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/NullableAnnotation.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Passes;

public enum NullableAnnotation : byte
{
	Oblivious,
	NotNull,
	MaybeNull,
}

```

`Source/AssetRipper.AssemblyDumper/Passes/NullableExtensions.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;

namespace AssetRipper.AssemblyDumper.Passes;

/// <summary>
/// <see href="https://github.com/dotnet/roslyn/blob/main/docs/features/nullable-metadata.md"/>
/// </summary>
internal static class NullableExtensions
{
	internal static PropertyDefinition AddNullableAttributesForMaybeNull(this PropertyDefinition property)
	{
		TypeSignature typeSignature = property.Signature!.ReturnType;
		if (typeSignature is SzArrayTypeSignature or GenericInstanceTypeSignature)
		{
			property.AddNullableAttribute(GetNullableByteArray(typeSignature));
		}
		else
		{
			property.AddNullableAttribute(NullableAnnotation.MaybeNull);
		}
		property.GetMethod!.AddNullableContextAttribute(NullableAnnotation.MaybeNull);
		property.SetMethod?.AddNullableContextAttribute(NullableAnnotation.MaybeNull);
		return property;
	}

	internal static FieldDefinition AddNullableAttributesForMaybeNull(this FieldDefinition field)
	{
		TypeSignature typeSignature = field.Signature!.FieldType;
		if (typeSignature is SzArrayTypeSignature or GenericInstanceTypeSignature)
		{
			field.AddNullableAttribute(GetNullableByteArray(typeSignature));
		}
		else
		{
			field.AddNullableAttribute(NullableAnnotation.MaybeNull);
		}
		return field;
	}

	internal static CustomAttribute AddNullableAttribute(this IHasCustomAttribute hasCustomAttribute, NullableAnnotation annotation)
	{
		return hasCustomAttribute.AddCustomAttribute(SharedState.Instance.NullableAttributeConstructorByte, SharedState.Instance.Importer.UInt8, (byte)annotation);
	}

	internal static CustomAttribute AddNullableAttribute(this IHasCustomAttribute hasCustomAttribute, byte[] annotationArray)
	{
		return hasCustomAttribute.AddCustomAttribute(SharedState.Instance.NullableAttributeConstructorByteArray, SharedState.Instance.Importer.UInt8.MakeSzArrayType(), annotationArray);
	}

	internal static CustomAttribute AddNullableContextAttribute(this IHasCustomAttribute hasCustomAttribute, NullableAnnotation annotation)
	{
		return hasCustomAttribute.AddCustomAttribute(SharedState.Instance.NullableContextAttributeConstructor, SharedState.Instance.Importer.UInt8, (byte)annotation);
	}

	internal static CustomAttribute AddNotNullAttribute(this MethodDefinition method)
	{
		IMethodDefOrRef attributeConstructor = SharedState.Instance.Importer.ImportDefaultConstructor<NotNullAttribute>();
		return method
			.GetOrAddReturnTypeParameterDefinition()
			.AddCustomAttribute(attributeConstructor);
	}

	private static byte[] GetNullableByteArray(TypeSignature type)
	{
		List<byte> result = new();
		AddNullableIndicatorBytes(type, result);
		result[0] = 2;
		return result.ToArray();
	}

	private static void AddNullableIndicatorBytes(TypeSignature type, List<byte> byteList)
	{
		byteList.Add(type.IsValueType ? (byte)0 : (byte)1);
		if (type is SzArrayTypeSignature arrayType)
		{
			AddNullableIndicatorBytes(arrayType.BaseType, byteList);
		}
		else if (type is GenericInstanceTypeSignature genericInstanceTypeSignature)
		{
			foreach (TypeSignature typeArgument in genericInstanceTypeSignature.TypeArguments)
			{
				AddNullableIndicatorBytes(typeArgument, byteList);
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass000_ProcessTpk.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.Tpk;
using AssetRipper.Tpk.TypeTrees;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass000_ProcessTpk
{
	private static UnityVersion MinimumVersion { get; } = new UnityVersion(3, 5, 0);

	public static void IntitializeSharedState(string tpkPath)
	{
		TpkTypeTreeBlob blob = ReadAndProcessTpkFile(tpkPath);
		Console.WriteLine($"\tCreation time: {blob.CreationTime.ToLocalTime()}");
		Dictionary<int, VersionedList<UniversalClass>> classes = new();
		foreach (TpkClassInformation classInfo in blob.ClassInformation)
		{
			int id = classInfo.ID;

			if (id is 129) // PlayerSettings
			{
				continue;
			}

			VersionedList<UniversalClass> classList = new();
			classes.Add(id, classList);
			for (int i = 0; i < classInfo.Classes.Count; i++)
			{
				KeyValuePair<UnityVersion, TpkUnityClass?> pair = classInfo.Classes[i];
				if (pair.Value is not null)
				{
					UniversalClass universalClass = UniversalClass.FromTpkUnityClass(pair.Value, id, blob.StringBuffer, blob.NodeBuffer);
					classList.Add(pair.Key, universalClass);
				}
				else
				{
					classList.Add(pair.Key, null);
				}
			}
		}
		UniversalCommonString commonString = UniversalCommonString.FromBlob(blob);
		UnityVersion[] usedVersions = blob.Versions.Where(v => v >= MinimumVersion).ToArray();
		SharedState.Initialize(usedVersions, classes, commonString, WriteTpkFile(blob));
	}

	private static TpkTypeTreeBlob ReadAndProcessTpkFile(string tpkPath)
	{
		TpkTypeTreeBlob blob = ReadTpkFile(tpkPath);
		Dictionary<UnityVersion, UnityVersion> versionRedirectDictionary = MakeVersionRedirectDictionary(blob.Versions);
		for (int i = blob.ClassInformation.Count - 1; i >= 0; i--)
		{
			TpkClassInformation classInfo = blob.ClassInformation[i];

			if (IsUnacceptable(classInfo.ID) || HasNoDataAfterMinimumVersion(classInfo))
			{
				blob.ClassInformation.RemoveAt(i);
			}
		}
		foreach (TpkClassInformation classInfo in blob.ClassInformation)
		{
			int i = 0;
			while (i < classInfo.Classes.Count)
			{
				KeyValuePair<UnityVersion, TpkUnityClass?> pair = classInfo.Classes[i];
				UnityVersion version = versionRedirectDictionary[pair.Key];
				if (version == MinimumVersion && i < classInfo.Classes.Count - 1 && versionRedirectDictionary[classInfo.Classes[i + 1].Key] == MinimumVersion)
				{
					//Delete. This TpkUnityClass conflicts with the next one because they're both redirected to the minimum version.
					classInfo.Classes.RemoveAt(i);
				}
				else
				{
					classInfo.Classes[i] = new(version, pair.Value);
					i++;
				}
			}

			while (classInfo.Classes[0].Value is null)
			{
				classInfo.Classes.RemoveAt(0);
			}
		}
		return blob;

		static bool IsUnacceptable(int typeId) => typeId is >= 100000 and <= 100011;

		static bool HasNoDataAfterMinimumVersion(TpkClassInformation info)
		{
			KeyValuePair<UnityVersion, TpkUnityClass?> lastPair = info.Classes[info.Classes.Count - 1];
			return lastPair.Key < MinimumVersion && lastPair.Value is null;
		}
	}

	private static TpkTypeTreeBlob ReadTpkFile(string path)
	{
		TpkDataBlob blob = TpkFile.FromFile(path).GetDataBlob();
		return blob is TpkTypeTreeBlob typeTreeBlob
			? typeTreeBlob
			: throw new NotSupportedException($"Blob cannot be type {blob.GetType()}");
	}

	private static byte[] WriteTpkFile(TpkTypeTreeBlob blob)
	{
		return TpkFile.FromBlob(blob, TpkCompressionType.Brotli).WriteToMemory();
	}

	private static Dictionary<UnityVersion, UnityVersion> MakeVersionRedirectDictionary(List<UnityVersion> list)
	{
		Dictionary<UnityVersion, UnityVersion> dict = new();

		UnityVersion first = list.First(v => v >= MinimumVersion);
		dict.Add(first, first.StripType());

		int firstIndex = list.IndexOf(first);
		for (int i = 0; i < firstIndex; i++)
		{
			dict.Add(list[i], MinimumVersion);
		}
		for (int i = firstIndex + 1; i < list.Count; i++)
		{
			UnityVersion previous = list[i - 1];
			UnityVersion current = list[i];
			if (current.Major != previous.Major)
			{
				dict.Add(current, current.StripMinor());
			}
			else if (current.Minor != previous.Minor)
			{
				dict.Add(current, current.StripBuild());
			}
			else if (current.Build != previous.Build)
			{
				dict.Add(current, current.StripType());
			}
			else if (current.Type != previous.Type)
			{
				dict.Add(current, current.StripTypeNumber());
			}
			else
			{
				dict.Add(current, current);
			}
		}
		return dict;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass001_MergeMovedGroups.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass001_MergeMovedGroups
{
	public static IReadOnlyDictionary<int, IReadOnlyList<int>> Changes { get; } = new Dictionary<int, IReadOnlyList<int>>
	{
		{ 238, new int[] { 194 } },//NavMesh
		{ 258, new int[] { 197 } },//LightProbes
		{ 319, new int[] { 1011 } },//AvatarMask
		{ 329, new int[] { 327 } },//VideoClip
	};

	public static void DoPass()
	{
		// Fix old NavMesh before merging
		{
			// This prevents a conflict with the new NavMesh class.
			// Between versions 5.0 and 5.3, they both existed, but the old one had no data.
			// We're removing that section to prevent any issues.
			// In the AssetFactory, we'll return null for 194 on version 5.0 and higher.

			VersionedList<UniversalClass> versionedList = SharedState.Instance.ClassInformation[194];

			versionedList.Pop();
			versionedList.Pop();

			versionedList.Add(new UnityVersion(5), null);
		}

		foreach ((int mainID, IReadOnlyList<int> idList) in Changes)
		{
			VersionedList<UniversalClass> versionedList = SharedState.Instance.ClassInformation[mainID];
			foreach (int id in idList)
			{
				VersionedList<UniversalClass> otherVersionedList = SharedState.Instance.ClassInformation[id];
				versionedList = VersionedList.Merge(versionedList, otherVersionedList);
				SharedState.Instance.ClassInformation.Remove(id);
			}
			foreach (UniversalClass? universalClass in versionedList.Values)
			{
				if (universalClass is not null)
				{
					universalClass.TypeID = mainID;
				}
			}
			SharedState.Instance.ClassInformation[mainID] = versionedList;
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass002_RenameSubnodes.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass002_RenameSubnodes
{
	public const string GuidName = "GUID";
	public const string Utf8StringName = "Utf8String";
	private const string PropertyNameName = "PropertyName";
	private const string OffsetPtrName = "OffsetPtr";
	private const string KeyframeName = "Keyframe";
	private const string AnimationCurveName = "AnimationCurve";
	private const string ColorRGBAName = "ColorRGBA";
	private const string PackedBitVectorName = "PackedBitVector";
	private const string VFXEntryExposedName = "VFXEntryExposed";
	private const string VFXEntryExpressionValueName = "VFXEntryExpressionValue";
	private const string VFXFieldName = "VFXField";
	private const string VFXPropertySheetSerializedBaseName = "VFXPropertySheetSerializedBase";
	private const string TilemapRefCountedDataName = "TilemapRefCountedData";
	private const string SpriteAtlasAssetName = "SpriteAtlasAsset";
	private const string SpriteAtlasAssetDataName = "SpriteAtlasAssetData";
	private const string SpriteAtlasAssetImporterDataFieldName = "m_ImporterData";
	private const string Vector4FloatName = "Vector4Float";
	private const string Vector3FloatName = "Vector3Float";

	private static readonly Dictionary<string, string> ClassNameReplacement = new()
	{
		{ "AvatarBodyMask" , "AvatarMask" },
		{ "LightmapSnapshot" , "LightingDataAsset" },
		{ "PhysicMaterial" , "PhysicsMaterial" },
		{ "RenderManager" , "GraphicsSettings" },
		{ "State" , "AnimatorState" },
		{ "StateMachine" , "AnimatorStateMachine" },
		{ "Transition" , "AnimatorStateTransition" },
	};
	private static readonly Dictionary<string, string> PPtrNameReplacement = new();
	private static readonly Dictionary<string, string> TypeNameReplacement = new()
	{
		{ "AlbedoSwatchInfo" , "AlbedoSwitchInfo" },
		{ "PlatformShaderSettings" , "TierGraphicsSettingsEditor" },//before 5.5
		{ "BoneInfluence" , "BoneWeights4" },
		{ "IntPoint" , "Vector2Long" },
		{ "Int2_storage" , "Vector2Int" },
		{ "Int3_storage" , "Vector3Int" },
		{ "Float3" , Vector3FloatName },
		{ "Float4" , Vector4FloatName },
		{ "Fixed_bitset" , "FixedBitset" },
		{ "GradientNEW" , "Gradient" },
	};

	private static IEnumerable<T> WhereNotNull<T>(this IEnumerable<T?> enumerable) where T : notnull
	{
		foreach (T? item in enumerable)
		{
			if (item is not null)
			{
				yield return item;
			}
		}
	}

	public static void DoPass()
	{
		InitializePPtrNameReplacementDictionary();
		foreach (VersionedList<UniversalClass> classList in SharedState.Instance.ClassInformation.Values)
		{
			foreach (UniversalClass? unityClass in classList.Values)
			{
				if (unityClass is not null)
				{
					unityClass.CorrectTypeNames();
					unityClass.EditorRootNode?.FixNamesRecursively();
					unityClass.ReleaseRootNode?.FixNamesRecursively();
					unityClass.EditorRootNode?.DoSecondaryRenamingRecursively(true);
					unityClass.ReleaseRootNode?.DoSecondaryRenamingRecursively(false);
				}
			}
		}
	}

	private static void InitializePPtrNameReplacementDictionary()
	{
		PPtrNameReplacement.Clear();
		foreach (string className in SharedState.Instance.ClassInformation.Values.SelectMany(list => list.Values).WhereNotNull().Select(@class => @class.Name).Distinct())
		{
			string replacementClass = ClassNameReplacement.GetValueOrDefault(className, className);
			PPtrNameReplacement.Add($"PPtr_{className}_", $"PPtr_{replacementClass}");
		}
	}

	/// <summary>
	/// Corrects the root nodes of classes to have the correct Type Name.<br/>
	/// For example, Behaviour uses Component as its type name in the root nodes.<br/>
	/// In addition, this also applies any renaming from <see cref="ClassNameReplacement"/>.
	/// </summary>
	/// <param name="unityClass"></param>
	private static void CorrectTypeNames(this UniversalClass unityClass)
	{
		if (ClassNameReplacement.TryGetValue(unityClass.Name, out string? replacementName))
		{
			unityClass.Name = replacementName;
		}
		if (unityClass.BaseString is not null && ClassNameReplacement.TryGetValue(unityClass.BaseString, out string? replacementBaseName))
		{
			unityClass.BaseString = replacementBaseName;
		}
		if (unityClass.EditorRootNode != null && unityClass.EditorRootNode.TypeName != unityClass.Name)
		{
			unityClass.EditorRootNode.TypeName = unityClass.Name;
			unityClass.EditorRootNode.OriginalTypeName = unityClass.OriginalName;
		}
		if (unityClass.ReleaseRootNode != null && unityClass.ReleaseRootNode.TypeName != unityClass.Name)
		{
			unityClass.ReleaseRootNode.TypeName = unityClass.Name;
			unityClass.ReleaseRootNode.OriginalTypeName = unityClass.OriginalName;
		}
	}

	/// <summary>
	/// Fix all type and field names to be valid if decompiled<br/>
	/// For example, it uses a regex to replace invalid characters with an underscore, ie data[0] to data_0_
	/// </summary>
	/// <param name="node"></param>
	private static void FixNamesRecursively(this UniversalNode node)
	{
		node.Name = ValidNameGenerator.GetValidFieldName(node.Name);
		if (node.NodeType == NodeType.Type) //don't rename special type names like long long, map, or Array
		{
			node.TypeName = ValidNameGenerator.GetValidTypeName(node.TypeName);
		}
		if (node.SubNodes != null)
		{
			foreach (UniversalNode subnode in node.SubNodes)
			{
				subnode.FixNamesRecursively();
			}
		}
	}

	private static void DoSecondaryRenamingRecursively(this UniversalNode node, bool isEditor)
	{
		if (node.SubNodes != null)
		{
			foreach (UniversalNode subnode in node.SubNodes)
			{
				subnode.DoSecondaryRenamingRecursively(isEditor);
			}
		}

		node.DoSecondaryRenaming(isEditor);
	}

	private static void DoSecondaryRenaming(this UniversalNode node, bool isEditor)
	{
		if (node.TypeName == "string")
		{
			ChangeStringToUtf8String(node);
		}
		else if (TypeNameReplacement.TryGetValue(node.TypeName, out string? replacementTypeName))
		{
			node.TypeName = replacementTypeName;
		}
		else if (node.TypeName == OffsetPtrName)
		{
			node.TypeName = $"{OffsetPtrName}_{node.GetSubNodeByName("m_Data").TypeName}";
		}
		else if (node.TypeName == KeyframeName)
		{
			string valueTypeName = node.GetSubNodeByName("m_Value").TypeName;
			string elementTypeName = valueTypeName == "float" ? nameof(Single) : valueTypeName;
			node.TypeName = $"{KeyframeName}_{elementTypeName}";
		}
		else if (node.TypeName == AnimationCurveName)
		{
			if (node.TryGetSubNodeByTypeAndName("vector", "m_Curve", out UniversalNode? curveNode))
			{
				UniversalNode keyframeNode = curveNode.SubNodes[0].SubNodes[1];

				if (keyframeNode.TypeName.StartsWith($"{KeyframeName}_"))
				{
					string elementType = keyframeNode.TypeName.Substring(KeyframeName.Length + 1);
					node.TypeName = $"{AnimationCurveName}_{elementType}";
				}
			}
		}
		else if (node.TypeName == ColorRGBAName)
		{
			node.TypeName = node.SubNodes.Count switch
			{
				4 => $"{ColorRGBAName}f",
				1 => $"{ColorRGBAName}32",
				_ => throw new NotSupportedException(),
			};
		}
		else if (node.TypeName == PackedBitVectorName)
		{
			//The packed bit vectors are constant throughout all the unity versions and identifiable by their number of fields
			node.TypeName = node.SubNodes.Count switch
			{
				5 => $"{PackedBitVectorName}_Single",
				3 => $"{PackedBitVectorName}_Int32",
				2 => $"{PackedBitVectorName}_Quaternionf",
				_ => throw new NotSupportedException(),
			};
		}
		else if (node.IsVFXEntryExposed(out string? vfxEntryExposedElement))
		{
			node.TypeName = $"{VFXEntryExposedName}_{vfxEntryExposedElement}";
		}
		else if (node.IsVFXEntryExpressionValue(out string? vfxEntryExpressionValueElement))
		{
			node.TypeName = $"{VFXEntryExpressionValueName}_{vfxEntryExpressionValueElement}";
		}
		else if (node.IsVFXField(out string? vfxFieldElement))
		{
			node.TypeName = $"{VFXFieldName}_{vfxFieldElement}";
		}
		else if (node.IsVFXPropertySheetSerializedBase(out string? vfxPropertySheetElement))
		{
			node.TypeName = $"{VFXPropertySheetSerializedBaseName}_{vfxPropertySheetElement}";
		}
		else if (node.TypeName == TilemapRefCountedDataName)
		{
			if (node.TryGetSubNodeByName("m_Data", out UniversalNode? subnode))
			{
				string elementType = subnode.TypeName;
				node.TypeName = $"{TilemapRefCountedDataName}_{elementType}";
			}
		}
		else if (node.TypeName == "Blend2dDataConstant")
		{
			// On Unity 4 versions, Blend1d and Blend2d were initially both called Blend2d
			if (node.SubNodes.Count == 1 && node.SubNodes[0].Name == "m_ChildThresholdArray")
			{
				node.TypeName = "Blend1dDataConstant";
			}
		}
		else if (node.IsSpriteAtlasAsset(out UniversalNode? spriteAtlasAssetImporterDataFieldNode))
		{
			spriteAtlasAssetImporterDataFieldNode.TypeName = SpriteAtlasAssetDataName;
		}
		else if (node.IsLightProbes(out UniversalNode? bakedCoefficientsNode))
		{
			bakedCoefficientsNode.TypeName = "SphericalHarmonicsL2";
			foreach (UniversalNode child in bakedCoefficientsNode.SubNodes)
			{
				if (child.Name.Length == "m_Sh_0_".Length)
				{
					child.Name = $"m_Sh_{child.Name.Substring(4)}";
				}
			}
		}
		else if (node.TypeName == "Hash128")
		{
			//So that the fields get ordered sequentially
			for (int i = 0; i < 10; i++)
			{
				node.TryRenameSubNode($"m_Bytes_{i}_", $"m_Bytes__{i}");
			}
			for (int i = 10; i < 16; i++)
			{
				node.TryRenameSubNode($"m_Bytes_{i}_", $"m_Bytes_{i}");
			}
		}
		else if (node.TypeName == "AudioSource")
		{
			if (node.TryGetSubNodeByName("m_Resource", out UniversalNode? resourceNode))
			{
				// https://github.com/AssetRipper/AssetRipper/issues/1881
				resourceNode.TypeName = "PPtr_Object";
				resourceNode.OriginalTypeName = "PPtr<Object>";// Need to ensure correct merging
			}
		}
		else if (node.IsAssetServerCache(out UniversalNode? modifiedItemTypeNode))
		{
			modifiedItemTypeNode.TypeName = "ModifiedItem";
		}
		else if (node.TypeName == "NameToObjectMap")
		{
			if (node.TryGetSubNodeByTypeAndName("map", "m_ObjectToName", out UniversalNode? subnode))
			{
				//array, pair, first
				UniversalNode typeNode = subnode.SubNodes[0].SubNodes[1].SubNodes[0];
				string typeName = typeNode.TypeName;
				node.TypeName = typeName.StartsWith("PPtr_", StringComparison.Ordinal)
					? $"NameToObjectMap_{typeName.Substring(5)}"
					: throw new NotSupportedException();
			}
		}
		else if (node.TypeName == "BuildTargetSettings")
		{
			node.TypeName = node.SubNodes.Any(n => n.Name == "m_MaxTextureSize")
				? "TextureImporterPlatformSettings"
				: "BuildTargetSettings_Material";
		}
		else if (node.TypeName == "Google")
		{
			if (node.SubNodes.Any(n => n.Name == "m_EnableTransitionView"))
			{
				node.TypeName = "GoogleCardboard";
			}
			else if (node.SubNodes.Any(n => n.Name == "m_UseSustainedPerformanceMode"))
			{
				node.TypeName = "GoogleDayDream";
			}
		}
		else if (node.TypeName == "InputImportSettings")
		{
			if (node.SubNodes.Any(n => n.Name == "m_Value"))
			{
				node.TypeName = "InputImportSettings_SubstanceValue";
			}
		}
		else if (node.TypeName == "MultiModeParameter")
		{
			if (!node.SubNodes.Any(n => n.Name == "m_Value"))
			{
				node.TypeName = "MultiModeParameter_MeshSpawn";
			}
		}
		else if (node.TypeName == "Output")
		{
			if (node.SubNodes.Any(n => n.Name == "m_HasEmptyFontData"))
			{
				node.TypeName = "FontOutput";
			}
			else if (node.SubNodes.Any(n => n.Name == "m_PreviewData"))
			{
				node.TypeName = "AudioImporterOutputOld";
				node.Name = "m_OutputOld";
			}
		}
		else if (node.TypeName == "PlatformSettingsData")
		{
			node.TypeName = node.SubNodes.Any(n => n.Name == "m_Enabled")
				? "PlatformSettingsData_Plugin"
				: "PlatformSettingsData_Editor";
		}
		else if (node.TypeName == "GraphicsSettings")
		{
			node.TryRenameSubNode("m_BuildTargetShaderSettings", "m_TierSettings");//before 5.5
			node.TryRenameSubNode("m_AlbedoSwatchInfos", "m_AlbedoSwitchInfos");//Unity spelling is great
		}
		else if (node.TypeName == "LightmapSettings")
		{
			node.TryRenameSubNode("m_LightmapSnapshot", "m_LightingDataAsset");
		}
		else if (node.TypeName == "BuildTargetShaderSettings")
		{
			//This class was changed in 5.5 to TierSettings, so we rename it for consistency.
			//Starting in 2022.2.0b10, a similiar class with this name was added,
			//but it conflicts with TierSettings, hence this rename is meant to only apply on the old versions.
			if (node.TryRenameSubNode("m_ShaderSettings", "m_Settings"))
			{
				node.TypeName = "TierSettings";
			}
		}
		else if (node.TypeName == "BuildTargetSettings")
		{
			node.TypeName = node.SubNodes.Any(n => n.Name == "m_MaxTextureSize") //only for TextureImporter before 5.5
				? "TextureImporterPlatformSettings"
				: "MaterialBuildTargetSettings";
		}
		else if (node.TypeName == "TextureImporter")
		{
			node.TryRenameSubNode("m_BuildTargetSettings", "m_PlatformSettings");
		}
		else if (node.TypeName == "ExposedReferenceTable")
		{
			if (isEditor)
			{
				// Ensure yaml is emitted as a sequence, rather than a mapping.
				// There does not seem to be any indication in the type trees about this,
				// but nonetheless it is required for correct serialization.
				// https://github.com/Unity-Technologies/Timeline-MessageMarker/blob/711db46387de66c746e9027090c2de786fe99855/Assets/TestScene.unity#L228
				// https://github.com/AssetRipper/AssetRipper/issues/1667#issuecomment-2646056403
				// This appears to be a unique case.
				node.GetSubNodeByName("m_References").TypeName = "vector";
			}
			node.RenameSubNode("m_References", isEditor ? "m_References_Editor" : "m_References_Release");
		}
		else if (node.TypeName == "ExtensionPropertyValue")
		{
			node.RenameSubNode("m_PluginName", isEditor ? "m_PluginNameNode_Editor" : "m_PluginNameNode_Release");
			node.RenameSubNode("m_ExtensionName", isEditor ? "m_ExtensionNameNode_Editor" : "m_ExtensionNameNode_Release");
			node.RenameSubNode("m_PropertyName", isEditor ? "m_PropertyNameNode_Editor" : "m_PropertyNameNode_Release");
		}
		else if (PPtrNameReplacement.TryGetValue(node.TypeName, out string? replacementPPtrName))
		{
			node.TypeName = replacementPPtrName;
			node.TryRenameSubNode("m_FileID", "m_FileID_");
			node.TryRenameSubNode("m_PathID", "m_PathID_");
			if (node.Name == "m_PrefabParentObject")//3.5 - 2018.2
			{
				node.Name = "m_CorrespondingSourceObject";
			}
			/*else if (node.Name == "m_PrefabInternal")//3.5 - 2018.3
			{
				node.Name = "m_PrefabAsset";
			}*/
		}
		else if (node.TypeName == "Texture3D")
		{
			node.TryRenameSubNode("m_DataSize", "m_CompleteImageSize");
			node.TryRenameSubNode("m_ImageCount", "m_Depth");
		}
		else if (node.Name == "m_Image_data")
		{
			node.Name = "m_ImageData";
		}
		else if (node.Name == "m_TextureFormat")
		{
			node.Name = "m_Format";//For better linking with documentation
		}
		else if (node.Name == "m_TextureDimension")
		{
			node.Name = "m_Dimension";//For better linking with documentation
		}
		else if (node.Name == "m_ObjectHideFlags")
		{
			node.Name = "m_HideFlags";//For better linking with documentation
		}
		else if (node.TypeName == "Mesh")
		{
			if (node.TryGetSubNodeByTypeAndName("vector", "m_Shapes", out UniversalNode? meshBlendShapesListNode))
			{
				meshBlendShapesListNode.Name = "m_ShapesList";
			}
		}
		else if (node.TypeName == "GameObject")
		{
			UniversalNode dataNode = node.GetSubNodeByName("m_Component").GetSubNodeByName("m_Array").GetSubNodeByName("m_Data");
			if (dataNode.TypeName == "pair")
			{
				//Before 5.5
				dataNode.TypeName = "ComponentPair";
				dataNode.RenameSubNode("m_First", "m_ClassID");
				dataNode.RenameSubNode("m_Second", "m_Component");
			}
			node.RenameSubNode("m_Component", "m_Components");
		}
		else if (node.TypeName == "MeshRenderer")
		{
			node.TryRenameSubNode("m_StitchSeams", "m_StitchLightmapSeams"); // Early 2017.2 betas
		}
		else if (node.TypeName == "ComputeShaderPlatformVariant")// 2020 and later
		{
			node.TypeName = "ComputeShaderVariant";
			node.TryRenameSubNode("m_Kernels", "m_KernelParents");
		}
		else if (node.TypeName == "VariantInfo" && node.TryGetSubNodeByName("m_Shader", out _))// 6 and later
		{
			node.TypeName = "ShaderVariantInfo";
		}
		else if (node.TypeName == "Shader")
		{
			node.TryRenameSubNode("m_SubProgramBlob", "m_CompressedBlob");
		}
		else if (node.TypeName == "BuildSettings")
		{
			node.TryRenameSubNode("m_Levels", "m_Scenes"); // Earlier than 5.2
		}
		else if (node.TypeName == "ParticleSystem")
		{
			if (node.TryGetSubNodeByName("m_StartDelay", out UniversalNode? particleSystemStartDelayNode))
			{
				particleSystemStartDelayNode.Name = particleSystemStartDelayNode.TypeName == "float"
					? "m_StartDelay_Single"
					: "m_StartDelay_MinMaxCurve";
			}
		}
		else if (node.TypeName == "Child" && node.SubNodes.Any(n => n.Name == "m_IsAnim"))
		{
			node.TypeName = "ChildMotion";
		}
		else if (node.TypeName == "BlendTree")
		{
			node.TryRenameSubNode("m_BlendEvent", "m_BlendParameter");
			node.TryRenameSubNode("m_BlendEventY", "m_BlendParameterY");
		}
		else if (node.TypeName == "JointAngleLimit2D")
		{
			node.TypeName = "JointAngleLimits2D";
		}
		else if (node.TypeName == "PlatformSettings" && node.SubNodes.Any(n => n.Name == "m_MaxTextureSize"))
		{
			node.TypeName = "TextureImporterPlatformSettings";
		}
		else if (node.TypeName == "Condition" && node.SubNodes.Any(n => n.Name == "m_ConditionEvent"))
		{
			node.TypeName = "AnimatorCondition";
		}
		else if (node.TypeName == "VisualEffectResource" && node.TryGetSubNodeByTypeAndName("VisualEffectSettings", "m_Infos", out UniversalNode? visualEffectResourceInfosNode))
		{
			visualEffectResourceInfosNode.Name = "m_Settings";
		}
		else if (node.TypeName == "Prefab")
		{
			node.TryRenameSubNode("m_IsPrefabParent", "m_IsPrefabAsset");
			node.TryRenameSubNode("m_ParentPrefab", "m_SourcePrefab");
		}
		else if (node.TypeName == "PrefabInstance")
		{
			//https://github.com/ds5678/TLD-Compass/blob/13e2dbd3a93a725d0e0bb1fc0c905ac37dd3cb84/UnityProject/Assets/Scenes/SampleScene.unity#L372
			//The type trees for this field are wrong. It should be a PPtr_PrefabInstance, not a PPtr_Prefab.
			UniversalNode sourcePrefabNode = node.GetSubNodeByName("m_SourcePrefab");
			sourcePrefabNode.TypeName = "PPtr_PrefabInstance";
			sourcePrefabNode.OriginalTypeName = "PPtr<PrefabInstance>";
		}
		else if (node.TypeName == "VertexData" && node.TryGetSubNodeByName("m_DataSize", out UniversalNode? vertexDataDataSizeNode))
		{
			vertexDataDataSizeNode.Name = "m_Data";
		}
		else if (node.TypeName == "AnimatorEvent")
		{
			node.TypeName = "AnimatorControllerParameter";
		}
		else if (node.TypeName == "AnimatorController")
		{
			node.TryRenameSubNode("m_AnimatorEvents", "m_AnimatorParameters");
			node.TryRenameSubNode("m_Layers", "m_AnimatorLayers");
		}
		else if (node.TypeName == "AnimatorControllerLayer")
		{
			node.TryRenameSubNode("m_HumanMask", "m_Mask");
		}
		else if (node.Name == "m__int__m_LayerBlendingMode")//LayerConstant
		{
			node.Name = "m_LayerBlendingMode";
		}
		else if (node.Name.StartsWith("m__SInt32__m_", StringComparison.Ordinal))//AudioClip 3.5 - 5 exclusive
		{
			node.Name = node.Name.Substring("m__SInt32__".Length);
		}
		else if (node.TypeName == "AnimationClip")
		{
			node.TryRenameSubNode("m_AnimationClipSettings", "m_MuscleClipInfo");
		}
		else if (node.TypeName == "GenericBinding")
		{
			node.TryRenameSubNode("m_TypeID", "m_ClassID");
		}
		else if (node.TypeName == "ClipMuscleConstant")
		{
			node.TypeName = "MuscleClipConstant";
			if (node.TryGetSubNodeByName("m_AverageSpeed", out UniversalNode? averageSpeedNode))
			{
				averageSpeedNode.Name = averageSpeedNode.TypeName switch
				{
					Vector4FloatName => "m_AverageSpeed4",
					Vector3FloatName => "m_AverageSpeed3",
					_ => throw new NotSupportedException(),
				};
			}
		}
		else if (node.TypeName == "Xform")
		{
			if (node.TryGetSubNodeByName("m_T", out UniversalNode? tNode))
			{
				tNode.Name = tNode.TypeName switch
				{
					Vector4FloatName => "m_T4",
					Vector3FloatName => "m_T3",
					_ => throw new NotSupportedException(),
				};
			}
			if (node.TryGetSubNodeByName("m_S", out UniversalNode? sNode))
			{
				sNode.Name = sNode.TypeName switch
				{
					Vector4FloatName => "m_S4",
					Vector3FloatName => "m_S3",
					_ => throw new NotSupportedException(),
				};
			}
		}
		else if (node.TypeName == "ValueArray")
		{
			if (node.TryGetSubNodeByName("m_PositionValues", out UniversalNode? positionVectorNode))
			{
				UniversalNode positionNode = positionVectorNode.GetSubNodeByName("m_Array").GetSubNodeByName("m_Data");
				positionVectorNode.Name = positionNode.TypeName switch
				{
					Vector4FloatName => "m_PositionValues4",
					Vector3FloatName => "m_PositionValues3",
					_ => throw new NotSupportedException(positionNode.TypeName),
				};
			}
			if (node.TryGetSubNodeByName("m_ScaleValues", out UniversalNode? scaleVectorNode))
			{
				UniversalNode scaleNode = scaleVectorNode.GetSubNodeByName("m_Array").GetSubNodeByName("m_Data");
				scaleVectorNode.Name = scaleNode.TypeName switch
				{
					Vector4FloatName => "m_ScaleValues4",
					Vector3FloatName => "m_ScaleValues3",
					_ => throw new NotSupportedException(scaleNode.TypeName),
				};
			}
		}
		else if (node.TypeName == "Gradient")
		{
			if (node.TryGetSubNodeByName("m_Color_0_", out _))
			{
				node.TypeName = "GradientOld";
			}
		}
		else if (node.TypeName == "HumanLayerConstant" || node.TypeName == "LayerConstant")
		{
			node.TypeName = "LayerConstant";
			node.TryRenameSubNode("m_StateMachineMotionSetIndex", "m_StateMachineSynchronizedLayerIndex");
		}
		else if (node.TypeName == "ControllerConstant")
		{
			node.TryRenameSubNode("m_HumanLayerArray", "m_LayerArray");
		}
		else if (node.TypeName == "StateMachineConstant")
		{
			node.TryRenameSubNode("m_MotionSetCount", "m_SynchronizedLayerCount");
		}
		else if (node.TypeName == "Heightmap")
		{
			node.TryRenameSubNode("m_EnableSurfaceMaskTextureCompression", "m_EnableHolesTextureCompression");
			node.TryRenameSubNode("m_SurfaceMask", "m_Holes");
			node.TryRenameSubNode("m_SurfaceMaskLOD", "m_HolesLOD");
		}
		else if (node.TypeName == "ShapeModule")
		{
			if (node.TryGetSubNodeByName("m_Arc", out UniversalNode? arcNode) && arcNode.TypeName != "float")
			{
				arcNode.Name = "m_ArcParameter";
			}
			if (node.TryGetSubNodeByName("m_Radius", out UniversalNode? radiusNode) && radiusNode.TypeName != "float")
			{
				radiusNode.Name = "m_RadiusParameter";
			}
		}

		if (node.Name.StartsWith("m_Dst", StringComparison.Ordinal) && char.IsUpper(node.Name[5]))
		{
			string suffix = node.Name.Substring(5);
			node.Name = "m_Destination" + suffix;
		}
		else if (node.Name.StartsWith("m_Dest", StringComparison.Ordinal) && char.IsUpper(node.Name[6]))
		{
			string suffix = node.Name.Substring(6);
			node.Name = "m_Destination" + suffix;
		}
		else if (node.Name.StartsWith("m_Src", StringComparison.Ordinal) && char.IsUpper(node.Name[5]))
		{
			string suffix = node.Name.Substring(5);
			node.Name = "m_Source" + suffix;
		}
	}

	private static bool TryRenameSubNode(this UniversalNode node, string currentName, string newName)
	{
		if (node.TryGetSubNodeByName(currentName, out UniversalNode? subNode))
		{
			subNode.Name = newName;
			return true;
		}
		return false;
	}

	private static void RenameSubNode(this UniversalNode node, string currentName, string newName)
	{
		node.GetSubNodeByName(currentName).Name = newName;
	}

	private static void ChangeStringToUtf8String(UniversalNode node)
	{
		node.TypeName = Utf8StringName;
		List<UniversalNode> subnodes = node.SubNodes!;
		if (subnodes.Count != 1)
		{
			throw new Exception($"String has {subnodes.Count} subnodes");
		}
		UniversalNode subnode = subnodes[0];
		if (subnode.TypeName == "Array")
		{
			if (subnode.AlignBytes)
			{
				node.MetaFlag |= TransferMetaFlags.AlignBytes;
			}
		}
		else if (subnode.TypeName == Utf8StringName)
		{
			//ExposedReferenceTable on late 2019 and after
			node.TypeName = PropertyNameName;
		}
		else if (subnode.TypeName == "SInt32")
		{
			//ExposedReferenceTable on 2017 - early 2019
			node.TypeName = PropertyNameName;
		}
		else
		{
			//Console.WriteLine($"String subnode has typename: {subnode.TypeName}");
			throw new NotSupportedException($"String subnode has typename: {subnode.TypeName}");
		}
	}

	private static bool IsVFXEntryExposed(this UniversalNode node, [NotNullWhen(true)] out string? elementType)
	{
		List<UniversalNode> subnodes = node.SubNodes;
		if (node.TypeName == VFXEntryExposedName && subnodes.Any(n => n.Name == "m_Value"))
		{
			elementType = subnodes.Single(n => n.Name == "m_Value").TypeName;
			return true;
		}

		elementType = null;
		return false;
	}

	private static bool IsVFXEntryExpressionValue(this UniversalNode node, [NotNullWhen(true)] out string? elementType)
	{
		List<UniversalNode> subnodes = node.SubNodes;
		if (node.TypeName == VFXEntryExpressionValueName && subnodes.Any(n => n.Name == "m_Value"))
		{
			elementType = subnodes.Single(n => n.Name == "m_Value").TypeName;
			return true;
		}

		elementType = null;
		return false;
	}

	private static bool IsVFXField(this UniversalNode node, [NotNullWhen(true)] out string? elementType)
	{
		if (node.TypeName == VFXFieldName)
		{
			if (node.TryGetSubNodeByTypeAndName("vector", "m_Array", out UniversalNode? arrayNode))
			{
				elementType = arrayNode.SubNodes[0].SubNodes[1].TypeName;
				return true;
			}
		}

		elementType = null;
		return false;
	}

	private static bool IsVFXPropertySheetSerializedBase(this UniversalNode node, [NotNullWhen(true)] out string? elementType)
	{
		elementType = null;
		List<UniversalNode> subnodes = node.SubNodes;
		if (node.TypeName == VFXPropertySheetSerializedBaseName && subnodes.Any(n => n.Name == "m_Float"))
		{
			string floatFieldType = subnodes.Single(n => n.Name == "m_Float").TypeName!;
			if (floatFieldType.StartsWith($"{VFXFieldName}_{VFXEntryExposedName}"))
			{
				elementType = VFXEntryExposedName;
				return true;
			}
			else if (floatFieldType.StartsWith($"{VFXFieldName}_{VFXEntryExpressionValueName}"))
			{
				elementType = VFXEntryExpressionValueName;
				return true;
			}
			else
			{
				throw new NotSupportedException();
			}
		}

		return false;
	}

	private static bool IsSpriteAtlasAsset(this UniversalNode node, [NotNullWhen(true)] out UniversalNode? importerNode)
	{
		importerNode = node.TypeName == SpriteAtlasAssetName
			? node.SubNodes.SingleOrDefault(n => n.Name == SpriteAtlasAssetImporterDataFieldName)
			: null;
		return importerNode != null;
	}

	private static bool IsLightProbes(this UniversalNode node, [NotNullWhen(true)] out UniversalNode? bakedCoefficentsNode)
	{
		bakedCoefficentsNode = node.TypeName == "LightProbes"
			? node.SubNodes.SingleOrDefault(n => n.Name == "m_BakedCoefficients")?.SubNodes[0].SubNodes[1]
			: null;
		return bakedCoefficentsNode != null;
	}

	private static bool IsAssetServerCache(this UniversalNode node, [NotNullWhen(true)] out UniversalNode? modifiedItemTypeNode)
	{
		modifiedItemTypeNode = node.TypeName == "AssetServerCache"
			? node.SubNodes.SingleOrDefault(n => n.Name == "m_ModifiedItems")?.SubNodes[0].SubNodes[1].SubNodes[1]
			: null;
		return modifiedItemTypeNode != null;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass003_FixTextureImporterNodes.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;

namespace AssetRipper.AssemblyDumper.Passes;

/// <summary>
/// This pass deliberately modifies the type tree for TextureImporter to reflect its yaml output.
/// It also changes the base class of VideoClipImporter to AssetImporter.
/// </summary>
internal static class Pass003_FixTextureImporterNodes
{
	private const string MipMapsTypeName = "TextureImporterMipMapSettings"; //Fabricated
	private const string MipMapsName = "m_MipMaps"; //Fabricated
	private const string MipMapsOriginalName = "mipmaps";
	private const string MipMapsStartFieldName = "m_MipMapMode";
	private const string MipMapsEndFieldName = "m_MipMapFadeDistanceEnd";

	private const string BumpMapTypeName = "TextureImporterBumpMapSettings"; //Fabricated
	private const string BumpMapName = "m_BumpMap"; //Fabricated
	private const string BumpMapOriginalName = "bumpmap";
	private const string BumpMapStartFieldName = "m_ConvertToNormalMap";
	private const string BumpMapEndFieldName = "m_NormalMapFilter";
	private const string BumpMapEndFieldName2 = "m_FlipGreenChannel";//Introduced in 2022.1.0

	private const int TextureImporterTypeId = 1006;

	private const int TextureId = 27;

	private const string ImageTextureName = "ImageTexture";
	private const int ImageTextureId = 189;//This is currently unused and is close to Texture2DArray (187) and CubemapArray (188)

	public static void DoPass()
	{
		foreach (UniversalClass? universalClass in SharedState.Instance.ClassInformation[TextureImporterTypeId].Values)
		{
			if (universalClass is not null)
			{
				DoPassOnClass(universalClass);
			}
		}

		//ImageTexture is a fabricated class that represents a texture with pixel data.
		CreateArtificialDerivedClass(ImageTextureName, ImageTextureId, TextureId);

		//VideoClipImporter
		ChangeBaseClass(1127, "AssetImporter");

		//EditorSettings
		ChangeBaseClass(159, "GlobalGameManager");

		//EditorBuildSettings
		ChangeBaseClass(1045, "GlobalGameManager");

		//Texture2D
		ChangeBaseClass(28, ImageTextureName);

		//Texture3D
		ChangeBaseClass(117, ImageTextureName);

		//Texture2DArray
		ChangeBaseClass(187, ImageTextureName);

		//CubemapArray
		ChangeBaseClass(188, ImageTextureName);
	}

	private static void ChangeBaseClass(int classId, string baseClass)
	{
		foreach (UniversalClass? universalClass in SharedState.Instance.ClassInformation[classId].Values)
		{
			if (universalClass is not null)
			{
				universalClass.BaseString = baseClass;
			}
		}
	}

	private static void CreateArtificialDerivedClass(string className, int classId, int baseClassId)
	{
		VersionedList<UniversalClass> list = new();
		foreach ((UnityVersion version, UniversalClass? rendererClass) in SharedState.Instance.ClassInformation[baseClassId])
		{
			if (rendererClass is null)
			{
				list.Add(version, null);
			}
			else
			{
				UniversalClass duplicate = rendererClass.DeepClone();

				duplicate.Name = className;
				duplicate.OriginalName = className;
				duplicate.TypeID = classId;
				duplicate.OriginalTypeID = classId;
				duplicate.IsAbstract = true;
				duplicate.BaseString = rendererClass.Name;
				if (duplicate.ReleaseRootNode is not null)
				{
					duplicate.ReleaseRootNode.TypeName = className;
				}
				if (duplicate.EditorRootNode is not null)
				{
					duplicate.EditorRootNode.TypeName = className;
				}

				list.Add(version, duplicate);
			}
		}
		SharedState.Instance.ClassInformation.Add(classId, list);
	}

	private static void DoPassOnClass(UniversalClass universalClass)
	{
		universalClass.ReleaseRootNode?.DoPassOnRootNode();
		universalClass.EditorRootNode?.DoPassOnRootNode();
	}

	private static void DoPassOnRootNode(this UniversalNode rootNode)
	{
		int mipMapsStartIndex = rootNode.GetSubnodeIndex(MipMapsStartFieldName);
		int mipMapsEndIndex = rootNode.GetSubnodeIndex(MipMapsEndFieldName);
		if (mipMapsStartIndex >= mipMapsEndIndex)
		{
			throw new Exception("MipMaps start later than its end");
		}

		int bumpMapStartIndex = rootNode.GetSubnodeIndex(BumpMapStartFieldName);
		int bumpMapEndIndex = Math.Max(rootNode.GetSubnodeIndex(BumpMapEndFieldName), rootNode.TryGetSubnodeIndex(BumpMapEndFieldName2));
		if (bumpMapStartIndex <= mipMapsEndIndex)
		{
			throw new Exception("BumpMap start later than MipMaps end");
		}
		if (bumpMapStartIndex >= bumpMapEndIndex)
		{
			throw new Exception("BumpMap start later than its end");
		}

		UniversalNode mipMapsNode = new();
		mipMapsNode.Name = MipMapsName;
		mipMapsNode.OriginalName = MipMapsOriginalName;
		mipMapsNode.TypeName = MipMapsTypeName;
		mipMapsNode.Version = 1;
		mipMapsNode.MetaFlag = default;

		for (int i = mipMapsStartIndex; i <= mipMapsEndIndex; i++)
		{
			mipMapsNode.SubNodes.Add(rootNode.SubNodes[i]);
		}

		UniversalNode bumpMapNode = new();
		bumpMapNode.Name = BumpMapName;
		bumpMapNode.OriginalName = BumpMapOriginalName;
		bumpMapNode.TypeName = BumpMapTypeName;
		bumpMapNode.Version = 1;
		bumpMapNode.MetaFlag = default;

		for (int i = bumpMapStartIndex; i <= bumpMapEndIndex; i++)
		{
			bumpMapNode.SubNodes.Add(rootNode.SubNodes[i]);
		}

		int count = rootNode.SubNodes.Count - (bumpMapEndIndex - bumpMapStartIndex) - (mipMapsEndIndex - mipMapsStartIndex);
		List<UniversalNode> newSubnodes = new List<UniversalNode>(count);
		for (int i = 0; i < mipMapsStartIndex; i++)
		{
			newSubnodes.Add(rootNode.SubNodes[i]);
		}
		newSubnodes.Add(mipMapsNode);
		for (int i = mipMapsEndIndex + 1; i < bumpMapStartIndex; i++)
		{
			newSubnodes.Add(rootNode.SubNodes[i]);
		}
		newSubnodes.Add(bumpMapNode);
		for (int i = bumpMapEndIndex + 1; i < rootNode.SubNodes.Count; i++)
		{
			newSubnodes.Add(rootNode.SubNodes[i]);
		}

		rootNode.SubNodes = newSubnodes;
	}

	private static int GetSubnodeIndex(this UniversalNode parent, string subnodeName)
	{
		int result = parent.SubNodes.FindIndex(n => n.Name == subnodeName);
		return result >= 0 ? result : throw new Exception($"{subnodeName} not found");
	}

	private static int TryGetSubnodeIndex(this UniversalNode parent, string subnodeName)
	{
		return parent.SubNodes.FindIndex(n => n.Name == subnodeName);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass004_FillNameToIdDictionary.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass004_FillNameToTypeIdDictionary
{
	public static void DoPass()
	{
		Dictionary<string, HashSet<int>> dictionary = SharedState.Instance.NameToTypeID;

		foreach ((int id, VersionedList<UniversalClass> list) in SharedState.Instance.ClassInformation)
		{
			foreach (UniversalClass? universalClass in list.Values)
			{
				if (universalClass is not null)
				{
					string name = universalClass.Name;
					if (!dictionary.TryGetValue(name, out HashSet<int>? classIds))
					{
						classIds = new HashSet<int>();
						dictionary.Add(name, classIds);
					}
					classIds.Add(id);
				}
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass005_SplitAbstractClasses.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using RangeClassList = System.Collections.Generic.List<System.Collections.Generic.KeyValuePair<AssetRipper.Numerics.Range<AssetRipper.Primitives.UnityVersion>, AssetRipper.AssemblyDumper.UniversalClass>>;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass005_SplitAbstractClasses
{
	private static readonly HashSet<int> processedClasses = new();
	private const int MaxRunCount = 1000;
	private const float MinimumProportion = 0.7f;

	public static void DoPass()
	{
		//ListAbstractClassIds();
		AssignInheritance();
		DoOtherStuff();
	}

	private static void ListAbstractClassIds()
	{
		HashSet<int> abstractIds = GetAbstractClassIds();
		foreach (int abstractId in abstractIds.OrderBy(i => i))
		{
			VersionedList<UniversalClass> list = SharedState.Instance.ClassInformation[abstractId];
			if (list.All(c => c.Value?.IsAbstract ?? true))
			{
				Console.WriteLine($"\t{abstractId} abstract");
			}
			else
			{
				Console.WriteLine($"\t{abstractId} abstract sometimes");
			}
		}
	}

	private static void DoOtherStuff()
	{
		HashSet<int> abstractIds = GetAbstractClassIds();
		int runCount = 0;
		while (abstractIds.Count > 0)
		{
			foreach (int abstractId in abstractIds.ToList())
			{
				VersionedList<UniversalClass> abstractClassList = SharedState.Instance.ClassInformation[abstractId];
				if (abstractClassList.AnyDerivedAbstractAndUnprocessed())
				{
					continue;
				}
				else
				{
					RangeClassList rangeClassList = abstractClassList.MakeRangeClassList();
					List<Section> sections = rangeClassList.MakeSectionList();

					UnifySectionFields(sections, rangeClassList);

					sections = GetMergedSections(sections);
					sections.ReplaceClassesWithClones();
					sections.FixInheritance();
					sections.ApplyApprovedFields();

					abstractClassList.UpdateWithSectionData(sections);

					abstractIds.Remove(abstractId);
					processedClasses.Add(abstractId);
				}
			}
			runCount++;
			if (runCount >= MaxRunCount)
			{
				throw new Exception("Hit max run count");
			}
		}
	}

	private static void ReplaceClassesWithClones(this List<Section> sectionList)
	{
		foreach (Section section in sectionList)
		{
			UniversalClass? baseClass = section.Class.BaseClass;
			if (baseClass is not null && baseClass.DerivedClasses.Contains(section.Class))
			{
				baseClass.DerivedClasses.Remove(section.Class);
			}
			section.Class = section.Class.DeepClone();
			if (baseClass is not null)
			{
				baseClass.DerivedClasses.Add(section.Class);
			}
		}
	}

	private static void FixInheritance(this List<Section> sectionList)
	{
		foreach (Section section in sectionList)
		{
			section.Class.DerivedClasses.Clear();
			foreach (UniversalClass derivedClass in section.DerivedClasses)
			{
				derivedClass.BaseClass = null;
			}
		}
		foreach (Section section in sectionList)
		{
			foreach (UniversalClass derivedClass in section.DerivedClasses)
			{
				if (derivedClass.BaseClass is null)
				{
					derivedClass.BaseClass = section.Class;
					section.Class.DerivedClasses.Add(derivedClass);
				}
			}
		}
	}

	private static void ApplyApprovedFields(this List<Section> sectionList)
	{
		foreach (Section section in sectionList)
		{
			section.Class.InitializeRootNodes();
			foreach ((_, (UniversalNode? releaseNode, UniversalNode? editorNode)) in section.ApprovedFields)
			{
				if (releaseNode is not null)
				{
					section.Class.ReleaseRootNode!.SubNodes.Add(releaseNode);
				}
				if (editorNode is not null)
				{
					section.Class.EditorRootNode!.SubNodes.Add(editorNode);
				}
			}
		}
	}

	private static void InitializeRootNodes(this UniversalClass abstractClass)
	{
		abstractClass.EditorRootNode ??= new()
		{
			Name = "Base",
			OriginalName = "Base",
			TypeName = abstractClass.Name,
			SubNodes = new(),
			Version = 1,
		};
		abstractClass.ReleaseRootNode ??= new()
		{
			Name = "Base",
			OriginalName = "Base",
			TypeName = abstractClass.Name,
			SubNodes = new(),
			Version = 1,
		};
	}

	private static void UpdateWithSectionData(this VersionedList<UniversalClass> versionedList, List<Section> sectionList)
	{
		List<KeyValuePair<UnityVersion, UniversalClass?>> originalList = versionedList.ToList();
		versionedList.Clear();
		int i = 0, j = 0;
		while (i < originalList.Count || j < sectionList.Count)
		{
			(UnityVersion originalStart, UniversalClass? originalClass) = originalList[i];
			if (originalClass is null || !originalClass.IsAbstract)
			{
				versionedList.Add(originalStart, originalClass);
				i++;
			}
			else
			{
				UnityVersion originalEnd = i == originalList.Count - 1 ? UnityVersion.MaxVersion : originalList[i + 1].Key;
				Section currentSection = sectionList[j];
				if (originalEnd <= currentSection.Range.Start)
				{
					i++;
				}
				else if (originalStart <= currentSection.Range.Start && currentSection.Range.End <= originalEnd)
				{
					versionedList.Add(currentSection.Range.Start, currentSection.Class);
					j++;
					if (originalEnd == currentSection.Range.End)
					{
						i++;
					}
				}
				else
				{
					throw new InvalidOperationException();
				}
			}
		}
	}

	private static List<Section> GetMergedSections(List<Section> sectionList)
	{
		List<Section> mergedSections = new();
		Section currentSection = sectionList[0].Clone();

		for (int i = 1; i < sectionList.Count; i++)
		{
			Section nextSection = sectionList[i];
			if (CanBeMerged(currentSection, nextSection))
			{
				currentSection.Range = currentSection.Range.MakeUnion(nextSection.Range);
				currentSection.DerivedClasses.AddRange(nextSection.DerivedClasses);
			}
			else
			{
				mergedSections.Add(currentSection);
				currentSection = nextSection.Clone();
			}
		}
		mergedSections.Add(currentSection);

		return mergedSections;
	}

	private static void UnifySectionFields(List<Section> sections, RangeClassList rangeClassList)
	{
		foreach (string fieldName in rangeClassList.GetAllFieldNames())
		{
			int count = 0;
			double proportionSum = 0;
			foreach (Section section in sections)
			{
				if (section.HasField(fieldName, out float proportion))
				{
					count++;
					proportionSum += proportion;
				}
			}

			float averageProportion = (float)(proportionSum / count);
			if (averageProportion <= MinimumProportion)
			{
				continue;
			}

			bool useField = true;
			Dictionary<Section, (UniversalNode?, UniversalNode?)> nodeDictionary = new();
			foreach (Section section in sections)
			{
				if (!useField)
				{
					break;
				}
				UniversalNode? releaseNode = section.DerivedClasses
					.SelectMany(c => c.ReleaseRootNode?.SubNodes ?? Enumerable.Empty<UniversalNode>())
					.FirstOrDefault(n => n.Name == fieldName);
				if (releaseNode is not null)
				{
					foreach (UniversalClass derivedClass in section.DerivedClasses)
					{
						if (derivedClass.ReleaseRootNode is not null
							&& derivedClass.ReleaseRootNode.TryGetSubNodeByName(fieldName, out UniversalNode? derivedNode)
							&& !UniversalNodeComparer.Equals(releaseNode, derivedNode, false))
						{
							useField = false;
							break;
						}
					}
				}
				UniversalNode? editorNode = section.DerivedClasses
					.SelectMany(c => c.EditorRootNode?.SubNodes ?? Enumerable.Empty<UniversalNode>())
					.FirstOrDefault(n => n.Name == fieldName);
				if (editorNode is not null)
				{
					foreach (UniversalClass derivedClass in section.DerivedClasses)
					{
						if (derivedClass.EditorRootNode is not null
							&& derivedClass.EditorRootNode.TryGetSubNodeByName(fieldName, out UniversalNode? derivedNode)
							&& !UniversalNodeComparer.Equals(editorNode, derivedNode, false))
						{
							useField = false;
							break;
						}
					}
				}

				nodeDictionary.Add(section, (releaseNode, editorNode));
			}

			if (useField)
			{
				foreach ((Section section, (UniversalNode?, UniversalNode?) pair) in nodeDictionary)
				{
					section.ApprovedFields.Add(fieldName, pair);
				}
			}
		}
	}

	private static List<Section> MakeSectionList(this RangeClassList rangeClassList)
	{
		List<UnityVersion> versions = rangeClassList.GetAllUnityVersions();
		Dictionary<UniversalClass, UnityVersionRange> derivedRangeDictionary = rangeClassList
						.SelectMany(pair => pair.Value.DerivedClasses)
						.Distinct()
						.ToDictionary(derived => derived, derived => GetRangeForClass(derived));
		List<Section> sections = new();

		int i = 0, j = 0;
		while (i < rangeClassList.Count && j < versions.Count)
		{
			UnityVersionRange originalRange = rangeClassList[i].Key;
			UnityVersion currentStart = versions[j];
			UnityVersion currentEnd = j == versions.Count - 1 ? UnityVersion.MaxVersion : versions[j + 1];
			if (currentEnd <= originalRange.Start)
			{
				j++;
			}
			else if (originalRange.End <= currentStart)
			{
				i++;
			}
			else if (originalRange.Start <= currentStart && currentEnd <= originalRange.End)
			{
				sections.Add(Section.Create(rangeClassList[i].Value, new UnityVersionRange(currentStart, currentEnd), derivedRangeDictionary));
				j++;
			}
			else
			{
				throw new InvalidOperationException();
			}
		}
		return sections;
	}

	private static HashSet<string> GetAllFieldNames(this RangeClassList rangeClassList)
	{
		HashSet<string> fieldNames = new();
		foreach ((_, UniversalClass universalClass) in rangeClassList)
		{
			foreach (UniversalClass derivedClass in universalClass.DerivedClasses)
			{
				if (derivedClass.ReleaseRootNode is not null)
				{
					foreach (UniversalNode subnode in derivedClass.ReleaseRootNode.SubNodes)
					{
						if (universalClass.ReleaseRootNode is null || !universalClass.ReleaseRootNode.TryGetSubNodeByName(subnode.Name, out _))
						{
							fieldNames.Add(subnode.Name);
						}
					}
				}
				if (derivedClass.EditorRootNode is not null)
				{
					foreach (UniversalNode subnode in derivedClass.EditorRootNode.SubNodes)
					{
						if (universalClass.EditorRootNode is null || !universalClass.EditorRootNode.TryGetSubNodeByName(subnode.Name, out _))
						{
							fieldNames.Add(subnode.Name);
						}
					}
				}
			}
		}
		return fieldNames;
	}

	private static List<UnityVersion> GetAllUnityVersions(this RangeClassList rangeClassList)
	{
		UnityVersion minimumVersion = rangeClassList[0].Key.Start;
		UnityVersion maximumVersion = rangeClassList[rangeClassList.Count - 1].Key.End;
		HashSet<UnityVersion> versionHashSet = new();
		foreach ((UnityVersionRange range, UniversalClass universalClass) in rangeClassList)
		{
			versionHashSet.Add(range.Start);
			versionHashSet.Add(range.End);
			foreach (UniversalClass derivedClass in universalClass.DerivedClasses)
			{
				UnityVersionRange derivedRange = GetRangeForClass(derivedClass);
				if (minimumVersion < derivedRange.Start)
				{
					versionHashSet.Add(derivedRange.Start);
				}
				if (derivedRange.End < maximumVersion)
				{
					versionHashSet.Add(derivedRange.End);
				}
			}
		}
		List<UnityVersion> versionList = new List<UnityVersion>(versionHashSet.Count);
		versionList.AddRange(versionHashSet);
		versionList.Sort();
		return versionList;
	}

	private static UnityVersionRange GetRangeForClass(UniversalClass universalClass)
	{
		return SharedState.Instance.ClassInformation[universalClass.TypeID].GetRangeForItem(universalClass);
	}

	private static RangeClassList MakeRangeClassList(this VersionedList<UniversalClass> abstractClassList)
	{
		RangeClassList result = new();
		for (int i = 0; i < abstractClassList.Count; i++)
		{
			UniversalClass? universalClass = abstractClassList[i].Value;
			if (universalClass is not null && universalClass.IsAbstract)
			{
				result.Add(new KeyValuePair<UnityVersionRange, UniversalClass>(abstractClassList.GetRange(i), universalClass));
			}
		}
		return result;
	}

	private static bool AnyDerivedAbstractAndUnprocessed(this VersionedList<UniversalClass> abstractClassList)
	{
		return abstractClassList
			.Select(pair => pair.Value)
			.Where(universalClass => universalClass is not null && universalClass.IsAbstract)
			.SelectMany(universalClass => universalClass!.DerivedClasses)
			.Any(derivedClass => derivedClass.IsAbstract && !processedClasses.Contains(derivedClass.TypeID));
	}

	private static HashSet<int> GetAbstractClassIds()
	{
		return SharedState.Instance.ClassInformation
			.Where(dictPair => dictPair.Value.Any(listPair => listPair.Value?.IsAbstract ?? false))
			.Select(pair => pair.Key)
			.ToHashSet();
	}

	private static void AssignInheritance()
	{
		foreach ((_, VersionedList<UniversalClass> list) in SharedState.Instance.ClassInformation)
		{
			foreach ((UnityVersion startVersion, UniversalClass? universalClass) in list)
			{
				if (!string.IsNullOrEmpty(universalClass?.BaseString))
				{
					UniversalClass baseClass = GetClass(universalClass.BaseString, startVersion);
					universalClass.BaseClass = baseClass;
					baseClass.DerivedClasses.Add(universalClass);
				}
			}
		}
	}

	private static UniversalClass GetClass(string name, UnityVersion version)
	{
		return SharedState.Instance.NameToTypeID[name]
			.Select(id => SharedState.Instance.ClassInformation[id].TryFindMatch(name, version))
			.Where(c => c is not null)
			.Single()!;
	}

	private static UniversalClass? TryFindMatch(this VersionedList<UniversalClass> list, string name, UnityVersion version)
	{
		UniversalClass? result = list.GetItemForVersion(version);
		return result is not null && result.Name == name ? result : null;
	}

	private static bool CanBeMerged(Section section1, Section section2)
	{
		if (!section1.Class.Equals(section2.Class))
		{
			return false;
		}
		else if (!section1.Range.CanUnion(section2.Range))
		{
			return false;
		}
		else if (section1.ApprovedFields.Count != section2.ApprovedFields.Count)
		{
			return false;
		}

		foreach ((string fieldName, (UniversalNode? releaseNode1, UniversalNode? editorNode1)) in section1.ApprovedFields)
		{
			if (section2.ApprovedFields.TryGetValue(fieldName, out (UniversalNode?, UniversalNode?) pair2))
			{
				if (!UniversalNodeComparer.Equals(releaseNode1, pair2.Item1, false))
				{
					return false;
				}
				if (!UniversalNodeComparer.Equals(editorNode1, pair2.Item2, false))
				{
					return false;
				}
			}
		}

		return true;
	}

	private static void AddRange<T>(this HashSet<T> hashset, IEnumerable<T> enumerable)
	{
		foreach (T item in enumerable)
		{
			hashset.Add(item);
		}
	}

	private class Section
	{
		public Section(UniversalClass @class, UnityVersionRange range, HashSet<UniversalClass> derivedClasses)
		{
			Class = @class;
			Range = range;
			DerivedClasses = derivedClasses;
		}

		public static Section Create(UniversalClass @class, UnityVersionRange range, Dictionary<UniversalClass, UnityVersionRange> dictionary)
		{
			HashSet<UniversalClass> derivedClasses = @class.DerivedClasses.Where(derived => dictionary[derived].Contains(range)).ToHashSet();
			return new Section(@class, range, derivedClasses);
		}

		public UniversalClass Class { get; set; }
		public UnityVersionRange Range { get; set; }
		public HashSet<UniversalClass> DerivedClasses { get; }
		/// <summary>
		/// FieldName : (ReleaseNode?, EditorNode?)
		/// </summary>
		public Dictionary<string, (UniversalNode?, UniversalNode?)> ApprovedFields { get; } = new();

		public Section Clone()
		{
			HashSet<UniversalClass> newDerivedClasses = new(DerivedClasses.Count);
			newDerivedClasses.AddRange(DerivedClasses);
			Section newSection = new Section(Class, Range, newDerivedClasses);
			foreach ((string fieldName, (UniversalNode?, UniversalNode?) pair) in ApprovedFields)
			{
				newSection.ApprovedFields.Add(fieldName, pair);
			}
			return newSection;
		}

		public bool HasField(string fieldName, out float proportion)
		{
			int sum = 0;
			foreach (UniversalClass derivedClass in DerivedClasses)
			{
				if (derivedClass.ReleaseRootNode?.TryGetSubNodeByName(fieldName) is not null
					|| derivedClass.EditorRootNode?.TryGetSubNodeByName(fieldName) is not null)
				{
					sum++;
				}
			}
			proportion = (float)sum / DerivedClasses.Count;
			return sum > 0;
		}

		public override string ToString()
		{
			return $"{Class.Name} {Range}";
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass007_ExtractSubclasses.ClassData.cs`:

```cs
using AssetRipper.Numerics;

namespace AssetRipper.AssemblyDumper.Passes;

internal static partial class Pass007_ExtractSubclasses
{
	private readonly struct ClassData
	{
		public readonly string Name;
		public readonly UniversalClass Class;
		public readonly UnityVersionRange VersionRange;

		public ClassData(string name, UniversalClass @class, Range<UnityVersion> versionRange)
		{
			Name = name;
			Class = @class;
			VersionRange = versionRange;
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass007_ExtractSubclasses.Injections.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.IO.Files.SerializedFiles;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Passes;

internal static partial class Pass007_ExtractSubclasses
{
	private static void DoCustomInjections()
	{
		InjectLayerMask();
		InjectRectInt();
		InjectRectOffset();
		InjectAABBInt();
		InjectGUIStyleState();
		InjectGUIStyle();
		InjectStreamedCurveKey();
		InjectStreamedFrame();
	}

	private static void InjectLayerMask()
	{
		const string ClassName = "LayerMask";
		VersionedList<UniversalClass> classList = new();
		SharedState.Instance.SubclassInformation.Add(ClassName, classList);
		UniversalNode releaseNode = MakeRootNode();
		UniversalNode editorNode = MakeRootNode();
		UniversalClass @class = new UniversalClass(releaseNode, editorNode);
		classList.Add(SharedState.Instance.MinVersion, @class);

		static UniversalNode MakeRootNode()
		{
			UniversalNode rootNode = new()
			{
				Name = "Base",
				TypeName = ClassName,
				Version = 2,//1 before 2.0.0
				MetaFlag = TransferMetaFlags.NoTransferFlags,
			};
			rootNode.SubNodes.Add(new()
			{
				Name = "m_Bits",
				TypeName = "UInt32",//UInt16 before 2.0.0
				Version = 1,
				MetaFlag = TransferMetaFlags.NoTransferFlags,
			});
			return rootNode;
		}
	}

	private static void InjectRectInt()
	{
		const string ClassName = "RectInt";
		VersionedList<UniversalClass> classList = new();
		SharedState.Instance.SubclassInformation.Add(ClassName, classList);
		UniversalNode releaseNode = MakeRootNode();
		UniversalNode editorNode = MakeRootNode();
		UniversalClass @class = new UniversalClass(releaseNode, editorNode);
		classList.Add(SharedState.Instance.MinVersion, @class);

		static UniversalNode MakeRootNode()
		{
			UniversalNode rootNode = CreateRootNode(ClassName, 2);
			rootNode.SubNodes.Add(CreateInt32Node("m_X", "x"));
			rootNode.SubNodes.Add(CreateInt32Node("m_Y", "y"));
			rootNode.SubNodes.Add(CreateInt32Node("m_Width", "width"));
			rootNode.SubNodes.Add(CreateInt32Node("m_Height", "height"));
			return rootNode;
		}
	}

	private static void InjectRectOffset()
	{
		const string ClassName = "RectOffset";
		VersionedList<UniversalClass> classList = new();
		SharedState.Instance.SubclassInformation.Add(ClassName, classList);
		UniversalNode releaseNode = MakeRootNode();
		UniversalNode editorNode = MakeRootNode();
		UniversalClass @class = new UniversalClass(releaseNode, editorNode);
		classList.Add(SharedState.Instance.MinVersion, @class);

		static UniversalNode MakeRootNode()
		{
			UniversalNode rootNode = CreateRootNode(ClassName);
			rootNode.SubNodes.Add(CreateInt32Node("m_Left"));
			rootNode.SubNodes.Add(CreateInt32Node("m_Right"));
			rootNode.SubNodes.Add(CreateInt32Node("m_Top"));
			rootNode.SubNodes.Add(CreateInt32Node("m_Bottom"));
			return rootNode;
		}
	}

	private static void InjectAABBInt()
	{
		VersionedList<UniversalClass> vector3IntList = SharedState.Instance.SubclassInformation["Vector3Int"];
		VersionedList<UniversalClass> classList = new();
		const string ClassName = "AABBInt";
		SharedState.Instance.SubclassInformation.Add(ClassName, classList);
		foreach ((UnityVersion version, UniversalClass? vectorClass) in vector3IntList)
		{
			if (vectorClass is null)
			{
				classList.Add(version, null);
			}
			else
			{
				UniversalNode releaseNode;
				{
					releaseNode = new()
					{
						Name = "Base",
						TypeName = ClassName,
						Version = 1,
						MetaFlag = TransferMetaFlags.NoTransferFlags,
					};
					UniversalNode centerNode = vectorClass.ReleaseRootNode!.DeepClone();
					centerNode.Name = centerNode.OriginalName = "m_Center";
					releaseNode.SubNodes.Add(centerNode);

					UniversalNode extentNode = vectorClass.ReleaseRootNode!.DeepClone();
					extentNode.Name = extentNode.OriginalName = "m_Extent";
					releaseNode.SubNodes.Add(extentNode);
				}
				UniversalNode editorNode;
				{
					editorNode = new()
					{
						Name = "Base",
						TypeName = ClassName,
						Version = 1,
						MetaFlag = TransferMetaFlags.NoTransferFlags,
					};
					UniversalNode centerNode = vectorClass.EditorRootNode!.DeepClone();
					centerNode.Name = centerNode.OriginalName = "m_Center";
					editorNode.SubNodes.Add(centerNode);

					UniversalNode extentNode = vectorClass.EditorRootNode!.DeepClone();
					extentNode.Name = extentNode.OriginalName = "m_Extent";
					editorNode.SubNodes.Add(extentNode);
				}
				UniversalClass @class = new UniversalClass(releaseNode, editorNode);
				classList.Add(version, @class);
			}
		}
	}

	private static void InjectGUIStyleState()
	{
		VersionedList<UniversalClass> pptrTexture2DList = SharedState.Instance.SubclassInformation["PPtr_Texture2D"];
		VersionedList<UniversalClass> colorList = SharedState.Instance.SubclassInformation["ColorRGBAf"];
		Debug.Assert(pptrTexture2DList.Count == 2);
		Debug.Assert(colorList.Count == 1);

		const string ClassName = "GUIStyleState";
		VersionedList<UniversalClass> classList = new();
		SharedState.Instance.SubclassInformation.Add(ClassName, classList);

		(UnityVersion versionC, UniversalClass? colorClass) = colorList[0];
		(UnityVersion versionP1, UniversalClass? pptrClass1) = pptrTexture2DList[0];
		(UnityVersion versionP2, UniversalClass? pptrClass2) = pptrTexture2DList[1];
		Debug.Assert(versionC == SharedState.Instance.MinVersion);
		Debug.Assert(versionC == versionP1);
		Debug.Assert(versionC < versionP2);

		UniversalNode releaseRoot1 = CreateRootNode(ClassName);
		releaseRoot1.SubNodes.Add(pptrClass1!.ReleaseRootNode!.DeepCloneAndChangeName("m_Background"));
		releaseRoot1.SubNodes.Add(colorClass!.ReleaseRootNode!.DeepCloneAndChangeName("m_TextColor"));
		UniversalNode editorRoot1 = CreateRootNode(ClassName);
		editorRoot1.SubNodes.Add(pptrClass1!.EditorRootNode!.DeepCloneAndChangeName("m_Background"));
		editorRoot1.SubNodes.Add(colorClass!.EditorRootNode!.DeepCloneAndChangeName("m_TextColor"));
		classList.Add(versionC, new UniversalClass(releaseRoot1, editorRoot1));

		UniversalNode releaseRoot2 = CreateRootNode(ClassName);
		releaseRoot2.SubNodes.Add(pptrClass2!.ReleaseRootNode!.DeepCloneAndChangeName("m_Background"));
		releaseRoot2.SubNodes.Add(colorClass!.ReleaseRootNode!.DeepCloneAndChangeName("m_TextColor"));
		UniversalNode editorRoot2 = CreateRootNode(ClassName);
		editorRoot2.SubNodes.Add(pptrClass2!.EditorRootNode!.DeepCloneAndChangeName("m_Background"));
		editorRoot2.SubNodes.Add(colorClass!.EditorRootNode!.DeepCloneAndChangeName("m_TextColor"));
		classList.Add(versionP2, new UniversalClass(releaseRoot2, editorRoot2));

		UniversalNode releaseRoot3 = CreateRootNode(ClassName);
		releaseRoot3.SubNodes.Add(pptrClass2!.ReleaseRootNode!.DeepCloneAndChangeName("m_Background"));
		releaseRoot3.SubNodes.Add(colorClass!.ReleaseRootNode!.DeepCloneAndChangeName("m_TextColor"));
		UniversalNode editorRoot3 = CreateRootNode(ClassName);
		editorRoot3.SubNodes.Add(pptrClass2!.EditorRootNode!.DeepCloneAndChangeName("m_Background"));
		editorRoot3.SubNodes.Add(CreateArrayNode("m_ScaledBackgrounds", pptrClass2!.EditorRootNode!.DeepClone(), false));
		editorRoot3.SubNodes.Add(colorClass!.EditorRootNode!.DeepCloneAndChangeName("m_TextColor"));
		classList.Add(new UnityVersion(5, 4, 0), new UniversalClass(releaseRoot3, editorRoot3));

		UniversalNode releaseRoot4 = CreateRootNode(ClassName);
		releaseRoot4.SubNodes.Add(pptrClass2!.ReleaseRootNode!.DeepCloneAndChangeName("m_Background"));
		releaseRoot4.SubNodes.Add(colorClass!.ReleaseRootNode!.DeepCloneAndChangeName("m_TextColor"));
		UniversalNode editorRoot4 = CreateRootNode(ClassName);
		editorRoot4.SubNodes.Add(pptrClass2!.EditorRootNode!.DeepCloneAndChangeName("m_Background"));
		editorRoot4.SubNodes.Add(CreateArrayNode("m_ScaledBackgrounds", pptrClass2!.EditorRootNode!.DeepClone(), true));
		editorRoot4.SubNodes.Add(colorClass!.EditorRootNode!.DeepCloneAndChangeName("m_TextColor"));
		classList.Add(ArrayAlignmentStartVersion, new UniversalClass(releaseRoot4, editorRoot4));
	}

	private static void InjectGUIStyle()
	{
		UnityVersion builtInVersion = new UnityVersion(4, 0, 0);
		VersionedList<UniversalClass> pptrFontList = SharedState.Instance.SubclassInformation["PPtr_Font"];
		VersionedList<UniversalClass> stateList = SharedState.Instance.SubclassInformation["GUIStyleState"];
		UniversalNode stringTemplate = SharedState.Instance.ClassInformation[1][^1].Value!.ReleaseRootNode!.GetSubNodeByName("m_Name");
		VersionedList<UniversalClass> rectOffsetList = SharedState.Instance.SubclassInformation["RectOffset"];
		VersionedList<UniversalClass> vectorList = SharedState.Instance.SubclassInformation["Vector2f"];
		Debug.Assert(pptrFontList.Count == 2);
		Debug.Assert(stateList.Count == 4);

		const string ClassName = "GUIStyle";
		VersionedList<UniversalClass> classList = new();
		SharedState.Instance.SubclassInformation.Add(ClassName, classList);

		UnityVersion versionS1 = stateList[0].Key;
		UnityVersion versionP1 = pptrFontList[0].Key;
		Debug.Assert(versionS1 == versionP1);
		Debug.Assert(versionS1 == SharedState.Instance.MinVersion);
		Debug.Assert(versionS1 < builtInVersion);

		UnityVersion versionP2 = pptrFontList[1].Key;
		UnityVersion versionS2 = stateList[1].Key;
		UnityVersion versionS3 = stateList[2].Key;
		UnityVersion versionS4 = stateList[3].Key;
		Debug.Assert(versionS2 == versionP2);
		Debug.Assert(versionS2 > builtInVersion);

		List<UnityVersion> versions = new()
		{
			versionS1,
			builtInVersion,
			versionS2,
			versionS3,
			versionS4,
		};

		foreach (UnityVersion version in versions)
		{
			UniversalNode releaseRoot = CreateRootNode(ClassName);
			UniversalNode editorRoot = CreateRootNode(ClassName);

			AddSubNodeClone(releaseRoot, editorRoot, stringTemplate, "m_Name");
			AddSubNode(releaseRoot, editorRoot, stateList, version, "m_Normal");
			AddSubNode(releaseRoot, editorRoot, stateList, version, "m_Hover");
			AddSubNode(releaseRoot, editorRoot, stateList, version, "m_Active");
			AddSubNode(releaseRoot, editorRoot, stateList, version, "m_Focused");
			AddSubNode(releaseRoot, editorRoot, stateList, version, "m_OnNormal");
			AddSubNode(releaseRoot, editorRoot, stateList, version, "m_OnHover");
			AddSubNode(releaseRoot, editorRoot, stateList, version, "m_OnActive");
			AddSubNode(releaseRoot, editorRoot, stateList, version, "m_OnFocused");
			AddSubNode(releaseRoot, editorRoot, rectOffsetList, version, "m_Border");
			if (IsBuiltinFormat(version))
			{
				AddSubNode(releaseRoot, editorRoot, rectOffsetList, version, "m_Margin");
				AddSubNode(releaseRoot, editorRoot, rectOffsetList, version, "m_Padding");
			}
			else
			{
				AddSubNode(releaseRoot, editorRoot, rectOffsetList, version, "m_Padding");
				AddSubNode(releaseRoot, editorRoot, rectOffsetList, version, "m_Margin");
			}
			AddSubNode(releaseRoot, editorRoot, rectOffsetList, version, "m_Overflow");
			AddSubNode(releaseRoot, editorRoot, pptrFontList, version, "m_Font");
			if (IsBuiltinFormat(version))
			{
				AddInt32SubNode(releaseRoot, editorRoot, "m_FontSize");
				AddInt32SubNode(releaseRoot, editorRoot, "m_FontStyle");
				AddInt32SubNode(releaseRoot, editorRoot, "m_Alignment");
				AddBooleanSubNode(releaseRoot, editorRoot, "m_WordWrap", false);
				AddBooleanSubNode(releaseRoot, editorRoot, "m_RichText", true);

				AddInt32SubNode(releaseRoot, editorRoot, "m_TextClipping");
				AddInt32SubNode(releaseRoot, editorRoot, "m_ImagePosition");
				AddSubNode(releaseRoot, editorRoot, vectorList, version, "m_ContentOffset");
				AddSingleSubNode(releaseRoot, editorRoot, "m_FixedWidth");
				AddSingleSubNode(releaseRoot, editorRoot, "m_FixedHeight");
				AddBooleanSubNode(releaseRoot, editorRoot, "m_StretchWidth", false);
				AddBooleanSubNode(releaseRoot, editorRoot, "m_StretchHeight", true);
			}
			else
			{
				AddInt32SubNode(releaseRoot, editorRoot, "m_ImagePosition");
				AddInt32SubNode(releaseRoot, editorRoot, "m_Alignment");
				AddBooleanSubNode(releaseRoot, editorRoot, "m_WordWrap", true);

				AddInt32SubNode(releaseRoot, editorRoot, "m_TextClipping");
				AddSubNode(releaseRoot, editorRoot, vectorList, version, "m_ContentOffset");
				AddSubNode(releaseRoot, editorRoot, vectorList, version, "m_ClipOffset");
				AddSingleSubNode(releaseRoot, editorRoot, "m_FixedWidth");
				AddSingleSubNode(releaseRoot, editorRoot, "m_FixedHeight");
				if (HasFontSize(version))
				{
					AddInt32SubNode(releaseRoot, editorRoot, "m_FontSize");
					AddInt32SubNode(releaseRoot, editorRoot, "m_FontStyle");
				}
				AddBooleanSubNode(releaseRoot, editorRoot, "m_StretchWidth", true);
				AddBooleanSubNode(releaseRoot, editorRoot, "m_StretchHeight", true);
			}

			classList.Add(version, new UniversalClass(releaseRoot, editorRoot));
		}

		static void AddSubNodeClone(UniversalNode releaseRoot, UniversalNode editorRoot, UniversalNode sourceNode, string name)
		{
			releaseRoot.SubNodes.Add(sourceNode.DeepCloneAndChangeName(name));
			editorRoot.SubNodes.Add(sourceNode.DeepCloneAndChangeName(name));
		}
	}

	private static void InjectStreamedCurveKey()
	{
		VersionedList<UniversalClass> vectorList = SharedState.Instance.SubclassInformation["Vector3f"];

		UnityVersion startVersion = vectorList[0].Key;

		const string ClassName = "StreamedCurveKey";
		VersionedList<UniversalClass> classList = new();
		SharedState.Instance.SubclassInformation.Add(ClassName, classList);

		UniversalNode releaseRoot = CreateRootNode(ClassName);
		UniversalNode editorRoot = CreateRootNode(ClassName);

		AddInt32SubNode(releaseRoot, editorRoot, "m_Index");
		AddSubNode(releaseRoot, editorRoot, vectorList, startVersion, "m_Coefficient");
		AddSingleSubNode(releaseRoot, editorRoot, "m_Value");

		classList.Add(startVersion, new UniversalClass(releaseRoot, editorRoot));
	}

	private static void InjectStreamedFrame()
	{
		VersionedList<UniversalClass> curveKeyList = SharedState.Instance.SubclassInformation["StreamedCurveKey"];

		const string ClassName = "StreamedFrame";
		VersionedList<UniversalClass> classList = new();
		SharedState.Instance.SubclassInformation.Add(ClassName, classList);

		List<UnityVersion> versions = new()
		{
			curveKeyList[0].Key,
			ArrayAlignmentStartVersion,
		};

		foreach (UnityVersion version in versions)
		{
			UniversalNode releaseRoot = CreateRootNode(ClassName);
			UniversalNode editorRoot = CreateRootNode(ClassName);

			AddSingleSubNode(releaseRoot, editorRoot, "m_Time");

			releaseRoot.SubNodes.Add(CreateArrayNode("m_Curves", curveKeyList[0].Value!.ReleaseRootNode!.DeepClone(), version));
			editorRoot.SubNodes.Add(CreateArrayNode("m_Curves", curveKeyList[0].Value!.EditorRootNode!.DeepClone(), version));

			classList.Add(version, new UniversalClass(releaseRoot, editorRoot));
		}
	}

	private static UniversalNode DeepCloneAndChangeName(this UniversalNode node, string name)
	{
		UniversalNode result = node.DeepClone();
		result.OriginalName = result.Name = name;
		return result;
	}

	private static UniversalNode CreateRootNode(string className, short version = 1)
	{
		return new()
		{
			Name = "Base",
			TypeName = className,
			Version = version,
			MetaFlag = TransferMetaFlags.NoTransferFlags,
		};
	}

	private static UniversalNode CreateInt32Node(string name)
	{
		return new()
		{
			Name = name,
			TypeName = "SInt32",
			Version = 1,
			MetaFlag = TransferMetaFlags.NoTransferFlags,
		};
	}

	private static UniversalNode CreateInt32Node(string name, string originalName)
	{
		UniversalNode result = CreateInt32Node(name);
		result.OriginalName = originalName;
		return result;
	}

	private static UniversalNode CreateSingleNode(string name)
	{
		return new()
		{
			Name = name,
			TypeName = "float",
			Version = 1,
			MetaFlag = TransferMetaFlags.NoTransferFlags,
		};
	}

	private static UniversalNode CreateBooleanNode(string name, bool align)
	{
		return new()
		{
			Name = name,
			TypeName = "bool",
			Version = 1,
			MetaFlag = align ? TransferMetaFlags.AlignBytes : TransferMetaFlags.NoTransferFlags,
		};
	}

	private static UniversalNode CreateArrayNode(string name, UniversalNode dataNode, bool align)
	{
		UniversalNode arrayNode = new()
		{
			Name = name,
			TypeName = "Array",
			Version = 1,
			MetaFlag = align ? TransferMetaFlags.AlignBytes : TransferMetaFlags.NoTransferFlags,
		};
		arrayNode.SubNodes.Add(new()
		{
			Name = "size",
			TypeName = "SInt32",
			Version = 1,
			MetaFlag = TransferMetaFlags.NoTransferFlags,
		});
		dataNode.Name = "m_Data";
		dataNode.OriginalName = "data";
		arrayNode.SubNodes.Add(dataNode);
		return arrayNode;
	}

	private static UniversalNode CreateArrayNode(string name, UniversalNode dataNode, UnityVersion version)
	{
		return CreateArrayNode(name, dataNode, version >= ArrayAlignmentStartVersion);
	}

	private static void AddSubNode(UniversalNode releaseRoot, UniversalNode editorRoot, VersionedList<UniversalClass> sourceList, UnityVersion version, string name)
	{
		releaseRoot.SubNodes.Add(sourceList.GetItemForVersion(version)!.ReleaseRootNode!.DeepCloneAndChangeName(name));
		editorRoot.SubNodes.Add(sourceList.GetItemForVersion(version)!.EditorRootNode!.DeepCloneAndChangeName(name));
	}

	private static void AddInt32SubNode(UniversalNode releaseRoot, UniversalNode editorRoot, string name)
	{
		releaseRoot.SubNodes.Add(CreateInt32Node(name));
		editorRoot.SubNodes.Add(CreateInt32Node(name));
	}

	private static void AddSingleSubNode(UniversalNode releaseRoot, UniversalNode editorRoot, string name)
	{
		releaseRoot.SubNodes.Add(CreateSingleNode(name));
		editorRoot.SubNodes.Add(CreateSingleNode(name));
	}

	private static void AddBooleanSubNode(UniversalNode releaseRoot, UniversalNode editorRoot, string name, bool align)
	{
		releaseRoot.SubNodes.Add(CreateBooleanNode(name, align));
		editorRoot.SubNodes.Add(CreateBooleanNode(name, align));
	}

	/// <summary>
	/// 4.0.0 and greater
	/// GUIStyle became builtin serializable only in v4.0.0
	/// </summary>
	private static bool IsBuiltinFormat(UnityVersion version) => version.GreaterThanOrEquals(4);
	/// <summary>
	/// 3.0.0 and greater
	/// </summary>
	private static bool HasFontSize(UnityVersion version) => version.GreaterThanOrEquals(3);
	private static UnityVersion ArrayAlignmentStartVersion { get; } = new UnityVersion(2017, 1);
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass007_ExtractSubclasses.SubclassCandidate.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.Numerics;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Passes;

internal static partial class Pass007_ExtractSubclasses
{
	private readonly struct SubclassCandidate
	{
		public readonly UniversalNode? ReleaseNode;
		public readonly UniversalNode? EditorNode;
		public readonly string Name;
		public readonly DiscontinuousRange<UnityVersion> VersionRange;
		public readonly UniversalNode[] NodesToBeAltered;

		public SubclassCandidate(UniversalNode? releaseNode, UniversalNode? editorNode, Range<UnityVersion> versionRange) : this()
		{
			if (releaseNode is null && editorNode is null)
			{
				throw new Exception("Release and editor can't both be null");
			}

			ReleaseNode = releaseNode;
			EditorNode = editorNode;
			VersionRange = versionRange;
			Name = releaseNode?.TypeName ?? editorNode?.TypeName ?? throw new Exception("All type names were null");
			if (releaseNode is null)
			{
				Debug.Assert(editorNode is not null);
				NodesToBeAltered = [editorNode];
			}
			else if (editorNode is null)
			{
				NodesToBeAltered = [releaseNode];
			}
			else
			{
				NodesToBeAltered = [releaseNode, editorNode];
			}
		}

		private SubclassCandidate(UniversalNode? releaseNode, UniversalNode? editorNode, string name, DiscontinuousRange<UnityVersion> versionRange, UniversalNode[] nodesToBeAltered)
		{
			if (releaseNode is null && editorNode is null)
			{
				throw new ArgumentException("Release and editor can't both be null");
			}

			ReleaseNode = releaseNode;
			EditorNode = editorNode;
			Name = name;
			VersionRange = versionRange;
			NodesToBeAltered = nodesToBeAltered;
		}

		public bool Contains(SubclassCandidate candidate)
		{
			return Name == candidate.Name &&
				VersionRange.Contains(candidate.VersionRange) &&
				(candidate.ReleaseNode is null || UniversalNodeComparer.Equals(ReleaseNode, candidate.ReleaseNode, true)) &&
				(candidate.EditorNode is null || UniversalNodeComparer.Equals(EditorNode, candidate.EditorNode, true));
		}

		public bool CanMerge(SubclassCandidate candidate)
		{
			return Name == candidate.Name &&
				UniversalNodeComparer.Equals(ReleaseNode, candidate.ReleaseNode, true) &&
				UniversalNodeComparer.Equals(EditorNode, candidate.EditorNode, true);
		}

		public bool CanMergeRelaxed(SubclassCandidate candidate)
		{
			return Name == candidate.Name &&
				(candidate.ReleaseNode is null || ReleaseNode is null || UniversalNodeComparer.Equals(ReleaseNode, candidate.ReleaseNode, true)) &&
				(candidate.EditorNode is null || EditorNode is null || UniversalNodeComparer.Equals(EditorNode, candidate.EditorNode, true));
		}

		public SubclassCandidate Merge(SubclassCandidate candidate)
		{
			UniversalNode[] nodes = new UniversalNode[NodesToBeAltered.Length + candidate.NodesToBeAltered.Length];
			Array.Copy(NodesToBeAltered, nodes, NodesToBeAltered.Length);
			Array.Copy(candidate.NodesToBeAltered, 0, nodes, NodesToBeAltered.Length, candidate.NodesToBeAltered.Length);
			DiscontinuousRange<UnityVersion> range = VersionRange.Union(candidate.VersionRange);
			return new SubclassCandidate(ReleaseNode ?? candidate.ReleaseNode, EditorNode ?? candidate.EditorNode, Name, range, nodes);
		}

		internal UniversalClass ToUniversalClass()
		{
			return new UniversalClass(ReleaseNode?.ShallowCloneAsRootNode(), EditorNode?.ShallowCloneAsRootNode());
		}

		public override string ToString()
		{
			return $"{Name} ({VersionRange})";
		}
	}

	private static void AddClassesToSharedStateSubclasses(List<SubclassCandidate> unprocessedList)
	{
		List<SubclassCandidate> consolidatedCandidates = ProcessList(unprocessedList);
		if (consolidatedCandidates.Count == 0)
		{
			throw new Exception("Candidate count can't be zero");
		}
		else if (consolidatedCandidates.Count == 1)
		{
			//Single class, don't change the name
			SubclassCandidate candidate = consolidatedCandidates[0];
			VersionedList<UniversalClass> classList = new();
			SharedState.Instance.SubclassInformation.Add(candidate.Name, classList);
			DiscontinuousRange<UnityVersion> versionRange = candidate.VersionRange;
			classList.Add(versionRange[0].Start, candidate.ToUniversalClass());
			UnityVersion end = versionRange[versionRange.Count - 1].End;
			if (end != UnityVersion.MaxVersion)
			{
				classList.Add(end, null);
			}
		}
		else if (AnyIntersections(consolidatedCandidates))
		{
			Console.WriteLine($"Using conflict naming for {consolidatedCandidates[0].Name}");
			//Use _2 naming
			for (int i = 0; i < consolidatedCandidates.Count; i++)
			{
				SubclassCandidate candidate = consolidatedCandidates[i];
				string typeName = $"{candidate.Name}_{i}";
				VersionedList<UniversalClass> classList = new();
				SharedState.Instance.SubclassInformation.Add(typeName, classList);
				foreach (UniversalNode node in candidate.NodesToBeAltered)
				{
					node.TypeName = typeName;
				}
				DiscontinuousRange<UnityVersion> versionRange = candidate.VersionRange;
				classList.Add(versionRange[0].Start, candidate.ToUniversalClass());
				UnityVersion end = versionRange[versionRange.Count - 1].End;
				if (end != UnityVersion.MaxVersion)
				{
					classList.Add(end, null);
				}
				else if (candidate.Name.StartsWith("PPtr"))
				{
					Console.WriteLine($"{candidate.Name} has unresolved conflicts and has no end version");
				}
			}
		}
		else
		{
			//Use _3_4_0f5 naming
			VersionedList<UniversalClass> classList = new();
			SharedState.Instance.SubclassInformation.Add(consolidatedCandidates[0].Name, classList);

			HashSet<UnityVersion> startSet = new();
			HashSet<UnityVersion> combinedSet = new();
			foreach (SubclassCandidate candidate in consolidatedCandidates)
			{
				foreach (UnityVersionRange range in candidate.VersionRange)
				{
					startSet.Add(range.Start);
					combinedSet.Add(range.Start);
					combinedSet.Add(range.End);
				}
			}

			List<(UnityVersion, SubclassCandidate?)> orderedVersions = new(combinedSet.Count);
			foreach (UnityVersion version in combinedSet.Order())
			{
				if (startSet.Contains(version))
				{
					SubclassCandidate? candidate = consolidatedCandidates.First(c => c.VersionRange.Contains(version));
					orderedVersions.Add((version, candidate));
				}
				else if (version != UnityVersion.MaxVersion)
				{
					orderedVersions.Add((version, null));
				}
			}
			SubclassCandidate? previousCandidate = default;//Always not null
			for (int i = 0; i < orderedVersions.Count; i++)
			{
				(UnityVersion version, SubclassCandidate? candidate) = orderedVersions[i];
				bool shouldAdd;
				if (i == 0)
				{
					//This is the first candidate.
					Debug.Assert(previousCandidate is null);
					shouldAdd = true;
					previousCandidate = candidate;
				}
				else if (candidate is null)
				{
					Debug.Assert(previousCandidate is not null);
					if (i < orderedVersions.Count - 1)
					{
						//This is null and not the end. Therefore, it's between two not null candidates.
						//If those candidates are the same, we don't add this.
						//The array is used for an efficient reference equality comparison.
						shouldAdd = orderedVersions[i + 1].Item2?.NodesToBeAltered != previousCandidate?.NodesToBeAltered;
					}
					else
					{
						//This is the last version.
						shouldAdd = true;
					}
				}
				else
				{
					//We only add if this candidate is different from the previous one.
					//The array is used for an efficient reference equality comparison.
					Debug.Assert(previousCandidate is not null);
					shouldAdd = candidate?.NodesToBeAltered != previousCandidate?.NodesToBeAltered;
					previousCandidate = candidate;
				}
				if (shouldAdd)
				{
					classList.Add(version, candidate?.ToUniversalClass());
				}
			}
		}
	}

	private static bool AnyIntersections(List<SubclassCandidate> consolidatedCandidates)
	{
		for (int i = 0; i < consolidatedCandidates.Count; i++)
		{
			for (int j = i + 1; j < consolidatedCandidates.Count; j++)
			{
				if (consolidatedCandidates[i].VersionRange.Intersects(consolidatedCandidates[j].VersionRange))
				{
					Console.WriteLine($"{consolidatedCandidates[i].VersionRange} intersects with {consolidatedCandidates[j].VersionRange}");
					return true;
				}
			}
		}
		return false;
	}

	private static List<SubclassCandidate> ProcessList(List<SubclassCandidate> unprocessedList)
	{
		SplitByNullability(unprocessedList, out List<SubclassCandidate> bothList, out List<SubclassCandidate> releaseList, out List<SubclassCandidate> editorList);
		bothList = GetConsolidatedList(bothList);
		MergeIntoBothList(bothList, releaseList);
		MergeIntoBothList(bothList, editorList);
		releaseList = GetConsolidatedList(releaseList);
		editorList = GetConsolidatedList(editorList);
		FinalMergeAttempts(bothList, releaseList, editorList);
		List<SubclassCandidate> unifiedList = new List<SubclassCandidate>(bothList.Count + releaseList.Count + editorList.Count);
		unifiedList.AddRange(bothList);
		unifiedList.AddRange(releaseList);
		unifiedList.AddRange(editorList);
		return unifiedList;
	}

	private static void SplitByNullability(List<SubclassCandidate> inputList,
		out List<SubclassCandidate> bothList,
		out List<SubclassCandidate> releaseList,
		out List<SubclassCandidate> editorList)
	{
		bothList = inputList.Where(c => c.EditorNode is not null && c.ReleaseNode is not null).ToList();
		releaseList = inputList.Where(c => c.EditorNode is null && c.ReleaseNode is not null).ToList();
		editorList = inputList.Where(c => c.EditorNode is not null && c.ReleaseNode is null).ToList();
	}

	private static bool TryMergeClasses(List<SubclassCandidate> inputList, out List<SubclassCandidate> outputList)
	{
		outputList = new();
		bool result = false;
		foreach (SubclassCandidate candidate in inputList)
		{
			bool merged = false;
			for (int i = 0; i < outputList.Count; i++)
			{
				if (outputList[i].CanMerge(candidate))
				{
					result = true;
					merged = true;
					outputList[i] = outputList[i].Merge(candidate);
					break;
				}
			}
			if (!merged)
			{
				outputList.Add(candidate);
			}
		}
		return result;
	}

	private static List<SubclassCandidate> GetConsolidatedList(List<SubclassCandidate> inputList)
	{
		List<SubclassCandidate> outputList = inputList;
		bool shouldTryAgain = true;
		while (shouldTryAgain)
		{
			shouldTryAgain = TryMergeClasses(outputList, out List<SubclassCandidate> newOutput);
			outputList = newOutput;
		}
		return outputList;
	}

	private static void MergeIntoBothList(List<SubclassCandidate> bothList, List<SubclassCandidate> singleList)
	{
		List<SubclassCandidate> leftovers = new();
		foreach (SubclassCandidate singleCandidate in singleList)
		{
			bool successful = false;
			for (int i = 0; i < bothList.Count; i++)
			{
				if (bothList[i].Contains(singleCandidate))
				{
					successful = true;
					bothList[i] = bothList[i].Merge(singleCandidate);
					break;
				}
			}
			if (!successful)
			{
				leftovers.Add(singleCandidate);
			}
		}
		singleList.Clear();
		singleList.Capacity = leftovers.Count;
		singleList.AddRange(leftovers);
	}

	private static void FinalMergeAttempts(List<SubclassCandidate> bothList, List<SubclassCandidate> releaseList, List<SubclassCandidate> editorList)
	{
		if (bothList.Count == 0)
		{
			if (releaseList.Count == 1 && editorList.Count == 1)
			{
				SubclassCandidate releaseCandidate = releaseList[0];
				SubclassCandidate editorCandidate = editorList[0];
				if (releaseCandidate.Name == editorCandidate.Name
					&& AreCompatible(releaseCandidate.ReleaseNode!, editorCandidate.EditorNode!, true))
				{
					SubclassCandidate mergedCandidate = releaseCandidate.Merge(editorCandidate);
					releaseList.Clear();
					editorList.Clear();
					bothList.Add(mergedCandidate);
				}
			}
		}
		else if (bothList.Count == 1)
		{
			if (releaseList.Count == 1 && editorList.Count == 0)
			{
				SubclassCandidate releaseCandidate = releaseList[0];
				SubclassCandidate bothCandidate = bothList[0];
				if (bothCandidate.CanMergeRelaxed(releaseCandidate))
				{
					SubclassCandidate mergedCandidate = bothCandidate.Merge(releaseCandidate);
					releaseList.Clear();
					bothList[0] = mergedCandidate;
				}
			}
			else if (releaseList.Count == 0 && editorList.Count == 1)
			{
				SubclassCandidate editorCandidate = editorList[0];
				SubclassCandidate bothCandidate = bothList[0];
				if (bothCandidate.CanMergeRelaxed(editorCandidate))
				{
					SubclassCandidate mergedCandidate = bothCandidate.Merge(editorCandidate);
					editorList.Clear();
					bothList[0] = mergedCandidate;
				}
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass007_ExtractSubclasses.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;

namespace AssetRipper.AssemblyDumper.Passes;

internal static partial class Pass007_ExtractSubclasses
{
	private static Dictionary<string, List<SubclassCandidate>> candidateListDictionary = new();

	public static void DoPass()
	{
		foreach (VersionedList<UniversalClass> classList in SharedState.Instance.ClassInformation.Values)
		{
			List<ClassData> classDataList = MakeClassData(classList);
			foreach (ClassData classData in classDataList)
			{
				AddDependentTypes(classData);
			}
		}
		foreach (List<SubclassCandidate> candidateList in candidateListDictionary.Values)
		{
			AddClassesToSharedStateSubclasses(candidateList);
		}
		candidateListDictionary.Clear();
		CheckCompatibility();
		DoCustomInjections();
	}

	private static void CheckCompatibility()
	{
		foreach (VersionedList<UniversalClass> list in SharedState.Instance.SubclassInformation.Values)
		{
			foreach (UniversalClass? @class in list.Values)
			{
				if (@class is not null && !AreCompatibleWithLogging(@class.ReleaseRootNode, @class.EditorRootNode))
				{
					Console.WriteLine($"{@class.Name} has incompatible release and editor root nodes");
				}
			}
		}
	}

	private static List<ClassData> MakeClassData(VersionedList<UniversalClass> list)
	{
		List<ClassData> result = new List<ClassData>(list.Count);
		for (int i = 0; i < list.Count - 1; i++)
		{
			if (list[i].Value is not null)
			{
				result.Add(new ClassData(list[i].Value!.Name, list[i].Value!, new UnityVersionRange(list[i].Key, list[i + 1].Key)));
			}
		}
		if (list.Count > 0)
		{
			var lastPair = list[list.Count - 1];
			if (lastPair.Value is not null)
			{
				result.Add(new ClassData(lastPair.Value.Name, lastPair.Value, new UnityVersionRange(lastPair.Key, UnityVersion.MaxVersion)));
			}
		}
		return result;
	}

	private static List<SubclassCandidate> GetOrAddSubclassCandidateList(string name)
	{
		if (!candidateListDictionary.TryGetValue(name, out List<SubclassCandidate>? result))
		{
			result = new();
			candidateListDictionary.Add(name, result);
		}
		return result;
	}

	private static void AddDependentTypes(ClassData classData) => AddDependentTypes(classData.Class.ReleaseRootNode, classData.Class.EditorRootNode, classData);
	private static void AddDependentTypes(UniversalNode? releaseNode, UniversalNode? editorNode, ClassData classData)
	{
		List<(UniversalNode?, UniversalNode?)> fieldList = GenerateFieldList(releaseNode, editorNode);
		foreach ((UniversalNode? releaseField, UniversalNode? editorField) in fieldList)
		{
			UniversalNode mainNode = releaseField ?? editorField ?? throw new NullReferenceException();
			NodeType nodeType = mainNode.NodeType;

			if (!nodeType.IsPrimitive())
			{
				if (nodeType == NodeType.Type)
				{
					List<SubclassCandidate> candidateList = GetOrAddSubclassCandidateList(mainNode.TypeName);
					candidateList.Add(new SubclassCandidate(releaseField, editorField, classData.VersionRange));
				}
				AddDependentTypes(releaseField, editorField, classData);
			}
		}
	}

	private static List<(UniversalNode?, UniversalNode?)> GenerateFieldList(UniversalNode? releaseRoot, UniversalNode? editorRoot)
	{
		if (releaseRoot?.SubNodes == null)
		{
			Func<UniversalNode, (UniversalNode?, UniversalNode?)> func = new Func<UniversalNode, (UniversalNode?, UniversalNode?)>(node => (null, node));
			return editorRoot?.SubNodes?.Select(func).ToList() ?? new List<(UniversalNode?, UniversalNode?)>();
		}
		else if (editorRoot?.SubNodes == null)
		{
			Func<UniversalNode, (UniversalNode?, UniversalNode?)>? func = new Func<UniversalNode, (UniversalNode?, UniversalNode?)>(node => (node, null));
			return releaseRoot?.SubNodes?.Select(func).ToList() ?? new List<(UniversalNode?, UniversalNode?)>();
		}
		Dictionary<string, (UniversalNode?, UniversalNode?)> result = new Dictionary<string, (UniversalNode?, UniversalNode?)>();
		foreach (UniversalNode releaseNode in releaseRoot.SubNodes)
		{
			UniversalNode? editorNode = editorRoot.SubNodes.FirstOrDefault(node => node.Name == releaseNode.Name);
			result.Add(releaseNode.Name!, (releaseNode, editorNode));
		}
		foreach (UniversalNode editorNode in editorRoot.SubNodes)
		{
			if (!result.ContainsKey(editorNode.Name!))
			{
				result.Add(editorNode.Name!, (null, editorNode));
			}
		}
		return result.Values.ToList();
	}

	private static bool AreCompatible(UniversalNode releaseNode, UniversalNode editorNode, bool root)
	{
		if (releaseNode == null || editorNode == null)
		{
			return true;
		}

		if (!root && releaseNode.OriginalName != editorNode.OriginalName) //The root nodes might not have the same name
		{
			return false;
		}

		if (releaseNode.OriginalTypeName != editorNode.OriginalTypeName)
		{
			return false;
		}

		if (releaseNode.SubNodes == null || editorNode.SubNodes == null)
		{
			return true;
		}

		Dictionary<string, UniversalNode> releaseFields = releaseNode.SubNodes.ToDictionary(x => x.Name!, x => x);
		Dictionary<string, UniversalNode> editorFields = editorNode.SubNodes.ToDictionary(x => x.Name!, x => x);
		foreach (KeyValuePair<string, UniversalNode> releasePair in releaseFields)
		{
			if (editorFields.TryGetValue(releasePair.Key, out UniversalNode? editorField))
			{
				if (!AreCompatible(releasePair.Value, editorField, false))
				{
					return false;
				}
			}
		}
		return true;
	}

	private static bool AreCompatibleWithLogging(UniversalNode? releaseNode, UniversalNode? editorNode)
	{
		if (releaseNode == null || editorNode == null)
		{
			return true;
		}

		if (releaseNode.OriginalName != editorNode.OriginalName)
		{
			Console.WriteLine($"Original Name {releaseNode.OriginalName} does not equal {editorNode.OriginalName}");
			return false;
		}

		if (releaseNode.Name != editorNode.Name)
		{
			Console.WriteLine($"Name {releaseNode.OriginalName} does not equal {editorNode.OriginalName}");
			return false;
		}

		if (releaseNode.OriginalTypeName != editorNode.OriginalTypeName)
		{
			Console.WriteLine($"Original Type Name {releaseNode.OriginalTypeName} does not equal {editorNode.OriginalTypeName}");
			return false;
		}

		if (releaseNode.TypeName != editorNode.TypeName)
		{
			Console.WriteLine($"Original Type Name {releaseNode.OriginalTypeName} does not equal {editorNode.OriginalTypeName}");
			return false;
		}

		if (releaseNode.SubNodes == null || editorNode.SubNodes == null)
		{
			return true;
		}

		Dictionary<string, UniversalNode> releaseFields = releaseNode.SubNodes.ToDictionary(x => x.Name!, x => x);
		Dictionary<string, UniversalNode> editorFields = editorNode.SubNodes.ToDictionary(x => x.Name!, x => x);
		foreach (KeyValuePair<string, UniversalNode> releasePair in releaseFields)
		{
			if (editorFields.TryGetValue(releasePair.Key, out UniversalNode? editorField))
			{
				if (!AreCompatibleWithLogging(releasePair.Value, editorField))
				{
					return false;
				}
			}
		}
		return true;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass008_DivideAmbiguousPPtr.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass008_DivideAmbiguousPPtr
{
	public static void DoPass()
	{
		foreach ((string name, VersionedList<UniversalClass> list) in SharedState.Instance.SubclassInformation)
		{
			if (!name.StartsWith("PPtr_", StringComparison.Ordinal))
			{
				continue;
			}

			string parameterTypeName = name.Substring(5);
			if (!MapsToMultipleIds(parameterTypeName))
			{
				continue;
			}

			List<List<UnityVersionRange>> rangeListList = MakeRangeListList(parameterTypeName);
			HashSet<UnityVersion> divisions = ExtractDivisions(rangeListList);

			foreach (UnityVersion division in divisions)
			{
				list.Divide(division);
			}
		}

		//SerializedVersion changed for Hash128 at the beginning of Unity 5, but Unity didn't update the type trees.
		//To see an example of this, look at Texture3D.
		{
			VersionedList<UniversalClass> list = SharedState.Instance.SubclassInformation["Hash128"];
			list.Divide(new UnityVersion(5));
			Debug.Assert(list.Count == 2);
			UniversalClass second = list[1].Value!;
			second.ReleaseRootNode!.Version = 2;
			second.EditorRootNode!.Version = 2;
		}
	}

	private static HashSet<UnityVersion> ExtractDivisions(List<List<UnityVersionRange>> rangeListList)
	{
		HashSet<UnityVersion> divisions = new();
		foreach (List<UnityVersionRange> rangeList in rangeListList)
		{
			foreach (List<UnityVersionRange> otherRangeList in rangeListList)
			{
				if (rangeList == otherRangeList)
				{
					continue;
				}

				foreach (UnityVersionRange range in rangeList)
				{
					foreach (UnityVersionRange otherRange in otherRangeList)
					{
						if (range.CanUnion(otherRange))
						{
							divisions.Add(UnityVersion.Max(range.Start, otherRange.Start));
							divisions.Add(UnityVersion.Min(range.End, otherRange.End));
						}
					}
				}
			}
		}

		return divisions;
	}

	private static List<List<UnityVersionRange>> MakeRangeListList(string parameterTypeName)
	{
		List<List<UnityVersionRange>> rangeListList = new();
		IEnumerable<VersionedList<UniversalClass>> classes = SharedState.Instance.NameToTypeID[parameterTypeName]
			.Select(id => SharedState.Instance.ClassInformation[id]);
		foreach (VersionedList<UniversalClass> versionedList in classes)
		{
			List<UnityVersionRange> rangeList = new();
			bool first = true;
			UnityVersionRange cumulativeRange = default;
			for (int i = 0; i < versionedList.Count; i++)
			{
				(UnityVersion start, UniversalClass? universalClass) = versionedList[i];
				if (universalClass is not null && universalClass.Name == parameterTypeName)
				{
					UnityVersionRange currentRange = i < versionedList.Count - 1
						? new UnityVersionRange(start, versionedList[i + 1].Key)
						: new UnityVersionRange(start, UnityVersion.MaxVersion);

					if (first)
					{
						cumulativeRange = currentRange;
						first = false;
					}
					else if (cumulativeRange.CanUnion(currentRange))
					{
						cumulativeRange = cumulativeRange.MakeUnion(currentRange);
					}
					else
					{
						rangeList.Add(cumulativeRange);
						cumulativeRange = currentRange;
					}
				}
			}
			if (cumulativeRange != default)
			{
				rangeList.Add(cumulativeRange);
				rangeListList.Add(rangeList);
			}
		}

		Debug.Assert(rangeListList.Count > 1);

		return rangeListList;
	}

	private static bool MapsToMultipleIds(string name)
	{
		return SharedState.Instance.NameToTypeID.TryGetValue(name, out HashSet<int>? set) && set.Count > 1;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass009_CreateGroups.cs`:

```cs
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.AssemblyDumper.Utils;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass009_CreateGroups
{
	public static void DoPass()
	{
		foreach ((int id, VersionedList<UniversalClass> list) in SharedState.Instance.ClassInformation)
		{
			ClassGroup group = CreateClasses(list, id);
			SharedState.Instance.ClassGroups.Add(id, group);
		}
		foreach ((string name, VersionedList<UniversalClass> list) in SharedState.Instance.SubclassInformation)
		{
			SubclassGroup group = CreateSubclasses(list, name);
			SharedState.Instance.SubclassGroups.Add(name, group);
		}
	}

	private static ClassGroup CreateClasses(VersionedList<UniversalClass> loadedClasses, int id)
	{
		TypeDefinition @interface = InterfaceCreator.CreateEmptyInterface(SharedState.Instance.Module, null, null);
		ClassGroup group = new ClassGroup(id, @interface);
		CreateTypeDefinitionsAndInitializeGroup(loadedClasses, group);
		return group;
	}

	private static SubclassGroup CreateSubclasses(VersionedList<UniversalClass> loadedClasses, string name)
	{
		TypeDefinition @interface = InterfaceCreator.CreateEmptyInterface(SharedState.Instance.Module, null, null);
		SubclassGroup group = new SubclassGroup(name, @interface);
		CreateTypeDefinitionsAndInitializeGroup(loadedClasses, group);
		return group;
	}

	private static void CreateTypeDefinitionsAndInitializeGroup(VersionedList<UniversalClass> loadedClasses, ClassGroupBase group)
	{
		int nonNullCount = loadedClasses.Values.Count(c => c != null);
		if (nonNullCount == 0)
		{
			throw new ArgumentException("Must have at least one class", nameof(loadedClasses));
		}
		else if (nonNullCount == 1)
		{
			KeyValuePair<UnityVersion, UniversalClass?> pair = loadedClasses.Single(c => c.Value != null);
			UniversalClass universalClass = pair.Value!;
			string typeName = universalClass.Name;
			UnityVersion endVersion = loadedClasses.Count == 2 && loadedClasses[1].Value == null ? loadedClasses[1].Key : UnityVersion.MaxVersion;
			CreateType(universalClass, pair.Key, endVersion, typeName, group);
		}
		else
		{
			for (int i = 0; i < loadedClasses.Count; i++)
			{
				KeyValuePair<UnityVersion, UniversalClass?> pair = loadedClasses[i];
				UnityVersion endVersion = i + 1 < loadedClasses.Count ? loadedClasses[i + 1].Key : UnityVersion.MaxVersion;
				UniversalClass? universalClass = pair.Value;
				if (universalClass is not null)
				{
					string typeName = $"{universalClass.Name}_{pair.Key.ToCleanString('_')}";
					CreateType(universalClass, pair.Key, endVersion, typeName, group);
				}
			}
		}
		group.InitializeHistory(SharedState.Instance.HistoryFile);
	}

	private static void CreateType(UniversalClass universalClass, UnityVersion startVersion, UnityVersion endVersion, string typeName, ClassGroupBase group)
	{
		TypeDefinition type = new TypeDefinition(group.Namespace, typeName, TypeAttributes.Public | TypeAttributes.BeforeFieldInit);
		SharedState.Instance.Module.TopLevelTypes.Add(type);

		GeneratedClassInstance instance = new GeneratedClassInstance(group, universalClass, type, startVersion, endVersion);
		group.Instances.Add(instance);
		SharedState.Instance.TypesToGroups.Add(type, group);
		SharedState.Instance.TypesToInstances.Add(type, instance);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass010_InitializeInterfacesAndFactories.cs`:

```cs
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass010_InitializeInterfacesAndFactories
{
	public static void DoPass()
	{
		ITypeDefOrRef unityObjectBaseReference = SharedState.Instance.Importer.ImportType<IUnityObjectBase>();
		ITypeDefOrRef unityAssetBaseReference = SharedState.Instance.Importer.ImportType<IUnityAssetBase>();
		foreach (ClassGroup group in SharedState.Instance.ClassGroups.Values)
		{
			group.InitializeInterface(unityObjectBaseReference);
		}
		foreach (SubclassGroup group in SharedState.Instance.SubclassGroups.Values)
		{
			group.InitializeInterface(unityAssetBaseReference);
		}
	}

	private static void InitializeInterface(this ClassGroupBase group, ITypeDefOrRef baseInterfaceReference)
	{
		group.Interface.Namespace = group.Namespace;
		group.Interface.Name = $"I{group.Name}";
		group.Interface.AddInterfaceImplementation(baseInterfaceReference);
		SharedState.Instance.TypesToGroups.Add(group.Interface, group);
		foreach (GeneratedClassInstance instance in group.Instances)
		{
			instance.Type.AddInterfaceImplementation(group.Interface);
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass011_ApplyInheritance.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass011_ApplyInheritance
{
	public static void DoPass()
	{
		//Not necessary but left just because
		/*foreach (ClassGroup group in SharedState.Instance.ClassGroups.Values)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				instance.Class.DerivedClasses.Clear();
				instance.Class.DescendantCount = 0;
				instance.Class.BaseClass = null;
			}
		}*/
		Dictionary<UniversalClass, GeneratedClassInstance> classInstanceDictionary = new();
		foreach (ClassGroup group in SharedState.Instance.ClassGroups.Values)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				classInstanceDictionary.Add(instance.Class, instance);
			}
		}
		foreach (ClassGroup group in SharedState.Instance.ClassGroups.Values)
		{
			group.ApplyBaseTypes(classInstanceDictionary);
		}
		foreach (SubclassGroup group in SharedState.Instance.SubclassGroups.Values)
		{
			group.ApplyBaseTypes(classInstanceDictionary);
		}
		foreach (UniversalClass universalClass in SharedState.Instance.ClassGroups.Values.SelectMany(g => g.Classes))
		{
			universalClass.SetDescendantCount();
		}
	}

	private static void ApplyBaseTypes(this ClassGroupBase group, Dictionary<UniversalClass, GeneratedClassInstance> classInstanceDictionary)
	{
		ITypeDefOrRef unityObjectBaseDefinition = SharedState.Instance.Importer.ImportType<UnityObjectBase>();
		ITypeDefOrRef unityAssetBaseDefinition = SharedState.Instance.Importer.ImportType<UnityAssetBase>();

		foreach (GeneratedClassInstance instance in group.Instances)
		{
			string name = instance.Name;
			string? baseTypeName = instance.Class.BaseString;
			if (string.IsNullOrEmpty(baseTypeName))
			{
				instance.Type.BaseType = name switch
				{
					"Object" => unityObjectBaseDefinition,
					_ => unityAssetBaseDefinition,
				};
			}
			else
			{
				GeneratedClassInstance baseInstance = SharedState.Instance.GetGeneratedInstanceForObjectType(baseTypeName, instance.VersionRange.Start);
				instance.Type.BaseType = baseInstance.Type;
				instance.Class.BaseClass = baseInstance.Class;
				baseInstance.Class.DerivedClasses.Add(instance.Class);
				baseInstance.Derived.Add(instance);
				instance.Base = baseInstance;
			}
		}
	}

	private static void SetDescendantCount(this UniversalClass universalClass)
	{
		if (universalClass.DescendantCount <= 1 && universalClass.DerivedClasses.Count > 0)
		{
			foreach (UniversalClass derivedClass in universalClass.DerivedClasses)
			{
				derivedClass.SetDescendantCount();
				universalClass.DescendantCount += derivedClass.DescendantCount;
			}
		}
		else if (universalClass.DescendantCount < 1 && universalClass.DerivedClasses.Count == 0)
		{
			universalClass.DescendantCount = 1;
		}
	}
}
```

`Source/AssetRipper.AssemblyDumper/Passes/Pass012_ApplyCorrectTypeAttributes.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass012_ApplyCorrectTypeAttributes
{
	public static void DoPass()
	{
		foreach (ClassGroup classGroup in SharedState.Instance.ClassGroups.Values)
		{
			classGroup.FixTypeAttributes();
		}
		foreach (SubclassGroup subclassGroup in SharedState.Instance.SubclassGroups.Values)
		{
			subclassGroup.FixTypeAttributes();
		}
	}

	private static void FixTypeAttributes(this ClassGroupBase group)
	{
		foreach (GeneratedClassInstance instance in group.Instances)
		{
			instance.Type.Attributes = GetTypeAttributes(instance.Class);
		}
	}

	private static TypeAttributes GetTypeAttributes(UniversalClass universalClass)
	{
		TypeAttributes attributes = TypeAttributes.Public | TypeAttributes.BeforeFieldInit;
		if (universalClass.IsAbstract)
		{
			attributes |= TypeAttributes.Abstract;
		}
		else if (universalClass.IsSealed)
		{
			attributes |= TypeAttributes.Sealed;
		}
		return attributes;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass013_UnifyFieldsOfAbstractTypes.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass013_UnifyFieldsOfAbstractTypes
{
	private const float MinMatchingProportion = .999f;
	private static readonly bool shouldSkip = true;
	public static void DoPass()
	{
		if (shouldSkip)
		{
			return;
		}

		//We need to get all abstract classes, and we need to do them in order of lowest abstraction to highest.
		//In other words, the most derived classes should be done first, so their values can be used for their own base classes

		//Get all the abstract classes
		List<UniversalClass> abstractClasses = SharedState.Instance.ClassGroups.Values.SelectMany(g => g.Classes).Where(c => c.IsAbstract).ToList();

		//Now sort so that most-derived classes are first, or more crucially, before any of their base classes. 
		abstractClasses.Sort((a, b) => CompareByInheritance(a, b));

		foreach (UniversalClass abstractClass in abstractClasses)
		{
			Console.WriteLine($"{abstractClass.TypeID} {abstractClass.Name}");
			abstractClass.InitializeRootNodes();

			List<UniversalClass> derived = abstractClass.DerivedClasses;

			if (derived.Count == 0)
			{
				continue;
			}

			//Abstract classes that inherit from a nonabstract class will have the inherited fields in the json
			//For example, Behaviour inherits from Component
			List<string> existingEditorFields = abstractClass.EditorRootNode!.SubNodes!.Select(c => c.Name!).ToList();
			List<string> existingReleaseFields = abstractClass.ReleaseRootNode!.SubNodes!.Select(c => c.Name!).ToList();

			//Handle editor node
			foreach (string editorFieldName in GetAllFieldNames(derived, false))
			{
				if (existingEditorFields.Contains(editorFieldName))
				{
					continue;
				}

				UniversalNode subNode = GetFirstNode(derived, false, editorFieldName);

				float matchProportion = GetWeightedMatching(derived, false, editorFieldName, subNode);

				Console.WriteLine($"\t{matchProportion} {editorFieldName} editor");
				if (matchProportion < MinMatchingProportion)
				{
					//Mismatch in too many descendent classes, break out.
					break;
				}

				//This field is common to all sub classes. Add it to base.
				// Console.WriteLine($"\t\tCopying field {subNode.Name} to EDITOR");
				abstractClass.EditorRootNode!.SubNodes!.Add(subNode.DeepClone());
			}

			//Handle release node
			foreach (string releaseFieldName in GetAllFieldNames(derived, true))
			{
				//Console.WriteLine($"")
				if (existingReleaseFields.Contains(releaseFieldName))
				{
					continue;
				}

				UniversalNode subNode = GetFirstNode(derived, true, releaseFieldName);

				float matchProportion = GetWeightedMatching(derived, true, releaseFieldName, subNode);
				Console.WriteLine($"\t{matchProportion} {releaseFieldName} release");
				if (matchProportion < MinMatchingProportion)
				{
					//Mismatch in too many descendent classes, break out.
					break;
				}

				//This field is common to all sub classes. Add it to base.
				// Console.WriteLine($"\t\tCopying field {subNode.Name} to EDITOR");
				abstractClass.ReleaseRootNode!.SubNodes!.Add(subNode.DeepClone());
			}
		}
	}

	private static List<string> GetAllFieldNames(List<UniversalClass> classes, bool isRelease)
	{
		return classes.SelectMany(klass => klass.GetSubNodes(isRelease)) //all the subnodes
			.Select(s => s.Name!) //convert to their field name
			.Distinct() //remove duplicates
			.ToList(); //make list
	}

	private static UniversalNode GetFirstNode(List<UniversalClass> classes, bool isRelease, string fieldName)
	{
		return classes.SelectMany(klass => klass.GetSubNodes(isRelease)) //all the subnodes
			.First(s => s.Name == fieldName); //where the field name matches
	}

	private static List<UniversalNode> GetSubNodes(this UniversalClass klass, bool isRelease)
	{
		List<UniversalNode>? result = isRelease ? klass.ReleaseRootNode?.SubNodes : klass.EditorRootNode?.SubNodes;
		return result ?? new List<UniversalNode>();
	}

	private static float GetWeightedMatching(List<UniversalClass> classes, bool isRelease, string fieldName, UniversalNode baseFieldNode)
	{
		uint total = 0;
		uint matching = 0;

		foreach (UniversalClass universalClass in classes)
		{
			int duplicateCount = classes.Count(c => c.Name == universalClass.Name);
			float weight = (float)universalClass.DescendantCount / duplicateCount;
			if (isRelease)
			{
				if (universalClass.ReleaseRootNode.ContainsField(fieldName, out UniversalNode? fieldNode))
				{
					if (!AreEqual(fieldNode, baseFieldNode))
					{
						Console.WriteLine($"\tConflicts with {universalClass.Name} {universalClass.TypeID}");
						return 0f;
					}
					//matching += weight;
					matching += universalClass.DescendantCount;
				}
			}
			else
			{
				if (universalClass.EditorRootNode.ContainsField(fieldName, out UniversalNode? fieldNode))
				{
					if (!AreEqual(fieldNode, baseFieldNode))
					{
						Console.WriteLine($"\tConflicts with {universalClass.Name} {universalClass.TypeID}");
						return 0f;
					}
					//matching += weight;
					matching += universalClass.DescendantCount;
				}
			}
			//total += weight;
			total += universalClass.DescendantCount;
		}

		float result = matching / total;
		return !float.IsNaN(result)
			? result
			: throw new InvalidOperationException("Proportion cannot be nan");
	}

	private static bool AreEqual(UniversalNode left, UniversalNode right)
	{
		if (left.OriginalName != right.OriginalName) //The root nodes will most likely not have the same name
		{
			return false;
		}
		if (left.Name != right.Name) //The root nodes will most likely not have the same name
		{
			return false;
		}
		if (left.OriginalTypeName != right.OriginalTypeName)
		{
			return false;
		}
		if (left.TypeName != right.TypeName)
		{
			return false;
		}
		if (left.Version != right.Version)
		{
			return false;
		}
		if (left.MetaFlag != right.MetaFlag)
		{
			return false;
		}
		if (left.SubNodes!.Count != right.SubNodes!.Count)
		{
			return false;
		}
		for (int i = 0; i < left.SubNodes.Count; i++)
		{
			if (!AreEqual(left.SubNodes[i], right.SubNodes[i]))
			{
				return false;
			}
		}
		return true;
	}

	private static bool ContainsField(this UniversalNode? rootNode, string fieldName, [NotNullWhen(true)] out UniversalNode? fieldNode)
	{
		fieldNode = rootNode?.SubNodes.SingleOrDefault(node => node.Name == fieldName);
		return fieldNode != null;
	}

	private static void InitializeRootNodes(this UniversalClass abstractClass)
	{
		abstractClass.EditorRootNode ??= new()
		{
			Name = "Base",
			OriginalName = "Base",
			TypeName = abstractClass.Name,
			SubNodes = new(),
			Version = 1,
		};
		abstractClass.ReleaseRootNode ??= new()
		{
			Name = "Base",
			OriginalName = "Base",
			TypeName = abstractClass.Name,
			SubNodes = new(),
			Version = 1,
		};
	}

	/// <summary>
	/// A compare function favoring less derivation
	/// </summary>
	/// <returns>
	/// -1 if the left derives from the right<br/>
	/// 1 if the right derives from the left<br/>
	/// 0 if neither derives from the other
	/// </returns>
	private static int CompareByInheritance(UniversalClass left, UniversalClass right)
	{
		return left.IsSubclassOf(right)
			? -1
			: right.IsSubclassOf(left)
				? 1
				: 0;
	}

	private static bool IsSubclassOf(this UniversalClass potentialSubClass, UniversalClass potentialSuperClass)
	{
		UniversalClass? baseClass = potentialSubClass.BaseClass;
		while (baseClass is not null)
		{
			if (baseClass.Name == potentialSuperClass.Name)
			{
				return true;
			}

			baseClass = baseClass.BaseClass;
		}

		return false;
	}
}
```

`Source/AssetRipper.AssemblyDumper/Passes/Pass015_AddFields.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass015_AddFields
{
	public static void DoPass()
	{
		foreach (ClassGroup group in SharedState.Instance.ClassGroups.Values)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				ProcessNodeInformation(instance.Class, instance.Type, instance.VersionRange.Start);
			}
		}
		foreach (SubclassGroup group in SharedState.Instance.SubclassGroups.Values)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				ProcessNodeInformation(instance.Class, instance.Type, instance.VersionRange.Start);
			}
		}
	}

	private static void ProcessNodeInformation(UniversalClass unityClass, TypeDefinition type, UnityVersion version)
	{
		if (unityClass.EditorRootNode == null && unityClass.ReleaseRootNode == null)
		{
			return; //No fields.
		}

		GetFieldNodeSets(unityClass, out List<UniversalNode> releaseOnly, out List<UniversalNode> editorOnly, out List<(UniversalNode, UniversalNode)> releaseAndEditor);

		foreach (UniversalNode releaseOnlyField in releaseOnly)
		{
			TypeSignature releaseOnlyFieldType = GenericTypeResolver.ResolveNode(releaseOnlyField, version);
			type.AddFieldForNode(releaseOnlyField, releaseOnlyFieldType);
		}

		foreach (UniversalNode editorOnlyField in editorOnly)
		{
			TypeSignature editorOnlyFieldType = GenericTypeResolver.ResolveNode(editorOnlyField, version);
			type.AddFieldForNode(editorOnlyField, editorOnlyFieldType);
		}

		foreach ((UniversalNode releaseField, _) in releaseAndEditor)
		{
			TypeSignature fieldType = GenericTypeResolver.ResolveNode(releaseField, version);
			type.AddFieldForNode(releaseField, fieldType);
		}
	}

	private static void GetFieldNodeSets(UniversalClass unityClass, out List<UniversalNode> releaseOnly, out List<UniversalNode> editorOnly, out List<(UniversalNode, UniversalNode)> releaseAndEditor)
	{
		List<UniversalNode> editorNodes = unityClass.GetNonInheritedEditorNodes();
		List<UniversalNode> releaseNodes = unityClass.GetNonInheritedReleaseNodes();

		Dictionary<string, UniversalNode> releaseFields = releaseNodes.ToDictionary(x => x.Name, x => x);
		Dictionary<string, UniversalNode> editorFields = editorNodes.ToDictionary(x => x.Name, x => x);

		List<UniversalNode> releaseOnlyResult = releaseNodes.Where(node => !editorFields.ContainsKey(node.Name)).ToList();
		//Need to use a result local field here becuase out parameters can't be used in lambda expressions
		editorOnly = editorNodes.Where(node => !releaseFields.ContainsKey(node.Name)).ToList();

		releaseAndEditor = releaseNodes.
			Where(anyRelease => !releaseOnlyResult.Contains(anyRelease)).
			Select(releaseWithEditor => (releaseWithEditor, editorFields[releaseWithEditor.Name])).
			ToList();

		releaseOnly = releaseOnlyResult;
	}

	private static List<UniversalNode> GetNonInheritedEditorNodes(this UniversalClass unityClass)
	{
		List<UniversalNode> editorNodes = unityClass.EditorRootNode?.SubNodes ?? new();
		return editorNodes.Where(node => !IsFieldInBaseType(unityClass, node.Name)).ToList();
	}

	private static List<UniversalNode> GetNonInheritedReleaseNodes(this UniversalClass unityClass)
	{
		List<UniversalNode> releaseNodes = unityClass.ReleaseRootNode?.SubNodes ?? new();
		return releaseNodes.Where(node => !IsFieldInBaseType(unityClass, node.Name)).ToList();
	}

	private static void AddFieldForNode(this TypeDefinition type, UniversalNode mainNode, TypeSignature fieldType)
	{
		FieldDefinition fieldDefinition = new FieldDefinition(mainNode.Name, FieldAttributes.Assembly, new FieldSignature(fieldType));
		type.Fields.Add(fieldDefinition);
		fieldDefinition.AddDebuggerBrowsableNeverAttribute();
	}

	private static bool IsFieldInBaseType(UniversalClass unityClass, string fieldName)
	{
		UniversalClass? baseType = unityClass.BaseClass;
		while (baseType is not null)
		{

			if (baseType.EditorRootNode?.SubNodes.Any(n => n.Name == fieldName) == true)
			{
				return true;
			}

			if (baseType.ReleaseRootNode?.SubNodes.Any(n => n.Name == fieldName) == true)
			{
				return true;
			}

			baseType = baseType.BaseClass;
		}

		return false;
	}
}
```

`Source/AssetRipper.AssemblyDumper/Passes/Pass039_InjectEnumValues.cs`:

```cs
using AssetRipper.DocExtraction.DataStructures;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass039_InjectEnumValues
{
	private static readonly List<InjectedTypeData> injectedTypes = new()
	{
		new()
		{
			Name = "CurveLoopTypes",
			Summary = "Enum for AnimationCurve.PreInfinity and AnimationCurve.PostInfinity",
			Members = new()
			{
				("Constant", 0, ""),
				("Cycle", 1, ""),
				("CycleWithOffset", 2, ""),
				("Oscillate", 3, ""),
				("Linear", 4, ""),
			},
		},
	};
	private static readonly Dictionary<string, List<(string, long, string?)>> injectedValues = new()
	{
		{ "UnityEngine.TextureFormat",
			new()
			{
				("ARGBFloat", 6, ""),
				("BGR24", 8, ""),
				("DXT3", 11, ""),
			} },
		{ "UnityEditor.TextureImporterFormat",
			new()
			{
				("ARGBFloat", 6, ""),
				("BGR24", 8, ""),
				("DXT3", 11, ""),
			} },
		{ "UnityEngine.MeshTopology",
			new()
			{
				("TriangleStrip", 1, "Mesh is a triangle strip."),
			} },
		{ "UnityEngine.SpritePackingRotation",
			new()
			{
				("Rotate90", 4, "Might not exist. It was included in legacy code."),
				("Any_Old", 5, "Might not exist. It was included in legacy code."),
			} },
		{ "UnityEngine.AnimatorControllerParameterType",
			new()
			{
				("Vector", 0, "Added to allow merging. Remove once complex merging is implemented."),
			} },
		{ "UnityEditor.Animations.AnimatorConditionMode",
			new()
			{
				("ExitTime", 5, "The condition is true when the source state has stepped over the exit time value."),
			} },
	};
	private static readonly Dictionary<string, List<(string?, string)>> injectedDocumentation = new()
	{
		{ "UnityEditor.ModelImporterMeshCompression",
			new()
			{
				(null, "Compressing meshes saves space in the built game, but more compression introduces more artifacts in vertex data."),
			}
		},
		{ "UnityEditor.TextureUsageMode",
			new()
			{
				("Default", "Not a lightmap"),
				("LightmapDoubleLDR", "Range [0;2] packed to [0;1] with loss of precision"),
				("BakedLightmapDoubleLDR", "Range [0;2] packed to [0;1] with loss of precision"),
				("LightmapRGBM", "Range [0;kLightmapRGBMMax] packed to [0;1] with multiplier stored in the alpha channel"),
				("BakedLightmapRGBM", "Range [0;kLightmapRGBMMax] packed to [0;1] with multiplier stored in the alpha channel"),
				("NormalmapDXT5nm", "Compressed DXT5 normal map"),
				("NormalmapPlain", "Plain RGB normal map"),
				("AlwaysPadded", "Texture is always padded if NPOT and on low-end hardware"),
				("BakedLightmapFullHDR", "Baked lightmap without any encoding"),
			} },
	};

	public static void DoPass()
	{
		Dictionary<string, EnumHistory> dictionary = SharedState.Instance.HistoryFile.Enums;

		//Inject types
		foreach (InjectedTypeData injectedTypeData in injectedTypes)
		{
			UnityVersion minVersion = SharedState.Instance.MinSourceVersion;
			EnumHistory history = new();
			history.Name = injectedTypeData.Name;
			history.FullName = $"Injected.{injectedTypeData.Name}";
			history.IsFlagsEnum = injectedTypeData.IsFlags;
			history.ElementType.Add(minVersion, injectedTypeData.ElementType);
			history.NativeName.Add(minVersion, null);
			history.DocumentationString.Add(minVersion, injectedTypeData.Summary);
			history.ObsoleteMessage.Add(minVersion, null);
			history.Exists.Add(minVersion, true);
			foreach ((string fieldName, long value, string? description) in injectedTypeData.Members)
			{
				EnumMemberHistory member = new();
				member.Name = fieldName;
				member.NativeName.Add(minVersion, null);
				member.Value.Add(minVersion, value);
				member.DocumentationString.Add(minVersion, string.IsNullOrEmpty(description) ? null : description);
				member.ObsoleteMessage.Add(minVersion, null);
				member.Exists.Add(minVersion, true);
				history.Members.Add(fieldName, member);
			}
			dictionary.Add(history.FullName, history);
		}

		//Inject values
		foreach ((string fullName, List<(string, long, string?)> list) in injectedValues)
		{
			EnumHistory history = dictionary[fullName];
			UnityVersion minVersion = history.Exists[0].Key;
			foreach ((string fieldName, long value, string? description) in list)
			{
				if (history.Members.ContainsKey(fieldName))
				{
					Console.WriteLine($"{fullName} already has an entry for {fieldName}");
				}
				else
				{
					EnumMemberHistory member = new();
					member.Name = fieldName;
					member.NativeName.Add(minVersion, null);
					member.Value.Add(minVersion, value);
					member.DocumentationString.Add(minVersion, string.IsNullOrEmpty(description) ? "Injected" : $"Injected. {description}");
					member.ObsoleteMessage.Add(minVersion, null);
					member.Exists.Add(minVersion, true);
					history.Members.Add(fieldName, member);
				}
			}
		}

		//Inject documentation
		foreach ((string fullName, List<(string?, string)> list) in injectedDocumentation)
		{
			EnumHistory history = dictionary[fullName];
			foreach ((string? fieldName, string description) in list)
			{
				if (string.IsNullOrEmpty(fieldName))
				{
					//Inject documentation for the enum itself
					history.InjectedDocumentation = description;
				}
				else
				{
					EnumMemberHistory member = history.Members[fieldName];
					member.InjectedDocumentation = description;
				}
			}
		}

		//Fix TextureFormat
		{
			EnumHistory history = dictionary["UnityEngine.TextureFormat"];
			foreach (EnumMemberHistory member in history.Members.Values)
			{
				if (member.Value.Count == 2 && member.Value[1].Value == -127)
				{
					member.Value.RemoveAt(1);
				}
			}
		}
	}

	private record class InjectedTypeData
	{
		public required string Name { get; init; }
		public string? Summary { get; init; }
		public bool IsFlags { get; init; } = false;
		public ElementType ElementType { get; init; } = ElementType.I4;
		public required List<(string, long, string?)> Members { get; init; }
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass040_AddEnums.cs`:

```cs
using AssetRipper.AssemblyDumper.Enums;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass040_AddEnums
{
	private static readonly HashSet<string?> namespaceBlacklist = new()
	{
		"UnityEngine.Yoga",
	};
	private static readonly HashSet<string> fullNameBlackList = new()
	{
		"UnityEditor.PackageManager.LogLevel",
		"UnityEngine.LogOption",
		"UnityEngine.LogType",
	};

	private static readonly Dictionary<string, (TypeDefinition, EnumDefinitionBase)> enumDictionary = new();
	internal static IReadOnlyDictionary<string, (TypeDefinition, EnumDefinitionBase)> EnumDictionary => enumDictionary;
	public static void DoPass()
	{
		IMethodDefOrRef flagsConstructor = SharedState.Instance.Importer.ImportDefaultConstructor<FlagsAttribute>();
		int total = 0;
		int merged = 0;
		Dictionary<string, IReadOnlyList<EnumDefinitionBase>> definitionDictionary = EnumDefinitionBase.Create(SharedState.Instance.HistoryFile.Enums.Values.Where(h =>
		{
			return !fullNameBlackList.Contains(h.FullName) && !namespaceBlacklist.Contains(h.Namespace);
		}));
		foreach ((string name, IReadOnlyList<EnumDefinitionBase> definitionList) in definitionDictionary)
		{
			for (int i = 0; i < definitionList.Count; i++)
			{
				EnumDefinitionBase definition = definitionList[i];

				string enumName = definitionList.Count > 1 ? $"{definition.Name}_{i}" : definition.Name;

				TypeDefinition type = EnumCreator.CreateFromDictionary(
					SharedState.Instance,
					SharedState.EnumsNamespace,
					enumName,
					definition.GetOrderedFields(),
					definition.ElementType.ToEnumUnderlyingType());

				if (definition.IsFlagsEnum)
				{
					type.AddCustomAttribute(flagsConstructor);
				}

				foreach (string fullName in definition.FullNames)
				{
					enumDictionary.Add(fullName, (type, definition));
				}

				if (definition is MergedEnumDefinition)
				{
					merged++;
				}

				total++;
			}
		}
		Console.WriteLine($"\t{total} generated enums, of which {merged} were created from multiple sources.");
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass041_NativeEnums.cs`:

```cs
using AssetRipper.AssemblyDumper.Documentation;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.DocExtraction.MetaData;
using System.Text;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass041_NativeEnums
{
	private static readonly Dictionary<string, string> fullNamePrefixToNamespace = new()
	{
		{ "fbxsdk", "Fbx" },
		{ "std", "Std" },
		{ "crn", "Images.Crunch" },
		{ "D2D", "Rendering.DirectX" },
		{ "D3D", "Rendering.DirectX" },
		{ "DXGI", "Rendering.DirectX" },
		{ "cuda", "Rendering.Cuda" },
		{ "FMOD", "Fmod" },
		{ "FLAC", "Flac" },
		{ "Umbra", "Umbra" },
		{ "asio", "Asio" },
		{ "curl", "Networking.Curl" },
		{ "Curl", "Networking.Curl" },
		{ "CURL", "Networking.Curl" },
		{ "FWP", "Fwp" },
		{ "Gfx", "Gfx" },
		{ "gl", "GL" },
		{ "Graphine", "Graphine" },
		{ "physx", "PhysX" },
		{ "SpeedTree", "SpeedTree" },
		{ "tetgen", "TetGen" },
		{ "TextCore", "TextCore" },
		{ "unity.google.protobuf", "ProtoBuf" },
		{ "vk", "Vk" },
		{ "Vk", "Vk" },
		{ "vpx", "VPX" },
		{ "VPX", "VPX" },
		{ "yaml", "Yaml" },
		{ "UnityYAML", "Yaml" },
		{ "zlib", "Compression.ZLib" },
		{ "Wintermute", "Wintermute" },
		{ "unitytls", "TLS" },
		{ "mbedtls", "TLS" },
		{ "tag", "Tags" },
		{ "Shader", "Shaders" },
		{ "smolv", "Shaders" },
		{ "Collab", "Networking.Collab" },
		{ "RestService", "Networking" },
		{ "Unity.Http", "Networking" },
		{ "UnityConnect", "Networking" },
		{ "UnityCurl", "Networking.Curl" },
		{ "CacheServer", "Networking" },
		{ "ssl", "Networking.SSL" },
		{ "SSL", "Networking.SSL" },
		{ "pb", "Networking.PB" },
		{ "PB", "Networking.PB" },
		{ "Suite", "Suite" },
		{ "pubnub", "PubNub" },
		{ "profiling", "Profiling" },
		{ "Profiler", "Profiling" },
		{ "PlayerLoopCallbacks", "PlayerLoopCallbacks" },
		{ "mecanim", "Animation" },
		{ "Animation", "Animation" },
		{ "Animator", "Animation" },
		{ "lws", "LWS" },
		{ "Log", "Logging" },
		{ "JPEG", "Images.Jpeg" },
		{ "jpgd", "Images.Jpeg" },
		{ "FREE_IMAGE", "Images.FreeImage" },
		{ "freeimage", "Images.FreeImage" },
		{ "etccompress", "Images.Etc" },
		{ "EXR", "Images.Exr" },
		{ "astc", "Images.Astc" },
		{ "Job", "Jobs" },
		{ "JOB", "Jobs" },
		{ "BakeEnlighten", "Jobs.Baking" },
		{ "BakeJob", "Jobs.Baking" },
		{ "IPSEC", "Security" },
		{ "IKEEXT", "Security" },
		{ "Geo", "Geo" },
		{ "Enlighten", "Rendering.Enlighten" },
		{ "CreateEnlighten", "Rendering.Enlighten" },
		{ "baselib.UnityClassic", "UnityClassic" },
		{ "UnityClassic.Baselib", "UnityClassic" },
		{ "ArchiveStorage", "AssetBundles" },
		{ "`anonymous-namespace'", "Anonymous" },
		{ "MIDL", "MIDL" },
		{ "RadeonRays", "RadeonRays" },
		{ "radeonRays", "RadeonRays" },
		{ "UnityEngine.Analytics", "Networking.Analytics" },
	};

	private static readonly HashSet<string> vagueNames = new()
	{
		"Type", "type",
		"State", "state",
		"Event", "event", "EventType",
		"Code", "code",
		"Flag", "flag",
		"Flags", "flags", "FLAGS",
		"Level", "level",
		"Bits", "bits",
		"Tag", "tag",
		"Tiling", "tiling",
		"Shade", "shade",
		"Mode", "mode", "MODE",
		"Enum", "enum",
		"EType",
		"Error", "ErrorType", "ErrorFlags",
		"FailureCodes",
	};

	public static void DoPass()
	{
		DocumentationFile file = DocumentationFile.FromFile("native_enums.json");
		//MakeEnumsAsIs(file);
		MakeCleanEnums(file);
	}

	private static void MakeEnumsAsIs(DocumentationFile file)
	{
		foreach (EnumDocumentation enumDoc in file.Enums)
		{
			TypeDefinition type = EnumCreator.CreateFromDictionary(
				SharedState.Instance,
				SharedState.NativeEnumsNamespace,
				enumDoc.FullName.Replace('.', '_'),
				enumDoc.Members.Values.Select(member => new KeyValuePair<string, long>(member.Name, member.Value)),
				enumDoc.ElementType.ToEnumUnderlyingType());
			DocumentationHandler.AddTypeDefinitionLine(type, $"Full Name: {enumDoc.FullName}");
		}
	}

	private static void MakeCleanEnums(DocumentationFile file)
	{
		IMethodDefOrRef flagsConstructor = SharedState.Instance.Importer.ImportDefaultConstructor<FlagsAttribute>();
		Dictionary<string, Dictionary<EnumDocumentation, string>> enumDictionary = new();
		foreach (EnumDocumentation enumDoc in file.Enums)
		{
			string fullName = RemoveLeadingUnderscores(enumDoc.FullName);
			string name = GetNameNotVague(fullName, RemoveLeadingUnderscores(enumDoc.Name))
				.RemoveTrailingSuffix()
				.TryMakePascalCase()
				.FixBeginning();
			string @namespace = $"{SharedState.NativeEnumsNamespace}.{GetSubnamespace(fullName)}";

			enumDictionary.GetOrAdd(@namespace).Add(enumDoc, name);
		}
		foreach ((string @namespace, Dictionary<EnumDocumentation, string> nameDictionary) in enumDictionary)
		{
			Dictionary<string, int> conflicts = GetDuplicates(nameDictionary.Values).ToDictionary(key => key, key => 0);
			foreach ((EnumDocumentation enumDoc, string name) in nameDictionary)
			{
				EnumUnderlyingType enumUnderlyingType = enumDoc.ElementType.ToEnumUnderlyingType();

				string nonConflictingTypeName;
				if (conflicts.TryGetValue(name, out int typeNameIndex))
				{
					nonConflictingTypeName = $"{name}_{typeNameIndex}";
					conflicts[name] = typeNameIndex + 1;
				}
				else
				{
					nonConflictingTypeName = name;
				}

				TypeDefinition type = EnumCreator.CreateEmptyEnum(SharedState.Instance, @namespace, nonConflictingTypeName, enumUnderlyingType);
				if (name.Contains("flags", StringComparison.OrdinalIgnoreCase) || name.Contains("mask", StringComparison.OrdinalIgnoreCase))
				{
					type.AddCustomAttribute(flagsConstructor);
				}
				string memberPrefix = enumDoc.Members.Count > 1 ? GetSharedPrefix(enumDoc.Members.Keys) : "";
				Dictionary<EnumMemberDocumentation, string> members = new();
				HashSet<(string, long)> distinctFields = new();
				foreach (EnumMemberDocumentation enumMember in enumDoc.Members.Values)
				{
					string memberName = enumMember.Name
						.RemovePrefix(memberPrefix)
						.RemoveLeadingUnderscores()
						.RemoveTrailingSuffix()
						.TryMakePascalCase();
					if (memberName.Length == 0)
					{
						memberName = $"EnumField_{GetStringForLong(enumMember.Value)}";
					}
					if (distinctFields.Add((memberName, enumMember.Value)))
					{
						members.Add(enumMember, memberName);
					}
				}
				HashSet<string> memberConflicts = GetDuplicates(members.Values);
				foreach ((EnumMemberDocumentation enumMember, string memberName) in members.OrderBy(pair => pair.Key.Value))
				{
					string nonConflictingName = memberConflicts.Contains(memberName)
						? $"{memberName}_{GetStringForLong(enumMember.Value)}"
						: memberName;
					FieldDefinition field = type.AddEnumField(nonConflictingName, enumMember.Value, enumUnderlyingType);
					if (memberName != enumMember.Name)
					{
						DocumentationHandler.AddFieldDefinitionLine(field, $"Original name: {enumMember.Name}");
					}
				}
				DocumentationHandler.AddTypeDefinitionLine(type, $"Full Name: {enumDoc.FullName}");
			}
		}
		Console.WriteLine($"\t{file.Enums.Count} generated enums.");
	}

	private static HashSet<T> GetDuplicates<T>(IEnumerable<T> values)
	{
		HashSet<T> distinctValues = new();
		HashSet<T> duplicateValues = new();
		foreach (T value in values)
		{
			if (!distinctValues.Add(value))
			{
				duplicateValues.Add(value);
			}
		}
		return duplicateValues;
	}

	private static string GetStringForLong(long value)
	{
		return value >= 0 ? value.ToString() : $"N{value.ToString().AsSpan(1)}";
	}

	private static string GetSubnamespace(string fullName)
	{
		foreach ((string prefix, string prefixNamespace) in fullNamePrefixToNamespace)
		{
			if (fullName.StartsWith(prefix, StringComparison.Ordinal))
			{
				return prefixNamespace;
			}
		}

		return "Global";
	}

	private static string TryMakePascalCase(this string str)
	{
		if (str.IsAllUpperCaseAndUnderScores() || str.IsAllLowerCaseAndUnderScores())
		{
			return str.ConvertToPascalCase().FixBeginning();
		}
		else
		{
			return str.RemoveUnderscores().FixBeginning();
		}
	}

	private static string GetNameNotVague(string fullName, string name)
	{
		if (vagueNames.Contains(name))
		{
			string[] fullNameSplit = fullName.Split('.');
			if (fullNameSplit.Length < 2)
			{
				return name;
			}
			else
			{
				string newName = $"{fullNameSplit[fullNameSplit.Length - 2]}_{fullNameSplit[fullNameSplit.Length - 1]}";
				return RemoveLeadingUnderscores(newName);
			}
		}
		else
		{
			return name;
		}
	}

	private static string GetSharedPrefix(IEnumerable<string> names)
	{
		string? result = null;
		foreach (string name in names)
		{
			result = result is null ? name : GetSharedPrefix(result, name);
		}
		return result ?? "";
	}

	private static string GetSharedPrefix(string str1, string str2)
	{
		int i = 0;
		for (; i < str1.Length && i < str2.Length; i++)
		{
			if (str1[i] != str2[i])
			{
				break;
			}
		}
		return str1.Substring(0, i);
	}

	private static string RemovePrefix(this string str, string prefix)
	{
		return str.Substring(prefix.Length);
	}

	private static bool IsAllUpperCaseAndUnderScores(this string str)
	{
		return str.All(c => c == '_' || char.IsUpper(c) || char.IsDigit(c));
	}

	private static bool IsAllLowerCaseAndUnderScores(this string str)
	{
		return str.All(c => c == '_' || char.IsLower(c) || char.IsDigit(c));
	}

	private static string ConvertToPascalCase(this string str)
	{
		StringBuilder sb = new StringBuilder();
		bool nextCharacterIsUpperCase = true;
		foreach (char c in str)
		{
			if (c == '_')
			{
				nextCharacterIsUpperCase = true;
			}
			else if (nextCharacterIsUpperCase)
			{
				sb.Append(char.ToUpper(c));
				nextCharacterIsUpperCase = false;
			}
			else
			{
				sb.Append(char.ToLower(c));
			}
		}
		return sb.ToString();
	}

	private static string RemoveUnderscores(this string str)
	{
		if (!str.Contains('_'))
		{
			return str;
		}
		else
		{
			StringBuilder sb = new StringBuilder();
			foreach (char c in str)
			{
				if (c != '_')
				{
					sb.Append(c);
				}
			}
			return sb.ToString();
		}
	}

	private static string RemoveLeadingUnderscores(this string str)
	{
		for (int i = 0; i < str.Length; i++)
		{
			if (str[i] != '_')
			{
				return str.Substring(i);
			}
		}
		return str;
	}

	private static string RemoveTrailingSuffix(this string str)
	{
		if (str.EndsWith('_'))
		{
			return str.Substring(0, str.Length - 1);
		}
		else if (str.EndsWith("_t", StringComparison.Ordinal))
		{
			return str.Substring(0, str.Length - 2);
		}
		else
		{
			return str;
		}
	}

	private static string FixBeginning(this string str)
	{
		if (str.Length == 0)
		{
			return str;
		}
		char firstCharacter = str[0];
		if (char.IsDigit(firstCharacter))
		{
			return $"E{str}";
		}
		else if (char.IsLower(firstCharacter))
		{
			return $"{char.ToUpperInvariant(firstCharacter)}{str.AsSpan(1)}";
		}
		else
		{
			return str;
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass045_AddMarkerInterfaces.cs`:

```cs
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass045_AddMarkerInterfaces
{
	public static void DoPass()
	{
		foreach (ClassGroup group in SharedState.Instance.ClassGroups.Values)
		{
			if (group.UniformlyNamed)
			{
				group.Interface.AddInterfaceImplementation(GetOrAddMarkerInterface(group.Name));
			}
			else
			{
				foreach (GeneratedClassInstance instance in group.Instances)
				{
					instance.Type.AddInterfaceImplementation(GetOrAddMarkerInterface(instance.Name));
				}
			}
		}
	}

	private static string GetInterfaceName(string className) => $"I{className}Marker";

	private static TypeDefinition GetOrAddMarkerInterface(string className)
	{
		string interfaceName = GetInterfaceName(className);
		if (!SharedState.Instance.MarkerInterfaces.TryGetValue(className, out TypeDefinition? result))
		{
			result = InterfaceCreator.CreateEmptyInterface(SharedState.Instance.Module, SharedState.MarkerInterfacesNamespace, interfaceName);
			result.AddInterfaceImplementation<IUnityObjectBase>(SharedState.Instance.Importer);
			SharedState.Instance.MarkerInterfaces.Add(className, result);
		}
		return result;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass052_InterfacePropertiesAndMethods.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets.Generics;
using System.Text;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass052_InterfacePropertiesAndMethods
{
	private static readonly SignatureComparer signatureComparer = new(SignatureComparisonFlags.VersionAgnostic);

	public static void DoPass()
	{
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			group.ImplementProperties();
		}
	}

	private static void ImplementProperties(this ClassGroupBase group)
	{
		Dictionary<string, (string, TypeSignature, bool)> propertyDictionary = group.GetPropertyDictionary();
		HashSet<string> differingFieldNames = group.GetDifferingFieldNames();

		foreach ((string propertyName, (string fieldName, TypeSignature propertyTypeSignature, bool hasConflictingTypes)) in propertyDictionary)
		{
			bool missingOnSomeVersions = differingFieldNames.Contains(fieldName);
			bool isValueType = propertyTypeSignature.IsValueType;

			PropertyDefinition propertyDeclaration = group.AddInterfacePropertyDeclaration(propertyName, propertyTypeSignature);
			InterfaceProperty interfaceProperty = new InterfaceProperty(propertyDeclaration, group);
			group.InterfaceProperties.Add(interfaceProperty);

			foreach (GeneratedClassInstance instance in group.Instances)
			{
				FieldDefinition? field = instance.Type.TryGetFieldByName(fieldName, true);
				PropertyDefinition property;
				ClassProperty classProperty;
				if (hasConflictingTypes || missingOnSomeVersions)
				{
					if (field is not { Signature.FieldType: { } fieldType } || !instance.Class.ContainsField(fieldName))
					{
						// Field either:
						// * doesn't exist
						// * exists in a base class, but isn't present in this derived class
						property = instance.ImplementInterfaceProperty(interfaceProperty, null);
						classProperty = new ClassProperty(property, null, interfaceProperty, instance);
					}
					else if (!hasConflictingTypes || signatureComparer.Equals(fieldType, propertyTypeSignature))
					{
						property = instance.ImplementInterfaceProperty(interfaceProperty, field);
						classProperty = new ClassProperty(property, field, interfaceProperty, instance);

						if (propertyTypeSignature is SzArrayTypeSignature)
						{
							property.FixNullableArraySetMethod(field);
						}
					}
					else if (interfaceProperty.HasSetAccessor && fieldType.IsIntegerPrimitive(out ElementType fieldPrimitive) && propertyTypeSignature.IsIntegerPrimitive(out ElementType propertyPrimitive))
					{
						// Field exists, but is the wrong primitive type, so we convert.
						// Because we check HasSetAccessor, this does not run on PPtrs, which is fine.
						property = instance.Type.AddFullProperty(propertyName, InterfaceUtils.InterfacePropertyImplementation, propertyTypeSignature);

						// get
						{
							CilInstructionCollection instructions = property.GetMethod!.CilMethodBody!.Instructions;
							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldfld, field);
							instructions.Add(propertyPrimitive switch
							{
								ElementType.U1 => CilOpCodes.Conv_U1,
								ElementType.U2 => CilOpCodes.Conv_U2,
								ElementType.U4 => CilOpCodes.Conv_U4,
								ElementType.U => CilOpCodes.Conv_U,
								ElementType.U8 => CilOpCodes.Conv_U8,
								ElementType.I1 => CilOpCodes.Conv_I1,
								ElementType.I2 => CilOpCodes.Conv_I2,
								ElementType.I4 => CilOpCodes.Conv_I4,
								ElementType.I => CilOpCodes.Conv_I,
								ElementType.I8 => CilOpCodes.Conv_I8,
								_ => throw new NotSupportedException(),
							});
							instructions.Add(CilOpCodes.Ret);
						}

						// set
						{
							CilInstructionCollection instructions = property.SetMethod!.CilMethodBody!.Instructions;
							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldarg_1);
							instructions.Add(fieldPrimitive switch
							{
								ElementType.U1 => CilOpCodes.Conv_U1,
								ElementType.U2 => CilOpCodes.Conv_U2,
								ElementType.U4 => CilOpCodes.Conv_U4,
								ElementType.U => CilOpCodes.Conv_U,
								ElementType.U8 => CilOpCodes.Conv_U8,
								ElementType.I1 => CilOpCodes.Conv_I1,
								ElementType.I2 => CilOpCodes.Conv_I2,
								ElementType.I4 => CilOpCodes.Conv_I4,
								ElementType.I => CilOpCodes.Conv_I,
								ElementType.I8 => CilOpCodes.Conv_I8,
								_ => throw new NotSupportedException(),
							});
							instructions.Add(CilOpCodes.Stfld, field);
							instructions.Add(CilOpCodes.Ret);
						}

						// We give a null backing field here because it doesn't actually have one.
						// The other property is the one that actually has a backing field.
						classProperty = new ClassProperty(property, null, interfaceProperty, instance);
					}
					else
					{
						// Field is not compatible with the property
						property = instance.ImplementInterfaceProperty(interfaceProperty, null);
						classProperty = new ClassProperty(property, null, interfaceProperty, instance);
					}

					instance.Properties.Add(classProperty);
				}
				else
				{
					property = instance.ImplementInterfaceProperty(interfaceProperty, field);
					classProperty = new ClassProperty(property, field, interfaceProperty, instance);
					instance.Properties.Add(classProperty);
				}

				if (instance.Type.IsAbstract || instance.Group.ID is 2)
				{
					property.AddDebuggerBrowsableNeverAttribute();//Properties in base classes are redundant in the debugger.
				}
				else if (classProperty.IsAbsent)
				{
					property.AddDebuggerBrowsableNeverAttribute();//Dummy properties should not be visible in the debugger.
				}
				else if (classProperty.Name == "Name_R")
				{
					property.AddDebuggerBrowsableNeverAttribute();//Name_R is redundant in the debugger because a Name property exists.
				}
			}
		}
	}

	private static HashSet<string> GetDifferingFieldNames(this ClassGroupBase group)
	{
		List<(GeneratedClassInstance, List<string>)> data = new();
		List<string> allFieldNames = new();
		foreach (GeneratedClassInstance instance in group.Instances)
		{
			List<string> instanceFieldNames = instance.Class.GetFieldNames().ToList();
			data.Add((instance, instanceFieldNames));
			allFieldNames.AddRange(instanceFieldNames);
		}
		return allFieldNames.Distinct().Where(f => data.Any(pair => !pair.Item2.Contains(f))).ToHashSet();
	}

	/// <summary>
	/// Field name : List of field types
	/// </summary>
	private static Dictionary<string, List<TypeSignature>> GetFieldTypeListDictionary(this ClassGroupBase group)
	{
		Dictionary<string, List<TypeSignature>> result = new();
		foreach (GeneratedClassInstance instance in group.Instances)
		{
			foreach (string fieldName in instance.Class.GetFieldNames())
			{
				TypeSignature fieldType = instance.Type.GetFieldByName(fieldName, true).Signature!.FieldType;
				List<TypeSignature> typeList = result.GetOrAdd(fieldName);
				if (!typeList.Any(sig => signatureComparer.Equals(sig, fieldType)))
				{
					typeList.Add(fieldType);
				}
			}
		}
		return result;
	}

	private static Dictionary<string, T> SortStringDictionary<T>(this Dictionary<string, T> dictionary)
	{
		var keyList = dictionary.Keys.ToList();
		keyList.Sort();
		return keyList.ToDictionary(key => key, key => dictionary[key]);
	}

	/// <summary>
	/// Property name : field name, property type, type conflict
	/// </summary>
	private static Dictionary<string, (string, TypeSignature, bool)> GetPropertyDictionary(this ClassGroupBase group)
	{
		Dictionary<string, List<TypeSignature>> fieldTypeDictionary = group.GetFieldTypeListDictionary().SortStringDictionary();
		Dictionary<string, (string, TypeSignature, bool)> propertyDictionary = new();

		foreach ((string fieldName, List<TypeSignature> fieldTypeList) in fieldTypeDictionary)
		{
			string propertyName = GeneratedInterfaceUtils.GetPropertyNameFromFieldName(fieldName, group);
			if (fieldTypeList.Count == 1)
			{
				propertyDictionary.Add(propertyName, (fieldName, fieldTypeList[0], false));
			}
			else if (TryGetCommonInheritor(fieldTypeList, out TypeSignature? baseInterface))
			{
				propertyDictionary.Add(propertyName, (fieldName, baseInterface, false));
			}
			else if (TryGetCommonGenericInstance(fieldTypeList, out TypeSignature? accessTypeSignature))
			{
				propertyDictionary.Add(propertyName, (fieldName, accessTypeSignature, false));
			}
			else
			{
				foreach (TypeSignature fieldType in fieldTypeList)
				{
					string fieldTypeName = GetName(fieldType);
					propertyDictionary.Add($"{propertyName}_{fieldTypeName}", (fieldName, fieldType, true));
				}
			}
		}

		return propertyDictionary;
	}

	private static bool TryGetCommonGenericInstance(List<TypeSignature> fieldTypeList, [NotNullWhen(true)] out TypeSignature? accessTypeSignature)
	{
		accessTypeSignature = null;
		if (fieldTypeList.TryCast(out List<GenericInstanceTypeSignature>? genericInstanceFields))
		{
			if (genericInstanceFields.All(genericInstance => genericInstance.GenericType.Name == "AssetList`1"))
			{
				List<TypeSignature> typeArguments = genericInstanceFields.Select(genericInstance => genericInstance.TypeArguments.Single()).ToList();
				if (TryGetCommonInheritor(typeArguments, out TypeSignature? commonInterface))
				{
					accessTypeSignature = SharedState.Instance.Importer.ImportTypeSignature(typeof(AccessListBase<>)).MakeGenericInstanceType(commonInterface);
				}
			}
			else if (genericInstanceFields.All(genericInstance => genericInstance.GenericType.Name == "AssetDictionary`2"))
			{
				List<TypeSignature> keyTypeArguments = genericInstanceFields.Select(genericInstance => genericInstance.TypeArguments[0]).ToList();
				List<TypeSignature> valueTypeArguments = genericInstanceFields.Select(genericInstance => genericInstance.TypeArguments[1]).ToList();
				if (keyTypeArguments.TryGetEqualityOrCommonInheritor(out TypeSignature? commonKeyType)
					&& valueTypeArguments.TryGetEqualityOrCommonInheritor(out TypeSignature? commonValueType))
				{
					accessTypeSignature = SharedState.Instance.Importer.ImportTypeSignature(typeof(AccessDictionaryBase<,>))
						.MakeGenericInstanceType(commonKeyType, commonValueType);
				}
			}
			//Pair only used by Sprite and it's AssetPair<GUID, long>
		}
		return accessTypeSignature != null;
	}

	private static bool TryGetEqualityOrCommonInheritor(this List<TypeSignature> types, [NotNullWhen(true)] out TypeSignature? commonType)
	{
		return types.TryGetEquality(out commonType) || types.TryGetCommonInheritor(out commonType);
	}

	private static bool TryGetEquality(this List<TypeSignature> types, [NotNullWhen(true)] out TypeSignature? commonType)
	{
		TypeSignature first = types.First();
		if (types.All(type => signatureComparer.Equals(type, first)))
		{
			commonType = first;
			return true;
		}
		else
		{
			commonType = null;
			return false;
		}
	}

	private static bool TryGetCommonInheritor(this List<TypeSignature> types, [NotNullWhen(true)] out TypeSignature? baseInterface)
	{
		if (types.Count == 0)
		{
			throw new ArgumentException(null, nameof(types));
		}

		if (TryGetTypeDefinitionsForTypeSignatures(types, out List<TypeDefinition>? typeDefinitions))
		{
			ClassGroupBase group = SharedState.Instance.TypesToGroups[typeDefinitions[0]];
			if (!typeDefinitions.Any(def => !group.ContainsTypeDefinition(def)))
			{
				baseInterface = group.GetSingularTypeOrInterface().ToTypeSignature();
				return true;
			}
		}
		baseInterface = null;
		return false;
	}

	private static bool ContainsTypeDefinition(this ClassGroupBase group, TypeDefinition type)
	{
		//any instance where an instance's type definition is equal or the group interface is equal
		return group.Instances.Any(instance => signatureComparer.Equals(type, instance.Type)) || signatureComparer.Equals(type, group.Interface);
	}

	private static bool TryGetTypeDefinitionForTypeSignature(TypeSignature typeSignature, [NotNullWhen(true)] out TypeDefinition? typeDefinition)
	{
		typeDefinition = (typeSignature as TypeDefOrRefSignature)?.Type as TypeDefinition;
		return typeDefinition != null;
	}

	private static TypeDefinition? TryGetTypeDefinitionForTypeSignature(TypeSignature typeSignature)
	{
		return (typeSignature as TypeDefOrRefSignature)?.Type as TypeDefinition;
	}

	private static bool TryGetTypeDefinitionsForTypeSignatures(List<TypeSignature> typeSignatures, [NotNullWhen(true)] out List<TypeDefinition>? typeDefinitions)
	{
		typeDefinitions = new List<TypeDefinition>(typeSignatures.Count);
		foreach (TypeSignature typeSignature in typeSignatures)
		{
			if (TryGetTypeDefinitionForTypeSignature(typeSignature, out TypeDefinition? typeDefinition))
			{
				typeDefinitions.Add(typeDefinition);
			}
			else
			{
				typeDefinitions = null;
				return false;
			}
		}
		return true;
	}

	private static PropertyDefinition AddInterfacePropertyDeclaration(this ClassGroupBase group, string propertyName, TypeSignature propertyType)
	{
		return !group.IsPPtr && ShouldUseFullProperty(propertyType)
			? group.Interface.AddFullProperty(propertyName, InterfaceUtils.InterfacePropertyDeclaration, propertyType)
			: group.Interface.AddGetterProperty(propertyName, InterfaceUtils.InterfacePropertyDeclaration, propertyType);
	}

	private static bool ShouldUseFullProperty(TypeSignature propertyType)
	{
		return propertyType is SzArrayTypeSignature or CorLibTypeSignature || propertyType.IsUtf8String() || propertyType.IsValueType;
	}

	private static PropertyDefinition ImplementInterfaceProperty(this GeneratedClassInstance instance, InterfaceProperty interfaceProperty, FieldDefinition? field)
	{
		TypeDefinition declaringType = instance.Type;
		string propertyName = interfaceProperty.Name;
		TypeSignature propertyType = interfaceProperty.Definition.Signature!.ReturnType;
		if (interfaceProperty.HasSetAccessor)
		{
			return declaringType.ImplementFullProperty(propertyName, InterfaceUtils.InterfacePropertyImplementation, propertyType, field);
		}
		else if (field is not null && propertyType is GenericInstanceTypeSignature genericPropertyType)
		{
			IMethodDefOrRef constructor;
			switch (genericPropertyType.GenericType.Name?.Value)
			{
				case "AccessListBase`1":
					{
						GenericInstanceTypeSignature fieldType = field.Signature?.FieldType as GenericInstanceTypeSignature ?? throw new();
						TypeSignature underlyingType = fieldType.TypeArguments.Single();
						TypeSignature baseType = genericPropertyType.TypeArguments.Single();
						GenericInstanceTypeSignature accessListSignature = SharedState.Instance.Importer
							.ImportTypeSignature(typeof(AccessList<,>))
							.MakeGenericInstanceType(underlyingType, baseType);
						constructor = MethodUtils.MakeConstructorOnGenericType(SharedState.Instance.Importer, accessListSignature, 1);
					}
					break;
				case "AccessDictionaryBase`2":
					{
						GenericInstanceTypeSignature fieldType = field.Signature?.FieldType as GenericInstanceTypeSignature ?? throw new();
						TypeSignature keyNormalType = fieldType.TypeArguments[0];
						TypeSignature valueNormalType = fieldType.TypeArguments[1];
						TypeSignature keyBaseType = genericPropertyType.TypeArguments[0];
						TypeSignature valueBaseType = genericPropertyType.TypeArguments[1];
						GenericInstanceTypeSignature accessDictionarySignature = SharedState.Instance.Importer
							.ImportTypeSignature(typeof(AccessDictionary<,,,>))
							.MakeGenericInstanceType(keyNormalType, valueNormalType, keyBaseType, valueBaseType);
						constructor = MethodUtils.MakeConstructorOnGenericType(SharedState.Instance.Importer, accessDictionarySignature, 1);
					}
					break;
				case "AccessPairBase`2":
					//Pair only used by Sprite and it's AssetPair<GUID, long>
					throw new NotSupportedException("AccessPair not supported.");
				default:
					//Handles AssetList, AssetDictionary, and AssetPair
					return declaringType.ImplementGetterProperty(propertyName, InterfaceUtils.InterfacePropertyImplementation, propertyType, field);
			}
			PropertyDefinition property = declaringType.AddGetterProperty(propertyName, InterfaceUtils.InterfacePropertyImplementation, propertyType);
			FieldDefinition cacheField = declaringType
				.AddField($"_{propertyName}_k__BackingField", propertyType, visibility: Visibility.Private)
				.AddNullableAttributesForMaybeNull();
			cacheField.AddDebuggerBrowsableNeverAttribute();
			CilInstructionCollection instructions = property.GetMethod!.CilMethodBody!.Instructions;

			CilInstructionLabel afterAssignmentLabel = new();

			//if accessValue is null
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, cacheField);
			instructions.Add(CilOpCodes.Ldnull);
			instructions.Add(CilOpCodes.Ceq);
			instructions.Add(CilOpCodes.Brfalse_S, afterAssignmentLabel);

			//accessValue = new(referenceValue);
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, field);
			instructions.Add(CilOpCodes.Newobj, constructor);
			instructions.Add(CilOpCodes.Stfld, cacheField);

			//return accessValue
			afterAssignmentLabel.Instruction = instructions.Add(CilOpCodes.Nop);
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, cacheField);
			instructions.Add(CilOpCodes.Ret);
			return property;
		}
		else
		{
			return declaringType.ImplementGetterProperty(propertyName, InterfaceUtils.InterfacePropertyImplementation, propertyType, field);
		}
	}

	/// <summary>
	/// Ensures that the <paramref name="field"/> is set to <see cref="Array.Empty{T}"/> instead of null.
	/// </summary>
	private static void FixNullableArraySetMethod(this PropertyDefinition property, FieldDefinition field)
	{
		TypeSignature elementType = ((SzArrayTypeSignature)field.Signature!.FieldType).BaseType;
		MethodSpecification emptyArrayMethod = SharedState.Instance.Importer
			.ImportMethod(typeof(Array), m => m.Name == nameof(Array.Empty))
			.MakeGenericInstanceMethod(elementType);

		CilInstructionCollection instructions = property.SetMethod!.CilMethodBody!.Instructions;
		instructions.Clear();
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldarg_1); //value

		CilInstructionLabel label = new();
		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Brtrue, label);
		instructions.Add(CilOpCodes.Pop);
		instructions.Add(CilOpCodes.Call, emptyArrayMethod);

		label.Instruction = instructions.Add(CilOpCodes.Stfld, field);
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
	}

	private static IEnumerable<string> GetFieldNames(this UniversalClass universalClass)
	{
		return universalClass.EditorRootNode.GetFieldNames().Union(universalClass.ReleaseRootNode.GetFieldNames()).Distinct();
	}

	private static IEnumerable<string> GetFieldNames(this UniversalNode? rootNode)
	{
		return rootNode?.SubNodes.Select(node => node.Name) ?? Enumerable.Empty<string>();
	}

	private static string GetName(TypeSignature type)
	{
		if (type is CorLibTypeSignature)
		{
			return type.Name ?? throw new NullReferenceException();
		}
		else if (type is TypeDefOrRefSignature normalType)
		{
			string asmName = normalType.Name;
			int index = asmName.IndexOf('`');
			return index > -1 ? asmName.Substring(0, index) : asmName;
		}
		else if (type is SzArrayTypeSignature arrayType)
		{
			return $"{GetName(arrayType.BaseType)}_Array";
		}
		else if (type is GenericInstanceTypeSignature genericInstanceType)
		{
			string baseTypeName = GetName(genericInstanceType.GenericType.ToTypeSignature());
			StringBuilder sb = new();
			sb.Append(baseTypeName);
			foreach (TypeSignature typeArgument in genericInstanceType.TypeArguments)
			{
				sb.Append('_');
				sb.Append(GetName(typeArgument));
			}
			return sb.ToString();
		}
		else
		{
			throw new NotSupportedException($"GetName not support for {type.FullName} of type {type.GetType()}");
		}
	}

	private static bool TryCast<T, TCast>(this List<T> originalList, [NotNullWhen(true)] out List<TCast>? castedList)
	{
		castedList = new List<TCast>(originalList.Count);
		foreach (T element in originalList)
		{
			if (element is TCast castedElement)
			{
				castedList.Add(castedElement);
			}
			else
			{
				castedList = null;
				return false;
			}
		}
		return true;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass053_HasMethodsAndNullableAttributes.cs`:

```cs
using AssetRipper.AssemblyDumper.Attributes;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.DocExtraction.Extensions;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass053_HasMethodsAndNullableAttributes
{
	public static void DoPass()
	{
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			ApplyNullableAttributesToTypes(group);
			AddHasMethodsAndApplyNullableAttributesToProperties(group);
			AddIsMethods(group);
			AddMemberNotNullAttributesToInterfaceMethods(group);
		}
	}

	private static void ApplyNullableAttributesToTypes(ClassGroupBase group)
	{
		group.Interface.AddNullableContextAttribute(NullableAnnotation.NotNull);
		group.Interface.AddNullableAttribute(NullableAnnotation.Oblivious);
		foreach (TypeDefinition instanceType in group.Types)
		{
			instanceType.AddNullableContextAttribute(NullableAnnotation.NotNull);
			instanceType.AddNullableAttribute(NullableAnnotation.Oblivious);
		}
	}

	private static void AddHasMethodsAndApplyNullableAttributesToProperties(ClassGroupBase group)
	{
		foreach (InterfaceProperty interfaceProperty in group.InterfaceProperties)
		{
			if (interfaceProperty.AbsentRange.IsEmpty())
			{
				continue;
			}

			bool isValueType = interfaceProperty.Definition.IsValueType();
			string propertyName = interfaceProperty.Definition.Name!;
			interfaceProperty.HasMethod = group.Interface.AddHasMethodDeclaration(propertyName);

			if (!isValueType)
			{
				interfaceProperty.Definition.AddNullableAttributesForMaybeNull();
			}

			foreach (ClassProperty classProperty in interfaceProperty.Implementations)
			{
				classProperty.HasMethod = classProperty.Class.Type.AddHasMethodImplementation(classProperty.Definition.Name!, classProperty.BackingField is not null);

				if (!isValueType)
				{
					classProperty.Definition.AddNullableAttributesForMaybeNull();
					if (classProperty.BackingField is not null)
					{
						classProperty.Definition.GetMethod!.AddNotNullAttribute();
					}
				}
			}
		}
	}

	private static void AddIsMethods(ClassGroupBase group)
	{
		foreach (InterfaceProperty interfaceProperty in group.InterfaceProperties)
		{
			string propertyName = interfaceProperty.Definition.Name!;
			if (!interfaceProperty.ReleaseOnlyRange.IsEmpty() && interfaceProperty.ReleaseOnlyRange != interfaceProperty.PresentRange)
			{
				interfaceProperty.ReleaseOnlyMethod = group.Interface.AddReleaseOnlyMethodDeclaration(propertyName);
				foreach (ClassProperty classProperty in interfaceProperty.Implementations)
				{
					classProperty.ReleaseOnlyMethod = classProperty.Class.Type.AddReleaseOnlyMethodImplementation(propertyName, classProperty.IsReleaseOnly);
				}
			}
			if (!interfaceProperty.EditorOnlyRange.IsEmpty() && interfaceProperty.EditorOnlyRange != interfaceProperty.PresentRange)
			{
				interfaceProperty.EditorOnlyMethod = group.Interface.AddEditorOnlyMethodDeclaration(propertyName);
				foreach (ClassProperty classProperty in interfaceProperty.Implementations)
				{
					classProperty.EditorOnlyMethod = classProperty.Class.Type.AddEditorOnlyMethodImplementation(propertyName, classProperty.IsEditorOnly);
				}
			}
		}
	}

	private static void AddMemberNotNullAttributesToInterfaceMethods(ClassGroupBase group)
	{
		foreach (InterfaceProperty property in group.InterfaceProperties)
		{
			if (property.HasMethod is null && property.ReleaseOnlyMethod is null && property.EditorOnlyMethod is null)
			{
				continue;
			}

			foreach (InterfaceProperty otherProperty in group.InterfaceProperties)
			{
				if (otherProperty.HasMethod is null || otherProperty.Definition.IsValueType())
				{
					continue;
				}
				if (property.HasMethod is not null)
				{
					//other is always present when this is present
					if (otherProperty.PresentRange.Contains(property.PresentRange))
					{
						property.HasMethod.AddMemberNotNullWhenAttribute(SharedState.Instance.Importer, true, otherProperty.Definition.Name!);
					}
					//other is always present when this is absent
					else if (otherProperty.PresentRange.Contains(property.AbsentRange))
					{
						property.HasMethod.AddMemberNotNullWhenAttribute(SharedState.Instance.Importer, false, otherProperty.Definition.Name!);
					}
				}
				if (property.ReleaseOnlyMethod is not null)
				{
					//other is always present when this is release only
					if (otherProperty.PresentRange.Contains(property.ReleaseOnlyRange))
					{
						property.ReleaseOnlyMethod.AddMemberNotNullWhenAttribute(SharedState.Instance.Importer, true, otherProperty.Definition.Name!);
					}
					//other is always present when this is not release only
					else if (otherProperty.PresentRange.Contains(property.NotReleaseOnlyRange))
					{
						property.ReleaseOnlyMethod.AddMemberNotNullWhenAttribute(SharedState.Instance.Importer, false, otherProperty.Definition.Name!);
					}
				}
				if (property.EditorOnlyMethod is not null)
				{
					//other is always present when this is editor only
					if (otherProperty.PresentRange.Contains(property.EditorOnlyRange))
					{
						property.EditorOnlyMethod.AddMemberNotNullWhenAttribute(SharedState.Instance.Importer, true, otherProperty.Definition.Name!);
					}
					//other is always present when this is not editor only
					else if (otherProperty.PresentRange.Contains(property.NotEditorOnlyRange))
					{
						property.EditorOnlyMethod.AddMemberNotNullWhenAttribute(SharedState.Instance.Importer, false, otherProperty.Definition.Name!);
					}
				}
			}
		}
	}

	private static MethodDefinition AddHasMethodDeclaration(this TypeDefinition @interface, string propertyName)
	{
		return @interface.AddBooleanMethodDeclaration(GeneratedInterfaceUtils.GetHasMethodName(propertyName));
	}

	private static MethodDefinition AddHasMethodImplementation(this TypeDefinition declaringType, string propertyName, bool returnTrue)
	{
		return declaringType.AddBooleanMethodImplementation(GeneratedInterfaceUtils.GetHasMethodName(propertyName), returnTrue);
	}

	private static MethodDefinition AddReleaseOnlyMethodDeclaration(this TypeDefinition @interface, string propertyName)
	{
		return @interface.AddBooleanMethodDeclaration(GeneratedInterfaceUtils.GetReleaseOnlyMethodName(propertyName));
	}

	private static MethodDefinition AddReleaseOnlyMethodImplementation(this TypeDefinition declaringType, string propertyName, bool returnTrue)
	{
		return declaringType.AddBooleanMethodImplementation(GeneratedInterfaceUtils.GetReleaseOnlyMethodName(propertyName), returnTrue);
	}

	private static MethodDefinition AddEditorOnlyMethodDeclaration(this TypeDefinition @interface, string propertyName)
	{
		return @interface.AddBooleanMethodDeclaration(GeneratedInterfaceUtils.GetEditorOnlyMethodName(propertyName));
	}

	private static MethodDefinition AddEditorOnlyMethodImplementation(this TypeDefinition declaringType, string propertyName, bool returnTrue)
	{
		return declaringType.AddBooleanMethodImplementation(GeneratedInterfaceUtils.GetEditorOnlyMethodName(propertyName), returnTrue);
	}

	private static MethodDefinition AddBooleanMethodDeclaration(this TypeDefinition @interface, string methodName)
	{
		return @interface.AddMethod(
			methodName,
			InterfaceUtils.InterfaceMethodDeclaration,
			SharedState.Instance.Importer.Boolean);
	}

	private static MethodDefinition AddBooleanMethodImplementation(this TypeDefinition declaringType, string methodName, bool returnTrue)
	{
		MethodDefinition method = declaringType.AddMethod(
			methodName,
			InterfaceUtils.InterfaceMethodImplementation,
			SharedState.Instance.Importer.Boolean);
		method.CilMethodBody!.Instructions.FillWithSimpleBooleanReturn(returnTrue);
		return method;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass054_AssignPropertyHistories.cs`:

```cs
using AssetRipper.DocExtraction.DataStructures;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass054_AssignPropertyHistories
{
	public static void DoPass()
	{
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			HashSet<GeneratedClassInstance> instancesWithHistoriesNotFromBase = new();
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				ComplexTypeHistory? history = TryGetHistoryInThisOrBase(instance, out bool usedBaseClass);
				if (history is null)
				{
					continue;
				}

				if (!usedBaseClass)
				{
					instancesWithHistoriesNotFromBase.Add(instance);
				}

				IReadOnlyDictionary<string, DataMemberHistory> members = history.GetAllMembers(instance.VersionRange.Start, SharedState.Instance.HistoryFile);
				foreach (ClassProperty classProperty in instance.Properties)
				{
					SetHistory(classProperty, members);
				}
			}
			foreach (InterfaceProperty interfaceProperty in group.InterfaceProperties)
			{
				interfaceProperty.History = interfaceProperty.DetermineHistoryFromImplementations(instancesWithHistoriesNotFromBase);
			}
		}
	}

	private static ComplexTypeHistory? TryGetHistoryInThisOrBase(GeneratedClassInstance instance, out bool usedBaseClass)
	{
		if (instance.History is not null)
		{
			usedBaseClass = false;
			return instance.History;
		}
		usedBaseClass = true;
		GeneratedClassInstance? current = instance.Base;
		while (current is not null)
		{
			if (current.History is not null)
			{
				return current.History;
			}
			current = current.Base;
		}
		return null;
	}

	private static void SetHistory(ClassProperty classProperty, IReadOnlyDictionary<string, DataMemberHistory> dictionary)
	{
		if (classProperty.OriginalFieldName is not null && TryGetHistoryFromOriginalName(classProperty.OriginalFieldName, dictionary, out DataMemberHistory? history))
		{
		}
		else if (classProperty.BackingField is not null)
		{
			if (dictionary.TryGetValue(classProperty.BackingField.Name!, out history))
			{
			}
			else
			{
				history = dictionary.FirstOrDefault(pair => HistoryIsApplicable(pair.Value, classProperty.BackingField)).Value;
			}
		}
		else
		{
			history = null;
		}
		classProperty.History = history;
	}

	private static bool TryGetHistoryFromOriginalName(string originalName, IReadOnlyDictionary<string, DataMemberHistory> dictionary, [NotNullWhen(true)] out DataMemberHistory? history)
	{
		if (dictionary.TryGetValue(originalName, out history))
		{
			return true;
		}
		else
		{
			history = dictionary.FirstOrDefault(pair => HistoryIsApplicable(pair.Value, originalName)).Value;
			return history is not null;
		}
	}

	private static bool HistoryIsApplicable(DataMemberHistory history, string originalName)
	{
		string historyNameNormalized = ValidNameGenerator.GetValidFieldName(history.Name).ToLowerInvariant();
		string fieldName = originalName.ToLowerInvariant();
		return historyNameNormalized == fieldName;
	}
	private static bool HistoryIsApplicable(DataMemberHistory history, FieldDefinition field)
	{
		string historyNameNormalized = ValidNameGenerator.GetValidFieldName(history.Name).ToLowerInvariant();
		string fieldName = field.Name!.ToString().ToLowerInvariant();
		if (historyNameNormalized == fieldName)
		{
			return true;
		}
		foreach (string? nativeName in history.NativeName.Values)
		{
			if (nativeName is null)
			{
			}
			else if (fieldName == nativeName.ToLowerInvariant()
				|| fieldName == ValidNameGenerator.GetValidFieldName(nativeName).ToLowerInvariant())
			{
				return true;
			}
		}
		return false;
	}

	private static DataMemberHistory? DetermineHistoryFromImplementations(this InterfaceProperty interfaceProperty, HashSet<GeneratedClassInstance> instancesWithHistoriesNotFromBase)
	{
		IEnumerable<ClassProperty> enumerable = instancesWithHistoriesNotFromBase.SelectMany(i => i.Properties).Where(c => c.Base == interfaceProperty);
		return TryGetUniqueHistory(enumerable, out DataMemberHistory? history) || TryGetUniqueHistory(interfaceProperty.Implementations, out history)
			? history
			: null;
	}

	/// <summary>
	/// 
	/// </summary>
	/// <param name="properties"></param>
	/// <param name="history">This will be null if there are conflicts or all the options are null.</param>
	/// <returns>True if a unique, possibly null, history has been decided.</returns>
	private static bool TryGetUniqueHistory(IEnumerable<ClassProperty> properties, out DataMemberHistory? history)
	{
		history = null;
		foreach (ClassProperty classProperty in properties)
		{
			if (history is null)
			{
				history = classProperty.History;
			}
			else if (classProperty.History is null)
			{
			}
			else if (history != classProperty.History)
			{
				history = null;
				return true;
			}
		}
		return history is not null;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass055_CreateEnumProperties.cs`:

```cs
using AssetRipper.AssemblyDumper.Enums;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.DocExtraction.Extensions;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass055_CreateEnumProperties
{
	public static void DoPass()
	{
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			foreach (InterfaceProperty interfaceProperty in group.InterfaceProperties)
			{
				if (interfaceProperty.TryGetEnumFullName(out string? fullName) && Pass040_AddEnums.EnumDictionary.TryGetValue(fullName, out (TypeDefinition, EnumDefinitionBase) tuple))
				{
					CreateEnumProperty(group, interfaceProperty, tuple.Item1);
				}
			}
		}
	}

	private static void CreateEnumProperty(ClassGroupBase group, InterfaceProperty interfaceProperty, TypeDefinition enumType)
	{
		ElementType enumElementType = ((CorLibTypeSignature)enumType.GetFieldByName("value__").Signature!.FieldType).ElementType;
		string propertyName = $"{interfaceProperty.Definition.Name}E";

		interfaceProperty.SpecialDefinition = group.Interface.AddFullProperty(
			propertyName,
			InterfaceUtils.InterfacePropertyDeclaration,
			enumType.ToTypeSignature());

		foreach (ClassProperty classProperty in interfaceProperty.Implementations)
		{
			if (classProperty.BackingField?.Signature?.FieldType is CorLibTypeSignature fieldTypeSignature
				&& fieldTypeSignature.ElementType.IsFixedSizeInteger())
			{
				classProperty.SpecialDefinition = classProperty.Class.Type.AddFullProperty(
					propertyName,
					InterfaceUtils.InterfacePropertyImplementation,
					enumType.ToTypeSignature());
				classProperty.SpecialDefinition.GetMethod!.GetInstructions().FillGetter(classProperty.BackingField, fieldTypeSignature.ElementType, enumElementType);
				classProperty.SpecialDefinition.SetMethod!.GetInstructions().FillSetter(classProperty.BackingField, fieldTypeSignature.ElementType, enumElementType);
				if (classProperty.Class.Type.IsAbstract)
				{
					classProperty.SpecialDefinition.AddDebuggerBrowsableNeverAttribute();//Properties in base classes are redundant in the debugger.
				}
			}
			else
			{
				classProperty.SpecialDefinition = classProperty.Class.Type.ImplementFullProperty(
					propertyName,
					InterfaceUtils.InterfacePropertyImplementation,
					enumType.ToTypeSignature(),
					null);
				classProperty.SpecialDefinition.AddDebuggerBrowsableNeverAttribute();//Dummy properties should not be visible in the debugger.
			}
		}
	}

	private static bool TryGetEnumFullName(this InterfaceProperty interfaceProperty, [NotNullWhen(true)] out string? fullName)
	{
		if (interfaceProperty.Group is ClassGroup
			&& (interfaceProperty.Name == "HideFlags" || interfaceProperty.Name.StartsWith("HideFlags_C", StringComparison.Ordinal)))
		{
			fullName = "UnityEngine.HideFlags";
			return true;
		}
		interfaceProperty.TryGetEnumFullNameFromHistory(out string? metadata);
		if (interfaceProperty.TryGetOverridenEnumFullName(out string? overriden))
		{
			fullName = metadata != overriden
				? overriden
				: throw new Exception($"{interfaceProperty.Group.Name}.{interfaceProperty.Name} did not need to be overriden.");
		}
		else
		{
			fullName = metadata;
		}
		return fullName is not null;
	}

	private static bool TryGetEnumFullNameFromHistory(this InterfaceProperty interfaceProperty, [NotNullWhen(true)] out string? fullName)
	{
		if (interfaceProperty.History is not null && interfaceProperty.History.TypeFullName.Count == 1)
		{
			fullName = interfaceProperty.History.TypeFullName[0].Value.ToString();
			return true;
		}
		else
		{
			fullName = null;
			return false;
		}
	}

	private static bool TryGetOverridenEnumFullName(this InterfaceProperty interfaceProperty, out string? fullName)
	{
		if (interfaceProperty.Group switch { _ => false })
		{
			fullName = null;
			return true;
		}

		fullName = interfaceProperty.Group switch
		{
			ClassGroup classGroup => classGroup.ID switch
			{
				1 => interfaceProperty.Name switch
				{
					"StaticEditorFlags" => "UnityEditor.StaticEditorFlags",
					_ => null,
				},
				11 => interfaceProperty.Name switch
				{
					"Default_Speaker_Mode" => "UnityEngine.AudioSpeakerMode",
					_ => null,
				},
				28 => interfaceProperty.Name switch
				{
					"ColorSpace_C28" => "UnityEngine.ColorSpace",
					"LightmapFormat_C28" => "UnityEditor.TextureUsageMode",
					_ => null,
				},
				30 => interfaceProperty.Name switch
				{
					"DefaultMobileRenderingPath" => "UnityEngine.RenderingPath",
					"DefaultRenderingPath" => "UnityEngine.RenderingPath",
					_ => null,
				},
				43 => interfaceProperty.Name switch
				{
					"MeshCompression" => "UnityEditor.ModelImporterMeshCompression",
					_ => null,
				},
				83 => interfaceProperty.Name switch
				{
					"CompressionFormat" => "UnityEngine.AudioCompressionFormat",
					_ => null,
				},
				117 => interfaceProperty.Name switch
				{
					"ColorSpace" => "UnityEngine.ColorSpace",
					"Dimension" => "UnityEngine.Rendering.TextureDimension",
					"LightmapFormat" => "UnityEditor.TextureUsageMode",
					"UsageMode" => "UnityEditor.TextureUsageMode",
					_ => null,
				},
				187 => interfaceProperty.Name switch
				{
					"ColorSpace" => "UnityEngine.ColorSpace",
					"UsageMode" => "UnityEditor.TextureUsageMode",
					_ => null,
				},
				188 => interfaceProperty.Name switch
				{
					"ColorSpace" => "UnityEngine.ColorSpace",
					"UsageMode" => "UnityEditor.TextureUsageMode",
					_ => null,
				},
				206 => interfaceProperty.Name switch
				{
					"BlendType_Int32" => "UnityEditor.Animations.BlendTreeType",
					"BlendType_UInt32" => "UnityEditor.Animations.BlendTreeType",
					_ => null,
				},
				1006 => interfaceProperty.Name switch
				{
					"Alignment" => "UnityEngine.SpriteAlignment",
					"AlphaUsage" => "UnityEditor.TextureImporterAlphaSource",
					"SpriteMeshType" => "UnityEngine.SpriteMeshType",
					_ => null,
				},
				_ => null,
			},
			SubclassGroup subclassGroup => subclassGroup.Name switch
			{
				"AnimationCurve_Single" or "AnimationCurve_Vector3f" or "AnimationCurve_Quaternionf" => interfaceProperty.Name switch
				{
					"PreInfinity" => "Injected.CurveLoopTypes",
					"PostInfinity" => "Injected.CurveLoopTypes",
					"RotationOrder" => "UnityEngine.RotationOrder",
					_ => null,
				},
				"BlendTreeNodeConstant" => interfaceProperty.Name switch
				{
					"BlendType" => "UnityEditor.Animations.BlendTreeType",
					_ => null,
				},
				"ConditionConstant" => interfaceProperty.Name switch
				{
					"ConditionMode" => "UnityEditor.Animations.AnimatorConditionMode",
					_ => null,
				},
				"Keyframe_Single" or "Keyframe_Vector3f" or "Keyframe_Quaternionf" => interfaceProperty.Name switch
				{
					"WeightedMode" => "UnityEngine.WeightedMode",
					_ => null,
				},
				"SubMesh" => interfaceProperty.Name switch
				{
					"Topology" or "IsTriStrip" => "UnityEngine.MeshTopology",
					_ => null,
				},
				"TextureImporterBumpMapSettings" => interfaceProperty.Name switch
				{
					"NormalMapFilter" => "UnityEditor.TextureImporterNormalFilter",
					_ => null,
				},
				"TextureImporterMipMapSettings" => interfaceProperty.Name switch
				{
					"MipMapMode" => "UnityEditor.TextureImporterMipFilter",
					_ => null,
				},
				"TextureImporterPlatformSettings" => interfaceProperty.Name switch
				{
					"AndroidETC2FallbackOverride" => "UnityEditor.AndroidETC2FallbackOverride",
					"Format" => "UnityEditor.TextureImporterFormat",
					"ResizeAlgorithm" => "UnityEditor.TextureResizeAlgorithm",
					"TextureCompression" => "UnityEditor.TextureImporterCompression",
					_ => null,
				},
				"TextureSettings" => interfaceProperty.Name switch
				{
					"FilterMode" => "UnityEngine.FilterMode",
					"TextureCompression" => "UnityEditor.TextureImporterCompression",
					_ => null,
				},
				"TierGraphicsSettings" => interfaceProperty.Name switch
				{
					"HdrMode" => "UnityEngine.Rendering.CameraHDRMode",
					"RealtimeGICPUUsage" => "UnityEngine.Rendering.RealtimeGICPUUsage",
					"RenderingPath" => "UnityEngine.RenderingPath",
					_ => null,
				},
				"TierGraphicsSettingsEditor" => interfaceProperty.Name switch
				{
					"HdrMode" => "UnityEngine.Rendering.CameraHDRMode",
					"RealtimeGICPUUsage" => "UnityEngine.Rendering.RealtimeGICPUUsage",
					"RenderingPath" => "UnityEngine.RenderingPath",
					"StandardShaderQuality" => "UnityEditor.Rendering.ShaderQuality",
					_ => null,
				},
				"TierSettings" => interfaceProperty.Name switch
				{
					"Tier" => "UnityEngine.Rendering.GraphicsTier",
					_ => null,
				},
				"TransitionConstant" => interfaceProperty.Name switch
				{
					"InterruptionSource" => "UnityEditor.Animations.TransitionInterruptionSource",
					_ => null,
				},
				"UVModule" => interfaceProperty.Name switch
				{
					"AnimationType" => "UnityEngine.ParticleSystemAnimationType",
					"Mode" => "UnityEngine.ParticleSystemAnimationMode",
					"RowMode" => "UnityEngine.ParticleSystemAnimationRowMode",
					"TimeMode" => "UnityEngine.ParticleSystemAnimationTimeMode",
					_ => null,
				},
				"ValueConstant" => interfaceProperty.Name switch
				{
					"Type" => "UnityEngine.AnimatorControllerParameterType",
					_ => null,
				},
				"VariantInfo" => interfaceProperty.Name switch
				{
					"PassType" => "UnityEngine.Rendering.PassType",
					_ => null,
				},
				_ => null,
			},
			_ => throw new(),
		};
		return fullName is not null;
	}

	private static CilInstruction? AddConversion(this CilInstructionCollection instructions, ElementType from, ElementType to)
	{
		if (from == to)
		{
			return null;
		}

		CilOpCode opCode = to switch
		{
			//ElementType.I1 => from.IsSigned() ? CilOpCodes.Conv_Ovf_I1 : CilOpCodes.Conv_Ovf_I1_Un,
			//ElementType.U1 => from.IsSigned() ? CilOpCodes.Conv_Ovf_U1 : CilOpCodes.Conv_Ovf_U1_Un,
			//ElementType.I2 => from.IsSigned() ? CilOpCodes.Conv_Ovf_I2 : CilOpCodes.Conv_Ovf_I2_Un,
			//ElementType.U2 => from.IsSigned() ? CilOpCodes.Conv_Ovf_U2 : CilOpCodes.Conv_Ovf_U2_Un,
			//ElementType.I4 => from.IsSigned() ? CilOpCodes.Conv_Ovf_I4 : CilOpCodes.Conv_Ovf_I4_Un,
			//ElementType.U4 => from.IsSigned() ? CilOpCodes.Conv_Ovf_U4 : CilOpCodes.Conv_Ovf_U4_Un,
			//ElementType.I8 => from.IsSigned() ? CilOpCodes.Conv_Ovf_I8 : CilOpCodes.Conv_Ovf_I8_Un,
			//ElementType.U8 => from.IsSigned() ? CilOpCodes.Conv_Ovf_U8 : CilOpCodes.Conv_Ovf_U8_Un,
			ElementType.I1 => CilOpCodes.Conv_I1,
			ElementType.U1 => CilOpCodes.Conv_U1,
			ElementType.I2 => CilOpCodes.Conv_I2,
			ElementType.U2 => CilOpCodes.Conv_U2,
			ElementType.I4 => CilOpCodes.Conv_I4,
			ElementType.U4 => CilOpCodes.Conv_U4,
			ElementType.I8 => CilOpCodes.Conv_I8,
			ElementType.U8 => CilOpCodes.Conv_U8,
			_ => throw new ArgumentOutOfRangeException(nameof(to)),
		};

		return instructions.Add(opCode);
	}

	private static void FillGetter(this CilInstructionCollection instructions, FieldDefinition field, ElementType fieldType, ElementType enumType)
	{
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, field);
		instructions.AddConversion(fieldType, enumType);
		instructions.Add(CilOpCodes.Ret);
	}

	private static void FillSetter(this CilInstructionCollection instructions, FieldDefinition field, ElementType fieldType, ElementType enumType)
	{
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.AddConversion(enumType, fieldType);
		instructions.Add(CilOpCodes.Stfld, field);
		instructions.Add(CilOpCodes.Ret);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass058_InjectChineseTextureProperties.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.DocExtraction.DataStructures;

namespace AssetRipper.AssemblyDumper.Passes;

/// <summary>
/// A special case for Chinese textures containing an extra 24 bytes at the end.
/// </summary>
internal static class Pass058_InjectChineseTextureProperties
{
	//int m_OriginalWidth // ByteSize{4}, Index{26}, Version{1}, IsArray{0}, MetaFlag{10}
	//int m_OriginalHeight // ByteSize{4}, Index{27}, Version{1}, IsArray{0}, MetaFlag{10}
	//GUID m_OriginalAssetGuid // ByteSize{10}, Index{28}, Version{1}, IsArray{0}, MetaFlag{10}
	//unsigned int data[0] // ByteSize{4}, Index{29}, Version{1}, IsArray{0}, MetaFlag{10}
	//unsigned int data[1] // ByteSize{4}, Index{2a}, Version{1}, IsArray{0}, MetaFlag{10}
	//unsigned int data[2] // ByteSize{4}, Index{2b}, Version{1}, IsArray{0}, MetaFlag{10}
	//unsigned int data[3] // ByteSize{4}, Index{2c}, Version{1}, IsArray{0}, MetaFlag{10}

	private static TypeSignature Int32Type => SharedState.Instance.Importer.Int32;

	public static void DoPass()
	{
		ClassGroup textureGroup = SharedState.Instance.ClassGroups[28];
		ClassGroup cubemapGroup = SharedState.Instance.ClassGroups[89];

		SubclassGroup guidGroup = SharedState.Instance.SubclassGroups["GUID"];
		TypeSignature guidType = guidGroup.Types.Single().ToTypeSignature();

		AddPropertyToBothGroups(textureGroup, cubemapGroup, Int32Type, "m_OriginalWidth");
		AddPropertyToBothGroups(textureGroup, cubemapGroup, Int32Type, "m_OriginalHeight");
		AddPropertyToBothGroups(textureGroup, cubemapGroup, guidType, "m_OriginalAssetGuid");
	}

	private static void AddPropertyToBothGroups(ClassGroup textureGroup, ClassGroup cubemapGroup, TypeSignature fieldType, string fieldName)
	{
		AddProperty(textureGroup, fieldType, fieldName, static (instance, fieldType, fieldName) =>
		{
			FieldDefinition field = instance.Type.AddField(fieldName, fieldType, visibility: Visibility.Internal);
			field.AddDebuggerBrowsableNeverAttribute();
			return field;
		});
		AddProperty(cubemapGroup, fieldType, fieldName, static (instance, fieldType, fieldName) =>
		{
			return instance.Base!.Type.GetFieldByName(fieldName);
		});
	}

	private static void AddProperty(
		ClassGroup group,
		TypeSignature fieldType,
		string fieldName,
		Func<GeneratedClassInstance, TypeSignature, string, FieldDefinition> fieldDelegate)
	{
		string propertyName = GeneratedInterfaceUtils.GetPropertyNameFromFieldName(fieldName, group);

		DataMemberHistory history = new();
		history.Exists.Add(group.MinimumVersion, true);
		history.DocumentationString.Add(group.MinimumVersion, "Injected for chinese textures.");
		history.Name = fieldName;
		if (fieldType is CorLibTypeSignature)
		{
			history.TypeFullName.Add(group.MinimumVersion, new DocExtraction.MetaData.FullNameRecord(fieldType.FullName, fieldType.Name!));
		}

		bool useFullProperty = fieldType.IsValueType;
		InjectedInterfaceProperty interfaceProperty;
		{
			PropertyDefinition property = useFullProperty
				? group.Interface.AddFullProperty(
					propertyName,
					InterfaceUtils.InterfacePropertyDeclaration,
					fieldType)
				: group.Interface.AddGetterProperty(
					propertyName,
					InterfaceUtils.InterfacePropertyDeclaration,
					fieldType);
			interfaceProperty = new InjectedInterfaceProperty(property, group)
			{
				History = history,
			};
			group.InterfaceProperties.Add(interfaceProperty);

		}
		foreach (GeneratedClassInstance instance in group.Instances)
		{
			TypeDefinition type = instance.Type;
			{
				FieldDefinition field = fieldDelegate.Invoke(instance, fieldType, fieldName);
				PropertyDefinition property = useFullProperty
					? type.ImplementFullProperty(
						propertyName,
						InterfaceUtils.InterfacePropertyImplementation,
						fieldType,
						field)
					: type.ImplementGetterProperty(
						propertyName,
						InterfaceUtils.InterfacePropertyImplementation,
						fieldType,
						field);
				InjectedClassProperty classProperty = new InjectedClassProperty(property, field, interfaceProperty, instance)
				{
					History = history,
				};
				instance.Properties.Add(classProperty);
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass061_AddConstructors.cs`:

```cs
using AssetRipper.Assets.Metadata;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass061_AddConstructors
{
	private const MethodAttributes PublicInstanceConstructorAttributes =
		MethodAttributes.Public |
		MethodAttributes.HideBySig |
		MethodAttributes.SpecialName |
		MethodAttributes.RuntimeSpecialName;
	private readonly static HashSet<GeneratedClassInstance> processed = new HashSet<GeneratedClassInstance>();
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
	private static ITypeDefOrRef AssetInfoRef;
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

	public static void DoPass()
	{
		AssetInfoRef = SharedState.Instance.Importer.ImportType<AssetInfo>();
		IEnumerable<ClassGroupBase> groups = SharedState.Instance.ClassGroups.Values.Select(g => (ClassGroupBase)g)
			.Union(SharedState.Instance.SubclassGroups.Values.Select(g => (ClassGroupBase)g));
		foreach (ClassGroupBase group in groups)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				if (processed.Contains(instance))
				{
					continue;
				}

				AddConstructor(instance);
			}
		}
		processed.Clear();
	}

	private static void AddConstructor(GeneratedClassInstance instance)
	{
		if (instance.Base is not null && !processed.Contains(instance.Base))
		{
			AddConstructor(instance.Base);
		}

		TypeDefinition type = instance.Type;
		if (instance.Group is ClassGroup)
		{
			type.AddAssetInfoConstructor();
		}
		else
		{
			type.AddEmptyDefaultConstructor();
		}
		processed.Add(instance);
	}

	private static MethodDefinition AddAssetInfoConstructor(this TypeDefinition typeDefinition)
	{
		return AddSingleParameterConstructor(typeDefinition, AssetInfoRef, "info");
	}

	private static MethodDefinition AddEmptyDefaultConstructor(this TypeDefinition typeDefinition)
	{
		return typeDefinition.AddMethod(
			".ctor",
			PublicInstanceConstructorAttributes,
			SharedState.Instance.Importer.Void
		);
	}

	private static MethodDefinition AddSingleParameterConstructor(this TypeDefinition typeDefinition, ITypeDefOrRef parameterType, string parameterName)
	{
		MethodDefinition? constructor = typeDefinition.AddMethod(
			".ctor",
			PublicInstanceConstructorAttributes,
			SharedState.Instance.Importer.Void
		);
		constructor.AddParameter(parameterType.ToTypeSignature(), parameterName);
		return constructor;
	}
}
```

`Source/AssetRipper.AssemblyDumper/Passes/Pass062_FillConstructors.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass062_FillConstructors
{
#nullable disable
	private static IMethodDefOrRef emptyArray;
	private static IMethodDefOrRef emptyString;
#nullable enable
	public static void DoPass()
	{
		emptyArray = SharedState.Instance.Importer.ImportMethod<Array>(method => method.Name == nameof(Array.Empty));
		emptyString = SharedState.Instance.Importer.ImportMethod<Utf8String>(method => method.Name == $"get_{nameof(Utf8String.Empty)}");
		foreach ((int id, ClassGroup classGroup) in SharedState.Instance.ClassGroups)
		{
			foreach (TypeDefinition type in classGroup.Types)
			{
				MethodDefinition assetInfoConstructor = type.GetAssetInfoConstructor();
				type.FillClassAssetInfoConstructor(assetInfoConstructor);
			}
		}
		foreach (SubclassGroup subclassGroup in SharedState.Instance.SubclassGroups.Values)
		{
			foreach (TypeDefinition type in subclassGroup.Types)
			{
				type.FillSubclassDefaultConstructor();
			}
		}
	}

	private static TypeDefinition GetResolvedBaseType(this TypeDefinition type)
	{
		ArgumentNullException.ThrowIfNull(type);
		if (type.BaseType == null)
		{
			throw new ArgumentException(null, nameof(type));
		}

		if (type.BaseType is TypeDefinition baseTypeDefinition)
		{
			return baseTypeDefinition;
		}
		TypeDefinition? resolvedBaseType = SharedState.Instance.Importer.LookupType(type.BaseType.FullName);
		return resolvedBaseType ?? throw new Exception($"Could not resolve base type {type.BaseType} of derived type {type} from module {type.DeclaringModule} in assembly {type.DeclaringModule!.Assembly}");
	}

	private static IMethodDefOrRef GetDefaultConstructor(this GenericInstanceTypeSignature type)
	{
		return MethodUtils.MakeConstructorOnGenericType(SharedState.Instance.Importer, type, 0);
	}

	private static MethodDefinition GetAssetInfoConstructor(this TypeDefinition type)
	{
		return type.Methods.First(x => x.IsConstructor && x.Parameters.Count == 1 && x.Parameters[0].ParameterType.Name == nameof(AssetInfo));
	}

	private static void FillSubclassDefaultConstructor(this TypeDefinition type)
	{
		MethodDefinition constructor = type.GetDefaultConstructor();
		CilInstructionCollection instructions = constructor.CilMethodBody!.Instructions;
		instructions.Clear();
		IMethodDefOrRef baseConstructor = SharedState.Instance.Importer.UnderlyingImporter.ImportMethod(type.GetResolvedBaseType().GetDefaultConstructor());
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, baseConstructor);
		instructions.AddFieldAssignments(type);
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
	}

	private static void FillClassAssetInfoConstructor(this TypeDefinition type, MethodDefinition constructor)
	{
		CilInstructionCollection instructions = constructor.CilMethodBody!.Instructions;
		instructions.Clear();
		MethodDefinition baseConstructorDefinition = type.GetResolvedBaseType().GetAssetInfoConstructor();
		IMethodDefOrRef baseConstructor = SharedState.Instance.Importer.UnderlyingImporter.ImportMethod(baseConstructorDefinition);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Call, baseConstructor);
		instructions.AddFieldAssignments(type);
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
	}

	private static void AddFieldAssignments(this CilInstructionCollection instructions, TypeDefinition type)
	{
		foreach (FieldDefinition field in type.Fields)
		{
			if (field.IsStatic || field.IsPrivate || field.Signature!.FieldType.IsValueType)
			{
				continue;
			}

			if (field.Signature.FieldType is GenericInstanceTypeSignature generic)
			{
				// List, Dictionary, or pair
				field.IsInitOnly = true;
				instructions.Add(CilOpCodes.Ldarg_0);
				instructions.Add(CilOpCodes.Newobj, GetDefaultConstructor(generic));
				instructions.Add(CilOpCodes.Stfld, field);
			}
			else if (field.Signature.FieldType is SzArrayTypeSignature array)
			{
				// Array
				instructions.Add(CilOpCodes.Ldarg_0);
				MethodSpecification method = emptyArray.MakeGenericInstanceMethod(array.BaseType);
				instructions.Add(CilOpCodes.Call, method);
				instructions.Add(CilOpCodes.Stfld, field);
			}
			else if (field.Signature.FieldType.ToTypeDefOrRef() is TypeDefinition typeDef)
			{
				// Regular class type
				field.IsInitOnly = true;
				instructions.Add(CilOpCodes.Ldarg_0);
				instructions.Add(CilOpCodes.Newobj, typeDef.GetDefaultConstructor());
				instructions.Add(CilOpCodes.Stfld, field);
			}
			else if (field.Signature.FieldType is TypeDefOrRefSignature { Namespace: "AssetRipper.Primitives", Name: nameof(Utf8String) })
			{
				// Utf8String
				instructions.Add(CilOpCodes.Ldarg_0);
				instructions.Add(CilOpCodes.Call, emptyString);
				instructions.Add(CilOpCodes.Stfld, field);
			}
			else
			{
				Console.WriteLine($"Warning: skipping {type.Name}.{field.Name} of type {field.Signature.FieldType.Name} while adding field assignments.");
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass063_CreateEmptyMethods.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.IO.Writing;
using AssetRipper.Assets.Metadata;
using AssetRipper.IO.Endian;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass063_CreateEmptyMethods
{
	public const MethodAttributes OverrideMethodAttributes = MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.ReuseSlot | MethodAttributes.HideBySig;

	public static void DoPass()
	{
		TypeSignature commonPPtrTypeRef = SharedState.Instance.Importer.ImportTypeSignature(typeof(PPtr<>));
		TypeSignature unityObjectBaseInterfaceRef = SharedState.Instance.Importer.ImportTypeSignature<IUnityObjectBase>();
		GenericInstanceTypeSignature unityObjectBasePPtrRef = commonPPtrTypeRef.MakeGenericInstanceType(unityObjectBaseInterfaceRef);
		TypeSignature refEndianSpanReaderRef = SharedState.Instance.Importer.ImportTypeSignature(typeof(EndianSpanReader)).MakeByReferenceType();
		TypeSignature assetWriterRef = SharedState.Instance.Importer.ImportTypeSignature<AssetWriter>();

		foreach (TypeDefinition type in SharedState.Instance.AllNonInterfaceTypes)
		{
			type.AddMethod(nameof(UnityAssetBase.ReadRelease), OverrideMethodAttributes, SharedState.Instance.Importer.Void)
				.AddParameter(refEndianSpanReaderRef, "reader");

			type.AddMethod(nameof(UnityAssetBase.ReadEditor), OverrideMethodAttributes, SharedState.Instance.Importer.Void)
				.AddParameter(refEndianSpanReaderRef, "reader");

			type.AddMethod(nameof(UnityAssetBase.WriteRelease), OverrideMethodAttributes, SharedState.Instance.Importer.Void)
				.AddParameter(assetWriterRef, "writer");

			type.AddMethod(nameof(UnityAssetBase.WriteEditor), OverrideMethodAttributes, SharedState.Instance.Importer.Void)
				.AddParameter(assetWriterRef, "writer");

			type.AddMethod(nameof(UnityAssetBase.Reset), OverrideMethodAttributes, SharedState.Instance.Importer.Void);
		}
	}
}
```

`Source/AssetRipper.AssemblyDumper/Passes/Pass080_PPtrConversions.cs`:

```cs
using AssetRipper.AssemblyDumper.Attributes;
using AssetRipper.AssemblyDumper.InjectedTypes;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass080_PPtrConversions
{
	public static IReadOnlyDictionary<TypeDefinition, TypeDefinition> PPtrsToParameters => pptrsToParameters;
	public static IReadOnlyDictionary<TypeDefinition, IMethodDescriptor> PPtrsToTryGetAssetMethods => pptrsToTryGetAssetMethods;
	public static IReadOnlyDictionary<TypeDefinition, IMethodDescriptor> PPtrsToSetAssetMethods => pptrsToSetAssetMethods;
#nullable disable
	private static ITypeDefOrRef pptrTypeImported;
	private static ITypeDefOrRef commonPPtrTypeGeneric;
	private static ITypeDefOrRef commonPPtrType;
	private static IMethodDefOrRef commonPPtrConstructor;
	private static IMethodDefOrRef commonPPtrGetFileIDMethod;
	private static IMethodDefOrRef commonPPtrGetPathIDMethod;
	private static MethodDefinition forceCreatePPtrHelper;
	private static MethodDefinition tryGetAssetHelper;
#nullable enable

	private static readonly Dictionary<TypeDefinition, TypeDefinition> pptrsToParameters = new();
	private static readonly Dictionary<TypeDefinition, IMethodDescriptor> pptrsToTryGetAssetMethods = new();
	private static readonly Dictionary<TypeDefinition, IMethodDescriptor> pptrsToSetAssetMethods = new();

	public static void DoPass()
	{
		pptrTypeImported = SharedState.Instance.Importer.ImportType(typeof(IPPtr<>));
		commonPPtrTypeGeneric = SharedState.Instance.Importer.ImportType(typeof(PPtr<>));
		commonPPtrType = SharedState.Instance.Importer.ImportType(typeof(PPtr));
		commonPPtrConstructor = SharedState.Instance.Importer.ImportConstructor<PPtr>(c => c.Parameters.Count == 2);
		commonPPtrGetFileIDMethod = SharedState.Instance.Importer.ImportMethod<PPtr>(m => m.Name == $"get_{nameof(PPtr.FileID)}");
		commonPPtrGetPathIDMethod = SharedState.Instance.Importer.ImportMethod<PPtr>(m => m.Name == $"get_{nameof(PPtr.PathID)}");
		forceCreatePPtrHelper = SharedState.Instance.InjectHelperType(typeof(PPtrHelper)).Methods.Single(m => m.Name == nameof(PPtrHelper.ForceCreatePPtr));
		tryGetAssetHelper = SharedState.Instance.InjectHelperType(typeof(PPtrHelper)).Methods.Single(m =>
		{
			return m.Name == nameof(PPtrHelper.TryGetAsset) && m.Signature!.ReturnType is CorLibTypeSignature;
		});

		IMethodDefOrRef pptrTryGetAssetMethod = SharedState.Instance.Importer.ImportMethod(typeof(IPPtr<>), method =>
		{
			return method.Name == nameof(IPPtr<>.TryGetAsset) && method.Parameters.Count == 2;
		});
		IMethodDefOrRef pptrSetAssetMethod = SharedState.Instance.Importer.ImportMethod(typeof(IPPtr<>), method =>
		{
			return method.Name == nameof(IPPtr<>.SetAsset) && method.Parameters.Count == 2;
		});

		foreach (SubclassGroup group in SharedState.Instance.SubclassGroups.Values.Where(g => g.IsPPtr))
		{
			bool usingMarkerInterface = !GetInterfaceParameterTypeDefinition(group, out TypeDefinition parameterType);
			group.Interface.AddPPtrInterfaceImplementation(parameterType);

			pptrsToTryGetAssetMethods.Add(group.Interface, MethodUtils.MakeMethodOnGenericType(
				SharedState.Instance.Importer,
				SharedState.Instance.Importer.ImportType(typeof(IPPtr<>)).MakeGenericInstanceType(parameterType.ToTypeSignature()),
				pptrTryGetAssetMethod));
			pptrsToSetAssetMethods.Add(group.Interface, MethodUtils.MakeMethodOnGenericType(
				SharedState.Instance.Importer,
				SharedState.Instance.Importer.ImportType(typeof(IPPtr<>)).MakeGenericInstanceType(parameterType.ToTypeSignature()),
				pptrSetAssetMethod));
			pptrsToParameters.Add(group.Interface, parameterType);

			foreach (GeneratedClassInstance instance in group.Instances)
			{
				DoPassOnInstance(usingMarkerInterface, parameterType, instance);
			}
		}
	}

	private static void DoPassOnInstance(bool usingMarkerInterface, TypeDefinition parameterType, GeneratedClassInstance instance)
	{
		instance.Type.ImplementFileIDAndPathID();

		TypeDefinition? instanceParameterType;
		if (usingMarkerInterface)
		{
			instanceParameterType = GetInstanceParameterTypeDefinition(instance);
			pptrsToParameters.Add(instance.Type, instanceParameterType);
			instance.Type.AddPPtrInterfaceImplementation(instanceParameterType);
		}
		else
		{
			instanceParameterType = null;
			pptrsToParameters.Add(instance.Type, parameterType);
		}

		AddTryGetAssetMethods(parameterType, instance, instanceParameterType);

		instance.Type.ImplementSetAssetMethods(parameterType.ToTypeSignature(), instanceParameterType?.ToTypeSignature());

		AddImplicitConversions(instance, parameterType, instanceParameterType);
	}

	private static void AddTryGetAssetMethods(TypeDefinition parameterType, GeneratedClassInstance instance, TypeDefinition? instanceParameterType)
	{
		MethodDefinition interfaceTryGetAssetMethod = instance.Type.ImplementTryGetAssetMethod(parameterType.ToTypeSignature());

		if (instanceParameterType is not null)
		{
			MethodDefinition instanceTryGetAssetMethod = instance.Type.ImplementTryGetAssetMethod(instanceParameterType.ToTypeSignature());
			pptrsToTryGetAssetMethods.Add(instance.Type, instanceTryGetAssetMethod);
		}
		else
		{
			pptrsToTryGetAssetMethods.Add(instance.Type, interfaceTryGetAssetMethod);
		}
	}

	private static void AddImplicitConversions(GeneratedClassInstance instance, TypeDefinition parameterType, TypeDefinition? instanceParameterType)
	{
		if (instanceParameterType is not null)
		{
			instance.Type.AddImplicitConversion(instanceParameterType.ToTypeSignature());
		}
		instance.Type.AddImplicitConversion(parameterType.ToTypeSignature());
		instance.Type.AddImplicitConversion<IUnityObjectBase>();
		instance.Type.AddImplicitConversion(commonPPtrType.ToTypeSignature(), commonPPtrConstructor);
	}

	private static void AddPPtrInterfaceImplementation(this TypeDefinition type, TypeDefinition parameterType)
	{
		GenericInstanceTypeSignature pptrInterface = pptrTypeImported.MakeGenericInstanceType(parameterType.ToTypeSignature());
		type.AddInterfaceImplementation(pptrInterface.ToTypeDefOrRef());
	}

	private static void ImplementFileIDAndPathID(this TypeDefinition pptrType)
	{
		pptrType.ImplementGetterProperty(
			nameof(IPPtr.FileID),
			InterfaceUtils.InterfacePropertyImplementation,
			SharedState.Instance.Importer.Int32,
			pptrType.GetFieldByName("m_FileID_"));

		FieldDefinition pathidField = pptrType.GetFieldByName("m_PathID_");
		PropertyDefinition property = pptrType.AddGetterProperty(nameof(IPPtr.PathID), InterfaceUtils.InterfacePropertyImplementation, SharedState.Instance.Importer.Int64);
		CilInstructionCollection instructions = property.GetMethod!.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, pathidField);
		if (pathidField.IsInt32Type())
		{
			instructions.Add(CilOpCodes.Conv_I8);
		}
		instructions.Add(CilOpCodes.Ret);
	}

	private static void ImplementSetAssetMethods(this TypeDefinition pptrType, TypeSignature groupParameterType, TypeSignature? instanceParameterType)
	{
		TypeSignature parameterType = instanceParameterType ?? groupParameterType;

		MethodDefinition mainMethod;
		{
			MethodDefinition method = mainMethod = pptrType.AddMethod(nameof(IPPtr<>.SetAsset), InterfaceUtils.InterfaceMethodImplementation, SharedState.Instance.Importer.Void);
			method.AddParameter(SharedState.Instance.Importer.ImportType<AssetCollection>().ToTypeSignature(), "collection");
			method.AddParameter(parameterType, "asset").Definition!.AddNullableAttribute(NullableAnnotation.MaybeNull);
			CilInstructionCollection instructions = method.CilMethodBody!.Instructions;

			//Convert PPtr
			CilLocalVariable convertedPPtr = instructions.AddLocalVariable(commonPPtrType.ToTypeSignature());
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.Add(CilOpCodes.Ldarg_2);
			instructions.Add(CilOpCodes.Call, forceCreatePPtrHelper);
			instructions.Add(CilOpCodes.Stloc, convertedPPtr);

			//Store FileID
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldloca, convertedPPtr);
			instructions.Add(CilOpCodes.Call, commonPPtrGetFileIDMethod);
			instructions.Add(CilOpCodes.Stfld, pptrType.GetFieldByName("m_FileID_"));

			//Store PathID
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldloca, convertedPPtr);
			instructions.Add(CilOpCodes.Call, commonPPtrGetPathIDMethod);
			FieldDefinition pathIDField = pptrType.GetFieldByName("m_PathID_");
			if (pathIDField.Signature!.FieldType is CorLibTypeSignature { ElementType: ElementType.I4 })
			{
				instructions.Add(CilOpCodes.Conv_Ovf_I4);//Convert I8 to I4
			}
			instructions.Add(CilOpCodes.Stfld, pathIDField);

			//Return
			instructions.Add(CilOpCodes.Ret);
		}

		pptrsToSetAssetMethods.Add(pptrType, mainMethod);

		//Secondary Method
		if (instanceParameterType is not null)
		{
			MethodDefinition method = pptrType.AddMethod(nameof(IPPtr<>.SetAsset), InterfaceUtils.InterfaceMethodImplementation, SharedState.Instance.Importer.Void);
			method.AddParameter(SharedState.Instance.Importer.ImportType<AssetCollection>().ToTypeSignature(), "collection");
			method.AddParameter(groupParameterType, "asset").Definition!.AddNullableAttribute(NullableAnnotation.MaybeNull);
			CilInstructionCollection instructions = method.CilMethodBody!.Instructions;

			CilInstructionLabel returnLabel = new();
			CilInstructionLabel isNullLabel = new();

			instructions.Add(CilOpCodes.Ldarg_2);
			instructions.Add(CilOpCodes.Ldnull);
			instructions.Add(CilOpCodes.Cgt_Un);
			instructions.Add(CilOpCodes.Brfalse, isNullLabel);

			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.Add(CilOpCodes.Ldarg_2);
			instructions.Add(CilOpCodes.Castclass, instanceParameterType.ToTypeDefOrRef());
			instructions.Add(CilOpCodes.Callvirt, mainMethod);
			instructions.Add(CilOpCodes.Br, returnLabel);

			isNullLabel.Instruction = instructions.Add(CilOpCodes.Nop);

			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Callvirt, pptrType.GetMethodByName(nameof(IUnityAssetBase.Reset)));

			returnLabel.Instruction = instructions.Add(CilOpCodes.Nop);

			//Return
			instructions.Add(CilOpCodes.Ret);
		}
	}

	private static MethodDefinition ImplementTryGetAssetMethod(this TypeDefinition pptrType, TypeSignature parameterType)
	{
		MethodDefinition method = pptrType.AddMethod(nameof(IPPtr<>.TryGetAsset), InterfaceUtils.InterfaceMethodImplementation, SharedState.Instance.Importer.Boolean);
		method.AddParameter(SharedState.Instance.Importer.ImportType<AssetCollection>().ToTypeSignature(), "collection");
		ParameterDefinition outParameter = method.AddParameter(parameterType.MakeByReferenceType(), "asset").Definition!;
		outParameter.IsOut = true;
		outParameter.AddNullableAttribute(NullableAnnotation.MaybeNull);
		outParameter.AddNotNullWhenAttribute(SharedState.Instance.Importer, true);
		CilInstructionCollection instructions = method.CilMethodBody!.Instructions;

		//Load container
		instructions.Add(CilOpCodes.Ldarg_1);

		//Load FileID
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, pptrType.GetFieldByName("m_FileID_"));

		//Load PathID
		instructions.Add(CilOpCodes.Ldarg_0);
		FieldDefinition pathIDField = pptrType.GetFieldByName("m_PathID_");
		instructions.Add(CilOpCodes.Ldfld, pathIDField);
		if (pathIDField.Signature!.FieldType is CorLibTypeSignature { ElementType: ElementType.I4 })
		{
			instructions.Add(CilOpCodes.Conv_I8);//Convert I4 to I8
		}

		//Load out parameter
		instructions.Add(CilOpCodes.Ldarg_2);

		//Call TryGetAsset helper
		instructions.Add(CilOpCodes.Call, tryGetAssetHelper.MakeGenericInstanceMethod(parameterType));

		//Return
		instructions.Add(CilOpCodes.Ret);

		return method;
	}

	private static bool IsInt32Type(this FieldDefinition field) => field.Signature!.FieldType is CorLibTypeSignature { ElementType: ElementType.I4 };

	private static MethodDefinition AddImplicitConversion(this TypeDefinition pptrType, TypeSignature parameterType)
	{
		GenericInstanceTypeSignature resultPPtrSignature = commonPPtrTypeGeneric.MakeGenericInstanceType(parameterType);
		IMethodDefOrRef constructor = MethodUtils.MakeConstructorOnGenericType(SharedState.Instance.Importer, resultPPtrSignature, 2);
		return pptrType.AddImplicitConversion(resultPPtrSignature, constructor);
	}

	private static MethodDefinition AddImplicitConversion<T>(this TypeDefinition pptrType)
	{
		ITypeDefOrRef importedInterface = SharedState.Instance.Importer.ImportType<T>();
		return pptrType.AddImplicitConversion(importedInterface.ToTypeSignature());
	}

	private static MethodDefinition AddImplicitConversion(this TypeDefinition pptrType, TypeSignature resultTypeSignature, IMethodDefOrRef constructor)
	{
		FieldDefinition fileID = pptrType.Fields.Single(field => field.Name == "m_FileID_");
		FieldDefinition pathID = pptrType.Fields.Single(f => f.Name == "m_PathID_");

		MethodDefinition method = pptrType.AddEmptyConversion(pptrType.ToTypeSignature(), resultTypeSignature, true);

		CilInstructionCollection instructions = method.CilMethodBody!.Instructions;

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, fileID);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, pathID);
		if (pathID.IsInt32Type())
		{
			instructions.Add(CilOpCodes.Conv_I8);
		}

		instructions.Add(CilOpCodes.Newobj, constructor);
		instructions.Add(CilOpCodes.Ret);

		return method;
	}

	internal static bool GetInterfaceParameterTypeDefinition(SubclassGroup pptrGroup, out TypeDefinition type)
	{
		string parameterTypeName = pptrGroup.Name.Substring(5);
		if (SharedState.Instance.NameToTypeID.TryGetValue(parameterTypeName, out HashSet<int>? idList) && idList.Count == 1)
		{
			type = SharedState.Instance.ClassGroups[idList.First()].Interface;
			return true;
		}
		else
		{
			type = SharedState.Instance.MarkerInterfaces[parameterTypeName];
			return false;
		}
	}

	internal static TypeDefinition GetInstanceParameterTypeDefinition(GeneratedClassInstance pptrInstance)
	{
		string parameterTypeName = pptrInstance.Name.Substring(5);
		if (SharedState.Instance.NameToTypeID.TryGetValue(parameterTypeName, out HashSet<int>? list))
		{
			List<GeneratedClassInstance> instances = new();

			foreach (int id in list)
			{
				ClassGroup group = SharedState.Instance.ClassGroups[id];
				foreach (GeneratedClassInstance instance in group.Instances)
				{
					if (instance.VersionRange.Intersects(pptrInstance.VersionRange) && parameterTypeName == instance.Name)
					{
						instances.Add(instance);
					}
				}
			}

			if (instances.Count == 0)
			{
				throw new Exception($"Could not find type {parameterTypeName} on version {pptrInstance.VersionRange.Start} to {pptrInstance.VersionRange.End}");
			}
			else if (instances.Count == 1)
			{
				return instances[0].Type;
			}
			else if (instances.Select(instance => instance.Group).Distinct().Count() == 1)
			{
				return instances[0].Group.Interface;
			}
			else
			{
				return SharedState.Instance.MarkerInterfaces[parameterTypeName];
			}
		}
		else
		{
			throw new Exception($"Could not find {parameterTypeName} in the name dictionary");
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass081_CreatePPtrProperties.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass081_CreatePPtrProperties
{
	public static void DoPass()
	{
		ITypeDefOrRef pptrAccessListType = SharedState.Instance.Importer.ImportType(typeof(PPtrAccessList<,>));
		IMethodDefOrRef pptrAccessListConstructor = SharedState.Instance.Importer.ImportMethod(typeof(PPtrAccessList<,>), method =>
		{
			return method.IsConstructor && method.Parameters.Count == 2 && method.Parameters[1].ParameterType.Name == nameof(IUnityObjectBase);
		});
		IMethodDefOrRef pptrAccessListEmptyMethod = SharedState.Instance.Importer.ImportMethod(typeof(PPtrAccessList<,>), method =>
		{
			return method.Name == $"get_{nameof(PPtrAccessList<,>.Empty)}";
		});
		IMethodDefOrRef getCollectionMethod = SharedState.Instance.Importer.ImportMethod(typeof(UnityObjectBase), method =>
		{
			return method.Name == $"get_{nameof(UnityObjectBase.Collection)}";
		});

		foreach (ClassGroup group in SharedState.Instance.ClassGroups.Values)
		{
			foreach (InterfaceProperty interfaceProperty in group.InterfaceProperties)
			{
				if (interfaceProperty.SpecialDefinition is null)
				{
					string pptrPropertyName = $"{interfaceProperty.Definition.Name}P";
					TypeSignature originalPropertySignature = interfaceProperty.Definition.Signature!.ReturnType;
					if (originalPropertySignature.IsPPtr(out TypeDefinition? pptrType, out TypeDefinition? parameterType))
					{
						interfaceProperty.SpecialDefinition = interfaceProperty.Group.Interface.AddFullProperty(
							pptrPropertyName,
							InterfaceUtils.InterfacePropertyDeclaration,
							parameterType.ToTypeSignature());
						interfaceProperty.SpecialDefinition.AddNullableAttributesForMaybeNull();

						foreach (ClassProperty classProperty in interfaceProperty.Implementations)
						{
							classProperty.SpecialDefinition = classProperty.Class.Type.AddFullProperty(
								pptrPropertyName,
								InterfaceUtils.InterfacePropertyImplementation,
								parameterType.ToTypeSignature());
							classProperty.SpecialDefinition.AddNullableAttributesForMaybeNull();

							//Get method
							{
								CilInstructionCollection instructions = classProperty.SpecialDefinition.GetMethod!.GetInstructions();
								if (classProperty.BackingField is null)
								{
									instructions.Add(CilOpCodes.Ldnull);
								}
								else
								{
									CilLocalVariable local = instructions.AddLocalVariable(parameterType.ToTypeSignature());
									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Callvirt, classProperty.Definition.GetMethod!);
									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Callvirt, getCollectionMethod);
									instructions.Add(CilOpCodes.Ldloca, local);
									instructions.Add(CilOpCodes.Callvirt, Pass080_PPtrConversions.PPtrsToTryGetAssetMethods[pptrType]);
									instructions.Add(CilOpCodes.Pop);
									instructions.Add(CilOpCodes.Ldloc, local);
								}
								instructions.Add(CilOpCodes.Ret);
								instructions.OptimizeMacros();
							}
							//Set method
							{
								CilInstructionCollection instructions = classProperty.SpecialDefinition.SetMethod!.GetInstructions();
								if (classProperty.BackingField is not null)
								{
									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Callvirt, classProperty.Definition.GetMethod!);
									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Callvirt, getCollectionMethod);
									instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Callvirt, Pass080_PPtrConversions.PPtrsToSetAssetMethods[pptrType]);
								}
								instructions.Add(CilOpCodes.Ret);
							}
							//Debugger attribute
							if (classProperty.Class.Type.IsAbstract)
							{
								classProperty.SpecialDefinition.AddDebuggerBrowsableNeverAttribute();//Properties in base classes are redundant in the debugger.
							}
							else if (classProperty.BackingField is null)
							{
								classProperty.SpecialDefinition.AddDebuggerBrowsableNeverAttribute();//The property will always be null.
							}
						}
					}
					else if (originalPropertySignature.IsPPtrList(out pptrType, out parameterType))
					{
						GenericInstanceTypeSignature propertySignature = pptrAccessListType.MakeGenericInstanceType(pptrType.ToTypeSignature(), parameterType.ToTypeSignature());
						IMethodDefOrRef constructor = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, propertySignature, pptrAccessListConstructor);
						IMethodDefOrRef emptyMethod = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, propertySignature, pptrAccessListEmptyMethod);

						interfaceProperty.SpecialDefinition = interfaceProperty.Group.Interface.AddGetterProperty(
							pptrPropertyName,
							InterfaceUtils.InterfacePropertyDeclaration,
							propertySignature);

						foreach (ClassProperty classProperty in interfaceProperty.Implementations)
						{
							classProperty.SpecialDefinition = classProperty.Class.Type.AddGetterProperty(
								pptrPropertyName,
								InterfaceUtils.InterfacePropertyImplementation,
								propertySignature);

							//Get method
							{
								CilInstructionCollection instructions = classProperty.SpecialDefinition.GetMethod!.GetInstructions();
								if (classProperty.BackingField is null)
								{
									instructions.Add(CilOpCodes.Call, emptyMethod);
								}
								else
								{
									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Callvirt, classProperty.Definition.GetMethod!);
									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Newobj, constructor);
								}
								instructions.Add(CilOpCodes.Ret);
							}
							//Debugger attribute
							if (classProperty.Class.Type.IsAbstract)
							{
								classProperty.SpecialDefinition.AddDebuggerBrowsableNeverAttribute();//Properties in base classes are redundant in the debugger.
							}
							else if (classProperty.BackingField is null)
							{
								classProperty.SpecialDefinition.AddDebuggerBrowsableNeverAttribute();//The list will always be empty.
							}
						}
					}
				}
			}
		}
	}

	private static bool IsPPtr(this TypeSignature typeSignature, [NotNullWhen(true)] out TypeDefinition? pptrType, [NotNullWhen(true)] out TypeDefinition? parameterType)
	{
		if (typeSignature is TypeDefOrRefSignature typeDefOrRefSignature
			&& typeDefOrRefSignature.ToTypeDefOrRef() is TypeDefinition typeDefinition
			&& Pass080_PPtrConversions.PPtrsToParameters.TryGetValue(typeDefinition, out parameterType))
		{
			pptrType = typeDefinition;
			return true;
		}
		else
		{
			pptrType = null;
			parameterType = null;
			return false;
		}
	}

	private static bool IsPPtrList(this TypeSignature typeSignature, [NotNullWhen(true)] out TypeDefinition? pptrType, [NotNullWhen(true)] out TypeDefinition? parameterType)
	{
		if (typeSignature is GenericInstanceTypeSignature genericInstanceTypeSignature
			&& NameIsAssetListOrAccessListBase(genericInstanceTypeSignature)
			&& genericInstanceTypeSignature.TypeArguments.Count == 1//For an extra bit of certainty
			&& genericInstanceTypeSignature.TypeArguments[0].IsPPtr(out pptrType, out parameterType))
		{
			return true;
		}
		else
		{
			pptrType = null;
			parameterType = null;
			return false;
		}
	}

	private static bool NameIsAssetListOrAccessListBase(GenericInstanceTypeSignature genericInstanceTypeSignature)
	{
		return genericInstanceTypeSignature.GenericType.Name == $"{nameof(AssetList<>)}`1"
			|| genericInstanceTypeSignature.GenericType.Name == $"{nameof(AccessListBase<>)}`1";
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass100_FillReadMethods.cs`:

```cs
using AssetRipper.AssemblyDumper.Attributes;
using AssetRipper.AssemblyDumper.InjectedTypes;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;
using AssetRipper.IO.Endian;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass100_FillReadMethods
{
#nullable disable
	private static IMethodDefOrRef alignStreamMethod;
	private static IMethodDefOrRef readInt32Method;
	private static IMethodDefOrRef readBytesMethod;
	/// <summary>
	/// TypeSignature for <see langword="ref"/> <see cref="EndianSpanReader"/>
	/// </summary>
	private static TypeSignature endianSpanReaderReference;

	private static ITypeDefOrRef assetDictionaryReference;
	private static TypeDefinition assetDictionaryDefinition;
	private static ITypeDefOrRef assetListReference;
	private static TypeDefinition assetListDefinition;
	private static ITypeDefOrRef assetPairReference;
	private static TypeDefinition assetPairDefinition;

	private static MethodDefinition readAssetAlignDefinition;
	private static MethodDefinition readAssetListDefinition;
	private static MethodDefinition readAssetListAlignDefinition;
	private static MethodDefinition readAssetPairDefinition;
	private static MethodDefinition readAssetPairAlignDefinition;
	private static MethodDefinition readAssetDictionaryDefinition;
	private static MethodDefinition readAssetDictionaryAlignDefinition;
#nullable enable

	private static readonly Dictionary<ElementType, IMethodDefOrRef> primitiveReadMethods = new();

	private static string ReadMethod => emittingRelease ? ReadRelease : ReadEditor;
	private const string ReadRelease = nameof(UnityAssetBase.ReadRelease);
	private const string ReadEditor = nameof(UnityAssetBase.ReadEditor);
	private const int MaxArraySize = 1024;

	private static readonly Dictionary<string, IMethodDescriptor> methodDictionary = new();
	private static readonly SignatureComparer signatureComparer = new(SignatureComparisonFlags.VersionAgnostic);
	private static bool emittingRelease;

	public static void DoPass()
	{
		methodDictionary.Clear();
		Initialize();

		emittingRelease = true;
		readAssetAlignDefinition = MakeGenericAssetAlignMethod();
		readAssetListDefinition = MakeGenericListMethod(false);
		readAssetListAlignDefinition = MakeGenericListMethod(true);
		readAssetPairDefinition = MakeGenericPairMethod(false);
		readAssetPairAlignDefinition = MakeGenericPairMethod(true);
		readAssetDictionaryDefinition = MakeGenericDictionaryMethod(false);
		readAssetDictionaryAlignDefinition = MakeGenericDictionaryMethod(true);
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				instance.Type.FillReleaseWriteMethod(instance.Class, instance.VersionRange.Start);
			}
		}
		CreateHelperClassForWriteMethods();
		methodDictionary.Clear();

		emittingRelease = false;
		readAssetAlignDefinition = MakeGenericAssetAlignMethod();
		readAssetListDefinition = MakeGenericListMethod(false);
		readAssetListAlignDefinition = MakeGenericListMethod(true);
		readAssetPairDefinition = MakeGenericPairMethod(false);
		readAssetPairAlignDefinition = MakeGenericPairMethod(true);
		readAssetDictionaryDefinition = MakeGenericDictionaryMethod(false);
		readAssetDictionaryAlignDefinition = MakeGenericDictionaryMethod(true);
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				instance.Type.FillEditorWriteMethod(instance.Class, instance.VersionRange.Start);
			}
		}
		CreateHelperClassForWriteMethods();
		methodDictionary.Clear();
	}

	private static void Initialize()
	{
		primitiveReadMethods.Add(ElementType.Boolean, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadBoolean)));
		primitiveReadMethods.Add(ElementType.Char, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadChar)));
		primitiveReadMethods.Add(ElementType.I1, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadSByte)));
		primitiveReadMethods.Add(ElementType.U1, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadByte)));
		primitiveReadMethods.Add(ElementType.I2, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadInt16)));
		primitiveReadMethods.Add(ElementType.U2, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadUInt16)));
		primitiveReadMethods.Add(ElementType.I4, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadInt32)));
		primitiveReadMethods.Add(ElementType.U4, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadUInt32)));
		primitiveReadMethods.Add(ElementType.I8, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadInt64)));
		primitiveReadMethods.Add(ElementType.U8, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadUInt64)));
		primitiveReadMethods.Add(ElementType.R4, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadSingle)));
		primitiveReadMethods.Add(ElementType.R8, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadDouble)));
		primitiveReadMethods.Add(ElementType.String, SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.ReadUtf8String)));

		readInt32Method = primitiveReadMethods[ElementType.I4];

		alignStreamMethod = SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == nameof(EndianSpanReader.Align));
		endianSpanReaderReference = SharedState.Instance.Importer.ImportTypeSignature(typeof(EndianSpanReader)).MakeByReferenceType();

		readBytesMethod = SharedState.Instance.InjectHelperType(typeof(TypelessDataHelper)).Methods.Single();

		assetDictionaryReference = SharedState.Instance.Importer.ImportType(typeof(AssetDictionary<,>));
		assetListReference = SharedState.Instance.Importer.ImportType(typeof(AssetList<>));
		assetPairReference = SharedState.Instance.Importer.ImportType(typeof(AssetPair<,>));

		assetDictionaryDefinition = SharedState.Instance.Importer.LookupType(typeof(AssetDictionary<,>));
		assetListDefinition = SharedState.Instance.Importer.LookupType(typeof(AssetList<>));
		assetPairDefinition = SharedState.Instance.Importer.LookupType(typeof(AssetPair<,>));
	}

	private static void CreateHelperClassForWriteMethods()
	{
		TypeDefinition type = StaticClassCreator.CreateEmptyStaticClass(SharedState.Instance.Module, SharedState.HelpersNamespace, $"{ReadMethod}Methods");
		type.IsPublic = false;
		type.Methods.Add(readAssetAlignDefinition);
		type.Methods.Add(readAssetListDefinition);
		type.Methods.Add(readAssetListAlignDefinition);
		type.Methods.Add(readAssetPairDefinition);
		type.Methods.Add(readAssetPairAlignDefinition);
		type.Methods.Add(readAssetDictionaryDefinition);
		type.Methods.Add(readAssetDictionaryAlignDefinition);
		foreach ((string _, IMethodDescriptor method) in methodDictionary.OrderBy(pair => pair.Key))
		{
			if (method is MethodDefinition methodDefinition && methodDefinition.DeclaringType is null)
			{
				type.Methods.Add(methodDefinition);
			}
		}
		Console.WriteLine($"\t{type.Methods.Count} {ReadMethod} helper methods");
	}

	private static void FillEditorWriteMethod(this TypeDefinition type, UniversalClass klass, UnityVersion version)
	{
		type.FillMethod(ReadEditor, klass.EditorRootNode, version);
	}

	private static void FillReleaseWriteMethod(this TypeDefinition type, UniversalClass klass, UnityVersion version)
	{
		type.FillMethod(ReadRelease, klass.ReleaseRootNode, version);
	}

	private static void FillMethod(this TypeDefinition type, string methodName, UniversalNode? rootNode, UnityVersion version)
	{
		MethodDefinition method = type.Methods.First(m => m.Name == methodName);
		CilInstructionCollection instructions = method.GetInstructions();

		if (rootNode is not null)
		{
			foreach (UniversalNode unityNode in rootNode.SubNodes)
			{
				FieldDefinition field = type.GetFieldByName(unityNode.Name, true);
				IMethodDescriptor fieldReadMethod = GetOrMakeMethod(unityNode, field.Signature!.FieldType, version);
				if (field.Signature.FieldType.IsArrayOrPrimitive())
				{
					instructions.Add(CilOpCodes.Ldarg_0);//this
					instructions.Add(CilOpCodes.Ldarg_1);//reader
					instructions.AddCall(fieldReadMethod);
					instructions.Add(CilOpCodes.Stfld, field);
				}
				else
				{
					instructions.Add(CilOpCodes.Ldarg_0);//this
					instructions.Add(CilOpCodes.Ldfld, field);
					instructions.Add(CilOpCodes.Ldarg_1);//reader
					instructions.AddCall(fieldReadMethod);
				}
			}
		}
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
	}

	private static IMethodDescriptor GetOrMakeMethod(UniversalNode node, TypeSignature type, UnityVersion version)
	{
		string uniqueName = UniqueNameFactory.GetReadWriteName(node, version);
		if (methodDictionary.TryGetValue(uniqueName, out IMethodDescriptor? method))
		{
			return method;
		}

		if (SharedState.Instance.SubclassGroups.TryGetValue(node.TypeName, out SubclassGroup? subclassGroup))
		{
			TypeDefinition typeDefinition = subclassGroup.GetTypeForVersion(version);
			Debug.Assert(signatureComparer.Equals(typeDefinition.ToTypeSignature(), type));
			MethodDefinition typeReadMethod = typeDefinition.GetMethodByName(ReadMethod);
			method = node.AlignBytes ? readAssetAlignDefinition.MakeGenericInstanceMethod(type) : typeReadMethod;
			methodDictionary.Add(uniqueName, method);
			return method;
		}

		switch (node.NodeType)
		{
			case NodeType.Vector:
				{
					UniversalNode arrayNode = node.SubNodes[0];
					UniversalNode elementTypeNode = arrayNode.SubNodes[1];
					bool align = node.AlignBytes || arrayNode.AlignBytes;
					if (type is GenericInstanceTypeSignature genericSignature)
					{
						Debug.Assert(genericSignature.GenericType.Name == $"{nameof(AssetList<>)}`1");
						Debug.Assert(genericSignature.TypeArguments.Count == 1);
						method = MakeListMethod(uniqueName, elementTypeNode, genericSignature.TypeArguments[0], version, align);
					}
					else
					{
						SzArrayTypeSignature arrayType = (SzArrayTypeSignature)type;
						TypeSignature elementType = arrayType.BaseType;
						method = MakeArrayMethod(uniqueName, elementTypeNode, elementType, version, align);
					}
				}
				break;
			case NodeType.Map:
				{
					UniversalNode arrayNode = node.SubNodes[0];
					UniversalNode pairNode = arrayNode.SubNodes[1];
					bool align = node.AlignBytes || arrayNode.AlignBytes;
					GenericInstanceTypeSignature genericSignature = (GenericInstanceTypeSignature)type;
					Debug.Assert(genericSignature.GenericType.Name == $"{nameof(AssetDictionary<,>)}`2");
					Debug.Assert(genericSignature.TypeArguments.Count == 2);
					GenericInstanceTypeSignature pairSignature = assetPairReference.MakeGenericInstanceType(genericSignature.TypeArguments[0], genericSignature.TypeArguments[1]);
					method = MakeDictionaryMethod(uniqueName, pairNode, pairSignature, version, align);
				}
				break;
			case NodeType.Pair:
				{
					UniversalNode firstTypeNode = node.SubNodes[0];
					UniversalNode secondTypeNode = node.SubNodes[1];
					bool align = node.AlignBytes;
					GenericInstanceTypeSignature genericSignature = (GenericInstanceTypeSignature)type;
					Debug.Assert(genericSignature.GenericType.Name == $"{nameof(AssetPair<,>)}`2");
					Debug.Assert(genericSignature.TypeArguments.Count == 2);
					method = MakePairMethod(uniqueName, firstTypeNode, genericSignature.TypeArguments[0], secondTypeNode, genericSignature.TypeArguments[1], version, align);
				}
				break;
			case NodeType.TypelessData: //byte array
				{
					method = MakeTypelessDataMethod(uniqueName, node.AlignBytes);
				}
				break;
			case NodeType.Array:
				{
					UniversalNode elementTypeNode = node.SubNodes[1];
					bool align = node.AlignBytes;
					if (type is GenericInstanceTypeSignature genericSignature)
					{
						Debug.Assert(genericSignature.GenericType.Name == $"{nameof(AssetList<>)}`1");
						Debug.Assert(genericSignature.TypeArguments.Count == 1);
						method = MakeListMethod(uniqueName, elementTypeNode, genericSignature.TypeArguments[0], version, align);
					}
					else
					{
						SzArrayTypeSignature arrayType = (SzArrayTypeSignature)type;
						TypeSignature elementType = arrayType.BaseType;
						method = MakeArrayMethod(uniqueName, elementTypeNode, elementType, version, align);
					}
				}
				break;
			default:
				method = MakePrimitiveMethod(uniqueName, node, node.AlignBytes);
				break;
		}

		methodDictionary.Add(uniqueName, method);
		return method;
	}

	private static MethodDefinition MakeGenericAssetAlignMethod()
	{
		string uniqueName = "AssetAlign";
		GenericParameterSignature elementType = new GenericParameterSignature(SharedState.Instance.Module, GenericParameterType.Method, 0);
		IMethodDefOrRef readMethod = SharedState.Instance.Importer.ImportMethod<UnityAssetBase>(m => m.Name == ReadMethod && m.Parameters[0].ParameterType is ByReferenceTypeSignature);
		MethodDefinition method = NewMethod(uniqueName, elementType);

		CilInstructionCollection instructions = method.GetInstructions();
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Callvirt, readMethod);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.AddCall(alignStreamMethod);
		instructions.Add(CilOpCodes.Ret);

		GenericParameter genericParameter = new GenericParameter("T");
		genericParameter.Constraints.Add(new GenericParameterConstraint(SharedState.Instance.Importer.ImportType<UnityAssetBase>()));
		method.GenericParameters.Add(genericParameter);
		method.Signature!.GenericParameterCount = 1;
		method.Signature.IsGeneric = true;

		return method;
	}

	private static IMethodDescriptor MakeDictionaryMethod(string uniqueName, UniversalNode pairNode, GenericInstanceTypeSignature pairSignature, UnityVersion version, bool align)
	{
		TypeSignature keySignature = pairSignature.TypeArguments[0];
		TypeSignature valueSignature = pairSignature.TypeArguments[1];
		if (keySignature.IsTypeDefinition() && valueSignature.IsTypeDefinition())
		{
			return align
				? readAssetDictionaryAlignDefinition.MakeGenericInstanceMethod(keySignature, valueSignature)
				: readAssetDictionaryDefinition.MakeGenericInstanceMethod(keySignature, valueSignature);
		}
		else
		{
			IMethodDescriptor pairReadMethod = GetOrMakeMethod(pairNode, pairSignature, version);
			return MakeDictionaryMethod(uniqueName, pairReadMethod, keySignature, valueSignature, align);
		}
	}

	private static MethodDefinition MakeGenericDictionaryMethod(bool align)
	{
		string uniqueName = align ? "MapAlign_Asset_Asset" : "Map_Asset_Asset";
		GenericParameterSignature keyType = new GenericParameterSignature(SharedState.Instance.Module, GenericParameterType.Method, 0);
		GenericParameterSignature valueType = new GenericParameterSignature(SharedState.Instance.Module, GenericParameterType.Method, 1);
		IMethodDescriptor readMethod = readAssetPairDefinition.MakeGenericInstanceMethod(keyType, valueType);
		MethodDefinition method = MakeDictionaryMethod(uniqueName, readMethod, keyType, valueType, align);

		GenericParameter keyParameter = new GenericParameter("TKey", GenericParameterAttributes.DefaultConstructorConstraint);
		keyParameter.Constraints.Add(new GenericParameterConstraint(SharedState.Instance.Importer.ImportType<UnityAssetBase>()));
		method.GenericParameters.Add(keyParameter);
		GenericParameter valueParameter = new GenericParameter("TValue", GenericParameterAttributes.DefaultConstructorConstraint);
		valueParameter.Constraints.Add(new GenericParameterConstraint(SharedState.Instance.Importer.ImportType<UnityAssetBase>()));
		method.GenericParameters.Add(valueParameter);
		method.Signature!.GenericParameterCount = 2;
		method.Signature.IsGeneric = true;

		return method;
	}

	private static MethodDefinition MakeDictionaryMethod(string uniqueName, IMethodDescriptor pairReadMethod, TypeSignature keySignature, TypeSignature valueSignature, bool align)
	{
		GenericInstanceTypeSignature genericDictionaryType = assetDictionaryReference.MakeGenericInstanceType(keySignature, valueSignature);

		MethodDefinition clearMethodDefinition = SharedState.Instance.Importer.LookupMethod(typeof(AssetDictionary<,>), m => m.Name == nameof(AssetDictionary<,>.Clear));
		IMethodDefOrRef clearMethodReference = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, genericDictionaryType, clearMethodDefinition);

		MethodDefinition method = NewMethod(uniqueName, genericDictionaryType);
		CilInstructionCollection instructions = method.GetInstructions();

		CilLocalVariable countLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);
		CilLocalVariable iLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);

		CilInstructionLabel loopConditionStartList = new();

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, clearMethodReference);

		//Read count
		instructions.Add(CilOpCodes.Ldarg_1);//reader
		instructions.AddCall(readInt32Method);
		instructions.Add(CilOpCodes.Stloc, countLocal);

		instructions.Add(CilOpCodes.Ldc_I4_0); //Load 0 as an int32
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in count

		//Create an empty, unconditional branch which will jump down to the loop condition.
		//This converts the do..while loop into a for loop.
		instructions.Add(CilOpCodes.Br, loopConditionStartList);

		//Now we just read pair, increment i, compare against count, and jump back to here if it's less
		ICilLabel jumpTargetList = instructions.Add(CilOpCodes.Nop).CreateLabel(); //Create a dummy instruction to jump back to

		MethodDefinition addNewMethodDefinition = SharedState.Instance.Importer.LookupMethod(typeof(AssetDictionary<,>), m => m.Name == nameof(AssetDictionary<,>.AddNew));
		IMethodDefOrRef addNewMethodReference = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, genericDictionaryType, addNewMethodDefinition);

		//Add new and read pair
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.AddCall(addNewMethodReference);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.AddCall(pairReadMethod);

		//Increment i
		instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i local
		instructions.Add(CilOpCodes.Ldc_I4_1); //Load constant 1 as int32
		instructions.Add(CilOpCodes.Add); //Add 
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in i local

		//Jump to start of loop if i < count
		loopConditionStartList.Instruction = instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i
		instructions.Add(CilOpCodes.Ldloc, countLocal); //Load count
		instructions.Add(CilOpCodes.Blt, jumpTargetList); //Jump back up if less than

		if (align)
		{
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.AddCall(alignStreamMethod);
		}
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
		return method;
	}

	private static IMethodDescriptor MakePairMethod(string uniqueName, UniversalNode keyTypeNode, TypeSignature keySignature, UniversalNode valueTypeNode, TypeSignature valueSignature, UnityVersion version, bool align)
	{
		if (keySignature.IsTypeDefinition() && valueSignature.IsTypeDefinition())
		{
			return align
				? readAssetPairAlignDefinition.MakeGenericInstanceMethod(keySignature, valueSignature)
				: readAssetPairDefinition.MakeGenericInstanceMethod(keySignature, valueSignature);
		}
		else
		{
			IMethodDescriptor keyReadMethod = GetOrMakeMethod(keyTypeNode, keySignature, version);
			IMethodDescriptor valueReadMethod = GetOrMakeMethod(valueTypeNode, valueSignature, version);
			return MakePairMethod(uniqueName, keyReadMethod, keySignature, valueReadMethod, valueSignature, align);
		}
	}

	private static MethodDefinition MakeGenericPairMethod(bool align)
	{
		string uniqueName = align ? "PairAlign_Asset_Asset" : "Pair_Asset_Asset";
		GenericParameterSignature keyType = new GenericParameterSignature(SharedState.Instance.Module, GenericParameterType.Method, 0);
		GenericParameterSignature valueType = new GenericParameterSignature(SharedState.Instance.Module, GenericParameterType.Method, 1);
		IMethodDefOrRef readMethod = SharedState.Instance.Importer.ImportMethod<UnityAssetBase>(m => m.Name == ReadMethod && m.Parameters[0].ParameterType is ByReferenceTypeSignature);
		MethodDefinition method = MakePairMethod(uniqueName, readMethod, keyType, readMethod, valueType, align);

		GenericParameter keyParameter = new GenericParameter("TKey", GenericParameterAttributes.DefaultConstructorConstraint);
		keyParameter.Constraints.Add(new GenericParameterConstraint(SharedState.Instance.Importer.ImportType<UnityAssetBase>()));
		method.GenericParameters.Add(keyParameter);
		GenericParameter valueParameter = new GenericParameter("TValue", GenericParameterAttributes.DefaultConstructorConstraint);
		valueParameter.Constraints.Add(new GenericParameterConstraint(SharedState.Instance.Importer.ImportType<UnityAssetBase>()));
		method.GenericParameters.Add(valueParameter);
		method.Signature!.GenericParameterCount = 2;
		method.Signature.IsGeneric = true;

		return method;
	}

	private static MethodDefinition MakePairMethod(string uniqueName, IMethodDescriptor keyReadMethod, TypeSignature keySignature, IMethodDescriptor valueReadMethod, TypeSignature valueSignature, bool align)
	{
		GenericInstanceTypeSignature genericPairType = assetPairReference.MakeGenericInstanceType(keySignature, valueSignature);

		MethodDefinition method = NewMethod(uniqueName, genericPairType);
		CilInstructionCollection instructions = method.GetInstructions();

		if (keySignature.IsArrayOrPrimitive())
		{
			IMethodDefOrRef setKeyMethod = MethodUtils.MakeMethodOnGenericType(
				SharedState.Instance.Importer,
				genericPairType,
				assetPairDefinition.Methods.Single(m => m.Name == $"set_{nameof(AssetPair<,>.Key)}"));

			instructions.Add(CilOpCodes.Ldarg_0);//pair
			instructions.Add(CilOpCodes.Ldarg_1);//reader
			instructions.AddCall(keyReadMethod);
			instructions.AddCall(setKeyMethod);
		}
		else
		{
			IMethodDefOrRef getKeyMethod = MethodUtils.MakeMethodOnGenericType(
				SharedState.Instance.Importer,
				genericPairType,
				assetPairDefinition.Methods.Single(m => m.Name == $"get_{nameof(AssetPair<,>.Key)}"));

			instructions.Add(CilOpCodes.Ldarg_0);//pair
			instructions.AddCall(getKeyMethod);
			instructions.Add(CilOpCodes.Ldarg_1);//reader
			instructions.AddCall(keyReadMethod);
		}

		if (valueSignature.IsArrayOrPrimitive())
		{
			IMethodDefOrRef setValueMethod = MethodUtils.MakeMethodOnGenericType(
				SharedState.Instance.Importer,
				genericPairType,
				assetPairDefinition.Methods.Single(m => m.Name == $"set_{nameof(AssetPair<,>.Value)}"));

			instructions.Add(CilOpCodes.Ldarg_0);//pair
			instructions.Add(CilOpCodes.Ldarg_1);//reader
			instructions.AddCall(valueReadMethod);
			instructions.AddCall(setValueMethod);
		}
		else
		{
			IMethodDefOrRef getValueMethod = MethodUtils.MakeMethodOnGenericType(
				SharedState.Instance.Importer,
				genericPairType,
				assetPairDefinition.Methods.Single(m => m.Name == $"get_{nameof(AssetPair<,>.Value)}"));

			instructions.Add(CilOpCodes.Ldarg_0);//pair
			instructions.AddCall(getValueMethod);
			instructions.Add(CilOpCodes.Ldarg_1);//reader
			instructions.AddCall(valueReadMethod);
		}

		if (align)
		{
			instructions.Add(CilOpCodes.Ldarg_1);//reader
			instructions.AddCall(alignStreamMethod);
		}
		instructions.Add(CilOpCodes.Ret);
		return method;
	}

	private static IMethodDescriptor MakeTypelessDataMethod(string uniqueName, bool align)
	{
		CorLibTypeSignature elementType = SharedState.Instance.Importer.UInt8;
		SzArrayTypeSignature arrayType = elementType.MakeSzArrayType();
		MethodDefinition method = NewMethod(uniqueName, arrayType);
		CilInstructionCollection instructions = method.GetInstructions();

		CilLocalVariable countLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);
		CilLocalVariable arrayLocal = instructions.AddLocalVariable(arrayType);

		//Read count
		instructions.Add(CilOpCodes.Ldarg_0);//reader
		instructions.AddCall(readInt32Method);
		instructions.Add(CilOpCodes.Stloc, countLocal);

		instructions.Add(CilOpCodes.Ldarg_0);//reader
		instructions.Add(CilOpCodes.Ldloc, countLocal);
		instructions.AddCall(readBytesMethod);
		instructions.Add(CilOpCodes.Stloc, arrayLocal);

		if (align)
		{
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.AddCall(alignStreamMethod);
		}
		instructions.Add(CilOpCodes.Ldloc, arrayLocal);
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
		return method;
	}

	private static IMethodDescriptor MakeListMethod(string uniqueName, UniversalNode elementTypeNode, TypeSignature elementType, UnityVersion version, bool align)
	{
		if (elementType.IsTypeDefinition())
		{
			return align
				? readAssetListAlignDefinition.MakeGenericInstanceMethod(elementType)
				: readAssetListDefinition.MakeGenericInstanceMethod(elementType);
		}
		else
		{
			IMethodDescriptor elementReadMethod = GetOrMakeMethod(elementTypeNode, elementType, version);
			return MakeListMethod(uniqueName, elementType, elementReadMethod, align);
		}
	}

	private static MethodDefinition MakeGenericListMethod(bool align)
	{
		string uniqueName = align ? "ArrayAlign_Asset" : "Array_Asset";
		GenericParameterSignature elementType = new GenericParameterSignature(SharedState.Instance.Module, GenericParameterType.Method, 0);
		IMethodDefOrRef readMethod = SharedState.Instance.Importer.ImportMethod<UnityAssetBase>(m => m.Name == ReadMethod && m.Parameters[0].ParameterType is ByReferenceTypeSignature);
		MethodDefinition method = MakeListMethod(uniqueName, elementType, readMethod, align);

		GenericParameter genericParameter = new GenericParameter("T", GenericParameterAttributes.DefaultConstructorConstraint);
		genericParameter.Constraints.Add(new GenericParameterConstraint(SharedState.Instance.Importer.ImportType<UnityAssetBase>()));
		method.GenericParameters.Add(genericParameter);
		method.Signature!.GenericParameterCount = 1;
		method.Signature.IsGeneric = true;

		return method;
	}

	private static MethodDefinition MakeListMethod(string uniqueName, TypeSignature elementType, IMethodDescriptor elementReadMethod, bool align)
	{
		GenericInstanceTypeSignature genericListType = assetListReference.MakeGenericInstanceType(elementType);

		MethodDefinition clearMethodDefinition = SharedState.Instance.Importer.LookupMethod(typeof(AssetList<>), m => m.Name == nameof(AssetList<>.Clear));
		IMethodDefOrRef clearMethodReference = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, genericListType, clearMethodDefinition);

		MethodDefinition method = NewMethod(uniqueName, genericListType);
		CilInstructionCollection instructions = method.GetInstructions();

		CilLocalVariable countLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);
		CilLocalVariable iLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);

		CilInstructionLabel loopConditionStartList = new();

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, clearMethodReference);

		//Read count
		instructions.Add(CilOpCodes.Ldarg_1);//reader
		instructions.AddCall(readInt32Method);
		instructions.Add(CilOpCodes.Stloc, countLocal);

		instructions.Add(CilOpCodes.Ldc_I4_0); //Load 0 as an int32
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in count

		//Create an empty, unconditional branch which will jump down to the loop condition.
		//This converts the do..while loop into a for loop.
		instructions.Add(CilOpCodes.Br, loopConditionStartList);

		//Now we just read pair, increment i, compare against count, and jump back to here if it's less
		ICilLabel jumpTargetList = instructions.Add(CilOpCodes.Nop).CreateLabel(); //Create a dummy instruction to jump back to

		//Read and add to list
		if (elementType.IsArrayOrPrimitive())
		{
			MethodDefinition addMethodDefinition = SharedState.Instance.Importer.LookupMethod(typeof(AssetList<>), m => m.Name == nameof(AssetList<>.Add));
			IMethodDefOrRef addMethodReference = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, genericListType, addMethodDefinition);
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.AddCall(elementReadMethod);
			instructions.AddCall(addMethodReference);
		}
		else
		{
			MethodDefinition addNewMethodDefinition = SharedState.Instance.Importer.LookupMethod(typeof(AssetList<>), m => m.Name == nameof(AssetList<>.AddNew));
			IMethodDefOrRef addNewMethodReference = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, genericListType, addNewMethodDefinition);
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.AddCall(addNewMethodReference);
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.AddCall(elementReadMethod);
		}

		//Increment i
		instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i local
		instructions.Add(CilOpCodes.Ldc_I4_1); //Load constant 1 as int32
		instructions.Add(CilOpCodes.Add); //Add 
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in i local

		//Jump to start of loop if i < count
		loopConditionStartList.Instruction = instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i
		instructions.Add(CilOpCodes.Ldloc, countLocal); //Load count
		instructions.Add(CilOpCodes.Blt, jumpTargetList); //Jump back up if less than

		if (align)
		{
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.AddCall(alignStreamMethod);
		}
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();

		return method;
	}

	private static IMethodDescriptor MakeArrayMethod(string uniqueName, UniversalNode elementTypeNode, TypeSignature elementType, UnityVersion version, bool align)
	{
		if (elementType is CorLibTypeSignature corLibTypeSignature && corLibTypeSignature.ElementType == ElementType.U1)
		{
			return MakeTypelessDataMethod(uniqueName, align);
		}

		bool throwForNonByteArrays = true;
		if (throwForNonByteArrays)
		{
			throw new NotSupportedException();
		}

		IMethodDescriptor elementReadMethod = GetOrMakeMethod(elementTypeNode, elementType, version);

		SzArrayTypeSignature arrayType = elementType.MakeSzArrayType();
		GenericInstanceTypeSignature listType = SharedState.Instance.Importer.ImportType(typeof(List<>)).MakeGenericInstanceType(elementType);
		MethodDefinition method = NewMethod(uniqueName, arrayType);
		CilInstructionCollection instructions = method.GetInstructions();

		CilLocalVariable countLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);
		CilLocalVariable iLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);
		CilLocalVariable arrayLocal = instructions.AddLocalVariable(arrayType);
		CilLocalVariable listLocal = instructions.AddLocalVariable(listType);

		//Read count
		instructions.Add(CilOpCodes.Ldarg_0);//reader
		instructions.AddCall(readInt32Method);
		instructions.Add(CilOpCodes.Stloc, countLocal);

		CilInstructionLabel readAsListInstruction = new();
		CilInstructionLabel loopConditionStartArray = new();
		CilInstructionLabel loopConditionStartList = new();
		CilInstructionLabel returnInstruction = new();

		//Check size of count
		instructions.Add(CilOpCodes.Ldloc, countLocal);
		instructions.Add(CilOpCodes.Ldc_I4, MaxArraySize);
		instructions.Add(CilOpCodes.Bgt, readAsListInstruction);

		//Read into array
		instructions.Add(CilOpCodes.Ldloc, countLocal);
		instructions.Add(CilOpCodes.Newarr, elementType.ToTypeDefOrRef());
		instructions.Add(CilOpCodes.Stloc, arrayLocal);

		instructions.Add(CilOpCodes.Ldc_I4_0); //Load 0 as an int32
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in count

		//Create an empty, unconditional branch which will jump down to the loop condition.
		//This converts the do..while loop into a for loop.
		instructions.Add(CilOpCodes.Br, loopConditionStartArray);

		//Now we just read pair, increment i, compare against count, and jump back to here if it's less
		ICilLabel jumpTargetArray = instructions.Add(CilOpCodes.Nop).CreateLabel(); //Create a dummy instruction to jump back to

		//Read and add to array
		instructions.Add(CilOpCodes.Ldloc, arrayLocal);
		instructions.Add(CilOpCodes.Ldloc, iLocal);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.AddCall(elementReadMethod);
		instructions.AddStoreElement(elementType);

		//Increment i
		instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i local
		instructions.Add(CilOpCodes.Ldc_I4_1); //Load constant 1 as int32
		instructions.Add(CilOpCodes.Add); //Add 
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in i local

		//Jump to start of loop if i < count
		loopConditionStartArray.Instruction = instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i
		instructions.Add(CilOpCodes.Ldloc, countLocal); //Load count
		instructions.Add(CilOpCodes.Blt, jumpTargetArray); //Jump back up if less than

		instructions.Add(CilOpCodes.Br, returnInstruction);//Jump to return statement

		//Read into list (because we don't trust large counts)

		MethodDefinition listConstructorDefinition = SharedState.Instance.Importer.LookupMethod(typeof(List<>), m =>
		{
			return m.IsConstructor
				&& m.Parameters.Count == 1
				&& m.Parameters[0].ParameterType is CorLibTypeSignature corLibTypeSignature
				&& corLibTypeSignature.ElementType == ElementType.I4;
		});
		IMethodDefOrRef listConstructorReference = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, listType, listConstructorDefinition);
		MethodDefinition addMethodDefinition = SharedState.Instance.Importer.LookupMethod(typeof(List<>), m => m.Name == nameof(List<>.Add));
		IMethodDefOrRef addMethodReference = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, listType, addMethodDefinition);
		MethodDefinition toArrayMethodDefinition = SharedState.Instance.Importer.LookupMethod(typeof(List<>), m => m.Name == nameof(List<>.ToArray));
		IMethodDefOrRef toArrayMethodReference = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, listType, toArrayMethodDefinition);

		readAsListInstruction.Instruction = instructions.Add(CilOpCodes.Ldc_I4, MaxArraySize);
		instructions.Add(CilOpCodes.Newobj, listConstructorReference);
		instructions.Add(CilOpCodes.Stloc, listLocal);

		instructions.Add(CilOpCodes.Ldc_I4_0); //Load 0 as an int32
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in count

		//Create an empty, unconditional branch which will jump down to the loop condition.
		//This converts the do..while loop into a for loop.
		instructions.Add(CilOpCodes.Br, loopConditionStartList);

		//Now we just read pair, increment i, compare against count, and jump back to here if it's less
		ICilLabel jumpTargetList = instructions.Add(CilOpCodes.Nop).CreateLabel(); //Create a dummy instruction to jump back to

		//Read byte and add to list
		instructions.Add(CilOpCodes.Ldloc, listLocal);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.AddCall(elementReadMethod);
		instructions.AddCall(addMethodReference);

		//Increment i
		instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i local
		instructions.Add(CilOpCodes.Ldc_I4_1); //Load constant 1 as int32
		instructions.Add(CilOpCodes.Add); //Add 
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in i local

		//Jump to start of loop if i < count
		loopConditionStartList.Instruction = instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i
		instructions.Add(CilOpCodes.Ldloc, countLocal); //Load count
		instructions.Add(CilOpCodes.Blt, jumpTargetList); //Jump back up if less than

		instructions.Add(CilOpCodes.Ldloc, listLocal);
		instructions.AddCall(toArrayMethodReference);
		instructions.Add(CilOpCodes.Stloc, arrayLocal);

		returnInstruction.Instruction = instructions.Add(CilOpCodes.Nop);
		if (align)
		{
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.AddCall(alignStreamMethod);
		}
		instructions.Add(CilOpCodes.Ldloc, arrayLocal);
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
		return method;
	}

	private static IMethodDescriptor MakePrimitiveMethod(string uniqueName, UniversalNode node, bool align)
	{
		IMethodDescriptor primitiveMethod = GetPrimitiveMethod(node);
		if (align)
		{
			MethodDefinition method = NewMethod(uniqueName, primitiveMethod.Signature!.ReturnType);
			CilInstructionCollection instructions = method.GetInstructions();
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.AddCall(primitiveMethod);
			if (align)
			{
				instructions.Add(CilOpCodes.Ldarg_0);
				instructions.AddCall(alignStreamMethod);
			}
			instructions.Add(CilOpCodes.Ret);
			return method;
		}
		else
		{
			return primitiveMethod;
		}
	}

	/// <summary>
	/// Array and primitive read methods have the Func&lt;AssetReader, T&gt; signature.<br/>
	/// Others have the Action&lt;T, AssetReader&gt; signature.
	/// </summary>
	/// <param name="type"></param>
	/// <returns></returns>
	private static bool IsArrayOrPrimitive(this TypeSignature type)
	{
		return type is SzArrayTypeSignature or CorLibTypeSignature or TypeDefOrRefSignature { Namespace: "AssetRipper.Primitives", Name: nameof(Utf8String) };
	}

	private static bool IsTypeDefinition(this TypeSignature type)
	{
		return type is TypeDefOrRefSignature defOrRefSignature && defOrRefSignature.Type is TypeDefinition;
	}

	private static IMethodDescriptor GetPrimitiveMethod(UniversalNode node)
	{
		return node.NodeType switch
		{
			NodeType.Boolean => primitiveReadMethods[ElementType.Boolean],
			NodeType.Character => primitiveReadMethods[ElementType.Char],
			NodeType.Int8 => primitiveReadMethods[ElementType.I1],
			NodeType.UInt8 => primitiveReadMethods[ElementType.U1],
			NodeType.Int16 => primitiveReadMethods[ElementType.I2],
			NodeType.UInt16 => primitiveReadMethods[ElementType.U2],
			NodeType.Int32 => primitiveReadMethods[ElementType.I4],
			NodeType.UInt32 => primitiveReadMethods[ElementType.U4],
			NodeType.Int64 => primitiveReadMethods[ElementType.I8],
			NodeType.UInt64 => primitiveReadMethods[ElementType.U8],
			NodeType.Single => primitiveReadMethods[ElementType.R4],
			NodeType.Double => primitiveReadMethods[ElementType.R8],
			NodeType.String => primitiveReadMethods[ElementType.String],
			_ => throw new NotSupportedException(node.TypeName),
		};
	}

	private static MethodDefinition NewMethod(string uniqueName, TypeSignature parameter)
	{
		if (parameter.IsArrayOrPrimitive())
		{
			MethodSignature methodSignature = MethodSignature.CreateStatic(parameter);
			MethodDefinition method = new MethodDefinition($"{ReadMethod}_{uniqueName}", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig, methodSignature);
			method.CilMethodBody = new CilMethodBody();
			method.AddParameter(endianSpanReaderReference, "reader");
			method.AddExtensionAttribute(SharedState.Instance.Importer);
			return method;
		}
		else
		{
			MethodSignature methodSignature = MethodSignature.CreateStatic(SharedState.Instance.Importer.Void);
			MethodDefinition method = new MethodDefinition($"{ReadMethod}_{uniqueName}", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig, methodSignature);
			method.CilMethodBody = new CilMethodBody();
			method.AddParameter(parameter, "value");
			method.AddParameter(endianSpanReaderReference, "reader");
			method.AddExtensionAttribute(SharedState.Instance.Importer);
			return method;
		}
	}

	private static CilInstruction AddCall(this CilInstructionCollection instructions, IMethodDescriptor method)
	{
		return method is MethodDefinition definition && definition.IsStatic
			? instructions.Add(CilOpCodes.Call, method)
			: instructions.Add(CilOpCodes.Callvirt, method);
	}

	private static IMethodDefOrRef GetDefaultConstructor(this TypeSignature type)
	{
		return type switch
		{
			TypeDefOrRefSignature typeDefOrRefSignature => typeDefOrRefSignature.Type is TypeDefinition typeDefinition
										? typeDefinition.GetDefaultConstructor()
										: throw new InvalidOperationException(),
			GenericInstanceTypeSignature genericInstanceTypeSignature => MethodUtils.MakeConstructorOnGenericType(SharedState.Instance.Importer, genericInstanceTypeSignature, 0),
			_ => throw new NotSupportedException(),
		};
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass101_FillWriteMethods.cs`:

```cs
using AssetRipper.AssemblyDumper.Attributes;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.IO.Writing;
using AssetRipper.IO.Endian;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass101_FillWriteMethods
{
	private static IMethodDefOrRef? alignStreamMethod;
	private static IMethodDescriptor? writeInt32Method;
	private static ITypeDefOrRef? assetWriterReference;

	private static ITypeDefOrRef? assetDictionaryReference;
	private static TypeDefinition? assetDictionaryDefinition;
	private static ITypeDefOrRef? assetListReference;
	private static TypeDefinition? assetListDefinition;
	private static ITypeDefOrRef? keyValuePairReference;
	private static TypeDefinition? keyValuePairDefinition;

	private static MethodDefinition? writeAssetAlignDefinition;
	private static MethodDefinition? writeAssetListDefinition;
	private static MethodDefinition? writeAssetListAlignDefinition;

	private const string WriteRelease = nameof(UnityAssetBase.WriteRelease);
	private const string WriteEditor = nameof(UnityAssetBase.WriteEditor);
	private static string WriteMethod => emittingRelease ? WriteRelease : WriteEditor;

	private static readonly bool throwNotSupported = false;
	private static readonly Dictionary<string, IMethodDescriptor> methodDictionary = new();
	private static readonly SignatureComparer signatureComparer = new(SignatureComparisonFlags.VersionAgnostic);
	private static bool emittingRelease;

	private static void Initialize()
	{
		alignStreamMethod = SharedState.Instance.Importer.ImportMethod<EndianWriter>(m => m.Name == nameof(EndianWriter.AlignStream));
		writeInt32Method = ImportPrimitiveWriteMethod(ElementType.I4);
		assetWriterReference = SharedState.Instance.Importer.ImportType<AssetWriter>();

		assetDictionaryReference = SharedState.Instance.Importer.ImportType(typeof(AssetDictionary<,>));
		assetListReference = SharedState.Instance.Importer.ImportType(typeof(AssetList<>));
		keyValuePairReference = SharedState.Instance.Importer.ImportType(typeof(AssetPair<,>));

		assetDictionaryDefinition = SharedState.Instance.Importer.LookupType(typeof(AssetDictionary<,>));
		assetListDefinition = SharedState.Instance.Importer.LookupType(typeof(AssetList<>));
		keyValuePairDefinition = SharedState.Instance.Importer.LookupType(typeof(AssetPair<,>));
	}

	public static void DoPass()
	{
		Initialize();

		emittingRelease = true;
		methodDictionary.Clear();
		writeAssetAlignDefinition = MakeGenericAssetAlignMethod();
		writeAssetListDefinition = MakeGenericListMethod(false);
		writeAssetListAlignDefinition = MakeGenericListMethod(true);
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				instance.Type.FillReleaseWriteMethod(instance.Class, instance.VersionRange.Start);
			}
		}
		CreateHelperClassForWriteMethods();

		emittingRelease = false;
		methodDictionary.Clear();
		writeAssetAlignDefinition = MakeGenericAssetAlignMethod();
		writeAssetListDefinition = MakeGenericListMethod(false);
		writeAssetListAlignDefinition = MakeGenericListMethod(true);
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				instance.Type.FillEditorWriteMethod(instance.Class, instance.VersionRange.Start);
			}
		}
		CreateHelperClassForWriteMethods();

		methodDictionary.Clear();
	}

	private static void CreateHelperClassForWriteMethods()
	{
		TypeDefinition type = StaticClassCreator.CreateEmptyStaticClass(SharedState.Instance.Module, SharedState.HelpersNamespace, $"{WriteMethod}Methods");
		type.IsPublic = false;
		type.Methods.Add(writeAssetAlignDefinition!);
		type.Methods.Add(writeAssetListDefinition!);
		type.Methods.Add(writeAssetListAlignDefinition!);
		foreach ((string _, IMethodDescriptor method) in methodDictionary.OrderBy(pair => pair.Key))
		{
			if (method is MethodDefinition methodDefinition && methodDefinition.DeclaringType is null)
			{
				type.Methods.Add(methodDefinition);
			}
		}
		Console.WriteLine($"\t{type.Methods.Count} {WriteMethod} helper methods");
	}

	private static void FillEditorWriteMethod(this TypeDefinition type, UniversalClass klass, UnityVersion version)
	{
		MethodDefinition method = type.Methods.First(m => m.Name == WriteEditor);
		CilInstructionCollection instructions = method.GetInstructions();

		if (throwNotSupported)
		{
			instructions.AddNotSupportedException();
		}
		else
		{
			if (klass.EditorRootNode != null)
			{
				foreach (UniversalNode unityNode in klass.EditorRootNode.SubNodes)
				{
					FieldDefinition field = type.GetFieldByName(unityNode.Name, true);
					IMethodDescriptor fieldWriteMethod = GetOrMakeMethod(unityNode, field.Signature!.FieldType, version);
					instructions.Add(CilOpCodes.Ldarg_0);//this
					instructions.Add(CilOpCodes.Ldfld, field);
					instructions.Add(CilOpCodes.Ldarg_1);//writer
					instructions.AddCall(fieldWriteMethod);
				}
			}
			instructions.Add(CilOpCodes.Ret);
		}
		instructions.OptimizeMacros();
	}

	private static void FillReleaseWriteMethod(this TypeDefinition type, UniversalClass klass, UnityVersion version)
	{
		MethodDefinition method = type.Methods.First(m => m.Name == WriteRelease);
		CilInstructionCollection instructions = method.GetInstructions();

		if (throwNotSupported)
		{
			instructions.AddNotSupportedException();
		}
		else
		{
			if (klass.ReleaseRootNode != null)
			{
				foreach (UniversalNode unityNode in klass.ReleaseRootNode.SubNodes)
				{
					FieldDefinition field = type.GetFieldByName(unityNode.Name, true);
					IMethodDescriptor fieldWriteMethod = GetOrMakeMethod(unityNode, field.Signature!.FieldType, version);
					instructions.Add(CilOpCodes.Ldarg_0);//this
					instructions.Add(CilOpCodes.Ldfld, field);
					instructions.Add(CilOpCodes.Ldarg_1);//writer
					instructions.AddCall(fieldWriteMethod);
				}
			}
			instructions.Add(CilOpCodes.Ret);
		}
		instructions.OptimizeMacros();
	}

	private static IMethodDescriptor GetOrMakeMethod(UniversalNode node, TypeSignature type, UnityVersion version)
	{
		string uniqueName = UniqueNameFactory.GetReadWriteName(node, version);
		if (methodDictionary.TryGetValue(uniqueName, out IMethodDescriptor? method))
		{
			return method;
		}

		if (SharedState.Instance.SubclassGroups.TryGetValue(node.TypeName, out SubclassGroup? subclassGroup))
		{
			TypeDefinition typeDefinition = subclassGroup.GetTypeForVersion(version);
			Debug.Assert(signatureComparer.Equals(typeDefinition.ToTypeSignature(), type));
			MethodDefinition typeWriteMethod = typeDefinition.GetMethodByName(WriteMethod);
			method = node.AlignBytes ? writeAssetAlignDefinition!.MakeGenericInstanceMethod(type) : typeWriteMethod;
			methodDictionary.Add(uniqueName, method);
			return method;
		}

		switch (node.NodeType)
		{
			case NodeType.Vector:
				{
					UniversalNode arrayNode = node.SubNodes[0];
					UniversalNode elementTypeNode = arrayNode.SubNodes[1];
					bool align = node.AlignBytes || arrayNode.AlignBytes;
					if (type is GenericInstanceTypeSignature genericSignature)
					{
						Debug.Assert(genericSignature.GenericType.Name == $"{nameof(AssetList<>)}`1");
						Debug.Assert(genericSignature.TypeArguments.Count == 1);
						method = MakeListMethod(uniqueName, elementTypeNode, genericSignature.TypeArguments[0], version, align);
					}
					else
					{
						SzArrayTypeSignature arrayType = (SzArrayTypeSignature)type;
						TypeSignature elementType = arrayType.BaseType;
						method = MakeArrayMethod(uniqueName, elementTypeNode, elementType, version, align);
					}
				}
				break;
			case NodeType.Map:
				{
					UniversalNode arrayNode = node.SubNodes[0];
					UniversalNode pairNode = arrayNode.SubNodes[1];
					UniversalNode firstTypeNode = pairNode.SubNodes[0];
					UniversalNode secondTypeNode = pairNode.SubNodes[1];
					bool align = node.AlignBytes || arrayNode.AlignBytes;
					GenericInstanceTypeSignature genericSignature = (GenericInstanceTypeSignature)type;
					Debug.Assert(genericSignature.GenericType.Name == $"{nameof(AssetDictionary<,>)}`2");
					Debug.Assert(genericSignature.TypeArguments.Count == 2);
					method = MakeDictionaryMethod(uniqueName, firstTypeNode, genericSignature.TypeArguments[0], secondTypeNode, genericSignature.TypeArguments[1], version, align);
				}
				break;
			case NodeType.Pair:
				{
					UniversalNode firstTypeNode = node.SubNodes[0];
					UniversalNode secondTypeNode = node.SubNodes[1];
					bool align = node.AlignBytes;
					GenericInstanceTypeSignature genericSignature = (GenericInstanceTypeSignature)type;
					Debug.Assert(genericSignature.GenericType.Name == $"{nameof(AssetPair<,>)}`2");
					Debug.Assert(genericSignature.TypeArguments.Count == 2);
					method = MakePairMethod(uniqueName, firstTypeNode, genericSignature.TypeArguments[0], secondTypeNode, genericSignature.TypeArguments[1], version, align);
				}
				break;
			case NodeType.TypelessData: //byte array
				{
					method = MakeTypelessDataMethod(uniqueName, node.AlignBytes);
				}
				break;
			case NodeType.Array:
				{
					UniversalNode elementTypeNode = node.SubNodes[1];
					bool align = node.AlignBytes;
					if (type is GenericInstanceTypeSignature genericSignature)
					{
						Debug.Assert(genericSignature.GenericType.Name == $"{nameof(AssetList<>)}`1");
						Debug.Assert(genericSignature.TypeArguments.Count == 1);
						method = MakeListMethod(uniqueName, elementTypeNode, genericSignature.TypeArguments[0], version, align);
					}
					else
					{
						SzArrayTypeSignature arrayType = (SzArrayTypeSignature)type;
						TypeSignature elementType = arrayType.BaseType;
						method = MakeArrayMethod(uniqueName, elementTypeNode, elementType, version, align);
					}
				}
				break;
			default:
				method = MakePrimitiveMethod(uniqueName, node, node.AlignBytes);
				break;
		}

		if (method is null)
		{
			throw new InvalidOperationException();
		}

		methodDictionary.Add(uniqueName, method);
		return method;
	}

	private static MethodDefinition MakeGenericAssetAlignMethod()
	{
		string uniqueName = "AssetAlign";
		GenericParameterSignature elementType = new GenericParameterSignature(SharedState.Instance.Module, GenericParameterType.Method, 0);
		IMethodDefOrRef writeMethod = SharedState.Instance.Importer.ImportMethod<UnityAssetBase>(m => m.Name == WriteMethod);
		MethodDefinition method = NewWriteMethod(uniqueName, elementType);

		CilInstructionCollection instructions = method.GetInstructions();
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Callvirt, writeMethod);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.AddCall(alignStreamMethod!);
		instructions.Add(CilOpCodes.Ret);

		GenericParameter genericParameter = new GenericParameter("T", GenericParameterAttributes.DefaultConstructorConstraint);
		genericParameter.Constraints.Add(new GenericParameterConstraint(SharedState.Instance.Importer.ImportType<UnityAssetBase>()));
		method.GenericParameters.Add(genericParameter);
		method.Signature!.GenericParameterCount = 1;
		method.Signature.IsGeneric = true;

		return method;
	}

	private static IMethodDescriptor? MakeTypelessDataMethod(string uniqueName, bool align)
	{
		IMethodDefOrRef writeBytesMethod = SharedState.Instance.Importer.ImportMethod<BinaryWriter>(m =>
		{
			return m.Name == nameof(BinaryWriter.Write)
				&& m.Parameters.Count == 1
				&& m.Parameters[0].ParameterType is SzArrayTypeSignature arrayTypeSignature
				&& arrayTypeSignature.BaseType is CorLibTypeSignature corLibTypeSignature
				&& corLibTypeSignature.ElementType == ElementType.U1;
		});
		MethodDefinition method = NewWriteMethod(uniqueName, SharedState.Instance.Importer.UInt8.MakeSzArrayType());
		CilInstructionCollection instructions = method.GetInstructions();
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldlen);
		instructions.AddCall(writeInt32Method!);

		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.AddCall(writeBytesMethod);
		if (align)
		{
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.AddCall(alignStreamMethod!);
		}
		instructions.Add(CilOpCodes.Ret);
		return method;
	}

	private static IMethodDescriptor? MakePrimitiveMethod(string uniqueName, UniversalNode node, bool align)
	{
		IMethodDescriptor primitiveMethod = GetPrimitiveMethod(node);
		MethodDefinition method = NewWriteMethod(uniqueName, primitiveMethod.Signature!.ParameterTypes[0]);
		CilInstructionCollection instructions = method.GetInstructions();
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.AddCall(primitiveMethod);
		if (align)
		{
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.AddCall(alignStreamMethod!);
		}
		instructions.Add(CilOpCodes.Ret);
		return method;
	}

	private static IMethodDescriptor? MakePairMethod(string uniqueName, UniversalNode firstTypeNode, TypeSignature typeSignature1, UniversalNode secondTypeNode, TypeSignature typeSignature2, UnityVersion version, bool align)
	{
		IMethodDescriptor firstWriteMethod = GetOrMakeMethod(firstTypeNode, typeSignature1, version);
		IMethodDescriptor secondWriteMethod = GetOrMakeMethod(secondTypeNode, typeSignature2, version);

		GenericInstanceTypeSignature genericPairType = keyValuePairReference!.MakeGenericInstanceType(typeSignature1, typeSignature2);

		IMethodDefOrRef keyMethod = MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericPairType,
			keyValuePairDefinition!.Methods.Single(m => m.Name == $"get_{nameof(AssetPair<,>.Key)}"));

		IMethodDefOrRef valueMethod = MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericPairType,
			keyValuePairDefinition!.Methods.Single(m => m.Name == $"get_{nameof(AssetPair<,>.Value)}"));

		MethodDefinition method = NewWriteMethod(uniqueName, genericPairType);
		CilInstructionCollection instructions = method.GetInstructions();
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.AddCall(keyMethod);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.AddCall(firstWriteMethod);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.AddCall(valueMethod);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.AddCall(secondWriteMethod);
		if (align)
		{
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.AddCall(alignStreamMethod!);
		}
		instructions.Add(CilOpCodes.Ret);
		return method;
	}

	private static IMethodDescriptor? MakeArrayMethod(string uniqueName, UniversalNode elementTypeNode, TypeSignature elementType, UnityVersion version, bool align)
	{
		IMethodDescriptor elementWriteMethod = GetOrMakeMethod(elementTypeNode, elementType, version);

		SzArrayTypeSignature arrayTypeSignature = elementType.MakeSzArrayType();

		MethodDefinition method = NewWriteMethod(uniqueName, arrayTypeSignature);
		CilInstructionCollection instructions = method.GetInstructions();

		//Read length of array
		instructions.Add(CilOpCodes.Ldarg_0); //Load array
		instructions.Add(CilOpCodes.Ldlen); //Get length

		//Make local and store length in it
		CilLocalVariable countLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32); //Create local
		instructions.Add(CilOpCodes.Stloc, countLocal); //Store count in it

		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Ldloc, countLocal);
		instructions.AddCall(writeInt32Method!);//Write the count

		//Make an i
		CilLocalVariable iLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32); //Create local
		instructions.Add(CilOpCodes.Ldc_I4_0); //Load 0 as an int32
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in count

		CilInstructionLabel loopConditionStartLabel = new(); //Needed later

		//Create an empty, unconditional branch which will jump down to the loop condition.
		//This converts the do..while loop into a for loop.
		instructions.Add(CilOpCodes.Br, loopConditionStartLabel);

		//Now we just read pair, increment i, compare against count, and jump back to here if it's less
		ICilLabel jumpTarget = instructions.Add(CilOpCodes.Nop).CreateLabel(); //Create a dummy instruction to jump back to

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldloc, iLocal);
		instructions.AddLoadElement(elementType);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.AddCall(elementWriteMethod);

		//Increment i
		instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i local
		instructions.Add(CilOpCodes.Ldc_I4_1); //Load constant 1 as int32
		instructions.Add(CilOpCodes.Add); //Add 
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in i local

		//Jump to start of loop if i < count
		loopConditionStartLabel.Instruction = instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i
		instructions.Add(CilOpCodes.Ldloc, countLocal); //Load count
		instructions.Add(CilOpCodes.Blt, jumpTarget); //Jump back up if less than

		if (align)
		{
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.AddCall(alignStreamMethod!);
		}
		instructions.Add(CilOpCodes.Ret);
		return method;
	}

	private static IMethodDescriptor MakeListMethod(string uniqueName, UniversalNode elementTypeNode, TypeSignature elementType, UnityVersion version, bool align)
	{
		if (elementType is TypeDefOrRefSignature typeDefOrRefSignature && typeDefOrRefSignature.Type is TypeDefinition)
		{
			return align
				? writeAssetListAlignDefinition!.MakeGenericInstanceMethod(elementType)
				: writeAssetListDefinition!.MakeGenericInstanceMethod(elementType);
		}
		else
		{
			IMethodDescriptor elementWriteMethod = GetOrMakeMethod(elementTypeNode, elementType, version);
			return MakeListMethod(uniqueName, elementType, elementWriteMethod, align);
		}
	}

	private static MethodDefinition MakeGenericListMethod(bool align)
	{
		string uniqueName = align ? "ArrayAlign_Asset" : "Array_Asset";
		GenericParameterSignature elementType = new GenericParameterSignature(SharedState.Instance.Module, GenericParameterType.Method, 0);
		IMethodDefOrRef writeMethod = SharedState.Instance.Importer.ImportMethod<UnityAssetBase>(m => m.Name == WriteMethod);
		MethodDefinition method = MakeListMethod(uniqueName, elementType, writeMethod, align);

		GenericParameter genericParameter = new GenericParameter("T", GenericParameterAttributes.DefaultConstructorConstraint);
		genericParameter.Constraints.Add(new GenericParameterConstraint(SharedState.Instance.Importer.ImportType<UnityAssetBase>()));
		method.GenericParameters.Add(genericParameter);
		method.Signature!.GenericParameterCount = 1;
		method.Signature.IsGeneric = true;

		return method;
	}

	private static MethodDefinition MakeListMethod(string uniqueName, TypeSignature elementType, IMethodDescriptor elementWriteMethod, bool align)
	{
		GenericInstanceTypeSignature genericListType = assetListReference!.MakeGenericInstanceType(elementType);

		IMethodDefOrRef countMethod = MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericListType,
			assetListDefinition!.Methods.Single(m => m.Name == $"get_{nameof(AssetList<>.Count)}"));

		IMethodDefOrRef getElementMethod = MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericListType,
			assetListDefinition!.Methods.Single(m => m.Name == "get_Item"));

		MethodDefinition method = NewWriteMethod(uniqueName, genericListType);
		CilInstructionCollection instructions = method.GetInstructions();

		//Load Count
		instructions.Add(CilOpCodes.Ldarg_0); //Load list
		instructions.AddCall(countMethod); //Call get Count

		//Make local and store length in it
		CilLocalVariable countLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32); //Create local
		instructions.Add(CilOpCodes.Stloc, countLocal); //Store count in it

		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Ldloc, countLocal);
		instructions.AddCall(writeInt32Method!);//Write the count

		//Make an i
		CilLocalVariable iLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32); //Create local
		instructions.Add(CilOpCodes.Ldc_I4_0); //Load 0 as an int32
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in count

		CilInstructionLabel loopConditionStartLabel = new(); //Needed later

		//Create an empty, unconditional branch which will jump down to the loop condition.
		//This converts the do..while loop into a for loop.
		instructions.Add(CilOpCodes.Br, loopConditionStartLabel);

		//Now we just read pair, increment i, compare against count, and jump back to here if it's less
		ICilLabel jumpTarget = instructions.Add(CilOpCodes.Nop).CreateLabel(); //Create a dummy instruction to jump back to

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldloc, iLocal);
		instructions.AddCall(getElementMethod);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.AddCall(elementWriteMethod);

		//Increment i
		instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i local
		instructions.Add(CilOpCodes.Ldc_I4_1); //Load constant 1 as int32
		instructions.Add(CilOpCodes.Add); //Add 
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in i local

		//Jump to start of loop if i < count
		loopConditionStartLabel.Instruction = instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i
		instructions.Add(CilOpCodes.Ldloc, countLocal); //Load count
		instructions.Add(CilOpCodes.Blt, jumpTarget); //Jump back up if less than

		if (align)
		{
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.AddCall(alignStreamMethod!);
		}
		instructions.Add(CilOpCodes.Ret);
		return method;
	}

	private static IMethodDescriptor? MakeDictionaryMethod(string uniqueName, UniversalNode firstTypeNode, TypeSignature typeSignature1, UniversalNode secondTypeNode, TypeSignature typeSignature2, UnityVersion version, bool align)
	{
		IMethodDescriptor firstWriteMethod = GetOrMakeMethod(firstTypeNode, typeSignature1, version);
		IMethodDescriptor secondWriteMethod = GetOrMakeMethod(secondTypeNode, typeSignature2, version);

		GenericInstanceTypeSignature genericPairType = keyValuePairReference!.MakeGenericInstanceType(typeSignature1, typeSignature2);

		IMethodDefOrRef keyMethod = MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericPairType,
			keyValuePairDefinition!.Methods.Single(m => m.Name == $"get_{nameof(AssetPair<,>.Key)}"));

		IMethodDefOrRef valueMethod = MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericPairType,
			keyValuePairDefinition!.Methods.Single(m => m.Name == $"get_{nameof(AssetPair<,>.Value)}"));

		GenericInstanceTypeSignature genericDictionaryType = assetDictionaryReference!.MakeGenericInstanceType(typeSignature1, typeSignature2);

		IMethodDefOrRef countMethod = MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericDictionaryType,
			assetDictionaryDefinition!.Methods.Single(m => m.Name == $"get_{nameof(AssetDictionary<,>.Count)}"));

		IMethodDefOrRef getPairMethod = MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericDictionaryType,
			assetDictionaryDefinition!.Methods.Single(m => m.Name == nameof(AssetDictionary<,>.GetPair)));

		MethodDefinition method = NewWriteMethod(uniqueName, genericDictionaryType);
		CilInstructionCollection instructions = method.GetInstructions();

		//Load Count
		instructions.Add(CilOpCodes.Ldarg_0); //Load dictionary
		instructions.AddCall(countMethod); //Call get Count

		//Make local and store length in it
		CilLocalVariable countLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32); //Create local
		instructions.Add(CilOpCodes.Stloc, countLocal); //Store count in it

		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Ldloc, countLocal);
		instructions.AddCall(writeInt32Method!);//Write the count

		//Make an i
		CilLocalVariable iLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32); //Create local
		instructions.Add(CilOpCodes.Ldc_I4_0); //Load 0 as an int32
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in count

		CilInstructionLabel loopConditionStartLabel = new(); //Needed later

		//Create an empty, unconditional branch which will jump down to the loop condition.
		//This converts the do..while loop into a for loop.
		instructions.Add(CilOpCodes.Br, loopConditionStartLabel);

		//Now we just read pair, increment i, compare against count, and jump back to here if it's less
		ICilLabel jumpTarget = instructions.Add(CilOpCodes.Nop).CreateLabel(); //Create a dummy instruction to jump back to

		CilLocalVariable pairLocal = instructions.AddLocalVariable(genericPairType);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldloc, iLocal);
		instructions.AddCall(getPairMethod);
		instructions.Add(CilOpCodes.Stloc, pairLocal);

		instructions.Add(CilOpCodes.Ldloc, pairLocal);
		instructions.AddCall(keyMethod);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.AddCall(firstWriteMethod);
		instructions.Add(CilOpCodes.Ldloc, pairLocal);
		instructions.AddCall(valueMethod);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.AddCall(secondWriteMethod);

		//Increment i
		instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i local
		instructions.Add(CilOpCodes.Ldc_I4_1); //Load constant 1 as int32
		instructions.Add(CilOpCodes.Add); //Add 
		instructions.Add(CilOpCodes.Stloc, iLocal); //Store in i local

		//Jump to start of loop if i < count
		loopConditionStartLabel.Instruction = instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i
		instructions.Add(CilOpCodes.Ldloc, countLocal); //Load count
		instructions.Add(CilOpCodes.Blt, jumpTarget); //Jump back up if less than

		if (align)
		{
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.AddCall(alignStreamMethod!);
		}
		instructions.Add(CilOpCodes.Ret);
		return method;
	}

	private static IMethodDescriptor GetPrimitiveMethod(UniversalNode node)
	{
		return node.NodeType switch
		{
			NodeType.Boolean => ImportPrimitiveWriteMethod(ElementType.Boolean),
			NodeType.Character => ImportPrimitiveWriteMethod(ElementType.Char),
			NodeType.Int8 => ImportPrimitiveWriteMethod(ElementType.I1),
			NodeType.UInt8 => ImportPrimitiveWriteMethod(ElementType.U1),
			NodeType.Int16 => ImportPrimitiveWriteMethod(ElementType.I2),
			NodeType.UInt16 => ImportPrimitiveWriteMethod(ElementType.U2),
			NodeType.Int32 => writeInt32Method!,
			NodeType.UInt32 => ImportPrimitiveWriteMethod(ElementType.U4),
			NodeType.Int64 => ImportPrimitiveWriteMethod(ElementType.I8),
			NodeType.UInt64 => ImportPrimitiveWriteMethod(ElementType.U8),
			NodeType.Single => ImportPrimitiveWriteMethod(ElementType.R4),
			NodeType.Double => ImportPrimitiveWriteMethod(ElementType.R8),
			NodeType.String => SharedState.Instance.Importer.ImportMethod<EndianWriter>(m =>
			{
				return m.Name == nameof(EndianWriter.Write)
					&& m.Parameters.Count == 1
					&& m.Parameters[0].ParameterType is TypeDefOrRefSignature { Namespace: "AssetRipper.Primitives", Name: nameof(Utf8String) };
			}),
			_ => throw new NotSupportedException(node.TypeName),
		};
	}

	private static IMethodDescriptor ImportPrimitiveWriteMethod(ElementType elementType)
	{
		if (elementType is ElementType.Boolean or ElementType.U1 or ElementType.I1)
		{
			return SharedState.Instance.Importer.ImportMethod<BinaryWriter>(m =>
			{
				return m.Name == nameof(BinaryWriter.Write)
					&& m.Parameters.Count == 1
					&& m.Parameters[0].ParameterType is CorLibTypeSignature corLibTypeSignature
					&& corLibTypeSignature.ElementType == elementType;
			});
		}
		else
		{
			return SharedState.Instance.Importer.ImportMethod<EndianWriter>(m =>
			{
				return m.Name == nameof(EndianWriter.Write)
					&& m.Parameters.Count == 1
					&& m.Parameters[0].ParameterType is CorLibTypeSignature corLibTypeSignature
					&& corLibTypeSignature.ElementType == elementType;
			});
		}
	}

	private static MethodDefinition NewWriteMethod(string uniqueName, TypeSignature parameter)
	{
		MethodSignature methodSignature = MethodSignature.CreateStatic(SharedState.Instance.Importer.Void);
		MethodDefinition method = new MethodDefinition($"{WriteMethod}_{uniqueName}", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig, methodSignature);
		method.CilMethodBody = new CilMethodBody();
		method.AddParameter(parameter, "value");
		method.AddParameter(assetWriterReference!.ToTypeSignature(), "writer");
		method.AddExtensionAttribute(SharedState.Instance.Importer);
		return method;
	}

	private static CilInstruction AddCall(this CilInstructionCollection instructions, IMethodDescriptor method)
	{
		return method is MethodDefinition definition && definition.IsStatic
			? instructions.Add(CilOpCodes.Call, method)
			: instructions.Add(CilOpCodes.Callvirt, method);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass102_IgnoreFieldInMetaFilesMethods.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass102_IgnoreFieldInMetaFilesMethods
{
	private static Dictionary<GeneratedClassInstance, string[]> ClassesWithFields { get; } = new();

	public static void DoPass()
	{
		FillCollections();

		IMethodDefOrRef stringEqualsMethod = SharedState.Instance.Importer.ImportMethod(typeof(string), m => m.Name == "op_Equality");

		foreach (GeneratedClassInstance instance in SharedState.Instance.AllInstances)
		{
			if (NeedsMethodEmitted(instance))
			{
				MethodDefinition method = instance.Type.AddMethod(nameof(UnityAssetBase.IgnoreFieldInMetaFiles), Pass063_CreateEmptyMethods.OverrideMethodAttributes, SharedState.Instance.Importer.Boolean);
				method.AddParameter(SharedState.Instance.Importer.String, "fieldName");
				CilInstructionCollection instructions = method.GetInstructions();
				if (ClassesWithFields.TryGetValue(instance, out string[]? fields))
				{
					CilInstructionLabel trueLabel = new();
					CilInstructionLabel returnLabel = new();

					for (int i = 0; i < fields.Length; i++)
					{
						instructions.Add(CilOpCodes.Ldarg_1);
						instructions.Add(CilOpCodes.Ldstr, fields[i]);
						instructions.Add(CilOpCodes.Call, stringEqualsMethod);
						if (i == fields.Length - 1)
						{
							instructions.Add(CilOpCodes.Br, returnLabel);
						}
						else
						{
							instructions.Add(CilOpCodes.Brtrue, trueLabel);
						}
					}

					trueLabel.Instruction = instructions.Add(CilOpCodes.Ldc_I4_1);
					returnLabel.Instruction = instructions.Add(CilOpCodes.Ret);
				}
				else
				{
					instructions.Add(CilOpCodes.Ldc_I4_0);
					instructions.Add(CilOpCodes.Ret);
				}
			}
		}
	}

	private static bool NeedsMethodEmitted(GeneratedClassInstance instance)
	{
		if (instance.Base is null)
		{
			return ClassesWithFields.ContainsKey(instance);
		}

		if (ClassesWithFields.TryGetValue(instance, out string[]? derivedFields))
		{
			if (ClassesWithFields.TryGetValue(instance.Base, out string[]? baseFields))
			{
				if (derivedFields.Length != baseFields.Length)
				{
					return true;
				}

				foreach (string field in derivedFields)
				{
					if (Array.IndexOf(baseFields, field) < 0)
					{
						return true;
					}
				}

				return false;
			}
			else
			{
				return true;
			}
		}
		else
		{
			return ClassesWithFields.ContainsKey(instance.Base);
		}
	}

	private static void FillCollections()
	{
		ClassesWithFields.Clear();
		List<string> fields = new();
		foreach (GeneratedClassInstance instance in SharedState.Instance.AllInstances)
		{
			if (instance.Class.EditorRootNode is null)
			{
				continue;
			}
			fields.Clear();
			foreach (UniversalNode node in instance.Class.EditorRootNode.SubNodes)
			{
				if (node.IgnoreInMetaFiles)
				{
					fields.Add(node.OriginalName);
				}
			}
			if (fields.Count > 0)
			{
				ClassesWithFields.Add(instance, fields.ToArray());
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass103_FillDependencyMethods.DependencyMethodContext.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.AssemblyDumper.Passes;

public static partial class Pass103_FillDependencyMethods
{
	private sealed class DependencyMethodContext
	{
		public DependencyMethodContext()
		{
			{
				GenericInstanceTypeSignature tupleSignature = SharedState.Instance.Importer.ImportType(typeof(ValueTuple<,>)).MakeGenericInstanceType(
					SharedState.Instance.Importer.ImportType(typeof(string)).ToTypeSignature(),
					SharedState.Instance.Importer.ImportType(typeof(PPtr)).ToTypeSignature());
				TupleConstructor = MethodUtils.MakeConstructorOnGenericType(SharedState.Instance.Importer, tupleSignature, 2);
			}
		}
		public required CilInstructionCollection Processor { get; init; }
		public required TypeDefinition Type { get; init; }
		public required IFieldDescriptor CurrentField { get; init; }
		public required IFieldDescriptor ThisField { get; init; }
		public CorLibTypeFactory CorLibTypeFactory => Type.DeclaringModule!.CorLibTypeFactory;
		public IMethodDescriptor TupleConstructor { get; }
		public void EmitReturnTrue()
		{
			Processor.Add(CilOpCodes.Ldc_I4_1);
			Processor.Add(CilOpCodes.Ret);
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass103_FillDependencyMethods.DictionaryNodeHelper.cs`:

```cs
using AssetRipper.AssemblyDumper.AST;

namespace AssetRipper.AssemblyDumper.Passes;

public static partial class Pass103_FillDependencyMethods
{
	private static class DictionaryNodeHelper
	{
		public static void Apply(DictionaryNode node, DependencyMethodContext context, ParentContext parentContext)
		{
			FieldDefinition stateField = context.Type.AddField(NodeHelper.GetStateFieldName(node), context.CorLibTypeFactory.Int32, visibility: Visibility.Private);

			CilInstructionLabel gotoNextCaseLabel = new();
			CilInstructionLabel endLabel = new();

			//Store list in a local variable
			CilLocalVariable local = context.Processor.AddLocalVariable(node.TypeSignature);
			parentContext.EmitLoad(context);
			context.Processor.Add(CilOpCodes.Stloc, local);

			context.Processor.Add(CilOpCodes.Ldarg_0);
			context.Processor.Add(CilOpCodes.Ldfld, stateField);
			context.Processor.Add(CilOpCodes.Ldloc, local);
			context.Processor.Add(CilOpCodes.Callvirt, node.GetCount);
			context.Processor.Add(CilOpCodes.Bge, gotoNextCaseLabel);

			NodeHelper.Apply(node.Child, context, new ParentContext()
			{
				EmitLoad = c =>
				{
					context.Processor.Add(CilOpCodes.Ldloc, local);
					c.Processor.Add(CilOpCodes.Ldarg_0);
					c.Processor.Add(CilOpCodes.Ldfld, stateField);
					context.Processor.Add(CilOpCodes.Callvirt, node.GetPair);
				},
				EmitIncrementStateAndGotoNextCase = c =>
				{
					c.Processor.Add(CilOpCodes.Ldarg_0);
					c.Processor.Add(CilOpCodes.Ldarg_0);
					c.Processor.Add(CilOpCodes.Ldfld, stateField);
					c.Processor.Add(CilOpCodes.Ldc_I4_1);
					c.Processor.Add(CilOpCodes.Add);
					c.Processor.Add(CilOpCodes.Stfld, stateField);
					parentContext.EmitIncrementStateAndGotoNextCase(c);
				},
				EmitIncrementStateAndReturnTrue = c =>
				{
					c.Processor.Add(CilOpCodes.Ldarg_0);
					c.Processor.Add(CilOpCodes.Ldarg_0);
					c.Processor.Add(CilOpCodes.Ldfld, stateField);
					c.Processor.Add(CilOpCodes.Ldc_I4_1);
					c.Processor.Add(CilOpCodes.Add);
					c.Processor.Add(CilOpCodes.Stfld, stateField);
					c.EmitReturnTrue();
				},
			});
			context.Processor.Add(CilOpCodes.Br, endLabel);

			gotoNextCaseLabel.Instruction = context.Processor.Add(CilOpCodes.Nop);
			parentContext.EmitIncrementStateAndGotoNextCase(context);

			endLabel.Instruction = context.Processor.Add(CilOpCodes.Nop);
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass103_FillDependencyMethods.ListNodeHelper.cs`:

```cs
using AssetRipper.AssemblyDumper.AST;

namespace AssetRipper.AssemblyDumper.Passes;

public static partial class Pass103_FillDependencyMethods
{
	private static class ListNodeHelper
	{
		public static void Apply(ListNode node, DependencyMethodContext context, ParentContext parentContext)
		{
			FieldDefinition stateField = context.Type.AddField(NodeHelper.GetStateFieldName(node), context.CorLibTypeFactory.Int32, visibility: Visibility.Private);

			CilInstructionLabel gotoNextCaseLabel = new();
			CilInstructionLabel endLabel = new();

			//Store list in a local variable
			CilLocalVariable local = context.Processor.AddLocalVariable(node.TypeSignature);
			parentContext.EmitLoad(context);
			context.Processor.Add(CilOpCodes.Stloc, local);

			context.Processor.Add(CilOpCodes.Ldarg_0);
			context.Processor.Add(CilOpCodes.Ldfld, stateField);
			context.Processor.Add(CilOpCodes.Ldloc, local);
			context.Processor.Add(CilOpCodes.Callvirt, node.GetCount);
			context.Processor.Add(CilOpCodes.Bge, gotoNextCaseLabel);

			NodeHelper.Apply(node.Child, context, new ParentContext()
			{
				EmitLoad = c =>
				{
					context.Processor.Add(CilOpCodes.Ldloc, local);
					c.Processor.Add(CilOpCodes.Ldarg_0);
					c.Processor.Add(CilOpCodes.Ldfld, stateField);
					context.Processor.Add(CilOpCodes.Callvirt, node.GetItem);
				},
				EmitIncrementStateAndGotoNextCase = c =>
				{
					c.Processor.Add(CilOpCodes.Ldarg_0);
					c.Processor.Add(CilOpCodes.Ldarg_0);
					c.Processor.Add(CilOpCodes.Ldfld, stateField);
					c.Processor.Add(CilOpCodes.Ldc_I4_1);
					c.Processor.Add(CilOpCodes.Add);
					c.Processor.Add(CilOpCodes.Stfld, stateField);
					parentContext.EmitIncrementStateAndGotoNextCase(c);
				},
				EmitIncrementStateAndReturnTrue = c =>
				{
					c.Processor.Add(CilOpCodes.Ldarg_0);
					c.Processor.Add(CilOpCodes.Ldarg_0);
					c.Processor.Add(CilOpCodes.Ldfld, stateField);
					c.Processor.Add(CilOpCodes.Ldc_I4_1);
					c.Processor.Add(CilOpCodes.Add);
					c.Processor.Add(CilOpCodes.Stfld, stateField);
					c.EmitReturnTrue();
				},
			});
			context.Processor.Add(CilOpCodes.Br, endLabel);

			gotoNextCaseLabel.Instruction = context.Processor.Add(CilOpCodes.Nop);
			parentContext.EmitIncrementStateAndGotoNextCase(context);

			endLabel.Instruction = context.Processor.Add(CilOpCodes.Nop);
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass103_FillDependencyMethods.NodeHelper.cs`:

```cs
using AssetRipper.AssemblyDumper.AST;
using System.Text;
using System.Text.RegularExpressions;

namespace AssetRipper.AssemblyDumper.Passes;

public static partial class Pass103_FillDependencyMethods
{
	private static partial class NodeHelper
	{
		private static string GetPathContent(Node node) => node switch
		{
			FieldNode fieldNode => fieldNode.Field.Name ?? "",
			ListNode or DictionaryNode => "[]",
			KeyNode => ".Key",
			ValueNode => ".Value",
			_ => "",
		};

		private static char GetStateFieldTypeCharacter(Node node) => node switch
		{
			TypeNode => 'T',
			ListNode => 'L',
			DictionaryNode => 'D',
			PairNode => 'P',
			_ => 'U',
		};

		public static void Apply(Node node, DependencyMethodContext context, ParentContext parentContext)
		{
			switch (node)
			{
				case TypeNode typeNode:
					TypeNodeHelper.Apply(typeNode, context, parentContext);
					break;
				case FieldNode fieldNode:
					Apply(fieldNode.Child, context, parentContext);
					break;
				case ListNode listNode:
					ListNodeHelper.Apply(listNode, context, parentContext);
					break;
				case DictionaryNode dictionaryNode:
					DictionaryNodeHelper.Apply(dictionaryNode, context, parentContext);
					break;
				case KeyNode keyNode:
					Apply(keyNode.Child, context, parentContext);
					break;
				case ValueNode valueNode:
					Apply(valueNode.Child, context, parentContext);
					break;
				case PPtrNode pptrNode:
					PPtrNodeHelper.Apply(pptrNode, context, parentContext);
					break;
				case PairNode pairNode:
					PairNodeHelper.Apply(pairNode, context, parentContext);
					break;
				default:
					throw new NotSupportedException(node.GetType().Name);
			}
		}

		public static string GetFullPath(Node node)
		{
			if (node.Parent is null)
			{
				return GetPathContent(node);
			}

			StringBuilder sb = new();
			Node? current = node;
			while (current != null)
			{
				string content = GetPathContent(current);
				for (int i = content.Length - 1; i >= 0; i--)
				{
					sb.Append(content[i]);
				}
				if (current is FieldNode)
				{
					sb.Append('.');
				}
				current = current.Parent;
			}
			if (sb.Length > 0 && sb[^1] == '.')
			{
				sb.Remove(sb.Length - 1, 1);
			}

			ReverseCharacterOrder(sb);

			return sb.ToString();
		}

		private static void ReverseCharacterOrder(StringBuilder sb)
		{
			int midpoint = sb.Length / 2;
			int lastIndex = sb.Length - 1;
			for (int i = 0; i < midpoint; i++)
			{
				char first = sb[i];
				char second = sb[lastIndex - i];
				sb[i] = second;
				sb[lastIndex - i] = first;
			}
		}

		/// <summary>
		/// The name of the field that stores the state of this node, if it has one.
		/// </summary>
		public static string GetStateFieldName(Node node)
		{
			return $"{InvalidMethodCharacters().Replace(GetFullPath(node), "_")}_state{GetStateFieldTypeCharacter(node)}";
		}

		[GeneratedRegex(@"[\[\].]")]
		private static partial Regex InvalidMethodCharacters();
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass103_FillDependencyMethods.PPtrNodeHelper.cs`:

```cs
using AssetRipper.AssemblyDumper.AST;

namespace AssetRipper.AssemblyDumper.Passes;

public static partial class Pass103_FillDependencyMethods
{
	private static class PPtrNodeHelper
	{
		public static void Apply(PPtrNode node, DependencyMethodContext context, ParentContext parentContext)
		{
			IMethodDescriptor conversionMethod = node.ClassInstance.Type.Methods.Single(m => m.Name == "op_Implicit" && m.Signature?.ReturnType?.Name == "PPtr");
			context.Processor.Add(CilOpCodes.Ldarg_0);
			context.Processor.Add(CilOpCodes.Ldstr, NodeHelper.GetFullPath(node));
			parentContext.EmitLoad(context);
			context.Processor.Add(CilOpCodes.Call, conversionMethod);
			context.Processor.Add(CilOpCodes.Newobj, context.TupleConstructor);
			context.Processor.Add(CilOpCodes.Stfld, context.CurrentField);
			parentContext.EmitIncrementStateAndReturnTrue(context);
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass103_FillDependencyMethods.PairNodeHelper.cs`:

```cs
using AssetRipper.AssemblyDumper.AST;

namespace AssetRipper.AssemblyDumper.Passes;

public static partial class Pass103_FillDependencyMethods
{
	private static class PairNodeHelper
	{
		public static void Apply(PairNode node, DependencyMethodContext context, ParentContext parentContext)
		{
			if (node.Key.AnyPPtrs)
			{
				if (node.Value.AnyPPtrs)
				{
					FieldDefinition stateField = context.Type.AddField(NodeHelper.GetStateFieldName(node), context.CorLibTypeFactory.Boolean, visibility: Visibility.Private);
					CilInstructionLabel valueLabel = new();
					CilInstructionLabel endLabel = new();

					context.Processor.Add(CilOpCodes.Ldarg_0);
					context.Processor.Add(CilOpCodes.Ldfld, stateField);
					context.Processor.Add(CilOpCodes.Brtrue, valueLabel);

					NodeHelper.Apply(node.Key, context, new ParentContext()
					{
						EmitLoad = c =>
						{
							parentContext.EmitLoad(c);
							c.Processor.Add(CilOpCodes.Callvirt, node.GetKey);
						},
						EmitIncrementStateAndGotoNextCase = c =>
						{
							c.Processor.Add(CilOpCodes.Ldarg_0);
							c.Processor.Add(CilOpCodes.Ldc_I4_1);
							c.Processor.Add(CilOpCodes.Stfld, stateField);
							c.Processor.Add(CilOpCodes.Br, valueLabel);
						},
						EmitIncrementStateAndReturnTrue = c =>
						{
							c.Processor.Add(CilOpCodes.Ldarg_0);
							c.Processor.Add(CilOpCodes.Ldc_I4_1);
							c.Processor.Add(CilOpCodes.Stfld, stateField);
							c.EmitReturnTrue();
						},
					});

					valueLabel.Instruction = context.Processor.Add(CilOpCodes.Nop);
					NodeHelper.Apply(node.Value, context, new ParentContext()
					{
						EmitLoad = c =>
						{
							parentContext.EmitLoad(c);
							c.Processor.Add(CilOpCodes.Callvirt, node.GetValue);
						},
						EmitIncrementStateAndGotoNextCase = parentContext.EmitIncrementStateAndGotoNextCase,
						EmitIncrementStateAndReturnTrue = parentContext.EmitIncrementStateAndReturnTrue,
					});

					endLabel.Instruction = context.Processor.Add(CilOpCodes.Nop);
				}
				else
				{
					NodeHelper.Apply(node.Key, context, new ParentContext()
					{
						EmitLoad = c =>
						{
							parentContext.EmitLoad(c);
							c.Processor.Add(CilOpCodes.Callvirt, node.GetKey);
						},
						EmitIncrementStateAndGotoNextCase = parentContext.EmitIncrementStateAndGotoNextCase,
						EmitIncrementStateAndReturnTrue = parentContext.EmitIncrementStateAndReturnTrue,
					});
				}
			}
			else if (node.Value.AnyPPtrs)
			{
				NodeHelper.Apply(node.Value, context, new ParentContext()
				{
					EmitLoad = c =>
					{
						parentContext.EmitLoad(c);
						c.Processor.Add(CilOpCodes.Callvirt, node.GetValue);
					},
					EmitIncrementStateAndGotoNextCase = parentContext.EmitIncrementStateAndGotoNextCase,
					EmitIncrementStateAndReturnTrue = parentContext.EmitIncrementStateAndReturnTrue,
				});
			}
			else
			{
				throw new InvalidOperationException("Neither Key nor Value have any PPtrs");
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass103_FillDependencyMethods.ParentContext.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Passes;

public static partial class Pass103_FillDependencyMethods
{
	private sealed class ParentContext
	{
		public required Action<DependencyMethodContext> EmitLoad { get; init; }
		public required Action<DependencyMethodContext> EmitIncrementStateAndGotoNextCase { get; init; }
		public required Action<DependencyMethodContext> EmitIncrementStateAndReturnTrue { get; init; }
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass103_FillDependencyMethods.TypeNodeHelper.cs`:

```cs
using AssetRipper.AssemblyDumper.AST;

namespace AssetRipper.AssemblyDumper.Passes;

public static partial class Pass103_FillDependencyMethods
{
	private static class TypeNodeHelper
	{
		public static void ApplyAsRoot(TypeNode node, DependencyMethodContext context)
		{
			if (node.Parent is not null)
			{
				throw new InvalidOperationException("This node is not a root node");
			}
			Apply(node, context, new ParentContext()
			{
				EmitLoad = c =>
				{
					c.Processor.Add(CilOpCodes.Ldarg_0);
					c.Processor.Add(CilOpCodes.Ldfld, c.ThisField);
				},
				EmitIncrementStateAndGotoNextCase = c =>
				{
					//This is the root node, so it has no parent to increment the state of.
					c.Processor.Add(CilOpCodes.Ldc_I4_0);
					c.Processor.Add(CilOpCodes.Ret);
				},
				EmitIncrementStateAndReturnTrue = c =>
				{
					c.EmitReturnTrue();
				},
			});
		}

		public static void Apply(TypeNode node, DependencyMethodContext context, ParentContext parentContext)
		{
			List<FieldNode> children = node.Children.Where(c => c.AnyPPtrs).ToList();
			if (children.Count == 1)
			{
				FieldNode child = children[0];
				NodeHelper.Apply(child, context, new ParentContext()
				{
					EmitLoad = c =>
					{
						parentContext.EmitLoad(c);
						c.Processor.Add(CilOpCodes.Ldfld, child.Field);
					},
					EmitIncrementStateAndGotoNextCase = parentContext.EmitIncrementStateAndGotoNextCase,
					EmitIncrementStateAndReturnTrue = parentContext.EmitIncrementStateAndReturnTrue,
				});
				return;
			}

			FieldDefinition stateField = context.Type.AddField(NodeHelper.GetStateFieldName(node), context.CorLibTypeFactory.Int32, visibility: Visibility.Private);
			CilInstructionLabel[] cases = new CilInstructionLabel[children.Count];
			for (int i = 0; i < cases.Length; i++)
			{
				cases[i] = new();
			}
			CilInstructionLabel defaultCase = new();
			CilInstructionLabel endLabel = new();

			context.Processor.Add(CilOpCodes.Ldarg_0);
			context.Processor.Add(CilOpCodes.Ldfld, stateField);
			context.Processor.Add(CilOpCodes.Switch, cases);
			context.Processor.Add(CilOpCodes.Br, defaultCase);
			for (int i = 0; i < cases.Length; i++)
			{
				FieldNode child = children[i];
				cases[i].Instruction = context.Processor.Add(CilOpCodes.Nop);
				NodeHelper.Apply(children[i], context, new ParentContext()
				{
					EmitLoad = c =>
					{
						parentContext.EmitLoad(c);
						c.Processor.Add(CilOpCodes.Ldfld, child.Field);
					},
					EmitIncrementStateAndGotoNextCase = c =>
					{
						c.Processor.Add(CilOpCodes.Ldarg_0);
						c.Processor.Add(CilOpCodes.Ldc_I4, i + 1);
						c.Processor.Add(CilOpCodes.Stfld, stateField);
						if (i + 1 < cases.Length)
						{
							c.Processor.Add(CilOpCodes.Br, cases[i + 1]);
						}
						else
						{
							c.Processor.Add(CilOpCodes.Br, defaultCase);
						}
					},
					EmitIncrementStateAndReturnTrue = c =>
					{
						c.Processor.Add(CilOpCodes.Ldarg_0);
						c.Processor.Add(CilOpCodes.Ldc_I4, i + 1);
						c.Processor.Add(CilOpCodes.Stfld, stateField);
						if (i + 1 < cases.Length)
						{
							c.EmitReturnTrue();
						}
						else
						{
							parentContext.EmitIncrementStateAndReturnTrue(c);
						}
					},
				});
				context.Processor.Add(CilOpCodes.Br, endLabel);
			}
			defaultCase.Instruction = context.Processor.Add(CilOpCodes.Nop);
			parentContext.EmitIncrementStateAndGotoNextCase(context);
			endLabel.Instruction = context.Processor.Add(CilOpCodes.Nop);
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass103_FillDependencyMethods.cs`:

```cs
using AssetRipper.AssemblyDumper.AST;
using AssetRipper.AssemblyDumper.InjectedTypes;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using System.Collections;

namespace AssetRipper.AssemblyDumper.Passes;

public static partial class Pass103_FillDependencyMethods
{
	public static void DoPass()
	{
		TypeDefinition injectedBaseType = SharedState.Instance.InjectHelperType(typeof(FetchDependenciesEnumerableBase));
		FieldDefinition currentField = injectedBaseType.Fields.First(t => t.Name == "_current");
		MethodDefinition baseConstructor = injectedBaseType.GetDefaultConstructor();

		ITypeDefOrRef commonPPtrTypeRef = SharedState.Instance.Importer.ImportType(typeof(PPtr));
		ITypeDefOrRef ienumerableRef = SharedState.Instance.Importer.ImportType(typeof(IEnumerable<>));
		ITypeDefOrRef valueTupleRef = SharedState.Instance.Importer.ImportType(typeof(ValueTuple<,>));
		GenericInstanceTypeSignature tupleGenericInstance = valueTupleRef.MakeGenericInstanceType(SharedState.Instance.Importer.String, commonPPtrTypeRef.ToTypeSignature());
		IMethodDescriptor emptyEnumerableMethod = SharedState.Instance.Importer.ImportMethod(typeof(Enumerable), m => m.Name == nameof(Enumerable.Empty))
			.MakeGenericInstanceMethod(tupleGenericInstance);
		GenericInstanceTypeSignature returnType = ienumerableRef.MakeGenericInstanceType(tupleGenericInstance);
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				TypeNode rootNode = new(instance);

				bool anyPPtrs = rootNode.AnyPPtrs;
				if (!anyPPtrs && group is SubclassGroup)
				{
					//No need to generate a duplicate of the method in UnityAssetBase
					continue;
				}

				MethodDefinition method = instance.Type.AddMethod(nameof(UnityAssetBase.FetchDependencies), Pass063_CreateEmptyMethods.OverrideMethodAttributes, returnType);
				CilInstructionCollection instructions = method.GetInstructions();
				if (anyPPtrs)
				{
					MethodDefinition enumerableConstructor = MakeEnumerableType(injectedBaseType, currentField, baseConstructor, instance, rootNode);
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Newobj, enumerableConstructor);
					instructions.Add(CilOpCodes.Ret);
				}
				else
				{
					instructions.Add(CilOpCodes.Call, emptyEnumerableMethod);
					instructions.Add(CilOpCodes.Ret);
				}
			}
		}
	}

	private static MethodDefinition MakeEnumerableType(TypeDefinition injectedBaseType, FieldDefinition currentField, MethodDefinition baseConstructor, GeneratedClassInstance instance, TypeNode rootNode)
	{
		TypeDefinition enumerableType = new(
			null,
			"FetchDependenciesEnumerable",
			TypeAttributes.NestedPrivate | TypeAttributes.Sealed,
			injectedBaseType);
		instance.Type.NestedTypes.Add(enumerableType);

		FieldDefinition thisField = enumerableType.AddField("_this", instance.Type.ToTypeSignature(), false, Visibility.Private);
		thisField.IsInitOnly = true;

		MethodDefinition enumerableConstructor = enumerableType.AddEmptyConstructor();
		enumerableConstructor.AddParameter(instance.Type.ToTypeSignature(), "_this");
		{
			CilInstructionCollection instructions = enumerableConstructor.GetInstructions();
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Call, baseConstructor);
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.Add(CilOpCodes.Stfld, thisField);
			instructions.Add(CilOpCodes.Ret);
		}

		// CreateNew
		{
			MethodDefinition createNewMethod = enumerableType.AddMethod("CreateNew", MethodAttributes.FamilyAndAssembly | MethodAttributes.Virtual | MethodAttributes.HideBySig, enumerableType.ToTypeSignature());
			{
				CilInstructionCollection instructions = createNewMethod.GetInstructions();
				instructions.Add(CilOpCodes.Ldarg_0);
				instructions.Add(CilOpCodes.Ldfld, thisField);
				instructions.Add(CilOpCodes.Newobj, enumerableConstructor);
				instructions.Add(CilOpCodes.Ret);
			}
		}

		// MoveNext
		{
			MethodDefinition moveNextMethod = enumerableType.AddMethod(nameof(IEnumerator.MoveNext), MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig, SharedState.Instance.Importer.Boolean);
			DependencyMethodContext context = new()
			{
				Processor = moveNextMethod.GetInstructions(),
				Type = enumerableType,
				CurrentField = currentField,
				ThisField = thisField,
			};
			TypeNodeHelper.ApplyAsRoot(rootNode, context);
			context.Processor.OptimizeMacros();
		}

		return enumerableConstructor;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass104_ResetMethods.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass104_ResetMethods
{
#nullable disable
	private static IMethodDefOrRef emptyString;
#nullable enable
	public static void DoPass()
	{
		emptyString = SharedState.Instance.Importer.ImportMethod<Utf8String>(method => method.Name == $"get_{nameof(Utf8String.Empty)}");
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				MethodDefinition method = instance.Type.GetMethodByName(nameof(UnityAssetBase.Reset));
				CilInstructionCollection instructions = method.GetInstructions();
				instructions.FillProcessor(instance);
			}
		}
	}

	private static void FillProcessor(this CilInstructionCollection instructions, GeneratedClassInstance instance)
	{
		foreach (ClassProperty classProperty in instance.Properties)
		{
			if (classProperty.BackingField is FieldDefinition field)
			{
				TypeSignature fieldTypeSignature = field.Signature!.FieldType;
				if (fieldTypeSignature is CorLibTypeSignature corLibTypeSignature)
				{
					instructions.Add(CilOpCodes.Ldarg_0);
					ElementType elementType = corLibTypeSignature.ElementType;
					LoadDefaultPrimitiveValue(instructions, elementType);
					instructions.Add(CilOpCodes.Stfld, field);
				}
				else if (fieldTypeSignature is TypeDefOrRefSignature typeDefOrRefSignature)
				{
					if (typeDefOrRefSignature is { Namespace: "AssetRipper.Primitives", Name: nameof(Utf8String) })
					{
						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Call, emptyString);
						instructions.Add(CilOpCodes.Stfld, field);
					}
					else
					{
						TypeDefinition fieldType = (TypeDefinition)typeDefOrRefSignature.Type;

						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Ldfld, field);
						instructions.Add(CilOpCodes.Callvirt, fieldType.GetMethodByName(nameof(UnityAssetBase.Reset)));
					}
				}
				else if (fieldTypeSignature is SzArrayTypeSignature arrayTypeSignature)
				{
					MethodSpecification emptyArray = MakeEmptyArrayMethod(arrayTypeSignature);
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Call, emptyArray);
					instructions.Add(CilOpCodes.Stfld, field);
				}
				else
				{
					GenericInstanceTypeSignature genericSignature = (GenericInstanceTypeSignature)fieldTypeSignature;
					if (genericSignature.GenericType.Name == $"{nameof(AssetDictionary<,>)}`2")
					{
						IMethodDefOrRef clearMethod = MakeDictionaryClearMethod(genericSignature);
						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Ldfld, field);
						instructions.Add(CilOpCodes.Call, clearMethod);
					}
					else if (genericSignature.GenericType.Name == $"{nameof(AssetList<>)}`1")
					{
						IMethodDefOrRef clearMethod = MakeListClearMethod(genericSignature);
						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Ldfld, field);
						instructions.Add(CilOpCodes.Call, clearMethod);
					}
					else if (genericSignature.GenericType.Name == $"{nameof(AssetPair<,>)}`2")
					{
						TypeSignature keySignature = genericSignature.TypeArguments[0];
						if (keySignature is CorLibTypeSignature keyCorLibTypeSignature)
						{
							IMethodDefOrRef setKeyMethod = MakeSetKeyMethod(genericSignature);
							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldfld, field);
							ElementType elementType = keyCorLibTypeSignature.ElementType;
							LoadDefaultPrimitiveValue(instructions, elementType);
							instructions.Add(CilOpCodes.Call, setKeyMethod);
						}
						else if (keySignature is TypeDefOrRefSignature keyTypeDefOrRefSignature)
						{
							TypeDefinition keyType = (TypeDefinition)keyTypeDefOrRefSignature.Type;

							IMethodDefOrRef getKeyMethod = MakeGetKeyMethod(genericSignature);
							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldfld, field);
							instructions.Add(CilOpCodes.Call, getKeyMethod);
							instructions.Add(CilOpCodes.Callvirt, keyType.GetMethodByName(nameof(UnityAssetBase.Reset)));
						}
						else
						{
							throw new NotSupportedException();
						}

						TypeSignature valueSignature = genericSignature.TypeArguments[1];
						if (valueSignature is CorLibTypeSignature valueCorLibTypeSignature)
						{
							IMethodDefOrRef setValueMethod = MakeSetValueMethod(genericSignature);
							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldfld, field);
							ElementType elementType = valueCorLibTypeSignature.ElementType;
							LoadDefaultPrimitiveValue(instructions, elementType);
							instructions.Add(CilOpCodes.Call, setValueMethod);
						}
						else if (valueSignature is TypeDefOrRefSignature valueTypeDefOrRefSignature)
						{
							TypeDefinition valueType = (TypeDefinition)valueTypeDefOrRefSignature.Type;

							IMethodDefOrRef getValueMethod = MakeGetValueMethod(genericSignature);
							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldfld, field);
							instructions.Add(CilOpCodes.Call, getValueMethod);
							instructions.Add(CilOpCodes.Callvirt, valueType.GetMethodByName(nameof(UnityAssetBase.Reset)));
						}
						else
						{
							throw new NotSupportedException();
						}
					}
					else
					{
						throw new NotSupportedException();
					}
				}
			}
		}
		instructions.Add(CilOpCodes.Ret);
	}

	private static IMethodDefOrRef MakeDictionaryClearMethod(GenericInstanceTypeSignature genericSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericSignature,
			SharedState.Instance.Importer.ImportMethod(typeof(AssetDictionary<,>),
				m => m.Name == nameof(AssetDictionary<,>.Clear)));
	}

	private static IMethodDefOrRef MakeListClearMethod(GenericInstanceTypeSignature genericSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericSignature,
			SharedState.Instance.Importer.ImportMethod(typeof(AssetList<>),
				m => m.Name == nameof(AssetList<>.Clear)));
	}

	private static IMethodDefOrRef MakeGetKeyMethod(GenericInstanceTypeSignature genericSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericSignature,
			SharedState.Instance.Importer.ImportMethod(typeof(AssetPair<,>),
				m => m.Name == $"get_{nameof(AssetPair<,>.Key)}"));
	}

	private static IMethodDefOrRef MakeSetKeyMethod(GenericInstanceTypeSignature genericSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericSignature,
			SharedState.Instance.Importer.ImportMethod(typeof(AssetPair<,>),
				m => m.Name == $"set_{nameof(AssetPair<,>.Key)}"));
	}

	private static IMethodDefOrRef MakeGetValueMethod(GenericInstanceTypeSignature genericSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericSignature,
			SharedState.Instance.Importer.ImportMethod(typeof(AssetPair<,>),
				m => m.Name == $"get_{nameof(AssetPair<,>.Value)}"));
	}

	private static IMethodDefOrRef MakeSetValueMethod(GenericInstanceTypeSignature genericSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			genericSignature,
			SharedState.Instance.Importer.ImportMethod(typeof(AssetPair<,>),
				m => m.Name == $"set_{nameof(AssetPair<,>.Value)}"));
	}

	private static MethodSpecification MakeEmptyArrayMethod(SzArrayTypeSignature arrayTypeSignature)
	{
		TypeSignature elementType = arrayTypeSignature.BaseType;
		MethodSpecification emptyArray = SharedState.Instance.Importer
			.ImportMethod(typeof(Array), m => m.Name == nameof(Array.Empty))
			.MakeGenericInstanceMethod(elementType);
		return emptyArray;
	}

	private static void LoadDefaultPrimitiveValue(CilInstructionCollection instructions, ElementType elementType)
	{
		switch (elementType)
		{
			case ElementType.String:
				throw new NotSupportedException();
			case ElementType.R4:
				instructions.Add(CilOpCodes.Ldc_R4, 0f);
				break;
			case ElementType.R8:
				instructions.Add(CilOpCodes.Ldc_R8, 0d);
				break;
			case ElementType.I8 or ElementType.U8:
				instructions.Add(CilOpCodes.Ldc_I4_0);
				instructions.Add(CilOpCodes.Conv_I8);
				break;
			default:
				instructions.Add(CilOpCodes.Ldc_I4_0);
				break;
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass105_CopyValuesMethods.CopyMethodType.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Passes;

internal static partial class Pass105_CopyValuesMethods
{
	[Flags]
	private enum CopyMethodType
	{
		None = 0,
		Callvirt = 1,
		HasConverter = 2,
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass105_CopyValuesMethods.cs`:

```cs
using AssetRipper.AssemblyDumper.InjectedTypes;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Passes;

internal static partial class Pass105_CopyValuesMethods
{
	private const string CopyValuesName = nameof(IUnityAssetBase.CopyValues);
	private const string DeepCloneName = "DeepClone";
	private static readonly Dictionary<TypeSignatureStruct, (IMethodDescriptor, CopyMethodType)> singleTypeDictionary = new();
	private static readonly Dictionary<(TypeSignatureStruct, TypeSignatureStruct), (IMethodDescriptor, CopyMethodType)> doubleTypeDictionary = new();
	private static readonly HashSet<ClassGroupBase> processedGroups = new();

#nullable disable
	private static TypeSignature pptrCommonType;
	private static IMethodDefOrRef pptrCommonGetFileIDMethod;
	private static IMethodDefOrRef pptrCommonGetPathIDMethod;

	private static IMethodDefOrRef ipptrGetFileIDMethod;
	private static IMethodDefOrRef ipptrGetPathIDMethod;

	private static ITypeDefOrRef pptrConverterType;
	private static IMethodDefOrRef pptrConverterGetSourceCollectionMethod;
	private static IMethodDefOrRef pptrConverterGetTargetCollectionMethod;

	private static IMethodDefOrRef utf8StringGetEmpty;

	private static TypeDefinition helperType;
	private static MethodDefinition duplicateArrayMethod;
	private static MethodDefinition duplicateArrayArrayMethod;
	private static MethodDefinition copyCapacityFromDictionary;
	private static MethodDefinition copyCapacityFromList;
	private static IMethodDefOrRef pptrConvertMethod;

	private static ITypeDefOrRef accessPairBase;
	private static IMethodDefOrRef accessPairBaseGetKey;
	private static IMethodDefOrRef accessPairBaseSetKey;
	private static IMethodDefOrRef accessPairBaseGetValue;
	private static IMethodDefOrRef accessPairBaseSetValue;

	private static ITypeDefOrRef accessListBase;
	private static IMethodDefOrRef accessListBaseGetCount;
	private static IMethodDefOrRef accessListBaseGetItem;
	private static IMethodDefOrRef accessListBaseSetItem;

	private static ITypeDefOrRef accessDictionaryBase;
	private static IMethodDefOrRef accessDictionaryBaseGetCount;
	private static IMethodDefOrRef accessDictionaryBaseGetPair;

	private static ITypeDefOrRef assetList;
	private static IMethodDefOrRef assetListSetItem;

	private static ITypeDefOrRef assetDictionary;
	private static IMethodDefOrRef assetDictionaryGetPair;

	private static ITypeDefOrRef assetPair;
#nullable enable

	public static void DoPass()
	{
		pptrCommonType = SharedState.Instance.Importer.ImportType<PPtr>().ToTypeSignature();
		pptrCommonGetFileIDMethod = SharedState.Instance.Importer.ImportMethod<PPtr>(m => m.Name == $"get_{nameof(PPtr.FileID)}");
		pptrCommonGetPathIDMethod = SharedState.Instance.Importer.ImportMethod<PPtr>(m => m.Name == $"get_{nameof(PPtr.PathID)}");

		ipptrGetFileIDMethod = SharedState.Instance.Importer.ImportMethod<IPPtr>(m => m.Name == $"get_{nameof(IPPtr.FileID)}");
		ipptrGetPathIDMethod = SharedState.Instance.Importer.ImportMethod<IPPtr>(m => m.Name == $"get_{nameof(IPPtr.PathID)}");

		utf8StringGetEmpty = SharedState.Instance.Importer.ImportMethod<Utf8String>(m => m.Name == "get_" + nameof(Utf8String.Empty));

		pptrConverterType = SharedState.Instance.Importer.ImportType<PPtrConverter>();
		pptrConverterGetSourceCollectionMethod = SharedState.Instance.Importer.ImportMethod<PPtrConverter>(m => m.Name == "get_" + nameof(PPtrConverter.SourceCollection));
		pptrConverterGetTargetCollectionMethod = SharedState.Instance.Importer.ImportMethod<PPtrConverter>(m => m.Name == "get_" + nameof(PPtrConverter.TargetCollection));
		helperType = InjectHelper();

		accessPairBase = SharedState.Instance.Importer.ImportType(typeof(AccessPairBase<,>));
		accessPairBaseGetKey = SharedState.Instance.Importer.ImportMethod(typeof(AccessPairBase<,>), m => m.Name == $"get_{nameof(AccessPairBase<,>.Key)}");
		accessPairBaseSetKey = SharedState.Instance.Importer.ImportMethod(typeof(AccessPairBase<,>), m => m.Name == $"set_{nameof(AccessPairBase<,>.Key)}");
		accessPairBaseGetValue = SharedState.Instance.Importer.ImportMethod(typeof(AccessPairBase<,>), m => m.Name == $"get_{nameof(AccessPairBase<,>.Value)}");
		accessPairBaseSetValue = SharedState.Instance.Importer.ImportMethod(typeof(AccessPairBase<,>), m => m.Name == $"set_{nameof(AccessPairBase<,>.Value)}");

		accessListBase = SharedState.Instance.Importer.ImportType(typeof(AccessListBase<>));
		accessListBaseGetCount = SharedState.Instance.Importer.ImportMethod(typeof(AccessListBase<>), m => m.Name == $"get_{nameof(AccessListBase<>.Count)}");
		accessListBaseGetItem = SharedState.Instance.Importer.ImportMethod(typeof(AccessListBase<>), m => m.Name == "get_Item");

		accessDictionaryBase = SharedState.Instance.Importer.ImportType(typeof(AccessDictionaryBase<,>));
		accessDictionaryBaseGetCount = SharedState.Instance.Importer.ImportMethod(typeof(AccessDictionaryBase<,>), m => m.Name == $"get_{nameof(AccessDictionaryBase<,>.Count)}");
		accessDictionaryBaseGetPair = SharedState.Instance.Importer.ImportMethod(typeof(AccessDictionaryBase<,>), m => m.Name == nameof(AccessDictionaryBase<,>.GetPair));

		assetList = SharedState.Instance.Importer.ImportType(typeof(AssetList<>));
		assetListSetItem = SharedState.Instance.Importer.ImportMethod(typeof(AssetList<>), m => m.Name == "set_Item");

		assetDictionary = SharedState.Instance.Importer.ImportType(typeof(AssetDictionary<,>));
		assetDictionaryGetPair = SharedState.Instance.Importer.ImportMethod(typeof(AssetDictionary<,>), m => m.Name == nameof(AssetDictionary<,>.GetPair));

		assetPair = SharedState.Instance.Importer.ImportType(typeof(AssetPair<,>));

		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			EnsureGroupProcessed(group);
		}


		foreach (SubclassGroup group in SharedState.Instance.SubclassGroups.Values)
		{
			bool needsConverter = GetPrimaryCopyValuesMethod(group.Interface).Parameters.Count == 2;
			{
				MethodDefinition method = group.Interface.AddMethod(DeepCloneName, InterfaceUtils.InterfaceMethodDeclaration, group.Interface.ToTypeSignature());
				if (needsConverter)
				{
					method.AddParameter(pptrConverterType.ToTypeSignature(), "converter");
				}
			}
			foreach (TypeDefinition type in group.Types)
			{
				MethodDefinition copyValuesMethod = GetPrimaryCopyValuesMethod(type);
				MethodDefinition method = type.AddMethod(DeepCloneName, InterfaceUtils.InterfaceMethodImplementation, group.Interface.ToTypeSignature());
				CilInstructionCollection instructions = method.GetInstructions();
				instructions.Add(CilOpCodes.Newobj, type.GetDefaultConstructor());
				instructions.Add(CilOpCodes.Dup);
				instructions.Add(CilOpCodes.Ldarg_0);
				if (needsConverter)
				{
					method.AddParameter(pptrConverterType.ToTypeSignature(), "converter");
					instructions.Add(CilOpCodes.Ldarg_1);
				}
				instructions.Add(CilOpCodes.Call, copyValuesMethod);
				instructions.Add(CilOpCodes.Ret);
			}
		}


		IMethodDefOrRef pptrConverterConstructor = SharedState.Instance.Importer.ImportMethod<PPtrConverter>(m =>
		{
			return m.IsConstructor && m.Parameters.Count == 2 && m.Parameters[0].ParameterType.Name == nameof(IUnityObjectBase);
		});
		foreach (ClassGroup group in SharedState.Instance.ClassGroups.Values)
		{
			if (GetPrimaryCopyValuesMethod(group.Interface).Parameters.Count == 2)//Has converter
			{
				{
					MethodDefinition method = group.Interface.AddMethod(CopyValuesName, InterfaceUtils.InterfaceMethodDeclaration, SharedState.Instance.Importer.Void);
					method.AddParameter(group.Interface.ToTypeSignature(), "source");
				}
				foreach (TypeDefinition type in group.Types)
				{
					MethodDefinition originalCopyValuesMethod = GetPrimaryCopyValuesMethod(type);
					MethodDefinition method = type.AddMethod(CopyValuesName, InterfaceUtils.InterfaceMethodImplementation, SharedState.Instance.Importer.Void);
					method.AddParameter(group.Interface.ToTypeSignature(), "source");
					CilInstructionCollection instructions = method.GetInstructions();

					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Newobj, pptrConverterConstructor);
					instructions.Add(CilOpCodes.Call, originalCopyValuesMethod);

					instructions.Add(CilOpCodes.Ret);
				}
			}
		}

		TypeSignature unityAssetBaseInterfaceRef = SharedState.Instance.Importer.ImportTypeSignature<IUnityAssetBase>();
		Dictionary<TypeDefinition, MethodDefinition> overridenMethods = new();
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			foreach (TypeDefinition type in group.Types)
			{
				MethodDefinition copyValuesMethod = type.AddMethod(
					nameof(UnityAssetBase.CopyValues),
					Pass063_CreateEmptyMethods.OverrideMethodAttributes,
					SharedState.Instance.Importer.Void);
				copyValuesMethod.AddParameter(unityAssetBaseInterfaceRef, "source");
				copyValuesMethod.AddParameter(pptrConverterType.ToTypeSignature(), "converter");
				copyValuesMethod.AddNullableContextAttribute(NullableAnnotation.MaybeNull);
				overridenMethods.Add(type, copyValuesMethod);
			}
		}
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				MethodDefinition primaryMethod = GetPrimaryCopyValuesMethod(instance.Type);
				MethodDefinition thisMethod = overridenMethods[instance.Type];
				MethodDefinition? baseMethod = instance.Base is null ? null : overridenMethods[instance.Base.Type];
				CilInstructionCollection instructions = thisMethod.GetInstructions();

				if (group is SubclassGroup)//Optimization for subclasses since 2 null checks is unnecessary
				{
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Isinst, group.Interface);
					if (primaryMethod.Parameters.Count == 2)
					{
						instructions.Add(CilOpCodes.Ldarg_2);//Converter is needed
					}
					instructions.Add(CilOpCodes.Callvirt, primaryMethod);
					instructions.Add(CilOpCodes.Ret);
				}
				else
				{
					CilInstructionLabel returnLabel = new();
					CilInstructionLabel isNullLabel = new();
					CilLocalVariable castedArgumentLocal = instructions.AddLocalVariable(group.Interface.ToTypeSignature());

					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Isinst, group.Interface);
					instructions.Add(CilOpCodes.Stloc, castedArgumentLocal);

					instructions.Add(CilOpCodes.Ldloc, castedArgumentLocal);
					instructions.Add(CilOpCodes.Ldnull);
					instructions.Add(CilOpCodes.Cgt_Un);
					instructions.Add(CilOpCodes.Brfalse, isNullLabel);

					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Ldloc, castedArgumentLocal);
					if (primaryMethod.Parameters.Count == 2)
					{
						instructions.Add(CilOpCodes.Ldarg_2);//Converter is needed
					}
					instructions.Add(CilOpCodes.Callvirt, primaryMethod);
					instructions.Add(CilOpCodes.Br, returnLabel);

					isNullLabel.Instruction = instructions.Add(CilOpCodes.Nop);

					if (baseMethod is null)//Object
					{
						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Callvirt, instance.Type.GetMethodByName(nameof(IUnityAssetBase.Reset)));
					}
					else
					{
						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Ldarg_1);
						instructions.Add(CilOpCodes.Ldarg_2);
						instructions.Add(CilOpCodes.Call, baseMethod);
					}

					returnLabel.Instruction = instructions.Add(CilOpCodes.Ret);
				}
			}
		}

		singleTypeDictionary.Clear();
		doubleTypeDictionary.Clear();
		processedGroups.Clear();
		overridenMethods.Clear();
	}

	private static TypeDefinition InjectHelper()
	{
		TypeDefinition clonedType = SharedState.Instance.InjectHelperType(typeof(CopyValuesHelper));
		duplicateArrayMethod = clonedType.GetMethodByName(nameof(CopyValuesHelper.DuplicateArray));
		duplicateArrayArrayMethod = clonedType.GetMethodByName(nameof(CopyValuesHelper.DuplicateArrayArray));
		pptrConvertMethod = clonedType.GetMethodByName(nameof(CopyValuesHelper.ConvertPPtr));
		copyCapacityFromDictionary = clonedType.GetMethodByName(nameof(CopyValuesHelper.CopyCapacityFrom_Dictionary));
		copyCapacityFromList = clonedType.GetMethodByName(nameof(CopyValuesHelper.CopyCapacityFrom_List));
		return clonedType;
	}

	private static void EnsureGroupProcessed(ClassGroupBase group)
	{
		if (!processedGroups.Add(group))
		{
			return;
		}

		if (group.IsPPtr)
		{
			{
				MethodDefinition method = group.Interface.AddMethod(CopyValuesName, InterfaceUtils.InterfaceMethodDeclaration, SharedState.Instance.Importer.Void);
				method.AddParameter(group.Interface.ToTypeSignature(), "source");
				method.AddParameter(pptrConverterType.ToTypeSignature(), "converter");
				method.AddNullableContextAttribute(NullableAnnotation.MaybeNull);
				singleTypeDictionary.Add(group.Interface.ToTypeSignature(), (method, CopyMethodType.Callvirt | CopyMethodType.HasConverter));
			}
			foreach (TypeDefinition type in group.Types)
			{
				MethodDefinition method = type.AddMethod(CopyValuesName, InterfaceUtils.InterfaceMethodImplementation, SharedState.Instance.Importer.Void);
				method.AddParameter(group.Interface.ToTypeSignature(), "source");
				Parameter converterParam = method.AddParameter(pptrConverterType.ToTypeSignature(), "converter");
				method.AddNullableContextAttribute(NullableAnnotation.MaybeNull);
				CilInstructionCollection instructions = method.GetInstructions();
				CilInstructionLabel returnLabel = new();
				CilInstructionLabel isNullLabel = new();

				//If other is null
				instructions.Add(CilOpCodes.Ldarg_1);
				instructions.Add(CilOpCodes.Brfalse, isNullLabel);

				//Not null
				{
					//Convert PPtr
					CilLocalVariable convertedPPtr = instructions.AddLocalVariable(pptrCommonType);
					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Ldarg_2);
					instructions.Add(CilOpCodes.Call, pptrConvertMethod.MakeGenericInstanceMethod(GetPPtrTypeArgument(type, group.Interface)));
					instructions.Add(CilOpCodes.Stloc, convertedPPtr);

					//Store FileID
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Ldloca, convertedPPtr);
					instructions.Add(CilOpCodes.Call, pptrCommonGetFileIDMethod);
					instructions.Add(CilOpCodes.Stfld, type.GetFieldByName("m_FileID_"));

					//Store PathID
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Ldloca, convertedPPtr);
					instructions.Add(CilOpCodes.Call, pptrCommonGetPathIDMethod);
					FieldDefinition pathIDField = type.GetFieldByName("m_PathID_");
					if (pathIDField.Signature!.FieldType is CorLibTypeSignature { ElementType: ElementType.I4 })
					{
						instructions.Add(CilOpCodes.Conv_Ovf_I4);//Convert I8 to I4
					}
					instructions.Add(CilOpCodes.Stfld, pathIDField);

					instructions.Add(CilOpCodes.Br, returnLabel);
				}

				isNullLabel.Instruction = instructions.Add(CilOpCodes.Nop);
				instructions.Add(CilOpCodes.Ldarg_0);
				instructions.Add(CilOpCodes.Callvirt, type.GetMethodByName(nameof(IUnityAssetBase.Reset)));

				returnLabel.Instruction = instructions.Add(CilOpCodes.Ret);
				singleTypeDictionary.Add(type.ToTypeSignature(), (method, CopyMethodType.HasConverter));
			}
		}
		else
		{
			bool needsConverter = false;
			bool needsNullCheck = group is SubclassGroup;
			Dictionary<TypeDefinition, MethodDefinition> instanceMethods = new();
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				MethodDefinition method = instance.Type.AddMethod(CopyValuesName, InterfaceUtils.InterfaceMethodImplementation, SharedState.Instance.Importer.Void);
				method.AddParameter(group.Interface.ToTypeSignature(), "source");
				CilInstructionCollection instructions = method.GetInstructions();
				CilInstructionLabel returnLabel = new();
				CilInstructionLabel isNullLabel = new();
				if (needsNullCheck)
				{
					method.AddNullableContextAttribute(NullableAnnotation.MaybeNull);
					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Ldnull);
					instructions.Add(CilOpCodes.Cgt_Un);
					instructions.Add(CilOpCodes.Brfalse, isNullLabel);
				}

				foreach (ClassProperty classProperty in instance.Properties)
				{
					if (classProperty.BackingField is not null)
					{
						TypeSignature fieldTypeSignature = classProperty.BackingField.Signature!.FieldType;
						if (fieldTypeSignature is CorLibTypeSignature)
						{
							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldarg_1);
							instructions.Add(CilOpCodes.Callvirt, classProperty.Base.Definition.GetMethod!);
							instructions.Add(CilOpCodes.Stfld, classProperty.BackingField);
						}
						else if (fieldTypeSignature is TypeDefOrRefSignature { Namespace: "AssetRipper.Primitives", Name: nameof(Utf8String) })
						{
							if (classProperty.Base.AbsentRange.IsEmpty())
							{
								// m_Field = source.Property;
								instructions.Add(CilOpCodes.Ldarg_0);
								instructions.Add(CilOpCodes.Ldarg_1);
								instructions.Add(CilOpCodes.Callvirt, classProperty.Base.Definition.GetMethod!);
								instructions.Add(CilOpCodes.Stfld, classProperty.BackingField);
							}
							else
							{
								// m_Field = source.Property ?? Utf8String.Empty;
								CilInstructionLabel stfldLabel = new();
								instructions.Add(CilOpCodes.Ldarg_0);
								instructions.Add(CilOpCodes.Ldarg_1);
								instructions.Add(CilOpCodes.Callvirt, classProperty.Base.Definition.GetMethod!);
								instructions.Add(CilOpCodes.Dup);
								instructions.Add(CilOpCodes.Brtrue, stfldLabel);
								instructions.Add(CilOpCodes.Pop);
								instructions.Add(CilOpCodes.Call, utf8StringGetEmpty);
								stfldLabel.Instruction = instructions.Add(CilOpCodes.Stfld, classProperty.BackingField);
							}
						}
						else if (fieldTypeSignature is SzArrayTypeSignature arrayTypeSignature)
						{
							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldarg_1);
							instructions.Add(CilOpCodes.Callvirt, classProperty.Base.Definition.GetMethod!);
							instructions.Add(CilOpCodes.Call, MakeDuplicateArrayMethod(arrayTypeSignature));
							instructions.Add(CilOpCodes.Stfld, classProperty.BackingField);
						}
						else
						{
							(IMethodDescriptor fieldCopyMethod, CopyMethodType copyMethodType) = GetOrMakeMethod(
								fieldTypeSignature,
								classProperty.Base.Definition.Signature!.ReturnType);
							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldfld, classProperty.BackingField);
							instructions.Add(CilOpCodes.Ldarg_1);
							instructions.Add(CilOpCodes.Callvirt, classProperty.Base.Definition.GetMethod!);
							if (HasConverter(copyMethodType))
							{
								instructions.Add(CilOpCodes.Ldarg_2);
								needsConverter = true;
							}
							instructions.Add(GetCallOpCode(copyMethodType), fieldCopyMethod);
						}
					}
				}

				if (needsNullCheck)
				{
					instructions.Add(CilOpCodes.Br, returnLabel);

					isNullLabel.Instruction = instructions.Add(CilOpCodes.Nop);
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Callvirt, instance.Type.GetMethodByName(nameof(IUnityAssetBase.Reset)));
				}

				returnLabel.Instruction = instructions.Add(CilOpCodes.Ret);
				instanceMethods.Add(instance.Type, method);
			}

			foreach ((TypeDefinition type, MethodDefinition method) in instanceMethods)
			{
				if (needsConverter)
				{
					method.AddParameter(pptrConverterType.ToTypeSignature(), "converter");
					singleTypeDictionary.Add(type.ToTypeSignature(), (method, CopyMethodType.HasConverter));
				}
				else
				{
					singleTypeDictionary.Add(type.ToTypeSignature(), (method, CopyMethodType.None));
				}
			}

			{
				MethodDefinition method = group.Interface.AddMethod(CopyValuesName, InterfaceUtils.InterfaceMethodDeclaration, SharedState.Instance.Importer.Void);
				method.AddParameter(group.Interface.ToTypeSignature(), "source");
				if (needsNullCheck)
				{
					method.AddNullableContextAttribute(NullableAnnotation.MaybeNull);
				}
				if (needsConverter)
				{
					method.AddParameter(pptrConverterType.ToTypeSignature(), "converter");
					singleTypeDictionary.Add(group.Interface.ToTypeSignature(), (method, CopyMethodType.Callvirt | CopyMethodType.HasConverter));
				}
				else
				{
					singleTypeDictionary.Add(group.Interface.ToTypeSignature(), (method, CopyMethodType.Callvirt));
				}
			}
		}
	}

	private static (IMethodDescriptor, CopyMethodType) GetOrMakeMethod(TypeSignature targetSignature, TypeSignature sourceSignature)
	{
		if (singleTypeDictionary.TryGetValue(targetSignature, out (IMethodDescriptor, CopyMethodType) pair))
		{
			return pair;
		}
		else if (doubleTypeDictionary.TryGetValue((targetSignature, sourceSignature), out pair))
		{
			return pair;
		}

		switch (targetSignature)
		{
			case TypeDefOrRefSignature typeDefOrRefSignature:
				TypeDefinition type = (TypeDefinition)typeDefOrRefSignature.Type;
				EnsureGroupProcessed(SharedState.Instance.TypesToGroups[type]);
				return singleTypeDictionary[type.ToTypeSignature()];
			case GenericInstanceTypeSignature targetGenericSignature:
				{
					bool needsConverter = false;
					GenericInstanceTypeSignature sourceGenericSignature = (GenericInstanceTypeSignature)sourceSignature;
					MethodDefinition method = helperType.AddMethod(
						MakeUniqueCopyValuesName(targetSignature, sourceSignature),
						StaticClassCreator.StaticMethodAttributes,
						SharedState.Instance.Importer.Void);
					method.AddParameter(targetSignature, "target");
					method.AddParameter(sourceSignature, "source");
					CilInstructionCollection instructions = method.GetInstructions();
					switch (targetGenericSignature.GenericType.Name?.ToString())
					{
						case $"{nameof(AssetDictionary<,>)}`2":
							{
								//Argument 0 (target) is AssetDictionary`2. Argument 1 (source) is AccessDictionaryBase`2.

								TypeSignature targetKeyTypeSignature = targetGenericSignature.TypeArguments[0];
								TypeSignature targetValueTypeSignature = targetGenericSignature.TypeArguments[1];
								TypeSignature targetPairTypeSignature = assetPair.MakeGenericInstanceType(targetKeyTypeSignature, targetValueTypeSignature);
								TypeSignature sourceKeyTypeSignature = sourceGenericSignature.TypeArguments[0];
								TypeSignature sourceValueTypeSignature = sourceGenericSignature.TypeArguments[1];
								TypeSignature sourcePairTypeSignature = accessPairBase.MakeGenericInstanceType(sourceKeyTypeSignature, sourceValueTypeSignature);

								instructions.Add(CilOpCodes.Ldarg_0);
								instructions.Add(CilOpCodes.Ldarg_1);
								instructions.Add(CilOpCodes.Call, copyCapacityFromDictionary.MakeGenericInstanceMethod(targetKeyTypeSignature, targetValueTypeSignature, sourceKeyTypeSignature, sourceValueTypeSignature));

								CilLocalVariable iLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);
								instructions.Add(CilOpCodes.Ldc_I4_0);
								instructions.Add(CilOpCodes.Stloc, iLocal);

								CilInstructionLabel conditionLabel = new();
								instructions.Add(CilOpCodes.Br, conditionLabel);

								CilInstructionLabel forStartLabel = new();
								forStartLabel.Instruction = instructions.Add(CilOpCodes.Nop);

								(IMethodDescriptor copyMethod, CopyMethodType copyMethodType) = GetOrMakeMethod(targetPairTypeSignature, sourcePairTypeSignature);
								instructions.Add(CilOpCodes.Ldarg_0);
								instructions.Add(CilOpCodes.Ldloc, iLocal);
								instructions.Add(CilOpCodes.Callvirt, MakeAssetDictionaryGetPairMethod(targetKeyTypeSignature, targetValueTypeSignature));
								instructions.Add(CilOpCodes.Ldarg_1);
								instructions.Add(CilOpCodes.Ldloc, iLocal);
								instructions.Add(CilOpCodes.Callvirt, MakeDictionaryGetPairMethod(sourceKeyTypeSignature, sourceValueTypeSignature));
								if (HasConverter(copyMethodType))
								{
									instructions.Add(CilOpCodes.Ldarg_2);
									needsConverter = true;
								}
								instructions.Add(GetCallOpCode(copyMethodType), copyMethod);

								instructions.Add(CilOpCodes.Ldloc, iLocal);
								instructions.Add(CilOpCodes.Ldc_I4_1);
								instructions.Add(CilOpCodes.Add);
								instructions.Add(CilOpCodes.Stloc, iLocal);

								conditionLabel.Instruction = instructions.Add(CilOpCodes.Nop);
								instructions.Add(CilOpCodes.Ldloc, iLocal);
								instructions.Add(CilOpCodes.Ldarg_0);
								instructions.Add(CilOpCodes.Callvirt, MakeDictionaryGetCountMethod(targetKeyTypeSignature, targetValueTypeSignature));
								instructions.Add(CilOpCodes.Clt);
								instructions.Add(CilOpCodes.Brtrue, forStartLabel);

								instructions.Add(CilOpCodes.Ret);
							}
							break;
						case $"{nameof(AssetList<>)}`1":
							{
								//Argument 0 (target) is AssetList`1. Argument 1 (source) is AccessListBase`1.

								TypeSignature targetElementTypeSignature = targetGenericSignature.TypeArguments[0];
								TypeSignature sourceElementTypeSignature = sourceGenericSignature.TypeArguments[0];

								instructions.Add(CilOpCodes.Ldarg_0);
								instructions.Add(CilOpCodes.Ldarg_1);
								instructions.Add(CilOpCodes.Call, copyCapacityFromList.MakeGenericInstanceMethod(targetElementTypeSignature, sourceElementTypeSignature));

								CilLocalVariable iLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);
								instructions.Add(CilOpCodes.Ldc_I4_0);
								instructions.Add(CilOpCodes.Stloc, iLocal);

								CilInstructionLabel conditionLabel = new();
								instructions.Add(CilOpCodes.Br, conditionLabel);

								CilInstructionLabel forStartLabel = new();
								forStartLabel.Instruction = instructions.Add(CilOpCodes.Nop);

								if (targetElementTypeSignature is CorLibTypeSignature or TypeDefOrRefSignature { Namespace: "AssetRipper.Primitives", Name: nameof(Utf8String) })
								{
									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Ldloc, iLocal);
									instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Ldloc, iLocal);
									instructions.Add(CilOpCodes.Callvirt, MakeListGetItemMethod(sourceElementTypeSignature));
									instructions.Add(CilOpCodes.Callvirt, MakeAssetListSetItemMethod(targetElementTypeSignature));
								}
								else if (targetElementTypeSignature is SzArrayTypeSignature keyArrayTypeSignature)
								{
									throw new NotSupportedException();
								}
								else
								{
									(IMethodDescriptor copyMethod, CopyMethodType copyMethodType) = GetOrMakeMethod(targetElementTypeSignature, sourceElementTypeSignature);

									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Ldloc, iLocal);
									instructions.Add(CilOpCodes.Callvirt, MakeListGetItemMethod(targetElementTypeSignature));
									instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Ldloc, iLocal);
									instructions.Add(CilOpCodes.Callvirt, MakeListGetItemMethod(sourceElementTypeSignature));
									if (HasConverter(copyMethodType))
									{
										instructions.Add(CilOpCodes.Ldarg_2);
										needsConverter = true;
									}
									instructions.Add(GetCallOpCode(copyMethodType), copyMethod);
								}

								instructions.Add(CilOpCodes.Ldloc, iLocal);
								instructions.Add(CilOpCodes.Ldc_I4_1);
								instructions.Add(CilOpCodes.Add);
								instructions.Add(CilOpCodes.Stloc, iLocal);

								conditionLabel.Instruction = instructions.Add(CilOpCodes.Nop);
								instructions.Add(CilOpCodes.Ldloc, iLocal);
								instructions.Add(CilOpCodes.Ldarg_0);
								instructions.Add(CilOpCodes.Callvirt, MakeListGetCountMethod(targetElementTypeSignature));
								instructions.Add(CilOpCodes.Clt);
								instructions.Add(CilOpCodes.Brtrue, forStartLabel);

								instructions.Add(CilOpCodes.Ret);
							}
							break;
						case $"{nameof(AssetPair<,>)}`2" or $"{nameof(AccessPairBase<,>)}`2":
							{
								TypeSignature targetKeyTypeSignature = targetGenericSignature.TypeArguments[0];
								TypeSignature sourceKeyTypeSignature = sourceGenericSignature.TypeArguments[0];
								TypeSignature targetValueTypeSignature = targetGenericSignature.TypeArguments[1];
								TypeSignature sourceValueTypeSignature = sourceGenericSignature.TypeArguments[1];

								if (targetKeyTypeSignature is CorLibTypeSignature)
								{
									CilInstructionLabel notNullLabel = new();
									CilInstructionLabel finishLabel = new();

									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Brtrue, notNullLabel);
									instructions.AddDefaultValue(sourceKeyTypeSignature);
									instructions.Add(CilOpCodes.Br, finishLabel);
									notNullLabel.Instruction = instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Callvirt, MakePairGetKeyMethod(sourceKeyTypeSignature, sourceValueTypeSignature));
									finishLabel.Instruction = instructions.Add(CilOpCodes.Callvirt, MakePairSetKeyMethod(targetKeyTypeSignature, targetValueTypeSignature));
								}
								else if (targetKeyTypeSignature is TypeDefOrRefSignature { Namespace: "AssetRipper.Primitives", Name: nameof(Utf8String) })
								{
									CilInstructionLabel notNullLabel = new();
									CilInstructionLabel finishLabel = new();

									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Brtrue, notNullLabel);
									instructions.Add(CilOpCodes.Call, utf8StringGetEmpty);
									instructions.Add(CilOpCodes.Br, finishLabel);
									notNullLabel.Instruction = instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Callvirt, MakePairGetKeyMethod(sourceKeyTypeSignature, sourceValueTypeSignature));
									finishLabel.Instruction = instructions.Add(CilOpCodes.Callvirt, MakePairSetKeyMethod(targetKeyTypeSignature, targetValueTypeSignature));
								}
								else if (targetKeyTypeSignature is SzArrayTypeSignature keyArrayTypeSignature)
								{
									CilInstructionLabel notNullLabel = new();
									CilInstructionLabel finishLabel = new();

									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Brtrue, notNullLabel);
									instructions.Add(CilOpCodes.Ldnull);
									instructions.Add(CilOpCodes.Br, finishLabel);
									notNullLabel.Instruction = instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Callvirt, MakePairGetKeyMethod(sourceKeyTypeSignature, sourceValueTypeSignature));
									finishLabel.Instruction = instructions.Add(CilOpCodes.Call, MakeDuplicateArrayMethod(keyArrayTypeSignature));
									instructions.Add(CilOpCodes.Callvirt, MakePairSetKeyMethod(targetKeyTypeSignature, targetValueTypeSignature));
								}
								else
								{
									CilInstructionLabel notNullLabel = new();
									CilInstructionLabel finishLabel = new();

									(IMethodDescriptor keyCopyMethod, CopyMethodType keyCopyMethodType) = GetOrMakeMethod(targetKeyTypeSignature, sourceKeyTypeSignature);
									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Callvirt, MakePairGetKeyMethod(targetKeyTypeSignature, targetValueTypeSignature));
									instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Brtrue, notNullLabel);
									instructions.Add(CilOpCodes.Ldnull);
									instructions.Add(CilOpCodes.Br, finishLabel);
									notNullLabel.Instruction = instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Callvirt, MakePairGetKeyMethod(sourceKeyTypeSignature, sourceValueTypeSignature));
									int finishIndex = instructions.Count;
									if (HasConverter(keyCopyMethodType))
									{
										instructions.Add(CilOpCodes.Ldarg_2);
										needsConverter = true;
									}
									instructions.Add(GetCallOpCode(keyCopyMethodType), keyCopyMethod);
									finishLabel.Instruction = instructions[finishIndex];
								}

								if (targetValueTypeSignature is CorLibTypeSignature)
								{
									CilInstructionLabel notNullLabel = new();
									CilInstructionLabel finishLabel = new();

									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Brtrue, notNullLabel);
									instructions.AddDefaultValue(sourceValueTypeSignature);
									instructions.Add(CilOpCodes.Br, finishLabel);
									notNullLabel.Instruction = instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Callvirt, MakePairGetValueMethod(sourceKeyTypeSignature, sourceValueTypeSignature));
									finishLabel.Instruction = instructions.Add(CilOpCodes.Callvirt, MakePairSetValueMethod(targetKeyTypeSignature, targetValueTypeSignature));
								}
								else if (targetValueTypeSignature is TypeDefOrRefSignature { Namespace: "AssetRipper.Primitives", Name: nameof(Utf8String) })
								{
									CilInstructionLabel notNullLabel = new();
									CilInstructionLabel finishLabel = new();

									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Brtrue, notNullLabel);
									instructions.Add(CilOpCodes.Call, utf8StringGetEmpty);
									instructions.Add(CilOpCodes.Br, finishLabel);
									notNullLabel.Instruction = instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Callvirt, MakePairGetValueMethod(sourceKeyTypeSignature, sourceValueTypeSignature));
									finishLabel.Instruction = instructions.Add(CilOpCodes.Callvirt, MakePairSetValueMethod(targetKeyTypeSignature, targetValueTypeSignature));
								}
								else if (targetValueTypeSignature is SzArrayTypeSignature valueArrayTypeSignature)
								{
									CilInstructionLabel notNullLabel = new();
									CilInstructionLabel finishLabel = new();

									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Brtrue, notNullLabel);
									instructions.Add(CilOpCodes.Ldnull);
									instructions.Add(CilOpCodes.Br, finishLabel);
									notNullLabel.Instruction = instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Callvirt, MakePairGetValueMethod(sourceKeyTypeSignature, sourceValueTypeSignature));
									finishLabel.Instruction = instructions.Add(CilOpCodes.Call, MakeDuplicateArrayMethod(valueArrayTypeSignature));
									instructions.Add(CilOpCodes.Callvirt, MakePairSetValueMethod(targetKeyTypeSignature, targetValueTypeSignature));
								}
								else
								{
									CilInstructionLabel notNullLabel = new();
									CilInstructionLabel finishLabel = new();

									(IMethodDescriptor valueCopyMethod, CopyMethodType valueCopyMethodType) = GetOrMakeMethod(targetValueTypeSignature, sourceValueTypeSignature);
									instructions.Add(CilOpCodes.Ldarg_0);
									instructions.Add(CilOpCodes.Callvirt, MakePairGetValueMethod(targetKeyTypeSignature, targetValueTypeSignature));
									instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Brtrue, notNullLabel);
									instructions.Add(CilOpCodes.Ldnull);
									instructions.Add(CilOpCodes.Br, finishLabel);
									notNullLabel.Instruction = instructions.Add(CilOpCodes.Ldarg_1);
									instructions.Add(CilOpCodes.Callvirt, MakePairGetValueMethod(sourceKeyTypeSignature, sourceValueTypeSignature));
									int finishIndex = instructions.Count;
									if (HasConverter(valueCopyMethodType))
									{
										instructions.Add(CilOpCodes.Ldarg_2);
										needsConverter = true;
									}
									instructions.Add(GetCallOpCode(valueCopyMethodType), valueCopyMethod);
									finishLabel.Instruction = instructions[finishIndex];
								}

								instructions.Add(CilOpCodes.Ret);
							}
							break;
						default:
							throw new NotSupportedException();
					}
					(IMethodDescriptor, CopyMethodType) result;
					if (needsConverter)
					{
						method.AddParameter(pptrConverterType.ToTypeSignature(), "converter");
						result = (method, CopyMethodType.HasConverter);
					}
					else
					{
						result = (method, CopyMethodType.None);
					}
					doubleTypeDictionary.Add((targetSignature, sourceSignature), result);
					return result;
				}
			default:
				throw new NotSupportedException();
		}
	}

	private static MethodDefinition GetPrimaryCopyValuesMethod(this TypeDefinition type)
	{
		return (MethodDefinition)singleTypeDictionary[type.ToTypeSignature()].Item1;
	}

	private static IMethodDefOrRef MakeDictionaryGetCountMethod(TypeSignature keyTypeSignature, TypeSignature valueTypeSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			accessDictionaryBase.MakeGenericInstanceType(keyTypeSignature, valueTypeSignature),
			accessDictionaryBaseGetCount);
	}

	private static IMethodDefOrRef MakeDictionaryGetPairMethod(TypeSignature keyTypeSignature, TypeSignature valueTypeSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			accessDictionaryBase.MakeGenericInstanceType(keyTypeSignature, valueTypeSignature),
			accessDictionaryBaseGetPair);
	}

	private static IMethodDefOrRef MakeAssetDictionaryGetPairMethod(TypeSignature keyTypeSignature, TypeSignature valueTypeSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			assetDictionary.MakeGenericInstanceType(keyTypeSignature, valueTypeSignature),
			assetDictionaryGetPair);
	}

	private static IMethodDefOrRef MakeListGetCountMethod(TypeSignature elementTypeSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			accessListBase.MakeGenericInstanceType(elementTypeSignature),
			accessListBaseGetCount);
	}

	private static IMethodDefOrRef MakeListGetItemMethod(TypeSignature elementTypeSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			accessListBase.MakeGenericInstanceType(elementTypeSignature),
			accessListBaseGetItem);
	}

	private static IMethodDefOrRef MakeAssetListSetItemMethod(TypeSignature elementTypeSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			assetList.MakeGenericInstanceType(elementTypeSignature),
			assetListSetItem);
	}

	private static IMethodDefOrRef MakePairGetKeyMethod(TypeSignature keyTypeSignature, TypeSignature valueTypeSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			accessPairBase.MakeGenericInstanceType(keyTypeSignature, valueTypeSignature),
			accessPairBaseGetKey);
	}

	private static IMethodDefOrRef MakePairSetKeyMethod(TypeSignature keyTypeSignature, TypeSignature valueTypeSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			accessPairBase.MakeGenericInstanceType(keyTypeSignature, valueTypeSignature),
			accessPairBaseSetKey);
	}

	private static IMethodDefOrRef MakePairGetValueMethod(TypeSignature keyTypeSignature, TypeSignature valueTypeSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			accessPairBase.MakeGenericInstanceType(keyTypeSignature, valueTypeSignature),
			accessPairBaseGetValue);
	}

	private static IMethodDefOrRef MakePairSetValueMethod(TypeSignature keyTypeSignature, TypeSignature valueTypeSignature)
	{
		return MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			accessPairBase.MakeGenericInstanceType(keyTypeSignature, valueTypeSignature),
			accessPairBaseSetValue);
	}

	private static string MakeUniqueCopyValuesName(TypeSignature target, TypeSignature source)
	{
		return $"{CopyValuesName}__{UniqueNameFactory.MakeUniqueName(target)}__{UniqueNameFactory.MakeUniqueName(source)}";
	}

	private static IMethodDescriptor MakeDuplicateArrayMethod(SzArrayTypeSignature arrayTypeSignature)
	{
		TypeSignature elementType = arrayTypeSignature.BaseType;
		if (elementType is SzArrayTypeSignature nestedArray)
		{
			Debug.Assert(nestedArray.BaseType is CorLibTypeSignature or TypeDefOrRefSignature { Namespace: "AssetRipper.Primitives", Name: nameof(Utf8String) });
			return duplicateArrayArrayMethod.MakeGenericInstanceMethod(nestedArray.BaseType);
		}
		else
		{
			Debug.Assert(elementType is CorLibTypeSignature or TypeDefOrRefSignature { Namespace: "AssetRipper.Primitives", Name: nameof(Utf8String) });
			return duplicateArrayMethod.MakeGenericInstanceMethod(elementType);
		}
	}

	private static TypeSignature GetPPtrTypeArgument(TypeDefinition type, TypeDefinition groupInterface)
	{
		return TryGetPPtrTypeArgument(type)
			?? TryGetPPtrTypeArgument(groupInterface)
			?? throw new Exception("Could not get PPtr type argument.");
	}

	private static TypeSignature? TryGetPPtrTypeArgument(TypeDefinition type)
	{
		foreach (InterfaceImplementation implem in type.Interfaces)
		{
			if (implem.Interface is TypeSpecification specification
				&& specification.Signature is GenericInstanceTypeSignature genericInstanceTypeSignature
				&& genericInstanceTypeSignature.GenericType.Name == $"{nameof(IPPtr<>)}`1")
			{
				return genericInstanceTypeSignature.TypeArguments[0];
			}
		}

		return null;
	}

	private static bool HasConverter(CopyMethodType copyMethodType)
	{
		return (copyMethodType & CopyMethodType.HasConverter) != 0;
	}

	private static CilOpCode GetCallOpCode(CopyMethodType copyMethodType)
	{
		return (copyMethodType & CopyMethodType.Callvirt) != 0 ? CilOpCodes.Callvirt : CilOpCodes.Call;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass108_WalkMethods.cs`:

```cs
using AssetRipper.AssemblyDumper.AST;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;
using AssetRipper.Assets.Traversal;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass108_WalkMethods
{
	private enum State
	{
		Release,
		Editor,
		Standard,
	}

	private static State CurrentState { get; set; } = State.Standard;

	private static string MethodName => CurrentState switch
	{
		State.Release => nameof(IUnityAssetBase.WalkRelease),
		State.Editor => nameof(IUnityAssetBase.WalkEditor),
		_ => nameof(IUnityAssetBase.WalkStandard),
	};

	private static bool IsUsable(FieldNode node) => CurrentState switch
	{
		State.Release => !node.Property.IsEditorOnly && !node.Property.IsInjected,
		State.Editor => !node.Property.IsReleaseOnly && !node.Property.IsInjected,
		_ => true,
	};

	private static List<FieldNode> ToOrderedList(this IEnumerable<FieldNode> nodes)
	{
		switch (CurrentState)
		{
			case State.Release:
				{
					List<FieldNode> list = nodes.ToList();
					if (list.Count > 0)
					{
						UniversalNode root = list[0].Property.Class.Class.ReleaseRootNode!;
						list.Sort((a, b) => root.SubNodes.IndexOf(a.Property.ReleaseNode!) - root.SubNodes.IndexOf(b.Property.ReleaseNode!));
					}
					return list;
				}
			case State.Editor:
				{
					List<FieldNode> list = nodes.ToList();
					if (list.Count > 0)
					{
						UniversalNode root = list[0].Property.Class.Class.EditorRootNode!;
						list.Sort((a, b) => root.SubNodes.IndexOf(a.Property.EditorNode!) - root.SubNodes.IndexOf(b.Property.EditorNode!));
					}
					return list;
				}
			default:
				return nodes.OrderBy(n => n.Field.Name?.Value).ToList();
		}
	}

	private static string GetName(FieldNode node) => CurrentState switch
	{
		State.Release or State.Editor => node.Property.OriginalFieldName!,
		_ => node.Field.Name!,
	};
#nullable disable
	private static TypeSignature assetWalkerType;

	private static IMethodDefOrRef enterAssetMethod;
	private static IMethodDefOrRef divideAssetMethod;
	private static IMethodDefOrRef exitAssetMethod;

	private static IMethodDefOrRef enterFieldMethod;
	private static IMethodDefOrRef exitFieldMethod;

	private static IMethodDefOrRef enterListMethod;
	private static IMethodDefOrRef divideListMethod;
	private static IMethodDefOrRef exitListMethod;

	private static IMethodDefOrRef enterDictionaryMethod;
	private static IMethodDefOrRef divideDictionaryMethod;
	private static IMethodDefOrRef exitDictionaryMethod;

	private static IMethodDefOrRef enterDictionaryPairMethod;
	private static IMethodDefOrRef divideDictionaryPairMethod;
	private static IMethodDefOrRef exitDictionaryPairMethod;

	private static IMethodDefOrRef enterPairMethod;
	private static IMethodDefOrRef dividePairMethod;
	private static IMethodDefOrRef exitPairMethod;

	private static IMethodDefOrRef visitPrimitiveMethod;
	private static IMethodDefOrRef visitPPtrMethod;

	private static TypeDefinition helperClass;
#nullable enable
	private static Dictionary<TypeSignature, IMethodDescriptor> MethodDictionary { get; } = new(SignatureComparer.Default);

	public static void DoPass()
	{
		Initialize();
		foreach (State state in (ReadOnlySpan<State>)[State.Release, State.Editor, State.Standard])
		{
			CurrentState = state;
			MethodDictionary.Clear();

			CreateEmptyMethods();

			helperClass = StaticClassCreator.CreateEmptyStaticClass(SharedState.Instance.Module, SharedState.HelpersNamespace, MethodName + "Methods");
			helperClass.IsPublic = false;

			foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
			{
				foreach (GeneratedClassInstance instance in group.Instances)
				{
					TypeNode rootNode = new(instance);

					TypeDefinition type = instance.Type;
					TypeSignature typeSignature = type.ToTypeSignature();

					CilInstructionCollection instructions = type.GetMethodByName(MethodName).GetInstructions();

					if (group.IsPPtr)
					{
						instructions.Add(CilOpCodes.Ldarg_1);
						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Callvirt, visitPPtrMethod.MakeGenericInstanceMethod(Pass080_PPtrConversions.PPtrsToParameters[type].ToTypeSignature()));
						instructions.Add(CilOpCodes.Ret);
					}
					else
					{
						CilInstructionLabel returnLabel = new();

						instructions.Add(CilOpCodes.Ldarg_1);
						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Callvirt, enterAssetMethod);
						instructions.Add(CilOpCodes.Brfalse, returnLabel);

						List<FieldNode> usableChildren = rootNode.Children.Where(IsUsable).ToOrderedList();
						for (int i = 0; i < usableChildren.Count; i++)
						{
							FieldNode fieldNode = usableChildren[i];
							CilInstructionLabel finishLabel = new();

							if (i > 0)
							{
								instructions.Add(CilOpCodes.Ldarg_1);
								instructions.Add(CilOpCodes.Ldarg_0);
								instructions.Add(CilOpCodes.Callvirt, divideAssetMethod);
							}

							string fieldName;
							if ((CurrentState is State.Release && fieldNode.Property.ReleaseNode?.NodeType is NodeType.TypelessData)
								|| (CurrentState is State.Editor && fieldNode.Property.ReleaseNode?.NodeType is NodeType.TypelessData))
							{
								//This is required for correct yaml export

								Debug.Assert(fieldNode.TypeSignature is SzArrayTypeSignature);

								string lengthName = GetName(fieldNode);

								CilInstructionLabel lengthLabel = new();

								instructions.Add(CilOpCodes.Ldarg_1);
								instructions.Add(CilOpCodes.Ldarg_0);
								instructions.Add(CilOpCodes.Ldstr, lengthName);
								instructions.Add(CilOpCodes.Callvirt, enterFieldMethod);
								instructions.Add(CilOpCodes.Brfalse, lengthLabel);

								instructions.Add(CilOpCodes.Ldarg_1);
								instructions.Add(CilOpCodes.Ldarg_0);
								instructions.Add(CilOpCodes.Ldfld, fieldNode.Field);
								instructions.Add(CilOpCodes.Ldlen);
								instructions.Add(CilOpCodes.Callvirt, visitPrimitiveMethod.MakeGenericInstanceMethod(SharedState.Instance.Importer.Int32));

								instructions.Add(CilOpCodes.Ldarg_1);
								instructions.Add(CilOpCodes.Ldarg_0);
								instructions.Add(CilOpCodes.Ldstr, lengthName);
								instructions.Add(CilOpCodes.Callvirt, exitFieldMethod);

								lengthLabel.Instruction = instructions.Add(CilOpCodes.Nop);

								instructions.Add(CilOpCodes.Ldarg_1);
								instructions.Add(CilOpCodes.Ldarg_0);
								instructions.Add(CilOpCodes.Callvirt, divideAssetMethod);

								fieldName = "_typelessdata";
							}
							else
							{
								fieldName = GetName(fieldNode);
							}

							instructions.Add(CilOpCodes.Ldarg_1);
							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldstr, fieldName);
							instructions.Add(CilOpCodes.Callvirt, enterFieldMethod);
							instructions.Add(CilOpCodes.Brfalse, finishLabel);

							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldfld, fieldNode.Field);
							instructions.Add(CilOpCodes.Ldarg_1);
							instructions.AddCall(GetOrMakeMethod(fieldNode.Child));

							instructions.Add(CilOpCodes.Ldarg_1);
							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldstr, fieldName);
							instructions.Add(CilOpCodes.Callvirt, exitFieldMethod);

							finishLabel.Instruction = instructions.Add(CilOpCodes.Nop);
						}

						instructions.Add(CilOpCodes.Ldarg_1);
						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Callvirt, exitAssetMethod);

						returnLabel.Instruction = instructions.Add(CilOpCodes.Ret);
					}
				}
			}
		}
	}

	private static IMethodDescriptor GetOrMakeMethod(Node node)
	{
		if (MethodDictionary.TryGetValue(node.TypeSignature, out IMethodDescriptor? cachedMethod))
		{
			return cachedMethod;
		}

		IMethodDescriptor result;
		switch (node)
		{
			case PrimitiveNode:
				{
					MethodDefinition method = NewMethod(node);
					CilInstructionCollection instructions = method.GetInstructions();
					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Callvirt, visitPrimitiveMethod.MakeGenericInstanceMethod(node.TypeSignature));
					instructions.Add(CilOpCodes.Ret);
					result = method;
				}
				break;
			case ListNode listNode:
				{
					MethodDefinition method = NewMethod(node);
					CilInstructionCollection instructions = method.GetInstructions();

					CilInstructionLabel returnLabel = new();
					CilInstructionLabel exitLabel = new();

					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Callvirt, enterListMethod.MakeGenericInstanceMethod(listNode.Child.TypeSignature));
					instructions.Add(CilOpCodes.Brfalse, returnLabel);

					{
						IMethodDescriptor elementMethod = GetOrMakeMethod(listNode.Child);

						//Make local and store length in it
						CilLocalVariable countLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32); //Create local
						instructions.Add(CilOpCodes.Ldarg_0); //Load list
						instructions.Add(CilOpCodes.Call, listNode.GetCount); //Get count
						instructions.Add(CilOpCodes.Stloc, countLocal); //Store it

						//Avoid the loop if count is less than 1
						instructions.Add(CilOpCodes.Ldloc, countLocal);
						instructions.Add(CilOpCodes.Ldc_I4_1);
						instructions.Add(CilOpCodes.Blt, exitLabel);

						//Make an i
						CilLocalVariable iLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);
						instructions.Add(CilOpCodes.Ldc_I4_0); //Load 0 as an int32
						instructions.Add(CilOpCodes.Stloc, iLocal); //Store in count

						//Jump over dividing for i == 0
						CilInstructionLabel visitItemLabel = new();
						instructions.Add(CilOpCodes.Br, visitItemLabel);

						//Divide List
						ICilLabel loopStartLabel = instructions.Add(CilOpCodes.Nop).CreateLabel();
						instructions.Add(CilOpCodes.Ldarg_1);
						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Callvirt, divideListMethod.MakeGenericInstanceMethod([.. listNode.TypeSignature.TypeArguments]));

						//Visit Item
						visitItemLabel.Instruction = instructions.Add(CilOpCodes.Nop);
						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Ldloc, iLocal);
						instructions.Add(CilOpCodes.Call, listNode.GetItem);
						instructions.Add(CilOpCodes.Ldarg_1);
						instructions.AddCall(elementMethod);

						//Increment i
						instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i local
						instructions.Add(CilOpCodes.Ldc_I4_1); //Load constant 1 as int32
						instructions.Add(CilOpCodes.Add); //Add 
						instructions.Add(CilOpCodes.Stloc, iLocal); //Store in i local

						//Jump to start of loop if i < count
						instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i
						instructions.Add(CilOpCodes.Ldloc, countLocal); //Load count
						instructions.Add(CilOpCodes.Blt, loopStartLabel); //Jump back up if less than
					}

					exitLabel.Instruction = instructions.Add(CilOpCodes.Nop);
					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Callvirt, exitListMethod.MakeGenericInstanceMethod(listNode.Child.TypeSignature));

					returnLabel.Instruction = instructions.Add(CilOpCodes.Ret);
					result = method;
				}
				break;
			case DictionaryNode dictionaryNode:
				{
					MethodDefinition method = NewMethod(node);
					CilInstructionCollection instructions = method.GetInstructions();

					CilInstructionLabel returnLabel = new();
					CilInstructionLabel exitLabel = new();

					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Callvirt, enterDictionaryMethod.MakeGenericInstanceMethod([.. dictionaryNode.TypeSignature.TypeArguments]));
					instructions.Add(CilOpCodes.Brfalse, returnLabel);

					{
						//Make local and store length in it
						CilLocalVariable countLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32); //Create local
						instructions.Add(CilOpCodes.Ldarg_0); //Load collection
						instructions.Add(CilOpCodes.Call, dictionaryNode.GetCount); //Get count
						instructions.Add(CilOpCodes.Stloc, countLocal); //Store it

						//Avoid the loop if count is less than 1
						instructions.Add(CilOpCodes.Ldloc, countLocal);
						instructions.Add(CilOpCodes.Ldc_I4_1);
						instructions.Add(CilOpCodes.Blt, exitLabel);

						//Make an i
						CilLocalVariable iLocal = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);
						instructions.Add(CilOpCodes.Ldc_I4_0); //Load 0 as an int32
						instructions.Add(CilOpCodes.Stloc, iLocal); //Store in count

						//Jump over dividing for i == 0
						CilInstructionLabel visitPairLabel = new();
						instructions.Add(CilOpCodes.Br, visitPairLabel);

						//Divide Dictionary
						ICilLabel loopStartLabel = instructions.Add(CilOpCodes.Nop).CreateLabel();
						instructions.Add(CilOpCodes.Ldarg_1);
						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Callvirt, divideDictionaryMethod.MakeGenericInstanceMethod([.. dictionaryNode.TypeSignature.TypeArguments]));

						//Visit Pair
						{
							PairNode pairNode = dictionaryNode.Child;

							IMethodDescriptor keyMethod = GetOrMakeMethod(pairNode.Key);
							IMethodDescriptor valueMethod = GetOrMakeMethod(pairNode.Value);

							visitPairLabel.Instruction = instructions.Add(CilOpCodes.Nop);

							CilLocalVariable pairLocal = instructions.AddLocalVariable(pairNode.TypeSignature);
							instructions.Add(CilOpCodes.Ldarg_0);
							instructions.Add(CilOpCodes.Ldloc, iLocal);
							instructions.Add(CilOpCodes.Call, dictionaryNode.GetPair);
							instructions.Add(CilOpCodes.Stloc, pairLocal);

							CilInstructionLabel afterPairLabel = new();
							instructions.Add(CilOpCodes.Ldarg_1);
							instructions.Add(CilOpCodes.Ldloc, pairLocal);
							instructions.Add(CilOpCodes.Call, pairNode.ImplicitConversion);
							instructions.Add(CilOpCodes.Callvirt, enterDictionaryPairMethod.MakeGenericInstanceMethod([.. pairNode.TypeSignature.TypeArguments]));
							instructions.Add(CilOpCodes.Brfalse, afterPairLabel);

							instructions.Add(CilOpCodes.Ldloc, pairLocal);
							instructions.Add(CilOpCodes.Call, pairNode.GetKey);
							instructions.Add(CilOpCodes.Ldarg_1);
							instructions.AddCall(keyMethod);

							instructions.Add(CilOpCodes.Ldarg_1);
							instructions.Add(CilOpCodes.Ldloc, pairLocal);
							instructions.Add(CilOpCodes.Call, pairNode.ImplicitConversion);
							instructions.Add(CilOpCodes.Callvirt, divideDictionaryPairMethod.MakeGenericInstanceMethod([.. pairNode.TypeSignature.TypeArguments]));

							instructions.Add(CilOpCodes.Ldloc, pairLocal);
							instructions.Add(CilOpCodes.Call, pairNode.GetValue);
							instructions.Add(CilOpCodes.Ldarg_1);
							instructions.AddCall(valueMethod);

							instructions.Add(CilOpCodes.Ldarg_1);
							instructions.Add(CilOpCodes.Ldloc, pairLocal);
							instructions.Add(CilOpCodes.Call, pairNode.ImplicitConversion);
							instructions.Add(CilOpCodes.Callvirt, exitDictionaryPairMethod.MakeGenericInstanceMethod([.. pairNode.TypeSignature.TypeArguments]));

							afterPairLabel.Instruction = instructions.Add(CilOpCodes.Nop);
						}

						//Increment i
						instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i local
						instructions.Add(CilOpCodes.Ldc_I4_1); //Load constant 1 as int32
						instructions.Add(CilOpCodes.Add); //Add 
						instructions.Add(CilOpCodes.Stloc, iLocal); //Store in i local

						//Jump to start of loop if i < count
						instructions.Add(CilOpCodes.Ldloc, iLocal); //Load i
						instructions.Add(CilOpCodes.Ldloc, countLocal); //Load count
						instructions.Add(CilOpCodes.Blt, loopStartLabel); //Jump back up if less than
					}

					exitLabel.Instruction = instructions.Add(CilOpCodes.Nop);
					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Callvirt, exitDictionaryMethod.MakeGenericInstanceMethod([.. dictionaryNode.TypeSignature.TypeArguments]));

					returnLabel.Instruction = instructions.Add(CilOpCodes.Ret);
					result = method;
				}
				break;
			case PairNode pairNode:
				{
					MethodDefinition method = NewMethod(node);
					CilInstructionCollection instructions = method.GetInstructions();

					CilInstructionLabel returnLabel = new();

					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Call, pairNode.ImplicitConversion);
					instructions.Add(CilOpCodes.Callvirt, enterPairMethod.MakeGenericInstanceMethod([.. pairNode.TypeSignature.TypeArguments]));
					instructions.Add(CilOpCodes.Brfalse, returnLabel);

					{
						IMethodDescriptor keyMethod = GetOrMakeMethod(pairNode.Key);
						IMethodDescriptor valueMethod = GetOrMakeMethod(pairNode.Value);

						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Call, pairNode.GetKey);
						instructions.Add(CilOpCodes.Ldarg_1);
						instructions.AddCall(keyMethod);

						instructions.Add(CilOpCodes.Ldarg_1);
						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Call, pairNode.ImplicitConversion);
						instructions.Add(CilOpCodes.Callvirt, dividePairMethod.MakeGenericInstanceMethod([.. pairNode.TypeSignature.TypeArguments]));

						instructions.Add(CilOpCodes.Ldarg_0);
						instructions.Add(CilOpCodes.Call, pairNode.GetValue);
						instructions.Add(CilOpCodes.Ldarg_1);
						instructions.AddCall(valueMethod);
					}

					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Call, pairNode.ImplicitConversion);
					instructions.Add(CilOpCodes.Callvirt, exitPairMethod.MakeGenericInstanceMethod([.. pairNode.TypeSignature.TypeArguments]));

					returnLabel.Instruction = instructions.Add(CilOpCodes.Ret);
					result = method;
				}
				break;
			case KeyNode keyNode:
				return GetOrMakeMethod(keyNode.Child);
			case ValueNode valueNode:
				return GetOrMakeMethod(valueNode.Child);
			default:
				throw new NotSupportedException();
		}
		MethodDictionary.Add(node.TypeSignature, result);
		return result;

		static MethodDefinition NewMethod(Node node)
		{
			MethodDefinition method = helperClass.AddMethod(
				UniqueNameFactory.MakeUniqueName(node.TypeSignature),
				MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig,
				SharedState.Instance.Importer.Void);
			method.AddParameter(node.TypeSignature, "value");
			method.AddParameter(assetWalkerType, "walker");
			return method;
		}
	}

	private static void Initialize()
	{
		assetWalkerType = SharedState.Instance.Importer.ImportType<AssetWalker>().ToTypeSignature();

		enterAssetMethod = ImportWalkerMethod(nameof(AssetWalker.EnterAsset));
		divideAssetMethod = ImportWalkerMethod(nameof(AssetWalker.DivideAsset));
		exitAssetMethod = ImportWalkerMethod(nameof(AssetWalker.ExitAsset));

		enterFieldMethod = ImportWalkerMethod(nameof(AssetWalker.EnterField));
		exitFieldMethod = ImportWalkerMethod(nameof(AssetWalker.ExitField));

		enterListMethod = ImportWalkerMethod(nameof(AssetWalker.EnterList));
		divideListMethod = ImportWalkerMethod(nameof(AssetWalker.DivideList));
		exitListMethod = ImportWalkerMethod(nameof(AssetWalker.ExitList));

		enterDictionaryMethod = ImportWalkerMethod(nameof(AssetWalker.EnterDictionary));
		divideDictionaryMethod = ImportWalkerMethod(nameof(AssetWalker.DivideDictionary));
		exitDictionaryMethod = ImportWalkerMethod(nameof(AssetWalker.ExitDictionary));

		enterDictionaryPairMethod = ImportWalkerMethod(nameof(AssetWalker.EnterDictionaryPair));
		divideDictionaryPairMethod = ImportWalkerMethod(nameof(AssetWalker.DivideDictionaryPair));
		exitDictionaryPairMethod = ImportWalkerMethod(nameof(AssetWalker.ExitDictionaryPair));

		enterPairMethod = ImportWalkerMethod(nameof(AssetWalker.EnterPair));
		dividePairMethod = ImportWalkerMethod(nameof(AssetWalker.DividePair));
		exitPairMethod = ImportWalkerMethod(nameof(AssetWalker.ExitPair));

		visitPrimitiveMethod = ImportWalkerMethod(nameof(AssetWalker.VisitPrimitive));
		visitPPtrMethod = ImportWalkerMethod(nameof(AssetWalker.VisitPPtr));
	}

	private static void CreateEmptyMethods()
	{
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			foreach (TypeDefinition type in group.Types)
			{
				MethodDictionary.Add(type.ToTypeSignature(), AddMethod(type, MethodName, assetWalkerType));
			}
		}

		static MethodDefinition AddMethod(TypeDefinition type, string methodName, TypeSignature assetWalkerType)
		{
			MethodDefinition method = type.AddMethod(methodName, Pass063_CreateEmptyMethods.OverrideMethodAttributes, SharedState.Instance.Importer.Void);
			method.AddParameter(assetWalkerType, "walker");
			return method;
		}
	}

	private static IMethodDefOrRef ImportWalkerMethod(string methodName)
	{
		return SharedState.Instance.Importer.ImportMethod<AssetWalker>(m =>
		{
			if (m.Name != methodName)
			{
				return false;
			}
			else if (methodName == nameof(AssetWalker.VisitPPtr))
			{
				return !m.Parameters[0].ParameterType.IsValueType;
			}
			else if (methodName is nameof(AssetWalker.VisitPrimitive))
			{
				return true;
			}
			else
			{
				TypeSignature parameterType = m.Parameters[0].ParameterType;
				return parameterType is not GenericInstanceTypeSignature || !(parameterType.Namespace?.StartsWith("AssetRipper") ?? false);
			}
		});
	}

	private static CilInstruction AddCall(this CilInstructionCollection instructions, IMethodDescriptor method)
	{
		return method is MethodDefinition { IsStatic: true }
			? instructions.Add(CilOpCodes.Call, method)
			: instructions.Add(CilOpCodes.Callvirt, method);
	}
}
```

`Source/AssetRipper.AssemblyDumper/Passes/Pass110_ClassNameAndIdOverrides.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.Assets;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass110_ClassNameAndIdOverrides
{
	const MethodAttributes PropertyOverrideAttributes =
		MethodAttributes.Public |
		MethodAttributes.HideBySig |
		MethodAttributes.SpecialName |
		MethodAttributes.ReuseSlot |
		MethodAttributes.Virtual;

	public static void DoPass()
	{
		foreach ((int id, ClassGroup group) in SharedState.Instance.ClassGroups)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				instance.Type.AddClassNameOverride(instance.Class.OriginalName);
			}
		}
		foreach (GeneratedClassInstance instance in SharedState.Instance.AllGroups.SelectMany(g => g.Instances))
		{
			instance.Type.AddSerializedVersionOverride(GetSerializedVersion(instance));
			instance.Type.AddFlowMappedInYamlOverride(GetFlowMappedInYaml(instance));
		}
	}

	private static void AddClassNameOverride(this TypeDefinition type, string className)
	{
		PropertyDefinition property = type.AddGetterProperty(nameof(UnityObjectBase.ClassName), PropertyOverrideAttributes, SharedState.Instance.Importer.String);
		CilInstructionCollection instructions = property.GetMethod!.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldstr, className);
		instructions.Add(CilOpCodes.Ret);
		property.AddDebuggerBrowsableNeverAttribute();
	}

	private static void AddSerializedVersionOverride(this TypeDefinition type, int version)
	{
		PropertyDefinition property = type.AddGetterProperty(nameof(UnityAssetBase.SerializedVersion), PropertyOverrideAttributes, SharedState.Instance.Importer.Int32);
		CilInstructionCollection instructions = property.GetMethod!.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldc_I4, version);
		instructions.Add(CilOpCodes.Ret);
		property.AddDebuggerBrowsableNeverAttribute();
	}

	private static void AddFlowMappedInYamlOverride(this TypeDefinition type, bool flowMapped)
	{
		PropertyDefinition property = type.AddGetterProperty(nameof(UnityAssetBase.FlowMappedInYaml), PropertyOverrideAttributes, SharedState.Instance.Importer.Boolean);
		CilInstructionCollection instructions = property.GetMethod!.CilMethodBody!.Instructions;
		instructions.Add(flowMapped ? CilOpCodes.Ldc_I4_1 : CilOpCodes.Ldc_I4_0);
		instructions.Add(CilOpCodes.Ret);
		property.AddDebuggerBrowsableNeverAttribute();
	}

	private static int GetSerializedVersion(GeneratedClassInstance instance)
	{
		if (instance.Class.EditorRootNode is null)
		{
			return instance.Class.ReleaseRootNode?.Version ?? 1;
		}
		else if (instance.Class.ReleaseRootNode is null)
		{
			return instance.Class.EditorRootNode.Version;
		}
		else
		{
			int release = instance.Class.ReleaseRootNode.Version;
			int editor = instance.Class.EditorRootNode.Version;
			return release == editor ? release : throw new("Release and editor serialized versions were different!");
		}
	}

	private static bool GetFlowMappedInYaml(GeneratedClassInstance instance)
	{
		if (instance.Class.EditorRootNode is null)
		{
			return instance.Class.ReleaseRootNode?.MetaFlag.IsTransferUsingFlowMappingStyle() ?? false;
		}
		else if (instance.Class.ReleaseRootNode is null)
		{
			return instance.Class.EditorRootNode.MetaFlag.IsTransferUsingFlowMappingStyle();
		}
		else
		{
			bool release = instance.Class.ReleaseRootNode.MetaFlag.IsTransferUsingFlowMappingStyle();
			bool editor = instance.Class.EditorRootNode.MetaFlag.IsTransferUsingFlowMappingStyle();
			return release == editor ? release : throw new("Release and editor flow mapping were different!");
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass201_GuidConversionOperators.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass201_GuidConversionOperators
{
	const MethodAttributes ConversionAttributes = MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName | MethodAttributes.HideBySig;
	public static void DoPass()
	{
		foreach (TypeDefinition type in SharedState.Instance.SubclassGroups["GUID"].Types)
		{
			AddImplicitConversion(type);
			AddExplicitConversion(type);
		}
	}

	private static void AddImplicitConversion(TypeDefinition guidType)
	{
		ITypeDefOrRef commonGuidType = SharedState.Instance.Importer.ImportType<UnityGuid>();
		IMethodDefOrRef constructor = SharedState.Instance.Importer.ImportConstructor<UnityGuid>(4);

		FieldDefinition data0 = guidType.Fields.Single(field => field.Name == "m_Data_0_");
		FieldDefinition data1 = guidType.Fields.Single(field => field.Name == "m_Data_1_");
		FieldDefinition data2 = guidType.Fields.Single(field => field.Name == "m_Data_2_");
		FieldDefinition data3 = guidType.Fields.Single(field => field.Name == "m_Data_3_");

		MethodDefinition implicitMethod = guidType.AddMethod("op_Implicit", ConversionAttributes, commonGuidType.ToTypeSignature());
		implicitMethod.AddParameter(guidType.ToTypeSignature(), "value");

		implicitMethod.CilMethodBody!.InitializeLocals = true;
		CilInstructionCollection instructions = implicitMethod.CilMethodBody.Instructions;

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, data0);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, data1);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, data2);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, data3);
		instructions.Add(CilOpCodes.Newobj, constructor);
		instructions.Add(CilOpCodes.Ret);
	}

	private static void AddExplicitConversion(TypeDefinition guidType)
	{
		ITypeDefOrRef commonGuidType = SharedState.Instance.Importer.ImportType<UnityGuid>();
		IMethodDefOrRef constructor = guidType.Methods.Single(m => m.IsConstructor && m.Parameters.Count == 0 && !m.IsStatic);

		FieldDefinition data0 = guidType.Fields.Single(field => field.Name == "m_Data_0_");
		FieldDefinition data1 = guidType.Fields.Single(field => field.Name == "m_Data_1_");
		FieldDefinition data2 = guidType.Fields.Single(field => field.Name == "m_Data_2_");
		FieldDefinition data3 = guidType.Fields.Single(field => field.Name == "m_Data_3_");

		IMethodDefOrRef getData0 = SharedState.Instance.Importer.ImportMethod<UnityGuid>(m => m.Name == $"get_{nameof(UnityGuid.Data0)}");
		IMethodDefOrRef getData1 = SharedState.Instance.Importer.ImportMethod<UnityGuid>(m => m.Name == $"get_{nameof(UnityGuid.Data1)}");
		IMethodDefOrRef getData2 = SharedState.Instance.Importer.ImportMethod<UnityGuid>(m => m.Name == $"get_{nameof(UnityGuid.Data2)}");
		IMethodDefOrRef getData3 = SharedState.Instance.Importer.ImportMethod<UnityGuid>(m => m.Name == $"get_{nameof(UnityGuid.Data3)}");

		MethodDefinition explicitMethod = guidType.AddMethod("op_Explicit", ConversionAttributes, guidType.ToTypeSignature());
		Parameter parameter = explicitMethod.AddParameter(commonGuidType.ToTypeSignature(), "value");

		CilInstructionCollection instructions = explicitMethod.CilMethodBody!.Instructions;

		instructions.Add(CilOpCodes.Newobj, constructor);
		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga, parameter);
		instructions.Add(CilOpCodes.Call, getData0);
		instructions.Add(CilOpCodes.Stfld, data0);
		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga, parameter);
		instructions.Add(CilOpCodes.Call, getData1);
		instructions.Add(CilOpCodes.Stfld, data1);
		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga, parameter);
		instructions.Add(CilOpCodes.Call, getData2);
		instructions.Add(CilOpCodes.Stfld, data2);
		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga, parameter);
		instructions.Add(CilOpCodes.Call, getData3);
		instructions.Add(CilOpCodes.Stfld, data3);
		instructions.Add(CilOpCodes.Ret);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass202_VectorExplicitConversions.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using System.Numerics;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass202_VectorExplicitConversions
{
	public static void DoPass()
	{
		//DoImplementation<Vector3f, IVector3f>(SharedState.Instance.SubclassGroups["Vector3Float"], 3);
		//DoImplementation<Vector4f, IVector4f>(SharedState.Instance.SubclassGroups["Vector4Float"], 4);
		//DoImplementation<Vector2i, IVector2i>(SharedState.Instance.SubclassGroups["Vector2Int"], 2);
		//DoImplementation<Vector3i, IVector3i>(SharedState.Instance.SubclassGroups["Vector3Int"], 3);
		//DoImplementation<Vector2f, IVector2f>(SharedState.Instance.SubclassGroups["Vector2f"], 2);
		//DoImplementation<Vector3f, IVector3f>(SharedState.Instance.SubclassGroups["Vector3f"], 3);
		//DoImplementation<Vector4f, IVector4f>(SharedState.Instance.SubclassGroups["Vector4f"], 4);
		//DoImplementation<Quaternionf, IQuaternionf>(SharedState.Instance.SubclassGroups["Quaternionf"], 4);

		DoImplementation<Vector3>(SharedState.Instance.SubclassGroups["Vector3Float"], 3);
		DoImplementation<Vector4>(SharedState.Instance.SubclassGroups["Vector4Float"], 4);
		DoImplementation<Vector2>(SharedState.Instance.SubclassGroups["Vector2f"], 2);
		DoImplementation<Vector3>(SharedState.Instance.SubclassGroups["Vector3f"], 3);
		DoImplementation<Vector4>(SharedState.Instance.SubclassGroups["Vector4f"], 4);
		DoImplementation<Quaternion>(SharedState.Instance.SubclassGroups["Quaternionf"], 4);
	}

	//private static void DoImplementation<TClass, TInterface>(SubclassGroup group, int size)
	//{
	//	AddInterface<TInterface>(group, size);
	//	foreach (TypeDefinition type in group.Types)
	//	{
	//		AddConversion<TClass>(type, size);
	//		AddReverseConversion<TClass>(type, size);
	//	}
	//}

	private static void DoImplementation<TClass>(SubclassGroup group, int size)
	{
		foreach (TypeDefinition type in group.Types)
		{
			AddConversion<TClass>(type, size);
			AddReverseConversion<TClass>(type, size);
		}
	}

	private static void AddConversion<T>(TypeDefinition type, int size)
	{
		TypeSignature commonType = SharedState.Instance.Importer.ImportTypeSignature<T>();
		IMethodDefOrRef constructor = SharedState.Instance.Importer.ImportConstructor<T>(size);

		MethodDefinition method = type.AddEmptyConversion(type.ToTypeSignature(), commonType, true);
		CilInstructionCollection instructions = method.GetInstructions();

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, type.Fields.Single(field => field.Name == "m_X"));

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, type.Fields.Single(field => field.Name == "m_Y"));

		if (size > 2)
		{
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, type.Fields.Single(field => field.Name == "m_Z"));
		}
		if (size > 3)
		{
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, type.Fields.Single(field => field.Name == "m_W"));
		}

		instructions.Add(CilOpCodes.Newobj, constructor);
		instructions.Add(CilOpCodes.Ret);
	}

	private static void AddReverseConversion<T>(TypeDefinition type, int size)
	{
		TypeSignature commonType = SharedState.Instance.Importer.ImportTypeSignature<T>();

		MethodDefinition constructor = type.GetDefaultConstructor();

		MethodDefinition method = type.AddEmptyConversion(commonType, type.ToTypeSignature(), false);
		CilInstructionCollection instructions = method.GetInstructions();

		instructions.Add(CilOpCodes.Newobj, constructor);

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, SharedState.Instance.Importer.ImportField<T>("X"));
		instructions.Add(CilOpCodes.Stfld, type.Fields.Single(field => field.Name == "m_X"));

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, SharedState.Instance.Importer.ImportField<T>("Y"));
		instructions.Add(CilOpCodes.Stfld, type.Fields.Single(field => field.Name == "m_Y"));

		if (size > 2)
		{
			instructions.Add(CilOpCodes.Dup);
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, SharedState.Instance.Importer.ImportField<T>("Z"));
			instructions.Add(CilOpCodes.Stfld, type.Fields.Single(field => field.Name == "m_Z"));
		}
		if (size > 3)
		{
			instructions.Add(CilOpCodes.Dup);
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, SharedState.Instance.Importer.ImportField<T>("W"));
			instructions.Add(CilOpCodes.Stfld, type.Fields.Single(field => field.Name == "m_W"));
		}

		instructions.Add(CilOpCodes.Ret);
	}

	private static void AddInterface<T>(SubclassGroup group, int size)
	{
		group.Interface.AddInterfaceImplementation<T>(SharedState.Instance.Importer);
		foreach (TypeDefinition type in group.Types)
		{
			type.ImplementVectorProperty("X");
			type.ImplementVectorProperty("Y");
			if (size > 2)
			{
				type.ImplementVectorProperty("Z");
			}
			if (size > 3)
			{
				type.ImplementVectorProperty("W");
			}
		}
	}

	private static void ImplementVectorProperty(this TypeDefinition type, string propertyName)
	{
		type.ImplementFullProperty(
			propertyName,
			InterfaceUtils.InterfacePropertyImplementation,
			null,
			type.GetFieldByName($"m_{propertyName}"));
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass203_OffsetPtrImplicitConversions.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Passes;

/// <summary>
/// Adds implicit conversion and ToString override to OffsetPtr types.
/// </summary>
public static class Pass203_OffsetPtrImplicitConversions
{
	const MethodAttributes ConversionAttributes = MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName | MethodAttributes.HideBySig;

	public static void DoPass()
	{
		foreach ((string name, SubclassGroup group) in SharedState.Instance.SubclassGroups)
		{
			if (name.StartsWith("OffsetPtr"))
			{
				foreach (TypeDefinition type in group.Types)
				{
					type.AddImplicitConversion();
					type.AddToStringOverride();
				}
			}
		}
	}

	private static void AddImplicitConversion(this TypeDefinition type)
	{
		FieldDefinition field = type.GetField();

		MethodDefinition implicitMethod = type.AddMethod("op_Implicit", ConversionAttributes, field.Signature!.FieldType);
		implicitMethod.AddParameter(type.ToTypeSignature(), "value");

		CilInstructionCollection instructions = implicitMethod.CilMethodBody!.Instructions;

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, field);
		instructions.Add(CilOpCodes.Ret);
	}

	private static void AddToStringOverride(this TypeDefinition type)
	{
		const MethodAttributes attributes = MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.ReuseSlot | MethodAttributes.HideBySig;

		CorLibTypeSignature stringType = type.DeclaringModule!.CorLibTypeFactory.String;
		ITypeDefOrRef objectType = type.DeclaringModule.CorLibTypeFactory.Object.ToTypeDefOrRef();

		MethodDefinition toStringMethod = type.AddMethod(nameof(ToString), attributes, stringType);

		CilInstructionCollection instructions = toStringMethod.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, type.GetField());
		instructions.Add(CilOpCodes.Callvirt, new MemberReference(objectType, nameof(ToString), MethodSignature.CreateInstance(stringType)));
		instructions.Add(CilOpCodes.Ret);
	}

	private static FieldDefinition GetField(this TypeDefinition type)
	{
		return type.Fields.Single(field => field.Name == "m_Data");
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass204_Hash128ExplicitConversion.cs`:

```cs
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.IO.Files.BundleFiles;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass204_Hash128ExplicitConversion
{
	const MethodAttributes ConversionAttributes = MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName | MethodAttributes.HideBySig;
	public static void DoPass()
	{
		foreach (TypeDefinition type in SharedState.Instance.SubclassGroups["Hash128"].Types)
		{
			//type.AddConversion();
		}
	}

	private static void AddConversion(this TypeDefinition type)
	{
		ITypeDefOrRef returnType = SharedState.Instance.Importer.ImportType<Hash128>();
		MethodDefinition method = type.AddMethod("op_Explicit", ConversionAttributes, returnType.ToTypeSignature());
		method.AddParameter(type.ToTypeSignature(), "value");
		method.CilMethodBody!.InitializeLocals = true;

		CilInstructionCollection instructions = method.CilMethodBody.Instructions;
		SzArrayTypeSignature arrayType = SharedState.Instance.Importer.UInt8.MakeSzArrayType();

		instructions.Add(CilOpCodes.Ldc_I4, 16);
		instructions.Add(CilOpCodes.Newarr, SharedState.Instance.Importer.UInt8.ToTypeDefOrRef());

		CilLocalVariable array = instructions.AddLocalVariable(arrayType);
		instructions.Add(CilOpCodes.Stloc, array);

		for (int i = 0; i < 16; i++)
		{
			FieldDefinition field = type.GetFieldByName(GetFieldName(i));
			instructions.Add(CilOpCodes.Ldloc, array);
			instructions.Add(CilOpCodes.Ldc_I4, i);
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, field);
			instructions.Add(CilOpCodes.Stelem, SharedState.Instance.Importer.UInt8.ToTypeDefOrRef());
		}

		instructions.Add(CilOpCodes.Ldloc, array);

		IMethodDefOrRef constructor = SharedState.Instance.Importer.ImportMethod<Hash128>(m => m.IsConstructor && m.Parameters.Count == 1 && m.Parameters[0].ParameterType is SzArrayTypeSignature);
		instructions.Add(CilOpCodes.Newobj, constructor);
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
	}

	private static string GetFieldName(int i)
	{
		return i < 10 ? $"m_Bytes__{i}" : $"m_Bytes_{i}";
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass205_ColorExplicitConversions.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.Numerics;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass205_ColorExplicitConversions
{
	public static void DoPass()
	{
		AddConversion32(SharedState.Instance.SubclassGroups["ColorRGBA32"]);
		AddConversionF(SharedState.Instance.SubclassGroups["ColorRGBAf"]);
	}

	private static void AddConversion32(SubclassGroup group)
	{
		foreach (TypeDefinition type in group.Types)
		{
			AddConversion32(type);
			AddReverseConversion32(type);
		}
	}

	private static void AddConversion32(TypeDefinition type)
	{
		TypeSignature commonType = SharedState.Instance.Importer.ImportTypeSignature<Color32>();

		MethodDefinition method = type.AddEmptyConversion(type.ToTypeSignature(), commonType, false);
		CilInstructionCollection instructions = method.GetInstructions();

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_Rgba"));
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<Color32>(m => m.Name == nameof(Color32.FromRgba)));

		instructions.Add(CilOpCodes.Ret);
	}

	private static void AddReverseConversion32(TypeDefinition type)
	{
		TypeSignature commonType = SharedState.Instance.Importer.ImportTypeSignature<Color32>();

		MethodDefinition constructor = type.GetDefaultConstructor();

		MethodDefinition method = type.AddEmptyConversion(commonType, type.ToTypeSignature(), false);
		CilInstructionCollection instructions = method.GetInstructions();

		instructions.Add(CilOpCodes.Newobj, constructor);

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<Color32>(m => m.Name == $"get_{nameof(Color32.Rgba)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_Rgba"));

		instructions.Add(CilOpCodes.Ret);
	}

	private static void AddConversionF(SubclassGroup group)
	{
		foreach (TypeDefinition type in group.Types)
		{
			AddConversionF(type);
			AddReverseConversionF(type);
		}
	}

	private static void AddConversionF(TypeDefinition type)
	{
		TypeSignature commonType = SharedState.Instance.Importer.ImportTypeSignature<ColorFloat>();

		IMethodDefOrRef constructor = SharedState.Instance.Importer.ImportConstructor<ColorFloat>(4);

		MethodDefinition method = type.AddEmptyConversion(type.ToTypeSignature(), commonType, true);
		CilInstructionCollection instructions = method.GetInstructions();

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_R"));

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_G"));

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_B"));

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_A"));

		instructions.Add(CilOpCodes.Newobj, constructor);

		instructions.Add(CilOpCodes.Ret);
	}

	private static void AddReverseConversionF(TypeDefinition type)
	{
		TypeSignature commonType = SharedState.Instance.Importer.ImportTypeSignature<ColorFloat>();

		MethodDefinition constructor = type.GetDefaultConstructor();

		MethodDefinition method = type.AddEmptyConversion(commonType, type.ToTypeSignature(), false);
		CilInstructionCollection instructions = method.GetInstructions();

		instructions.Add(CilOpCodes.Newobj, constructor);

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<ColorFloat>(m => m.Name == $"get_{nameof(ColorFloat.R)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_R"));

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<ColorFloat>(m => m.Name == $"get_{nameof(ColorFloat.G)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_G"));

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<ColorFloat>(m => m.Name == $"get_{nameof(ColorFloat.B)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_B"));

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<ColorFloat>(m => m.Name == $"get_{nameof(ColorFloat.A)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_A"));

		instructions.Add(CilOpCodes.Ret);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass206_BoneWeights4ExplicitConversions.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.Numerics;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass206_BoneWeights4ExplicitConversions
{
	public static void DoPass()
	{
		AddConversion(SharedState.Instance.SubclassGroups["BoneWeights4"]);
	}

	private static void AddConversion(SubclassGroup group)
	{
		foreach (TypeDefinition type in group.Types)
		{
			AddConversion(type);
			AddReverseConversion(type);
		}
	}

	private static void AddConversion(TypeDefinition type)
	{
		TypeSignature commonType = SharedState.Instance.Importer.ImportTypeSignature<BoneWeight4>();

		IMethodDefOrRef constructor = SharedState.Instance.Importer.ImportConstructor<BoneWeight4>(8);

		MethodDefinition method = type.AddEmptyConversion(type.ToTypeSignature(), commonType, true);
		CilInstructionCollection instructions = method.GetInstructions();

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_Weight_0_"));

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_Weight_1_"));

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_Weight_2_"));

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_Weight_3_"));

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_BoneIndex_0_"));

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_BoneIndex_1_"));

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_BoneIndex_2_"));

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "get_BoneIndex_3_"));

		instructions.Add(CilOpCodes.Newobj, constructor);

		instructions.Add(CilOpCodes.Ret);
	}

	private static void AddReverseConversion(TypeDefinition type)
	{
		TypeSignature commonType = SharedState.Instance.Importer.ImportTypeSignature<BoneWeight4>();

		MethodDefinition constructor = type.GetDefaultConstructor();

		MethodDefinition method = type.AddEmptyConversion(commonType, type.ToTypeSignature(), false);
		CilInstructionCollection instructions = method.GetInstructions();

		instructions.Add(CilOpCodes.Newobj, constructor);

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<BoneWeight4>(m => m.Name == $"get_{nameof(BoneWeight4.Index0)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_BoneIndex_0_"));

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<BoneWeight4>(m => m.Name == $"get_{nameof(BoneWeight4.Index1)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_BoneIndex_1_"));

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<BoneWeight4>(m => m.Name == $"get_{nameof(BoneWeight4.Index2)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_BoneIndex_2_"));

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<BoneWeight4>(m => m.Name == $"get_{nameof(BoneWeight4.Index3)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_BoneIndex_3_"));

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<BoneWeight4>(m => m.Name == $"get_{nameof(BoneWeight4.Weight0)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_Weight_0_"));

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<BoneWeight4>(m => m.Name == $"get_{nameof(BoneWeight4.Weight1)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_Weight_1_"));

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<BoneWeight4>(m => m.Name == $"get_{nameof(BoneWeight4.Weight2)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_Weight_2_"));

		instructions.Add(CilOpCodes.Dup);
		instructions.Add(CilOpCodes.Ldarga_S, method.Parameters[0]);
		instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod<BoneWeight4>(m => m.Name == $"get_{nameof(BoneWeight4.Weight3)}"));
		instructions.Add(CilOpCodes.Call, type.Methods.Single(m => m.Name == "set_Weight_3_"));

		instructions.Add(CilOpCodes.Ret);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass300_NamedInterface.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass300_NamedInterface
{
	private const string PropertyName = nameof(INamed.Name);

	public static void DoPass()
	{
		TypeSignature utf8StringSignature = SharedState.Instance.Importer.ImportType<Utf8String>().ToTypeSignature();
		ITypeDefOrRef hasNameInterface = SharedState.Instance.Importer.ImportType<INamed>();
		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			DoPassOnGroup(group, hasNameInterface, utf8StringSignature);
		}
	}

	private static void DoPassOnGroup(ClassGroupBase group, ITypeDefOrRef hasNameInterface, TypeSignature utf8StringSignature)
	{
		if (group.Types.All(t => t.TryGetNameField(true, out var _)))
		{
			TypeDefinition groupInterface = group.Interface;
			groupInterface.AddInterfaceImplementation(hasNameInterface);
			if (groupInterface.Properties.Any(p => p.Name == PropertyName))
			{
				throw new Exception("Interface already has a name property");
			}

			foreach (TypeDefinition type in group.Types)
			{
				if (type.TryGetNameField(false, out FieldDefinition? field))
				{
					type.ImplementNameProperty(field, utf8StringSignature);
				}
			}
		}
		else
		{
			foreach (TypeDefinition type in group.Types)
			{
				if (type.TryGetNameField(false, out FieldDefinition? field))
				{
					type.AddInterfaceImplementation(hasNameInterface);
					type.ImplementNameProperty(field, utf8StringSignature);
				}
			}
		}
	}

	private static void ImplementNameProperty(this TypeDefinition type, FieldDefinition field, TypeSignature utf8StringSignature)
	{
		if (!type.Properties.Any(p => p.Name == PropertyName))
		{
			type.ImplementFullProperty(PropertyName, InterfaceUtils.InterfacePropertyImplementation, utf8StringSignature, field);
		}
	}

	private static bool TryGetNameField(this TypeDefinition type, bool checkBaseTypes, [NotNullWhen(true)] out FieldDefinition? field)
	{
		field = type.TryGetFieldByName("m_Name", checkBaseTypes);
		return field?.Signature?.FieldType.Name == nameof(Utf8String);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass301_SourcePrefabProperty.cs`:

```cs
using AssetRipper.AssemblyDumper.Documentation;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass301_SourcePrefabProperty
{
	private const string PropertyName = "SourcePrefabP";

	public static void DoPass()
	{
		ClassGroup group = SharedState.Instance.ClassGroups[1001];

		//Interface Property
		{
			PropertyDefinition property = group.Interface.AddFullProperty(PropertyName, InterfaceUtils.InterfacePropertyDeclaration, group.Interface.ToTypeSignature());
			property.AddNullableAttributesForMaybeNull();
			DocumentationHandler.AddPropertyDefinitionLine(property, $"Injected in {nameof(Pass301_SourcePrefabProperty)}");
			DocumentationHandler.AddPropertyDefinitionLine(property, "It is the source/parent prefab of this prefab instance.");
		}

		foreach (GeneratedClassInstance instance in group.Instances)
		{
			PropertyDefinition existingProperty = instance.Properties.Single(p => p.BackingField?.Name == "m_SourcePrefab").SpecialDefinition!;

			PropertyDefinition property = instance.Type.AddFullProperty(PropertyName, InterfaceUtils.InterfacePropertyImplementation, group.Interface.ToTypeSignature());

			//Get method
			{
				MethodDefinition method = property.GetMethod!;
				CilInstructionCollection instructions = method.GetInstructions();
				instructions.Add(CilOpCodes.Ldarg_0);
				instructions.Add(CilOpCodes.Call, existingProperty.GetMethod!);
				instructions.Add(CilOpCodes.Ret);
			}

			//Set method
			{
				MethodDefinition method = property.SetMethod!;
				CilInstructionCollection instructions = method.GetInstructions();
				instructions.Add(CilOpCodes.Ldarg_0);
				instructions.Add(CilOpCodes.Ldarg_1);
				instructions.Add(CilOpCodes.Call, existingProperty.SetMethod!);
				instructions.Add(CilOpCodes.Ret);
			}

			property.AddNullableAttributesForMaybeNull();
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass400_EqualityComparison.cs`:

```cs
using AssetRipper.AssemblyDumper.AST;
using AssetRipper.AssemblyDumper.InjectedTypes;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass400_EqualityComparison
{
	/// <summary>
	/// Methods are guaranteed to be static and have signature: bool(T x, T y)
	/// </summary>
	private static readonly Dictionary<TypeSignature, IMethodDescriptor> equalsMethods = new(SignatureComparer.Default);
	/// <summary>
	/// Methods are guaranteed to be static and have signature: bool?(T x, T y, AssetEqualityComparer)
	/// </summary>
	private static readonly Dictionary<TypeSignature, IMethodDescriptor> addToEqualityComparerMethods = new(SignatureComparer.Default);

	public static void DoPass()
	{
		TypeDefinition equalityComparisonHelper = SharedState.Instance.InjectHelperType(typeof(EqualityComparisonHelper));

		ITypeDefOrRef hashCodeType = SharedState.Instance.Importer.ImportType<HashCode>();
		IMethodDefOrRef addMethod = SharedState.Instance.Importer.ImportMethod<HashCode>(
			m => m.Name == nameof(HashCode.Add) && m.Parameters.Count == 1 && m.Signature!.GenericParameterCount == 1);
		IMethodDefOrRef toHashCodeMethod = SharedState.Instance.Importer.ImportMethod<HashCode>(m => m.Name == nameof(HashCode.ToHashCode));

		ITypeDefOrRef equatableInterface = SharedState.Instance.Importer.ImportType(typeof(IEquatable<>));

		ITypeDefOrRef iunityAssetBase = SharedState.Instance.Importer.ImportType<IUnityAssetBase>();
		ITypeDefOrRef assetEqualityComparer = SharedState.Instance.Importer.ImportType<AssetEqualityComparer>();

		TypeSignature trileanTypeSignature = equalityComparisonHelper.GetMethodByName(nameof(EqualityComparisonHelper.ToTrilean)).Signature!.ReturnType;

		HashSet<SubclassGroup> subclassesWithPPtrs = new();
		foreach (SubclassGroup group in SharedState.Instance.SubclassGroups.Values.Where(g => !g.IsString && !g.IsPPtr))
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				TypeNode root = new(instance);
				if (root.AnyPPtrs)
				{
					//For now, we do nothing.
					subclassesWithPPtrs.Add(group);
					TypeSignature typeSignature = instance.Type.ToTypeSignature();
					addToEqualityComparerMethods.Add(typeSignature, equalityComparisonHelper
						.GetMethodByName(nameof(EqualityComparisonHelper.AssetEquals))
						.MakeGenericInstanceMethod(typeSignature));
				}
				else
				{
					//Generate IEquatable<T>, ==, !=, Equals, GetHashCode

					instance.Type.AddInterfaceImplementation(equatableInterface.MakeGenericInstanceType(instance.Type.ToTypeSignature()).ToTypeDefOrRef());

					MethodDefinition equalsMethod = GenerateEqualsMethod(instance, root, equalityComparisonHelper);

					MethodDefinition objectEqualsMethod = OverrideObjectEquals(instance, root, equalsMethod);

					OverrideGetHashCode(instance, root, hashCodeType, addMethod, toHashCodeMethod);

					AddEqualityOperators(instance, root, equalsMethod);

					OverrideAddToEqualityComparer(instance, objectEqualsMethod, iunityAssetBase, assetEqualityComparer, equalityComparisonHelper);
				}
			}
		}

		//PPtr classes
		{
			MethodDefinition pptrMethod = equalityComparisonHelper.GetMethodByName(nameof(EqualityComparisonHelper.MaybeAddDependentComparison));
			foreach (SubclassGroup group in SharedState.Instance.SubclassGroups.Values.Where(g => g.IsPPtr))
			{
				foreach (GeneratedClassInstance instance in group.Instances)
				{
					TypeDefinition type = instance.Type;
					MethodDefinition method = type.AddMethod(
						nameof(UnityAssetBase.AddToEqualityComparer),
						Pass063_CreateEmptyMethods.OverrideMethodAttributes,
						trileanTypeSignature);
					method.AddParameter(iunityAssetBase.ToTypeSignature(), "other");
					method.AddParameter(assetEqualityComparer.ToTypeSignature(), "comparer");

					CilInstructionCollection instructions = method.GetInstructions();

					instructions.Add(CilOpCodes.Ldarg_0);
					instructions.Add(CilOpCodes.Ldarg_1);
					instructions.Add(CilOpCodes.Castclass, type);
					instructions.Add(CilOpCodes.Ldarg_2);
					instructions.Add(CilOpCodes.Call, pptrMethod);
					instructions.Add(CilOpCodes.Ret);

					//We're generating these methods for AssetList<T>, but the following method avoids a cast.
					addToEqualityComparerMethods.Add(type.ToTypeSignature(), pptrMethod);
				}
			}
		}

		//Equals methods have been cached.
		foreach (SubclassGroup group in subclassesWithPPtrs)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				TypeNode root = new(instance);
				if (!root.AnyPPtrs)
				{
					// Equals methods have already been generated.
					continue;
				}

				GenerateAddToEqualityComparer(equalityComparisonHelper, iunityAssetBase, assetEqualityComparer, trileanTypeSignature, instance, root);
			}
		}

		foreach (ClassGroup group in SharedState.Instance.ClassGroups.Values)
		{
			foreach (GeneratedClassInstance instance in group.Instances)
			{
				if (instance.Type.IsAbstract)
				{
					//We don't need to generate equality methods for abstract classes.
					continue;
				}

				TypeNode root = new(instance);

				GenerateAddToEqualityComparer(equalityComparisonHelper, iunityAssetBase, assetEqualityComparer, trileanTypeSignature, instance, root);
			}
		}

		equalsMethods.Clear();
		addToEqualityComparerMethods.Clear();
	}

	private static void GenerateAddToEqualityComparer(TypeDefinition equalityComparisonHelper, ITypeDefOrRef iunityAssetBase, ITypeDefOrRef assetEqualityComparer, TypeSignature trileanTypeSignature, GeneratedClassInstance instance, TypeNode root)
	{
		TypeDefinition type = instance.Type;
		MethodDefinition method = type.AddMethod(
			nameof(UnityAssetBase.AddToEqualityComparer),
			Pass063_CreateEmptyMethods.OverrideMethodAttributes,
			trileanTypeSignature);
		method.AddParameter(iunityAssetBase.ToTypeSignature(), "other");
		method.AddParameter(assetEqualityComparer.ToTypeSignature(), "comparer");

		MethodDefinition getTrueMethod = equalityComparisonHelper.GetMethodByName(nameof(EqualityComparisonHelper.GetTrue));
		MethodDefinition getFalseMethod = equalityComparisonHelper.GetMethodByName(nameof(EqualityComparisonHelper.GetFalse));
		MethodDefinition getNullMethod = equalityComparisonHelper.GetMethodByName(nameof(EqualityComparisonHelper.GetNull));

		MethodDefinition isFalseMethod = equalityComparisonHelper.GetMethodByName(nameof(EqualityComparisonHelper.IsFalse));
		MethodDefinition isNullMethod = equalityComparisonHelper.GetMethodByName(nameof(EqualityComparisonHelper.IsNull));

		CilInstructionCollection instructions = method.GetInstructions();

		CilLocalVariable otherLocal = instructions.AddLocalVariable(type.ToTypeSignature());
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Castclass, type);
		instructions.Add(CilOpCodes.Stloc, otherLocal);

		CilLocalVariable resultLocal = instructions.AddLocalVariable(trileanTypeSignature);
		instructions.Add(CilOpCodes.Call, getTrueMethod);
		instructions.Add(CilOpCodes.Stloc, resultLocal);

		foreach (FieldNode field in root.Children)
		{
			if (!field.AnyPPtrs)
			{
				CilInstructionLabel nextFieldLabel = new();
				instructions.Add(CilOpCodes.Ldarg_0);
				instructions.Add(CilOpCodes.Ldfld, field.Field);
				instructions.Add(CilOpCodes.Ldloc, otherLocal);
				instructions.Add(CilOpCodes.Ldfld, field.Field);
				instructions.Add(CilOpCodes.Call, GetEqualsMethod(equalityComparisonHelper, field));
				instructions.Add(CilOpCodes.Brtrue, nextFieldLabel);
				instructions.Add(CilOpCodes.Call, getFalseMethod);
				instructions.Add(CilOpCodes.Ret);
				nextFieldLabel.Instruction = instructions.Add(CilOpCodes.Nop);
			}
			else
			{
				CilLocalVariable fieldResultLocal = instructions.AddLocalVariable(trileanTypeSignature);

				instructions.Add(CilOpCodes.Ldarg_0);
				instructions.Add(CilOpCodes.Ldfld, field.Field);
				instructions.Add(CilOpCodes.Ldloc, otherLocal);
				instructions.Add(CilOpCodes.Ldfld, field.Field);
				instructions.Add(CilOpCodes.Ldarg_2);
				instructions.Add(CilOpCodes.Call, GetAddToEqualityComparerMethod(equalityComparisonHelper, field));
				instructions.Add(CilOpCodes.Stloc, fieldResultLocal);

				CilInstructionLabel notFalseLabel = new();
				instructions.Add(CilOpCodes.Ldloc, fieldResultLocal);
				instructions.Add(CilOpCodes.Call, isFalseMethod);
				instructions.Add(CilOpCodes.Brfalse, notFalseLabel);
				instructions.Add(CilOpCodes.Call, getFalseMethod);
				instructions.Add(CilOpCodes.Ret);
				notFalseLabel.Instruction = instructions.Add(CilOpCodes.Nop);

				CilInstructionLabel nextFieldLabel = new();
				instructions.Add(CilOpCodes.Ldloc, fieldResultLocal);
				instructions.Add(CilOpCodes.Call, isNullMethod);
				instructions.Add(CilOpCodes.Brfalse, nextFieldLabel);
				instructions.Add(CilOpCodes.Call, getNullMethod);
				instructions.Add(CilOpCodes.Stloc, resultLocal);
				nextFieldLabel.Instruction = instructions.Add(CilOpCodes.Nop);
			}
		}

		if (root.ClassInstance.Group.ID is 114 or 2089858483) // MonoBehaviour or ScriptedImporter
		{
			MethodDefinition structureEqualsMethod = equalityComparisonHelper.GetMethodByName(nameof(EqualityComparisonHelper.MonoBehaviourStructureEquals));

			// The structure field doesn't exist yet, so we work around that by creating a MemberReference.
			MemberReference structureField = new MemberReference(type, "m_Structure", new FieldSignature(structureEqualsMethod.Signature!.ParameterTypes[0]));

			CilLocalVariable fieldResultLocal = instructions.AddLocalVariable(trileanTypeSignature);

			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, structureField);
			instructions.Add(CilOpCodes.Ldloc, otherLocal);
			instructions.Add(CilOpCodes.Ldfld, structureField);
			instructions.Add(CilOpCodes.Ldarg_2);
			instructions.Add(CilOpCodes.Call, structureEqualsMethod);
			instructions.Add(CilOpCodes.Stloc, fieldResultLocal);

			CilInstructionLabel notFalseLabel = new();
			instructions.Add(CilOpCodes.Ldloc, fieldResultLocal);
			instructions.Add(CilOpCodes.Call, isFalseMethod);
			instructions.Add(CilOpCodes.Brfalse, notFalseLabel);
			instructions.Add(CilOpCodes.Call, getFalseMethod);
			instructions.Add(CilOpCodes.Ret);
			notFalseLabel.Instruction = instructions.Add(CilOpCodes.Nop);

			CilInstructionLabel nextFieldLabel = new();
			instructions.Add(CilOpCodes.Ldloc, fieldResultLocal);
			instructions.Add(CilOpCodes.Call, isNullMethod);
			instructions.Add(CilOpCodes.Brfalse, nextFieldLabel);
			instructions.Add(CilOpCodes.Call, getNullMethod);
			instructions.Add(CilOpCodes.Stloc, resultLocal);
			nextFieldLabel.Instruction = instructions.Add(CilOpCodes.Nop);
		}

		instructions.Add(CilOpCodes.Ldloc, resultLocal);
		instructions.Add(CilOpCodes.Ret);
	}

	private static void OverrideAddToEqualityComparer(GeneratedClassInstance instance, MethodDefinition objectEqualsMethod, ITypeDefOrRef iunityAssetBase, ITypeDefOrRef assetEqualityComparer, TypeDefinition equalityComparisonHelper)
	{
		TypeDefinition type = instance.Type;
		MethodDefinition method = type.AddMethod(
			nameof(UnityAssetBase.AddToEqualityComparer),
			Pass063_CreateEmptyMethods.OverrideMethodAttributes,
			equalityComparisonHelper.GetMethodByName(nameof(EqualityComparisonHelper.GetTrue)).Signature!.ReturnType);
		method.AddParameter(iunityAssetBase.ToTypeSignature(), "other");
		method.AddParameter(assetEqualityComparer.ToTypeSignature(), "comparer");
		CilInstructionCollection instructions = method.GetInstructions();

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Callvirt, objectEqualsMethod);
		instructions.Add(CilOpCodes.Call, equalityComparisonHelper.GetMethodByName(nameof(EqualityComparisonHelper.ToTrilean)));
		instructions.Add(CilOpCodes.Ret);
	}

	private static MethodDefinition GenerateEqualsMethod(GeneratedClassInstance instance, TypeNode root, TypeDefinition equalityComparisonHelper)
	{
		TypeDefinition type = instance.Type;
		MethodDefinition method = type.AddMethod(
			nameof(object.Equals),
			InterfaceUtils.InterfaceMethodImplementation,
			SharedState.Instance.Importer.Boolean);
		method.AddParameter(type.ToTypeSignature(), "other");
		CilInstructionCollection instructions = method.GetInstructions();

		CilInstructionLabel falseLabel = new();

		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Brfalse, falseLabel);

		for (int i = 0; i < root.Children.Count; i++)
		{
			FieldNode field = root.Children[i];
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, field.Field);
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.Add(CilOpCodes.Ldfld, field.Field);
			instructions.Add(CilOpCodes.Call, GetEqualsMethod(equalityComparisonHelper, field));

			if (i < root.Children.Count - 1)
			{
				instructions.Add(CilOpCodes.Brfalse, falseLabel);
			}
		}

		CilInstructionLabel returnLabel = new();
		instructions.Add(CilOpCodes.Br, returnLabel);

		falseLabel.Instruction = instructions.Add(CilOpCodes.Ldc_I4_0);

		returnLabel.Instruction = instructions.Add(CilOpCodes.Ret);

		instructions.OptimizeMacros();

		return method;
	}

	private static IMethodDescriptor GetEqualsMethod(TypeDefinition equalityComparisonHelper, FieldNode field)
	{
		if (!equalsMethods.TryGetValue(field.TypeSignature, out IMethodDescriptor? cachedMethod))
		{
			switch (field.Child)
			{
				case DictionaryNode dictionary:
					if (dictionary.Child.Key.Equatable && dictionary.Child.Value.Equatable)
					{
						cachedMethod = equalityComparisonHelper
							.GetMethodByName(nameof(EqualityComparisonHelper.EquatableDictionaryEquals))
							.MakeGenericInstanceMethod(dictionary.KeyTypeSignature, dictionary.ValueTypeSignature);
					}
					else if (dictionary.Child.Key.Equatable && dictionary.Child.Value.Child is ListNode listValue && listValue.Child.Equatable)
					{
						cachedMethod = equalityComparisonHelper
							.GetMethodByName(nameof(EqualityComparisonHelper.EquatableDictionaryListEquals))
							.MakeGenericInstanceMethod(dictionary.KeyTypeSignature, listValue.ElementTypeSignature);
					}
					else
					{
						throw new NotImplementedException();
					}

					break;
				case ListNode list:
					if (list.Child is ListNode childList)
					{
						if (!childList.Child.Equatable)
						{
							throw new NotImplementedException();
						}

						cachedMethod = equalityComparisonHelper
							.GetMethodByName(nameof(EqualityComparisonHelper.EquatableListListEquals))
							.MakeGenericInstanceMethod(childList.ElementTypeSignature);
					}
					else if (!list.Child.Equatable)
					{
						throw new NotImplementedException();
					}
					else
					{
						cachedMethod = equalityComparisonHelper
							.GetMethodByName(nameof(EqualityComparisonHelper.EquatableListEquals))
							.MakeGenericInstanceMethod(list.ElementTypeSignature);
					}
					break;
				case PairNode pair:
					if (!pair.Equatable)
					{
						throw new NotImplementedException();
					}
					goto default;
				case PrimitiveNode primitive:
					if (primitive.TypeSignature is SzArrayTypeSignature)
					{
						Debug.Assert(primitive.TypeSignature is SzArrayTypeSignature { BaseType: CorLibTypeSignature { ElementType: ElementType.U1 } });
						cachedMethod = equalityComparisonHelper.GetMethodByName(nameof(EqualityComparisonHelper.ByteArrayEquals));
					}
					else
					{
						goto default;
					}
					break;
				default:
					cachedMethod = equalityComparisonHelper
						.GetMethodByName(nameof(EqualityComparisonHelper.EquatableEquals))
						.MakeGenericInstanceMethod(field.TypeSignature);
					break;
			}

			equalsMethods.Add(field.TypeSignature, cachedMethod);
		}

		return cachedMethod;
	}

	private static IMethodDescriptor GetAddToEqualityComparerMethod(TypeDefinition equalityComparisonHelper, FieldNode field)
	{
		if (!addToEqualityComparerMethods.TryGetValue(field.TypeSignature, out IMethodDescriptor? cachedMethod))
		{
			switch (field.Child)
			{
				case TypeNode:
					cachedMethod = equalityComparisonHelper
						.GetMethodByName(nameof(EqualityComparisonHelper.AssetEquals))
						.MakeGenericInstanceMethod(field.TypeSignature);
					break;
				case DictionaryNode dictionary:
					if (dictionary.Child.Key.Child is TypeNode or PPtrNode or PrimitiveNode { TypeSignature: not SzArrayTypeSignature }
						&& dictionary.Child.Value.Child is TypeNode or PPtrNode or PrimitiveNode { TypeSignature: not SzArrayTypeSignature })
					{
						cachedMethod = equalityComparisonHelper
							.GetMethodByName(nameof(EqualityComparisonHelper.AssetDictionaryEquals))
							.MakeGenericInstanceMethod(dictionary.KeyTypeSignature, dictionary.ValueTypeSignature);
					}
					else if (dictionary.Child.Key.Child is TypeNode or PPtrNode or PrimitiveNode { TypeSignature: not SzArrayTypeSignature }
						&& dictionary.Child.Value.Child is ListNode childList
						&& childList.Child is TypeNode or PPtrNode or PrimitiveNode { TypeSignature: not SzArrayTypeSignature })
					{
						cachedMethod = equalityComparisonHelper
							.GetMethodByName(nameof(EqualityComparisonHelper.AssetDictionaryListEquals))
							.MakeGenericInstanceMethod(dictionary.KeyTypeSignature, childList.ElementTypeSignature);
					}
					else if (dictionary.Child.Key.Child is PairNode pairKey
						&& pairKey.Key.Child is TypeNode or PPtrNode or PrimitiveNode { TypeSignature: not SzArrayTypeSignature }
						&& pairKey.Value.Child is TypeNode or PPtrNode or PrimitiveNode { TypeSignature: not SzArrayTypeSignature }
						&& dictionary.Child.Value.Child is TypeNode or PPtrNode or PrimitiveNode { TypeSignature: not SzArrayTypeSignature })
					{
						cachedMethod = equalityComparisonHelper
							.GetMethodByName(nameof(EqualityComparisonHelper.AssetDictionaryPairEquals))
							.MakeGenericInstanceMethod(pairKey.Key.TypeSignature, pairKey.Value.TypeSignature, dictionary.ValueTypeSignature);
					}
					else
					{
						//Dictionary<Pair, Asset>
						throw new NotImplementedException();
					}
					break;
				case ListNode list:
					if (list.Child is TypeNode or PPtrNode)
					{
						cachedMethod = equalityComparisonHelper
							.GetMethodByName(nameof(EqualityComparisonHelper.AssetListEquals))
							.MakeGenericInstanceMethod(list.ElementTypeSignature);
					}
					else if (list.Child is PairNode
					{
						Key.Child: TypeNode or PPtrNode or PrimitiveNode { TypeSignature: not SzArrayTypeSignature },
						Value.Child: TypeNode or PPtrNode or PrimitiveNode { TypeSignature: not SzArrayTypeSignature },
					} childPair)
					{
						cachedMethod = equalityComparisonHelper
							.GetMethodByName(nameof(EqualityComparisonHelper.AssetPairListEquals))
							.MakeGenericInstanceMethod(childPair.Key.TypeSignature, childPair.Value.TypeSignature);
					}
					else
					{
						throw new NotImplementedException();
					}
					break;
				case PairNode pair:
					throw new NotImplementedException();
				default:
					throw new InvalidOperationException();
			}

			addToEqualityComparerMethods.Add(field.TypeSignature, cachedMethod);
		}

		return cachedMethod;
	}

	private static MethodDefinition OverrideObjectEquals(GeneratedClassInstance instance, TypeNode root, MethodDefinition equalsMethod)
	{
		TypeDefinition type = instance.Type;
		MethodDefinition method = type.AddMethod(
			nameof(object.Equals),
			MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.Virtual,
			SharedState.Instance.Importer.Boolean);
		method.AddParameter(SharedState.Instance.Importer.Object, "obj");
		CilInstructionCollection instructions = method.GetInstructions();

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Isinst, type);
		instructions.Add(CilOpCodes.Callvirt, equalsMethod);
		instructions.Add(CilOpCodes.Ret);

		return method;
	}

	private static void OverrideGetHashCode(GeneratedClassInstance instance, TypeNode root, ITypeDefOrRef hashCodeType, IMethodDefOrRef addMethod, IMethodDefOrRef toHashCodeMethod)
	{
		TypeDefinition type = instance.Type;
		MethodDefinition method = type.AddMethod(
			nameof(object.GetHashCode),
			MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.Virtual,
			SharedState.Instance.Importer.Int32);
		CilInstructionCollection instructions = method.GetInstructions();

		CilLocalVariable variable = instructions.AddLocalVariable(hashCodeType.ToTypeSignature());

		instructions.Add(CilOpCodes.Ldloca, variable);
		instructions.Add(CilOpCodes.Initobj, hashCodeType);

		foreach (FieldNode field in root.Children)
		{
			instructions.Add(CilOpCodes.Ldloca, variable);
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, field.Field);
			switch (field.Child)
			{
				case DictionaryNode dictionary:
					instructions.Add(CilOpCodes.Callvirt, dictionary.GetCount);
					instructions.Add(CilOpCodes.Call, addMethod.MakeGenericInstanceMethod(SharedState.Instance.Importer.Int32));
					break;
				case ListNode list:
					instructions.Add(CilOpCodes.Callvirt, list.GetCount);
					instructions.Add(CilOpCodes.Call, addMethod.MakeGenericInstanceMethod(SharedState.Instance.Importer.Int32));
					break;
				case PrimitiveNode primitive:
					if (primitive.TypeSignature is SzArrayTypeSignature)
					{
						instructions.Add(CilOpCodes.Ldlen);
						instructions.Add(CilOpCodes.Call, addMethod.MakeGenericInstanceMethod(SharedState.Instance.Importer.Int32));
						break;
					}
					else
					{
						goto default;
					}
				default:
					instructions.Add(CilOpCodes.Call, addMethod.MakeGenericInstanceMethod(field.TypeSignature));
					break;
			}
		}

		instructions.Add(CilOpCodes.Ldloca, variable);
		instructions.Add(CilOpCodes.Call, toHashCodeMethod);
		instructions.Add(CilOpCodes.Ret);

		instructions.OptimizeMacros();
	}

	private static void AddEqualityOperators(GeneratedClassInstance instance, TypeNode root, MethodDefinition equalsMethod)
	{
		//Fine for now, but maybe we should use the equalsMethod to generate the operators.
		instance.Type.AddDefaultEqualityOperators(
			SharedState.Instance.Importer,
			out MethodDefinition equalityMethod,
			out MethodDefinition inequalityMethod);

		equalityMethod.AddNullableContextAttribute(NullableAnnotation.MaybeNull);
		inequalityMethod.AddNullableContextAttribute(NullableAnnotation.MaybeNull);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass410_SetValuesMethods.cs`:

```cs
using AssetRipper.AssemblyDumper.Types;
using System.Collections;
using System.Text;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass410_SetValuesMethods
{
	private const string SetValuesName = "SetValues";

	public static void DoPass()
	{
		foreach (SubclassGroup group in SharedState.Instance.SubclassGroups.Values)
		{
			ProcessGroup(group);
		}
	}

	private static void ProcessGroup(SubclassGroup group)
	{
		if (group.InterfaceProperties.All(prop => prop.HasSetAccessor))
		{
			group.ImplementSetValuesMethod();
		}
	}

	private static void ImplementSetValuesMethod(this SubclassGroup group)
	{
		MethodDefinition interfaceMethod = group.Interface.AddMethod(SetValuesName, InterfaceUtils.InterfaceMethodDeclaration, SharedState.Instance.Importer.Void);
		foreach (PropertyDefinition property in group.GetInterfacePropertiesInOrder())
		{
			interfaceMethod.AddParameter(property.Signature!.ReturnType, GetParameterName(property.Name));
		}

		foreach (GeneratedClassInstance instance in group.Instances)
		{
			MethodDefinition method = instance.Type.AddMethod(SetValuesName, InterfaceUtils.InterfaceMethodImplementation, SharedState.Instance.Importer.Void);
			CilInstructionCollection instructions = method.GetInstructions();
			IEnumerable<PropertyDefinition> properties = group.IsVector4()
				? new Vector4PropertyEnumerable_Instance(instance)
				: group.IsColorRGBAf()
					? new ColorPropertyEnumerable_Instance(instance)
					: instance.Properties.Select(c => c.Definition);
			foreach (PropertyDefinition property in properties)
			{
				Parameter parameter = method.AddParameter(property.Signature!.ReturnType, GetParameterName(property.Name));
				instructions.Add(CilOpCodes.Ldarg_0);
				instructions.Add(CilOpCodes.Ldarg, parameter);
				instructions.Add(CilOpCodes.Call, property.SetMethod ?? throw new Exception("Set method can't be null"));
			}
			instructions.Add(CilOpCodes.Ret);
			instructions.OptimizeMacros();
		}
	}

	private static IEnumerable<PropertyDefinition> GetInterfacePropertiesInOrder(this SubclassGroup group)
	{
		return group.IsVector4()
			? new Vector4PropertyEnumerable_Group(group)
			: group.IsColorRGBAf()
				? new ColorPropertyEnumerable_Group(group)
				: group.InterfaceProperties.Select(i => i.Definition);
	}

	private static string GetParameterName(string? propertyName)
	{
		if (string.IsNullOrEmpty(propertyName))
		{
			throw new Exception("Property name cannot be null or empty");
		}

		StringBuilder sb = new StringBuilder(propertyName.Length);
		sb.Append(char.ToLowerInvariant(propertyName[0]));
		if (propertyName.Length > 1)
		{
			sb.Append(propertyName.AsSpan(1));
		}
		return sb.ToString();
	}

	private static bool IsVector4(this SubclassGroup group) => group.Name is "Vector4f" or "Vector4Float" or "Quaternionf";
	private abstract class Vector4PropertyEnumerableBase : IEnumerable<PropertyDefinition>
	{
		public IEnumerator<PropertyDefinition> GetEnumerator()
		{
			yield return GetProperty("X");
			yield return GetProperty("Y");
			yield return GetProperty("Z");
			yield return GetProperty("W");
		}
		protected abstract PropertyDefinition GetProperty(string propertyName);
		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
	}
	private sealed class Vector4PropertyEnumerable_Instance : Vector4PropertyEnumerableBase
	{
		private readonly GeneratedClassInstance instance;
		public Vector4PropertyEnumerable_Instance(GeneratedClassInstance instance) => this.instance = instance;
		protected override PropertyDefinition GetProperty(string propertyName)
		{
			return instance.Properties.Select(c => c.Definition).Single(property => property.Name == propertyName);
		}
	}
	private sealed class Vector4PropertyEnumerable_Group : Vector4PropertyEnumerableBase
	{
		private readonly SubclassGroup group;
		public Vector4PropertyEnumerable_Group(SubclassGroup group) => this.group = group;
		protected override PropertyDefinition GetProperty(string propertyName)
		{
			return group.InterfaceProperties.Select(i => i.Definition).Single(property => property.Name == propertyName);
		}
	}

	private static bool IsColorRGBAf(this SubclassGroup group) => group.Name is "ColorRGBAf";
	private abstract class ColorPropertyEnumerableBase : IEnumerable<PropertyDefinition>
	{
		public IEnumerator<PropertyDefinition> GetEnumerator()
		{
			yield return GetProperty("R");
			yield return GetProperty("G");
			yield return GetProperty("B");
			yield return GetProperty("A");
		}
		protected abstract PropertyDefinition GetProperty(string propertyName);
		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
	}
	private sealed class ColorPropertyEnumerable_Instance : ColorPropertyEnumerableBase
	{
		private readonly GeneratedClassInstance instance;
		public ColorPropertyEnumerable_Instance(GeneratedClassInstance instance) => this.instance = instance;
		protected override PropertyDefinition GetProperty(string propertyName)
		{
			return instance.Properties.Select(c => c.Definition).Single(property => property.Name == propertyName);
		}
	}
	private sealed class ColorPropertyEnumerable_Group : ColorPropertyEnumerableBase
	{
		private readonly SubclassGroup group;
		public ColorPropertyEnumerable_Group(SubclassGroup group) => this.group = group;
		protected override PropertyDefinition GetProperty(string propertyName)
		{
			return group.InterfaceProperties.Select(i => i.Definition).Single(property => property.Name == propertyName);
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass500_PPtrFixes.cs`:

```cs
using AssetRipper.AssemblyDumper.Documentation;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass500_PPtrFixes
{
	public static void DoPass()
	{
		foreach (SubclassGroup group in SharedState.Instance.SubclassGroups.Values)
		{
			if (group.IsPPtr)
			{
				foreach (GeneratedClassInstance instance in group.Instances)
				{
					TypeDefinition parameterType = Pass080_PPtrConversions.PPtrsToParameters[instance.Type];

					//DebuggerDisplay
					{
						string parameterTypeName = group.Name.Substring("PPtr_".Length);
						instance.Type.AddDebuggerDisplayAttribute($"{parameterTypeName} FileID: {{FileID}} PathID: {{PathID}}");
					}

					//Documentation
					{
						DocumentationHandler.AddTypeDefinitionLine(instance.Type, $"{SeeXmlTagGenerator.MakeCRef(typeof(PPtr))} for {SeeXmlTagGenerator.MakeCRef(parameterType)}");
					}
				}
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass501_MonoBehaviourImplementation.cs`:

```cs
using AssetRipper.AssemblyDumper.Documentation;
using AssetRipper.AssemblyDumper.InjectedTypes;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;

namespace AssetRipper.AssemblyDumper.Passes;

/// <summary>
/// Adds to the IMonoBehaviour and IScriptedImporter interfaces. Also fixes the read and yaml methods
/// </summary>
public static class Pass501_MonoBehaviourImplementation
{
	public static void DoPass()
	{
		TypeDefinition monoBehaviourHelperType = SharedState.Instance.InjectHelperType(typeof(MonoBehaviourHelper));
		TypeSignature propertyType = SharedState.Instance.Importer.ImportTypeSignature<IUnityAssetBase>();

		//MonoBehaviour
		ApplyChangesToGroup(SharedState.Instance.ClassGroups[114], monoBehaviourHelperType, propertyType);

		//ScriptedImporter
		ApplyChangesToGroup(SharedState.Instance.ClassGroups[2089858483], monoBehaviourHelperType, propertyType);
	}

	private static void ApplyChangesToGroup(ClassGroup group, TypeDefinition monoBehaviourHelperType, TypeSignature propertyType)
	{
		const string propertyName = "Structure";
		const string fieldName = "m_" + propertyName;

		PropertyDefinition interfaceProperty = group.Interface.AddFullProperty(propertyName, InterfaceUtils.InterfacePropertyDeclaration, propertyType)
			.AddNullableAttributesForMaybeNull();

		foreach (GeneratedClassInstance instance in group.Instances)
		{
			FieldDefinition structureField = instance.Type.AddField(fieldName, propertyType, visibility: Visibility.Internal);
			structureField
				.AddNullableAttributesForMaybeNull()
				.AddDebuggerBrowsableNeverAttribute();

			PropertyDefinition property = instance.Type.ImplementFullProperty(propertyName, InterfaceUtils.InterfacePropertyImplementation, null, structureField)
				.AddNullableAttributesForMaybeNull();

			DocumentationHandler.AddPropertyDefinitionLine(property, "The custom structure of this asset, based on the instance fields of its MonoScript.");

			instance.Type.AddWalkStructure(structureField, monoBehaviourHelperType, "Editor");
			instance.Type.AddWalkStructure(structureField, monoBehaviourHelperType, "Release");
			instance.Type.AddWalkStructure(structureField, monoBehaviourHelperType, "Standard");

			instance.Type.AddStructureFetchDependencies(structureField, monoBehaviourHelperType);

			instance.Type.AddStructureReset(structureField, monoBehaviourHelperType);

			instance.Type.AddStructureCopyValues(structureField, interfaceProperty, monoBehaviourHelperType);
		}
	}

	private static void AddWalkStructure(this TypeDefinition type, FieldDefinition field, TypeDefinition monoBehaviourHelperType, string walkType)
	{
		string targetMethodName = walkType switch
		{
			"Editor" => nameof(UnityAssetBase.WalkEditor),
			"Release" => nameof(UnityAssetBase.WalkRelease),
			"Standard" => nameof(UnityAssetBase.WalkStandard),
			_ => throw new ArgumentException(null, nameof(walkType)),
		};

		MethodDefinition method = type.Methods.Single(m => m.Name == targetMethodName);

		string injectedMethodName = walkType switch
		{
			"Editor" => nameof(MonoBehaviourHelper.MaybeWalkStructureEditor),
			"Release" => nameof(MonoBehaviourHelper.MaybeWalkStructureRelease),
			"Standard" => nameof(MonoBehaviourHelper.MaybeWalkStructureStandard),
			_ => throw new ArgumentException(null, nameof(walkType)),
		};

		IMethodDefOrRef walkStructureMethod = monoBehaviourHelperType.Methods.Single(m => m.Name == injectedMethodName);

		CilInstructionCollection instructions = method.CilMethodBody!.Instructions;

		int insertIndex = FindLastNop(instructions) + 1;

		//Insert the opcodes in reverse order, so that we don't have to adjust the insert index.
		instructions.Insert(insertIndex, CilOpCodes.Call, walkStructureMethod);
		instructions.Insert(insertIndex, CilOpCodes.Ldarg_1);//walker
		instructions.Insert(insertIndex, CilOpCodes.Ldfld, field);//the structure field
		instructions.Insert(insertIndex, CilOpCodes.Ldarg_0);//this
		instructions.Insert(insertIndex, CilOpCodes.Ldarg_0);//this

		static int FindLastNop(CilInstructionCollection instructions)
		{
			for (int i = instructions.Count - 1; i >= 0; i--)
			{
				if (instructions[i].OpCode == CilOpCodes.Nop)
				{
					return i;
				}
			}
			throw new Exception("No nop found");
		}
	}

	private static void AddStructureFetchDependencies(this TypeDefinition type, FieldDefinition field, TypeDefinition monoBehaviourHelperType)
	{
		MethodDefinition method = type.Methods.Single(m => m.Name == nameof(UnityAssetBase.FetchDependencies));
		IMethodDefOrRef fetchDependenciesMethod = monoBehaviourHelperType.Methods.Single(m => m.Name == nameof(MonoBehaviourHelper.MaybeAppendStructureDependencies));
		CilInstructionCollection instructions = method.CilMethodBody!.Instructions;
		instructions.Pop(); //pop the return value
		instructions.Add(CilOpCodes.Ldarg_0);//this
		instructions.Add(CilOpCodes.Ldfld, field);//the structure field
		instructions.Add(CilOpCodes.Call, fetchDependenciesMethod);
		instructions.Add(CilOpCodes.Ret);
	}

	private static void AddStructureReset(this TypeDefinition type, FieldDefinition field, TypeDefinition monoBehaviourHelperType)
	{
		MethodDefinition method = type.Methods.Single(m => m.Name == nameof(UnityAssetBase.Reset));
		IMethodDefOrRef resetMethod = monoBehaviourHelperType.Methods.Single(m => m.Name == nameof(MonoBehaviourHelper.ResetStructure));
		CilInstructionCollection instructions = method.CilMethodBody!.Instructions;
		instructions.Pop(); //pop the return value
		instructions.Add(CilOpCodes.Ldarg_0);//this
		instructions.Add(CilOpCodes.Ldfld, field);//the structure field
		instructions.Add(CilOpCodes.Call, resetMethod);
		instructions.Add(CilOpCodes.Ret);
	}

	private static void AddStructureCopyValues(this TypeDefinition type, FieldDefinition field, PropertyDefinition interfaceProperty, TypeDefinition monoBehaviourHelperType)
	{
		MethodDefinition method = type.Methods.Single(m => m.Name == nameof(UnityAssetBase.CopyValues) && m.IsFinal && m.Parameters.Count == 2);
		IMethodDefOrRef copyValuesMethod = monoBehaviourHelperType.Methods.Single(m => m.Name == nameof(MonoBehaviourHelper.CopyStructureValues));
		CilInstructionCollection instructions = method.CilMethodBody!.Instructions;
		instructions.Pop(); //pop the return value
		instructions.Add(CilOpCodes.Ldarg_0);//this
		instructions.Add(CilOpCodes.Ldflda, field);//the structure field
		instructions.Add(CilOpCodes.Ldarg_1);//source
		instructions.Add(CilOpCodes.Callvirt, interfaceProperty.GetMethod!);//the Structure property
		instructions.Add(CilOpCodes.Ldarg_2);//converter
		instructions.Add(CilOpCodes.Call, copyValuesMethod);
		instructions.Add(CilOpCodes.Ret);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass502_FixGuidAndHashYaml.cs`:

```cs
using AssetRipper.AssemblyDumper.InjectedTypes;
using AssetRipper.AssemblyDumper.Types;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass502_FixGuidAndHashYaml
{
	public static void DoPass()
	{
		foreach (TypeDefinition guidType in SharedState.Instance.SubclassGroups["GUID"].Types)
		{
			MethodDefinition toStringMethod = guidType.AddGuidToStringOverride();
		}
		TypeDefinition helperType = SharedState.Instance.InjectHelperType(typeof(HashHelper));
		foreach (TypeDefinition hashType in SharedState.Instance.SubclassGroups["Hash128"].Types)
		{
			hashType.AddHashToStringOverride(helperType);
		}
	}

	private static MethodDefinition AddGuidToStringOverride(this TypeDefinition type)
	{
		MethodDefinition method = type.AddMethod(nameof(object.ToString), MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.Virtual, type.DeclaringModule!.CorLibTypeFactory.String);
		MethodDefinition conversionMethod = type.Methods.Single(m => m.Name == "op_Implicit");
		ITypeDefOrRef commonRef = SharedState.Instance.Importer.ImportType<UnityGuid>();
		IMethodDefOrRef toStringMethod = SharedState.Instance.Importer.ImportMethod<UnityGuid>(m => m.Name == nameof(UnityGuid.ToString) && m.Parameters.Count == 0);

		CilInstructionCollection instructions = method.GetInstructions();
		CilLocalVariable local = instructions.AddLocalVariable(commonRef.ToTypeSignature());
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, conversionMethod);
		instructions.Add(CilOpCodes.Stloc, local);
		instructions.Add(CilOpCodes.Ldloca, local);
		instructions.Add(CilOpCodes.Call, toStringMethod);
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();

		return method;
	}

	private static MethodDefinition AddHashToStringOverride(this TypeDefinition type, TypeDefinition helperType)
	{
		MethodDefinition method = type.AddMethod(nameof(object.ToString), MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.Virtual, type.DeclaringModule!.CorLibTypeFactory.String);
		IMethodDefOrRef helperMethod = helperType.Methods.Single(m => m.Name == nameof(HashHelper.ToString));

		CilInstructionCollection instructions = method.GetInstructions();
		instructions.AddLoadAllHashFields(type);
		instructions.Add(CilOpCodes.Call, helperMethod);
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();

		return method;
	}

	private static void AddLoadAllHashFields(this CilInstructionCollection instructions, TypeDefinition type)
	{
		for (int i = 0; i < 16; i++)
		{
			FieldDefinition field = type.GetFieldByName(GetHashFieldName(i));
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldfld, field);
		}
	}

	private static string GetHashFieldName(int i)
	{
		return i < 10 ? $"m_Bytes__{i}" : $"m_Bytes_{i}";
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass504_FixShaderName.cs`:

```cs
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass504_FixShaderName
{
	public static void DoPass()
	{
		int id = SharedState.Instance.NameToTypeID["Shader"].Single();
		ClassGroup group = SharedState.Instance.ClassGroups[id];
		foreach (TypeDefinition type in group.Types)
		{
			type.FixShaderTypeDefinition();
		}
	}

	private static void FixShaderTypeDefinition(this TypeDefinition type)
	{
		FieldDefinition nameField = type.GetFieldByName("m_Name", true);
		FieldDefinition? parsedFormField = type.TryGetFieldByName("m_ParsedForm");
		if (parsedFormField is null)
		{
			return;
		}

		if (parsedFormField.Signature?.FieldType.ToTypeDefOrRef() is not TypeDefinition serializedShaderDefinition)
		{
			throw new NullReferenceException($"{nameof(serializedShaderDefinition)} is null");
		}

		FieldDefinition? parsedFormNameField = serializedShaderDefinition.TryGetFieldByName("m_Name");
		if (parsedFormNameField is null)
		{
			throw new NullReferenceException($"{nameof(parsedFormNameField)} is null");
		}

		type.Methods.Single(m => m.Name == nameof(UnityAssetBase.ReadRelease))
			.AddCopyString(nameField, parsedFormField, parsedFormNameField);
		type.Methods.Single(m => m.Name == nameof(UnityAssetBase.ReadEditor))
			.AddCopyString(nameField, parsedFormField, parsedFormNameField);
	}

	private static void AddCopyString(
		this MethodDefinition method,
		FieldDefinition nameField,
		FieldDefinition parsedFormField,
		FieldDefinition parsedFormNameField)
	{
		CilInstructionCollection instructions = method.CilMethodBody!.Instructions;
		instructions.Pop();//Remove the return
		instructions.Add(CilOpCodes.Ldarg_0);

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, parsedFormField);
		instructions.Add(CilOpCodes.Ldfld, parsedFormNameField);

		instructions.Add(CilOpCodes.Stfld, nameField);
		instructions.Add(CilOpCodes.Ret);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass505_FixOldAudioClip.cs`:

```cs
using AssetRipper.AssemblyDumper.InjectedTypes;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass505_FixOldAudioClip
{
	public static void DoPass()
	{
		TypeDefinition helperType = SharedState.Instance.InjectHelperType(typeof(AudioClipHelper));
		MethodDefinition helperMethod = helperType.Methods.Single(m => m.Name == nameof(AudioClipHelper.ReadOldByteArray));

		foreach (GeneratedClassInstance instance in SharedState.Instance.ClassGroups[83].Instances)
		{
			if (instance.TryGetStreamField(out FieldDefinition? streamField))
			{
				MethodDefinition readReleaseMethod = instance.Type.Methods.Single(m => m.Name == nameof(UnityObjectBase.ReadRelease));
				MethodDefinition readEditorMethod = instance.Type.Methods.Single(m => m.Name == nameof(UnityObjectBase.ReadEditor));
				FieldDefinition dataField = instance.Type.GetFieldByName("m_AudioData");
				FixMethod(readReleaseMethod, helperMethod, dataField, streamField);
				FixMethod(readEditorMethod, helperMethod, dataField, streamField);
			}
		}
	}

	private static void FixMethod(MethodDefinition readMethod, MethodDefinition helperMethod, FieldDefinition dataField, FieldDefinition streamField)
	{
		CilInstructionCollection instructions = readMethod.GetInstructions();

		//remove bad instructions
		while (instructions.Count > 0)
		{
			int index = instructions.Count - 1;
			CilInstruction instruction = instructions[index];
			instructions.RemoveAt(index);
			if (instruction.OpCode == CilOpCodes.Ldarg_0)
			{
				break;
			}
		}

		instructions.Add(CilOpCodes.Ldarg_0);//for the store field

		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, streamField);
		instructions.Add(CilOpCodes.Call, helperMethod);

		instructions.Add(CilOpCodes.Stfld, dataField);

		instructions.Add(CilOpCodes.Ret);
	}

	private static bool TryGetStreamField(this GeneratedClassInstance instance, [NotNullWhen(true)] out FieldDefinition? streamField)
	{
		if (instance.Type.TryGetFieldByName("m_Stream", out streamField))
		{
			CorLibTypeSignature? fieldType = streamField.Signature?.FieldType as CorLibTypeSignature;
			if (fieldType is not null && fieldType.ElementType == ElementType.I4)
			{
				return true;
			}
			else
			{
				streamField = null;
				return false;
			}
		}
		else
		{
			return false;
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass506_FixUnityConnectSettings.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.IO.Endian;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass506_FixUnityConnectSettings
{
	/// <summary>
	/// On some platforms, the UnityConnectSettings asset doesn't contain any settings. As this is platform specific, it is not reflected in the type trees.
	/// </summary>
	public static void DoPass()
	{
		foreach (GeneratedClassInstance instance in SharedState.Instance.ClassGroups[310].Instances)
		{
			FixMethod(instance.Type.Methods.Single(m => m.Name == nameof(UnityAssetBase.ReadRelease)));
			FixMethod(instance.Type.Methods.Single(m => m.Name == nameof(UnityAssetBase.ReadEditor)));
		}
	}

	private static void FixMethod(MethodDefinition method)
	{
		CilInstructionCollection instructions = method.GetInstructions();
		InsertInstructions(instructions, FindInsertionPoint(instructions));
	}

	private static int FindInsertionPoint(CilInstructionCollection instructions)
	{
		for (int i = 0; i < instructions.Count; i++)
		{
			CilInstruction instruction = instructions[i];
			if (instruction.OpCode == CilOpCodes.Ldfld
				&& instruction.Operand is FieldDefinition field
				&& (field.Name == "m_UnityPurchasingSettings" || field.Name == "m_CrashReportingSettings"))
			{
				//ldarg.0  asset
				//ldfld    field
				//ldarg.1  reader
				//callvirt ReadRelease

				return i - 1;
			}
		}
		throw new Exception("Could not determine the insertion point");
	}

	private static void InsertInstructions(CilInstructionCollection instructions, int insertionPoint)
	{
		ICilLabel returnLabel = instructions[instructions.Count - 1].CreateLabel();
		instructions.Insert(insertionPoint, new CilInstruction(CilOpCodes.Brtrue, returnLabel));
		instructions.Insert(insertionPoint, new CilInstruction(CilOpCodes.Ceq));

		IMethodDefOrRef getLength = SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == $"get_{nameof(EndianSpanReader.Length)}");
		IMethodDefOrRef getPosition = SharedState.Instance.Importer.ImportMethod(typeof(EndianSpanReader), m => m.Name == $"get_{nameof(EndianSpanReader.Position)}");

		instructions.Insert(insertionPoint, new CilInstruction(CilOpCodes.Call, getLength));
		instructions.Insert(insertionPoint, new CilInstruction(CilOpCodes.Ldarg_1));

		instructions.Insert(insertionPoint, new CilInstruction(CilOpCodes.Call, getPosition));
		instructions.Insert(insertionPoint, new CilInstruction(CilOpCodes.Ldarg_1));

		instructions.OptimizeMacros();
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass507_InjectedProperties.cs`:

```cs
using AssetRipper.Assets.Collections;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass507_InjectedProperties
{
	public const string TargetSceneName = "TargetScene";

	public static void DoPass()
	{
		SceneAssetTargetScene();
	}

	private static void SceneAssetTargetScene()
	{
		ClassGroup group = SharedState.Instance.ClassGroups[1032]; //SceneAsset
		TypeSignature propertyType = SharedState.Instance.Importer.ImportType<SceneDefinition>().ToTypeSignature();
		PropertyInjector.InjectFullProperty(group, propertyType, TargetSceneName, true);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass508_LazySceneObjectIdentifier.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass508_LazySceneObjectIdentifier
{
	public const string TargetObjectName = "TargetObjectReference";
	public const string TargetPrefabName = "TargetPrefabReference";
	public static void DoPass()
	{
		TypeSignature unityObjectBase = SharedState.Instance.Importer.ImportType<IUnityObjectBase>().ToTypeSignature();

		SubclassGroup group = SharedState.Instance.SubclassGroups["SceneObjectIdentifier"];
		PropertyInjector.InjectFullProperty(group, unityObjectBase, TargetObjectName, true);
		PropertyInjector.InjectFullProperty(group, unityObjectBase, TargetPrefabName, true);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass510_FixComponentPairWalking.cs`:

```cs
using AssetRipper.AssemblyDumper.InjectedTypes;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass510_FixComponentPairWalking
{
	public static void DoPass()
	{
		TypeDefinition walkingHelperType = SharedState.Instance.InjectHelperType(typeof(WalkingHelper));
		MethodDefinition releaseMethod = walkingHelperType.Methods.Single(m => m.Name == nameof(WalkingHelper.WalkComponentPairRelease));
		MethodDefinition editorMethod = walkingHelperType.Methods.Single(m => m.Name == nameof(WalkingHelper.WalkComponentPairEditor));
		MethodDefinition standardMethod = walkingHelperType.Methods.Single(m => m.Name == nameof(WalkingHelper.WalkComponentPairStandard));
		SubclassGroup componentPairGroup = SharedState.Instance.SubclassGroups["ComponentPair"];
		foreach (GeneratedClassInstance instance in componentPairGroup.Instances)
		{
			ClassProperty classId = instance.Properties.First(p => p.Name == "ClassID");
			ClassProperty component = instance.Properties.First(p => p.Name == "Component");
			if (!classId.IsPresent)
			{
				continue;
			}

			instance.Type.GetMethodByName(nameof(IUnityAssetBase.WalkRelease)).FixWalkMethod(releaseMethod, classId.BackingField, component.BackingField!);
			instance.Type.GetMethodByName(nameof(IUnityAssetBase.WalkEditor)).FixWalkMethod(editorMethod, classId.BackingField, component.BackingField!);
			instance.Type.GetMethodByName(nameof(IUnityAssetBase.WalkStandard)).FixWalkMethod(standardMethod, classId.BackingField, component.BackingField!);
		}
	}

	private static void FixWalkMethod(this MethodDefinition method, MethodDefinition injectedMethod, FieldDefinition classIDField, FieldDefinition componentField)
	{
		CilInstructionCollection instructions = method.GetInstructions();
		instructions.Clear();
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, classIDField);
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, componentField);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Call, injectedMethod.MakeGenericInstanceMethod(componentField.Signature!.FieldType));
		instructions.Add(CilOpCodes.Ret);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass555_CreateCommonString.cs`:

```cs
using AssetRipper.AssemblyDumper.Attributes;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass555_CreateCommonString
{
	public static void DoPass()
	{
		ThrowIfStringCountIsWrong();
		TypeDefinition newTypeDef = StaticClassCreator.CreateEmptyStaticClass(SharedState.Instance.Module, SharedState.RootNamespace, "CommonString");

		GenericInstanceTypeSignature readOnlyUintStringDictionary = SharedState.Instance.Importer.ImportType(typeof(IReadOnlyDictionary<,>))
			.MakeGenericInstanceType(SharedState.Instance.Importer.UInt32, SharedState.Instance.Importer.String);
		GenericInstanceTypeSignature uintStringDictionary = SharedState.Instance.Importer.ImportType(typeof(Dictionary<,>))
			.MakeGenericInstanceType(SharedState.Instance.Importer.UInt32, SharedState.Instance.Importer.String);
		IMethodDefOrRef dictionaryConstructor = MethodUtils.MakeConstructorOnGenericType(SharedState.Instance.Importer, uintStringDictionary, 0);
		IMethodDefOrRef addMethod = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, uintStringDictionary, SharedState.Instance.Importer.LookupMethod(typeof(Dictionary<,>), m => m.Name == "Add"));

		const string propertyName = "Dictionary";
		FieldDefinition field = newTypeDef.AddField($"<{propertyName}>k__BackingField", readOnlyUintStringDictionary, true, Visibility.Private);
		field.Attributes |= FieldAttributes.InitOnly;
		field.AddCompilerGeneratedAttribute(SharedState.Instance.Importer);

		MethodDefinition staticConstructor = newTypeDef.AddEmptyConstructor(true);
		CilInstructionCollection instructions = staticConstructor.GetInstructions();
		instructions.Add(CilOpCodes.Newobj, dictionaryConstructor);
		foreach ((uint index, string str) in SharedState.Instance.CommonString.Strings)
		{
			instructions.Add(CilOpCodes.Dup);
			instructions.Add(CilOpCodes.Ldc_I4, (int)index);
			instructions.Add(CilOpCodes.Ldstr, str);
			instructions.Add(CilOpCodes.Call, addMethod);
		}
		instructions.Add(CilOpCodes.Stsfld, field);
		instructions.Add(CilOpCodes.Ret);

		instructions.OptimizeMacros();

		newTypeDef.ImplementGetterProperty(
				propertyName,
				MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.SpecialName,
				readOnlyUintStringDictionary,
				field)
			.GetMethod!.AddCompilerGeneratedAttribute(SharedState.Instance.Importer);
	}

	private static void ThrowIfStringCountIsWrong()
	{
		int count = SharedState.Instance.CommonString.Strings.Count;
		if (count != 112)
		{
			throw new Exception($"The size of Common String has changed! {count}");
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass556_CreateClassIDTypeEnum.cs`:

```cs
using AssetRipper.AssemblyDumper.Documentation;
using AssetRipper.AssemblyDumper.Types;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass556_CreateClassIDTypeEnum
{
	public static Dictionary<FieldDefinition, ClassGroup> FieldGroupDictionary { get; } = new();
	public static TypeDefinition? ClassIdTypeDefintion { get; private set; }

	public static void DoPass()
	{
		Dictionary<int, ClassGroup> classIdDictionary = CreateClassIdDictionary();
		Dictionary<string, long> nameDictionary = CreateNameDictionary(classIdDictionary);
		ClassIdTypeDefintion = EnumCreator.CreateFromDictionary(SharedState.Instance, SharedState.RootNamespace, "ClassIDType", nameDictionary);

		List<KeyValuePair<string, long>> alphabeticalList = nameDictionary.ToList();
		alphabeticalList.Sort((a, b) => a.Key.CompareTo(b.Key));
		TypeDefinition alphabeticalEnum = EnumCreator.CreateFromDictionary(SharedState.Instance, SharedState.RootNamespace, "ClassIDTypeAlphabetical", alphabeticalList);
		alphabeticalEnum.IsPublic = false;

		foreach (FieldDefinition field in ClassIdTypeDefintion.Fields)
		{
			if (field.IsStatic)
			{
				int id = (int)nameDictionary[field.Name!];
				FieldGroupDictionary.Add(field, classIdDictionary[id]);
			}
		}
		foreach (FieldDefinition field in alphabeticalEnum.Fields)
		{
			if (field.IsStatic)
			{
				int id = (int)nameDictionary[field.Name!];
				FieldGroupDictionary.Add(field, classIdDictionary[id]);
			}
		}

		string documentationString = $"This enum is an identifier for the {nameDictionary.Count} Unity object types.";
		DocumentationHandler.AddTypeDefinitionLine(ClassIdTypeDefintion, documentationString);
		DocumentationHandler.AddTypeDefinitionLine(alphabeticalEnum, documentationString);

		Console.WriteLine($"\t{nameDictionary.Count} ClassIDType numbers.");
	}

	private static Dictionary<string, long> CreateNameDictionary(Dictionary<int, ClassGroup> classIdDictionary)
	{
		HashSet<string> duplicateNames = GetDuplicates(classIdDictionary.Values.Select(g => g.Name));
		Dictionary<string, long> result = new Dictionary<string, long>(classIdDictionary.Count);
		foreach ((int id, ClassGroup group) in classIdDictionary.OrderBy(pair => pair.Key))
		{
			string rawName = group.Name;
			if (duplicateNames.Contains(rawName))
			{
				result.Add($"{rawName}_{id}", id);
			}
			else
			{
				result.Add(rawName, id);
			}
		}
		return result;
	}

	private static Dictionary<int, ClassGroup> CreateClassIdDictionary()
	{
		Dictionary<int, ClassGroup> rawDictionary = SharedState.Instance.ClassGroups.ToDictionary(pair => pair.Key, pair => pair.Value);
		foreach ((int mainID, IReadOnlyList<int> idList) in Pass001_MergeMovedGroups.Changes)
		{
			ClassGroup group = SharedState.Instance.ClassGroups[mainID];
			foreach (int id in idList)
			{
				rawDictionary.Add(id, group);
			}
		}

		return rawDictionary;
	}

	private static HashSet<string> GetDuplicates(IEnumerable<string> rawStrings)
	{
		HashSet<string> uniqueStrings = new();
		HashSet<string> duplicates = new();
		foreach (string str in rawStrings)
		{
			if (uniqueStrings.Add(str))
			{
			}
			else
			{
				duplicates.Add(str);
			}
		}
		return duplicates;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass557_CreateSourceTpkClass.cs`:

```cs
using AsmResolver;
using AssetRipper.AssemblyDumper.Attributes;
using AssetRipper.AssemblyDumper.Documentation;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass557_CreateSourceTpkClass
{
	public static void DoPass()
	{
		//Type Tree
		{
			TypeDefinition type = StaticClassCreator.CreateEmptyStaticClass(SharedState.Instance.Module, SharedState.RootNamespace, "SourceTpk");
			FieldDefinition field = CreateInternalStorageClass("SourceTpkData", SharedState.Instance.TpkData);
			AddGetStreamMethod(type, field);
			AddDataProperty(type, field);
			AddVersionsProperty(type, SharedState.Instance.SourceVersions);

			DocumentationHandler.AddTypeDefinitionLine(type, "Type Trees are used in the AssetRipper source generation.");
			DocumentationHandler.AddTypeDefinitionLine(type, $"This data is sourced from {SharedState.Instance.SourceVersions.Length} versions of Unity.");
			DocumentationHandler.AddTypeDefinitionLine(type, $"See: {SeeXmlTagGenerator.MakeHRef(@"https://github.com/AssetRipper/TypeTreeDumps")}");
		}

		//Engine Assets
		{
			TypeDefinition type = StaticClassCreator.CreateEmptyStaticClass(SharedState.Instance.Module, SharedState.RootNamespace, "EngineAssetsTpk");
			FieldDefinition field = CreateInternalStorageClass("EngineAssetsTpkData", File.ReadAllBytes("engine_assets.tpk"));
			AddGetStreamMethod(type, field);
			AddDataProperty(type, field);

			DocumentationHandler.AddTypeDefinitionLine(type, "Engine Assets are embedded during the AssetRipper source generation.");
			DocumentationHandler.AddTypeDefinitionLine(type, $"This data is sourced from many versions of Unity.");
			DocumentationHandler.AddTypeDefinitionLine(type, $"See: {SeeXmlTagGenerator.MakeHRef(@"https://github.com/AssetRipper/DocumentationDumps")}");
		}

		//Assemblies
		{
			TypeDefinition type = StaticClassCreator.CreateEmptyStaticClass(SharedState.Instance.Module, SharedState.RootNamespace, "ReferenceAssembliesJson");
			FieldDefinition field = CreateInternalStorageClass("ReferenceAssembliesJsonData", File.ReadAllBytes("assemblies.json"));
			AddGetStreamMethod(type, field);
			AddDataProperty(type, field);
		}
	}

	private static void AddVersionsProperty(TypeDefinition type, IReadOnlyCollection<UnityVersion> versions)
	{
		GenericInstanceTypeSignature readOnlySet = SharedState.Instance.Importer.ImportType(typeof(IReadOnlySet<>))
						.MakeGenericInstanceType(SharedState.Instance.Importer.ImportTypeSignature<UnityVersion>());
		GenericInstanceTypeSignature unityVersionHashSet = SharedState.Instance.Importer.ImportType(typeof(HashSet<>))
			.MakeGenericInstanceType(SharedState.Instance.Importer.ImportTypeSignature<UnityVersion>());
		IMethodDefOrRef hashsetConstructor = MethodUtils.MakeConstructorOnGenericType(SharedState.Instance.Importer, unityVersionHashSet, 0);
		IMethodDefOrRef addMethod = MethodUtils.MakeMethodOnGenericType(
			SharedState.Instance.Importer,
			unityVersionHashSet,
			SharedState.Instance.Importer.LookupMethod(typeof(HashSet<>), m => m.Name == nameof(HashSet<>.Add)));

		IMethodDefOrRef unityVersionConstructor = SharedState.Instance.Importer.ImportConstructor<UnityVersion>(5);

		const string propertyName = "Versions";
		FieldDefinition field = type.AddField($"<{propertyName}>k__BackingField", readOnlySet, true, Visibility.Private);

		field.Attributes |= FieldAttributes.InitOnly;
		field.AddCompilerGeneratedAttribute(SharedState.Instance.Importer);

		MethodDefinition staticConstructor = type.GetOrCreateStaticConstructor();
		CilInstructionCollection instructions = staticConstructor.CilMethodBody!.Instructions;
		instructions.Pop();//pop the ret
		instructions.Add(CilOpCodes.Newobj, hashsetConstructor);
		foreach (UnityVersion version in versions)
		{
			instructions.Add(CilOpCodes.Dup);
			instructions.Add(CilOpCodes.Ldc_I4, (int)version.Major);
			instructions.Add(CilOpCodes.Ldc_I4, (int)version.Minor);
			instructions.Add(CilOpCodes.Ldc_I4, (int)version.Build);
			instructions.Add(CilOpCodes.Ldc_I4, (int)version.Type);
			instructions.Add(CilOpCodes.Ldc_I4, (int)version.TypeNumber);
			instructions.Add(CilOpCodes.Newobj, unityVersionConstructor);
			instructions.Add(CilOpCodes.Call, addMethod);
			instructions.Add(CilOpCodes.Pop);
		}
		instructions.Add(CilOpCodes.Stsfld, field);
		instructions.Add(CilOpCodes.Ret);

		instructions.OptimizeMacros();

		type.ImplementGetterProperty(
				propertyName,
				MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.SpecialName,
				readOnlySet,
				field)
			.GetMethod!.AddCompilerGeneratedAttribute(SharedState.Instance.Importer);

		Console.WriteLine($"\t{versions.Count} source versions.");
	}

	private static void AddDataProperty(TypeDefinition type, FieldDefinition field)
	{
		TypeSignature propertySignature = SharedState.Instance.Importer.ImportType(typeof(ReadOnlySpan<>))
			.MakeGenericInstanceType(SharedState.Instance.Importer.UInt8);

		PropertyDefinition property = type.AddGetterProperty("Data", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig, propertySignature);

		MethodDefinition method = property.GetMethod!;
		CilInstructionCollection instructions = method.GetInstructions();

		MemberReference reference = new MemberReference(propertySignature.ToTypeDefOrRef(), ".ctor", SharedState.Instance.Importer.ImportMethod(typeof(ReadOnlySpan<>),
			m => m.IsConstructor && m.Parameters.Count == 1 && m.Parameters[0].ParameterType is SzArrayTypeSignature).Signature);
		instructions.Add(CilOpCodes.Ldsfld, field);
		instructions.Add(CilOpCodes.Newobj, reference);
		instructions.Add(CilOpCodes.Ret);
	}

	private static void AddGetStreamMethod(TypeDefinition type, FieldDefinition field)
	{
		ITypeDefOrRef returnType = SharedState.Instance.Importer.ImportType(typeof(MemoryStream));

		MethodDefinition method = type.AddMethod("GetStream", MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig, returnType.ToTypeSignature());
		CilInstructionCollection instructions = method.GetInstructions();

		MemberReference reference = new MemberReference(returnType, ".ctor", SharedState.Instance.Importer.ImportMethod(typeof(MemoryStream), m =>
		{
			return m.IsConstructor
				&& m.Parameters.Count == 2
				&& m.Parameters[0].ParameterType is SzArrayTypeSignature
				&& m.Parameters[1].ParameterType is CorLibTypeSignature;
		})
			.Signature);
		instructions.Add(CilOpCodes.Ldsfld, field);
		instructions.Add(CilOpCodes.Ldc_I4_0);//Not writable
		instructions.Add(CilOpCodes.Newobj, reference);
		instructions.Add(CilOpCodes.Ret);
	}

	private static FieldDefinition CreateInternalStorageClass(string className, byte[] data)
	{
		FieldDefinition field;
		TypeDefinition internalType = StaticClassCreator.CreateEmptyStaticClass(SharedState.Instance.Module, SharedState.RootNamespace, className);
		internalType.IsPublic = false;

		FieldDefinition privateImplementationField = AddStoredDataField(data);

		field = internalType.AddField("data", SharedState.Instance.Importer.UInt8.MakeSzArrayType(), true, Visibility.Internal);
		field.IsInitOnly = true;

		//Static Constructor
		{
			MethodDefinition staticConstructor = internalType.GetOrCreateStaticConstructor();
			CilInstructionCollection instructions = staticConstructor.CilMethodBody!.Instructions;
			instructions.Pop();//pop the ret
			instructions.Add(CilOpCodes.Ldc_I4, data.Length);
			instructions.Add(CilOpCodes.Newarr, SharedState.Instance.Importer.UInt8.ToTypeDefOrRef());
			instructions.Add(CilOpCodes.Dup);
			instructions.Add(CilOpCodes.Ldtoken, privateImplementationField);
			instructions.Add(CilOpCodes.Call, SharedState.Instance.Importer.ImportMethod(typeof(RuntimeHelpers), m => m.Name == nameof(RuntimeHelpers.InitializeArray)));
			instructions.Add(CilOpCodes.Stsfld, field);
			instructions.Add(CilOpCodes.Ret);
		}

		return field;
	}

	/// <summary>
	/// Adds a byte array field to the PrivateImplementationDetails class.
	/// </summary>
	/// <param name="fieldName">The name of the field.</param>
	/// <param name="data">The data contained within the field.</param>
	/// <returns>The field's <see cref="FieldDefinition"/>.</returns>
	private static FieldDefinition AddStoredDataField(byte[] data)
	{
		TypeDefinition nestedType = GetOrCreateStaticArrayInitType(data.Length);

		FieldDefinition privateImplementationField = SharedState.Instance.PrivateImplementationDetails.AddField(HashDataToBase64(data), nestedType.ToTypeSignature(), true, Visibility.Internal);
		privateImplementationField.IsInitOnly = true;
		privateImplementationField.FieldRva = new DataSegment(data);
		privateImplementationField.HasFieldRva = true;
		privateImplementationField.AddCompilerGeneratedAttribute(SharedState.Instance.Importer);

		return privateImplementationField;

		//This might not be the correct way to choose a field name, but I think the specification allows it.
		//In any case, ILSpy handles it the way we want, which is all that matters.
		static string HashDataToBase64(byte[] data)
		{
			byte[] hash = SHA256.HashData(data);
			return Convert.ToBase64String(hash, Base64FormattingOptions.None);
		}
	}

	private static TypeDefinition GetOrCreateStaticArrayInitType(int length)
	{
		string name = $"__StaticArrayInitTypeSize={length}";

		foreach (TypeDefinition nestedType in SharedState.Instance.PrivateImplementationDetails.NestedTypes)
		{
			if (nestedType.Name == name)
			{
				return nestedType;
			}
		}

		TypeDefinition result = new TypeDefinition(null, name,
			TypeAttributes.NestedPrivate |
			TypeAttributes.ExplicitLayout |
			TypeAttributes.AnsiClass |
			TypeAttributes.Sealed);
		SharedState.Instance.PrivateImplementationDetails.NestedTypes.Add(result);

		result.BaseType = SharedState.Instance.Importer.ImportType(typeof(ValueType));
		result.ClassLayout = new ClassLayout(1, (uint)length);
		result.AddCompilerGeneratedAttribute(SharedState.Instance.Importer);

		return result;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass558_TypeCache.cs`:

```cs
using AssetRipper.AssemblyDumper.Attributes;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass558_TypeCache
{
	public static void DoPass()
	{
		TypeDefinition newTypeDef = StaticClassCreator.CreateEmptyStaticClass(SharedState.Instance.Module, SharedState.RootNamespace, "ClassIDTypeMap");

		GenericInstanceTypeSignature readOnlyDictionarySignature = SharedState.Instance.Importer.ImportType(typeof(IReadOnlyDictionary<,>))
			.MakeGenericInstanceType(SharedState.Instance.Importer.ImportTypeSignature<Type>(), Pass556_CreateClassIDTypeEnum.ClassIdTypeDefintion!.ToTypeSignature());
		GenericInstanceTypeSignature dictionarySignature = SharedState.Instance.Importer.ImportType(typeof(Dictionary<,>))
			.MakeGenericInstanceType(SharedState.Instance.Importer.ImportTypeSignature<Type>(), Pass556_CreateClassIDTypeEnum.ClassIdTypeDefintion!.ToTypeSignature());
		IMethodDefOrRef dictionaryConstructor = MethodUtils.MakeConstructorOnGenericType(SharedState.Instance.Importer, dictionarySignature, 0);
		IMethodDefOrRef addMethod = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, dictionarySignature, SharedState.Instance.Importer.LookupMethod(typeof(Dictionary<,>), m => m.Name == "Add"));
		IMethodDefOrRef getTypeFromHandleMethod = SharedState.Instance.Importer.ImportMethod(typeof(Type), m => m.Name == nameof(Type.GetTypeFromHandle));

		const string propertyName = "Dictionary";
		FieldDefinition field = newTypeDef.AddField($"<{propertyName}>k__BackingField", readOnlyDictionarySignature, true, Visibility.Private);
		field.Attributes |= FieldAttributes.InitOnly;
		field.AddCompilerGeneratedAttribute(SharedState.Instance.Importer);

		MethodDefinition staticConstructor = newTypeDef.AddEmptyConstructor(true);
		CilInstructionCollection instructions = staticConstructor.GetInstructions();
		instructions.Add(CilOpCodes.Newobj, dictionaryConstructor);
		foreach ((int id, ClassGroup group) in SharedState.Instance.ClassGroups)
		{
			instructions.Add(CilOpCodes.Dup);
			instructions.Add(CilOpCodes.Ldtoken, group.Interface);
			instructions.Add(CilOpCodes.Call, getTypeFromHandleMethod);
			instructions.Add(CilOpCodes.Ldc_I4, id);
			instructions.Add(CilOpCodes.Call, addMethod);

			foreach (TypeDefinition type in group.Types)
			{
				instructions.Add(CilOpCodes.Dup);
				instructions.Add(CilOpCodes.Ldtoken, type);
				instructions.Add(CilOpCodes.Call, getTypeFromHandleMethod);
				instructions.Add(CilOpCodes.Ldc_I4, id);
				instructions.Add(CilOpCodes.Call, addMethod);
			}
		}
		instructions.Add(CilOpCodes.Stsfld, field);
		instructions.Add(CilOpCodes.Ret);

		instructions.OptimizeMacros();

		newTypeDef.ImplementGetterProperty(
				propertyName,
				MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.SpecialName,
				readOnlyDictionarySignature,
				field)
			.GetMethod!.AddCompilerGeneratedAttribute(SharedState.Instance.Importer);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass920_InterfaceInheritance.cs`:

```cs
using AssetRipper.AssemblyDumper.Types;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass920_InterfaceInheritance
{
	public static void DoPass()
	{
		foreach (ClassGroup group in SharedState.Instance.ClassGroups.Values
			.OrderBy(g => g.Types.Select(t => t.GetInheritanceDepth()).Max())
			.Order(GroupComparer.Instance))
		{
			DoPassOnGroup(group);
		}
	}

	private static void DoPassOnGroup(ClassGroup group)
	{
		List<HashSet<ITypeDefOrRef>> instances = group.Types.Select(t => t.GetAllInterfaces()).ToList();
		HashSet<ITypeDefOrRef> existingInterfaces = group.Interface.GetAllInterfaces();
		existingInterfaces.Add(group.Interface);

		foreach (ITypeDefOrRef potentialInterface in instances.First())
		{
			if (!existingInterfaces.Contains(potentialInterface) && instances.All(i => i.Contains(potentialInterface)))
			{
				ITypeDefOrRef interfaceReference = potentialInterface.ToTypeDefOrRef();
				group.Interface.AddInterfaceImplementation(interfaceReference);

				if (interfaceReference is TypeDefinition interfaceType)
				{
					existingInterfaces.UnionWith(interfaceType.GetAllInterfaces());
				}
			}
		}
	}

	private static HashSet<ITypeDefOrRef> GetAllInterfaces(this TypeDefinition type)
	{
		HashSet<ITypeDefOrRef> result = new(SignatureComparer.Default);
		HashSet<TypeDefinition> alreadyQueued = new()
		{
			type
		};
		Queue<TypeDefinition> queue = new()
		{
			type
		};

		while (queue.TryDequeue(out TypeDefinition? current))
		{
			foreach (InterfaceImplementation interfaceImplementation in current.Interfaces)
			{
				if (interfaceImplementation.Interface is not null)
				{
					result.Add(interfaceImplementation.Interface);
					if (interfaceImplementation.Interface is TypeDefinition interfaceType && alreadyQueued.Add(interfaceType))
					{
						queue.Enqueue(interfaceType);
					}
				}
			}
			if (current.BaseType is TypeDefinition baseType && alreadyQueued.Add(baseType))
			{
				queue.Enqueue(baseType);
			}
		}

		return result;
	}

	private static void Add<T>(this Queue<T> queue, T item) => queue.Enqueue(item);

	private static int GetInheritanceDepth(this TypeDefinition type)
	{
		int depth = 0;
		while (type.BaseType is TypeDefinition baseType)
		{
			depth++;
			type = baseType;
		}
		return depth;
	}

	private sealed class GroupComparer : IComparer<ClassGroup>
	{
		public static GroupComparer Instance { get; } = new();

		int IComparer<ClassGroup>.Compare(ClassGroup? x, ClassGroup? y)
		{
			return x is null
				? y is null ? 0 : -1
				: y is null ? 1 : Compare(x, y);
		}

		public static int Compare(ClassGroup x, ClassGroup y)
		{
			HashSet<TypeDefinition> xTypes = x.Types.ToHashSet();
			HashSet<TypeDefinition> yTypes = y.Types.ToHashSet();

			bool xInheritsFromY = xTypes.Any(t => ContainsBaseType(yTypes, t));
			bool yInheritsFromX = yTypes.Any(t => ContainsBaseType(xTypes, t));

			return yInheritsFromX
				? xInheritsFromY ? 0 : -1
				: xInheritsFromY ? 1 : 0;

			static bool ContainsBaseType(HashSet<TypeDefinition> set, TypeDefinition type)
			{
				while (type.BaseType is TypeDefinition baseType)
				{
					if (set.Contains(baseType))
					{
						return true;
					}
					type = baseType;
				}
				return false;
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass940_MakeAssetFactory.cs`:

```cs
using AssetRipper.AssemblyDumper.Documentation;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass940_MakeAssetFactory
{
	private const MethodAttributes CreateAssetAttributes = MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.Static;
#nullable disable
	private static TypeSignature iunityObjectBase;
	private static TypeSignature assetInfoType;
	private static TypeSignature assetCollectionType;
	private static TypeSignature unityVersionType;
	private static TypeDefinition abstractClassException;
	private static MethodDefinition abstractClassExceptionConstructor;
	private static IMethodDefOrRef unityVersionIsGreaterEqualMethod;
	private static IMethodDefOrRef assetInfoConstructor;
	private static IMethodDefOrRef assetInfoCollectionGetMethod;
	private static IMethodDefOrRef assetCollectionVersionGetMethod;
#nullable enable
	private static readonly HashSet<int> importerClassIDs = new();

	public static void DoPass()
	{
		FindImporterGroups();

		iunityObjectBase = SharedState.Instance.Importer.ImportTypeSignature<IUnityObjectBase>();
		assetInfoType = SharedState.Instance.Importer.ImportTypeSignature<AssetInfo>();
		assetCollectionType = SharedState.Instance.Importer.ImportTypeSignature<AssetCollection>();
		unityVersionType = SharedState.Instance.Importer.ImportTypeSignature<UnityVersion>();

		abstractClassException = ExceptionCreator.CreateSimpleException(
			SharedState.Instance.Importer,
			SharedState.ExceptionsNamespace,
			"AbstractClassException",
			"Abstract class could not be created");
		abstractClassExceptionConstructor = abstractClassException.GetDefaultConstructor();

		unityVersionIsGreaterEqualMethod = SharedState.Instance.Importer.ImportMethod<UnityVersion>(m =>
			m.Name == nameof(UnityVersion.GreaterThanOrEquals) && m.Parameters.Count == 5);
		assetInfoConstructor = SharedState.Instance.Importer.ImportMethod<AssetInfo>(method =>
			method.Name == ".ctor"
			&& method.Parameters.Count == 3);
		assetInfoCollectionGetMethod = SharedState.Instance.Importer.ImportMethod<AssetInfo>(method =>
			method.Name == $"get_{nameof(AssetInfo.Collection)}");
		assetCollectionVersionGetMethod = SharedState.Instance.Importer.ImportMethod<AssetCollection>(method =>
			method.Name == $"get_{nameof(AssetCollection.Version)}");

		TypeDefinition factoryDefinition = CreateFactoryDefinition();
		List<GeneratedMethodInformation> assetInfoMethods = AddAllClassCreationMethods();
		MethodDefinition creationMethod = factoryDefinition.AddAssetInfoCreationMethod("Create", assetInfoMethods);
		AddMethodWithoutVersionParameter(creationMethod);

		// CreateSerialized
		{
			// On Unity 5 and later, we want to return null for ClassID 194 (NavMesh).
			// It was made obsolete and contains no data, so it's safe to ignore.
			// This is done in CreateSerialized so that version changing can still use the Create method.
			// See pass 1 for more information.
			MethodDefinition method = factoryDefinition.AddMethod("CreateSerialized", CreateAssetAttributes, iunityObjectBase);
			Parameter assetInfoParameter = method.AddParameter(assetInfoType, "info");
			Parameter versionParameter = method.AddParameter(unityVersionType, "version");

			CilInstructionCollection instructions = method.GetInstructions();

			CilLocalVariable switchCondition = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);
			instructions.Add(CilOpCodes.Ldarga, assetInfoParameter);
			IMethodDefOrRef propertyRef = SharedState.Instance.Importer.ImportMethod<AssetInfo>(m => m.Name == $"get_{nameof(AssetInfo.ClassID)}");
			instructions.Add(CilOpCodes.Call, propertyRef);
			instructions.Add(CilOpCodes.Stloc, switchCondition);

			CilInstructionLabel defaultLabel = new();
			CilInstructionLabel returnLabel = new();

			instructions.Add(CilOpCodes.Ldloc, switchCondition);
			instructions.Add(CilOpCodes.Ldc_I4, 194);
			instructions.Add(CilOpCodes.Ceq);
			instructions.Add(CilOpCodes.Brfalse, defaultLabel);

			instructions.AddIsGreaterOrEqualToVersion(versionParameter, new UnityVersion(5));
			instructions.Add(CilOpCodes.Brfalse, defaultLabel);

			instructions.Add(CilOpCodes.Ldnull);
			instructions.Add(CilOpCodes.Br, returnLabel);

			defaultLabel.Instruction = instructions.Add(CilOpCodes.Nop);
			instructions.Add(CilOpCodes.Ldarg_0);
			instructions.Add(CilOpCodes.Ldarg_1);
			instructions.Add(CilOpCodes.Call, creationMethod);

			returnLabel.Instruction = instructions.Add(CilOpCodes.Ret);

			AddMethodWithoutVersionParameter(method);
		}
	}

	private static TypeDefinition CreateFactoryDefinition()
	{
		return StaticClassCreator.CreateEmptyStaticClass(SharedState.Instance.Module, SharedState.RootNamespace, "AssetFactory");
	}

	private static MethodDefinition AddAssetInfoCreationMethod(this TypeDefinition factoryDefinition, string methodName, List<GeneratedMethodInformation> constructors)
	{
		MethodDefinition method = factoryDefinition.AddMethod(methodName, CreateAssetAttributes, iunityObjectBase);
		Parameter assetInfoParameter = method.AddParameter(assetInfoType, "info");
		Parameter versionParameter = method.AddParameter(unityVersionType, "version");
		method.GetInstructions().EmitIdSwitchStatement(assetInfoParameter, versionParameter, constructors);
		return method;
	}

	private static void EmitIdSwitchStatement(this CilInstructionCollection instructions, Parameter assetInfoParameter, Parameter versionParameter, List<GeneratedMethodInformation> constructors)
	{
		int count = constructors.Count;

		CilLocalVariable switchCondition = instructions.AddLocalVariable(SharedState.Instance.Importer.Int32);
		instructions.Add(CilOpCodes.Ldarga, assetInfoParameter);
		IMethodDefOrRef propertyRef = SharedState.Instance.Importer.ImportMethod<AssetInfo>(m => m.Name == $"get_{nameof(AssetInfo.ClassID)}");
		instructions.Add(CilOpCodes.Call, propertyRef);
		instructions.Add(CilOpCodes.Stloc, switchCondition);

		CilInstructionLabel[] nopInstructions = Enumerable.Range(0, count).Select(i => new CilInstructionLabel()).ToArray();
		CilInstructionLabel defaultNop = new CilInstructionLabel();
		for (int i = 0; i < count; i++)
		{
			instructions.Add(CilOpCodes.Ldloc, switchCondition);
			instructions.Add(CilOpCodes.Ldc_I4, constructors[i].ClassID);
			instructions.Add(CilOpCodes.Beq, nopInstructions[i]);
		}
		instructions.Add(CilOpCodes.Br, defaultNop);
		for (int i = 0; i < count; i++)
		{
			nopInstructions[i].Instruction = instructions.Add(CilOpCodes.Nop);
			GeneratedMethodInformation tuple = constructors[i];
			if (tuple.AssetInfoMethod is null)
			{
				instructions.AddThrowAbstractClassException();
			}
			else
			{
				instructions.Add(CilOpCodes.Ldarg, assetInfoParameter);

				if (tuple.HasVersionParameter)
				{
					instructions.Add(CilOpCodes.Ldarg, versionParameter);
				}

				instructions.Add(CilOpCodes.Call, tuple.AssetInfoMethod);
				instructions.Add(CilOpCodes.Ret);
			}
		}
		defaultNop.Instruction = instructions.Add(CilOpCodes.Nop);
		instructions.Add(CilOpCodes.Ldnull);
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
	}

	private static void AddMethodWithoutVersionParameter(MethodDefinition mainMethod)
	{
		//The main method has two parameters: UnityVersion and AssetInfo.
		//This generates a second method with one parameter: AssetInfo.
		//UnityVersion is pulled from AssetInfo.Collection.Version.
		MethodDefinition method = mainMethod.DeclaringType!.AddMethod(mainMethod.Name, mainMethod.Attributes, mainMethod.Signature!.ReturnType);
		Parameter parameter = method.AddParameter(assetInfoType, "info");
		CilInstructionCollection instructions = method.GetInstructions();

		//Load Parameter 1
		instructions.Add(CilOpCodes.Ldarg_0);

		//Load Parameter 2
		instructions.Add(CilOpCodes.Ldarga, parameter);
		instructions.Add(CilOpCodes.Call, assetInfoCollectionGetMethod);
		instructions.Add(CilOpCodes.Call, assetCollectionVersionGetMethod);

		//Call main method and return
		instructions.Add(CilOpCodes.Call, mainMethod);
		instructions.Add(CilOpCodes.Ret);
	}

	private static List<GeneratedMethodInformation> AddAllClassCreationMethods()
	{
		List<GeneratedMethodInformation> assetInfoMethods = new();
		foreach (ClassGroup group in SharedState.Instance.ClassGroups.Values.OrderBy(g => g.ID))
		{
			group.AddMethodsForGroup(
				out MethodDefinition? assetInfoMethod,
				out bool usesVersion);
			if (usesVersion && assetInfoMethod is not null)
			{
				AddMethodWithoutVersionParameter(assetInfoMethod);
			}
			assetInfoMethods.Add((group.ID, assetInfoMethod, usesVersion));
			if (Pass001_MergeMovedGroups.Changes.TryGetValue(group.ID, out IReadOnlyList<int>? aliasIDs))
			{
				foreach (int aliasID in aliasIDs)
				{
					assetInfoMethods.Add((aliasID, assetInfoMethod, usesVersion));
				}
			}
		}
		foreach (SubclassGroup group in SharedState.Instance.SubclassGroups.Values)
		{
			group.AddMethodsForGroup(out _, out _);
		}
		assetInfoMethods.Sort((a, b) => a.ClassID.CompareTo(b.ClassID));
		return assetInfoMethods;
	}

	private static void AddMethodsForGroup(
		this ClassGroupBase group,
		out MethodDefinition? assetInfoMethod,
		out bool usesVersion)
	{
		if (group.IsAbstractGroup())
		{
			usesVersion = false;
			assetInfoMethod = null;
		}
		else if (group.Instances.Count == 1)
		{
			usesVersion = false;
			TypeDefinition factoryClass = group.GetOrCreateMainClass();
			MethodDefinition generatedMethod = ImplementSingleCreationMethod(group, factoryClass);
			if (group is SubclassGroup)
			{
				assetInfoMethod = null;
			}
			else
			{
				assetInfoMethod = generatedMethod;
				MaybeImplementImporterCreationMethod(group, assetInfoMethod, usesVersion, factoryClass);
			}
		}
		else
		{
			usesVersion = true;
			TypeDefinition factoryClass = group.GetOrCreateMainClass();
			MethodDefinition generatedMethod = ImplementNormalCreationMethod(group, factoryClass);
			if (group is SubclassGroup)
			{
				assetInfoMethod = null;
			}
			else
			{
				assetInfoMethod = generatedMethod;
				MaybeImplementImporterCreationMethod(group, assetInfoMethod, usesVersion, factoryClass);
			}
		}

		static void MaybeImplementImporterCreationMethod(ClassGroupBase group, MethodDefinition assetInfoMethod, bool usesVersion, TypeDefinition factoryClass)
		{
			if (importerClassIDs.Contains(group.ID))
			{
				ImplementImporterCreationMethod(group, factoryClass, assetInfoMethod, usesVersion);
			}
		}
	}

	private static MethodDefinition ImplementSingleCreationMethod(ClassGroupBase group, TypeDefinition factoryClass)
	{
		MethodDefinition method = factoryClass.AddMethod("Create", CreateAssetAttributes, group.GetSingularTypeOrInterface().ToTypeSignature());
		CilInstructionCollection instructions = method.GetInstructions();
		Parameter? assetInfoParameter = group is SubclassGroup ? null : method.AddParameter(assetInfoType, "info");
		instructions.AddReturnNewConstructedObject(group.Instances[0].Type, assetInfoParameter);
		return method;
	}

	private static MethodDefinition ImplementNormalCreationMethod(ClassGroupBase group, TypeDefinition factoryClass)
	{
		MethodDefinition method = factoryClass.AddMethod("Create", CreateAssetAttributes, group.GetSingularTypeOrInterface().ToTypeSignature());
		Parameter? assetInfoParameter = group is SubclassGroup ? null : method.AddParameter(assetInfoType, "info");
		Parameter versionParameter = method.AddParameter(unityVersionType, "version");
		CilInstructionCollection instructions = method.GetInstructions();
		instructions.FillNormalCreationMethod(group, versionParameter, assetInfoParameter);
		return method;
	}

	private static MethodDefinition ImplementImporterCreationMethod(ClassGroupBase group, TypeDefinition factoryClass, MethodDefinition assetInfoMethod, bool hasVersion)
	{
		MethodDefinition method = factoryClass.AddMethod("Create",
			CreateAssetAttributes,
			group.GetSingularTypeOrInterface().ToTypeSignature());

		DocumentationHandler.AddMethodDefinitionLine(method, $"This is a special factory method for creating a temporary {SeeXmlTagGenerator.MakeCRef(group.Interface)} with no PathID.");

		CilInstructionCollection instructions = method.GetInstructions();

		method.AddParameter(assetCollectionType, "collection");
		instructions.Add(CilOpCodes.Ldarg_0);

		instructions.Add(CilOpCodes.Ldc_I4_0);//PathID
		instructions.Add(CilOpCodes.Conv_I8);
		instructions.Add(CilOpCodes.Ldc_I4, group.ID);//ClassID
		instructions.Add(CilOpCodes.Newobj, assetInfoConstructor);

		if (hasVersion)
		{
			method.AddParameter(unityVersionType, "version");
			instructions.Add(CilOpCodes.Ldarg_1);
		}

		instructions.Add(CilOpCodes.Call, assetInfoMethod);
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
		return method;
	}

	private static bool IsAbstractGroup(this ClassGroupBase group)
	{
		return group.Types.All(t => t.IsAbstract);
	}

	private static void AddThrowExceptionOrReturnNewObject(this CilInstructionCollection instructions, TypeDefinition objectType, Parameter? assetInfoParameter)
	{
		if (objectType.IsAbstract)
		{
			instructions.AddThrowAbstractClassException();
		}
		else
		{
			instructions.AddReturnNewConstructedObject(objectType, assetInfoParameter);
		}
	}

	private static void AddThrowAbstractClassException(this CilInstructionCollection instructions)
	{
		instructions.Add(CilOpCodes.Newobj, abstractClassExceptionConstructor);
		instructions.Add(CilOpCodes.Throw);
	}

	private static void AddReturnNewConstructedObject(this CilInstructionCollection instructions, TypeDefinition objectType, Parameter? assetInfoParameter)
	{
		if (assetInfoParameter is not null)
		{
			instructions.Add(CilOpCodes.Ldarg, assetInfoParameter);
			instructions.Add(CilOpCodes.Newobj, objectType.GetAssetInfoConstructor());
		}
		else
		{
			instructions.Add(CilOpCodes.Newobj, objectType.GetDefaultConstructor());
		}
		instructions.Add(CilOpCodes.Ret);
	}

	private static void AddIsGreaterOrEqualToVersion(this CilInstructionCollection instructions, Parameter versionParameter, UnityVersion versionToCompareWith)
	{
		instructions.Add(CilOpCodes.Ldarga, versionParameter);
		instructions.Add(CilOpCodes.Ldc_I4, (int)versionToCompareWith.Major);
		instructions.Add(CilOpCodes.Ldc_I4, (int)versionToCompareWith.Minor);
		instructions.Add(CilOpCodes.Ldc_I4, (int)versionToCompareWith.Build);
		instructions.Add(CilOpCodes.Ldc_I4, (int)versionToCompareWith.Type);
		instructions.Add(CilOpCodes.Ldc_I4, (int)versionToCompareWith.TypeNumber);
		instructions.Add(CilOpCodes.Call, unityVersionIsGreaterEqualMethod);
	}

	private static void FillNormalCreationMethod(this CilInstructionCollection instructions, ClassGroupBase group, Parameter versionParameter, Parameter? assetInfoParameter)
	{
		for (int i = group.Instances.Count - 1; i > 0; i--)
		{
			CilInstructionLabel label = new();
			UnityVersion startVersion = group.Instances[i].VersionRange.Start;
			instructions.AddIsGreaterOrEqualToVersion(versionParameter, startVersion);
			instructions.Add(CilOpCodes.Brfalse, label);
			instructions.AddThrowExceptionOrReturnNewObject(group.Instances[i].Type, assetInfoParameter);
			label.Instruction = instructions.Add(CilOpCodes.Nop);
		}
		instructions.AddThrowExceptionOrReturnNewObject(group.Instances[0].Type, assetInfoParameter);
		instructions.OptimizeMacros();
	}

	private static MethodDefinition GetAssetInfoConstructor(this TypeDefinition typeDefinition)
	{
		return typeDefinition.Methods.Where(x => x.IsConstructor && x.Parameters.Count == 1 && x.Parameters[0].ParameterType.Name == nameof(AssetInfo)).Single();
	}

	private static void FindImporterGroups()
	{
		foreach ((int id, ClassGroup group) in SharedState.Instance.ClassGroups)
		{
			if (group.Instances.Any(i => i.InheritsFromAssetImporter()))
			{
				importerClassIDs.Add(id);
			}
		}
	}

	private readonly record struct GeneratedMethodInformation(int ClassID, MethodDefinition? AssetInfoMethod, bool HasVersionParameter)
	{
		public static implicit operator GeneratedMethodInformation((int, MethodDefinition?, bool) tuple)
		{
			return new GeneratedMethodInformation(tuple.Item1, tuple.Item2, tuple.Item3);
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass941_MakeFieldHashes.cs`:

```cs
using AssetRipper.AssemblyDumper.Attributes;
using AssetRipper.AssemblyDumper.Documentation;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;
using AssetRipper.Checksum;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass941_MakeFieldHashes
{
	private const string MethodName = "TryGetPath";

	public static void DoPass()
	{
		List<(int, MethodDefinition)> groupMethods = new();
		foreach ((ClassGroup group, Dictionary<uint, string> hashes) in HashAllFieldPaths())
		{
			if (hashes.Count > 0)
			{
				MethodDefinition method = MakeMethodForGroup(group, hashes);
				groupMethods.Add((group.ID, method));
				if (Pass001_MergeMovedGroups.Changes.TryGetValue(group.ID, out IReadOnlyList<int>? aliasIDs))
				{
					foreach (int aliasID in aliasIDs)
					{
						groupMethods.Add((aliasID, method));
					}
				}
			}
		}
		groupMethods.Sort((a, b) => a.Item1.CompareTo(b.Item1));

		{
			TypeDefinition type = StaticClassCreator.CreateEmptyStaticClass(SharedState.Instance.Module, SharedState.RootNamespace, "FieldHashes");
			DocumentationHandler.AddTypeDefinitionLine(type, $"CRC32 field path hashes for all source generated classes.");
			type.AddNullableContextAttribute(NullableAnnotation.NotNull);
			MethodDefinition nullHelperMethod = MakeNullHelperMethod(type);

			MethodDefinition method = type.AddMethod(MethodName, MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig, SharedState.Instance.Importer.Boolean);
			Parameter idParameter = method.AddParameter(Pass556_CreateClassIDTypeEnum.ClassIdTypeDefintion!.ToTypeSignature(), "classID");
			Parameter hashParameter = method.AddParameter(SharedState.Instance.Importer.UInt32, "hash");
			Parameter outParameter = method.AddParameter(SharedState.Instance.Importer.String.MakeByReferenceType(), "path");
			ParameterDefinition outParameterDefinition = outParameter.Definition!;
			outParameterDefinition.Attributes |= ParameterAttributes.Out;
			outParameterDefinition.AddNullableAttribute(NullableAnnotation.MaybeNull);
			outParameterDefinition.AddCustomAttribute(SharedState.Instance.Importer.ImportConstructor<NotNullWhenAttribute>(1), SharedState.Instance.Importer.Boolean, true);

			CilInstructionCollection instructions = method.GetInstructions();
			instructions.EmitIdSwitchStatement(groupMethods, nullHelperMethod);
		}

		foreach (SubclassGroup group in SharedState.Instance.SubclassGroups.Values)
		{
			MakeFieldPathsTypeForGroup(group);
		}
	}

	private static void EmitIdSwitchStatement(this CilInstructionCollection instructions, List<(int, MethodDefinition)> groupMethods, MethodDefinition nullHelperMethod)
	{
		GenericInstanceTypeSignature uintStringDictionary = SharedState.Instance.Importer.ImportType(typeof(Dictionary<,>))
			.MakeGenericInstanceType(SharedState.Instance.Importer.UInt32, SharedState.Instance.Importer.String);
		int count = groupMethods.Count;

		CilLocalVariable switchCondition = instructions.AddLocalVariable(Pass556_CreateClassIDTypeEnum.ClassIdTypeDefintion!.ToTypeSignature());

		instructions.Add(CilOpCodes.Ldarg_0);//classID
		instructions.Add(CilOpCodes.Stloc, switchCondition);

		CilInstructionLabel[] nopInstructions = Enumerable.Range(0, count).Select(i => new CilInstructionLabel()).ToArray();
		CilInstructionLabel defaultNop = new CilInstructionLabel();
		for (int i = 0; i < count; i++)
		{
			instructions.Add(CilOpCodes.Ldloc, switchCondition);
			instructions.Add(CilOpCodes.Ldc_I4, groupMethods[i].Item1);
			instructions.Add(CilOpCodes.Beq, nopInstructions[i]);
		}
		instructions.Add(CilOpCodes.Br, defaultNop);
		for (int i = 0; i < count; i++)
		{
			nopInstructions[i].Instruction = instructions.Add(CilOpCodes.Nop);

			instructions.Add(CilOpCodes.Ldarg_1);//hash
			instructions.Add(CilOpCodes.Ldarg_2);//path
			instructions.Add(CilOpCodes.Call, groupMethods[i].Item2);
			instructions.Add(CilOpCodes.Ret);
		}
		defaultNop.Instruction = instructions.Add(CilOpCodes.Nop);
		instructions.Add(CilOpCodes.Ldarg_2);//path
		instructions.Add(CilOpCodes.Call, nullHelperMethod);
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
	}

	private static MethodDefinition MakeNullHelperMethod(TypeDefinition type)
	{
		MethodDefinition nullHelperMethod = type.AddMethod("NullHelper", MethodAttributes.Private | MethodAttributes.Static | MethodAttributes.HideBySig, SharedState.Instance.Importer.Boolean);
		Parameter outParameter = nullHelperMethod.AddParameter(SharedState.Instance.Importer.String.MakeByReferenceType(), "value");
		ParameterDefinition outParameterDefinition = outParameter.Definition!;
		outParameterDefinition.Attributes |= ParameterAttributes.Out;
		outParameterDefinition.AddNullableAttribute(NullableAnnotation.MaybeNull);
		outParameterDefinition.AddCustomAttribute(SharedState.Instance.Importer.ImportConstructor<NotNullWhenAttribute>(1), SharedState.Instance.Importer.Boolean, true);

		CilInstructionCollection instructions = nullHelperMethod.GetInstructions();
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Initobj, SharedState.Instance.Importer.String.ToTypeDefOrRef());
		instructions.Add(CilOpCodes.Ldc_I4_0);
		instructions.Add(CilOpCodes.Ret);
		return nullHelperMethod;
	}

	private static MethodDefinition MakeMethodForGroup(ClassGroupBase group, Dictionary<uint, string> hashes)
	{
		TypeDefinition type = group.GetOrCreateMainClass();

		GenericInstanceTypeSignature uintStringDictionary = SharedState.Instance.Importer.ImportType(typeof(Dictionary<,>))
			.MakeGenericInstanceType(SharedState.Instance.Importer.UInt32, SharedState.Instance.Importer.String);
		IMethodDefOrRef dictionaryConstructor = MethodUtils.MakeConstructorOnGenericType(SharedState.Instance.Importer, uintStringDictionary, 0);
		IMethodDefOrRef addMethod = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, uintStringDictionary, SharedState.Instance.Importer.LookupMethod(typeof(Dictionary<,>), m => m.Name == "Add"));
		IMethodDefOrRef tryGetValue = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, uintStringDictionary, SharedState.Instance.Importer.LookupMethod(typeof(Dictionary<,>), m => m.Name == "TryGetValue"));

		FieldDefinition field = type.AddField("s_FieldPathDictionary", uintStringDictionary, true, Visibility.Private);
		field.Attributes |= FieldAttributes.InitOnly;
		DocumentationHandler.AddFieldDefinitionLine(field, $"CRC32 field path hashes for {SeeXmlTagGenerator.MakeCRef(group.Interface)} classes.");

		//Static constructor
		{
			MethodDefinition staticConstructor = type.GetOrCreateStaticConstructor();
			CilInstructionCollection instructions = staticConstructor.GetInstructions();
			instructions.Pop();//The return instruction.
			instructions.Add(CilOpCodes.Newobj, dictionaryConstructor);
			foreach ((uint hash, string str) in hashes)
			{
				instructions.Add(CilOpCodes.Dup);
				instructions.Add(CilOpCodes.Ldc_I4, unchecked((int)hash));
				instructions.Add(CilOpCodes.Ldstr, str);
				instructions.Add(CilOpCodes.Call, addMethod);
			}
			instructions.Add(CilOpCodes.Stsfld, field);
			instructions.Add(CilOpCodes.Ret);

			instructions.OptimizeMacros();
		}

		//Method
		{
			MethodDefinition method = type.AddMethod(MethodName, MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig, SharedState.Instance.Importer.Boolean);
			Parameter hashParameter = method.AddParameter(SharedState.Instance.Importer.UInt32, "hash");
			Parameter outParameter = method.AddParameter(SharedState.Instance.Importer.String.MakeByReferenceType(), "path");
			ParameterDefinition outParameterDefinition = outParameter.Definition!;
			outParameterDefinition.Attributes |= ParameterAttributes.Out;
			outParameterDefinition.AddNullableAttribute(NullableAnnotation.MaybeNull);
			outParameterDefinition.AddCustomAttribute(SharedState.Instance.Importer.ImportConstructor<NotNullWhenAttribute>(1), SharedState.Instance.Importer.Boolean, true);

			CilInstructionCollection instructions = method.GetInstructions();
			instructions.Add(CilOpCodes.Ldsfld, field);
			instructions.Add(CilOpCodes.Ldarg_0);//hash
			instructions.Add(CilOpCodes.Ldarg_1);//path
			instructions.Add(CilOpCodes.Callvirt, tryGetValue);
			instructions.Add(CilOpCodes.Ret);

			DocumentationHandler.AddMethodDefinitionLine(method, $"Try get field path from a {SeeXmlTagGenerator.MakeCRef(group.Interface)} class for a CRC32 hash.");

			return method;
		}
	}

	private static void MakeFieldPathsTypeForGroup(ClassGroupBase group)
	{
		TypeDefinition type = group.GetOrCreateMainClass();

		GenericInstanceTypeSignature readonlyStringList = SharedState.Instance.Importer.ImportType(typeof(IReadOnlyList<>))
			.MakeGenericInstanceType(SharedState.Instance.Importer.String);
		GenericInstanceTypeSignature stringList = SharedState.Instance.Importer.ImportType(typeof(List<>))
			.MakeGenericInstanceType(SharedState.Instance.Importer.String);
		IMethodDefOrRef listConstructor = MethodUtils.MakeConstructorOnGenericType(SharedState.Instance.Importer, stringList, 0);
		IMethodDefOrRef addMethod = MethodUtils.MakeMethodOnGenericType(SharedState.Instance.Importer, stringList, SharedState.Instance.Importer.LookupMethod(typeof(List<>), m => m.Name == "Add"));

		const string propertyName = "FieldPaths";//Not currently in use by any subclasses.
		FieldDefinition field = type.AddField($"<{propertyName}>k__BackingField", readonlyStringList, true, Visibility.Private);
		field.Attributes |= FieldAttributes.InitOnly;
		field.AddCompilerGeneratedAttribute(SharedState.Instance.Importer);

		MethodDefinition staticConstructor = type.GetOrCreateStaticConstructor();
		CilInstructionCollection instructions = staticConstructor.GetInstructions();
		instructions.Pop();//The return instruction.
		bool emittedListConstructor = false;
		foreach (string str in group.GetOrderedFieldPaths())
		{
			if (!emittedListConstructor)
			{
				instructions.Add(CilOpCodes.Newobj, listConstructor);
				emittedListConstructor = true;
			}
			instructions.Add(CilOpCodes.Dup);
			instructions.Add(CilOpCodes.Ldstr, str);
			instructions.Add(CilOpCodes.Call, addMethod);
		}
		if (!emittedListConstructor)
		{
			MethodSpecification emptyStringArray = SharedState.Instance.Importer.ImportMethod<Array>(method => method.Name == nameof(Array.Empty))
				.MakeGenericInstanceMethod(SharedState.Instance.Importer.String);
			instructions.Add(CilOpCodes.Call, emptyStringArray);
		}
		instructions.Add(CilOpCodes.Stsfld, field);
		instructions.Add(CilOpCodes.Ret);

		PropertyDefinition property = type.ImplementGetterProperty(
				propertyName,
				MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.SpecialName,
				readonlyStringList,
				field);
		property.GetMethod!.AddCompilerGeneratedAttribute(SharedState.Instance.Importer);
		DocumentationHandler.AddPropertyDefinitionLine(property, $"List of field paths for {SeeXmlTagGenerator.MakeCRef(group.Interface)} classes.");
	}

	private static List<(ClassGroup, Dictionary<uint, string>)> HashAllFieldPaths()
	{
		Dictionary<GeneratedClassInstance, Dictionary<uint, string>> instanceDictionary = new();
		HashSet<GeneratedClassInstance> fullyImplemented = new();
		foreach (GeneratedClassInstance instance in SharedState.Instance.ClassGroups.Values.SelectMany(g => g.Instances))
		{
			Dictionary<uint, string> hashes = GetFieldPaths(instance.Class).Distinct().ToDictionary(Crc32Algorithm.HashUTF8, str => str);
			if (!instance.Class.IsAbstract)
			{
				fullyImplemented.Add(instance);
			}
			instanceDictionary.Add(instance, hashes);
		}
		while (fullyImplemented.Count < instanceDictionary.Count)
		{
			foreach ((GeneratedClassInstance instance, Dictionary<uint, string> hashes) in instanceDictionary)
			{
				if (fullyImplemented.Contains(instance))
				{
					continue;
				}
				if (instance.Derived.All(fullyImplemented.Contains))
				{
					foreach ((uint hash, string path) in instance.Derived.Select(derived => instanceDictionary[derived]).SelectMany(pair => pair))
					{
						hashes.TryAdd(hash, path);
					}
					fullyImplemented.Add(instance);
				}
			}
		}
		List<(ClassGroup, Dictionary<uint, string>)> groupList = new();
		foreach (ClassGroup group in SharedState.Instance.ClassGroups.Values.OrderBy(g => g.ID))
		{
			Dictionary<uint, string> groupHashes = new();
			foreach ((uint hash, string path) in group.Instances.Select(instance => instanceDictionary[instance]).SelectMany(pair => pair).OrderBy(pair => pair.Value))
			{
				groupHashes.TryAdd(hash, path);
			}
			groupList.Add((group, groupHashes));
		}
		return groupList;
	}

	private static IOrderedEnumerable<string> GetOrderedFieldPaths(this ClassGroupBase group)
	{
		return group
			.Classes
			.SelectMany(GetFieldPaths)
			.Distinct()
			.Order();
	}

	private static IEnumerable<string> GetFieldPaths(UniversalClass c)
	{
		if (c.ReleaseRootNode is null)
		{
			Debug.Assert(c.EditorRootNode is not null);
			return GetFieldPaths(c.EditorRootNode);
		}
		else if (c.EditorRootNode is null)
		{
			return GetFieldPaths(c.ReleaseRootNode);
		}
		else
		{
			return GetFieldPaths(c.ReleaseRootNode).Concat(GetFieldPaths(c.EditorRootNode));
		}
	}

	private static IEnumerable<string> GetFieldPaths(UniversalNode rootNode)
	{
		List<string> result = new();
		Stack<(UniversalNode, int, string)> nodeStack = new();
		for (int i = rootNode.SubNodes.Count - 1; i >= 0; i--)
		{
			UniversalNode child = rootNode.SubNodes[i];
			NodeType childType = child.NodeType;
			if (childType is NodeType.Type)
			{
				if (IsNotPPtr(child))
				{
					nodeStack.Push((child, 0, child.OriginalName));
				}
			}
			else if (childType.IsPrimitive())
			{
				result.Add(child.OriginalName);
			}
		}

		while (nodeStack.Count > 0)
		{
			(UniversalNode parent, int childIndex, string parentPath) = nodeStack.Pop();
			while (true)
			{
				if (childIndex >= parent.SubNodes.Count)
				{
					break;
				}
				UniversalNode child = parent.SubNodes[childIndex];
				childIndex++;
				NodeType childType = child.NodeType;
				if (childType is NodeType.Type)
				{
					if (IsNotPPtr(child))
					{
						nodeStack.Push((parent, childIndex, parentPath));
						nodeStack.Push((child, 0, $"{parentPath}.{child.OriginalName}"));
						break;
					}
				}
				else if (childType.IsPrimitive())
				{
					result.Add($"{parentPath}.{child.OriginalName}");
				}
			}
		}
		return result;

		static bool IsNotPPtr(UniversalNode child)
		{
			return child.SubNodes.Count != 2 || child.SubNodes[0].OriginalName is not "m_FileID" || child.SubNodes[1].OriginalName is not "m_PathID";
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass998_SaveAssembly.cs`:

```cs
using AsmResolver;
using AsmResolver.DotNet.Builder;

namespace AssetRipper.AssemblyDumper.Passes;

public static class Pass998_SaveAssembly
{
	public static void DoPass()
	{
		AssemblyDefinition assembly = SharedState.Instance.Assembly;

		string filePath = Path.Combine(Environment.CurrentDirectory, assembly.Name!.ToString() + ".dll");

		DotNetDirectoryFactory factory = new();
		ManagedPEImageBuilder builder = new ManagedPEImageBuilder(factory, ThrowErrorListener.Instance);

		if (File.Exists(filePath))
		{
			File.Delete(filePath);
		}

		assembly.Write(filePath, builder);
		Console.WriteLine($"\t{GetTypeCount()} top level types.");
		Console.WriteLine($"\t{GetMethodCount()} methods.");
		Console.WriteLine($"\t{GetPropertyCount()} properties.");
		Console.WriteLine($"\t{GetFieldCount()} fields.");
	}

	private static int GetTypeCount()
	{
		return SharedState.Instance.Module.TopLevelTypes.Count;
	}

	private static int GetMethodCount()
	{
		int sum = 0;
		foreach (TypeDefinition type in SharedState.Instance.Module.TopLevelTypes)
		{
			sum += GetMethodCount(type);
		}
		return sum;
	}

	private static int GetMethodCount(TypeDefinition type)
	{
		int sum = type.Methods.Count;
		foreach (TypeDefinition nestedType in type.NestedTypes)
		{
			sum += GetMethodCount(nestedType);
		}
		return sum;
	}

	private static int GetPropertyCount()
	{
		int sum = 0;
		foreach (TypeDefinition type in SharedState.Instance.Module.TopLevelTypes)
		{
			sum += GetPropertyCount(type);
		}
		return sum;
	}

	private static int GetPropertyCount(TypeDefinition type)
	{
		int sum = type.Properties.Count;
		foreach (TypeDefinition nestedType in type.NestedTypes)
		{
			sum += GetPropertyCount(nestedType);
		}
		return sum;
	}

	private static int GetFieldCount()
	{
		int sum = 0;
		foreach (TypeDefinition type in SharedState.Instance.Module.TopLevelTypes)
		{
			sum += GetFieldCount(type);
		}
		return sum;
	}

	private static int GetFieldCount(TypeDefinition type)
	{
		int sum = type.Fields.Count;
		foreach (TypeDefinition nestedType in type.NestedTypes)
		{
			sum += GetFieldCount(nestedType);
		}
		return sum;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/Pass999_Documentation.cs`:

```cs
using AssetRipper.AssemblyDumper.Documentation;
using AssetRipper.AssemblyDumper.Enums;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class Pass999_Documentation
{
	public static void DoPass()
	{
		InjectedDocumenter.AddDocumentation();

		foreach (ClassGroupBase group in SharedState.Instance.AllGroups)
		{
			InterfaceDocumenter.AddInterfaceDocumentation(group);

			foreach (GeneratedClassInstance instance in group.Instances)
			{
				ClassDocumenter.AddClassDocumentation(instance);
			}
		}

		IdEnumDocumenter.AddIdEnumDocumentation();

		foreach ((TypeDefinition type, EnumDefinitionBase definition) in Pass040_AddEnums.EnumDictionary.Values.Distinct())
		{
			EnumTypeDocumenter.AddEnumTypeDocumentation(type, definition);
		}

		DocumentationHandler.MakeDocumentationFile();
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/PropertyInjector.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Types;

namespace AssetRipper.AssemblyDumper.Passes;

internal static class PropertyInjector
{
	public static void InjectFullProperty(ClassGroupBase group, TypeSignature propertySignature, string propertyName, bool nullable)
	{
		PropertyDefinition interfaceProperty = group.Interface.AddFullProperty(propertyName, InterfaceUtils.InterfacePropertyDeclaration, propertySignature);
		if (nullable)
		{
			interfaceProperty.AddNullableAttributesForMaybeNull();
		}

		foreach (TypeDefinition type in group.Types)
		{
			FieldDefinition field = type.AddField($"m_{propertyName}", propertySignature, visibility: Visibility.Internal);
			field.AddDebuggerBrowsableNeverAttribute();
			PropertyDefinition property = type.ImplementFullProperty(propertyName, InterfaceUtils.InterfacePropertyImplementation, null, field);
			if (nullable)
			{
				field.AddNullableAttributesForMaybeNull();
				property.AddNullableAttributesForMaybeNull();
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Passes/TypeSignatureStruct.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Passes;

internal readonly struct TypeSignatureStruct : IEquatable<TypeSignatureStruct>
{
	private static readonly SignatureComparer signatureComparer = new();

	public TypeSignatureStruct(TypeSignature signature)
	{
		Signature = signature;
	}

	public TypeSignature Signature { get; }

	public override string ToString()
	{
		return Signature.ToString();
	}

	public override bool Equals(object? obj)
	{
		return (obj is TypeSignatureStruct @struct && Equals(@struct));
	}

	public bool Equals(TypeSignatureStruct other)
	{
		return signatureComparer.Equals(Signature, other.Signature);
	}

	public override int GetHashCode()
	{
		return signatureComparer.GetHashCode(Signature);
	}

	public static bool operator ==(TypeSignatureStruct left, TypeSignatureStruct right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(TypeSignatureStruct left, TypeSignatureStruct right)
	{
		return !(left == right);
	}

	public static implicit operator TypeSignature(TypeSignatureStruct signature) => signature.Signature;
	public static implicit operator TypeSignatureStruct(TypeSignature signature) => new TypeSignatureStruct(signature);
	public static implicit operator TypeSignatureStruct(TypeDefinition type) => new TypeSignatureStruct(type.ToTypeSignature());
}

```

`Source/AssetRipper.AssemblyDumper/Passes/ValidNameGenerator.cs`:

```cs
using System.Text.RegularExpressions;

internal static partial class ValidNameGenerator
{
	/// <summary>
	/// Fixes the string to be a valid field name
	/// </summary>
	/// <param name="originalName"></param>
	/// <returns>A new string with the valid content</returns>
	public static string GetValidFieldName(string originalName)
	{
		if (string.IsNullOrWhiteSpace(originalName))
		{
			throw new ArgumentException("Nodes cannot have a null or whitespace name", nameof(originalName));
		}
		string result = originalName.ReplaceBadCharacters();
		if (char.IsDigit(result[0]) || !result.StartsWith("m_", StringComparison.Ordinal))
		{
			result = "m_" + result;
		}
		if (char.IsLower(result[2]))
		{
			string remaining = result.Length > 3 ? result.Substring(3) : "";
			result = $"m_{char.ToUpperInvariant(result[2])}{remaining}";
		}
		return result;
	}

	/// <summary>
	/// Fixes the string to be a valid type name
	/// </summary>
	/// <param name="originalName"></param>
	/// <returns>A new string with the valid content</returns>
	public static string GetValidTypeName(string originalName)
	{
		if (string.IsNullOrWhiteSpace(originalName))
		{
			throw new ArgumentException("Nodes cannot have a null or whitespace type name", nameof(originalName));
		}
		string result = originalName.ReplaceBadCharacters();
		if (char.IsDigit(result[0]))
		{
			result = "_" + result;
		}
		if (char.IsLower(result[0]) && result.Length > 1)
		{
			result = char.ToUpperInvariant(result[0]) + result.Substring(1);
		}
		return result;
	}

	[GeneratedRegex("[<>\\[\\]\\s&\\(\\):\\.-]", RegexOptions.Compiled)]
	private static partial Regex GetBadCharactersRegex();

	private static string ReplaceBadCharacters(this string str) => GetBadCharactersRegex().Replace(str, "_");
}
```

`Source/AssetRipper.AssemblyDumper/Program.cs`:

```cs
using AssetRipper.AssemblyDumper.Passes;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper;

public static class Program
{
	public static void Main(string[] args)
	{
		RunGeneration();
	}

	private static void RunGeneration()
	{
		using (new TimingCookie("Pass 000: Initialization"))
		{
			Pass000_ProcessTpk.IntitializeSharedState("type_tree.tpk");
		}
		using (new TimingCookie("Pass 001: Merge Moved Groups"))
		{
			Pass001_MergeMovedGroups.DoPass();
		}
		using (new TimingCookie("Pass 002: Rename Subnodes"))
		{
			Pass002_RenameSubnodes.DoPass();
		}
		using (new TimingCookie("Pass 003: Fix TextureImporter Nodes"))
		{
			Pass003_FixTextureImporterNodes.DoPass();
		}
		using (new TimingCookie("Pass 004: Fill Name to Type Id Dictionary"))
		{
			Pass004_FillNameToTypeIdDictionary.DoPass();
		}
		using (new TimingCookie("Pass 005: Split Abstract Classes"))
		{
			Pass005_SplitAbstractClasses.DoPass();
		}
		using (new TimingCookie("Pass 007: Extract Subclasses"))
		{
			Pass007_ExtractSubclasses.DoPass();
		}
		using (new TimingCookie("Pass 008: Divide Ambiguous PPtr"))
		{
			Pass008_DivideAmbiguousPPtr.DoPass();
		}
		using (new TimingCookie("Pass 009: Create Groups"))
		{
			Pass009_CreateGroups.DoPass();
		}
		using (new TimingCookie("Pass 010: Initialize Interfaces"))
		{
			Pass010_InitializeInterfacesAndFactories.DoPass();
		}
		using (new TimingCookie("Pass 011: Apply Inheritance"))
		{
			Pass011_ApplyInheritance.DoPass();
		}
		using (new TimingCookie("Pass 012: Apply Correct Type Attributes"))
		{
			Pass012_ApplyCorrectTypeAttributes.DoPass();
		}
		using (new TimingCookie("Pass 013: Unify Fields of Abstract Types"))
		{
			Pass013_UnifyFieldsOfAbstractTypes.DoPass();
		}
		using (new TimingCookie("Pass 015: Add Fields"))
		{
			Pass015_AddFields.DoPass();
		}
		using (new TimingCookie("Pass 039: Inject Enum Values"))
		{
			Pass039_InjectEnumValues.DoPass();
		}
		using (new TimingCookie("Pass 040: Add Enum Types"))
		{
			Pass040_AddEnums.DoPass();
		}
		using (new TimingCookie("Pass 041: Add Native Enum Types"))
		{
			Pass041_NativeEnums.DoPass();
		}
		using (new TimingCookie("Pass 045: Marker Interfaces"))
		{
			Pass045_AddMarkerInterfaces.DoPass();
		}
		using (new TimingCookie("Pass 052: Interface Properties and Methods"))
		{
			Pass052_InterfacePropertiesAndMethods.DoPass();
		}
		using (new TimingCookie("Pass 053: Has Methods and Nullable Attributes"))
		{
			Pass053_HasMethodsAndNullableAttributes.DoPass();
		}
		using (new TimingCookie("Pass 054: Assign Property Histories"))
		{
			Pass054_AssignPropertyHistories.DoPass();
		}
		using (new TimingCookie("Pass 055: Create Enum Properties"))
		{
			Pass055_CreateEnumProperties.DoPass();
		}
		using (new TimingCookie("Pass 058: Inject Chinese Texture Properties"))
		{
			Pass058_InjectChineseTextureProperties.DoPass();
		}
		using (new TimingCookie("Pass 061: Add Constructors"))
		{
			Pass061_AddConstructors.DoPass();
		}
		using (new TimingCookie("Pass 062: Fill Constructors"))
		{
			Pass062_FillConstructors.DoPass();
		}
		using (new TimingCookie("Pass 063: Create Empty Methods"))
		{
			Pass063_CreateEmptyMethods.DoPass();
		}
		using (new TimingCookie("Pass 080: PPtr Conversions"))
		{
			Pass080_PPtrConversions.DoPass();
		}
		using (new TimingCookie("Pass 081: PPtr Properties"))
		{
			Pass081_CreatePPtrProperties.DoPass();
		}
		using (new TimingCookie("Pass 100: Filling Read Methods"))
		{
			Pass100_FillReadMethods.DoPass();
		}
		using (new TimingCookie("Pass 101: Filling Write Methods"))
		{
			Pass101_FillWriteMethods.DoPass();
		}
		using (new TimingCookie("Pass 102: Ignore Field In Meta Files Methods"))
		{
			Pass102_IgnoreFieldInMetaFilesMethods.DoPass();
		}
		using (new TimingCookie("Pass 103: Filling Dependency Methods"))
		{
			Pass103_FillDependencyMethods.DoPass();
		}
		using (new TimingCookie("Pass 104: Reset Methods"))
		{
			Pass104_ResetMethods.DoPass();
		}
		using (new TimingCookie("Pass 105: CopyValues Methods"))
		{
			Pass105_CopyValuesMethods.DoPass();
		}
		using (new TimingCookie("Pass 108: Walk Methods"))
		{
			Pass108_WalkMethods.DoPass();
		}
		using (new TimingCookie("Pass 110: Class Name and ID Overrides"))
		{
			Pass110_ClassNameAndIdOverrides.DoPass();
		}
		using (new TimingCookie("Pass 201: GUID Explicit Conversion"))
		{
			Pass201_GuidConversionOperators.DoPass();
		}
		using (new TimingCookie("Pass 202: Vector Explicit Conversions"))
		{
			Pass202_VectorExplicitConversions.DoPass();
		}
		using (new TimingCookie("Pass 203: OffsetPtr Implicit Conversions"))
		{
			Pass203_OffsetPtrImplicitConversions.DoPass();
		}
		using (new TimingCookie("Pass 204: Hash128 Explicit Conversion"))
		{
			Pass204_Hash128ExplicitConversion.DoPass();
		}
		using (new TimingCookie("Pass 205: Color Explicit Conversions"))
		{
			Pass205_ColorExplicitConversions.DoPass();
		}
		using (new TimingCookie("Pass 206: BoneWeights4 Explicit Conversions"))
		{
			Pass206_BoneWeights4ExplicitConversions.DoPass();
		}
		using (new TimingCookie("Pass 300: Named Interface"))
		{
			Pass300_NamedInterface.DoPass();
		}
		using (new TimingCookie("Pass 301: SourcePrefab Property"))
		{
			Pass301_SourcePrefabProperty.DoPass();
		}
		using (new TimingCookie("Pass 400: Equality Comparison"))
		{
			Pass400_EqualityComparison.DoPass();
		}
		using (new TimingCookie("Pass 410: SetValues Methods"))
		{
			Pass410_SetValuesMethods.DoPass();
		}
		using (new TimingCookie("Pass 500: Fixing PPtr Yaml"))
		{
			Pass500_PPtrFixes.DoPass();
		}
		using (new TimingCookie("Pass 501: Fixing MonoBehaviour"))
		{
			Pass501_MonoBehaviourImplementation.DoPass();
		}
		using (new TimingCookie("Pass 502: Fixing Guid and Hash Yaml Export"))
		{
			Pass502_FixGuidAndHashYaml.DoPass();
		}
		using (new TimingCookie("Pass 504: Fixing Shader Name"))
		{
			Pass504_FixShaderName.DoPass();
		}
		using (new TimingCookie("Pass 505: Fixing Old AudioClips"))
		{
			Pass505_FixOldAudioClip.DoPass();
		}
		using (new TimingCookie("Pass 506: Fixing UnityConnectSettings"))
		{
			Pass506_FixUnityConnectSettings.DoPass();
		}
		using (new TimingCookie("Pass 507: Inject Properties"))
		{
			Pass507_InjectedProperties.DoPass();
		}
		using (new TimingCookie("Pass 508: Lazy SceneObjectIdentifier"))
		{
			Pass508_LazySceneObjectIdentifier.DoPass();
		}
		using (new TimingCookie("Pass 510: Fix Component Pair Walking"))
		{
			Pass510_FixComponentPairWalking.DoPass();
		}
		using (new TimingCookie("Pass 555: Create Common String"))
		{
			Pass555_CreateCommonString.DoPass();
		}
		using (new TimingCookie("Pass 556: Create ClassIDType Enum"))
		{
			Pass556_CreateClassIDTypeEnum.DoPass();
		}
		using (new TimingCookie("Pass 557: Create SourceTpk Class"))
		{
			Pass557_CreateSourceTpkClass.DoPass();
		}
		using (new TimingCookie("Pass 558: Create Type to ClassIDType Dictionary"))
		{
			Pass558_TypeCache.DoPass();
		}
		using (new TimingCookie("Pass 920: Interface Inheritance"))
		{
			Pass920_InterfaceInheritance.DoPass();
		}
		using (new TimingCookie("Pass 940: Make Asset Factory"))
		{
			Pass940_MakeAssetFactory.DoPass();
		}
		using (new TimingCookie("Pass 941: Make Field Hashes"))
		{
			Pass941_MakeFieldHashes.DoPass();
		}
		using (new TimingCookie("Pass 998: Write Assembly"))
		{
			Pass998_SaveAssembly.DoPass();
		}
		using (new TimingCookie("Pass 999: Generate Documentation"))
		{
			Pass999_Documentation.DoPass();
		}
	}

	private readonly struct TimingCookie : IDisposable
	{
		private readonly Stopwatch stopWatch = new();

		public TimingCookie(string message)
		{
			Console.WriteLine(message);
			stopWatch.Start();
		}

		public void Dispose()
		{
			stopWatch.Stop();
			Console.WriteLine($"\tFinished in {stopWatch.ElapsedMilliseconds} ms");
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Properties/AssemblyInfo.cs`:

```cs
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("AssetRipper.AssemblyDumper.Tests")]
```

`Source/AssetRipper.AssemblyDumper/PropertyBase.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.DocExtraction.DataStructures;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper;

[DebuggerDisplay($"{{{nameof(GetDebuggerDisplay)}(),nq}}")]
internal abstract class PropertyBase
{
	protected PropertyBase(PropertyDefinition definition)
	{
		Definition = definition;
	}

	public PropertyDefinition Definition { get; }
	public PropertyDefinition? SpecialDefinition { get; set; }
	public DataMemberHistory? History { get; set; }
	public MethodDefinition? HasMethod { get; set; }
	public MethodDefinition? ReleaseOnlyMethod { get; set; }
	public MethodDefinition? EditorOnlyMethod { get; set; }

	[MemberNotNullWhen(true, nameof(SpecialDefinition))]
	public bool HasEnumVariant
	{
		get
		{
			return SpecialDefinition?.Signature?.ReturnType.ToTypeDefOrRef() is TypeDefinition typeDefinition
				&& typeDefinition.IsEnum;
		}
	}

	public bool HasSetAccessor => Definition.SetMethod != null;

	/// <summary>
	/// The <see cref="PropertyDefinition.Name"/> for <see cref="Definition"/>.
	/// </summary>
	public string Name => Definition.Name ?? "";

	public virtual bool IsInjected => false;

	/// <summary>
	/// Import references for doing an equality comparison of this property.
	/// </summary>
	/// <param name="getReference">A reference to a static, parameterless method returning a <see cref="EqualityComparer{T}"/>.</param>
	/// <param name="equalsReference">A reference to the corresponding <see cref="EqualityComparer{T}.Equals(T?, T?)"/> method.</param>
	public virtual void GetEqualityComparer(out IMethodDefOrRef getReference, out IMethodDefOrRef equalsReference)
	{
		EqualityMethods.MakeEqualityComparerGenericMethods(
			Definition.Signature!.ReturnType,
			SharedState.Instance.Importer,
			out getReference,
			out equalsReference);
	}

	private string GetDebuggerDisplay() => Name;
}

```

`Source/AssetRipper.AssemblyDumper/SharedState.cs`:

```cs
using AsmResolver.DotNet.Cloning;
using AssetRipper.AssemblyDumper.Attributes;
using AssetRipper.AssemblyDumper.Methods;
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.DocExtraction.DataStructures;

namespace AssetRipper.AssemblyDumper;

internal sealed class SharedState : AssemblyBuilder
{
	public const string AssemblyName = "AssetRipper.SourceGenerated";
	public const string RootNamespace = AssemblyName;
	public const string ClassesNamespace = RootNamespace + ".Classes";
	public const string EnumsNamespace = RootNamespace + ".Enums";
	public const string ExceptionsNamespace = RootNamespace + ".Exceptions";
	public const string InterfacesNamespace = RootNamespace + ".Interfaces";
	public const string HelpersNamespace = RootNamespace + ".Helpers";
	public const string MarkerInterfacesNamespace = RootNamespace + ".MarkerInterfaces";
	public const string NativeEnumsNamespace = RootNamespace + ".NativeEnums";
	public const string SubclassesNamespace = RootNamespace + ".Subclasses";

	public static string GetClassNamespace(int id) => $"{ClassesNamespace}.ClassID_{id}";
	public static string GetSubclassNamespace(string className) => $"{SubclassesNamespace}.{className}";

	private static SharedState? _instance;

	public static SharedState Instance => _instance ?? throw new NullReferenceException("ShareState.Instance not initialized");

	public UnityVersion MinVersion { get; }
	/// <summary>
	/// The minimum version in <see cref="SourceVersions"/>.
	/// </summary>
	/// <remarks>
	/// This is used for versions without stripping, such as enums.
	/// </remarks>
	public UnityVersion MinSourceVersion => SourceVersions[0];
	public UnityVersion MaxVersion { get; }
	public UnityVersion[] SourceVersions { get; }
	/// <summary>
	/// The processed type tree data
	/// </summary>
	/// <remarks>
	/// This is different from the original type tree data. In particular, it removes unnecessary types and moves versions to the inferred boundaries.
	/// </remarks>
	public byte[] TpkData { get; }
	public UniversalCommonString CommonString { get; }
	public HistoryFile HistoryFile { get; }
	public Dictionary<int, VersionedList<UniversalClass>> ClassInformation { get; }
	public Dictionary<string, VersionedList<UniversalClass>> SubclassInformation { get; } = new();
	public Dictionary<int, ClassGroup> ClassGroups { get; } = new();
	public Dictionary<string, SubclassGroup> SubclassGroups { get; } = new();
	public Dictionary<TypeDefinition, ClassGroupBase> TypesToGroups { get; } = new();
	public Dictionary<TypeDefinition, GeneratedClassInstance> TypesToInstances { get; } = new();
	public Dictionary<string, HashSet<int>> NameToTypeID { get; } = new();
	public Dictionary<string, TypeDefinition> MarkerInterfaces { get; } = new();
	private Dictionary<Type, TypeDefinition> InjectedHelperTypes { get; } = new();

	public IEnumerable<ClassGroupBase> AllGroups => ClassGroups.Values.Union<ClassGroupBase>(SubclassGroups.Values);
	public IEnumerable<GeneratedClassInstance> AllInstances => AllGroups.SelectMany(g => g.Instances);
	public IEnumerable<TypeDefinition> AllTypes => TypesToGroups.Keys;
	public IEnumerable<TypeDefinition> AllNonInterfaceTypes => AllTypes.Where(t => !t.IsInterface);

	public MethodDefinition EmbeddedAttributeConstructor { get; }
	public MethodDefinition NullableAttributeConstructorByte { get; }
	public MethodDefinition NullableAttributeConstructorByteArray { get; }
	public MethodDefinition NullableContextAttributeConstructor { get; }
	public TypeDefinition PrivateImplementationDetails { get; }

	private static readonly string referenceDirectory;

	static SharedState()
	{
		referenceDirectory = "";
		for (int i = 50; i >= 0; i--)
		{
			string path = @$"C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref\9.0.{i}\ref\net9.0\";
			if (Directory.Exists(path))
			{
				referenceDirectory = path;
				break;
			}
		}
		if (referenceDirectory.Length == 0)
		{
			throw new InvalidOperationException(".NET reference directory could not be found");
		}
	}

	private SharedState(
		UnityVersion[] sourceVersions,
		Dictionary<int, VersionedList<UniversalClass>> classes,
		UniversalCommonString commonString,
		byte[] tpkData)
		: base(AssemblyName, new Version(0, 0, 0, 0), KnownCorLibs.SystemRuntime_v9_0_0_0)
	{
		SourceVersions = sourceVersions;
		CommonString = commonString;
		ClassInformation = classes;
		TpkData = tpkData;
		HistoryFile = HistoryFile.FromFile("consolidated.json");

		//input array is sequentially ordered
		MinVersion = sourceVersions[0].StripType();
		MaxVersion = sourceVersions[sourceVersions.Length - 1];

		AddReferenceModules();

		CompilerInjectedAttributeCreator.CreateEmbeddedAttribute(Importer, out MethodDefinition embeddedAttributeConstructor);
		EmbeddedAttributeConstructor = embeddedAttributeConstructor;
		NullableContextAttributeConstructor = CompilerInjectedAttributeCreator.CreateNullableContextAttribute(Importer, embeddedAttributeConstructor)
			.GetConstructor(1);
		TypeDefinition nullableAttributeType = CompilerInjectedAttributeCreator.CreateNullableAttribute(Importer, embeddedAttributeConstructor);
		NullableAttributeConstructorByte = nullableAttributeType.Methods
			.Single(m => m.IsConstructor && m.Parameters.Count == 1 && m.Parameters[0].ParameterType is CorLibTypeSignature);
		NullableAttributeConstructorByteArray = nullableAttributeType.Methods
			.Single(m => m.IsConstructor && m.Parameters.Count == 1 && m.Parameters[0].ParameterType is SzArrayTypeSignature);

		PrivateImplementationDetails = new TypeDefinition(null, "<PrivateImplementationDetails>", TypeAttributes.NotPublic | TypeAttributes.AutoLayout | TypeAttributes.AnsiClass | TypeAttributes.Sealed);
		Module.TopLevelTypes.Add(PrivateImplementationDetails);
		PrivateImplementationDetails.AddCompilerGeneratedAttribute(Importer);
		TpkData = tpkData;
	}

	public static void Initialize(
		UnityVersion[] sourceVersions,
		Dictionary<int, VersionedList<UniversalClass>> classes,
		UniversalCommonString commonString,
		byte[] tpkData)
	{
		_instance = new SharedState(sourceVersions, classes, commonString, tpkData);
		_instance.AddTargetFrameworkAttribute(".NET 9.0");
		File.WriteAllBytes("processed.tpk", tpkData);
	}

	private void AddReferenceModules()
	{
		AddLocalReferenceModule("AssetRipper.Assets");
		AddLocalReferenceModule("AssetRipper.IO.Endian");
		AddLocalReferenceModule("AssetRipper.IO.Files");
		AddLocalReferenceModule("AssetRipper.Numerics");
		AddLocalReferenceModule("AssetRipper.Primitives");
		AddSystemReferenceModule("System.Runtime");
		AddSystemReferenceModule("System.Numerics.Vectors");
		AddSystemReferenceModule("System.Linq");
		AddSystemReferenceModule("System.Collections");
		AddSystemReferenceModule("System.Text.Json");
		AddSystemReferenceModule("System.Threading");
		AddLocalReferenceModule("AssetRipper.AssemblyDumper");//needed for member cloning
	}

	private void AddLocalReferenceModule(string name)
	{
		string path = Path.Combine(AppContext.BaseDirectory, $"{name}.dll"); ;
		AddReferenceModule(path);
	}

	private void AddSystemReferenceModule(string name)
	{
		string path = $"{referenceDirectory}{name}.dll";
		AddReferenceModule(path);
	}

	private void AddReferenceModule(string path)
	{
		ModuleDefinition module = ModuleDefinition.FromFile(path);
		Importer.AddReferenceModule(module);
	}

	public static void Clear() => _instance = null;

	internal GeneratedClassInstance GetGeneratedInstanceForObjectType(string typeName, UnityVersion version)
	{
		if (NameToTypeID.TryGetValue(typeName, out HashSet<int>? list))
		{
			foreach (int id in list)
			{
				ClassGroup group = ClassGroups[id];
				foreach (GeneratedClassInstance instance in group.Instances)
				{
					if (instance.VersionRange.Contains(version) && typeName == instance.Name)
					{
						return instance;
					}
				}
			}
			throw new Exception($"Could not find type {typeName} on version {version}");
		}
		else
		{
			throw new Exception($"Could not find {typeName} in the name dictionary");
		}
	}

	internal ClassGroup GetClassGroupForObjectType(string typeName, UnityVersion version)
	{
		if (NameToTypeID.TryGetValue(typeName, out HashSet<int>? list))
		{
			foreach (int id in list)
			{
				ClassGroup group = ClassGroups[id];
				foreach (GeneratedClassInstance instance in group.Instances)
				{
					if (instance.VersionRange.Contains(version) && typeName == instance.Name)
					{
						return group;
					}
				}
			}
			throw new Exception($"Could not find type {typeName} on version {version}");
		}
		else
		{
			throw new Exception($"Could not find {typeName} in the name dictionary");
		}
	}

	internal TypeDefinition InjectHelperType(Type type)
	{
		if (!InjectedHelperTypes.TryGetValue(type, out TypeDefinition? helperType))
		{
			MemberCloner cloner = new MemberCloner(Module);
			cloner.Include(Importer.LookupType(type) ?? throw new NullReferenceException(type.FullName), true);
			MemberCloneResult result = cloner.Clone();
			helperType = result.ClonedTopLevelTypes.Single();
			helperType.Namespace = HelpersNamespace;
			Module.TopLevelTypes.Add(helperType);
			InjectedHelperTypes.Add(type, helperType);
		}
		return helperType;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Types/EnumCreator.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Types;

public static class EnumCreator
{
	private static TypeDefinition CreateFromExisting<T>(AssemblyBuilder builder, string? @namespace, string name) where T : struct, Enum
	{
		EnumUnderlyingType underlyingType = Enum.GetUnderlyingType(typeof(T)).ToEnumUnderlyingType();
		TypeDefinition definition = CreateEmptyEnum(builder, @namespace, name, underlyingType);
		foreach (long item in Enum.GetValues<T>().Select(i => (IConvertible)i).Select(i => i.ToInt64(null)))
		{
			definition.AddEnumField(item.ToString(), item, underlyingType);
		}

		return definition;
	}

	public static TypeDefinition CreateFromDictionary(AssemblyBuilder builder, string? @namespace, string name, IEnumerable<KeyValuePair<string, long>> fields, EnumUnderlyingType underlyingType = EnumUnderlyingType.Int32)
	{
		TypeDefinition definition = CreateEmptyEnum(builder, @namespace, name, underlyingType);
		foreach (KeyValuePair<string, long> pair in fields)
		{
			definition.AddEnumField(pair.Key, pair.Value, underlyingType);
		}

		return definition;
	}

	public static TypeDefinition CreateFromArray(AssemblyBuilder builder, string? @namespace, string name, string[] fields, EnumUnderlyingType underlyingType = EnumUnderlyingType.Int32)
	{
		TypeDefinition definition = CreateEmptyEnum(builder, @namespace, name, underlyingType);
		for (int i = 0; i < fields.Length; i++)
		{
			definition.AddEnumField(fields[i], i, underlyingType);
		}

		return definition;
	}

	private static void AddEnumValue(this TypeDefinition typeDefinition, AssemblyBuilder builder, EnumUnderlyingType underlyingType)
	{
		FieldSignature fieldSignature = new FieldSignature(underlyingType.ToTypeSignature(builder));
		FieldDefinition fieldDef = new FieldDefinition("value__", FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RuntimeSpecialName, fieldSignature);
		typeDefinition.Fields.Add(fieldDef);
	}

	public static FieldDefinition AddEnumField(this TypeDefinition typeDefinition, string name, long value, EnumUnderlyingType underlyingType)
	{
		FieldSignature fieldSignature = new FieldSignature(typeDefinition.ToTypeSignature());
		FieldDefinition fieldDef = new FieldDefinition(name, FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal | FieldAttributes.HasDefault, fieldSignature);
		fieldDef.Constant = FromValue(value, underlyingType);
		typeDefinition.Fields.Add(fieldDef);
		return fieldDef;
	}

	public static TypeDefinition CreateEmptyEnum(AssemblyBuilder builder, string? @namespace, string name, EnumUnderlyingType underlyingType)
	{
		ITypeDefOrRef enumReference = builder.Importer.ImportType(typeof(Enum));
		TypeDefinition definition = new TypeDefinition(@namespace, name, TypeAttributes.Public | TypeAttributes.Sealed, enumReference);
		builder.Module.TopLevelTypes.Add(definition);
		definition.AddEnumValue(builder, underlyingType);
		return definition;
	}

	private static Constant FromValue(long value, EnumUnderlyingType underlyingType)
	{
		return underlyingType switch
		{
			EnumUnderlyingType.Int8 => Constant.FromValue((sbyte)value),
			EnumUnderlyingType.UInt8 => Constant.FromValue(ToByte(value)),
			EnumUnderlyingType.Int16 => Constant.FromValue((short)value),
			EnumUnderlyingType.UInt16 => Constant.FromValue(ToUShort(value)),
			EnumUnderlyingType.Int32 => Constant.FromValue((int)value),
			EnumUnderlyingType.UInt32 => Constant.FromValue(ToUInt(value)),
			EnumUnderlyingType.Int64 => Constant.FromValue(value),
			EnumUnderlyingType.UInt64 => Constant.FromValue(unchecked((ulong)value)),
			_ => throw new ArgumentOutOfRangeException(nameof(underlyingType)),
		};

		static byte ToByte(long value)
		{
			if (value < 0)
			{
				sbyte value1 = checked((sbyte)value);
				return unchecked((byte)value1);
			}
			else
			{
				return checked((byte)value);
			}
		}

		static ushort ToUShort(long value)
		{
			if (value < 0)
			{
				short value1 = checked((short)value);
				return unchecked((ushort)value1);
			}
			else
			{
				return checked((ushort)value);
			}
		}

		static uint ToUInt(long value)
		{
			if (value < 0)
			{
				int value1 = checked((int)value);
				return unchecked((uint)value1);
			}
			else
			{
				return checked((uint)value);
			}
		}
	}
}

```

`Source/AssetRipper.AssemblyDumper/Types/EnumUnderlyingType.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Types;

public enum EnumUnderlyingType : byte
{
	/// <summary>
	/// sbyte
	/// </summary>
	Int8,
	/// <summary>
	/// byte
	/// </summary>
	UInt8,
	/// <summary>
	/// short
	/// </summary>
	Int16,
	/// <summary>
	/// ushort
	/// </summary>
	UInt16,
	/// <summary>
	/// int
	/// </summary>
	Int32,
	/// <summary>
	/// uint
	/// </summary>
	UInt32,
	/// <summary>
	/// long
	/// </summary>
	Int64,
	/// <summary>
	/// ulong
	/// </summary>
	UInt64,
}

public static class EnumUnderlyingTypeExtensions
{
	public static CorLibTypeSignature ToTypeSignature(this EnumUnderlyingType enumUnderlyingType, AssemblyBuilder builder)
	{
		return enumUnderlyingType.ToTypeSignature(builder.Importer);
	}

	public static CorLibTypeSignature ToTypeSignature(this EnumUnderlyingType enumUnderlyingType, CachedReferenceImporter importer)
	{
		return enumUnderlyingType switch
		{
			EnumUnderlyingType.Int8 => importer.Int8,
			EnumUnderlyingType.UInt8 => importer.UInt8,
			EnumUnderlyingType.Int16 => importer.Int16,
			EnumUnderlyingType.UInt16 => importer.UInt16,
			EnumUnderlyingType.Int32 => importer.Int32,
			EnumUnderlyingType.UInt32 => importer.UInt32,
			EnumUnderlyingType.Int64 => importer.Int64,
			EnumUnderlyingType.UInt64 => importer.UInt64,
			_ => throw new ArgumentOutOfRangeException(nameof(enumUnderlyingType)),
		};
	}

	public static EnumUnderlyingType ToEnumUnderlyingType(this Type type)
	{
		if (type.Namespace != "System")
		{
			throw new ArgumentException($"{type.Namespace} is not a valid namespace for an underlying enum type", nameof(type));
		}

		return type.Name switch
		{
			nameof(SByte) => EnumUnderlyingType.Int8,
			nameof(Byte) => EnumUnderlyingType.UInt8,
			nameof(Int16) => EnumUnderlyingType.Int16,
			nameof(UInt16) => EnumUnderlyingType.UInt16,
			nameof(Int32) => EnumUnderlyingType.Int32,
			nameof(UInt32) => EnumUnderlyingType.UInt32,
			nameof(Int64) => EnumUnderlyingType.Int64,
			nameof(UInt64) => EnumUnderlyingType.UInt64,
			_ => throw new ArgumentOutOfRangeException(nameof(type), $"{type.Name} is not a valid type name for an underlying enum type"),
		};
	}

	public static EnumUnderlyingType ToEnumUnderlyingType(this ElementType type)
	{
		return type switch
		{
			ElementType.I1 => EnumUnderlyingType.Int8,
			ElementType.U1 => EnumUnderlyingType.UInt8,
			ElementType.I2 => EnumUnderlyingType.Int16,
			ElementType.U2 => EnumUnderlyingType.UInt16,
			ElementType.I4 => EnumUnderlyingType.Int32,
			ElementType.U4 => EnumUnderlyingType.UInt32,
			ElementType.I8 => EnumUnderlyingType.Int64,
			ElementType.U8 => EnumUnderlyingType.UInt64,
			_ => throw new ArgumentOutOfRangeException(nameof(type), $"{type} is not a valid type name for an underlying enum type"),
		};
	}
}

```

`Source/AssetRipper.AssemblyDumper/Types/ExceptionCreator.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;

namespace AssetRipper.AssemblyDumper.Types;

public static class ExceptionCreator
{
	public static TypeDefinition CreateSimpleException(CachedReferenceImporter importer, string @namespace, string name, string errorMessage)
	{
		ITypeDefOrRef exceptionRef = importer.ImportType<Exception>();
		TypeDefinition type = new TypeDefinition(@namespace, name, TypeAttributes.Public | TypeAttributes.Sealed, exceptionRef);
		importer.TargetModule.TopLevelTypes.Add(type);
		IMethodDefOrRef exceptionConstructor = importer.ImportConstructor<Exception>(1);
		MethodDefinition constructor = type.AddEmptyConstructor();
		CilInstructionCollection instructions = constructor.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldstr, errorMessage);
		instructions.Add(CilOpCodes.Call, exceptionConstructor);
		instructions.Add(CilOpCodes.Ret);
		return type;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Types/FunctionPointerCreator.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Types;

public static class FunctionPointerCreator
{
	public static FunctionPointerTypeSignature CreateUnmanaged(TypeSignature returnType, IEnumerable<TypeSignature> parameterTypes)
	{
		MethodSignature methodSignature = new MethodSignature(CallingConventionAttributes.Unmanaged | CallingConventionAttributes.C, returnType, parameterTypes);
		return new FunctionPointerTypeSignature(methodSignature);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Types/FunctionPointerStructCreator.cs`:

```cs
using AssetRipper.AssemblyDumper.Methods;
using System.Runtime.InteropServices;

namespace AssetRipper.AssemblyDumper.Types;

public static class FunctionPointerStructCreator
{
	public static TypeDefinition Create(AssemblyBuilder builder, string @namespace, string name, TypeSignature returnType, Dictionary<string, TypeSignature> parameters)
	{
		TypeDefinition type = StructCreator.CreateEmptyStruct(builder, @namespace, name);
		FieldDefinition field = type.AddField("address", builder.Importer.IntPtr);
		MethodDefinition constructor = type.AddConstructor(field);
		FunctionPointerTypeSignature functionPointerSignature = FunctionPointerCreator.CreateUnmanaged(returnType, parameters.Values);
		TypeSignature managedDelegateSignature = ResolveManagedDelegateSignature(builder.Importer, returnType, parameters.Values.ToArray());
		type.AddConversionToIntPtr(builder.Importer, field);
		type.AddConversionFromIntPtr(builder.Importer, field, constructor);
		type.AddConversionToFunctionPointer(builder.Importer, field, functionPointerSignature);
		type.AddConversionFromFunctionPointer(builder.Importer, constructor, functionPointerSignature);
		MethodDefinition managedDelegateConversionMethod = type.AddConversionToManagedDelegate(builder.Importer, field, managedDelegateSignature);
		type.AddInvokeMethod(builder.Importer, managedDelegateConversionMethod, managedDelegateSignature, returnType, parameters);
		return type;
	}

	private static MethodDefinition AddConstructor(this TypeDefinition type, FieldDefinition field)
	{
		MethodDefinition constructor = type.AddMethod(
			".ctor",
			MethodAttributes.Public |
			MethodAttributes.HideBySig |
			MethodAttributes.SpecialName |
			MethodAttributes.RuntimeSpecialName,
			type.DeclaringModule!.CorLibTypeFactory.Void);

		constructor.AddParameter(type.DeclaringModule.CorLibTypeFactory.IntPtr, "address");

		CilInstructionCollection instructions = constructor.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldarg_1);
		instructions.Add(CilOpCodes.Stfld, field);
		instructions.Add(CilOpCodes.Ret);
		return constructor;
	}

	private static MethodDefinition AddConversionToManagedDelegate(this TypeDefinition type, CachedReferenceImporter importer, FieldDefinition field, TypeSignature managedDelegateSignature)
	{
		MethodDefinition conversion = type.AddEmptyConversion(type.ToTypeSignature(), managedDelegateSignature, false);

		IMethodDefOrRef genericMarshalMethod = importer.ImportMethod(typeof(Marshal), m => m.Name == nameof(Marshal.GetDelegateForFunctionPointer) && m.GenericParameters.Count == 1);
		MethodSpecification instanceMarshalMethod = genericMarshalMethod.MakeGenericInstanceMethod(managedDelegateSignature);

		CilInstructionCollection instructions = conversion.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, field);
		instructions.Add(CilOpCodes.Call, instanceMarshalMethod);
		instructions.Add(CilOpCodes.Ret);
		return conversion;
	}

	private static MethodDefinition AddConversionToFunctionPointer(this TypeDefinition type, CachedReferenceImporter importer, FieldDefinition field, FunctionPointerTypeSignature functionPointerSignature)
	{
		MethodDefinition conversion = type.AddEmptyConversion(type.ToTypeSignature(), functionPointerSignature, true);

		CilLocalVariable local = new CilLocalVariable(functionPointerSignature);
		conversion.CilMethodBody!.LocalVariables.Add(local);

		IMethodDefOrRef intPtrConversionMethod = importer.ImportMethod(typeof(nint), m => m.Name == "op_Explicit" && m.Signature!.ReturnType is PointerTypeSignature);

		CilInstructionCollection instructions = conversion.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, field);
		instructions.Add(CilOpCodes.Call, intPtrConversionMethod);
		instructions.Add(CilOpCodes.Stloc, local);
		instructions.Add(CilOpCodes.Ldloc, local);
		instructions.Add(CilOpCodes.Ret);
		return conversion;
	}

	private static MethodDefinition AddConversionFromFunctionPointer(this TypeDefinition type, CachedReferenceImporter importer, MethodDefinition constructor, FunctionPointerTypeSignature functionPointerSignature)
	{
		MethodDefinition conversion = type.AddEmptyConversion(functionPointerSignature, type.ToTypeSignature(), true);

		//CilLocalVariable local = new CilLocalVariable(type.ToTypeSignature());
		//conversion.CilMethodBody!.LocalVariables.Add(local);

		IMethodDefOrRef intPtrConversionMethod = importer.ImportMethod(typeof(nint), m => m.Name == "op_Explicit" && m.Parameters.Count == 1 && m.Parameters[0].ParameterType is PointerTypeSignature);

		CilInstructionCollection instructions = conversion.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Call, intPtrConversionMethod);
		instructions.Add(CilOpCodes.Newobj, constructor);
		//instructions.Add(CilOpCodes.Stloc, local);
		//instructions.Add(CilOpCodes.Ldloc, local);
		instructions.Add(CilOpCodes.Ret);
		return conversion;
	}

	private static MethodDefinition AddConversionToIntPtr(this TypeDefinition type, CachedReferenceImporter importer, FieldDefinition field)
	{
		MethodDefinition conversion = type.AddEmptyConversion(type.ToTypeSignature(), importer.IntPtr, false);

		CilInstructionCollection instructions = conversion.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldfld, field);
		instructions.Add(CilOpCodes.Ret);
		return conversion;
	}

	private static MethodDefinition AddConversionFromIntPtr(this TypeDefinition type, CachedReferenceImporter importer, FieldDefinition field, MethodDefinition constructor)
	{
		MethodDefinition conversion = type.AddEmptyConversion(importer.IntPtr, type.ToTypeSignature(), false);

		CilLocalVariable local = new CilLocalVariable(type.ToTypeSignature());
		conversion.CilMethodBody!.LocalVariables.Add(local);

		CilInstructionCollection instructions = conversion.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Newobj, constructor);
		instructions.Add(CilOpCodes.Ret);
		return conversion;
	}

	private static MethodDefinition AddInvokeMethod(
		this TypeDefinition type,
		CachedReferenceImporter importer,
		MethodDefinition explicitConversion,
		TypeSignature managedDelegateSignature,
		TypeSignature returnType,
		Dictionary<string, TypeSignature> parameterDictionary)
	{
		MethodDefinition conversion = type.AddMethod("Invoke", MethodAttributes.Public | MethodAttributes.HideBySig, returnType);

		Parameter[] parameters = new Parameter[parameterDictionary.Count];
		int i = 0;
		foreach (var parameterDescription in parameterDictionary)
		{
			parameters[i] = conversion.AddParameter(parameterDescription.Value, parameterDescription.Key);
			i++;
		}

		//CilLocalVariable local = new CilLocalVariable(type.ToTypeSignature());
		//conversion.CilMethodBody!.LocalVariables.Add(local);

		IMethodDefOrRef invokeMethod;
		if (managedDelegateSignature is GenericInstanceTypeSignature genericDelegateSignature)
		{
			invokeMethod = MethodUtils.MakeMethodOnGenericType(importer, genericDelegateSignature, m => m.Name == "Invoke");
		}
		else
		{
			invokeMethod = importer.ImportMethod<Action>(m => m.Name == "Invoke");
		}

		CilInstructionCollection instructions = conversion.CilMethodBody!.Instructions;
		instructions.Add(CilOpCodes.Ldarg_0);
		instructions.Add(CilOpCodes.Ldobj, type);
		instructions.Add(CilOpCodes.Call, explicitConversion);
		for (int j = 0; j < parameters.Length; j++)
		{
			instructions.Add(CilOpCodes.Ldarg, parameters[j]);
		}
		instructions.Add(CilOpCodes.Callvirt, invokeMethod);
		//instructions.Add(CilOpCodes.Stloc, local);
		//instructions.Add(CilOpCodes.Ldloc, local);
		instructions.Add(CilOpCodes.Ret);
		instructions.OptimizeMacros();
		return conversion;
	}

	private static TypeSignature ResolveManagedDelegateSignature(CachedReferenceImporter importer, TypeSignature returnType, TypeSignature[] parameterTypes)
	{
		bool useFunc = returnType.FullName != typeof(void).FullName;
		if (useFunc)
		{
			TypeSignature funcType = importer.ImportTypeSignature(GetFuncType(parameterTypes.Length));
			TypeSignature[] funcTypeParameters = new TypeSignature[parameterTypes.Length + 1];
			Array.Copy(parameterTypes, 0, funcTypeParameters, 0, parameterTypes.Length);
			funcTypeParameters[parameterTypes.Length] = returnType;
			return funcType.MakeGenericInstanceType(funcTypeParameters);
		}
		else
		{
			TypeSignature actionType = importer.ImportTypeSignature(GetActionType(parameterTypes.Length));
			return parameterTypes.Length == 0 ? actionType : actionType.MakeGenericInstanceType(parameterTypes);
		}
	}

	private static Type GetActionType(int parameterCount)
	{
		return parameterCount switch
		{
			0 => typeof(Action),
			1 => typeof(Action<>),
			2 => typeof(Action<,>),
			3 => typeof(Action<,,>),
			4 => typeof(Action<,,,>),
			5 => typeof(Action<,,,,>),
			6 => typeof(Action<,,,,,>),
			7 => typeof(Action<,,,,,,>),
			8 => typeof(Action<,,,,,,,>),
			9 => typeof(Action<,,,,,,,,>),
			10 => typeof(Action<,,,,,,,,,>),
			11 => typeof(Action<,,,,,,,,,,>),
			12 => typeof(Action<,,,,,,,,,,,>),
			13 => typeof(Action<,,,,,,,,,,,,>),
			14 => typeof(Action<,,,,,,,,,,,,,>),
			15 => typeof(Action<,,,,,,,,,,,,,,>),
			16 => typeof(Action<,,,,,,,,,,,,,,,>),
			_ => throw new ArgumentOutOfRangeException(nameof(parameterCount)),
		};
	}

	private static Type GetFuncType(int parameterCount)
	{
		return parameterCount switch
		{
			0 => typeof(Func<>),
			1 => typeof(Func<,>),
			2 => typeof(Func<,,>),
			3 => typeof(Func<,,,>),
			4 => typeof(Func<,,,,>),
			5 => typeof(Func<,,,,,>),
			6 => typeof(Func<,,,,,,>),
			7 => typeof(Func<,,,,,,,>),
			8 => typeof(Func<,,,,,,,,>),
			9 => typeof(Func<,,,,,,,,,>),
			10 => typeof(Func<,,,,,,,,,,>),
			11 => typeof(Func<,,,,,,,,,,,>),
			12 => typeof(Func<,,,,,,,,,,,,>),
			13 => typeof(Func<,,,,,,,,,,,,,>),
			14 => typeof(Func<,,,,,,,,,,,,,,>),
			15 => typeof(Func<,,,,,,,,,,,,,,,>),
			16 => typeof(Func<,,,,,,,,,,,,,,,,>),
			_ => throw new ArgumentOutOfRangeException(nameof(parameterCount)),
		};
	}
}

```

`Source/AssetRipper.AssemblyDumper/Types/InterfaceCreator.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Types;

public static class InterfaceCreator
{
	public static TypeDefinition CreateEmptyInterface(ModuleDefinition module, string? @namespace, string? name)
	{
		TypeDefinition definition = new TypeDefinition(@namespace, name, TypeAttributes.Public | TypeAttributes.Interface);
		module!.TopLevelTypes.Add(definition);
		return definition;
	}

	public static TypeDefinition CreateEmptyInterface(ModuleDefinition module, string? @namespace, string? name, params ITypeDefOrRef[] interfaces)
	{
		TypeDefinition emptyInterface = CreateEmptyInterface(module, @namespace, name);
		foreach (ITypeDefOrRef implementedInterface in interfaces)
		{
			emptyInterface.AddInterfaceImplementation(implementedInterface);
		}

		return emptyInterface;
	}
}
```

`Source/AssetRipper.AssemblyDumper/Types/InterfaceUtils.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Types;

public static class InterfaceUtils
{
	public const MethodAttributes InterfaceMethodImplementation =
		MethodAttributes.Public |
		MethodAttributes.Final |
		MethodAttributes.HideBySig |
		MethodAttributes.NewSlot |
		MethodAttributes.Virtual;
	public const MethodAttributes InterfaceMethodDeclaration =
		MethodAttributes.Public |
		MethodAttributes.Abstract |
		MethodAttributes.HideBySig |
		MethodAttributes.NewSlot |
		MethodAttributes.Virtual;
	public const MethodAttributes InterfacePropertyImplementation =
		InterfaceMethodImplementation |
		MethodAttributes.SpecialName;
	public const MethodAttributes InterfacePropertyDeclaration =
		InterfaceMethodDeclaration |
		MethodAttributes.SpecialName;

	public static void AddInterfaceImplementation<T>(this TypeDefinition type, CachedReferenceImporter importer)
	{
		type.Interfaces.Add(new InterfaceImplementation(importer.ImportType<T>()));
	}

	public static void AddInterfaceImplementation(this TypeDefinition type, ITypeDefOrRef interfaceReference)
	{
		type.Interfaces.Add(new InterfaceImplementation(interfaceReference));
	}

	public static TypeSignature GetPropertyTypeSignature<T>(string propertyName, CachedReferenceImporter importer)
	{
		return importer.UnderlyingImporter.ImportTypeSignature(
			importer.
			LookupType<T>()!.
			Properties.
			Single(p => p.Name == propertyName).
			Signature!.
			ReturnType);
	}
}

```

`Source/AssetRipper.AssemblyDumper/Types/StaticClassCreator.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Types;

public static class StaticClassCreator
{
	public const TypeAttributes StaticClassAttributes =
		TypeAttributes.AnsiClass |
		TypeAttributes.BeforeFieldInit |
		TypeAttributes.Public |
		TypeAttributes.Sealed |
		TypeAttributes.Abstract;
	private const MethodAttributes StaticConstructorAttributes =
		MethodAttributes.Private |
		MethodAttributes.HideBySig |
		MethodAttributes.RuntimeSpecialName |
		MethodAttributes.SpecialName |
		MethodAttributes.Static;
	public const MethodAttributes StaticMethodAttributes =
		MethodAttributes.Public |
		MethodAttributes.HideBySig |
		MethodAttributes.Static;

	public static TypeDefinition CreateEmptyStaticClass(ModuleDefinition module, string? @namespace, string? name)
	{
		TypeDefinition newTypeDef = new TypeDefinition(@namespace, name, StaticClassAttributes);
		newTypeDef.BaseType = module.CorLibTypeFactory.Object.ToTypeDefOrRef();
		module.TopLevelTypes.Add(newTypeDef);

		return newTypeDef;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Types/StructCreator.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Types;

public static class StructCreator
{
	public const TypeAttributes SequentialStructAttributes =
		TypeAttributes.Public |
		TypeAttributes.SequentialLayout |
		TypeAttributes.Sealed |
		TypeAttributes.BeforeFieldInit;
	public const TypeAttributes ExplicitStructAttributes =
		TypeAttributes.Public |
		TypeAttributes.ExplicitLayout |
		TypeAttributes.Sealed |
		TypeAttributes.BeforeFieldInit;

	public static TypeDefinition CreateEmptyStruct(AssemblyBuilder builder, string @namespace, string name, bool sequential = true)
	{
		ITypeDefOrRef valueTypeReference = builder.Importer.ImportType<ValueType>();
		TypeAttributes typeAttributes = sequential ? SequentialStructAttributes : ExplicitStructAttributes;
		TypeDefinition definition = new TypeDefinition(@namespace, name, typeAttributes, valueTypeReference);
		builder.Module.TopLevelTypes.Add(definition);
		return definition;
	}

	public static TypeDefinition CreateEmptyStruct(AssemblyBuilder builder, TypeDefinition parentType, string name, bool sequential = true)
	{
		ITypeDefOrRef valueTypeReference = builder.Importer.ImportType<ValueType>();
		TypeAttributes typeAttributes = sequential ? SequentialStructAttributes : ExplicitStructAttributes;
		TypeDefinition definition = new TypeDefinition(parentType.Namespace, name, typeAttributes, valueTypeReference);
		parentType.NestedTypes.Add(definition);
		return definition;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Types/TypeDefinitionExtensions.cs`:

```cs
namespace AssetRipper.AssemblyDumper.Types;

public static class TypeDefinitionExtensions
{
	public static MethodDefinition GetMethodByName(this TypeDefinition type, string name, bool checkBaseTypes = false)
	{
		return type.TryGetMethodByName(name, checkBaseTypes)
			?? throw new Exception($"{type.FullName} doesn't have a {name} method.");
	}

	public static bool TryGetMethodByName(this TypeDefinition type, string name, [NotNullWhen(true)] out MethodDefinition? method, bool checkBaseTypes = false)
	{
		method = type.TryGetMethodByName(name, checkBaseTypes);
		return method != null;
	}

	public static MethodDefinition? TryGetMethodByName(this TypeDefinition type, string name, bool checkBaseTypes = false)
	{
		var result = type.Methods.SingleOrDefault(field => field.Name == name);
		if (result == null && checkBaseTypes)
		{
			result = type.TryGetBaseTypeDefinition()?.TryGetMethodByName(name, checkBaseTypes);
		}
		return result;
	}

	public static List<FieldDefinition> GetAllFieldsInTypeAndBase(this TypeDefinition? type)
	{
		if (type == null)
		{
			return new();
		}

		List<FieldDefinition>? ret = type.Fields.ToList();

		ret.AddRange((type.BaseType?.Resolve()).GetAllFieldsInTypeAndBase());

		return ret;
	}

	public static FieldDefinition GetFieldByName(this TypeDefinition type, string name, bool checkBaseTypes = false)
	{
		return type.TryGetFieldByName(name, checkBaseTypes)
			?? throw new Exception($"{type.FullName} doesn't have a {name} field.");
	}

	public static bool TryGetFieldByName(this TypeDefinition type, string name, [NotNullWhen(true)] out FieldDefinition? field, bool checkBaseTypes = false)
	{
		field = type.TryGetFieldByName(name, checkBaseTypes);
		return field != null;
	}

	public static FieldDefinition? TryGetFieldByName(this TypeDefinition type, string name, bool checkBaseTypes = false)
	{
		var result = type.Fields.SingleOrDefault(field => field.Name == name);
		if (result == null && checkBaseTypes)
		{
			result = type.TryGetBaseTypeDefinition()?.TryGetFieldByName(name, checkBaseTypes);
		}
		return result;
	}

	private static TypeDefinition? TryGetBaseTypeDefinition(this TypeDefinition type)
	{
		return type.BaseType as TypeDefinition;
	}
}

```

`Source/AssetRipper.AssemblyDumper/UniqueNameFactory.cs`:

```cs
namespace AssetRipper.AssemblyDumper;

internal static class UniqueNameFactory
{
	public static string GetReadWriteName(UniversalNode node, UnityVersion version)
	{
		if (SharedState.Instance.SubclassGroups.TryGetValue(node.TypeName, out SubclassGroup? subclassGroup))
		{
			TypeDefinition fieldType = subclassGroup.GetTypeForVersion(version);
			return node.AlignBytes ? $"{fieldType.Name}Align" : fieldType.Name ?? throw new NullReferenceException();
		}

		switch (node.NodeType)
		{
			case NodeType.Vector:
				{
					UniversalNode arrayNode = node.SubNodes[0];
					UniversalNode listTypeNode = arrayNode.SubNodes[1];
					string listName = GetReadWriteName(listTypeNode, version);
					return node.AlignBytes || arrayNode.AlignBytes ? $"ArrayAlign_{listName}" : $"Array_{listName}";
				}
			case NodeType.Map:
				{
					UniversalNode arrayNode = node.SubNodes[0];
					UniversalNode pairNode = arrayNode.SubNodes[1];
					UniversalNode firstTypeNode = pairNode.SubNodes[0];
					UniversalNode secondTypeNode = pairNode.SubNodes[1];
					string firstTypeName = GetReadWriteName(firstTypeNode, version);
					string secondTypeName = GetReadWriteName(secondTypeNode, version);
					return node.AlignBytes || arrayNode.AlignBytes
						? $"MapAlign_{firstTypeName}_{secondTypeName}"
						: $"Map_{firstTypeName}_{secondTypeName}";
				}
			case NodeType.Pair:
				{
					UniversalNode firstTypeNode = node.SubNodes[0];
					UniversalNode secondTypeNode = node.SubNodes[1];
					string firstTypeName = GetReadWriteName(firstTypeNode, version);
					string secondTypeName = GetReadWriteName(secondTypeNode, version);
					return node.AlignBytes ? $"PairAlign_{firstTypeName}_{secondTypeName}" : $"Pair_{firstTypeName}_{secondTypeName}";
				}
			case NodeType.TypelessData: //byte array
				{
					return node.AlignBytes ? "TypelessDataAlign" : "TypelessData";
				}
			case NodeType.Array:
				{
					UniversalNode listTypeNode = node.SubNodes[1];
					string listName = GetReadWriteName(listTypeNode, version);
					return node.AlignBytes ? $"ArrayAlign_{listName}" : $"Array_{listName}";
				}
			default:
				{
					string name = node.NodeType.ToPrimitiveTypeName();
					return node.AlignBytes ? $"{name}Align" : name;
				}
		}
	}

	public static string GetYamlName(UniversalNode node, UnityVersion version)
	{
		if (SharedState.Instance.SubclassGroups.TryGetValue(node.TypeName, out SubclassGroup? subclassGroup))
		{
			TypeDefinition fieldType = subclassGroup.GetTypeForVersion(version);
			return fieldType.Name ?? throw new NullReferenceException();
		}

		switch (node.NodeType)
		{
			case NodeType.Vector:
				{
					UniversalNode arrayNode = node.SubNodes[0];
					UniversalNode listTypeNode = arrayNode.SubNodes[1];
					string listName = GetYamlName(listTypeNode, version);
					return $"Array_{listName}";
				}
			case NodeType.Map:
				{
					UniversalNode arrayNode = node.SubNodes[0];
					UniversalNode pairNode = arrayNode.SubNodes[1];
					UniversalNode firstTypeNode = pairNode.SubNodes[0];
					UniversalNode secondTypeNode = pairNode.SubNodes[1];
					string firstTypeName = GetYamlName(firstTypeNode, version);
					string secondTypeName = GetYamlName(secondTypeNode, version);
					return $"Map_{firstTypeName}_{secondTypeName}";
				}
			case NodeType.Pair:
				{
					UniversalNode firstTypeNode = node.SubNodes[0];
					UniversalNode secondTypeNode = node.SubNodes[1];
					string firstTypeName = GetYamlName(firstTypeNode, version);
					string secondTypeName = GetYamlName(secondTypeNode, version);
					return $"Pair_{firstTypeName}_{secondTypeName}";
				}
			case NodeType.TypelessData: //byte array
				{
					return "TypelessData";
				}
			case NodeType.Array:
				{
					UniversalNode listTypeNode = node.SubNodes[1];
					string listName = GetYamlName(listTypeNode, version);
					return $"Array_{listName}";
				}
			default:
				{
					return node.NodeType.ToPrimitiveTypeName();
				}
		}
	}

	public static string MakeUniqueName(TypeSignature type)
	{
		return type switch
		{
			CorLibTypeSignature or TypeDefOrRefSignature => type.Name,
			SzArrayTypeSignature arrayType => $"Array{MakeUniqueName(arrayType.BaseType)}",
			GenericInstanceTypeSignature genericType => $"{genericType.GenericType.Name?.ToString()[..^2]}_{string.Join('_', genericType.TypeArguments.Select(t => MakeUniqueName(t)))}",
			_ => throw new NotSupportedException(),
		}
		?? throw new NullReferenceException();
	}
}

```

`Source/AssetRipper.AssemblyDumper/UniversalClass.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.Tpk.Shared;
using AssetRipper.Tpk.TypeTrees;

namespace AssetRipper.AssemblyDumper;

internal sealed class UniversalClass : IDeepCloneable<UniversalClass>
{
	/// <summary>
	/// The name of the class not including the namespace.
	/// </summary>
	public string Name { get; set; } = "";
	/// <summary>
	/// The original name of the class not including the namespace.
	/// </summary>
	public string OriginalName { get; set; } = "";
	/// <summary>
	/// The unique number used to identify the class. Negative value indicates that the class doesn't have a type id
	/// </summary>
	public int TypeID { get; set; }
	/// <summary>
	/// <see cref="TypeID"/> might be overridden. This is the original type id.
	/// </summary>
	public int OriginalTypeID { get; set; }
	/// <summary>
	/// The name of the base class if it exists. Namespace not included
	/// </summary>
	public string? BaseString { get; set; }
	/// <summary>
	/// The base class if it exists
	/// </summary>
	public UniversalClass? BaseClass { get; set; }
	/// <summary>
	/// The names of the classes that directly derive from this. Namespaces not included
	/// </summary>
	public List<UniversalClass> DerivedClasses { get; } = new();
	/// <summary>
	/// The count of all classes that descend from this class<br/>
	/// It includes this class, so the count is always positive<br/>
	/// This gets generated in <see cref="Passes.Pass011_ApplyInheritance"/>
	/// </summary>
	public uint DescendantCount { get; internal set; } = 1;
	/// <summary>
	/// Is the class abstract?
	/// </summary>
	public bool IsAbstract { get; set; }
	/// <summary>
	/// Is the class sealed?
	/// </summary>
	public bool IsSealed => DerivedClasses.Count == 0 && !IsAbstract;
	/// <summary>
	/// Does the class only appear in the editor?
	/// </summary>
	public bool IsEditorOnly { get; set; }
	/// <summary>
	/// Does the class only appear in game files?
	/// </summary>
	public bool IsReleaseOnly { get; set; }
	/// <summary>
	/// Is the class stripped?
	/// </summary>
	public bool IsStripped { get; set; }
	public UniversalNode? EditorRootNode { get; set; }
	public UniversalNode? ReleaseRootNode { get; set; }

	private UniversalClass() { }

	/// <summary>
	/// The constructor used to make dependent class definitions
	/// </summary>
	public UniversalClass(UniversalNode? releaseRootNode, UniversalNode? editorRootNode)
	{
		ReleaseRootNode = releaseRootNode;
		EditorRootNode = editorRootNode;
		UniversalNode mainRootNode = releaseRootNode ?? editorRootNode ?? throw new ArgumentException("Both root nodes cannot be null");

		Name = mainRootNode.TypeName;
		OriginalName = mainRootNode.OriginalTypeName;
		TypeID = -1;
		OriginalTypeID = -1;
		IsAbstract = false;
		IsEditorOnly = releaseRootNode == null;
		IsReleaseOnly = editorRootNode == null;
		IsStripped = false;
	}

	public static UniversalClass FromTpkUnityClass(TpkUnityClass tpkClass, int typeId, TpkStringBuffer stringBuffer, TpkUnityNodeBuffer nodeBuffer)
	{
		string name = stringBuffer[tpkClass.Name];
		return new()
		{
			Name = name,
			OriginalName = name,
			TypeID = typeId,
			OriginalTypeID = typeId,
			BaseString = stringBuffer[tpkClass.Base],
			IsAbstract = tpkClass.Flags.IsAbstract(),
			IsEditorOnly = tpkClass.Flags.IsEditorOnly(),
			IsReleaseOnly = tpkClass.Flags.IsReleaseOnly(),
			IsStripped = tpkClass.Flags.IsStripped(),
			EditorRootNode = tpkClass.Flags.HasEditorRootNode()
				? UniversalNode.FromTpkUnityNode(nodeBuffer[tpkClass.EditorRootNode], stringBuffer, nodeBuffer)
				: null,
			ReleaseRootNode = tpkClass.Flags.HasReleaseRootNode()
				? UniversalNode.FromTpkUnityNode(nodeBuffer[tpkClass.ReleaseRootNode], stringBuffer, nodeBuffer)
				: null
		};
	}

	public UniversalClass DeepClone()
	{
		UniversalClass newClass = new();
		newClass.Name = Name;
		newClass.OriginalName = OriginalName;
		newClass.TypeID = TypeID;
		newClass.OriginalTypeID = OriginalTypeID;
		newClass.BaseString = BaseString;
		newClass.BaseClass = BaseClass;
		newClass.DerivedClasses.Capacity = DerivedClasses.Count;
		newClass.DerivedClasses.AddRange(DerivedClasses);
		newClass.DescendantCount = DescendantCount;
		newClass.IsAbstract = IsAbstract;
		newClass.IsEditorOnly = IsEditorOnly;
		newClass.IsReleaseOnly = IsReleaseOnly;
		newClass.IsStripped = IsStripped;
		newClass.EditorRootNode = EditorRootNode?.DeepClone();
		newClass.ReleaseRootNode = ReleaseRootNode?.DeepClone();
		return newClass;
	}

	public override string ToString()
	{
		return Name;
	}

	public bool ContainsField(string fieldName)
	{
		UniversalNode? node = ReleaseRootNode?.TryGetSubNodeByName(fieldName) ?? EditorRootNode?.TryGetSubNodeByName(fieldName);
		return node is not null;
	}
}

```

`Source/AssetRipper.AssemblyDumper/UniversalCommonString.cs`:

```cs
using AssetRipper.Tpk.Shared;
using AssetRipper.Tpk.TypeTrees;

namespace AssetRipper.AssemblyDumper;

internal sealed class UniversalCommonString
{
	public Dictionary<uint, string> Strings { get; } = new();

	private UniversalCommonString()
	{
	}

	public static UniversalCommonString FromBlob(TpkTypeTreeBlob blob)
	{
		TpkCommonString commonString = blob.CommonString;
		TpkStringBuffer stringBuffer = blob.StringBuffer;

		UniversalCommonString result = new UniversalCommonString();
		result.Strings.EnsureCapacity(commonString.StringBufferIndices.Count);

		int currentKey = 0;
		foreach (ushort stringIndex in commonString.StringBufferIndices)
		{
			string str = stringBuffer[stringIndex];
			result.Strings.Add((uint)currentKey, str);
			currentKey += str.Length + 1;
		}

		return result;
	}
}

```

`Source/AssetRipper.AssemblyDumper/UniversalNode.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.Tpk.Shared;
using AssetRipper.Tpk.TypeTrees;
using System.Diagnostics;

namespace AssetRipper.AssemblyDumper;

internal sealed class UniversalNode : IEquatable<UniversalNode>, IDeepCloneable<UniversalNode>
{
	/// <summary>
	/// The current type name
	/// </summary>
	public string TypeName { get => typeName; set => typeName = value ?? ""; }
	/// <summary>
	/// The original type name as obtained from the tpk file
	/// </summary>
	public string OriginalTypeName
	{
		get => string.IsNullOrEmpty(originalTypeName) ? TypeName : originalTypeName;
		set => originalTypeName = value ?? "";
	}
	public string Name { get => name; set => name = value ?? ""; }
	/// <summary>
	/// The original name as obtained from the tpk file
	/// </summary>
	public string OriginalName
	{
		get => string.IsNullOrEmpty(originalName) ? Name : originalName;
		set => originalName = value ?? "";
	}
	public short Version { get; set; }
	public TransferMetaFlags MetaFlag { get; set; }
	public List<UniversalNode> SubNodes { get => subNodes; set => subNodes = value ?? new(); }

	private string originalTypeName = "";
	private string originalName = "";
	private string typeName = "";
	private string name = "";
	private List<UniversalNode> subNodes = new();

	public bool IgnoreInMetaFiles => MetaFlag.IsIgnoreInMetaFiles();
	public bool AlignBytes => MetaFlag.IsAlignBytes();
	public bool TreatIntegerAsBoolean => MetaFlag.IsTreatIntegerValueAsBoolean();
	private bool TreatIntegerAsChar => MetaFlag.IsCharPropertyMask();

	public NodeType NodeType
	{
		get
		{
			return subNodes.Count == 0
				? TypeName switch
				{
					"bool" => NodeType.Boolean,
					//"char" => NodeType.Character,
					"char" => NodeType.UInt8,
					"SInt8" => NodeType.Int8,
					"UInt8" => NodeType.UInt8,
					"short" or "SInt16" => NodeType.Int16,
					"ushort" or "UInt16" or "unsigned short" => TreatIntegerAsChar ? NodeType.Character : NodeType.UInt16,
					"int" or "SInt32" or "Type*" or "EntityId" => NodeType.Int32,
					"uint" or "UInt32" or "unsigned int" => NodeType.UInt32,
					"SInt64" or "long long" => NodeType.Int64,
					"UInt64" or "FileSize" or "unsigned long long" => NodeType.UInt64,//FileSize is used in StreamedResource.m_Offset 2020.1+
					"float" => NodeType.Single,
					"double" => NodeType.Double,
					_ => NodeType.Type,
				}
				: TypeName switch
				{
					"Array" => NodeType.Array,
					"vector" or "staticvector" or "set" => NodeType.Vector,
					"map" => NodeType.Map,
					"pair" => NodeType.Pair,
					"TypelessData" => NodeType.TypelessData,
					"string" or Passes.Pass002_RenameSubnodes.Utf8StringName => NodeType.String,
					_ => NodeType.Type,
				};
		}
	}

	public UniversalNode()
	{
	}

	public bool TryGetSubNodeByName(string nodeName, [NotNullWhen(true)] out UniversalNode? subnode)
	{
		subnode = SubNodes.SingleOrDefault(n => n.Name == nodeName);
		return subnode is not null;
	}

	public UniversalNode? TryGetSubNodeByName(string nodeName)
	{
		return SubNodes.SingleOrDefault(n => n.Name == nodeName);
	}

	public bool TryGetSubNodeByTypeAndName(string nodeTypeName, string nodeName, [NotNullWhen(true)] out UniversalNode? subnode)
	{
		subnode = SubNodes.SingleOrDefault(n => n.Name == nodeName && n.TypeName == nodeTypeName);
		return subnode is not null;
	}

	public UniversalNode GetSubNodeByName(string nodeName)
	{
		return SubNodes.Single(n => n.Name == nodeName);
	}

	public static UniversalNode FromTpkUnityNode(TpkUnityNode tpkNode, TpkStringBuffer stringBuffer, TpkUnityNodeBuffer nodeBuffer)
	{
		UniversalNode result = new UniversalNode();
		result.TypeName = GetFixedTypeName(stringBuffer[tpkNode.TypeName]);
		result.OriginalTypeName = result.TypeName;
		result.Name = stringBuffer[tpkNode.Name];
		result.OriginalName = result.Name;
		result.Version = tpkNode.Version;
		result.MetaFlag = (TransferMetaFlags)tpkNode.MetaFlag;
		result.SubNodes = tpkNode.SubNodes
			.Select(nodeIndex => FromTpkUnityNode(nodeBuffer[nodeIndex], stringBuffer, nodeBuffer))
			.ToList();
		return result;
	}

	/// <summary>
	/// Only store one name for each primitive integer size.
	/// </summary>
	/// <remarks>
	/// Although this deduplicates, it also prevents these loaded type trees from being used in making new serialized files.
	/// </remarks>
	/// <param name="originalName"></param>
	/// <returns></returns>
	private static string GetFixedTypeName(string originalName)
	{
		return originalName switch
		{
			"short" => "SInt16",
			"int" => "SInt32",
			"long long" => "SInt64",
			"unsigned short" => "UInt16",
			"unsigned int" => "UInt32",
			"unsigned long long" => "UInt64",
			_ => originalName,
		};
	}

	/// <summary>
	/// Deep clones a node and all its subnodes<br/>
	/// Warning: Deep cloning a node with a circular hierarchy will cause an endless loop
	/// </summary>
	/// <returns>The new node</returns>
	public UniversalNode DeepClone()
	{
		UniversalNode clone = new UniversalNode();
		clone.TypeName = TypeName;
		clone.originalTypeName = originalTypeName;
		clone.Name = Name;
		clone.originalName = originalName;
		clone.Version = Version;
		clone.MetaFlag = MetaFlag;
		clone.SubNodes = SubNodes.ConvertAll(x => x.DeepClone());
		return clone;
	}

	/// <summary>
	/// Shallow clones a node but not its subnodes
	/// </summary>
	/// <returns>The new node</returns>
	public UniversalNode ShallowClone()
	{
		UniversalNode clone = new UniversalNode();
		clone.TypeName = TypeName;
		clone.originalTypeName = originalTypeName;
		clone.Name = Name;
		clone.originalName = originalName;
		clone.Version = Version;
		clone.MetaFlag = MetaFlag;
		clone.SubNodes = SubNodes.ToList();
		return clone;
	}

	public UniversalNode DeepCloneAsRootNode()
	{
		UniversalNode clone = DeepClone();
		clone.Name = "Base";
		clone.OriginalName = clone.Name;
		return clone;
	}

	public UniversalNode ShallowCloneAsRootNode()
	{
		UniversalNode clone = ShallowClone();
		clone.Name = "Base";
		clone.OriginalName = clone.Name;
		return clone;
	}

	public override bool Equals(object? obj)
	{
		return Equals(obj as UniversalNode);
	}

	public bool Equals(UniversalNode? other)
	{
		return other is not null &&
			   TypeName == other.TypeName &&
			   OriginalTypeName == other.OriginalTypeName &&
			   Name == other.Name &&
			   OriginalName == other.OriginalName &&
			   Version == other.Version &&
			   MetaFlag == other.MetaFlag &&
			   EqualityComparer<List<UniversalNode>>.Default.Equals(SubNodes, other.SubNodes);
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(TypeName, OriginalTypeName, Name, OriginalName, Version, MetaFlag, SubNodes);
	}

	public static bool operator ==(UniversalNode? left, UniversalNode? right)
	{
		return EqualityComparer<UniversalNode>.Default.Equals(left, right);
	}

	public static bool operator !=(UniversalNode? left, UniversalNode? right)
	{
		return !(left == right);
	}

	public override string ToString()
	{
		return $"{TypeName} {Name}";
	}
}

```

`Source/AssetRipper.AssemblyDumper/UniversalNodeComparer.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.AssemblyDumper;

internal class UniversalNodeComparer
{
	private const TransferMetaFlags MetaMask = TransferMetaFlags.TreatIntegerValueAsBoolean
		| TransferMetaFlags.AlignBytes
		| TransferMetaFlags.TransferUsingFlowMappingStyle;

	public static bool Equals(UniversalNode? left, UniversalNode? right, bool root)
	{
		if (left is null || right is null)
		{
			return left is null && right is null;
		}
		if (!root && left.OriginalName != right.OriginalName) //The root nodes will most likely not have the same name
		{
			//Console.WriteLine($"\tInequal because original name {left.OriginalName} doesn't match {right.OriginalName}");
			return false;
		}
		if (!root && left.Name != right.Name) //The root nodes will most likely not have the same name
		{
			//Console.WriteLine($"\tInequal because name {left.Name} doesn't match {right.Name}");
			return false;
		}
		if (left.OriginalTypeName != right.OriginalTypeName)
		{
			//Console.WriteLine($"\tInequal because original type name {left.OriginalTypeName} doesn't match {right.OriginalTypeName}");
			return false;
		}
		if (left.TypeName != right.TypeName)
		{
			//Console.WriteLine($"\tInequal because type name {left.TypeName} doesn't match {right.TypeName}");
			return false;
		}
		if (left.Version != right.Version)
		{
			//Console.WriteLine($"\tInequal because version {left.Version} doesn't match {right.Version}");
			return false;
		}
		if (!root && (left.MetaFlag & MetaMask) != (right.MetaFlag & MetaMask))
		//if (!root && left.MetaFlag != right.MetaFlag)
		{
			//Console.WriteLine($"\tInequal because meta flag {left.MetaFlag} doesn't match {right.MetaFlag}");
			return false;
		}
		if (left.SubNodes!.Count != right.SubNodes!.Count)
		{
			//Console.WriteLine($"\tInequal because subnode count {left.SubNodes.Count} doesn't match {right.SubNodes.Count}");
			return false;
		}
		for (int i = 0; i < left.SubNodes.Count; i++)
		{
			if (!Equals(left.SubNodes[i], right.SubNodes[i], false))
			{
				return false;
			}
		}
		return true;
	}
}

```

`Source/AssetRipper.AssemblyDumper/Usings.cs`:

```cs
global using AsmResolver.DotNet;
global using AsmResolver.DotNet.Code.Cil;
global using AsmResolver.DotNet.Collections;
global using AsmResolver.DotNet.Signatures;
global using AsmResolver.PE.DotNet.Cil;
global using AsmResolver.PE.DotNet.Metadata.Tables;
global using AssetRipper.AssemblyDumper.Extensions;
global using AssetRipper.AssemblyDumper.Groups;
global using AssetRipper.CIL;
global using AssetRipper.Primitives;
global using System;
global using System.Collections.Generic;
global using System.Diagnostics.CodeAnalysis;
global using System.Linq;

global using UnityVersionRange = AssetRipper.Numerics.Range<AssetRipper.Primitives.UnityVersion>;


```

`Source/AssetRipper.Assets.Tests/AccessListTests.cs`:

```cs
using AssetRipper.Assets.Generics;

namespace AssetRipper.Assets.Tests;

internal class AccessListTests
{
	[Test]
	public void EmptyListToArray()
	{
		AssetList<int> list = new();
		AccessList<int, int> accessList = new(list);
		int[] array = accessList.ToArray();
		Assert.That(array, Is.Empty);
	}

	[Test]
	public void NonemptyListToArray()
	{
		AssetList<int> list = new()
		{
			1,
			2
		};
		AccessList<int, int> accessList = new(list);
		int[] array = accessList.ToArray();
		Assert.That(array, Has.Length.EqualTo(2));
	}
}

```

`Source/AssetRipper.Assets.Tests/AssetEqualityTests.cs`:

```cs
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Collections;
using AssetRipper.Primitives;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Assets.Tests;

internal class AssetEqualityTests
{
	[Test]
	public void DefaultGameObjectEqualityTest()
	{
		IGameObject gameObject1 = AssetCreator.CreateGameObject(new UnityVersion(2017));
		IGameObject gameObject2 = AssetCreator.CreateGameObject(new UnityVersion(2017));
		Assert.That(gameObject1, Is.EqualTo(gameObject2).Using(new AssetEqualityComparer()));
	}

	[Test]
	public void GameObjectWithTransformEqualityTest()
	{
		IGameObject gameObject1 = CreateGameObject();
		IGameObject gameObject2 = CreateGameObject();
		Assert.That(gameObject1, Is.EqualTo(gameObject2).Using(new AssetEqualityComparer()));

		static IGameObject CreateGameObject()
		{
			ProcessedAssetCollection collection = AssetCreator.CreateCollection(new UnityVersion(2017));
			IGameObject gameObject = collection.CreateGameObject();
			ITransform transform = collection.CreateTransform();
			gameObject.AddComponent(ClassIDType.Transform, transform);
			transform.GameObject_C4P = gameObject;
			return gameObject;
		}
	}

	[Test]
	public void GameObjectWithTransformInequalityTest()
	{
		IGameObject gameObject1 = CreateGameObject(0, 0, 0);
		IGameObject gameObject2 = CreateGameObject(1, 1, 1);
		Assert.That(gameObject1, Is.Not.EqualTo(gameObject2).Using(new AssetEqualityComparer()));

		static IGameObject CreateGameObject(float x, float y, float z)
		{
			ProcessedAssetCollection collection = AssetCreator.CreateCollection(new UnityVersion(2017));
			IGameObject gameObject = collection.CreateGameObject();
			ITransform transform = collection.CreateTransform();
			transform.LocalPosition_C4.SetValues(x, y, z);
			gameObject.AddComponent(ClassIDType.Transform, transform);
			transform.GameObject_C4P = gameObject;
			return gameObject;
		}
	}
}

```

`Source/AssetRipper.Assets.Tests/AssetListTests.cs`:

```cs
using AssetRipper.Assets.Generics;

namespace AssetRipper.Assets.Tests;

internal class AssetListTests
{
	[Test]
	public void EmptyListToArray()
	{
		AssetList<int> list = new();
		int[] array = list.ToArray();
		Assert.That(array, Is.Empty);
	}

	[Test]
	public void NonemptyListToArray()
	{
		AssetList<int> list = new()
		{
			1,
			2
		};
		int[] array = list.ToArray();
		Assert.That(array, Has.Length.EqualTo(2));
	}
}

```

`Source/AssetRipper.Assets.Tests/AssetResolutionTests.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using AssetRipper.Primitives;

namespace AssetRipper.Assets.Tests;

public class AssetResolutionTests
{
	[Test]
	public void ResolvingNullObjects()
	{
		ProcessedAssetCollection collection = Create();
		SealedNullObject asset = collection.CreateAsset(-1, (assetInfo) => new SealedNullObject(assetInfo));

		using (Assert.EnterMultipleScope())
		{
			//NullObject is not a real asset, so we should not be able to get it under normal conditions.
			Assert.That(collection.TryGetAsset(asset.PathID), Is.Null);
			Assert.That(collection.TryGetAsset(0, asset.PathID), Is.Null);
			Assert.That(collection.TryGetAsset<IUnityObjectBase>(asset.PathID), Is.Null);
			Assert.That(collection.TryGetAsset<IUnityObjectBase>(0, asset.PathID), Is.Null);

			//We are explicitly looking for a NullObject, so we should get it.
			Assert.That(collection.TryGetAsset<NullObject>(asset.PathID), Is.EqualTo(asset));
			Assert.That(collection.TryGetAsset<NullObject>(0, asset.PathID), Is.EqualTo(asset));
			Assert.That(collection.TryGetAsset<SealedNullObject>(asset.PathID), Is.EqualTo(asset));
			Assert.That(collection.TryGetAsset<SealedNullObject>(0, asset.PathID), Is.EqualTo(asset));
		}
	}

	private static ProcessedAssetCollection Create()
	{
		return new GameBundle().AddNewProcessedCollection(nameof(Create), new UnityVersion(2017));
	}

	private sealed class SealedNullObject : NullObject
	{
		public SealedNullObject(AssetInfo assetInfo) : base(assetInfo)
		{
		}
	}
}

```

`Source/AssetRipper.Assets.Tests/AssetRipper.Assets.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<IsPackable>false</IsPackable>
		<OutputPath>..\0Bins\Other\AssetRipper.Assets.Tests\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Assets.Tests\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
		<PackageReference Include="NUnit" Version="4.4.0" />
		<PackageReference Include="NUnit3TestAdapter" Version="6.1.0" />
		<PackageReference Include="NUnit.Analyzers" Version="4.11.2">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Assets\AssetRipper.Assets.csproj" />
		<ProjectReference Include="..\AssetRipper.SourceGenerated.Extensions\AssetRipper.SourceGenerated.Extensions.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Assets.Tests/FileResolutionTests.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.Assets.Tests;

public class FileResolutionTests
{
	[Test]
	public void CollectionResolutionWorksAnywhereInTheHierarchy()
	{
		const string name1 = "name1";
		const string name2 = "name2";
		GameBundle gameBundle = new();

		ProcessedAssetCollection collection1 = new ProcessedAssetCollection(gameBundle);
		collection1.Name = name1;

		ProcessedBundle processedBundle = new();
		gameBundle.AddBundle(processedBundle);

		ProcessedAssetCollection collection2 = new ProcessedAssetCollection(processedBundle);
		collection2.Name = name2;

		using (Assert.EnterMultipleScope())
		{
			Assert.That(gameBundle.ResolveCollection(name1), Is.EqualTo(collection1));
			Assert.That(gameBundle.ResolveCollection(name2), Is.EqualTo(collection2));
			Assert.That(processedBundle.ResolveCollection(name1), Is.EqualTo(collection1));
			Assert.That(processedBundle.ResolveCollection(name2), Is.EqualTo(collection2));
		}
	}

	[Test]
	public void CollectionResolutionIsAbleToFindTheSecondFile()
	{
		const string name1 = "name1";
		const string name2 = "name2";
		GameBundle gameBundle = new();

		ProcessedBundle processedBundle1 = new();
		gameBundle.AddBundle(processedBundle1);

		ProcessedAssetCollection collection1 = new ProcessedAssetCollection(processedBundle1);
		collection1.Name = name1;

		ProcessedBundle processedBundle2 = new();
		gameBundle.AddBundle(processedBundle2);

		ProcessedAssetCollection collection2 = new ProcessedAssetCollection(processedBundle2);
		collection2.Name = name2;
		using (Assert.EnterMultipleScope())
		{
			Assert.That(gameBundle.ResolveCollection(name1), Is.EqualTo(collection1));
			Assert.That(gameBundle.ResolveCollection(name2), Is.EqualTo(collection2));
		}
	}

	[Test]
	public void CollectionResolutionIsAbleToFindUnityDefaultResourcesWithInconsistentUnderscores()
	{
		const string name = "unity_default_resources";
		GameBundle gameBundle = new();

		ProcessedAssetCollection collection = new ProcessedAssetCollection(gameBundle);
		collection.Name = name;

		Assert.That(gameBundle.ResolveCollection("library/unity default resources"), Is.EqualTo(collection));
	}

	[TestCase("unity default resources")]
	[TestCase("unity_default_resources")]
	[TestCase("unity editor resources")]
	[TestCase("unity builtin extra")]
	[TestCase("unity_builtin_extra")]
	public void CollectionResolutionIsAbleToFindEngineResourcess(string name)
	{
		GameBundle gameBundle = new();

		ProcessedAssetCollection collection = new ProcessedAssetCollection(gameBundle);
		collection.Name = name;
		using (Assert.EnterMultipleScope())
		{
			Assert.That(gameBundle.ResolveCollection(name), Is.EqualTo(collection));
			Assert.That(gameBundle.ResolveCollection($"library/{name}"), Is.EqualTo(collection));
			Assert.That(gameBundle.ResolveCollection($"resources/{name}"), Is.EqualTo(collection));
		}
	}

	[TestCase("unity default resources")]
	[TestCase("unity_default_resources")]
	[TestCase("unity editor resources")]
	[TestCase("unity builtin extra")]
	[TestCase("unity_builtin_extra")]
	public void CollectionResolutionIsAbleToFindEngineResourcesNested(string name)
	{
		GameBundle gameBundle = new();

		ProcessedBundle processedBundle = new();
		gameBundle.AddBundle(processedBundle);

		ProcessedAssetCollection collection = new ProcessedAssetCollection(processedBundle);
		collection.Name = name;
		using (Assert.EnterMultipleScope())
		{
			Assert.That(gameBundle.ResolveCollection(name), Is.EqualTo(collection));
			Assert.That(gameBundle.ResolveCollection($"library/{name}"), Is.EqualTo(collection));
			Assert.That(gameBundle.ResolveCollection($"resources/{name}"), Is.EqualTo(collection));
		}
	}

	[Test]
	public void ResourceResolutionWorksAnywhereInTheHierarchy()
	{
		const string name1 = "name1";
		const string name2 = "name2";
		GameBundle gameBundle = new();

		ResourceFile resource1 = CreateNewResourceFile(name1);
		gameBundle.AddResource(resource1);

		ProcessedBundle processedBundle = new();
		gameBundle.AddBundle(processedBundle);

		ResourceFile resource2 = CreateNewResourceFile(name2);
		processedBundle.AddResource(resource2);
		using (Assert.EnterMultipleScope())
		{
			Assert.That(gameBundle.ResolveResource(name1), Is.EqualTo(resource1));
			Assert.That(gameBundle.ResolveResource(name2), Is.EqualTo(resource2));
			Assert.That(processedBundle.ResolveResource(name1), Is.EqualTo(resource1));
			Assert.That(processedBundle.ResolveResource(name2), Is.EqualTo(resource2));
		}
	}

	[Test]
	public void ResourceResolutionIsAbleToFindTheSecondFile()
	{
		const string name1 = "name1";
		const string name2 = "name2";
		GameBundle gameBundle = new();

		ProcessedBundle processedBundle1 = new();
		gameBundle.AddBundle(processedBundle1);

		ResourceFile resource1 = CreateNewResourceFile(name1);
		processedBundle1.AddResource(resource1);

		ProcessedBundle processedBundle2 = new();
		gameBundle.AddBundle(processedBundle2);

		ResourceFile resource2 = CreateNewResourceFile(name2);
		processedBundle2.AddResource(resource2);
		using (Assert.EnterMultipleScope())
		{
			Assert.That(gameBundle.ResolveResource(name1), Is.EqualTo(resource1));
			Assert.That(gameBundle.ResolveResource(name2), Is.EqualTo(resource2));
		}
	}

	[Test]
	public void ResourceResolutionIsAbleToFindAnArchiveFile()
	{
		const string name = "archive:/name1";
		GameBundle gameBundle = new();

		ProcessedBundle processedBundle = new();
		gameBundle.AddBundle(processedBundle);

		ResourceFile resource = CreateNewResourceFile(name);
		processedBundle.AddResource(resource);

		Assert.That(gameBundle.ResolveResource(name), Is.EqualTo(resource));
	}

	[Test]
	public void ResourceResolutionIsAbleToFindFilesWithCapitalLetters()
	{
		const string name = "ResourceName.resS";
		GameBundle gameBundle = new();

		ProcessedBundle processedBundle = new();
		gameBundle.AddBundle(processedBundle);

		ResourceFile resource = CreateNewResourceFile(name);
		processedBundle.AddResource(resource);

		Assert.That(gameBundle.ResolveResource(name), Is.EqualTo(resource));
	}

	[Test]
	public void ResourceResolutionIsAbleToFindExternalFilesFromParentBundles()
	{
		const string resourceName = "resources.resource";
		GameBundle gameBundle = new();

		ProcessedBundle processedBundle = new();
		gameBundle.AddBundle(processedBundle);

		ResourceFile resource = CreateNewResourceFile(resourceName);
		gameBundle.ResourceProvider = new SingleResourceProvider(resource);

		Assert.That(processedBundle.ResolveResource(resourceName), Is.EqualTo(resource));
	}

	[Test]
	public void ResourceResolutionIsAbleToFindExternalFilesFromGameBundles()
	{
		const string resourceName = "resources.resource";
		GameBundle gameBundle = new();

		ResourceFile resource = CreateNewResourceFile(resourceName);
		gameBundle.ResourceProvider = new SingleResourceProvider(resource);

		Assert.That(gameBundle.ResolveResource(resourceName), Is.EqualTo(resource));
	}

	private sealed record class SingleResourceProvider(ResourceFile Resource) : IResourceProvider
	{
		public ResourceFile? FindResource(string identifier)
		{
			string fixedName = SpecialFileNames.FixResourcePath(identifier);
			return fixedName == Resource.NameFixed ? Resource : null;
		}
	}

	private static ResourceFile CreateNewResourceFile(string name) => new ResourceFile(SmartStream.CreateMemory(), name, name);
}

```

`Source/AssetRipper.Assets.Tests/GameBundleTests.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Primitives;

namespace AssetRipper.Assets.Tests;

public class GameBundleTests
{
	[Test]
	public void HasAnyAssetCollections_ReturnsFalse()
	{
		GameBundle gameBundle = new();
		Assert.That(gameBundle.HasAnyAssetCollections(), Is.False);
	}

	[Test]
	public void AddNewProcessedCollection_AddsNewProcessedCollection()
	{
		GameBundle gameBundle = new();
		string name = "testName";
		UnityVersion version = UnityVersion.Parse("10.3.1f1");
		Collections.ProcessedAssetCollection processedCollection = gameBundle.AddNewProcessedCollection(name, version);
		using (Assert.EnterMultipleScope())
		{
			Assert.That(processedCollection.Name, Is.EqualTo(name));
			Assert.That(processedCollection.Version, Is.EqualTo(version));
		}
		Assert.That(gameBundle.FetchAssetCollections(), Contains.Item(processedCollection));
	}

	[Test]
	public void GetMaxUnityVersion_ReturnsMaxUnityVersion()
	{
		GameBundle gameBundle = new();
		gameBundle.AddNewProcessedCollection("test", UnityVersion.Parse("1.0.0f1"));
		gameBundle.AddNewProcessedCollection("test2", UnityVersion.Parse("2.0.10f3"));
		gameBundle.AddNewProcessedCollection("test3", UnityVersion.Parse("3.0.0f0"));
		Assert.That(gameBundle.GetMaxUnityVersion(), Is.EqualTo(UnityVersion.Parse("3.0.0f0")));
	}
}

```

`Source/AssetRipper.Assets.Tests/GameObjectCopyValuesTests.cs`:

```cs
using AssetRipper.Primitives;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Assets.Tests;

internal class GameObjectCopyValuesTests
{
	private IGameObject gameObject;

	[SetUp]
	public void Setup()
	{
		gameObject = AssetCreator.CreateGameObject(new UnityVersion(2017));
	}

	[Test]
	public void CopyingSelfDoesNotClearPrimitives()
	{
		gameObject.Layer = 1;
		gameObject.CopyValues(gameObject);
		Assert.That(gameObject.Layer, Is.EqualTo(1));
	}

	[Test]
	public void CopyingSelfDoesNotClearLists()
	{
		IGameObject gameObject = AssetCreator.CreateGameObject(new UnityVersion(2017));
		gameObject.Components.AddNew();
		Assert.That(gameObject.Components, Has.Count.EqualTo(1));
		gameObject.CopyValues(gameObject);
		Assert.That(gameObject.Components, Has.Count.EqualTo(1));
	}
}

```

`Source/AssetRipper.Assets.Tests/PPtrAccessListTests.cs`:

```cs
using ObjectPPtrAccessList = AssetRipper.Assets.Generics.PPtrAccessList<AssetRipper.Assets.Metadata.IPPtr<AssetRipper.Assets.IUnityObjectBase>, AssetRipper.Assets.IUnityObjectBase>;

namespace AssetRipper.Assets.Tests;

internal class PPtrAccessListTests
{
	[Test]
	public void EmptyListIsImmutable()
	{
		using (Assert.EnterMultipleScope())
		{
			Assert.Throws<NotSupportedException>(() =>
			{
				ObjectPPtrAccessList.Empty.Add(null);
			});
			Assert.Throws<NotSupportedException>(() =>
			{
				ObjectPPtrAccessList.Empty.AddNew();
			});
		}
	}

	[Test]
	public void EmptyListIsEmpty()
	{
		Assert.That(ObjectPPtrAccessList.Empty, Is.Empty);
	}

	[Test]
	public void EmptyListThrowsForAccessingFirstElement()
	{
		Assert.Throws<ArgumentOutOfRangeException>(() =>
		{
			_ = ObjectPPtrAccessList.Empty[0];
		});
	}
}

```

`Source/AssetRipper.Assets.Tests/PPtrTests.cs`:

```cs
using AssetRipper.Assets.Metadata;

namespace AssetRipper.Assets.Tests;

public class PPtrTests
{
	[Test]
	public void PPtr_ReturnsCorrectValues()
	{
		// Arrange
		int fileID = 1;
		long pathID = 2;

		// Act
		PPtr pptr = new PPtr(fileID, pathID);

		// Assert
		using (Assert.EnterMultipleScope())
		{
			Assert.That(pptr.FileID, Is.EqualTo(fileID));
			Assert.That(pptr.PathID, Is.EqualTo(pathID));
		}
	}

	[Test]
	public void PPtr_ImplicitOperator_ReturnsCorrectType()
	{
		// Arrange
		int fileID = 1;
		long pathID = 2;
		PPtr<IUnityObjectBase> pptr = new PPtr<IUnityObjectBase>(fileID, pathID);

		// Act
		PPtr convertedPptr = pptr;

		// Assert
		using (Assert.EnterMultipleScope())
		{
			Assert.That(convertedPptr.FileID, Is.EqualTo(fileID));
			Assert.That(convertedPptr.PathID, Is.EqualTo(pathID));
		}
	}

	[Test]
	public void PPtrT_ReturnsCorrectValues()
	{
		// Arrange
		int fileID = 1;
		long pathID = 2;

		// Act
		PPtr<IDerivedUnityObjectInterface> pptr = new PPtr<IDerivedUnityObjectInterface>(fileID, pathID);

		// Assert
		using (Assert.EnterMultipleScope())
		{
			Assert.That(pptr.FileID, Is.EqualTo(fileID));
			Assert.That(pptr.PathID, Is.EqualTo(pathID));
		}
	}

	[Test]
	public void PPtrT_ExplicitOperator_ReturnsCorrectType()
	{
		// Arrange
		int fileID = 1;
		long pathID = 2;
		PPtr<IUnityObjectBase> pptr = new PPtr<IUnityObjectBase>(fileID, pathID);

		// Act
		PPtr<IDerivedUnityObjectInterface> convertedPptr = (PPtr<IDerivedUnityObjectInterface>)pptr;

		// Assert
		using (Assert.EnterMultipleScope())
		{
			Assert.That(convertedPptr.FileID, Is.EqualTo(fileID));
			Assert.That(convertedPptr.PathID, Is.EqualTo(pathID));
		}
	}

	[Test]
	public void PPtrT_ImplicitOperator_ReturnsCorrectType()
	{
		// Arrange
		int fileID = 1;
		long pathID = 2;
		PPtr<IDerivedUnityObjectInterface> pptr = new PPtr<IDerivedUnityObjectInterface>(fileID, pathID);

		// Act
		PPtr<IUnityObjectBase> convertedPptr = pptr;

		// Assert
		using (Assert.EnterMultipleScope())
		{
			Assert.That(convertedPptr.FileID, Is.EqualTo(fileID));
			Assert.That(convertedPptr.PathID, Is.EqualTo(pathID));
		}
	}

	[Test]
	public void PPtrT_ExplicitOperator_FromIUnityObjectBase_ReturnsCorrectType()
	{
		// Arrange
		int fileID = 1;
		long pathID = 2;
		PPtr<IUnityObjectBase> pptr = new PPtr<IUnityObjectBase>(fileID, pathID);

		// Act
		PPtr<IDerivedUnityObjectInterface> convertedPptr = (PPtr<IDerivedUnityObjectInterface>)pptr;

		// Assert
		using (Assert.EnterMultipleScope())
		{
			Assert.That(convertedPptr.FileID, Is.EqualTo(fileID));
			Assert.That(convertedPptr.PathID, Is.EqualTo(pathID));
		}
	}

	private interface IDerivedUnityObjectInterface : IUnityObjectBase
	{
	}
}

```

`Source/AssetRipper.Assets.Tests/ProcessedBundleTests.cs`:

```cs
using AssetRipper.Assets.Bundles;

namespace AssetRipper.Assets.Tests;

public class ProcessedBundleTests
{
	[Test]
	public void ProcessedBundle_DefaultConstructor_NameShouldNotBeEmpty()
	{
		// Arrange
		ProcessedBundle bundle = new();

		// Act

		// Assert
		Assert.That(bundle.Name, Is.Not.Empty);
	}

	[Test]
	public void ProcessedBundle_ArgumentConstructor_Null_ShouldNotThrowException()
	{
		// Arrange
		string? name = null;

		// Act

		// Assert
		Assert.DoesNotThrow(() => new ProcessedBundle(name));
	}

	[Test]
	public void ProcessedBundle_ArgumentConstructor_EmptyString_ShouldNotThrowException()
	{
		// Arrange
		string name = string.Empty;

		// Act

		// Assert
		Assert.DoesNotThrow(() => new ProcessedBundle(name));
	}

	[Test]
	public void ProcessedBundle_ArgumentConstructor_ValidName_ShouldNotBeNull()
	{
		// Arrange
		string name = "TestBundleName";

		// Act
		ProcessedBundle bundle = new ProcessedBundle(name);

		// Assert
		Assert.That(bundle, Is.Not.Null);
		Assert.That(bundle.Name, Is.EqualTo(name));
	}
}

```

`Source/AssetRipper.Assets.Tests/SceneDefinitionTests.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Primitives;

namespace AssetRipper.Assets.Tests;

public class SceneDefinitionTests
{
	[Test]
	public void FromName_CreatesSceneDefinitionWithName()
	{
		SceneDefinition sceneDefinition = SceneDefinition.FromName("testScene");
		Assert.That(sceneDefinition.Name, Is.EqualTo("testScene"));
	}

	[Test]
	public void FromName_CreatesSceneDefinitionWithGuid()
	{
		SceneDefinition sceneDefinition = SceneDefinition.FromName("testScene");
		Assert.That(sceneDefinition.GUID, Is.Not.EqualTo(UnityGuid.Zero));
	}

	[Test]
	public void FromPath_CreatesSceneDefinitionWithPath()
	{
		SceneDefinition sceneDefinition = SceneDefinition.FromPath("Assets/Scenes/testScene");
		Assert.That(sceneDefinition.Path, Is.EqualTo("Assets/Scenes/testScene"));
	}

	[Test]
	public void FromPath_CreatesSceneDefinitionWithGuid()
	{
		SceneDefinition sceneDefinition = SceneDefinition.FromPath("Assets/Scenes/testScene");
		Assert.That(sceneDefinition.GUID, Is.Not.EqualTo(UnityGuid.Zero));
	}

	[Test]
	public void AddCollection_AddsCollectionToSceneDefinition()
	{
		SceneDefinition sceneDefinition = SceneDefinition.FromName("testScene");
		AssetCollection mockAssetCollection = CreateCollection();
		sceneDefinition.AddCollection(mockAssetCollection);
		Assert.That(sceneDefinition.Collections, Has.Count.EqualTo(1));
		Assert.That(sceneDefinition.Collections[0], Is.EqualTo(mockAssetCollection));
	}

	[Test]
	public void AddCollection_ThrowsWhenAssetCollectionIsPartOfDifferentScene()
	{
		SceneDefinition sceneDefinition1 = SceneDefinition.FromName("testScene1");
		AssetCollection mockAssetCollection1 = CreateCollection();
		sceneDefinition1.AddCollection(mockAssetCollection1);

		SceneDefinition sceneDefinition2 = SceneDefinition.FromName("testScene2");
		AssetCollection mockAssetCollection2 = CreateCollection();
		sceneDefinition2.AddCollection(mockAssetCollection2);

		Assert.Throws<InvalidOperationException>(() =>
			sceneDefinition1.AddCollection(mockAssetCollection2));
	}

	[Test]
	public void RemoveCollection_RemovesCollectionFromSceneDefinition()
	{
		SceneDefinition sceneDefinition = SceneDefinition.FromName("testScene");
		AssetCollection mockAssetCollection = CreateCollection();
		sceneDefinition.AddCollection(mockAssetCollection);

		sceneDefinition.RemoveCollection(mockAssetCollection);

		Assert.That(sceneDefinition.Collections, Is.Empty);
	}

	[Test]
	public void RemoveCollection_ThrowsWhenCollectionNotPartOfSceneDefinition()
	{
		SceneDefinition sceneDefinition = SceneDefinition.FromName("testScene");
		AssetCollection mockAssetCollection1 = CreateCollection();
		AssetCollection mockAssetCollection2 = CreateCollection();

		sceneDefinition.AddCollection(mockAssetCollection1);

		Assert.Throws<ArgumentException>(() =>
			sceneDefinition.RemoveCollection(mockAssetCollection2));

	}

	[Test]
	public void RemoveCollection_DeletesAssetCollectionSceneReference()
	{
		SceneDefinition sceneDefinition = SceneDefinition.FromName("testScene");
		AssetCollection mockAssetCollection = CreateCollection();
		sceneDefinition.AddCollection(mockAssetCollection);

		sceneDefinition.RemoveCollection(mockAssetCollection);

		Assert.That(mockAssetCollection.Scene, Is.Null);
	}

	private static AssetCollection CreateCollection()
	{
		GameBundle gameBundle = new();
		return gameBundle.AddNewProcessedCollection(UnityGuid.NewGuid().ToString(), UnityVersion.MinVersion);
	}
}

```

`Source/AssetRipper.Assets.Tests/TransformCopyValuesTests.cs`:

```cs
using AssetRipper.Assets.Cloning;
using AssetRipper.Primitives;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Assets.Tests;

internal class TransformCopyValuesTests
{
	private ITransform transform;

	[SetUp]
	public void Setup()
	{
		transform = AssetCreator.CreateTransform(new UnityVersion(2017));
	}

	[Test]
	public void CopyingSelfDoesNotClearPosition()
	{
		transform.LocalPosition_C4.SetValues(1, 2, 3);
		transform.CopyValues(transform);
		using (Assert.EnterMultipleScope())
		{
			Assert.That(transform.LocalPosition_C4.X, Is.EqualTo(1));
			Assert.That(transform.LocalPosition_C4.Y, Is.EqualTo(2));
			Assert.That(transform.LocalPosition_C4.Z, Is.EqualTo(3));
		}
	}

	[Test]
	public void CopyingSelfDoesNotClearGameObject()
	{
		IGameObject gameObject = AssetCreator.CreateGameObject(new UnityVersion(2017));
		transform.GameObject_C4P = gameObject;
		transform.CopyValues(transform);
		Assert.That(transform.GameObject_C4P, Is.SameAs(gameObject));
	}

	[Test]
	public void ReplacingChildSucceeds()
	{
		ITransform child = AssetCreator.CreateTransform(new UnityVersion(2017));
		transform.Children_C4P.Add(child);
		ITransform newChild = AssetCreator.CreateTransform(new UnityVersion(2017));
		SingleReplacementAssetResolver resolver = new(child, newChild);
		transform.CopyValues(transform, new PPtrConverter(transform.Collection, transform.Collection, resolver));
		Assert.That(transform.Children_C4P, Has.Count.EqualTo(1));
		Assert.That(transform.Children_C4P[0], Is.SameAs(newChild));
	}
}

```

`Source/AssetRipper.Assets.Tests/Usings.cs`:

```cs
global using NUnit.Framework;

```

`Source/AssetRipper.Assets/AssetRipper.Assets.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.Assets\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Assets\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.IO.Files\AssetRipper.IO.Files.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Assets/Bundles/Bundle.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.IO;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.Assets.Bundles;

/// <summary>
/// A container for <see cref="AssetCollection"/>s, <see cref="ResourceFile"/>s, and other <see cref="Bundle"/>s.
/// </summary>
public abstract class Bundle : IDisposable
{
	/// <summary>
	/// The parent <see cref="Bundle"/> of this Bundle.
	/// </summary>
	public Bundle? Parent { get; private set; }

	/// <summary>
	/// The list of <see cref="ResourceFile"/>s in this Bundle.
	/// </summary>
	public IReadOnlyList<ResourceFile> Resources => resources;
	private readonly List<ResourceFile> resources = [];

	/// <summary>
	/// The list of <see cref="AssetCollection"/>s in this Bundle.
	/// </summary>
	public IReadOnlyList<AssetCollection> Collections => collections;
	private readonly List<AssetCollection> collections = [];

	/// <summary>
	/// The list of child <see cref="Bundle"/>s in this Bundle.
	/// </summary>
	public IReadOnlyList<Bundle> Bundles => bundles;
	private readonly List<Bundle> bundles = [];

	/// <summary>
	/// The list of <see cref="FailedFile"/>s in this Bundle.
	/// </summary>
	public IReadOnlyList<FailedFile> FailedFiles => failedFiles;
	private readonly List<FailedFile> failedFiles = [];

	private bool disposedValue;

	/// <summary>
	/// The name of this Bundle.
	/// </summary>
	public abstract string Name { get; }

	/// <summary>
	/// All the <see cref="SceneDefinition"/>s in this bundle.
	/// </summary>
	public IEnumerable<SceneDefinition> Scenes
	{
		get
		{
			HashSet<SceneDefinition> scenes = new();
			foreach (AssetCollection collection in FetchAssetCollections())
			{
				SceneDefinition? scene = collection.Scene;
				if (scene is not null && scenes.Add(scene))
				{
					yield return scene;
				}
			}
		}
	}

	/// <summary>
	/// Initializes the dependency list for each SerializedAssetCollection in this Bundle and its children Bundles.
	/// </summary>
	internal void InitializeAllDependencyLists(IDependencyProvider? dependencyProvider)
	{
		foreach (AssetCollection collection in Collections)
		{
			if (collection is SerializedAssetCollection serializedAssetCollection)
			{
				serializedAssetCollection.InitializeDependencyList(dependencyProvider);
			}
		}
		foreach (Bundle bundle in Bundles)
		{
			bundle.InitializeAllDependencyLists(dependencyProvider);
		}
	}

	/// <summary>
	/// Resolves an <see cref="AssetCollection"/> with the specified name in this Bundle and its ascendants.
	/// </summary>
	/// <param name="identifier">The identifier of the file of the <see cref="AssetCollection"/>.</param>
	/// <returns>The resolved <see cref="AssetCollection"/> if it exists, else null.</returns>
	public AssetCollection? ResolveCollection(FileIdentifier identifier)
	{
		return ResolveCollection(identifier.GetFilePath());
	}

	/// <summary>
	/// Resolves an <see cref="AssetCollection"/> with the specified name in this Bundle and its ascendants.
	/// </summary>
	/// <param name="name">The name of the <see cref="AssetCollection"/>.</param>
	/// <returns>The resolved <see cref="AssetCollection"/> if it exists, else null.</returns>
	public AssetCollection? ResolveCollection(string name)
	{
		AssetCollection? result = ResolveInternal(name);
		if (result is not null)
		{
			return result;
		}

		string fixedName = SpecialFileNames.FixFileIdentifier(name);
		result = ResolveInternal(fixedName);
		if (result is not null)
		{
			return result;
		}

		return fixedName switch
		{
			SpecialFileNames.DefaultResourceName1 => ResolveInternal(SpecialFileNames.DefaultResourceName2),
			SpecialFileNames.DefaultResourceName2 => ResolveInternal(SpecialFileNames.DefaultResourceName1),
			SpecialFileNames.BuiltinExtraName1 => ResolveInternal(SpecialFileNames.BuiltinExtraName2),
			SpecialFileNames.BuiltinExtraName2 => ResolveInternal(SpecialFileNames.BuiltinExtraName1),
			_ => null,
		};

		AssetCollection? ResolveInternal(string name)
		{
			Bundle? bundleToExclude = null;
			Bundle? currentBundle = this;
			while (currentBundle is not null)
			{
				AssetCollection? result = TryResolveFromCollections(currentBundle, name) ?? TryResolveFromChildBundles(currentBundle, name, bundleToExclude);
				if (result is not null)
				{
					return result;
				}

				bundleToExclude = currentBundle;
				currentBundle = currentBundle.Parent;
			}

			return null;
		}

		/// <summary>
		/// Attempts to resolve an <see cref="AssetCollection"/> with the specified name in the specified Bundle's collections.
		/// </summary>
		/// <param name="currentBundle">The Bundle to attempt to resolve the <see cref="AssetCollection"/> from.</param>
		/// <param name="name">The name of the <see cref="AssetCollection"/>.</param>
		/// <returns>The resolved <see cref="AssetCollection"/> if it exists, else null.</returns>
		static AssetCollection? TryResolveFromCollections(Bundle currentBundle, string name)
		{
			//Uniqueness is not guaranteed because of asset bundle variants
			foreach (AssetCollection collection in currentBundle.Collections)
			{
				if (collection.Name == name)
				{
					return collection;
				}
			}

			return null;
		}

		/// <summary>
		/// Attempts to resolve an <see cref="AssetCollection"/> with the specified name in the specified Bundle's child Bundles.
		/// </summary>
		/// <param name="currentBundle">The Bundle to attempt to resolve the <see cref="AssetCollection"/> from.</param>
		/// <param name="name">The name of the <see cref="AssetCollection"/>.</param>
		/// <param name="bundleToExclude">The <see cref="Bundle"/> to exclude from the search.</param>
		/// <returns>The resolved <see cref="AssetCollection"/> if it exists, else null.</returns>
		static AssetCollection? TryResolveFromChildBundles(Bundle currentBundle, string name, Bundle? bundleToExclude)
		{
			foreach (Bundle bundle in currentBundle.Bundles)
			{
				if (bundle != bundleToExclude && TryResolveFromCollections(bundle, name) is { } collection)
				{
					return collection;
				}
			}

			return null;
		}
	}

	/// <summary>
	/// Resolves a ResourceFile with the specified name in this Bundle and its ascendants.
	/// </summary>
	/// <param name="name">The name of the ResourceFile.</param>
	/// <returns>The resolved ResourceFile if it exists, else null.</returns>
	public ResourceFile? ResolveResource([NotNullWhen(true)] string? name)
	{
		if (string.IsNullOrEmpty(name))
		{
			return null;
		}

		string originalName = name;
		string fixedName = SpecialFileNames.FixFileIdentifier(name);

		Bundle? bundleToExclude = null;
		Bundle? currentBundle = this;
		while (currentBundle is not null)
		{
			ResourceFile? result = TryResolveFromResources(currentBundle, fixedName)
				?? TryResolveFromChildBundles(currentBundle, originalName, fixedName, bundleToExclude)
				?? currentBundle.ResolveExternalResource(originalName);
			if (result is not null)
			{
				return result;
			}

			bundleToExclude = currentBundle;
			currentBundle = currentBundle.Parent;
		}

		return null;

		/// <summary>
		/// Attempts to resolve a ResourceFile with the specified name in the specified Bundle's Resources.
		/// </summary>
		/// <param name="currentBundle">The Bundle to attempt to resolve the ResourceFile from.</param>
		/// <param name="fixedName">The name of the ResourceFile with invalid characters and path separators fixed.</param>
		/// <returns>The resolved ResourceFile if it exists, else null.</returns>
		static ResourceFile? TryResolveFromResources(Bundle currentBundle, string fixedName)
		{
			//Uniqueness is not guaranteed because of asset bundle variants
			foreach (ResourceFile resource in currentBundle.Resources)
			{
				if (resource.NameFixed == fixedName)
				{
					return resource;
				}
			}

			return null;
		}

		/// <summary>
		/// Attempts to resolve a ResourceFile with the specified name in the specified Bundle's child Bundles.
		/// </summary>
		/// <param name="currentBundle">The Bundle to attempt to resolve the ResourceFile from.</param>
		/// <param name="originalName">The original name of the ResourceFile.</param>
		/// <param name="fixedName">The name of the ResourceFile with invalid characters and path separators fixed.</param>
		/// <param name="bundleToExclude">The Bundle to exclude from the search.</param>
		/// <returns>The resolved ResourceFile if it exists, else null.</returns>
		static ResourceFile? TryResolveFromChildBundles(Bundle currentBundle, string originalName, string fixedName, Bundle? bundleToExclude)
		{
			foreach (Bundle bundle in currentBundle.Bundles)
			{
				if (bundle != bundleToExclude && TryResolveFromResources(bundle, fixedName) is { } resource)
				{
					return resource;
				}
			}

			return null;
		}
	}

	protected virtual ResourceFile? ResolveExternalResource(string originalName) => null;

	/// <summary>
	/// Adds a ResourceFile to this Bundle.
	/// </summary>
	/// <param name="resource">The ResourceFile to add.</param>
	public void AddResource(ResourceFile resource)
	{
		resources.Add(resource);
	}

	/// <summary>
	/// Adds an <see cref="AssetCollection"/> to this Bundle.
	/// </summary>
	/// <param name="collection">The <see cref="AssetCollection"/> to add.</param>
	public void AddCollection(AssetCollection collection)
	{
		if (collection.Bundle != this)
		{
			throw new ArgumentException($"Collection's {nameof(AssetCollection.Bundle)} property did not match this.", nameof(collection));
		}
		else if (IsCompatibleCollection(collection))
		{
			collections.Add(collection);
		}
		else
		{
			throw new ArgumentException($"The collection is not compatible with this {nameof(Bundle)}.", nameof(collection));
		}
	}

	/// <summary>
	/// Adds a child Bundle to this Bundle.
	/// </summary>
	/// <param name="bundle">The Bundle to add.</param>
	public void AddBundle(Bundle bundle)
	{
		if (bundle.Parent is null)
		{
			if (IsCompatibleBundle(bundle))
			{
				bundles.Add(bundle);
				bundle.Parent = this;
			}
			else
			{
				throw new ArgumentException($"Child {nameof(Bundle)} is not compatible with this parent {nameof(Bundle)}.", nameof(bundle));
			}
		}
		else if (bundle.Parent == this)
		{
		}
		else
		{
			throw new ArgumentException($"{nameof(bundle)} already has a parent.", nameof(bundle));
		}
	}

	public void AddFailed(FailedFile file)
	{
		failedFiles.Add(file);
	}

	/// <summary>
	/// Indicates if the specified <see cref="AssetCollection"/> is compatible with this Bundle.
	/// </summary>
	/// <param name="collection">The <see cref="AssetCollection"/> to check.</param>
	/// <returns>True if the <see cref="AssetCollection"/> is compatible, else false.</returns>
	protected virtual bool IsCompatibleCollection(AssetCollection collection) => true;

	/// <summary>
	/// Indicates if the specified Bundle is compatible with this Bundle.
	/// </summary>
	/// <param name="bundle">The Bundle to check.</param>
	/// <returns>True if the Bundle is compatible, else false.</returns>
	protected virtual bool IsCompatibleBundle(Bundle bundle) => bundle is not GameBundle;

	/// <summary>
	/// Gets the root Bundle of this Bundle.
	/// </summary>
	/// <returns>The root Bundle of this Bundle.</returns>
	public Bundle GetRoot()
	{
		Bundle root = this;
		while (root.Parent is not null)
		{
			root = root.Parent;
		}
		return root;
	}

	/// <summary>
	/// Fetches all <see cref="IUnityObjectBase"/>s in the hierarchy of this Bundle.
	/// </summary>
	/// <returns>An IEnumerable of all <see cref="IUnityObjectBase"/>s in the hierarchy.</returns>
	public IEnumerable<IUnityObjectBase> FetchAssetsInHierarchy()
	{
		return GetRoot().FetchAssets();
	}

	/// <summary>
	/// Fetches all <see cref="IUnityObjectBase"/>s in this Bundle.
	/// </summary>
	/// <returns>An IEnumerable of all <see cref="IUnityObjectBase"/>s in this Bundle.</returns>
	public IEnumerable<IUnityObjectBase> FetchAssets()
	{
		foreach (AssetCollection collection in collections)
		{
			foreach (IUnityObjectBase asset in collection)
			{
				yield return asset;
			}
		}
		foreach (Bundle bundle in bundles)
		{
			foreach (IUnityObjectBase asset in bundle.FetchAssets())
			{
				yield return asset;
			}
		}
	}

	/// <summary>
	/// Fetches all AssetCollections in the hierarchy of this Bundle.
	/// </summary>
	/// <returns>An IEnumerable of all AssetCollections in the hierarchy.</returns>
	public IEnumerable<AssetCollection> FetchAssetCollections()
	{
		foreach (AssetCollection collection in collections)
		{
			yield return collection;
		}
		foreach (Bundle bundle in bundles)
		{
			foreach (AssetCollection collection in bundle.FetchAssetCollections())
			{
				yield return collection;
			}
		}
	}

	public IEnumerable<ResourceFile> FetchResourceFiles()
	{
		foreach (ResourceFile resource in resources)
		{
			yield return resource;
		}
		foreach (Bundle bundle in bundles)
		{
			foreach (ResourceFile resource in bundle.FetchResourceFiles())
			{
				yield return resource;
			}
		}
	}

	public override string ToString()
	{
		return Name;
	}

	public SerializedAssetCollection AddCollectionFromSerializedFile(SerializedFile file, AssetFactoryBase factory, UnityVersion defaultVersion = default)
	{
		return SerializedAssetCollection.FromSerializedFile(this, file, factory, defaultVersion);
	}

	#region IDisposable Support
	protected virtual void Dispose(bool disposing)
	{
		if (!disposedValue)
		{
			if (disposing)
			{
				foreach (ResourceFile resourceFile in resources)
				{
					resourceFile.Dispose();
				}
				foreach (Bundle bundle in bundles)
				{
					bundle.Dispose();
				}
			}

			disposedValue = true;
		}
	}

	// This code added to correctly implement the disposable pattern.
	public void Dispose()
	{
		// Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}
	#endregion
}

```

`Source/AssetRipper.Assets/Bundles/DefaultGameInitializer.cs`:

```cs
using AssetRipper.Assets.IO;

namespace AssetRipper.Assets.Bundles;

public record class DefaultGameInitializer(IDependencyProvider? DependencyProvider = null, IResourceProvider? ResourceProvider = null, UnityVersion DefaultVersion = default) : IGameInitializer
{
	public virtual void OnCreated(GameBundle gameBundle, AssetFactoryBase assetFactory) { }
	public virtual void OnPathsLoaded(GameBundle gameBundle, AssetFactoryBase assetFactory) { }
	public virtual void OnDependenciesInitialized(GameBundle gameBundle, AssetFactoryBase assetFactory) { }
}

```

`Source/AssetRipper.Assets/Bundles/GameBundle.FromPaths.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.IO;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.CompressedFiles;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.Assets.Bundles;

partial class GameBundle
{
	/// <summary>
	/// Create and initialize a <see cref="GameBundle"/> from a set of paths.
	/// </summary>
	/// <param name="paths">The set of paths to load.</param>
	/// <param name="assetFactory">The factory for reading assets.</param>
	/// <param name="dependencyProvider"></param>
	/// <param name="resourceProvider"></param>
	/// <param name="defaultVersion">The default version to use if a file does not have a version, ie the version has been stripped.</param>
	public static GameBundle FromPaths(IEnumerable<string> paths, AssetFactoryBase assetFactory, FileSystem fileSystem, IGameInitializer? initializer = null)
	{
		GameBundle gameBundle = new();
		initializer?.OnCreated(gameBundle, assetFactory);
		gameBundle.InitializeFromPaths(paths, assetFactory, fileSystem, initializer);
		initializer?.OnPathsLoaded(gameBundle, assetFactory);
		gameBundle.InitializeAllDependencyLists(initializer?.DependencyProvider);
		initializer?.OnDependenciesInitialized(gameBundle, assetFactory);
		return gameBundle;
	}

	private void InitializeFromPaths(IEnumerable<string> paths, AssetFactoryBase assetFactory, FileSystem fileSystem, IGameInitializer? initializer)
	{
		ResourceProvider = initializer?.ResourceProvider;
		List<FileBase> fileStack = LoadFilesAndDependencies(paths, fileSystem, initializer?.DependencyProvider);
		UnityVersion defaultVersion = initializer is null ? default : initializer.DefaultVersion;

		while (fileStack.Count > 0)
		{
			switch (RemoveLastItem(fileStack))
			{
				case SerializedFile serializedFile:
					SerializedAssetCollection.FromSerializedFile(this, serializedFile, assetFactory, defaultVersion);
					break;
				case FileContainer container:
					SerializedBundle serializedBundle = SerializedBundle.FromFileContainer(container, assetFactory, defaultVersion);
					AddBundle(serializedBundle);
					break;
				case ResourceFile resourceFile:
					AddResource(resourceFile);
					break;
				case FailedFile failedFile:
					AddFailed(failedFile);
					break;
			}
		}
	}

	private static FileBase RemoveLastItem(List<FileBase> list)
	{
		int index = list.Count - 1;
		FileBase file = list[index];
		list.RemoveAt(index);
		return file;
	}

	private static List<FileBase> LoadFilesAndDependencies(IEnumerable<string> paths, FileSystem fileSystem, IDependencyProvider? dependencyProvider)
	{
		List<FileBase> files = new();
		HashSet<string> serializedFileNames = new();//Includes missing dependencies
		foreach (string path in paths)
		{
			FileBase? file;
			try
			{
				file = SchemeReader.LoadFile(path, fileSystem);
				file.ReadContentsRecursively();
			}
			catch (Exception ex)
			{
				file = new FailedFile()
				{
					Name = fileSystem.Path.GetFileName(path),
					FilePath = path,
					StackTrace = ex.ToString(),
				};
			}
			while (file is CompressedFile compressedFile)
			{
				file = compressedFile.UncompressedFile;
			}
			if (file is ResourceFile or FailedFile)
			{
				files.Add(file);
			}
			else if (file is SerializedFile serializedFile)
			{
				files.Add(file);
				serializedFileNames.Add(serializedFile.NameFixed);
			}
			else if (file is FileContainer container)
			{
				files.Add(file);
				foreach (SerializedFile serializedFileInContainer in container.FetchSerializedFiles())
				{
					serializedFileNames.Add(serializedFileInContainer.NameFixed);
				}
			}
		}

		for (int i = 0; i < files.Count; i++)
		{
			FileBase file = files[i];
			if (file is SerializedFile serializedFile)
			{
				LoadDependencies(serializedFile, files, serializedFileNames, dependencyProvider);
			}
			else if (file is FileContainer container)
			{
				foreach (SerializedFile serializedFileInContainer in container.FetchSerializedFiles())
				{
					LoadDependencies(serializedFileInContainer, files, serializedFileNames, dependencyProvider);
				}
			}
		}

		return files;
	}

	private static void LoadDependencies(SerializedFile serializedFile, List<FileBase> files, HashSet<string> serializedFileNames, IDependencyProvider? dependencyProvider)
	{
		foreach (FileIdentifier fileIdentifier in serializedFile.Dependencies)
		{
			string name = fileIdentifier.GetFilePath();
			if (serializedFileNames.Add(name) && dependencyProvider?.FindDependency(fileIdentifier) is { } dependency)
			{
				files.Add(dependency);
			}
		}
	}
}

```

`Source/AssetRipper.Assets/Bundles/GameBundle.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Files.ResourceFiles;

namespace AssetRipper.Assets.Bundles;

/// <summary>
/// A <see cref="Bundle"/> encompassing an entire game.
/// </summary>
public sealed partial class GameBundle : Bundle
{
	/// <summary>
	/// The <see cref="IResourceProvider"/> being used for this bundle.
	/// </summary>
	public IResourceProvider? ResourceProvider { get; set; }

	/// <summary>
	/// The name of this bundle which is 'GameBundle'.
	/// </summary>
	public override string Name => nameof(GameBundle);

	/// <summary>
	/// Returns true if the given bundle is compatible with this bundle.
	/// </summary>
	/// <param name="bundle">The bundle to check compatibility with.</param>
	protected override bool IsCompatibleBundle(Bundle bundle)
	{
		return bundle is not GameBundle;
	}

	/// <summary>
	/// Resolves an external ResourceFile, or returns null if it cannot be found.
	/// </summary>
	/// <param name="originalName">The original name of the ResourceFile.</param>
	protected override ResourceFile? ResolveExternalResource(string originalName)
	{
		if (ResourceProvider is not null)
		{
			ResourceFile? resourceFile = ResourceProvider.FindResource(originalName);
			if (resourceFile is not null)
			{
				AddResource(resourceFile);
			}
			return resourceFile;
		}
		else
		{
			return base.ResolveExternalResource(originalName);
		}
	}

	[Obsolete($"{nameof(GameBundle)} has no {nameof(Parent)}. Use {nameof(FetchAssets)} instead.", true)]
	public new IEnumerable<IUnityObjectBase> FetchAssetsInHierarchy() => base.FetchAssetsInHierarchy();

	/// <summary>
	/// Initializes all dependency lists.
	/// </summary>
	public new void InitializeAllDependencyLists(IDependencyProvider? dependencyProvider = null) => base.InitializeAllDependencyLists(dependencyProvider);

	/// Returns true if this bundle has any asset collections.
	/// </summary>
	public bool HasAnyAssetCollections()
	{
		return FetchAssetCollections().Any();
	}

	/// <summary>
	/// Adds a new processed asset collection to this bundle.
	/// </summary>
	/// <param name="name">The name of the new asset collection.</param>
	/// <param name="version">The Unity version of the new asset collection.</param>
	public ProcessedAssetCollection AddNewProcessedCollection(string name, UnityVersion version)
	{
		ProcessedAssetCollection processedCollection = new ProcessedAssetCollection(this);
		processedCollection.Name = name;
		processedCollection.SetLayout(version);
		return processedCollection;
	}

	public ProcessedBundle AddNewProcessedBundle(string? name = null)
	{
		ProcessedBundle processedBundle = new ProcessedBundle(name);
		AddBundle(processedBundle);
		return processedBundle;
	}

	/// <summary>
	/// Returns the maximum Unity version of all asset collections in this bundle.
	/// </summary>
	public UnityVersion GetMaxUnityVersion()
	{
		return FetchAssetCollections().Select(t => t.Version).Append(UnityVersion.MinVersion).Max();
	}
}

```

`Source/AssetRipper.Assets/Bundles/IDependencyProvider.cs`:

```cs
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.Assets.Bundles;

public interface IDependencyProvider
{
	FileBase? FindDependency(FileIdentifier identifier);
	void ReportMissingDependency(FileIdentifier identifier);
}

```

`Source/AssetRipper.Assets/Bundles/IGameInitializer.cs`:

```cs
using AssetRipper.Assets.IO;

namespace AssetRipper.Assets.Bundles;

public interface IGameInitializer
{
	IDependencyProvider? DependencyProvider => null;
	IResourceProvider? ResourceProvider => null;
	UnityVersion DefaultVersion => default;
	void OnCreated(GameBundle gameBundle, AssetFactoryBase assetFactory) { }
	void OnPathsLoaded(GameBundle gameBundle, AssetFactoryBase assetFactory) { }
	void OnDependenciesInitialized(GameBundle gameBundle, AssetFactoryBase assetFactory) { }
}

```

`Source/AssetRipper.Assets/Bundles/IResourceProvider.cs`:

```cs
using AssetRipper.IO.Files.ResourceFiles;

namespace AssetRipper.Assets.Bundles;

public interface IResourceProvider
{
	ResourceFile? FindResource(string identifier);
}

```

`Source/AssetRipper.Assets/Bundles/ProcessedBundle.cs`:

```cs
using AssetRipper.Assets.Collections;

namespace AssetRipper.Assets.Bundles;

/// <summary>
/// A <see cref="Bundle"/> containing <see cref="ProcessedAssetCollection"/>s.
/// </summary>
public sealed class ProcessedBundle : VirtualBundle<ProcessedAssetCollection>
{
	/// <inheritdoc/>
	public override string Name { get; }

	/// <summary>
	/// Initializes a new instance of the <see cref="ProcessedBundle"/> class with a generated name.
	/// </summary>
	public ProcessedBundle()
	{
		Name = GenerateRandomName();
	}

	/// <summary>
	/// Initializes a new instance of the <see cref="ProcessedBundle"/> class.
	/// </summary>
	/// <param name="name">The name of the bundle. If a name is not provided, a random name is generated.</param>
	public ProcessedBundle(string? name)
	{
		Name = string.IsNullOrEmpty(name) ? GenerateRandomName() : name;
	}

	private static string GenerateRandomName() => $"{nameof(ProcessedBundle)}_{UnityGuid.NewGuid()}";

	/// <summary>
	/// Adds a new processed asset collection to this bundle.
	/// </summary>
	/// <param name="name">The name of the new asset collection.</param>
	/// <param name="version">The Unity version of the new asset collection.</param>
	public ProcessedAssetCollection AddNewProcessedCollection(string name, UnityVersion version)
	{
		ProcessedAssetCollection processedCollection = new ProcessedAssetCollection(this);
		processedCollection.Name = name;
		processedCollection.SetLayout(version);
		return processedCollection;
	}
}

```

`Source/AssetRipper.Assets/Bundles/SerializedBundle.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.IO;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.Assets.Bundles;

/// <summary>
/// A <see cref="Bundle"/> created from serialized assets.
/// </summary>
public sealed class SerializedBundle : Bundle
{
	private string name = string.Empty;

	public override string Name => name;

	public static SerializedBundle FromFileContainer(FileContainer container, AssetFactoryBase factory, UnityVersion defaultVersion = default)
	{
		SerializedBundle bundle = new();
		bundle.name = container.NameFixed;
		foreach (ResourceFile resourceFile in container.ResourceFiles)
		{
			bundle.AddResource(resourceFile);
		}
		foreach (SerializedFile serializedFile in container.SerializedFiles)
		{
			bundle.AddCollectionFromSerializedFile(serializedFile, factory, defaultVersion);
		}
		foreach (FileContainer childContainer in container.FileLists)
		{
			SerializedBundle childBundle = FromFileContainer(childContainer, factory, defaultVersion);
			bundle.AddBundle(childBundle);
		}
		foreach (FailedFile failedFile in container.FailedFiles)
		{
			bundle.AddFailed(failedFile);
		}
		return bundle;
	}

	protected override bool IsCompatibleBundle(Bundle bundle) => bundle is SerializedBundle;

	protected override bool IsCompatibleCollection(AssetCollection collection) => collection is SerializedAssetCollection;
}

```

`Source/AssetRipper.Assets/Bundles/VirtualBundle.cs`:

```cs
using AssetRipper.Assets.Collections;

namespace AssetRipper.Assets.Bundles;

/// <summary>
/// Abstract class for virtual bundles.
/// </summary>
/// <typeparam name="T">The Type of the <see cref="VirtualAssetCollection"/>s that this bundle can contain.</typeparam>
public abstract class VirtualBundle<T> : Bundle where T : VirtualAssetCollection
{
	protected sealed override bool IsCompatibleBundle(Bundle bundle)
	{
		return bundle is VirtualBundle<T>;
	}

	protected sealed override bool IsCompatibleCollection(AssetCollection collection)
	{
		return collection is T;
	}
}

```

`Source/AssetRipper.Assets/Cloning/AssetEqualityComparer.cs`:

```cs
using AssetRipper.Assets.Metadata;
using System.Diagnostics;

namespace AssetRipper.Assets.Cloning;

public sealed class AssetEqualityComparer : IEqualityComparer<IUnityObjectBase>
{
	private readonly Dictionary<UnorderedPair, bool> compareCache = new();
	private readonly Dictionary<UnorderedPair, List<UnorderedPair>> dependentEqualityPairs = new();
	public IUnityObjectBase CallingObject { get; private set; } = default!;
	public IUnityObjectBase OtherObject { get; private set; } = default!;

	/// <summary>
	/// Used for source generation.
	/// </summary>
	/// <param name="pptrFromCallingObject"></param>
	/// <param name="pptrFromOtherObject"></param>
	/// <returns>True if they're equal, false if they're inequal, or null if it was added to the list of dependent pairs.</returns>
	public bool? MaybeAddDependentComparison(IPPtr pptrFromCallingObject, IPPtr pptrFromOtherObject)
	{
		IUnityObjectBase? x = CallingObject.Collection.TryGetAsset(pptrFromCallingObject.FileID, pptrFromCallingObject.PathID);
		IUnityObjectBase? y = OtherObject.Collection.TryGetAsset(pptrFromOtherObject.FileID, pptrFromOtherObject.PathID);

		if (ReferenceEquals(x, y)) //Both null or both same instance
		{
			return true;
		}
		else if (x is null || y is null || x.GetType() != y.GetType())
		{
			return false;
		}
		else if (compareCache.TryGetValue((x, y), out bool value))
		{
			return value;
		}
		else
		{
			if (dependentEqualityPairs.TryGetValue((CallingObject, OtherObject), out List<UnorderedPair>? list))
			{
				list.Add((x, y));
			}
			else
			{
				list = [(x, y)];
				dependentEqualityPairs.Add((CallingObject, OtherObject), list);
			}
			return null;
		}
	}

	public bool Equals(IUnityObjectBase? x, IUnityObjectBase? y)
	{
		if (ReferenceEquals(x, y)) //Both null or both same instance
		{
			return true;
		}
		else if (x is null || y is null || x.GetType() != y.GetType())
		{
			return false;
		}

		DoComparison(x, y);
		EvaluateDependentEqualityComparisons();
		Debug.Assert(dependentEqualityPairs.Count == 0, "Dependent equality pairs should have been resolved");

		return compareCache[(x, y)];
	}

	private void EvaluateDependentEqualityComparisons()
	{
		if (dependentEqualityPairs.Count == 0)
		{
			return;
		}

		List<UnorderedPair> pairsToCompare = new();
		bool hasChanged;
		do
		{
			hasChanged = false;
			pairsToCompare.Clear();

			foreach ((UnorderedPair keyPair, List<UnorderedPair> list) in dependentEqualityPairs.ToArray())
			{
				for (int i = list.Count - 1; i >= 0; i--)
				{
					UnorderedPair valuePair = list[i];
					if (compareCache.TryGetValue(valuePair, out bool value))
					{
						hasChanged = true;
						if (value)
						{
							list.RemoveAt(i);
						}
						else
						{
							compareCache[keyPair] = false;
							dependentEqualityPairs.Remove(keyPair);
							break;
						}
					}
					else if (!dependentEqualityPairs.ContainsKey(valuePair))
					{
						pairsToCompare.Add(valuePair);
					}
				}
			}

			if (pairsToCompare.Count > 0)
			{
				hasChanged = true;

				foreach (UnorderedPair pair in pairsToCompare)
				{
					DoComparison(pair.First, pair.Second);
				}
			}
		} while (hasChanged);

		if (dependentEqualityPairs.Count > 0)
		{
			foreach ((UnorderedPair keyPair, _) in dependentEqualityPairs)
			{
				compareCache[keyPair] = true;
			}
			dependentEqualityPairs.Clear();
		}
	}

	private void DoComparison(IUnityObjectBase x, IUnityObjectBase y)
	{
		CallingObject = x;
		OtherObject = y;

		bool? result = x.AddToEqualityComparer(y, this);
		if (result is { } value)
		{
			dependentEqualityPairs.Remove((x, y));
			compareCache[(x, y)] = value;
		}

		CallingObject = default!;
		OtherObject = default!;
	}

	public int GetHashCode(IUnityObjectBase? obj)
	{
		if (obj == null)
		{
			return 0;
		}

		return HashCode.Combine(obj.GetType(), obj.GetBestName());
	}

	private readonly record struct UnorderedPair(IUnityObjectBase First, IUnityObjectBase Second)
	{
		public bool Equals(UnorderedPair other)
		{
			return (First == other.First && Second == other.Second) || (First == other.Second && Second == other.First);
		}

		public override int GetHashCode()
		{
			return First.GetHashCode() ^ Second.GetHashCode();
		}

		public static implicit operator UnorderedPair((IUnityObjectBase First, IUnityObjectBase Second) pair)
		{
			return new(pair.First, pair.Second);
		}

		public static implicit operator (IUnityObjectBase, IUnityObjectBase)(UnorderedPair pair)
		{
			return (pair.First, pair.Second);
		}
	}
}

```

`Source/AssetRipper.Assets/Cloning/DefaultAssetResolver.cs`:

```cs
namespace AssetRipper.Assets.Cloning;

public class DefaultAssetResolver : IAssetResolver
{
	public static DefaultAssetResolver Shared { get; } = new();

	public virtual T? Resolve<T>(IUnityObjectBase? asset) where T : IUnityObjectBase
	{
		return asset is T t ? t : default;
	}
}

```

`Source/AssetRipper.Assets/Cloning/IAssetResolver.cs`:

```cs
namespace AssetRipper.Assets.Cloning;

public interface IAssetResolver
{
	T? Resolve<T>(IUnityObjectBase? asset) where T : IUnityObjectBase;
}

```

`Source/AssetRipper.Assets/Cloning/PPtrConverter.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.Assets.Cloning;

public readonly record struct PPtrConverter(AssetCollection SourceCollection, AssetCollection TargetCollection, IAssetResolver Resolver)
{
	public PPtrConverter(AssetCollection SourceCollection, AssetCollection TargetCollection)
		: this(SourceCollection, TargetCollection, DefaultAssetResolver.Shared)
	{
	}

	public PPtrConverter(IUnityObjectBase sourceAsset, IUnityObjectBase targetAsset) : this(sourceAsset.Collection, targetAsset.Collection)
	{
	}

	/// <summary>
	/// A constructor for when an asset is both the source and the target.
	/// </summary>
	/// <param name="asset"></param>
	public PPtrConverter(IUnityObjectBase asset) : this(asset, asset)
	{
	}

	public PPtr<T> Convert<T>(PPtr sourcePPtr) where T : IUnityObjectBase
	{
		IUnityObjectBase? asset = SourceCollection.TryGetAsset(sourcePPtr);
		return TargetCollection.ForceCreatePPtr(Resolver.Resolve<T>(asset));
	}
}

```

`Source/AssetRipper.Assets/Cloning/SingleReplacementAssetResolver.cs`:

```cs
namespace AssetRipper.Assets.Cloning;

public class SingleReplacementAssetResolver(IUnityObjectBase original, IUnityObjectBase replacement) : IAssetResolver
{
	public IUnityObjectBase Original { get; } = original;
	public IUnityObjectBase Replacement { get; } = replacement;

	public T? Resolve<T>(IUnityObjectBase? asset) where T : IUnityObjectBase
	{
		if (asset == Original)
		{
			return TryCast<T>(Replacement);
		}
		return TryCast<T>(asset);
	}

	private static T? TryCast<T>(IUnityObjectBase? asset) where T : IUnityObjectBase
	{
		return asset is T t ? t : default;
	}
}

```

`Source/AssetRipper.Assets/Collections/AssetCollection.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Metadata;
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles;
using System.Collections;

namespace AssetRipper.Assets.Collections;

/// <summary>
/// A collection of <see cref="IUnityObjectBase"/> assets.
/// </summary>
public abstract class AssetCollection : IReadOnlyCollection<IUnityObjectBase>
{
	protected AssetCollection(Bundle bundle)
	{
		dependencies.Add(this);
		Bundle = bundle;
		bundle.AddCollection(this);
	}

	public Bundle Bundle { get; }
	public string Name { get; protected set; } = string.Empty;
	public string FilePath { get; set; } = string.Empty;
	/// <summary>
	/// The list of dependencies for this collection.
	/// </summary>
	/// <remarks>
	/// The zeroth entry is <see langword="this"/> for correct correspondence with file indices.
	/// Entries are null if they could not be found.
	/// </remarks>
	public IReadOnlyList<AssetCollection?> Dependencies => dependencies;
	private readonly List<AssetCollection?> dependencies = new();
	public IReadOnlyDictionary<long, IUnityObjectBase> Assets => assets;
	private readonly Dictionary<long, IUnityObjectBase> assets = new();
	public UnityVersion OriginalVersion { get; protected set; }
	public UnityVersion Version { get; protected set; }
	public BuildTarget Platform { get; protected set; }
	public TransferInstructionFlags Flags { get; protected set; }
	public EndianType EndianType { get; protected set; }

	[MemberNotNullWhen(true, nameof(Scene))]
	public bool IsScene => Scene is not null;

	public SceneDefinition? Scene { get; internal set; }

	public int AddDependency(AssetCollection dependency)
	{
		int index = dependencies.IndexOf(dependency);
		if (index >= 0)
		{
			return index;
		}
		else if (IsCompatibleDependency(dependency))
		{
			dependencies.Add(dependency);
			return dependencies.Count - 1;
		}
		else
		{
			throw new ArgumentException($"Dependency is not compatible with this {nameof(AssetCollection)}.", nameof(dependency));
		}
	}

	protected void SetDependency(int index, AssetCollection? collection)
	{
		if (index < 1)
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}
		else if (index < dependencies.Count)
		{
			dependencies[index] = collection;
		}
		else
		{
			while (dependencies.Count < index)
			{
				dependencies.Add(null);
			}
			dependencies.Add(collection);
		}
	}

	/// <summary>
	/// Determines if the given dependency collection is referencable from this collection.
	/// </summary>
	/// <param name="dependency"></param>
	/// <returns></returns>
	protected virtual bool IsCompatibleDependency(AssetCollection dependency) => true;

	public PPtr<T> CreatePPtr<T>(T? asset) where T : IUnityObjectBase
	{
		if (asset is null)
		{
			return default;
		}

		int fileIndex = dependencies.IndexOf(asset.Collection);
		if (fileIndex < 0)
		{
			throw new ArgumentException($"Asset doesn't belong to this {nameof(AssetCollection)} or any of its dependencies", nameof(asset));
		}
		return new PPtr<T>(fileIndex, asset.PathID);
	}

	public PPtr<T> ForceCreatePPtr<T>(T? asset) where T : IUnityObjectBase
	{
		if (asset is null)
		{
			return default;
		}

		int fileIndex = AddDependency(asset.Collection);
		return new PPtr<T>(fileIndex, asset.PathID);
	}

	protected void AddAsset(IUnityObjectBase asset)
	{
		ValidateAsset(asset);

		assets.Add(asset.PathID, asset);

		void ValidateAsset(IUnityObjectBase asset)
		{
			if (asset.Collection != this)
			{
				throw new ArgumentException("AssetInfo must have this marked as its collection.", nameof(asset));
			}
			if (asset.PathID is 0)
			{
				throw new ArgumentException("The zero path ID is reserved for null PPtr's.", nameof(asset));
			}
		}
	}

	/// <summary>
	/// Replace an asset in this collection.
	/// </summary>
	/// <remarks>
	/// This is useful for switching the underlying implementation, such as for version changing.
	/// </remarks>
	/// <param name="replacement"></param>
	public void ReplaceAsset(IUnityObjectBase replacement)
	{
		ValidateAsset(replacement);
		assets[replacement.PathID] = replacement;

		void ValidateAsset(IUnityObjectBase replacement)
		{
			if (replacement.Collection != this)
			{
				throw new ArgumentException("AssetInfo must have this marked as its collection.", nameof(replacement));
			}
			if (!assets.TryGetValue(replacement.PathID, out IUnityObjectBase? original))
			{
				throw new ArgumentException("There is no existing asset with this PathID.", nameof(replacement));
			}
			if (replacement.ClassID != original.ClassID)
			{
				throw new ArgumentException("The replacement asset's class id is not equal to the original asset's class id.", nameof(replacement));
			}
		}
	}

	public override string ToString()
	{
		return Name;
	}

	#region GetAsset Methods
	public IUnityObjectBase? TryGetAsset(long pathID)
	{
		TryGetAsset(pathID, out IUnityObjectBase? asset);
		return asset;
	}

	public T? TryGetAsset<T>(long pathID) where T : IUnityObjectBase
	{
		TryGetAsset(pathID, out T? asset);
		return asset;
	}

	public bool TryGetAsset(long pathID, [NotNullWhen(true)] out IUnityObjectBase? asset)
	{
		return TryGetAsset<IUnityObjectBase>(pathID, out asset);
	}

	public bool TryGetAsset<T>(long pathID, [NotNullWhen(true)] out T? asset) where T : IUnityObjectBase
	{
		if (assets.TryGetValue(pathID, out IUnityObjectBase? @object))
		{
			if (typeof(T).IsAssignableTo(typeof(NullObject)))
			{
				//T inherits from NullObject, so we allow the null object to be found.
				switch (@object)
				{
					case T t:
						asset = t;
						return true;
					default:
						asset = default;
						return false;
				}
			}
			else
			{
				switch (@object)
				{
					case NullObject:
						asset = default;
						return false;
					case T t:
						asset = t;
						return true;
					default:
						asset = default;
						return false;
				}
			}
		}
		else
		{
			asset = default;
			return false;
		}
	}

	public IUnityObjectBase? TryGetAsset(int fileIndex, long pathID)
	{
		TryGetAsset(fileIndex, pathID, out IUnityObjectBase? asset);
		return asset;
	}

	public T? TryGetAsset<T>(int fileIndex, long pathID) where T : IUnityObjectBase
	{
		TryGetAsset(fileIndex, pathID, out T? asset);
		return asset;
	}

	public bool TryGetAsset(int fileIndex, long pathID, [NotNullWhen(true)] out IUnityObjectBase? asset)
	{
		AssetCollection? file = TryGetDependency(fileIndex);
		if (file is not null)
		{
			return file.TryGetAsset(pathID, out asset);
		}
		else
		{
			asset = null;
			return false;
		}
	}

	public bool TryGetAsset<T>(int fileIndex, long pathID, [NotNullWhen(true)] out T? asset) where T : IUnityObjectBase
	{
		AssetCollection? file = TryGetDependency(fileIndex);
		if (file is not null)
		{
			return file.TryGetAsset(pathID, out asset);
		}
		else
		{
			asset = default;
			return false;
		}
	}

	public IUnityObjectBase? TryGetAsset(PPtr pptr) => TryGetAsset(pptr.FileID, pptr.PathID);

	public T? TryGetAsset<T>(PPtr<T> pptr) where T : IUnityObjectBase
	{
		return TryGetAsset<T>(pptr.FileID, pptr.PathID);
	}

	public bool TryGetAsset(PPtr pptr, [NotNullWhen(true)] out IUnityObjectBase? asset) => TryGetAsset(pptr.FileID, pptr.PathID, out asset);

	public bool TryGetAsset<T>(PPtr<T> pptr, [NotNullWhen(true)] out T? asset) where T : IUnityObjectBase
	{
		return TryGetAsset(pptr.FileID, pptr.PathID, out asset);
	}

	private AssetCollection? TryGetDependency(int fileIndex)
	{
		if (fileIndex < 0 || fileIndex >= Dependencies.Count)
		{
			return null;
		}
		else
		{
			return Dependencies[fileIndex];
		}
	}
	#endregion

	#region IReadOnlyCollection
	public IEnumerator<IUnityObjectBase> GetEnumerator() => assets.Values.GetEnumerator();
	IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
	public int Count => assets.Count;
	#endregion
}

```

`Source/AssetRipper.Assets/Collections/ProcessedAssetCollection.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Metadata;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.Assets.Collections;

/// <summary>
/// A collection of artificial assets generated during asset processing.
/// </summary>
public sealed class ProcessedAssetCollection : VirtualAssetCollection
{
	private long m_nextId;

	public ProcessedAssetCollection(Bundle bundle) : base(bundle)
	{
	}

	public new string Name
	{
		get => base.Name;
		set => base.Name = value;
	}

	public void SetLayout(UnityVersion version)
	{
		SetLayout(version, BuildTarget.NoTarget, TransferInstructionFlags.NoTransferInstructionFlags);
	}

	public void SetLayout(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
	{
		Version = version;
		OriginalVersion = version;
		Platform = platform;
		Flags = flags;
	}

	public T CreateAsset<T>(int classID, Func<AssetInfo, T> factory) where T : IUnityObjectBase
	{
		AssetInfo assetInfo = CreateAssetInfo(classID);
		T asset = factory(assetInfo);
		AddAsset(asset);
		return asset;
	}

	public TAsset CreateAsset<TData, TAsset>(int classID, TData data, Func<AssetInfo, TData, TAsset> factory) where TAsset : IUnityObjectBase
	{
		AssetInfo assetInfo = CreateAssetInfo(classID);
		TAsset asset = factory(assetInfo, data);
		AddAsset(asset);
		return asset;
	}

	private AssetInfo CreateAssetInfo(int classID)
	{
		return new AssetInfo(this, ++m_nextId, classID);
	}
}


```

`Source/AssetRipper.Assets/Collections/SceneDefinition.cs`:

```cs
namespace AssetRipper.Assets.Collections;

public sealed class SceneDefinition
{
	private readonly List<AssetCollection> collections = new();

	private SceneDefinition()
	{
	}

	/// <summary>
	/// Creates a new <see cref="SceneDefinition"/> from the given name and guid.
	/// </summary>
	/// <param name="name">The name of the scene.</param>
	/// <param name="guid">The predefined <see cref="UnityGuid"/> for the scene. If default, a random one is assigned.</param>
	/// <returns></returns>
	public static SceneDefinition FromName(string name, UnityGuid guid = default)
	{
		return new()
		{
			Name = name,
			Path = $"Assets/Scenes/{name}",
			GUID = guid.IsZero ? UnityGuid.NewGuid() : guid,
		};
	}

	/// <summary>
	/// Creates a new <see cref="SceneDefinition"/> from the given path and guid.
	/// </summary>
	/// <param name="path">The relative path to the scene.</param>
	/// <param name="guid">The predefined <see cref="UnityGuid"/> for the scene. If default, a random one is assigned.</param>
	/// <returns></returns>
	public static SceneDefinition FromPath(string path, UnityGuid guid = default)
	{
		return new()
		{
			Name = System.IO.Path.GetFileName(path),
			Path = path,
			GUID = guid.IsZero ? UnityGuid.NewGuid() : guid,
		};
	}

	/// <summary>
	/// The name of the scene, without any file extension.
	/// </summary>
	public required string Name { get; init; }

	/// <summary>
	/// The scene path without any file extension, relative to the project root directory.
	/// </summary>
	public required string Path { get; init; }

	/// <summary>
	/// The GUID of this scene. It gets used in the scene's meta file. This will not be <see cref="UnityGuid.Zero"/>.
	/// </summary>
	public required UnityGuid GUID { get; init; }

	/// <summary>
	/// All the <see cref="AssetCollection"/>s that make up this scene.
	/// </summary>
	public IReadOnlyList<AssetCollection> Collections => collections;

	/// <summary>
	/// All the assets inside the <see cref="Collections"/> that make up this scene.
	/// </summary>
	public IEnumerable<IUnityObjectBase> Assets => collections.SelectMany(c => c);

	/// <summary>
	/// Adds an <see cref="AssetCollection"/> to this <see cref="SceneDefinition"/> and sets its <see cref="AssetCollection.Scene"/> property.
	/// </summary>
	/// <param name="collection">The collection to be added.</param>
	public void AddCollection(AssetCollection collection)
	{
		ThrowIfAlreadyPartOfAScene(collection);
		collections.Add(collection);
		collection.Scene = this;
	}

	public void RemoveCollection(AssetCollection collection)
	{
		if (collections.Remove(collection))
		{
			collection.Scene = null;
		}
		else
		{
			throw new ArgumentException($"{collection} is not part of this scene.", nameof(collection));
		}
	}

	private static void ThrowIfAlreadyPartOfAScene(AssetCollection collection)
	{
		if (collection.Scene is not null)
		{
			throw new InvalidOperationException($"{collection} is already part of a scene.");
		}
	}

	public override string ToString() => Name;
}

```

`Source/AssetRipper.Assets/Collections/SerializedAssetCollection.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.IO;
using AssetRipper.Assets.Metadata;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.Assets.Collections;

/// <summary>
/// A collection of assets read from a <see cref="SerializedFile"/>.
/// </summary>
public sealed class SerializedAssetCollection : AssetCollection
{
	private FileIdentifier[]? DependencyIdentifiers { get; set; }

	private SerializedAssetCollection(Bundle bundle) : base(bundle)
	{
	}

	internal void InitializeDependencyList(IDependencyProvider? dependencyProvider)
	{
		if (Dependencies.Count > 1)
		{
			throw new Exception("Dependency list has already been initialized.");
		}
		if (DependencyIdentifiers is not null)
		{
			for (int i = 0; i < DependencyIdentifiers.Length; i++)
			{
				FileIdentifier identifier = DependencyIdentifiers[i];
				AssetCollection? dependency = Bundle.ResolveCollection(identifier);
				if (dependency is null)
				{
					dependencyProvider?.ReportMissingDependency(identifier);
				}
				SetDependency(i + 1, dependency);
			}
			DependencyIdentifiers = null;
		}
	}

	/// <summary>
	/// Creates a <see cref="SerializedAssetCollection"/> from a <see cref="SerializedFile"/>.
	/// </summary>
	/// <remarks>
	/// The new <see cref="SerializedAssetCollection"/> is automatically added to the <paramref name="bundle"/>.
	/// </remarks>
	/// <param name="bundle">The <see cref="Bundle"/> to add this collection to.</param>
	/// <param name="file">The <see cref="SerializedFile"/> from which to make this collection.</param>
	/// <param name="factory">A factory for creating assets.</param>
	/// <param name="defaultVersion">The default version to use if the file does not have a version, ie the version has been stripped.</param>
	/// <returns>The new collection.</returns>
	internal static SerializedAssetCollection FromSerializedFile(Bundle bundle, SerializedFile file, AssetFactoryBase factory, UnityVersion defaultVersion = default)
	{
		UnityVersion version = file.Version.Equals(0, 0, 0) ? defaultVersion : file.Version;
		SerializedAssetCollection collection = new SerializedAssetCollection(bundle)
		{
			Name = file.NameFixed,
			Version = version,
			OriginalVersion = version,
			Platform = file.Platform,
			Flags = file.Flags,
			EndianType = file.EndianType,
		};
		ReadOnlySpan<FileIdentifier> fileDependencies = file.Dependencies;
		if (fileDependencies.Length > 0)
		{
			collection.DependencyIdentifiers = fileDependencies.ToArray();
		}
		ReadData(collection, file, factory);
		return collection;
	}

	private static void ReadData(SerializedAssetCollection collection, SerializedFile file, AssetFactoryBase factory)
	{
		foreach (ObjectInfo objectInfo in file.Objects)
		{
			SerializedType? type = objectInfo.GetSerializedType(file.Types);
			int classID = objectInfo.TypeID < 0 ? 114 : objectInfo.TypeID;
			AssetInfo assetInfo = new AssetInfo(collection, objectInfo.FileID, classID);
			IUnityObjectBase? asset = factory.ReadAsset(assetInfo, objectInfo.ObjectData, type);
			if (asset is not null)
			{
				collection.AddAsset(asset);
			}
		}
	}
}

```

`Source/AssetRipper.Assets/Collections/VirtualAssetCollection.cs`:

```cs
using AssetRipper.Assets.Bundles;

namespace AssetRipper.Assets.Collections;

/// <summary>
/// A collection of artificial assets.
/// </summary>
public abstract class VirtualAssetCollection : AssetCollection
{
	protected VirtualAssetCollection(Bundle bundle) : base(bundle)
	{
	}
}

```

`Source/AssetRipper.Assets/Debugging/AssetKeyValuePair.cs`:

```cs
using System.Diagnostics;

namespace AssetRipper.Assets.Debugging;

[DebuggerDisplay("{Value}", Name = "{Key}")]
internal readonly struct AssetKeyValuePair
{
	public object? Key { get; }
	public object? Value { get; }

	public AssetKeyValuePair(object? key, object? value)
	{
		Key = key;
		Value = value;
	}
}

```

`Source/AssetRipper.Assets/Debugging/DebuggingWalker.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using System.Diagnostics;
using System.Reflection;

namespace AssetRipper.Assets.Debugging;

internal sealed class DebuggingWalker(AssetCollection collection, List<FieldNameValuePair> fields) : AssetWalker
{
	private bool rootAsset = true;
	private readonly Stack<object?> stack = new();

	public static FieldNameValuePair[] GetFields(IUnityAssetBase asset, AssetCollection collection)
	{
		List<FieldNameValuePair> fields = new();
		DebuggingWalker walker = new(collection, fields);
		asset.WalkStandard(walker);
		return fields.ToArray();
	}

	public override bool EnterField(IUnityAssetBase asset, string name)
	{
		stack.Push(name);
		return true;
	}

	public override void ExitField(IUnityAssetBase asset, string name)
	{
		object? fieldValue = stack.Pop();
		object? fieldName = stack.Pop();
		Debug.Assert(fieldName is string, "Expected field name to be a string.");

#pragma warning disable IL2075 // 'this' argument does not satisfy 'DynamicallyAccessedMembersAttribute' in call to target method. The return value of the source method does not have matching annotations.
		string? fieldType = asset.GetType().GetField(name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)?.FieldType.ToString();
#pragma warning restore IL2075 // 'this' argument does not satisfy 'DynamicallyAccessedMembersAttribute' in call to target method. The return value of the source method does not have matching annotations.

		fields.Add(new((string)fieldName, fieldValue, fieldType));
	}

	public override bool EnterAsset(IUnityAssetBase asset)
	{
		if (rootAsset)
		{
			// Ignore the root asset
			rootAsset = false;
			return true;
		}

		stack.Push(new UnityAssetBaseWithCollection(asset, collection));
		return false; // Do not visit children of the asset
	}

	public override bool EnterDictionary<TKey, TValue>(IReadOnlyCollection<KeyValuePair<TKey, TValue>> dictionary)
	{
		stack.Push(new List<AssetKeyValuePair>(dictionary.Count));
		return true;
	}

	public override void DivideDictionary<TKey, TValue>(IReadOnlyCollection<KeyValuePair<TKey, TValue>> dictionary)
	{
		AssetKeyValuePair pair = (AssetKeyValuePair)stack.Pop()!;
		List<AssetKeyValuePair> list = (List<AssetKeyValuePair>)stack.Peek()!;
		list.Add(pair);
	}

	public override void ExitDictionary<TKey, TValue>(IReadOnlyCollection<KeyValuePair<TKey, TValue>> dictionary)
	{
		if (dictionary.Count > 0)
		{
			DivideDictionary(dictionary);
		}
		List<AssetKeyValuePair> list = (List<AssetKeyValuePair>)stack.Pop()!;
		stack.Push(list.ToArray());
	}

	public override bool EnterList<T>(IReadOnlyList<T> _list)
	{
		if (typeof(T) == typeof(string) || typeof(T) == typeof(Utf8String) || typeof(T).IsPrimitive)
		{
			stack.Push(_list);
			return false;
		}

		stack.Push(new List<object?>(_list.Count));
		return true;
	}

	public override void DivideList<T>(IReadOnlyList<T> _list)
	{
		object? value = stack.Pop();
		List<object?> list = (List<object?>)stack.Peek()!;
		list.Add(value);
	}

	public override void ExitList<T>(IReadOnlyList<T> _list)
	{
		if (_list.Count > 0)
		{
			DivideList(_list);
		}
		List<object?> list = (List<object?>)stack.Pop()!;
		stack.Push(list.ToArray());
	}

	public override void ExitDictionaryPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		object? value = stack.Pop();
		object? key = stack.Pop();
		stack.Push(new AssetKeyValuePair(key, value));
	}

	public override void ExitPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		object? value = stack.Pop();
		object? key = stack.Pop();
		stack.Push(new KeyValuePair<object?, object?>(key, value));
	}

	public override void VisitPPtr<TAsset>(PPtr<TAsset> pptr)
	{
		TAsset? asset = collection.TryGetAsset(pptr);
		stack.Push(asset);
	}

	public override void VisitPrimitive<T>(T value)
	{
		stack.Push(value);
	}
}

```

`Source/AssetRipper.Assets/Debugging/FieldNameValuePair.cs`:

```cs
using System.Diagnostics;

namespace AssetRipper.Assets.Debugging;

[DebuggerDisplay("{Value}", Name = "{Name}", Type = "{Type}")]
internal readonly struct FieldNameValuePair
{
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public string Name { get; }

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	public object? Value { get; }

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public string? ValueType => Value?.GetType().ToString();

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public string? FieldType { get; }

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public string Type
	{
		get
		{
			if (Value is null)
			{
				return FieldType ?? "null";
			}
			else
			{
				string valueType = Value.GetType().ToString();
				if (FieldType is null || FieldType == valueType)
				{
					return valueType;
				}
				else
				{
					return $"{FieldType} {{{valueType}}}";
				}
			}
		}
	}

	public FieldNameValuePair(string name, object? value, string? fieldType)
	{
		Name = name;
		Value = value;
		FieldType = fieldType;
	}
}

```

`Source/AssetRipper.Assets/Debugging/UnityAssetBaseProxy.cs`:

```cs
using AssetRipper.Assets.Collections;
using System.Diagnostics;

namespace AssetRipper.Assets.Debugging;

internal readonly struct UnityAssetBaseProxy
{
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	internal readonly IUnityAssetBase asset;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	internal readonly AssetCollection collection;

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	public FieldNameValuePair[] lds => DebuggingWalker.GetFields(asset, collection);

	public UnityAssetBaseProxy(UnityAssetBaseWithCollection asset)
	{
		this.asset = asset.Asset;
		collection = asset.Collection;
	}

	public override string? ToString()
	{
		return asset.ToString();
	}
}

```

`Source/AssetRipper.Assets/Debugging/UnityAssetBaseWithCollection.cs`:

```cs
using AssetRipper.Assets.Collections;
using System.Diagnostics;

namespace AssetRipper.Assets.Debugging;

[DebuggerTypeProxy(typeof(UnityAssetBaseProxy))]
internal readonly struct UnityAssetBaseWithCollection
{
	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	internal IUnityAssetBase Asset { get; }

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	internal AssetCollection Collection { get; }

	public UnityAssetBaseWithCollection(IUnityAssetBase asset, AssetCollection collection)
	{
		Asset = asset;
		Collection = collection;
	}

	public override string? ToString()
	{
		return Asset.ToString();
	}
}

```

`Source/AssetRipper.Assets/Debugging/UnityObjectBaseProxy.cs`:

```cs
using AssetRipper.Assets.Collections;
using System.Diagnostics;

namespace AssetRipper.Assets.Debugging;

internal readonly struct UnityObjectBaseProxy
{
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly IUnityObjectBase asset;

	public AssetCollection Collection => asset.Collection;

	public IUnityObjectBase? MainAsset => asset.MainAsset;

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	public FieldNameValuePair[] Fields => DebuggingWalker.GetFields(asset, Collection);

	public UnityObjectBaseProxy(IUnityObjectBase asset)
	{
		this.asset = asset;
	}

	public override string? ToString()
	{
		return asset.ToString();
	}
}

```

`Source/AssetRipper.Assets/EmptyAsset.cs`:

```cs
namespace AssetRipper.Assets;

public sealed class EmptyAsset : UnityAssetBase
{
	public static EmptyAsset Instance { get; } = new EmptyAsset();
	private EmptyAsset()
	{
	}
}

```

`Source/AssetRipper.Assets/Exceptions/IncorrectByteCountException.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.Assets.Exceptions;

public sealed class IncorrectByteCountException : Exception
{
	public IncorrectByteCountException(long actual, long expected) : base(GetMessage(actual, expected))
	{
	}

	private static string GetMessage(long actual, long expected)
	{
		return $"Incorrect number of bytes read. Read {actual} but expected {expected}";
	}

	public static void ThrowIf(Stream stream, long basePosition, long size)
	{
		if (stream.Position - basePosition != size)
		{
			throw new IncorrectByteCountException(stream.Position - basePosition, size);
		}
	}

	public static void ThrowIf(in EndianSpanReader reader)
	{
		if (reader.Position != reader.Length)
		{
			throw new IncorrectByteCountException(reader.Position, reader.Length);
		}
	}
}

```

`Source/AssetRipper.Assets/Generics/AccessDictionary.cs`:

```cs
namespace AssetRipper.Assets.Generics;

/// <summary>
/// A wrapper for accessing the elements of an <see cref="AccessDictionaryBase{TKey, TValue}"/>
/// </summary>
/// <typeparam name="TKeyBase">The exposed key type, such as an interface</typeparam>
/// <typeparam name="TValueBase">The exposed value type, such as an interface</typeparam>
/// <typeparam name="TKey">The key type of the reference dictionary</typeparam>
/// <typeparam name="TValue">The value type of the reference dictionary</typeparam>
public sealed class AccessDictionary<TKey, TValue, TKeyBase, TValueBase> : AccessDictionaryBase<TKeyBase, TValueBase>
	where TKeyBase : notnull
	where TValueBase : notnull
	where TKey : notnull, TKeyBase, new()
	where TValue : notnull, TValueBase, new()
{
	private readonly AssetDictionary<TKey, TValue> referenceDictionary;

	public AccessDictionary(AssetDictionary<TKey, TValue> referenceDictionary)
	{
		this.referenceDictionary = referenceDictionary;
	}

	/// <inheritdoc/>
	public override int Count => referenceDictionary.Count;

	/// <inheritdoc/>
	public override int Capacity
	{
		get => referenceDictionary.Capacity;
		set => referenceDictionary.Capacity = value;
	}

	/// <inheritdoc/>
	public override void Add(TKeyBase key, TValueBase value) => referenceDictionary.Add((TKey)key, (TValue)value);

	/// <inheritdoc/>
	public override AccessPair<TKey, TValue, TKeyBase, TValueBase> AddNew() => new(referenceDictionary.AddNew());

	/// <inheritdoc/>
	public override TKeyBase GetKey(int index) => referenceDictionary.GetKey(index);

	/// <inheritdoc/>
	public override void SetKey(int index, TKeyBase newKey) => referenceDictionary.SetKey(index, (TKey)newKey);

	/// <inheritdoc/>
	public override TValueBase GetValue(int index) => referenceDictionary.GetValue(index);

	/// <inheritdoc/>
	public override void SetValue(int index, TValueBase newValue) => referenceDictionary.SetValue(index, (TValue)newValue);

	public override AccessPair<TKey, TValue, TKeyBase, TValueBase> GetPair(int index) => new(referenceDictionary.GetPair(index));

	/// <inheritdoc/>
	public override void RemoveAt(int index) => referenceDictionary.RemoveAt(index);

	/// <inheritdoc/>
	public override void Clear() => referenceDictionary.Clear();

	public override bool TryGetSinglePairForKey(TKeyBase key, [NotNullWhen(true)] out AccessPairBase<TKeyBase, TValueBase>? pair)
	{
		ArgumentNullException.ThrowIfNull(key);

		int hash = key.GetHashCode();
		bool found = false;
		pair = null;
		for (int i = Count - 1; i > -1; i--)
		{
			AccessPairBase<TKey, TValue> p = referenceDictionary.GetPair(i);
			if (p.Key.GetHashCode() == hash && key.Equals(p.Key))
			{
				if (found)
				{
					// Multiple entries found
					pair = null;
					return false;
				}
				else
				{
					found = true;
					pair = new AccessPair<TKey, TValue, TKeyBase, TValueBase>(p);
				}
			}
		}
		return found;
	}

	public override bool TryGetSinglePairForValue(TValueBase value, [NotNullWhen(true)] out AccessPairBase<TKeyBase, TValueBase>? pair)
	{
		ArgumentNullException.ThrowIfNull(value);

		int hash = value.GetHashCode();
		bool found = false;
		pair = null;
		for (int i = Count - 1; i > -1; i--)
		{
			AccessPairBase<TKey, TValue> p = referenceDictionary.GetPair(i);
			if (p.Value.GetHashCode() == hash && value.Equals(p.Value))
			{
				if (found)
				{
					// Multiple entries found
					pair = null;
					return false;
				}
				else
				{
					found = true;
					pair = new AccessPair<TKey, TValue, TKeyBase, TValueBase>(p);
				}
			}
		}
		return found;
	}

	/// <inheritdoc/>
	public override IEnumerator<AccessPair<TKey, TValue, TKeyBase, TValueBase>> GetEnumerator()
	{
		for (int i = 0; i < Count; i++)
		{
			yield return GetPair(i);
		}
	}
}

```

`Source/AssetRipper.Assets/Generics/AccessDictionaryBase.cs`:

```cs
using System.Collections;

namespace AssetRipper.Assets.Generics;

/// <summary>
/// Access the contents of a dictionary
/// </summary>
/// <typeparam name="TKey">The exposed key type, such as an interface, base type, or primitive type</typeparam>
/// <typeparam name="TValue">The exposed value type, such as an interface, base type, or primitive type</typeparam>
public abstract class AccessDictionaryBase<TKey, TValue> : IReadOnlyCollection<AccessPairBase<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>
	where TKey : notnull
	where TValue : notnull
{
	/// <summary>
	/// The capacity of the dictionary 
	/// </summary>
	public abstract int Capacity { get; set; }

	/// <summary>
	/// The number of pairs in the dictionary
	/// </summary>
	public abstract int Count { get; }

	/// <summary>
	/// The keys in the dictionary
	/// </summary>
	public IEnumerable<TKey> Keys => keyEnumerable ??= new KeyEnumerable(this);
	private KeyEnumerable? keyEnumerable;

	/// <summary>
	/// The values in the dictionary
	/// </summary>
	public IEnumerable<TValue> Values => valueEnumerable ??= new ValueEnumerable(this);
	private ValueEnumerable? valueEnumerable;

	/// <summary>
	/// Add a pair to the dictionary
	/// </summary>
	/// <remarks>
	/// This method is not necessarily type safe. 
	/// It could throw exceptions if used improperly.
	/// </remarks>
	/// <param name="key">The key to be added</param>
	/// <param name="value">The value to be added</param>
	public abstract void Add(TKey key, TValue value);

	/// <summary>
	/// Add a new pair to the dictionary
	/// </summary>
	public abstract AccessPairBase<TKey, TValue> AddNew();

	public bool ContainsKey(TKey key) => Keys.Contains(key);

	/// <summary>
	/// Get a key in the dictionary
	/// </summary>
	/// <param name="index">The index to access</param>
	/// <returns>The key at the specified index</returns>
	public abstract TKey GetKey(int index);

	/// <summary>
	/// Get a value in the dictionary
	/// </summary>
	/// <param name="index">The index to access</param>
	/// <returns>The value at the specified index</returns>
	public abstract TValue GetValue(int index);

	/// <summary>
	/// Get a pair in the dictionary
	/// </summary>
	/// <param name="index">The index to access</param>
	/// <returns>The pair at the specified index</returns>
	public abstract AccessPairBase<TKey, TValue> GetPair(int index);

	/// <summary>
	/// Set a key in the dictionary
	/// </summary>
	/// <remarks>
	/// This method is not necessarily type safe. 
	/// It could throw exceptions if used improperly.
	/// </remarks>
	/// <param name="index">The index to access</param>
	/// <param name="newKey">The new key to be assigned</param>
	public abstract void SetKey(int index, TKey newKey);

	/// <summary>
	/// Set a value in the dictionary
	/// </summary>
	/// <remarks>
	/// This method is not necessarily type safe. 
	/// It could throw exceptions if used improperly.
	/// </remarks>
	/// <param name="index">The index to access</param>
	/// <param name="newValue">The new value to be assigned</param>
	public abstract void SetValue(int index, TValue newValue);

	/// <inheritdoc/>
	public abstract void RemoveAt(int index);

	/// <inheritdoc/>
	public void RemoveAt(Index index)
	{
		RemoveAt(index.GetOffset(Count));
	}

	/// <inheritdoc/>
	public abstract void Clear();

	public AccessPairBase<TKey, TValue> GetSinglePairForKey(TKey key)
	{
		if (TryGetSinglePairForKey(key, out AccessPairBase<TKey, TValue>? pair))
		{
			return pair;
		}
		else
		{
			throw new KeyNotFoundException($"Key not found: {key}");
		}
	}

	public abstract bool TryGetSinglePairForKey(TKey key, [NotNullWhen(true)] out AccessPairBase<TKey, TValue>? pair);

	public abstract bool TryGetSinglePairForValue(TValue value, [NotNullWhen(true)] out AccessPairBase<TKey, TValue>? pair);

	/// <summary>
	/// Access a value in the dictionary
	/// </summary>
	/// <remarks>
	/// The get method is type safe.
	/// The set method is not necessarily type safe
	/// and could throw exceptions if used improperly.
	/// Both will throw if the key isn't unique.
	/// </remarks>
	public TValue this[TKey key]
	{
		get => GetSinglePairForKey(key).Value;
		set
		{
			if (TryGetSinglePairForKey(key, out AccessPairBase<TKey, TValue>? pair))
			{
				pair.Value = value;
			}
			else
			{
				Add(key, value);
			}
		}
	}

	public bool TryGetKey(TValue value, [NotNullWhen(true)] out TKey? key)
	{
		if (TryGetSinglePairForValue(value, out AccessPairBase<TKey, TValue>? pair))
		{
			key = pair.Key;
			return key is not null;
		}
		else
		{
			key = default;
			return false;
		}
	}

	public TKey? TryGetKey(TValue value)
	{
		TryGetKey(value, out TKey? key);
		return key;
	}

	public bool TryGetValue(TKey key, [NotNullWhen(true)] out TValue? value)
	{
		if (TryGetSinglePairForKey(key, out AccessPairBase<TKey, TValue>? pair))
		{
			value = pair.Value;
			return value is not null;
		}
		else
		{
			value = default;
			return false;
		}
	}

	public TValue? TryGetValue(TKey key)
	{
		TryGetValue(key, out TValue? value);
		return value;
	}

	/// <inheritdoc/>
	public abstract IEnumerator<AccessPairBase<TKey, TValue>> GetEnumerator();

	/// <inheritdoc/>
	IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

	public override string ToString()
	{
		return $"{nameof(Count)} = {Count}";
	}

	IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
	{
		IEnumerator<AccessPairBase<TKey, TValue>> enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			AccessPairBase<TKey, TValue> pair = enumerator.Current;
			yield return new KeyValuePair<TKey, TValue>(pair.Key, pair.Value);
		}
	}

	public bool TryAdd(TKey key, TValue value)
	{
		if (ContainsKey(key))
		{
			return false;
		}

		Add(key, value);
		return true;
	}

	private class KeyEnumerable : IEnumerable<TKey>
	{
		private readonly AccessDictionaryBase<TKey, TValue> dictionary;

		public KeyEnumerable(AccessDictionaryBase<TKey, TValue> dictionary)
		{
			this.dictionary = dictionary;
		}

		public IEnumerator<TKey> GetEnumerator()
		{
			for (int i = 0; i < dictionary.Count; i++)
			{
				yield return dictionary.GetKey(i);
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	private class ValueEnumerable : IEnumerable<TValue>
	{
		private readonly AccessDictionaryBase<TKey, TValue> dictionary;

		public ValueEnumerable(AccessDictionaryBase<TKey, TValue> dictionary)
		{
			this.dictionary = dictionary;
		}

		public IEnumerator<TValue> GetEnumerator()
		{
			for (int i = 0; i < dictionary.Count; i++)
			{
				yield return dictionary.GetValue(i);
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
}

```

`Source/AssetRipper.Assets/Generics/AccessList.cs`:

```cs
namespace AssetRipper.Assets.Generics;

public sealed class AccessList<T, TBase> : AccessListBase<TBase>
	where TBase : notnull
	where T : notnull, TBase, new()
{
	private readonly AssetList<T> referenceList;

	public AccessList(AssetList<T> referenceList)
	{
		this.referenceList = referenceList;
	}

	/// <inheritdoc/>
	public override int Count => referenceList.Count;

	/// <inheritdoc/>
	public override int Capacity
	{
		get => referenceList.Capacity;
		set => referenceList.Capacity = value;
	}

	/// <inheritdoc/>
	public override void Add(TBase item) => referenceList.Add((T)item);

	/// <inheritdoc/>
	public override TBase AddNew() => referenceList.AddNew();

	/// <inheritdoc/>
	public override int IndexOf(TBase item) => referenceList.IndexOf((T)item);

	/// <inheritdoc/>
	public override void Insert(int index, TBase item) => referenceList.Insert(index, (T)item);

	/// <inheritdoc/>
	public override void RemoveAt(int index) => referenceList.RemoveAt(index);

	/// <inheritdoc/>
	public override void Clear() => referenceList.Clear();

	/// <inheritdoc/>
	public override bool Contains(TBase item) => referenceList.Contains((T)item);

	/// <inheritdoc/>
	public override void CopyTo(TBase[] array, int arrayIndex)
	{
		ArgumentNullException.ThrowIfNull(array);

		if (arrayIndex < 0 || arrayIndex > array.Length - Count)
		{
			throw new ArgumentOutOfRangeException(nameof(arrayIndex), arrayIndex, null);
		}

		for (int i = 0; i < Count; i++)
		{
			array[i + arrayIndex] = this[i];
		}
	}

	public override int EnsureCapacity(int capacity) => referenceList.EnsureCapacity(capacity);

	/// <inheritdoc/>
	public override bool Remove(TBase item) => referenceList.Remove((T)item);

	/// <inheritdoc/>
	public override TBase this[int index]
	{
		get => referenceList[index];
		set => referenceList[index] = (T)value;
	}
}

```

`Source/AssetRipper.Assets/Generics/AccessListBase.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using System.Collections;
using System.Diagnostics;

namespace AssetRipper.Assets.Generics;

public abstract class AccessListBase<T> : IList<T>, IReadOnlyList<T>
	where T : notnull
{
	/// <inheritdoc/>
	public abstract T this[int index] { get; set; }

	/// <inheritdoc/>
	public abstract int Count { get; }

	/// <summary>
	/// The capacity of the list 
	/// </summary>
	public abstract int Capacity { get; set; }

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	bool ICollection<T>.IsReadOnly => false;

	/// <inheritdoc/>
	public abstract void Add(T item);

	/// <summary>
	/// Add a new element to the list
	/// </summary>
	public abstract T AddNew();

	/// <inheritdoc/>
	public abstract void Clear();

	/// <inheritdoc/>
	public abstract bool Contains(T item);

	/// <inheritdoc/>
	public abstract void CopyTo(T[] array, int arrayIndex);

	public abstract int EnsureCapacity(int capacity);

	/// <inheritdoc/>
	public abstract int IndexOf(T item);

	/// <inheritdoc/>
	public abstract void Insert(int index, T item);

	/// <inheritdoc/>
	public abstract bool Remove(T item);

	/// <inheritdoc/>
	public abstract void RemoveAt(int index);

	/// <inheritdoc cref="IList{T}.RemoveAt(int)"/>
	public void RemoveAt(Index index)
	{
		RemoveAt(index.GetOffset(Count));
	}

	/// <inheritdoc/>
	public IEnumerator<T> GetEnumerator()
	{
		for (int i = 0; i < Count; i++)
		{
			yield return this[i];
		}
	}

	/// <inheritdoc/>
	IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

	public override string ToString()
	{
		return $"{nameof(Count)} = {Count}";
	}
}
public static class AccessListBaseExtensions
{
	public static PPtrAccessList<TPPtr, TAsset> ToPPtrAccessList<TPPtr, TAsset>(this AccessListBase<TPPtr> list, AssetCollection collection)
		where TPPtr : IPPtr<TAsset>
		where TAsset : IUnityObjectBase
	{
		return new PPtrAccessList<TPPtr, TAsset>(list, collection);
	}
}

```

`Source/AssetRipper.Assets/Generics/AccessPair.cs`:

```cs
namespace AssetRipper.Assets.Generics;

public sealed class AccessPair<TKey, TValue, TKeyBase, TValueBase> : AccessPairBase<TKeyBase, TValueBase>
	where TKeyBase : notnull
	where TValueBase : notnull
	where TKey : notnull, TKeyBase, new()
	where TValue : notnull, TValueBase, new()
{
	private readonly AccessPairBase<TKey, TValue> referencePair;

	public AccessPair(AccessPairBase<TKey, TValue> pair)
	{
		referencePair = pair;
	}

	public override TKeyBase Key
	{
		get => referencePair.Key;
		set => referencePair.Key = (TKey)value;
	}

	public override TValueBase Value
	{
		get => referencePair.Value;
		set => referencePair.Value = (TValue)value;
	}
}

```

`Source/AssetRipper.Assets/Generics/AccessPairBase.cs`:

```cs
namespace AssetRipper.Assets.Generics;

public abstract class AccessPairBase<TKey, TValue> : IEquatable<AccessPairBase<TKey, TValue>>
	where TKey : notnull
	where TValue : notnull
{
	public abstract TKey Key { get; set; }
	public abstract TValue Value { get; set; }

	public sealed override bool Equals(object? obj)
	{
		return Equals(obj as AccessPairBase<TKey, TValue>);
	}

	public bool Equals(AccessPairBase<TKey, TValue>? other)
	{
		return other is not null &&
			EqualityComparer<TKey>.Default.Equals(Key, other.Key) &&
			EqualityComparer<TValue>.Default.Equals(Value, other.Value);
	}

	public sealed override int GetHashCode()
	{
		return HashCode.Combine(Key, Value);
	}

	public sealed override string ToString()
	{
		return $"{Key} : {Value}";
	}

	public static bool operator ==(AccessPairBase<TKey, TValue>? left, AccessPairBase<TKey, TValue>? right)
	{
		return EqualityComparer<AccessPairBase<TKey, TValue>>.Default.Equals(left, right);
	}

	public static bool operator !=(AccessPairBase<TKey, TValue>? left, AccessPairBase<TKey, TValue>? right)
	{
		return !(left == right);
	}

	public static implicit operator KeyValuePair<TKey, TValue>(AccessPairBase<TKey, TValue> pair) => new KeyValuePair<TKey, TValue>(pair.Key, pair.Value);

	public static implicit operator ValueTuple<TKey, TValue>(AccessPairBase<TKey, TValue> pair) => (pair.Key, pair.Value);

	public void Deconstruct(out TKey key, out TValue value)
	{
		key = Key;
		value = Value;
	}
}

```

`Source/AssetRipper.Assets/Generics/AssetDictionary.cs`:

```cs
namespace AssetRipper.Assets.Generics;

/// <summary>
/// A dictionary class supporting non-unique keys
/// </summary>
/// <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
/// <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
public sealed class AssetDictionary<TKey, TValue> : AccessDictionaryBase<TKey, TValue>
	where TKey : notnull, new()
	where TValue : notnull, new()
{
	private const int DefaultCapacity = 4;
	private AssetPair<TKey, TValue>[] pairs;
	private int count = 0;

	public AssetDictionary()
	{
		pairs = Array.Empty<AssetPair<TKey, TValue>>();
	}

	public AssetDictionary(int capacity)
	{
		pairs = capacity == 0 ? Array.Empty<AssetPair<TKey, TValue>>() : new AssetPair<TKey, TValue>[capacity];
	}

	/// <inheritdoc/>
	public override int Count => count;

	/// <inheritdoc/>
	public override int Capacity
	{
		get => pairs.Length;
		set
		{
			ArgumentOutOfRangeException.ThrowIfLessThan(value, count);

			if (value != pairs.Length)
			{
				if (value > 0)
				{
					AssetPair<TKey, TValue>[] newPairs = new AssetPair<TKey, TValue>[value];
					if (count > 0)
					{
						Array.Copy(pairs, newPairs, count);
					}
					pairs = newPairs;
				}
				else
				{
					pairs = Array.Empty<AssetPair<TKey, TValue>>();
				}
			}
		}
	}

	/// <inheritdoc/>
	public override void Add(TKey key, TValue value)
	{
		AssetPair<TKey, TValue> pair = AddNew();
		pair.Key = key;
		pair.Value = value;
	}

	/// <inheritdoc/>
	private void Add(AssetPair<TKey, TValue> pair)
	{
		if (count == Capacity)
		{
			Grow(count + 1);
		}

		pairs[count] = pair;
		count++;
	}

	/// <inheritdoc/>
	public override AssetPair<TKey, TValue> AddNew()
	{
		AssetPair<TKey, TValue> pair = new();
		Add(pair);
		return pair;
	}

	/// <inheritdoc/>
	public override TKey GetKey(int index)
	{
		if ((uint)index >= (uint)count)
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}

		return pairs[index].Key;
	}

	/// <inheritdoc/>
	public override void SetKey(int index, TKey newKey)
	{
		if ((uint)index >= (uint)count)
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}

		pairs[index].Key = newKey;
	}

	/// <inheritdoc/>
	public override TValue GetValue(int index)
	{
		if (index < 0 || index >= count)
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}

		return pairs[index].Value;
	}

	/// <inheritdoc/>
	public override void SetValue(int index, TValue newValue)
	{
		if ((uint)index >= (uint)count)
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}

		pairs[index].Value = newValue;
	}

	public override AssetPair<TKey, TValue> GetPair(int index)
	{
		if ((uint)index >= (uint)count)
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}

		return pairs[index];
	}

	/// <inheritdoc/>
	public override void RemoveAt(int index)
	{
		if ((uint)index >= (uint)count)
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}

		count--;
		if (index < count)
		{
			Array.Copy(pairs, index + 1, pairs, index, count - index);
		}
#pragma warning disable CS8625 // Cannot convert null literal to non-nullable reference type.
		pairs[count] = default;
#pragma warning restore CS8625 // Cannot convert null literal to non-nullable reference type.
	}

	/// <inheritdoc/>
	public override void Clear()
	{
		if (count > 0)
		{
			Array.Clear(pairs, 0, count); // Clear the elements so that the gc can reclaim the references.
		}
		count = 0;
	}

	public override bool TryGetSinglePairForKey(TKey key, [NotNullWhen(true)] out AccessPairBase<TKey, TValue>? pair)
	{
		ArgumentNullException.ThrowIfNull(key);

		int hash = key.GetHashCode();
		bool found = false;
		pair = null;
		for (int i = Count - 1; i > -1; i--)
		{
			AssetPair<TKey, TValue> p = pairs[i];
			if (p.Key.GetHashCode() == hash && key.Equals(p.Key))
			{
				if (found)
				{
					// We found more than one matching key
					return false;
				}
				else
				{
					found = true;
					pair = p;
				}
			}
		}
		return found;
	}

	public override bool TryGetSinglePairForValue(TValue value, [NotNullWhen(true)] out AccessPairBase<TKey, TValue>? pair)
	{
		ArgumentNullException.ThrowIfNull(value);

		int hash = value.GetHashCode();
		bool found = false;
		pair = null;
		for (int i = Count - 1; i > -1; i--)
		{
			AssetPair<TKey, TValue> p = pairs[i];
			if (p.Value.GetHashCode() == hash && value.Equals(p.Value))
			{
				if (found)
				{
					// We found more than one matching value
					return false;
				}
				else
				{
					found = true;
					pair = p;
				}
			}
		}
		return found;
	}

	/// <summary>
	/// Ensures that the capacity of this list is at least the specified <paramref name="capacity"/>.
	/// If the current capacity of the list is less than specified <paramref name="capacity"/>,
	/// the capacity is increased by continuously twice current capacity until it is at least the specified <paramref name="capacity"/>.
	/// </summary>
	/// <param name="capacity">The minimum capacity to ensure.</param>
	/// <returns>The new capacity of this list.</returns>
	public int EnsureCapacity(int capacity)
	{
		ArgumentOutOfRangeException.ThrowIfNegative(capacity);
		if (pairs.Length < capacity)
		{
			Grow(capacity);
		}

		return pairs.Length;
	}

	private void Grow(int capacity)
	{
		long newcapacity = pairs.Length == 0 ? DefaultCapacity : 2L * pairs.Length;

		// Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.
		// Note that this check works even when _items.Length overflowed thanks to the (uint) cast
		if (newcapacity > Array.MaxLength)
		{
			newcapacity = Array.MaxLength;
		}

		// If the computed capacity is still less than specified, set to the original argument.
		// Capacities exceeding Array.MaxLength will be surfaced as OutOfMemoryException by Array.Resize.
		if (newcapacity < capacity)
		{
			newcapacity = capacity;
		}

		Capacity = (int)newcapacity;
	}

	/// <inheritdoc/>
	public override IEnumerator<AssetPair<TKey, TValue>> GetEnumerator()
	{
		for (int i = 0; i < Count; i++)
		{
			yield return pairs[i];
		}
	}
}

```

`Source/AssetRipper.Assets/Generics/AssetList.cs`:

```cs
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace AssetRipper.Assets.Generics;

public sealed class AssetList<T> : AccessListBase<T>
	where T : notnull, new()
{
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private const int DefaultCapacity = 4;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private int count = 0;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private T[] items;

	public AssetList()
	{
		items = [];
	}

	public AssetList(int capacity)
	{
		items = capacity == 0 ? [] : new T[capacity];
	}

	/// <inheritdoc/>
	public override int Count => count;

	/// <inheritdoc/>
	public override int Capacity
	{
		get => items.Length;
		set
		{
			ArgumentOutOfRangeException.ThrowIfLessThan(value, count);

			if (value != items.Length)
			{
				if (value > 0)
				{
					T[] newElements = new T[value];
					if (count > 0)
					{
						Array.Copy(items, newElements, count);
					}
					items = newElements;
				}
				else
				{
					items = [];
				}
			}
		}
	}

	/// <inheritdoc/>
	public override T this[int index]
	{
		get
		{
			if ((uint)index >= (uint)count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			return items[index];
		}
		set
		{
			ThrowIfElementsNotImmutable();

			if ((uint)index >= (uint)count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			items[index] = value;
		}
	}

	/// <inheritdoc/>
	public override void Add(T item)
	{
		ThrowIfElementsNotImmutable();
		AddInternal(item);
	}

	private void AddInternal(T item)
	{
		if (count == Capacity)
		{
			Grow(count + 1);
		}

		items[count] = item;
		count++;
	}

	/// <inheritdoc/>
	public override T AddNew()
	{
		T newItem = new();
		AddInternal(newItem);
		return newItem;
	}

	public void AddRange(IEnumerable<T> enumerable)
	{
		ThrowIfElementsNotImmutable();
		if (enumerable is IReadOnlyCollection<T> collection)
		{
			EnsureCapacity(count + collection.Count);
			switch (collection)
			{
				case T[] array:
					array.AsSpan().CopyTo(items.AsSpan(count, array.Length));
					count += array.Length;
					break;
				case IReadOnlyList<T> list:
					for (int i = 0; i < list.Count; i++)
					{
						items[count + i] = list[i];
					}
					count += list.Count;
					break;
				default:
					foreach (T item in enumerable)
					{
						items[count] = item;
						count++;
					}
					break;
			}
		}
		else
		{
			foreach (T item in enumerable)
			{
				AddInternal(item);
			}
		}
	}

	/// <inheritdoc/>
	public override void Clear()
	{
		if (count > 0)
		{
			Array.Clear(items, 0, count); // Clear the elements so that the gc can reclaim the references.
		}
		count = 0;
	}

	/// <inheritdoc/>
	public override bool Contains(T item) => IndexOf(item) >= 0;

	/// <inheritdoc/>
	public override void CopyTo(T[] array, int arrayIndex)
	{
		ArgumentNullException.ThrowIfNull(array);

		if (arrayIndex < 0 || arrayIndex > array.Length - count)
		{
			throw new ArgumentOutOfRangeException(nameof(arrayIndex), arrayIndex, null);
		}

		Array.Copy(items, 0, array, arrayIndex, count);
	}

	public void CopyTo(Span<T> destination)
	{
		new ReadOnlySpan<T>(items, 0, count).CopyTo(destination);
	}

	/// <summary>
	/// Get a span for this list.
	/// </summary>
	/// <remarks>
	/// <typeparamref name="T"/> must be blittable.
	/// </remarks>
	/// <returns>A span for the underlying array, with length equal to <see cref="Count"/>.</returns>
	public Span<T> GetSpan()
	{
		if (!RuntimeHelpers.IsReferenceOrContainsReferences<T>())
		{
			return new(items, 0, count);
		}
		else
		{
			throw new NotSupportedException("Type must be blittable.");
		}
	}

	/// <inheritdoc/>
	public override int IndexOf(T item) => Array.IndexOf(items, item, 0, count);

	/// <inheritdoc/>
	public override void Insert(int index, T item)
	{
		ThrowIfElementsNotImmutable();

		// Note that insertions at the end are legal.
		if ((uint)index > (uint)count)
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}

		if (count == items.Length)
		{
			Grow(count + 1);
		}

		if (index < count)
		{
			Array.Copy(items, index, items, index + 1, count - index);
		}

		items[index] = item;
		count++;
	}

	/// <inheritdoc/>
	public override bool Remove(T item)
	{
		int index = IndexOf(item);
		if (index >= 0)
		{
			RemoveAt(index);
			return true;
		}
		return false;
	}

	/// <inheritdoc/>
	public override void RemoveAt(int index)
	{
		if ((uint)index >= (uint)count)
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}

		count--;
		if (index < count)
		{
			Array.Copy(items, index + 1, items, index, count - index);
		}
		items[count] = default!;
	}

	/// <summary>
	/// Ensures that the capacity of this list is at least the specified <paramref name="capacity"/>.
	/// If the current capacity of the list is less than specified <paramref name="capacity"/>,
	/// the capacity is increased by continuously twice current capacity until it is at least the specified <paramref name="capacity"/>.
	/// </summary>
	/// <param name="capacity">The minimum capacity to ensure.</param>
	/// <returns>The new capacity of this list.</returns>
	public override int EnsureCapacity(int capacity)
	{
		ArgumentOutOfRangeException.ThrowIfNegative(capacity);
		if (items.Length < capacity)
		{
			Grow(capacity);
		}

		return items.Length;
	}

	private void Grow(int capacity)
	{
		long newcapacity = items.Length == 0 ? DefaultCapacity : 2L * items.Length;

		// Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.
		// Note that this check works even when _items.Length overflowed thanks to the (uint) cast
		if (newcapacity > Array.MaxLength)
		{
			newcapacity = Array.MaxLength;
		}

		// If the computed capacity is still less than specified, set to the original argument.
		// Capacities exceeding Array.MaxLength will be surfaced as OutOfMemoryException by Array.Resize.
		if (newcapacity < capacity)
		{
			newcapacity = capacity;
		}

		Capacity = (int)newcapacity;
	}

	private static void ThrowIfElementsNotImmutable()
	{
		if (!typeof(T).IsValueType && typeof(T) != typeof(string) && typeof(T) != typeof(Utf8String))
		{
			throw new NotSupportedException($"Only immutable elements can be used in {nameof(Add)}, {nameof(Insert)}, and the setter for this[int].");
		}
	}
}

```

`Source/AssetRipper.Assets/Generics/AssetPair.cs`:

```cs
namespace AssetRipper.Assets.Generics;

public sealed class AssetPair<TKey, TValue> : AccessPairBase<TKey, TValue>, IEquatable<AssetPair<TKey, TValue>>
	where TKey : notnull, new()
	where TValue : notnull, new()
{
	private TKey key;
	private TValue value;

	public AssetPair()
	{
		key = new();
		value = new();
	}

	public override TKey Key
	{
		get => key;
		set
		{
			ThrowIfKeyNotImmutable();
			key = value;
		}
	}

	public override TValue Value
	{
		get => value;
		set
		{
			ThrowIfValueNotImmutable();
			this.value = value;
		}
	}

	private static void ThrowIfKeyNotImmutable()
	{
		if (!typeof(TKey).IsValueType && typeof(TKey) != typeof(string) && typeof(TKey) != typeof(Utf8String))
		{
			throw new NotSupportedException($"Only immutable values can be used in the setter for {nameof(Key)}.");
		}
	}

	private static void ThrowIfValueNotImmutable()
	{
		if (!typeof(TValue).IsValueType && typeof(TValue) != typeof(string) && typeof(TValue) != typeof(Utf8String))
		{
			throw new NotSupportedException($"Only immutable values can be used in the setter for {nameof(Value)}.");
		}
	}

	bool IEquatable<AssetPair<TKey, TValue>>.Equals(AssetPair<TKey, TValue>? other) => Equals(other);

	public static implicit operator KeyValuePair<TKey, TValue>(AssetPair<TKey, TValue> pair)
	{
		return new KeyValuePair<TKey, TValue>(pair.Key, pair.Value);
	}
}

```

`Source/AssetRipper.Assets/Generics/PPtrAccessList.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using System.Collections;
using System.Diagnostics;

namespace AssetRipper.Assets.Generics;

[DebuggerDisplay($"{{{nameof(GetDebuggerDisplay)}(),nq}}")]
public readonly struct PPtrAccessList<TPPtr, TTarget> : IReadOnlyList<TTarget?>
	where TPPtr : IPPtr<TTarget>
	where TTarget : IUnityObjectBase
{
	public static PPtrAccessList<TPPtr, TTarget> Empty => new PPtrAccessList<TPPtr, TTarget>(Array.Empty<TPPtr>(), EmptyBundle.Instance.Collection);

	private readonly IReadOnlyList<TPPtr> list;
	private readonly AssetCollection file;

	public PPtrAccessList(IReadOnlyList<TPPtr> list, AssetCollection file)
	{
		this.list = list;
		this.file = file;
	}

	public PPtrAccessList(IReadOnlyList<TPPtr> list, IUnityObjectBase asset) : this(list, asset.Collection)
	{
	}

	public TTarget? this[int index]
	{
		get
		{
			list[index].TryGetAsset(file, out TTarget? result);
			return result;
		}
		set
		{
			list[index].SetAsset(file, value);
		}
	}

	public TPPtr AddNew()
	{
		return GetAccessList().AddNew();
	}

	public void Add(TTarget? item)
	{
		GetAccessList().AddNew().SetAsset(file, item);
	}

	public void AddRange(IEnumerable<TTarget?> items)
	{
		AccessListBase<TPPtr> accessList = GetAccessList();
		foreach (TTarget? value in items)
		{
			accessList.AddNew().SetAsset(file, value);
		}
	}

	public void AddRange<TPPtrSource, TTargetSource>(PPtrAccessList<TPPtrSource, TTargetSource> items)
		where TPPtrSource : IPPtr<TTargetSource>
		where TTargetSource : TTarget
	{
		AccessListBase<TPPtr> accessList = GetAccessList();
		foreach (TTargetSource? value in items)
		{
			accessList.AddNew().SetAsset(file, value);
		}
	}

	private AccessListBase<TPPtr> GetAccessList()
	{
		return list is AccessListBase<TPPtr> accessList
			? accessList
			: throw new NotSupportedException();
	}

	public int Count => list.Count;

	public IEnumerator<TTarget?> GetEnumerator()
	{
		for (int i = 0; i < Count; i++)
		{
			yield return this[i];
		}
	}

	IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

	public IEnumerable<TTarget> WhereNotNull()
	{
		return Count == 0 ? Enumerable.Empty<TTarget>() : InternalNotNull(this);

		static IEnumerable<TTarget> InternalNotNull(PPtrAccessList<TPPtr, TTarget> list)
		{
			for (int i = 0; i < list.Count; i++)
			{
				TTarget? asset = list[i];
				if (asset is not null)
				{
					yield return asset;
				}
			}
		}
	}

	private string GetDebuggerDisplay()
	{
		return $"{nameof(Count)} = {Count}";
	}

	private sealed class EmptyBundle : Bundle
	{
		public static EmptyBundle Instance { get; } = new();
		public AssetCollection Collection { get; }
		public override string Name => nameof(EmptyBundle);
		private EmptyBundle()
		{
			Collection = new EmptyAssetCollection(this);
		}

		protected override bool IsCompatibleBundle(Bundle bundle) => false;
		protected override bool IsCompatibleCollection(AssetCollection collection) => collection is EmptyAssetCollection;

		private sealed class EmptyAssetCollection : AssetCollection
		{
			public EmptyAssetCollection(Bundle bundle) : base(bundle)
			{
			}

			protected override bool IsCompatibleDependency(AssetCollection dependency) => false;
		}
	}
}

```

`Source/AssetRipper.Assets/Generics/ReadOnlyArraySegment.cs`:

```cs
using System.Collections;

namespace AssetRipper.Assets.Generics;

public readonly struct ReadOnlyArraySegment<T> : IReadOnlyList<T>
{
	// ReadOnlyArraySegment<T> doesn't implement IEquatable<T>, even though it provides a strongly-typed
	// Equals(T), as that results in different comparison semantics than comparing item-by-item
	// the elements returned from its IEnumerable<T> implementation.  This then is a breaking change
	// for usage like that in xunit's Assert.Equal, which will prioritize using an instance's IEquatable<T>
	// over its IEnumerable<T>.

	public static ReadOnlyArraySegment<T> Empty { get; } = new ReadOnlyArraySegment<T>(Array.Empty<T>());

	private readonly T[]? _array;
	private readonly int _offset;

	public ReadOnlyArraySegment(T[] array)
	{
		ArgumentNullException.ThrowIfNull(array, nameof(array));

		_array = array;
		_offset = 0;
		Count = array.Length;
	}

	public ReadOnlyArraySegment(T[] array, int offset, int count)
	{
		ArgumentNullException.ThrowIfNull(array, nameof(array));
		ValidateOffsetAndCount(array, offset, count);

		_array = array;
		_offset = offset;
		Count = count;
	}

	public int Count { get; }

	public T this[int index]
	{
		get
		{
			ThrowInvalidOperationIfDefault();
			ThrowIfIndexNegativeOrGreaterEqualThanCount(index);

			return _array[_offset + index];
		}
	}

	public ArraySegment<T>.Enumerator GetEnumerator()
	{
		ThrowInvalidOperationIfDefault();
		return new ArraySegment<T>(_array, _offset, Count).GetEnumerator();
	}

	public override int GetHashCode()
	{
		return _array is null ? 0 : HashCode.Combine(_offset, Count, _array);
	}

	public override bool Equals([NotNullWhen(true)] object? obj)
	{
		return obj is ReadOnlyArraySegment<T> other && Equals(other);
	}

	public bool Equals(ReadOnlyArraySegment<T> obj)
	{
		return obj._array == _array && obj._offset == _offset && obj.Count == Count;
	}

	public ReadOnlyArraySegment<T> Slice(int index)
	{
		ThrowInvalidOperationIfDefault();
		ThrowIfIndexNegativeOrGreaterThanCount(index);

		return new ReadOnlyArraySegment<T>(_array, _offset + index, Count - index);
	}

	public ReadOnlyArraySegment<T> Slice(int index, int count)
	{
		ThrowInvalidOperationIfDefault();

		if ((uint)index > (uint)Count || (uint)count > (uint)(Count - index))
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}

		return new ReadOnlyArraySegment<T>(_array, _offset + index, count);
	}

	public T[] ToArray()
	{
		if (Count == 0)
		{
			return Array.Empty<T>();
		}

		ThrowInvalidOperationIfDefault();

		T[] array = new T[Count];
		Array.Copy(_array, _offset, array, 0, Count);
		return array;
	}

	public static bool operator ==(ReadOnlyArraySegment<T> a, ReadOnlyArraySegment<T> b) => a.Equals(b);
	public static bool operator !=(ReadOnlyArraySegment<T> a, ReadOnlyArraySegment<T> b) => !(a == b);

	public static implicit operator ReadOnlyArraySegment<T>(T[]? array)
	{
		return array is not null ? new ReadOnlyArraySegment<T>(array) : default;
	}

	public static implicit operator ReadOnlyArraySegment<T>(ArraySegment<T> segment)
	{
		return segment.Array is not null ? new ReadOnlyArraySegment<T>(segment.Array, segment.Offset, segment.Count) : default;
	}

	public static implicit operator ReadOnlySpan<T>(ReadOnlyArraySegment<T> segment)
	{
		return new ReadOnlySpan<T>(segment._array, segment._offset, segment.Count);
	}

	IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();
	IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

	private static void ValidateOffsetAndCount(T[] array, int offset, int count)
	{
		if ((uint)offset > (uint)array.Length || (uint)count > (uint)(array.Length - offset))
		{
			throw new ArgumentException("Invalid offset and count.");
		}
	}

	private void ThrowIfIndexNegativeOrGreaterThanCount(int index)
	{
		if ((uint)index > (uint)Count)
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}
	}

	private void ThrowIfIndexNegativeOrGreaterEqualThanCount(int index)
	{
		if (index < 0 || index >= Count)
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}
	}

	[MemberNotNull(nameof(_array))]
	private void ThrowInvalidOperationIfDefault()
	{
		if (_array == null)
		{
			throw new InvalidOperationException("Array was null.");
		}
	}
}

```

`Source/AssetRipper.Assets/IDeepCloneable.cs`:

```cs
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.Assets;

public interface IDeepCloneable
{
	/// <summary>
	/// Deep clones this object.
	/// </summary>
	/// <param name="converter">The converter to use for cloning <see cref="PPtr"/>s.</param>
	/// <returns>The cloned object.</returns>
	IUnityAssetBase DeepClone(PPtrConverter converter);
}

```

`Source/AssetRipper.Assets/INamed.cs`:

```cs
namespace AssetRipper.Assets;

public interface INamed
{
	Utf8String Name { get; set; }
}

```

`Source/AssetRipper.Assets/IO/AssetFactoryBase.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.Assets.IO;

public abstract class AssetFactoryBase
{
	public abstract IUnityObjectBase? ReadAsset(AssetInfo assetInfo, ReadOnlyArraySegment<byte> assetData, SerializedType? assetType);
}

```

`Source/AssetRipper.Assets/IO/Writing/AssetWriter.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Endian;

namespace AssetRipper.Assets.IO.Writing;

public sealed class AssetWriter : EndianWriter
{
	public AssetWriter(Stream stream, AssetCollection assetCollection) : base(stream, assetCollection.EndianType, false)
	{
		AssetCollection = assetCollection;
	}

	public override void Write(string value)
	{
		throw new NotSupportedException();
	}

	public void WriteAssetArray<T>(T[] buffer) where T : IAssetWritable
	{
		Write(buffer.Length);

		for (int i = 0; i < buffer.Length; i++)
		{
			buffer[i].Write(this);
		}

		if (IsAlignArray)
		{
			AlignStream();
		}
	}

	public AssetCollection AssetCollection { get; }
}

```

`Source/AssetRipper.Assets/IO/Writing/IAssetWritable.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.Assets.IO.Writing;

public interface IAssetWritable
{
	void WriteEditor(AssetWriter writer);
	void WriteRelease(AssetWriter writer);
}
public static class AssetWritableExtensions
{
	public static void Write(this IAssetWritable asset, AssetWriter writer)
	{
		asset.Write(writer, writer.AssetCollection.Flags);
	}

	public static void Write(this IAssetWritable asset, AssetWriter writer, TransferInstructionFlags flags)
	{
		if (flags.IsRelease())
		{
			asset.WriteRelease(writer);
		}
		else
		{
			asset.WriteEditor(writer);
		}
	}
}

```

`Source/AssetRipper.Assets/IUnityAssetBase.cs`:

```cs
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.IO.Writing;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.Assets;

public interface IUnityAssetBase : IEndianSpanReadable, IAssetWritable
{
	int SerializedVersion { get; }
	/// <summary>
	/// <see cref="TransferMetaFlags.TransferUsingFlowMappingStyle"/>
	/// </summary>
	bool FlowMappedInYaml { get; }
	/// <summary>
	/// <see cref="TransferMetaFlags.IgnoreInMetaFiles"/>
	/// </summary>
	/// <param name="fieldName">The field's name, according to the original naming.</param>
	/// <returns>True if the field should not be emitted in yaml meta files.</returns>
	bool IgnoreFieldInMetaFiles(string fieldName);
	void CopyValues(IUnityAssetBase? source, PPtrConverter converter);
	void Reset();
	/// <summary>
	/// Walk this asset using original naming.
	/// </summary>
	/// <param name="walker">A walker for traversal.</param>
	void WalkEditor(AssetWalker walker);
	/// <summary>
	/// Walk this asset using original naming.
	/// </summary>
	/// <param name="walker">A walker for traversal.</param>
	void WalkRelease(AssetWalker walker);
	/// <summary>
	/// Walk this asset using standardized naming.
	/// </summary>
	/// <param name="walker">A walker for traversal.</param>
	void WalkStandard(AssetWalker walker);
	IEnumerable<(string, PPtr)> FetchDependencies();
	/// <summary>
	/// Compares this object to another object for deep value equality.
	/// </summary>
	/// <remarks>
	/// <paramref name="other"/> is expected to be not null and of the same type as this object.
	/// </remarks>
	/// <param name="other">The other object.</param>
	/// <param name="comparer">The <see cref="AssetEqualityComparer"/> to which any dependent comparisons are added.</param>
	/// <returns>Null if it could not be immediately determined</returns>
	bool? AddToEqualityComparer(IUnityAssetBase other, AssetEqualityComparer comparer);
}
public static class UnityAssetBaseExtensions
{
	public static void Read(this IUnityAssetBase asset, ref EndianSpanReader reader, TransferInstructionFlags flags)
	{
		if (flags.IsRelease())
		{
			asset.ReadRelease(ref reader);
		}
		else
		{
			asset.ReadEditor(ref reader);
		}
	}
}

```

`Source/AssetRipper.Assets/IUnityObjectBase.cs`:

```cs
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using AssetRipper.IO.Endian;

namespace AssetRipper.Assets;

public interface IUnityObjectBase : IUnityAssetBase
{
	/// <summary>
	/// The key information about the location of this asset.
	/// </summary>
	AssetInfo AssetInfo { get; }
	/// <summary>
	/// The native class ID number of this object.
	/// </summary>
	int ClassID { get; }
	/// <summary>
	/// The native class name of this object.
	/// </summary>
	string ClassName { get; }
	/// <summary>
	/// The <see cref="AssetCollection"/> this object belongs to.
	/// </summary>
	AssetCollection Collection { get; }
	/// <summary>
	/// The <see cref="AssetInfo.PathID"/> of this object within <see cref="Collection"/>.
	/// </summary>
	long PathID { get; }
	/// <summary>
	/// The original path of this object, if known.
	/// </summary>
	/// <remarks>
	/// The path is relative to the project root and may use forward or back slashes.
	/// This will never be the empty string.
	/// </remarks>
	string? OriginalPath { get; set; }
	/// <summary>
	/// The original directory of this object, if known.
	/// </summary>
	/// <remarks>
	/// The path is relative to the project root and may use forward or back slashes.
	/// This will never be the empty string.
	/// </remarks>
	string? OriginalDirectory { get; set; }
	/// <summary>
	/// The original file name of this object, if known.
	/// </summary>
	/// <remarks>
	/// This will never be the empty string.
	/// </remarks>
	string? OriginalName { get; set; }
	/// <summary>
	/// The original file extension of this object, if known.
	/// </summary>
	/// <remarks>
	/// This will never be the empty string.
	/// </remarks>
	string? OriginalExtension { get; set; }
	/// <summary>
	/// The path of this object, if chosen.
	/// </summary>
	/// <remarks>
	/// The path is relative to the project root and may use forward or back slashes.
	/// This will never be the empty string.
	/// </remarks>
	string? OverridePath { get; set; }
	/// <summary>
	/// The directory of this object, if chosen.
	/// </summary>
	/// <remarks>
	/// The path is relative to the project root and may use forward or back slashes.
	/// This will never be the empty string.
	/// </remarks>
	string? OverrideDirectory { get; set; }
	/// <summary>
	/// The file name of this object, if chosen.
	/// </summary>
	/// <remarks>
	/// This will never be the empty string.
	/// </remarks>
	string? OverrideName { get; set; }
	/// <summary>
	/// The file extension of this object, if chosen.
	/// </summary>
	/// <remarks>
	/// This will never be the empty string.
	/// </remarks>
	string? OverrideExtension { get; set; }
	/// <summary>
	/// The name of the asset bundle this object belongs to, if known.
	/// </summary>
	/// <remarks>
	/// This will never be the empty string.
	/// </remarks>
	string? AssetBundleName { get; set; }
	/// <summary>
	/// The primary asset that this object is associated with, if any.
	/// </summary>
	IUnityObjectBase? MainAsset { get; set; }

	/// <summary>
	/// Get the best directory for this object, relative to the project root.
	/// </summary>
	/// <remarks>
	/// In order of preference:<br/>
	/// 1. <see cref="OverrideDirectory"/><br/>
	/// 2. <see cref="OriginalDirectory"/><br/>
	/// 3. <see cref="ClassName"/>
	/// </remarks>
	/// <returns>A non-empty string.</returns>
	public sealed string GetBestDirectory()
	{
		if (OverrideDirectory is not null || OverrideName is not null)
		{
			return OverrideDirectory ?? "Assets";
		}
		else if (OriginalDirectory is not null || OriginalName is not null)
		{
			return OriginalDirectory ?? "Assets";
		}
		else
		{
			return "Assets/" + ClassName;
		}
	}

	/// <summary>
	/// Get the best name for this object.
	/// </summary>
	/// <remarks>
	/// In order of preference:<br/>
	/// 1. <see cref="OverrideName"/><br/>
	/// 2. <see cref="IHasNameString.NameString"/><br/>
	/// 3. <see cref="OriginalName"/><br/>
	/// 4. <see cref="ClassName"/><br/>
	/// <see cref="OriginalName"/> has secondary preference because file importers can create assets with a different name from the file.
	/// </remarks>
	/// <returns>A nonempty string.</returns>
	public sealed string GetBestName()
	{
		if (OverrideName is not null)
		{
			return OverrideName;
		}
		Utf8String? name = (this as INamed)?.Name;
		if (!Utf8String.IsNullOrEmpty(name))
		{
			return name;
		}
		else if (OriginalName is not null)
		{
			return OriginalName;
		}
		else
		{
			return ClassName;
		}
	}

	/// <summary>
	/// Get the best extension for this object, if one exists.
	/// </summary>
	/// <remarks>
	/// In order of preference:<br/>
	/// 1. <see cref="OverrideExtension"/><br/>
	/// 2. <see cref="OriginalExtension"/>
	/// </remarks>
	/// <returns>A nonempty string or null.</returns>
	public sealed string? GetBestExtension() => OverrideExtension ?? OriginalExtension;

	public sealed void CopyValues(IUnityObjectBase? source)
	{
		if (source is null)
		{
			Reset();
		}
		else
		{
			CopyValues(source, new PPtrConverter(source, this));
		}
	}
}
public static class UnityObjectBaseExtensions
{
	public static void Read(this IUnityObjectBase asset, ref EndianSpanReader reader) => asset.Read(ref reader, asset.Collection.Flags);
}

```

`Source/AssetRipper.Assets/Metadata/AssetInfo.cs`:

```cs
using AssetRipper.Assets.Collections;

namespace AssetRipper.Assets.Metadata;

public readonly record struct AssetInfo(AssetCollection Collection, long PathID, int ClassID)
{
}

```

`Source/AssetRipper.Assets/Metadata/IPPtr.cs`:

```cs
using AssetRipper.Assets.Collections;

namespace AssetRipper.Assets.Metadata;

public interface IPPtr : IUnityAssetBase
{
	/// <summary>
	/// Zero means the asset is located within the current file.
	/// </summary>
	int FileID { get; }
	/// <summary>
	/// It is sometimes sequential and sometimes more like a hash. Zero signifies a null reference.
	/// </summary>
	long PathID { get; }
}

public interface IPPtr<T> : IPPtr where T : IUnityObjectBase
{
	void SetAsset(AssetCollection collection, T? asset);
	bool TryGetAsset(AssetCollection collection, [NotNullWhen(true)] out T? asset);
}

```

`Source/AssetRipper.Assets/Metadata/NullPPtr.cs`:

```cs
namespace AssetRipper.Assets.Metadata;

public sealed class NullPPtr : UnityAssetBase, IPPtr
{
	public static NullPPtr Instance { get; } = new();
	public int FileID => 0;
	public long PathID => 0;

	private NullPPtr()
	{
	}
}

```

`Source/AssetRipper.Assets/Metadata/PPtr.cs`:

```cs
namespace AssetRipper.Assets.Metadata;

/// <summary>
/// A Unity pointer to any type of object.
/// </summary>
/// <param name="FileID">Zero means the asset is located within the current file.</param>
/// <param name="PathID">It is sometimes sequential and sometimes more like a hash. Zero signifies a null reference.</param>
public readonly record struct PPtr(int FileID, long PathID)
{
	public PPtr(long PathID) : this(0, PathID) { }

	public PPtr(IPPtr pptr) : this(pptr.FileID, pptr.PathID) { }

	/// <summary>
	/// PathID == 0
	/// </summary>
	public bool IsNull => PathID == 0;

	public static implicit operator PPtr<IUnityObjectBase>(PPtr pptr) => new PPtr<IUnityObjectBase>(pptr.FileID, pptr.PathID);
}

/// <summary>
/// A Unity pointer to a specific type of object.
/// </summary>
/// <typeparam name="T">The type of object this references.</typeparam>
/// <param name="FileID">Zero means the asset is located within the current file.</param>
/// <param name="PathID">It is sometimes sequential and sometimes more like a hash. Zero signifies a null reference.</param>
public readonly record struct PPtr<T>(int FileID, long PathID) where T : IUnityObjectBase
{
	public PPtr(long PathID) : this(0, PathID) { }

	public PPtr<TCast> Cast<TCast>() where TCast : IUnityObjectBase
	{
		return new PPtr<TCast>(FileID, PathID);
	}

	/// <summary>
	/// PathID == 0
	/// </summary>
	public bool IsNull => PathID == 0;

	public static implicit operator PPtr(PPtr<T> pptr) => new PPtr(pptr.FileID, pptr.PathID);
	public static explicit operator PPtr<T>(PPtr pptr) => new PPtr<T>(pptr.FileID, pptr.PathID);
	public static implicit operator PPtr<IUnityObjectBase>(PPtr<T> pptr) => new PPtr<IUnityObjectBase>(pptr.FileID, pptr.PathID);
	public static explicit operator PPtr<T>(PPtr<IUnityObjectBase> pptr) => new PPtr<T>(pptr.FileID, pptr.PathID);
}

```

`Source/AssetRipper.Assets/NullObject.cs`:

```cs
using AssetRipper.Assets.Metadata;

namespace AssetRipper.Assets;

/// <summary>
/// An object that, if referenced by a <see cref="PPtr"/>, returns null unless explicity searched for.
/// </summary>
public abstract class NullObject : UnityObjectBase
{
	protected NullObject(AssetInfo assetInfo) : base(assetInfo)
	{
	}
}

```

`Source/AssetRipper.Assets/StringPathExtensions.cs`:

```cs
namespace AssetRipper.Assets;

internal static class StringPathExtensions
{
	[return: NotNullIfNotNull(nameof(str))]
	public static string? RemovePeriod(this string? str)
	{
		return string.IsNullOrEmpty(str) || str[0] != '.' ? str : str.Substring(1);
	}

	public static string? NotEmpty(this string? str)
	{
		return string.IsNullOrEmpty(str) ? null : str;
	}
}

```

`Source/AssetRipper.Assets/Traversal/AssetWalker.cs`:

```cs
using AssetRipper.Assets.Metadata;

namespace AssetRipper.Assets.Traversal;

/// <summary>
/// Abstract base class for traversing objects that implement <see cref="IUnityAssetBase"/>.
/// </summary>
public abstract class AssetWalker
{
	/// <summary>
	/// Called when entering an asset node during traversal.
	/// </summary>
	/// <param name="asset">The asset being entered.</param>
	/// <returns>
	///   <c>true</c> to continue visiting the children of the asset node,
	///   <c>false</c> to skip visiting the children and not call the exit method.
	/// </returns>
	public virtual bool EnterAsset(IUnityAssetBase asset)
	{
		return true;
	}

	/// <summary>
	/// Called between two fields of an asset node during traversal.
	/// </summary>
	/// <param name="asset">The asset having its fields divided.</param>
	public virtual void DivideAsset(IUnityAssetBase asset)
	{
	}

	/// <summary>
	/// Called when exiting an asset node during traversal.
	/// </summary>
	/// <param name="asset">The asset being exited.</param>
	public virtual void ExitAsset(IUnityAssetBase asset)
	{
	}

	/// <summary>
	/// Called when entering a field node during traversal.
	/// </summary>
	/// <param name="name">The name of the field being entered.</param>
	/// <returns>
	///   <c>true</c> to continue visiting the children of the field node,
	///   <c>false</c> to skip visiting the children and not call the exit method.
	/// </returns>
	public virtual bool EnterField(IUnityAssetBase asset, string name)
	{
		return true;
	}

	/// <summary>
	/// Called when exiting a field node during traversal.
	/// </summary>
	/// <param name="name">The name of the field being exited.</param>
	public virtual void ExitField(IUnityAssetBase asset, string name)
	{
	}

	/// <summary>
	/// Called when entering a list node during traversal.
	/// </summary>
	/// <typeparam name="T">The type of the list elements.</typeparam>
	/// <param name="list">The list being entered.</param>
	/// <returns>
	///   <c>true</c> to continue visiting the children of the list node,
	///   <c>false</c> to skip visiting the children and not call the exit method.
	/// </returns>
	public virtual bool EnterList<T>(IReadOnlyList<T> list)
		where T : notnull
	{
		return true;
	}

	/// <summary>
	/// Called between two elements of a list node during traversal.
	/// </summary>
	/// <typeparam name="T">The type of the list elements being divided.</typeparam>
	/// <param name="list">The list having its elements divided.</param>
	public virtual void DivideList<T>(IReadOnlyList<T> list)
		where T : notnull
	{
	}

	/// <summary>
	/// Called when exiting a list node during traversal.
	/// </summary>
	/// <typeparam name="T">The type of the list elements.</typeparam>
	/// <param name="list">The list being exited.</param>
	public virtual void ExitList<T>(IReadOnlyList<T> list)
		where T : notnull
	{
	}

	/// <summary>
	/// Called when entering a dictionary node during traversal.
	/// </summary>
	/// <typeparam name="TKey">The type of dictionary keys.</typeparam>
	/// <typeparam name="TValue">The type of dictionary values.</typeparam>
	/// <param name="dictionary">The dictionary being entered.</param>
	/// <returns>
	///   <c>true</c> to continue visiting the children of the dictionary node,
	///   <c>false</c> to skip visiting the children and not call the exit method.
	/// </returns>
	public virtual bool EnterDictionary<TKey, TValue>(IReadOnlyCollection<KeyValuePair<TKey, TValue>> dictionary)
		where TKey : notnull
		where TValue : notnull
	{
		return true;
	}

	/// <summary>
	/// Called between two pairs of a dictionary node during traversal.
	/// </summary>
	/// <typeparam name="TKey">The type of dictionary keys.</typeparam>
	/// <typeparam name="TValue">The type of dictionary values.</typeparam>
	/// <param name="dictionary">The dictionary having its pairs divided.</param>
	public virtual void DivideDictionary<TKey, TValue>(IReadOnlyCollection<KeyValuePair<TKey, TValue>> dictionary)
		where TKey : notnull
		where TValue : notnull
	{
	}

	/// <summary>
	/// Called when exiting a dictionary node during traversal.
	/// </summary>
	/// <typeparam name="TKey">The type of dictionary keys.</typeparam>
	/// <typeparam name="TValue">The type of dictionary values.</typeparam>
	/// <param name="dictionary">The dictionary being exited.</param>
	public virtual void ExitDictionary<TKey, TValue>(IReadOnlyCollection<KeyValuePair<TKey, TValue>> dictionary)
		where TKey : notnull
		where TValue : notnull
	{
	}

	/// <summary>
	/// Called when entering a dictionary pair during traversal.
	/// </summary>
	/// <remarks>
	/// This calls <see cref="EnterPair{TKey, TValue}(KeyValuePair{TKey, TValue})"/> by default.
	/// </remarks>
	/// <typeparam name="TKey">The type of the key in the pair.</typeparam>
	/// <typeparam name="TValue">The type of the value in the pair.</typeparam>
	/// <param name="pair">The dictionary pair being entered.</param>
	/// <returns>
	///   <c>true</c> to continue visiting the key and value of the dictionary pair,
	///   <c>false</c> to skip visiting the children and not call the exit method.
	/// </returns>
	public virtual bool EnterDictionaryPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
		where TKey : notnull
		where TValue : notnull
	{
		return EnterPair(pair);
	}

	/// <summary>
	/// Called between the key and value of a dictionary pair during traversal.
	/// </summary>
	/// <remarks>
	/// This calls <see cref="DividePair{TKey, TValue}(KeyValuePair{TKey, TValue})"/> by default.
	/// </remarks>
	/// <typeparam name="TKey">The type of the key in the pair.</typeparam>
	/// <typeparam name="TValue">The type of the value in the pair.</typeparam>
	/// <param name="pair">The dictionary pair having its key and value divided.</param>
	public virtual void DivideDictionaryPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
		where TKey : notnull
		where TValue : notnull
	{
		DividePair(pair);
	}

	/// <summary>
	/// Called when exiting a dictionary pair during traversal.
	/// </summary>
	/// <remarks>
	/// This calls <see cref="ExitPair{TKey, TValue}(KeyValuePair{TKey, TValue})"/> by default.
	/// </remarks>
	/// <typeparam name="TKey">The type of the key in the pair.</typeparam>
	/// <typeparam name="TValue">The type of the value in the pair.</typeparam>
	/// <param name="pair">The dictionary pair being exited.</param>
	public virtual void ExitDictionaryPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
		where TKey : notnull
		where TValue : notnull
	{
		ExitPair(pair);
	}

	/// <summary>
	/// Called when entering a key-value pair node during traversal.
	/// </summary>
	/// <typeparam name="TKey">The type of the key in the pair.</typeparam>
	/// <typeparam name="TValue">The type of the value in the pair.</typeparam>
	/// <param name="pair">The key-value pair being entered.</param>
	/// <returns>
	///   <c>true</c> to continue visiting the children of the key-value pair node,
	///   <c>false</c> to skip visiting the children and not call the exit method.
	/// </returns>
	public virtual bool EnterPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
		where TKey : notnull
		where TValue : notnull
	{
		return true;
	}

	/// <summary>
	/// Called between the key and value of a key-value pair node during traversal.
	/// </summary>
	/// <typeparam name="TKey">The type of the key in the pair.</typeparam>
	/// <typeparam name="TValue">The type of the value in the pair.</typeparam>
	/// <param name="pair">The key-value pair having its key and value divided.</param>
	public virtual void DividePair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
		where TKey : notnull
		where TValue : notnull
	{
	}

	/// <summary>
	/// Called when exiting a key-value pair node during traversal.
	/// </summary>
	/// <typeparam name="TKey">The type of the key in the pair.</typeparam>
	/// <typeparam name="TValue">The type of the value in the pair.</typeparam>
	/// <param name="pair">The key-value pair being exited.</param>
	public virtual void ExitPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
		where TKey : notnull
		where TValue : notnull
	{
	}

	/// <summary>
	/// Visit a primitive leaf node.
	/// </summary>
	/// <remarks>
	/// byte[] is treated as a primitive.
	/// </remarks>
	/// <typeparam name="T">The type of the primitive.</typeparam>
	/// <param name="value">The primitive value.</param>
	public virtual void VisitPrimitive<T>(T value)
		where T : notnull
	{
	}

	/// <summary>
	/// Visits a generic PPtr (Serialized Pointer) node with a specified PPtr type and target Unity object type.
	/// </summary>
	/// <remarks>
	/// This method is called when encountering a generic PPtr node during asset traversal.
	/// A generic PPtr is a serialized pointer to a Unity object within the asset file.
	/// </remarks>
	/// <typeparam name="TAsset">The type of the Unity object pointed to by the PPtr.</typeparam>
	/// <param name="pptr">The generic PPtr instance representing the serialized pointer.</param>
	public void VisitPPtr<TAsset>(IPPtr<TAsset> pptr)
		where TAsset : IUnityObjectBase
	{
		VisitPPtr(new PPtr<TAsset>(pptr.FileID, pptr.PathID));
	}

	/// <summary>
	/// Visits a Unity PPtr (Serialized Pointer) node.
	/// </summary>
	/// <remarks>
	/// This method is called when encountering a Unity PPtr node during asset traversal.
	/// A PPtr is a serialized pointer to a Unity object within the asset file.
	/// </remarks>
	/// <typeparam name="TAsset">The type of the Unity object pointed to by the PPtr.</typeparam>
	/// <param name="pptr">The PPtr instance representing the serialized pointer.</param>
	public virtual void VisitPPtr<TAsset>(PPtr<TAsset> pptr)
		where TAsset : IUnityObjectBase
	{
	}
}

```

`Source/AssetRipper.Assets/UnityAssetBase.cs`:

```cs
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.IO.Writing;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.IO.Endian;
using System.Runtime.CompilerServices;

namespace AssetRipper.Assets;

/// <summary>
/// The artificial base class for all generated Unity classes
/// </summary>
public abstract class UnityAssetBase : IUnityAssetBase
{
	public virtual int SerializedVersion => 1;

	public virtual bool FlowMappedInYaml => false;

	public virtual bool IgnoreFieldInMetaFiles(string fieldName) => false;

	public virtual void ReadEditor(ref EndianSpanReader reader) => throw MethodNotSupported();

	public virtual void ReadRelease(ref EndianSpanReader reader) => throw MethodNotSupported();

	public virtual void WriteEditor(AssetWriter writer) => throw MethodNotSupported();

	public virtual void WriteRelease(AssetWriter writer) => throw MethodNotSupported();

	public virtual IEnumerable<(string, PPtr)> FetchDependencies()
	{
		return Enumerable.Empty<(string, PPtr)>();
	}

	public override string ToString()
	{
		string? name = (this as INamed)?.Name;
		return string.IsNullOrEmpty(name) ? GetType().Name : name;
	}

	public virtual void Reset() => throw MethodNotSupported();

	public virtual void CopyValues(IUnityAssetBase? source, PPtrConverter converter)
	{
	}

	public virtual void WalkEditor(AssetWalker walker) => WalkStandard(walker);

	public virtual void WalkRelease(AssetWalker walker) => WalkStandard(walker);

	public virtual void WalkStandard(AssetWalker walker)
	{
		if (walker.EnterAsset(this))
		{
			walker.ExitAsset(this);
		}
	}

	public virtual bool? AddToEqualityComparer(IUnityAssetBase other, AssetEqualityComparer comparer)
	{
		throw MethodNotSupported();
	}

	private NotSupportedException MethodNotSupported([CallerMemberName] string? methodName = null)
	{
		return new NotSupportedException($"{methodName} is not supported for {GetType().FullName}");
	}
}

```

`Source/AssetRipper.Assets/UnityObjectBase.PathDetails.cs`:

```cs
namespace AssetRipper.Assets;

public abstract partial class UnityObjectBase
{
	private sealed class PathDetails
	{
		private string? directory;
		private string? name;
		private string? extension;
		private string? fullPath;

		public string? Directory
		{
			get => directory;
			set
			{
				directory = value.NotEmpty();
				fullPath = null;
			}
		}

		public string? Name
		{
			get => name;
			set
			{
				name = value.NotEmpty();
				fullPath = null;
			}
		}

		/// <summary>
		/// Not including the period
		/// </summary>
		public string? Extension
		{
			get => extension;
			set
			{
				extension = value.RemovePeriod().NotEmpty();
				fullPath = null;
			}
		}

		public string? FullPath
		{
			get => fullPath ??= CalculatePath();
			set
			{
				if (value != fullPath)
				{
					fullPath = value.NotEmpty();
					directory = Path.GetDirectoryName(value).NotEmpty();
					name = Path.GetFileNameWithoutExtension(value).NotEmpty();
					extension = Path.GetExtension(value).RemovePeriod().NotEmpty();
				}
			}
		}

		private string? NameWithExtension => Extension is null ? Name : $"{Name}.{Extension}";

		public override string? ToString() => FullPath;

		private string? CalculatePath()
		{
			return Directory is null
				? NameWithExtension
				: Path.Join(Directory, NameWithExtension);
		}
	}
}

```

`Source/AssetRipper.Assets/UnityObjectBase.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Debugging;
using AssetRipper.Assets.Metadata;
using System.Diagnostics;

namespace AssetRipper.Assets;

/// <summary>
/// The artificial base class for all generated Unity classes which inherit from Object.
/// </summary>
[DebuggerTypeProxy(typeof(UnityObjectBaseProxy))]
public abstract partial class UnityObjectBase : UnityAssetBase, IUnityObjectBase
{
	protected UnityObjectBase(AssetInfo assetInfo)
	{
		AssetInfo = assetInfo;
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private PathDetails? originalPathDetails;
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private PathDetails? overridePathDetails;
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public AssetInfo AssetInfo { get; }
	public AssetCollection Collection => AssetInfo.Collection;
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public int ClassID => AssetInfo.ClassID;
	public long PathID => AssetInfo.PathID;
	public virtual string ClassName => GetType().Name;
	public IUnityObjectBase? MainAsset { get; set; }

	/// <inheritdoc/>
	public string? OriginalPath
	{
		get => originalPathDetails?.ToString();
		set
		{
			if (value is null)
			{
				originalPathDetails = null;
			}
			else
			{
				originalPathDetails ??= new();
				originalPathDetails.FullPath = value;
			}
		}
	}

	/// <inheritdoc/>
	public string? OriginalDirectory
	{
		get => originalPathDetails?.Directory;
		set
		{
			if (originalPathDetails is not null)
			{
				originalPathDetails.Directory = value;
			}
			else if (value is not null)
			{
				originalPathDetails = new();
				originalPathDetails.Directory = value;
			}
		}
	}

	/// <inheritdoc/>
	public string? OriginalName
	{
		get => originalPathDetails?.Name;
		set
		{
			if (originalPathDetails is not null)
			{
				originalPathDetails.Name = value;
			}
			else if (value is not null)
			{
				originalPathDetails = new();
				originalPathDetails.Name = value;
			}
		}
	}

	/// <inheritdoc/>
	public string? OriginalExtension
	{
		get => originalPathDetails?.Extension;
		set
		{
			if (originalPathDetails is not null)
			{
				originalPathDetails.Extension = value;
			}
			else if (value is not null)
			{
				originalPathDetails = new();
				originalPathDetails.Extension = value;
			}
		}
	}

	/// <inheritdoc/>
	public string? OverridePath
	{
		get => overridePathDetails?.ToString();
		set
		{
			if (value is null)
			{
				overridePathDetails = null;
			}
			else
			{
				overridePathDetails ??= new();
				overridePathDetails.FullPath = value;
			}
		}
	}

	/// <inheritdoc/>
	public string? OverrideDirectory
	{
		get => overridePathDetails?.Directory;
		set
		{
			if (overridePathDetails is not null)
			{
				overridePathDetails.Directory = value;
			}
			else if (value is not null)
			{
				overridePathDetails = new();
				overridePathDetails.Directory = value;
			}
		}
	}

	/// <inheritdoc/>
	public string? OverrideName
	{
		get => overridePathDetails?.Name;
		set
		{
			if (overridePathDetails is not null)
			{
				overridePathDetails.Name = value;
			}
			else if (value is not null)
			{
				overridePathDetails = new();
				overridePathDetails.Name = value;
			}
		}
	}

	/// <inheritdoc/>
	public string? OverrideExtension
	{
		get => overridePathDetails?.Extension;
		set
		{
			if (overridePathDetails is not null)
			{
				overridePathDetails.Extension = value;
			}
			else if (value is not null)
			{
				overridePathDetails = new();
				overridePathDetails.Extension = value;
			}
		}
	}

	/// <summary>
	/// The name of the asset bundle containing this asset.
	/// </summary>
	public string? AssetBundleName { get; set; }
}

```

`Source/AssetRipper.Assets/Usings.cs`:

```cs
global using AssetRipper.Primitives;

```

`Source/AssetRipper.DocExtraction.ConsoleApp/AssetRipper.DocExtraction.ConsoleApp.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.DocExtraction.ConsoleApp\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.DocExtraction.ConsoleApp\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>


	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.DocExtraction\AssetRipper.DocExtraction.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.DocExtraction.ConsoleApp/Program.cs`:

```cs
using AssetRipper.DocExtraction.DataStructures;
using AssetRipper.DocExtraction.MetaData;
using AssetRipper.Primitives;
using System.Diagnostics;

namespace AssetRipper.DocExtraction.ConsoleApp;

internal static class Program
{
	private static readonly UnityVersion MinimumUnityVersion = new(3, 5);
	static void Main(string[] args)
	{
		Stopwatch stopwatch = Stopwatch.StartNew();

		string unityInstallationsPath = args[0];
		string outputPath = args.Length > 1 ? args[1] : "consolidated.json";
		ExtractAndSaveConsolidated(unityInstallationsPath, outputPath);

		stopwatch.Stop();
		Console.WriteLine($"Finished in {stopwatch.ElapsedMilliseconds} ms");
	}

	private static void ExtractAndSaveConsolidated(string inputDirectory, string outputPath)
	{
		HistoryFile historyFile = new();
		Dictionary<string, ClassHistory> classes = historyFile.Classes;
		Dictionary<string, EnumHistory> enums = historyFile.Enums;
		Dictionary<string, StructHistory> structs = historyFile.Structs;
		foreach (DocumentationFile documentationFile in ExtractAllDocumentation(inputDirectory))
		{
			UnityVersion version = UnityVersion.Parse(documentationFile.UnityVersion);

			ProcessListIntoDictionary<ClassHistory, DataMemberHistory, ClassDocumentation, DataMemberDocumentation>(
				version,
				classes,
				documentationFile.Classes);
			ProcessListIntoDictionary<StructHistory, DataMemberHistory, StructDocumentation, DataMemberDocumentation>(
				version,
				structs,
				documentationFile.Structs);
			ProcessListIntoDictionary<EnumHistory, EnumMemberHistory, EnumDocumentation, EnumMemberDocumentation>(
				version,
				enums,
				documentationFile.Enums);

			Console.WriteLine(documentationFile.UnityVersion);
		}
		historyFile.SaveAsJson(outputPath);
	}

	private static void ProcessListIntoDictionary<THistory, TMemberHistory, TDocumentation, TMemberDocumentation>(
		UnityVersion version,
		Dictionary<string, THistory> dictionary,
		List<TDocumentation> list)
		where TMemberDocumentation : DocumentationBase, new()
		where TDocumentation : TypeDocumentation<TMemberDocumentation>, new()
		where TMemberHistory : HistoryBase, new()
		where THistory : TypeHistory<TMemberHistory, TMemberDocumentation>, new()
	{
		HashSet<string> processedClasses = new();
		foreach (TDocumentation @class in list)
		{
			string fullName = @class.FullName.ToString();
			if (dictionary.TryGetValue(fullName, out THistory? classHistory))
			{
				classHistory.Add(version, @class);
			}
			else
			{
				classHistory = new();
				classHistory.Initialize(version, @class);
				dictionary.Add(fullName, classHistory);
			}
			processedClasses.Add(fullName);
		}
		foreach ((string fullName, THistory classHistory) in dictionary)
		{
			if (!processedClasses.Contains(fullName))
			{
				classHistory.Add(version, null);
			}
		}
	}

	private static IEnumerable<DocumentationFile> ExtractAllDocumentation(string inputDirectory)
	{
		foreach ((UnityVersion unityVersion, string versionFolder) in GetUnityDirectories(inputDirectory))
		{
			string engineXmlPath = Path.Combine(versionFolder, @"Editor\Data\Managed\UnityEngine.xml");
			string editorXmlPath = Path.Combine(versionFolder, @"Editor\Data\Managed\UnityEditor.xml");
			string engineDllPath = Path.Combine(versionFolder, @"Editor\Data\Managed\UnityEngine.dll");
			string editorDllPath = Path.Combine(versionFolder, @"Editor\Data\Managed\UnityEditor.dll");
			yield return DocumentationExtractor.ExtractDocumentation(unityVersion.ToString(), engineXmlPath, editorXmlPath, engineDllPath, editorDllPath);
		}
	}

	private static List<(UnityVersion, string)> GetUnityDirectories(string inputDirectory)
	{
		List<(UnityVersion, string)> list = new();
		foreach (string versionFolder in Directory.GetDirectories(inputDirectory))
		{
			UnityVersion unityVersion = UnityVersion.Parse(Path.GetFileName(versionFolder));
			if (unityVersion < MinimumUnityVersion)
			{
				continue;
			}
			else if (unityVersion.LessThan(4, 5))
			{
				string infoPlistPath = Path.Combine(versionFolder, "Editor/Data/PlaybackEngines/macstandaloneplayer/UnityPlayer.app/Contents/Info.plist");
				UnityVersion actualVersion = XmlDocumentParser.ExtractUnityVersionFromXml(infoPlistPath);
				list.Add((actualVersion, versionFolder));
			}
			else if (unityVersion.LessThan(4, 6, 2))
			{
				string infoPlistPath = Path.Combine(versionFolder, "Editor/Data/PlaybackEngines/macstandalonesupport/Variations/universal_development/UnityPlayer.app/Contents/Info.plist");
				UnityVersion actualVersion = XmlDocumentParser.ExtractUnityVersionFromXml(infoPlistPath);
				list.Add((actualVersion, versionFolder));
			}
			else if (unityVersion.Equals(4, 6, 4))//This particular version doesn't have Info.plist
			{
				list.Add((new UnityVersion(4, 6, 4, UnityVersionType.Final, 1), versionFolder));
			}
			else if (unityVersion.LessThan(5))
			{
				string infoPlistPath = Path.Combine(versionFolder, "Editor/Data/PlaybackEngines/macstandalonesupport/Variations/universal_development_mono/UnityPlayer.app/Contents/Info.plist");
				UnityVersion actualVersion = XmlDocumentParser.ExtractUnityVersionFromXml(infoPlistPath);
				list.Add((actualVersion, versionFolder));
			}
			else
			{
				list.Add((unityVersion, versionFolder));
			}
		}
		list.Sort((pair1, pair2) => pair1.Item1.CompareTo(pair2.Item1));
		return list;
	}
}

```

`Source/AssetRipper.DocExtraction.ConsoleApp/Usings.cs`:

```cs
global using System;

```

`Source/AssetRipper.DocExtraction/AssemblyParser.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AssetRipper.DocExtraction.Extensions;
using AssetRipper.DocExtraction.MetaData;

namespace AssetRipper.DocExtraction;

public static class AssemblyParser
{
	private static readonly HashSet<string?> ClassBlackList = new()
	{
		"<Module>",
		"<PrivateImplementationDetails>",
		"System.Attribute",
		"System.Exception",
		"System.IO.Stream",
		"System.SystemException",
		"UnityEditor.Build.BuildPlayerProcessor",
		"UnityEditor.Experimental.AssetsModifiedProcessor",
		"UnityEditor.AssetModificationProcessor",
		"UnityEditor.AssetPostinstructions",
		"UnityEditor.Editor",
		"UnityEditor.EditorWindow",
		"UnityEditor.Joint2DEditor",
		"UnityEngine.PropertyAttribute",
		"UnityEditor.RendererEditorBase",
	};

	public static void ExtractDocumentationFromAssembly(
		string dllPath,
		Dictionary<string, string> typeSummaries,
		Dictionary<string, string> fieldSummaries,
		Dictionary<string, string> propertySummaries,
		Dictionary<string, ClassDocumentation> classDictionary,
		Dictionary<string, EnumDocumentation> enumDictionary,
		Dictionary<string, StructDocumentation> structDictionary)
	{
		ModuleDefinition module = ModuleDefinition.FromFile(dllPath);
		foreach (TypeDefinition type in module.TopLevelTypes)
		{
			ExtractDocumentationFromType(type, typeSummaries, fieldSummaries, propertySummaries, classDictionary, enumDictionary, structDictionary);
		}
	}

	private static void ExtractDocumentationFromType(TypeDefinition type, Dictionary<string, string> typeSummaries, Dictionary<string, string> fieldSummaries, Dictionary<string, string> propertySummaries, Dictionary<string, ClassDocumentation> classDictionary, Dictionary<string, EnumDocumentation> enumDictionary, Dictionary<string, StructDocumentation> structDictionary)
	{
		string typeFullName = type.FullName;
		if (type.GenericParameters.Count > 0 || ClassBlackList.Contains(typeFullName) || ClassBlackList.Contains(type.BaseType?.FullName) || type.IsCompilerGenerated())
		{
			return;
		}
		else if (type.IsEnum)
		{
			EnumDocumentation enumDocumentation = AddEnumDocumentation(typeSummaries, fieldSummaries, type, typeFullName);
			enumDictionary.TryAdd(typeFullName, enumDocumentation);
		}
		else if (type.IsValueType)
		{
			StructDocumentation structDocumentation = AddStructDocumentation(typeSummaries, fieldSummaries, propertySummaries, type, typeFullName);
			structDictionary.TryAdd(typeFullName, structDocumentation);
		}
		else if (!type.IsInterface && !type.IsStatic())
		{
			ClassDocumentation classDocumentation = AddClassDocumetation(typeSummaries, fieldSummaries, propertySummaries, type, typeFullName);
			classDictionary.TryAdd(typeFullName, classDocumentation);
		}

		foreach (TypeDefinition nestedType in type.NestedTypes)
		{
			ExtractDocumentationFromType(nestedType, typeSummaries, fieldSummaries, propertySummaries, classDictionary, enumDictionary, structDictionary);
		}
	}

	//Static fields and properties are included because some editor classes have important properties as static.

	private static ClassDocumentation AddClassDocumetation(Dictionary<string, string> typeSummaries, Dictionary<string, string> fieldSummaries, Dictionary<string, string> propertySummaries, TypeDefinition type, string typeFullName)
	{
		ClassDocumentation classDocumentation = new()
		{
			Name = type.Name ?? throw new NullReferenceException("Name cannot be null"),
			FullName = typeFullName,
			BaseName = type.BaseType?.Name is null ? "Object" : type.BaseType.Name,
			BaseFullName = type.BaseType?.Name is null ? "System.Object" : type.BaseType.FullName,
			DocumentationString = typeSummaries.TryGetValue(typeFullName.Replace('+', '.')),
			ObsoleteMessage = type.GetObsoleteMessage(),
			NativeName = type.GetNativeClass(),
		};

		foreach (FieldDefinition field in type.Fields)
		{
			if (!field.IsCompilerGenerated())
			{
				string fieldName = field.Name ?? throw new NullReferenceException("Field Name cannot be null");
				DataMemberDocumentation fieldDocumentation = new()
				{
					Name = fieldName,
					TypeName = field.Signature?.FieldType.Name ?? throw new NullReferenceException("Field Signature cannot be null"),
					TypeFullName = field.Signature?.FieldType.FullName ?? throw new NullReferenceException("Field Signature cannot be null"),
					DocumentationString = fieldSummaries.TryGetValue($"{typeFullName.Replace('+', '.')}.{field.Name}"),
					ObsoleteMessage = field.GetObsoleteMessage(),
					NativeName = field.GetNativeName(),
				};
				classDocumentation.Members.Add(fieldName, fieldDocumentation);
			}
		}

		foreach (PropertyDefinition property in type.Properties)
		{
			if (!property.HasParameters() && !property.IsCompilerGenerated())
			{
				string propertyName = property.Name ?? throw new NullReferenceException("Property Name cannot be null");
				DataMemberDocumentation propertyDocumentation = new()
				{
					Name = propertyName,
					TypeName = property.Signature?.ReturnType?.Name ?? throw new NullReferenceException("Property Type cannot be null"),
					TypeFullName = property.Signature?.ReturnType?.FullName ?? throw new NullReferenceException("Property Type cannot be null"),
					DocumentationString = propertySummaries.TryGetValue($"{typeFullName.Replace('+', '.')}.{property.Name}"),
					ObsoleteMessage = property.GetObsoleteMessage(),
					NativeName = property.GetNativeName() ?? property.GetNativeProperty(),
				};
				classDocumentation.Members.Add(propertyName, propertyDocumentation);
			}
		}

		return classDocumentation;
	}

	private static EnumDocumentation AddEnumDocumentation(Dictionary<string, string> typeSummaries, Dictionary<string, string> fieldSummaries, TypeDefinition type, string typeFullName)
	{
		FieldDefinition valueField = type.Fields[0]; //value field is always first
		if (valueField.IsStatic)
		{
			throw new Exception("Value field can't be static");
		}

		EnumDocumentation enumDocumentation = new()
		{
			ElementType = ((CorLibTypeSignature)valueField.Signature!.FieldType).ElementType,
			IsFlagsEnum = type.HasAttribute("System", nameof(FlagsAttribute)),
			Name = type.Name ?? throw new NullReferenceException("Type Name cannot be null"),
			FullName = typeFullName,
			DocumentationString = typeSummaries.TryGetValue(typeFullName.Replace('+', '.')),
			ObsoleteMessage = type.GetObsoleteMessage(),
			NativeName = null,//NativeClassAttribute isn't valid on enums
		};

		for (int i = 1; i < type.Fields.Count; i++)
		{
			FieldDefinition enumField = type.Fields[i];
			if (enumField.IsStatic)
			{
				string enumFieldName = enumField.Name ?? throw new NullReferenceException("Field Name cannot be null");
				EnumMemberDocumentation memberDocumentation = new()
				{
					Name = enumFieldName,
					Value = enumField.Constant!.ConvertToLong(),
					DocumentationString = fieldSummaries.TryGetValue($"{typeFullName.Replace('+', '.')}.{enumField.Name}"),
					ObsoleteMessage = enumField.GetObsoleteMessage(),
					NativeName = enumField.GetNativeName(),
				};
				enumDocumentation.Members.Add(enumFieldName, memberDocumentation);
			}
			else
			{
				throw new Exception("Enum field must be static");
			}
		}

		return enumDocumentation;
	}

	private static StructDocumentation AddStructDocumentation(Dictionary<string, string> typeSummaries, Dictionary<string, string> fieldSummaries, Dictionary<string, string> propertySummaries, TypeDefinition type, string typeFullName)
	{
		StructDocumentation structDocumentation = new()
		{
			Name = type.Name ?? throw new NullReferenceException("Name cannot be null"),
			FullName = typeFullName,
			DocumentationString = typeSummaries.TryGetValue(typeFullName.Replace('+', '.')),
			ObsoleteMessage = type.GetObsoleteMessage(),
			NativeName = type.GetNativeClass(),
		};

		foreach (FieldDefinition field in type.Fields)
		{
			if (!field.IsCompilerGenerated())
			{
				string fieldName = field.Name ?? throw new NullReferenceException("Field Name cannot be null");
				DataMemberDocumentation fieldDocumentation = new()
				{
					Name = fieldName,
					TypeName = field.Signature?.FieldType.Name ?? throw new NullReferenceException("Field Signature cannot be null"),
					TypeFullName = field.Signature?.FieldType.FullName ?? throw new NullReferenceException("Field Signature cannot be null"),
					DocumentationString = fieldSummaries.TryGetValue($"{typeFullName.Replace('+', '.')}.{field.Name}"),
					ObsoleteMessage = field.GetObsoleteMessage(),
					NativeName = field.GetNativeName(),
				};
				structDocumentation.Members.Add(fieldName, fieldDocumentation);
			}
		}

		foreach (PropertyDefinition property in type.Properties)
		{
			if (!property.HasParameters() && !property.IsCompilerGenerated())
			{
				string propertyName = property.Name ?? throw new NullReferenceException("Property Name cannot be null");
				DataMemberDocumentation propertyDocumentation = new()
				{
					Name = propertyName,
					TypeName = property.Signature?.ReturnType?.Name ?? throw new NullReferenceException("Property Type cannot be null"),
					TypeFullName = property.Signature?.ReturnType?.FullName ?? throw new NullReferenceException("Property Type cannot be null"),
					DocumentationString = propertySummaries.TryGetValue($"{typeFullName.Replace('+', '.')}.{property.Name}"),
					ObsoleteMessage = property.GetObsoleteMessage(),
					NativeName = property.GetNativeName() ?? property.GetNativeProperty(),
				};
				structDocumentation.Members.Add(propertyName, propertyDocumentation);
			}
		}

		return structDocumentation;
	}

	private static bool IsCompilerGenerated(this IHasCustomAttribute hasCustomAttribute)
	{
		return hasCustomAttribute.HasAttribute("System.Runtime.CompilerServices", nameof(System.Runtime.CompilerServices.CompilerGeneratedAttribute));
	}
}

```

`Source/AssetRipper.DocExtraction/AssetRipper.DocExtraction.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.DocExtraction\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.DocExtraction\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AsmResolver.DotNet" Version="6.0.0-beta.5" />
		<PackageReference Include="AssetRipper.Primitives" Version="3.2.0" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.AssemblyDumper.Utils\AssetRipper.AssemblyDumper.Utils.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.DocExtraction/DataStructures/ClassHistory.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.DocExtraction.MetaData;
using AssetRipper.Primitives;

namespace AssetRipper.DocExtraction.DataStructures;

public sealed class ClassHistory : ComplexTypeHistory
{
	/// <summary>
	/// The full name for the base type of the class
	/// </summary>
	public VersionedList<FullNameRecord> BaseFullName { get; set; } = new();

	public override void Initialize(UnityVersion version, DocumentationBase first)
	{
		base.Initialize(version, first);
		ClassDocumentation @class = (ClassDocumentation)first;
		BaseFullName.Add(version, new FullNameRecord(@class.BaseFullName, @class.BaseName));
	}

	protected override void AddNotNull(UnityVersion version, DocumentationBase next)
	{
		base.AddNotNull(version, next);
		AddIfNotEqual(BaseFullName, version, ((ClassDocumentation)next).BaseFullNameRecord);
	}

	public static ClassHistory From(UnityVersion version, ClassDocumentation @class)
	{
		ClassHistory? classHistory = new();
		classHistory.Initialize(version, @class);
		return classHistory;
	}

	public bool TryGetBaseClass(UnityVersion version, HistoryFile historyFile, [NotNullWhen(true)] out ClassHistory? baseClass)
	{
		if (historyFile.Classes.TryGetValue(BaseFullName.GetItemForVersion(version).ToString(), out ClassHistory? potentialBaseClass))
		{
			if (potentialBaseClass.ExistsOnVersion(version))//Just to be safe
			{
				baseClass = potentialBaseClass;
				return true;
			}
		}
		baseClass = null;
		return false;
	}

	/// <summary>
	/// 
	/// </summary>
	/// <remarks>
	/// Base class must be constant for this to succeed.
	/// </remarks>
	/// <param name="historyFile"></param>
	/// <param name="baseClass"></param>
	/// <returns></returns>
	public bool TryGetBaseClass(HistoryFile historyFile, [NotNullWhen(true)] out ClassHistory? baseClass)
	{
		if (BaseFullName.Count == 1 && historyFile.Classes.TryGetValue(BaseFullName[0].Value.ToString(), out ClassHistory? potentialBaseClass))
		{
			baseClass = potentialBaseClass;
			return true;
		}
		baseClass = null;
		return false;
	}

	public bool IsUnityEngineObject()
	{
		return Name == "Object" && Namespace == "UnityEngine";
	}

	public bool InheritsFromUnityEngineObject(UnityVersion version, HistoryFile historyFile)
	{
		ClassHistory? baseClass = this;
		while (true)
		{
			if (baseClass.IsUnityEngineObject())
			{
				return true;
			}
			else if (!baseClass.TryGetBaseClass(version, historyFile, out baseClass))
			{
				break;
			}
		}
		return false;
	}

	public override IReadOnlyDictionary<string, DataMemberHistory> GetAllMembers(UnityVersion version, HistoryFile historyFile)
	{
		Dictionary<string, DataMemberHistory> result = new();
		ClassHistory? baseClass = this;
		while (true)
		{
			foreach ((string name, DataMemberHistory member) in baseClass.Members)
			{
				if (member.ExistsOnVersion(version))
				{
					result[name] = member;//In the case of property overrides, the base property is usually more documented
				}
			}
			if (!baseClass.TryGetBaseClass(version, historyFile, out baseClass))
			{
				break;
			}
		}
		return result;
	}

	public override IReadOnlyDictionary<string, DataMemberHistory> GetAllMembers(HistoryFile historyFile)
	{
		Dictionary<string, DataMemberHistory> result = new();
		ClassHistory? baseClass = this;
		while (true)
		{
			foreach ((string name, DataMemberHistory member) in baseClass.Members)
			{
				result[name] = member;//In the case of property overrides, the base property is usually more documented
			}
			if (!baseClass.TryGetBaseClass(historyFile, out baseClass))
			{
				break;
			}
		}
		return result;
	}
}
```

`Source/AssetRipper.DocExtraction/DataStructures/ComplexTypeHistory.cs`:

```cs
using AssetRipper.DocExtraction.MetaData;
using AssetRipper.Primitives;

namespace AssetRipper.DocExtraction.DataStructures;

public abstract class ComplexTypeHistory : TypeHistory<DataMemberHistory, DataMemberDocumentation>
{
	public virtual IReadOnlyDictionary<string, DataMemberHistory> GetAllMembers(HistoryFile historyFile)
	{
		return Members;
	}

	public virtual IReadOnlyDictionary<string, DataMemberHistory> GetAllMembers(UnityVersion version, HistoryFile historyFile)
	{
		return Members;
	}
}

```

`Source/AssetRipper.DocExtraction/DataStructures/DataMemberHistory.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.DocExtraction.MetaData;
using AssetRipper.Primitives;

namespace AssetRipper.DocExtraction.DataStructures;

public sealed class DataMemberHistory : HistoryBase
{
	/// <summary>
	/// The full name for the return type of the property
	/// </summary>
	public VersionedList<FullNameRecord> TypeFullName { get; set; } = new();

	public override void Initialize(UnityVersion version, DocumentationBase first)
	{
		base.Initialize(version, first);
		DataMemberDocumentation dataMember = (DataMemberDocumentation)first;
		TypeFullName.Add(version, new FullNameRecord(dataMember.TypeFullName, dataMember.TypeName));
	}

	protected override void AddNotNull(UnityVersion version, DocumentationBase next)
	{
		base.AddNotNull(version, next);
		AddIfNotEqual(TypeFullName, version, ((DataMemberDocumentation)next).TypeFullNameRecord);
	}
}

```

`Source/AssetRipper.DocExtraction/DataStructures/EnumHistory.cs`:

```cs
using AsmResolver.PE.DotNet.Metadata.Tables;
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.DocExtraction.Extensions;
using AssetRipper.DocExtraction.MetaData;
using AssetRipper.Primitives;

namespace AssetRipper.DocExtraction.DataStructures;
public sealed class EnumHistory : TypeHistory<EnumMemberHistory, EnumMemberDocumentation>
{
	public VersionedList<ElementType> ElementType { get; set; } = new();
	public bool IsFlagsEnum { get; set; }

	public static EnumHistory From(UnityVersion version, EnumDocumentation @enum)
	{
		EnumHistory? history = new();
		history.Initialize(version, @enum);
		return history;
	}

	public override void Initialize(UnityVersion version, DocumentationBase first)
	{
		base.Initialize(version, first);
		EnumDocumentation @enum = (EnumDocumentation)first;
		ElementType.Add(version, @enum.ElementType);
		IsFlagsEnum = @enum.IsFlagsEnum;
	}

	protected override void AddNotNull(UnityVersion version, DocumentationBase next)
	{
		base.AddNotNull(version, next);
		EnumDocumentation @enum = (EnumDocumentation)next;
		AddIfNotEqual(ElementType, version, @enum.ElementType);
		IsFlagsEnum |= @enum.IsFlagsEnum;
	}

	public bool TryGetSingleElementType(out ElementType elementType)
	{
		if (ElementType.Count == 1)
		{
			elementType = ElementType[0].Value;
			return true;
		}
		else
		{
			elementType = default;
			return false;
		}
	}

	public bool TryGetMergedElementType(out ElementType elementType)
	{
		if (ElementType.Count == 0)
		{
			elementType = default;
			return false;
		}
		else if (ElementType.Count == 1)
		{
			elementType = ElementType[0].Value;
			return true;
		}
		else
		{
			try
			{
				elementType = ElementType[0].Value;
				for (int i = 1; i < ElementType.Count; i++)
				{
					elementType = elementType.Merge(ElementType[i].Value);
				}
				return true;
			}
			catch (ArgumentOutOfRangeException)
			{
				elementType = default;
				return false;
			}
		}
	}

}

```

`Source/AssetRipper.DocExtraction/DataStructures/EnumMemberHistory.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.DocExtraction.MetaData;
using AssetRipper.Primitives;

namespace AssetRipper.DocExtraction.DataStructures;

public sealed class EnumMemberHistory : HistoryBase
{
	public VersionedList<long> Value { get; set; } = new();

	public override void Initialize(UnityVersion version, DocumentationBase first)
	{
		base.Initialize(version, first);
		Value.Add(version, ((EnumMemberDocumentation)first).Value);
	}

	protected override void AddNotNull(UnityVersion version, DocumentationBase next)
	{
		base.AddNotNull(version, next);
		AddIfNotEqual(Value, version, ((EnumMemberDocumentation)next).Value);
	}
}

```

`Source/AssetRipper.DocExtraction/DataStructures/HistoryBase.cs`:

```cs
using AssetRipper.AssemblyDumper.Utils;
using AssetRipper.DocExtraction.MetaData;
using AssetRipper.Primitives;
using System.Text.Json.Serialization;

namespace AssetRipper.DocExtraction.DataStructures;

public abstract class HistoryBase
{
	public string Name { get; set; } = "";
	public VersionedList<bool> Exists { get; set; } = new();
	public VersionedList<string> NativeName { get; set; } = new();
	public VersionedList<string> ObsoleteMessage { get; set; } = new();
	public VersionedList<string> DocumentationString { get; set; } = new();
	[JsonIgnore]
	public string? InjectedDocumentation { get; set; }
	[JsonIgnore]
	public UnityVersion MinimumVersion
	{
		get
		{
			return Exists.Count > 0 ? Exists[0].Key : UnityVersion.MinVersion;
		}
	}
	public override string ToString() => Name;

	public virtual void Initialize(UnityVersion version, DocumentationBase first)
	{
		Name = first.Name;
		ObsoleteMessage.Add(version, first.ObsoleteMessage);
		DocumentationString.Add(version, first.DocumentationString);
		NativeName.Add(version, first.NativeName);
		Exists.Add(version, true);
	}

	public void Add(UnityVersion version, DocumentationBase? next)
	{
		if (next is null)
		{
			if (Exists.GetLastValue() is not false)
			{
				Exists.Add(version, false);
			}
		}
		else
		{
			if (Exists.GetLastValue() is not true)
			{
				Exists.Add(version, true);
			}
			AddNotNull(version, next);
		}
	}

	protected virtual void AddNotNull(UnityVersion version, DocumentationBase next)
	{
		AddIfNotEqual(NativeName, version, next.NativeName);
		AddIfNotEqual(ObsoleteMessage, version, next.ObsoleteMessage);
		AddIfNotEqual(DocumentationString, version, next.DocumentationString, false);
	}

	protected static void AddIfNotEqual<T>(VersionedList<T> versionedList, UnityVersion version, T? element)
	{
		if (!EqualityComparer<T>.Default.Equals(versionedList.GetLastValue(), element))
		{
			versionedList.Add(version, element);
		}
	}

	protected static void AddIfNotEqual(VersionedList<string> versionedList, UnityVersion version, string? element)
	{
		AddIfNotEqual(versionedList, version, element, true);
	}

	protected static void AddIfNotEqual(VersionedList<string> versionedList, UnityVersion version, string? element, bool allowNullReplacement)
	{
		string? lastValue = versionedList.GetLastValue();
		if (element is null)
		{
			if (allowNullReplacement && lastValue is not null)
			{
				versionedList.Add(version, null);
			}
		}
		else if (lastValue != element && (lastValue is null || lastValue.ToLowerInvariant() != element.ToLowerInvariant()))
		{
			versionedList.Add(version, element);
		}
	}

	public bool ExistsOnVersion(UnityVersion version)
	{
		return Exists.GetItemForVersion(version);
	}
}

```

`Source/AssetRipper.DocExtraction/DataStructures/HistoryFile.cs`:

```cs
using System.Text.Json;

namespace AssetRipper.DocExtraction.DataStructures;

public sealed class HistoryFile
{
	public Dictionary<string, ClassHistory> Classes { get; set; } = new();
	public Dictionary<string, StructHistory> Structs { get; set; } = new();
	public Dictionary<string, EnumHistory> Enums { get; set; } = new();

	public string ToJson()
	{
		return JsonSerializer.Serialize(this, JsonSourceGenerationContext.Default.HistoryFile);
	}

	public void SaveAsJson(string path)
	{
		using FileStream fileStream = File.Create(path);
		JsonSerializer.Serialize(fileStream, this, JsonSourceGenerationContext.Default.HistoryFile);
	}

	public static HistoryFile FromFile(string path)
	{
		using FileStream fileStream = File.OpenRead(path);
		return JsonSerializer.Deserialize(fileStream, JsonSourceGenerationContext.Default.HistoryFile)
			?? throw new Exception("Failed to deserialize json");
	}

	public static HistoryFile FromJson(string text)
	{
		return JsonSerializer.Deserialize(text, JsonSourceGenerationContext.Default.HistoryFile)
			?? throw new Exception("Failed to deserialize json");
	}
}

```

`Source/AssetRipper.DocExtraction/DataStructures/StructHistory.cs`:

```cs
using AssetRipper.DocExtraction.MetaData;
using AssetRipper.Primitives;

namespace AssetRipper.DocExtraction.DataStructures;

public sealed class StructHistory : ComplexTypeHistory
{
	public static StructHistory From(UnityVersion version, StructDocumentation @struct)
	{
		StructHistory? history = new();
		history.Initialize(version, @struct);
		return history;
	}
}

```

`Source/AssetRipper.DocExtraction/DataStructures/TypeHistory.cs`:

```cs
using AssetRipper.DocExtraction.MetaData;
using AssetRipper.Primitives;
using System.Text.Json.Serialization;

namespace AssetRipper.DocExtraction.DataStructures;

public abstract class TypeHistory<TMember, TMemberDocumentation> : HistoryBase
	where TMember : HistoryBase, new()
	where TMemberDocumentation : DocumentationBase, new()
{
	public Dictionary<string, TMember> Members { get; set; } = new();
	public string FullName { get; set; } = "";
	[JsonIgnore]
	public string? Namespace
	{
		get
		{
			if (Name.Length == 0)
			{
				return FullName;
			}
			else if (FullName.Length <= Name.Length + 1)
			{
				return null;
			}
			else
			{
				return FullName.Substring(0, FullName.Length - Name.Length - 1);
			}
		}
	}
	public override string ToString() => FullName;

	public override void Initialize(UnityVersion version, DocumentationBase first)
	{
		base.Initialize(version, first);
		TypeDocumentation<TMemberDocumentation> type = (TypeDocumentation<TMemberDocumentation>)first;
		FullName = type.FullName;
		foreach ((string memberName, TMemberDocumentation memberInstance) in type.Members)
		{
			TMember memberHistory = new();
			memberHistory.Initialize(version, memberInstance);
			Members.Add(memberName, memberHistory);
		}
	}

	protected override void AddNotNull(UnityVersion version, DocumentationBase next)
	{
		base.AddNotNull(version, next);
		TypeDocumentation<TMemberDocumentation> type = (TypeDocumentation<TMemberDocumentation>)next;
		HashSet<string> processedNames = new();
		foreach ((string memberName, TMember memberHistory) in Members)
		{
			if (type.Members.TryGetValue(memberName, out TMemberDocumentation? memberInstance))
			{
				memberHistory.Add(version, memberInstance);
			}
			else
			{
				memberHistory.Add(version, null);
			}
			processedNames.Add(memberName);
		}
		foreach ((string memberName, TMemberDocumentation memberInstance) in type.Members)
		{
			if (!processedNames.Contains(memberName))
			{
				TMember memberHistory = new();
				memberHistory.Initialize(version, memberInstance);
				Members.Add(memberName, memberHistory);
			}
		}
	}
}

```

`Source/AssetRipper.DocExtraction/DocumentationExtractor.cs`:

```cs
using AssetRipper.DocExtraction.MetaData;

namespace AssetRipper.DocExtraction;

public static class DocumentationExtractor
{
	public static DocumentationFile ExtractDocumentation(string unityVersion, string engineXmlPath, string editorXmlPath, string engineDllPath, string editorDllPath)
	{
		Dictionary<string, string> typeSummaries = new();
		Dictionary<string, string> fieldSummaries = new();
		Dictionary<string, string> propertySummaries = new();
		XmlDocumentParser.ExtractDocumentationFromXml(engineXmlPath, typeSummaries, fieldSummaries, propertySummaries);
		XmlDocumentParser.ExtractDocumentationFromXml(editorXmlPath, typeSummaries, fieldSummaries, propertySummaries);

		Dictionary<string, ClassDocumentation> classDictionary = new();
		Dictionary<string, EnumDocumentation> enumDictionary = new();
		Dictionary<string, StructDocumentation> structDictionary = new();
		AssemblyParser.ExtractDocumentationFromAssembly(engineDllPath, typeSummaries, fieldSummaries, propertySummaries, classDictionary, enumDictionary, structDictionary);
		AssemblyParser.ExtractDocumentationFromAssembly(editorDllPath, typeSummaries, fieldSummaries, propertySummaries, classDictionary, enumDictionary, structDictionary);

		return new DocumentationFile()
		{
			UnityVersion = unityVersion,
			Classes = classDictionary.Values.ToList(),
			Enums = enumDictionary.Values.ToList(),
			Structs = structDictionary.Values.ToList(),
		};
	}
}
```

`Source/AssetRipper.DocExtraction/Extensions/AttributeExtractionExtensions.cs`:

```cs
using AsmResolver;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AsmResolver.PE.DotNet.Metadata.Tables;

namespace AssetRipper.DocExtraction.Extensions;

internal static class AttributeExtractionExtensions
{

	/// <summary>
	/// For <see cref="DocumentationBase.NativeName"/> on <see cref="TypeDocumentation"/>
	/// </summary>
	public static string? GetNativeClass(this ITypeDefOrRef type)
	{
		return type.TryGetCustomAttribute("UnityEngine", "NativeClassAttribute", out CustomAttribute? attribute)
			? GetFirstStringArgument(attribute)
			: null;
	}

	public static string? GetNativeName(this IHasCustomAttribute hasCustomAttributeObject)
	{
		return hasCustomAttributeObject.TryGetCustomAttribute("UnityEngine.Bindings", "NativeNameAttribute", out CustomAttribute? attribute)
			? GetFirstStringArgument(attribute)
			: null;
	}

	/// <summary>
	/// For <see cref="DocumentationBase.NativeName"/> on <see cref="DataMemberDocumentation"/> when <see cref="GetNativeName(IHasCustomAttribute)"/> fails.
	/// </summary>
	public static string? GetNativeProperty(this IHasCustomAttribute hasCustomAttributeObject)
	{
		return hasCustomAttributeObject.TryGetCustomAttribute("UnityEngine.Bindings", "NativePropertyAttribute", out CustomAttribute? attribute)
			? GetFirstStringArgument(attribute)
			: null;
	}

	public static string? GetObsoleteMessage(this IHasCustomAttribute hasCustomAttributeObject)
	{
		if (hasCustomAttributeObject.TryGetCustomAttribute("System", nameof(ObsoleteAttribute), out CustomAttribute? attribute))
		{
			string? stringArgument = GetFirstStringArgument(attribute);
			return string.IsNullOrEmpty(stringArgument) ? "Obsolete" : stringArgument;
		}
		return null;
	}

	private static string? GetFirstStringArgument(CustomAttribute attribute)
	{
		return attribute.Signature?.FixedArguments
			.FirstOrDefault(arg => (arg.ArgumentType as CorLibTypeSignature)?.ElementType == ElementType.String)?
			.Elements
			.Select(e => e as Utf8String)
			.Single()?.Value;
	}
}
```

`Source/AssetRipper.DocExtraction/Extensions/ConstantExtensions.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.PE.DotNet.Metadata.Tables;

namespace AssetRipper.DocExtraction.Extensions;

public static class ConstantExtensions
{
	public static long ConvertToLong(this Constant constant)
	{
		return constant.Type switch
		{
			ElementType.U1 => constant.InterpretData<byte>(),
			ElementType.U2 => constant.InterpretData<ushort>(),
			ElementType.U4 => constant.InterpretData<uint>(),
			ElementType.U8 => unchecked((long)constant.InterpretData<ulong>()),
			ElementType.I1 => constant.InterpretData<sbyte>(),
			ElementType.I2 => constant.InterpretData<short>(),
			ElementType.I4 => constant.InterpretData<int>(),
			ElementType.I8 => constant.InterpretData<long>(),
			_ => throw new NotSupportedException(constant.Type.ToString())
		};
	}

	public static object InterpretData(this Constant constant)
	{
		return constant.Value!.InterpretData(constant.Type);
	}

	public static T InterpretData<T>(this Constant constant)
	{
		return (T)constant.InterpretData();
	}
}
```

`Source/AssetRipper.DocExtraction/Extensions/DictionaryExtensions.cs`:

```cs
namespace AssetRipper.DocExtraction.Extensions;

internal static class DictionaryExtensions
{
	public static TValue? TryGetValue<TKey, TValue>(this Dictionary<TKey, TValue> dictionary, TKey key) where TKey : notnull
	{
		dictionary.TryGetValue(key, out TValue? value);
		return value;
	}

	public static bool EqualByContent<TKey, TValue>(this Dictionary<TKey, TValue> dictionary, Dictionary<TKey, TValue> other) where TKey : notnull
	{
		if (dictionary.GetType() != other.GetType() || dictionary.Count != other.Count)
		{
			return false;
		}

		EqualityComparer<TValue> comparer = EqualityComparer<TValue>.Default;
		foreach ((TKey key, TValue value) in dictionary)
		{
			if (!other.TryGetValue(key, out TValue? otherValue) || !comparer.Equals(value, otherValue))
			{
				return false;
			}
		}

		return true;
	}

	public static int GetHashCodeByContent<TKey, TValue>(this Dictionary<TKey, TValue> dictionary) where TKey : notnull
	{
		int hashCode = 0;
		foreach ((TKey key, _) in dictionary)
		{
			hashCode ^= key.GetHashCode();
		}
		return hashCode;
	}
}
```

`Source/AssetRipper.DocExtraction/Extensions/ElementTypeExtensions.cs`:

```cs
using AsmResolver.PE.DotNet.Metadata.Tables;

namespace AssetRipper.DocExtraction.Extensions;

public static class ElementTypeExtensions
{
	public static int GetByteSize(this ElementType elementType)
	{
		return elementType switch
		{
			ElementType.I1 => 1,
			ElementType.U1 => 1,
			ElementType.I2 => 2,
			ElementType.U2 => 2,
			ElementType.I4 => 4,
			ElementType.U4 => 4,
			ElementType.I8 => 8,
			ElementType.U8 => 8,
			_ => throw new ArgumentOutOfRangeException(nameof(elementType)),
		};
	}

	public static bool IsSigned(this ElementType elementType)
	{
		return elementType switch
		{
			ElementType.I1 => true,
			ElementType.U1 => false,
			ElementType.I2 => true,
			ElementType.U2 => false,
			ElementType.I4 => true,
			ElementType.U4 => false,
			ElementType.I8 => true,
			ElementType.U8 => false,
			_ => throw new ArgumentOutOfRangeException(nameof(elementType)),
		};
	}

	public static bool IsFixedSizeInteger(this ElementType elementType)
	{
		return elementType switch
		{
			ElementType.I1 => true,
			ElementType.U1 => true,
			ElementType.I2 => true,
			ElementType.U2 => true,
			ElementType.I4 => true,
			ElementType.U4 => true,
			ElementType.I8 => true,
			ElementType.U8 => true,
			_ => false,
		};
	}

	public static bool IsUnsigned(this ElementType elementType) => !elementType.IsSigned();

	public static ElementType Merge(this ElementType first, ElementType second)
	{
		if (first == second)
		{
			return first;
		}

		int firstByteSize = first.GetByteSize();
		int secondByteSize = second.GetByteSize();

		if (firstByteSize == secondByteSize) //Different signs
		{
			return first.IncreaseToNextSignedType();
		}
		else
		{
			ElementType larger;
			ElementType smaller;
			if (firstByteSize > secondByteSize)
			{
				larger = first;
				smaller = second;
			}
			else
			{
				larger = second;
				smaller = first;
			}

			if (larger.IsSigned() || smaller.IsUnsigned())
			{
				return larger;
			}
			else
			{
				return larger.IncreaseToNextSignedType();
			}
		}
	}

	private static ElementType IncreaseToNextSignedType(this ElementType elementType)
	{
		return elementType switch
		{
			ElementType.I1 => ElementType.I2,
			ElementType.U1 => ElementType.I2,
			ElementType.I2 => ElementType.I4,
			ElementType.U2 => ElementType.I4,
			ElementType.I4 => ElementType.I8,
			ElementType.U4 => ElementType.I8,
			ElementType.I8 => throw new ArgumentOutOfRangeException(nameof(elementType), "There is no larger ElementType than I8."),
			ElementType.U8 => throw new ArgumentOutOfRangeException(nameof(elementType), "There is no larger ElementType than U8."),
			_ => throw new ArgumentOutOfRangeException(nameof(elementType)),
		};
	}
}
```

`Source/AssetRipper.DocExtraction/Extensions/HasCustomAttributeExtensions.cs`:

```cs
using AsmResolver.DotNet;

namespace AssetRipper.DocExtraction.Extensions;

internal static class HasCustomAttributeExtensions
{

	public static CustomAttribute? GetCustomAttribute(this IHasCustomAttribute hasCustomAttributeObject, string @namespace, string name)
	{
		return hasCustomAttributeObject.CustomAttributes.Count > 0
			? hasCustomAttributeObject.CustomAttributes
				.FirstOrDefault(attr => MatchesNameAndNamespace(attr.Constructor?.DeclaringType, @namespace, name))
			: null;
	}

	public static bool HasAttribute(this IHasCustomAttribute hasCustomAttributeObject, string @namespace, string name)
	{
		return hasCustomAttributeObject.CustomAttributes.Count > 0
			&& hasCustomAttributeObject.CustomAttributes.Any(attr => MatchesNameAndNamespace(attr.Constructor?.DeclaringType, @namespace, name));
	}

	public static bool TryGetCustomAttribute(this IHasCustomAttribute hasCustomAttributeObject, string @namespace, string name, [NotNullWhen(true)] out CustomAttribute? attribute)
	{
		attribute = hasCustomAttributeObject.GetCustomAttribute(@namespace, name);
		return attribute is not null;
	}

	private static bool MatchesNameAndNamespace(ITypeDefOrRef? type, string @namespace, string name)
	{
		return type is not null && type.Namespace == @namespace && type.Name == name;
	}
}
```

`Source/AssetRipper.DocExtraction/Extensions/PropertyDefinitionExtensions.cs`:

```cs
using AsmResolver.DotNet;

namespace AssetRipper.DocExtraction.Extensions;

public static class PropertyDefinitionExtensions
{
	public static bool HasParameters(this PropertyDefinition property)
	{
		return property.Signature?.ParameterTypes.Count > 0;
	}

	public static bool IsPublic(this PropertyDefinition property)
	{
		return (property.GetMethod?.IsPublic ?? false) || (property.SetMethod?.IsPublic ?? false);
	}

	public static bool IsStatic(this PropertyDefinition property)
	{
		return (property.GetMethod?.IsStatic ?? false) || (property.SetMethod?.IsStatic ?? false);
	}

	public static bool IsValueType(this PropertyDefinition property)
	{
		return property.Signature?.ReturnType.IsValueType ?? throw new NullReferenceException("Property signature");
	}
}
```

`Source/AssetRipper.DocExtraction/Extensions/TypeDefinitionExtensions.cs`:

```cs
using AsmResolver.DotNet;

namespace AssetRipper.DocExtraction.Extensions;

public static class TypeDefinitionExtensions
{
	public static bool IsStatic(this TypeDefinition type)
	{
		return type.IsAbstract && type.IsSealed;
	}
}
```

`Source/AssetRipper.DocExtraction/JsonSourceGenerationContext.cs`:

```cs
using AssetRipper.DocExtraction.DataStructures;
using AssetRipper.DocExtraction.MetaData;
using System.Text.Json.Serialization;

namespace AssetRipper.DocExtraction;

[JsonSourceGenerationOptions(WriteIndented = true)]
[JsonSerializable(typeof(DocumentationFile))]
[JsonSerializable(typeof(HistoryFile))]
[JsonSerializable(typeof(FullNameRecord))]
public sealed partial class JsonSourceGenerationContext : JsonSerializerContext
{
}
```

`Source/AssetRipper.DocExtraction/Metadata/ClassDocumentation.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.DocExtraction.MetaData;

public sealed record class ClassDocumentation : ComplexTypeDocumentation
{
	[JsonIgnore]
	public string? BaseNamespace => BaseFullNameRecord.Namespace;
	public string BaseName { get; set; } = "";
	public string BaseFullName { get; set; } = "";
	[JsonIgnore]
	public FullNameRecord BaseFullNameRecord => new FullNameRecord(BaseFullName, BaseName);
}

```

`Source/AssetRipper.DocExtraction/Metadata/ComplexTypeDocumentation.cs`:

```cs
namespace AssetRipper.DocExtraction.MetaData;

public abstract record class ComplexTypeDocumentation : TypeDocumentation<DataMemberDocumentation>
{
}
```

`Source/AssetRipper.DocExtraction/Metadata/DataMemberDocumentation.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.DocExtraction.MetaData;

public sealed record class DataMemberDocumentation : DocumentationBase
{
	/// <summary>
	/// The namespace for the return type of the property
	/// </summary>
	[JsonIgnore]
	public string? TypeNamespace => TypeFullNameRecord.Namespace;
	/// <summary>
	/// The name for the return type of the property
	/// </summary>
	public string TypeName { get; set; } = "";
	/// <summary>
	/// The full name for the return type of the property
	/// </summary>
	public string TypeFullName { get; set; } = "";
	[JsonIgnore]
	public FullNameRecord TypeFullNameRecord => new FullNameRecord(TypeFullName, TypeName);
}

```

`Source/AssetRipper.DocExtraction/Metadata/DocumentationBase.cs`:

```cs
namespace AssetRipper.DocExtraction.MetaData;

public abstract record class DocumentationBase
{
	public string Name { get; set; } = "";
	/// <summary>
	/// NativeNameAttribute for members, NativeClassAttribute for structs and classes, sometimes NativePropertyAttribute for properties
	/// </summary>
	public string? NativeName { get; set; }
	public string? ObsoleteMessage { get; set; }
	public string? DocumentationString { get; set; }
	public override string ToString()
	{
		return Name;
	}
}

```

`Source/AssetRipper.DocExtraction/Metadata/DocumentationFile.cs`:

```cs
using System.Text.Json;

namespace AssetRipper.DocExtraction.MetaData;

public sealed class DocumentationFile
{
	public string UnityVersion { get; set; } = "";
	public List<ClassDocumentation> Classes { get; set; } = new();
	public List<StructDocumentation> Structs { get; set; } = new();
	public List<EnumDocumentation> Enums { get; set; } = new();

	public string ToJson()
	{
		return JsonSerializer.Serialize(this, JsonSourceGenerationContext.Default.DocumentationFile);
	}

	public void SaveAsJson(string path)
	{
		using FileStream fileStream = File.Create(path);
		JsonSerializer.Serialize(fileStream, this, JsonSourceGenerationContext.Default.DocumentationFile);
	}

	public static DocumentationFile FromFile(string path)
	{
		using FileStream fileStream = File.OpenRead(path);
		return JsonSerializer.Deserialize(fileStream, JsonSourceGenerationContext.Default.DocumentationFile)
			?? throw new Exception("Failed to deserialize json");
	}

	public static DocumentationFile FromJson(string text)
	{
		return JsonSerializer.Deserialize(text, JsonSourceGenerationContext.Default.DocumentationFile)
			?? throw new Exception("Failed to deserialize json");
	}
}

```

`Source/AssetRipper.DocExtraction/Metadata/EnumDocumentation.cs`:

```cs
using AsmResolver.PE.DotNet.Metadata.Tables;

namespace AssetRipper.DocExtraction.MetaData;

public sealed record class EnumDocumentation : TypeDocumentation<EnumMemberDocumentation>
{
	public ElementType ElementType { get; set; }
	public bool IsFlagsEnum { get; set; }
}

```

`Source/AssetRipper.DocExtraction/Metadata/EnumMemberDocumentation.cs`:

```cs
namespace AssetRipper.DocExtraction.MetaData;

public sealed record class EnumMemberDocumentation : DocumentationBase
{
	public long Value { get; set; }
}

```

`Source/AssetRipper.DocExtraction/Metadata/FullName.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.DocExtraction.MetaData;

public record struct FullNameRecord(string FullName, string Name)
{
	public override string ToString() => FullName;
	[JsonIgnore]
	public string? Namespace
	{
		get
		{
			if (Name.Length == 0)
			{
				return FullName;
			}
			else if (FullName.Length <= Name.Length + 1)
			{
				return null;
			}
			else
			{
				return FullName.Substring(0, FullName.Length - Name.Length - 1);
			}
		}
	}
}
```

`Source/AssetRipper.DocExtraction/Metadata/StructDocumentation.cs`:

```cs
namespace AssetRipper.DocExtraction.MetaData;

public sealed record class StructDocumentation : ComplexTypeDocumentation
{
}

```

`Source/AssetRipper.DocExtraction/Metadata/TypeDocumentation.cs`:

```cs
using AssetRipper.DocExtraction.Extensions;
using System.Text.Json.Serialization;

namespace AssetRipper.DocExtraction.MetaData;

public abstract record class TypeDocumentation<TMember> : DocumentationBase where TMember : DocumentationBase, new()
{
	public Dictionary<string, TMember> Members { get; set; } = new();
	[JsonIgnore]
	public string? Namespace
	{
		get
		{
			if (Name.Length == 0)
			{
				return FullName;
			}
			else if (FullName.Length <= Name.Length + 1)
			{
				return null;
			}
			else
			{
				return FullName.Substring(0, FullName.Length - Name.Length - 1);
			}
		}
	}
	public string FullName { get; set; } = "";
	public override string ToString() => FullName.ToString();
	public override int GetHashCode()
	{
		return HashCode.Combine(base.GetHashCode(), FullName, Members.GetHashCodeByContent());
	}

	public virtual bool Equals(TypeDocumentation<TMember>? other)
	{
		return (object)this == other || (base.Equals(other) && FullName == other.FullName && Members.EqualByContent(other.Members));
	}
}

```

`Source/AssetRipper.DocExtraction/Usings.cs`:

```cs
global using System;
global using System.Collections.Generic;
global using System.Diagnostics.CodeAnalysis;
```

`Source/AssetRipper.DocExtraction/XmlDocumentParser.cs`:

```cs
using AssetRipper.Primitives;
using System.Xml;

namespace AssetRipper.DocExtraction;

public static class XmlDocumentParser
{
	public static void ExtractDocumentationFromXml(
		string path,
		Dictionary<string, string> typeSummaries,
		Dictionary<string, string> fieldSummaries,
		Dictionary<string, string> propertySummaries)
	{
		if (!File.Exists(path))
		{
			return;
		}

		XmlDocument doc = new();
		doc.Load(path);
		XmlNode membersNode = doc.ChildNodes[1]! //doc
			.ChildNodes[0]!; //members

		foreach (XmlNode memberNode in membersNode.ChildNodes)
		{
			if (memberNode.Name != "member")
			{
				if (memberNode.Name == "assembly")
				{
					continue;
				}
				throw new Exception("Child was not member");
			}

			string memberName = memberNode.Attributes!["name"]!.InnerText;

			if (memberName.StartsWith("T:", StringComparison.Ordinal))
			{
				typeSummaries.TryAdd(memberName.Substring(2), GetSummary(memberNode));
			}
			else if (memberName.StartsWith("F:", StringComparison.Ordinal))
			{
				fieldSummaries.TryAdd(memberName.Substring(2), GetSummary(memberNode));
			}
			else if (memberName.StartsWith("P:", StringComparison.Ordinal))
			{
				propertySummaries.TryAdd(memberName.Substring(2), GetSummary(memberNode));
			}
		}
	}

	private static string GetSummary(XmlNode memberNode)
	{
		XmlNode summaryNode = memberNode.ChildNodes[0]!;
		return summaryNode.Name == "summary" ? summaryNode.InnerText.Trim() : throw new Exception("Child was not summary");
	}

	/// <summary>
	/// Extracts the Unity version from Info.plist inside UnityPlayer.app
	/// </summary>
	/// <param name="path"></param>
	/// <returns></returns>
	public static UnityVersion ExtractUnityVersionFromXml(string path)
	{
		XmlDocument doc = new();
		doc.Load(path);
		string version = doc.LastChild!.FirstChild!.ChildNodes[21]!.InnerText;
		return UnityVersion.Parse(version);
	}
}
```

`Source/AssetRipper.Export.Modules.Audio/AssetRipper.Export.Modules.Audio.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.Export.Modules.Audio\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Export.Modules.Audio\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Fmod5Sharp" Version="3.1.0" />
		<PackageReference Include="NAudio.Core" Version="2.2.1" />
		<PackageReference Include="NAudio.Vorbis" Version="1.5.0" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Export\AssetRipper.Export.csproj" />
	</ItemGroup>

	<ItemGroup>
		<None Remove="C:\Users\**\.nuget\packages\naudio.vorbis\**\README.md" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Export.Modules.Audio/AudioClipDecoder.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.NativeEnums.Fmod;
using Fmod5Sharp;
using Fmod5Sharp.FmodTypes;
using Fmod5Sharp.Util;

namespace AssetRipper.Export.Modules.Audio;

public static class AudioClipDecoder
{
	public static bool TryDecode(
		IAudioClip audioClip,
		[NotNullWhen(true)] out byte[]? decodedData,
		[NotNullWhen(true)] out string? fileExtension,
		[NotNullWhen(false)] out string? message)
	{
		byte[] rawData = audioClip.GetAudioData();

		if (rawData.Length == 0)
		{
			decodedData = null;
			fileExtension = null;
			message = $"Can't decode audio clip '{audioClip.Name}' with default decoder because its audio data could not be found.";
			return false;
		}

		if (audioClip.Has_Type())
		{
			fileExtension = audioClip.GetSoundType().ToRawExtension();
			decodedData = rawData;
			message = null;
			return true;
		}
		else if (CheckMagic(rawData, "FSB5"u8))
		{
			FmodAudioType audioType = (FmodAudioType)uint.MaxValue;
			try
			{
				if (FsbLoader.TryLoadFsbFromByteArray(rawData, out FmodSoundBank? fsbData))
				{
					audioType = fsbData!.Header.AudioType;
					if (audioType.IsSupported() && fsbData.Samples.Single().RebuildAsStandardFileFormat(out decodedData, out fileExtension))
					{
						message = null;
						return true;
					}
					else
					{
						decodedData = null;
						fileExtension = null;
						message = $"Can't decode audio clip '{audioClip.Name}' with Fmod5Sharp because it's '{audioType}' encoded.";
						return false;
					}
				}
			}
			catch (Exception ex)
			{
				decodedData = null;
				fileExtension = null;
				message = $"Failed to convert audio ({audioType})\n{ex}";
				return false;
			}
		}
		else if (CheckMagic(rawData, "IMPM"u8))
		{
			fileExtension = FmodSoundType.It.ToRawExtension();
			decodedData = rawData;
			message = null;
			return true;
		}
		else if (CheckMagic(rawData, "Extended Module: "u8))
		{
			fileExtension = FmodSoundType.Xm.ToRawExtension();
			decodedData = rawData;
			message = null;
			return true;
		}
		// https://moddingwiki.shikadi.net/wiki/S3M_Format
		else if (CheckMagic(rawData, "SCRM"u8, 156))
		{
			fileExtension = FmodSoundType.S3m.ToRawExtension();
			decodedData = rawData;
			message = null;
			return true;
		}
		// https://www.aes.id.au/modformat.html
		else if (
			CheckMagic(rawData, "M.K."u8, 1080) ||
			CheckMagic(rawData, "M!K!"u8, 1080) ||
			CheckMagic(rawData, "FLT4"u8, 1080) ||
			CheckMagic(rawData, "FLT8"u8, 1080) ||
			CheckMagic(rawData, "4CHN"u8, 1080) ||
			CheckMagic(rawData, "6CHN"u8, 1080) ||
			CheckMagic(rawData, "8CHN"u8, 1080))
		{
			fileExtension = FmodSoundType.Mod.ToRawExtension();
			decodedData = rawData;
			message = null;
			return true;
		}

		decodedData = null;
		fileExtension = null;
		Span<char> asciiCharacters = stackalloc char[4];
		CopyPrintable(rawData, asciiCharacters);
		Span<char> hexCharacters = stackalloc char[8];
		CopyHex(rawData, hexCharacters);
		message = $"Failed to convert audio starting with '{asciiCharacters}' ({hexCharacters})";
		return false;
	}

	private static bool CheckMagic(byte[] data, ReadOnlySpan<byte> magic, int startIndex = 0)
	{
		if (data.Length < magic.Length + startIndex)
		{
			return false;
		}
		return data.AsSpan(startIndex, magic.Length).SequenceEqual(magic);
	}

	private static void CopyPrintable(ReadOnlySpan<byte> data, Span<char> characters)
	{
		const char FillCharacter = 'Ø';
		characters.Fill(FillCharacter);
		for (int i = 0; i < data.Length && i < characters.Length; i++)
		{
			char c = (char)data[i];
			if (IsAsciiPrintable(c) && c != '\t')
			{
				characters[i] = c;
			}
		}

		static bool IsAsciiPrintable(char c) => c >= (char)32 && c <= (char)126;
	}

	private static void CopyHex(ReadOnlySpan<byte> data, Span<char> characters)
	{
		ReadOnlySpan<char> hexCharacterLookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
		const char FillCharacter = '0';
		characters.Fill(FillCharacter);
		for (int i = 0; i < data.Length && i < characters.Length / 2; i++)
		{
			byte b = data[i];
			int upper = (b & 0xF0) >> 4;
			characters[2 * i] = hexCharacterLookup[upper];
			int lower = b & 0x0F;
			characters[2 * i + 1] = hexCharacterLookup[lower];
		}
	}
}

```

`Source/AssetRipper.Export.Modules.Audio/AudioConverter.cs`:

```cs
using AssetRipper.Import.Logging;
using NAudio.Vorbis;
using NAudio.Wave;

namespace AssetRipper.Export.Modules.Audio;

public static class AudioConverter
{
	public static byte[] OggToWav(byte[] oggData)
	{
		ArgumentNullException.ThrowIfNull(oggData);

		if (oggData.Length == 0)
		{
			return [];
		}

		try
		{
			using VorbisWaveReader vorbisStream = new VorbisWaveReader(new MemoryStream(oggData), true);
			using MemoryStream writeStream = new MemoryStream();
			WaveFileWriter.WriteWavFileToStream(writeStream, vorbisStream);
			return writeStream.ToArray();
		}
		catch (Exception ex)
		{
			Logger.Error(LogCategory.Export, "Failed to convert audio from OGG to WAV", ex);
			return [];
		}
	}
}

```

`Source/AssetRipper.Export.Modules.Models/AssetRipper.Export.Modules.Models.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.Export.Modules.Models\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Export.Modules.Models\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.SharpGLTF.Toolkit" Version="1.0.2" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Export.Modules.Textures\AssetRipper.Export.Modules.Textures.csproj" />
		<ProjectReference Include="..\AssetRipper.Export\AssetRipper.Export.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Export.Modules.Models/GlbCoordinateConversion.cs`:

```cs
using System.Numerics;

namespace AssetRipper.Export.Modules.Models;

internal static class GlbCoordinateConversion
{
	/// <summary>
	/// Define the transformation between Unity coordinate space and glTF.
	/// glTF is a right-handed coordinate system, where the 'right' direction is -X relative to
	/// Unity's coordinate system.
	/// glTF matrix: column vectors, column-major storage, +Y up, +Z forward, -X right, right-handed
	/// unity matrix: column vectors, column-major storage, +Y up, +Z forward, +X right, left-handed
	/// multiply by a negative X scale to convert handedness
	/// </summary>
	public static readonly Vector3 CoordinateSpaceConversionScale = new Vector3(-1, 1, 1);

	public static readonly Vector4 TangentSpaceConversionScale = new Vector4(-1, 1, 1, -1);

	/// <summary>
	/// Define whether the coordinate space scale conversion above means we have a change in handedness.
	/// This is used when determining the conventional direction of rotation - the right-hand rule states
	/// that rotations are clockwise in left-handed systems and counter-clockwise in right-handed systems.
	/// Reversing the direction of one or three axes of reverses the handedness.
	/// </summary>
	private const float axisFlipScale = -1;

	/// <summary>
	/// Convert unity quaternion to a gltf quaternion
	/// </summary>
	/// <param name="unityQuaternion">unity quaternion</param>
	/// <returns>gltf quaternion</returns>
	public static Quaternion ToGltfQuaternionConvert(Quaternion unityQuaternion)
	{
		Vector3 fromAxisOfRotation = new Vector3(unityQuaternion.X, unityQuaternion.Y, unityQuaternion.Z);
		Vector3 toAxisOfRotation = axisFlipScale * fromAxisOfRotation * CoordinateSpaceConversionScale;
		return new Quaternion(toAxisOfRotation.X, toAxisOfRotation.Y, toAxisOfRotation.Z, unityQuaternion.W);
	}

	public static Vector3 ToGltfVector3Convert(Vector3 unityVector)
	{
		return unityVector * CoordinateSpaceConversionScale;
	}

	public static Vector4 ToGltfTangentConvert(Vector4 unityVector)
	{
		return unityVector * TangentSpaceConversionScale;
	}
}

```

`Source/AssetRipper.Export.Modules.Models/GlbLevelBuilder.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Generics;
using AssetRipper.Export.Modules.Textures;
using AssetRipper.Numerics;
using AssetRipper.Primitives;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_18;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_33;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Material;
using AssetRipper.SourceGenerated.Subclasses.SubMesh;
using AssetRipper.SourceGenerated.Subclasses.UnityTexEnv;
using SharpGLTF.Geometry;
using SharpGLTF.Materials;
using SharpGLTF.Memory;
using SharpGLTF.Scenes;
using System.Buffers;

namespace AssetRipper.Export.Modules.Models;

public static class GlbLevelBuilder
{
	public static SceneBuilder Build(IEnumerable<IUnityObjectBase> assets, bool isScene)
	{
		SceneBuilder sceneBuilder = new();
		BuildParameters parameters = new BuildParameters(isScene);

		HashSet<IUnityObjectBase> exportedAssets = new();

		foreach (IUnityObjectBase asset in assets)
		{
			if (!exportedAssets.Contains(asset) && asset is IGameObject or IComponent)
			{
				IGameObject root = GetRoot(asset);

				AddGameObjectToScene(sceneBuilder, parameters, null, Transformation.Identity, Transformation.Identity, root.GetTransform());

				foreach (IEditorExtension exportedAsset in root.FetchHierarchy())
				{
					exportedAssets.Add(exportedAsset);
				}
			}
		}

		return sceneBuilder;
	}

	private static void AddGameObjectToScene(SceneBuilder sceneBuilder, BuildParameters parameters, NodeBuilder? parentNode, Transformation parentGlobalTransform, Transformation parentGlobalInverseTransform, ITransform transform)
	{
		IGameObject? gameObject = transform.GameObject_C4P;
		if (gameObject is null)
		{
			return;
		}

		Transformation localTransform = transform.ToTransformation();
		Transformation localInverseTransform = transform.ToInverseTransformation();
		Transformation globalTransform = localTransform * parentGlobalTransform;
		Transformation globalInverseTransform = parentGlobalInverseTransform * localInverseTransform;

		NodeBuilder node = parentNode is null ? new NodeBuilder(gameObject.Name) : parentNode.CreateNode(gameObject.Name);
		if (parentNode is not null || parameters.IsScene)
		{
			node.LocalTransform = new SharpGLTF.Transforms.AffineTransform(
				transform.LocalScale_C4.CastToStruct(),//Scaling is the same in both coordinate systems
				GlbCoordinateConversion.ToGltfQuaternionConvert(transform.LocalRotation_C4),
				GlbCoordinateConversion.ToGltfVector3Convert(transform.LocalPosition_C4));
		}
		sceneBuilder.AddNode(node);

		if (gameObject.TryGetComponent(out IMeshFilter? meshFilter)
			&& meshFilter.TryGetMesh(out IMesh? mesh)
			&& mesh.IsSet()
			&& parameters.TryGetOrMakeMeshData(mesh, out MeshData meshData))
		{
			if (gameObject.TryGetComponent(out IRenderer? meshRenderer))
			{
				if (ReferencesDynamicMesh(meshRenderer))
				{

					AddDynamicMeshToScene(sceneBuilder, parameters, node, mesh, meshData, new MaterialList(meshRenderer));
				}
				else
				{
					int[] subsetIndices = GetSubsetIndices(meshRenderer);
					AddStaticMeshToScene(sceneBuilder, parameters, node, mesh, meshData, subsetIndices, new MaterialList(meshRenderer), globalTransform, globalInverseTransform);
				}
			}
		}

		foreach (ITransform childTransform in transform.Children_C4P.WhereNotNull())
		{
			AddGameObjectToScene(sceneBuilder, parameters, node, localTransform * parentGlobalTransform, parentGlobalInverseTransform * localInverseTransform, childTransform);
		}
	}

	private static void AddDynamicMeshToScene(SceneBuilder sceneBuilder, BuildParameters parameters, NodeBuilder node, IMesh mesh, MeshData meshData, MaterialList materialList)
	{
		AccessListBase<ISubMesh> subMeshes = mesh.SubMeshes;
		(ISubMesh, MaterialBuilder)[] subMeshArray = ArrayPool<(ISubMesh, MaterialBuilder)>.Shared.Rent(subMeshes.Count);
		for (int i = 0; i < subMeshes.Count; i++)
		{
			MaterialBuilder materialBuilder = parameters.GetOrMakeMaterial(materialList[i]);
			subMeshArray[i] = (subMeshes[i], materialBuilder);
		}
		ArraySegment<(ISubMesh, MaterialBuilder)> arraySegment = new ArraySegment<(ISubMesh, MaterialBuilder)>(subMeshArray, 0, subMeshes.Count);
		IMeshBuilder<MaterialBuilder> subMeshBuilder = GlbSubMeshBuilder.BuildSubMeshes(arraySegment, mesh.Is16BitIndices(), meshData, Transformation.Identity, Transformation.Identity);
		sceneBuilder.AddRigidMesh(subMeshBuilder, node);
		ArrayPool<(ISubMesh, MaterialBuilder)>.Shared.Return(subMeshArray);
	}

	private static void AddStaticMeshToScene(SceneBuilder sceneBuilder, BuildParameters parameters, NodeBuilder node, IMesh mesh, MeshData meshData, int[] subsetIndices, MaterialList materialList, Transformation globalTransform, Transformation globalInverseTransform)
	{
		(ISubMesh, MaterialBuilder)[] subMeshArray = ArrayPool<(ISubMesh, MaterialBuilder)>.Shared.Rent(subsetIndices.Length);
		AccessListBase<ISubMesh> subMeshes = mesh.SubMeshes;
		for (int i = 0; i < subsetIndices.Length; i++)
		{
			ISubMesh subMesh = subMeshes[subsetIndices[i]];
			MaterialBuilder materialBuilder = parameters.GetOrMakeMaterial(materialList[i]);
			subMeshArray[i] = (subMesh, materialBuilder);
		}
		ArraySegment<(ISubMesh, MaterialBuilder)> arraySegment = new ArraySegment<(ISubMesh, MaterialBuilder)>(subMeshArray, 0, subsetIndices.Length);
		IMeshBuilder<MaterialBuilder> subMeshBuilder = GlbSubMeshBuilder.BuildSubMeshes(arraySegment, mesh.Is16BitIndices(), meshData, globalInverseTransform, globalTransform);
		sceneBuilder.AddRigidMesh(subMeshBuilder, node);
		ArrayPool<(ISubMesh, MaterialBuilder)>.Shared.Return(subMeshArray);
	}

	private static IGameObject GetRoot(IUnityObjectBase asset)
	{
		return asset switch
		{
			IGameObject gameObject => gameObject.GetRoot(),
			IComponent component => component.GameObject_C2P!.GetRoot(),
			_ => throw new InvalidOperationException()
		};
	}

	private static bool ReferencesDynamicMesh(IRenderer renderer)
	{
		return renderer.Has_StaticBatchInfo_C25() && renderer.StaticBatchInfo_C25.SubMeshCount == 0
			|| renderer.Has_SubsetIndices_C25() && renderer.SubsetIndices_C25.Count == 0;
	}

	private static int[] GetSubsetIndices(IRenderer renderer)
	{
		AccessListBase<IPPtr_Material> materials = renderer.Materials_C25;
		if (renderer.Has_SubsetIndices_C25())
		{
			return renderer.SubsetIndices_C25.Select(i => (int)i).ToArray();
		}
		else if (renderer.Has_StaticBatchInfo_C25())
		{
			return Enumerable.Range(renderer.StaticBatchInfo_C25.FirstSubMesh, renderer.StaticBatchInfo_C25.SubMeshCount).ToArray();
		}
		else
		{
			return Array.Empty<int>();
		}
	}

	private readonly record struct BuildParameters(
		MaterialBuilder DefaultMaterial,
		Dictionary<ITexture2D, MemoryImage> ImageCache,
		Dictionary<IMaterial, MaterialBuilder> MaterialCache,
		Dictionary<IMesh, MeshData> MeshCache,
		bool IsScene)
	{
		public BuildParameters(bool isScene) : this(new MaterialBuilder("DefaultMaterial"), new(), new(), new(), isScene) { }
		public bool TryGetOrMakeMeshData(IMesh mesh, out MeshData meshData)
		{
			if (MeshCache.TryGetValue(mesh, out meshData))
			{
				return true;
			}
			else if (MeshData.TryMakeFromMesh(mesh, out meshData))
			{
				MeshCache.Add(mesh, meshData);
				return true;
			}
			return false;
		}

		public MaterialBuilder GetOrMakeMaterial(IMaterial? material)
		{
			if (material is null)
			{
				return DefaultMaterial;
			}
			if (!MaterialCache.TryGetValue(material, out MaterialBuilder? materialBuilder))
			{
				materialBuilder = MakeMaterialBuilder(material);
				MaterialCache.Add(material, materialBuilder);
			}
			return materialBuilder;
		}

		public bool TryGetOrMakeImage(ITexture2D texture, out MemoryImage image)
		{
			if (!ImageCache.TryGetValue(texture, out image))
			{
				if (TextureConverter.TryConvertToBitmap(texture, out DirectBitmap bitmap))
				{
					using MemoryStream memoryStream = new();
					bitmap.SaveAsPng(memoryStream);
					image = new MemoryImage(memoryStream.ToArray());
					ImageCache.Add(texture, image);
					return true;
				}
				return false;
			}
			else
			{
				return true;
			}
		}

		private MaterialBuilder MakeMaterialBuilder(IMaterial material)
		{
			MaterialBuilder materialBuilder = new MaterialBuilder(material.Name);
			GetTextures(material, out ITexture2D? mainTexture, out ITexture2D? normalTexture);
			if (mainTexture is not null && TryGetOrMakeImage(mainTexture, out MemoryImage mainImage))
			{
				materialBuilder.WithBaseColor(mainImage);
			}
			if (normalTexture is not null && TryGetOrMakeImage(normalTexture, out MemoryImage normalImage))
			{
				materialBuilder.WithNormal(normalImage);
			}
			return materialBuilder;
		}

		private static void GetTextures(IMaterial material, out ITexture2D? mainTexture, out ITexture2D? normalTexture)
		{
			mainTexture = null;
			normalTexture = null;
			ITexture2D? mainReplacement = null;
			foreach ((Utf8String utf8Name, IUnityTexEnv textureParameter) in material.GetTextureProperties())
			{
				string name = utf8Name.String;
				if (IsMainTexture(name))
				{
					mainTexture ??= textureParameter.Texture.TryGetAsset(material.Collection) as ITexture2D;
				}
				else if (IsNormalTexture(name))
				{
					normalTexture ??= textureParameter.Texture.TryGetAsset(material.Collection) as ITexture2D;
				}
				else
				{
					mainReplacement ??= textureParameter.Texture.TryGetAsset(material.Collection) as ITexture2D;
				}
			}
			mainTexture ??= mainReplacement;
		}

		private static bool IsMainTexture(string textureName)
		{
			return textureName is "_MainTex" or "texture" or "Texture" or "_Texture";
		}

		private static bool IsNormalTexture(string textureName)
		{
			return textureName is "_Normal" or "Normal" or "normal";
		}
	}

	private readonly struct MaterialList
	{
		private readonly AccessListBase<IPPtr_Material> materials;
		private readonly AssetCollection file;

		private MaterialList(AccessListBase<IPPtr_Material> materials, AssetCollection file)
		{
			this.materials = materials;
			this.file = file;
		}

		public MaterialList(IRenderer renderer) : this(renderer.Materials_C25, renderer.Collection) { }

		public int Count => materials.Count;

		public IMaterial? this[int index]
		{
			get
			{
				if (index >= materials.Count)
				{
					return null;
				}
				return materials[index].TryGetAsset(file);
			}
		}
	}
}

```

`Source/AssetRipper.Export.Modules.Models/GlbMeshBuilder.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.SubMesh;
using SharpGLTF.Geometry;
using SharpGLTF.Materials;
using SharpGLTF.Scenes;

namespace AssetRipper.Export.Modules.Models;

public static class GlbMeshBuilder
{
	public static SceneBuilder Build(IMesh mesh)
	{
		SceneBuilder sceneBuilder = new();
		MaterialBuilder material = new MaterialBuilder("DefaultMaterial");

		AddMeshToScene(sceneBuilder, material, mesh);

		return sceneBuilder;
	}

	private static bool AddMeshToScene(SceneBuilder sceneBuilder, MaterialBuilder material, IMesh mesh)
	{
		if (MeshData.TryMakeFromMesh(mesh, out MeshData meshData))
		{
			NodeBuilder rootNodeForMesh = new NodeBuilder(mesh.Name);
			sceneBuilder.AddNode(rootNodeForMesh);

			(ISubMesh, MaterialBuilder)[] subMeshes = new (ISubMesh, MaterialBuilder)[1];

			for (int submeshIndex = 0; submeshIndex < mesh.SubMeshes.Count; submeshIndex++)
			{
				ISubMesh subMesh = mesh.SubMeshes[submeshIndex];
				subMeshes[0] = (subMesh, material);

				IMeshBuilder<MaterialBuilder> subMeshBuilder = GlbSubMeshBuilder.BuildSubMeshes(subMeshes, mesh.Is16BitIndices(), meshData, Transformation.Identity, Transformation.Identity);
				NodeBuilder subMeshNode = rootNodeForMesh.CreateNode($"SubMesh_{submeshIndex}");
				sceneBuilder.AddRigidMesh(subMeshBuilder, subMeshNode);
			}
			return true;
		}
		return false;
	}
}

```

`Source/AssetRipper.Export.Modules.Models/GlbMeshType.cs`:

```cs
using SharpGLTF.Geometry.VertexTypes;

namespace AssetRipper.Export.Modules.Models;

[Flags]
internal enum GlbMeshType
{
	/// <summary>
	/// <see cref="VertexEmpty"/>
	/// </summary>
	Empty = 0,
	/// <summary>
	/// <see cref="VertexPosition"/>
	/// </summary>
	Position = 0,
	Normal = 1 << 0,
	Tangent = 1 << 1,
	/// <summary>
	/// <see cref="VertexPositionNormal"/>
	/// </summary>
	PositionNormal = Position | Normal,
	/// <summary>
	/// <see cref="VertexPositionNormalTangent"/>
	/// </summary>
	PositionNormalTangent = Position | Normal | Tangent,
	/// <summary>
	/// <see cref="VertexColor1"/>
	/// </summary>
	Color1 = 1 << 2,
	/// <summary>
	/// <see cref="VertexTexture1"/>
	/// </summary>
	Texture1 = 1 << 3,
	/// <summary>
	/// <see cref="VertexTexture2"/>
	/// </summary>
	Texture2 = 1 << 4,
	/// <summary>
	/// Not implemented yet. Defines a vertex with up to 8 UV channels.
	/// </summary>
	TextureN = 1 << 5,
	/// <summary>
	/// <see cref="VertexColor1Texture1"/>
	/// </summary>
	Color1Texture1 = Color1 | Texture1,
	/// <summary>
	/// <see cref="VertexColor1Texture2"/>
	/// </summary>
	Color1Texture2 = Color1 | Texture2,
	/// <summary>
	/// Not implemented yet.
	/// </summary>
	Color1TextureN = Color1 | TextureN,
	/// <summary>
	/// <see cref="VertexJoints4"/>
	/// </summary>
	Joints4 = 1 << 6,
}

```

`Source/AssetRipper.Export.Modules.Models/GlbSubMeshBuilder.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.SubMesh;
using SharpGLTF.Geometry;
using SharpGLTF.Geometry.VertexTypes;
using SharpGLTF.Materials;
using SharpGLTF.Transforms;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace AssetRipper.Export.Modules.Models;

internal static class GlbSubMeshBuilder
{
	public static IMeshBuilder<MaterialBuilder> BuildSubMeshes(ArraySegment<ValueTuple<ISubMesh, MaterialBuilder>> subMeshes, bool is16BitIndices, MeshData meshData, Transformation transform, Transformation inverseTransform)
	{
		BuildSubMeshParameters parameters = new BuildSubMeshParameters(subMeshes, is16BitIndices, meshData, transform, inverseTransform);
		switch (meshData.GetMeshType())
		{
			case GlbMeshType.Position | GlbMeshType.Empty | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPosition, VertexEmpty, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.Empty | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormal, VertexEmpty, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Empty | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexEmpty, VertexEmpty>(parameters);

			case GlbMeshType.Position | GlbMeshType.Texture1 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPosition, VertexTexture1, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.Texture1 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormal, VertexTexture1, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Texture1 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexTexture1, VertexEmpty>(parameters);

			case GlbMeshType.Position | GlbMeshType.Texture2 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPosition, VertexTexture2, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.Texture2 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormal, VertexTexture2, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Texture2 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexTexture2, VertexEmpty>(parameters);

			case GlbMeshType.Position | GlbMeshType.Color1 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPosition, VertexColor1, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.Color1 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormal, VertexColor1, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Color1 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexColor1, VertexEmpty>(parameters);

			case GlbMeshType.Position | GlbMeshType.Color1Texture1 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPosition, VertexColor1Texture1, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.Color1Texture1 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormal, VertexColor1Texture1, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Color1Texture1 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexColor1Texture1, VertexEmpty>(parameters);

			case GlbMeshType.Position | GlbMeshType.Color1Texture2 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPosition, VertexColor1Texture2, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.Color1Texture2 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormal, VertexColor1Texture2, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Color1Texture2 | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexColor1Texture2, VertexEmpty>(parameters);

			case GlbMeshType.Position | GlbMeshType.TextureN | GlbMeshType.Empty:
			case GlbMeshType.Position | GlbMeshType.Color1TextureN | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPosition, VertexColor1Texture8, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.TextureN | GlbMeshType.Empty:
			case GlbMeshType.PositionNormal | GlbMeshType.Color1TextureN | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormal, VertexColor1Texture8, VertexEmpty>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.TextureN | GlbMeshType.Empty:
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Color1TextureN | GlbMeshType.Empty:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexColor1Texture8, VertexEmpty>(parameters);

			case GlbMeshType.Position | GlbMeshType.Empty | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPosition, VertexEmpty, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.Empty | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormal, VertexEmpty, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Empty | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexEmpty, VertexJoints4>(parameters);

			case GlbMeshType.Position | GlbMeshType.Texture1 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPosition, VertexTexture1, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.Texture1 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormal, VertexTexture1, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Texture1 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexTexture1, VertexJoints4>(parameters);

			case GlbMeshType.Position | GlbMeshType.Texture2 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPosition, VertexTexture2, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.Texture2 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormal, VertexTexture2, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Texture2 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexTexture2, VertexJoints4>(parameters);

			case GlbMeshType.Position | GlbMeshType.Color1 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPosition, VertexColor1, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.Color1 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormal, VertexColor1, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Color1 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexColor1, VertexJoints4>(parameters);

			case GlbMeshType.Position | GlbMeshType.Color1Texture1 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPosition, VertexColor1Texture1, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.Color1Texture1 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormal, VertexColor1Texture1, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Color1Texture1 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexColor1Texture1, VertexJoints4>(parameters);

			case GlbMeshType.Position | GlbMeshType.Color1Texture2 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPosition, VertexColor1Texture2, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.Color1Texture2 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormal, VertexColor1Texture2, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Color1Texture2 | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexColor1Texture2, VertexJoints4>(parameters);

			case GlbMeshType.Position | GlbMeshType.TextureN | GlbMeshType.Joints4:
			case GlbMeshType.Position | GlbMeshType.Color1TextureN | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPosition, VertexColor1Texture8, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormal | GlbMeshType.TextureN | GlbMeshType.Joints4:
			case GlbMeshType.PositionNormal | GlbMeshType.Color1TextureN | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormal, VertexColor1Texture8, VertexJoints4>(parameters);
			case GlbMeshType.PositionNormalTangent | GlbMeshType.TextureN | GlbMeshType.Joints4:
			case GlbMeshType.PositionNormalTangent | GlbMeshType.Color1TextureN | GlbMeshType.Joints4:
				return BuildSubMeshes<VertexPositionNormalTangent, VertexColor1Texture8, VertexJoints4>(parameters);

			default:
				throw new ArgumentOutOfRangeException(nameof(meshData), meshData.GetMeshType(), "Mesh type not supported.");
		}
	}

	private static MeshBuilder<TvG, TvM, TvS> BuildSubMeshes<TvG, TvM, TvS>(BuildSubMeshParameters parameters)
		where TvG : unmanaged, IVertexGeometry
		where TvM : unmanaged, IVertexMaterial
		where TvS : unmanaged, IVertexSkinning
	{
		Transformation positionTransform = parameters.Transform;
		Transformation tangentTransform = positionTransform.RemoveTranslation();
		Transformation normalTransform = parameters.InverseTransform.Transpose();
		MeshBuilder<TvG, TvM, TvS> meshBuilder = VertexBuilder<TvG, TvM, TvS>.CreateCompatibleMesh();

		for (int i = 0; i < parameters.SubMeshes.Count; i++)
		{
			(ISubMesh subMesh, MaterialBuilder material) = parameters.SubMeshes[i];
			BuildSubMesh(meshBuilder, subMesh, material, parameters.Is16BitIndices, parameters.MeshData, positionTransform, tangentTransform, normalTransform);
		}

		return meshBuilder;
	}

	private static PrimitiveBuilder<MaterialBuilder, TvG, TvM, TvS> BuildSubMesh<TvG, TvM, TvS>(
		MeshBuilder<TvG, TvM, TvS> meshBuilder,
		ISubMesh subMesh,
		MaterialBuilder material,
		bool is16BitIndices,
		MeshData meshData,
		Transformation positionTransform,
		Transformation tangentTransform,
		Transformation normalTransform)
		where TvG : unmanaged, IVertexGeometry
		where TvM : unmanaged, IVertexMaterial
		where TvS : unmanaged, IVertexSkinning
	{
		uint firstIndex = subMesh.GetFirstIndex(is16BitIndices);

		uint indexCount = subMesh.IndexCount;
		MeshTopology topology = subMesh.GetTopology();

		int primitiveVertexCount = topology switch
		{
			MeshTopology.Lines or MeshTopology.LineStrip => 2,
			MeshTopology.Points => 1,
			_ => 3
		};
		PrimitiveBuilder<MaterialBuilder, TvG, TvM, TvS> primitiveBuilder = meshBuilder.UsePrimitive(material, primitiveVertexCount);

		//Vertex order is flipped in Gltf
		switch (topology)
		{
			case MeshTopology.Triangles:
				{
					for (int i = 0; i < indexCount; i += 3)
					{
						primitiveBuilder.AddTriangle(
							GetVertex<TvG, TvM, TvS>(meshData, meshData.ProcessedIndexBuffer[firstIndex + i + 2], positionTransform, normalTransform, tangentTransform),
							GetVertex<TvG, TvM, TvS>(meshData, meshData.ProcessedIndexBuffer[firstIndex + i + 1], positionTransform, normalTransform, tangentTransform),
							GetVertex<TvG, TvM, TvS>(meshData, meshData.ProcessedIndexBuffer[firstIndex + i], positionTransform, normalTransform, tangentTransform));
					}
				}
				break;

			case MeshTopology.TriangleStrip:
				{
					// de-stripify :
					uint triIndex = 0;
					for (int i = 0; i < indexCount - 2; i++)
					{
						uint a = meshData.ProcessedIndexBuffer[firstIndex + i + 2];
						uint b = meshData.ProcessedIndexBuffer[firstIndex + i + 1];
						uint c = meshData.ProcessedIndexBuffer[firstIndex + i];

						// skip degenerates
						if (a == b || a == c || b == c)
						{
							continue;
						}

						// do the winding flip-flop of strips :
						if ((i & 1) == 1)
						{
							primitiveBuilder.AddTriangle(
								GetVertex<TvG, TvM, TvS>(meshData, b, positionTransform, normalTransform, tangentTransform),
								GetVertex<TvG, TvM, TvS>(meshData, a, positionTransform, normalTransform, tangentTransform),
								GetVertex<TvG, TvM, TvS>(meshData, c, positionTransform, normalTransform, tangentTransform));
						}
						else
						{
							primitiveBuilder.AddTriangle(
								GetVertex<TvG, TvM, TvS>(meshData, a, positionTransform, normalTransform, tangentTransform),
								GetVertex<TvG, TvM, TvS>(meshData, b, positionTransform, normalTransform, tangentTransform),
								GetVertex<TvG, TvM, TvS>(meshData, c, positionTransform, normalTransform, tangentTransform));
						}
						triIndex += 3;
					}
				}
				break;

			case MeshTopology.Quads:
				{
					for (int q = 0; q < indexCount; q += 4)
					{
						primitiveBuilder.AddQuadrangle(
							GetVertex<TvG, TvM, TvS>(meshData, meshData.ProcessedIndexBuffer[firstIndex + q + 3], positionTransform, normalTransform, tangentTransform),
							GetVertex<TvG, TvM, TvS>(meshData, meshData.ProcessedIndexBuffer[firstIndex + q + 2], positionTransform, normalTransform, tangentTransform),
							GetVertex<TvG, TvM, TvS>(meshData, meshData.ProcessedIndexBuffer[firstIndex + q + 1], positionTransform, normalTransform, tangentTransform),
							GetVertex<TvG, TvM, TvS>(meshData, meshData.ProcessedIndexBuffer[firstIndex + q], positionTransform, normalTransform, tangentTransform));
					}
				}
				break;

			case MeshTopology.Lines:
				{
					for (int l = 0; l < indexCount; l += 2)
					{
						primitiveBuilder.AddLine(
							GetVertex<TvG, TvM, TvS>(meshData, meshData.ProcessedIndexBuffer[firstIndex + l + 1], positionTransform, normalTransform, tangentTransform),
							GetVertex<TvG, TvM, TvS>(meshData, meshData.ProcessedIndexBuffer[firstIndex + l], positionTransform, normalTransform, tangentTransform));
						//The vertex order is currently flipped because triangle and quad vertices need their order flipped, but is that still true for lines?
					}
				}
				break;

			case MeshTopology.LineStrip:
				//First two indices form a line, and then each new index connects a new vertex to the existing line strip.
				//https://docs.unity3d.com/ScriptReference/MeshTopology.LineStrip.html
				if (indexCount > 1)
				{
					VertexBuilder<TvG, TvM, TvS> previousVertex = GetVertex<TvG, TvM, TvS>(meshData, meshData.ProcessedIndexBuffer[firstIndex], positionTransform, normalTransform, tangentTransform);
					for (int l = 1; l < indexCount; l++)
					{
						VertexBuilder<TvG, TvM, TvS> currentVertex = GetVertex<TvG, TvM, TvS>(meshData, meshData.ProcessedIndexBuffer[firstIndex + l], positionTransform, normalTransform, tangentTransform);
						primitiveBuilder.AddLine(currentVertex, previousVertex);
						//The vertex order is currently flipped because triangle and quad vertices need their order flipped, but is that still true for lines?
						previousVertex = currentVertex;
					}
				}
				break;

			case MeshTopology.Points:
				{
					for (int p = 0; p < indexCount; p++)
					{
						primitiveBuilder.AddPoint(GetVertex<TvG, TvM, TvS>(meshData, meshData.ProcessedIndexBuffer[firstIndex + p], positionTransform, normalTransform, tangentTransform));
					}
				}
				break;
		}

		return primitiveBuilder;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
	private static VertexBuilder<TvG, TvM, TvS> GetVertex<TvG, TvM, TvS>(MeshData meshData, uint index,
		Transformation positionTransform, Transformation normalTransform, Transformation tangentTransform)
		where TvG : unmanaged, IVertexGeometry
		where TvM : unmanaged, IVertexMaterial
		where TvS : unmanaged, IVertexSkinning
	{
		TvG geometry = GetGeometry<TvG>(meshData, index, positionTransform, normalTransform, tangentTransform);
		TvM material = GetMaterial<TvM>(meshData, index);
		TvS skin = GetSkin<TvS>(meshData, index);
		return new VertexBuilder<TvG, TvM, TvS>(geometry, material, skin);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
	private static TvG GetGeometry<TvG>(MeshData meshData, uint index, Transformation positionTransform, Transformation normalTransform, Transformation tangentTransform)
		where TvG : unmanaged, IVertexGeometry
	{
		Vector3 position = GlbCoordinateConversion.ToGltfVector3Convert(meshData.TryGetVertexAtIndex(index) * positionTransform);
		if (typeof(TvG) == typeof(VertexPosition))
		{
			return Cast<VertexPosition, TvG>(new VertexPosition(position));
		}
		else if (typeof(TvG) == typeof(VertexPositionNormal))
		{
			Vector3 normal = GlbCoordinateConversion.ToGltfVector3Convert(Vector3.Normalize(meshData.TryGetNormalAtIndex(index) * normalTransform));
			return Cast<VertexPositionNormal, TvG>(new VertexPositionNormal(position, normal));
		}
		else if (typeof(TvG) == typeof(VertexPositionNormalTangent))
		{
			Vector3 normal = GlbCoordinateConversion.ToGltfVector3Convert(Vector3.Normalize(meshData.TryGetNormalAtIndex(index) * normalTransform));
			Vector4 originalTangent = meshData.TryGetTangentAtIndex(index);
			Vector3 transformedTangent = Vector3.Normalize(originalTangent.AsVector3() * tangentTransform);
			Vector4 tangent = GlbCoordinateConversion.ToGltfTangentConvert(new Vector4(transformedTangent, originalTangent.W));
			return Cast<VertexPositionNormalTangent, TvG>(new VertexPositionNormalTangent(position, normal, tangent));
		}
		else
		{
			return default;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
	private static TvM GetMaterial<TvM>(MeshData meshData, uint index) where TvM : unmanaged, IVertexMaterial
	{
		if (typeof(TvM) == typeof(VertexTexture1))
		{
			return Cast<VertexTexture1, TvM>(new VertexTexture1(meshData.TryGetUV0AtIndex(index)));
		}
		else if (typeof(TvM) == typeof(VertexTexture2))
		{
			return Cast<VertexTexture2, TvM>(new VertexTexture2(meshData.TryGetUV0AtIndex(index), meshData.TryGetUV1AtIndex(index)));
		}
		else if (typeof(TvM) == typeof(VertexColor1Texture1))
		{
			return Cast<VertexColor1Texture1, TvM>(new VertexColor1Texture1(meshData.TryGetColorAtIndex(index).Vector, meshData.TryGetUV0AtIndex(index)));
		}
		else if (typeof(TvM) == typeof(VertexColor1Texture2))
		{
			return Cast<VertexColor1Texture2, TvM>(new VertexColor1Texture2(meshData.TryGetColorAtIndex(index).Vector, meshData.TryGetUV0AtIndex(index), meshData.TryGetUV1AtIndex(index)));
		}
		else if (typeof(TvM) == typeof(VertexColor1Texture8))
		{
			VertexColor1Texture8 result = new()
			{
				Color = meshData.TryGetColorAtIndex(index).Vector,
				TexCoord0 = meshData.TryGetUV0AtIndex(index),
				TexCoord1 = meshData.TryGetUV1AtIndex(index),
				TexCoord2 = meshData.TryGetUV2AtIndex(index),
				TexCoord3 = meshData.TryGetUV3AtIndex(index),
				TexCoord4 = meshData.TryGetUV4AtIndex(index),
				TexCoord5 = meshData.TryGetUV5AtIndex(index),
				TexCoord6 = meshData.TryGetUV6AtIndex(index),
				TexCoord7 = meshData.TryGetUV7AtIndex(index),
			};
			return Cast<VertexColor1Texture8, TvM>(result);
		}
		else
		{
			return default;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
	private static TvS GetSkin<TvS>(MeshData meshData, uint index) where TvS : unmanaged, IVertexSkinning
	{
		if (typeof(TvS) == typeof(VertexJoints4))
		{
			BoneWeight4 skin = meshData.TryGetSkinAtIndex(index);
			Vector4 indices = new Vector4(skin.Index0, skin.Index1, skin.Index2, skin.Index3);
			Vector4 weights = new Vector4(skin.Weight0, skin.Weight1, skin.Weight2, skin.Weight3);
			SparseWeight8 sparseWeight = SparseWeight8.Create(indices, weights);
			return Cast<VertexJoints4, TvS>(new(sparseWeight));
		}
		else
		{
			return default;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
	private static TTo Cast<TFrom, TTo>(TFrom value) where TFrom : unmanaged where TTo : unmanaged
	{
		//Protect against accidental misuse
		//Branches will get optimized away by JIT
		if (typeof(TFrom) == typeof(TTo))
		{
			return Unsafe.As<TFrom, TTo>(ref value);
		}
		else
		{
#if DEBUG
			throw new InvalidCastException();
#else
			return default;
#endif
		}
	}

	private readonly record struct BuildSubMeshParameters(
		ArraySegment<ValueTuple<ISubMesh, MaterialBuilder>> SubMeshes,
		bool Is16BitIndices,
		MeshData MeshData,
		Transformation Transform,
		Transformation InverseTransform)
	{
	}
}

```

`Source/AssetRipper.Export.Modules.Models/GlbTerrainBuilder.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using AssetRipper.SourceGenerated.Extensions;
using SharpGLTF.Geometry;
using SharpGLTF.Geometry.VertexTypes;
using SharpGLTF.Materials;
using SharpGLTF.Scenes;
using System.Numerics;

namespace AssetRipper.Export.Modules.Models;

public static class GlbTerrainBuilder
{
	public static SceneBuilder Build(ITerrainData terrain)
	{
		SceneBuilder sceneBuilder = new();
		AddTerrainToSceneBuilder(sceneBuilder, terrain);
		return sceneBuilder;
	}

	private static void AddTerrainToSceneBuilder(SceneBuilder sceneBuilder, ITerrainData terrain)
	{
		MaterialBuilder material = new MaterialBuilder("DefaultMaterial");
		MeshBuilder<VertexPosition, VertexTexture1, VertexEmpty> meshBuilder = new();
		PrimitiveBuilder<MaterialBuilder, VertexPosition, VertexTexture1, VertexEmpty> primitiveBuilder = meshBuilder.UsePrimitive(material);

		int tw = Math.Max(terrain.Heightmap.Width, terrain.Heightmap.Resolution);
		int th = Math.Max(terrain.Heightmap.Height, terrain.Heightmap.Resolution);

		Vector3 meshScale = terrain.Heightmap.Scale.CastToStruct() * new Vector3(-1, 1, 1);
		Vector2 uvScale = new Vector2(1 / (tw - 1), 1 / (th - 1));

		int w = th;
		int h = tw;

		int startX = 0;
		int startY = 0;

		float[,] tData = GetHeights(terrain);

		VertexBuilder<VertexPosition, VertexTexture1, VertexEmpty>[] vertices = new VertexBuilder<VertexPosition, VertexTexture1, VertexEmpty>[w * h];
		for (int y = 0; y < h; y++)
		{
			for (int x = 0; x < w; x++)
			{
				Vector3 pos = new Vector3(-(startY + y), tData[startX + x, startY + y], startX + x) * meshScale;
				Vector2 uv = new Vector2(x, y) * uvScale;
				vertices[y * w + x] = new VertexBuilder<VertexPosition, VertexTexture1, VertexEmpty>(new VertexPosition(pos), new VertexTexture1(uv));
			}
		}

		for (int y = 0; y < h - 1; y++)
		{
			for (int x = 0; x < w - 1; x++)
			{
				primitiveBuilder.AddTriangle(
					vertices[y * w + x],
					vertices[y * w + x + 1],
					vertices[(y + 1) * w + x]);
				primitiveBuilder.AddTriangle(
					vertices[(y + 1) * w + x],
					vertices[y * w + x + 1],
					vertices[(y + 1) * w + x + 1]);
			}
		}

		NodeBuilder nodeBuilder = new NodeBuilder(terrain.Name);
		sceneBuilder.AddRigidMesh(meshBuilder, nodeBuilder);
	}

	private static float[,] GetHeights(ITerrainData terrain)
	{
		int width = Math.Max(terrain.Heightmap.Width, terrain.Heightmap.Resolution);
		int height = Math.Max(terrain.Heightmap.Height, terrain.Heightmap.Resolution);
		AssetList<short> heights = terrain.Heightmap.Heights;
		float[,] result = new float[width, height];
		for (int y = 0; y < height; y++)
		{
			for (int x = 0; x < width; x++)
			{
				result[x, y] = (float)heights[x + y * width] / short.MaxValue;
			}
		}
		return result;
	}
}

```

`Source/AssetRipper.Export.Modules.Models/GlbWriter.cs`:

```cs
using SharpGLTF.Scenes;

namespace AssetRipper.Export.Modules.Models;

public static class GlbWriter
{
	public static bool TryWrite(SceneBuilder sceneBuilder, Stream stream, [NotNullWhen(false)] out string? errorMessage)
	{
		// Setting MergeBuffers to false doesn't actually do anything because SharpGLTF changes it back to true.
		try
		{
			sceneBuilder.ToGltf2().WriteGLB(stream);
			errorMessage = null;
			return true;
		}
		catch (InvalidOperationException ex) when (ex.Message is "Can't merge a buffer larger than 2Gb")
		{
			errorMessage = "Model was too large to export as GLB.";
			return false;
		}
		catch (ArgumentException ex) when (ex.Message is "the combined size of all the meshes exceeds the maximum capacity of the buffers, try disabling Buffers merging")
		{
			errorMessage = "Model was too large to export as GLB.";
			return false;
		}
		catch (OutOfMemoryException)
		{
			errorMessage = "Could not allocate enough contiguous memory to export the model as GLB.";
			return false;
		}
	}
}

```

`Source/AssetRipper.Export.Modules.Models/MeshDataExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.Modules.Models;

internal static class MeshDataExtensions
{
	public static GlbMeshType GetMeshType(this MeshData mesh)
	{
		GlbMeshType meshType = default;

		if (mesh.HasNormals)
		{
			if (mesh.HasTangents)
			{
				meshType |= GlbMeshType.PositionNormalTangent;
			}
			else
			{
				meshType |= GlbMeshType.PositionNormal;
			}
		}

		meshType |= mesh.UVCount switch
		{
			0 => default,
			1 => GlbMeshType.Texture1,
			2 => GlbMeshType.Texture2,
			_ => GlbMeshType.TextureN,
		};

		if (mesh.HasColors)
		{
			meshType |= GlbMeshType.Color1;
		}

		if (mesh.HasSkin)
		{
			meshType |= GlbMeshType.Joints4;
		}

		return meshType;
	}
}

```

`Source/AssetRipper.Export.Modules.Models/VertexColor1Texture8.cs`:

```cs
using SharpGLTF.Geometry.VertexTypes;
using SharpGLTF.Memory;
using SharpGLTF.Schema2;
using System.Numerics;

namespace AssetRipper.Export.Modules.Models;

/// <summary>
/// Defines a Vertex attribute with 1 color and 8 textures.
/// </summary>
internal struct VertexColor1Texture8 : IVertexMaterial, IEquatable<VertexColor1Texture8>
{
	#region constructors

	public VertexColor1Texture8()
	{
	}

	public VertexColor1Texture8(
		Vector4 color = default,
		Vector2 texcoord0 = default,
		Vector2 texcoord1 = default,
		Vector2 texcoord2 = default,
		Vector2 texcoord3 = default,
		Vector2 texcoord4 = default,
		Vector2 texcoord5 = default,
		Vector2 texcoord6 = default,
		Vector2 texcoord7 = default)
	{
		Color = color;
		TexCoord0 = texcoord0;
		TexCoord1 = texcoord1;
		TexCoord2 = texcoord2;
		TexCoord3 = texcoord3;
		TexCoord4 = texcoord4;
		TexCoord5 = texcoord5;
		TexCoord6 = texcoord6;
		TexCoord7 = texcoord7;
	}

	public VertexColor1Texture8(
		Vector2 texcoord0 = default,
		Vector2 texcoord1 = default,
		Vector2 texcoord2 = default,
		Vector2 texcoord3 = default,
		Vector2 texcoord4 = default,
		Vector2 texcoord5 = default,
		Vector2 texcoord6 = default,
		Vector2 texcoord7 = default) : this(default, texcoord0, texcoord1, texcoord2, texcoord3, texcoord4, texcoord5, texcoord6, texcoord7)
	{
	}

	public VertexColor1Texture8(IVertexMaterial src)
	{
		ArgumentNullException.ThrowIfNull(src);
		Color = 0 < src.MaxColors ? src.GetColor(0) : Vector4.One;
		TexCoord0 = 0 < src.MaxTextCoords ? src.GetTexCoord(0) : Vector2.Zero;
		TexCoord1 = 1 < src.MaxTextCoords ? src.GetTexCoord(1) : Vector2.Zero;
		TexCoord2 = 2 < src.MaxTextCoords ? src.GetTexCoord(2) : Vector2.Zero;
		TexCoord3 = 3 < src.MaxTextCoords ? src.GetTexCoord(3) : Vector2.Zero;
		TexCoord4 = 4 < src.MaxTextCoords ? src.GetTexCoord(4) : Vector2.Zero;
		TexCoord5 = 5 < src.MaxTextCoords ? src.GetTexCoord(5) : Vector2.Zero;
		TexCoord6 = 6 < src.MaxTextCoords ? src.GetTexCoord(6) : Vector2.Zero;
		TexCoord7 = 7 < src.MaxTextCoords ? src.GetTexCoord(7) : Vector2.Zero;
	}
	#endregion

	#region data

	public Vector4 Color;
	public Vector2 TexCoord0;
	public Vector2 TexCoord1;
	public Vector2 TexCoord2;
	public Vector2 TexCoord3;
	public Vector2 TexCoord4;
	public Vector2 TexCoord5;
	public Vector2 TexCoord6;
	public Vector2 TexCoord7;

	public readonly int MaxColors => 1;
	public readonly int MaxTextCoords => 8;

	readonly IEnumerable<KeyValuePair<string, AttributeFormat>> IVertexReflection.GetEncodingAttributes()
	{
		yield return new KeyValuePair<string, AttributeFormat>("COLOR_0", new AttributeFormat(DimensionType.VEC4, EncodingType.UNSIGNED_BYTE, true));
		for (int i = 0; i < MaxTextCoords; i++)
		{
			yield return new KeyValuePair<string, AttributeFormat>($"TEXCOORD_{i}", new AttributeFormat(DimensionType.VEC2));
		}
	}

	public readonly override int GetHashCode()
	{
		HashCode hash = new();
		hash.Add(Color);
		hash.Add(TexCoord0);
		hash.Add(TexCoord1);
		hash.Add(TexCoord2);
		hash.Add(TexCoord3);
		hash.Add(TexCoord4);
		hash.Add(TexCoord5);
		hash.Add(TexCoord6);
		hash.Add(TexCoord7);
		return hash.ToHashCode();
	}

	public readonly override bool Equals(object? obj) { return obj is VertexColor1Texture8 other ? Equals(other) : false; }

	public readonly bool Equals(VertexColor1Texture8 other) { return AreEqual(this, other); }

	public static bool operator ==(in VertexColor1Texture8 a, in VertexColor1Texture8 b) { return AreEqual(a, b); }

	public static bool operator !=(in VertexColor1Texture8 a, in VertexColor1Texture8 b) { return !AreEqual(a, b); }

	public static bool AreEqual(in VertexColor1Texture8 a, in VertexColor1Texture8 b)
	{
		return a.Color == b.Color
			&& a.TexCoord0 == b.TexCoord0
			&& a.TexCoord1 == b.TexCoord1
			&& a.TexCoord2 == b.TexCoord2
			&& a.TexCoord3 == b.TexCoord3
			&& a.TexCoord4 == b.TexCoord4
			&& a.TexCoord5 == b.TexCoord5
			&& a.TexCoord6 == b.TexCoord6
			&& a.TexCoord7 == b.TexCoord7
			&& a.MaxColors == b.MaxColors
			&& a.MaxTextCoords == b.MaxTextCoords;
	}

	#endregion

	#region API

	public readonly VertexMaterialDelta Subtract(IVertexMaterial baseValue)
	{
		return new()
		{
			Color0Delta = baseValue.MaxColors > 0 ? Color - baseValue.GetColor(0) : default,
			TexCoord0Delta = baseValue.MaxTextCoords > 0 ? TexCoord0 - baseValue.GetTexCoord(0) : default,
			TexCoord1Delta = baseValue.MaxTextCoords > 1 ? TexCoord1 - baseValue.GetTexCoord(1) : default,
			TexCoord2Delta = baseValue.MaxTextCoords > 2 ? TexCoord2 - baseValue.GetTexCoord(2) : default,
			TexCoord3Delta = baseValue.MaxTextCoords > 3 ? TexCoord3 - baseValue.GetTexCoord(3) : default,
		};
	}
	public void Add(in VertexMaterialDelta delta)
	{
		Color += delta.Color0Delta;
		TexCoord0 += delta.TexCoord0Delta;
		TexCoord1 += delta.TexCoord1Delta;
		TexCoord2 += delta.TexCoord2Delta;
		TexCoord3 += delta.TexCoord3Delta;
	}
	void IVertexMaterial.SetColor(int index, Vector4 color)
	{
		ArgumentOutOfRangeException.ThrowIfNotEqual(index, 0);
		Color = color;
	}
	void IVertexMaterial.SetTexCoord(int index, Vector2 coord)
	{
		switch (index)
		{
			case 0: TexCoord0 = coord; break;
			case 1: TexCoord1 = coord; break;
			case 2: TexCoord2 = coord; break;
			case 3: TexCoord3 = coord; break;
			case 4: TexCoord4 = coord; break;
			case 5: TexCoord5 = coord; break;
			case 6: TexCoord6 = coord; break;
			case 7: TexCoord7 = coord; break;
		}
	}
	public readonly Vector4 GetColor(int index)
	{
		ArgumentOutOfRangeException.ThrowIfNotEqual(index, 0);
		return Color;
	}
	public readonly Vector2 GetTexCoord(int index)
	{
		return index switch
		{
			0 => TexCoord0,
			1 => TexCoord1,
			2 => TexCoord2,
			3 => TexCoord3,
			4 => TexCoord4,
			5 => TexCoord5,
			6 => TexCoord6,
			7 => TexCoord7,
			_ => throw new ArgumentOutOfRangeException(nameof(index)),
		};
	}
	#endregion

}

```

`Source/AssetRipper.Export.Modules.Models/VertexVariable.cs`:

```cs
using SharpGLTF.Geometry.VertexTypes;
using SharpGLTF.Memory;
using SharpGLTF.Schema2;
using System.Numerics;

namespace AssetRipper.Export.Modules.Models;

/// <summary>
/// Defines a Vertex attribute with up to 1 color and up to 8 textures.
/// </summary>
internal struct VertexVariable : IVertexMaterial, IEquatable<VertexVariable>
{
	#region constructors

	public VertexVariable(
		int maxColors,
		int maxTextCoords)
	{
		MaxColors = int.Clamp(maxColors, 0, 1);
		MaxTextCoords = int.Clamp(maxTextCoords, 0, 8);
	}

	public VertexVariable(
		int maxColors,
		int maxTextCoords,
		Vector4 color = default,
		Vector2 texcoord0 = default,
		Vector2 texcoord1 = default,
		Vector2 texcoord2 = default,
		Vector2 texcoord3 = default,
		Vector2 texcoord4 = default,
		Vector2 texcoord5 = default,
		Vector2 texcoord6 = default,
		Vector2 texcoord7 = default)
	{
		Color = color;
		TexCoord0 = texcoord0;
		TexCoord1 = texcoord1;
		TexCoord2 = texcoord2;
		TexCoord3 = texcoord3;
		TexCoord4 = texcoord4;
		TexCoord5 = texcoord5;
		TexCoord6 = texcoord6;
		TexCoord7 = texcoord7;
		MaxColors = int.Clamp(maxColors, 0, 1);
		MaxTextCoords = int.Clamp(maxTextCoords, 0, 8);
	}

	public VertexVariable(
		int maxTextCoords,
		Vector2 texcoord0 = default,
		Vector2 texcoord1 = default,
		Vector2 texcoord2 = default,
		Vector2 texcoord3 = default,
		Vector2 texcoord4 = default,
		Vector2 texcoord5 = default,
		Vector2 texcoord6 = default,
		Vector2 texcoord7 = default) : this(0, maxTextCoords, default, texcoord0, texcoord1, texcoord2, texcoord3, texcoord4, texcoord5, texcoord6, texcoord7)
	{
	}

	public VertexVariable(IVertexMaterial src)
	{
		ArgumentNullException.ThrowIfNull(src);
		Color = 0 < src.MaxColors ? src.GetColor(0) : Vector4.One;
		TexCoord0 = 0 < src.MaxTextCoords ? src.GetTexCoord(0) : Vector2.Zero;
		TexCoord1 = 1 < src.MaxTextCoords ? src.GetTexCoord(1) : Vector2.Zero;
		TexCoord2 = 2 < src.MaxTextCoords ? src.GetTexCoord(2) : Vector2.Zero;
		TexCoord3 = 3 < src.MaxTextCoords ? src.GetTexCoord(3) : Vector2.Zero;
		TexCoord4 = 4 < src.MaxTextCoords ? src.GetTexCoord(4) : Vector2.Zero;
		TexCoord5 = 5 < src.MaxTextCoords ? src.GetTexCoord(5) : Vector2.Zero;
		TexCoord6 = 6 < src.MaxTextCoords ? src.GetTexCoord(6) : Vector2.Zero;
		TexCoord7 = 7 < src.MaxTextCoords ? src.GetTexCoord(7) : Vector2.Zero;
		MaxColors = int.Clamp(src.MaxColors, 0, 1);
		MaxTextCoords = int.Clamp(src.MaxTextCoords, 0, 8);
	}
	#endregion

	#region data

	public Vector4 Color;
	public Vector2 TexCoord0;
	public Vector2 TexCoord1;
	public Vector2 TexCoord2;
	public Vector2 TexCoord3;
	public Vector2 TexCoord4;
	public Vector2 TexCoord5;
	public Vector2 TexCoord6;
	public Vector2 TexCoord7;

	public readonly int MaxColors { get; }
	public readonly int MaxTextCoords { get; }

	readonly IEnumerable<KeyValuePair<string, AttributeFormat>> IVertexReflection.GetEncodingAttributes()
	{
		if (MaxColors == 1)
		{
			yield return new KeyValuePair<string, AttributeFormat>("COLOR_0", new AttributeFormat(DimensionType.VEC4, EncodingType.UNSIGNED_BYTE, true));
		}
		for (int i = 0; i < MaxTextCoords; i++)
		{
			yield return new KeyValuePair<string, AttributeFormat>($"TEXCOORD_{i}", new AttributeFormat(DimensionType.VEC2));
		}
	}

	public readonly override int GetHashCode()
	{
		HashCode hash = new();
		hash.Add(Color);
		hash.Add(TexCoord0);
		hash.Add(TexCoord1);
		hash.Add(TexCoord2);
		hash.Add(TexCoord3);
		hash.Add(TexCoord4);
		hash.Add(TexCoord5);
		hash.Add(TexCoord6);
		hash.Add(TexCoord7);
		hash.Add(MaxColors);
		hash.Add(MaxTextCoords);
		return hash.ToHashCode();
	}

	public readonly override bool Equals(object? obj) { return obj is VertexVariable other ? Equals(other) : false; }

	public readonly bool Equals(VertexVariable other) { return AreEqual(this, other); }

	public static bool operator ==(in VertexVariable a, in VertexVariable b) { return AreEqual(a, b); }

	public static bool operator !=(in VertexVariable a, in VertexVariable b) { return !AreEqual(a, b); }

	public static bool AreEqual(in VertexVariable a, in VertexVariable b)
	{
		return a.Color == b.Color
			&& a.TexCoord0 == b.TexCoord0
			&& a.TexCoord1 == b.TexCoord1
			&& a.TexCoord2 == b.TexCoord2
			&& a.TexCoord3 == b.TexCoord3
			&& a.TexCoord4 == b.TexCoord4
			&& a.TexCoord5 == b.TexCoord5
			&& a.TexCoord6 == b.TexCoord6
			&& a.TexCoord7 == b.TexCoord7
			&& a.MaxColors == b.MaxColors
			&& a.MaxTextCoords == b.MaxTextCoords;
	}

	#endregion

	#region API

	public readonly VertexMaterialDelta Subtract(IVertexMaterial baseValue)
	{
		if (MaxTextCoords <= 4)
		{
			return new()
			{
				Color0Delta = baseValue.MaxColors > 0 ? Color - baseValue.GetColor(0) : default,
				TexCoord0Delta = baseValue.MaxTextCoords > 0 ? TexCoord0 - baseValue.GetTexCoord(0) : default,
				TexCoord1Delta = baseValue.MaxTextCoords > 1 ? TexCoord1 - baseValue.GetTexCoord(1) : default,
				TexCoord2Delta = baseValue.MaxTextCoords > 2 ? TexCoord2 - baseValue.GetTexCoord(2) : default,
				TexCoord3Delta = baseValue.MaxTextCoords > 3 ? TexCoord3 - baseValue.GetTexCoord(3) : default,
			};
		}
		else
		{
			throw new NotSupportedException();
		}
	}
	public void Add(in VertexMaterialDelta delta)
	{
		Color += delta.Color0Delta;
		TexCoord0 += delta.TexCoord0Delta;
		TexCoord1 += delta.TexCoord1Delta;
		TexCoord2 += delta.TexCoord2Delta;
		TexCoord3 += delta.TexCoord3Delta;
	}
	void IVertexMaterial.SetColor(int index, Vector4 color)
	{
		ArgumentOutOfRangeException.ThrowIfNotEqual(index, 0);
		Color = color;
	}
	void IVertexMaterial.SetTexCoord(int index, Vector2 coord)
	{
		switch (index)
		{
			case 0: TexCoord0 = coord; break;
			case 1: TexCoord1 = coord; break;
			case 2: TexCoord2 = coord; break;
			case 3: TexCoord3 = coord; break;
			case 4: TexCoord4 = coord; break;
			case 5: TexCoord5 = coord; break;
			case 6: TexCoord6 = coord; break;
			case 7: TexCoord7 = coord; break;
		}
	}
	public readonly Vector4 GetColor(int index)
	{
		ArgumentOutOfRangeException.ThrowIfNotEqual(index, 0);
		return Color;
	}
	public readonly Vector2 GetTexCoord(int index)
	{
		return index switch
		{
			0 => TexCoord0,
			1 => TexCoord1,
			2 => TexCoord2,
			3 => TexCoord3,
			4 => TexCoord4,
			5 => TexCoord5,
			6 => TexCoord6,
			7 => TexCoord7,
			_ => throw new ArgumentOutOfRangeException(nameof(index)),
		};
	}
	#endregion

}

```

`Source/AssetRipper.Export.Modules.Textures/AssetRipper.Export.Modules.Textures.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.Export.Modules.Textures\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Export.Modules.Textures\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Export\AssetRipper.Export.csproj" />
	</ItemGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.Conversions.Crunch" Version="1.0.3" />
		<PackageReference Include="AssetRipper.Conversions.FastPng" Version="1.1.0" />
		<PackageReference Include="AssetRipper.Conversions.UnityCrunch" Version="1.0.3" />
		<PackageReference Include="AssetRipper.TextureDecoder" Version="2.6.0" />
		<PackageReference Include="AssetRipper.Tpk" Version="1.1.0" />
		<PackageReference Include="StbImageWriteSharp" Version="1.16.7" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Export.Modules.Textures/BmpWriter.cs`:

```cs
using System.Runtime.CompilerServices;

namespace AssetRipper.Export.Modules.Textures;

/// <summary>
/// This is really fast, even in comparison to System.Drawing<br/>
/// It could be even faster if it didn't have to flip the pixels in the y direction
/// </summary>
/// <remarks>
/// <see href="https://en.wikipedia.org/wiki/BMP_file_format"/>
/// </remarks>
internal static class BmpWriter
{
	/*
	static byte[] bmpData = // All values are little-endian
	{
		//14 bytes
		0x42, 0x4D,             // Signature 'BM'
		0x9a, 0x00, 0x00, 0x00, // Size: 154 bytes
		0x00, 0x00,             // Unused
		0x00, 0x00,             // Unused
		0x7a, 0x00, 0x00, 0x00, // Offset to image data, ie 122

		//108 bytes
		0x6c, 0x00, 0x00, 0x00, // DIB header size (108 bytes)
		0x04, 0x00, 0x00, 0x00, // Width (4px)
		0x02, 0x00, 0x00, 0x00, // Height (2px)
		0x01, 0x00,             // Planes (1)
		0x20, 0x00,             // Bits per pixel (32)
		0x03, 0x00, 0x00, 0x00, // Format (bitfield = use bitfields | no compression)
		0x20, 0x00, 0x00, 0x00, // Image raw size (32 bytes)
		0x13, 0x0B, 0x00, 0x00, // Horizontal print resolution (2835 = 72dpi * 39.3701)
		0x13, 0x0B, 0x00, 0x00, // Vertical print resolution (2835 = 72dpi * 39.3701)
		0x00, 0x00, 0x00, 0x00, // Colors in palette (none)
		0x00, 0x00, 0x00, 0x00, // Important colors (0 = all)
		0x00, 0x00, 0xFF, 0x00, // R bitmask (00FF0000)
		0x00, 0xFF, 0x00, 0x00, // G bitmask (0000FF00)
		0xFF, 0x00, 0x00, 0x00, // B bitmask (000000FF)
		0x00, 0x00, 0x00, 0xFF, // A bitmask (FF000000)
		0x42, 0x47, 0x52, 0x73, // sRGB color space
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Unused R entry for color space
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Unused G entry for color space
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Unused B entry for color space
		0x00, 0x00, 0x00, 0x00, // Unused Gamma X entry for color space
		0x00, 0x00, 0x00, 0x00, // Unused Gamma Y entry for color space
		0x00, 0x00, 0x00, 0x00, // Unused Gamma Z entry for color space

		// Image data: 32 bytes
		0xFF, 0x00, 0x00, 0x7F, // Bottom left pixel
		0x00, 0xFF, 0x00, 0x7F,
		0x00, 0x00, 0xFF, 0x7F,
		0xFF, 0xFF, 0xFF, 0x7F, // Bottom right pixel
		0xFF, 0x00, 0x00, 0xFF, // Top left pixel
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF  // Top right pixel
	};
	*/

	public static void WriteBmp(byte[] bgra32Data, int width, int height, Stream stream, bool flip = true)
	{
		ArgumentNullException.ThrowIfNull(bgra32Data);
		ArgumentNullException.ThrowIfNull(stream);
		ArgumentOutOfRangeException.ThrowIfNegativeOrZero(width);
		ArgumentOutOfRangeException.ThrowIfNegativeOrZero(height);
		ThrowIfIncorrectLength(bgra32Data, width, height);

		using BinaryWriter writer = new BinaryWriter(stream);

		//14 bytes
		writer.WriteBytes(0x42, 0x4D); // Signature 'BM'
		writer.Write(GetTotalSize(width, height)); // Size of the file
		writer.WriteZeroBytes(4); // 2 unused shorts
		writer.Write((uint)(14 + (16 + 92))); // offset to image data

		//16 bytes
		writer.Write((uint)108); // DIB header size (108 bytes)
		writer.Write(width); // Width
		writer.Write(height); // Height
		writer.Write((ushort)1); // Planes (1)
		writer.Write((ushort)32); // Bits per pixel (32)

		//92 bytes
		writer.WriteBytes(0x03, 0x00, 0x00, 0x00); // Format (bitfield = use bitfields | no compression)
		writer.Write(GetRawImageSize(width, height)); // Image raw size in bytes
		writer.WriteBytes(0x13, 0x0B, 0x00, 0x00); // Horizontal print resolution (2835 = 72dpi * 39.3701)
		writer.WriteBytes(0x13, 0x0B, 0x00, 0x00); // Vertical print resolution (2835 = 72dpi * 39.3701)
		writer.WriteZeroBytes(4); // Colors in palette (none)
		writer.WriteZeroBytes(4); // Important colors (0 = all)
		writer.WriteBytes(0x00, 0x00, 0xFF, 0x00); // R bitmask (00FF0000)
		writer.WriteBytes(0x00, 0xFF, 0x00, 0x00); // G bitmask (0000FF00)
		writer.WriteBytes(0xFF, 0x00, 0x00, 0x00); // B bitmask (000000FF)
		writer.WriteBytes(0x00, 0x00, 0x00, 0xFF); // A bitmask (FF000000)
		writer.WriteBytes(0x42, 0x47, 0x52, 0x73); // sRGB color space
		writer.WriteZeroBytes(12); // Unused R entry for color space
		writer.WriteZeroBytes(12); // Unused G entry for color space
		writer.WriteZeroBytes(12); // Unused B entry for color space
		writer.WriteZeroBytes(4); // Unused Gamma X entry for color space
		writer.WriteZeroBytes(4); // Unused Gamma Y entry for color space
		writer.WriteZeroBytes(4); // Unused Gamma Z entry for color space

		if (flip)
		{
			writer.WriteFlippedY(bgra32Data, width, height);
		}
		else
		{
			writer.Write(bgra32Data.AsSpan());
		}

		static void ThrowIfIncorrectLength(byte[] bgra32Data, int width, int height, [CallerArgumentExpression(nameof(bgra32Data))] string? paramName = null)
		{
			if (bgra32Data.Length != GetRawImageSize(width, height))
			{
				throw new ArgumentException("Length must match 4 * width * height", paramName);
			}
		}
	}

	private static void WriteFlippedY(this BinaryWriter writer, byte[] data, int width, int height)
	{
		for (int r = height - 1; r >= 0; r--)
		{
			writer.Write(data.AsSpan(r * width * 4, width * 4));
		}
	}

	private static void WriteBytes(this BinaryWriter writer, byte byte0, byte byte1)
	{
		writer.Write(byte0);
		writer.Write(byte1);
	}

	private static void WriteBytes(this BinaryWriter writer, byte byte0, byte byte1, byte byte2, byte byte3)
	{
		writer.Write(byte0);
		writer.Write(byte1);
		writer.Write(byte2);
		writer.Write(byte3);
	}

	private static void WriteZeroBytes(this BinaryWriter writer, int count)
	{
		for (int i = 0; i < count; i++)
		{
			writer.Write((byte)0);
		}
	}

	private static int GetTotalSize(int width, int height)
	{
		return 14 + 108 + GetRawImageSize(width, height);
	}

	private static int GetRawImageSize(int width, int height)
	{
		return 4 * width * height;
	}
}

```

`Source/AssetRipper.Export.Modules.Textures/CrunchHandler.cs`:

```cs
using AssetRipper.Conversions.Crunch;
using AssetRipper.Conversions.UnityCrunch;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.Export.UnityProjects.Textures;

internal static class CrunchHandler
{
	public static bool DecompressCrunch(TextureFormat textureFormat, UnityVersion unityVersion, ReadOnlySpan<byte> data, [NotNullWhen(true)] out byte[]? uncompressedBytes)
	{
		return IsUseUnityCrunch(unityVersion, textureFormat)
			? UnityCrunch.TryDecompress(data, out uncompressedBytes)
			: Crunch.TryDecompress(data, out uncompressedBytes);
	}

	private static bool IsUseUnityCrunch(UnityVersion version, TextureFormat format)
	{
		if (version.GreaterThanOrEquals(2017, 3))
		{
			return true;
		}
		return format is TextureFormat.ETC_RGB4Crunched or TextureFormat.ETC2_RGBA8Crunched;
	}
}

```

`Source/AssetRipper.Export.Modules.Textures/DirectBitmap.cs`:

```cs
using AssetRipper.Export.Configuration;

namespace AssetRipper.Export.Modules.Textures;

public abstract class DirectBitmap
{
	public static DirectBitmap Empty => EmptyDirectBitmap.Instance;

	public int Height { get; }
	public int Width { get; }
	public int Depth { get; }
	public int ByteSize => (int)CalculateByteSize(Width, Height, Depth, PixelSize);
	public Span<byte> Bits => new Span<byte>(Data, 0, ByteSize);
	public abstract int PixelSize { get; }
	protected byte[] Data { get; }
	public bool IsEmpty => Width == 0 || Height == 0 || Depth == 0;

	protected DirectBitmap(int width, int height, int depth)
	{
		ArgumentOutOfRangeException.ThrowIfNegative(width);
		ArgumentOutOfRangeException.ThrowIfNegative(height);
		ArgumentOutOfRangeException.ThrowIfNegative(depth);
		long byteSize = CalculateByteSize(width, height, depth, PixelSize);
		ArgumentOutOfRangeException.ThrowIfGreaterThan(byteSize, Array.MaxLength);
		Width = width;
		Height = height;
		Depth = depth;
		Data = new byte[byteSize];
	}

	protected DirectBitmap(int width, int height, int depth, byte[] data)
	{
		ArgumentOutOfRangeException.ThrowIfNegative(width);
		ArgumentOutOfRangeException.ThrowIfNegative(height);
		ArgumentOutOfRangeException.ThrowIfNegative(depth);
		ValidateLength(width, height, depth, data);

		Width = width;
		Height = height;
		Depth = depth;
		Data = data;

		void ValidateLength(int width, int height, int depth, byte[] data)
		{
			if (data.Length < CalculateByteSize(width, height, depth, PixelSize))
			{
				throw new ArgumentException("Data does not have enough space.", nameof(data));
			}
		}
	}

	public abstract DirectBitmap GetLayer(int layer);

	public abstract void FlipX();

	public abstract void FlipY();

	public abstract void Transpose();

	public void Rotate90()
	{
		Transpose();
		FlipX();
	}

	public void Rotate180()
	{
		FlipX();
		FlipY();
	}

	public void Rotate270()
	{
		FlipX();
		Transpose();
	}

	public DirectBitmap Crop(Range xRange, Range yRange)
	{
		return Crop(xRange, yRange, 0..Depth);
	}

	public abstract DirectBitmap Crop(Range xRange, Range yRange, Range zRange);

	public abstract DirectBitmap DeepClone();

	public void Save(Stream stream, ImageExportFormat format)
	{
		switch (format)
		{
			case ImageExportFormat.Bmp:
				SaveAsBmp(stream);
				break;
			case ImageExportFormat.Exr:
				SaveAsExr(stream);
				break;
			case ImageExportFormat.Hdr:
				SaveAsHdr(stream);
				break;
			case ImageExportFormat.Jpeg:
				SaveAsJpeg(stream);
				break;
			case ImageExportFormat.Png:
				SaveAsPng(stream);
				break;
			case ImageExportFormat.Tga:
				SaveAsTga(stream);
				break;
			default:
				throw new ArgumentOutOfRangeException(nameof(format));
		}
	}

	public abstract void SaveAsBmp(Stream stream);

	public abstract void SaveAsExr(Stream stream);

	public abstract void SaveAsHdr(Stream stream);

	public abstract void SaveAsPng(Stream stream);

	public abstract void SaveAsJpeg(Stream stream);

	public abstract void SaveAsTga(Stream stream);

	private static long CalculateByteSize(int width, int height, int depth, int pixelSize)
	{
		return 1L * width * height * depth * pixelSize;
	}
}

```

`Source/AssetRipper.Export.Modules.Textures/DirectBitmap`1.cs`:

```cs
using AssetRipper.Conversions.FastPng;
using AssetRipper.TextureDecoder.Exr;
using AssetRipper.TextureDecoder.Rgb;
using AssetRipper.TextureDecoder.Rgb.Formats;
using StbImageWriteSharp;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace AssetRipper.Export.Modules.Textures;

public sealed class DirectBitmap<TColor, TChannel> : DirectBitmap
	where TChannel : unmanaged
	where TColor : unmanaged, IColor<TChannel>
{
	private static bool UseFastBmp => true;
	private static readonly ImageWriter imageWriter = new();

	public override int PixelSize => Unsafe.SizeOf<TColor>();
	public Span<TColor> Pixels => MemoryMarshal.Cast<byte, TColor>(Bits);

	public DirectBitmap(int width, int height, int depth = 1) : base(width, height, depth)
	{
	}

	public DirectBitmap(int width, int height, int depth, byte[] data) : base(width, height, depth, data)
	{
	}

	public override DirectBitmap<TColor, TChannel> GetLayer(int layer)
	{
		ArgumentOutOfRangeException.ThrowIfNegative(layer);
		ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(layer, Depth);

		int layerSize = Width * Height;
		byte[] layerData = new byte[layerSize * PixelSize];
		Buffer.BlockCopy(Data, layer * layerSize * PixelSize, layerData, 0, layerSize * PixelSize);

		return new DirectBitmap<TColor, TChannel>(Width, Height, 1, layerData);
	}

	public override void FlipX()
	{
		int totalRows = Height * Depth;
		Span<TColor> pixels = Pixels;
		for (int row = 0; row < totalRows; row += Height)
		{
			Span<TColor> pixelsRow = pixels.Slice(row * Width, Width);
			pixelsRow.Reverse();
		}
	}

	public override void FlipY()
	{
		int totalRows = Height * Depth;
		Span<TColor> pixels = Pixels;
		for (int startingRow = 0; startingRow < totalRows; startingRow += Height)
		{
			int endingRow = startingRow + Height - 1;
			for (int row = startingRow, irow = endingRow; row < irow; row++, irow--)
			{
				Span<TColor> rowTop = pixels.Slice(row * Width, Width);
				Span<TColor> rowBottom = pixels.Slice(irow * Width, Width);
				for (int i = 0; i < Width; i++)
				{
					(rowTop[i], rowBottom[i]) = (rowBottom[i], rowTop[i]);
				}
			}
		}
	}

	public override void Transpose()
	{
		if (Width != Height)
		{
			throw new InvalidOperationException("Only square images can be transposed.");
		}
		int layerSize = Width * Height;
		Span<TColor> pixels = Pixels;
		for (int depthIndex = 0; depthIndex < Depth; depthIndex++)
		{
			int offset = depthIndex * layerSize;
			for (int i = 0; i < layerSize; i++)
			{
				int first = offset + i;
				int ci = i % Width;
				int ri = i / Width;
				int second = offset + ci * Width + ri;
				(pixels[first], pixels[second]) = (pixels[second], pixels[first]);
			}
		}
	}

	public new DirectBitmap<TColor, TChannel> Crop(Range xRange, Range yRange)
	{
		return (DirectBitmap<TColor, TChannel>)base.Crop(xRange, yRange);
	}

	public override DirectBitmap<TColor, TChannel> Crop(Range xRange, Range yRange, Range zRange)
	{
		(int xOffset, int xLength) = xRange.GetOffsetAndLength(Width);
		(int yOffset, int yLength) = yRange.GetOffsetAndLength(Height);
		(int zOffset, int zLength) = zRange.GetOffsetAndLength(Depth);
		if (xLength == Width && yLength == Height && zLength == Depth)
		{
			return DeepClone();
		}
		byte[] croppedData = new byte[xLength * yLength * zLength * PixelSize];
		int layerSize = Width * Height;
		int croppedLayerSize = xLength * yLength;
		for (int z = 0; z < zLength; z++)
		{
			for (int y = 0; y < yLength; y++)
			{
				int sourceIndex = (z + zOffset) * layerSize + (y + yOffset) * Width + xOffset;
				int destinationIndex = z * croppedLayerSize + y * xLength;
				Buffer.BlockCopy(Data, sourceIndex * PixelSize, croppedData, destinationIndex * PixelSize, xLength * PixelSize);
			}
		}
		return new DirectBitmap<TColor, TChannel>(xLength, yLength, zLength, croppedData);
	}

	public override DirectBitmap<TColor, TChannel> DeepClone()
	{
		byte[] data = new byte[Data.Length];
		Buffer.BlockCopy(Data, 0, data, 0, Data.Length);
		return new DirectBitmap<TColor, TChannel>(Width, Height, Depth, data);
	}

	public override void SaveAsBmp(Stream stream)
	{
		if (UseFastBmp)
		{
			if (typeof(TColor) == typeof(ColorBGRA<byte>))
			{
				BmpWriter.WriteBmp(Data, Width, Height * Depth, stream);
			}
			else
			{
				RgbConverter.Convert<TColor, TChannel, ColorBGRA<byte>, byte>(Bits, Width, Height * Depth, out byte[] data);
				BmpWriter.WriteBmp(data, Width, Height * Depth, stream);
			}
		}
		else
		{
			GetDataAndComponentsForSaving(out byte[] data, out ColorComponents components);
			lock (imageWriter)
			{
				imageWriter.WriteBmp(data, Width, Height * Depth, components, stream);
			}
		}
	}

	public override void SaveAsExr(Stream stream)
	{
		ExrWriter.Write<TColor, TChannel>(stream, Width, Height * Depth, Pixels);
	}

	public override void SaveAsHdr(Stream stream)
	{
		GetDataAndComponentsForSaving(out byte[] data, out ColorComponents components);
		lock (imageWriter)
		{
			imageWriter.WriteHdr(data, Width, Height * Depth, components, stream);
		}
	}

	public override void SaveAsJpeg(Stream stream)
	{
		GetDataAndComponentsForSaving(out byte[] data, out ColorComponents components);
		lock (imageWriter)
		{
			imageWriter.WriteJpg(data, Width, Height * Depth, components, stream, default);
		}
	}

	public override void SaveAsPng(Stream stream)
	{
		if (Width > ushort.MaxValue || Height * Depth > ushort.MaxValue)
		{
			// https://github.com/richgel999/fpng/issues/31
			GetDataAndComponentsForSaving(out byte[] data, out ColorComponents components);
			lock (imageWriter)
			{
				imageWriter.WritePng(data, Width, Height * Depth, components, stream);
			}
		}
		else
		{
			byte[] data;

			if (typeof(TColor) == typeof(ColorRGBA<byte>) || typeof(TColor) == typeof(ColorRGB<byte>))
			{
				data = Data;
			}
			else if (TColor.HasAlphaChannel)
			{
				RgbConverter.Convert<TColor, TChannel, ColorRGBA<byte>, byte>(Bits, Width, Height * Depth, out data);
			}
			else
			{
				RgbConverter.Convert<TColor, TChannel, ColorRGB<byte>, byte>(Bits, Width, Height * Depth, out data);
			}
			byte[] result = FPng.EncodeImageToMemory(data, Width, Height * Depth);
			new MemoryStream(result).CopyTo(stream);
		}
	}

	public override void SaveAsTga(Stream stream)
	{
		GetDataAndComponentsForSaving(out byte[] data, out ColorComponents components);
		lock (imageWriter)
		{
			imageWriter.WriteTga(data, Width, Height * Depth, components, stream);
		}
	}

	private void GetDataAndComponentsForSaving(out byte[] data, out ColorComponents components)
	{
		if (typeof(TColor) == typeof(ColorRGBA<byte>))
		{
			data = Data;
			components = ColorComponents.RedGreenBlueAlpha;
		}
		else if (typeof(TColor) == typeof(ColorRGB<byte>))
		{
			data = Data;
			components = ColorComponents.RedGreenBlue;
		}
		else if (TColor.HasAlphaChannel)
		{
			RgbConverter.Convert<TColor, TChannel, ColorRGBA<byte>, byte>(Bits, Width, Height * Depth, out data);
			components = ColorComponents.RedGreenBlueAlpha;
		}
		else
		{
			RgbConverter.Convert<TColor, TChannel, ColorRGB<byte>, byte>(Bits, Width, Height * Depth, out data);
			components = ColorComponents.RedGreenBlue;
		}
	}
}

```

`Source/AssetRipper.Export.Modules.Textures/EmptyDirectBitmap.cs`:

```cs
namespace AssetRipper.Export.Modules.Textures;

internal sealed class EmptyDirectBitmap : DirectBitmap
{
	public static EmptyDirectBitmap Instance { get; } = new();

	private EmptyDirectBitmap() : base(0, 0, 1, [])
	{
	}

	public override int PixelSize => 0;

	public override EmptyDirectBitmap GetLayer(int layer) => this;

	public override void FlipX()
	{
	}

	public override void FlipY()
	{
	}

	public override void Transpose()
	{
	}

	public override EmptyDirectBitmap Crop(Range xRange, Range yRange, Range zRange) => this;

	public override EmptyDirectBitmap DeepClone() => this;

	public override void SaveAsBmp(Stream stream)
	{
	}

	public override void SaveAsExr(Stream stream)
	{
	}

	public override void SaveAsHdr(Stream stream)
	{
	}

	public override void SaveAsPng(Stream stream)
	{
	}

	public override void SaveAsJpeg(Stream stream)
	{
	}

	public override void SaveAsTga(Stream stream)
	{
	}
}

```

`Source/AssetRipper.Export.Modules.Textures/SpriteConverter.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.Modules.Textures;

public static class SpriteConverter
{
	public static bool Supported(ISprite sprite)
	{
		if (sprite.TryGetTexture() is { } texture)
		{
			return texture.CheckAssetIntegrity();
		}
		else if (sprite.SpriteAtlasP is { } atlas)
		{
			return false;
		}
		else
		{
			return false;
		}
	}

	public static bool TryConvertToBitmap(ISprite sprite, out DirectBitmap bitmap)
	{
		if (sprite.TryGetTexture() is { } texture)
		{
			if (!TextureConverter.TryConvertToBitmap(texture, out DirectBitmap textureBitmap))
			{
				return ReturnFalse(out bitmap);
			}

			bitmap = textureBitmap;
			return true;
		}
		else if (sprite.SpriteAtlasP is { } atlas)
		{
			return ReturnFalse(out bitmap);
		}
		else
		{
			return ReturnFalse(out bitmap);
		}
	}

	private static bool ReturnFalse(out DirectBitmap bitmap)
	{
		bitmap = DirectBitmap.Empty;
		return false;
	}
}

```

`Source/AssetRipper.Export.Modules.Textures/TerrainHeatmap.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using AssetRipper.TextureDecoder.Rgb.Formats;

namespace AssetRipper.Export.Modules.Textures;

public static class TerrainHeatmap
{
	public static DirectBitmap GetBitmap(ITerrainData terrain)
	{
		DirectBitmap bitmap = new DirectBitmap<ColorRGBA<byte>, byte>(
			Math.Max(terrain.Heightmap.Width, terrain.Heightmap.Resolution),
			Math.Max(terrain.Heightmap.Height, terrain.Heightmap.Resolution),
			1,
			GetRGBA32Data(terrain));
		bitmap.FlipY();
		return bitmap;
	}

	public static byte[] GetRGBA32Data(ITerrainData terrain)
	{
		AssetList<short> heights = terrain.Heightmap.Heights;
		byte[] result = new byte[heights.Count * 4];
		for (int y = 0; y < heights.Count; y++)
		{
			Color32 color = (Color32)ConvertToColor((float)heights[y] / short.MaxValue);
			result[4 * y] = color.R;
			result[4 * y + 1] = color.G;
			result[4 * y + 2] = color.B;
			result[4 * y + 3] = byte.MaxValue; //small optimization
		}
		return result;
	}

	private static ColorFloat ConvertToColor(float value)
	{
		if (value <= 0f)
		{
			return zero;
		}
		else if (value < q1point)
		{
			return Average(zero, 0f, q1, q1point, value);
		}
		else if (value < q2point)
		{
			return Average(q1, q1point, q2, q2point, value);
		}
		else if (value < q3point)
		{
			return Average(q2, q2point, q3, q3point, value);
		}
		else if (value < 1f)
		{
			return Average(q3, q3point, one, 1f, value);
		}
		else
		{
			return one;
		}
	}

	private static float Normalize(float min, float max, float value)
	{
		if (value <= min)
		{
			return 0f;
		}
		else if (value >= max)
		{
			return 1f;
		}
		else
		{
			return (value - min) / (max - min);
		}
	}

	private static ColorFloat Average(ColorFloat minColor, float min, ColorFloat maxColor, float max, float value)
	{
		float normalized = Normalize(min, max, value);
		return (1 - normalized) * minColor + normalized * maxColor;
	}

	private static readonly ColorFloat zero = new(0, 0, 0.4f, 1);
	private static readonly ColorFloat q1 = new(0, 0, 1, 1);
	private static readonly ColorFloat q2 = new(0, 1, 0, 1);
	private static readonly ColorFloat q3 = new(1, 0, 0, 1);
	private static readonly ColorFloat one = ColorFloat.White;

	private const float q1point = 0.15f;
	private const float q2point = 0.3f;
	private const float q3point = 0.6f;
}

```

`Source/AssetRipper.Export.Modules.Textures/TextureConverter.cs`:

```cs
using AssetRipper.Export.UnityProjects.Textures;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_117;
using AssetRipper.SourceGenerated.Classes.ClassID_187;
using AssetRipper.SourceGenerated.Classes.ClassID_188;
using AssetRipper.SourceGenerated.Classes.ClassID_189;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_89;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.TextureDecoder.Astc;
using AssetRipper.TextureDecoder.Atc;
using AssetRipper.TextureDecoder.Bc;
using AssetRipper.TextureDecoder.Dxt;
using AssetRipper.TextureDecoder.Etc;
using AssetRipper.TextureDecoder.Pvrtc;
using AssetRipper.TextureDecoder.Rgb;
using AssetRipper.TextureDecoder.Rgb.Formats;
using AssetRipper.TextureDecoder.Yuy2;
using System.Runtime.CompilerServices;

namespace AssetRipper.Export.Modules.Textures;

public static class TextureConverter
{
	public static bool TryConvertToBitmap(IImageTexture texture, out DirectBitmap bitmap)
	{
		return texture switch
		{
			ICubemapArray cubemapArray => TryConvertToBitmap(cubemapArray, out bitmap),
			ITexture2DArray texture2DArray => TryConvertToBitmap(texture2DArray, out bitmap),
			ITexture3D texture3D => TryConvertToBitmap(texture3D, out bitmap),
			ITexture2D texture2D => TryConvertToBitmap(texture2D, out bitmap),
			_ => ReturnFalse(out bitmap),
		};

		static bool ReturnFalse(out DirectBitmap bitmap)
		{
			bitmap = DirectBitmap.Empty;
			return false;
		}
	}

	public static bool TryConvertToBitmap(ITexture3D texture, out DirectBitmap bitmap)
	{
		byte[] buffer = texture.GetImageData();
		if (buffer.Length == 0)
		{
			bitmap = DirectBitmap.Empty;
			return false;
		}

		if (!TryGetTextureFormat((GraphicsFormat)texture.Format, out TextureFormat format))
		{
			bitmap = DirectBitmap.Empty;
			return false;
		}

		if (!TryConvertToBitmap(
			format,
			texture.Width,
			texture.Height,
			texture.Depth,
			texture.GetCompleteImageSize(),
			texture.Collection.Version,
			buffer,
			out bitmap))
		{
			return false;
		}

		bitmap.FlipY();

		// despite the name, this packing works for different formats
		if (texture.LightmapFormatE == TextureUsageMode.NormalmapDXT5nm)
		{
			UnpackNormal(bitmap);
		}

		return true;
	}

	public static bool TryConvertToBitmap(ITexture2DArray texture, out DirectBitmap bitmap)
	{
		byte[] buffer = texture.GetImageData();
		if (buffer.Length == 0)
		{
			bitmap = DirectBitmap.Empty;
			return false;
		}

		if (!TryGetTextureFormat((GraphicsFormat)texture.Format, out TextureFormat format))
		{
			bitmap = DirectBitmap.Empty;
			return false;
		}

		if (!TryConvertToBitmap(
			format,
			texture.Width,
			texture.Height,
			texture.Depth,
			texture.GetCompleteImageSize(),
			texture.Collection.Version,
			buffer,
			out bitmap))
		{
			return false;
		}

		bitmap.FlipY();

		return true;
	}

	public static bool TryConvertToBitmap(ICubemapArray texture, out DirectBitmap bitmap)
	{
		byte[] buffer = texture.GetImageData();
		if (buffer.Length == 0)
		{
			bitmap = DirectBitmap.Empty;
			return false;
		}

		if (!TryGetTextureFormat((GraphicsFormat)texture.Format, out TextureFormat format))
		{
			bitmap = DirectBitmap.Empty;
			return false;
		}

		if (!TryConvertToBitmap(
			format,
			texture.Width,
			texture.GetHeight(),
			texture.GetDepth(),
			texture.GetCompleteImageSize(),
			texture.Collection.Version,
			buffer,
			out bitmap))
		{
			return false;
		}

		bitmap.FlipY();// Maybe not needed?

		return true;
	}

	public static bool TryConvertToBitmap(ITexture2D texture, out DirectBitmap bitmap)
	{
		byte[] buffer = texture.GetImageData();
		if (buffer.Length == 0)
		{
			bitmap = DirectBitmap.Empty;
			return false;
		}

		if (!TryConvertToBitmap(
			texture.Format_C28E,
			texture.Width_C28,
			texture.Height_C28,
			texture.ImageCount_C28,
			texture.ActualImageSize,
			texture.Collection.Version,
			buffer,
			out bitmap))
		{
			return false;
		}

		// cubemaps dont need flipping, for some reason
		if (texture is not ICubemap)
		{
			bitmap.FlipY();
		}

		// despite the name, this packing works for different formats
		if (texture.LightmapFormat_C28E == TextureUsageMode.NormalmapDXT5nm)
		{
			UnpackNormal(bitmap);
		}

		return true;
	}

	private static bool TryConvertToBitmap(
		TextureFormat textureFormat,
		int width,
		int height,
		int depth,
		int imageSize,
		UnityVersion version,
		byte[] data,
		out DirectBitmap bitmap)
	{
		return textureFormat switch
		{
			TextureFormat.Alpha8 => TryConvertToBitmap<ColorA<byte>, byte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.ARGB4444 => TryConvertToBitmap<ColorARGB16, byte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGB24 => TryConvertToBitmap<ColorRGB<byte>, byte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGBA32 => TryConvertToBitmap<ColorRGBA<byte>, byte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.ARGB32 => TryConvertToBitmap<ColorARGB<byte>, byte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.ARGBFloat => TryConvertToBitmap<ColorARGB<float>, float>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGB565 => TryConvertToBitmap<ColorRGB16, byte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.BGR24 => TryConvertToBitmap<ColorBGR<byte>, byte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.R16 => TryConvertToBitmap<ColorR<ushort>, ushort>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGBA4444 => TryConvertToBitmap<ColorRGBA16, byte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.BGRA32_14 or TextureFormat.BGRA32_37 => TryConvertToBitmap<ColorBGRA<byte>, byte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RHalf => TryConvertToBitmap<ColorR<Half>, Half>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGHalf => TryConvertToBitmap<ColorRG<Half>, Half>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGBAHalf => TryConvertToBitmap<ColorRGBA<Half>, Half>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RFloat => TryConvertToBitmap<ColorR<float>, float>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGFloat => TryConvertToBitmap<ColorRG<float>, float>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGBAFloat => TryConvertToBitmap<ColorRGBA<float>, float>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGB9e5Float => TryConvertToBitmap<ColorRGB9e5, double>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RG16 => TryConvertToBitmap<ColorRG<byte>, byte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.R8 => TryConvertToBitmap<ColorR<byte>, byte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RG32 => TryConvertToBitmap<ColorRG<ushort>, ushort>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGB48 => TryConvertToBitmap<ColorRGB<ushort>, ushort>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGBA64 => TryConvertToBitmap<ColorRGBA<ushort>, ushort>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.R8_SIGNED => TryConvertToBitmap<ColorR<sbyte>, sbyte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RG16_SIGNED => TryConvertToBitmap<ColorRG<sbyte>, sbyte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGB24_SIGNED => TryConvertToBitmap<ColorRGB<sbyte>, sbyte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGBA32_SIGNED => TryConvertToBitmap<ColorRGBA<sbyte>, sbyte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.R16_SIGNED => TryConvertToBitmap<ColorR<short>, short>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RG32_SIGNED => TryConvertToBitmap<ColorRG<short>, short>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGB48_SIGNED => TryConvertToBitmap<ColorRGB<short>, short>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			TextureFormat.RGBA64_SIGNED => TryConvertToBitmap<ColorRGBA<short>, short>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
			_ => TryConvertToBitmap<ColorRGBA<byte>, byte>(textureFormat, width, height, depth, imageSize, version, data, out bitmap),
		};
	}

	private static bool TryConvertToBitmap<TColor, TChannelValue>(
		TextureFormat textureFormat,
		int width,
		int height,
		int depth,
		int imageSize,
		UnityVersion version,
		byte[] data,
		out DirectBitmap bitmap)
		where TColor : unmanaged, IColor<TChannelValue>
		where TChannelValue : unmanaged
	{
		if (width <= 0 || height <= 0 || depth <= 0)
		{
			Logger.Log(LogType.Error, LogCategory.Export, $"Invalid texture dimensions. Width: {width}, Height: {height}, Depth: {depth}.");
			bitmap = DirectBitmap.Empty;
			return false;
		}

		if (1L * width * height * depth * Unsafe.SizeOf<TColor>() > int.MaxValue)
		{
			Logger.Log(LogType.Error, LogCategory.Export, $"Texture size is too large. Width: {width}, Height: {height}, Depth: {depth}.");
			bitmap = DirectBitmap.Empty;
			return false;
		}

		ReadOnlySpan<byte> uncompressedSpan;
		int bytesPerLayer;
		if (textureFormat.IsCrunched())
		{
			if (CrunchHandler.DecompressCrunch(textureFormat, version, data, out byte[]? decompressedData))
			{
				uncompressedSpan = decompressedData;
				bytesPerLayer = decompressedData.Length / depth;
			}
			else
			{
				bitmap = DirectBitmap.Empty;
				return false;
			}
		}
		else
		{
			if (data.Length == imageSize)
			{
				// This can happen for Texture3D
				// For mips, all 3 dimensions get halved with each mip level, unlike Texture2DArray.
				// https://github.com/AssetRipper/AssetRipper/issues/1886
				bytesPerLayer = -1;
			}
			else if (data.Length < (long)imageSize * depth)
			{
				Logger.Log(LogType.Error, LogCategory.Export, $"Image data length {data.Length} is less than expected {(long)imageSize * depth}. Width: {width}, Height: {height}, Depth: {depth}, Image Size: {imageSize}, Format {textureFormat}.");
				bitmap = DirectBitmap.Empty;
				return false;
			}
			else
			{
				bytesPerLayer = imageSize;
			}
			uncompressedSpan = data;
		}

		bitmap = new DirectBitmap<TColor, TChannelValue>(width, height, depth);
		int outputSize = width * height * bitmap.PixelSize;
		int inputOffset = 0;
		for (int i = 0; i < depth; i++)
		{
			ReadOnlySpan<byte> inputSpan = uncompressedSpan.Slice(inputOffset, int.Max(uncompressedSpan.Length - inputOffset, bytesPerLayer));
			Span<byte> outputSpan = bitmap.Bits.Slice(i * outputSize, outputSize);

			int bytesRead = DecodeTexture<TColor, TChannelValue>(textureFormat, width, height, inputSpan, outputSpan);
			if (bytesRead < 0)
			{
				bitmap = DirectBitmap.Empty;
				return false;
			}

			inputOffset += bytesPerLayer > 0 ? bytesPerLayer : bytesRead;
		}
		return true;
	}

	private static int DecodeTexture<TColor, TChannelValue>(TextureFormat textureFormat, int width, int height, ReadOnlySpan<byte> inputSpan, Span<byte> outputSpan)
		where TColor : unmanaged, IColor<TChannelValue>
		where TChannelValue : unmanaged
	{
		switch (textureFormat)
		{
			//ASTC
			case TextureFormat.ASTC_RGB_4x4:
			case TextureFormat.ASTC_RGBA_4x4:
				return AstcDecoder.DecodeASTC<TColor, TChannelValue>(inputSpan, width, height, 4, 4, outputSpan);

			case TextureFormat.ASTC_RGB_5x5:
			case TextureFormat.ASTC_RGBA_5x5:
				return AstcDecoder.DecodeASTC<TColor, TChannelValue>(inputSpan, width, height, 5, 5, outputSpan);

			case TextureFormat.ASTC_RGB_6x6:
			case TextureFormat.ASTC_RGBA_6x6:
				return AstcDecoder.DecodeASTC<TColor, TChannelValue>(inputSpan, width, height, 6, 6, outputSpan);

			case TextureFormat.ASTC_RGB_8x8:
			case TextureFormat.ASTC_RGBA_8x8:
				return AstcDecoder.DecodeASTC<TColor, TChannelValue>(inputSpan, width, height, 8, 8, outputSpan);

			case TextureFormat.ASTC_RGB_10x10:
			case TextureFormat.ASTC_RGBA_10x10:
				return AstcDecoder.DecodeASTC<TColor, TChannelValue>(inputSpan, width, height, 10, 10, outputSpan);

			case TextureFormat.ASTC_RGB_12x12:
			case TextureFormat.ASTC_RGBA_12x12:
				return AstcDecoder.DecodeASTC<TColor, TChannelValue>(inputSpan, width, height, 12, 12, outputSpan);

			//ATC
			case TextureFormat.ATC_RGB4:
				return AtcDecoder.DecompressAtcRgb4<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.ATC_RGBA8:
				return AtcDecoder.DecompressAtcRgba8<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			//BC
			case TextureFormat.BC4:
				return Bc4.Decompress<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.BC5:
				return Bc5.Decompress<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.BC6H:
				return Bc6h.Decompress<TColor, TChannelValue>(inputSpan, width, height, false, outputSpan);

			case TextureFormat.BC7:
				return Bc7.Decompress<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			//DXT
			case TextureFormat.DXT1:
			case TextureFormat.DXT1Crunched:
				return DxtDecoder.DecompressDXT1<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.DXT3:
				return DxtDecoder.DecompressDXT3<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.DXT5:
			case TextureFormat.DXT5Crunched:
				return DxtDecoder.DecompressDXT5<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			//ETC
			case TextureFormat.ETC_RGB4:
			case TextureFormat.ETC_RGB4_3DS:
			case TextureFormat.ETC_RGB4Crunched:
				return EtcDecoder.DecompressETC<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.EAC_R:
				return EtcDecoder.DecompressEACRUnsigned<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.EAC_R_SIGNED:
				return EtcDecoder.DecompressEACRSigned<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.EAC_RG:
				return EtcDecoder.DecompressEACRGUnsigned<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.EAC_RG_SIGNED:
				return EtcDecoder.DecompressEACRGSigned<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.ETC2_RGB:
				return EtcDecoder.DecompressETC2<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.ETC2_RGBA1:
				return EtcDecoder.DecompressETC2A1<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.ETC2_RGBA8:
			case TextureFormat.ETC_RGBA8_3DS:
			case TextureFormat.ETC2_RGBA8Crunched:
				return EtcDecoder.DecompressETC2A8<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			//PVRTC
			case TextureFormat.PVRTC_RGB2:
			case TextureFormat.PVRTC_RGBA2:
				return PvrtcDecoder.DecompressPVRTC<TColor, TChannelValue>(inputSpan, width, height, true, outputSpan);

			case TextureFormat.PVRTC_RGB4:
			case TextureFormat.PVRTC_RGBA4:
				return PvrtcDecoder.DecompressPVRTC<TColor, TChannelValue>(inputSpan, width, height, false, outputSpan);

			//YUY2
			case TextureFormat.YUY2:
				return Yuy2Decoder.DecompressYUY2<TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			//RGB
			case TextureFormat.Alpha8:
				return RgbConverter.Convert<ColorA<byte>, byte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.ARGB4444:
				return RgbConverter.Convert<ColorARGB16, byte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGBA4444:
				return RgbConverter.Convert<ColorRGBA16, byte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGB565:
				return RgbConverter.Convert<ColorRGB16, byte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.R8:
				return RgbConverter.Convert<ColorR<byte>, byte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RG16:
				return RgbConverter.Convert<ColorRG<byte>, byte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGB24:
				return RgbConverter.Convert<ColorRGB<byte>, byte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGBA32:
				return RgbConverter.Convert<ColorRGBA<byte>, byte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.ARGB32:
				return RgbConverter.Convert<ColorARGB<byte>, byte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.ARGBFloat:
				return RgbConverter.Convert<ColorARGB<float>, float, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.BGR24:
				return RgbConverter.Convert<ColorBGR<byte>, byte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.BGRA32_14:
			case TextureFormat.BGRA32_37:
				return RgbConverter.Convert<ColorBGRA<byte>, byte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.R16:
				return RgbConverter.Convert<ColorR<ushort>, ushort, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RG32:
				return RgbConverter.Convert<ColorRG<ushort>, ushort, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGB48:
				return RgbConverter.Convert<ColorRGB<ushort>, ushort, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGBA64:
				return RgbConverter.Convert<ColorRGBA<ushort>, ushort, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RHalf:
				return RgbConverter.Convert<ColorR<Half>, Half, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGHalf:
				return RgbConverter.Convert<ColorRG<Half>, Half, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGBAHalf:
				return RgbConverter.Convert<ColorRGBA<Half>, Half, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RFloat:
				return RgbConverter.Convert<ColorR<float>, float, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGFloat:
				return RgbConverter.Convert<ColorRG<float>, float, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGBAFloat:
				return RgbConverter.Convert<ColorRGBA<float>, float, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGB9e5Float:
				return RgbConverter.Convert<ColorRGB9e5, double, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.R8_SIGNED:
				return RgbConverter.Convert<ColorR<sbyte>, sbyte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RG16_SIGNED:
				return RgbConverter.Convert<ColorRG<sbyte>, sbyte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGB24_SIGNED:
				return RgbConverter.Convert<ColorRGB<sbyte>, sbyte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGBA32_SIGNED:
				return RgbConverter.Convert<ColorRGBA<sbyte>, sbyte, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.R16_SIGNED:
				return RgbConverter.Convert<ColorR<short>, short, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RG32_SIGNED:
				return RgbConverter.Convert<ColorRG<short>, short, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGB48_SIGNED:
				return RgbConverter.Convert<ColorRGB<short>, short, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			case TextureFormat.RGBA64_SIGNED:
				return RgbConverter.Convert<ColorRGBA<short>, short, TColor, TChannelValue>(inputSpan, width, height, outputSpan);

			default:
				Logger.Log(LogType.Error, LogCategory.Export, $"Unsupported texture format '{textureFormat}'");
				return -1;
		}
	}

	private static bool TryGetTextureFormat(GraphicsFormat graphicsFormat, out TextureFormat format)
	{
		try
		{
			format = graphicsFormat.ToTextureFormat();
			return true;
		}
		catch (NotSupportedException)
		{
			format = default;
			return false;
		}
		catch (ArgumentOutOfRangeException)
		{
			Logger.Log(LogType.Error, LogCategory.Export, $"Unknown GraphicsFormat '{(int)graphicsFormat}'");
			format = default;
			return false;
		}
	}

	private static void UnpackNormal(DirectBitmap bitmap)
	{
		if (bitmap is DirectBitmap<ColorRGBA<byte>, byte> rgbaBitmap)
		{
			UnpackNormal(rgbaBitmap.Pixels);
		}
		else
		{
			Logger.Log(LogType.Warning, LogCategory.Export, "UnpackNormal called on unsupported bitmap format. Only RGBA 32 is supported.");
		}
	}

	private static void UnpackNormal<T>(Span<T> pixels) where T : unmanaged, IColor<byte>
	{
		for (int i = 0; i < pixels.Length; i++)
		{
			// Alpha and red are swapped
			// Blue needs calculated
			pixels[i].GetChannels(out byte a, out byte g, out _, out byte r);

			const double MagnitudeSqr = 255 * 255;
			double vr = r * 2.0 - 255.0;
			double vg = g * 2.0 - 255.0;
			double hypotenuseSqr = double.Min(vr * vr + vg * vg, MagnitudeSqr);
			double vb = double.Sqrt(MagnitudeSqr - hypotenuseSqr);
			double bExact = (vb + 255.0) / 2.0;
			byte b = NumericConversion.Convert<double, byte>(bExact / 255.0);

			pixels[i].SetChannels(r, g, b, a);
		}
	}
}

```

`Source/AssetRipper.Export.Modules.Textures/Usings.cs`:

```cs
global using AssetRipper.Primitives;
global using System;
global using System.Diagnostics.CodeAnalysis;

```

`Source/AssetRipper.Export.PrimaryContent/AssetRipper.Export.PrimaryContent.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.Export.PrimaryContent\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Export.PrimaryContent\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Export.Modules.Audio\AssetRipper.Export.Modules.Audio.csproj" />
		<ProjectReference Include="..\AssetRipper.Export.Modules.Models\AssetRipper.Export.Modules.Models.csproj" />
		<ProjectReference Include="..\AssetRipper.Export\AssetRipper.Export.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Export.PrimaryContent/Audio/AudioContentExtractor.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_83;

namespace AssetRipper.Export.PrimaryContent.Audio;

public sealed class AudioContentExtractor : IContentExtractor
{
	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection)
	{
		if (asset is IAudioClip audioClip && AudioExportCollection.TryCreate(this, audioClip, out AudioExportCollection? audioExportCollection))
		{
			exportCollection = audioExportCollection;
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/Audio/AudioExportCollection.cs`:

```cs
using AssetRipper.Export.Modules.Audio;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_83;

namespace AssetRipper.Export.PrimaryContent.Audio;

public sealed class AudioExportCollection : SingleExportCollection<IAudioClip>
{
	private byte[] data;
	private readonly string extension;

	private AudioExportCollection(AudioContentExtractor contentExtractor, IAudioClip asset, byte[] data, string extension) : base(contentExtractor, asset)
	{
		this.data = data;
		this.extension = extension;
	}

	public static bool TryCreate(AudioContentExtractor contentExtractor, IAudioClip asset, [NotNullWhen(true)] out AudioExportCollection? exportCollection)
	{
		if (AudioClipDecoder.TryDecode(asset, out byte[]? data, out string? extension, out string? message))
		{
			exportCollection = new AudioExportCollection(contentExtractor, asset, data, extension);
			return true;
		}
		else
		{
			Logger.Log(LogType.Warning, LogCategory.Export, message);
			exportCollection = null;
			return false;
		}
	}

	protected override bool ExportInner(string filePath, string dirPath, FileSystem fileSystem)
	{
		if (data.Length > 0)
		{
			fileSystem.File.WriteAllBytes(filePath, data);
			data = []; // Export is only called once, so we can clear the data.
			return true;
		}
		else
		{
			return false;
		}
	}

	protected override string ExportExtension => extension;
}

```

`Source/AssetRipper.Export.PrimaryContent/BinaryAssetContentExtractor.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_128;
using AssetRipper.SourceGenerated.Classes.ClassID_152;
using AssetRipper.SourceGenerated.Classes.ClassID_329;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.PrimaryContent;

public sealed class BinaryAssetContentExtractor : IContentExtractor
{
	public static BinaryAssetContentExtractor Instance { get; } = new();
	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection)
	{
		exportCollection = asset switch
		{
			ITextAsset textAsset => TextAssetExportCollection.Create(textAsset),
			IFont font => FontExportCollection.Create(font),
			IMovieTexture movieTexture => MovieTextureExportCollection.Create(movieTexture),
			IVideoClip videoClip => VideoClipExportCollection.Create(videoClip),
			_ => null,
		};
		return exportCollection is not null;
	}

	private abstract class BinaryAssetExportCollection<T> : SingleExportCollection<T> where T : IUnityObjectBase
	{
		public BinaryAssetExportCollection(T asset) : base(Instance, asset)
		{
		}

		protected override bool ExportInner(string filePath, string dirPath, FileSystem fileSystem)
		{
			ReadOnlySpan<byte> data = Data;
			if (data.Length > 0)
			{
				fileSystem.File.WriteAllBytes(filePath, data);
				return true;
			}
			else
			{
				return false;
			}
		}

		protected abstract ReadOnlySpan<byte> Data { get; }
	}

	private sealed class TextAssetExportCollection : BinaryAssetExportCollection<ITextAsset>
	{
		public TextAssetExportCollection(ITextAsset asset) : base(asset)
		{
		}

		protected override ReadOnlySpan<byte> Data => Asset.Script_C49.Data;

		protected override string ExportExtension => "bytes";

		public static TextAssetExportCollection? Create(ITextAsset asset)
		{
			if (asset.Script_C49.Data.Length > 0)
			{
				return new TextAssetExportCollection(asset);
			}
			return null;
		}
	}

	private sealed class FontExportCollection : BinaryAssetExportCollection<IFont>
	{
		public FontExportCollection(IFont asset) : base(asset)
		{
		}

		protected override ReadOnlySpan<byte> Data => Asset.FontData;

		protected override string ExportExtension => Asset.GetFontExtension();

		public static FontExportCollection? Create(IFont asset)
		{
			if (asset.FontData.Length > 0)
			{
				return new FontExportCollection(asset);
			}
			return null;
		}
	}

	private sealed class MovieTextureExportCollection : BinaryAssetExportCollection<IMovieTexture>
	{
		public MovieTextureExportCollection(IMovieTexture asset) : base(asset)
		{
		}

		protected override ReadOnlySpan<byte> Data => Asset.MovieData ?? [];

		protected override string ExportExtension => "ogv";

		public static MovieTextureExportCollection? Create(IMovieTexture asset)
		{
			if (asset.Has_MovieData() && asset.MovieData.Length > 0)
			{
				return new MovieTextureExportCollection(asset);
			}
			return null;
		}
	}

	private sealed class VideoClipExportCollection : BinaryAssetExportCollection<IVideoClip>
	{
		public VideoClipExportCollection(IVideoClip asset) : base(asset)
		{
		}

		protected override ReadOnlySpan<byte> Data => Asset.GetContent();

		protected override string ExportExtension => Asset.GetExtensionFromPath();

		public static VideoClipExportCollection? Create(IVideoClip asset)
		{
			if (asset.CheckIntegrity())
			{
				return new VideoClipExportCollection(asset);
			}
			return null;
		}
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/DefaultJsonWalker.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.Primitives;
using System.CodeDom.Compiler;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Web;

namespace AssetRipper.Export.PrimaryContent;

public class DefaultJsonWalker : AssetWalker
{
	private readonly StringWriter stringWriter = new(CultureInfo.InvariantCulture) { NewLine = "\n" };
	protected IndentedTextWriter Writer { get; }

	public DefaultJsonWalker()
	{
		Writer = new IndentedTextWriter(stringWriter, "\t");
	}

	public string SerializeEditor(IUnityAssetBase asset)
	{
		Clear();
		asset.WalkEditor(this);
		return stringWriter.ToString();
	}

	public string SerializeRelease(IUnityAssetBase asset)
	{
		Clear();
		asset.WalkRelease(this);
		return stringWriter.ToString();
	}

	public string SerializeStandard(IUnityAssetBase asset)
	{
		Clear();
		asset.WalkStandard(this);
		return stringWriter.ToString();
	}

	private void Clear()
	{
		Writer.Flush();
		stringWriter.GetStringBuilder().Clear();
	}

	public override bool EnterAsset(IUnityAssetBase asset)
	{
		Writer.WriteLine('{');
		Writer.Indent++;
		return true;
	}

	public override void DivideAsset(IUnityAssetBase asset)
	{
		Writer.WriteLine(',');
	}

	public override void ExitAsset(IUnityAssetBase asset)
	{
		Writer.WriteLine();
		Writer.Indent--;
		Writer.Write('}');
	}

	public override bool EnterField(IUnityAssetBase asset, string name)
	{
		Writer.Write(HttpUtility.JavaScriptStringEncode(name, true));
		Writer.Write(": ");
		return true;
	}

	public override bool EnterList<T>(IReadOnlyList<T> list)
	{
		if (list.Count == 0)
		{
			Writer.Write("[]");
			return false;
		}

		Writer.WriteLine('[');
		Writer.Indent++;
		return true;
	}

	public override void DivideList<T>(IReadOnlyList<T> list)
	{
		Writer.WriteLine(',');
	}

	public override void ExitList<T>(IReadOnlyList<T> list)
	{
		Writer.WriteLine();
		Writer.Indent--;
		Writer.Write(']');
	}

	public override bool EnterDictionary<TKey, TValue>(IReadOnlyCollection<KeyValuePair<TKey, TValue>> dictionary)
	{
		if (IsString<TKey>())
		{
			if (dictionary.Count == 0)
			{
				Writer.Write("{}");
				return false;
			}

			Writer.WriteLine('{');
			Writer.Indent++;
		}
		else
		{
			if (dictionary.Count == 0)
			{
				Writer.Write("[]");
				return false;
			}

			Writer.WriteLine('[');
			Writer.Indent++;
		}
		return true;
	}

	public override void DivideDictionary<TKey, TValue>(IReadOnlyCollection<KeyValuePair<TKey, TValue>> dictionary)
	{
		Writer.WriteLine(',');
	}

	public override void ExitDictionary<TKey, TValue>(IReadOnlyCollection<KeyValuePair<TKey, TValue>> dictionary)
	{
		if (IsString<TKey>())
		{
			Writer.WriteLine();
			Writer.Indent--;
			Writer.Write('}');
		}
		else
		{
			Writer.WriteLine();
			Writer.Indent--;
			Writer.Write(']');
		}
	}

	public override bool EnterDictionaryPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		if (IsString<TKey>())
		{
			return true;
		}
		else
		{
			return EnterPair(pair);
		}
	}

	public override void DivideDictionaryPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		if (IsString<TKey>())
		{
			Writer.Write(": ");
		}
		else
		{
			DividePair(pair);
		}
	}

	public override void ExitDictionaryPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		if (IsString<TKey>())
		{
		}
		else
		{
			ExitPair(pair);
		}
	}

	public override bool EnterPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		Writer.WriteLine('{');
		Writer.Indent++;
		Writer.Write("\"Key\": ");
		return true;
	}

	public override void DividePair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		Writer.WriteLine(',');
		Writer.Write("\"Value\": ");
	}

	public override void ExitPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		Writer.WriteLine();
		Writer.Indent--;
		Writer.Write('}');
	}

	public override void VisitPrimitive<T>(T value)
	{
		if (typeof(T) == typeof(byte[]))
		{
			Writer.Write('"');
			Writer.Write(Convert.ToBase64String(Unsafe.As<T, byte[]>(ref value), Base64FormattingOptions.None));
			Writer.Write('"');
		}
		else if (typeof(T) == typeof(string))
		{
			Writer.Write('"');
			Writer.Write(HttpUtility.JavaScriptStringEncode(Unsafe.As<T, string>(ref value)));
			Writer.Write('"');
		}
		else if (typeof(T) == typeof(Utf8String))
		{
			Writer.Write('"');
			Writer.Write(HttpUtility.JavaScriptStringEncode(Unsafe.As<T, Utf8String>(ref value)));
			Writer.Write('"');
		}
		else if (typeof(T) == typeof(bool))
		{
			Writer.Write(Unsafe.As<T, bool>(ref value) ? "true" : "false");
		}
		else if (typeof(T) == typeof(char))
		{
			Writer.Write('"');
			Writer.Write(Unsafe.As<T, char>(ref value));
			Writer.Write('"');
		}
		else if (typeof(T) == typeof(sbyte))
		{
			Writer.Write(Unsafe.As<T, sbyte>(ref value));
		}
		else if (typeof(T) == typeof(byte))
		{
			Writer.Write(Unsafe.As<T, byte>(ref value));
		}
		else if (typeof(T) == typeof(short))
		{
			Writer.Write(Unsafe.As<T, short>(ref value));
		}
		else if (typeof(T) == typeof(ushort))
		{
			Writer.Write(Unsafe.As<T, ushort>(ref value));
		}
		else if (typeof(T) == typeof(int))
		{
			Writer.Write(Unsafe.As<T, int>(ref value));
		}
		else if (typeof(T) == typeof(uint))
		{
			Writer.Write(Unsafe.As<T, uint>(ref value));
		}
		else if (typeof(T) == typeof(long))
		{
			Writer.Write(Unsafe.As<T, long>(ref value));
		}
		else if (typeof(T) == typeof(ulong))
		{
			Writer.Write(Unsafe.As<T, ulong>(ref value));
		}
		else if (typeof(T) == typeof(float))
		{
			Writer.Write(Unsafe.As<T, float>(ref value));
		}
		else if (typeof(T) == typeof(double))
		{
			Writer.Write(Unsafe.As<T, double>(ref value));
		}
		else
		{
			Writer.Write('"');
			Writer.Write(HttpUtility.JavaScriptStringEncode(value?.ToString()));
			Writer.Write('"');
		}
	}

	public override void VisitPPtr<TAsset>(PPtr<TAsset> pptr)
	{
		Writer.Write("{ \"m_FileID\": ");
		Writer.Write(pptr.FileID);
		Writer.Write(", \"m_PathID\": ");
		Writer.Write(pptr.PathID);
		Writer.Write(" }");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
	private static bool IsString<T>() => typeof(T) == typeof(string) || typeof(T) == typeof(Utf8String);
}

```

`Source/AssetRipper.Export.PrimaryContent/DeletedAssets/DeletedAssetsExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Processing;

namespace AssetRipper.Export.PrimaryContent.DeletedAssets;

public sealed class DeletedAssetsExportCollection(DeletedAssetsInformation Asset) : ExportCollectionBase
{
	public override bool Exportable => false;

	public override IEnumerable<IUnityObjectBase> Assets => Asset.DeletedAssets.Append(Asset);

	public override string Name => nameof(DeletedAssetsExportCollection);

	public override IContentExtractor ContentExtractor => DeletedAssetsExporter.Instance;

	public override bool Contains(IUnityObjectBase asset)
	{
		return ReferenceEquals(Asset, asset) || Asset.DeletedAssets.Contains(asset);
	}

	public override bool Export(string projectDirectory, FileSystem fileSystem)
	{
		throw new NotSupportedException();
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/DeletedAssets/DeletedAssetsExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Processing;

namespace AssetRipper.Export.PrimaryContent.DeletedAssets;

public sealed class DeletedAssetsExporter : IContentExtractor
{
	public static DeletedAssetsExporter Instance { get; } = new();
	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection)
	{
		if (asset.MainAsset is DeletedAssetsInformation infoAsset)
		{
			exportCollection = new DeletedAssetsExportCollection(infoAsset);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/EmptyContentExtractor.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Export.PrimaryContent;

public sealed class EmptyContentExtractor : IContentExtractor
{
	public static EmptyContentExtractor Instance { get; } = new();
	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection)
	{
		exportCollection = EmptyExportCollection.Instance;
		return true;
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/EmptyExportCollection.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Export.PrimaryContent;

public sealed class EmptyExportCollection : ExportCollectionBase
{
	public static EmptyExportCollection Instance { get; } = new();
	public override bool Contains(IUnityObjectBase asset) => false;
	public override bool Export(string projectDirectory, FileSystem fileSystem) => true;
	public override IContentExtractor ContentExtractor => throw new NotSupportedException();
	public override IEnumerable<IUnityObjectBase> Assets => [];
	public override string Name => nameof(EmptyExportCollection);
	public override bool Exportable => false;
}

```

`Source/AssetRipper.Export.PrimaryContent/ExportCollectionBase.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Export.PrimaryContent;

public abstract class ExportCollectionBase
{
	public abstract bool Contains(IUnityObjectBase asset);
	public abstract bool Export(string projectDirectory, FileSystem fileSystem);
	protected void ExportAsset(IUnityObjectBase asset, string path, string name, FileSystem fileSystem)
	{
		if (!fileSystem.Directory.Exists(path))
		{
			fileSystem.Directory.Create(path);
		}

		string fullName = $"{name}.{ExportExtension}";
		string uniqueName = fileSystem.GetUniqueName(path, fullName, FileSystem.MaxFileNameLength);
		string filePath = fileSystem.Path.Join(path, uniqueName);
		ContentExtractor.Export(asset, filePath, fileSystem);
	}

	protected string GetUniqueFileName(IUnityObjectBase asset, string dirPath, FileSystem fileSystem)
	{
		string fileName = asset.GetBestName();
		fileName = FileSystem.RemoveCloneSuffixes(fileName);
		fileName = FileSystem.RemoveInstanceSuffixes(fileName);
		fileName = fileName.Trim();
		if (string.IsNullOrEmpty(fileName))
		{
			fileName = asset.ClassName;
		}
		else
		{
			fileName = FileSystem.FixInvalidFileNameCharacters(fileName);
		}

		fileName = $"{fileName}.{ExportExtension}";
		return GetUniqueFileName(dirPath, fileName, fileSystem);
	}

	protected virtual string ExportExtension => "asset";

	protected static string GetUniqueFileName(string directoryPath, string fileName, FileSystem fileSystem)
	{
		return fileSystem.GetUniqueName(directoryPath, fileName, FileSystem.MaxFileNameLength);
	}

	public abstract IContentExtractor ContentExtractor { get; }
	public abstract IEnumerable<IUnityObjectBase> Assets { get; }
	public virtual IEnumerable<IUnityObjectBase> ExportableAssets => Assets;
	public virtual bool Exportable => true;
	public abstract string Name { get; }
}

```

`Source/AssetRipper.Export.PrimaryContent/IContentExtractor.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Export.PrimaryContent;

public interface IContentExtractor
{
	bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection);
	bool Export(IUnityObjectBase asset, string filePath, FileSystem fileSystem) => Export([asset], filePath, fileSystem);
	bool Export(IEnumerable<IUnityObjectBase> assets, string filePath, FileSystem fileSystem) => throw new NotSupportedException();
}

```

`Source/AssetRipper.Export.PrimaryContent/JsonContentExtractor.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using System.Web;

namespace AssetRipper.Export.PrimaryContent;

public class JsonContentExtractor : IContentExtractor
{
	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection)
	{
		exportCollection = new JsonExportCollection(this, asset);
		return true;
	}

	public bool Export(IUnityObjectBase asset, string filePath, FileSystem fileSystem)
	{
		// Todo: make this use a stream instead of a string for better performance.
		string json = new JsonWalker(asset.Collection).SerializeStandard(asset);
		fileSystem.File.WriteAllText(filePath, json);
		return true;
	}

	private sealed class JsonExportCollection : SingleExportCollection<IUnityObjectBase>
	{
		public JsonExportCollection(IContentExtractor contentExtractor, IUnityObjectBase asset) : base(contentExtractor, asset)
		{
		}

		protected override string ExportExtension => "json";
	}

	private sealed class JsonWalker(AssetCollection collection) : DefaultJsonWalker
	{
		public override void VisitPPtr<TAsset>(PPtr<TAsset> pptr)
		{
			AssetCollection? targetCollection = pptr.FileID >= 0 && pptr.FileID < collection.Dependencies.Count
				? collection.Dependencies[pptr.FileID]
				: null;

			if (targetCollection is null)
			{
				base.VisitPPtr(pptr);
			}
			else
			{
				Writer.Write("{ \"m_Collection\": \"");
				Writer.Write(HttpUtility.JavaScriptStringEncode(collection.Name));
				Writer.Write("\", \"m_PathID\": ");
				Writer.Write(pptr.PathID);
				Writer.Write(" }");
			}
		}
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/Models/GlbExportCollection.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Export.PrimaryContent.Models;

public sealed class GlbExportCollection : SingleExportCollection<IUnityObjectBase>
{
	public GlbExportCollection(IContentExtractor assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
	{
	}

	protected override string ExportExtension => "glb";
}

```

`Source/AssetRipper.Export.PrimaryContent/Models/GlbMeshExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Modules.Models;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Extensions;
using SharpGLTF.Scenes;

namespace AssetRipper.Export.PrimaryContent.Models;

public sealed class GlbMeshExporter : IContentExtractor
{
	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection)
	{
		if (asset is IMesh mesh && mesh.IsSet())
		{
			exportCollection = new GlbExportCollection(this, asset);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public bool Export(IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		SceneBuilder sceneBuilder = GlbMeshBuilder.Build((IMesh)asset);
		using Stream fileStream = fileSystem.File.Create(path);
		if (GlbWriter.TryWrite(sceneBuilder, fileStream, out string? errorMessage))
		{
			return true;
		}
		else
		{
			Logger.Error(LogCategory.Export, errorMessage);
			return false;
		}
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/Models/GlbModelExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Modules.Models;
using AssetRipper.Import.Logging;
using AssetRipper.Processing.Prefabs;
using SharpGLTF.Scenes;

namespace AssetRipper.Export.PrimaryContent.Models;

public class GlbModelExporter : IContentExtractor
{
	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection)
	{
		switch (asset.MainAsset)
		{
			case SceneHierarchyObject sceneHierarchyObject:
				exportCollection = new GlbSceneModelExportCollection(this, sceneHierarchyObject);
				return true;
			case PrefabHierarchyObject prefabHierarchyObject:
				exportCollection = new GlbPrefabModelExportCollection(this, prefabHierarchyObject);
				return true;
			default:
				exportCollection = null;
				return false;
		}
	}

	public bool Export(IEnumerable<IUnityObjectBase> assets, string path, FileSystem fileSystem)
	{
		return ExportModel(assets, path, false, fileSystem); //Called by the prefab exporter
	}

	public static bool ExportModel(IEnumerable<IUnityObjectBase> assets, string path, bool isScene, FileSystem fileSystem)
	{
		SceneBuilder sceneBuilder = GlbLevelBuilder.Build(assets, isScene);
		using Stream fileStream = fileSystem.File.Create(path);
		if (GlbWriter.TryWrite(sceneBuilder, fileStream, out string? errorMessage))
		{
			return true;
		}
		else
		{
			Logger.Error(LogCategory.Export, errorMessage);
			return false;
		}
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/Models/GlbNavMeshExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;
using AssetRipper.Export.Modules.Models;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_238;
using AssetRipper.SourceGenerated.Subclasses.HeightMeshData;
using AssetRipper.SourceGenerated.Subclasses.Vector3f;
using SharpGLTF.Geometry;
using SharpGLTF.Geometry.VertexTypes;
using SharpGLTF.Materials;
using SharpGLTF.Scenes;
using System.Diagnostics;
using System.Numerics;

namespace AssetRipper.Export.PrimaryContent.Models;

public sealed class GlbNavMeshExporter : IContentExtractor
{
	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection)
	{
		if (asset is INavMeshData { HeightMeshes: not null })
		{
			exportCollection = new GlbExportCollection(this, asset);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public bool Export(IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		SceneBuilder sceneBuilder = new();
		AddAssetToSceneBuilder(sceneBuilder, (INavMeshData)asset);
		using Stream fileStream = fileSystem.File.Create(path);
		if (GlbWriter.TryWrite(sceneBuilder, fileStream, out string? errorMessage))
		{
			return true;
		}
		else
		{
			Logger.Error(LogCategory.Export, errorMessage);
			return false;
		}
	}

	private static void AddAssetToSceneBuilder(SceneBuilder sceneBuilder, INavMeshData asset)
	{
		MaterialBuilder material = new MaterialBuilder("DefaultMaterial");
		MeshBuilder<VertexPosition, VertexEmpty, VertexEmpty> meshBuilder = new();
		PrimitiveBuilder<MaterialBuilder, VertexPosition, VertexEmpty, VertexEmpty> primitiveBuilder = meshBuilder.UsePrimitive(material);

		Debug.Assert(asset.HeightMeshes != null);
		foreach (IHeightMeshData heightMeshData in asset.HeightMeshes)
		{
			AssetList<int> indices = heightMeshData.Indices;
			if (indices.Count % 3 != 0)
			{
				throw new Exception("Height mesh must be triangles.");
			}

			AssetList<Vector3f> vertices = heightMeshData.Vertices;

			for (int i = 0; i < indices.Count; i += 3)
			{
				primitiveBuilder.AddTriangle(
					FromVector(vertices[indices[i + 2]]),
					FromVector(vertices[indices[i + 1]]),
					FromVector(vertices[indices[i]]));
			}
		}

		NodeBuilder nodeBuilder = new NodeBuilder(asset.Name);
		sceneBuilder.AddRigidMesh(meshBuilder, nodeBuilder);
	}

	private static VertexBuilder<VertexPosition, VertexEmpty, VertexEmpty> FromVector(Vector3f vector)
	{
		return new VertexBuilder<VertexPosition, VertexEmpty, VertexEmpty>(new Vector3(-vector.X, vector.Y, vector.Z));
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/Models/GlbPrefabModelExportCollection.cs`:

```cs
using AssetRipper.Processing.Prefabs;

namespace AssetRipper.Export.PrimaryContent.Models;

public sealed class GlbPrefabModelExportCollection : MultipleExportCollection<PrefabHierarchyObject>
{
	public GlbPrefabModelExportCollection(GlbModelExporter assetExporter, PrefabHierarchyObject asset) : base(assetExporter, asset)
	{
		AddAssets(asset.Assets);
	}

	protected override string ExportExtension => "glb";
}

```

`Source/AssetRipper.Export.PrimaryContent/Models/GlbSceneModelExportCollection.cs`:

```cs
using AssetRipper.Processing.Prefabs;

namespace AssetRipper.Export.PrimaryContent.Models;

public sealed class GlbSceneModelExportCollection : MultipleExportCollection<SceneHierarchyObject>
{
	public GlbSceneModelExportCollection(GlbModelExporter assetExporter, SceneHierarchyObject asset) : base(assetExporter, asset)
	{
		AddAssets(asset.Assets);
	}

	protected override string ExportExtension => "glb";
}

```

`Source/AssetRipper.Export.PrimaryContent/Models/GlbTerrainExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Modules.Models;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using SharpGLTF.Scenes;

namespace AssetRipper.Export.PrimaryContent.Models;

public sealed class GlbTerrainExporter : IContentExtractor
{
	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection)
	{
		if (asset is ITerrainData)
		{
			exportCollection = new GlbExportCollection(this, asset);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public bool Export(IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		SceneBuilder sceneBuilder = GlbTerrainBuilder.Build((ITerrainData)asset);
		using Stream fileStream = fileSystem.File.Create(path);
		if (GlbWriter.TryWrite(sceneBuilder, fileStream, out string? errorMessage))
		{
			return true;
		}
		else
		{
			Logger.Error(LogCategory.Export, errorMessage);
			return false;
		}
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/MultipleExportCollection.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Export.PrimaryContent;

public class MultipleExportCollection<T> : SingleExportCollection<T> where T : IUnityObjectBase
{
	public MultipleExportCollection(IContentExtractor contentExtractor, T asset) : base(contentExtractor, asset)
	{
	}

	protected override bool ExportInner(string filePath, string dirPath, FileSystem fileSystem)
	{
		return ContentExtractor.Export(Assets, filePath, fileSystem);
	}

	public void AddAsset(IUnityObjectBase asset)
	{
		if (!ReferenceEquals(asset, Asset))
		{
			secondaryAssets.Add(asset);
		}
	}

	public void AddAssets(IEnumerable<IUnityObjectBase> assets)
	{
		foreach (IUnityObjectBase asset in assets)
		{
			AddAsset(asset);
		}
	}

	public override bool Contains(IUnityObjectBase asset)
	{
		return base.Contains(asset) || secondaryAssets.Contains(asset);
	}

	private readonly HashSet<IUnityObjectBase> secondaryAssets = new();

	public override IEnumerable<IUnityObjectBase> Assets
	{
		get
		{
			yield return Asset;
			foreach (IUnityObjectBase asset in secondaryAssets)
			{
				yield return asset;
			}
		}
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/PrimaryContentExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Export.Configuration;
using AssetRipper.Export.PrimaryContent.Audio;
using AssetRipper.Export.PrimaryContent.DeletedAssets;
using AssetRipper.Export.PrimaryContent.Models;
using AssetRipper.Export.PrimaryContent.Scripts;
using AssetRipper.Export.PrimaryContent.Textures;
using AssetRipper.Import.Configuration;
using AssetRipper.Import.Logging;
using AssetRipper.Processing;
using AssetRipper.Processing.Prefabs;
using AssetRipper.Processing.Textures;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1032;
using AssetRipper.SourceGenerated.Classes.ClassID_1101;
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_1107;
using AssetRipper.SourceGenerated.Classes.ClassID_1109;
using AssetRipper.SourceGenerated.Classes.ClassID_111;
using AssetRipper.SourceGenerated.Classes.ClassID_1111;
using AssetRipper.SourceGenerated.Classes.ClassID_1120;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Classes.ClassID_128;
using AssetRipper.SourceGenerated.Classes.ClassID_150;
using AssetRipper.SourceGenerated.Classes.ClassID_152;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using AssetRipper.SourceGenerated.Classes.ClassID_189;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_206;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_221;
using AssetRipper.SourceGenerated.Classes.ClassID_238;
using AssetRipper.SourceGenerated.Classes.ClassID_3;
using AssetRipper.SourceGenerated.Classes.ClassID_329;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using AssetRipper.SourceGenerated.Classes.ClassID_72;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Classes.ClassID_90;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Classes.ClassID_93;
using AssetRipper.SourceGenerated.Classes.ClassID_95;

namespace AssetRipper.Export.PrimaryContent;

public sealed class PrimaryContentExporter
{
	private readonly ObjectHandlerStack<IContentExtractor> exporters = new();
	private readonly GameData gameData;

	private PrimaryContentExporter(GameData gameData)
	{
		this.gameData = gameData;
	}

	public void RegisterHandler<T>(IContentExtractor handler, bool allowInheritance = true) where T : IUnityObjectBase
	{
		exporters.OverrideHandler(typeof(T), handler, allowInheritance);
	}

	public void RegisterHandler(Type type, IContentExtractor handler, bool allowInheritance = true)
	{
		exporters.OverrideHandler(type, handler, allowInheritance);
	}

	public static PrimaryContentExporter CreateDefault(GameData gameData, FullConfiguration settings)
	{
		PrimaryContentExporter exporter = new(gameData);
		exporter.RegisterDefaultHandlers(settings);
		return exporter;
	}

	private void RegisterDefaultHandlers(FullConfiguration settings)
	{
		RegisterHandler<IUnityObjectBase>(new JsonContentExtractor());

		RegisterEmptyHandler<IAnimation>();
		RegisterEmptyHandler<IAnimationClip>();
		RegisterEmptyHandler<IAnimator>();
		RegisterEmptyHandler<IAnimatorController>();
		RegisterEmptyHandler<IAnimatorOverrideController>();
		RegisterEmptyHandler<IAnimatorState>();
		RegisterEmptyHandler<IAnimatorStateMachine>();
		RegisterEmptyHandler<IAnimatorStateTransition>();
		RegisterEmptyHandler<IAnimatorTransition>();
		RegisterEmptyHandler<IAnimatorTransitionBase>();
		RegisterEmptyHandler<IAvatar>();
		RegisterEmptyHandler<IBlendTree>();
		RegisterEmptyHandler<IComponent>();
		RegisterEmptyHandler<IComputeShader>();
		RegisterEmptyHandler<ILightingDataAsset>();
		RegisterEmptyHandler<IMaterial>();
		RegisterEmptyHandler<IPreloadData>();
		RegisterEmptyHandler<IRuntimeAnimatorController>();
		RegisterEmptyHandler<ISceneAsset>();
		RegisterEmptyHandler<SpriteInformationObject>();

		GlbModelExporter modelExporter = new();
		RegisterHandler<GameObjectHierarchyObject>(modelExporter);
		RegisterHandler<IGameObject>(modelExporter);
		RegisterHandler<IComponent>(modelExporter);
		RegisterHandler<ILevelGameManager>(modelExporter);

		RegisterHandler<IMesh>(new GlbMeshExporter());

		RegisterHandler<INavMeshData>(new GlbNavMeshExporter());
		RegisterHandler<ITerrainData>(new GlbTerrainExporter());

		RegisterHandler<ITextAsset>(BinaryAssetContentExtractor.Instance);
		RegisterHandler<IFont>(BinaryAssetContentExtractor.Instance);
		RegisterHandler<IMovieTexture>(BinaryAssetContentExtractor.Instance);
		RegisterHandler<IVideoClip>(BinaryAssetContentExtractor.Instance);

		RegisterHandler<IAudioClip>(new AudioContentExtractor());

		RegisterHandler<IImageTexture>(new TextureExporter(settings.ExportSettings.ImageExportFormat));

		RegisterHandler<IMonoScript>(new ScriptContentExtractor(gameData.AssemblyManager, settings.ExportSettings.ScriptLanguageVersion.ToCSharpLanguageVersion(gameData.ProjectVersion)));

		// Deleted assets
		// This must be the last handler
		RegisterHandler<IUnityObjectBase>(DeletedAssetsExporter.Instance);
	}

	public void Export(GameBundle fileCollection, FullConfiguration settings, FileSystem fileSystem)
	{
		List<ExportCollectionBase> collections = CreateCollections(fileCollection);

		for (int i = 0; i < collections.Count; i++)
		{
			ExportCollectionBase collection = collections[i];
			if (collection.Exportable)
			{
				Logger.Info(LogCategory.ExportProgress, $"({i + 1}/{collections.Count}) Exporting '{collection.Name}'");
				bool exportedSuccessfully = collection.Export(settings.ExportRootPath, fileSystem);
				if (!exportedSuccessfully)
				{
					Logger.Warning(LogCategory.ExportProgress, $"Failed to export '{collection.Name}'");
				}
			}
		}
	}

	private List<ExportCollectionBase> CreateCollections(GameBundle fileCollection)
	{
		List<ExportCollectionBase> collections = new();
		HashSet<IUnityObjectBase> queued = new();

		foreach (IUnityObjectBase asset in fileCollection.FetchAssets())
		{
			if (!queued.Add(asset))
			{
				// Skip duplicates
				continue;
			}

			ExportCollectionBase collection = CreateCollection(asset);
			if (collection is EmptyExportCollection)
			{
				// Skip empty collections. The asset has already been added to the hash set.
				continue;
			}

			foreach (IUnityObjectBase element in collection.Assets)
			{
				queued.Add(element);
			}
			collections.Add(collection);
		}

		return collections;
	}

	private ExportCollectionBase CreateCollection(IUnityObjectBase asset)
	{
		foreach (IContentExtractor exporter in exporters.GetHandlerStack(asset.GetType()))
		{
			if (exporter.TryCreateCollection(asset, out ExportCollectionBase? collection))
			{
				return collection;
			}
		}
		throw new Exception($"There is no exporter that can handle '{asset}'");
	}

	private void RegisterEmptyHandler<T>() where T : IUnityObjectBase
	{
		RegisterHandler<T>(EmptyContentExtractor.Instance);
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/Scripts/ScriptContentExtractor.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using ICSharpCode.Decompiler.CSharp;

namespace AssetRipper.Export.PrimaryContent.Scripts;

public sealed class ScriptContentExtractor : IContentExtractor
{
	public IAssemblyManager AssemblyManager { get; }
	public LanguageVersion LanguageVersion { get; }
	private bool first = true;
	public ScriptContentExtractor(IAssemblyManager assemblyManager, LanguageVersion languageVersion = LanguageVersion.Latest)
	{
		AssemblyManager = assemblyManager;
		LanguageVersion = languageVersion;
	}

	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection)
	{
		if (asset is IMonoScript)
		{
			exportCollection = first ? new ScriptExportCollection(this, LanguageVersion) : EmptyExportCollection.Instance;
			first = false;
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/Scripts/ScriptExportCollection.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Assets;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using ICSharpCode.Decompiler;
using ICSharpCode.Decompiler.CSharp;
using ICSharpCode.Decompiler.CSharp.ProjectDecompiler;
using ICSharpCode.Decompiler.Metadata;

namespace AssetRipper.Export.PrimaryContent.Scripts;

public sealed class ScriptExportCollection : ExportCollectionBase
{
	public ScriptExportCollection(ScriptContentExtractor contentExtractor, LanguageVersion languageVersion = LanguageVersion.Latest)
	{
		ContentExtractor = contentExtractor;
		LanguageVersion = languageVersion;
	}

	public override IContentExtractor ContentExtractor { get; }

	public LanguageVersion LanguageVersion { get; }

	public override IEnumerable<IUnityObjectBase> Assets => [];

	public override string Name => nameof(ScriptExportCollection);

	public override bool Contains(IUnityObjectBase asset) => asset is IMonoScript;

	public override bool Export(string projectDirectory, FileSystem fileSystem)
	{
		IAssemblyManager assemblyManager = ((ScriptContentExtractor)ContentExtractor).AssemblyManager;

		string assemblyDirectory = fileSystem.Path.Join(projectDirectory, "Assemblies");
		fileSystem.Directory.Create(assemblyDirectory);

		//Export assemblies
		List<string> assemblyPaths = new();
		foreach (AssemblyDefinition assembly in assemblyManager.GetAssemblies())
		{
			Stream stream = assemblyManager.GetStreamForAssembly(assembly);
			stream.Position = 0;

			//Write assembly
			{
				string assemblyPath = fileSystem.Path.Join(assemblyDirectory, assembly.Name + ".dll");
				assemblyPaths.Add(assemblyPath);
				using Stream fileStream = fileSystem.File.Create(assemblyPath);
				stream.CopyTo(fileStream);
				stream.Position = 0;
			}
		}

		//Decompile scripts
		string scriptDirectory = fileSystem.Path.Join(projectDirectory, "Scripts");
		foreach (string assemblyPath in assemblyPaths)
		{
			string assemblyName = fileSystem.Path.GetFileNameWithoutExtension(assemblyPath);
			string outputDirectory = fileSystem.Path.Join(scriptDirectory, assemblyName);
			fileSystem.Directory.Create(outputDirectory);

			DecompilerSettings settings = new();

			settings.SetLanguageVersion(LanguageVersion);

			settings.AlwaysShowEnumMemberValues = true;
			settings.ShowXmlDocumentation = true;

			settings.UseNestedDirectoriesForNamespaces = true;

			WholeProjectDecompiler decompiler = new(settings, new UniversalAssemblyResolver(assemblyPath, false, null), null, null, null);
			PEFile file = new(assemblyPath);
			decompiler.DecompileProject(file, outputDirectory);
		}

		return true;
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/SingleExportCollection.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Export.PrimaryContent;

public class SingleExportCollection<T> : ExportCollectionBase where T : IUnityObjectBase
{
	public SingleExportCollection(IContentExtractor contentExtractor, T asset)
	{
		ContentExtractor = contentExtractor ?? throw new ArgumentNullException(nameof(contentExtractor));
		Asset = asset ?? throw new ArgumentNullException(nameof(asset));
	}

	public override bool Export(string projectDirectory, FileSystem fileSystem)
	{
		string subPath = fileSystem.Path.Join(projectDirectory, FileSystem.FixInvalidPathCharacters(Asset.GetBestDirectory()));
		string fileName = GetUniqueFileName(Asset, subPath, fileSystem);

		fileSystem.Directory.Create(subPath);

		string filePath = fileSystem.Path.Join(subPath, fileName);
		return ExportInner(filePath, projectDirectory, fileSystem);
	}

	public override bool Contains(IUnityObjectBase asset)
	{
		return Asset.AssetInfo == asset.AssetInfo;
	}

	/// <summary>
	/// 
	/// </summary>
	/// <param name="container"></param>
	/// <param name="filePath">The full path to the exported asset destination</param>
	/// <param name="dirPath">The full path to the project export directory</param>
	/// <returns>True if export was successful, false otherwise</returns>
	protected virtual bool ExportInner(string filePath, string dirPath, FileSystem fileSystem)
	{
		return ContentExtractor.Export(Asset, filePath, fileSystem);
	}

	public override IContentExtractor ContentExtractor { get; }
	public override IEnumerable<IUnityObjectBase> Assets
	{
		get { yield return Asset; }
	}
	public override string Name => Asset.GetBestName();
	public T Asset { get; }
}

```

`Source/AssetRipper.Export.PrimaryContent/Textures/TerrainHeatmapExportCollection.cs`:

```cs
using AssetRipper.Export.Configuration;
using AssetRipper.SourceGenerated.Classes.ClassID_156;

namespace AssetRipper.Export.PrimaryContent.Textures;

public sealed class TerrainHeatmapExportCollection : SingleExportCollection<ITerrainData>
{
	public TerrainHeatmapExportCollection(TerrainHeatmapExporter assetExporter, ITerrainData asset) : base(assetExporter, asset)
	{
	}

	protected override string ExportExtension => ((TerrainHeatmapExporter)ContentExtractor).ImageFormat.GetFileExtension();
}

```

`Source/AssetRipper.Export.PrimaryContent/Textures/TerrainHeatmapExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Configuration;
using AssetRipper.Export.Modules.Textures;
using AssetRipper.SourceGenerated.Classes.ClassID_156;

namespace AssetRipper.Export.PrimaryContent.Textures;

public sealed class TerrainHeatmapExporter : IContentExtractor
{
	public ImageExportFormat ImageFormat { get; }
	public TerrainHeatmapExporter(ImageExportFormat imageFormat)
	{
		ImageFormat = imageFormat;
	}

	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection)
	{
		if (asset is ITerrainData terrainData)
		{
			exportCollection = new TerrainHeatmapExportCollection(this, terrainData);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public bool Export(IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		ITerrainData terrain = (ITerrainData)asset;
		DirectBitmap bitmap = TerrainHeatmap.GetBitmap(terrain);
		using Stream stream = fileSystem.File.Create(path);
		bitmap.Save(stream, ImageFormat);
		return true;
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/Textures/TextureExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Configuration;
using AssetRipper.Export.Modules.Textures;
using AssetRipper.SourceGenerated.Classes.ClassID_189;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.PrimaryContent.Textures;

public sealed class TextureExporter : IContentExtractor
{
	public ImageExportFormat ImageFormat { get; }
	public TextureExporter(ImageExportFormat imageFormat)
	{
		ImageFormat = imageFormat;
	}

	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out ExportCollectionBase? exportCollection)
	{
		if (asset is IImageTexture texture && texture.CheckAssetIntegrity())
		{
			exportCollection = new ImageExportCollection(this, texture);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public bool Export(IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		if (TextureConverter.TryConvertToBitmap((IImageTexture)asset, out DirectBitmap bitmap))
		{
			using Stream stream = fileSystem.File.Create(path);
			bitmap.Save(stream, ImageFormat);
			return true;
		}
		else
		{
			return false;
		}
	}

	private sealed class ImageExportCollection : SingleExportCollection<IImageTexture>
	{
		private ImageExportFormat ExportFormat => ((TextureExporter)ContentExtractor).ImageFormat;

		protected override string ExportExtension => ExportFormat.GetFileExtension();

		public ImageExportCollection(IContentExtractor contentExtractor, IImageTexture asset) : base(contentExtractor, asset)
		{
		}
	}
}

```

`Source/AssetRipper.Export.PrimaryContent/Usings.cs`:

```cs
global using AssetRipper.IO.Files;

```

`Source/AssetRipper.Export.UnityProjects/AnimatorControllers/AnimatorControllerExportCollection.cs`:

```cs
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.UnityProjects.AnimatorControllers;

public sealed class AnimatorControllerExportCollection : AssetsExportCollection<IAnimatorController>
{
	public AnimatorControllerExportCollection(IAssetExporter assetExporter, IAnimatorController controller) : base(assetExporter, controller)
	{
		AddAssets(controller.FetchEditorHierarchy());
	}
}

```

`Source/AssetRipper.Export.UnityProjects/AnimatorControllers/AnimatorControllerExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_91;

namespace AssetRipper.Export.UnityProjects.AnimatorControllers;

public sealed class AnimatorControllerExporter : YamlExporterBase
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		exportCollection = asset.MainAsset switch
		{
			IAnimatorController controller => new AnimatorControllerExportCollection(this, controller),
			_ => null,
		};
		return exportCollection is not null;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/AssetExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.SourceGenerated.Classes.ClassID_1034;

namespace AssetRipper.Export.UnityProjects;

public class AssetExportCollection<T> : ExportCollection where T : IUnityObjectBase
{
	public AssetExportCollection(IAssetExporter assetExporter, T asset)
	{
		AssetExporter = assetExporter ?? throw new ArgumentNullException(nameof(assetExporter));
		Asset = asset ?? throw new ArgumentNullException(nameof(asset));
	}

	public override bool Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		string subPath = fileSystem.Path.Join(projectDirectory, FileSystem.FixInvalidPathCharacters(Asset.GetBestDirectory()));
		string fileName = GetUniqueFileName(Asset, subPath, fileSystem);

		fileSystem.Directory.Create(subPath);

		string filePath = fileSystem.Path.Join(subPath, fileName);
		bool result = ExportInner(container, filePath, projectDirectory, fileSystem);
		if (result)
		{
			Meta meta = new Meta(GUID, CreateImporter(container));
			ExportMeta(container, meta, filePath, fileSystem);
			return true;
		}
		return false;
	}

	public override bool Contains(IUnityObjectBase asset)
	{
		return Asset.AssetInfo == asset.AssetInfo;
	}

	public override long GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		if (asset.AssetInfo == Asset.AssetInfo)
		{
			return ExportIdHandler.GetMainExportID(Asset);
		}
		throw new ArgumentException(null, nameof(asset));
	}

	public override MetaPtr CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		long exportID = GetExportID(container, asset);
		return isLocal ?
			new MetaPtr(exportID) :
			new MetaPtr(exportID, GUID, AssetExporter.ToExportType(Asset));
	}

	/// <summary>
	/// 
	/// </summary>
	/// <param name="container"></param>
	/// <param name="filePath">The full path to the exported asset destination</param>
	/// <param name="dirPath">The full path to the project export directory</param>
	/// <returns>True if export was successful, false otherwise</returns>
	protected virtual bool ExportInner(IExportContainer container, string filePath, string dirPath, FileSystem fileSystem)
	{
		return AssetExporter.Export(container, Asset, filePath, fileSystem);
	}

	protected virtual IUnityObjectBase CreateImporter(IExportContainer container)
	{
		INativeFormatImporter importer = NativeFormatImporter.Create(container.File, container.ExportVersion);
		importer.MainObjectFileID = GetExportID(container, Asset);
		if (importer.Has_AssetBundleName_R() && Asset.AssetBundleName is not null)
		{
			importer.AssetBundleName_R = Asset.AssetBundleName;
		}
		return importer;
	}

	public override UnityGuid GUID { get; } = UnityGuid.NewGuid();
	public override IAssetExporter AssetExporter { get; }
	public override AssetCollection File => Asset.Collection;
	public override IEnumerable<IUnityObjectBase> Assets
	{
		get { yield return Asset; }
	}
	public override string Name => Asset.GetBestName();
	public T Asset { get; }
}

```

`Source/AssetRipper.Export.UnityProjects/AssetRipper.Export.UnityProjects.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.Export.UnityProjects\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Export.UnityProjects\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.HashAlgorithms" Version="1.0.0" />
		<PackageReference Include="AssetRipper.Mining.PredefinedAssets" Version="1.5.0" />
		<PackageReference Include="AssetRipper.Tpk" Version="1.1.0" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Export.Modules.Audio\AssetRipper.Export.Modules.Audio.csproj" />
		<ProjectReference Include="..\AssetRipper.Export.Modules.Models\AssetRipper.Export.Modules.Models.csproj" />
		<ProjectReference Include="..\AssetRipper.Export.Modules.Textures\AssetRipper.Export.Modules.Textures.csproj" />
		<ProjectReference Include="..\AssetRipper.Import\AssetRipper.Import.csproj" />
		<ProjectReference Include="..\AssetRipper.Processing\AssetRipper.Processing.csproj" />
		<ProjectReference Include="..\AssetRipper.Yaml\AssetRipper.Yaml.csproj" />
	</ItemGroup>

	<ItemGroup>
		<None Remove="Shaders\Templates\*" />
		<EmbeddedResource Include="Shaders\Templates\*" />
	</ItemGroup>

	<ItemGroup>
		<Content Remove="C:\Users\**\.nuget\packages\icsharpcode.decompiler\**\Humanizer\LICENSE" />
		<Content Remove="C:\Users\**\.nuget\packages\icsharpcode.decompiler\**\Pattern Matching.html" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Export.UnityProjects/Audio/AudioClipExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_83;

namespace AssetRipper.Export.UnityProjects.Audio;

public sealed class AudioClipExportCollection : AudioExportCollection
{
	private byte[]? data;
	private readonly string fileExtension;
	public AudioClipExportCollection(AudioClipExporter assetExporter, IAudioClip asset, byte[] data, string fileExtension) : base(assetExporter, asset)
	{
		this.data = data;
		this.fileExtension = fileExtension;
	}

	protected override bool ExportInner(IExportContainer container, string filePath, string dirPath, FileSystem fileSystem)
	{
		if (data is null or { Length: 0 })
		{
			return false;
		}
		else
		{
			fileSystem.File.WriteAllBytes(filePath, data);
			data = null;
			return true;
		}
	}

	protected override string GetExportExtension(IUnityObjectBase asset)
	{
		return fileExtension;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Audio/AudioClipExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Configuration;
using AssetRipper.Export.Modules.Audio;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_83;

namespace AssetRipper.Export.UnityProjects.Audio;

public sealed class AudioClipExporter : BinaryAssetExporter
{
	public AudioExportFormat AudioFormat { get; }
	public AudioClipExporter(FullConfiguration configuration) => AudioFormat = configuration.ExportSettings.AudioExportFormat;

	public static bool IsSupportedExportFormat(AudioExportFormat format) => format switch
	{
		AudioExportFormat.Default or AudioExportFormat.PreferWav => true,
		_ => false,
	};

	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is IAudioClip audio)
		{
			if (AudioClipDecoder.TryDecode(audio, out byte[]? decodedData, out string? fileExtension, out string? message))
			{
				if (AudioFormat == AudioExportFormat.PreferWav && fileExtension == "ogg")
				{
					exportCollection = new AudioClipExportCollection(this, audio, AudioConverter.OggToWav(decodedData), "wav");
				}
				else
				{
					exportCollection = new AudioClipExportCollection(this, audio, decodedData, fileExtension);
				}

				return true;
			}
			else
			{
				Logger.Error(LogCategory.Export, message);
			}
		}

		exportCollection = null;
		return false;
	}

	public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		throw new NotSupportedException();
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Audio/AudioExportCollection.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_1020;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Subclasses.SampleSettings;

namespace AssetRipper.Export.UnityProjects.Audio;

public class AudioExportCollection : AssetExportCollection<IAudioClip>
{
	public AudioExportCollection(IAssetExporter assetExporter, IAudioClip asset) : base(assetExporter, asset)
	{
	}

	protected override IAudioImporter CreateImporter(IExportContainer container)
	{
		IAudioImporter importer = AudioImporter.Create(container.File, container.ExportVersion);
		importer.P_3D = Asset.P_3D;
		importer.Ambisonic = Asset.Ambisonic;
		if (importer.Has_DefaultSettings())
		{
			ISampleSettings settings = importer.DefaultSettings;
			settings.CompressionFormat = Asset.CompressionFormat;
			settings.LoadType = Asset.LoadType;
			settings.PreloadAudioData = Asset.PreloadAudioData;
		}
		importer.Format = Asset.Format;
		importer.LoadInBackground = Asset.LoadInBackground;
		importer.PreloadAudioData = Asset.PreloadAudioData;
		importer.Stream = Asset.Stream;
		importer.UseHardware = Asset.UseHardware;
		if (importer.Has_AssetBundleName_R() && Asset.AssetBundleName is not null)
		{
			importer.AssetBundleName_R = Asset.AssetBundleName;
		}
		return importer;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Audio/NativeAudioExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.UnityProjects.Audio;

public sealed class NativeAudioExportCollection : AudioExportCollection
{
	public NativeAudioExportCollection(NativeAudioExporter assetExporter, IAudioClip asset) : base(assetExporter, asset)
	{
	}

	protected override string GetExportExtension(IUnityObjectBase asset)
	{
		IAudioClip audioClip = (IAudioClip)asset;
		if (audioClip.Has_Type())
		{
			return audioClip.GetSoundType().ToRawExtension();
		}
		else
		{
			return audioClip.CompressionFormatE.ToRawExtension();
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Audio/NativeAudioExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.UnityProjects.Audio;

public class NativeAudioExporter : BinaryAssetExporter
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is IAudioClip clip)
		{
			exportCollection = new NativeAudioExportCollection(this, clip);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		IAudioClip audioClip = (IAudioClip)asset;

		byte[] data = audioClip.GetAudioData();
		if (data.Length == 0)
		{
			Logger.Log(LogType.Warning, LogCategory.Export, $"Can't export '{audioClip.GetBestName()}' because no valid data was found");
			return false;
		}
		else
		{
			fileSystem.File.WriteAllBytes(path, data);
			return true;
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Audio/YamlAudioExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.StreamedResource;

namespace AssetRipper.Export.UnityProjects.Audio;

public sealed class YamlAudioExportCollection : AssetExportCollection<IAudioClip>
{
	public YamlAudioExportCollection(IAssetExporter assetExporter, IAudioClip asset) : base(assetExporter, asset)
	{
	}

	protected override bool ExportInner(IExportContainer container, string filePath, string dirPath, FileSystem fileSystem)
	{
		IStreamedResource? resource = Asset.Resource;
		if (resource is not null)
		{
			Utf8String originalSource = resource.Source;
			ulong originalOffset = resource.Offset;
			ulong originalSize = resource.Size;
			if (resource.TryGetContent(Asset.Collection, out byte[]? data))
			{
				string resPath = filePath + ".resS";
				fileSystem.File.WriteAllBytes(resPath, data);
				resource.Source = fileSystem.Path.GetRelativePath(dirPath, resPath);
			}
			else
			{
				resource.Source = Utf8String.Empty;
				resource.Offset = 0;
				resource.Size = 0;
			}
			bool result = base.ExportInner(container, filePath, dirPath, fileSystem);
			resource.Source = originalSource;
			resource.Offset = originalOffset;
			resource.Size = originalSize;
			return result;
		}
		else
		{
			return base.ExportInner(container, filePath, dirPath, fileSystem);
		}
	}

	protected override string GetExportExtension(IUnityObjectBase asset) => "audioclip";
}

```

`Source/AssetRipper.Export.UnityProjects/Audio/YamlAudioExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_83;

namespace AssetRipper.Export.UnityProjects.Audio;

public sealed class YamlAudioExporter : YamlExporterBase
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		exportCollection = asset switch
		{
			IAudioClip audioClip => new YamlAudioExportCollection(this, audioClip),
			_ => null,
		};
		return exportCollection is not null;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/AudioMixers/AudioMixerExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_240;
using AssetRipper.SourceGenerated.Classes.ClassID_243;
using AssetRipper.SourceGenerated.Classes.ClassID_273;

namespace AssetRipper.Export.UnityProjects.AudioMixers;

public class AudioMixerExportCollection : AssetsExportCollection<IAudioMixer>
{
	public AudioMixerExportCollection(IAssetExporter assetExporter, IAudioMixer mixer) : base(assetExporter, mixer)
	{
		foreach (IAudioMixerGroup group in FindChildren(mixer))
		{
			AddAsset(group);
			if (group is IAudioMixerGroupController controller)
			{
				AddAssets(controller.EffectsP);
			}
		}
		AddAssets(mixer.Snapshots_C240P);
	}

	private static IEnumerable<IAudioMixerGroup> FindChildren(IAudioMixer mixer)
	{
		//IAudioMixerController.Children might give the same information and be way more efficient.
		foreach (IAudioMixerGroup group in mixer.Collection.Bundle.FetchAssetsInHierarchy().OfType<IAudioMixerGroup>())
		{
			if (group.AudioMixer_C273P == mixer)
			{
				yield return group;
			}
		}
	}

	private uint m_nextExportID;

	protected override long GenerateExportID(IUnityObjectBase asset)
	{
		long exportID = ExportIdHandler.GetMainExportID(asset, m_nextExportID);
		m_nextExportID += 2;
		return exportID;
	}

	protected override bool ExportInner(IExportContainer container, string filePath, string dirPath, FileSystem fileSystem)
	{
		UnityPatches.ApplyPatchFromText(AudioMixerPatchText, "AudioMixerPostprocessor", dirPath, fileSystem);
		return base.ExportInner(container, filePath, dirPath, fileSystem);
	}

	private const string AudioMixerPatchText = """
		using System;
		using System.Reflection;
		using UnityEditor;
		using UnityEngine;
		using Object = UnityEngine.Object;

		namespace AssetRipperPatches.Editor
		{
			/// <summary>
			/// This script is AssetRipper's patch for exported audio effects to recover effect parameter names when Unity imports each audio mixer.
			/// Unity does not serialize the parameter names in a release asset, so it is impossible to recover them by AssetRipper.
			/// Fortunately, there is an internal function <c>AudioMixerEffectController.PreallocateGUIDs</c> in UnityEditor.dll, which can help us.
			/// This function is used by Unity Editor when creating a new audio effect. It collects a list of runtime audio effects,
			/// retrieves parameter definitions for each, and updates the parameter names and GUIDs in the caller AudioMixerEffectController.
			/// Moreover, this function won't update the GUID for a parameter if it already has a non-empty GUID,
			/// which is the case in exported audio effects, perfectly matching our needs.
			/// </summary>
			public class AudioMixerPostprocessor : AssetPostprocessor
			{
				private static readonly Type AudioMixerEffectControllerType;
				private static readonly MethodInfo PreallocateGUIDsMethod;
				private static readonly MethodInfo GetAudioEffectNamesMethod;

				static AudioMixerPostprocessor()
				{
					Assembly editorAssembly = typeof(AssetPostprocessor).Assembly;
					AudioMixerEffectControllerType = editorAssembly.GetType("UnityEditor.Audio.AudioMixerEffectController", true);
					PreallocateGUIDsMethod = AudioMixerEffectControllerType.GetMethod("PreallocateGUIDs", BindingFlags.Public | BindingFlags.Instance);
					if (PreallocateGUIDsMethod == null)
					{
						Debug.LogError("AudioMixerEffectController.PreallocateGUIDs() method is missing in this version of Unity. Audio effect parameter values will be reset to default.");
					}

					Type mixerEffectDefinitionsType = editorAssembly.GetType("UnityEditor.Audio.MixerEffectDefinitions", true);
					GetAudioEffectNamesMethod = mixerEffectDefinitionsType.GetMethod("GetAudioEffectNames", BindingFlags.Public | BindingFlags.Static);
				}

				static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
				{
					if (PreallocateGUIDsMethod == null) return;

					bool printEffectNames = GetAudioEffectNamesMethod != null;

					foreach (string importedAsset in importedAssets)
					{
						if (importedAsset.EndsWith(".mixer"))
						{
							foreach (Object asset in AssetDatabase.LoadAllAssetsAtPath(importedAsset))
							{
								if (asset.GetType() == AudioMixerEffectControllerType)
								{
									if (printEffectNames)
									{
										printEffectNames = false;
										string[] effectNames = (string[])GetAudioEffectNamesMethod.Invoke(null, new object[0]);
										Debug.LogFormat("MixerEffectDefinitions.GetAudioEffectNames returns [{0}]", String.Join(", ", effectNames));
									}
									PreallocateGUIDsMethod.Invoke(asset, new object[0]);
									Debug.LogFormat("AudioMixerEffectController.PreallocateGUIDs has been called on {0}", asset);
									EditorUtility.SetDirty(asset);
								}
							}
						}
					}
				}
			}
		}
		""";
}

```

`Source/AssetRipper.Export.UnityProjects/AudioMixers/AudioMixerExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_241;

namespace AssetRipper.Export.UnityProjects.AudioMixers;

public class AudioMixerExporter : YamlExporterBase
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		// Audio mixer groups and snapshots should be serialized into the audio mixer YAML asset,
		// precisely the same as a regular Unity project would do.
		// So when we encounter audio mixer groups and snapshots, we create an export collection for the audio mixer
		// to which they belong and let the collection export all related assets into one audio mixer YAML asset.

		IAudioMixerController? audioMixer = asset.MainAsset as IAudioMixerController;

		exportCollection = audioMixer is not null
			? new AudioMixerExportCollection(this, audioMixer)
			: new FailExportCollection(this, asset);

		return exportCollection is not null;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/BinaryAssetExporter.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Export.UnityProjects;

public class BinaryAssetExporter : IAssetExporter
{
	public virtual bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		throw new NotSupportedException();
	}

	public virtual void Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem, Action<IExportContainer, IUnityObjectBase, string, FileSystem>? callback)
	{
		Export(container, asset, path, fileSystem);
		callback?.Invoke(container, asset, path, fileSystem);
	}

	public virtual bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, FileSystem fileSystem)
	{
		throw new NotSupportedException();
	}

	public virtual void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, FileSystem fileSystem, Action<IExportContainer, IUnityObjectBase, string, FileSystem>? callback)
	{
		throw new NotSupportedException();
	}

	public virtual bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		exportCollection = new AssetExportCollection<IUnityObjectBase>(this, asset);
		return true;
	}

	public AssetType ToExportType(IUnityObjectBase asset)
	{
		return AssetType.Meta;
	}

	public bool ToUnknownExportType(Type type, out AssetType assetType)
	{
		assetType = AssetType.Meta;
		return true;
	}

	protected static bool IsValidData(byte[]? data) => data != null && data.Length > 0;
}

```

`Source/AssetRipper.Export.UnityProjects/DeletedAssets/DeletedAssetsExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.Logging;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.Processing;

namespace AssetRipper.Export.UnityProjects.DeletedAssets;

public sealed record DeletedAssetsExportCollection(DeletedAssetsInformation Asset) : IExportCollection
{
	bool IExportCollection.Exportable => false;

	AssetCollection IExportCollection.File => Asset.Collection;

	TransferInstructionFlags IExportCollection.Flags => Asset.Collection.Flags;

	IEnumerable<IUnityObjectBase> IExportCollection.Assets => Asset.DeletedAssets.Append(Asset);

	string IExportCollection.Name => nameof(DeletedAssetsExportCollection);

	bool IExportCollection.Contains(IUnityObjectBase asset)
	{
		return ReferenceEquals(Asset, asset) || Asset.DeletedAssets.Contains(asset);
	}

	MetaPtr IExportCollection.CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		Logger.Warning(LogCategory.Export, $"Deleted asset '{asset.GetBestName()}' was referenced from '{container.File.Name}'");
		return MetaPtr.CreateMissingReference(asset.ClassID, container.ToExportType(asset.GetType()));
	}

	bool IExportCollection.Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		throw new NotSupportedException();
	}

	long IExportCollection.GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		throw new NotSupportedException();
	}
}

```

`Source/AssetRipper.Export.UnityProjects/DeletedAssets/DeletedAssetsExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Processing;

namespace AssetRipper.Export.UnityProjects.DeletedAssets;

public sealed class DeletedAssetsExporter : IAssetExporter
{
	AssetType IAssetExporter.ToExportType(IUnityObjectBase asset)
	{
		throw new NotSupportedException();
	}

	bool IAssetExporter.ToUnknownExportType(Type type, out AssetType assetType)
	{
		assetType = default;
		return false;
	}

	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset.MainAsset is DeletedAssetsInformation infoAsset)
		{
			exportCollection = new DeletedAssetsExportCollection(infoAsset);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/DummyAssetExporter.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Export.UnityProjects;

public abstract class DummyAssetExporter : IAssetExporter
{
	private static readonly EmptyDummyAssetExporter instance_empty_serialized = new(AssetType.Serialized);
	private static readonly SkipDummyAssetExporter instance_skip_serialized = new(AssetType.Serialized);
	private static readonly EmptyDummyAssetExporter instance_empty_meta = new(AssetType.Meta);
	private static readonly SkipDummyAssetExporter instance_skip_meta = new(AssetType.Meta);

	/// <summary>
	/// Setup exporting of the specified class type.
	/// </summary>
	/// <param name="classType">The class id of assets we are setting these parameters for.</param>
	/// <param name="isEmptyCollection">
	/// True: an exception will be thrown if the asset is referenced by another asset.<br/>
	/// False: any references to this asset will be replaced with a missing reference.
	/// </param>
	/// <param name="isMetaType"><see cref="AssetType.Meta"/> or <see cref="AssetType.Serialized"/>?</param>
	public static DummyAssetExporter Get(bool isEmptyCollection, bool isMetaType)
	{
		if (isEmptyCollection)
		{
			return isMetaType ? instance_empty_meta : instance_empty_serialized;
		}
		else
		{
			return isMetaType ? instance_skip_meta : instance_skip_serialized;
		}
	}

	private AssetType ExportType { get; }

	private DummyAssetExporter(AssetType exportType)
	{
		ExportType = exportType;
	}

	public abstract bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection);

	public AssetType ToExportType(IUnityObjectBase asset)
	{
		return ExportType;
	}

	public bool ToUnknownExportType(Type type, out AssetType assetType)
	{
		assetType = ExportType;
		return true;
	}

	private sealed class EmptyDummyAssetExporter(AssetType exportType) : DummyAssetExporter(exportType)
	{
		public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
		{
			exportCollection = EmptyExportCollection.Instance;
			return true;
		}
	}

	private sealed class SkipDummyAssetExporter(AssetType exportType) : DummyAssetExporter(exportType)
	{
		public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
		{
			exportCollection = new SkipExportCollection(this, asset);
			return true;
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/EmptyExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.Export.UnityProjects;

public sealed class EmptyExportCollection : IExportCollection
{
	public static EmptyExportCollection Instance { get; } = new();

	private EmptyExportCollection()
	{
	}

	bool IExportCollection.Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		throw new NotSupportedException();
	}

	bool IExportCollection.Contains(IUnityObjectBase asset)
	{
		return false;
	}

	long IExportCollection.GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		throw new NotSupportedException();
	}

	MetaPtr IExportCollection.CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		throw new NotSupportedException();
	}

	bool IExportCollection.Exportable => false;

	AssetCollection IExportCollection.File => throw new NotSupportedException();
	TransferInstructionFlags IExportCollection.Flags => throw new NotSupportedException();
	IEnumerable<IUnityObjectBase> IExportCollection.Assets => Enumerable.Empty<IUnityObjectBase>();
	public string Name => nameof(EmptyExportCollection);
}

```

`Source/AssetRipper.Export.UnityProjects/EngineAssets/EngineAssetsExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Mining.PredefinedAssets;
using AssetRipper.Processing.Textures;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.Tpk;
using AssetRipper.Tpk.EngineAssets;
using AssetType = AssetRipper.IO.Files.AssetType;

namespace AssetRipper.Export.UnityProjects.EngineAssets;

public class EngineAssetsExporter : IAssetExporter
{
	private static Utf8String FontMaterialName { get; } = (Utf8String)"Font Material"u8;
	private static Utf8String FontTextureName { get; } = (Utf8String)"Font Texture"u8;

	private PredefinedAssetCache Cache { get; }

	public EngineAssetsExporter(PredefinedAssetCache cache)
	{
		Cache = cache;
	}

	public static EngineAssetsExporter CreateFromEmbeddedData(UnityVersion version) => CreateFromTpkFile(version, EngineAssetsTpk.GetStream());

	public static EngineAssetsExporter CreateFromTpkFile(UnityVersion version, Stream stream)
	{
		TpkFile tpk = TpkFile.FromStream(stream);
		return CreateFromTpkBlob(version, (TpkEngineAssetsBlob)tpk.GetDataBlob());
	}

	public static EngineAssetsExporter CreateFromTpkBlob(UnityVersion version, TpkEngineAssetsBlob blob)
	{
		if (blob.Data.Count == 0)
		{
			return new(new PredefinedAssetCache());
		}

		int index;
		if (version <= blob.Data[0].Key)
		{
			index = 0;
		}
		else
		{
			index = blob.Data.Count - 1;
			for (int i = 1; i < blob.Data.Count; i++)
			{
				if (version <= blob.Data[i].Key)
				{
					index = i - 1;
					break;
				}
			}
		}

		string json = blob.Data[index].Value;
		return CreateFromJsonText(json);
	}

	public static EngineAssetsExporter CreateFromJsonText(string json)
	{
		return CreateFromResourceData(EngineResourceData.FromJson(json));
	}

	public static EngineAssetsExporter CreateFromResourceData(EngineResourceData resourceData)
	{
		return new(new PredefinedAssetCache(resourceData));
	}

	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (IsEngineFile(asset.Collection.Name, out UnityGuid engineGuid))
		{
			exportCollection = new SingleRedirectExportCollection(asset, asset.PathID, engineGuid, AssetType.Internal);
			return true;
		}
		else
		{
			if (asset is IMaterial material)
			{
				if (material.Name == FontMaterialName)
				{
					goto returnFalse;
				}
			}
			else if (asset is ITexture2D texture)
			{
				if (texture.Name == FontTextureName)
				{
					goto returnFalse;
				}
			}
		}

		if (asset.MainAsset is SpriteInformationObject spriteInformationObject)
		{
			if (Cache.Contains(spriteInformationObject.Texture, out long textureID, out UnityGuid textureGuid, out _))
			{
				RedirectExportCollection redirectExportCollection = new();
				redirectExportCollection.Add(spriteInformationObject.Texture, textureID, textureGuid, AssetType.Internal);
				redirectExportCollection.AddMissing(spriteInformationObject, default);
				exportCollection = redirectExportCollection;

				//I think it's safe to ignore sprite atlases.
				foreach ((ISprite sprite, _) in spriteInformationObject.Sprites)
				{
					if (Cache.Contains(sprite, out long spriteID, out UnityGuid spriteGuid, out _))
					{
						redirectExportCollection.Add(sprite, spriteID, spriteGuid, AssetType.Internal);
					}
					else
					{
						redirectExportCollection.AddMissing(sprite, AssetType.Internal);
					}
				}
				return true;
			}
		}
		else if (Cache.Contains(asset, out long exportID, out UnityGuid guid, out _))
		{
			exportCollection = new SingleRedirectExportCollection(asset, exportID, guid, AssetType.Internal);
			return true;
		}

		returnFalse:
		exportCollection = null;
		return false;
	}

	private static bool IsEngineFile(string? fileName, out UnityGuid guid)
	{
		if (SpecialFileNames.IsDefaultResource(fileName))
		{
			guid = PredefinedAssetCache.EGUID;
			return true;
		}
		else if (SpecialFileNames.IsBuiltinExtra(fileName))
		{
			guid = PredefinedAssetCache.FGUID;
			return true;
		}
		guid = default;
		return false;
	}

	public AssetType ToExportType(IUnityObjectBase asset)
	{
		return AssetType.Internal;
	}

	public bool ToUnknownExportType(Type type, out AssetType assetType)
	{
		assetType = AssetType.Internal;
		return false;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/EngineAssets/EngineAssetsFactory.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Mining.PredefinedAssets;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Classes.ClassID_130;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using AssetRipper.SourceGenerated.Classes.ClassID_8;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Classes.ClassID_89;
using AssetRipper.SourceGenerated.Extensions;
using AudioClip = AssetRipper.Mining.PredefinedAssets.AudioClip;
using Behaviour = AssetRipper.Mining.PredefinedAssets.Behaviour;
using Component = AssetRipper.Mining.PredefinedAssets.Component;
using Cubemap = AssetRipper.Mining.PredefinedAssets.Cubemap;
using GameObject = AssetRipper.Mining.PredefinedAssets.GameObject;
using Material = AssetRipper.Mining.PredefinedAssets.Material;
using Mesh = AssetRipper.Mining.PredefinedAssets.Mesh;
using MonoBehaviour = AssetRipper.Mining.PredefinedAssets.MonoBehaviour;
using MonoScript = AssetRipper.Mining.PredefinedAssets.MonoScript;
using Object = AssetRipper.Mining.PredefinedAssets.Object;
using Shader = AssetRipper.Mining.PredefinedAssets.Shader;
using Sprite = AssetRipper.Mining.PredefinedAssets.Sprite;
using TextAsset = AssetRipper.Mining.PredefinedAssets.TextAsset;
using Texture2D = AssetRipper.Mining.PredefinedAssets.Texture2D;

namespace AssetRipper.Export.UnityProjects.EngineAssets;

public static class EngineAssetsFactory
{
	public static Object? Create(IUnityObjectBase asset)
	{
		return asset switch
		{
			INamedObject namedObject => Create(namedObject),
			IGameObject gameObject => Create(gameObject),
			IComponent component => Create(component),
			_ => null,
		};
	}

	public static Object? Create(INamedObject namedObject)
	{
		return namedObject switch
		{
			IMaterial material => Create(material),
			ITexture2D texture2D => Create(texture2D),
			IMesh mesh => Create(mesh),
			ITextAsset textAsset => Create(textAsset),
			IShader shader => Create(shader),
			IAudioClip audioClip => Create(audioClip),
			ISprite sprite => Create(sprite),
			_ => new GenericNamedObject()
			{
				Name = namedObject.Name,
				TypeID = namedObject.ClassID,
			},
		};
	}

	public static Component? Create(IComponent component)
	{
		return component is IBehaviour behaviour
			? Create(behaviour)
			: new GenericComponent()
			{
				GameObject = component.GameObject_C2P?.Name,
				TypeID = component.ClassID,
			};
	}

	public static Behaviour? Create(IBehaviour behaviour)
	{
		return behaviour is IMonoBehaviour monoBehaviour
			? Create(monoBehaviour)
			: new GenericBehaviour()
			{
				Enabled = behaviour.Enabled_C8 != 0,
				GameObject = behaviour.GameObject_C8P?.Name,
				TypeID = behaviour.ClassID,
			};
	}

	public static Object Create(ITextAsset textAsset)
	{
		return textAsset switch
		{
			IMonoScript monoScript => Create(monoScript),
			IShader shader => Create(shader),
			_ => new TextAsset(textAsset.Name, textAsset.Script_C49),
		};
	}

	public static Texture2D Create(ITexture2D texture2D)
	{
		return texture2D is ICubemap cubemap
			? Create(cubemap)
			: new Texture2D()
			{
				Name = texture2D.Name,
				Width = texture2D.Width_C28,
				Height = texture2D.Height_C28,
			};
	}

	public static Cubemap Create(ICubemap cubemap)
	{
		return new Cubemap()
		{
			Name = cubemap.Name,
			Width = cubemap.Width,
			Height = cubemap.Height,
		};
	}

	public static Material? Create(IMaterial material)
	{
		IShader? shader = material.Shader_C21P;
		if (shader is null && !material.Shader_C21.IsNull())
		{
			return null;
		}

		return new Material()
		{
			Name = material.Name,
			Shader = shader?.Name,
		};
	}

	public static Sprite? Create(ISprite sprite)
	{
		ITexture2D? texture = sprite.TryGetTexture();
		if (texture is null && !sprite.RD.Texture.IsNull())
		{
			return null;
		}

		return new Sprite()
		{
			Name = sprite.Name,
			Texture = texture?.Name,
		};
	}

	public static Mesh Create(IMesh mesh)
	{
		return new Mesh()
		{
			Name = mesh.Name,
			VertexCount = (int)mesh.VertexData.VertexCount,
			SubMeshCount = mesh.SubMeshes.Count,
			LocalAABB = new()
			{
				Center = mesh.LocalAABB.Center,
				Extent = mesh.LocalAABB.Extent
			}
		};
	}

	public static AudioClip Create(IAudioClip audioClip)
	{
		return new AudioClip()
		{
			Name = audioClip.Name,
			Channels = audioClip.Channels,
			Frequency = audioClip.Frequency,
			Length = audioClip.Length,
		};
	}

	public static Shader Create(IShader shader)
	{
		return new Shader()
		{
			Name = shader.Name,
			PropertyNames = shader.ParsedForm?.PropInfo.Props.Select(p => p.Name.String).ToArray() ?? Array.Empty<string>(),
		};
	}

	public static MonoScript Create(IMonoScript monoScript)
	{
		return new MonoScript()
		{
			AssemblyName = monoScript.AssemblyName,
			Namespace = monoScript.Namespace,
			ClassName = monoScript.ClassName_R,
		};
	}

	public static GameObject Create(IGameObject gameObject)
	{
		return new GameObject()
		{
			Name = gameObject.Name,
			Layer = gameObject.Layer,
			Components = gameObject.GetComponentAccessList().Select(c => c?.ClassID ?? 2).ToArray(),
		};
	}

	public static MonoBehaviour? Create(IMonoBehaviour monoBehaviour)
	{
		IMonoScript? monoScript = monoBehaviour.ScriptP;
		if (monoScript is null)
		{
			return null;
		}

		IGameObject? gameObject = monoBehaviour.GameObjectP;
		if (gameObject is null && !monoBehaviour.GameObject.IsNull())
		{
			return null;
		}

		return new MonoBehaviour()
		{
			Name = monoBehaviour.Name,
			Enabled = monoBehaviour.Enabled != 0,
			AssemblyName = monoScript.AssemblyName,
			Namespace = monoScript.Namespace,
			ClassName = monoScript.ClassName_R,
			GameObject = gameObject?.Name
		};
	}
}

```

`Source/AssetRipper.Export.UnityProjects/EngineAssets/PredefinedAssetCache.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Mining.PredefinedAssets;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Classes.ClassID_130;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using AssetRipper.SourceGenerated.Classes.ClassID_8;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Classes.ClassID_89;
using AssetRipper.SourceGenerated.Extensions;
using System.Text;
using AssetType = AssetRipper.IO.Files.AssetType;
using AudioClip = AssetRipper.Mining.PredefinedAssets.AudioClip;
using Behaviour = AssetRipper.Mining.PredefinedAssets.Behaviour;
using Component = AssetRipper.Mining.PredefinedAssets.Component;
using Cubemap = AssetRipper.Mining.PredefinedAssets.Cubemap;
using GameObject = AssetRipper.Mining.PredefinedAssets.GameObject;
using Material = AssetRipper.Mining.PredefinedAssets.Material;
using Mesh = AssetRipper.Mining.PredefinedAssets.Mesh;
using MonoBehaviour = AssetRipper.Mining.PredefinedAssets.MonoBehaviour;
using MonoScript = AssetRipper.Mining.PredefinedAssets.MonoScript;
using NamedObject = AssetRipper.Mining.PredefinedAssets.NamedObject;
using Object = AssetRipper.Mining.PredefinedAssets.Object;
using Shader = AssetRipper.Mining.PredefinedAssets.Shader;
using Sprite = AssetRipper.Mining.PredefinedAssets.Sprite;
using TextAsset = AssetRipper.Mining.PredefinedAssets.TextAsset;
using Texture2D = AssetRipper.Mining.PredefinedAssets.Texture2D;

namespace AssetRipper.Export.UnityProjects.EngineAssets;

public sealed class PredefinedAssetCache
{
	private readonly record struct AssetMetaPtr(long FileID, UnityGuid Guid, AssetType AssetType);
	private readonly record struct NamedObjectKey(Utf8String Name, ClassIDType ClassID)
	{
		public NamedObjectKey(Utf8String Name, int ClassID) : this(Name, (ClassIDType)ClassID)
		{
		}
	}
	private readonly record struct ComponentKey(Utf8String GameObjectName, ClassIDType ClassID)
	{
		public ComponentKey(Utf8String GameObjectName, int ClassID) : this(GameObjectName, (ClassIDType)ClassID)
		{
		}
	}
	private readonly record struct BehaviourKey(Utf8String GameObjectName, bool Enabled, ClassIDType ClassID)
	{
		public BehaviourKey(Utf8String GameObjectName, byte Enabled, int ClassID) : this(GameObjectName, Enabled != 0, (ClassIDType)ClassID)
		{
		}
	}
	private readonly record struct MonoBehaviourKey(Utf8String Name, bool Enabled, Utf8String AssemblyName, Utf8String Namespace, Utf8String ClassName, Utf8String? GameObjectName);
	private readonly record struct MonoScriptKey(Utf8String AssemblyName, Utf8String Namespace, Utf8String ClassName);
	private readonly record struct AudioClipKey(Utf8String Name, int Channels, int Frequency, float Length);
	private readonly record struct MeshKey(Utf8String Name, int VertexCount, int SubMeshCount, AxisAlignedBoundingBox localAABB);
	private readonly record struct CubeMapKey(Utf8String Name, int Width, int Height);
	private readonly record struct Texture2DKey(Utf8String Name, int Width, int Height);
	private readonly record struct ShaderKey(Utf8String Name, int PropertyNamesHash);
	private readonly record struct GameObjectKey(Utf8String Name, uint Layer, int ComponentCount);
	private readonly record struct MaterialKey(Utf8String Name, Utf8String? ShaderName);
	private readonly record struct SpriteKey(Utf8String Name, Utf8String? TextureName);

	private static UnityGuid DGUID { get; } = new UnityGuid(0x00000000, 0x00000000, 0x0000000D, 0x00000000);
	/// <summary>
	/// The predefined guid for unity default resources
	/// </summary>
	internal static UnityGuid EGUID { get; } = new UnityGuid(0x00000000, 0x00000000, 0x0000000E, 0x00000000);
	/// <summary>
	/// The predefined guid for unity builtin extra
	/// </summary>
	internal static UnityGuid FGUID { get; } = new UnityGuid(0x00000000, 0x00000000, 0x0000000F, 0x00000000);

	private readonly Dictionary<NamedObjectKey, AssetMetaPtr> namedObjectDictionary = new();
	private readonly Dictionary<ComponentKey, AssetMetaPtr> componentDictionary = new();
	private readonly Dictionary<BehaviourKey, AssetMetaPtr> behaviourDictionary = new();
	private readonly Dictionary<MonoBehaviourKey, AssetMetaPtr> monoBehaviourDictionary = new();
	private readonly Dictionary<MonoScriptKey, AssetMetaPtr> monoScriptDictionary = new();
	private readonly Dictionary<AudioClipKey, AssetMetaPtr> audioClipDictionary = new();
	private readonly Dictionary<MeshKey, AssetMetaPtr> meshDictionary = new();
	private readonly Dictionary<CubeMapKey, AssetMetaPtr> cubeMapDictionary = new();
	private readonly Dictionary<Texture2DKey, AssetMetaPtr> texture2DDictionary = new();
	private readonly Dictionary<ShaderKey, AssetMetaPtr> shaderDictionary = new();
	private readonly Dictionary<GameObjectKey, AssetMetaPtr> gameObjectDictionary = new();
	private readonly Dictionary<MaterialKey, AssetMetaPtr> materialDictionary = new();
	private readonly Dictionary<TextAsset, AssetMetaPtr> textAssetDictionary = new();
	private readonly Dictionary<SpriteKey, AssetMetaPtr> spriteDictionary = new();

	public PredefinedAssetCache()
	{
	}

	public PredefinedAssetCache(EngineResourceData resourceData)
	{
		foreach ((long id, Object @object) in resourceData.DefaultResources)
		{
			TryAdd(@object, id, EGUID, AssetType.Internal);
		}
		foreach ((long id, Object @object) in resourceData.ExtraResources)
		{
			TryAdd(@object, id, FGUID, AssetType.Internal);
		}
	}

	public bool Contains(IUnityObjectBase asset, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		return asset switch
		{
			INamedObject namedObject => Contains(namedObject, out fileID, out guid, out assetType),
			IGameObject gameObject => Contains(gameObject, out fileID, out guid, out assetType),
			IComponent component => Contains(component, out fileID, out guid, out assetType),
			_ => SetDefaultAndReturnFalse(out fileID, out guid, out assetType),
		};
	}

	public bool Contains(INamedObject namedObject, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		return namedObject switch
		{
			IMaterial material => Contains(material, out fileID, out guid, out assetType),
			ITexture2D texture2D => Contains(texture2D, out fileID, out guid, out assetType),
			IMesh mesh => Contains(mesh, out fileID, out guid, out assetType),
			ITextAsset textAsset => Contains(textAsset, out fileID, out guid, out assetType),
			IShader shader => Contains(shader, out fileID, out guid, out assetType),
			IAudioClip audioClip => Contains(audioClip, out fileID, out guid, out assetType),
			ISprite sprite => Contains(sprite, out fileID, out guid, out assetType),
			_ => Default(namedObject, out fileID, out guid, out assetType),
		};

		bool Default(INamedObject namedObject, out long fileID, out UnityGuid guid, out AssetType assetType)
		{
			if (namedObjectDictionary.TryGetValue(new NamedObjectKey(namedObject.Name, namedObject.ClassID), out AssetMetaPtr assetMetaPtr))
			{
				(fileID, guid, assetType) = assetMetaPtr;
				return true;
			}
			else
			{
				return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
			}
		}
	}

	public bool Contains(IComponent component, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		return component is IBehaviour behaviour
			? Contains(behaviour, out fileID, out guid, out assetType)
			: Default(component, out fileID, out guid, out assetType);

		bool Default(IComponent component, out long fileID, out UnityGuid guid, out AssetType assetType)
		{
			if (component.GameObject_C2.IsNull())
			{
				//Not enough information to determine the asset.
			}
			else if (component.GameObject_C2P is not { } gameObject)
			{
				//GameObject could not be resolved.
			}
			else
			{
				//Component index should be included in the future.
				if (componentDictionary.TryGetValue(new ComponentKey(gameObject.Name, component.ClassID), out AssetMetaPtr assetMetaPtr))
				{
					(fileID, guid, assetType) = assetMetaPtr;
					return true;
				}
			}
			return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
		}
	}

	public bool Contains(IBehaviour behaviour, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		return behaviour is IMonoBehaviour monoBehaviour
			? Contains(monoBehaviour, out fileID, out guid, out assetType)
			: Default(behaviour, out fileID, out guid, out assetType);

		bool Default(IBehaviour behaviour, out long fileID, out UnityGuid guid, out AssetType assetType)
		{
			if (behaviour.GameObject_C8.IsNull())
			{
				//Not enough information to determine the asset.
			}
			else if (behaviour.GameObject_C8P is not { } gameObject)
			{
				//GameObject could not be resolved.
			}
			else
			{
				//Component index should be included in the future.
				if (behaviourDictionary.TryGetValue(new BehaviourKey(gameObject.Name, behaviour.Enabled_C8, behaviour.ClassID), out AssetMetaPtr assetMetaPtr))
				{
					(fileID, guid, assetType) = assetMetaPtr;
					return true;
				}
			}
			return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
		}
	}

	public bool Contains(ITextAsset textAsset, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		return textAsset switch
		{
			IMonoScript monoScript => Contains(monoScript, out fileID, out guid, out assetType),
			IShader shader => Contains(shader, out fileID, out guid, out assetType),
			_ => Default(textAsset, out fileID, out guid, out assetType),
		};

		bool Default(ITextAsset textAsset, out long fileID, out UnityGuid guid, out AssetType assetType)
		{
			if (textAssetDictionary.TryGetValue(new TextAsset(textAsset.Name, textAsset.Script_C49.Data), out AssetMetaPtr assetMetaPtr))
			{
				(fileID, guid, assetType) = assetMetaPtr;
				return true;
			}
			else
			{
				return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
			}
		}
	}

	public bool Contains(ITexture2D texture2D, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		return texture2D is ICubemap cubemap
			? Contains(cubemap, out fileID, out guid, out assetType)
			: Default(texture2D, out fileID, out guid, out assetType);

		bool Default(ITexture2D texture2D, out long fileID, out UnityGuid guid, out AssetType assetType)
		{
			if (texture2DDictionary.TryGetValue(new Texture2DKey(texture2D.Name, texture2D.Width_C28, texture2D.Height_C28), out AssetMetaPtr assetMetaPtr))
			{
				(fileID, guid, assetType) = assetMetaPtr;
				return true;
			}
			else
			{
				return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
			}
		}
	}

	public bool Contains(ICubemap cubemap, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		if (cubeMapDictionary.TryGetValue(new CubeMapKey(cubemap.Name, cubemap.Width, cubemap.Height), out AssetMetaPtr assetMetaPtr))
		{
			(fileID, guid, assetType) = assetMetaPtr;
			return true;
		}
		else
		{
			return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
		}
	}

	public bool Contains(IMaterial material, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		IShader? shader = material.Shader_C21P;
		if (shader is null && !material.Shader_C21.IsNull())
		{
			//Shader could not be resolved.
		}
		else if (materialDictionary.TryGetValue(new MaterialKey(material.Name, shader?.Name), out AssetMetaPtr assetMetaPtr))
		{
			(fileID, guid, assetType) = assetMetaPtr;
			return true;
		}
		return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
	}

	public bool Contains(ISprite sprite, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		ITexture2D? texture = sprite.TryGetTexture();
		if (texture is null && !sprite.RD.Texture.IsNull())
		{
			//Texture could not be resolved.
		}
		else if (spriteDictionary.TryGetValue(new SpriteKey(sprite.Name, texture?.Name), out AssetMetaPtr assetMetaPtr))
		{
			(fileID, guid, assetType) = assetMetaPtr;
			return true;
		}
		return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
	}

	public bool Contains(IMesh mesh, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		if (meshDictionary.TryGetValue(new MeshKey(mesh.Name, (int)mesh.VertexData.VertexCount, mesh.SubMeshes.Count, new()
		{
			Center = mesh.LocalAABB.Center,
			Extent = mesh.LocalAABB.Extent
		}), out AssetMetaPtr assetMetaPtr))
		{
			(fileID, guid, assetType) = assetMetaPtr;
			return true;
		}
		else
		{
			return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
		}
	}

	public bool Contains(IAudioClip audioClip, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		if (audioClipDictionary.TryGetValue(new AudioClipKey(audioClip.Name, audioClip.Channels, audioClip.Frequency, audioClip.Length), out AssetMetaPtr assetMetaPtr))
		{
			(fileID, guid, assetType) = assetMetaPtr;
			return true;
		}
		else
		{
			return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
		}
	}

	public bool Contains(IShader shader, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		int hash = shader.ParsedForm is { } parsedForm
			? HashStrings(parsedForm.PropInfo.Props.Select(p => p.Name))
			: 0;

		if (shaderDictionary.TryGetValue(new ShaderKey(shader.Name, hash), out AssetMetaPtr assetMetaPtr))
		{
			(fileID, guid, assetType) = assetMetaPtr;
			return true;
		}
		else
		{
			return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
		}
	}

	public bool Contains(IMonoScript monoScript, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		if (monoScriptDictionary.TryGetValue(new MonoScriptKey(monoScript.GetAssemblyNameFixed(), monoScript.Namespace, monoScript.ClassName_R), out AssetMetaPtr assetMetaPtr))
		{
			(fileID, guid, assetType) = assetMetaPtr;
			return true;
		}
		else
		{
			return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
		}
	}

	public bool Contains(IGameObject gameObject, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		if (gameObjectDictionary.TryGetValue(new GameObjectKey(gameObject.Name, gameObject.Layer, gameObject.GetComponentCount()), out AssetMetaPtr assetMetaPtr))
		{
			(fileID, guid, assetType) = assetMetaPtr;
			return true;
		}
		else
		{
			return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
		}
	}

	public bool Contains(IMonoBehaviour monoBehaviour, out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		if (monoBehaviour.Script.IsNull())
		{
			//Not enough information to determine the asset.
		}
		else if (monoBehaviour.ScriptP is not { } script)
		{
			//MonoScript could not be resolved.
		}
		else if (monoBehaviour.GameObject.IsNull())
		{
			MonoBehaviourKey key = new()
			{
				Name = monoBehaviour.Name,
				Enabled = monoBehaviour.Enabled != 0,
				AssemblyName = script.AssemblyName,
				Namespace = script.Namespace,
				ClassName = script.ClassName_R,
				GameObjectName = null,
			};
			if (monoBehaviourDictionary.TryGetValue(key, out AssetMetaPtr assetMetaPtr))
			{
				(fileID, guid, assetType) = assetMetaPtr;
				return true;
			}
		}
		else if (monoBehaviour.GameObjectP is not { } gameObject)
		{
			//GameObject could not be resolved.
		}
		else
		{
			//Component index should be included in the future.
			MonoBehaviourKey key = new()
			{
				Name = monoBehaviour.Name,
				Enabled = monoBehaviour.Enabled != 0,
				AssemblyName = script.AssemblyName,
				Namespace = script.Namespace,
				ClassName = script.ClassName_R,
				GameObjectName = gameObject.Name,
			};
			if (monoBehaviourDictionary.TryGetValue(key, out AssetMetaPtr assetMetaPtr))
			{
				(fileID, guid, assetType) = assetMetaPtr;
				return true;
			}
		}
		return SetDefaultAndReturnFalse(out fileID, out guid, out assetType);
	}

	private static bool SetDefaultAndReturnFalse(out long fileID, out UnityGuid guid, out AssetType assetType)
	{
		fileID = default;
		guid = default;
		assetType = default;
		return false;
	}

	public bool TryAdd(Object @object, long fileID, UnityGuid guid, AssetType assetType)
	{
		return @object switch
		{
			NamedObject namedObject => TryAdd(namedObject, fileID, guid, assetType),
			GameObject gameObject => TryAdd(gameObject, fileID, guid, assetType),
			Component component => TryAdd(component, fileID, guid, assetType),
			MonoScript monoScript => TryAdd(monoScript, fileID, guid, assetType),
			_ => false,
		};
	}

	public bool TryAdd(NamedObject namedObject, long fileID, UnityGuid guid, AssetType assetType)
	{
		return namedObject switch
		{
			Material material => TryAdd(material, fileID, guid, assetType),
			Texture2D texture2D => TryAdd(texture2D, fileID, guid, assetType),
			Mesh mesh => TryAdd(mesh, fileID, guid, assetType),
			TextAsset textAsset => TryAdd(textAsset, fileID, guid, assetType),
			Shader shader => TryAdd(shader, fileID, guid, assetType),
			AudioClip audioClip => TryAdd(audioClip, fileID, guid, assetType),
			Sprite sprite => TryAdd(sprite, fileID, guid, assetType),
			_ => TryAddDefault(namedObject, fileID, guid, assetType),
		};

		bool TryAddDefault(NamedObject namedObject, long fileID, UnityGuid guid, AssetType assetType)
		{
			return namedObjectDictionary.TryAdd(new NamedObjectKey(namedObject.Name, namedObject.TypeID), new AssetMetaPtr(fileID, guid, assetType));
		}
	}

	public bool TryAdd(Component component, long fileID, UnityGuid guid, AssetType assetType)
	{
		return component is Behaviour behaviour
			? TryAdd(behaviour, fileID, guid, assetType)
			: TryAddDefault(component, fileID, guid, assetType);

		bool TryAddDefault(Component component, long fileID, UnityGuid guid, AssetType assetType)
		{
			if (component.GameObject is null)
			{
				//Not enough information to determine the asset.
				return false;
			}
			else
			{
				return componentDictionary.TryAdd(new ComponentKey(component.GameObject, component.TypeID), new AssetMetaPtr(fileID, guid, assetType));
			}
		}
	}

	public bool TryAdd(Behaviour behaviour, long fileID, UnityGuid guid, AssetType assetType)
	{
		return behaviour is MonoBehaviour monoBehaviour
			? TryAdd(monoBehaviour, fileID, guid, assetType)
			: TryAddDefault(behaviour, fileID, guid, assetType);

		bool TryAddDefault(Behaviour behaviour, long fileID, UnityGuid guid, AssetType assetType)
		{
			if (behaviour.GameObject is null)
			{
				//Not enough information to determine the asset.
				return false;
			}
			else
			{
				return behaviourDictionary.TryAdd(new BehaviourKey(behaviour.GameObject, behaviour.Enabled, (ClassIDType)behaviour.TypeID), new AssetMetaPtr(fileID, guid, assetType));
			}
		}
	}

	public bool TryAdd(MonoBehaviour monoBehaviour, long fileID, UnityGuid guid, AssetType assetType)
	{
		MonoBehaviourKey key = new()
		{
			Name = monoBehaviour.Name,
			Enabled = monoBehaviour.Enabled,
			AssemblyName = monoBehaviour.AssemblyName,
			Namespace = monoBehaviour.Namespace,
			ClassName = monoBehaviour.ClassName,
			GameObjectName = monoBehaviour.GameObject,
		};
		return monoBehaviourDictionary.TryAdd(key, new AssetMetaPtr(fileID, guid, assetType));
	}

	public bool TryAdd(TextAsset textAsset, long fileID, UnityGuid guid, AssetType assetType)
	{
		return textAssetDictionary.TryAdd(textAsset, new AssetMetaPtr(fileID, guid, assetType));
	}

	public bool TryAdd(Texture2D texture2D, long fileID, UnityGuid guid, AssetType assetType)
	{
		return texture2D is Cubemap cubemap
			? TryAdd(cubemap, fileID, guid, assetType)
			: texture2DDictionary.TryAdd(new Texture2DKey(texture2D.Name, texture2D.Width, texture2D.Height), new AssetMetaPtr(fileID, guid, assetType));
	}

	public bool TryAdd(Cubemap cubemap, long fileID, UnityGuid guid, AssetType assetType)
	{
		return cubeMapDictionary.TryAdd(new CubeMapKey(cubemap.Name, cubemap.Width, cubemap.Height), new AssetMetaPtr(fileID, guid, assetType));
	}

	public bool TryAdd(Mesh mesh, long fileID, UnityGuid guid, AssetType assetType)
	{
		return meshDictionary.TryAdd(new MeshKey(mesh.Name, mesh.VertexCount, mesh.SubMeshCount, new()
		{
			Center = mesh.LocalAABB.Center,
			Extent = mesh.LocalAABB.Extent
		}), new AssetMetaPtr(fileID, guid, assetType));
	}

	public bool TryAdd(AudioClip audioClip, long fileID, UnityGuid guid, AssetType assetType)
	{
		return audioClipDictionary.TryAdd(new AudioClipKey(audioClip.Name, audioClip.Channels, audioClip.Frequency, audioClip.Length), new AssetMetaPtr(fileID, guid, assetType));
	}

	public bool TryAdd(Shader shader, long fileID, UnityGuid guid, AssetType assetType)
	{
		return shaderDictionary.TryAdd(new ShaderKey(shader.Name, HashStrings(shader.PropertyNames)), new AssetMetaPtr(fileID, guid, assetType));
	}

	public bool TryAdd(MonoScript monoScript, long fileID, UnityGuid guid, AssetType assetType)
	{
		return monoScriptDictionary.TryAdd(new MonoScriptKey(monoScript.AssemblyName, monoScript.Namespace, monoScript.ClassName), new AssetMetaPtr(fileID, guid, assetType));
	}

	public bool TryAdd(GameObject gameObject, long fileID, UnityGuid guid, AssetType assetType)
	{
		return gameObjectDictionary.TryAdd(new GameObjectKey(gameObject.Name, gameObject.Layer, gameObject.Components.Length), new AssetMetaPtr(fileID, guid, assetType));
	}

	public bool TryAdd(Material material, long fileID, UnityGuid guid, AssetType assetType)
	{
		return materialDictionary.TryAdd(new MaterialKey(material.Name, material.Shader), new AssetMetaPtr(fileID, guid, assetType));
	}

	public bool TryAdd(Sprite sprite, long fileID, UnityGuid guid, AssetType assetType)
	{
		return spriteDictionary.TryAdd(new SpriteKey(sprite.Name, sprite.Texture), new AssetMetaPtr(fileID, guid, assetType));
	}

	private static int HashStrings(ReadOnlySpan<string> strings)
	{
		HashCode hashCode = new();
		foreach (string str in strings)
		{
			hashCode.AddBytes(Encoding.UTF8.GetBytes(str));
		}
		return hashCode.ToHashCode();
	}

	private static int HashStrings(IEnumerable<Utf8String> strings)
	{
		HashCode hashCode = new();
		foreach (Utf8String str in strings)
		{
			hashCode.AddBytes(str.Data);
		}
		return hashCode.ToHashCode();
	}
}

```

`Source/AssetRipper.Export.UnityProjects/ExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_1107;
using AssetRipper.SourceGenerated.Classes.ClassID_1109;
using AssetRipper.SourceGenerated.Classes.ClassID_1113;
using AssetRipper.SourceGenerated.Classes.ClassID_121;
using AssetRipper.SourceGenerated.Classes.ClassID_134;
using AssetRipper.SourceGenerated.Classes.ClassID_158;
using AssetRipper.SourceGenerated.Classes.ClassID_1953259897;
using AssetRipper.SourceGenerated.Classes.ClassID_200;
using AssetRipper.SourceGenerated.Classes.ClassID_206;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_221;
using AssetRipper.SourceGenerated.Classes.ClassID_240;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_319;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Classes.ClassID_62;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_84;
using AssetRipper.SourceGenerated.Classes.ClassID_850595691;
using AssetRipper.SourceGenerated.Classes.ClassID_89;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.Yaml;
using System.Text;

namespace AssetRipper.Export.UnityProjects;

public abstract class ExportCollection : IExportCollection
{
	public virtual UnityGuid GUID => throw new NotSupportedException();

	protected static void ExportMeta(IExportContainer container, Meta meta, string filePath, FileSystem fileSystem)
	{
		string metaPath = $"{filePath}{MetaExtension}";
		using Stream fileStream = fileSystem.File.Create(metaPath);
		using InvariantStreamWriter streamWriter = new InvariantStreamWriter(fileStream, new UTF8Encoding(false));

		YamlWriter writer = new();
		writer.IsWriteDefaultTag = false;
		writer.IsWriteVersion = false;
		writer.IsFormatKeys = true;
		YamlDocument doc = meta.ExportYamlDocument(container);
		writer.AddDocument(doc);
		writer.Write(streamWriter);
	}

	public abstract bool Export(IExportContainer container, string projectDirectory, FileSystem fileSystem);
	public abstract bool Contains(IUnityObjectBase asset);
	public abstract long GetExportID(IExportContainer container, IUnityObjectBase asset);
	public abstract MetaPtr CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal);

	protected void ExportAsset(IExportContainer container, IUnityObjectBase importer, IUnityObjectBase asset, string path, string name, FileSystem fileSystem)
	{
		if (!fileSystem.Directory.Exists(path))
		{
			fileSystem.Directory.Create(path);
		}

		string fullName = $"{name}.{GetExportExtension(asset)}";
		string uniqueName = fileSystem.GetUniqueName(path, fullName, FileSystem.MaxFileNameLength - MetaExtension.Length);
		string filePath = fileSystem.Path.Join(path, uniqueName);
		AssetExporter.Export(container, asset, filePath, fileSystem);
		Meta meta = new Meta(GUID, importer);
		ExportMeta(container, meta, filePath, fileSystem);
	}

	protected string GetUniqueFileName(IUnityObjectBase asset, string dirPath, FileSystem fileSystem)
	{
		string fileName = asset.GetBestName();
		fileName = FileSystem.RemoveCloneSuffixes(fileName);
		fileName = FileSystem.RemoveInstanceSuffixes(fileName);
		fileName = fileName.Trim();
		if (string.IsNullOrEmpty(fileName))
		{
			fileName = asset.ClassName;
		}
		else
		{
			fileName = FileSystem.FixInvalidFileNameCharacters(fileName);
		}

		fileName = $"{fileName}.{GetExportExtension(asset)}";
		return GetUniqueFileName(dirPath, fileName, fileSystem);
	}

	protected static string GetUniqueFileName(string directoryPath, string fileName, FileSystem fileSystem)
	{
		return fileSystem.GetUniqueName(directoryPath, fileName, FileSystem.MaxFileNameLength - MetaExtension.Length);
	}

	protected virtual string GetExportExtension(IUnityObjectBase asset)
	{
		//https://docs.unity3d.com/Manual/BuiltInImporters.html
		return asset switch
		{
			IShader => "shader",
			IMaterial => "mat",
			IAnimationClip => "anim",
			IAnimatorController => "controller",
			IAnimatorOverrideController => "overrideController",
			IAudioMixer => "mixer",
			IAvatarMask => "mask",
			IShaderVariantCollection => "shadervariants",
			ICubemap => "cubemap",
			ITexture2D => "texture2D",
			IFlare => "flare",
			ILightingSettings => "lighting",
			ILightmapParameters => "giparams",
			IPhysicsMaterial => "physicMaterial",
			IPhysicsMaterial2D => "physicsMaterial2D",
			IRenderTexture => "renderTexture",
			ITerrainLayer => "terrainlayer",
			IWebCamTexture => "webCamTexture",
			IAnimatorState => "state",
			IAnimatorStateMachine => "statemachine",
			IAnimatorTransition => "transition",
			IBlendTree => "blendtree",
			_ => AssetExtension
		};
	}

	public abstract IAssetExporter AssetExporter { get; }
	public abstract AssetCollection File { get; }
	public virtual TransferInstructionFlags Flags => TransferInstructionFlags.NoTransferInstructionFlags;
	public abstract IEnumerable<IUnityObjectBase> Assets { get; }
	public virtual IEnumerable<IUnityObjectBase> ExportableAssets => Assets;
	public abstract string Name { get; }

	private const string MetaExtension = ".meta";
	protected const string AssetExtension = "asset";
	public const string AssetsKeyword = "Assets";
}

```

`Source/AssetRipper.Export.UnityProjects/ExportHandler.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Export.Configuration;
using AssetRipper.Export.UnityProjects.PathIdMapping;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.Export.UnityProjects.Scripts;
using AssetRipper.Import.Configuration;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure;
using AssetRipper.Processing;
using AssetRipper.Processing.AnimatorControllers;
using AssetRipper.Processing.Assemblies;
using AssetRipper.Processing.AudioMixers;
using AssetRipper.Processing.Editor;
using AssetRipper.Processing.Prefabs;
using AssetRipper.Processing.Scenes;
using AssetRipper.Processing.ScriptableObject;
using AssetRipper.Processing.Textures;

namespace AssetRipper.Export.UnityProjects;

public class ExportHandler
{
	protected FullConfiguration Settings { get; }

	public ExportHandler(FullConfiguration settings)
	{
		Settings = settings;
	}

	public GameData Load(IReadOnlyList<string> paths, FileSystem fileSystem)
	{
		if (paths.Count == 1)
		{
			Logger.Info(LogCategory.Import, $"Attempting to read files from {paths[0]}");
		}
		else
		{
			Logger.Info(LogCategory.Import, $"Attempting to read files from {paths.Count} paths...");
		}

		GameStructure gameStructure = GameStructure.Load(paths, fileSystem, Settings);
		GameData gameData = GameData.FromGameStructure(gameStructure);
		Logger.Info(LogCategory.Import, "Finished reading files");
		return gameData;
	}

	public void Process(GameData gameData)
	{
		Logger.Info(LogCategory.Processing, "Processing loaded assets...");
		foreach (IAssetProcessor processor in GetProcessors())
		{
			processor.Process(gameData);
		}
		Logger.Info(LogCategory.Processing, "Finished processing assets");
	}

	protected virtual IEnumerable<IAssetProcessor> GetProcessors()
	{
		// Assembly processors
		yield return new AttributePolyfillGenerator();
		yield return new MonoExplicitPropertyRepairProcessor();
		yield return new ObfuscationRepairProcessor();
		yield return new ForwardingAssemblyGenerator();
		if (Settings.ImportSettings.ScriptContentLevel == ScriptContentLevel.Level1)
		{
			yield return new MethodStubbingProcessor();
		}
		yield return new NullRefReturnProcessor(Settings.ImportSettings.ScriptContentLevel);
		yield return new UnmanagedConstraintRecoveryProcessor();
		if (Settings.ProcessingSettings.RemoveNullableAttributes)
		{
			yield return new NullableRemovalProcessor();
		}
		if (Settings.ProcessingSettings.PublicizeAssemblies)
		{
			yield return new SafeAssemblyPublicizingProcessor();
		}
		yield return new RemoveAssemblyKeyFileAttributeProcessor();
		yield return new InternalsVisibileToPublicKeyRemover();

		yield return new SceneDefinitionProcessor();
		yield return new MainAssetProcessor();
		yield return new AnimatorControllerProcessor();
		yield return new AudioMixerProcessor();
		yield return new EditorFormatProcessor(Settings.ProcessingSettings.BundledAssetsExportMode);
		//Static mesh separation goes here
		yield return new LightingDataProcessor();//Needs to be after static mesh separation
		yield return new PrefabProcessor();
		yield return new SpriteProcessor();
		yield return new ScriptableObjectProcessor();
	}

	public void Export(GameData gameData, string outputPath, FileSystem fileSystem)
	{
		Logger.Info(LogCategory.Export, "Starting export");
		Logger.Info(LogCategory.Export, $"Attempting to export assets to {outputPath}...");
		Logger.Info(LogCategory.Export, $"Game files have these Unity versions: {GetListOfVersions(gameData.GameBundle)}");
		Logger.Info(LogCategory.Export, $"Exporting to Unity version {gameData.ProjectVersion}");

		Settings.ExportRootPath = outputPath;
		Settings.SetProjectSettings(gameData.ProjectVersion);

		ProjectExporter projectExporter = new(Settings, gameData.AssemblyManager);
		BeforeExport(projectExporter);
		projectExporter.DoFinalOverrides(Settings);
		projectExporter.Export(gameData.GameBundle, Settings, fileSystem);

		Logger.Info(LogCategory.Export, "Finished exporting assets");

		foreach (IPostExporter postExporter in GetPostExporters())
		{
			postExporter.DoPostExport(gameData, Settings, fileSystem);
		}
		Logger.Info(LogCategory.Export, "Finished post-export");

		static string GetListOfVersions(GameBundle gameBundle)
		{
			return string.Join(' ', gameBundle
				.FetchAssetCollections()
				.Select(c => c.Version)
				.Distinct()
				.Select(v => v.ToString()));
		}
	}

	protected virtual void BeforeExport(ProjectExporter projectExporter)
	{
	}

	protected virtual IEnumerable<IPostExporter> GetPostExporters()
	{
		yield return new ProjectVersionPostExporter();
		yield return new PackageManifestPostExporter();
		yield return new StreamingAssetsPostExporter();
		yield return new DllPostExporter();
		yield return new PathIdMapExporter();
	}

	public GameData LoadAndProcess(IReadOnlyList<string> paths, FileSystem fileSystem)
	{
		GameData gameData = Load(paths, fileSystem);
		Process(gameData);
		return gameData;
	}

	public void LoadProcessAndExport(IReadOnlyList<string> inputPaths, string outputPath, FileSystem fileSystem)
	{
		GameData gameData = LoadAndProcess(inputPaths, fileSystem);
		Export(gameData, outputPath, fileSystem);
	}

	public void ThrowIfSettingsDontMatch(FullConfiguration settings)
	{
		if (Settings != settings)
		{
			throw new ArgumentException("Settings don't match");
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/ExportIdHandler.cs`:

```cs
using AssetRipper.Assets;
using System.Diagnostics;
using System.IO.Hashing;

namespace AssetRipper.Export.UnityProjects;

public static class ExportIdHandler
{
	/// <summary>
	/// One quadrillion, ie 10^15
	/// </summary>
	private const long TenToTheFifthteenth = 1_000_000_000_000_000L;

	/// <summary>
	/// The maximum class id that can be used as a prefix for export ids.
	/// </summary>
	/// <remarks>
	/// 9223
	/// </remarks>
	private const int MaxPrefixedClassId = (int)(long.MaxValue / TenToTheFifthteenth);

	public static long GetMainExportID(IUnityObjectBase asset)
	{
		return GetMainExportID(asset.ClassID, 0);
	}

	public static long GetMainExportID(int classID)
	{
		return GetMainExportID(classID, 0);
	}

	public static long GetMainExportID(IUnityObjectBase asset, uint value)
	{
		return GetMainExportID(asset.ClassID, value);
	}

	public static long GetMainExportID(int classID, uint value)
	{
		if (classID > 100100)
		{
			if (value != 0)
			{
				throw new ArgumentException("Unique asset type with non unique modifier", nameof(value));
			}
			return classID;
		}

		Debug.Assert(value < 100000, $"Value {value} for main export ID must have no more than 5 digits");
		return classID * 100000L + value;
	}

	/// <summary>
	/// Generate a random export id.
	/// </summary>
	/// <param name="asset"></param>
	/// <param name="duplicateChecker"></param>
	/// <returns></returns>
	public static long GetPseudoRandomExportId(IUnityObjectBase asset, long seed)
	{
		ArgumentNullException.ThrowIfNull(asset);

		// Depending on the export version, exportID should has random or ordered value.
		// However, I don't have any idea where the version threshold is, and it has never seemed to matter.

		// We don't bother checking for duplicates here, as the probability of a collision is extremely low.

		long exportID;
		if (asset.ClassID > MaxPrefixedClassId)
		{
			//Checked for StreamingController on 2018.2.5f1
			//Small class id's use the below format
			//Whereas this uses random id's
			exportID = GetPseudoRandomValue(seed);
		}
		else
		{
			long prefix = asset.ClassID * TenToTheFifthteenth;
			ulong value = unchecked((ulong)GetPseudoRandomValue(seed));
			exportID = prefix + (long)(value % TenToTheFifthteenth);
		}

		return exportID;
	}

	/// <summary>
	/// Generate a pseudo random internal id.
	/// </summary>
	/// <remarks>
	/// This uses the XxHash64 algorithm to generate a random-looking <see cref="long"/> from a <see cref="long"/> seed.
	/// </remarks>
	/// <returns>A random-looking <see cref="long"/> between <see cref="long.MinValue"/> and <see cref="long.MaxValue"/>.</returns>
	public static long GetPseudoRandomValue(long seed)
	{
		return unchecked((long)XxHash64.HashToUInt64([], seed));
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Extensions/OcclusionCullingDataExtensions.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Classes.ClassID_29;
using AssetRipper.SourceGenerated.Classes.ClassID_363;
using AssetRipper.SourceGenerated.Classes.ClassID_41;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.GUID;
using AssetRipper.SourceGenerated.Subclasses.OcclusionScene;
using AssetRipper.SourceGenerated.Subclasses.PPtr_OcclusionPortal;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Renderer;
using AssetRipper.SourceGenerated.Subclasses.SceneObjectIdentifier;

namespace AssetRipper.Export.UnityProjects.Extensions;

internal static class OcclusionCullingDataExtensions
{
	public static void Initialize(this IOcclusionCullingData occlusionCullingData, IExportContainer container, IOcclusionCullingSettings cullingSetting)
	{
		occlusionCullingData.PVSData = cullingSetting.PVSData ?? Array.Empty<byte>();
		int renderCount = cullingSetting.StaticRenderers?.Count ?? 0;
		int portalCount = cullingSetting.Portals?.Count ?? 0;
		occlusionCullingData.Scenes.InitializeList(1);
		OcclusionScene scene = occlusionCullingData.Scenes[0];
		scene.Initialize(cullingSetting.SceneGUID, renderCount, portalCount);

		occlusionCullingData.StaticRenderers.InitializeList(scene.SizeRenderers);
		occlusionCullingData.Portals.InitializeList(scene.SizePortals);
		occlusionCullingData.SetIDs(container, cullingSetting, scene);
	}

	private static void InitializeList<T>(this AssetList<T> list, int size) where T : notnull, new()
	{
		list.Clear();
		list.Capacity = size;
		for (int i = 0; i < size; i++)
		{
			list.AddNew();
		}
	}

	public static void Initialize(this OcclusionScene occlusionScene, GUID? scene, int renderSize, int portalSize)
	{
		if (scene is not null)
		{
			occlusionScene.Scene.CopyValues(scene);
		}
		occlusionScene.IndexRenderers = 0;
		occlusionScene.SizeRenderers = renderSize;
		occlusionScene.IndexPortals = 0;
		occlusionScene.SizePortals = portalSize;
	}

	public static void SetExportData(this IOcclusionCullingData occlusionCullingData, IExportContainer container)
	{
		// If < 3.0.0, this asset doesn't exist.

		// For 3.0.0 to 5.5.0, this asset is created by culling settings, so its data is already set.
		if (occlusionCullingData.Collection.Version.LessThan(5, 5))
		{
			return;
		}

		// If >= 5.5.0 and not Release, this asset contains renderer data,
		if (!occlusionCullingData.Collection.Flags.IsRelease())
		{
			return;
		}

		// If >= 5.5.0 and Release. this asset doesn't contain renderer data, so we need to create it.
		List<IOcclusionCullingSettings> cullingSettings = new();
		foreach (IUnityObjectBase asset in occlusionCullingData.Collection.Bundle.FetchAssetsInHierarchy())
		{
			if (asset is IOcclusionCullingSettings cullingSetting
				&& cullingSetting.Has_OcclusionCullingData()
				&& cullingSetting.OcclusionCullingData.IsAsset(cullingSetting.Collection, occlusionCullingData))
			{
				cullingSettings.Add(cullingSetting);
			}
		}

		int maxRenderer = occlusionCullingData.Scenes.Max(j => j.IndexRenderers + j.SizeRenderers);
		occlusionCullingData.StaticRenderers.InitializeList(maxRenderer);
		int maxPortal = occlusionCullingData.Scenes.Max(j => j.IndexPortals + j.SizePortals);
		occlusionCullingData.Portals.InitializeList(maxPortal);

		foreach (IOcclusionCullingSettings cullingSetting in cullingSettings)
		{
			if (!cullingSetting.Has_SceneGUID())
			{
				continue;
			}

			int sceneIndex = occlusionCullingData.Scenes.IndexOf(t => t.Scene == cullingSetting.SceneGUID);
			if (sceneIndex == -1)
			{
				//Previously a logged error
				throw new Exception($"Unable to find scene data with GUID {cullingSetting.SceneGUID} in {occlusionCullingData.GetBestName()}");
			}

			IOcclusionScene scene = occlusionCullingData.Scenes[sceneIndex];
			if (scene.SizeRenderers != cullingSetting.StaticRenderers.Count)
			{
				throw new Exception($"Scene renderer count {scene.SizeRenderers} doesn't match with given {cullingSetting.StaticRenderers.Count}");
			}
			if (scene.SizePortals != cullingSetting.Portals.Count)
			{
				throw new Exception($"Scene portal count {scene.SizePortals} doesn't match with given {cullingSetting.Portals.Count}");
			}
			occlusionCullingData.SetIDs(container, cullingSetting, scene);
		}
	}

	private static void SetIDs(this IOcclusionCullingData occlusionCullingData, IExportContainer container, IOcclusionCullingSettings cullingSetting, IOcclusionScene scene)
	{
		PPtrAccessList<PPtr_Renderer_5, IRenderer> renderers = cullingSetting.StaticRenderersP;
		for (int i = 0; i < renderers.Count; i++)
		{
			IRenderer? renderer = renderers[i];
			occlusionCullingData.StaticRenderers[scene.IndexRenderers + i].SetObjectID(container, renderer);
		}

		PPtrAccessList<PPtr_OcclusionPortal_5_5, IOcclusionPortal> portals = cullingSetting.PortalsP;
		for (int i = 0; i < portals.Count; i++)
		{
			IOcclusionPortal? portal = portals[i];
			occlusionCullingData.Portals[scene.IndexPortals + i].SetObjectID(container, portal);
		}
	}

	private static void SetObjectID(this ISceneObjectIdentifier sceneObjectIdentifier, IExportContainer container, IUnityObjectBase? asset)
	{
		ArgumentNullException.ThrowIfNull(sceneObjectIdentifier);

		long lid = asset == null ? 0 : container.GetExportID(asset);
		sceneObjectIdentifier.TargetObject = lid;
		sceneObjectIdentifier.TargetPrefab = 0;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/FailExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.Logging;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.Export.UnityProjects;

public class FailExportCollection : IExportCollection
{
	public FailExportCollection(IAssetExporter assetExporter, IUnityObjectBase asset)
	{
		AssetExporter = assetExporter ?? throw new ArgumentNullException(nameof(assetExporter));
		m_asset = asset ?? throw new ArgumentNullException(nameof(asset));
	}

	public bool Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		Logger.Log(LogType.Warning, LogCategory.Export, $"Unable to export asset {Name}");
		return false;
	}

	public bool Contains(IUnityObjectBase asset)
	{
		return asset == m_asset;
	}

	public long GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		if (asset == m_asset)
		{
			return ExportIdHandler.GetMainExportID(m_asset);
		}
		throw new ArgumentException(null, nameof(asset));
	}

	public UnityGuid GetExportGUID(IUnityObjectBase _)
	{
		throw new NotSupportedException();
	}

	public MetaPtr CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		if (isLocal)
		{
			throw new ArgumentException(null, nameof(isLocal));
		}

		long exportId = GetExportID(container, asset);
		AssetType type = AssetExporter.ToExportType(asset);
		return new MetaPtr(exportId, UnityGuid.MissingReference, type);
	}

	public IAssetExporter AssetExporter { get; }
	public AssetCollection File => m_asset.Collection;
	public TransferInstructionFlags Flags => File.Flags;
	public IEnumerable<IUnityObjectBase> Assets
	{
		get { yield return m_asset; }
	}
	public string Name => m_asset.GetBestName();

	private readonly IUnityObjectBase m_asset;
}

```

`Source/AssetRipper.Export.UnityProjects/IAssetExporter.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Export.UnityProjects;

public interface IAssetExporter
{
	bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection);

	bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		Export(container, asset, path, fileSystem, null);
		return true;
	}
	void Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem, Action<IExportContainer, IUnityObjectBase, string, FileSystem>? callback)
	{
		throw new NotSupportedException();
	}
	bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, FileSystem fileSystem)
	{
		Export(container, assets, path, fileSystem, null);
		return true;
	}
	void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, FileSystem fileSystem, Action<IExportContainer, IUnityObjectBase, string, FileSystem>? callback)
	{
		throw new NotSupportedException();
	}

	AssetType ToExportType(IUnityObjectBase asset);
	bool ToUnknownExportType(Type type, out AssetType assetType);
}

```

`Source/AssetRipper.Export.UnityProjects/IExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.Export.UnityProjects;

public interface IExportCollection
{
	/// <summary>
	/// Export the assets in this collection.
	/// </summary>
	/// <param name="container"></param>
	/// <param name="projectDirectory">The directory containing the whole project including Assets and ProjectSettings.</param>
	/// <returns>True if export was successful.</returns>
	bool Export(IExportContainer container, string projectDirectory, FileSystem fileSystem);
	/// <summary>
	/// Is the asset part of this collection?
	/// </summary>
	bool Contains(IUnityObjectBase asset);
	/// <summary>
	/// Get the export ID of the asset.
	/// </summary>
	long GetExportID(IExportContainer container, IUnityObjectBase asset);
	MetaPtr CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal);

	AssetCollection File { get; }
	TransferInstructionFlags Flags { get; }
	IEnumerable<IUnityObjectBase> Assets { get; }
	IEnumerable<IUnityObjectBase> ExportableAssets => Assets;
	/// <summary>
	/// Does this collection save any files?
	/// </summary>
	bool Exportable => true;
	string Name { get; }
}

```

`Source/AssetRipper.Export.UnityProjects/IExportContainer.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;

namespace AssetRipper.Export.UnityProjects;

public interface IExportContainer
{
	long GetExportID(IUnityObjectBase asset);
	AssetType ToExportType(Type type);
	MetaPtr CreateExportPointer(IUnityObjectBase asset);

	UnityGuid ScenePathToGUID(string name);
	bool IsSceneDuplicate(int sceneID);

	AssetCollection File { get; }

	UnityVersion ExportVersion { get; }
}

```

`Source/AssetRipper.Export.UnityProjects/IPostExporter.cs`:

```cs
using AssetRipper.Export.Configuration;
using AssetRipper.Processing;

namespace AssetRipper.Export.UnityProjects;

public interface IPostExporter
{
	void DoPostExport(GameData gameData, FullConfiguration settings, FileSystem fileSystem);
}

```

`Source/AssetRipper.Export.UnityProjects/InvariantStreamWriter.cs`:

```cs
using System.Globalization;
using System.Text;

namespace AssetRipper.Export.UnityProjects;

internal sealed class InvariantStreamWriter : StreamWriter
{
	public InvariantStreamWriter(Stream stream) : base(stream) { }

	public InvariantStreamWriter(string path) : base(path) { }

	public InvariantStreamWriter(Stream stream, Encoding encoding) : base(stream, encoding) { }

	public InvariantStreamWriter(string path, bool append) : base(path, append) { }

	public InvariantStreamWriter(Stream stream, Encoding encoding, int bufferSize) : base(stream, encoding, bufferSize) { }

	public InvariantStreamWriter(string path, bool append, Encoding encoding) : base(path, append, encoding) { }

	public InvariantStreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen) : base(stream, encoding, bufferSize, leaveOpen) { }

	public InvariantStreamWriter(string path, bool append, Encoding encoding, int bufferSize) : base(path, append, encoding, bufferSize) { }

	public sealed override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;
}

```

`Source/AssetRipper.Export.UnityProjects/Meta.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.Yaml;


namespace AssetRipper.Export.UnityProjects;

public readonly struct Meta
{
	public Meta(UnityGuid guid, IUnityObjectBase importer) : this(guid, importer, true) { }

	public Meta(UnityGuid guid, IUnityObjectBase importer, bool hasLicense) : this(guid, importer, hasLicense, false) { }

	public Meta(UnityGuid guid, IUnityObjectBase importer, bool hasLicense, bool isFolder)
	{
		if (guid.IsZero)
		{
			throw new ArgumentNullException(nameof(guid));
		}

		GUID = guid;
		IsFolderAsset = isFolder;
		HasLicenseData = hasLicense;
		Importer = importer ?? throw new ArgumentNullException(nameof(importer));
	}

	private static int ToFileFormatVersion()
	{
		//This has been 2 for a long time, but probably not forever.
		//If Unity 3 usesd version 1, we need to find out when 2 started.
		return 2;
	}

	public YamlDocument ExportYamlDocument(IExportContainer container)
	{
		YamlDocument document = new();
		YamlMappingNode root = document.CreateMappingRoot();
		root.Add(FileFormatVersionName, ToFileFormatVersion());
		root.Add(GuidName, GUID.ToString());
		if (IsFolderAsset)
		{
			root.Add(FolderAssetName, true);
		}
		if (HasLicenseData)
		{
			root.Add(TimeCreatedName, CurrentTick);
			root.Add(LicenseTypeName, "Free");
		}
		//if (Importer.IncludesImporter(container.ExportVersion)) //For now, assume true
		{
			root.Add(Importer.ClassName, new ProjectYamlWalker(container) { ExportingAssetImporter = true }.ExportYamlNode(Importer));
		}
		return document;
	}

	public UnityGuid GUID { get; }
	public bool IsFolderAsset { get; }
	public bool HasLicenseData { get; }
	public IUnityObjectBase Importer { get; }

	private const long UnityEpoch = 0x089f7ff5f7b58000;

	private static long? _deterministicTimestamp;

	private static long CurrentTick
	{
		get
		{
			//If this is the first time we're writing out a timestamp, check whether `SOURCE_DATE_EPOCH` is set and cache it.
			//This should be a Unix timestamp as a decimal string. For more details on how tools can use this to improve build reproducibility, see: https://reproducible-builds.org/docs/source-date-epoch/#setting-the-variable
			_deterministicTimestamp ??= long.TryParse(Environment.GetEnvironmentVariable("SOURCE_DATE_EPOCH"), out long l)
				? SystemTimeToUnityTime(DateTimeOffset.FromUnixTimeSeconds(l))
				: -1;
			return _deterministicTimestamp is < 0
				? SystemTimeToUnityTime(DateTimeOffset.Now)
				: _deterministicTimestamp.Value;
			static long SystemTimeToUnityTime(DateTimeOffset time) => (time.UtcTicks - UnityEpoch) / 10000000;
		}
	}

	public const string FileFormatVersionName = "fileFormatVersion";
	public const string GuidName = "guid";
	public const string FolderAssetName = "folderAsset";
	public const string TimeCreatedName = "timeCreated";
	public const string LicenseTypeName = "licenseType";
}

```

`Source/AssetRipper.Export.UnityProjects/MetaPtr.cs`:

```cs
using AssetRipper.Yaml;

namespace AssetRipper.Export.UnityProjects;

public readonly record struct MetaPtr(long FileID, UnityGuid GUID, AssetType AssetType)
{
	public MetaPtr(long fileID) : this(fileID, UnityGuid.Zero, AssetType.Serialized)
	{
	}

	public YamlNode ExportYaml(UnityVersion exportVersion)
	{
		YamlMappingNode node = new();
		node.Style = MappingStyle.Flow;
		node.Add(FileIDName, FileID);
		if (!GUID.IsZero)
		{
			node.Add(GuidName, GUID.ToString());
			if (exportVersion.GreaterThanOrEquals(4) || AssetType is not AssetType.Meta)
			{
				node.Add(TypeName, (int)AssetType);
			}
			else
			{
				// For Unity 3, type 3 (Meta) is only used for 3d models.
				// All other imported assets (eg images and audio) use type 1 (Cached).
				// Since we only export yaml meshes during Unity project export and have no plans to change that,
				// we can safely redirect all type 3 references to type 1.
				// https://github.com/AssetRipper/AssetRipper/issues/1827
				// https://github.com/AssetRipper/AssetRipper/issues/1329
				node.Add(TypeName, (int)AssetType.Cached);
			}
		}
		return node;
	}

	/// <summary>
	/// Write this pointer to a string.
	/// </summary>
	/// <remarks>
	/// This uses the same format as Yaml.
	/// </remarks>
	/// <returns>This pointer expressed as a string.</returns>
	public override string ToString()
	{
		if (GUID.IsZero)
		{
			return $"{{{FileIDName}: {FileID}}}";
		}
		else
		{
			return $"{{{FileIDName}: {FileID}, {GuidName}: {GUID}, {TypeName}: {(int)AssetType}}}";
		}
	}

	public static MetaPtr NullPtr { get; } = new MetaPtr(0);

	public static MetaPtr CreateMissingReference(int classID, AssetType assetType)
	{
		return new MetaPtr(ExportIdHandler.GetMainExportID(classID), UnityGuid.MissingReference, assetType);
	}

	private const string FileIDName = "fileID";
	private const string GuidName = "guid";
	private const string TypeName = "type";
}

```

`Source/AssetRipper.Export.UnityProjects/Miscellaneous/FontAssetExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_1042;
using AssetRipper.SourceGenerated.Classes.ClassID_128;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_27;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Font;
using System.Diagnostics;

namespace AssetRipper.Export.UnityProjects.Miscellaneous;

public sealed class FontAssetExportCollection : AssetsExportCollection<IFont>
{
	public FontAssetExportCollection(FontAssetExporter assetExporter, IFont font) : base(assetExporter, font)
	{
		if (font.TryGetFontMaterial(out IMaterial? fontMaterial))
		{
			Debug.Assert(fontMaterial.MainAsset == font);
			AddAsset(fontMaterial);
		}
		if (font.TryGetFontTexture(out ITexture? fontTexture))
		{
			Debug.Assert(fontTexture.MainAsset == font);
			AddAsset(fontTexture);
		}
	}

	protected override IUnityObjectBase CreateImporter(IExportContainer container)
	{
		IFont origin = Asset;
		ITrueTypeFontImporter instance = TrueTypeFontImporter.Create(container.File, container.ExportVersion);
		instance.FontSize = (int)origin.FontSize;
		instance.IncludeFontData = true;
		instance.Style = (int)origin.GetDefaultStyle();
		if (origin.FontNames.Count > 0)
		{
			instance.FontName = origin.FontNames[0];
			foreach (Utf8String name in origin.FontNames)
			{
				instance.FontNames.Add(name);
			}
		}
		if (origin.Has_FallbackFonts() && instance.Has_FallbackFontReferences())
		{
			PPtrConverter ptrConverter = new(origin, instance);
			foreach (IPPtr_Font ptrFont in origin.FallbackFonts)
			{
				instance.FallbackFontReferences.AddNew().CopyValues(ptrFont, ptrConverter);
			}
		}
		instance.CharacterSpacing = origin.CharacterSpacing;
		instance.CharacterPadding = origin.CharacterPadding;
		instance.FontRenderingMode = origin.FontRenderingMode;
		instance.AscentCalculationModeE = AscentCalculationMode.FaceAscender;
		instance.ForceTextureCaseE = FontTextureCase.Dynamic;
		instance.UseLegacyBoundsCalculation = origin.UseLegacyBoundsCalculation;
		instance.ShouldRoundAdvanceValue = origin.ShouldRoundAdvanceValue;
		if (instance.Has_AssetBundleName_R() && origin.AssetBundleName is not null)
		{
			instance.AssetBundleName_R = origin.AssetBundleName;
		}
		return instance;
	}

	protected override string GetExportExtension(IUnityObjectBase asset)
	{
		return ((IFont)asset).GetFontExtension();
	}

	protected override long GenerateExportID(IUnityObjectBase asset)
	{
		Debug.Assert(asset is IMaterial or ITexture);
		return ExportIdHandler.GetMainExportID(asset);
		//The font material always has the same id: 2100000
		//Source: https://github.com/AssetRipper/TestProjects/blob/b19ddf4550504790d9da266d4fb4ec457859076e/2018/4/FontExportTest/Assets/Scenes/SampleScene.unity#LL172C14-L172C21

		//The font texture is assumed to be 2800000, but has not been verified.
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Miscellaneous/FontAssetExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_128;

namespace AssetRipper.Export.UnityProjects.Miscellaneous;

public sealed class FontAssetExporter : BinaryAssetExporter
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset.MainAsset is IFont font && IsValidData(font.FontData))
		{
			exportCollection = new FontAssetExportCollection(this, font);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public override bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, FileSystem fileSystem)
	{
		IFont font = assets.OfType<IFont>().Single();
		fileSystem.File.WriteAllBytes(path, font.FontData);
		return true;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Miscellaneous/MovieTextureAssetExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_152;

namespace AssetRipper.Export.UnityProjects.Miscellaneous;

public sealed class MovieTextureAssetExportCollection : AssetExportCollection<IMovieTexture>
{
	public MovieTextureAssetExportCollection(MovieTextureAssetExporter assetExporter, IMovieTexture asset) : base(assetExporter, asset)
	{
	}

	protected override string GetExportExtension(IUnityObjectBase asset) => "ogv";
}

```

`Source/AssetRipper.Export.UnityProjects/Miscellaneous/MovieTextureAssetExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_152;

namespace AssetRipper.Export.UnityProjects.Miscellaneous;

public sealed class MovieTextureAssetExporter : BinaryAssetExporter
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is IMovieTexture texture && IsValidData(texture.MovieData))
		{
			exportCollection = new MovieTextureAssetExportCollection(this, texture);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		fileSystem.File.WriteAllBytes(path, ((IMovieTexture)asset).MovieData!);
		return true;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Miscellaneous/TextAssetExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Configuration;
using AssetRipper.SourceGenerated.Classes.ClassID_1031;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using System.Text.Json;

namespace AssetRipper.Export.UnityProjects.Miscellaneous;

public sealed class TextAssetExportCollection : AssetExportCollection<ITextAsset>
{
	private const string JsonExtension = "json";
	private const string TxtExtension = "txt";
	private const string BytesExtension = "bytes";

	private static readonly HashSet<string> DangerousExtensions = new(StringComparer.OrdinalIgnoreCase)
	{
		"cs", "dll", "exe", "bat", "cmd", "ps1", "vbs", "js", "msi", "scr", "com"
	};

	public TextAssetExportCollection(TextAssetExporter assetExporter, ITextAsset asset) : base(assetExporter, asset)
	{
	}

	protected override string GetExportExtension(IUnityObjectBase asset)
	{
		string? extension = asset.GetBestExtension();
		if (extension is not null)
		{
			if (DangerousExtensions.Contains(extension))
			{
				return TxtExtension;
			}
			return extension;
		}
		return ((TextAssetExporter)AssetExporter).ExportMode switch
		{
			TextExportMode.Txt => TxtExtension,
			TextExportMode.Parse => GetExtension((ITextAsset)asset),
			_ => BytesExtension,
		};
	}

	private static string GetExtension(ITextAsset asset)
	{
		string text = asset.Script_C49.String;
		if (IsValidJson(text))
		{
			return JsonExtension;
		}
		else if (IsPlainText(text))
		{
			return TxtExtension;
		}
		else
		{
			return BytesExtension;
		}
	}

	private static bool IsValidJson(string text)
	{
		try
		{
			using JsonDocument? parsed = JsonDocument.Parse(text);
			return parsed != null;
		}
		catch
		{
			return false;
		}
	}

	private static bool IsPlainText(string text) => text.All(c => !char.IsControl(c) || char.IsWhiteSpace(c));

	protected override ITextScriptImporter CreateImporter(IExportContainer container)
	{
		ITextScriptImporter importer = TextScriptImporter.Create(container.File, container.ExportVersion);
		if (importer.Has_AssetBundleName_R() && Asset.AssetBundleName is not null)
		{
			importer.AssetBundleName_R = Asset.AssetBundleName;
		}
		return importer;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Miscellaneous/TextAssetExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Configuration;
using AssetRipper.SourceGenerated.Classes.ClassID_49;

namespace AssetRipper.Export.UnityProjects.Miscellaneous;

public sealed class TextAssetExporter : BinaryAssetExporter
{
	public TextExportMode ExportMode { get; }
	public TextAssetExporter(FullConfiguration configuration)
	{
		ExportMode = configuration.ExportSettings.TextExportMode;
	}

	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is ITextAsset textAsset && !textAsset.Script_C49.IsEmpty)
		{
			exportCollection = new TextAssetExportCollection(this, textAsset);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		fileSystem.File.WriteAllBytes(path, ((ITextAsset)asset).Script_C49.Data);
		return true;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Miscellaneous/VideoClipExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_1127;
using AssetRipper.SourceGenerated.Classes.ClassID_329;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.UnityProjects.Miscellaneous;

public sealed class VideoClipExportCollection : AssetExportCollection<IVideoClip>
{
	public VideoClipExportCollection(VideoClipExporter assetExporter, IVideoClip asset) : base(assetExporter, asset)
	{
	}

	protected override string GetExportExtension(IUnityObjectBase asset)
	{
		return Asset.GetExtensionFromPath();
	}

	protected override IVideoClipImporter CreateImporter(IExportContainer container)
	{
		//There may be more fields to set here. I did not throughly check.

		IVideoClipImporter importer = VideoClipImporter.Create(container.File, container.ExportVersion);
		importer.EndFrame = (int)Asset.FrameCount;
		if (importer.Has_SourceFileSize())
		{
			importer.OriginalHeight = (int)Asset.Height;
			importer.OriginalWidth = (int)Asset.Width;
			importer.SourceFileSize = Asset.ExternalResources.Size;
		}
		importer.FrameRate = Asset.FrameRate;
		importer.FrameCount = importer.EndFrame;
		importer.ImportAudio = true;
		if (importer.Has_AssetBundleName_R() && Asset.AssetBundleName is not null)
		{
			importer.AssetBundleName_R = Asset.AssetBundleName;
		}
		return importer;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Miscellaneous/VideoClipExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_329;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.UnityProjects.Miscellaneous;

public sealed class VideoClipExporter : BinaryAssetExporter
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is IVideoClip clip && clip.ExternalResources.CheckIntegrity(clip.Collection))
		{
			exportCollection = new VideoClipExportCollection(this, clip);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		if (((IVideoClip)asset).TryGetContent(out byte[]? data))
		{
			fileSystem.File.WriteAllBytes(path, data);
			return true;
		}
		else
		{
			return false;
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/PathIdMapping/PathIdMapExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Export.Configuration;
using AssetRipper.Processing;
using AssetRipper.SourceGenerated.Classes.ClassID_27;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using System.Text.Json;

namespace AssetRipper.Export.UnityProjects.PathIdMapping;

public sealed class PathIdMapExporter : IPostExporter
{
	public void DoPostExport(GameData gameData, FullConfiguration settings, FileSystem fileSystem)
	{
		SerializedGameInfo gameInfo = new();
		foreach (SerializedAssetCollection collection in gameData.GameBundle.FetchAssetCollections().OfType<SerializedAssetCollection>())
		{
			SerializedFileInfo fileInfo = new()
			{
				Name = collection.Name,
			};
			gameInfo.Files.Add(fileInfo);
			foreach (IUnityObjectBase asset in collection)
			{
				if (asset is IMesh or ITexture or IAudioClip or ITextAsset)//Commonly useful asset types
				{
					fileInfo.Assets.Add(new()
					{
						Name = (asset as INamed)?.Name,
						Type = asset.ClassName,
						PathID = asset.PathID,
					});
				}
			}
		}

		string outputDirectory = settings.AuxiliaryFilesPath;
		fileSystem.Directory.Create(outputDirectory);
		using Stream stream = fileSystem.File.Create(fileSystem.Path.Join(outputDirectory, "path_id_map.json"));
		JsonSerializer.Serialize(stream, gameInfo, SerializedGameInfoSerializerContext.Default.SerializedGameInfo);
		stream.Flush();
	}
}

```

`Source/AssetRipper.Export.UnityProjects/PathIdMapping/SerializedAssetInfo.cs`:

```cs
namespace AssetRipper.Export.UnityProjects.PathIdMapping;

internal sealed class SerializedAssetInfo
{
	public long PathID { get; set; }
	public string? Name { get; set; }
	public string? Type { get; set; }
}

```

`Source/AssetRipper.Export.UnityProjects/PathIdMapping/SerializedFileInfo.cs`:

```cs
namespace AssetRipper.Export.UnityProjects.PathIdMapping;

internal sealed class SerializedFileInfo
{
	public string? Name { get; set; }
	public List<SerializedAssetInfo> Assets { get; set; } = new();
}

```

`Source/AssetRipper.Export.UnityProjects/PathIdMapping/SerializedGameInfo.cs`:

```cs
namespace AssetRipper.Export.UnityProjects.PathIdMapping;

internal sealed class SerializedGameInfo
{
	public List<SerializedFileInfo> Files { get; set; } = new();
}

```

`Source/AssetRipper.Export.UnityProjects/PathIdMapping/SerializedGameInfoSerializerContext.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.Export.UnityProjects.PathIdMapping;

[JsonSourceGenerationOptions(WriteIndented = true)]
[JsonSerializable(typeof(SerializedGameInfo))]
internal sealed partial class SerializedGameInfoSerializerContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.Export.UnityProjects/Project/AssetsExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;

namespace AssetRipper.Export.UnityProjects.Project;

/// <summary>
/// A collection of assets that are exported together.
/// </summary>
/// <typeparam name="T">The type of <see cref="AssetExportCollection{T}.Asset"/>.</typeparam>
public abstract class AssetsExportCollection<T> : AssetExportCollection<T> where T : IUnityObjectBase
{
	public AssetsExportCollection(IAssetExporter assetExporter, T asset) : base(assetExporter, asset)
	{
		m_file = asset.Collection;
	}

	public override bool Contains(IUnityObjectBase asset)
	{
		return base.Contains(asset) || m_exportIDs.ContainsKey(asset);
	}

	public override long GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		if (asset.AssetInfo == Asset.AssetInfo)
		{
			return base.GetExportID(container, asset);
		}
		return m_exportIDs[asset];
	}

	protected override bool ExportInner(IExportContainer container, string filePath, string dirPath, FileSystem fileSystem)
	{
		return AssetExporter.Export(container, ExportableAssets, filePath, fileSystem);
	}

	public override IEnumerable<IUnityObjectBase> Assets
	{
		get
		{
			foreach (IUnityObjectBase asset in base.Assets)
			{
				m_file = asset.Collection;
				yield return asset;
			}
			foreach ((IUnityObjectBase asset, long _) in m_exportIDs)
			{
				m_file = asset.Collection;
				yield return asset;
			}
		}
	}

	protected virtual long GenerateExportID(IUnityObjectBase asset)
	{
		return ExportIdHandler.GetPseudoRandomExportId(asset, m_exportIDs.Count);
	}

	/// <summary>
	/// Add an asset to this export collection.
	/// </summary>
	/// <param name="asset">The asset to be added to this export collection.</param>
	/// <returns><see langword="true"/> if the <paramref name="asset"/> is added to the <see cref="AssetsExportCollection"/> object; <see langword="false"/> if the <paramref name="asset"/> is already present.</returns>
	protected bool AddAsset(IUnityObjectBase? asset)
	{
		if (asset is null || asset == (IUnityObjectBase)Asset)
		{
			return false;
		}

		long exportID = GenerateExportID(asset);
		return m_exportIDs.TryAdd(asset, exportID);
	}

	protected void AddAssets(IEnumerable<IUnityObjectBase?> assets)
	{
		foreach (IUnityObjectBase? asset in assets)
		{
			AddAsset(asset);
		}
	}

	public override AssetCollection File => m_file;
	protected AssetCollection m_file;

	/// <summary>
	/// A one-to-one dictionary of export id's
	/// </summary>
	private readonly Dictionary<IUnityObjectBase, long> m_exportIDs = new();
}

```

`Source/AssetRipper.Export.UnityProjects/Project/DefaultYamlExporter.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Export.UnityProjects.Project;

public class DefaultYamlExporter : YamlExporterBase
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		exportCollection = new AssetExportCollection<IUnityObjectBase>(this, asset);
		return true;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/EditorBuildSettingsExportCollection.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_1045;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.Scene;

namespace AssetRipper.Export.UnityProjects.Project;

public sealed class EditorBuildSettingsExportCollection : ManagerExportCollection
{
	public EditorBuildSettingsExportCollection(IAssetExporter assetExporter, IEditorBuildSettings asset) : base(assetExporter, asset)
	{
	}

	public override bool Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		SetSceneGuidValues((IEditorBuildSettings)Asset, container);
		return base.Export(container, projectDirectory, fileSystem);
	}

	private static void SetSceneGuidValues(IEditorBuildSettings editorBuildSettings, IExportContainer container)
	{
		foreach (IScene scene in editorBuildSettings.Scenes)
		{
			if (scene.Has_Guid())
			{
				scene.Guid.CopyValues(container.ScenePathToGUID(Path.ChangeExtension(scene.Path, null)));
			}
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/ManagerAssetExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Import.AssetCreation;
using AssetRipper.SourceGenerated.Classes.ClassID_1045;
using AssetRipper.SourceGenerated.Classes.ClassID_6;

namespace AssetRipper.Export.UnityProjects.Project;

public class ManagerAssetExporter : YamlExporterBase
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is IGlobalGameManager or TypeTreeObject { IsPlayerSettings: true })
		{
			exportCollection = asset is IEditorBuildSettings editorBuildSettings
				? new EditorBuildSettingsExportCollection(this, editorBuildSettings)
				: new ManagerExportCollection(this, asset);
			return true;
		}
		exportCollection = null;
		return false;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/ManagerExportCollection.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Export.UnityProjects.Project;

public class ManagerExportCollection : AssetExportCollection<IUnityObjectBase>
{
	public ManagerExportCollection(IAssetExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset) { }

	public override bool Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		string subPath = fileSystem.Path.Join(projectDirectory, ProjectSettingsName);
		string name = GetCorrectName(Asset.ClassName);
		string fileName = $"{name}.asset";
		string filePath = fileSystem.Path.Join(subPath, fileName);

		fileSystem.Directory.Create(subPath);

		ExportInner(container, filePath, projectDirectory, fileSystem);
		return true;
	}

	public override long GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		if (asset == Asset)
		{
			return 1;
		}
		throw new ArgumentException(null, nameof(asset));
	}

	public override MetaPtr CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		throw new NotSupportedException();
	}

	private static string GetCorrectName(string typeName)
	{
		return typeName switch
		{
			PlayerSettingsName or "129" => ProjectSettingsName,
			NavMeshProjectSettingsName => NavMeshAreasName,
			PhysicsManagerName => DynamicsManagerName,
			_ => typeName,
		};
	}

	//Type names
	protected const string PlayerSettingsName = "PlayerSettings";
	protected const string NavMeshProjectSettingsName = "NavMeshProjectSettings";
	protected const string PhysicsManagerName = "PhysicsManager";

	//Altered names
	protected const string ProjectSettingsName = "ProjectSettings";
	protected const string NavMeshAreasName = "NavMeshAreas";
	protected const string DynamicsManagerName = "DynamicsManager";
}

```

`Source/AssetRipper.Export.UnityProjects/Project/PackageManifest.cs`:

```cs
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AssetRipper.Export.UnityProjects.Project;

public record class PackageManifest([property: JsonPropertyName("dependencies")] Dictionary<string, string> Dependencies)
{
	public PackageManifest() : this(new Dictionary<string, string>())
	{
	}

	public void Save(Stream stream)
	{
		JsonSerializer.Serialize(stream, this, PackageManifestSerializerContext.Default.PackageManifest);
	}

	public static PackageManifest CreateDefault(UnityVersion version)
	{
		PackageManifest manifest = new();
		manifest.AddDefaultDependencies(version);
		return manifest;
	}

	public void AddDefaultDependencies(UnityVersion version)
	{
		// This should be accurate to at least 2023

		Dependencies.TryAdd("com.unity.modules.ai", "1.0.0");
		if (version.GreaterThanOrEquals(2019, 2))
		{
			Dependencies.TryAdd("com.unity.modules.androidjni", "1.0.0");
		}
		Dependencies.TryAdd("com.unity.modules.animation", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.assetbundle", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.audio", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.cloth", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.director", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.imageconversion", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.imgui", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.jsonserialize", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.particlesystem", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.physics", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.physics2d", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.screencapture", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.terrain", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.terrainphysics", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.tilemap", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.ui", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.uielements", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.umbra", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.unityanalytics", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.unitywebrequest", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.unitywebrequestassetbundle", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.unitywebrequestaudio", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.unitywebrequesttexture", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.unitywebrequestwww", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.vehicles", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.video", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.vr", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.wind", "1.0.0");
		Dependencies.TryAdd("com.unity.modules.xr", "1.0.0");
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/PackageManifestPostExporter.cs`:

```cs
using AssetRipper.Export.Configuration;
using AssetRipper.Processing;

namespace AssetRipper.Export.UnityProjects.Project;

public class PackageManifestPostExporter : IPostExporter
{
	public void DoPostExport(GameData gameData, FullConfiguration settings, FileSystem fileSystem)
	{
		string packagesDirectory = fileSystem.Path.Join(settings.ProjectRootPath, "Packages");
		fileSystem.Directory.Create(packagesDirectory);
		string path = fileSystem.Path.Join(packagesDirectory, "manifest.json");
		using Stream stream = fileSystem.File.Create(path);
		CreateManifest(settings.Version).Save(stream);
	}

	protected virtual PackageManifest CreateManifest(UnityVersion version)
	{
		return PackageManifest.CreateDefault(version);
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/PackageManifestSerializerContext.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.Export.UnityProjects.Project;

[JsonSerializable(typeof(PackageManifest))]
[JsonSourceGenerationOptions(WriteIndented = true)]
internal partial class PackageManifestSerializerContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.Export.UnityProjects/Project/PrefabExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.Processing.Prefabs;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_468431735;
using AssetRipper.SourceGenerated.MarkerInterfaces;

namespace AssetRipper.Export.UnityProjects.Project;

public class PrefabExportCollection : AssetsExportCollection<IPrefabInstance>
{
	public PrefabExportCollection(IAssetExporter assetExporter, PrefabHierarchyObject prefabHierarchyObject)
		: base(assetExporter, prefabHierarchyObject.Prefab)
	{
		RootGameObject = prefabHierarchyObject.Root;
		Prefab = prefabHierarchyObject.Prefab;
		Hierarchy = prefabHierarchyObject;
		AddAssets(prefabHierarchyObject.Assets);
		AddAsset(prefabHierarchyObject);
	}

	protected override string GetExportExtension(IUnityObjectBase asset) => PrefabKeyword;

	public override TransferInstructionFlags Flags => base.Flags | TransferInstructionFlags.SerializeForPrefabSystem;
	public IGameObject RootGameObject { get; }
	public IPrefabInstance Prefab { get; }
	public PrefabHierarchyObject Hierarchy { get; }
	/// <summary>
	/// Prior to 2018.3, Prefab was an actual asset inside "*.prefab" files.
	/// After that, PrefabImporter and PrefabInstance were introduced as a replacement.
	/// </summary>
	public bool EmitPrefabAsset => Prefab is IPrefabMarker;
	public override string Name => RootGameObject.Name;

	protected override IUnityObjectBase CreateImporter(IExportContainer container)
	{
		if (EmitPrefabAsset)
		{
			return base.CreateImporter(container);
		}
		else
		{
			IPrefabImporter importer = PrefabImporter.Create(container.File, container.ExportVersion);
			if (RootGameObject.AssetBundleName is not null)
			{
				importer.AssetBundleName_R = RootGameObject.AssetBundleName;
			}
			return importer;
		}
	}

	public override IEnumerable<IUnityObjectBase> ExportableAssets
	{
		get
		{
			foreach (IUnityObjectBase asset in Hierarchy.ExportableAssets)
			{
				m_file = asset.Collection;
				yield return asset;
			}
		}
	}

	/// <summary>
	/// Used for <see cref="IPrefabInstance.SourcePrefab"/>
	/// </summary>
	/// <returns></returns>
	public MetaPtr GenerateMetaPtrForPrefab()
	{
		return new MetaPtr(
			ExportIdHandler.GetMainExportID((int)ClassIDType.PrefabInstance),
			GUID,
			EmitPrefabAsset ? AssetType.Serialized : AssetType.Meta);
	}

	public const string PrefabKeyword = "prefab";
}

```

`Source/AssetRipper.Export.UnityProjects/Project/ProjectVersionPostExporter.cs`:

```cs
using AssetRipper.Export.Configuration;
using AssetRipper.Processing;
using System.Text;

namespace AssetRipper.Export.UnityProjects.Project;

public sealed class ProjectVersionPostExporter : IPostExporter
{
	public void DoPostExport(GameData gameData, FullConfiguration settings, FileSystem fileSystem)
	{
		// Although Unity 4 and lower don't have this file, we leave it in anyway for user readibility.
		SaveProjectVersion(settings.ProjectSettingsPath, settings.Version, fileSystem);
	}

	private static void SaveProjectVersion(string projectSettingsDirectory, UnityVersion version, FileSystem fileSystem)
	{
		fileSystem.Directory.Create(projectSettingsDirectory);
		using Stream fileStream = fileSystem.File.Create(fileSystem.Path.Join(projectSettingsDirectory, "ProjectVersion.txt"));
		using StreamWriter writer = new InvariantStreamWriter(fileStream, new UTF8Encoding(false));
		writer.Write($"m_EditorVersion: {version}\n");
		if (version.Equals(5))
		{
			//Unity 5 has an extra line
			//Even on beta versions, this always seems to be zero.
			writer.Write("m_StandardAssetsVersion: 0\n");
		}

		//Beginning with 2019.1.0a10, ProjectVersion.txt files have an additional line.
		//m_EditorVersionWithRevision: 2019.4.3f1 (f880dceab6fe)
		//The revision is always 6 bytes.

		//Beginning with 2019.3.0a5, it can be acquired with the FileVersionInfo class in the System.Diagnostics namespace.
		//FileVersionInfo versionInfo = FileVersionInfo.GetVersionInfo("path/to/Unity.exe");
		//string productVersion = versionInfo.ProductVersion; //For example: 2019.4.3f1_f880dceab6fe
		//string revision = productVersion.Substring(productVersion.IndexOf('_') + 1);

		//For 2019.3.0a4 and earlier, versionInfo.ProductVersion is equal to versionInfo.FileVersion.
		//versionInfo.FileVersion is the same format for all Unity versions: 2019.4.3.16285916
		//The fourth number contains half of the revision and is a 24-bit big-endian integer.
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/ProjectYamlWalker.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using AssetRipper.SourceGenerated.Subclasses.SceneObjectIdentifier;
using AssetRipper.Yaml;

namespace AssetRipper.Export.UnityProjects.Project;

public sealed class ProjectYamlWalker : YamlWalker
{
	private readonly IExportContainer container;

	public ProjectYamlWalker(IExportContainer container)
	{
		this.container = container;
		WithUnityVersion(container.ExportVersion);
	}

	public IUnityObjectBase CurrentAsset { get; set; } = null!;

	public YamlDocument ExportYamlDocument(IUnityObjectBase asset)
	{
		CurrentAsset = asset;
		return ExportYamlDocument(asset, container.GetExportID(asset));
	}

	public YamlNode ExportYamlNode(IUnityObjectBase asset)
	{
		CurrentAsset = asset;
		return base.ExportYamlNode(asset);
	}

	public override bool EnterAsset(IUnityAssetBase asset)
	{
		if (asset is SceneObjectIdentifier sceneObjectIdentifier)
		{
			long targetObject = sceneObjectIdentifier.TargetObjectReference is not null
				? container.CreateExportPointer(sceneObjectIdentifier.TargetObjectReference).FileID
				: sceneObjectIdentifier.TargetObject;
			long targetPrefab = sceneObjectIdentifier.TargetPrefabReference is not null
				? container.CreateExportPointer(sceneObjectIdentifier.TargetPrefabReference).FileID
				: sceneObjectIdentifier.TargetPrefab;
			YamlMappingNode yamlMappingNode = new()
			{
				{ YamlScalarNode.Create("targetObject"), targetObject },
				{ YamlScalarNode.Create("targetPrefab"), targetPrefab },
			};
			AddNode(yamlMappingNode);
			return false;
		}
		else
		{
			return base.EnterAsset(asset);
		}
	}

	public override YamlNode CreateYamlNodeForPPtr<TAsset>(PPtr<TAsset> pptr)
	{
		if (pptr.PathID == 0)
		{
			return MetaPtr.NullPtr.ExportYaml(container.ExportVersion);
		}
		else if (CurrentAsset.Collection.TryGetAsset(pptr, out TAsset? asset))
		{
			return container.CreateExportPointer(asset).ExportYaml(container.ExportVersion);
		}
		else
		{
			AssetType assetType = container.ToExportType(typeof(TAsset));
			MetaPtr pointer = MetaPtr.CreateMissingReference(GetClassID(typeof(TAsset)), assetType);
			return pointer.ExportYaml(container.ExportVersion);
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/SceneAssetExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_1032;

namespace AssetRipper.Export.UnityProjects.Project;

public sealed class SceneAssetExportCollection : IExportCollection
{
	public ISceneAsset Asset { get; }
	public SceneDefinition TargetScene => Asset.TargetScene ?? throw new NullReferenceException();

	public SceneAssetExportCollection(ISceneAsset asset)
	{
		Asset = asset;
	}

	public AssetCollection File => Asset.Collection;
	public TransferInstructionFlags Flags => File.Flags;
	public IEnumerable<IUnityObjectBase> Assets
	{
		get
		{
			yield return Asset;
		}
	}

	public string Name => $"{TargetScene.Name} (SceneAsset)";

	public MetaPtr CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		return new MetaPtr(GetExportID(), TargetScene.GUID, AssetType.Meta);
	}

	private static long GetExportID()
	{
		return ExportIdHandler.GetMainExportID((int)ClassIDType.DefaultAsset);
	}

	public bool Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		return true;
	}

	public long GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		return GetExportID();
	}

	public bool Contains(IUnityObjectBase asset)
	{
		return asset == Asset;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/SceneAssetExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_1032;

namespace AssetRipper.Export.UnityProjects.Project;

public sealed class SceneAssetExporter : IAssetExporter
{
	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is ISceneAsset sceneAsset)
		{
			exportCollection = new SceneAssetExportCollection(sceneAsset);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public AssetType ToExportType(IUnityObjectBase asset)
	{
		return AssetType.Meta;
	}

	public bool ToUnknownExportType(Type type, out AssetType assetType)
	{
		assetType = AssetType.Meta;
		return true;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/SceneExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.Logging;
using AssetRipper.Processing.Prefabs;
using AssetRipper.Processing.Scenes;
using AssetRipper.SourceGenerated.Classes.ClassID_1030;
using AssetRipper.SourceGenerated.Classes.ClassID_3;

namespace AssetRipper.Export.UnityProjects.Project;

public class SceneExportCollection : ExportCollection, IComparer<IUnityObjectBase>
{
	public SceneExportCollection(IAssetExporter assetExporter, SceneHierarchyObject hierarchy)
	{
		ArgumentNullException.ThrowIfNull(assetExporter);
		ArgumentNullException.ThrowIfNull(hierarchy);

		AssetExporter = assetExporter;
		Hierarchy = hierarchy;
		CurrentFile = Hierarchy.Collection;//Have to set it to something.

		int index = 0;
		foreach (IUnityObjectBase asset in Hierarchy.Assets)
		{
			m_exportIDs.Add(asset, asset.Collection is SerializedAssetCollection ? asset.PathID : ExportIdHandler.GetPseudoRandomValue(index++));
		}

		componentArray = hierarchy.ExportableAssets.Order(this).ToArray();
	}

	public override bool Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		string filePath = fileSystem.Path.Join(projectDirectory, $"{Scene.Path}.{ExportExtension}");
		string folderPath = fileSystem.Path.GetDirectoryName(filePath)!;

		if (IsSceneDuplicate(container))
		{
			if (fileSystem.File.Exists(filePath))
			{
				Logger.Log(LogType.Warning, LogCategory.Export, $"Duplicate scene '{Scene.Path}' has been found. Skipping");
				return false;
			}
		}

		fileSystem.Directory.Create(folderPath);
		return ExportScene(container, folderPath, filePath, Scene.Name, fileSystem);
	}

	protected virtual bool ExportScene(IExportContainer container, string folderPath, string filePath, string sceneName, FileSystem fileSystem)
	{
		AssetExporter.Export(container, ExportableAssets, filePath, fileSystem);
		IDefaultImporter sceneImporter = DefaultImporter.Create(container.File, container.ExportVersion);
		if (sceneImporter.Has_AssetBundleName_R() && Hierarchy.AssetBundleName is not null)
		{
			sceneImporter.AssetBundleName_R = Hierarchy.AssetBundleName;
		}
		Meta meta = new Meta(GUID, sceneImporter);
		ExportMeta(container, meta, filePath, fileSystem);
		return true;
	}

	public override bool Contains(IUnityObjectBase asset)
	{
		return m_exportIDs.ContainsKey(asset);
	}

	public override long GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		return m_exportIDs[asset];
	}

	public override MetaPtr CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		long exportID = GetExportID(container, asset);
		if (isLocal)
		{
			return new MetaPtr(exportID);
		}
		else
		{
			return new MetaPtr(exportID, GUID, AssetType.Serialized);
		}
	}

	public int Compare(IUnityObjectBase? obj1, IUnityObjectBase? obj2)
	{
		if (obj1?.ClassID == obj2?.ClassID)
		{
			return 0;
		}

		if (obj1 is ILevelGameManager)
		{
			if (obj2 is ILevelGameManager)
			{
				return obj1.ClassID < obj2.ClassID ? -1 : 1;
			}
			else
			{
				return -1;
			}
		}
		else if (obj2 is ILevelGameManager)
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}

	private bool IsSceneDuplicate(IExportContainer container)
	{
		if (SceneHelpers.TryGetFileNameToSceneIndex(File.Name, File.OriginalVersion, out int index))
		{
			return container.IsSceneDuplicate(index);
		}
		return false;
	}

	public override IEnumerable<IUnityObjectBase> Assets
	{
		get
		{
			foreach (IUnityObjectBase asset in Hierarchy.Assets)
			{
				CurrentFile = asset.Collection;
				yield return asset;
			}
			CurrentFile = Hierarchy.Collection;
			yield return Hierarchy;
		}
	}

	public override IEnumerable<IUnityObjectBase> ExportableAssets
	{
		get
		{
			foreach (IUnityObjectBase asset in componentArray)
			{
				CurrentFile = asset.Collection;
				yield return asset;
			}
		}
	}

	public virtual string ExportExtension => "unity";

	/// <summary>
	/// The <see cref="SceneDefinition.Name"/> of <see cref="Scene"/>.
	/// </summary>
	public override string Name => Scene.Name;

	public override AssetCollection File => CurrentFile;
	public override UnityGuid GUID => Scene.GUID;
	public override IAssetExporter AssetExporter { get; }
	public SceneHierarchyObject Hierarchy { get; }
	public SceneDefinition Scene => Hierarchy.Scene;
	private AssetCollection CurrentFile { get; set; }

	private readonly IUnityObjectBase[] componentArray;
	private readonly Dictionary<IUnityObjectBase, long> m_exportIDs = new();
}

```

`Source/AssetRipper.Export.UnityProjects/Project/SceneYamlExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Processing.Prefabs;

namespace AssetRipper.Export.UnityProjects.Project;

public class SceneYamlExporter : YamlExporterBase
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		switch (asset.MainAsset)
		{
			case SceneHierarchyObject sceneHierarchyObject:
				exportCollection = new SceneExportCollection(this, sceneHierarchyObject);
				return true;
			case PrefabHierarchyObject prefabHierarchyObject:
				exportCollection = new PrefabExportCollection(this, prefabHierarchyObject);
				return true;
			default:
				exportCollection = null;
				return false;
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/ScriptableObjectExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.UnityProjects.Project;

public class ScriptableObjectExporter : YamlExporterBase
{
	private IExportCollection CreateCollection(IMonoBehaviour monoBehaviour)
	{
		if (monoBehaviour.IsComponentOnGameObject())
		{
			return EmptyExportCollection.Instance;
		}
		else
		{
			return new ScriptableObjectExportCollection(this, monoBehaviour);
		}
	}

	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		exportCollection = asset switch
		{
			IMonoBehaviour monoBehaviour => CreateCollection(monoBehaviour),
			_ => null,
		};
		return exportCollection is not null;
	}

	private sealed class ScriptableObjectExportCollection : AssetExportCollection<IMonoBehaviour>
	{
		public ScriptableObjectExportCollection(ScriptableObjectExporter exporter, IMonoBehaviour asset) : base(exporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			IMonoBehaviour monoBehaviour = (IMonoBehaviour)asset;
			if (monoBehaviour.IsGuiSkin())
			{
				return "guiskin";
			}
			else if (monoBehaviour.IsBrush())
			{
				return "brush";
			}
			return base.GetExportExtension(asset);
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/ScriptableObjectGroupExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Processing.ScriptableObject;
using AssetRipper.SourceGenerated.Classes.ClassID_114;

namespace AssetRipper.Export.UnityProjects.Project;

public class ScriptableObjectGroupExporter : YamlExporterBase
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		switch (asset.MainAsset)
		{
			case ScriptableObjectGroup playableAssetGroup:
				exportCollection = new ScriptableObjectGroupExportCollection(this, playableAssetGroup);
				return true;
			default:
				exportCollection = null;
				return false;
		}
	}

	private sealed class ScriptableObjectGroupExportCollection : AssetsExportCollection<IMonoBehaviour>
	{
		public ScriptableObjectGroup Group { get; }
		public ScriptableObjectGroupExportCollection(ScriptableObjectGroupExporter exporter, ScriptableObjectGroup group) : base(exporter, group.Root)
		{
			Group = group;
			AddAssets(group.Children);
		}

		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			return Group.FileExtension ?? base.GetExportExtension(asset);
		}

		public override IEnumerable<IUnityObjectBase> Assets => base.Assets.Prepend(Group);

		public override IEnumerable<IUnityObjectBase> ExportableAssets => base.Assets;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/StreamingAssetsPostExporter.cs`:

```cs
using AssetRipper.Export.Configuration;
using AssetRipper.Import.Configuration;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Platforms;
using AssetRipper.Processing;

namespace AssetRipper.Export.UnityProjects.Project;

public class StreamingAssetsPostExporter : IPostExporter
{
	public void DoPostExport(GameData gameData, FullConfiguration settings, FileSystem fileSystem)
	{
		PlatformGameStructure? platform = gameData.PlatformStructure;
		if (platform is null)
		{
			return;
		}

		if (settings.ImportSettings.StreamingAssetsMode == StreamingAssetsMode.Ignore)
		{
			return;
		}

		string? inputDirectory = platform.StreamingAssetsPath;
		if (!string.IsNullOrEmpty(inputDirectory) && platform.FileSystem.Directory.Exists(inputDirectory))
		{
			Logger.Info(LogCategory.Export, "Copying streaming assets...");
			string outputDirectory = fileSystem.Path.Join(settings.AssetsPath, "StreamingAssets");

			fileSystem.Directory.Create(outputDirectory);

			foreach (string directory in platform.FileSystem.Directory.EnumerateDirectories(inputDirectory, "*", SearchOption.AllDirectories))
			{
				string relativePath = platform.FileSystem.Path.GetRelativePath(inputDirectory, directory);
				fileSystem.Directory.Create(fileSystem.Path.Join(outputDirectory, relativePath));
			}

			foreach (string file in platform.FileSystem.Directory.EnumerateFiles(inputDirectory, "*", SearchOption.AllDirectories))
			{
				string relativePath = platform.FileSystem.Path.GetRelativePath(inputDirectory, file);
				string newFile = fileSystem.Path.Join(outputDirectory, relativePath);

				using Stream readStream = platform.FileSystem.File.OpenRead(file);
				using Stream writeStream = fileSystem.File.Create(newFile);
				readStream.CopyTo(writeStream);
			}
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/UnityPatches.cs`:

```cs
using System.Text;

namespace AssetRipper.Export.UnityProjects.Project;

public static class UnityPatches
{
	private const string RelativePathToPatchesDirectory = "Assets/Editor/AssetRipperPatches/";

	/// <summary>
	/// For some asset types, the complete recovery must be assisted by scripts that run in the Unity Editor.
	/// This method copies a script file from a <see cref="string"/> to the exported project.
	/// </summary>
	/// <param name="text">The text of the patch</param>
	/// <param name="name">The name of the patch</param>
	/// <param name="exportDirectoryPath">The path of the exported project</param>
	public static void ApplyPatchFromText(string text, string name, string exportDirectoryPath, FileSystem fileSystem)
	{
		string patchFileName = $"{name}.cs";
		string patchDirectoryPath = fileSystem.Path.Join(exportDirectoryPath, RelativePathToPatchesDirectory);
		string patchFilePath = fileSystem.Path.Join(patchDirectoryPath, patchFileName);
		if (fileSystem.File.Exists(patchFilePath))
		{
			return;
		}

		fileSystem.Directory.Create(patchDirectoryPath);
		fileSystem.File.WriteAllBytes(patchFilePath, Encoding.UTF8.GetBytes(text));
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/YamlExporterBase.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Yaml;
using System.Text;

namespace AssetRipper.Export.UnityProjects.Project;

public abstract class YamlExporterBase : IAssetExporter
{
	public abstract bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection);

	public bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		using Stream fileStream = fileSystem.File.Create(path);
		using InvariantStreamWriter streamWriter = new InvariantStreamWriter(fileStream, UTF8);
		YamlWriter writer = new();
		ProjectYamlWalker walker = new(container);
		YamlDocument doc = walker.ExportYamlDocument(asset);
		writer.AddDocument(doc);
		writer.Write(streamWriter);
		return true;
	}

	public void Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem, Action<IExportContainer, IUnityObjectBase, string, FileSystem>? callback)
	{
		Export(container, asset, path, fileSystem);
		callback?.Invoke(container, asset, path, fileSystem);
	}

	public bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, FileSystem fileSystem)
	{
		using Stream fileStream = fileSystem.File.Create(path);
		using InvariantStreamWriter streamWriter = new InvariantStreamWriter(fileStream, UTF8);
		YamlWriter writer = new();
		writer.WriteHead(streamWriter);
		ProjectYamlWalker walker = new(container);
		foreach (IUnityObjectBase asset in assets)
		{
			YamlDocument doc = walker.ExportYamlDocument(asset);
			writer.WriteDocument(doc);
		}
		writer.WriteTail(streamWriter);
		return true;
	}

	public void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, FileSystem fileSystem, Action<IExportContainer, IUnityObjectBase, string, FileSystem>? callback)
	{
		throw new NotSupportedException("Yaml supports only single file export");
	}

	public AssetType ToExportType(IUnityObjectBase asset)
	{
		return AssetType.Serialized;
	}

	public bool ToUnknownExportType(Type type, out AssetType assetType)
	{
		assetType = AssetType.Serialized;
		return true;
	}

	private static readonly Encoding UTF8 = new UTF8Encoding(false);
}

```

`Source/AssetRipper.Export.UnityProjects/Project/YamlStreamedAssetExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_189;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.UnityProjects.Project;

public sealed class YamlStreamedAssetExportCollection : AssetExportCollection<IUnityObjectBase>
{
	public YamlStreamedAssetExportCollection(IAssetExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
	{
	}

	protected override bool ExportInner(IExportContainer container, string filePath, string dirPath, FileSystem fileSystem)
	{
		return Asset switch
		{
			IMesh mesh => ExportMesh(container, filePath, dirPath, mesh, fileSystem),
			IImageTexture texture => ExportTexture(container, filePath, dirPath, texture, fileSystem),
			_ => false,
		};
	}

	private bool ExportMesh(IExportContainer container, string filePath, string dirPath, IMesh mesh, FileSystem fileSystem)
	{
		if (!mesh.Has_StreamData())
		{
			return base.ExportInner(container, filePath, dirPath, fileSystem);
		}

		bool result;
		mesh.StreamData.GetValues(out Utf8String path, out ulong offset, out uint size);
		if (mesh.VertexData.Data.Length != 0)
		{
			mesh.StreamData.ClearValues();
			result = base.ExportInner(container, filePath, dirPath, fileSystem);
		}
		else
		{
			mesh.VertexData.Data = mesh.StreamData.GetContent(mesh.Collection);
			mesh.StreamData.ClearValues();
			result = base.ExportInner(container, filePath, dirPath, fileSystem);
			mesh.VertexData.Data = [];
		}
		mesh.StreamData.SetValues(path, offset, size);

		return result;
	}

	private bool ExportTexture(IExportContainer container, string filePath, string dirPath, IImageTexture texture, FileSystem fileSystem)
	{
		if (!texture.Has_StreamData_C189())
		{
			return base.ExportInner(container, filePath, dirPath, fileSystem);
		}

		bool result;
		texture.StreamData_C189.GetValues(out Utf8String path, out ulong offset, out uint size);
		if (texture.ImageData_C189.Length != 0)
		{
			texture.StreamData_C189.ClearValues();
			result = base.ExportInner(container, filePath, dirPath, fileSystem);
		}
		else
		{
			byte[]? data = texture.StreamData_C189.GetContent(texture.Collection);
			if (data.IsNullOrEmpty())
			{
				return false;
			}
			texture.ImageData_C189 = data;
			texture.StreamData_C189.ClearValues();
			result = base.ExportInner(container, filePath, dirPath, fileSystem);
			texture.ImageData_C189 = [];
		}
		texture.StreamData_C189.SetValues(path, offset, size);

		return result;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Project/YamlStreamedAssetExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_189;
using AssetRipper.SourceGenerated.Classes.ClassID_43;

namespace AssetRipper.Export.UnityProjects.Project;

public sealed class YamlStreamedAssetExporter : YamlExporterBase
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is IMesh or IImageTexture)
		{
			exportCollection = new YamlStreamedAssetExportCollection(this, asset);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/ProjectAssetContainer.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.Import.Configuration;
using AssetRipper.Processing.Scenes;
using AssetRipper.SourceGenerated.Classes.ClassID_141;
using System.Diagnostics;


namespace AssetRipper.Export.UnityProjects;

public class ProjectAssetContainer : IExportContainer
{
	public ProjectAssetContainer(ProjectExporter exporter, CoreConfiguration options, IEnumerable<IUnityObjectBase> assets,
		IReadOnlyList<IExportCollection> collections)
	{
		m_exporter = exporter ?? throw new ArgumentNullException(nameof(exporter));
		CurrentCollection = null!;

		ExportVersion = options.Version;

		m_buildSettings = assets.OfType<IBuildSettings>().FirstOrDefault();

		List<SceneExportCollection> scenes = new();
		foreach (IExportCollection collection in collections)
		{
			foreach (IUnityObjectBase asset in collection.Assets)
			{
				CheckIfAlreadyAdded(this, asset, collection);
				m_assetCollections.Add(asset, collection);
			}
			if (collection is SceneExportCollection scene)
			{
				scenes.Add(scene);
			}
		}
		m_scenes = scenes.ToArray();

		[Conditional("DEBUG")]
		static void CheckIfAlreadyAdded(ProjectAssetContainer container, IUnityObjectBase asset, IExportCollection currentCollection)
		{
			if (container.m_assetCollections.TryGetValue(asset, out IExportCollection? previousCollection))
			{
				throw new ArgumentException($"Asset {asset} is already added by {previousCollection}");
			}
		}
	}

	public long GetExportID(IUnityObjectBase asset)
	{
		if (m_assetCollections.TryGetValue(asset, out IExportCollection? collection))
		{
			return collection.GetExportID(this, asset);
		}

		return ExportIdHandler.GetMainExportID(asset);
	}

	public AssetType ToExportType(Type type)
	{
		return m_exporter.ToExportType(type);
	}

	public MetaPtr CreateExportPointer(IUnityObjectBase asset)
	{
		if (m_assetCollections.TryGetValue(asset, out IExportCollection? collection))
		{
			return collection.CreateExportPointer(this, asset, collection == CurrentCollection);
		}

		return MetaPtr.CreateMissingReference(asset.ClassID, AssetType.Meta);
	}

	public UnityGuid ScenePathToGUID(string path)
	{
		foreach (SceneExportCollection scene in m_scenes)
		{
			if (scene.Scene.Path == path)
			{
				return scene.GUID;
			}
		}
		return default;
	}

	public bool IsSceneDuplicate(int sceneIndex) => SceneHelpers.IsSceneDuplicate(sceneIndex, m_buildSettings);

	public IExportCollection CurrentCollection { get; set; }
	public AssetCollection File => CurrentCollection.File;
	public UnityVersion ExportVersion { get; }

	private readonly ProjectExporter m_exporter;
	private readonly Dictionary<IUnityObjectBase, IExportCollection> m_assetCollections = new();

	private readonly IBuildSettings? m_buildSettings;
	private readonly SceneExportCollection[] m_scenes;
}

```

`Source/AssetRipper.Export.UnityProjects/ProjectExporter.Overrides.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Configuration;
using AssetRipper.Export.UnityProjects.AnimatorControllers;
using AssetRipper.Export.UnityProjects.Audio;
using AssetRipper.Export.UnityProjects.AudioMixers;
using AssetRipper.Export.UnityProjects.DeletedAssets;
using AssetRipper.Export.UnityProjects.EngineAssets;
using AssetRipper.Export.UnityProjects.Miscellaneous;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.Export.UnityProjects.RawAssets;
using AssetRipper.Export.UnityProjects.Scripts;
using AssetRipper.Export.UnityProjects.Shaders;
using AssetRipper.Export.UnityProjects.Terrains;
using AssetRipper.Export.UnityProjects.Textures;
using AssetRipper.Import.AssetCreation;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.Mining.PredefinedAssets;
using AssetRipper.Processing.ScriptableObject;
using AssetRipper.Processing.Textures;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_1032;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Classes.ClassID_116;
using AssetRipper.SourceGenerated.Classes.ClassID_117;
using AssetRipper.SourceGenerated.Classes.ClassID_128;
using AssetRipper.SourceGenerated.Classes.ClassID_141;
using AssetRipper.SourceGenerated.Classes.ClassID_142;
using AssetRipper.SourceGenerated.Classes.ClassID_147;
using AssetRipper.SourceGenerated.Classes.ClassID_150;
using AssetRipper.SourceGenerated.Classes.ClassID_152;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using AssetRipper.SourceGenerated.Classes.ClassID_187;
using AssetRipper.SourceGenerated.Classes.ClassID_188;
using AssetRipper.SourceGenerated.Classes.ClassID_189;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_240;
using AssetRipper.SourceGenerated.Classes.ClassID_244;
using AssetRipper.SourceGenerated.Classes.ClassID_27;
using AssetRipper.SourceGenerated.Classes.ClassID_272;
using AssetRipper.SourceGenerated.Classes.ClassID_273;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_290;
using AssetRipper.SourceGenerated.Classes.ClassID_3;
using AssetRipper.SourceGenerated.Classes.ClassID_329;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using AssetRipper.SourceGenerated.Classes.ClassID_6;
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Classes.ClassID_94;

namespace AssetRipper.Export.UnityProjects;

partial class ProjectExporter
{
	public ProjectExporter(FullConfiguration settings, IAssemblyManager assemblyManager)
	{
		OverrideExporter<IUnityObjectBase>(new DefaultYamlExporter(), true);

		ManagerAssetExporter managerExporter = new();
		OverrideExporter<IGlobalGameManager>(managerExporter, true);
		OverrideExporter<TypeTreeObject>(managerExporter, true);

		OverrideExporter<IMonoBehaviour>(new ScriptableObjectExporter(), true);

		SceneYamlExporter sceneExporter = new();
		OverrideExporter<IPrefabInstance>(sceneExporter, true);
		OverrideExporter<IGameObject>(sceneExporter, true);
		OverrideExporter<IComponent>(sceneExporter, true);
		OverrideExporter<ILevelGameManager>(sceneExporter, true);

		OverrideDummyExporter<IBuildSettings>(true, false);
		OverrideDummyExporter<IPreloadData>(true, false);
		OverrideDummyExporter<IAssetBundle>(true, false);
		OverrideDummyExporter<IAssetBundleManifest>(true, false);
		OverrideDummyExporter<IMonoManager>(true, false);
		OverrideDummyExporter<IResourceManager>(true, false);
		OverrideDummyExporter<IShaderNameRegistry>(true, false);

		OverrideExporter<ISceneAsset>(new SceneAssetExporter(), true);

		if (settings.ExportSettings.ExportUnreadableAssets)
		{
			OverrideExporter<UnknownObject>(new UnknownObjectExporter(), false);
			OverrideExporter<UnreadableObject>(new UnreadableObjectExporter(), false);
		}
		else
		{
			OverrideDummyExporter<UnknownObject>(false, false);
			OverrideDummyExporter<UnreadableObject>(false, false);
		}

		//Yaml Exporters
		YamlStreamedAssetExporter streamedAssetExporter = new();
		OverrideExporter<IMesh>(streamedAssetExporter);
		OverrideExporter<IImageTexture>(streamedAssetExporter);

		//Miscellaneous exporters
		OverrideExporter<ITextAsset>(new TextAssetExporter(settings));
		OverrideExporter<IMovieTexture>(new MovieTextureAssetExporter());
		OverrideExporter<IVideoClip>(new VideoClipExporter());

		//Texture exporters
		TextureAssetExporter textureExporter = new(settings);
		OverrideExporter<ITexture2D>(textureExporter); //Texture2D and Cubemap
		OverrideExporter<ISprite>(textureExporter);
		OverrideExporter<SpriteInformationObject>(textureExporter);
		if (settings.ExportSettings.SpriteExportMode == SpriteExportMode.Yaml)
		{
			YamlSpriteExporter spriteExporter = new();
			OverrideExporter<ISprite>(spriteExporter);
			OverrideExporter<ISpriteAtlas>(spriteExporter);
		}
		if (settings.ExportSettings.LightmapTextureExportFormat is not LightmapTextureExportFormat.Yaml)
		{
			OverrideExporter<ITexture2D>(new LightmapTextureAssetExporter(settings.ExportSettings.LightmapTextureExportFormat is LightmapTextureExportFormat.Exr
				? ImageExportFormat.Exr
				: settings.ExportSettings.ImageExportFormat));
		}

		//Texture Array exporters
		if (settings.Version.GreaterThanOrEquals(2020, 2))
		{
			TextureArrayAssetExporter textureArrayExporter = new(settings);
			OverrideExporter<ICubemapArray>(textureArrayExporter);
			OverrideExporter<ITexture2DArray>(textureArrayExporter);
			OverrideExporter<ITexture3D>(textureArrayExporter);
		}

		//Font exporter
		FontAssetExporter fontAssetExporter = new FontAssetExporter();
		OverrideExporter<IFont>(fontAssetExporter);
		OverrideExporter<IMaterial>(fontAssetExporter);
		OverrideExporter<ITexture>(fontAssetExporter);

		//Shader exporters
		OverrideExporter<IShader>(settings.ExportSettings.ShaderExportMode switch
		{
			ShaderExportMode.Yaml => new YamlShaderExporter(),
			_ => new DummyShaderTextExporter(),
		});
		OverrideExporter<IShader>(new SimpleShaderExporter());

		//Audio exporters
		OverrideExporter<IAudioClip>(new YamlAudioExporter());
		if (settings.ExportSettings.AudioExportFormat == AudioExportFormat.Native)
		{
			OverrideExporter<IAudioClip>(new NativeAudioExporter());
		}
		if (AudioClipExporter.IsSupportedExportFormat(settings.ExportSettings.AudioExportFormat))
		{
			OverrideExporter<IAudioClip>(new AudioClipExporter(settings));
		}

		//AudioMixer exporters
		AudioMixerExporter audioMixerExporter = new();
		OverrideExporter<IAudioMixer>(audioMixerExporter);
		OverrideExporter<IAudioMixerEffectController>(audioMixerExporter);
		OverrideExporter<IAudioMixerGroup>(audioMixerExporter);
		OverrideExporter<IAudioMixerSnapshot>(audioMixerExporter);

		//Terrain exporter
		TerrainYamlExporter terrainYamlExporter = new();
		OverrideExporter<ITerrainData>(terrainYamlExporter);
		OverrideExporter<ITexture2D>(terrainYamlExporter);

		//Script exporter
		OverrideExporter<IMonoScript>(new ScriptExporter(assemblyManager, settings));

		//Animator Controller
		OverrideExporter<IUnityObjectBase>(new AnimatorControllerExporter());

		//Playable assets
		ScriptableObjectGroupExporter scriptableObjectGroupExporter = new();
		OverrideExporter<IMonoBehaviour>(scriptableObjectGroupExporter);
		OverrideExporter<ScriptableObjectGroup>(scriptableObjectGroupExporter);
	}

	//These need to be absolutely last
	public void DoFinalOverrides(FullConfiguration settings)
	{
		//Engine assets
		OverrideExporter<IUnityObjectBase>(settings.SingletonData.TryGetStoredValue(nameof(EngineResourceData), out EngineResourceData? engineResourceData)
			&& engineResourceData is not null
			? EngineAssetsExporter.CreateFromResourceData(engineResourceData.Value)
			: EngineAssetsExporter.CreateFromEmbeddedData(settings.Version));

		//Deleted assets
		OverrideExporter<IUnityObjectBase>(new DeletedAssetsExporter());
	}
}

```

`Source/AssetRipper.Export.UnityProjects/ProjectExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Import.Configuration;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated;

namespace AssetRipper.Export.UnityProjects;

public sealed partial class ProjectExporter
{
	public event Action? EventExportPreparationStarted;
	public event Action? EventExportPreparationFinished;
	public event Action? EventExportStarted;
	public event Action<int, int>? EventExportProgressUpdated;
	public event Action? EventExportFinished;

	private readonly ObjectHandlerStack<IAssetExporter> assetExporterStack = new();

	/// <summary>Adds an exporter to the stack of exporters for this asset type.</summary>
	/// <typeparam name="T">The c sharp type of this asset type. Any inherited types also get this exporter.</typeparam>
	/// <param name="exporter">The new exporter. If it doesn't work, the next one in the stack is used.</param>
	/// <param name="allowInheritance">Should types that inherit from this type also use the exporter?</param>
	public void OverrideExporter<T>(IAssetExporter exporter, bool allowInheritance = true)
	{
		assetExporterStack.OverrideHandler(typeof(T), exporter, allowInheritance);
	}

	/// <summary>Adds an exporter to the stack of exporters for this asset type.</summary>
	/// <param name="type">The c sharp type of this asset type. Any inherited types also get this exporter.</param>
	/// <param name="exporter">The new exporter. If it doesn't work, the next one in the stack is used.</param>
	/// <param name="allowInheritance">Should types that inherit from this type also use the exporter?</param>
	public void OverrideExporter(Type type, IAssetExporter exporter, bool allowInheritance)
	{
		assetExporterStack.OverrideHandler(type, exporter, allowInheritance);
	}

	/// <summary>
	/// Use the <see cref="DummyExporter"/> for the specified class type.
	/// </summary>
	/// <typeparam name="T">The base type for assets of that <paramref name="classType"/>.</typeparam>
	/// <param name="isEmptyCollection">
	/// True: an exception will be thrown if the asset is referenced by another asset.<br/>
	/// False: any references to this asset will be replaced with a missing reference.
	/// </param>
	/// <param name="isMetaType"><see cref="AssetType.Meta"/> or <see cref="AssetType.Serialized"/>?</param>
	private void OverrideDummyExporter<T>(bool isEmptyCollection, bool isMetaType)
	{
		OverrideExporter<T>(DummyAssetExporter.Get(isEmptyCollection, isMetaType), true);
	}

	public AssetType ToExportType(Type type)
	{
		foreach (IAssetExporter exporter in assetExporterStack.GetHandlerStack(type))
		{
			if (exporter.ToUnknownExportType(type, out AssetType assetType))
			{
				return assetType;
			}
		}
		throw new NotSupportedException($"There is no exporter that know {nameof(AssetType)} for unknown asset '{type}'");
	}

	private IExportCollection CreateCollection(IUnityObjectBase asset)
	{
		foreach (IAssetExporter exporter in assetExporterStack.GetHandlerStack(asset.GetType()))
		{
			if (exporter.TryCreateCollection(asset, out IExportCollection? collection))
			{
				return collection;
			}
		}
		throw new Exception($"There is no exporter that can handle '{asset}'");
	}

	public void Export(GameBundle fileCollection, CoreConfiguration options, FileSystem fileSystem)
	{
		EventExportPreparationStarted?.Invoke();
		List<IExportCollection> collections = CreateCollections(fileCollection);
		EventExportPreparationFinished?.Invoke();

		EventExportStarted?.Invoke();
		ProjectAssetContainer container = new ProjectAssetContainer(this, options, fileCollection.FetchAssets(), collections);
		int exportableCount = collections.Count(c => c.Exportable);
		int currentExportable = 0;

		for (int i = 0; i < collections.Count; i++)
		{
			IExportCollection collection = collections[i];
			container.CurrentCollection = collection;
			if (collection.Exportable)
			{
				currentExportable++;
				Logger.Info(LogCategory.ExportProgress, $"({currentExportable}/{exportableCount}) Exporting '{collection.Name}'");
				bool exportedSuccessfully = collection.Export(container, options.ProjectRootPath, fileSystem);
				if (!exportedSuccessfully)
				{
					Logger.Warning(LogCategory.ExportProgress, $"Failed to export '{collection.Name}' ({collection.GetType().Name})");
				}
			}
			EventExportProgressUpdated?.Invoke(i, collections.Count);
		}
		EventExportFinished?.Invoke();
	}

	private List<IExportCollection> CreateCollections(GameBundle fileCollection)
	{
		List<IExportCollection> collections = new();
		HashSet<IUnityObjectBase> queued = new();

		foreach (IUnityObjectBase asset in fileCollection.FetchAssets())
		{
			if (!queued.Contains(asset))
			{
				IExportCollection collection = CreateCollection(asset);
				foreach (IUnityObjectBase element in collection.Assets)
				{
					queued.Add(element);
				}
				collections.Add(collection);
			}
		}

		return collections;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/RawAssets/UnknownExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.AssetCreation;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.Export.UnityProjects.RawAssets;

public sealed class UnknownExportCollection : ExportCollection
{
	UnknownObject Asset { get; }
	public override IAssetExporter AssetExporter { get; }

	public UnknownExportCollection(IAssetExporter exporter, UnknownObject asset)
	{
		Asset = asset;
		AssetExporter = exporter;
	}

	public override AssetCollection File => Asset.Collection;

	public override TransferInstructionFlags Flags => Asset.Collection.Flags;

	public override IEnumerable<IUnityObjectBase> Assets
	{
		get { yield return Asset; }
	}

	public override string Name => Asset.Name;

	public override MetaPtr CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		return MetaPtr.NullPtr;
	}

	public override bool Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		string resourcePath = fileSystem.Path.Join(projectDirectory, "AssetRipper", "UnknownAssets", Asset.ClassName, $"{Asset.Name}.unknown");
		string subPath = fileSystem.Path.GetDirectoryName(resourcePath)!;
		fileSystem.Directory.Create(subPath);
		string resFileName = fileSystem.Path.GetFileName(resourcePath);
		string fileName = GetUniqueFileName(subPath, resFileName, fileSystem);
		string filePath = fileSystem.Path.Join(subPath, fileName);
		return AssetExporter.Export(container, Asset, filePath, fileSystem);
	}

	public override long GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		throw new NotSupportedException();
	}

	public override bool Contains(IUnityObjectBase asset)
	{
		return asset == Asset;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/RawAssets/UnknownObjectExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Import.AssetCreation;

namespace AssetRipper.Export.UnityProjects.RawAssets;

public sealed class UnknownObjectExporter : IAssetExporter
{
	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is UnknownObject @object)
		{
			exportCollection = new UnknownExportCollection(this, @object);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		fileSystem.File.WriteAllBytes(path, ((UnknownObject)asset).RawData);
		return true;
	}

	public void Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem, Action<IExportContainer, IUnityObjectBase, string, FileSystem>? callback)
	{
		if (Export(container, asset, path, fileSystem))
		{
			callback?.Invoke(container, asset, path, fileSystem);
		}
	}

	public bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, FileSystem fileSystem)
	{
		bool success = true;
		foreach (IUnityObjectBase asset in assets)
		{
			success &= Export(container, asset, path, fileSystem);
		}
		return success;
	}

	public void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, FileSystem fileSystem, Action<IExportContainer, IUnityObjectBase, string, FileSystem>? callback)
	{
		foreach (IUnityObjectBase asset in assets)
		{
			Export(container, asset, path, fileSystem, callback);
		}
	}

	public AssetType ToExportType(IUnityObjectBase asset)
	{
		return AssetType.Meta;
	}

	public bool ToUnknownExportType(Type type, out AssetType assetType)
	{
		assetType = AssetType.Meta;
		return true;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/RawAssets/UnreadableExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.AssetCreation;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.Export.UnityProjects.RawAssets;

public sealed class UnreadableExportCollection : ExportCollection
{
	UnreadableObject Asset { get; }
	public override IAssetExporter AssetExporter { get; }

	public UnreadableExportCollection(IAssetExporter exporter, UnreadableObject asset)
	{
		Asset = asset;
		AssetExporter = exporter;
	}

	public override AssetCollection File => Asset.Collection;

	public override TransferInstructionFlags Flags => Asset.Collection.Flags;

	public override IEnumerable<IUnityObjectBase> Assets
	{
		get { yield return Asset; }
	}

	public override string Name => Asset.Name;

	public override MetaPtr CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		return MetaPtr.NullPtr;
	}

	public override bool Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		string name = FileSystem.FixInvalidPathCharacters(Asset.Name);
		string resourcePath = fileSystem.Path.Join(projectDirectory, "AssetRipper", "UnreadableAssets", Asset.ClassName, $"{name}.unreadable");
		string subPath = fileSystem.Path.GetDirectoryName(resourcePath)!;
		fileSystem.Directory.Create(subPath);
		string resFileName = fileSystem.Path.GetFileName(resourcePath);
		string fileName = GetUniqueFileName(subPath, resFileName, fileSystem);
		string filePath = fileSystem.Path.Join(subPath, fileName);
		return AssetExporter.Export(container, Asset, filePath, fileSystem);
	}

	public override long GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		throw new NotSupportedException();
	}

	public override bool Contains(IUnityObjectBase asset)
	{
		return asset == Asset;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/RawAssets/UnreadableObjectExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Import.AssetCreation;

namespace AssetRipper.Export.UnityProjects.RawAssets;

internal class UnreadableObjectExporter : IAssetExporter
{
	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is UnreadableObject @object)
		{
			exportCollection = new UnreadableExportCollection(this, @object);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		fileSystem.File.WriteAllBytes(path, ((UnreadableObject)asset).RawData);
		return true;
	}

	public void Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem, Action<IExportContainer, IUnityObjectBase, string, FileSystem>? callback)
	{
		if (Export(container, asset, path, fileSystem))
		{
			callback?.Invoke(container, asset, path, fileSystem);
		}
	}

	public bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, FileSystem fileSystem)
	{
		bool success = true;
		foreach (IUnityObjectBase? asset in assets)
		{
			success &= Export(container, asset, path, fileSystem);
		}
		return success;
	}

	public void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, FileSystem fileSystem, Action<IExportContainer, IUnityObjectBase, string, FileSystem>? callback)
	{
		foreach (IUnityObjectBase asset in assets)
		{
			Export(container, asset, path, fileSystem, callback);
		}
	}

	public AssetType ToExportType(IUnityObjectBase asset)
	{
		return AssetType.Meta;
	}

	public bool ToUnknownExportType(Type type, out AssetType assetType)
	{
		assetType = AssetType.Meta;
		return true;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/RedirectExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Files.SerializedFiles;
using System.Diagnostics;

namespace AssetRipper.Export.UnityProjects;

public sealed class RedirectExportCollection : IExportCollection
{
	private readonly Dictionary<IUnityObjectBase, MetaPtr> redirectionDictionary = new();
	private readonly Dictionary<IUnityObjectBase, AssetType> missingDictionary = new();

	public IEnumerable<IUnityObjectBase> Assets
	{
		get
		{
			if (missingDictionary.Count == 0)
			{
				return redirectionDictionary.Keys;
			}
			else if (redirectionDictionary.Count == 0)
			{
				return missingDictionary.Keys;
			}
			else
			{
				return redirectionDictionary.Keys.Concat(missingDictionary.Keys);
			}
		}
	}

	public string Name => redirectionDictionary.Count == 1 ? redirectionDictionary.Keys.First().GetBestName() : nameof(RedirectExportCollection);

	public void Add(IUnityObjectBase asset, long exportID, UnityGuid guid, AssetType assetType)
	{
		ArgumentOutOfRangeException.ThrowIfEqual(exportID, 0);
		ArgumentOutOfRangeException.ThrowIfEqual(guid, UnityGuid.MissingReference);
		ArgumentOutOfRangeException.ThrowIfEqual(guid, UnityGuid.Zero);

		redirectionDictionary.Add(asset, new MetaPtr(exportID, guid, assetType));
	}

	public void AddMissing(IUnityObjectBase asset, AssetType assetType)
	{
		missingDictionary.Add(asset, assetType);
	}

	public MetaPtr CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		ThrowIfLocal(isLocal);

		if (missingDictionary.TryGetValue(asset, out AssetType missingAssetType))
		{
			return MetaPtr.CreateMissingReference(asset.ClassID, missingAssetType);
		}

		return redirectionDictionary[asset];

		[StackTraceHidden]
		static void ThrowIfLocal(bool isLocal)
		{
			if (isLocal)
			{
				throw new NotSupportedException();
			}
		}
	}

	public long GetExportID(IExportContainer container, IUnityObjectBase asset) => redirectionDictionary[asset].FileID;

	public bool Contains(IUnityObjectBase asset) => redirectionDictionary.ContainsKey(asset) || missingDictionary.ContainsKey(asset);

	bool IExportCollection.Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		throw new NotSupportedException();
	}

	bool IExportCollection.Exportable => false;

	AssetCollection IExportCollection.File => throw new NotSupportedException();

	TransferInstructionFlags IExportCollection.Flags => throw new NotSupportedException();
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/AssemblyData.cs`:

```cs
namespace AssetRipper.Export.UnityProjects.Scripts;

internal readonly record struct AssemblyData(IReadOnlyList<string> Mono2, IReadOnlyList<string> Mono4, IReadOnlyList<string> Unity, IReadOnlyList<KeyValuePair<string, UnityGuid>> UnityExtensions)
{
	public bool Equals(AssemblyData other)
	{
		return Mono2.SequenceEqual(other.Mono2) && Mono4.SequenceEqual(other.Mono4) && Unity.SequenceEqual(other.Unity) && UnityExtensions.SequenceEqual(other.UnityExtensions);
	}

	public override int GetHashCode()
	{
		HashCode hash = new();
		foreach (string assembly in Mono2)
		{
			hash.Add(assembly);
		}
		foreach (string assembly in Mono4)
		{
			hash.Add(assembly);
		}
		foreach (string assembly in Unity)
		{
			hash.Add(assembly);
		}
		foreach (KeyValuePair<string, UnityGuid> pair in UnityExtensions)
		{
			hash.Add(pair);
		}
		return hash.ToHashCode();
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/AssemblyDataFile.cs`:

```cs
using AssetRipper.SourceGenerated;
using System.Text.Json;

namespace AssetRipper.Export.UnityProjects.Scripts;

internal readonly record struct AssemblyDataFile(IReadOnlyList<UnityVersion> Versions, IReadOnlyList<KeyValuePair<UnityVersion, AssemblyData>> Assemblies)
{
	public static AssemblyDataFile Load()
	{
		return JsonSerializer.Deserialize(ReferenceAssembliesJson.GetStream(), AssemblyDataSerializerContext.Default.AssemblyDataFile);
	}

	public AssemblyData Get(UnityVersion version)
	{
		if (version < Assemblies[1].Key)
		{
			return Assemblies[0].Value;
		}
		if (version >= Assemblies[^1].Key)
		{
			return Assemblies[^1].Value;
		}

		// Binary search
		// We want to find the index of the last element that is less than or equal to the target.
		int low = 0;
		int high = Assemblies.Count - 1;
		while (low < high)
		{
			int mid = (low + high + 1) / 2;
			if (Assemblies[mid].Key <= version)
			{
				low = mid;
			}
			else
			{
				high = mid - 1;
			}
		}

		return Assemblies[low].Value;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/AssemblyDataSerializerContext.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.Export.UnityProjects.Scripts;

[JsonSourceGenerationOptions(GenerationMode = JsonSourceGenerationMode.Metadata)]
[JsonSerializable(typeof(AssemblyDataFile))]
internal sealed partial class AssemblyDataSerializerContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/AssemblyDefinitions/AssemblyDefinitionAsset.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.Export.UnityProjects.Scripts.AssemblyDefinitions;

public sealed class AssemblyDefinitionAsset
{
	[JsonPropertyName("name")]
	public string Name { get; set; }
	[JsonPropertyName("references")]
	public List<string> References { get; set; }
	[JsonPropertyName("allowUnsafeCode")]
	public bool AllowUnsafeCode { get; set; }

	public AssemblyDefinitionAsset(string name)
	{
		Name = name;
		AllowUnsafeCode = true;
		References = new();
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/AssemblyDefinitions/AssemblyDefinitionDetails.cs`:

```cs
using AsmResolver.DotNet;

namespace AssetRipper.Export.UnityProjects.Scripts.AssemblyDefinitions;

public readonly struct AssemblyDefinitionDetails : IEquatable<AssemblyDefinitionDetails>
{
	public readonly string AssemblyName;
	public readonly string OutputFolder;
	public readonly AssemblyDefinition? Assembly;

	public AssemblyDefinitionDetails(AssemblyDefinition assembly, string outputFolder)
	{
		AssemblyName = assembly.Name!;
		OutputFolder = outputFolder;
		Assembly = assembly;
	}

	public AssemblyDefinitionDetails(string assemblyName, string outputFolder)
	{
		AssemblyName = assemblyName;
		OutputFolder = outputFolder;
		Assembly = null;
	}

	public override bool Equals(object? obj)
	{
		return obj is AssemblyDefinitionDetails details && Equals(details);
	}

	public bool Equals(AssemblyDefinitionDetails other)
	{
		return AssemblyName == other.AssemblyName &&
			   OutputFolder == other.OutputFolder &&
			   EqualityComparer<AssemblyDefinition?>.Default.Equals(Assembly, other.Assembly);
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(AssemblyName, OutputFolder, Assembly);
	}

	public static bool operator ==(AssemblyDefinitionDetails left, AssemblyDefinitionDetails right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(AssemblyDefinitionDetails left, AssemblyDefinitionDetails right)
	{
		return !(left == right);
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/AssemblyDefinitions/AssemblyDefinitionExporter.cs`:

```cs
using AsmResolver.DotNet;
using System.Text.Json;

namespace AssetRipper.Export.UnityProjects.Scripts.AssemblyDefinitions;

public static class AssemblyDefinitionExporter
{
	public static void Export(AssemblyDefinitionDetails details, FileSystem fileSystem, Dictionary<string, UnityGuid> referenceAssemblies)
	{
		string assetPath = fileSystem.Path.Join(details.OutputFolder, $"{details.AssemblyName}.asmdef");

		AssemblyDefinitionAsset asset = new AssemblyDefinitionAsset(details.AssemblyName);
		ModuleDefinition? module = details.Assembly?.ManifestModule;
		if (module is not null)
		{
			foreach (AssemblyReference reference in module.AssemblyReferences)
			{
				if (reference.Name is null || referenceAssemblies.ContainsKey(reference.Name))
				{
					continue;
				}

				asset.References.Add(reference.Name);
			}
		}

		string assetData = JsonSerializer.Serialize(asset, AssemblyDefinitionSerializerContext.Default.AssemblyDefinitionAsset);
		fileSystem.File.WriteAllText(assetPath, assetData);
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/AssemblyDefinitions/AssemblyDefinitionSerializerContext.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.Export.UnityProjects.Scripts.AssemblyDefinitions;

[JsonSourceGenerationOptions(WriteIndented = true)]
[JsonSerializable(typeof(AssemblyDefinitionAsset))]
internal sealed partial class AssemblyDefinitionSerializerContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/AssemblyExportType.cs`:

```cs
namespace AssetRipper.Export.UnityProjects.Scripts;

public enum AssemblyExportType
{
	/// <summary>
	/// The assembly should be decompiled.
	/// </summary>
	Decompile,
	/// <summary>
	/// The assembly should be saved as is.
	/// </summary>
	Save,
	/// <summary>
	/// The assembly is a framework assembly and should be skipped.
	/// </summary>
	Skip,
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/AssemblyResolverExtensions.cs`:

```cs
using ICSharpCode.Decompiler.Metadata;
using IAssemblyResolver = ICSharpCode.Decompiler.Metadata.IAssemblyResolver;

namespace AssetRipper.Export.UnityProjects.Scripts;

internal static class AssemblyResolverExtensions
{
	public static bool TryResolve(this IAssemblyResolver resolver, IAssemblyReference reference, [NotNullWhen(true)] out MetadataFile? module)
	{
		module = resolver.Resolve(reference);
		return module is not null;
	}

	public static bool TryResolveModule(this IAssemblyResolver resolver, MetadataFile mainModule, string moduleName, [NotNullWhen(true)] out MetadataFile? module)
	{
		module = resolver.ResolveModule(mainModule, moduleName);
		return module is not null;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/CecilAssemblyResolver.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.Processing.Assemblies;
using ICSharpCode.Decompiler.Metadata;
using System.Collections.Concurrent;
using IAssemblyResolver = ICSharpCode.Decompiler.Metadata.IAssemblyResolver;

namespace AssetRipper.Export.UnityProjects.Scripts;

internal class CecilAssemblyResolver(IAssemblyManager manager) : IAssemblyResolver
{
	/// <remarks>
	/// In <see cref="ICSharpCode.Decompiler.TypeSystem.DecompilerTypeSystem"/>, it states:<br /><br />
	///   For .NET Core and .NET 5 and newer, we need to pull in implicit references which are not included in the metadata,<br />
	///   as they contain compile-time-only types, such as System.Runtime.InteropServices.dll (for DllImport, MarshalAs, etc.)<br /><br />
	/// As a result, it tries to load these assemblies:<br />
	///  * System.Runtime.InteropServices<br />
	///  * System.Runtime.CompilerServices.Unsafe<br /><br />
	/// Current solution:<br />
	///  * The types from these assemblies always seem to be included in mscorlib, we currently use a <see cref="ForwardingAssemblyGenerator"/>
	///    to enable these types to be resolved.
	/// </remarks>
	private readonly ConcurrentDictionary<string, PEFile> peAssemblies = new();

	public MetadataFile? Resolve(IAssemblyReference reference)
	{
		return ResolveAssembly(reference.Name);
	}

	public PEFile Resolve(AssemblyDefinition assembly)
	{
		return ResolveAssembly(assembly.Name!)!;
	}

	public Task<MetadataFile?> ResolveAsync(IAssemblyReference reference)
	{
		return Task.Run(() => Resolve(reference));
	}

	/// <summary>
	/// Finds a module in the same directory as another
	/// </summary>
	/// <param name="mainModule"></param>
	/// <param name="moduleName"></param>
	/// <returns></returns>
	public MetadataFile? ResolveModule(MetadataFile mainModule, string moduleName)
	{
		return ResolveModule(moduleName);
	}

	public Task<MetadataFile?> ResolveModuleAsync(MetadataFile mainModule, string moduleName)
	{
		return Task.Run(() => ResolveModule(mainModule, moduleName));
	}

	private PEFile? ResolveAssembly(string referenceName)
	{
		if (peAssemblies.TryGetValue(referenceName, out PEFile? peResult))
		{
			return peResult;
		}
		else
		{
			lock (peAssemblies)
			{
				if (peAssemblies.TryGetValue(referenceName, out peResult))
				{
					return peResult;
				}

				AssemblyDefinition? assembly = manager.GetAssemblies().FirstOrDefault(x => x.Name == referenceName);
				if (assembly is not null)
				{
					Stream stream = manager.GetStreamForAssembly(assembly);
					stream.Position = 0;
					string assemblyName = assembly.Name!;
					peResult = new PEFile(assemblyName, stream);
					if (!peAssemblies.TryAdd(assemblyName, peResult))
					{
						throw new Exception($"Could not add pe assembly: {assemblyName} to name dictionary!");
					}
					return peResult;
				}
			}

			Logger.Warning(LogCategory.Export, $"Could not resolve assembly: {referenceName}");
			return null;
		}
	}

	private PEFile? ResolveModule(string moduleName)
	{
		lock (peAssemblies)
		{
			PEFile? result = peAssemblies.Values.Where(x => x.Name == moduleName).SingleOrDefault();
			if (result is not null)
			{
			}
			else
			{
				foreach (AssemblyDefinition assembly in manager.GetAssemblies())
				{
					if (!assembly.Modules.Any(m => m.Name == moduleName))
					{
						continue;
					}

					Stream stream = manager.GetStreamForAssembly(assembly);
					stream.Position = 0;
					string assemblyName = assembly.Name!;
					result = new PEFile(assemblyName, stream);
					if (!peAssemblies.TryAdd(assemblyName, result))
					{
						throw new Exception($"Could not add pe assembly: {assemblyName} to name dictionary!");
					}
					return result;
				}
				Logger.Warning(LogCategory.Export, $"Could not resolve module: {moduleName}");
			}
			return result;
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/DllPostExporter.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Export.Configuration;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.Processing;

namespace AssetRipper.Export.UnityProjects.Scripts;

public class DllPostExporter : IPostExporter
{
	public void DoPostExport(GameData gameData, FullConfiguration settings, FileSystem fileSystem)
	{
		Logger.Info(LogCategory.Export, "Saving game assemblies...");
		IAssemblyManager assemblyManager = gameData.AssemblyManager;
		AssemblyDefinition[] assemblies = assemblyManager.GetAssemblies().ToArray();
		if (assemblies.Length != 0)
		{
			string outputDirectory = fileSystem.Path.Join(settings.AuxiliaryFilesPath, "GameAssemblies");

			fileSystem.Directory.Create(outputDirectory);
			foreach (AssemblyDefinition assembly in assemblies)
			{
				string filepath = fileSystem.Path.Join(outputDirectory, SpecialFileNames.AddAssemblyFileExtension(assembly.Name!));
				assemblyManager.SaveAssembly(assembly, filepath, fileSystem);
			}
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/EmptyScript.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.UnityProjects.Scripts;

public static class EmptyScript
{
	public static string GetContent(IMonoScript script)
	{
		return GetContent(script.Namespace.String, script.ClassName_R.String);
	}

	internal static string GetContent(MonoScriptInfo script)
	{
		return GetContent(script.Namespace, script.Class);
	}

	public static string GetContent(string? @namespace, string name)
	{
		if (MonoScriptExtensions.IsGeneric(name, out string genericName, out int genericCount))
		{
			string genericParams = string.Join(", ", Enumerable.Range(1, genericCount).Select(i => $"T{i}"));
			name = $"{genericName}<{genericParams}>";
		}
		if (string.IsNullOrEmpty(@namespace))
		{
			//Indented so that the numerical section can be easily copy-pasted when needed.
			{
				return $$"""
					using UnityEngine;

					public class {{name}} : MonoBehaviour
					{
						/*
						Dummy class. This could have happened for several reasons:
					
						1. No dll files were provided to AssetRipper.
					
							Unity asset bundles and serialized files do not contain script information to decompile.
								* For Mono games, that information is contained in .NET dll files.
								* For Il2Cpp games, that information is contained in compiled C++ assemblies and the global metadata.
								
							AssetRipper usually expects games to conform to a normal file structure for Unity games of that platform.
							A unexpected file structure could cause AssetRipper to not find the required files.
					
						2. Incorrect dll files were provided to AssetRipper.
					
							Any of the following could cause this:
								* Il2CppInterop assemblies
								* Deobfuscated assemblies
								* Older assemblies (compared to when the bundle was built)
								* Newer assemblies (compared to when the bundle was built)
					
							Note: Although assembly publicizing is bad, it alone cannot cause empty scripts. See: https://github.com/AssetRipper/AssetRipper/issues/653
					
						3. Assembly Reconstruction has not been implemented.
					
							Asset bundles contain a small amount of information about the script content.
							This information can be used to recover the serializable fields of a script.
					
							See: https://github.com/AssetRipper/AssetRipper/issues/655
					
						4. This script is unnecessary.
					
							If this script has no asset or script references, it can be deleted.
							Be sure to resolve any compile errors before deleting because they can hide references.
					
						5. Script Content Level 0
					
							AssetRipper was set to not load any script information.
					
						6. Cpp2IL failed to decompile Il2Cpp data
					
							If this happened, there will be errors in the AssetRipper.log indicating that it happened.
							This is an upstream problem, and the AssetRipper developer has very little control over it.
							Please post a GitHub issue at: https://github.com/SamboyCoding/Cpp2IL/issues
				
						7. An incorrect path was provided to AssetRipper.
				
							This is characterized by "Mixed game structure has been found at" in the AssetRipper.log file.
							AssetRipper expects games to conform to a normal file structure for Unity games of that platform.
							An unexpected file structure could cause AssetRipper to not find the required files for script decompilation.
							Generally, AssetRipper expects users to provide the root folder of the game. For example:
								* Windows: the folder containing the game's .exe file
								* Mac: the .app file/folder
								* Linux: the folder containing the game's executable file
								* Android: the apk file
								* iOS: the ipa file
								* Switch: the folder containing exefs and romfs
					
						*/
					}
					""";
			}
		}
		else
		{
			return $$"""
				using UnityEngine;

				namespace {{@namespace}}
				{
					public class {{name}} : MonoBehaviour
					{
						/*
						Dummy class. This could have happened for several reasons:

						1. No dll files were provided to AssetRipper.

							Unity asset bundles and serialized files do not contain script information to decompile.
								* For Mono games, that information is contained in .NET dll files.
								* For Il2Cpp games, that information is contained in compiled C++ assemblies and the global metadata.
								
							AssetRipper usually expects games to conform to a normal file structure for Unity games of that platform.
							A unexpected file structure could cause AssetRipper to not find the required files.

						2. Incorrect dll files were provided to AssetRipper.

							Any of the following could cause this:
								* Il2CppInterop assemblies
								* Deobfuscated assemblies
								* Older assemblies (compared to when the bundle was built)
								* Newer assemblies (compared to when the bundle was built)

							Note: Although assembly publicizing is bad, it alone cannot cause empty scripts. See: https://github.com/AssetRipper/AssetRipper/issues/653

						3. Assembly Reconstruction has not been implemented.

							Asset bundles contain a small amount of information about the script content.
							This information can be used to recover the serializable fields of a script.

							See: https://github.com/AssetRipper/AssetRipper/issues/655
					
						4. This script is unnecessary.

							If this script has no asset or script references, it can be deleted.
							Be sure to resolve any compile errors before deleting because they can hide references.

						5. Script Content Level 0

							AssetRipper was set to not load any script information.

						6. Cpp2IL failed to decompile Il2Cpp data

							If this happened, there will be errors in the AssetRipper.log indicating that it happened.
							This is an upstream problem, and the AssetRipper developer has very little control over it.
							Please post a GitHub issue at: https://github.com/SamboyCoding/Cpp2IL/issues

						7. An incorrect path was provided to AssetRipper.

							This is characterized by "Mixed game structure has been found at" in the AssetRipper.log file.
							AssetRipper expects games to conform to a normal file structure for Unity games of that platform.
							An unexpected file structure could cause AssetRipper to not find the required files for script decompilation.
							Generally, AssetRipper expects users to provide the root folder of the game. For example:
								* Windows: the folder containing the game's .exe file
								* Mac: the .app file/folder
								* Linux: the folder containing the game's executable file
								* Android: the apk file
								* iOS: the ipa file
								* Switch: the folder containing exefs and romfs

						*/
					}
				}
				""";
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/EmptyScriptExportCollection.cs`:

```cs
using AssetRipper.Export.UnityProjects.Scripts.AssemblyDefinitions;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using System.Diagnostics;

namespace AssetRipper.Export.UnityProjects.Scripts;

public sealed class EmptyScriptExportCollection : ScriptExportCollectionBase
{
	public EmptyScriptExportCollection(ScriptExporter assetExporter, IMonoScript firstScript) : base(assetExporter, firstScript)
	{
		Debug.Assert(!assetExporter.AssemblyManager.IsSet);

		// Find all scripts in the project
		foreach (IMonoScript assetScript in firstScript.Collection.Bundle.FetchAssetsInHierarchy().OfType<IMonoScript>())
		{
			UniqueScripts.TryAdd(MonoScriptInfo.From(assetScript), assetScript);
		}
	}

	private Dictionary<MonoScriptInfo, IMonoScript> UniqueScripts { get; } = new();

	public override string Name => nameof(EmptyScriptExportCollection);

	public override bool Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		Logger.Info(LogCategory.Export, "Exporting scripts...");

		string assetsDirectoryPath = fileSystem.Path.Join(projectDirectory, AssetsKeyword);

		Dictionary<string, AssemblyDefinitionDetails> assemblyDefinitionDetailsDictionary = new();

		foreach ((MonoScriptInfo info, IMonoScript script) in UniqueScripts)
		{
			if (info.IsInjected())
			{
				continue;
			}

			GetExportSubPath(info, out string subFolderPath, out string fileName);
			string folderPath = fileSystem.Path.Join(assetsDirectoryPath, subFolderPath);
			string filePath = fileSystem.Path.Join(folderPath, fileName);
			fileSystem.Directory.Create(folderPath);
			fileSystem.File.WriteAllText(filePath, EmptyScript.GetContent(info));
			string assemblyName = info.Assembly;
			if (!assemblyDefinitionDetailsDictionary.ContainsKey(assemblyName))
			{
				string assemblyDirectoryPath = fileSystem.Path.Join(assetsDirectoryPath, GetScriptsFolderName(assemblyName), assemblyName);
				AssemblyDefinitionDetails details = new AssemblyDefinitionDetails(assemblyName, assemblyDirectoryPath);
				assemblyDefinitionDetailsDictionary.Add(assemblyName, details);
			}

			OnScriptExported(container, script, filePath, fileSystem);
		}

		// assembly definitions were added in 2017.3
		//     see: https://blog.unity.com/technology/unity-2017-3b-feature-preview-assembly-definition-files-and-transform-tool
		if (assemblyDefinitionDetailsDictionary.Count > 0 && container.ExportVersion.GreaterThanOrEquals(2017, 3))
		{
			foreach (AssemblyDefinitionDetails details in assemblyDefinitionDetailsDictionary.Values)
			{
				// exclude predefined assemblies like Assembly-CSharp.dll
				//    see: https://docs.unity3d.com/2017.3/Documentation/Manual/ScriptCompilationAssemblyDefinitionFiles.html
				if (!ReferenceAssemblies.IsPredefinedAssembly(details.AssemblyName))
				{
					AssemblyDefinitionExporter.Export(details, fileSystem, AssetExporter.ReferenceAssemblyDictionary);
				}
			}
		}

		return true;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/MonoScriptInfo.cs`:

```cs
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.SourceGenerated.Classes.ClassID_115;

namespace AssetRipper.Export.UnityProjects.Scripts;

internal readonly record struct MonoScriptInfo(string Class, string Namespace, string Assembly)
{
	public static MonoScriptInfo From(IMonoScript monoScript)
	{
		return new MonoScriptInfo(monoScript.ClassName_R.String, monoScript.Namespace.String, monoScript.GetAssemblyNameFixed());
	}

	public bool IsInjected()
	{
		return Class is { Length: 0 } && Namespace is { Length: 0 } && Assembly is { Length: 0 };
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/ReferenceAssemblies.cs`:

```cs
using AssetRipper.Import.Structure.Assembly.Managers;
using System.Diagnostics;

namespace AssetRipper.Export.UnityProjects.Scripts;

public static class ReferenceAssemblies
{
	private static readonly AssemblyDataFile assemblyDataFile = AssemblyDataFile.Load();
	private static UnityGuid UnityEngineGUID => new UnityGuid(0x1F55507F, 0xA1948D44, 0x4080F528, 0xC176C90E);

	public static bool IsPredefinedAssembly(string assemblyName)
	{
		return assemblyName
			is "Assembly-CSharp"
			or "Assembly-CSharp-firstpass"
			or "Assembly-CSharp-Editor"
			or "Assembly-CSharp-Editor-firstpass"
			or "Assembly-UnityScript"
			or "Assembly-UnityScript-firstpass";
	}

	public static Dictionary<string, UnityGuid> GetReferenceAssemblies(IAssemblyManager assemblyManager, UnityVersion version)
	{
		Debug.Assert(assemblyDataFile.Assemblies.Count > 0);

		AssemblyData assemblyData = assemblyDataFile.Get(version);

		Dictionary<string, UnityGuid> referenceAssemblies = [];
		foreach ((string assembly, UnityGuid guid) in assemblyData.UnityExtensions)
		{
			referenceAssemblies.Add(assembly, guid);
		}
		foreach (string assembly in GetMonoAssemblies(assemblyManager, assemblyData))
		{
			referenceAssemblies.TryAdd(assembly, UnityEngineGUID);
		}
		foreach (string assembly in assemblyData.Unity)
		{
			referenceAssemblies.TryAdd(assembly, UnityEngineGUID);
		}

		// Todo: investigate why 5.4.0a0 does not have UnityEngine
		referenceAssemblies.TryAdd("UnityEngine", UnityEngineGUID);

		return referenceAssemblies;

		static IReadOnlyList<string> GetMonoAssemblies(IAssemblyManager assemblyManager, AssemblyData assemblyData)
		{
			if (assemblyManager.HasMscorlib2)
			{
				return assemblyData.Mono2.Count > 0 ? assemblyData.Mono2 : assemblyData.Mono4;
			}
			else
			{
				return assemblyData.Mono4.Count > 0 ? assemblyData.Mono4 : assemblyData.Mono2;
			}
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/ScriptDecompiler.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Import.Configuration;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;
using ICSharpCode.Decompiler;
using ICSharpCode.Decompiler.CSharp;
using ICSharpCode.Decompiler.CSharp.ProjectDecompiler;

namespace AssetRipper.Export.UnityProjects.Scripts;

internal class ScriptDecompiler
{
	private readonly CecilAssemblyResolver assemblyResolver;
	public LanguageVersion LanguageVersion { get; set; } = LanguageVersion.CSharp7_3;
	public ScriptContentLevel ScriptContentLevel { get; set; } = ScriptContentLevel.Level2;
	public ScriptingBackend ScriptingBackend { get; set; } = ScriptingBackend.Unknown;
	public bool FullyQualifiedTypeNames { get; set; } = false;

	public ScriptDecompiler(IAssemblyManager assemblyManager) : this(new CecilAssemblyResolver(assemblyManager), assemblyManager.ScriptingBackend) { }
	private ScriptDecompiler(CecilAssemblyResolver cecilAssemblyResolver, ScriptingBackend scriptingBackend)
	{
		assemblyResolver = cecilAssemblyResolver;
		ScriptingBackend = scriptingBackend;
	}

	public void DecompileWholeProject(AssemblyDefinition assembly, string outputFolder, FileSystem fileSystem)
	{
		DecompilerSettings settings = new();

		settings.SetLanguageVersion(LanguageVersion);

		settings.AlwaysShowEnumMemberValues = true;
		settings.ShowXmlDocumentation = true;

		settings.UseNestedDirectoriesForNamespaces = true;

		if (FullyQualifiedTypeNames)
		{
			settings.AlwaysUseGlobal = true;
			settings.UsingDeclarations = false;
		}

		CustomWholeProjectDecompiler decompiler = new(settings, assemblyResolver, fileSystem);

		DecompileWholeProject(decompiler, assembly, outputFolder);
	}

	private void DecompileWholeProject(WholeProjectDecompiler decompiler, AssemblyDefinition assembly, string outputFolder)
	{
		try
		{
			decompiler.DecompileProject(assemblyResolver.Resolve(assembly), outputFolder, TextWriter.Null);
		}
		catch (Exception exception)
		{
			Logger.Error(exception);
		}
	}

	private sealed class CustomWholeProjectDecompiler(DecompilerSettings settings, CecilAssemblyResolver assemblyResolver, FileSystem fileSystem) : WholeProjectDecompiler(settings, assemblyResolver, null, null, null)
	{
		protected override void CreateDirectory(string path)
		{
			try
			{
				fileSystem.Directory.Create(path);
			}
			catch (IOException)
			{
				fileSystem.File.Delete(path);
				fileSystem.Directory.Create(path);
			}
		}

		protected override TextWriter CreateFile(string path)
		{
			if (fileSystem.Path.GetFileName(path) is "UnitySourceGeneratedAssemblyMonoScriptTypes_v1.cs")
			{
				// UnitySourceGeneratedAssemblyMonoScriptTypes_v1 is generated by Unity and should not be decompiled
				return TextWriter.Null;
			}

			Stream stream = fileSystem.File.Create(path);
			return new StreamWriter(stream);
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/ScriptExportCollection.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Assets;
using AssetRipper.Export.UnityProjects.Scripts.AssemblyDefinitions;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.SourceGenerated.Classes.ClassID_1050;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.PlatformSettingsData_Plugin;
using System.Diagnostics;

namespace AssetRipper.Export.UnityProjects.Scripts;
public sealed class ScriptExportCollection : ScriptExportCollectionBase
{
	public ScriptExportCollection(ScriptExporter assetExporter, IMonoScript firstScript) : base(assetExporter, firstScript)
	{
		Debug.Assert(assetExporter.AssemblyManager.IsSet);

		// find copies in whole project and skip them
		Dictionary<MonoScriptInfo, IMonoScript> uniqueDictionary = new();
		foreach (IMonoScript assetScript in firstScript.Collection.Bundle.FetchAssetsInHierarchy().OfType<IMonoScript>())
		{
			MonoScriptInfo info = MonoScriptInfo.From(assetScript);
			if (uniqueDictionary.TryGetValue(info, out IMonoScript? uniqueScript))
			{
				m_scripts.Add(assetScript, uniqueScript);
			}
			else
			{
				m_scripts.Add(assetScript, assetScript);
				uniqueDictionary.Add(info, assetScript);
				if (ShouldExport(assetScript))
				{
					m_export.Add(assetScript);
				}
			}
		}
	}

	private bool ShouldExport(IMonoScript script)
	{
		if (AssetExporter.GetExportType(script) is AssemblyExportType.Decompile)
		{
			return script.IsScriptPresents(AssetExporter.AssemblyManager);
		}
		else
		{
			return false;
		}
	}

	public override bool Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		Logger.Info(LogCategory.Export, "Exporting scripts...");

		string assetsDirectoryPath = fileSystem.Path.Join(projectDirectory, AssetsKeyword);

		Dictionary<string, AssemblyDefinitionDetails> assemblyDefinitionDetailsDictionary = new();

		string pluginsFolder = fileSystem.Path.Join(assetsDirectoryPath, "Plugins");

		foreach (AssemblyDefinition assembly in AssetExporter.AssemblyManager.GetAssemblies())
		{
			string assemblyName = assembly.Name!;
			AssemblyExportType exportType = AssetExporter.GetExportType(assemblyName);

			if (exportType is AssemblyExportType.Decompile)
			{
				Logger.Info(LogCategory.Export, $"Decompiling {assemblyName}");
				string outputDirectory = fileSystem.Path.Join(assetsDirectoryPath, GetScriptsFolderName(assemblyName), assemblyName);
				fileSystem.Directory.Create(outputDirectory);
				AssetExporter.Decompiler.DecompileWholeProject(assembly, outputDirectory, fileSystem);

				assemblyDefinitionDetailsDictionary.TryAdd(assemblyName, new AssemblyDefinitionDetails(assembly, outputDirectory));
			}
			else if (exportType is AssemblyExportType.Save)
			{
				Logger.Info(LogCategory.Export, $"Saving {assemblyName}");
				fileSystem.Directory.Create(pluginsFolder);
				string outputPath = fileSystem.Path.Join(pluginsFolder, SpecialFileNames.AddAssemblyFileExtension(assemblyName));
				AssetExporter.AssemblyManager.SaveAssembly(assembly, outputPath, fileSystem);
				OnAssemblyExported(container, outputPath, fileSystem);
			}
		}

		foreach (IMonoScript asset in m_export)
		{
			GetExportSubPath(asset, out string subFolderPath, out string fileName);
			string folderPath = fileSystem.Path.Join(assetsDirectoryPath, subFolderPath);
			string filePath = fileSystem.Path.Join(folderPath, fileName);
			if (!fileSystem.File.Exists(filePath))
			{
				fileSystem.Directory.Create(folderPath);
				fileSystem.File.WriteAllText(filePath, EmptyScript.GetContent(asset));
				string assemblyName = asset.GetAssemblyNameFixed();
				if (!assemblyDefinitionDetailsDictionary.ContainsKey(assemblyName))
				{
					string assemblyDirectoryPath = fileSystem.Path.Join(assetsDirectoryPath, GetScriptsFolderName(assemblyName), assemblyName);
					AssemblyDefinitionDetails details = new AssemblyDefinitionDetails(assemblyName, assemblyDirectoryPath);
					assemblyDefinitionDetailsDictionary.Add(assemblyName, details);
				}
			}

			if (fileSystem.File.Exists($"{filePath}.meta"))
			{
				Logger.Error(LogCategory.Export, $"Metafile already exists at {filePath}.meta");
				//throw new Exception($"Metafile already exists at {filePath}.meta");
			}
			else
			{
				OnScriptExported(container, asset, filePath, fileSystem);
			}
		}

		// assembly definitions were added in 2017.3
		//     see: https://blog.unity.com/technology/unity-2017-3b-feature-preview-assembly-definition-files-and-transform-tool
		if (assemblyDefinitionDetailsDictionary.Count > 0 && container.ExportVersion.GreaterThanOrEquals(2017, 3))
		{
			foreach (AssemblyDefinitionDetails details in assemblyDefinitionDetailsDictionary.Values)
			{
				// exclude predefined assemblies like Assembly-CSharp.dll
				//    see: https://docs.unity3d.com/2017.3/Documentation/Manual/ScriptCompilationAssemblyDefinitionFiles.html
				if (!ReferenceAssemblies.IsPredefinedAssembly(details.AssemblyName))
				{
					AssemblyDefinitionExporter.Export(details, fileSystem, AssetExporter.ReferenceAssemblyDictionary);
				}
			}
		}

		return true;
	}

	private void OnAssemblyExported(IExportContainer container, string path, FileSystem fileSystem)
	{
		UnityGuid guid = ScriptHashing.CalculateAssemblyGuid(Path.GetFileName(path));
		IPluginImporter importer = PluginImporter.Create(Assets.First().Collection, container.ExportVersion);
		if (importer.HasPlatformData())
		{
			PlatformSettingsData_Plugin anyPlatformSettings = importer.AddPlatformSettings("Any", Utf8String.Empty);
			anyPlatformSettings.Enabled = true;

			PlatformSettingsData_Plugin editorPlatformSettings = importer.AddPlatformSettings("Editor", "Editor");
			editorPlatformSettings.Enabled = false;
			editorPlatformSettings.Settings.Add("DefaultValueInitialized", "true");
		}

		Meta meta = new Meta(guid, importer);
		ExportMeta(container, meta, path, fileSystem);

	}

	public override string Name => nameof(ScriptExportCollection);

	private readonly List<IMonoScript> m_export = new();
	private readonly Dictionary<IUnityObjectBase, IMonoScript> m_scripts = new();
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/ScriptExportCollectionBase.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.SourceGenerated.Classes.ClassID_1035;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Extensions;
using System.Diagnostics;

namespace AssetRipper.Export.UnityProjects.Scripts;

public abstract class ScriptExportCollectionBase : ExportCollection
{
	public sealed override ScriptExporter AssetExporter { get; }

	public IMonoScript FirstScript { get; }

	public sealed override AssetCollection File => FirstScript.Collection;

	public sealed override IEnumerable<IMonoScript> Assets => [FirstScript];

	public ScriptExportCollectionBase(ScriptExporter assetExporter, IMonoScript firstScript)
	{
		AssetExporter = assetExporter;
		FirstScript = firstScript;
	}

	public sealed override bool Contains(IUnityObjectBase asset)
	{
		return ReferenceEquals(asset, FirstScript);
	}

	public sealed override MetaPtr CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		ThrowIfLocal(isLocal);
		ThrowIfNotAsset(asset);
		return AssetExporter.CreateExportPointer(FirstScript);

		[StackTraceHidden]
		static void ThrowIfLocal(bool isLocal)
		{
			if (isLocal)
			{
				throw new NotSupportedException();
			}
		}
	}

	public sealed override long GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		ThrowIfNotAsset(asset);
		return CreateExportPointer(container, asset, false).FileID;
	}

	[StackTraceHidden]
	private void ThrowIfNotAsset(IUnityObjectBase asset)
	{
		if (!ReferenceEquals(FirstScript, asset))
		{
			throw new ArgumentException($"The asset must be the same one referenced in this collection.", nameof(asset));
		}
	}

	protected static string GetScriptsFolderName(string assemblyName)
	{
		return assemblyName
			is "Assembly-CSharp-firstpass"
			or "Assembly - CSharp - firstpass"
			or "Assembly-UnityScript-firstpass"
			or "Assembly - UnityScript - firstpass"
			? "Plugins"
			: "Scripts";
	}

	protected static void GetExportSubPath(string assembly, string @namespace, string @class, out string folderPath, out string fileName)
	{
		string assemblyFolder = SpecialFileNames.RemoveAssemblyFileExtension(assembly);
		string scriptsFolder = GetScriptsFolderName(assemblyFolder);
		string namespaceFolder = @namespace.Replace('.', Path.DirectorySeparatorChar);
		folderPath = FileSystem.FixInvalidPathCharacters(Path.Join(scriptsFolder, assemblyFolder, namespaceFolder));
		fileName = $"{FileSystem.FixInvalidPathCharacters(@class)}.cs";
	}

	protected static void GetExportSubPath(IMonoScript script, out string folderPath, out string fileName)
	{
		GetExportSubPath(script.GetAssemblyNameFixed(), script.Namespace.String, script.GetNonGenericClassName(), out folderPath, out fileName);
	}

	private protected static void GetExportSubPath(MonoScriptInfo script, out string folderPath, out string fileName)
	{
		GetExportSubPath(script.Assembly, script.Namespace, script.Class, out folderPath, out fileName);
	}

	protected static void OnScriptExported(IExportContainer container, IMonoScript script, string path, FileSystem fileSystem)
	{
		IMonoImporter importer = MonoImporter.Create(script.Collection, container.ExportVersion);
		importer.ExecutionOrder = (short)script.ExecutionOrder;
		Meta meta = new Meta(ScriptHashing.CalculateScriptGuid(script), importer);
		ExportMeta(container, meta, path, fileSystem);
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/ScriptExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Configuration;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_115;

namespace AssetRipper.Export.UnityProjects.Scripts;

public class ScriptExporter : IAssetExporter
{
	public ScriptExporter(IAssemblyManager assemblyManager, FullConfiguration configuration)
	{
		AssemblyManager = assemblyManager;
		Decompiler = new ScriptDecompiler(AssemblyManager)
		{
			LanguageVersion = configuration.ExportSettings.ScriptLanguageVersion.ToCSharpLanguageVersion(configuration.Version),
			ScriptContentLevel = configuration.ImportSettings.ScriptContentLevel,
			FullyQualifiedTypeNames = configuration.ExportSettings.ScriptTypesFullyQualified,
		};
		ExportMode = configuration.ExportSettings.ScriptExportMode;
		ReferenceAssemblyDictionary = ReferenceAssemblies.GetReferenceAssemblies(AssemblyManager, configuration.Version);
	}

	public IAssemblyManager AssemblyManager { get; }
	public ScriptExportMode ExportMode { get; }
	internal ScriptDecompiler Decompiler { get; }
	internal Dictionary<string, UnityGuid> ReferenceAssemblyDictionary { get; }
	private bool HasDecompiled { get; set; } = false;
	private static long MonoScriptDecompiledFileID { get; } = ExportIdHandler.GetMainExportID((int)ClassIDType.MonoScript);

	public bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is IMonoScript script)
		{
			if (HasDecompiled)
			{
				exportCollection = new SingleRedirectExportCollection(asset, CreateExportPointer(script));
			}
			else
			{
				HasDecompiled = true;
				if (AssemblyManager.IsSet)
				{
					exportCollection = new ScriptExportCollection(this, script);
				}
				else
				{
					exportCollection = new EmptyScriptExportCollection(this, script);
				}
			}
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public AssemblyExportType GetExportType(IMonoScript script)
	{
		return GetExportType(script.GetAssemblyNameFixed());
	}

	public MetaPtr CreateExportPointer(IMonoScript script)
	{
		return GetExportType(script) switch
		{
			AssemblyExportType.Decompile => new(MonoScriptDecompiledFileID, ScriptHashing.CalculateScriptGuid(script), AssetType.Meta),
			AssemblyExportType.Skip => new(ScriptHashing.CalculateScriptFileID(script), ReferenceAssemblyDictionary[script.GetAssemblyNameFixed()], AssetType.Meta),
			_ => new(ScriptHashing.CalculateScriptFileID(script), ScriptHashing.CalculateAssemblyGuid(script), AssetType.Meta),
		};
	}

	public AssemblyExportType GetExportType(string assemblyName)
	{
		if (ReferenceAssemblyDictionary.ContainsKey(assemblyName))
		{
			return AssemblyExportType.Skip;
		}
		else if (!AssemblyManager.IsSet)
		{
			return AssemblyExportType.Decompile;
		}
		else if (ExportMode is ScriptExportMode.Decompiled)
		{
			return AssemblyExportType.Decompile;
		}
		else if (ExportMode is ScriptExportMode.Hybrid)
		{
			return ReferenceAssemblies.IsPredefinedAssembly(assemblyName)
				? AssemblyExportType.Decompile
				: AssemblyExportType.Save;
		}
		else
		{
			return AssemblyExportType.Save;
		}
	}

	AssetType IAssetExporter.ToExportType(IUnityObjectBase asset) => AssetType.Meta;

	bool IAssetExporter.ToUnknownExportType(Type type, out AssetType assetType)
	{
		assetType = AssetType.Meta;
		return true;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Scripts/ScriptHashing.cs`:

```cs
using AssetRipper.HashAlgorithms;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using System.Buffers.Binary;
using System.Text;

namespace AssetRipper.Export.UnityProjects.Scripts;

public static class ScriptHashing
{
	/// <summary>
	/// Compute the FileID of a script inside a compiled assembly.
	/// </summary>
	/// <remarks>
	/// This replicates a Unity algorithm.
	/// </remarks>
	/// <param name="namespace">The namespace of the script.</param>
	/// <param name="name">The name of the script.</param>
	public static int CalculateScriptFileID(string @namespace, string name)
	{
		Span<byte> source = stackalloc byte[4 + Encoding.UTF8.GetByteCount(@namespace) + Encoding.UTF8.GetByteCount(name)];

		source[0] = (byte)'s';
		source[1] = 0;
		source[2] = 0;
		source[3] = 0;

		int namespaceLength = Encoding.UTF8.GetBytes(@namespace, source[4..]);

		int nameLength = Encoding.UTF8.GetBytes(name, source[(4 + namespaceLength)..]);

		Span<byte> destination = stackalloc byte[16];
		MD4.HashData(source[..(4 + namespaceLength + nameLength)], destination);

		return BinaryPrimitives.ReadInt32LittleEndian(destination);
	}

	/// <summary>
	/// Compute the FileID of a script inside a compiled assembly.
	/// </summary>
	/// <remarks>
	/// This replicates a Unity algorithm.
	/// </remarks>
	/// <param name="namespace">The namespace of the script encoded as UTF8.</param>
	/// <param name="name">The name of the script encoded as UTF8.</param>
	public static int CalculateScriptFileID(ReadOnlySpan<byte> @namespace, ReadOnlySpan<byte> name)
	{
		Span<byte> source = stackalloc byte[4 + @namespace.Length + name.Length];

		source[0] = (byte)'s';
		source[1] = 0;
		source[2] = 0;
		source[3] = 0;

		@namespace.CopyTo(source[4..]);
		name.CopyTo(source[(4 + @namespace.Length)..]);

		Span<byte> destination = stackalloc byte[16];
		MD4.HashData(source, destination);

		return BinaryPrimitives.ReadInt32LittleEndian(destination);
	}

	/// <summary>
	/// Compute the FileID of a script inside a compiled assembly.
	/// </summary>
	/// <remarks>
	/// This replicates a Unity algorithm.
	/// </remarks>
	public static int CalculateScriptFileID(IMonoScript script)
	{
		return CalculateScriptFileID(script.Namespace.Data, script.ClassName_R.Data);
	}

	/// <summary>
	/// Compute a unique hash of a script and use that as the Guid for the script.
	/// </summary>
	/// <remarks>
	/// This is for consistency. Script guid's are random when created in Unity.
	/// </remarks>
	/// <param name="assemblyName">The name of the assembly (without any file extension) encoded as UTF8.</param>
	/// <param name="namespace">The namespace of the script encoded as UTF8.</param>
	/// <param name="className">The name of the script encoded as UTF8.</param>
	public static UnityGuid CalculateScriptGuid(ReadOnlySpan<byte> assemblyName, ReadOnlySpan<byte> @namespace, ReadOnlySpan<byte> className)
	{
		return UnityGuid.Md5Hash(assemblyName, @namespace, className);
	}

	/// <summary>
	/// Compute a unique hash of a script and use that as the Guid for the script.
	/// </summary>
	/// <remarks>
	/// This is for consistency. Script guid's are random when created in Unity.
	/// </remarks>
	public static UnityGuid CalculateScriptGuid(IMonoScript script)
	{
		//The assembly file name without any extension.
		ReadOnlySpan<byte> assemblyName = Encoding.UTF8.GetBytes(script.GetAssemblyNameFixed());
		return CalculateScriptGuid(assemblyName, script.Namespace.Data, script.ClassName_R.Data);
	}

	/// <summary>
	/// Compute a unique hash of an assembly name and use that as the Guid for the assembly.
	/// </summary>
	/// <remarks>
	/// This is for consistency. Assembly guid's are random when created in Unity.
	/// </remarks>
	public static UnityGuid CalculateAssemblyGuid(string assemblyName)
	{
		return CalculateAssemblyGuidInternal(SpecialFileNames.RemoveAssemblyFileExtension(assemblyName));
	}

	/// <summary>
	/// Compute a unique hash of an assembly name and use that as the Guid for the assembly.
	/// </summary>
	/// <remarks>
	/// This is for consistency. Assembly guid's are random when created in Unity.
	/// </remarks>
	public static UnityGuid CalculateAssemblyGuid(IMonoScript script)
	{
		return CalculateAssemblyGuidInternal(script.GetAssemblyNameFixed());
	}

	private static UnityGuid CalculateAssemblyGuidInternal(string assemblyName)
	{
		return UnityGuid.Md5Hash(assemblyName);
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Shaders/DummyShaderTextExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;
using AssetRipper.SourceGenerated.Subclasses.SerializedProperties;
using AssetRipper.SourceGenerated.Subclasses.SerializedProperty;

namespace AssetRipper.Export.UnityProjects.Shaders;

public sealed class DummyShaderTextExporter : ShaderExporterBase
{
	// This uses CGPROGRAM instead of HLSLPROGRAM because the latter was supposedly introduced in Unity 5.6.
	// https://github.com/UnityCommunity/UnityReleaseNotes/blob/7b417b8ff64415e1e509d8c345b829c7cc11b650/5.6-Beta/5.6.0b1.txt#L143
	private static string FallbackDummyShader { get; } = """

			SubShader{
				Tags { "RenderType" = "Opaque" }
				LOD 200
				CGPROGRAM
		#pragma surface surf Lambert
		#pragma target 3.0
				sampler2D _MainTex;
				struct Input
				{
					float2 uv_MainTex;
				};
				void surf(Input IN, inout SurfaceOutput o)
				{
					float4 c = tex2D(_MainTex, IN.uv_MainTex);
					o.Albedo = c.rgb;
				}
				ENDCG
			}

		""".Replace("\r", "");

	public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		return ExportShader((IShader)asset, path, fileSystem);
	}

	public static bool ExportShader(IShader shader, string path, FileSystem fileSystem)
	{
		using Stream fileStream = fileSystem.File.Create(path);
		using InvariantStreamWriter writer = new(fileStream);
		return ExportShader(shader, writer);
	}

	public static bool ExportShader(IShader shader, TextWriter writer)
	{
		// Technically, this outputs invalid shader code for Unity 5.5 because HLSLPROGRAM was not introduced until Unity 5.6.
		if (shader.Has_ParsedForm())
		{
			writer.Write($"Shader \"{shader.ParsedForm.Name}\" {{\n");
			Export(shader.ParsedForm.PropInfo, writer);

			TemplateShader templateShader = TemplateList.GetBestTemplate(shader);
			writer.Write("\t//DummyShaderTextExporter\n");
			if (templateShader != null)
			{
				writer.Write(templateShader.ShaderText);
			}
			else
			{
				writer.WriteIndent(1);
				writer.Write(FallbackDummyShader);
			}
			writer.Write('\n');

			if (shader.ParsedForm.FallbackName != string.Empty)
			{
				writer.WriteIndent(1);
				writer.Write($"Fallback \"{shader.ParsedForm.FallbackName}\"\n");
			}
			if (shader.ParsedForm.CustomEditorName != string.Empty)
			{
				writer.WriteIndent(1);
				writer.Write($"//CustomEditor \"{shader.ParsedForm.CustomEditorName}\"\n");
			}
			writer.Write('}');
		}
		else
		{
			string header = shader.Script.String;
			int subshaderIndex = header.IndexOf("SubShader");
			if (subshaderIndex < 0)
			{
				return false;
			}
			writer.WriteString(header, 0, subshaderIndex);

			writer.Write("\t//DummyShaderTextExporter\n");
			writer.WriteIndent(1);
			writer.Write(FallbackDummyShader);

			writer.Write('}');
		}
		return true;
	}

	private static void Export(ISerializedProperties _this, TextWriter writer)
	{
		writer.WriteIndent(1);
		writer.Write("Properties {\n");
		foreach (ISerializedProperty prop in _this.Props)
		{
			Export(prop, writer);
		}
		writer.WriteIndent(1);
		writer.Write("}\n");
	}

	private static void Export(ISerializedProperty _this, TextWriter writer)
	{
		writer.WriteIndent(2);
		foreach (Utf8String attribute in _this.Attributes)
		{
			writer.Write($"[{attribute}] ");
		}
		SerializedPropertyFlag flags = (SerializedPropertyFlag)_this.Flags;
		if (flags.IsHideInInspector())
		{
			writer.Write("[HideInInspector] ");
		}
		if (flags.IsPerRendererData())
		{
			writer.Write("[PerRendererData] ");
		}
		if (flags.IsNoScaleOffset())
		{
			writer.Write("[NoScaleOffset] ");
		}
		if (flags.IsNormal())
		{
			writer.Write("[Normal] ");
		}
		if (flags.IsHDR())
		{
			writer.Write("[HDR] ");
		}
		if (flags.IsGamma())
		{
			writer.Write("[Gamma] ");
		}

		writer.Write($"{_this.Name} (\"{_this.Description}\", ");

		switch (_this.GetType_())
		{
			case SerializedPropertyType.Color:
			case SerializedPropertyType.Vector:
				writer.Write("Vector");
				break;

			case SerializedPropertyType.Float:
				writer.Write("Float");
				break;

			case SerializedPropertyType.Range:
				writer.Write($"Range({_this.DefValue_1_.ToStringInvariant()}, {_this.DefValue_2_.ToStringInvariant()})");
				break;

			case SerializedPropertyType.Texture:
				switch (_this.DefTexture.TexDim)
				{
					case 1:
						writer.Write("any");
						break;
					case 2:
						writer.Write("2D");
						break;
					case 3:
						writer.Write("3D");
						break;
					case 4:
						writer.Write("Cube");
						break;
					case 5:
						writer.Write("2DArray");
						break;
					case 6:
						writer.Write("CubeArray");
						break;
					default:
						throw new NotSupportedException("Texture dimension isn't supported");

				}
				break;

			case SerializedPropertyType.Int:
				writer.Write("Int");
				break;

			default:
				throw new NotSupportedException($"Serialized property type {_this.Type} isn't supported");
		}
		writer.Write(") = ");

		switch (_this.GetType_())
		{
			case SerializedPropertyType.Color:
			case SerializedPropertyType.Vector:
				writer.Write($"({_this.DefValue_0_.ToStringInvariant()},{_this.DefValue_1_.ToStringInvariant()},{_this.DefValue_2_.ToStringInvariant()},{_this.DefValue_3_.ToStringInvariant()})");
				break;

			case SerializedPropertyType.Float:
			case SerializedPropertyType.Range:
			case SerializedPropertyType.Int:
				writer.Write(_this.DefValue_0_.ToStringInvariant());
				break;

			case SerializedPropertyType.Texture:
				writer.Write($"\"{_this.DefTexture.DefaultName}\" {{}}");
				break;

			default:
				throw new NotSupportedException($"Serialized property type {_this.Type} isn't supported");
		}
		writer.Write('\n');
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Shaders/PropertyType.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

namespace AssetRipper.Export.UnityProjects.Shaders;

public enum PropertyType
{
	Color = 0,
	Vector = 1,
	Single = 2,
	Range = 3,
	Texture = 4,
}

public static class PropertyTypeExtensions
{
	public static bool IsMatch(this PropertyType _this, SerializedPropertyType type) => (int)_this == (int)type;
	public static bool IsMatch(this PropertyType _this, int type) => (int)_this == type;
}

```

`Source/AssetRipper.Export.UnityProjects/Shaders/RequiredProperty.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.SerializedProperty;

namespace AssetRipper.Export.UnityProjects.Shaders;

public class RequiredProperty
{
	public RequiredProperty() { }
	public RequiredProperty(string name, PropertyType type)
	{
		ArgumentException.ThrowIfNullOrEmpty(name);
		PropertyName = name;
		PropertyType = type;
	}

	public string PropertyName { get; set; } = "";
	public string PropertyTypeName
	{
		get => PropertyType.ToString();
		set => PropertyType = Enum.Parse<PropertyType>(value);
	}
	public PropertyType PropertyType { get; set; }

	public bool IsMatch(ISerializedProperty property)
	{
		return PropertyName == property.Name && PropertyType.IsMatch(property.Type);
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Shaders/ShaderExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_1007;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Texture;

namespace AssetRipper.Export.UnityProjects.Shaders;

public class ShaderExportCollection : AssetExportCollection<IShader>
{
	public ShaderExportCollection(ShaderExporterBase assetExporter, IShader asset) : base(assetExporter, asset)
	{
	}

	protected override IUnityObjectBase CreateImporter(IExportContainer container)
	{
		IShaderImporter importer = ShaderImporter.Create(container.File, container.ExportVersion);
		if (importer.Has_NonModifiableTextures() && Asset.Has_NonModifiableTextures())
		{
			PPtrConverter converter = new(Asset, importer);
			foreach ((Utf8String name, PPtr_Texture_5 pptr) in Asset.NonModifiableTextures)
			{
				AssetPair<Utf8String, PPtr_Texture_5> pair = importer.NonModifiableTextures.AddNew();
				pair.Key = name;
				pair.Value.CopyValues(pptr, converter);
			}
		}
		if (importer.Has_AssetBundleName_R() && Asset.AssetBundleName is not null)
		{
			importer.AssetBundleName_R = Asset.AssetBundleName;
		}
		return importer;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Shaders/ShaderExporterBase.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_48;

namespace AssetRipper.Export.UnityProjects.Shaders;

public abstract class ShaderExporterBase : BinaryAssetExporter
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is IShader shader)
		{
			exportCollection = new ShaderExportCollection(this, shader);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Shaders/SimpleShaderExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_48;

namespace AssetRipper.Export.UnityProjects.Shaders;

/// <summary>
/// An exporter for the occasional situation where a shader asset actually contains the shader source code
/// </summary>
public class SimpleShaderExporter : ShaderExporterBase
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is IShader shader && shader.Has_Script() && HasDecompiledShaderText(shader.Script.String))
		{
			exportCollection = new ShaderExportCollection(this, shader);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		fileSystem.File.WriteAllBytes(path, ((IShader)asset).Script!.Data);
		return true;
	}

	private static bool HasDecompiledShaderText(string text)
	{
		return !string.IsNullOrEmpty(text)
			&& !text.Contains("Program")
			&& !text.Contains("SubProgram");
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Shaders/TemplateJson.cs`:

```cs
namespace AssetRipper.Export.UnityProjects.Shaders;

internal sealed class TemplateJson
{
	public List<TemplateShader> Templates { get; set; } = new();
}

```

`Source/AssetRipper.Export.UnityProjects/Shaders/TemplateJsonSerializerContext.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.Export.UnityProjects.Shaders;

[JsonSerializable(typeof(TemplateJson))]
internal sealed partial class TemplateJsonSerializerContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.Export.UnityProjects/Shaders/TemplateList.cs`:

```cs
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using System.Reflection;
using System.Text.Json;

namespace AssetRipper.Export.UnityProjects.Shaders;

public static class TemplateList
{
	public const string ShaderTemplatePrefix = "AssetRipper.Export.UnityProjects.Shaders.Templates.";
	public const string ShaderTemplateExtension = ".txt";
	public const string TemplatesJsonPath = ShaderTemplatePrefix + "Templates.json";
	public static List<TemplateShader> Templates { get; }

	static TemplateList()
	{
		Templates = LoadTemplates();
	}

	public static TemplateShader GetBestTemplate(IShader shader)
	{
		return Templates.Where(tmp => tmp.IsMatch(shader)).MaxBy(matchedTmp => matchedTmp.RequiredProperties.Count)!;
	}

	private static List<TemplateShader> LoadTemplates()
	{
		Logger.Verbose("Loading shader templates");
		string jsonText = GetTextFromResource(TemplatesJsonPath);

		TemplateJson templateJson = JsonSerializer.Deserialize(jsonText, TemplateJsonSerializerContext.Default.TemplateJson)
			?? throw new Exception("Failed to deserialize json");
		foreach (TemplateShader template in templateJson.Templates)
		{
			string path = ShaderTemplatePrefix + template.TemplateName + ShaderTemplateExtension;
			template.ShaderText = GetTextFromResource(path);
		}
		return templateJson.Templates;
	}

	private static string GetTextFromResource(string path)
	{
		Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(path)
			?? throw new ArgumentException($"No stream at path: {path}", nameof(path));
		using StreamReader reader = new(stream);
		return reader.ReadToEnd().Replace("\r", "");
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Shaders/TemplateShader.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Subclasses.SerializedProperty;

namespace AssetRipper.Export.UnityProjects.Shaders;

public sealed class TemplateShader
{
	public string TemplateName { get; set; } = string.Empty;
	public List<RequiredProperty> RequiredProperties { get; set; } = new();
	public string ShaderText { get; set; } = string.Empty;


	public bool IsMatch(IShader shader)
	{
		if (RequiredProperties == null)
		{
			throw new NullReferenceException("requiredProperties cannot be null");
		}

		if (RequiredProperties.Count == 0)
		{
			return true;
		}

		AccessListBase<ISerializedProperty>? properties = shader.ParsedForm?.PropInfo.Props;
		if (properties is null || properties.Count == 0)
		{
			return false;
		}

		foreach (RequiredProperty? reqProp in RequiredProperties)
		{
			int matches = properties.Where(prop => reqProp.IsMatch(prop)).Count();
			if (matches == 0)
			{
				return false;
			}
		}
		return true;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Shaders/Templates/Default.txt`:

```txt
	SubShader{
		Tags { "RenderType" = "Opaque" }
		LOD 200

		Pass
		{
			HLSLPROGRAM
			#pragma vertex vert
			#pragma fragment frag

			float4x4 unity_ObjectToWorld;
			float4x4 unity_MatrixVP;

			struct Vertex_Stage_Input
			{
				float4 pos : POSITION;
			};

			struct Vertex_Stage_Output
			{
				float4 pos : SV_POSITION;
			};

			Vertex_Stage_Output vert(Vertex_Stage_Input input)
			{
				Vertex_Stage_Output output;
				output.pos = mul(unity_MatrixVP, mul(unity_ObjectToWorld, input.pos));
				return output;
			}

			float4 frag(Vertex_Stage_Output input) : SV_TARGET
			{
				return float4(1.0, 1.0, 1.0, 1.0); // RGBA
			}

			ENDHLSL
		}
	}
```

`Source/AssetRipper.Export.UnityProjects/Shaders/Templates/SingleColor.txt`:

```txt
	SubShader{
		Tags { "RenderType"="Opaque" }
		LOD 200

		Pass
		{
			HLSLPROGRAM
			#pragma vertex vert
			#pragma fragment frag

			float4x4 unity_ObjectToWorld;
			float4x4 unity_MatrixVP;

			struct Vertex_Stage_Input
			{
				float4 pos : POSITION;
			};

			struct Vertex_Stage_Output
			{
				float4 pos : SV_POSITION;
			};

			Vertex_Stage_Output vert(Vertex_Stage_Input input)
			{
				Vertex_Stage_Output output;
				output.pos = mul(unity_MatrixVP, mul(unity_ObjectToWorld, input.pos));
				return output;
			}

			float4 _Color;

			float4 frag(Vertex_Stage_Output input) : SV_TARGET
			{
				return _Color; // RGBA
			}

			ENDHLSL
		}
	}
```

`Source/AssetRipper.Export.UnityProjects/Shaders/Templates/SingleTexture.txt`:

```txt
	SubShader{
		Tags { "RenderType"="Opaque" }
		LOD 200

		Pass
		{
			HLSLPROGRAM
			#pragma vertex vert
			#pragma fragment frag

			float4x4 unity_ObjectToWorld;
			float4x4 unity_MatrixVP;
			float4 _MainTex_ST;

			struct Vertex_Stage_Input
			{
				float4 pos : POSITION;
				float2 uv : TEXCOORD0;
			};

			struct Vertex_Stage_Output
			{
				float2 uv : TEXCOORD0;
				float4 pos : SV_POSITION;
			};

			Vertex_Stage_Output vert(Vertex_Stage_Input input)
			{
				Vertex_Stage_Output output;
				output.uv = (input.uv.xy * _MainTex_ST.xy) + _MainTex_ST.zw;
				output.pos = mul(unity_MatrixVP, mul(unity_ObjectToWorld, input.pos));
				return output;
			}

			Texture2D<float4> _MainTex;
			SamplerState sampler_MainTex;

			struct Fragment_Stage_Input
			{
				float2 uv : TEXCOORD0;
			};

			float4 frag(Fragment_Stage_Input input) : SV_TARGET
			{
				return _MainTex.Sample(sampler_MainTex, input.uv.xy);
			}

			ENDHLSL
		}
	}
```

`Source/AssetRipper.Export.UnityProjects/Shaders/Templates/Templates.json`:

```json
{
	"Templates" : [
		{
			"TemplateName" : "Default",
			"RequiredProperties" : []
		},
		{
			"TemplateName" : "SingleTexture",
			"RequiredProperties" : [
				{
					"PropertyName" : "_MainTex",
					"PropertyTypeName" : "Texture"
				}]
		},
		{
			"TemplateName" : "SingleColor",
			"RequiredProperties" : [
				{
					"PropertyName" : "_Color",
					"PropertyTypeName" : "Color"
				}]
		},
		{
			"TemplateName" : "TransparentDiffuse",
			"RequiredProperties" : [
				{
					"PropertyName" : "_MainTex",
					"PropertyTypeName" : "Texture"
				},
				{
					"PropertyName" : "_Color",
					"PropertyTypeName" : "Color"
				}]
		}
	]
}
```

`Source/AssetRipper.Export.UnityProjects/Shaders/Templates/TransparentDiffuse.txt`:

```txt
	SubShader{
		Tags { "RenderType"="Opaque" }
		LOD 200

		Pass
		{
			HLSLPROGRAM
			#pragma vertex vert
			#pragma fragment frag

			float4x4 unity_ObjectToWorld;
			float4x4 unity_MatrixVP;
			float4 _MainTex_ST;

			struct Vertex_Stage_Input
			{
				float4 pos : POSITION;
				float2 uv : TEXCOORD0;
			};

			struct Vertex_Stage_Output
			{
				float2 uv : TEXCOORD0;
				float4 pos : SV_POSITION;
			};

			Vertex_Stage_Output vert(Vertex_Stage_Input input)
			{
				Vertex_Stage_Output output;
				output.uv = (input.uv.xy * _MainTex_ST.xy) + _MainTex_ST.zw;
				output.pos = mul(unity_MatrixVP, mul(unity_ObjectToWorld, input.pos));
				return output;
			}

			Texture2D<float4> _MainTex;
			SamplerState sampler_MainTex;
			float4 _Color;

			struct Fragment_Stage_Input
			{
				float2 uv : TEXCOORD0;
			};

			float4 frag(Fragment_Stage_Input input) : SV_TARGET
			{
				return _MainTex.Sample(sampler_MainTex, input.uv.xy) * _Color;
			}

			ENDHLSL
		}
	}
```

`Source/AssetRipper.Export.UnityProjects/Shaders/YamlShaderExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_48;

namespace AssetRipper.Export.UnityProjects.Shaders;

public sealed class YamlShaderExportCollection : AssetExportCollection<IShader>
{
	public YamlShaderExportCollection(YamlShaderExporter assetExporter, IShader asset) : base(assetExporter, asset)
	{
	}

	protected override string GetExportExtension(IUnityObjectBase asset) => "asset";

	protected override bool ExportInner(IExportContainer container, string filePath, string dirPath, FileSystem fileSystem)
	{
		// This patch uses ShaderUtil.RegisterShader(), which is only available start from Unity 2018.
		if (container.ExportVersion.GreaterThanOrEquals(2018, 1, 0))
		{
			UnityPatches.ApplyPatchFromText(RegisterShaderUnityPatchText, "YamlShaderPostprocessor", dirPath, fileSystem);
		}
		// This patch uses AssetModificationProcessor, which is only available start from Unity 3.5.
		if (container.ExportVersion.GreaterThanOrEquals(3, 5, 0))
		{
			UnityPatches.ApplyPatchFromText(FileLockerUnityPatchText, "AvoidSavingYamlShaders", dirPath, fileSystem);
		}
		return base.ExportInner(container, filePath, dirPath, fileSystem);
	}

	private const string RegisterShaderUnityPatchText = """
		using System;
		using UnityEngine;
		using UnityEditor;

		namespace AssetRipperPatches.Editor
		{
			/// <summary>
			/// This script is AssetRipper's patch for shaders exported as YAML assets.
			/// Such a shader can be assigned to and used by a material as a regular .shader asset,
			/// but it does not work with Shader.Find() unless we explicitly register it. 
			/// Note that this patch only works for a limited range of Unity versions
			/// since it uses ShaderUtil.RegisterShader(), which is only available in Unity 2018+.
			/// </summary>
			public class YamlShaderPostprocessor : AssetPostprocessor
			{
				static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
				{
					foreach (var importedAsset in importedAssets)
					{
						if (!importedAsset.EndsWith(".asset", StringComparison.Ordinal)) continue;
						Shader yamlShader = AssetDatabase.LoadMainAssetAtPath(importedAsset) as Shader;
						if (yamlShader == null) continue;
						ShaderUtil.RegisterShader(yamlShader);
						Debug.Log($"Registered shader \"{yamlShader.name}\" from {importedAsset}");
					}
				}
			}
		}
		""";

	private const string FileLockerUnityPatchText = """
		using System;
		using System.Collections.Generic;
		using UnityEditor;
		using UnityEngine;

		namespace AssetRipperPatches.Editor
		{
			/// <summary>
			/// This script is AssetRipper's patch for shaders exported as YAML assets.
			/// Such a shader asset can be corrupted if Unity Editor thinks it is dirty and tries to save it.
			/// Manual repro of the issue is easy as a simple call of EditorUtility.SetDirty(someYamlShaderAsset) followed by a Save Project.
			/// Hence we use this script to prevent Unity from saving YAML shader assets.
			/// </summary>
			class AvoidSavingYamlShaders
				// AssetModificationProcessor is a new API added since Unity 3.5. However, it is not in the UnityEditor namespace until Unity 4.0.
		#if UNITY_4_0 || UNITY_4_1 || UNITY_4_2 || UNITY_4_3 || UNITY_4_4 || UNITY_4_5 || UNITY_4_6 || UNITY_4_7 || UNITY_5 || UNITY_2017_1_OR_NEWER
				: UnityEditor.AssetModificationProcessor
		#elif UNITY_3_5
				: AssetModificationProcessor
		#endif
			{
				private static readonly List<string> _pathList = new List<string>();

				private static string[] OnWillSaveAssets(string[] paths)
				{
					_pathList.Clear();
					foreach (string path in paths)
					{
						if (path.EndsWith(".asset", StringComparison.Ordinal) && AssetDatabase.LoadMainAssetAtPath(path) is Shader)
						{
							Debug.Log(string.Format("Unity's attempt to overwrite the YAML Shader asset has been blocked: {0}", path));
						}
						else
						{
							_pathList.Add(path);
						}
					}
					return _pathList.ToArray();
				}
			}
		}
		""";
}

```

`Source/AssetRipper.Export.UnityProjects/Shaders/YamlShaderExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_48;

namespace AssetRipper.Export.UnityProjects.Shaders;

/// <summary>
/// An exporter for exporting shaders as unity assets. Shader.Find will not work in the Unity Editor with this exporter.
/// </summary>
public sealed class YamlShaderExporter : YamlExporterBase
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		exportCollection = asset switch
		{
			IShader shader => new YamlShaderExportCollection(this, shader),
			_ => null,
		};
		return exportCollection is not null;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/SingleRedirectExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Files.SerializedFiles;
using System.Diagnostics;

namespace AssetRipper.Export.UnityProjects;

/// <summary>
/// A collection that redirects a single <paramref name="Asset"/> to a known <paramref name="Pointer"/>.
/// </summary>
/// <remarks>
/// This is a simpler and more efficient alternative to <see cref="RedirectExportCollection"/> when only a single asset is being redirected.
/// </remarks>
/// <param name="Asset">The asset being redirected.</param>
/// <param name="Pointer">The location of <paramref name="Asset"/>.</param>
public sealed record class SingleRedirectExportCollection(IUnityObjectBase Asset, MetaPtr Pointer) : IExportCollection
{
	public SingleRedirectExportCollection(IUnityObjectBase asset, long fileID, UnityGuid guid, AssetType type) : this(asset, new MetaPtr(fileID, guid, type))
	{
	}

	AssetCollection IExportCollection.File => Asset.Collection;

	TransferInstructionFlags IExportCollection.Flags => Asset.Collection.Flags;

	IEnumerable<IUnityObjectBase> IExportCollection.Assets => [Asset];

	public string Name => Asset.GetBestName();

	bool IExportCollection.Contains(IUnityObjectBase asset)
	{
		return ReferenceEquals(Asset, asset);
	}

	MetaPtr IExportCollection.CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		ThrowIfLocal(isLocal);
		ThrowIfNotAsset(asset);
		return Pointer;

		[StackTraceHidden]
		static void ThrowIfLocal(bool isLocal)
		{
			if (isLocal)
			{
				throw new NotSupportedException();
			}
		}
	}

	bool IExportCollection.Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		throw new NotSupportedException();
	}

	bool IExportCollection.Exportable => false;

	long IExportCollection.GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		ThrowIfNotAsset(asset);
		return Pointer.FileID;
	}

	[StackTraceHidden]
	private void ThrowIfNotAsset(IUnityObjectBase asset)
	{
		if (!ReferenceEquals(Asset, asset))
		{
			throw new ArgumentException($"The asset must be the same one referenced in this collection.", nameof(asset));
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/SkipExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.Export.UnityProjects;

public sealed class SkipExportCollection : IExportCollection
{
	public SkipExportCollection(IAssetExporter assetExporter, IUnityObjectBase asset)
	{
		AssetExporter = assetExporter ?? throw new ArgumentNullException(nameof(assetExporter));
		m_asset = asset ?? throw new ArgumentNullException(nameof(asset));
	}

	bool IExportCollection.Export(IExportContainer container, string projectDirectory, FileSystem fileSystem)
	{
		throw new NotSupportedException();
	}

	public bool Contains(IUnityObjectBase asset)
	{
		return asset == m_asset;
	}

	public long GetExportID(IExportContainer container, IUnityObjectBase asset)
	{
		if (asset == m_asset)
		{
			return ExportIdHandler.GetMainExportID(m_asset);
		}
		throw new ArgumentException(null, nameof(asset));
	}

	public MetaPtr CreateExportPointer(IExportContainer container, IUnityObjectBase asset, bool isLocal)
	{
		if (isLocal)
		{
			throw new ArgumentException(null, nameof(isLocal));
		}

		long exportId = GetExportID(container, asset);
		AssetType type = AssetExporter.ToExportType(asset);
		return new MetaPtr(exportId, UnityGuid.MissingReference, type);
	}

	bool IExportCollection.Exportable => false;

	public IAssetExporter AssetExporter { get; }
	public AssetCollection File => m_asset.Collection;
	public TransferInstructionFlags Flags => File.Flags;
	public IEnumerable<IUnityObjectBase> Assets => Enumerable.Empty<IUnityObjectBase>();
	public string Name => m_asset.GetType().Name;

	private readonly IUnityObjectBase m_asset;
}

```

`Source/AssetRipper.Export.UnityProjects/StrippedAssetExtensions.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Processing.Prefabs;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.Yaml;

namespace AssetRipper.Export.UnityProjects;

public static class StrippedAssetExtensions
{
	public static bool IsStripped(this IUnityObjectBase asset)
	{
		if (asset.MainAsset is GameObjectHierarchyObject hierarchy)
		{
			return hierarchy.StrippedAssets.Contains(asset);
		}
		return false;
	}

	internal static void RemoveStrippedFields(this IUnityObjectBase asset, YamlMappingNode root)
	{
		RemoveStrippedFields(root, asset is IMonoBehaviour ? AllowedMonoBehaviourFields : AllowedAssetFields);
	}

	private static void RemoveStrippedFields(YamlMappingNode root, HashSet<string> allowedFields)
	{
		for (int i = root.Children.Count - 1; i >= 0; i--)
		{
			YamlNode child = root.Children[i].Key;
			if (child is not YamlScalarNode scalar || !allowedFields.Contains(scalar.Value))
			{
				root.Children.RemoveAt(i);
			}
		}
	}

	private static HashSet<string> AllowedAssetFields { get; } =
	[
		"m_CorrespondingSourceObject",
		"m_PrefabAsset",
		"m_PrefabInstance",
		"m_PrefabInternal",
		"m_PrefabParentObject",
	];

	private static HashSet<string> AllowedMonoBehaviourFields { get; } =
	[
		"m_CorrespondingSourceObject",
		"m_EditorClassIdentifier",
		"m_EditorHideFlags",
		"m_Enabled",
		"m_GameObject",
		"m_Name",
		"m_PrefabAsset",
		"m_PrefabInstance",
		"m_PrefabInternal",
		"m_PrefabParentObject",
		"m_Script",
	];
}

```

`Source/AssetRipper.Export.UnityProjects/Terrains/TerrainYamlExportCollection.cs`:

```cs
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.UnityProjects.Terrains;

public sealed class TerrainYamlExportCollection : AssetsExportCollection<ITerrainData>
{
	public TerrainYamlExportCollection(IAssetExporter assetExporter, ITerrainData terrainData) : base(assetExporter, terrainData)
	{
		foreach (ITexture2D texture in terrainData.GetSplatAlphaTextures())
		{
			//Sometimes TerrainData can be duplicated, but retain the same alpha textures.
			//https://github.com/AssetRipper/AssetRipper/issues/1356
			if (texture.MainAsset == terrainData)
			{
				AddAsset(texture);
			}
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Terrains/TerrainYamlExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_156;

namespace AssetRipper.Export.UnityProjects.Terrains;

public sealed class TerrainYamlExporter : YamlExporterBase
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		exportCollection = asset.MainAsset switch
		{
			ITerrainData terrainData => new TerrainYamlExportCollection(this, terrainData),
			_ => null,
		};
		return exportCollection is not null;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Textures/Enums/KTXBaseInternalFormat.cs`:

```cs
namespace AssetRipper.Export.UnityProjects.Textures.Enums;

public enum KTXBaseInternalFormat : uint
{
	DEPTH_COMPONENT = 0x1902,
	DEPTH_STENCIL = 0x84F9,
	RED = 0x1903,
	RG = 0x8227,
	RGB = 0x1907,
	RGBA = 0x1908,
	STENCIL_INDEX = 0x1901,
}

```

`Source/AssetRipper.Export.UnityProjects/Textures/Extensions/Texture2DExtensions.cs`:

```cs
using AssetRipper.Export.UnityProjects.Textures.Enums;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.Export.UnityProjects.Textures.Extensions;

public static class Texture2DExtensions
{
	/// <summary>
	/// Get the applicable KTX base format for a texture
	/// </summary>
	/// <param name="_this">The texture</param>
	/// <param name="safe">If true, this method will return RG rather than throwing an exception.</param>
	/// <returns>The format</returns>
	/// <exception cref="NotSupportedException">if not safe and not an pvrtc texture</exception>
	public static KTXBaseInternalFormat GetKTXBaseInternalFormat(this SourceGenerated.Classes.ClassID_28.ITexture2D _this, bool safe)
	{
		switch (_this.Format_C28E)
		{
			case TextureFormat.RHalf:
			case TextureFormat.RFloat:
			case TextureFormat.BC4:
			case TextureFormat.EAC_R:
			case TextureFormat.EAC_R_SIGNED:
				return KTXBaseInternalFormat.RED;

			case TextureFormat.RGHalf:
			case TextureFormat.RGFloat:
			case TextureFormat.BC5:
			case TextureFormat.EAC_RG:
			case TextureFormat.EAC_RG_SIGNED:
				return KTXBaseInternalFormat.RG;

			case TextureFormat.BC6H:
			case TextureFormat.PVRTC_RGB2:
			case TextureFormat.PVRTC_RGB4:
			case TextureFormat.ETC_RGB4Crunched:
			case TextureFormat.ETC_RGB4_3DS:
			case TextureFormat.ETC_RGB4:
			case TextureFormat.ATC_RGB4:
			case TextureFormat.ETC2_RGB:
				return KTXBaseInternalFormat.RGB;

			case TextureFormat.RGBAHalf:
			case TextureFormat.RGBAFloat:
			case TextureFormat.BC7:
			case TextureFormat.PVRTC_RGBA2:
			case TextureFormat.PVRTC_RGBA4:
			case TextureFormat.ATC_RGBA8:
			case TextureFormat.ETC2_RGBA8Crunched:
			case TextureFormat.ETC_RGBA8_3DS:
			case TextureFormat.ETC2_RGBA8:
			case TextureFormat.ETC2_RGBA1:
				return KTXBaseInternalFormat.RGBA;

			default:
				{
					if (safe)
					{
						return KTXBaseInternalFormat.RG;
					}
					else
					{
						throw new NotSupportedException(_this.Format_C28E.ToString());
					}
				}
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Textures/ImporterFactory.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_1006;
using AssetRipper.SourceGenerated.Classes.ClassID_1055;
using AssetRipper.SourceGenerated.Classes.ClassID_117;
using AssetRipper.SourceGenerated.Classes.ClassID_187;
using AssetRipper.SourceGenerated.Classes.ClassID_188;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_89;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.GLTextureSettings;
using AssetRipper.SourceGenerated.Subclasses.TextureImporterPlatformSettings;
using System.Numerics;

namespace AssetRipper.Export.UnityProjects.Textures;

public static class ImporterFactory
{
	public static ITextureImporter GenerateTextureImporter(IExportContainer container, IUnityObjectBase origin)
	{
		TextureImporterData data = new TextureImporterData(origin);
		ITextureImporter instance = TextureImporter.Create(container.File, container.ExportVersion);
		instance.MipMaps.EnableMipMap = data.EnableMipMap ? 1 : 0;
		instance.MipMaps.SRGBTexture = data.SRGBTexture ? 1 : 0;
		instance.MipMaps.AlphaTestReferenceValue = 0.5f;
		instance.MipMaps.MipMapFadeDistanceStart = 1;
		instance.MipMaps.MipMapFadeDistanceEnd = 3;
		instance.BumpMap.HeightScale = .25f;
		instance.GenerateCubemapE = origin is ICubemap
			? TextureImporterGenerateCubemap.FullCubemap
			: instance.Has_TextureShape()
				? TextureImporterGenerateCubemap.AutoCubemap
				: TextureImporterGenerateCubemap.None;
		instance.StreamingMipmaps = data.StreamingMipmaps ? 1 : 0;
		instance.StreamingMipmapsPriority = data.StreamingMipmapsPriority;
		instance.IsReadable = data.IsReadable ? 1 : 0;
		instance.Format = (int)data.Format;
		instance.MaxTextureSize = data.MaxTextureSize;
		instance.TextureSettings.CopyValues(data.TextureSettings);
		// cubemaps break when they aren't scaled, while sprites break if they ARE scaled
		// everything else works with no scaling, so we just only scale for cubemaps
		instance.NPOTScaleE = origin is ICubemap
			? TextureImporterNPOTScale.ToNearest
			: TextureImporterNPOTScale.None;
		instance.CompressionQuality = 50;

		instance.SetSwizzle(TextureImporterSwizzle.R, TextureImporterSwizzle.G, TextureImporterSwizzle.B, TextureImporterSwizzle.A);

		instance.SpriteModeE = SpriteImportMode.Single;
		instance.SpriteExtrude = 1;
		instance.SpriteMeshTypeE = SpriteMeshType.Tight;
		instance.SpritePivot?.SetValues(0.5f, 0.5f);
		instance.SpritePixelsToUnits = 100.0f;
		instance.SpriteGenerateFallbackPhysicsShape = 1;
		instance.AlphaUsageE = TextureImporterAlphaSource.FromInput;
		instance.AlphaIsTransparency = 1;
		instance.SpriteTessellationDetail = -1;
		instance.TextureTypeE = instance.Has_TextureShape() || origin is not ICubemap
			? data.TextureType
			: TextureImporterType.Advanced;
		instance.TextureShapeE = data.TextureShape;

		ITextureImporterPlatformSettings platformSettings = instance.PlatformSettings.AddNew();
		platformSettings.BuildTarget = "DefaultTexturePlatform";
		platformSettings.MaxTextureSize = instance.MaxTextureSize;
		platformSettings.ResizeAlgorithm = (int)TextureResizeAlgorithm.Mitchell;
		platformSettings.Format = (int)TextureImporterFormat.Automatic;
		platformSettings.TextureCompression = (int)TextureImporterCompression.CompressedHQ;//Uncompressed results in a significantly larger Library folder
		platformSettings.CompressionQuality = 50;
		platformSettings.CrunchedCompression = false;
		platformSettings.AllowsAlphaSplitting = false;
		platformSettings.Overridden = false;
		platformSettings.AndroidETC2FallbackOverride = (int)AndroidETC2FallbackOverride.UseBuildSettings;
		platformSettings.ForceMaximumCompressionQuality_BC6H_BC7 = false;

		if (instance.Has_AssetBundleName_R() && origin.AssetBundleName is not null)
		{
			instance.AssetBundleName_R = origin.AssetBundleName;
		}

		return instance;
	}

	private static int CalculateMaxTextureSize(int width, int height)
	{
		uint maxSideLength = (uint)Math.Max(width, height);
		return Math.Max(2048, (int)BitOperations.RoundUpToPowerOf2(maxSideLength));
	}

	private readonly ref struct TextureImporterData
	{
		public bool EnableMipMap { get; }
		public bool SRGBTexture { get; }
		public bool StreamingMipmaps { get; }
		public int StreamingMipmapsPriority { get; }
		public bool IsReadable { get; }
		public TextureFormat Format { get; }
		public int MaxTextureSize { get; }
		public IGLTextureSettings? TextureSettings { get; }
		public TextureImporterType TextureType { get; }
		public TextureImporterShape TextureShape { get; }

		public TextureImporterData(IUnityObjectBase asset)
		{
			switch (asset)
			{
				case ITexture2D texture2D:
					{
						EnableMipMap = texture2D.Mips;
						SRGBTexture = texture2D.ColorSpace_C28E == ColorSpace.Linear;
						StreamingMipmaps = texture2D.StreamingMipmaps_C28;
						StreamingMipmapsPriority = texture2D.StreamingMipmapsPriority_C28;
						IsReadable = texture2D.IsReadable_C28;
						Format = texture2D.Format_C28E;
						MaxTextureSize = CalculateMaxTextureSize(texture2D.Width_C28, texture2D.Height_C28);
						TextureSettings = texture2D.TextureSettings_C28;
						TextureType = texture2D.LightmapFormat_C28E.IsNormalmap()
							? TextureImporterType.NormalMap
							: TextureImporterType.Default;
						TextureShape = texture2D is ICubemap
							? TextureImporterShape.TextureCube
							: TextureImporterShape.Texture2D;
					}
					break;
				case ITexture2DArray texture2DArray:
					{
						EnableMipMap = texture2DArray.MipCount > 1;
						SRGBTexture = texture2DArray.ColorSpaceE == ColorSpace.Linear;
						StreamingMipmaps = false;
						StreamingMipmapsPriority = default;
						IsReadable = texture2DArray.IsReadable;
						Format = texture2DArray.FormatE;
						MaxTextureSize = CalculateMaxTextureSize(texture2DArray.Width, texture2DArray.Height);
						TextureSettings = texture2DArray.TextureSettings;
						TextureType = texture2DArray.Has_UsageMode() && texture2DArray.UsageModeE.IsNormalmap()
							? TextureImporterType.NormalMap
							: TextureImporterType.Default;
						TextureShape = TextureImporterShape.Texture2DArray;
					}
					break;
				case ICubemapArray cubemapArray:
					{
						EnableMipMap = cubemapArray.MipCount > 1;
						SRGBTexture = cubemapArray.ColorSpaceE == ColorSpace.Linear;
						StreamingMipmaps = false;
						StreamingMipmapsPriority = default;
						IsReadable = cubemapArray.IsReadable;
						Format = cubemapArray.FormatE;
						MaxTextureSize = CalculateMaxTextureSize(cubemapArray.Width, cubemapArray.Width);
						TextureSettings = cubemapArray.TextureSettings;
						TextureType = cubemapArray.Has_UsageMode() && cubemapArray.UsageModeE.IsNormalmap()
							? TextureImporterType.NormalMap
							: TextureImporterType.Default;
						TextureShape = TextureImporterShape.Texture2DArray;//Maybe this should be TextureCube
					}
					break;
				case ITexture3D texture3D:
					{
						EnableMipMap = texture3D.Has_MipCount() && texture3D.MipCount > 1 || texture3D.Has_MipMap() && texture3D.MipMap;
						SRGBTexture = texture3D.ColorSpaceE == ColorSpace.Linear;
						StreamingMipmaps = false;
						StreamingMipmapsPriority = default;
						IsReadable = texture3D.IsReadable;
						Format = texture3D.GetTextureFormat();
						MaxTextureSize = CalculateMaxTextureSize(texture3D.Width, texture3D.Height);
						TextureSettings = texture3D.TextureSettings;
						TextureType = texture3D.GetLightmapFormat().IsNormalmap()
							? TextureImporterType.NormalMap
							: TextureImporterType.Default;
						TextureShape = TextureImporterShape.Texture3D;
					}
					break;
				default:
					throw new ArgumentException($"Asset type not supported: {asset.GetType().Name}", nameof(asset));
			}
		}
	}

	public static IIHVImageFormatImporter GenerateIHVImporter(IExportContainer container, ITexture2D origin)
	{
		if (container.ExportVersion.LessThan(5, 6))
		{
			Logger.Warning("IHVImageFormatImporter doesn't exist on versions less than 5.6. A different importer needs to be used on this version");
		}
		IIHVImageFormatImporter instance = IHVImageFormatImporter.Create(container.File, container.ExportVersion);
		instance.SetToDefault();
		instance.IsReadable = origin.IsReadable_C28;
		instance.SRGBTexture = origin.ColorSpace_C28E == ColorSpace.Linear;
		instance.StreamingMipmaps = origin.StreamingMipmaps_C28;
		instance.StreamingMipmapsPriority = origin.StreamingMipmapsPriority_C28;
		if (origin.AssetBundleName is not null)
		{
			instance.AssetBundleName_R = origin.AssetBundleName;
		}
		return instance;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Textures/LightmapTextureAssetExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Configuration;
using AssetRipper.Export.Modules.Textures;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_1120;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.UnityProjects.Textures;

public class LightmapTextureAssetExporter : BinaryAssetExporter
{
	public ImageExportFormat ImageExportFormat { get; private set; }

	public LightmapTextureAssetExporter(ImageExportFormat imageExportFormat)
	{
		ImageExportFormat = imageExportFormat;
	}

	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset.MainAsset is ILightingDataAsset)
		{
			exportCollection = new LightmapExportCollection(this, (ITexture2D)asset);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		ITexture2D texture = (ITexture2D)asset;
		if (!texture.CheckAssetIntegrity())
		{
			Logger.Log(LogType.Warning, LogCategory.Export, $"Can't export '{texture.Name}' because resources file '{texture.StreamData_C28?.Path}' hasn't been found");
			return false;
		}

		if (TextureConverter.TryConvertToBitmap(texture, out DirectBitmap bitmap))
		{
			using Stream stream = fileSystem.File.Create(path);
			bitmap.Save(stream, ImageExportFormat);
			return true;
		}
		else
		{
			Logger.Log(LogType.Warning, LogCategory.Export, $"Unable to convert '{texture.Name}' to bitmap");
			return false;
		}
	}

	private sealed class LightmapExportCollection(LightmapTextureAssetExporter exporter, ITexture2D lightmap) : AssetExportCollection<ITexture2D>(exporter, lightmap)
	{
		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			return ((LightmapTextureAssetExporter)AssetExporter).ImageExportFormat.GetFileExtension();
		}

		protected override IUnityObjectBase CreateImporter(IExportContainer container)
		{
			return ImporterFactory.GenerateTextureImporter(container, Asset);
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Textures/RawTextureExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_28;

namespace AssetRipper.Export.UnityProjects.Textures;

internal class RawTextureExportCollection : AssetExportCollection<ITexture2D>
{
	public RawTextureExportCollection(IAssetExporter assetExporter, ITexture2D asset) : base(assetExporter, asset)
	{
	}

	protected override string GetExportExtension(IUnityObjectBase asset)
	{
		return Asset.Format_C28E.ToString();
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Textures/RawTextureExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.UnityProjects.Textures;

internal class RawTextureExporter : BinaryAssetExporter
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset is ITexture2D texture)
		{
			exportCollection = new RawTextureExportCollection(this, texture);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		fileSystem.File.WriteAllBytes(path, ((ITexture2D)asset).GetImageData());
		return true;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Textures/TextureArrayAssetExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Configuration;

namespace AssetRipper.Export.UnityProjects.Textures;

public sealed class TextureArrayAssetExportCollection : AssetExportCollection<IUnityObjectBase>
{
	public TextureArrayAssetExportCollection(TextureArrayAssetExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
	{
	}

	protected override string GetExportExtension(IUnityObjectBase asset)
	{
		return ((TextureArrayAssetExporter)AssetExporter).ImageExportFormat.GetFileExtension();
	}

	protected override IUnityObjectBase CreateImporter(IExportContainer container)
	{
		return ImporterFactory.GenerateTextureImporter(container, Asset);
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Textures/TextureArrayAssetExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Configuration;
using AssetRipper.Export.Modules.Textures;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_117;
using AssetRipper.SourceGenerated.Classes.ClassID_187;
using AssetRipper.SourceGenerated.Classes.ClassID_188;
using AssetRipper.SourceGenerated.Classes.ClassID_189;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.StreamingInfo;

namespace AssetRipper.Export.UnityProjects.Textures;

public sealed class TextureArrayAssetExporter : BinaryAssetExporter
{
	public ImageExportFormat ImageExportFormat { get; private set; }

	public TextureArrayAssetExporter(FullConfiguration configuration)
	{
		ImageExportFormat = configuration.ExportSettings.ImageExportFormat;
	}

	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		exportCollection = asset switch
		{
			IImageTexture texture when texture.CheckAssetIntegrity() && texture.MainAsset is null => new TextureArrayAssetExportCollection(this, texture),
			_ => null,
		};
		return exportCollection is not null;
	}

	public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		bool success;
		DirectBitmap bitmap;
		switch (asset)
		{
			case ICubemapArray cubemapArray:
				{
					if (!cubemapArray.CheckAssetIntegrity())
					{
						WarnResourceFileNotFound(cubemapArray.Name, cubemapArray.StreamData);
						return false;
					}
					success = TextureConverter.TryConvertToBitmap(cubemapArray, out bitmap);
				}
				break;
			case ITexture2DArray texture2DArray:
				{
					if (!texture2DArray.CheckAssetIntegrity())
					{
						WarnResourceFileNotFound(texture2DArray.Name, texture2DArray.StreamData);
						return false;
					}
					success = TextureConverter.TryConvertToBitmap(texture2DArray, out bitmap);
				}
				break;
			case ITexture3D texture3D:
				{
					if (!texture3D.CheckAssetIntegrity())
					{
						WarnResourceFileNotFound(texture3D.Name, texture3D.StreamData);
						return false;
					}
					success = TextureConverter.TryConvertToBitmap(texture3D, out bitmap);
				}
				break;
			default:
				{
					Logger.Log(LogType.Error, LogCategory.Export, $"Texture array '{asset}' has unsupported type '{asset.GetType().Name}'");
				}
				return false;
		}

		if (success)
		{
			using Stream stream = fileSystem.File.Create(path);
			bitmap.Save(stream, ImageExportFormat);
			return true;
		}
		else
		{
			Logger.Log(LogType.Warning, LogCategory.Export, $"Unable to convert '{asset}' to bitmap");
			return false;
		}

		static void WarnResourceFileNotFound(Utf8String assetName, IStreamingInfo? streamingInfo)
		{
			Logger.Log(LogType.Warning, LogCategory.Export, $"Can't export '{assetName}' because resources file '{streamingInfo?.Path}' hasn't been found");
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Textures/TextureAssetExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Configuration;
using AssetRipper.Export.Modules.Textures;
using AssetRipper.Import.Logging;
using AssetRipper.Processing.Textures;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Export.UnityProjects.Textures;

public class TextureAssetExporter : BinaryAssetExporter
{
	public ImageExportFormat ImageExportFormat { get; private set; }
	private SpriteExportMode SpriteExportMode { get; set; }
	private bool ExportSprites => SpriteExportMode is not SpriteExportMode.Yaml;

	public TextureAssetExporter(FullConfiguration configuration)
	{
		ImageExportFormat = configuration.ExportSettings.ImageExportFormat;
		SpriteExportMode = configuration.ExportSettings.SpriteExportMode;
	}

	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		if (asset.MainAsset is SpriteInformationObject spriteInformationObject && (ExportSprites || asset is not ISprite))
		{
			exportCollection = new TextureExportCollection(this, spriteInformationObject, ExportSprites);
			return true;
		}
		else
		{
			exportCollection = null;
			return false;
		}
	}

	public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
	{
		ITexture2D texture = (ITexture2D)asset;
		if (!texture.CheckAssetIntegrity())
		{
			Logger.Log(LogType.Warning, LogCategory.Export, $"Can't export '{texture.Name}' because resources file '{texture.StreamData_C28?.Path}' hasn't been found");
			return false;
		}

		if (TextureConverter.TryConvertToBitmap(texture, out DirectBitmap bitmap))
		{
			using Stream stream = fileSystem.File.Create(path);
			bitmap.Save(stream, ImageExportFormat);
			return true;
		}
		else
		{
			Logger.Log(LogType.Warning, LogCategory.Export, $"Unable to convert '{texture.Name}' to bitmap");
			return false;
		}
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Textures/TextureExportCollection.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;
using AssetRipper.Export.Configuration;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.Processing.Textures;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_1006;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.SpriteMetaData;
using System.Diagnostics;

namespace AssetRipper.Export.UnityProjects.Textures;

public class TextureExportCollection : AssetsExportCollection<ITexture2D>
{
	public TextureExportCollection(TextureAssetExporter assetExporter, SpriteInformationObject spriteInformationObject, bool exportSprites)
		: base(assetExporter, spriteInformationObject.Texture)
	{
		m_exportSprites = exportSprites;

		if (exportSprites && spriteInformationObject.Sprites.Count > 0)
		{
			foreach ((ISprite? sprite, ISpriteAtlas? _) in spriteInformationObject.Sprites)
			{
				Debug.Assert(sprite.TryGetTexture() == Asset);
				AddAsset(sprite);
			}
		}
		AddAsset(spriteInformationObject);
	}

	protected override IUnityObjectBase CreateImporter(IExportContainer container)
	{
		ITexture2D texture = Asset;
		if (m_convert)
		{
			ITextureImporter importer = ImporterFactory.GenerateTextureImporter(container, texture);
			AddSprites(container, importer, ((SpriteInformationObject?)Asset.MainAsset)!.Sprites);
			return importer;
		}
		else
		{
			return ImporterFactory.GenerateIHVImporter(container, texture);
		}
	}

	protected override bool ExportInner(IExportContainer container, string filePath, string dirPath, FileSystem fileSystem)
	{
		return AssetExporter.Export(container, Asset, filePath, fileSystem);
	}

	protected override string GetExportExtension(IUnityObjectBase asset)
	{
		if (m_convert)
		{
			return ((TextureAssetExporter)AssetExporter).ImageExportFormat.GetFileExtension();
		}
		return base.GetExportExtension(asset);
	}

	protected override long GenerateExportID(IUnityObjectBase asset)
	{
		long exportID = ExportIdHandler.GetMainExportID(asset, m_nextExportID);
		m_nextExportID += 2;
		return exportID;
	}

	private void AddSprites(IExportContainer container, ITextureImporter importer, IReadOnlyDictionary<ISprite, ISpriteAtlas?>? textureSpriteInformation)
	{
		if (textureSpriteInformation == null || textureSpriteInformation.Count == 0)
		{
			importer.SpriteModeE = SpriteImportMode.Single;
			importer.SpriteExtrude = 1;
			importer.SpriteMeshType = (int)SpriteMeshType.FullRect;//See pull request #306
			importer.Alignment = (int)SpriteAlignment.Center;
			if (importer.Has_SpritePivot())
			{
				importer.SpritePivot.SetValues(0.5f, 0.5f);
			}
			importer.SpritePixelsToUnits = 100.0f;
		}
		else if (textureSpriteInformation.Count == 1)
		{
			ISprite sprite = textureSpriteInformation.Keys.First();
			ITexture2D texture = Asset;
			if (sprite.Rect == sprite.RD.TextureRect && sprite.Name == texture.Name)
			{
				importer.SpriteModeE = SpriteImportMode.Single;
			}
			else
			{
				importer.SpriteModeE = SpriteImportMode.Multiple;
				importer.TextureTypeE = TextureImporterType.Sprite;
			}
			importer.SpriteExtrude = sprite.Extrude;
			importer.SpriteMeshType = (int)sprite.RD.MeshType;
			importer.Alignment = (int)SpriteAlignment.Custom;
			if (importer.Has_SpritePivot() && sprite.Has_Pivot())
			{
				importer.SpritePivot.CopyValues(sprite.Pivot);
			}
			if (importer.Has_SpriteBorder() && sprite.Has_Border())
			{
				importer.SpriteBorder.CopyValues(sprite.Border);
			}
			importer.SpritePixelsToUnits = sprite.PixelsToUnits;
			importer.TextureTypeE = TextureImporterType.Sprite;
			if (m_exportSprites)
			{
				AddSpriteSheet(importer, textureSpriteInformation);
				AddIDToName(container, importer, textureSpriteInformation);
			}
		}
		else
		{
			ISprite sprite = textureSpriteInformation.Keys.First();
			importer.TextureTypeE = TextureImporterType.Sprite;
			importer.SpriteModeE = SpriteImportMode.Multiple;
			importer.SpriteExtrude = sprite.Extrude;
			importer.SpriteMeshType = (int)sprite.RD.MeshType;
			importer.Alignment = (int)SpriteAlignment.Center;
			if (importer.Has_SpritePivot())
			{
				importer.SpritePivot.SetValues(0.5f, 0.5f);
			}
			importer.SpritePixelsToUnits = sprite.PixelsToUnits;
			importer.TextureTypeE = TextureImporterType.Sprite;
			if (m_exportSprites)
			{
				AddSpriteSheet(importer, textureSpriteInformation);
				AddIDToName(container, importer, textureSpriteInformation);
			}
		}
	}

	private static void AddSpriteSheet(ITextureImporter importer, IReadOnlyDictionary<ISprite, ISpriteAtlas?> textureSpriteInformation)
	{
		if (!importer.Has_SpriteSheet())
		{
		}
		else if (importer.SpriteModeE == SpriteImportMode.Single)
		{
			KeyValuePair<ISprite, ISpriteAtlas?> kvp = textureSpriteInformation.First();
			ISpriteMetaData smeta = SpriteMetaData.Create(kvp.Key.Collection.Version);
			smeta.FillSpriteMetaData(kvp.Key, kvp.Value);
			importer.SpriteSheet.CopyFromSpriteMetaData(smeta);
		}
		else
		{
			AccessListBase<ISpriteMetaData> spriteSheetSprites = importer.SpriteSheet.Sprites;
			int index = 0;
			foreach (KeyValuePair<ISprite, ISpriteAtlas?> kvp in textureSpriteInformation)
			{
				ISpriteMetaData smeta = spriteSheetSprites.AddNew();
				smeta.FillSpriteMetaData(kvp.Key, kvp.Value);
				if (smeta.Has_InternalID())
				{
					smeta.InternalID = ExportIdHandler.GetPseudoRandomValue(index++);
				}
			}
		}
	}

	private void AddIDToName(IExportContainer container, ITextureImporter importer, IReadOnlyDictionary<ISprite, ISpriteAtlas?> textureSpriteInformation)
	{
		if (importer.SpriteModeE == SpriteImportMode.Multiple)
		{
			if (importer.Has_InternalIDToNameTable())
			{
				foreach (ISprite sprite in textureSpriteInformation.Keys)
				{
#warning TODO: TEMP:
					long exportID = GetExportID(container, sprite);
					ISpriteMetaData smeta = importer.SpriteSheet.GetSpriteMetaData(sprite.Name);
					smeta.InternalID = exportID;
					AssetPair<AssetPair<int, long>, Utf8String> pair = importer.InternalIDToNameTable.AddNew();
					pair.Key.Key = (int)ClassIDType.Sprite;
					pair.Key.Value = exportID;
					pair.Value = sprite.Name;
				}
			}
			else if (importer.Has_FileIDToRecycleName_AssetDictionary_Int64_Utf8String())
			{
				foreach (ISprite sprite in textureSpriteInformation.Keys)
				{
					long exportID = GetExportID(container, sprite);
					importer.FileIDToRecycleName_AssetDictionary_Int64_Utf8String.Add(exportID, sprite.Name);
				}
			}
			else if (importer.Has_FileIDToRecycleName_AssetDictionary_Int32_Utf8String())
			{
				foreach (ISprite sprite in textureSpriteInformation.Keys)
				{
					long exportID = GetExportID(container, sprite);
					importer.FileIDToRecycleName_AssetDictionary_Int32_Utf8String.Add((int)exportID, sprite.Name);
				}
			}
		}
	}

	/// <summary>
	/// If exportSprites is false, we do not generate sprite sheet into texture importer,
	/// yet we still need the sprites to properly set other texture importer settings.
	/// </summary>
	private readonly bool m_exportSprites;
	private readonly bool m_convert = true;
	private uint m_nextExportID = 0;
}

```

`Source/AssetRipper.Export.UnityProjects/Textures/YamlSpriteExporter.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.UnityProjects.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;

namespace AssetRipper.Export.UnityProjects.Textures;

/// <summary>
/// Exports sprites as YAML assets.
/// </summary>
public sealed class YamlSpriteExporter : YamlExporterBase
{
	public override bool TryCreateCollection(IUnityObjectBase asset, [NotNullWhen(true)] out IExportCollection? exportCollection)
	{
		exportCollection = asset switch
		{
			ISprite sprite => new AssetExportCollection<ISprite>(this, sprite),
			ISpriteAtlas => EmptyExportCollection.Instance,
			_ => null,
		};
		return exportCollection is not null;
	}
}

```

`Source/AssetRipper.Export.UnityProjects/Usings.cs`:

```cs
global using AssetRipper.IO.Files;
global using AssetRipper.Primitives;
global using System;
global using System.Diagnostics.CodeAnalysis;

```

`Source/AssetRipper.Export.UnityProjects/YamlWalker.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.GUID;
using AssetRipper.SourceGenerated.Subclasses.Hash128;
using AssetRipper.SourceGenerated.Subclasses.PropertyName;
using AssetRipper.Yaml;
using AssetRipper.Yaml.Extensions;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace AssetRipper.Export.UnityProjects;

public class YamlWalker : AssetWalker
{
	private readonly record struct YamlContext(YamlMappingNode? MappingNode, YamlSequenceNode? SequenceNode, string? FieldName)
	{
		public YamlContext(YamlMappingNode mappingNode) : this(mappingNode, null, null)
		{
		}

		public YamlContext(YamlMappingNode mappingNode, string fieldName) : this(mappingNode, null, fieldName)
		{
		}

		public YamlContext(YamlSequenceNode sequenceNode) : this(null, sequenceNode, null)
		{
		}
	}

	/// <summary>
	/// These fields are excluded from meta files even though they might not have flags indicating that.
	/// </summary>
	/// <remarks>
	/// This set uses original names for robustness and clarity.
	/// </remarks>
	private static readonly HashSet<string> FieldsToSkipInImporters = new()
	{
		"m_ObjectHideFlags",
		"m_ExtensionPtr",
		"m_PrefabParentObject",
		"m_CorrespondingSourceObject",
		"m_PrefabInternal",
		"m_PrefabAsset",
		"m_PrefabInstance",
	};

	private const string Data = "data";
	private const string First = "first";
	private const string Second = "second";
	private Stack<YamlContext> ContextStack { get; } = new();
	public bool ExportingAssetImporter { private get; set; }
	public bool UseHyphensInDictionaries { get; set; } = true;
	private YamlMappingNode? CurrentMappingNode => ContextStack.Peek().MappingNode;
	private YamlSequenceNode? CurrentSequenceNode => ContextStack.Peek().SequenceNode;
	private string? CurrentFieldName => ContextStack.Peek().FieldName;

	public YamlWalker WithUnityVersion(UnityVersion version)
	{
		UseHyphensInDictionaries = version.GreaterThanOrEquals(5, 4);
		return this;
	}

	public YamlDocument ExportYamlDocument(IUnityObjectBase asset, long exportID)
	{
		ContextStack.Clear();

		YamlDocument document = new();

		YamlMappingNode root = document.CreateMappingRoot();
		root.Tag = asset.ClassID.ToString();
		root.Anchor = exportID.ToString();

		ContextStack.Push(new(root, null, asset.ClassName));
		asset.WalkEditor(this);

		if (asset.IsStripped())
		{
			Debug.Assert(root.Children.Count == 1);
			asset.RemoveStrippedFields((YamlMappingNode)root.Children[0].Value);
			root.Stripped = true;
		}

		return document;
	}

	public YamlNode ExportYamlNode(IUnityAssetBase asset)
	{
		ContextStack.Clear();
		YamlSequenceNode falseRoot = new();
		ContextStack.Push(new(falseRoot));
		asset.WalkEditor(this);
		Debug.Assert(falseRoot.Children.Count == 1);
		return falseRoot.Children[0];
	}

	public override bool EnterAsset(IUnityAssetBase asset)
	{
		if (asset is GUID guid)
		{
			VisitPrimitive(guid.ToString());
			return false;
		}
		else if (asset is IHash128 hash)
		{
			AddNode(HashHelper.ExportYaml(hash));
			return false;
		}
		else if (asset is IPropertyName propertyName)
		{
			VisitPrimitive(propertyName.GetIdString());
			return false;
		}
		else
		{
			bool result = EnterMap(asset.FlowMappedInYaml);
			Debug.Assert(result);
			Debug.Assert(CurrentMappingNode is { Children.Count: 0 });
			Debug.Assert(CurrentSequenceNode is null);
			Debug.Assert(CurrentFieldName is null);
			CurrentMappingNode.AddSerializedVersion(asset.SerializedVersion);
			return result;
		}
	}

	public sealed override void DivideAsset(IUnityAssetBase asset)
	{
	}

	public override void ExitAsset(IUnityAssetBase asset)
	{
		ExitMap();
	}

	public override bool EnterField(IUnityAssetBase asset, string name)
	{
		Debug.Assert(CurrentMappingNode is not null);
		Debug.Assert(CurrentSequenceNode is null);
		Debug.Assert(CurrentFieldName is null);
		if (ExportingAssetImporter && (FieldsToSkipInImporters.Contains(name) || asset.IgnoreFieldInMetaFiles(name)))
		{
			return false;
		}
		ContextStack.Push(new(CurrentMappingNode, name));
		return true;
	}

	public override void ExitField(IUnityAssetBase asset, string name)
	{
		Debug.Assert(CurrentMappingNode is not null);
		Debug.Assert(CurrentSequenceNode is null);
		Debug.Assert(CurrentFieldName is null);
		if (name is "m_Structure" && asset is IMonoBehaviour)
		{
			YamlMappingNode structureNode = PopStructureNode(CurrentMappingNode.Children);
			CurrentMappingNode.Append(structureNode);
		}

		static YamlMappingNode PopStructureNode(List<KeyValuePair<YamlNode, YamlNode>> children)
		{
			KeyValuePair<YamlNode, YamlNode> pair = children[^1];
			Debug.Assert(pair.Key.ToString() == "m_Structure");
			children.RemoveAt(children.Count - 1);
			return (YamlMappingNode)pair.Value;
		}
	}

	public override bool EnterList<T>(IReadOnlyList<T> list)
	{
		// Integer arrays and lists are emitted as hex strings by Unity, both in custom MonoBehaviour fields and internal engine classes.
		// In this particular case, integer means the traditional C# integer types, bool, and char.
		// float and double are not emitted as hex strings. They are emitted as regular sequences.
		if (typeof(T) == typeof(sbyte) ||
			typeof(T) == typeof(byte) ||
			typeof(T) == typeof(short) ||
			typeof(T) == typeof(ushort) ||
			typeof(T) == typeof(int) ||
			typeof(T) == typeof(uint) ||
			typeof(T) == typeof(long) ||
			typeof(T) == typeof(ulong) ||
			typeof(T) == typeof(bool) ||
			typeof(T) == typeof(char))
		{
			VisitPrimitive(list);
			return false;
		}
		else
		{
			return EnterSequence(SequenceStyle.Block);
		}
	}

	public override void ExitList<T>(IReadOnlyList<T> list)
	{
		ExitSequence();
	}

	public override bool EnterPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		YamlMappingNode node = new YamlMappingNode();
		ContextStack.Push(new(node));
		if (!IsValidDictionaryKey<TKey>())
		{
			ContextStack.Push(new(node, First));
		}
		return true;
	}

	public override void DividePair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		Debug.Assert(CurrentMappingNode is not null);
		Debug.Assert(CurrentSequenceNode is null);
		if (IsValidDictionaryKey<TKey>())
		{
			Debug.Assert(CurrentFieldName is not null);
		}
		else
		{
			Debug.Assert(CurrentFieldName is null);
			ContextStack.Push(new(CurrentMappingNode, Second));
		}
	}

	public override void ExitPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		ExitMap();
	}

	public override bool EnterDictionary<TKey, TValue>(IReadOnlyCollection<KeyValuePair<TKey, TValue>> dictionary)
	{
		if (IsValidDictionaryKey<TKey>() || !UseHyphensInDictionaries)
		{
			return EnterMap();
		}
		else
		{
			return EnterSequence(SequenceStyle.BlockCurve);
		}
	}

	public override void ExitDictionary<TKey, TValue>(IReadOnlyCollection<KeyValuePair<TKey, TValue>> dictionary)
	{
		if (IsValidDictionaryKey<TKey>() || !UseHyphensInDictionaries)
		{
			ExitMap();
		}
		else
		{
			ExitSequence();
		}
	}

	public override bool EnterDictionaryPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		if (IsValidDictionaryKey<TKey>())
		{
			Debug.Assert(CurrentMappingNode is not null);
			Debug.Assert(CurrentSequenceNode is null);
			Debug.Assert(CurrentFieldName is null);
		}
		else if (!UseHyphensInDictionaries)
		{
			Debug.Assert(CurrentMappingNode is not null);
			Debug.Assert(CurrentSequenceNode is null);
			Debug.Assert(CurrentFieldName is null);
			YamlMappingNode node = new();
			CurrentMappingNode.Add(Data, node);
			ContextStack.Push(new(node));
			ContextStack.Push(new(node, First));
		}
		else
		{
			Debug.Assert(CurrentMappingNode is null);
			Debug.Assert(CurrentSequenceNode is not null);
			Debug.Assert(CurrentFieldName is null);
			YamlMappingNode node = new();
			CurrentSequenceNode.Add(node);
			ContextStack.Push(new(node));
			ContextStack.Push(new(node, First));
		}
		return true;
	}

	public override void DivideDictionaryPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		if (IsValidDictionaryKey<TKey>())
		{
		}
		else
		{
			Debug.Assert(CurrentMappingNode is not null);
			Debug.Assert(CurrentSequenceNode is null);
			Debug.Assert(CurrentFieldName is null);
			ContextStack.Push(new(CurrentMappingNode, Second));
		}
	}

	public override void ExitDictionaryPair<TKey, TValue>(KeyValuePair<TKey, TValue> pair)
	{
		if (IsValidDictionaryKey<TKey>())
		{
		}
		else
		{
			Debug.Assert(CurrentMappingNode is not null);
			Debug.Assert(CurrentSequenceNode is null);
			Debug.Assert(CurrentFieldName is null);
			ContextStack.Pop();
		}
	}

	public override void VisitPrimitive<T>(T value)
	{
		if (CurrentMappingNode is not null)
		{
			Debug.Assert(CurrentSequenceNode is null);

			if (CurrentFieldName is not null)
			{
				CurrentMappingNode.Add(CurrentFieldName, ToNode(value));

				//Pop the context off the stack
				ContextStack.Pop();
			}
			else
			{
				Debug.Assert(IsValidDictionaryKey<T>());
				ContextStack.Push(new(CurrentMappingNode, value?.ToString() ?? ""));
			}
		}
		else
		{
			Debug.Assert(CurrentSequenceNode is not null);
			Debug.Assert(CurrentFieldName is null);

			//Add to sequence
			CurrentSequenceNode.Add(ToNode(value));
		}

		static YamlNode ToNode(T value)
		{
			// IReadOnlyList<T> branches are from EnterList
			if (typeof(T) == typeof(IReadOnlyList<sbyte>))
			{
				return YamlScalarNode.CreateHex((IReadOnlyList<sbyte>)value);
			}
			else if (typeof(T) == typeof(IReadOnlyList<byte>))
			{
				return YamlScalarNode.CreateHex((IReadOnlyList<byte>)value);
			}
			else if (typeof(T) == typeof(IReadOnlyList<short>))
			{
				return YamlScalarNode.CreateHex((IReadOnlyList<short>)value);
			}
			else if (typeof(T) == typeof(IReadOnlyList<ushort>))
			{
				return YamlScalarNode.CreateHex((IReadOnlyList<ushort>)value);
			}
			else if (typeof(T) == typeof(IReadOnlyList<int>))
			{
				return YamlScalarNode.CreateHex((IReadOnlyList<int>)value);
			}
			else if (typeof(T) == typeof(IReadOnlyList<uint>))
			{
				return YamlScalarNode.CreateHex((IReadOnlyList<uint>)value);
			}
			else if (typeof(T) == typeof(IReadOnlyList<long>))
			{
				return YamlScalarNode.CreateHex((IReadOnlyList<long>)value);
			}
			else if (typeof(T) == typeof(IReadOnlyList<ulong>))
			{
				return YamlScalarNode.CreateHex((IReadOnlyList<ulong>)value);
			}
			else if (typeof(T) == typeof(IReadOnlyList<bool>))
			{
				return YamlScalarNode.CreateHex((IReadOnlyList<bool>)value);
			}
			else if (typeof(T) == typeof(IReadOnlyList<char>))
			{
				return YamlScalarNode.CreateHex((IReadOnlyList<char>)value);
			}
			else if (typeof(T) == typeof(byte[]))
			{
				return YamlScalarNode.CreateHex(Unsafe.As<T, byte[]>(ref value));
			}
			else if (typeof(T) == typeof(bool))
			{
				return YamlScalarNode.Create(Unsafe.As<T, bool>(ref value));
			}
			else if (typeof(T) == typeof(char))
			{
				return YamlScalarNode.Create(Unsafe.As<T, char>(ref value));
			}
			else if (typeof(T) == typeof(sbyte))
			{
				return YamlScalarNode.Create(Unsafe.As<T, sbyte>(ref value));
			}
			else if (typeof(T) == typeof(byte))
			{
				return YamlScalarNode.Create(Unsafe.As<T, byte>(ref value));
			}
			else if (typeof(T) == typeof(short))
			{
				return YamlScalarNode.Create(Unsafe.As<T, short>(ref value));
			}
			else if (typeof(T) == typeof(ushort))
			{
				return YamlScalarNode.Create(Unsafe.As<T, ushort>(ref value));
			}
			else if (typeof(T) == typeof(int))
			{
				return YamlScalarNode.Create(Unsafe.As<T, int>(ref value));
			}
			else if (typeof(T) == typeof(uint))
			{
				return YamlScalarNode.Create(Unsafe.As<T, uint>(ref value));
			}
			else if (typeof(T) == typeof(long))
			{
				return YamlScalarNode.Create(Unsafe.As<T, long>(ref value));
			}
			else if (typeof(T) == typeof(ulong))
			{
				return YamlScalarNode.Create(Unsafe.As<T, ulong>(ref value));
			}
			else if (typeof(T) == typeof(float))
			{
				return YamlScalarNode.Create(Unsafe.As<T, float>(ref value));
			}
			else if (typeof(T) == typeof(double))
			{
				return YamlScalarNode.Create(Unsafe.As<T, double>(ref value));
			}
			else if (typeof(T) == typeof(string))
			{
				return YamlScalarNode.Create(Unsafe.As<T, string>(ref value));
			}
			else if (typeof(T) == typeof(Utf8String))
			{
				return YamlScalarNode.Create(Unsafe.As<T, Utf8String>(ref value));
			}
			else
			{
				return YamlScalarNode.Create(value?.ToString() ?? "");// Fallback
			}
		}
	}

	public sealed override void VisitPPtr<TAsset>(PPtr<TAsset> pptr)
	{
		AddNode(CreateYamlNodeForPPtr(pptr));
	}

	public virtual YamlNode CreateYamlNodeForPPtr<TAsset>(PPtr<TAsset> pptr) where TAsset : IUnityObjectBase
	{
		YamlMappingNode mappingNode = new()
		{
			Style = MappingStyle.Flow,
		};
		mappingNode.Add("m_FileID", pptr.FileID);
		mappingNode.Add("m_PathID", pptr.PathID);
		mappingNode.Add("m_TargetClassID", GetClassID(typeof(TAsset)));
		return mappingNode;
	}

	protected static int GetClassID(Type type)
	{
		return (int)(ClassIDTypeMap.Dictionary.GetValueOrDefault(type, ClassIDType.Object));
	}

	private bool EnterMap(bool flowmapped = false)
	{
		ContextStack.Push(new(new YamlMappingNode(flowmapped ? MappingStyle.Flow : MappingStyle.Block)));
		return true;
	}

	private void ExitMap()
	{
		YamlContext context = ContextStack.Pop();
		Debug.Assert(context.MappingNode is not null);
		Debug.Assert(context.SequenceNode is null);
		Debug.Assert(context.FieldName is null);

		AddNode(context.MappingNode);
	}

	private bool EnterSequence(SequenceStyle style)
	{
		ContextStack.Push(new(new YamlSequenceNode(style)));
		return true;
	}

	private void ExitSequence()
	{
		YamlContext context = ContextStack.Pop();
		Debug.Assert(context.MappingNode is null);
		Debug.Assert(context.SequenceNode is not null);
		Debug.Assert(context.FieldName is null);

		AddNode(context.SequenceNode);
	}

	protected void AddNode(YamlNode node)
	{
		if (CurrentMappingNode is not null)
		{
			Debug.Assert(CurrentSequenceNode is null);
			Debug.Assert(CurrentFieldName is not null);
			CurrentMappingNode.Add(CurrentFieldName, node);
			ContextStack.Pop();
		}
		else
		{
			Debug.Assert(CurrentSequenceNode is not null);
			Debug.Assert(CurrentFieldName is null);
			CurrentSequenceNode.Add(node);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
	private static bool IsString<T>() => typeof(T) == typeof(string) || typeof(T) == typeof(Utf8String);

	[MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
	private static bool IsValidDictionaryKey<T>() => IsString<T>() || typeof(T).IsPrimitive || typeof(T) == typeof(GUID);

	private static class HashHelper
	{
		public static YamlMappingNode ExportYaml(IHash128 hash)
		{
			return ExportYaml(hash.Bytes__0, hash.Bytes__1, hash.Bytes__2, hash.Bytes__3, hash.Bytes__4, hash.Bytes__5, hash.Bytes__6, hash.Bytes__7, hash.Bytes__8, hash.Bytes__9, hash.Bytes_10, hash.Bytes_11, hash.Bytes_12, hash.Bytes_13, hash.Bytes_14, hash.Bytes_15, hash.SerializedVersion);
		}

		private static YamlMappingNode ExportYaml(byte bytes__0, byte bytes__1, byte bytes__2, byte bytes__3, byte bytes__4, byte bytes__5, byte bytes__6, byte bytes__7, byte bytes__8, byte bytes__9, byte bytes_10, byte bytes_11, byte bytes_12, byte bytes_13, byte bytes_14, byte bytes_15, int serializedVersion)
		{
			YamlMappingNode node = new();
			node.AddSerializedVersion(serializedVersion);
			if (serializedVersion > 1)
			{
				//Unity is stupid and didn't change the type trees.
				//To see an example of this, look at Texture3D.
				//This change happened at the beginning of Unity 5.
				string str = ToString(bytes__0, bytes__1, bytes__2, bytes__3, bytes__4, bytes__5, bytes__6, bytes__7, bytes__8, bytes__9, bytes_10, bytes_11, bytes_12, bytes_13, bytes_14, bytes_15);
				node.Add(HashName, str);
			}
			else
			{
				node.Add(Bytes00Name, bytes__0);
				node.Add(Bytes01Name, bytes__1);
				node.Add(Bytes02Name, bytes__2);
				node.Add(Bytes03Name, bytes__3);
				node.Add(Bytes04Name, bytes__4);
				node.Add(Bytes05Name, bytes__5);
				node.Add(Bytes06Name, bytes__6);
				node.Add(Bytes07Name, bytes__7);
				node.Add(Bytes08Name, bytes__8);
				node.Add(Bytes09Name, bytes__9);
				node.Add(Bytes10Name, bytes_10);
				node.Add(Bytes11Name, bytes_11);
				node.Add(Bytes12Name, bytes_12);
				node.Add(Bytes13Name, bytes_13);
				node.Add(Bytes14Name, bytes_14);
				node.Add(Bytes15Name, bytes_15);
			}
			return node;
		}

		public static string ToString(byte bytes__0, byte bytes__1, byte bytes__2, byte bytes__3, byte bytes__4, byte bytes__5, byte bytes__6, byte bytes__7, byte bytes__8, byte bytes__9, byte bytes_10, byte bytes_11, byte bytes_12, byte bytes_13, byte bytes_14, byte bytes_15)
		{
			//Not sure if this depends on Endianess
			//If it does, it might be best to split Hash at Unity 5
			uint Data0 = bytes__0 | (uint)bytes__1 << 8 | (uint)bytes__2 << 16 | (uint)bytes__3 << 24;
			uint Data1 = bytes__4 | (uint)bytes__5 << 8 | (uint)bytes__6 << 16 | (uint)bytes__7 << 24;
			uint Data2 = bytes__8 | (uint)bytes__9 << 8 | (uint)bytes_10 << 16 | (uint)bytes_11 << 24;
			uint Data3 = bytes_12 | (uint)bytes_13 << 8 | (uint)bytes_14 << 16 | (uint)bytes_15 << 24;
			string str = $"{Data0:x8}{Data1:x8}{Data2:x8}{Data3:x8}";
			return str;
		}

		private const string Bytes00Name = "bytes[0]";
		private const string Bytes01Name = "bytes[1]";
		private const string Bytes02Name = "bytes[2]";
		private const string Bytes03Name = "bytes[3]";
		private const string Bytes04Name = "bytes[4]";
		private const string Bytes05Name = "bytes[5]";
		private const string Bytes06Name = "bytes[6]";
		private const string Bytes07Name = "bytes[7]";
		private const string Bytes08Name = "bytes[8]";
		private const string Bytes09Name = "bytes[9]";
		private const string Bytes10Name = "bytes[10]";
		private const string Bytes11Name = "bytes[11]";
		private const string Bytes12Name = "bytes[12]";
		private const string Bytes13Name = "bytes[13]";
		private const string Bytes14Name = "bytes[14]";
		private const string Bytes15Name = "bytes[15]";
		private const string HashName = "Hash";
	}
}

```

`Source/AssetRipper.Export/AssetRipper.Export.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.Export\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Export\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.ICSharpCode.Decompiler" Version="10.0.0.8284-preview3" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Processing\AssetRipper.Processing.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Export/Configuration/AudioExportFormat.cs`:

```cs
namespace AssetRipper.Export.Configuration;

public enum AudioExportFormat
{
	/// <summary>
	/// Export as a yaml asset and resS file. This is a safe option and is the backup when things go wrong.
	/// </summary>
	Yaml,
	/// <summary>
	/// For advanced users. This exports in a native format, usually FSB (FMOD Sound Bank). FSB files cannot be used in Unity Editor.
	/// </summary>
	Native,
	/// <summary>
	/// This is the recommended option. Audio assets are exported in the compression of the source, usually OGG.
	/// </summary>
	Default,
	/// <summary>
	/// Not advised if rebundling. This converts audio to the WAV format when possible
	/// </summary>
	PreferWav,
}

```

`Source/AssetRipper.Export/Configuration/EngineResourceDataContext.cs`:

```cs
using AssetRipper.Mining.PredefinedAssets;
using System.Text.Json.Serialization;

namespace AssetRipper.Export.UnityProjects.Configuration;

[JsonSourceGenerationOptions(WriteIndented = true)]
[JsonSerializable(typeof(EngineResourceData?))]
internal partial class EngineResourceDataContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.Export/Configuration/ExportSettings.cs`:

```cs
using AssetRipper.Import.Logging;

namespace AssetRipper.Export.Configuration;

public sealed record class ExportSettings
{
	/// <summary>
	/// The file format that audio clips get exported in. Recommended: Ogg
	/// </summary>
	public AudioExportFormat AudioExportFormat { get; set; } = AudioExportFormat.Default;

	/// <summary>
	/// The file format that images (like textures) get exported in.
	/// </summary>
	public ImageExportFormat ImageExportFormat { get; set; } = ImageExportFormat.Png;

	/// <summary>
	/// The file format that images (like textures) get exported in.
	/// </summary>
	public LightmapTextureExportFormat LightmapTextureExportFormat { get; set; } = LightmapTextureExportFormat.Yaml;

	/// <summary>
	/// How are MonoScripts exported? Recommended: Decompiled
	/// </summary>
	public ScriptExportMode ScriptExportMode { get; set; } = ScriptExportMode.Hybrid;

	/// <summary>
	/// The C# language version of decompiled scripts.
	/// </summary>
	public ScriptLanguageVersion ScriptLanguageVersion { get; set; } = ScriptLanguageVersion.AutoSafe;

	/// <summary>
	/// If true, type references in scripts are fully qualified.
	/// </summary>
	public bool ScriptTypesFullyQualified { get; set; } = false;

	/// <summary>
	/// How to export shaders?
	/// </summary>
	public ShaderExportMode ShaderExportMode { get; set; } = ShaderExportMode.Dummy;

	/// <summary>
	/// Should sprites be exported as a texture? Recommended: Native
	/// </summary>
	public SpriteExportMode SpriteExportMode { get; set; } = SpriteExportMode.Yaml;

	/// <summary>
	/// How are text assets exported?
	/// </summary>
	public TextExportMode TextExportMode { get; set; } = TextExportMode.Parse;

	public bool ExportUnreadableAssets { get; set; } = false;

	public bool SaveSettingsToDisk { get; set; }

	public string? LanguageCode { get; set; }

	public void Log()
	{
		Logger.Info(LogCategory.General, $"{nameof(AudioExportFormat)}: {AudioExportFormat}");
		Logger.Info(LogCategory.General, $"{nameof(ImageExportFormat)}: {ImageExportFormat}");
		Logger.Info(LogCategory.General, $"{nameof(LightmapTextureExportFormat)}: {LightmapTextureExportFormat}");
		Logger.Info(LogCategory.General, $"{nameof(ScriptExportMode)}: {ScriptExportMode}");
		Logger.Info(LogCategory.General, $"{nameof(ScriptLanguageVersion)}: {ScriptLanguageVersion}");
		Logger.Info(LogCategory.General, $"{nameof(ShaderExportMode)}: {ShaderExportMode}");
		Logger.Info(LogCategory.General, $"{nameof(SpriteExportMode)}: {SpriteExportMode}");
		Logger.Info(LogCategory.General, $"{nameof(TextExportMode)}: {TextExportMode}");
		Logger.Info(LogCategory.General, $"{nameof(ExportUnreadableAssets)}: {ExportUnreadableAssets}");
	}
}

```

`Source/AssetRipper.Export/Configuration/FullConfiguration.cs`:

```cs
using AssetRipper.Export.UnityProjects.Configuration;
using AssetRipper.Import.Configuration;
using AssetRipper.Mining.PredefinedAssets;
using AssetRipper.Processing.Configuration;

namespace AssetRipper.Export.Configuration;

public class FullConfiguration : CoreConfiguration
{
	public ProcessingSettings ProcessingSettings
	{
		get => SingletonData.GetStoredValue<ProcessingSettings>(nameof(ProcessingSettings));
		set => SingletonData.SetStoredValue(nameof(ProcessingSettings), value);
	}

	public ExportSettings ExportSettings
	{
		get => SingletonData.GetStoredValue<ExportSettings>(nameof(ExportSettings));
		set => SingletonData.SetStoredValue(nameof(ExportSettings), value);
	}

	public bool SaveSettingsToDisk => ExportSettings.SaveSettingsToDisk;

	public string? LanguageCode
	{
		get => ExportSettings.LanguageCode;
		set => ExportSettings.LanguageCode = value;
	}

	public FullConfiguration()
	{
		SingletonData.Add(nameof(ProcessingSettings), new JsonDataInstance<ProcessingSettings>(SerializedSettingsContext.Default.ProcessingSettings));
		SingletonData.Add(nameof(ExportSettings), new JsonDataInstance<ExportSettings>(SerializedSettingsContext.Default.ExportSettings));
		SingletonData.Add(nameof(EngineResourceData), new JsonDataInstance<EngineResourceData?>(EngineResourceDataContext.Default.NullableEngineResourceData));
	}

	public override void LogConfigurationValues()
	{
		base.LogConfigurationValues();
		ProcessingSettings.Log();
		ExportSettings.Log();
	}

	public void LoadFromDefaultPath()
	{
		if (SerializedSettings.TryLoadFromDefaultPath(out SerializedSettings settings))
		{
			ImportSettings = settings.Import;
			ProcessingSettings = settings.Processing;
			ExportSettings = settings.Export;
		}
	}

	public void SaveToDefaultPath()
	{
		new SerializedSettings(ImportSettings, ProcessingSettings, ExportSettings).SaveToDefaultPath();
	}

	public void MaybeSaveToDefaultPath()
	{
		if (SaveSettingsToDisk)
		{
			SaveToDefaultPath();
		}
	}
}

```

`Source/AssetRipper.Export/Configuration/ImageExportFormat.cs`:

```cs
namespace AssetRipper.Export.Configuration;

public enum ImageExportFormat
{
	/// <summary>
	/// Lossless. Bitmap<br/>
	/// <see href="https://en.wikipedia.org/wiki/BMP_file_format"/>
	/// </summary>
	Bmp,
	/// <summary>
	/// Lossless. OpenEXR<br/>
	/// <see href="https://en.wikipedia.org/wiki/OpenEXR"/>
	/// </summary>
	Exr,
	/// <summary>
	/// Lossless. Radiance HDR<br/>
	/// <see href="https://en.wikipedia.org/wiki/RGBE_image_format"/>
	/// </summary>
	Hdr,
	/// <summary>
	/// Lossy. Joint Photographic Experts Group<br/>
	/// <see href="https://en.wikipedia.org/wiki/JPEG"/>
	/// </summary>
	Jpeg,
	/// <summary>
	/// Lossless. Portable Network Graphics<br/>
	/// <see href="https://en.wikipedia.org/wiki/Portable_Network_Graphics"/>
	/// </summary>
	Png,
	/// <summary>
	/// Lossless. Truevision TGA<br/>
	/// <see href="https://en.wikipedia.org/wiki/Truevision_TGA"/>
	/// </summary>
	Tga,
}

public static class ImageExportFormatExtensions
{
	public static string GetFileExtension(this ImageExportFormat _this)
	{
		return _this switch
		{
			ImageExportFormat.Bmp => "bmp",
			ImageExportFormat.Exr => "exr",
			ImageExportFormat.Hdr => "hdr",
			ImageExportFormat.Jpeg => "jpeg",
			ImageExportFormat.Png => "png",
			ImageExportFormat.Tga => "tga",
			_ => throw new ArgumentOutOfRangeException(nameof(_this)),
		};
	}

	//When extension types come in C# 13, this will be more convenient to use.
	public static bool TryGetFromExtension(string extension, out ImageExportFormat format)
	{
		format = extension switch
		{
			"bmp" => ImageExportFormat.Bmp,
			"exr" => ImageExportFormat.Exr,
			"hdr" => ImageExportFormat.Hdr,
			"jpeg" => ImageExportFormat.Jpeg,
			"jpg" => ImageExportFormat.Jpeg,
			"png" => ImageExportFormat.Png,
			"tga" => ImageExportFormat.Tga,
			_ => (ImageExportFormat)(-1),
		};
		return format >= 0;
	}
}

```

`Source/AssetRipper.Export/Configuration/LightmapTextureExportFormat.cs`:

```cs
namespace AssetRipper.Export.Configuration;

public enum LightmapTextureExportFormat
{
	/// <summary>
	/// Use <see cref="ImageExportFormat.Exr"/>
	/// </summary>
	Exr,
	/// <summary>
	/// Use <see cref="ExportSettings.ImageExportFormat"/>
	/// </summary>
	Image,
	/// <summary>
	/// The internal Unity format
	/// </summary>
	Yaml,
}

```

`Source/AssetRipper.Export/Configuration/ScriptExportMode.cs`:

```cs
namespace AssetRipper.Export.Configuration;

public enum ScriptExportMode
{
	/// <summary>
	/// Use the ILSpy decompiler to generate CS scripts. This is reliable. However, it's also time-consuming and contains many compile errors.
	/// </summary>
	Decompiled,
	/// <summary>
	/// Special assemblies, such as Assembly-CSharp, are decompiled to CS scripts with the ILSpy decompiler. Other assemblies are saved as DLL files.
	/// </summary>
	Hybrid,
	/// <summary>
	/// Special assemblies, such as Assembly-CSharp, are renamed to have compatible names.
	/// </summary>
	DllExportWithRenaming,
	/// <summary>
	/// Export assemblies in their compiled Dll form. Experimental. Might not work at all.
	/// </summary>
	DllExportWithoutRenaming,
}

```

`Source/AssetRipper.Export/Configuration/ScriptLanguageVersion.cs`:

```cs
using AssetRipper.Primitives;
using ICSharpCode.Decompiler.CSharp;

namespace AssetRipper.Export.Configuration;

public enum ScriptLanguageVersion
{
	AutoExperimental = -2,
	AutoSafe = -1,
	CSharp1 = 1,
	CSharp2 = 2,
	CSharp3 = 3,
	CSharp4 = 4,
	CSharp5 = 5,
	CSharp6 = 6,
	CSharp7 = 7,
	CSharp7_1 = 701,
	CSharp7_2 = 702,
	CSharp7_3 = 703,
	CSharp8_0 = 800,
	CSharp9_0 = 900,
	CSharp10_0 = 1000,
	CSharp11_0 = 1100,
	CSharp12_0 = 1200,
	Latest = int.MaxValue
}

public static class ScriptLanguageVersionExtensions
{
	public static LanguageVersion ToCSharpLanguageVersion(this ScriptLanguageVersion scriptLanguageVersion, UnityVersion unityVersion)
	{
		return scriptLanguageVersion switch
		{
			ScriptLanguageVersion.AutoExperimental => GetAutomaticCSharpLanguageVersion(unityVersion, true),
			ScriptLanguageVersion.AutoSafe => GetAutomaticCSharpLanguageVersion(unityVersion, false),
			ScriptLanguageVersion.CSharp1 => LanguageVersion.CSharp1,
			ScriptLanguageVersion.CSharp2 => LanguageVersion.CSharp2,
			ScriptLanguageVersion.CSharp3 => LanguageVersion.CSharp3,
			ScriptLanguageVersion.CSharp4 => LanguageVersion.CSharp4,
			ScriptLanguageVersion.CSharp5 => LanguageVersion.CSharp5,
			ScriptLanguageVersion.CSharp6 => LanguageVersion.CSharp6,
			ScriptLanguageVersion.CSharp7 => LanguageVersion.CSharp7,
			ScriptLanguageVersion.CSharp7_1 => LanguageVersion.CSharp7_1,
			ScriptLanguageVersion.CSharp7_2 => LanguageVersion.CSharp7_2,
			ScriptLanguageVersion.CSharp7_3 => LanguageVersion.CSharp7_3,
			ScriptLanguageVersion.CSharp8_0 => LanguageVersion.CSharp8_0,
			ScriptLanguageVersion.CSharp9_0 => LanguageVersion.CSharp9_0,
			ScriptLanguageVersion.CSharp10_0 => LanguageVersion.CSharp10_0,
			ScriptLanguageVersion.CSharp11_0 => LanguageVersion.CSharp11_0,
			ScriptLanguageVersion.CSharp12_0 => LanguageVersion.CSharp12_0,
			ScriptLanguageVersion.Latest => LanguageVersion.Latest,
			_ => throw new ArgumentOutOfRangeException(nameof(scriptLanguageVersion), $"{scriptLanguageVersion}"),
		};
	}

	private static LanguageVersion GetAutomaticCSharpLanguageVersion(UnityVersion unityVersion, bool experimental)
	{
		if (HasCSharp9Support(unityVersion))
		{
			return LanguageVersion.CSharp9_0;
		}
		else if (unityVersion.GreaterThanOrEquals(2020, 2))
		{
			return LanguageVersion.CSharp8_0;
		}
		else if (unityVersion.GreaterThanOrEquals(2019, 2))
		{
			return LanguageVersion.CSharp7_3;
		}
		//.NET Standard 2.0 support was added in 2018.1,
		//But Roslyn and C# 7.3 weren't added until 2018.3.
		//https://learn.microsoft.com/en-us/dotnet/standard/net-standard?tabs=net-standard-2-0#net-standard-versions
		else if (experimental && unityVersion.GreaterThanOrEquals(2018, 3))
		{
			//https://blog.unity.com/technology/introducing-unity-2018-3
			return LanguageVersion.CSharp7_3;
		}
		else if (experimental && unityVersion.GreaterThanOrEquals(2017, 1))
		{
			return LanguageVersion.CSharp6;
		}
		else
		{
			return LanguageVersion.CSharp4;
		}
	}

	/// <summary>
	/// Added in 2021.2.0b6 and 2022.1.0a3
	/// </summary>
	/// <remarks>
	/// These are also the versions that introduced .NET Standard 2.1 support.<br/>
	/// Despite being part of C# 8, support for
	/// <see href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods">default interface methods</see>
	/// was added in this language support expansion. It was unavailable prior to these versions.<br/>
	/// Despite being part of C# 9, support for
	/// <see href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/covariant-returns">covariant return types</see>
	/// was not included in this language support expansion, nor any other C# 9 features requiring runtime support.<br/>
	/// <see href="https://learn.microsoft.com/en-us/dotnet/standard/net-standard?tabs=net-standard-2-1#net-standard-versions"/><br/>
	/// <see href="https://forum.unity.com/threads/unity-future-net-development-status.1092205/"/>
	/// </remarks>
	/// <param name="unityVersion"></param>
	/// <returns></returns>
	private static bool HasCSharp9Support(UnityVersion unityVersion)
	{
		return unityVersion.GreaterThanOrEquals(2022, 1, 0, UnityVersionType.Alpha, 3)
			|| unityVersion.GreaterThanOrEquals(2021, 2, 0, UnityVersionType.Beta, 6) && unityVersion.Equals(2021);
	}
}

```

`Source/AssetRipper.Export/Configuration/SerializedSettings.cs`:

```cs
using AssetRipper.Export.UnityProjects.Configuration;
using AssetRipper.Import.Configuration;
using AssetRipper.Import.Utils;
using AssetRipper.Processing.Configuration;
using System.Text.Json;

namespace AssetRipper.Export.Configuration;

public readonly record struct SerializedSettings(ImportSettings Import, ProcessingSettings Processing, ExportSettings Export)
{
	public const string DefaultFileName = "AssetRipper.Settings.json";

	public static string DefaultFilePath => ExecutingDirectory.Combine(DefaultFileName);

	public static SerializedSettings Load(string path)
	{
		return JsonSerializer.Deserialize(File.ReadAllText(path), SerializedSettingsContext.Default.SerializedSettings);
	}

	public static bool TryLoadFromDefaultPath(out SerializedSettings settings)
	{
		string path = DefaultFilePath;
		if (File.Exists(path))
		{
			settings = Load(path);
			return true;
		}
		settings = default;
		return false;
	}

	public void Save(string path)
	{
		using FileStream fileStream = File.Create(path);
		JsonSerializer.Serialize(fileStream, this, SerializedSettingsContext.Default.SerializedSettings);
	}

	public void SaveToDefaultPath()
	{
		Save(DefaultFilePath);
	}

	public static void DeleteDefaultPath()
	{
		string path = DefaultFilePath;
		if (File.Exists(path))
		{
			File.Delete(path);
		}
	}
}

```

`Source/AssetRipper.Export/Configuration/SerializedSettingsContext.cs`:

```cs
using AssetRipper.Export.Configuration;
using System.Text.Json.Serialization;

namespace AssetRipper.Export.UnityProjects.Configuration;

[JsonSourceGenerationOptions(WriteIndented = true)]
[JsonSerializable(typeof(SerializedSettings))]
internal sealed partial class SerializedSettingsContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.Export/Configuration/ShaderExportMode.cs`:

```cs
namespace AssetRipper.Export.Configuration;

public enum ShaderExportMode
{
	/// <summary>
	/// Export as dummy shaders which compile in the editor
	/// </summary>
	Dummy,
	/// <summary>
	/// Export as yaml assets which can be viewed in the editor
	/// </summary>
	Yaml,
	/// <summary>
	/// Export as decompiled HLSL
	/// </summary>
	Decompile
}

```

`Source/AssetRipper.Export/Configuration/SpriteExportMode.cs`:

```cs
namespace AssetRipper.Export.Configuration;

public enum SpriteExportMode
{
	/// <summary>
	/// Export as yaml assets which can be viewed in the editor.
	/// This is the only mode that ensures a precise recovery of all metadata of sprites.
	/// <see href="https://github.com/trouger/AssetRipper/issues/2"/>
	/// </summary>
	Yaml,
	/// <summary>
	/// Export in the native asset format, where all sprites data are stored in texture importer settings.
	/// </summary>
	/// <remarks>
	/// The output from this mode was substantially changed by
	/// <see href="https://github.com/AssetRipper/AssetRipper/commit/084b3e5ea7826ac2f54ed2b11cbfbbf3692ddc9c"/>.
	/// Using this is inadvisable.
	/// </remarks>
	Native,
	/// <summary>
	/// Export as a Texture2D png image
	/// </summary>
	/// <remarks>
	/// The output from this mode was substantially changed by
	/// <see href="https://github.com/AssetRipper/AssetRipper/commit/084b3e5ea7826ac2f54ed2b11cbfbbf3692ddc9c"/>.
	/// Using this is inadvisable.
	/// </remarks>
	Texture2D,
}

```

`Source/AssetRipper.Export/Configuration/TerrainExportMode.cs`:

```cs
namespace AssetRipper.Export.Configuration;

public enum TerrainExportMode
{
	/// <summary>
	/// The default export mode. This is the only one that exports in a format Unity can use for terrains.
	/// </summary>
	Yaml,
	/// <summary>
	/// This converts the terrain data into a mesh. Unity cannot import this.
	/// </summary>
	Mesh,
	/// <summary>
	/// A heatmap of the terrain height. Probably not usable for anything but a visual representation.
	/// </summary>
	Heatmap,
}

```

`Source/AssetRipper.Export/Configuration/TextExportMode.cs`:

```cs
namespace AssetRipper.Export.Configuration;

public enum TextExportMode
{
	/// <summary>
	/// Export as bytes
	/// </summary>
	Bytes,
	/// <summary>
	/// Export as plain text files
	/// </summary>
	Txt,
	/// <summary>
	/// Export as plain text files, but try to guess the file extension
	/// </summary>
	Parse,
}

```

`Source/AssetRipper.Export/ObjectHandlerStack.cs`:

```cs
namespace AssetRipper.Export;

public sealed class ObjectHandlerStack<T>
{
	/// <summary>
	/// Exact type to the handlers that handle that type
	/// </summary>
	private readonly Dictionary<Type, Stack<T>> typeMap = new();

	/// <summary>
	/// List of type-handler-allow pairs<br/>
	/// Type: the object type<br/>
	/// T: the handler that can handle that object type<br/>
	/// Bool: allow the handler to apply on inherited object types?
	/// </summary>
	private readonly List<(Type, T, bool)> registeredHandlers = new();

	/// <summary>Adds a handler to the stack of handlers for this object type.</summary>
	/// <param name="type">The c sharp type of this object type. Any inherited types also get this handler.</param>
	/// <param name="handler">The new handler. If it doesn't work, the next one in the stack is used.</param>
	/// <param name="allowInheritance">Should types that inherit from this type also use the handler?</param>
	public void OverrideHandler(Type type, T handler, bool allowInheritance)
	{
		ArgumentNullException.ThrowIfNull(handler);

		registeredHandlers.Add((type, handler, allowInheritance));
		if (typeMap.Count > 0)
		{
			// clear the cache
			typeMap.Clear();
		}
	}

	public IEnumerable<T> GetHandlerStack(Type type)
	{
		if (!typeMap.TryGetValue(type, out Stack<T>? handlers))
		{
			handlers = CalculateAssetHandlerStack(type);
			typeMap.Add(type, handlers);
		}
		return handlers;
	}

	private Stack<T> CalculateAssetHandlerStack(Type type)
	{
		Stack<T> result = new();
		foreach ((Type baseType, T handler, bool allowInheritance) in registeredHandlers)
		{
			if (type == baseType || allowInheritance && type.IsAssignableTo(baseType))
			{
				result.Push(handler);
			}
		}
		return result;
	}
}

```

`Source/AssetRipper.GUI.Free/AssetRipper.GUI.Free.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk.Web">

	<PropertyGroup>
		<ServerGarbageCollection>true</ServerGarbageCollection>
		<OptimizationPreference>Size</OptimizationPreference>
		<PublishAot>true</PublishAot>
		<CETCompat>false</CETCompat>
		<TrimmerSingleWarn>false</TrimmerSingleWarn>
		<OutputPath>..\0Bins\AssetRipper.GUI.Free\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.GUI.Free\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<PropertyGroup>
		<!-- https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trimming-options#trim-framework-library-features -->
		<EnableUnsafeBinaryFormatterSerialization>false</EnableUnsafeBinaryFormatterSerialization>
		<EnableUnsafeUTF7Encoding>false</EnableUnsafeUTF7Encoding>
		<EventSourceSupport>false</EventSourceSupport>
		<InvariantGlobalization>true</InvariantGlobalization>
		<MetadataUpdaterSupport>false</MetadataUpdaterSupport>
		<MetricsSupport>false</MetricsSupport>
		<XmlResolverIsNetworkingEnabledByDefault>false</XmlResolverIsNetworkingEnabledByDefault>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)' == 'Release'">
		<DebuggerSupport>false</DebuggerSupport>
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.GUI.Web\AssetRipper.GUI.Web.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.GUI.Free/Program.cs`:

```cs
using AssetRipper.GUI.Web;

WebApplicationLauncher.Launch(args);

```

`Source/AssetRipper.GUI.Free/appsettings.Development.json`:

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}

```

`Source/AssetRipper.GUI.Free/appsettings.json`:

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}

```

`Source/AssetRipper.GUI.Licensing.SourceGenerator/AssetRipper.GUI.Licensing.SourceGenerator.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>netstandard2.0</TargetFramework>
		<IsAotCompatible>false</IsAotCompatible>
		<AppendTargetFrameworkToOutputPath>true</AppendTargetFrameworkToOutputPath>
		<EnforceExtendedAnalyzerRules>true</EnforceExtendedAnalyzerRules>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="4.14.0">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
		<PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="5.0.0" />
		<PackageReference Include="SourceGenerator.Foundations" Version="2.0.14" />
	</ItemGroup>

	<ItemGroup>
		<!-- Generator dependencies -->
		<PackageReference Include="AssetRipper.Text.SourceGeneration" Version="1.2.3" PrivateAssets="all" GeneratePathProperty="true" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.GUI.Licensing.SourceGenerator/LicensesGenerator.cs`:

```cs
using AssetRipper.Text.SourceGeneration;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using SGF;
using System.CodeDom.Compiler;
using System.Collections.Immutable;

namespace AssetRipper.GUI.Licensing.SourceGenerator;

[IncrementalGenerator]
public sealed class LicensesGenerator() : IncrementalGenerator(nameof(LicensesGenerator))
{
	public override void OnInitialize(SgfInitializationContext context)
	{
		IncrementalValueProvider<ImmutableArray<(string Name, string License)>> pipeline = context.AdditionalTextsProvider
			.Where(static (text) => text.Path.EndsWith(".md"))
			.Select(static (text, cancellationToken) =>
			{
				string name = Path.GetFileNameWithoutExtension(text.Path);
				string? license = text.GetText(cancellationToken)?.ToString();
				return (name, license);
			})
			.Where(static (pair) => pair.license != null)
			.Collect()!;

		context.RegisterSourceOutput(pipeline, GenerateCode);
	}

	private static void GenerateCode(SgfSourceProductionContext context, ImmutableArray<(string Name, string License)> array)
	{
		using StringWriter stringWriter = new();
		using IndentedTextWriter writer = IndentedTextWriterFactory.Create(stringWriter);

		writer.WriteGeneratedCodeWarning();
		writer.WriteLineNoTabs();

		writer.WriteLine("#nullable enable");
		writer.WriteLineNoTabs();
		writer.WriteFileScopedNamespace("AssetRipper.GUI.Licensing");
		writer.WriteLineNoTabs();
		writer.WriteLine("partial class Licenses");
		using (new CurlyBrackets(writer))
		{
			List<(string, string)> sourceNames = new(array.Length);
			foreach ((string name, string license) in array.OrderBy(pair => pair.Name))
			{
				string sourceName = name.Replace('.', '_').Replace('-', '_');
				sourceNames.Add((name, sourceName));
				writer.WriteLine($"private static global::System.ReadOnlySpan<byte> {sourceName}_span => {SymbolDisplay.FormatLiteral(license, true)}u8;");
				writer.WriteLine($"private static string? {sourceName}_field;");
				if (name != sourceName)
				{
					writer.WriteSummaryDocumentation(name);
				}
				writer.WriteLine($"public static string {sourceName} => {sourceName}_field ??= global::System.Text.Encoding.UTF8.GetString({sourceName}_span);");
				writer.WriteLineNoTabs();
			}

			// Names list
			writer.WriteLine("public static global::System.Collections.Generic.IReadOnlyList<string> Names { get; } =");
			writer.WriteLine('[');
			using (new Indented(writer))
			{
				foreach ((string name, _) in sourceNames)
				{
					writer.WriteLine($"{SymbolDisplay.FormatLiteral(name, true)},");
				}
			}
			writer.WriteLine("];");
			writer.WriteLineNoTabs();

			// Get method
			writer.WriteLine("public static string? TryLoad(string name) => name switch");
			using (new CurlyBracketsWithSemicolon(writer))
			{
				foreach ((string name, string sourceName) in sourceNames)
				{
					writer.WriteLine($"{SymbolDisplay.FormatLiteral(name, true)} => {sourceName},");
				}
				writer.WriteLine($"_ => null,");
			}
		}

		context.AddSource("Licenses.g.cs", stringWriter.ToString());
	}
}

```

`Source/AssetRipper.GUI.Licensing/AssetRipper.GUI.Licensing.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.GUI.Licensing\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.GUI.Licensing\$(Configuration)\</IntermediateOutputPath>
		<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
	</PropertyGroup>

	<ItemGroup>
		<None Remove="..\Licenses\*.md" />
		<AdditionalFiles Include="..\Licenses\*.md" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.GUI.Licensing.SourceGenerator\AssetRipper.GUI.Licensing.SourceGenerator.csproj" OutputItemType="Analyzer" ReferenceOutputAssembly="false" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.GUI.Licensing/LicenseNotFoundException.cs`:

```cs
namespace AssetRipper.GUI.Licensing;

public sealed class LicenseNotFoundException : Exception
{
	public LicenseNotFoundException(string fileName) : base($"Could not find license file {fileName}.md")
	{
	}
}

```

`Source/AssetRipper.GUI.Licensing/Licenses.cs`:

```cs
namespace AssetRipper.GUI.Licensing;

public static partial class Licenses
{
	/// <summary>
	/// Load a license file.
	/// </summary>
	/// <param name="name">The name of the license (without any extension).</param>
	/// <returns>The loaded text.</returns>
	public static string Load(string name)
	{
		if (TryLoad(name, out string? license))
		{
			return license;
		}
		throw new LicenseNotFoundException(name);
	}

	public static bool TryLoad(string name, [NotNullWhen(true)] out string? license)
	{
		license = TryLoad(name);
		return license is not null;
	}
}

```

`Source/AssetRipper.GUI.Localizations.SourceGenerator/AssetRipper.GUI.Localizations.SourceGenerator.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>netstandard2.0</TargetFramework>
		<IsAotCompatible>false</IsAotCompatible>
		<AppendTargetFrameworkToOutputPath>true</AppendTargetFrameworkToOutputPath>
		<EnforceExtendedAnalyzerRules>true</EnforceExtendedAnalyzerRules>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="4.14.0">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
		<PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="5.0.0" />
		<PackageReference Include="SourceGenerator.Foundations" Version="2.0.14" />
	</ItemGroup>

	<ItemGroup>
		<!-- Generator dependencies -->
		<PackageReference Include="AssetRipper.Text.SourceGeneration" Version="1.2.3" PrivateAssets="all" GeneratePathProperty="true" />
		<PackageReference Include="System.Text.Json" Version="10.0.2" PrivateAssets="all" GeneratePathProperty="true" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.GUI.Localizations.SourceGenerator/DictionarySerializerContext.cs`:

```cs
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AssetRipper.GUI.Localizations.SourceGenerator;

[JsonSourceGenerationOptions(GenerationMode = JsonSourceGenerationMode.Metadata)]
[JsonSerializable(typeof(Dictionary<string, string>))]
internal sealed partial class DictionarySerializerContext : JsonSerializerContext
{
	public static Dictionary<string, string> Deserialize(string json)
	{
		return JsonSerializer.Deserialize(json, Default.DictionaryStringString) ?? throw new("Json text could not be deserialized.");
	}
}

```

`Source/AssetRipper.GUI.Localizations.SourceGenerator/LanguageCodesGenerator.cs`:

```cs
using AssetRipper.Text.SourceGeneration;
using Microsoft.CodeAnalysis;
using SGF;
using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Globalization;
using System.Text.RegularExpressions;

namespace AssetRipper.GUI.Localizations.SourceGenerator;

[IncrementalGenerator]
public sealed partial class LanguageCodesGenerator : IncrementalGenerator
{
	public LanguageCodesGenerator() : base(typeof(LanguageCodesGenerator).FullName)
	{
	}

	public override void OnInitialize(SgfInitializationContext context)
	{
		IncrementalValueProvider<ImmutableArray<string>> pipeline = context.AdditionalTextsProvider
			.Where(static (text) => text.Path.EndsWith(".json"))
			.Select(static (text, cancellationToken) =>
			{
				return Path.GetFileName(text.Path);
			})
			.Collect();

		context.RegisterSourceOutput(pipeline, GenerateCode);
	}

	private static void GenerateCode(SgfSourceProductionContext context, ImmutableArray<string> files)
	{
		StringWriter stringWriter = new();
		IndentedTextWriter writer = IndentedTextWriterFactory.Create(stringWriter);

		writer.WriteGeneratedCodeWarning();
		writer.WriteLineNoTabs();

		writer.WriteLineNoTabs("#nullable enable");

		writer.WriteFileScopedNamespace("AssetRipper.GUI.Localizations");
		writer.WriteLine("public static partial class LanguageCodes");
		using (new CurlyBrackets(writer))
		{
			AddLocalizationDictionary(writer, files);
			writer.WriteLineNoTabs();
			AddUnderscoredAndHyphenatedConversion(writer, files);
		}

		writer.Flush();

		context.AddSource("LanguageCodes.g.cs", stringWriter.ToString());
	}

	private static void AddLocalizationDictionary(IndentedTextWriter writer, ImmutableArray<string> files)
	{
		writer.WriteSummaryDocumentation("Dictionary of Language codes to Language names");
		writer.WriteLine("public static IReadOnlyDictionary<string, string> LanguageNameDictionary { get; } = new Dictionary<string, string>");

		using (new CurlyBracketsWithSemicolon(writer))
		{
			foreach (string file in files.OrderBy(s => s))
			{
				string languageCode = Path.GetFileNameWithoutExtension(file).Replace('_', '-');
				string languageName = ExtractCultureName(new CultureInfo(languageCode));
				writer.WriteLine($"{{ \"{languageCode}\", \"{languageName}\" }},");
			}
		}
	}

	private static void AddUnderscoredAndHyphenatedConversion(IndentedTextWriter writer, ImmutableArray<string> files)
	{
		writer.WriteSummaryDocumentation("Convert a language code to its underscored variant.");
		writer.WriteRemarksDocumentation("This is used by the json file names.");
		writer.WriteLine("[return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(value))]");
		writer.WriteLine("internal static string? AsUnderscoredLanguageCode(string? value) => value switch");
		using (new CurlyBracketsWithSemicolon(writer))
		{
			foreach (string file in files)
			{
				string underscoredCode = Path.GetFileNameWithoutExtension(file);
				if (underscoredCode.Contains('_'))
				{
					string hyphenatedCode = underscoredCode.Replace('_', '-');
					writer.WriteLine($"\"{hyphenatedCode}\" => \"{underscoredCode}\",");
				}
			}
			writer.WriteLine("_ => value");
		}

		writer.WriteLineNoTabs();

		writer.WriteSummaryDocumentation("Convert a language code to its hyphenated variant.");
		writer.WriteRemarksDocumentation("This is used by HTML and the IANA Language Subtag Registry.");
		writer.WriteLine("[return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(nameof(value))]");
		writer.WriteLine("internal static string? AsHyphenatedLanguageCode(string? value) => value switch");
		using (new CurlyBracketsWithSemicolon(writer))
		{
			foreach (string file in files)
			{
				string underscoredCode = Path.GetFileNameWithoutExtension(file);
				if (underscoredCode.Contains('_'))
				{
					string hyphenatedCode = underscoredCode.Replace('_', '-');
					writer.WriteLine($"\"{underscoredCode}\" => \"{hyphenatedCode}\",");
				}
			}
			writer.WriteLine("_ => value");
		}
	}

	private static string ExtractCultureName(CultureInfo culture)
	{
		return SortOrderRegex.Replace(culture.NativeName, match => $"({match.Groups[1].Value})");
	}

	private static Regex SortOrderRegex { get; } = new Regex(@"\(Sort Order=([A-Z]+)\)", RegexOptions.Compiled);
}

```

`Source/AssetRipper.GUI.Localizations.SourceGenerator/LocalizationGenerator.cs`:

```cs
using AssetRipper.Text.SourceGeneration;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using SGF;
using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Text;
using System.Text.Json;

namespace AssetRipper.GUI.Localizations.SourceGenerator;

[IncrementalGenerator]
public sealed class LocalizationGenerator : IncrementalGenerator
{
	public LocalizationGenerator() : base(typeof(LocalizationGenerator).FullName)
	{
	}

	public override void OnInitialize(SgfInitializationContext context)
	{
		IncrementalValueProvider<ImmutableArray<(string name, string? json)>> pipeline = context.AdditionalTextsProvider
			.Where(static (text) => text.Path.EndsWith(".json"))
			.Select(static (text, cancellationToken) =>
			{
				string name = Path.GetFileName(text.Path);
				string? json = text.GetText(cancellationToken)?.ToString();
				return (name, json);
			})
			.Where(static (pair) => pair.json != null)
			.Collect();

		context.RegisterSourceOutput(pipeline, GenerateCode);
	}

	private static void GenerateCode(SgfSourceProductionContext context, ImmutableArray<(string, string?)> files)
	{
		List<(string, Dictionary<string, string>)> list = new(files.Length);
		foreach ((string file, string? json) in files.OrderBy(s => s.Item1))
		{
			string languageCode = Path.GetFileNameWithoutExtension(file).Replace('_', '-');
			Dictionary<string, string> dictionary = JsonSerializer.Deserialize<Dictionary<string, string>>(json!) ?? throw new();
			list.Add((languageCode, dictionary));
		}
		list = list.OrderBy(pair => pair.Item1).ToList();

		Dictionary<string, string> americanEnglish = list.First(pair => pair.Item1 == "en-US").Item2;

		StringWriter stringWriter = new();
		IndentedTextWriter writer = IndentedTextWriterFactory.Create(stringWriter);

		writer.WriteGeneratedCodeWarning();
		writer.WriteLineNoTabs();

		writer.WriteFileScopedNamespace("AssetRipper.GUI.Localizations");
		writer.WriteLine("partial class Localization");
		using (new CurlyBrackets(writer))
		{
			foreach (KeyValuePair<string, string> pair in americanEnglish.OrderBy(pair => pair.Key))
			{
				(string key, string content) = (pair.Key, pair.Value);
				writer.WriteSummaryDocumentation(content);
				writer.WriteLine($"public static string {SnakeCaseToPascalCase(key)} => CurrentLanguageCode switch");
				using (new CurlyBracketsWithSemicolon(writer))
				{
					foreach ((string languageCode, Dictionary<string, string> dictionary) in list)
					{
						if (languageCode == "en-US" || !dictionary.TryGetValue(key, out string? value))
						{
							continue;
						}
						writer.WriteLine($"\"{languageCode}\" => {SymbolDisplay.FormatLiteral(value, quote: true)},");
					}
					writer.WriteLine($"_ => {SymbolDisplay.FormatLiteral(content, quote: true)},");
				}
				writer.WriteLineNoTabs();
			}
		}

		writer.Flush();

		context.AddSource("Localization.g.cs", stringWriter.ToString());
	}

	private static string SnakeCaseToPascalCase(string str)
	{
		StringBuilder builder = new(str.Length);
		bool nextUpper = true;
		foreach (char c in str)
		{
			if (c == '_')
			{
				nextUpper = true;
			}
			else if (nextUpper)
			{
				builder.Append(char.ToUpperInvariant(c));
				nextUpper = false;
			}
			else
			{
				builder.Append(c);
			}
		}
		return builder.ToString();
	}
}

```

`Source/AssetRipper.GUI.Localizations/AssetRipper.GUI.Localizations.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.GUI.Localizations\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.GUI.Localizations\$(Configuration)\</IntermediateOutputPath>
		<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
	</PropertyGroup>

	<ItemGroup>
		<None Remove="..\..\Localizations\*.json" />
		<AdditionalFiles Include="..\..\Localizations\*.json" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.GUI.Localizations.SourceGenerator\AssetRipper.GUI.Localizations.SourceGenerator.csproj" OutputItemType="Analyzer" ReferenceOutputAssembly="false" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.GUI.Localizations/LanguageCodes.cs`:

```cs
namespace AssetRipper.GUI.Localizations;

public static partial class LanguageCodes
{
	public const string English = "en-US";

	public static bool Exists([NotNullWhen(true)] string? code)
	{
		return code is not null && LanguageNameDictionary.ContainsKey(code);
	}
}

```

`Source/AssetRipper.GUI.Localizations/Localization.cs`:

```cs
namespace AssetRipper.GUI.Localizations;

public static partial class Localization
{
	/// <summary>
	/// <see href="https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry" >IANA</see> language code
	/// </summary>
	public static string CurrentLanguageCode { get; private set; } = LanguageCodes.English;

	public static event Action? OnLanguageChanged;

	public static void LoadLanguage(string? code)
	{
		string? value = LanguageCodes.AsHyphenatedLanguageCode(code);
		if (CurrentLanguageCode != value && LanguageCodes.Exists(value))
		{
			CurrentLanguageCode = value;
			OnLanguageChanged?.Invoke();
		}
	}
}

```

`Source/AssetRipper.GUI.SourceGenerator/AssetRipper.GUI.SourceGenerator.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>exe</OutputType>
		<OutputPath>..\0Bins\Other\AssetRipper.GUI.SourceGenerator\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.GUI.SourceGenerator\$(Configuration)\</IntermediateOutputPath>
		<IsAotCompatible>false</IsAotCompatible>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.Text.SourceGeneration" Version="1.2.3" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Export.UnityProjects\AssetRipper.Export.UnityProjects.csproj" />
	</ItemGroup>

</Project>
```

`Source/AssetRipper.GUI.SourceGenerator/DictionarySerializerContext.cs`:

```cs
using System.Text.Encodings.Web;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AssetRipper.GUI.SourceGenerator;

[JsonSourceGenerationOptions(WriteIndented = true, IndentCharacter = ' ', IndentSize = 4, NewLine = "\n")]
[JsonSerializable(typeof(Dictionary<string, string>))]
internal sealed partial class DictionarySerializerContext : JsonSerializerContext
{
	[field: MaybeNull]
	private static DictionarySerializerContext ActualDefault
	{
		get
		{
			return field ??= new(new JsonSerializerOptions(s_defaultOptions!)
			{
				Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
			});
		}
	}

	public static string Serialize(Dictionary<string, string> dictionary)
	{
		return JsonSerializer.Serialize(dictionary, ActualDefault.DictionaryStringString);
	}

	public static Dictionary<string, string> Deserialize(string json)
	{
		return JsonSerializer.Deserialize(json, ActualDefault.DictionaryStringString) ?? throw new("Json text could not be deserialized.");
	}
}

```

`Source/AssetRipper.GUI.SourceGenerator/Paths.cs`:

```cs
namespace AssetRipper.GUI.SourceGenerator;

public static class Paths
{
	public const string RepositoryPath = SourcePath + "../";
	public const string SourcePath = "../../../../";
	public const string LocalizationsPath = RepositoryPath + "Localizations/";
	public const string WebProjectPath = SourcePath + "AssetRipper.GUI.Web/";
}

```

`Source/AssetRipper.GUI.SourceGenerator/Program.cs`:

```cs
namespace AssetRipper.GUI.SourceGenerator;

public static class Program
{
	public static void Main()
	{
		CleanJsonLocalizationFiles();
		SettingsPageGenerator.Run();
	}

	private static void CleanJsonLocalizationFiles()
	{
		const string englishPath = Paths.LocalizationsPath + "en_US.json";
		Dictionary<string, string> englishDictionary = DeserializeJson(File.ReadAllText(englishPath))
			.OrderBy(pair => pair.Key)
			.ToDictionary(pair => pair.Key, pair => pair.Value);
		File.WriteAllText(englishPath, SerializeJson(englishDictionary));

		static Dictionary<string, string> DeserializeJson(string jsonText) => DictionarySerializerContext.Deserialize(jsonText);
		static string SerializeJson(Dictionary<string, string> dictionary) => DictionarySerializerContext.Serialize(dictionary);
	}
}

```

`Source/AssetRipper.GUI.SourceGenerator/PropertyData.cs`:

```cs
using AssetRipper.Primitives;
using System.Reflection;

namespace AssetRipper.GUI.SourceGenerator;

internal sealed class PropertyData(PropertyInfo info)
{
	public PropertyInfo Info { get; } = info;
	public string Name => Info.Name;
	public Type PropertyType => Info.PropertyType;
	public Type? DeclaringType => Info.DeclaringType;
	public bool IsBoolean => PropertyType == typeof(bool);
	public bool IsUnityVersion => PropertyType == typeof(UnityVersion);
	public bool IsString => PropertyType == typeof(string) || PropertyType == typeof(Utf8String);
	public bool IsEnum => PropertyType.IsAssignableTo(typeof(Enum));
	public string NameOfString => $"nameof({DeclaringType?.Name}.{Name})";
}

```

`Source/AssetRipper.GUI.SourceGenerator/SettingsPageGenerator.cs`:

```cs
using AssetRipper.Export.Configuration;
using AssetRipper.Import.Configuration;
using AssetRipper.Processing.Configuration;
using AssetRipper.Text.SourceGeneration;
using System.CodeDom.Compiler;
using System.Diagnostics;
using System.Reflection;

namespace AssetRipper.GUI.SourceGenerator;

internal static class SettingsPageGenerator
{
	public static void Run()
	{
		GenerateHelperClass(IndentedTextWriterFactory.Create(Paths.WebProjectPath + "Pages/Settings", "SettingsPage"));
		Console.WriteLine("Done!");
	}

	static void GenerateHelperClass(IndentedTextWriter writer)
	{
		writer.WriteGeneratedCodeWarning();
		writer.WriteLineNoTabs();
		writer.WriteUsing("AssetRipper.Export.Configuration");
		writer.WriteUsing("AssetRipper.GUI.Web.Pages.Settings.DropDown");
		writer.WriteUsing("AssetRipper.Import.Configuration");
		writer.WriteUsing("AssetRipper.Processing.Configuration");
		writer.WriteLineNoTabs();
		writer.WriteFileScopedNamespace("AssetRipper.GUI.Web.Pages.Settings");
		writer.WriteLineNoTabs();
		writer.WriteLine("#nullable enable");
		writer.WriteLineNoTabs();
		writer.WriteLine("partial class SettingsPage");
		using (new CurlyBrackets(writer))
		{
			List<PropertyData> properties = GetProperties().ToList();
			writer.WriteLine("private static void SetProperty(string key, string? value)");
			using (new CurlyBrackets(writer))
			{
				writer.WriteLine("switch (key)");
				using (new CurlyBrackets(writer))
				{
					foreach (PropertyData property in properties.Where(p => !p.IsBoolean))
					{
						writer.WriteLine($"case {property.NameOfString}:");
						using (new Indented(writer))
						{
							writer.Write($"Configuration.{property.DeclaringType?.Name}.");
							writer.Write(property.Name);
							writer.Write(" = ");
							if (property.IsUnityVersion)
							{
								writer.WriteLine("TryParseUnityVersion(value);");
							}
							else if (property.IsEnum)
							{
								writer.Write("TryParseEnum<");
								writer.Write(property.PropertyType.Name);
								writer.WriteLine(">(value);");
							}
							else
							{
								Debug.Assert(property.IsString);
								writer.WriteLine("value;");
							}
							writer.WriteLine("break;");
						}
					}
				}
			}

			writer.WriteLineNoTabs();
			writer.WriteLine("private static readonly Dictionary<string, Action<bool>> booleanProperties = new()");
			using (new CurlyBracketsWithSemicolon(writer))
			{
				foreach (PropertyData property in properties)
				{
					if (property.IsBoolean)
					{
						writer.WriteLine($"{{ {property.NameOfString}, (value) => {{ Configuration.{property.DeclaringType?.Name}.{property.Name} = value; }} }},");
					}
				}
			}

			foreach (PropertyData property in properties)
			{
				if (property.IsBoolean)
				{
					writer.WriteLineNoTabs();
					writer.WriteLine($"private static void WriteCheckBoxFor{property.Name}(TextWriter writer, string label, bool disabled = false)");
					using (new CurlyBrackets(writer))
					{
						writer.WriteLine($"WriteCheckBox(writer, label, Configuration.{property.DeclaringType?.Name}.{property.Name}, {property.NameOfString}, disabled);");
					}
				}
				else if (property.IsEnum)
				{
					writer.WriteLineNoTabs();
					writer.WriteLine($"private static void WriteDropDownFor{property.Name}(TextWriter writer)");
					using (new CurlyBrackets(writer))
					{
						writer.WriteLine($"WriteDropDown(writer, {property.PropertyType.Name}DropDownSetting.Instance, Configuration.{property.DeclaringType?.Name}.{property.Name}, {property.NameOfString});");
					}
				}
			}
		}
	}

	static IEnumerable<PropertyData> GetProperties()
	{
		foreach (Type type in (Type[])[typeof(ImportSettings), typeof(ProcessingSettings), typeof(ExportSettings)])
		{
			foreach (PropertyInfo property in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
			{
				yield return new PropertyData(property);
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web.Tests/AssetRipper.GUI.Web.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<IsPackable>false</IsPackable>
		<OutputPath>..\0Bins\Other\AssetRipper.GUI.Web.Tests\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.GUI.Web.Tests\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
		<PackageReference Include="NUnit" Version="4.4.0" />
		<PackageReference Include="NUnit3TestAdapter" Version="6.1.0" />
		<PackageReference Include="NUnit.Analyzers" Version="4.11.2">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.GUI.Web\AssetRipper.GUI.Web.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.GUI.Web.Tests/BundlePathTests.cs`:

```cs
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Tests;

public class BundlePathTests
{
	[Test]
	public void DefaultBundlePathIsRoot()
	{
		BundlePath path = default;
		Assert.That(path.IsRoot);
	}

	[Test]
	public void BundlePathParentWithDepthOneIsRoot()
	{
		BundlePath path = new([0]);
		Assert.That(path.Parent.IsRoot);
	}

	[Test]
	public void BundlePathParentWithDepthTwoIsNotRoot()
	{
		BundlePath path = new([0, 0]);
		Assert.That(path.Parent.IsRoot, Is.False);
	}

	[Test]
	public void ParentHasCorrectPath()
	{
		BundlePath path = new([1, 2, 3]);
		BundlePath parent = path.Parent;
		Assert.That(parent.Path.ToArray(), Is.EquivalentTo((int[])[1, 2]));
	}

	[Test]
	public void BundlePathsAreSequenceEqual()
	{
		BundlePath path1 = new([0, 0]);
		BundlePath path2 = new([0, 0]);
		Assert.That(path1, Is.EqualTo(path2));
	}

	[Test]
	public void ToStringDoesNotThrow()
	{
		// At one point, ToString could cause a StackOverflowException because it was a record,
		// and the generated PrintMembers method was calling Parent.ToString.
		// This test prevents that from ever happening again.
		Assert.DoesNotThrow(() =>
		{
			BundlePath bundlePath = default;
			bundlePath.ToString();
		});
	}
}

```

`Source/AssetRipper.GUI.Web.Tests/Usings.cs`:

```cs
global using NUnit.Framework;

```

`Source/AssetRipper.GUI.Web/AppJsonSerializerContext.cs`:

```cs
using AssetRipper.GUI.Web.Pages;
using System.Text.Json.Serialization;

namespace AssetRipper.GUI.Web;

[JsonSerializable(typeof(Dictionary<string, string>))]
[JsonSerializable(typeof(string[]))]
[JsonSerializable(typeof(bool))]
[JsonSerializable(typeof(int))]
[JsonSerializable(typeof(byte[]))]
[JsonSerializable(typeof(Commands.PathFormData))]
internal partial class AppJsonSerializerContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.GUI.Web/Arguments.cs`:

```cs
using Ookii.CommandLine;
using System.ComponentModel;

namespace AssetRipper.GUI.Web;

[GeneratedParser]
[ParseOptions(IsPosix = true)]
internal sealed partial class Arguments
{
	[CommandLineArgument(DefaultValue = WebApplicationLauncher.Defaults.Port)]
	[Description("If nonzero, the application will attempt to host on this port, instead of finding a random unused port.")]
	public int Port { get; set; }

	[CommandLineArgument(DefaultValue = WebApplicationLauncher.Defaults.Log)]
	[Description("If true, the application will log to a file.")]
	public bool Log { get; set; }

	[CommandLineArgument(DefaultValue = WebApplicationLauncher.Defaults.LogPath)]
	[Description("The file location at which to save the log, or a sensible default if not provided.")]
	public string? LogPath { get; set; }

	[CommandLineArgument("local-web-file")]
	[Description("Files provided with this option will replace online sources.")]
	public string[]? LocalWebFiles { get; set; }

	[CommandLineArgument(DefaultValue = false)]
	[Description("If true, a browser window will not be launched automatically.")]
	public bool Headless { get; set; }
}

```

`Source/AssetRipper.GUI.Web/AssetRipper.GUI.Web.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.GUI.Web\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.GUI.Web\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Export.PrimaryContent\AssetRipper.Export.PrimaryContent.csproj" />
		<ProjectReference Include="..\AssetRipper.Export.UnityProjects\AssetRipper.Export.UnityProjects.csproj" />
		<ProjectReference Include="..\AssetRipper.GUI.Licensing\AssetRipper.GUI.Licensing.csproj" />
		<ProjectReference Include="..\AssetRipper.GUI.Localizations\AssetRipper.GUI.Localizations.csproj" />
		<ProjectReference Include="..\AssetRipper.Web\AssetRipper.Web.csproj" />
	</ItemGroup>

	<ItemGroup>
		<FrameworkReference Include="Microsoft.AspNetCore.App" />
	</ItemGroup>

	<ItemGroup>
		<EmbeddedResource Include="StaticContent/css/site.css" />
		<EmbeddedResource Include="StaticContent/favicon.ico" />
		<EmbeddedResource Include="StaticContent/js/site.js" />
		<EmbeddedResource Include="StaticContent/js/commands_page.js" />
		<EmbeddedResource Include="StaticContent/js/mesh_preview.js" />
	</ItemGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.GUI.Web.Dependencies" Version="1.1.0" />
		<PackageReference Include="AssetRipper.NativeDialogs" Version="1.1.2" />
		<PackageReference Include="AssetRipper.Text.Html" Version="2.1.0" />
		<PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="10.0.2" />
		<PackageReference Include="Microsoft.OpenApi" Version="2.6.1" />
		<PackageReference Include="Ookii.CommandLine" Version="5.0.0" />
		<PackageReference Include="oqo0.SwaggerThemes" Version="1.4.3" />
		<PackageReference Include="Swashbuckle.AspNetCore" Version="10.1.0" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.GUI.Web/DefaultPage.cs`:

```cs
using AssetRipper.GUI.Web.Documentation;
using AssetRipper.GUI.Web.Pages;
using AssetRipper.GUI.Web.Pages.Search;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.Web.Content;

namespace AssetRipper.GUI.Web;
public abstract class DefaultPage : HtmlPage
{
	public sealed override void Write(TextWriter writer)
	{
		base.Write(writer);
		using (new Html(writer).WithLang(Localization.CurrentLanguageCode).End())
		{
			using (new Head(writer).End())
			{
				new Meta(writer).WithCharset("utf-8").Close();
				new Meta(writer).WithName("viewport").WithContent("width=device-width, initial-scale=1.0").Close();
				new Title(writer).Close(GetTitle());
				OnlineDependencies.Bootstrap.WriteStyleSheetReference(writer);
				new Link(writer).WithRel("stylesheet").WithHref("/css/site.css").Close();
			}
			using (new Body(writer).WithCustomAttribute("data-bs-theme", "dark").End())
			{
				WriteHeader(writer);

				using (new Div(writer).WithClass("container").End())
				{
					using (new Main(writer).WithRole("main").WithId("app").WithClass("pb-3").End())
					{
						WriteInnerContent(writer);
					}
				}

				WriteFooter(writer);

				WriteScriptReferences(writer);
			}
		}
	}

	public abstract string? GetTitle();

	public abstract void WriteInnerContent(TextWriter writer);

	private static void WriteHeader(TextWriter writer)
	{
		using (new Header(writer).End())
		{
			using (new Div(writer).WithClass("btn-group").End())
			{
				WriteFileMenu(writer);
				WriteViewMenu(writer);
				WriteExportMenu(writer);
				WriteLanguageMenu(writer);
				WriteDevelopmentMenu(writer);
			}
		}
	}

	private static void WriteFileMenu(TextWriter writer)
	{
		using (new Div(writer).WithClass("btn-group dropdown").End())
		{
			WriteDropdownButton(writer, Localization.MenuFile);
			using (new Ul(writer).WithClass("dropdown-menu").End())
			{
				using (new Li(writer).End())
				{
					WritePostLink(writer, "/LoadFile", Localization.MenuFileOpenFile, "dropdown-item");
				}
				using (new Li(writer).End())
				{
					WritePostLink(writer, "/LoadFolder", Localization.MenuFileOpenFolder, "dropdown-item");
				}
				using (new Li(writer).End())
				{
					WritePostLink(writer, "/Reset", Localization.MenuFileReset, "dropdown-item");
				}
				using (new Li(writer).End())
				{
					new Hr(writer).WithClass("dropdown-divider").Close();
				}
				using (new Li(writer).End())
				{
					new A(writer).WithClass("dropdown-item").WithHref("/Settings/Edit").Close(Localization.Settings);
				}
			}
		}
	}

	private static void WriteViewMenu(TextWriter writer)
	{
		using (new Div(writer).WithClass("btn-group dropdown").End())
		{
			WriteDropdownButton(writer, Localization.MenuView);
			using (new Ul(writer).WithClass("dropdown-menu").End())
			{
				using (new Li(writer).End())
				{
					new A(writer).WithClass("dropdown-item").WithHref("/").Close(Localization.Home);
				}
				if (GameFileLoader.IsLoaded)
				{
					using (new Li(writer).End())
					{
						new A(writer).WithClass("dropdown-item").WithHref("/Search/View").Close(Localization.Search);
					}
				}
				using (new Li(writer).End())
				{
					new A(writer).WithClass("dropdown-item").WithHref("/Settings/Edit").Close(Localization.Settings);
				}
				using (new Li(writer).End())
				{
					new A(writer).WithClass("dropdown-item").WithHref("/ConfigurationFiles").Close(Localization.ConfigurationFiles);
				}
				using (new Li(writer).End())
				{
					new A(writer).WithClass("dropdown-item").WithHref("/Commands").Close(Localization.Commands);
				}
				using (new Li(writer).End())
				{
					new A(writer).WithClass("dropdown-item").WithHref("/Privacy").Close(Localization.Privacy);
				}
				using (new Li(writer).End())
				{
					new A(writer).WithClass("dropdown-item").WithHref("/Licenses").Close(Localization.Licenses);
				}
				using (new Li(writer).End())
				{
					new A(writer).WithClass("dropdown-item").WithHref("/PremiumFeatures").Close(Localization.PremiumFeatures);
				}
			}
		}
	}

	private static void WriteExportMenu(TextWriter writer)
	{
		using (new Div(writer).WithClass("btn-group dropdown").End())
		{
			WriteDropdownButton(writer, Localization.MenuExport);
			using (new Ul(writer).WithClass("dropdown-menu").End())
			{
				if (GameFileLoader.IsLoaded)
				{
					using (new Li(writer).End())
					{
						new A(writer).WithClass("dropdown-item").WithHref("/Commands").Close(Localization.MenuExportAll);
					}
					string version = GameFileLoader.GameBundle.GetMaxUnityVersion().ToString();
					using (new Li(writer).End())
					{
						new A(writer).WithClass("dropdown-item").WithNewTabAttributes().WithHref($"unityhub://{version}").Close(version);
					}
				}
				else
				{
					using (new Li(writer).End())
					{
						new A(writer).WithClass("dropdown-item disabled").WithCustomAttribute("aria-diabled", "true").Close(Localization.MenuExportAll);
					}
				}
			}
		}
	}

	private static void WriteLanguageMenu(TextWriter writer)
	{
		using (new Div(writer).WithClass("btn-group dropdown").End())
		{
			WriteDropdownButton(writer, Localization.MenuLanguage);
			using (new Ul(writer).WithClass("dropdown-menu").End())
			{
				foreach ((string code, string name) in LanguageCodes.LanguageNameDictionary)
				{
					using (new Li(writer).End())
					{
						WritePostLink(writer, $"/Localization?code={code}", name, "dropdown-item");
					}
				}
			}
		}
	}

	private static void WriteDevelopmentMenu(TextWriter writer)
	{
		using (new Div(writer).WithClass("btn-group dropdown").End())
		{
			WriteDropdownButton(writer, Localization.MenuDevelopment);
			using (new Ul(writer).WithClass("dropdown-menu").End())
			{
				using (new Li(writer).End())
				{
					new A(writer).WithClass("dropdown-item").WithHref(DocumentationPaths.OpenApi).Close(Localization.OpenApiJson);
				}
				using (new Li(writer).End())
				{
					new A(writer).WithClass("dropdown-item").WithHref(DocumentationPaths.Swagger).Close(Localization.SwaggerDocumentation);
				}
				using (new Li(writer).End())
				{
					new A(writer).WithClass("dropdown-item").WithNewTabAttributes().WithHref("https://unity.com/unity-hub").Close(Localization.InstallUnityHub);
				}
				if (GameFileLoader.IsLoaded)
				{
					string version = GameFileLoader.GameBundle.GetMaxUnityVersion().ToString();
					using (new Li(writer).End())
					{
						new A(writer).WithClass("dropdown-item").WithNewTabAttributes().WithHref($"unityhub://{version}").Close(Localization.InstallUnityEditor);
					}
				}
			}
		}
	}

	private static void WriteDropdownButton(TextWriter writer, string buttonText)
	{
		new Button(writer).WithClass("btn btn-dark dropdown-toggle mx-0")
			.WithType("button")
			.WithCustomAttribute("data-bs-toggle", "dropdown")
			.WithCustomAttribute("aria-expanded", "false")
			.Close(buttonText);
	}

	private static void WritePostLink(TextWriter writer, string url, string name, string? @class = null)
	{
		using (new Form(writer).WithAction(url).WithMethod("post").End())
		{
			new Input(writer).WithType("submit").WithClass(@class).WithValue(name.ToHtml()).Close();
		}
	}

	private static void WriteFooter(TextWriter writer)
	{
		using (new Footer(writer).WithClass("border-top footer text-muted").End())
		{
			using (new Div(writer).WithClass("container text-center").End())
			{
				writer.Write("&copy; 2025 - AssetRipper - ");
				new A(writer).WithHref("/Privacy").Close(Localization.Privacy);
				writer.Write(" - ");
				new A(writer).WithHref("/Licenses").Close(Localization.Licenses);
			}
		}
	}

	protected virtual void WriteScriptReferences(TextWriter writer)
	{
		OnlineDependencies.Popper.WriteScriptReference(writer);
		OnlineDependencies.Bootstrap.WriteScriptReference(writer);
		new Script(writer).WithSrc("/js/site.js").Close();
	}
}

```

`Source/AssetRipper.GUI.Web/Dialogs.cs`:

```cs
using AssetRipper.NativeDialogs;
using AssetRipper.Web.Extensions;
using Microsoft.AspNetCore.Http;

namespace AssetRipper.GUI.Web;

internal static class Dialogs
{
	public static bool Supported => NativeDialog.Supported;

	public static class OpenFiles
	{
		public static async Task HandleGetRequest(HttpContext context)
		{
			context.Response.DisableCaching();
			string[] paths = await OpenFileDialog.OpenFiles() ?? [];
			await Results.Json(paths, AppJsonSerializerContext.Default.StringArray).ExecuteAsync(context);
		}
	}

	public static class OpenFolders
	{
		public static async Task HandleGetRequest(HttpContext context)
		{
			context.Response.DisableCaching();
			string[] paths = await OpenFolderDialog.OpenFolders() ?? [];
			await Results.Json(paths, AppJsonSerializerContext.Default.StringArray).ExecuteAsync(context);
		}
	}

	public static class OpenFile
	{
		public static async Task HandleGetRequest(HttpContext context)
		{
			context.Response.DisableCaching();
			string path = await OpenFileDialog.OpenFile() ?? "";
			await Results.Json(path, AppJsonSerializerContext.Default.String).ExecuteAsync(context);
		}
	}

	public static class OpenFolder
	{
		public static async Task HandleGetRequest(HttpContext context)
		{
			context.Response.DisableCaching();
			string path = await OpenFolderDialog.OpenFolder() ?? "";
			await Results.Json(path, AppJsonSerializerContext.Default.String).ExecuteAsync(context);
		}
	}

	public static class SaveFile
	{
		public static async Task HandleGetRequest(HttpContext context)
		{
			context.Response.DisableCaching();
			string path = await SaveFileDialog.SaveFile() ?? "";
			await Results.Json(path, AppJsonSerializerContext.Default.String).ExecuteAsync(context);
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Documentation/ClearDocumentTagsTransformer.cs`:

```cs
using Microsoft.AspNetCore.OpenApi;
using Microsoft.OpenApi;

namespace AssetRipper.GUI.Web.Documentation;

internal class ClearDocumentTagsTransformer : IOpenApiDocumentTransformer
{
	public Task TransformAsync(OpenApiDocument document, OpenApiDocumentTransformerContext context, CancellationToken cancellationToken)
	{
		document.Tags?.Clear();
		return Task.CompletedTask;
	}
}

```

`Source/AssetRipper.GUI.Web/Documentation/ClearOperationTagsTransformer.cs`:

```cs
using Microsoft.AspNetCore.OpenApi;
using Microsoft.OpenApi;

namespace AssetRipper.GUI.Web.Documentation;

internal class ClearOperationTagsTransformer : IOpenApiOperationTransformer
{
	public Task TransformAsync(OpenApiOperation operation, OpenApiOperationTransformerContext context, CancellationToken cancellationToken)
	{
		operation.Tags?.Clear();
		return Task.CompletedTask;
	}
}

```

`Source/AssetRipper.GUI.Web/Documentation/DocumentationExtensions.cs`:

```cs
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.OpenApi;

namespace AssetRipper.GUI.Web.Documentation;

internal static class DocumentationExtensions
{
	public static RouteHandlerBuilder WithParameter(this RouteHandlerBuilder builder, OpenApiParameter parameter)
	{
		return builder.WithMetadata(new InsertionMetadata<OpenApiParameter>(parameter));
	}

	public static RouteHandlerBuilder WithQueryStringParameter(this RouteHandlerBuilder builder, string name, string description = "", bool required = false)
	{
		return builder.WithParameter(new OpenApiParameter
		{
			Name = name,
			In = ParameterLocation.Query,
			Description = description,
			Required = required,
			Schema = new OpenApiSchema
			{
				Type = JsonSchemaType.String,
			},
		});
	}

	public static RouteHandlerBuilder ProducesHtmlPage(this RouteHandlerBuilder builder)
	{
		return builder.Produces<string>(StatusCodes.Status200OK, "text/html");
	}
}

```

`Source/AssetRipper.GUI.Web/Documentation/DocumentationPaths.cs`:

```cs
namespace AssetRipper.GUI.Web.Documentation;

internal static class DocumentationPaths
{
	public const string OpenApi = "/openapi.json";
	public const string Swagger = "/swagger";
}

```

`Source/AssetRipper.GUI.Web/Documentation/InsertionMetadata.cs`:

```cs
namespace AssetRipper.GUI.Web.Documentation;

internal record InsertionMetadata<T>(T Value);

```

`Source/AssetRipper.GUI.Web/Documentation/InsertionOperationTransformer.cs`:

```cs
using Microsoft.AspNetCore.OpenApi;
using Microsoft.OpenApi;

namespace AssetRipper.GUI.Web.Documentation;

internal class InsertionOperationTransformer : IOpenApiOperationTransformer
{
	public Task TransformAsync(OpenApiOperation operation, OpenApiOperationTransformerContext context, CancellationToken cancellationToken)
	{
		foreach (InsertionMetadata<OpenApiParameter> metadata in context.Description.ActionDescriptor.EndpointMetadata.OfType<InsertionMetadata<OpenApiParameter>>())
		{
			operation.Parameters ??= [];
			operation.Parameters.Add(metadata.Value);
		}
		return Task.CompletedTask;
	}
}

```

`Source/AssetRipper.GUI.Web/Documentation/NullSerializerContext.cs`:

```cs
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;

namespace AssetRipper.GUI.Web.Documentation;

/// <summary>
/// A <see cref="JsonSerializerContext"/> that treats everything as { }.
/// </summary>
/// <remarks>
/// Note: Classes have to be individually declared.
/// </remarks>
internal sealed class NullSerializerContext : JsonSerializerContext, IJsonTypeInfoResolver
{
	public static NullSerializerContext Instance { get; } = new(new(new JsonSerializerOptions()));

	public NullSerializerContext(JsonSerializerOptions? options) : base(options)
	{
	}

	protected override JsonSerializerOptions? GeneratedSerializerOptions => null;

	public override JsonTypeInfo? GetTypeInfo(Type type)
	{
		Options.TryGetTypeInfo(type, out JsonTypeInfo? typeInfo);
		return typeInfo;
	}

	JsonTypeInfo? IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options)
	{
		if (type == typeof(Task))
		{
			return CreateTypeInfo(options, () => Task.CompletedTask);
		}
		return null;
	}

	private static JsonTypeInfo<T> CreateTypeInfo<T>(JsonSerializerOptions options, Func<T> objectCreator) where T : class
	{
		JsonObjectInfoValues<T> jsonObjectInfoValues = new()
		{
			ObjectCreator = objectCreator,
			ObjectWithParameterizedConstructorCreator = null,
			PropertyMetadataInitializer = (_) => [],
			ConstructorParameterMetadataInitializer = null,
			ConstructorAttributeProviderFactory = null,
			SerializeHandler = null,
		};
		JsonTypeInfo<T> jsonTypeInfo = JsonMetadataServices.CreateObjectInfo(options, jsonObjectInfoValues);
		jsonTypeInfo.NumberHandling = null;
		return jsonTypeInfo;
	}
}

```

`Source/AssetRipper.GUI.Web/Documentation/SortDocumentPathsTransformer.cs`:

```cs
using Microsoft.AspNetCore.OpenApi;
using Microsoft.OpenApi;

namespace AssetRipper.GUI.Web.Documentation;

internal class SortDocumentPathsTransformer : IOpenApiDocumentTransformer
{
	public Task TransformAsync(OpenApiDocument document, OpenApiDocumentTransformerContext context, CancellationToken cancellationToken)
	{
		OpenApiPaths newPaths = new();
		newPaths.Extensions = document.Paths.Extensions;
		foreach ((string key, IOpenApiPathItem value) in document.Paths.OrderBy(pair => pair.Key))
		{
			newPaths.Add(key, value);
		}
		document.Paths = newPaths;
		return Task.CompletedTask;
	}
}

```

`Source/AssetRipper.GUI.Web/ErrorHandlingMiddleware.cs`:

```cs
using AssetRipper.Import.Logging;
using Microsoft.AspNetCore.Http;

namespace AssetRipper.GUI.Web;

internal sealed class ErrorHandlingMiddleware : IMiddleware
{
	public async Task InvokeAsync(HttpContext context, RequestDelegate next)
	{
		try
		{
			await next(context);
		}
		catch (Exception ex)
		{
			Logger.Error(ex);

			context.Response.Redirect("/"); // Redirect to the main page since we don't have an error page.
		}
	}
}

```

`Source/AssetRipper.GUI.Web/GameFileLoader.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Export.Configuration;
using AssetRipper.Export.PrimaryContent;
using AssetRipper.Export.UnityProjects;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.IO.Files;
using AssetRipper.NativeDialogs;
using AssetRipper.Processing;

namespace AssetRipper.GUI.Web;

public static class GameFileLoader
{
	private static GameData? GameData { get; set; }
	[MemberNotNullWhen(true, nameof(GameData))]
	public static bool IsLoaded => GameData is not null;
	public static GameBundle GameBundle => GameData!.GameBundle;
	public static IAssemblyManager AssemblyManager => GameData!.AssemblyManager;
	public static FullConfiguration Settings { get; } = LoadSettings();
	public static bool Headless { get; set; }

	public static ExportHandler ExportHandler
	{
		private get;
		set
		{
			ArgumentNullException.ThrowIfNull(value);
			value.ThrowIfSettingsDontMatch(Settings);
			field = value;
		}
	} = new(Settings);

	/// <summary>
	/// Is this the premium edition?
	/// </summary>
	/// <remarks>
	/// This is purely for UI functionality and has no direct effect on the presense of features.
	/// </remarks>
	public static bool Premium => ExportHandler.GetType() != typeof(ExportHandler);

	public static void Reset()
	{
		if (GameData is not null)
		{
			GameData = null;
			Logger.Info(LogCategory.General, "Data was reset.");
		}
	}

	public static void LoadAndProcess(IReadOnlyList<string> paths)
	{
		Reset();
		Settings.LogConfigurationValues();
		GameData = ExportHandler.LoadAndProcess(paths, LocalFileSystem.Instance);
	}

	public static async Task ExportUnityProject(string path)
	{
		if (IsLoaded && IsValidExportDirectory(path))
		{
			if (IsNonEmptyDirectory(path))
			{
				if (!await UserConsentsToDeletion())
				{
					Logger.Info(LogCategory.Export, "User declined to delete existing export directory. Aborting export.");
					return;
				}
				Directory.Delete(path, true);
			}

			Directory.CreateDirectory(path);
			ExportHandler.Export(GameData, path, LocalFileSystem.Instance);
		}
	}

	public static async Task ExportPrimaryContent(string path)
	{
		if (IsLoaded && IsValidExportDirectory(path))
		{
			if (IsNonEmptyDirectory(path))
			{
				if (!await UserConsentsToDeletion())
				{
					Logger.Info(LogCategory.Export, "User declined to delete existing export directory. Aborting export.");
					return;
				}
				Directory.Delete(path, true);
			}

			Directory.CreateDirectory(path);
			Logger.Info(LogCategory.Export, "Starting primary content export");
			Logger.Info(LogCategory.Export, $"Attempting to export assets to {path}...");
			Settings.ExportRootPath = path;
			PrimaryContentExporter.CreateDefault(GameData, Settings).Export(GameBundle, Settings, LocalFileSystem.Instance);
			Logger.Info(LogCategory.Export, "Finished exporting primary content.");
		}
	}

	private static FullConfiguration LoadSettings()
	{
		FullConfiguration settings = new();
		settings.LoadFromDefaultPath();
		return settings;
	}

	private static bool IsValidExportDirectory(string path)
	{
		if (string.IsNullOrEmpty(path))
		{
			Logger.Error(LogCategory.Export, "Export path is empty");
			return false;
		}
		string directoryName = Path.GetFileName(path);
		if (directoryName is "Desktop" or "Documents" or "Downloads")
		{
			Logger.Error(LogCategory.Export, $"Export path '{path}' is a system directory");
			return false;
		}
		return true;
	}

	private static bool IsNonEmptyDirectory(string path)
	{
		return Directory.Exists(path) && Directory.EnumerateFileSystemEntries(path).Any();
	}

	private static async Task<bool> UserConsentsToDeletion()
	{
		if (Headless)
		{
			return true;
		}
		ConfirmationDialog.Options options = new()
		{
			Message = Localization.ExportDirectoryDeleteUserConfirmation,
			Type = ConfirmationDialog.Type.YesNo,
		};
		bool? result = await ConfirmationDialog.Confirm(options);
		return result ?? false;
	}
}

```

`Source/AssetRipper.GUI.Web/HttpClientBuilder.cs`:

```cs
using System.Net.Http;
using static AssetRipper.Import.AssetRipperRuntimeInformation;

namespace AssetRipper.GUI.Web;

internal static class HttpClientBuilder
{
	internal static HttpClient CreateHttpClient()
	{
		string productName = GameFileLoader.Premium ? "AssetRipper.GUI.Premium" : "AssetRipper.GUI.Free";

		HttpClient client = new();
		client.DefaultRequestHeaders.UserAgent.Add(new(productName, Build.Version));
		client.DefaultRequestHeaders.UserAgent.Add(new($"({Build.Configuration}; {ProcessArchitecture}; {Build.Type})"));
		client.DefaultRequestHeaders.UserAgent.Add(new($"({OS.Name}; {OS.Version}; {RamQuantity})"));
		client.DefaultRequestHeaders.UserAgent.Add(new($"({CompileTime})"));
		return client;
	}
}

```

`Source/AssetRipper.GUI.Web/OnlineDependencies.cs`:

```cs
using AssetRipper.GUI.Web.Dependencies;
using AssetRipper.Import;
using Microsoft.AspNetCore.Routing;

namespace AssetRipper.GUI.Web;

/// <summary>
/// Contains references to online dependencies.
/// </summary>
internal static partial class OnlineDependencies
{
	private static IReadOnlyList<EmbeddedDependency> GetDependencies()
	{
		if (AssetRipperRuntimeInformation.Build.Debug)
		{
			return EmbeddedDependency.GetAllDevelopment();
		}
		else
		{
			return EmbeddedDependency.GetAllProduction();
		}
	}

	public static void MapDependencies(IEndpointRouteBuilder endpoints)
	{
		foreach (EmbeddedDependency dependency in GetDependencies())
		{
			StaticContentLoader.Add(dependency.Path, dependency.Content);
			endpoints.MapStaticFile(dependency.Path, dependency.MimeType);
		}
	}

	// Dependencies are ordered alphabetically in this class.

	/// <summary>
	/// <see href="https://www.babylonjs.com/"/>
	/// </summary>
	internal static partial class Babylon
	{
		public const string PathMain = "/js/babylon.js";
		public const string PathLoader = "/js/babylonjs.loaders.min.js";

		internal static void WriteScriptReference(TextWriter writer)
		{
			new Script(writer).WithSrc(PathMain).Close();
			new Script(writer).WithSrc(PathLoader).Close();
		}
	}

	/// <summary>
	/// <see href="https://getbootstrap.com/"/>
	/// </summary>
	internal static class Bootstrap
	{
		public const string PathMain = "/css/bootstrap.min.css";

		internal static void WriteStyleSheetReference(TextWriter writer)
		{
			new Link(writer).WithRel("stylesheet").WithHref(PathMain).Close();
		}

		public const string PathBundle = "/js/bootstrap.bundle.min.js";

		internal static void WriteScriptReference(TextWriter writer)
		{
			new Script(writer).WithSrc(PathBundle).Close();
		}
	}

	/// <summary>
	/// <see href="https://jquery.com/"/>
	/// </summary>
	internal static class Popper
	{
		public const string Path = "/js/popper.min.js";

		internal static void WriteScriptReference(TextWriter writer)
		{
			new Script(writer).WithSrc(Path).Close();
		}
	}

	/// <summary>
	/// <see href="https://vuejs.org/"/>
	/// </summary>
	internal static class Vue
	{
		public const string Path = "/js/vue.js";

		internal static void WriteScriptReference(TextWriter writer)
		{
			new Script(writer).WithSrc(Path).Close();
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Accordian.cs`:

```cs
namespace AssetRipper.GUI.Web.Pages;

internal static class Accordian
{
	public static void Write(TextWriter writer, ReadOnlySpan<AccordianItem> items, Guid parentId = default)
	{
		string parentIdString = (parentId == default ? Guid.NewGuid() : parentId).ToString();

		using (new Div(writer).WithClass("accordion").WithId(parentIdString).End())
		{
			for (int i = 0; i < items.Length; i++)
			{
				AccordianItem item = items[i];
				using (new Div(writer).WithClass("accordion-item").End())
				{
					using (new H2(writer).WithClass("accordion-header").End())
					{
						new Button(writer).WithClass("accordion-button collapsed")
							.WithType("button")
							.WithCustomAttribute("data-bs-toggle", "collapse")
							.WithCustomAttribute("data-bs-target", $"#collapse-{parentIdString}-{i}")
							.WithCustomAttribute("aria-expanded", "false")
							.WithCustomAttribute("aria-controls", $"collapse-{parentIdString}-{i}")
							.Close(item.Name ?? (i + 1).ToString());
					}
					using (new Div(writer).WithId($"collapse-{parentIdString}-{i}")
						.WithClass("accordion-collapse collapse")
						.WithCustomAttribute("data-bs-parent", $"#{parentIdString}")
						.End())
					{
						using (new Div(writer).WithClass("accordion-body").End())
						{
							item.Write(writer);
						}
					}
				}
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/AccordianItem.cs`:

```cs
namespace AssetRipper.GUI.Web.Pages;

internal abstract class AccordianItem
{
	public virtual string? Name => null;
	public abstract void Write(TextWriter writer);
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/AssetAPI.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.Configuration;
using AssetRipper.Export.Modules.Audio;
using AssetRipper.Export.Modules.Models;
using AssetRipper.Export.Modules.Textures;
using AssetRipper.Export.PrimaryContent;
using AssetRipper.Export.UnityProjects;
using AssetRipper.Export.UnityProjects.Scripts;
using AssetRipper.Export.UnityProjects.Shaders;
using AssetRipper.GUI.Web.Documentation;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.Import.AssetCreation;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.Processing.Textures;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Classes.ClassID_128;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using AssetRipper.SourceGenerated.Classes.ClassID_189;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_329;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.Web.Extensions;
using AssetRipper.Yaml;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using SharpGLTF.Scenes;
using System.Globalization;
using System.Runtime.InteropServices;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal static class AssetAPI
{
	public static class Urls
	{
		public const string Base = "/Assets";
		public const string View = Base + "/View";
		public const string Image = Base + "/Image";
		public const string Audio = Base + "/Audio";
		public const string Model = Base + "/Model.glb";
		public const string Font = Base + "/Font";
		public const string Video = Base + "/Video";
		public const string Json = Base + "/Json";
		public const string Yaml = Base + "/Yaml";
		public const string Text = Base + "/Text";
		public const string Binary = Base + "/Binary";
	}
	private const string Extension = "Extension";
	private const string Path = "Path";

	#region View
	public static string GetViewUrl(AssetPath path) => $"{Urls.View}?{GetPathQuery(path)}";
	public static Task GetView(HttpContext context)
	{
		context.Response.DisableCaching();
		if (TryGetAssetFromQuery(context, out IUnityObjectBase? asset, out AssetPath path, out Task? failureTask))
		{
			return new ViewPage() { Asset = asset, Path = path }.WriteToResponse(context.Response);
		}
		else
		{
			return failureTask;
		}
	}
	#endregion

	#region Image
	public static string GetImageUrl(AssetPath path, string? extension = null)
	{
		return $"{Urls.Image}?{GetPathQuery(path)}{GetExtensionQuerySuffix(extension)}";
	}

	public static Task GetImageData(HttpContext context)
	{
		context.Response.DisableCaching();
		if (!TryGetAssetFromQuery(context, out IUnityObjectBase? asset, out Task? failureTask))
		{
			return failureTask;
		}

		if (TryGetImageExtensionFromQuery(context, out string? extension, out ImageExportFormat format))
		{
			DirectBitmap bitmap = GetImageBitmap(asset);
			if (bitmap.IsEmpty)
			{
				return context.Response.NotFound("Image data could not be decoded.");
			}

			MemoryStream stream = new();
			bitmap.Save(stream, format);
			return Results.Bytes(stream.ToArray(), $"image/{extension}").ExecuteAsync(context);
		}
		else
		{
			return Results.Bytes(GetRawImageData(asset), "application/octet-stream").ExecuteAsync(context);
		}
	}

	public static bool HasImageData(IUnityObjectBase asset) => asset switch
	{
		IImageTexture texture => texture.CheckAssetIntegrity(),
		SpriteInformationObject spriteInformationObject => spriteInformationObject.Texture.CheckAssetIntegrity(),
		ISprite sprite => SpriteConverter.Supported(sprite),
		ITerrainData terrainData => terrainData.Heightmap.Heights.Count > 0,
		_ => false,
	};

	private static DirectBitmap GetImageBitmap(IUnityObjectBase asset)
	{
		return asset switch
		{
			IImageTexture texture => TextureToBitmap(texture),
			SpriteInformationObject spriteInformationObject => TextureToBitmap(spriteInformationObject.Texture),
			ISprite sprite => SpriteToBitmap(sprite),
			ITerrainData terrainData => TerrainHeatmap.GetBitmap(terrainData),
			_ => DirectBitmap.Empty,
		};

		static DirectBitmap TextureToBitmap(IImageTexture texture)
		{
			return TextureConverter.TryConvertToBitmap(texture, out DirectBitmap bitmap) ? bitmap : DirectBitmap.Empty;
		}

		static DirectBitmap SpriteToBitmap(ISprite sprite)
		{
			return SpriteConverter.TryConvertToBitmap(sprite, out DirectBitmap bitmap) ? bitmap : DirectBitmap.Empty;
		}
	}

	private static byte[] GetRawImageData(IUnityObjectBase asset)
	{
		return asset switch
		{
			ITexture2D texture => texture.GetImageData(),
			SpriteInformationObject spriteInformationObject => spriteInformationObject.Texture.GetImageData(),
			ISprite sprite => sprite.TryGetTexture()?.GetImageData() ?? [],
			ITerrainData terrainData => MemoryMarshal.AsBytes(terrainData.Heightmap.Heights.GetSpan()).ToArray(),
			_ => [],
		};
	}

	private static bool TryGetImageExtensionFromQuery(HttpContext context, [NotNullWhen(true)] out string? extension, out ImageExportFormat format)
	{
		if (context.Request.Query.TryGetValue(Extension, out extension))
		{
			return ImageExportFormatExtensions.TryGetFromExtension(extension, out format);
		}
		else
		{
			format = default;
			return false;
		}
	}
	#endregion

	#region Audio
	public static string GetAudioUrl(AssetPath path, string? extension = null)
	{
		return $"{Urls.Audio}?{GetPathQuery(path)}{GetExtensionQuerySuffix(extension)}";
	}

	public static Task GetAudioData(HttpContext context)
	{
		context.Response.DisableCaching();
		if (!TryGetAssetFromQuery(context, out IUnityObjectBase? asset, out Task? failureTask))
		{
			return failureTask;
		}

		if (asset is not IAudioClip clip)
		{
			return context.Response.NotFound("Asset was not an audio clip.");
		}
		else if (AudioClipDecoder.TryDecode(clip, out byte[]? decodedAudioData, out string? extension, out _))
		{
			if (context.Request.Query.TryGetValue(Extension, out string? desiredExtension))
			{
				if (extension is "ogg" && desiredExtension is "wav")
				{
					byte[] wavData = AudioConverter.OggToWav(decodedAudioData);
					if (wavData.Length > 0)
					{
						decodedAudioData = wavData;
						extension = "wav";
					}
				}
			}

			return Results.Bytes(decodedAudioData, $"audio/{extension}").ExecuteAsync(context);
		}
		else
		{
			return context.Response.NotFound("Audio data could not be decoded.");
		}
	}

	public static bool HasAudioData(IUnityObjectBase asset)
	{
		return asset is IAudioClip;
	}
	#endregion

	#region Model
	public static string GetModelUrl(AssetPath path)
	{
		return $"{Urls.Model}?{GetPathQuery(path)}";
	}

	public static Task GetModelData(HttpContext context)
	{
		context.Response.DisableCaching();
		if (!TryGetAssetFromQuery(context, out IUnityObjectBase? asset, out Task? failureTask))
		{
			return failureTask;
		}

		if (asset is not IMesh mesh)
		{
			return context.Response.NotFound("Asset was not a mesh.");
		}
		else
		{
			MemoryStream stream = new();
			SceneBuilder sceneBuilder;
			try
			{
				sceneBuilder = GlbMeshBuilder.Build(mesh);
			}
			catch (Exception ex)
			{
				Logger.Error(ex);
				return context.Response.NotFound("Model data could not be decoded.");
			}

			if (GlbWriter.TryWrite(sceneBuilder, stream, out string? errorMessage))
			{
				return Results.Bytes(stream.ToArray(), "model/gltf-binary", "model.glb").ExecuteAsync(context);
			}
			else
			{
				Logger.Error(errorMessage);
				return context.Response.NotFound("Model data could not be decoded.");
			}
		}
	}

	public static bool HasModelData(IUnityObjectBase asset)
	{
		return asset is IMesh;
	}
	#endregion

	#region Font
	public static string GetFontUrl(AssetPath path)
	{
		return $"{Urls.Font}?{GetPathQuery(path)}";
	}

	public static Task GetFontData(HttpContext context)
	{
		//Only accept Path in the query.
		context.Response.DisableCaching();
		if (!TryGetAssetFromQuery(context, out IUnityObjectBase? asset, out Task? failureTask))
		{
			return failureTask;
		}

		if (asset is not IFont font)
		{
			return context.Response.NotFound("Asset was not a font.");
		}
		else if (TryGetFontData(font, out byte[] data, out string? extension, out string? mimeType))
		{
			return Results.Bytes(data, mimeType, $"{font.GetBestName()}.{extension}").ExecuteAsync(context);
		}
		else
		{
			return context.Response.NotFound("Font data could not be decoded.");
		}
	}

	public static bool HasFontData(IUnityObjectBase asset)
	{
		return asset is IFont font && TryGetFontData(font, out _, out _, out _);
	}

	private static bool TryGetFontData(IFont font, out byte[] data, [NotNullWhen(true)] out string? extension, [NotNullWhen(true)] out string? mimeType)
	{
		data = font.FontData;

		if (data is { Length: >= 4 })
		{
			(extension, mimeType) = (data[0], data[1], data[2], data[3]) switch
			{
				(0x4F, 0x54, 0x54, 0x4F) => ("otf", "font/otf"),
				(0x00, 0x01, 0x00, 0x00) => ("ttf", "font/ttf"),
				(0x74, 0x74, 0x63, 0x66) => ("ttc", "font/collection"),
				_ => ("dat", "application/octet-stream"),
			};

			return true;
		}
		else
		{
			extension = null;
			mimeType = null;

			return false;
		}
	}
	#endregion

	#region Video
	public static string GetVideoUrl(AssetPath path)
	{
		return $"{Urls.Video}?{GetPathQuery(path)}";
	}

	public static Task GetVideoData(HttpContext context)
	{
		//Only accept Path in the query.
		context.Response.DisableCaching();
		if (!TryGetAssetFromQuery(context, out IUnityObjectBase? asset, out Task? failureTask))
		{
			return failureTask;
		}

		if (asset is not IVideoClip videoClip)
		{
			return context.Response.NotFound("Asset was not a video clip.");
		}
		else if (videoClip.TryGetExtensionFromPath(out string? extension) && videoClip.TryGetContent(out byte[]? content))
		{
			return Results.Bytes(content, $"video/{extension}", $"{videoClip.GetBestName()}.{extension}").ExecuteAsync(context);
		}
		else
		{
			return context.Response.NotFound("Video data could not be decoded.");
		}
	}

	public static bool HasVideoData(IUnityObjectBase asset)
	{
		return asset is IVideoClip clip && clip.CheckIntegrity();
	}
	#endregion

	#region Json
	public static string GetJsonUrl(AssetPath path)
	{
		return $"{Urls.Json}?{GetPathQuery(path)}";
	}
	public static Task GetJson(HttpContext context)
	{
		context.Response.DisableCaching();
		if (!TryGetAssetFromQuery(context, out IUnityObjectBase? asset, out Task? failureTask))
		{
			return failureTask;
		}

		try
		{
			string text = new DefaultJsonWalker().SerializeStandard(asset);
			return Results.Text(text, "application/json").ExecuteAsync(context);
		}
		catch (Exception ex)
		{
			return Results.Text(ex.ToString()).ExecuteAsync(context);
		}
	}
	#endregion

	#region Yaml
	public static string GetYamlUrl(AssetPath path)
	{
		return $"{Urls.Yaml}?{GetPathQuery(path)}";
	}
	public static Task GetYaml(HttpContext context)
	{
		context.Response.DisableCaching();
		if (!TryGetAssetFromQuery(context, out IUnityObjectBase? asset, out Task? failureTask))
		{
			return failureTask;
		}

		try
		{
			string text;
			using (StringWriter stringWriter = new(CultureInfo.InvariantCulture) { NewLine = "\n" })
			{
				YamlWriter writer = new();
				writer.WriteHead(stringWriter);
				YamlDocument document = new YamlWalker().ExportYamlDocument(asset, ExportIdHandler.GetMainExportID(asset));
				writer.WriteDocument(document);
				writer.WriteTail(stringWriter);
				text = stringWriter.ToString();
			}
			return Results.Text(text, "application/yaml").ExecuteAsync(context);
		}
		catch (Exception ex)
		{
			return Results.Text(ex.ToString()).ExecuteAsync(context);
		}
	}
	#endregion

	#region Text
	public static string GetTextUrl(AssetPath path)
	{
		return $"{Urls.Text}?{GetPathQuery(path)}";
	}

	public static Task GetText(HttpContext context)
	{
		//Only accept Path in the query. It sensibly determines the file extension.
		context.Response.DisableCaching();
		if (!TryGetAssetFromQuery(context, out IUnityObjectBase? asset, out Task? failureTask))
		{
			return failureTask;
		}

		return Results.Text(TryGetText(asset), "text/plain").ExecuteAsync(context);
	}

	public static bool HasText(IUnityObjectBase asset)
	{
		return asset is IShader or IMonoScript or ITextAsset { Script_C49.IsEmpty: false };
	}

	public static string TryGetText(IUnityObjectBase asset)
	{
		return asset switch
		{
			IShader shader => DumpShaderDataAsText(shader),
			IMonoScript monoScript => DecompileMonoScript(monoScript),
			ITextAsset textAsset => textAsset.Script_C49,
			_ => "",
		};
	}

	public static string GetTextFileName(IUnityObjectBase asset)
	{
		return asset switch
		{
			IShader => $"{asset.GetBestName()}.shader",
			IMonoScript monoScript => $"{monoScript.ClassName_R}.cs",
			ITextAsset textAsset => $"{asset.GetBestName()}.{GetTextAssetExtension(textAsset)}",
			_ => $"{asset.GetBestName()}.txt",
		};

		static string GetTextAssetExtension(ITextAsset textAsset)
		{
			return textAsset.GetBestExtension() ?? "txt";
		}
	}

	private static string DumpShaderDataAsText(IShader shader)
	{
		InvariantStringWriter writer = new();
		DummyShaderTextExporter.ExportShader(shader, writer);
		return writer.ToString();
	}

	private static string DecompileMonoScript(IMonoScript monoScript)
	{
		IAssemblyManager assemblyManager = GameFileLoader.AssemblyManager;
		if (!monoScript.IsScriptPresents(assemblyManager))
		{
			return EmptyScript.GetContent(monoScript);
		}
		else
		{
			try
			{
				_ = monoScript.GetTypeDefinition(assemblyManager);
				return EmptyScript.GetContent(monoScript); // Todo: replace with ILSpy
			}
			catch (Exception ex)
			{
				return $"{Localization.AnErrorOccuredDuringDecompilation}\n\n{ex}";
			}
		}
	}
	#endregion

	#region Binary Data
	public static string GetBinaryUrl(AssetPath path)
	{
		return $"{Urls.Binary}?{GetPathQuery(path)}";
	}

	public static Task GetBinaryData(HttpContext context)
	{
		//Only for RawDataObject. This should not call any of the IUnityAssetBase Write methods.
		context.Response.DisableCaching();
		if (!TryGetAssetFromQuery(context, out IUnityObjectBase? asset, out Task? failureTask))
		{
			return failureTask;
		}

		byte[] data = (asset as RawDataObject)?.RawData ?? [];
		return Results.Bytes(data, "application/octet-stream").ExecuteAsync(context);
	}

	public static bool HasBinaryData(IUnityObjectBase asset)
	{
		return asset is RawDataObject { RawData.Length: > 0 };
	}
	#endregion

	private static string GetPathQuery(AssetPath path) => $"{Path}={path.ToJson().ToUrl()}";

	private static string? GetExtensionQuerySuffix(string? extension) => string.IsNullOrEmpty(extension) ? null : $"&{Extension}={extension}";

	private static bool TryGetAssetFromQuery(HttpContext context, [NotNullWhen(true)] out IUnityObjectBase? asset, [NotNullWhen(false)] out Task? failureTask)
	{
		return TryGetAssetFromQuery(context, out asset, out _, out failureTask);
	}

	private static bool TryGetAssetFromQuery(HttpContext context, [NotNullWhen(true)] out IUnityObjectBase? asset, out AssetPath path, [NotNullWhen(false)] out Task? failureTask)
	{
		if (!context.Request.Query.TryGetValue(Path, out string? json) || string.IsNullOrEmpty(json))
		{
			asset = null;
			path = default;
			failureTask = context.Response.NotFound("The path must be included in the request.");
			return false;
		}

		try
		{
			path = AssetPath.FromJson(json);
		}
		catch (Exception ex)
		{
			asset = null;
			path = default;
			failureTask = context.Response.NotFound(ex.ToString());
			return false;
		}

		if (!GameFileLoader.IsLoaded)
		{
			asset = null;
			failureTask = context.Response.NotFound("No files loaded.");
			return false;
		}
		else if (!GameFileLoader.GameBundle.TryGetAsset(path, out asset))
		{
			failureTask = context.Response.NotFound($"Asset could not be resolved: {path}");
			return false;
		}
		else
		{
			failureTask = null;
			return true;
		}
	}

	public static RouteHandlerBuilder WithAssetPathParameter(this RouteHandlerBuilder builder)
	{
		return builder.WithQueryStringParameter(Path, "Path to the asset", true);
	}

	public static RouteHandlerBuilder WithImageExtensionParameter(this RouteHandlerBuilder builder)
	{
		return builder.WithQueryStringParameter(Extension, "Extension for decoding the image.", true);
	}

	private sealed class InvariantStringWriter : StringWriter
	{
		public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/AssetHtmlTab.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal abstract class AssetHtmlTab(IUnityObjectBase asset) : HtmlTab
{
	public IUnityObjectBase Asset { get; } = asset;
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/AudioTab.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal sealed class AudioTab : AssetHtmlTab
{
	public string PlaybackSource { get; }
	public string SaveSource { get; }

	public override string DisplayName => Localization.AssetTabAudio;

	public override string HtmlName => "audio";

	public override bool Enabled => AssetAPI.HasAudioData(Asset);

	public AudioTab(IUnityObjectBase asset, AssetPath path) : base(asset)
	{
		PlaybackSource = AssetAPI.GetAudioUrl(path, "wav");
		SaveSource = AssetAPI.GetAudioUrl(path);
	}

	public override void Write(TextWriter writer)
	{
		using (new Table(writer).WithCustomAttribute("width", "100%").WithCustomAttribute("height", "100%").End())
		{
			using (new Tbody(writer).End())
			{
				using (new Tr(writer).End())
				{
					using (new Td(writer).WithAlign("center").WithCustomAttribute("valign", "middle").End())
					{
						new Audio(writer).WithControls("").WithPreload("auto").WithClass("mt-4").WithSrc(PlaybackSource).Close();
					}
				}
				using (new Tr(writer).End())
				{
					using (new Td(writer).WithAlign("center").WithCustomAttribute("valign", "middle").End())
					{
						SaveButton.Write(writer, SaveSource, Asset.GetBestName());
					}
				}
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/DependenciesTab.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal sealed class DependenciesTab(IUnityObjectBase asset) : AssetHtmlTab(asset)
{
	public override string DisplayName => Localization.AssetTabDependencies;
	public override string HtmlName => "dependencies";
	public override bool Enabled => Asset.FetchDependencies().Any(pair => !pair.Item2.IsNull);

	public override void Write(TextWriter writer)
	{
		using (new Table(writer).WithClass("table").End())
		{
			using (new Tbody(writer).End())
			{
				foreach ((string path, PPtr pptr) in Asset.FetchDependencies())
				{
					if (pptr.IsNull)
					{
						continue;
					}

					using (new Tr(writer).End())
					{
						new Th(writer).Close(path);
						using (new Td(writer).End())
						{
							IUnityObjectBase? dependency = Asset.Collection.TryGetAsset(pptr);
							if (dependency is null)
							{
								writer.WriteHtml("Missing");
							}
							else
							{
								PathLinking.WriteLink(writer, dependency);
							}
						}
					}
				}
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/DevelopmentTab.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal sealed class DevelopmentTab(IUnityObjectBase asset) : AssetHtmlTab(asset)
{
	public override string DisplayName => Localization.AssetTabDevelopment;

	public override string HtmlName => "development";

	public override void Write(TextWriter writer)
	{
		using (new Table(writer).WithClass("table").End())
		{
			using (new Tbody(writer).End())
			{
				using (new Tr(writer).End())
				{
					new Th(writer).Close(Localization.CsharpType);
					new Td(writer).Close(Asset.GetType().Name);
				}
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/FontTab.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal sealed class FontTab : AssetHtmlTab
{
	public string Url { get; }

	public override string DisplayName => Localization.AssetTabFont;

	public override string HtmlName => "font";

	public override bool Enabled => AssetAPI.HasFontData(Asset);

	public FontTab(IUnityObjectBase asset, AssetPath path) : base(asset)
	{
		Url = AssetAPI.GetFontUrl(path);
	}

	public override void Write(TextWriter writer)
	{
		using (new Div(writer).WithClass("text-center").End())
		{
			new H1(writer).WithStyle($"font-family: {Asset.GetBestName()}").Close("Preview Font (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)");

			SaveButton.Write(writer, Url);

			new Script(writer).Close(
				$$"""
				  const fontFace = new FontFace(`{{Asset.GetBestName()}}`, `url({{Url}})`);
				  document.fonts.add(fontFace);
				  fontFace.load().then().catch(function(error) {
				    console.error(`Font loading failed: ${error}`);
				  });
				  """);
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/HexTab.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal sealed class HexTab : AssetHtmlTab
{
	public string Url { get; }

	public string FileName => $"{Asset.GetBestName()}.dat";

	public override string DisplayName => Localization.AssetTabHex;

	public override string HtmlName => "hex";

	public override bool Enabled => AssetAPI.HasBinaryData(Asset);

	public HexTab(IUnityObjectBase asset, AssetPath path) : base(asset)
	{
		Url = Enabled ? AssetAPI.GetBinaryUrl(path) : "";
	}

	public override void Write(TextWriter writer)
	{
		using (new Div(writer).WithClass("text-center").End())
		{
			SaveButton.Write(writer, Url, FileName);
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/ImageTab.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.IO.Files;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal sealed class ImageTab : AssetHtmlTab
{
	public AssetPath Path { get; }

	public override string DisplayName => Localization.AssetTabImage;

	public override string HtmlName => "image";

	public override bool Enabled => AssetAPI.HasImageData(Asset);

	public ImageTab(IUnityObjectBase asset, AssetPath path) : base(asset)
	{
		Path = path;
	}

	public override void Write(TextWriter writer)
	{
		string pngUrl = AssetAPI.GetImageUrl(Path, "png");
		string rawUrl = AssetAPI.GetImageUrl(Path);
		string fileName = FileSystem.FixInvalidFileNameCharacters(Asset.GetBestName());

		// Click on image to save
		using (new A(writer).WithHref(pngUrl).WithDownload(fileName).End())
		{
			new Img(writer).WithSrc(pngUrl).WithStyle("object-fit:contain; width:100%; height:100%").Close();
		}

		// Click a button beneath the image to download its raw data
		using (new Div(writer).WithTextCenter().End())
		{
			SaveButton.Write(writer, rawUrl, fileName, Localization.SaveRawData);
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/InformationTab.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.Processing.Prefabs;
using AssetRipper.Processing.Textures;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_33;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_82;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal sealed class InformationTab(IUnityObjectBase asset, AssetPath path) : AssetHtmlTab(asset)
{
	public override string DisplayName => Localization.AssetTabInformation;
	public override string HtmlName => "information";

	public override void Write(TextWriter writer)
	{
		using (new Table(writer).WithClass("table").End())
		{
			using (new Tbody(writer).End())
			{
				if (Asset.MainAsset is SceneHierarchyObject sceneHierarchyObject)
				{
					using (new Tr(writer).End())
					{
						new Th(writer).Close(Localization.Scene);
						using (new Td(writer).End())
						{
							PathLinking.WriteLink(writer, (ScenePath)sceneHierarchyObject.Scene.Collections[0].GetPath(), sceneHierarchyObject.Scene.Name);
						}
					}
				}
				using (new Tr(writer).End())
				{
					new Th(writer).Close(Localization.Collection);
					using (new Td(writer).End())
					{
						PathLinking.WriteLink(writer, path.CollectionPath, Asset.Collection.Name);
					}
				}
				using (new Tr(writer).End())
				{
					new Th(writer).Close(Localization.PathId);
					new Td(writer).Close(Asset.PathID.ToString());
				}
				using (new Tr(writer).End())
				{
					new Th(writer).Close(Localization.ClassIdTypeNumber);
					new Td(writer).Close(Asset.ClassID.ToString());
				}
				using (new Tr(writer).End())
				{
					new Th(writer).Close(Localization.ClassIdTypeName);
					new Td(writer).Close(Asset.ClassName);
				}
				if (Asset.OriginalPath is not null)
				{
					using (new Tr(writer).End())
					{
						new Th(writer).Close(Localization.OriginalPath);
						new Td(writer).Close(Asset.OriginalPath);
					}
				}
				if (Asset.OverridePath is not null)
				{
					using (new Tr(writer).End())
					{
						new Th(writer).Close(Localization.OverridePath);
						new Td(writer).Close(Asset.OverridePath);
					}
				}
				if (!string.IsNullOrEmpty(Asset.AssetBundleName))
				{
					using (new Tr(writer).End())
					{
						new Th(writer).Close(Localization.AssetBundleName);
						new Td(writer).Close(Asset.AssetBundleName);
					}
				}
				foreach ((string key, IUnityObjectBase value) in GetCustomReferenceProperties(Asset))
				{
					using (new Tr(writer).End())
					{
						new Th(writer).Close(key);
						using (new Td(writer).End())
						{
							PathLinking.WriteLink(writer, value);
						}
					}
				}
				foreach ((string key, string value) in GetCustomStringProperties(Asset))
				{
					using (new Tr(writer).End())
					{
						new Th(writer).Close(key);
						new Td(writer).Close(value);
					}
				}
			}
		}
	}

	private static IEnumerable<(string, IUnityObjectBase)> GetCustomReferenceProperties(IUnityObjectBase asset)
	{
		if (asset.MainAsset is not null && asset.MainAsset != asset)
		{
			yield return (Localization.MainAsset, asset.MainAsset);
		}
		switch (asset)
		{
			case IComponent component:
				{
					if (component.GameObject_C2P is { } gameObject)
					{
						yield return (Localization.GameObject, gameObject);
						if (component is IRenderer && gameObject.TryGetComponent<IMeshFilter>()?.MeshP is { } rendererMesh)
						{
							yield return (Localization.Mesh, rendererMesh);
						}
					}
					if (component is IMonoBehaviour monoBehaviour && monoBehaviour.ScriptP is { } monoScript)
					{
						yield return (Localization.Script, monoScript);
					}
					else if (component is IMeshFilter meshFilter && meshFilter.MeshP is { } mesh)
					{
						yield return (Localization.Mesh, mesh);
					}
					else if (component is IAudioSource audioSource && audioSource.AudioClipP is { } audioSourceClip)
					{
						yield return (Localization.AudioClip, audioSourceClip);
					}
				}
				break;
			case IGameObject gameObject:
				{
					if (gameObject.TryGetComponent(out ITransform? transform))
					{
						yield return (Localization.Transform, transform);
					}
				}
				break;
			case IMaterial material:
				{
					if (material.Shader_C21P is { } shader)
					{
						yield return (Localization.Shader, shader);
					}
				}
				break;
			case SpriteInformationObject spriteInformationObject:
				{
					yield return (Localization.Texture, spriteInformationObject.Texture);
				}
				break;
			default:
				break;
		}
	}

	private static IEnumerable<(string, string)> GetCustomStringProperties(IUnityObjectBase asset)
	{
		switch (asset)
		{
			case IMonoScript monoScript:
				{
					return GetProperties(monoScript);
				}
			case IMonoBehaviour monoBehaviour:
				{
					if (monoBehaviour.ScriptP is { } monoScript)
					{
						return GetProperties(monoScript);
					}
					else
					{
						goto default;
					}
				}
			case ITexture2D texture2D:
				{
					return
					[
						(Localization.Width, texture2D.Width_C28.ToString()),
						(Localization.Height, texture2D.Height_C28.ToString()),
						(Localization.Format, texture2D.Format_C28E.ToString()),
					];
				}
			case IMesh mesh:
				{
					return
					[
						(Localization.VertexCount, mesh.VertexData.VertexCount.ToString()),
						(Localization.SubmeshCount, mesh.SubMeshes.Count.ToString()),
					];
				}
			case IAudioClip audioClip:
				{
					return
					[
						(Localization.Channels, audioClip.Channels.ToString()),
						(Localization.Frequency, audioClip.Frequency.ToString()),
						(Localization.Length, audioClip.Length.ToString()),
					];
				}
			case ITerrainData terrainData:
				{
					return
					[
						(Localization.Width, terrainData.Heightmap.GetWidth().ToString()),
						(Localization.Height, terrainData.Heightmap.GetHeight().ToString()),
					];
				}
			default:
				return Enumerable.Empty<(string, string)>();
		}

		static IEnumerable<(string, string)> GetProperties(IMonoScript monoScript)
		{
			return
			[
				(Localization.AssemblyName, monoScript.AssemblyName),
				(Localization.Namespace, monoScript.Namespace),
				(Localization.ClassName, monoScript.ClassName_R),
			];
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/JsonTab.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal sealed class JsonTab(IUnityObjectBase asset, AssetPath path) : AssetHtmlTab(asset)
{
	public string Url { get; } = AssetAPI.GetJsonUrl(path);
	public string FileName => $"{Asset.GetBestName()}.json";
	public override string DisplayName => Localization.Json;
	public override string HtmlName => "json";
	public override bool Enabled => true;

	public override void Write(TextWriter writer)
	{
		new Pre(writer).WithClass("bg-dark-subtle rounded-3 p-2").WithDynamicTextContent(Url).Close();
		using (new Div(writer).WithClass("text-center").End())
		{
			SaveButton.Write(writer, Url, FileName);
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/ModelTab.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal sealed class ModelTab : AssetHtmlTab
{
	public string Source { get; }

	public override string DisplayName => Localization.AssetTabModel;

	public override string HtmlName => "model";

	public override bool Enabled => AssetAPI.HasModelData(Asset);

	public ModelTab(IUnityObjectBase asset, AssetPath path) : base(asset)
	{
		Source = AssetAPI.GetModelUrl(path);
	}

	public override void Write(TextWriter writer)
	{
		using (new Table(writer).WithCustomAttribute("width", "100%").WithCustomAttribute("height", "100%").End())
		{
			using (new Tbody(writer).End())
			{
				using (new Tr(writer).End())
				{
					using (new Td(writer).WithAlign("center").WithCustomAttribute("valign", "middle").End())
					{
						new Canvas(writer)
							.WithId("babylonRenderCanvas")
							.WithStyle("width: 100%; height: 100vh;")
							.WithCustomAttribute("glb-data-path", Source)
							.Close();
					}
				}
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/TextTab.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal sealed class TextTab : AssetHtmlTab
{
	public string Url { get; }

	public string? FileName => AssetAPI.GetTextFileName(Asset);

	public override string DisplayName => Localization.AssetTabText;

	public override string HtmlName => "text";

	public override bool Enabled => AssetAPI.HasText(Asset);

	public TextTab(IUnityObjectBase asset, AssetPath path) : base(asset)
	{
		Url = AssetAPI.GetTextUrl(path);
	}

	public override void Write(TextWriter writer)
	{
		new Pre(writer).WithClass("bg-dark-subtle rounded-3 p-2").WithDynamicTextContent(Url).Close();
		using (new Div(writer).WithClass("text-center").End())
		{
			SaveButton.Write(writer, Url, FileName);
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/VideoTab.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.SourceGenerated.Classes.ClassID_329;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal sealed class VideoTab : AssetHtmlTab
{
	public AssetPath Path { get; }
	private string? Extension { get; }
	public override string DisplayName => Localization.AssetTabVideo;
	public override string HtmlName => "video";
	public override bool Enabled => AssetAPI.HasVideoData(Asset);
	public VideoTab(IUnityObjectBase asset, AssetPath path) : base(asset)
	{
		Path = path;
		Extension = (asset as IVideoClip)?.TryGetExtensionFromPath();
	}
	public override void Write(TextWriter writer)
	{
		string videoUrl = AssetAPI.GetVideoUrl(Path);

		using (new Video(writer).WithControls().WithStyle("width:100%; height:100%").End())
		{
			new Source(writer).WithSrc(videoUrl).WithType($"video/{Extension}").Close();
		}

		// Click a button beneath the video to download its data
		using (new Div(writer).WithTextCenter().End())
		{
			SaveButton.Write(writer, videoUrl);
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/ViewPage.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Assets;

public sealed class ViewPage : DefaultPage
{
	public required IUnityObjectBase Asset { get; init; }
	public required AssetPath Path { get; init; }

	public override string GetTitle() => Asset.GetBestName();

	public override void WriteInnerContent(TextWriter writer)
	{
		new H1(writer).Close(GetTitle());

		ReadOnlySpan<HtmlTab> tabs =
			[
				new InformationTab(Asset, Path),
				new AudioTab(Asset, Path),
				new ImageTab(Asset, Path),
				new ModelTab(Asset, Path),
				new TextTab(Asset, Path),
				new FontTab(Asset, Path),
				new VideoTab(Asset, Path),
				new YamlTab(Asset, Path),
				new JsonTab(Asset, Path),
				new HexTab(Asset, Path),
				new DependenciesTab(Asset),
				new DevelopmentTab(Asset),
			];

		HtmlTab.WriteNavigation(writer, tabs);
		HtmlTab.WriteContent(writer, tabs);
	}

	protected override void WriteScriptReferences(TextWriter writer)
	{
		base.WriteScriptReferences(writer);
		OnlineDependencies.Babylon.WriteScriptReference(writer);
		new Script(writer).WithSrc("/js/mesh_preview.js").Close();
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Assets/YamlTab.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Assets;

internal sealed class YamlTab(IUnityObjectBase asset, AssetPath path) : AssetHtmlTab(asset)
{
	public string Url { get; } = AssetAPI.GetYamlUrl(path);
	public string FileName { get; } = $"{asset.GetBestName()}.asset";
	public override string DisplayName => Localization.Yaml;
	public override string HtmlName => "yaml";
	public override bool Enabled => true;

	public override void Write(TextWriter writer)
	{
		new Pre(writer).WithClass("bg-dark-subtle rounded-3 p-2").WithDynamicTextContent(Url).Close();
		using (new Div(writer).WithClass("text-center").End())
		{
			SaveButton.Write(writer, Url, FileName);
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Bundles/BundleAPI.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.Web.Extensions;
using Microsoft.AspNetCore.Http;

namespace AssetRipper.GUI.Web.Pages.Bundles;

internal static class BundleAPI
{
	public static class Urls
	{
		public const string Base = "/Bundles";
		public const string View = Base + "/View";
	}

	private const string Path = "Path";

	public static string GetViewUrl(BundlePath path) => $"/Bundles/View?{GetPathQuery(path)}";
	public static Task GetView(HttpContext context)
	{
		context.Response.DisableCaching();
		if (TryGetBundleFromQuery(context, out Bundle? bundle, out BundlePath path, out Task? failureTask))
		{
			return new ViewPage() { Bundle = bundle, Path = path }.WriteToResponse(context.Response);
		}
		else
		{
			return failureTask;
		}
	}

	private static string GetPathQuery(BundlePath path) => $"{Path}={path.ToJson().ToUrl()}";

	private static bool TryGetBundleFromQuery(HttpContext context, [NotNullWhen(true)] out Bundle? bundle, out BundlePath path, [NotNullWhen(false)] out Task? failureTask)
	{
		if (!context.Request.Query.TryGetValue(Path, out string? json) || string.IsNullOrEmpty(json))
		{
			bundle = null;
			path = default;
			failureTask = context.Response.NotFound("The path must be included in the request.");
			return false;
		}

		try
		{
			path = BundlePath.FromJson(json);
		}
		catch (Exception ex)
		{
			bundle = null;
			path = default;
			failureTask = context.Response.NotFound(ex.ToString());
			return false;
		}

		if (!GameFileLoader.IsLoaded)
		{
			bundle = null;
			failureTask = context.Response.NotFound("No files loaded.");
			return false;
		}
		else if (!GameFileLoader.GameBundle.TryGetBundle(path, out bundle))
		{
			failureTask = context.Response.NotFound($"Bundle could not be resolved: {path}");
			return false;
		}
		else
		{
			failureTask = null;
			return true;
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Bundles/ViewPage.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Bundles;

public sealed class ViewPage : DefaultPage
{
	public required Bundle Bundle { get; init; }
	public required BundlePath Path { get; init; }

	public override string GetTitle() => Bundle.Name;

	public override void WriteInnerContent(TextWriter writer)
	{
		new H1(writer).Close(GetTitle());

		if (Bundle.Parent is not null)
		{
			new H2(writer).Close(Localization.Parent);
			PathLinking.WriteLink(writer, Path.Parent, Bundle.Parent.Name);
		}

		if (Bundle.Bundles.Count > 0)
		{
			new H2(writer).Close(Localization.Bundles);
			using (new Ul(writer).End())
			{
				for (int i = 0; i < Bundle.Bundles.Count; i++)
				{
					using (new Li(writer).End())
					{
						PathLinking.WriteLink(writer, Path.GetChild(i), Bundle.Bundles[i].Name);
					}
				}
			}
		}

		if (Bundle.Collections.Count > 0)
		{
			new H2(writer).Close(Localization.Collections);
			using (new Ul(writer).End())
			{
				for (int i = 0; i < Bundle.Collections.Count; i++)
				{
					AssetCollection collection = Bundle.Collections[i];
					if (collection.Count > 0 || collection is SerializedAssetCollection)
					{
						using (new Li(writer).End())
						{
							PathLinking.WriteLink(writer, Path.GetCollection(i), collection.Name);
						}
					}
				}
			}
		}

		if (Bundle.Resources.Count > 0)
		{
			new H2(writer).Close(Localization.Resources);
			using (new Ul(writer).End())
			{
				for (int i = 0; i < Bundle.Resources.Count; i++)
				{
					using (new Li(writer).End())
					{
						PathLinking.WriteLink(writer, Path.GetResource(i), Bundle.Resources[i].Name);
					}
				}
			}
		}

		if (Bundle.FailedFiles.Count > 0)
		{
			new H2(writer).Close(Localization.FailedFiles);
			using (new Ul(writer).End())
			{
				for (int i = 0; i < Bundle.FailedFiles.Count; i++)
				{
					using (new Li(writer).End())
					{
						PathLinking.WriteLink(writer, Path.GetFailedFile(i), Bundle.FailedFiles[i].NameFixed);
					}
				}
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/ByteArrayExtensions.cs`:

```cs
namespace AssetRipper.GUI.Web.Pages;

internal static class ByteArrayExtensions
{
	public static string ToBase64String(this byte[] array)
	{
		return Convert.ToBase64String(array, Base64FormattingOptions.None);
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Collections/CollectionAPI.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.Web.Extensions;
using Microsoft.AspNetCore.Http;

namespace AssetRipper.GUI.Web.Pages.Collections;

internal static class CollectionAPI
{
	public static class Urls
	{
		public const string Base = "/Collections";
		public const string View = Base + "/View";
		public const string Count = Base + "/Count";
	}

	public const string Path = "Path";

	public static string GetViewUrl(CollectionPath path)
	{
		return $"{Urls.View}?{GetPathQuery(path)}";
	}

	public static Task GetView(HttpContext context)
	{
		context.Response.DisableCaching();
		if (TryGetCollectionFromQuery(context, out AssetCollection? collection, out CollectionPath path, out Task? failureTask))
		{
			return new ViewPage()
			{
				Collection = collection,
				Path = path
			}.WriteToResponse(context.Response);
		}
		else
		{
			return failureTask;
		}
	}

	public static string GetCountUrl(CollectionPath path) => $"/Collections/Count?{GetPathQuery(path)}";
	public static Task GetCount(HttpContext context)
	{
		context.Response.DisableCaching();
		if (TryGetCollectionFromQuery(context, out AssetCollection? collection, out Task? failureTask))
		{
			return Results.Json(collection.Count, AppJsonSerializerContext.Default.Int32).ExecuteAsync(context);
		}
		else
		{
			return failureTask;
		}
	}

	private static string GetPathQuery(CollectionPath path) => $"{Path}={path.ToJson().ToUrl()}";

	private static bool TryGetCollectionFromQuery(HttpContext context, [NotNullWhen(true)] out AssetCollection? collection, [NotNullWhen(false)] out Task? failureTask)
	{
		return TryGetCollectionFromQuery(context, out collection, out _, out failureTask);
	}

	private static bool TryGetCollectionFromQuery(HttpContext context, [NotNullWhen(true)] out AssetCollection? collection, out CollectionPath path, [NotNullWhen(false)] out Task? failureTask)
	{
		if (!context.Request.Query.TryGetValue(Path, out string? json) || string.IsNullOrEmpty(json))
		{
			collection = null;
			path = default;
			failureTask = context.Response.NotFound("The path must be included in the request.");
			return false;
		}

		try
		{
			path = CollectionPath.FromJson(json);
		}
		catch (Exception ex)
		{
			collection = null;
			path = default;
			failureTask = context.Response.NotFound(ex.ToString());
			return false;
		}

		if (!GameFileLoader.IsLoaded)
		{
			collection = null;
			failureTask = context.Response.NotFound("No files loaded.");
			return false;
		}
		else if (!GameFileLoader.GameBundle.TryGetCollection(path, out collection))
		{
			failureTask = context.Response.NotFound($"Asset collection could not be resolved: {path}");
			return false;
		}
		else
		{
			failureTask = null;
			return true;
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Collections/ViewPage.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Collections;

public sealed class ViewPage : DefaultPage
{
	public required AssetCollection Collection { get; init; }
	public required CollectionPath Path { get; init; }

	public override string GetTitle() => Collection.Name;

	public override void WriteInnerContent(TextWriter writer)
	{
		new H1(writer).Close(GetTitle());

		new H2(writer).Close(Localization.Bundle);
		PathLinking.WriteLink(writer, Path.BundlePath, Collection.Bundle.Name);

		if (Collection.IsScene)
		{
			new H2(writer).Close(Localization.Scene);
			PathLinking.WriteLink(writer, (ScenePath)Path, Collection.Scene.Name);
		}

		if (Collection.Count > 0)
		{
			new H2(writer).Close(Localization.Assets);
			
			var availableClasses = Collection.Select(a => a.ClassName).Distinct().Order().ToList();
			if (availableClasses.Count > 1)
			{
				new Label(writer).WithFor("classFilter").WithClass("me-2").Close(Localization.Class);

				using (new Select(writer)
					.WithId("classFilter")
					.WithClass("me-2")
					.End())
				{
					new Option(writer)
						.WithValue(string.Empty)
						.Close(Localization.All);

					foreach (string cn in availableClasses)
					{
						new Option(writer)
							.WithValue(cn)
							.Close(cn);
					}
				}
			}
			
			using (new Table(writer).WithClass("table").End())
			{
				using (new Thead(writer).End())
				{
					using (new Tr(writer).End())
					{
						new Th(writer).Close(Localization.PathId);
						new Th(writer).Close(Localization.Class);
						new Th(writer).Close(Localization.Name);
					}
				}
				using (new Tbody(writer).WithId("assetsTable").End())
				{
					foreach (IUnityObjectBase asset in Collection)
					{
						using (new Tr(writer).WithCustomAttribute("data-class", asset.ClassName).End())
						{
							new Td(writer).Close(asset.PathID.ToString());
							new Td(writer).Close(asset.ClassName);
							using (new Td(writer).End())
							{
								PathLinking.WriteLink(writer, Path.GetAsset(asset.PathID), asset.GetBestName());
							}
						}
					}
				}
			}
		}

		if (Collection.Dependencies.Count > 1)
		{
			new H2(writer).Close(Localization.AssetTabDependencies);
			using (new Table(writer).WithClass("table").End())
			{
				using (new Thead(writer).End())
				{
					using (new Tr(writer).End())
					{
						new Th(writer).Close(Localization.FileId);
						new Th(writer).Close(Localization.Name);
					}
				}
				using (new Tbody(writer).End())
				{
					for (int i = 1; i < Collection.Dependencies.Count; i++)
					{
						AssetCollection? dependency = Collection.Dependencies[i];
						if (dependency is null)
						{
							continue;
						}

						using (new Tr(writer).End())
						{
							new Td(writer).Close(i.ToString());
							using (new Td(writer).End())
							{
								PathLinking.WriteLink(writer, dependency);
							}
						}
					}
				}
			}
		}
	}

	protected override void WriteScriptReferences(TextWriter writer)
	{
		base.WriteScriptReferences(writer);
		
		// Add client-side filtering script
		using (new Script(writer).End())
		{
			writer.Write("""
				document.addEventListener('DOMContentLoaded', function() {
					const classFilter = document.getElementById('classFilter');
					if (classFilter) {
						classFilter.addEventListener('change', function() {
							const selectedClass = this.value;
							const rows = document.querySelectorAll('#assetsTable tr');
							
							rows.forEach(function(row) {
								const rowClass = row.getAttribute('data-class');
								if (selectedClass === '' || rowClass === selectedClass) {
									row.style.display = '';
								} else {
									row.style.display = 'none';
								}
							});
						});
					}
				});
				""");
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Commands.cs`:

```cs
using AssetRipper.NativeDialogs;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Primitives;

namespace AssetRipper.GUI.Web.Pages;

public static class Commands
{
	private const string RootPath = "/";
	private const string CommandsPath = "/Commands";

	/// <summary>
	/// For documentation purposes
	/// </summary>
	/// <param name="Path">The file system path.</param>
	internal record PathFormData(string Path);

	internal static RouteHandlerBuilder AcceptsFormDataContainingPath(this RouteHandlerBuilder builder)
	{
		return builder.Accepts<PathFormData>("application/x-www-form-urlencoded");
	}

	private static bool TryGetCreateSubfolder(IFormCollection form)
	{
		if (form.TryGetValue("CreateSubfolder", out StringValues values))
		{
			return values == "true";
		}

		return false;
	}

	public readonly struct LoadFile : ICommand
	{
		static async Task<string?> ICommand.Execute(HttpRequest request)
		{
			IFormCollection form = await request.ReadFormAsync();

			string[]? paths;
			if (form.TryGetValue("Path", out StringValues values))
			{
				paths = values;
			}
			else if (NativeDialog.Supported)
			{
				paths = await OpenFileDialog.OpenFiles();
			}
			else
			{
				return CommandsPath;
			}

			if (paths is { Length: > 0 })
			{
				GameFileLoader.LoadAndProcess(paths);
			}
			return null;
		}
	}

	public readonly struct LoadFolder : ICommand
	{
		static async Task<string?> ICommand.Execute(HttpRequest request)
		{
			IFormCollection form = await request.ReadFormAsync();

			string[]? paths;
			if (form.TryGetValue("Path", out StringValues values))
			{
				paths = values;
			}
			else if (NativeDialog.Supported)
			{
				paths = await OpenFolderDialog.OpenFolders();
			}
			else
			{
				return CommandsPath;
			}

			if (paths is { Length: > 0 })
			{
				GameFileLoader.LoadAndProcess(paths);
			}
			return null;
		}
	}

	public readonly struct ExportUnityProject : ICommand
	{
		static async Task<string?> ICommand.Execute(HttpRequest request)
		{
			IFormCollection form = await request.ReadFormAsync();

			string? path;
			if (form.TryGetValue("Path", out StringValues values))
			{
				path = values;
			}
			else
			{
				return CommandsPath;
			}

			if (!string.IsNullOrEmpty(path))
			{
				bool createSubfolder = TryGetCreateSubfolder(form);
				path = MaybeAppendTimestampedSubfolder(path, createSubfolder);
				await GameFileLoader.ExportUnityProject(path);
			}
			return null;
		}
	}

	public readonly struct ExportPrimaryContent : ICommand
	{
		static async Task<string?> ICommand.Execute(HttpRequest request)
		{
			IFormCollection form = await request.ReadFormAsync();

			string? path;
			if (form.TryGetValue("Path", out StringValues values))
			{
				path = values;
			}
			else
			{
				return CommandsPath;
			}

			if (!string.IsNullOrEmpty(path))
			{
				bool createSubfolder = TryGetCreateSubfolder(form);
				path = MaybeAppendTimestampedSubfolder(path, createSubfolder);
				await GameFileLoader.ExportPrimaryContent(path);
			}
			return null;
		}
	}

	private static string MaybeAppendTimestampedSubfolder(string path, bool append)
	{
		if (append)
		{
			string timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
			string subfolder = $"AssetRipper_export_{timestamp}";
			return Path.Combine(path, subfolder);
		}

		return path;
	}

	public readonly struct Reset : ICommand
	{
		static Task<string?> ICommand.Execute(HttpRequest request)
		{
			GameFileLoader.Reset();
			return Task.FromResult<string?>(null);
		}
	}

	public static async Task HandleCommand<T>(HttpContext context) where T : ICommand
	{
		string? redirectionTarget = await T.Execute(context.Request);
		context.Response.Redirect(redirectionTarget ?? RootPath);
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/CommandsPage.cs`:

```cs
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages;

public sealed class CommandsPage : VuePage
{
	public static CommandsPage Instance { get; } = new();

	public override string? GetTitle() => Localization.Commands;

	public override void WriteInnerContent(TextWriter writer)
	{
		if (!GameFileLoader.IsLoaded)
		{
			using (new P(writer).End())
			{
				using (new Form(writer).WithAction("/LoadFolder").WithMethod("post").End())
				{
					new Input(writer).WithClass("form-control").WithType("text").WithName("Path")
						.WithCustomAttribute("v-model", "load_path")
						.WithCustomAttribute("@input", "handleLoadPathChange").Close();
					new Input(writer).WithCustomAttribute("v-if", "load_path_exists").WithType("submit").WithClass("btn btn-primary").WithValue(Localization.MenuLoad).Close();
					new Button(writer).WithCustomAttribute("v-else").WithClass("btn btn-primary").WithCustomAttribute("disabled").Close(Localization.MenuLoad);
				}

				if (Dialogs.Supported)
				{
					new Button(writer).WithCustomAttribute("@click", "handleSelectLoadFile").WithClass("btn btn-success").Close(Localization.SelectFile);
					new Button(writer).WithCustomAttribute("@click", "handleSelectLoadFolder").WithClass("btn btn-success").Close(Localization.SelectFolder);
				}
			}
		}
		else
		{
			using (new P(writer).End())
			{
				WriteLink(writer, "/Reset", Localization.MenuFileReset, "btn btn-danger");
			}
			using (new P(writer).End())
			{
				using (new Form(writer).End())
				{
					new Input(writer).WithClass("form-control").WithType("text").WithName("Path")
						.WithCustomAttribute("v-model", "export_path")
						.WithCustomAttribute("@input", "handleExportPathChange").Close();
				}

				using (new Div(writer).WithClass("form-check mb-2").End())
				{
					new Input(writer)
						.WithType("checkbox")
						.WithClass("form-check-input")
						.WithCustomAttribute("v-model", "create_subfolder")
						.WithCustomAttribute("@input", "handleExportPathChange")
						.WithId("createSubfolder")
						.Close();
					new Label(writer)
						.WithClass("form-check-label")
						.WithCustomAttribute("for", "createSubfolder")
						.Close(Localization.CreateSubfolder);
				}

				using (new Form(writer).WithAction("/Export/UnityProject").WithMethod("post").End())
				{
					new Input(writer).WithType("hidden").WithName("Path").WithCustomAttribute("v-model", "export_path").Close();
					new Input(writer).WithType("hidden").WithName("CreateSubfolder").WithCustomAttribute("v-model", "create_subfolder").Close();

					new Button(writer).WithCustomAttribute("v-if", "export_path === '' || export_path !== export_path.trim()").WithClass("btn btn-primary").WithCustomAttribute("disabled").Close(Localization.ExportUnityProject);
					new Input(writer).WithCustomAttribute("v-else-if", "export_path_has_files").WithType("submit").WithClass("btn btn-danger").WithValue(Localization.ExportUnityProject).Close();
					new Input(writer).WithCustomAttribute("v-else").WithType("submit").WithClass("btn btn-primary").WithValue(Localization.ExportUnityProject).Close();
				}

				using (new Form(writer).WithAction("/Export/PrimaryContent").WithMethod("post").End())
				{
					new Input(writer).WithType("hidden").WithName("Path").WithCustomAttribute("v-model", "export_path").Close();
					new Input(writer).WithType("hidden").WithName("CreateSubfolder").WithCustomAttribute("v-model", "create_subfolder").Close();

					new Button(writer).WithCustomAttribute("v-if", "export_path === '' || export_path !== export_path.trim()").WithClass("btn btn-primary").WithCustomAttribute("disabled").Close(Localization.ExportPrimaryContent);
					new Input(writer).WithCustomAttribute("v-else-if", "export_path_has_files").WithType("submit").WithClass("btn btn-danger").WithValue(Localization.ExportPrimaryContent).Close();
					new Input(writer).WithCustomAttribute("v-else").WithType("submit").WithClass("btn btn-primary").WithValue(Localization.ExportPrimaryContent).Close();
				}

				if (Dialogs.Supported)
				{
					new Button(writer).WithCustomAttribute("@click", "handleSelectExportFolder").WithClass("btn btn-success").Close(Localization.SelectFolder);
				}

				using (new Div(writer).WithCustomAttribute("v-if", "export_path_has_files").End())
				{
					new P(writer).Close(Localization.WarningThisDirectoryIsNotEmptyAllContentWillBeDeleted);
				}
			}
		}
	}

	protected override void WriteScriptReferences(TextWriter writer)
	{
		base.WriteScriptReferences(writer);
		new Script(writer).WithSrc("/js/commands_page.js").Close();
	}

	private static void WriteLink(TextWriter writer, string url, string name, string? @class = null)
	{
		using (new Form(writer).WithAction(url).WithMethod("post").End())
		{
			new Input(writer).WithType("submit").WithClass(@class).WithValue(name.ToHtml()).Close();
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/DataExtensions.cs`:

```cs
using AssetRipper.Import.Configuration;

namespace AssetRipper.GUI.Web.Pages;

internal static class DataExtensions
{
	public static bool ContainsIndex(this DataSet list, int index)
	{
		return index >= 0 && index < list.Count;
	}
	public static DataInstance GetOrAdd(this SingletonDataStorage storage, string key)
	{
		if (!storage.TryGetValue(key, out DataInstance? value))
		{
			value = new StringDataInstance();
			storage.Add(key, value);
		}
		return value;
	}
	public static DataSet GetOrAdd(this ListDataStorage storage, string key)
	{
		if (!storage.TryGetValue(key, out DataSet? value))
		{
			value = new StringDataSet();
			storage.Add(key, value);
		}
		return value;
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/FailedFiles/FailedFileAPI.cs`:

```cs
using AssetRipper.GUI.Web.Paths;
using AssetRipper.IO.Files;
using AssetRipper.Web.Extensions;
using Microsoft.AspNetCore.Http;

namespace AssetRipper.GUI.Web.Pages.FailedFiles;

internal static class FailedFileAPI
{
	public static class Urls
	{
		public const string Base = "/FailedFiles";
		public const string View = Base + "/View";
		public const string StackTrace = Base + "/StackTrace";
	}

	private const string Path = "Path";

	public static string GetViewUrl(FailedFilePath path) => $"{Urls.View}?{GetPathQuery(path)}";
	public static Task GetView(HttpContext context)
	{
		context.Response.DisableCaching();
		if (TryGetFileFromQuery(context, out FailedFile? file, out FailedFilePath path, out Task? failureTask))
		{
			return new ViewPage() { File = file, Path = path }.WriteToResponse(context.Response);
		}
		else
		{
			return failureTask;
		}
	}

	public static string GetStackTraceUrl(FailedFilePath path) => $"{Urls.StackTrace}?{GetPathQuery(path)}";
	public static Task GetStackTrace(HttpContext context)
	{
		context.Response.DisableCaching();
		if (TryGetFileFromQuery(context, out FailedFile? file, out _, out Task? failureTask))
		{
			return Results.Text(file.StackTrace).ExecuteAsync(context);
		}
		else
		{
			return failureTask;
		}
	}

	private static string GetPathQuery(FailedFilePath path) => $"{Path}={path.ToJson().ToUrl()}";

	private static bool TryGetFileFromQuery(HttpContext context, [NotNullWhen(true)] out FailedFile? file, out FailedFilePath path, [NotNullWhen(false)] out Task? failureTask)
	{
		if (!context.Request.Query.TryGetValue(Path, out string? json) || string.IsNullOrEmpty(json))
		{
			file = null;
			path = default;
			failureTask = context.Response.NotFound("The path must be included in the request.");
			return false;
		}

		try
		{
			path = FailedFilePath.FromJson(json);
		}
		catch (Exception ex)
		{
			file = null;
			path = default;
			failureTask = context.Response.NotFound(ex.ToString());
			return false;
		}

		if (!GameFileLoader.IsLoaded)
		{
			file = null;
			failureTask = context.Response.NotFound("No files loaded.");
			return false;
		}
		else if (!GameFileLoader.GameBundle.TryGetFailedFile(path, out file))
		{
			failureTask = context.Response.NotFound($"Resource file could not be resolved: {path}");
			return false;
		}
		else
		{
			failureTask = null;
			return true;
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/FailedFiles/ViewPage.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.IO.Files;

namespace AssetRipper.GUI.Web.Pages.FailedFiles;

public sealed class ViewPage : DefaultPage
{
	public required FailedFile File { get; init; }
	public required FailedFilePath Path { get; init; }

	public Bundle? Bundle => GameFileLoader.GameBundle.TryGetBundle(Path.BundlePath);

	public override string GetTitle() => File.NameFixed;

	public override void WriteInnerContent(TextWriter writer)
	{
		new H1(writer).Close(GetTitle());

		if (Bundle is { } bundle)
		{
			new H2(writer).Close(Localization.Bundle);
			PathLinking.WriteLink(writer, Path.BundlePath, bundle.Name);
		}

		new H2(writer).Close(Localization.StackTrace);

		string url = FailedFileAPI.GetStackTraceUrl(Path);

		new Pre(writer).WithClass("bg-dark-subtle rounded-3 p-2").WithDynamicTextContent(url).Close();

		using (new Div(writer).WithClass("text-center").End())
		{
			SaveButton.Write(writer, url, "error.txt");
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/FormCollectionExtensions.cs`:

```cs
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Primitives;

namespace AssetRipper.GUI.Web.Pages;

internal static class FormCollectionExtensions
{
	public static bool TryGetInteger(this IFormCollection form, string key, out int value)
	{
		if (form.TryGetValue(key, out StringValues values) && int.TryParse(values, out int parsedValue))
		{
			value = parsedValue;
			return true;
		}
		value = default;
		return false;
	}

	public static bool TryGetString(this IFormCollection form, string key, [NotNullWhen(true)] out string? value)
	{
		if (form.TryGetValue(key, out StringValues values))
		{
			value = values;
			return value is not null;
		}
		value = default;
		return false;
	}

	public static bool TryGetStringArray(this IFormCollection form, string key, [NotNullWhen(true)] out string?[]? value)
	{
		if (form.TryGetValue(key, out StringValues values))
		{
			value = values;
			return value is not null;
		}
		value = default;
		return false;
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/HexTable.cs`:

```cs
namespace AssetRipper.GUI.Web.Pages;

internal static class HexTable
{
	public static void Write(TextWriter writer, byte[] data)
	{
		const int BytesPerRow = 16;

		for (int i = 0; i < data.Length; i += BytesPerRow)
		{
			using (new Tr(writer).End())
			{
				int remainder = data.Length - i;
				int nonEmptyCells = int.Min(remainder, BytesPerRow);
				for (int j = 0; j < nonEmptyCells; j++)
				{
					using (new Td(writer).End())
					{
						//We optimize this because it's a hot path.
						const string HexChars = "0123456789ABCDEF";
						byte value = data[i + j];
						writer.Write(HexChars[value >> 4]);
						writer.Write(HexChars[value & 0xF]);
					}
				}
				int emptyCells = BytesPerRow - remainder;
				for (int k = 0; k < emptyCells; k++)
				{
					new Td(writer).Close();
				}
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/HtmlExtensions.cs`:

```cs
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages;

internal static class HtmlExtensions
{
	public static A WithNewTabAttributes(this A element)
	{
		return element.WithTarget("_blank").WithRel("noopener noreferrer");
	}

	public static Div WithTextCenter(this Div element)
	{
		return element.WithClass("text-center");
	}

	public static Pre WithDynamicTextContent(this Pre element, string url)
	{
		return element.WithCustomAttribute("dynamic-text-content", url.ToHtml());
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/HtmlTab.cs`:

```cs
namespace AssetRipper.GUI.Web.Pages;

internal abstract class HtmlTab
{
	private string? guid;
	public abstract string DisplayName { get; }
	public virtual string HtmlName
	{
		get
		{
			return guid ??= Guid.NewGuid().ToString();
		}
	}
	public virtual bool Enabled => true;
	public abstract void Write(TextWriter writer);

	/// <summary>
	/// Write a tabbed navigation bar.
	/// </summary>
	/// <remarks>
	/// This should be used in conjunction with <see cref="WriteContent(TextWriter, ReadOnlySpan{HtmlTab})"/>.
	/// </remarks>
	/// <param name="writer">The text writer.</param>
	/// <param name="tabs">The tabs to write.</param>
	/// <param name="navClass">The list of classes to be used on the nav element.</param>
	public static void WriteNavigation(TextWriter writer, ReadOnlySpan<HtmlTab> tabs, string navClass = "nav nav-tabs")
	{
		using (new Nav(writer).WithClass(navClass).WithId("nav-tab").WithRole("tablist").End())
		{
			for (int i = 0; i < tabs.Length; i++)
			{
				HtmlTab tab = tabs[i];
				Button button = new Button(writer)
					.WithClass(GetTabClassSet(tab, i))
					.WithId($"nav-{tab.HtmlName}-tab")
					.WithCustomAttribute("data-bs-toggle", "tab")
					.WithCustomAttribute("data-bs-target", $"#nav-{tab.HtmlName}")
					.WithType("button")
					.WithRole("tab")
					.WithCustomAttribute("aria-controls", $"nav-{tab.HtmlName}")
					.WithCustomAttribute("aria-selected", "true");

				if (!tab.Enabled)
				{
					button.WithCustomAttribute("aria-disabled", "true");
				}

				button.Close(tab.DisplayName);
			}
		}

		static string GetTabClassSet(HtmlTab tab, int index)
		{
			const string DefaultTabClassSet = "nav-link";
			if (tab.Enabled)
			{
				return index == 0 ? DefaultTabClassSet + " active" : DefaultTabClassSet;
			}
			return DefaultTabClassSet + " disabled";
		}
	}

	/// <summary>
	/// Write the content for a tabbed navigation bar.
	/// </summary>
	/// <remarks>
	/// This should be used in conjunction with <see cref="WriteNavigation(TextWriter, ReadOnlySpan{HtmlTab}, string)"/>.
	/// </remarks>
	/// <param name="writer">The text writer.</param>
	/// <param name="tabs">The tabs to write.</param>
	public static void WriteContent(TextWriter writer, ReadOnlySpan<HtmlTab> tabs)
	{
		using (new Div(writer).WithClass("tab-content").End())
		{
			for (int i = 0; i < tabs.Length; i++)
			{
				HtmlTab tab = tabs[i];
				using (new Div(writer)
					.WithClass(i == 0 && tab.Enabled ? "tab-pane fade show active" : "tab-pane fade")
					.WithId($"nav-{tab.HtmlName}")
					.WithRole("tabpanel")
					.WithCustomAttribute("aria-labelledby", $"nav-{tab.HtmlName}-tab")
					.End())
				{
					if (tab.Enabled)
					{
						tab.Write(writer);
					}
				}
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/ICommand.cs`:

```cs
using Microsoft.AspNetCore.Http;

namespace AssetRipper.GUI.Web.Pages;

public interface ICommand
{
	/// <summary>
	/// Execute the command.
	/// </summary>
	/// <param name="request">The Http request.</param>
	/// <returns>The url target for redirection. If null, the website root is used.</returns>
	static abstract Task<string?> Execute(HttpRequest request);
}

```

`Source/AssetRipper.GUI.Web/Pages/IndexPage.cs`:

```cs
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages;

public sealed class IndexPage : DefaultPage
{
	public static IndexPage Instance { get; } = new();

	public override string? GetTitle() => GameFileLoader.Premium ? Localization.AssetRipperPremium : Localization.AssetRipperFree;

	public override void WriteInnerContent(TextWriter writer)
	{
		using (new Div(writer).WithClass("text-center container mt-5").End())
		{
			new H1(writer).WithClass("display-4 mb-4").Close(Localization.Welcome);
			if (GameFileLoader.IsLoaded)
			{
				PathLinking.WriteLink(writer, GameFileLoader.GameBundle, Localization.ViewLoadedFiles, "btn btn-success");
			}
			else
			{
				new Button(writer).WithType("button").WithClass("btn btn-secondary").WithDisabled().Close(Localization.NoFilesLoaded);
			}
			if (GameFileLoader.Premium)
			{
				new P(writer).WithClass("mt-4").Close(Localization.AppreciationMessage);
			}
			else
			{
				new P(writer).WithClass("mt-4").Close(Localization.DonationMessage);
				using (new Div(writer).WithClass("d-flex justify-content-center mt-3").End())
				{
					new A(writer).WithClass("btn btn-primary m-1").WithNewTabAttributes().WithHref("https://patreon.com/ds5678").Close("Patreon");
					new A(writer).WithClass("btn btn-primary m-1").WithNewTabAttributes().WithHref("https://paypal.me/ds5678").Close("Paypal");
					new A(writer).WithClass("btn btn-primary m-1").WithNewTabAttributes().WithHref("https://github.com/sponsors/ds5678").Close("GitHub Sponsors");
				}
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/LicensesPage.cs`:

```cs
using AssetRipper.GUI.Licensing;

namespace AssetRipper.GUI.Web.Pages;

public sealed class LicensesPage : DefaultPage
{
	public static LicensesPage Instance { get; } = new();

	private readonly HtmlTab[] tabs = Licenses.Names.Select(name => new LicenseTab(name)).ToArray();

	public override string? GetTitle() => Localization.Licenses;

	public override void WriteInnerContent(TextWriter writer)
	{
		new H1(writer).Close(GetTitle());
		using (new Div(writer).WithClass("container text-center").End())
		{
			using (new Div(writer).WithClass("row").End())
			{
				using (new Div(writer).WithClass("col-3").End())
				{
					HtmlTab.WriteNavigation(writer, tabs, "nav nav-pills flex-column");
				}
				using (new Div(writer).WithClass("col-9").End())
				{
					HtmlTab.WriteContent(writer, tabs);
				}
			}
		}
	}

	private sealed class LicenseTab(string name) : HtmlTab
	{
		public override string DisplayName => name;
		public override void Write(TextWriter writer)
		{
			new Pre(writer).WithClass("bg-dark-subtle rounded-3 p-2").Close(Licenses.Load(name));
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/PremiumFeaturesPage.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Extensions.Enums.Shader;

namespace AssetRipper.GUI.Web.Pages;

public sealed class PremiumFeaturesPage : DefaultPage
{
	public static PremiumFeaturesPage Instance { get; } = new();

	public override string? GetTitle() => Localization.PremiumFeatures;

	public override void WriteInnerContent(TextWriter writer)
	{
		new H1(writer).Close(GetTitle());
		using (new Table(writer).WithClass("table").End())
		{
			using (new Tbody(writer).End())
			{
				using (new Tr(writer).End())
				{
					new Th(writer).Close(Localization.ShaderDecompilation);
					new Td(writer).Close(GetFeatureStatus<IShader>(null, ShaderDecompilationSupported) switch
					{
						FeatureStatus.NoFilesLoaded => Localization.NoFilesLoaded,
						FeatureStatus.NoAssetsOfType => Localization.NoShadersFound,
						FeatureStatus.NoAssetsNeedFeature => null,
						FeatureStatus.NoAssetsAreSupported => Localization.NotSupported,
						FeatureStatus.Supported => Localization.Supported,
						_ => null,
					});
				}
				using (new Tr(writer).End())
				{
					new Th(writer).Close(Localization.StaticMeshSeparation);
					new Td(writer).Close(GetFeatureStatus<IMesh>(mesh => mesh.IsCombinedMesh(), null) switch
					{
						FeatureStatus.NoFilesLoaded => Localization.NoFilesLoaded,
						FeatureStatus.NoAssetsOfType => Localization.NoMeshesFound,
						FeatureStatus.NoAssetsNeedFeature => Localization.NoStaticMeshesFound,
						FeatureStatus.NoAssetsAreSupported => Localization.NotSupported,
						FeatureStatus.Supported => Localization.Supported,
						_ => null,
					});
				}
			}
		}
	}

	private static bool ShaderDecompilationSupported(IShader shader)
	{
		return shader.GetPlatforms()?.Any(platform => platform is GPUPlatform.vulkan || (platform.IsDirectX() && OperatingSystem.IsWindows())) ?? false;
	}

	private static FeatureStatus GetFeatureStatus<T>(Func<T, bool>? needsFeatureFunction, Func<T, bool>? isSupportedFunction)
		where T : class
	{
		if (!GameFileLoader.IsLoaded)
		{
			return FeatureStatus.NoFilesLoaded;
		}

		bool hasAssetsOfType = false;
		bool hasAssetsNeedingFeature = false;
		bool supportedAssetFound = false;
		foreach (T asset in GameFileLoader.GameBundle.FetchAssets().OfType<T>())
		{
			hasAssetsOfType = true;
			if (needsFeatureFunction?.Invoke(asset) ?? true)
			{
				hasAssetsNeedingFeature = true;
				if (isSupportedFunction?.Invoke(asset) ?? true)
				{
					supportedAssetFound = true;
					break;
				}
			}
		}
		if (!hasAssetsOfType)
		{
			return FeatureStatus.NoAssetsOfType;
		}
		if (!hasAssetsNeedingFeature)
		{
			return FeatureStatus.NoAssetsNeedFeature;
		}
		return supportedAssetFound ? FeatureStatus.Supported : FeatureStatus.NoAssetsAreSupported;
	}

	private enum FeatureStatus
	{
		NoFilesLoaded,
		NoAssetsOfType,
		NoAssetsNeedFeature,
		NoAssetsAreSupported,
		Supported,
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/PrivacyPage.cs`:

```cs
namespace AssetRipper.GUI.Web.Pages;

public sealed class PrivacyPage : DefaultPage
{
	public static PrivacyPage Instance { get; } = new();

	public override string GetTitle() => "Privacy Policy";

	public override void WriteInnerContent(TextWriter writer)
	{
		new H1(writer).Close(GetTitle());
		using (new P(writer).End())
		{
			writer.Write("This app does not access the internet.");
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Resources/ResourceAPI.cs`:

```cs
using AssetRipper.GUI.Web.Paths;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.Web.Extensions;
using Microsoft.AspNetCore.Http;

namespace AssetRipper.GUI.Web.Pages.Resources;

internal static class ResourceAPI
{
	public static class Urls
	{
		public const string Base = "/Resources";
		public const string View = Base + "/View";
		public const string Data = Base + "/Data";
	}

	private const string Path = "Path";

	public static string GetViewUrl(ResourcePath path) => $"{Urls.View}?{GetPathQuery(path)}";
	public static Task GetView(HttpContext context)
	{
		context.Response.DisableCaching();
		if (TryGetResourceFromQuery(context, out ResourceFile? resource, out ResourcePath path, out Task? failureTask))
		{
			return new ViewPage() { Resource = resource, Path = path }.WriteToResponse(context.Response);
		}
		else
		{
			return failureTask;
		}
	}

	public static string GetDataUrl(ResourcePath path) => $"{Urls.Data}?{GetPathQuery(path)}";
	public static Task GetData(HttpContext context)
	{
		context.Response.DisableCaching();
		if (TryGetResourceFromQuery(context, out ResourceFile? resource, out Task? failureTask))
		{
			return Results.Bytes(resource.ToByteArray(), "application/octet-stream").ExecuteAsync(context);
		}
		else
		{
			return failureTask;
		}
	}

	private static string GetPathQuery(ResourcePath path) => $"{Path}={path.ToJson().ToUrl()}";

	private static bool TryGetResourceFromQuery(HttpContext context, [NotNullWhen(true)] out ResourceFile? resource, [NotNullWhen(false)] out Task? failureTask)
	{
		return TryGetResourceFromQuery(context, out resource, out _, out failureTask);
	}

	private static bool TryGetResourceFromQuery(HttpContext context, [NotNullWhen(true)] out ResourceFile? resource, out ResourcePath path, [NotNullWhen(false)] out Task? failureTask)
	{
		if (!context.Request.Query.TryGetValue(Path, out string? json) || string.IsNullOrEmpty(json))
		{
			resource = null;
			path = default;
			failureTask = context.Response.NotFound("The path must be included in the request.");
			return false;
		}

		try
		{
			path = ResourcePath.FromJson(json);
		}
		catch (Exception ex)
		{
			resource = null;
			path = default;
			failureTask = context.Response.NotFound(ex.ToString());
			return false;
		}

		if (!GameFileLoader.IsLoaded)
		{
			resource = null;
			failureTask = context.Response.NotFound("No files loaded.");
			return false;
		}
		else if (!GameFileLoader.GameBundle.TryGetResource(path, out resource))
		{
			failureTask = context.Response.NotFound($"Resource file could not be resolved: {path}");
			return false;
		}
		else
		{
			failureTask = null;
			return true;
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Resources/ViewPage.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.IO.Files.ResourceFiles;

namespace AssetRipper.GUI.Web.Pages.Resources;

public sealed class ViewPage : DefaultPage
{
	public required ResourceFile Resource { get; init; }
	public required ResourcePath Path { get; init; }

	public Bundle? Bundle => GameFileLoader.GameBundle.TryGetBundle(Path.BundlePath);

	public override string GetTitle() => Resource.NameFixed;

	public override void WriteInnerContent(TextWriter writer)
	{
		new H1(writer).Close(GetTitle());

		if (Bundle is { } bundle)
		{
			new H2(writer).Close(Localization.Bundle);
			PathLinking.WriteLink(writer, Path.BundlePath, bundle.Name);
		}

		new H2(writer).Close(Localization.Size);
		new P(writer).Close(Resource.Stream.Length.ToString());

		using (new Div(writer).WithClass("text-center").End())
		{
			SaveButton.Write(writer, ResourceAPI.GetDataUrl(Path), Resource.NameFixed);
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/SaveButton.cs`:

```cs
namespace AssetRipper.GUI.Web.Pages;

internal static class SaveButton
{
	public static void Write(TextWriter writer, string url, string? fileName = null, string? text = null)
	{
		new A(writer).WithHref(url).WithDownload(fileName).WithClass("btn btn-primary").Close(text ?? Localization.Save);
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Scenes/SceneAPI.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.Web.Extensions;
using Microsoft.AspNetCore.Http;

namespace AssetRipper.GUI.Web.Pages.Scenes;

internal static class SceneAPI
{
	public static class Urls
	{
		public const string Base = "/Scenes";
		public const string View = Base + "/View";
	}

	private const string Path = "Path";

	public static string GetViewUrl(ScenePath path) => $"/Scenes/View?{GetPathQuery(path)}";
	public static Task GetView(HttpContext context)
	{
		context.Response.DisableCaching();
		if (TryGetSceneFromQuery(context, out SceneDefinition? scene, out ScenePath path, out Task? failureTask))
		{
			return new ViewPage() { Scene = scene, Path = path }.WriteToResponse(context.Response);
		}
		else
		{
			return failureTask;
		}
	}

	private static string GetPathQuery(ScenePath path) => $"{Path}={path.ToJson().ToUrl()}";

	private static bool TryGetSceneFromQuery(HttpContext context, [NotNullWhen(true)] out SceneDefinition? scene, out ScenePath path, [NotNullWhen(false)] out Task? failureTask)
	{
		if (!context.Request.Query.TryGetValue(Path, out string? json) || string.IsNullOrEmpty(json))
		{
			scene = null;
			path = default;
			failureTask = context.Response.NotFound("The path must be included in the request.");
			return false;
		}

		try
		{
			path = ScenePath.FromJson(json);
		}
		catch (Exception ex)
		{
			scene = null;
			path = default;
			failureTask = context.Response.NotFound(ex.ToString());
			return false;
		}

		if (!GameFileLoader.IsLoaded)
		{
			scene = null;
			failureTask = context.Response.NotFound("No files loaded.");
			return false;
		}
		else if (!GameFileLoader.GameBundle.TryGetCollection(path.FirstCollection, out AssetCollection? collection))
		{
			scene = null;
			failureTask = context.Response.NotFound($"Scene could not be resolved: {path.FirstCollection}");
			return false;
		}
		else if (!collection.IsScene)
		{
			scene = null;
			failureTask = context.Response.NotFound($"Collection is not a scene: {path.FirstCollection}");
			return false;
		}
		else
		{
			scene = collection.Scene;
			failureTask = null;
			return true;
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Scenes/ViewPage.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Scenes;

public sealed class ViewPage : DefaultPage
{
	public required SceneDefinition Scene { get; init; }
	public required ScenePath Path { get; init; }

	public override string GetTitle() => Scene.Name;

	public override void WriteInnerContent(TextWriter writer)
	{
		new H1(writer).Close(GetTitle());
		using (new Table(writer).WithClass("table").End())
		{
			using (new Tbody(writer).End())
			{
				using (new Tr(writer).End())
				{
					new Th(writer).Close(Localization.Name);
					new Td(writer).Close(Scene.Name);
				}
				using (new Tr(writer).End())
				{
					new Th(writer).Close(Localization.Path);
					new Td(writer).Close(Scene.Path);
				}
				using (new Tr(writer).End())
				{
					new Th(writer).Close(Localization.Guid);
					new Td(writer).Close(Scene.GUID.ToString());
				}
			}
		}
		new H2(writer).Close(Localization.Collections);
		using (new Ul(writer).End())
		{
			foreach (AssetCollection collection in Scene.Collections)
			{
				using (new Li(writer).End())
				{
					PathLinking.WriteLink(writer, collection);
				}
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Search/SearchAPI.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.Web.Extensions;
using Microsoft.AspNetCore.Http;

namespace AssetRipper.GUI.Web.Pages.Search;

internal static class SearchAPI
{
	public static class Urls
	{
		public const string Base = "/Search";
		public const string View = Base + "/View";
	}

	public const string Query = "q";

	public static string GetViewUrl(string searchQuery)
	{
		return $"{Urls.View}?{Query}={searchQuery.ToUrl()}";
	}

	public static Task GetView(HttpContext context)
	{
		context.Response.DisableCaching();
		
		if (!GameFileLoader.IsLoaded)
		{
			return context.Response.NotFound("No files loaded.");
		}

		string searchQuery = context.Request.Query[Query].ToString();

		return new ViewPage()
		{
			SearchQuery = searchQuery.Trim()
		}.WriteToResponse(context.Response);
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Search/ViewPage.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.GUI.Web.Paths;

namespace AssetRipper.GUI.Web.Pages.Search;

public sealed class ViewPage : DefaultPage
{
	public required string SearchQuery { get; init; }

	public override string GetTitle() => $"{Localization.Search}: {SearchQuery}";

	public override void WriteInnerContent(TextWriter writer)
	{
		new H1(writer).Close(Localization.Search);

		// Search form
		using (new Form(writer).WithAction(SearchAPI.Urls.View).WithMethod("get").WithClass("d-flex align-items-center mb-3").End())
		{
			new Input(writer)
				.WithType("text")
				.WithId("searchQuery")
				.WithName(SearchAPI.Query)
				.WithValue(SearchQuery.ToHtml())
				.WithPlaceholder(Localization.SearchPlaceholder)
				.WithClass("form-control me-2")
				.WithStyle("max-width: 50%;")
				.Close();

			new Button(writer).WithType("submit").WithClass("btn btn-primary").Close(Localization.Search);
		}

		if (string.IsNullOrWhiteSpace(SearchQuery))
		{
			new P(writer).Close(Localization.EnterSearchQuery);
			return;
		}

		// Perform search
		var results = PerformSearch(SearchQuery);

		if (results.Count == 0)
		{
			new P(writer).Close(Localization.NoResultsFound);
			return;
		}

		new H2(writer).Close($"{Localization.Results}: {results.Count}");

		// Class filter - only show if there are multiple class types
		var availableClasses = results.Select(r => r.Asset.ClassName).Distinct().Order().ToList();
		if (availableClasses.Count > 1)
		{
			new Label(writer).WithFor("classFilter").WithClass("me-2").Close(Localization.Class);

			using (new Select(writer)
				.WithId("classFilter")
				.WithClass("me-2")
				.End())
			{
				new Option(writer)
					.WithValue(string.Empty)
					.Close(Localization.All);

				foreach (string cn in availableClasses)
				{
					new Option(writer)
						.WithValue(cn)
						.Close(cn);
				}
			}
		}

		// Results table
		using (new Table(writer).WithClass("table").End())
		{
			using (new Thead(writer).End())
			{
				using (new Tr(writer).End())
				{
					new Th(writer).Close(Localization.PathId);
					new Th(writer).Close(Localization.Class);
					new Th(writer).Close(Localization.Name);
					new Th(writer).Close(Localization.Collection);
				}
			}
			using (new Tbody(writer).WithId("resultsTable").End())
			{
				foreach (SearchResult result in results)
				{
					using (new Tr(writer).WithCustomAttribute("data-class", result.Asset.ClassName).End())
					{
						new Td(writer).Close(result.Asset.PathID.ToString());
						new Td(writer).Close(result.Asset.ClassName);
						using (new Td(writer).End())
						{
							PathLinking.WriteLink(writer, result.Path, result.Asset.GetBestName());
						}
						using (new Td(writer).End())
						{
							PathLinking.WriteLink(writer, result.CollectionPath, result.Collection.Name);
						}
					}
				}
			}
		}
	}

	protected override void WriteScriptReferences(TextWriter writer)
	{
		base.WriteScriptReferences(writer);
		
		// Add client-side filtering script
		using (new Script(writer).End())
		{
			writer.Write("""
				document.addEventListener('DOMContentLoaded', function() {
					const classFilter = document.getElementById('classFilter');
					if (classFilter) {
						classFilter.addEventListener('change', function() {
							const selectedClass = this.value;
							const rows = document.querySelectorAll('#resultsTable tr');
							
							rows.forEach(function(row) {
								const rowClass = row.getAttribute('data-class');
								if (selectedClass === '' || rowClass === selectedClass) {
									row.style.display = '';
								} else {
									row.style.display = 'none';
								}
							});
						});
					}
				});
				""");
		}
	}

	private List<SearchResult> PerformSearch(string query)
	{
		List<SearchResult> results = [];
		GameBundle bundle = GameFileLoader.GameBundle;

		foreach (AssetCollection collection in bundle.FetchAssetCollections())
		{
			CollectionPath collectionPath = collection.GetPath();

			foreach (IUnityObjectBase asset in collection)
			{
				if (Match(asset, query))
				{
					results.Add(new SearchResult
					{
						Asset = asset,
						Collection = collection,
						CollectionPath = collectionPath,
						Path = collectionPath.GetAsset(asset.PathID)
					});
				}
			}
		}

		return results;
	}

	private static bool Match(IUnityObjectBase asset, string query)
	{
		// Search in asset name
		string assetName = asset.GetBestName();
		if (assetName.Contains(query, StringComparison.OrdinalIgnoreCase))
		{
			return true;
		}

		// Search in class name
		if (asset.ClassName.Contains(query, StringComparison.OrdinalIgnoreCase))
		{
			return true;
		}

		return false;
	}

	private struct SearchResult
	{
		public required IUnityObjectBase Asset { get; init; }
		public required AssetCollection Collection { get; init; }
		public required CollectionPath CollectionPath { get; init; }
		public required AssetPath Path { get; init; }
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/ConfigurationFilesPage.DataStorageTab.cs`:

```cs
namespace AssetRipper.GUI.Web.Pages.Settings;

public sealed partial class ConfigurationFilesPage
{
	private abstract class DataStorageTab : HtmlTab
	{
		public sealed override void Write(TextWriter writer)
		{
			HtmlTab[] tabs = GetTabs().ToArray();
			using (new Div(writer).WithClass("container").End())
			{
				if (tabs.Length == 0)
				{
					new P(writer).WithClass("text-center p-2").Close(Localization.ThereAreNoKeysForThisDataType);
				}
				else
				{
					using (new Div(writer).WithClass("row").End())
					{
						using (new Div(writer).WithClass("col-3 text-center").End())
						{
							WriteNavigation(writer, tabs, "nav nav-pills flex-column");
						}
						using (new Div(writer).WithClass("col-9").End())
						{
							WriteContent(writer, tabs);
						}
					}
				}
			}
		}

		protected abstract IEnumerable<HtmlTab> GetTabs();
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/ConfigurationFilesPage.ListsTab.cs`:

```cs
using AssetRipper.GUI.Web.Paths;
using AssetRipper.Import.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings;

public sealed partial class ConfigurationFilesPage
{
	private sealed class ListsTab : DataStorageTab
	{
		public static ListsTab Instance { get; } = new();

		public override string DisplayName => Localization.ConfigurationFilesLists;

		protected override IEnumerable<HtmlTab> GetTabs()
		{
			ListDataStorage dataStorage = GameFileLoader.Settings.ListData;
			foreach (string key in dataStorage.Keys)
			{
				yield return new FileListTab(key, dataStorage[key]);
			}
		}

		private sealed class FileListTab(string key, DataSet? list) : HtmlTab
		{
			public override string DisplayName => key;
			public override void Write(TextWriter writer)
			{
				if (list is null or { Count: 0 })
				{
					using (new Div(writer).WithTextCenter().End())
					{
						new P(writer).WithClass("p-2").Close(Localization.NoDataHasBeenLoadedForThisKey);
						using (new Form(writer).WithAction("/ConfigurationFiles/List/Add").WithMethod("post").End())
						{
							new Input(writer).WithType("hidden").WithName("Key").WithValue(key.ToHtml()).Close();
							new Input(writer).WithType("submit").WithClass("btn btn-primary").WithValue(Localization.Load.ToHtml()).Close();
						}
					}
				}
				else
				{
					FileAccordianItem[] items = new FileAccordianItem[list.Count];
					for (int i = 0; i < list.Count; i++)
					{
						items[i] = new FileAccordianItem(key, i, list.Strings[i]);
					}
					Accordian.Write(writer, items);
					using (new Div(writer).WithTextCenter().End())
					{
						using (new Form(writer).WithAction("/ConfigurationFiles/List/Add").WithMethod("post").End())
						{
							new Input(writer).WithType("hidden").WithName("Key").WithValue(key.ToHtml()).Close();
							new Input(writer).WithType("submit").WithClass("btn btn-secondary").WithValue("+").Close();
						}
					}
				}
			}

			private sealed class FileAccordianItem(string key, int index, string text) : AccordianItem
			{
				public override void Write(TextWriter writer)
				{
					new Pre(writer).WithClass("bg-dark-subtle rounded-3 p-2").Close(text);
					using (new Div(writer).WithClass("row text-center").End())
					{
						using (new Div(writer).WithClass("col").End())
						{
							using (new Form(writer).WithAction("/ConfigurationFiles/List/Replace").WithMethod("post").End())
							{
								new Input(writer).WithType("hidden").WithName("Key").WithValue(key.ToHtml()).Close();
								new Input(writer).WithType("hidden").WithName("Index").WithValue(index.ToString()).Close();
								new Input(writer).WithType("submit").WithClass("btn btn-primary mx-1").WithValue(Localization.Replace.ToHtml()).Close();
							}
						}
						using (new Div(writer).WithClass("col").End())
						{
							using (new Form(writer).WithAction("/ConfigurationFiles/List/Remove").WithMethod("post").End())
							{
								new Input(writer).WithType("hidden").WithName("Key").WithValue(key.ToHtml()).Close();
								new Input(writer).WithType("hidden").WithName("Index").WithValue(index.ToString()).Close();
								new Input(writer).WithType("submit").WithClass("btn btn-danger mx-1").WithValue(Localization.Remove.ToHtml()).Close();
							}
						}
					}
				}
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/ConfigurationFilesPage.SingletonsTab.cs`:

```cs
using AssetRipper.GUI.Web.Paths;
using AssetRipper.Import.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings;

public sealed partial class ConfigurationFilesPage
{
	private sealed class SingletonsTab : DataStorageTab
	{
		public static SingletonsTab Instance { get; } = new();

		public override string DisplayName => Localization.ConfigurationFilesSingletons;

		protected override IEnumerable<HtmlTab> GetTabs()
		{
			SingletonDataStorage dataStorage = GameFileLoader.Settings.SingletonData;
			foreach (string key in dataStorage.Keys)
			{
				yield return new FileTab(key, dataStorage[key]?.Text);
			}
		}

		private sealed class FileTab(string key, string? text) : HtmlTab
		{
			public override string DisplayName => key;
			public override void Write(TextWriter writer)
			{
				if (string.IsNullOrEmpty(text))
				{
					using (new Div(writer).WithTextCenter().End())
					{
						new P(writer).WithClass("p-2").Close(Localization.NoDataHasBeenLoadedForThisKey);
						using (new Form(writer).WithAction("/ConfigurationFiles/Singleton/Add").WithMethod("post").End())
						{
							new Input(writer).WithType("hidden").WithName("Key").WithValue(key.ToHtml()).Close();
							new Input(writer).WithType("submit").WithClass("btn btn-primary mx-1").WithValue(Localization.Load.ToHtml()).Close();
						}
					}
				}
				else
				{
					new Pre(writer).WithClass("bg-dark-subtle rounded-3 p-2").Close(text);
					using (new Div(writer).WithClass("row text-center").End())
					{
						using (new Div(writer).WithClass("col").End())
						{
							using (new Form(writer).WithAction("/ConfigurationFiles/Singleton/Add").WithMethod("post").End())
							{
								new Input(writer).WithType("hidden").WithName("Key").WithValue(key.ToHtml()).Close();
								new Input(writer).WithType("submit").WithClass("btn btn-primary mx-1").WithValue(Localization.Replace.ToHtml()).Close();
							}
						}
						using (new Div(writer).WithClass("col").End())
						{
							using (new Form(writer).WithAction("/ConfigurationFiles/Singleton/Remove").WithMethod("post").End())
							{
								new Input(writer).WithType("hidden").WithName("Key").WithValue(key.ToHtml()).Close();
								new Input(writer).WithType("submit").WithClass("btn btn-danger mx-1").WithValue(Localization.Remove.ToHtml()).Close();
							}
						}
					}
				}
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/ConfigurationFilesPage.cs`:

```cs
using AssetRipper.Import.Configuration;
using AssetRipper.NativeDialogs;
using AssetRipper.SourceGenerated.Extensions;
using Microsoft.AspNetCore.Http;

namespace AssetRipper.GUI.Web.Pages.Settings;

public sealed partial class ConfigurationFilesPage : DefaultPage
{
	public static ConfigurationFilesPage Instance { get; } = new();

	public override string? GetTitle() => Localization.ConfigurationFiles;

	public override void WriteInnerContent(TextWriter writer)
	{
		new H1(writer).Close(GetTitle());

		ReadOnlySpan<HtmlTab> tabs = [SingletonsTab.Instance, ListsTab.Instance];
		HtmlTab.WriteNavigation(writer, tabs);
		HtmlTab.WriteContent(writer, tabs);
	}

	public static async Task HandleSingletonAddPostRequest(HttpContext context)
	{
		if (!context.Request.Form.TryGetString("Key", out string? key))
		{
			await Results.BadRequest().ExecuteAsync(context);
			return;
		}

		if (!context.Request.Form.TryGetString("Content", out string? content))
		{
			string? path = await OpenFileDialog.OpenFile();
			if (!string.IsNullOrEmpty(path))
			{
				content = File.ReadAllText(path);
			}
		}

		if (content is not null)
		{
			GameFileLoader.Settings.SingletonData.GetOrAdd(key).Text = content;
		}

		await Results.Redirect("/ConfigurationFiles").ExecuteAsync(context);
	}

	public static Task HandleSingletonRemovePostRequest(HttpContext context)
	{
		if (!context.Request.Form.TryGetString("Key", out string? key))
		{
			return Results.BadRequest().ExecuteAsync(context);
		}

		GameFileLoader.Settings.SingletonData[key]?.Clear();

		return Results.Redirect("/ConfigurationFiles").ExecuteAsync(context);
	}

	public static async Task HandleListAddPostRequest(HttpContext context)
	{
		if (!context.Request.Form.TryGetString("Key", out string? key))
		{
			await Results.BadRequest().ExecuteAsync(context);
			return;
		}

		if (context.Request.Form.TryGetStringArray("Content", out string?[]? contentArray))
		{
			DataSet set = GameFileLoader.Settings.ListData.GetOrAdd(key);
			set.Strings.AddRange(contentArray.WhereNotNull());
		}
		else
		{
			string[]? paths = await OpenFileDialog.OpenFiles();
			if (paths is { Length: > 0 })
			{
				DataSet set = GameFileLoader.Settings.ListData.GetOrAdd(key);
				foreach (string path in paths)
				{
					set.Strings.Add(File.ReadAllText(path));
				}
			}
		}

		await Results.Redirect("/ConfigurationFiles").ExecuteAsync(context);
	}

	public static Task HandleListRemovePostRequest(HttpContext context)
	{
		if (!context.Request.Form.TryGetString("Key", out string? key)
			|| GameFileLoader.Settings.ListData[key] is not { } list
			|| !context.Request.Form.TryGetInteger("Index", out int index)
			|| !list.ContainsIndex(index))
		{
			return Results.BadRequest().ExecuteAsync(context);
		}

		list.RemoveAt(index);

		return Results.Redirect("/ConfigurationFiles").ExecuteAsync(context);
	}

	public static async Task HandleListReplacePostRequest(HttpContext context)
	{
		if (!context.Request.Form.TryGetString("Key", out string? key)
			|| GameFileLoader.Settings.ListData[key] is not { } list
			|| !context.Request.Form.TryGetInteger("Index", out int index)
			|| !list.ContainsIndex(index))
		{
			await Results.BadRequest().ExecuteAsync(context);
			return;
		}

		if (!context.Request.Form.TryGetString("Content", out string? content))
		{
			string? path = await OpenFileDialog.OpenFile();
			if (!string.IsNullOrEmpty(path))
			{
				content = File.ReadAllText(path);
			}
		}

		if (content is not null)
		{
			DataSet.StringAccessor strings = list.Strings;
			strings[index] = content;
		}

		await Results.Redirect("/ConfigurationFiles").ExecuteAsync(context);
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/AudioExportFormatDropDownSetting.cs`:

```cs
using AssetRipper.Export.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public sealed class AudioExportFormatDropDownSetting : DropDownSetting<AudioExportFormat>
{
	public static AudioExportFormatDropDownSetting Instance { get; } = new();

	public override string Title => Localization.AudioExportTitle;

	protected override string GetDisplayName(AudioExportFormat value) => value switch
	{
		AudioExportFormat.Yaml => Localization.AudioFormatYaml,
		AudioExportFormat.Native => Localization.AudioFormatNative,
		AudioExportFormat.PreferWav => Localization.AudioFormatForceWav,
		AudioExportFormat.Default => Localization.AudioFormatDefault,
		_ => base.GetDisplayName(value),
	};

	protected override string? GetDescription(AudioExportFormat value) => value switch
	{
		AudioExportFormat.Yaml => Localization.AudioFormatYamlDescription,
		AudioExportFormat.Native => Localization.AudioFormatNativeDescription,
		AudioExportFormat.PreferWav => Localization.AudioFormatForceWavDescription,
		AudioExportFormat.Default => Localization.AudioFormatDefaultDescription,
		_ => base.GetDescription(value),
	};
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/BundledAssetsExportModeDropDownSetting.cs`:

```cs
using AssetRipper.Processing.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public sealed class BundledAssetsExportModeDropDownSetting : DropDownSetting<BundledAssetsExportMode>
{
	public static BundledAssetsExportModeDropDownSetting Instance { get; } = new();

	public override string Title => Localization.BundledAssetsExportTitle;

	protected override string GetDisplayName(BundledAssetsExportMode value) => value switch
	{
		BundledAssetsExportMode.GroupByAssetType => Localization.BundledAssetsExportGroupByAssetType,
		BundledAssetsExportMode.GroupByBundleName => Localization.BundledAssetsExportGroupByBundleName,
		BundledAssetsExportMode.DirectExport => Localization.BundledAssetsExportDirectExport,
		_ => base.GetDisplayName(value),
	};

	protected override string? GetDescription(BundledAssetsExportMode value) => value switch
	{
		BundledAssetsExportMode.GroupByAssetType => Localization.BundledAssetsExportGroupByAssetTypeDescription,
		BundledAssetsExportMode.GroupByBundleName => Localization.BundledAssetsExportGroupByBundleNameDescription,
		BundledAssetsExportMode.DirectExport => Localization.BundledAssetsExportDirectExportDescription,
		_ => base.GetDescription(value),
	};
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/DropDownItem.cs`:

```cs
namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public readonly record struct DropDownItem<T>(T Value, string DisplayName, string? Description);

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/DropDownSetting.cs`:

```cs
namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public class DropDownSetting<T> where T : struct, Enum
{
	public virtual string Title => typeof(T).Name;

	protected virtual IReadOnlyList<T> Values { get; } = Enum.GetValues<T>();

	protected virtual string GetDisplayName(T value) => Enum.GetName(value) ?? value.ToString();

	protected virtual string? GetDescription(T value) => null;

	public IReadOnlyList<DropDownItem<T>> GetValues()
	{
		DropDownItem<T>[] result = new DropDownItem<T>[Values.Count];
		for (int i = 0; i < Values.Count; i++)
		{
			T value = Values[i];
			result[i] = new(value, GetDisplayName(value), GetDescription(value));
		}
		return result;
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/ImageExportFormatDropDownSetting.cs`:

```cs
using AssetRipper.Export.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public sealed class ImageExportFormatDropDownSetting : DropDownSetting<ImageExportFormat>
{
	public static ImageExportFormatDropDownSetting Instance { get; } = new();

	public override string Title => Localization.ImageExportTitle;

	protected override string? GetDescription(ImageExportFormat value)
	{
		return Localization.ImageFormatDescription;
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/LightmapTextureExportFormatDropDownSetting.cs`:

```cs
using AssetRipper.Export.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public sealed class LightmapTextureExportFormatDropDownSetting : DropDownSetting<LightmapTextureExportFormat>
{
	public static LightmapTextureExportFormatDropDownSetting Instance { get; } = new();

	public override string Title => Localization.LightmapTextureExportTitle;

	protected override string? GetDescription(LightmapTextureExportFormat value)
	{
		return Localization.LightmapTextureFormatDescription;
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/ScriptContentLevelDropDownSetting.cs`:

```cs
using AssetRipper.Import.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public sealed class ScriptContentLevelDropDownSetting : DropDownSetting<ScriptContentLevel>
{
	public static ScriptContentLevelDropDownSetting Instance { get; } = new();

	public override string Title => Localization.ScriptContentLevelTitle;

	protected override string GetDisplayName(ScriptContentLevel value) => value switch
	{
		ScriptContentLevel.Level0 => Localization.ScriptContentLevel0,
		ScriptContentLevel.Level1 => Localization.ScriptContentLevel1,
		ScriptContentLevel.Level2 => Localization.ScriptContentLevel2,
		ScriptContentLevel.Level3 => Localization.ScriptContentLevel3,
		_ => base.GetDisplayName(value),
	};

	protected override string? GetDescription(ScriptContentLevel value) => value switch
	{
		ScriptContentLevel.Level0 => Localization.ScriptContentLevel0Description,
		ScriptContentLevel.Level1 => Localization.ScriptContentLevel1Description,
		ScriptContentLevel.Level2 => Localization.ScriptContentLevel2Description,
		ScriptContentLevel.Level3 => GameFileLoader.Premium
			? Localization.ScriptContentLevel3Description
			: Localization.NotAvailableInTheFreeEdition,
		_ => base.GetDescription(value),
	};
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/ScriptExportModeDropDownSetting.cs`:

```cs
using AssetRipper.Export.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public sealed class ScriptExportModeDropDownSetting : DropDownSetting<ScriptExportMode>
{
	public static ScriptExportModeDropDownSetting Instance { get; } = new();

	public override string Title => Localization.ScriptExportTitle;

	protected override string GetDisplayName(ScriptExportMode value) => value switch
	{
		ScriptExportMode.Decompiled => Localization.ScriptExportFormatDecompiled,
		ScriptExportMode.Hybrid => Localization.ScriptExportFormatHybrid,
		ScriptExportMode.DllExportWithRenaming => Localization.ScriptExportFormatDllWithRenaming,
		ScriptExportMode.DllExportWithoutRenaming => Localization.ScriptExportFormatDllWithoutRenaming,
		_ => base.GetDisplayName(value),
	};

	protected override string? GetDescription(ScriptExportMode value) => value switch
	{
		ScriptExportMode.Decompiled => Localization.ScriptExportFormatDecompiledDescription,
		ScriptExportMode.Hybrid => Localization.ScriptExportFormatHybridDescription,
		ScriptExportMode.DllExportWithRenaming => Localization.NotImplementedYet,
		ScriptExportMode.DllExportWithoutRenaming => Localization.ScriptExportFormatDllWithoutRenamingDescription,
		_ => base.GetDescription(value),
	};
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/ScriptLanguageVersionDropDownSetting.cs`:

```cs
using AssetRipper.Export.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public sealed class ScriptLanguageVersionDropDownSetting : DropDownSetting<ScriptLanguageVersion>
{
	public static ScriptLanguageVersionDropDownSetting Instance { get; } = new();

	public override string Title => Localization.ScriptLanguageVersionTitle;

	protected override string GetDisplayName(ScriptLanguageVersion value) => value switch
	{
		ScriptLanguageVersion.AutoExperimental => Localization.CSharpLangageVersionConfigAutoExperimental,
		ScriptLanguageVersion.AutoSafe => Localization.CSharpLangageVersionConfigAutoSafe,
		ScriptLanguageVersion.CSharp1 => Localization.CSharpLangageVersionConfig1,
		ScriptLanguageVersion.CSharp2 => Localization.CSharpLangageVersionConfig2,
		ScriptLanguageVersion.CSharp3 => Localization.CSharpLangageVersionConfig3,
		ScriptLanguageVersion.CSharp4 => Localization.CSharpLangageVersionConfig4,
		ScriptLanguageVersion.CSharp5 => Localization.CSharpLangageVersionConfig5,
		ScriptLanguageVersion.CSharp6 => Localization.CSharpLangageVersionConfig6,
		ScriptLanguageVersion.CSharp7 => Localization.CSharpLangageVersionConfig7,
		ScriptLanguageVersion.CSharp7_1 => Localization.CSharpLangageVersionConfig71,
		ScriptLanguageVersion.CSharp7_2 => Localization.CSharpLangageVersionConfig72,
		ScriptLanguageVersion.CSharp7_3 => Localization.CSharpLangageVersionConfig73,
		ScriptLanguageVersion.CSharp8_0 => Localization.CSharpLangageVersionConfig80,
		ScriptLanguageVersion.CSharp9_0 => Localization.CSharpLangageVersionConfig90,
		ScriptLanguageVersion.CSharp10_0 => Localization.CSharpLangageVersionConfig100,
		ScriptLanguageVersion.CSharp11_0 => Localization.CSharpLangageVersionConfig110,
		ScriptLanguageVersion.CSharp12_0 => Localization.CSharpLangageVersionConfig120,
		ScriptLanguageVersion.Latest => Localization.CSharpLangageVersionConfigLatest,
		_ => base.GetDisplayName(value),
	};

	protected override string? GetDescription(ScriptLanguageVersion value) => Localization.CSharpLanguageVersionConfigDescription;
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/ShaderExportModeDropDownSetting.cs`:

```cs
using AssetRipper.Export.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public sealed class ShaderExportModeDropDownSetting : DropDownSetting<ShaderExportMode>
{
	public static ShaderExportModeDropDownSetting Instance { get; } = new();

	public override string Title => Localization.ShaderAssetExportTitle;

	protected override string GetDisplayName(ShaderExportMode value) => value switch
	{
		ShaderExportMode.Dummy => Localization.ShaderAssetFormatDummy,
		ShaderExportMode.Yaml => Localization.ShaderAssetFormatYaml,
		ShaderExportMode.Decompile => Localization.ShaderAssetFormatDecompile,
		_ => base.GetDisplayName(value),
	};

	protected override string? GetDescription(ShaderExportMode value) => value switch
	{
		ShaderExportMode.Dummy => Localization.ShaderAssetFormatDummyDescription,
		ShaderExportMode.Yaml => Localization.ShaderAssetFormatYamlDescription,
		ShaderExportMode.Decompile => GameFileLoader.Premium
			? Localization.ShaderAssetFormatDecompileDescription
			: Localization.NotAvailableInTheFreeEdition,
		_ => base.GetDescription(value),
	};
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/SpriteExportModeDropDownSetting.cs`:

```cs
using AssetRipper.Export.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public sealed class SpriteExportModeDropDownSetting : DropDownSetting<SpriteExportMode>
{
	public static SpriteExportModeDropDownSetting Instance { get; } = new();

	public override string Title => Localization.SpriteExportTitle;

	protected override string GetDisplayName(SpriteExportMode value) => value switch
	{
		SpriteExportMode.Yaml => Localization.SpriteFormatYaml,
		SpriteExportMode.Native => Localization.SpriteFormatNative,
		SpriteExportMode.Texture2D => Localization.SpriteFormatTexture,
		_ => base.GetDisplayName(value),
	};

	protected override string? GetDescription(SpriteExportMode value) => value switch
	{
		SpriteExportMode.Yaml => Localization.SpriteFormatYamlDescription,
		SpriteExportMode.Native => Localization.SpriteFormatNativeDescription,
		SpriteExportMode.Texture2D => Localization.SpriteFormatTextureDescription,
		_ => base.GetDescription(value),
	};
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/StreamingAssetsModeDropDownSetting.cs`:

```cs
using AssetRipper.Import.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public sealed class StreamingAssetsModeDropDownSetting : DropDownSetting<StreamingAssetsMode>
{
	public static StreamingAssetsModeDropDownSetting Instance { get; } = new();

	public override string Title => nameof(StreamingAssetsMode);

	protected override string? GetDescription(StreamingAssetsMode value)
	{
		return null;
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/TerrainExportModeDropDownSetting.cs`:

```cs
using AssetRipper.Export.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public sealed class TerrainExportModeDropDownSetting : DropDownSetting<TerrainExportMode>
{
	public static TerrainExportModeDropDownSetting Instance { get; } = new();

	public override string Title => Localization.TerrainExportTitle;

	protected override string GetDisplayName(TerrainExportMode value) => value switch
	{
		TerrainExportMode.Yaml => Localization.TerrainFormatNative,
		TerrainExportMode.Mesh => Localization.TerrainFormatMesh,
		TerrainExportMode.Heatmap => Localization.TerrainFormatHeatmap,
		_ => base.GetDisplayName(value),
	};

	protected override string? GetDescription(TerrainExportMode value) => value switch
	{
		TerrainExportMode.Yaml => Localization.TerrainFormatNativeDescription,
		TerrainExportMode.Mesh => Localization.TerrainFormatMeshDescription,
		TerrainExportMode.Heatmap => Localization.TerrainFormatHeatmapDescription,
		_ => base.GetDescription(value),
	};
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/DropDown/TextExportModeDropDownSetting.cs`:

```cs
using AssetRipper.Export.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings.DropDown;

public sealed class TextExportModeDropDownSetting : DropDownSetting<TextExportMode>
{
	public static TextExportModeDropDownSetting Instance { get; } = new();

	public override string Title => Localization.TextAssetExportTitle;

	protected override string GetDisplayName(TextExportMode value) => value switch
	{
		TextExportMode.Bytes => Localization.TextAssetFormatBinary,
		TextExportMode.Txt => Localization.TextAssetFormatText,
		TextExportMode.Parse => Localization.TextAssetFormatParse,
		_ => base.GetDisplayName(value),
	};

	protected override string? GetDescription(TextExportMode value) => value switch
	{
		TextExportMode.Bytes => Localization.TextAssetFormatBinaryDescription,
		TextExportMode.Txt => Localization.TextAssetFormatTextDescription,
		TextExportMode.Parse => Localization.TextAssetFormatParseDescription,
		_ => base.GetDescription(value),
	};
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/SettingsPage.cs`:

```cs
using AssetRipper.Export.Configuration;
using AssetRipper.GUI.Web.Pages.Settings.DropDown;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.Primitives;
using Microsoft.AspNetCore.Http;

namespace AssetRipper.GUI.Web.Pages.Settings;

public sealed partial class SettingsPage : DefaultPage
{
	public static SettingsPage Instance { get; } = new();

	private static FullConfiguration Configuration => GameFileLoader.Settings;

	public override string GetTitle() => Localization.Settings;

	public override void WriteInnerContent(TextWriter writer)
	{
		new H1(writer).WithClass("text-center").Close(Localization.ConfigOptions);
		if (GameFileLoader.IsLoaded)
		{
			using (new Div(writer).WithClass("text-center").End())
			{
				new P(writer).Close(Localization.SettingsCanOnlyBeChangedBeforeLoadingFiles);
			}
		}
		else
		{
			using (new Form(writer).WithAction("/Settings/Update").WithMethod("post").End())
			{
				using (new Div(writer).WithClass("form-group").End())
				{
					using (new Div(writer).WithClass("border rounded p-3 m-2").End())
					{
						new H2(writer).Close(Localization.MenuImport);

						using (new Div(writer).End())
						{
							using (new Div(writer).WithClass("row").End())
							{
								using (new Div(writer).WithClass("col").End())
								{
									WriteCheckBoxForIgnoreStreamingAssets(writer, Localization.SkipStreamingAssets);
								}
								using (new Div(writer).WithClass("col").End())
								{
									WriteCheckBoxForEnableStaticMeshSeparation(writer, Localization.EnableStaticMeshSeparation, !GameFileLoader.Premium);
								}
							}

							using (new Div(writer).WithClass("row").End())
							{
								using (new Div(writer).WithClass("col").End())
								{
									WriteCheckBoxForRemoveNullableAttributes(writer, Localization.RemoveNullableAttributes);
								}
								using (new Div(writer).WithClass("col").End())
								{
									WriteCheckBoxForPublicizeAssemblies(writer, Localization.PublicizeAssemblies);
								}
							}

							using (new Div(writer).WithClass("row").End())
							{
								using (new Div(writer).WithClass("col").End())
								{
									WriteTextAreaForDefaultVersion(writer);
								}
							}

							using (new Div(writer).WithClass("row").End())
							{
								using (new Div(writer).WithClass("col").End())
								{
									WriteDropDownForBundledAssetsExportMode(writer);
								}
								using (new Div(writer).WithClass("col").End())
								{
									WriteDropDownForScriptContentLevel(writer);
								}
							}
						}

						new Hr(writer).Close();

						using (new Div(writer).End())
						{
							new H3(writer).Close(Localization.Experimental);

							using (new Div(writer).WithClass("row").End())
							{
								using (new Div(writer).WithClass("col").End())
								{
									WriteCheckBoxForEnablePrefabOutlining(writer, Localization.EnablePrefabOutlining);
								}
								using (new Div(writer).WithClass("col").End())
								{
									WriteCheckBoxForEnableAssetDeduplication(writer, Localization.EnableAssetDeduplication, !GameFileLoader.Premium);
								}
							}

							using (new Div(writer).WithClass("row").End())
							{
								using (new Div(writer).WithClass("col").End())
								{
									WriteTextAreaForTargetVersion(writer);
								}
							}
						}
					}

					using (new Div(writer).WithClass("border rounded p-3 m-2").End())
					{
						new H2(writer).Close(Localization.MenuExport);

						using (new Div(writer).End())
						{
							using (new Div(writer).WithClass("row").End())
							{
								using (new Div(writer).WithClass("col").End())
								{
									WriteDropDownForAudioExportFormat(writer);
								}
								using (new Div(writer).WithClass("col").End())
								{
									WriteDropDownForImageExportFormat(writer);
								}
								using (new Div(writer).WithClass("col").End())
								{
									WriteDropDownForLightmapTextureExportFormat(writer);
								}
							}

							using (new Div(writer).WithClass("row").End())
							{
								using (new Div(writer).WithClass("col").End())
								{
									WriteDropDownForSpriteExportMode(writer);
								}
								using (new Div(writer).WithClass("col").End())
								{
									WriteDropDownForShaderExportMode(writer);
								}
								using (new Div(writer).WithClass("col").End())
								{
									WriteDropDownForTextExportMode(writer);
								}
							}

							using (new Div(writer).WithClass("row").End())
							{
								using (new Div(writer).WithClass("col").End())
								{
									WriteDropDownForScriptLanguageVersion(writer);
								}
								using (new Div(writer).WithClass("col").End())
								{
									WriteDropDownForScriptExportMode(writer);
								}
								using (new Div(writer).WithClass("col").End())
								{
								}
							}

							using (new Div(writer).WithClass("row").End())
							{
								using (new Div(writer).WithClass("col").End())
								{
									WriteCheckBoxForScriptTypesFullyQualified(writer, Localization.ScriptsUseFullyQualifiedTypeNames);
								}
								using (new Div(writer).WithClass("col").End())
								{
									WriteCheckBoxForSaveSettingsToDisk(writer, Localization.SaveSettingsToDisk);
								}
								using (new Div(writer).WithClass("col").End())
								{
									WriteCheckBoxForExportUnreadableAssets(writer, Localization.ExportUnreadableAssets);
								}
							}
						}
					}

					using (new Div(writer).WithClass("text-center").End())
					{
						new Input(writer).WithType("submit").WithValue(Localization.Save).Close();
					}
				}
			}
		}
	}

	private static void WriteTextAreaForDefaultVersion(TextWriter writer)
	{
		new Label(writer).WithClass("form-label").WithFor(nameof(Configuration.ImportSettings.DefaultVersion)).Close(Localization.DefaultVersion);
		new Input(writer)
			.WithType("text")
			.WithClass("form-control")
			.WithId(nameof(Configuration.ImportSettings.DefaultVersion))
			.WithName(nameof(Configuration.ImportSettings.DefaultVersion))
			.WithValue(Configuration.ImportSettings.DefaultVersion.ToString())
			.Close();
	}

	private static void WriteTextAreaForTargetVersion(TextWriter writer)
	{
		new Label(writer).WithClass("form-label").WithFor(nameof(Configuration.ImportSettings.TargetVersion)).Close(Localization.TargetVersionForVersionChanging);
		new Input(writer)
			.WithType("text")
			.WithClass("form-control")
			.WithId(nameof(Configuration.ImportSettings.TargetVersion))
			.WithName(nameof(Configuration.ImportSettings.TargetVersion))
			.WithValue(Configuration.ImportSettings.TargetVersion.ToString())
			.Close();
	}

	private static void WriteCheckBox(TextWriter writer, string label, bool @checked, string id, bool disabled = false)
	{
		using (new Div(writer).WithClass("form-check").End())
		{
			new Input(writer)
				.WithClass("form-check-input")
				.WithType("checkbox")
				.WithValue()
				.WithId(id)
				.WithName(id)
				.MaybeWithChecked(disabled ? false : @checked)
				.MaybeWithDisabled(disabled)
				.Close();
			new Label(writer)
				.WithClass("form-check-label" + (disabled ? " text-muted" : ""))
				.WithFor(id)
				.Close(label + (disabled ? $" ({Localization.PremiumFeatureNotice})" : ""));
		}
	}

	private static void WriteDropDown<T>(TextWriter writer, DropDownSetting<T> setting, T value, string id) where T : struct, Enum
	{
		IReadOnlyList<DropDownItem<T>> items = setting.GetValues();
		new Label(writer).WithClass("form-label").WithFor(id).Close(setting.Title);
		using (new Select(writer).WithClass("form-select").WithName(id).End())
		{
			for (int i = 0; i < items.Count; i++)
			{
				DropDownItem<T> item = items[i];
				new Option(writer)
					.WithValue(item.Value.ToString().ToHtml())
					.MaybeWithSelected(EqualityComparer<T>.Default.Equals(item.Value, value))
					.WithCustomAttribute("option-description", CreateUniqueID(id, i))
					.Close(item.DisplayName);
			}
		}

		for (int i = 0; i < items.Count; i++)
		{
			DropDownItem<T> item = items[i];
			new P(writer)
				.WithClass("dropdown-description")//Used for CSS selecting
				.WithId(CreateUniqueID(id, i))
				.Close(item.Description);
		}

		static string CreateUniqueID(string selectID, int index)
		{
			return $"{selectID}_description_{index}";
		}
	}

	private static UnityVersion TryParseUnityVersion(string? version)
	{
		if (string.IsNullOrEmpty(version))
		{
			return default;
		}
		try
		{
			return UnityVersion.Parse(version);
		}
		catch
		{
			return default;
		}
	}

	private static T TryParseEnum<T>(string? s) where T : struct, Enum
	{
		if (Enum.TryParse(s, out T result))
		{
			return result;
		}
		return default;
	}

	public static Task HandlePostRequest(HttpContext context)
	{
		IFormCollection form = context.Request.Form;
		foreach ((string key, Action<bool> action) in booleanProperties)
		{
			action.Invoke(form.ContainsKey(key));
		}
		foreach ((string key, string? value) in form.Select(pair => (pair.Key, (string?)pair.Value)))
		{
			SetProperty(key, value);
		}

		if (Configuration.SaveSettingsToDisk)
		{
			Configuration.SaveToDefaultPath();
		}
		else
		{
			SerializedSettings.DeleteDefaultPath();
		}

		context.Response.Redirect("/Settings/Edit");
		return Task.CompletedTask;
	}
}

```

`Source/AssetRipper.GUI.Web/Pages/Settings/SettingsPage.g.cs`:

```cs
// Auto-generated code. Do not modify manually.

using AssetRipper.Export.Configuration;
using AssetRipper.GUI.Web.Pages.Settings.DropDown;
using AssetRipper.Import.Configuration;
using AssetRipper.Processing.Configuration;

namespace AssetRipper.GUI.Web.Pages.Settings;

#nullable enable

partial class SettingsPage
{
	private static void SetProperty(string key, string? value)
	{
		switch (key)
		{
			case nameof(ImportSettings.ScriptContentLevel):
				Configuration.ImportSettings.ScriptContentLevel = TryParseEnum<ScriptContentLevel>(value);
				break;
			case nameof(ImportSettings.StreamingAssetsMode):
				Configuration.ImportSettings.StreamingAssetsMode = TryParseEnum<StreamingAssetsMode>(value);
				break;
			case nameof(ImportSettings.DefaultVersion):
				Configuration.ImportSettings.DefaultVersion = TryParseUnityVersion(value);
				break;
			case nameof(ImportSettings.TargetVersion):
				Configuration.ImportSettings.TargetVersion = TryParseUnityVersion(value);
				break;
			case nameof(ProcessingSettings.BundledAssetsExportMode):
				Configuration.ProcessingSettings.BundledAssetsExportMode = TryParseEnum<BundledAssetsExportMode>(value);
				break;
			case nameof(ExportSettings.AudioExportFormat):
				Configuration.ExportSettings.AudioExportFormat = TryParseEnum<AudioExportFormat>(value);
				break;
			case nameof(ExportSettings.ImageExportFormat):
				Configuration.ExportSettings.ImageExportFormat = TryParseEnum<ImageExportFormat>(value);
				break;
			case nameof(ExportSettings.LightmapTextureExportFormat):
				Configuration.ExportSettings.LightmapTextureExportFormat = TryParseEnum<LightmapTextureExportFormat>(value);
				break;
			case nameof(ExportSettings.ScriptExportMode):
				Configuration.ExportSettings.ScriptExportMode = TryParseEnum<ScriptExportMode>(value);
				break;
			case nameof(ExportSettings.ScriptLanguageVersion):
				Configuration.ExportSettings.ScriptLanguageVersion = TryParseEnum<ScriptLanguageVersion>(value);
				break;
			case nameof(ExportSettings.ShaderExportMode):
				Configuration.ExportSettings.ShaderExportMode = TryParseEnum<ShaderExportMode>(value);
				break;
			case nameof(ExportSettings.SpriteExportMode):
				Configuration.ExportSettings.SpriteExportMode = TryParseEnum<SpriteExportMode>(value);
				break;
			case nameof(ExportSettings.TextExportMode):
				Configuration.ExportSettings.TextExportMode = TryParseEnum<TextExportMode>(value);
				break;
			case nameof(ExportSettings.LanguageCode):
				Configuration.ExportSettings.LanguageCode = value;
				break;
		}
	}

	private static readonly Dictionary<string, Action<bool>> booleanProperties = new()
	{
		{ nameof(ImportSettings.IgnoreStreamingAssets), (value) => { Configuration.ImportSettings.IgnoreStreamingAssets = value; } },
		{ nameof(ProcessingSettings.EnablePrefabOutlining), (value) => { Configuration.ProcessingSettings.EnablePrefabOutlining = value; } },
		{ nameof(ProcessingSettings.EnableStaticMeshSeparation), (value) => { Configuration.ProcessingSettings.EnableStaticMeshSeparation = value; } },
		{ nameof(ProcessingSettings.EnableAssetDeduplication), (value) => { Configuration.ProcessingSettings.EnableAssetDeduplication = value; } },
		{ nameof(ProcessingSettings.RemoveNullableAttributes), (value) => { Configuration.ProcessingSettings.RemoveNullableAttributes = value; } },
		{ nameof(ProcessingSettings.PublicizeAssemblies), (value) => { Configuration.ProcessingSettings.PublicizeAssemblies = value; } },
		{ nameof(ExportSettings.ScriptTypesFullyQualified), (value) => { Configuration.ExportSettings.ScriptTypesFullyQualified = value; } },
		{ nameof(ExportSettings.ExportUnreadableAssets), (value) => { Configuration.ExportSettings.ExportUnreadableAssets = value; } },
		{ nameof(ExportSettings.SaveSettingsToDisk), (value) => { Configuration.ExportSettings.SaveSettingsToDisk = value; } },
	};

	private static void WriteDropDownForScriptContentLevel(TextWriter writer)
	{
		WriteDropDown(writer, ScriptContentLevelDropDownSetting.Instance, Configuration.ImportSettings.ScriptContentLevel, nameof(ImportSettings.ScriptContentLevel));
	}

	private static void WriteCheckBoxForIgnoreStreamingAssets(TextWriter writer, string label, bool disabled = false)
	{
		WriteCheckBox(writer, label, Configuration.ImportSettings.IgnoreStreamingAssets, nameof(ImportSettings.IgnoreStreamingAssets), disabled);
	}

	private static void WriteDropDownForStreamingAssetsMode(TextWriter writer)
	{
		WriteDropDown(writer, StreamingAssetsModeDropDownSetting.Instance, Configuration.ImportSettings.StreamingAssetsMode, nameof(ImportSettings.StreamingAssetsMode));
	}

	private static void WriteCheckBoxForEnablePrefabOutlining(TextWriter writer, string label, bool disabled = false)
	{
		WriteCheckBox(writer, label, Configuration.ProcessingSettings.EnablePrefabOutlining, nameof(ProcessingSettings.EnablePrefabOutlining), disabled);
	}

	private static void WriteCheckBoxForEnableStaticMeshSeparation(TextWriter writer, string label, bool disabled = false)
	{
		WriteCheckBox(writer, label, Configuration.ProcessingSettings.EnableStaticMeshSeparation, nameof(ProcessingSettings.EnableStaticMeshSeparation), disabled);
	}

	private static void WriteCheckBoxForEnableAssetDeduplication(TextWriter writer, string label, bool disabled = false)
	{
		WriteCheckBox(writer, label, Configuration.ProcessingSettings.EnableAssetDeduplication, nameof(ProcessingSettings.EnableAssetDeduplication), disabled);
	}

	private static void WriteCheckBoxForRemoveNullableAttributes(TextWriter writer, string label, bool disabled = false)
	{
		WriteCheckBox(writer, label, Configuration.ProcessingSettings.RemoveNullableAttributes, nameof(ProcessingSettings.RemoveNullableAttributes), disabled);
	}

	private static void WriteCheckBoxForPublicizeAssemblies(TextWriter writer, string label, bool disabled = false)
	{
		WriteCheckBox(writer, label, Configuration.ProcessingSettings.PublicizeAssemblies, nameof(ProcessingSettings.PublicizeAssemblies), disabled);
	}

	private static void WriteDropDownForBundledAssetsExportMode(TextWriter writer)
	{
		WriteDropDown(writer, BundledAssetsExportModeDropDownSetting.Instance, Configuration.ProcessingSettings.BundledAssetsExportMode, nameof(ProcessingSettings.BundledAssetsExportMode));
	}

	private static void WriteDropDownForAudioExportFormat(TextWriter writer)
	{
		WriteDropDown(writer, AudioExportFormatDropDownSetting.Instance, Configuration.ExportSettings.AudioExportFormat, nameof(ExportSettings.AudioExportFormat));
	}

	private static void WriteDropDownForImageExportFormat(TextWriter writer)
	{
		WriteDropDown(writer, ImageExportFormatDropDownSetting.Instance, Configuration.ExportSettings.ImageExportFormat, nameof(ExportSettings.ImageExportFormat));
	}

	private static void WriteDropDownForLightmapTextureExportFormat(TextWriter writer)
	{
		WriteDropDown(writer, LightmapTextureExportFormatDropDownSetting.Instance, Configuration.ExportSettings.LightmapTextureExportFormat, nameof(ExportSettings.LightmapTextureExportFormat));
	}

	private static void WriteDropDownForScriptExportMode(TextWriter writer)
	{
		WriteDropDown(writer, ScriptExportModeDropDownSetting.Instance, Configuration.ExportSettings.ScriptExportMode, nameof(ExportSettings.ScriptExportMode));
	}

	private static void WriteDropDownForScriptLanguageVersion(TextWriter writer)
	{
		WriteDropDown(writer, ScriptLanguageVersionDropDownSetting.Instance, Configuration.ExportSettings.ScriptLanguageVersion, nameof(ExportSettings.ScriptLanguageVersion));
	}

	private static void WriteCheckBoxForScriptTypesFullyQualified(TextWriter writer, string label, bool disabled = false)
	{
		WriteCheckBox(writer, label, Configuration.ExportSettings.ScriptTypesFullyQualified, nameof(ExportSettings.ScriptTypesFullyQualified), disabled);
	}

	private static void WriteDropDownForShaderExportMode(TextWriter writer)
	{
		WriteDropDown(writer, ShaderExportModeDropDownSetting.Instance, Configuration.ExportSettings.ShaderExportMode, nameof(ExportSettings.ShaderExportMode));
	}

	private static void WriteDropDownForSpriteExportMode(TextWriter writer)
	{
		WriteDropDown(writer, SpriteExportModeDropDownSetting.Instance, Configuration.ExportSettings.SpriteExportMode, nameof(ExportSettings.SpriteExportMode));
	}

	private static void WriteDropDownForTextExportMode(TextWriter writer)
	{
		WriteDropDown(writer, TextExportModeDropDownSetting.Instance, Configuration.ExportSettings.TextExportMode, nameof(ExportSettings.TextExportMode));
	}

	private static void WriteCheckBoxForExportUnreadableAssets(TextWriter writer, string label, bool disabled = false)
	{
		WriteCheckBox(writer, label, Configuration.ExportSettings.ExportUnreadableAssets, nameof(ExportSettings.ExportUnreadableAssets), disabled);
	}

	private static void WriteCheckBoxForSaveSettingsToDisk(TextWriter writer, string label, bool disabled = false)
	{
		WriteCheckBox(writer, label, Configuration.ExportSettings.SaveSettingsToDisk, nameof(ExportSettings.SaveSettingsToDisk), disabled);
	}
}

```

`Source/AssetRipper.GUI.Web/Paths/AssetPath.cs`:

```cs
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AssetRipper.GUI.Web.Paths;

public readonly record struct AssetPath([property: JsonPropertyName("C")] CollectionPath CollectionPath, [property: JsonPropertyName("D")] long PathID) : IPath<AssetPath>
{
	public string ToJson()
	{
		return JsonSerializer.Serialize(this, PathSerializerContext.Default.AssetPath);
	}

	public static AssetPath FromJson(string json)
	{
		return JsonSerializer.Deserialize(json, PathSerializerContext.Default.AssetPath);
	}
}

```

`Source/AssetRipper.GUI.Web/Paths/BundlePath.cs`:

```cs
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AssetRipper.GUI.Web.Paths;

public readonly struct BundlePath : IPath<BundlePath>, IEquatable<BundlePath>
{
	private readonly int[]? _path;

	private BundlePath(int[]? path)
	{
		_path = path;
	}

	public BundlePath(ReadOnlySpan<int> path)
	{
		_path = path.Length == 0 ? null : path.ToArray();
	}

	[JsonConstructor]
	public BundlePath(ReadOnlyMemory<int> path)
	{
		_path = path.Length == 0 ? null : path.ToArray();
	}

	[JsonPropertyName("P")]
	public ReadOnlyMemory<int> Path => _path;

	[JsonIgnore]
	public ReadOnlySpan<int> Span => _path;

	[JsonIgnore]
	public int Depth => Path.Length;

	[JsonIgnore]
	public bool IsRoot => Depth == 0;

	/// <summary>
	/// Get the path of the parent bundle.
	/// </summary>
	/// <remarks>
	/// If <see cref="IsRoot"/>, then this will return <see langword="default"/>.
	/// </remarks>
	[JsonIgnore]
	public BundlePath Parent => Depth > 1 ? new BundlePath(Path.Span[..^1]) : default;

	public BundlePath GetChild(int index)
	{
		int[] path;
		if (_path is null)
		{
			path = [index];
		}
		else
		{
			path = new int[_path.Length + 1];
			_path.CopyTo((Span<int>)path);
			path[^1] = index;
		}
		return new BundlePath(path);
	}

	public CollectionPath GetCollection(int index)
	{
		return new CollectionPath(this, index);
	}

	public FailedFilePath GetFailedFile(int index)
	{
		return new FailedFilePath(this, index);
	}

	public ResourcePath GetResource(int index)
	{
		return new ResourcePath(this, index);
	}

	public static implicit operator ReadOnlySpan<int>(BundlePath path) => path.Span;

	public static bool operator ==(BundlePath left, BundlePath right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(BundlePath left, BundlePath right)
	{
		return !(left == right);
	}

	public string ToJson()
	{
		return JsonSerializer.Serialize(this, PathSerializerContext.Default.BundlePath);
	}

	public static BundlePath FromJson(string json)
	{
		return JsonSerializer.Deserialize(json, PathSerializerContext.Default.BundlePath);
	}

	public override string ToString() => ToJson();

	public override bool Equals(object? obj)
	{
		return obj is BundlePath path && Equals(path);
	}

	public bool Equals(BundlePath other)
	{
		return Span.SequenceEqual(other.Span);
	}

	public override int GetHashCode()
	{
		HashCode code = new();
		foreach (int item in Span)
		{
			code.Add(item);
		}
		return code.ToHashCode();
	}
}

```

`Source/AssetRipper.GUI.Web/Paths/CollectionPath.cs`:

```cs
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AssetRipper.GUI.Web.Paths;

public readonly record struct CollectionPath([property: JsonPropertyName("B")] BundlePath BundlePath, [property: JsonPropertyName("I")] int Index) : IPath<CollectionPath>
{
	public AssetPath GetAsset(long pathID)
	{
		return new(this, pathID);
	}

	public string ToJson()
	{
		return JsonSerializer.Serialize(this, PathSerializerContext.Default.CollectionPath);
	}

	public static CollectionPath FromJson(string json)
	{
		return JsonSerializer.Deserialize(json, PathSerializerContext.Default.CollectionPath);
	}
}

```

`Source/AssetRipper.GUI.Web/Paths/FailedFilePath.cs`:

```cs
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AssetRipper.GUI.Web.Paths;

public readonly record struct FailedFilePath([property: JsonPropertyName("B")] BundlePath BundlePath, [property: JsonPropertyName("I")] int Index) : IPath<FailedFilePath>
{
	public string ToJson()
	{
		return JsonSerializer.Serialize(this, PathSerializerContext.Default.FailedFilePath);
	}

	public static FailedFilePath FromJson(string json)
	{
		return JsonSerializer.Deserialize(json, PathSerializerContext.Default.FailedFilePath);
	}
}

```

`Source/AssetRipper.GUI.Web/Paths/IPath.cs`:

```cs
namespace AssetRipper.GUI.Web.Paths;

public interface IPath<TSelf>
{
	string ToJson();
	static abstract TSelf FromJson(string json);
}

```

`Source/AssetRipper.GUI.Web/Paths/PathExtensions.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.ResourceFiles;

namespace AssetRipper.GUI.Web.Paths;

public static class PathExtensions
{
	public static BundlePath GetPath(this Bundle bundle)
	{
		int count = 0;
		{
			Bundle? current = bundle;
			while (current.Parent is not null)
			{
				count++;
				current = current.Parent;
			}
		}

		if (count == 0)
		{
			return new();
		}

		Span<int> path = count < 1024 ? stackalloc int[count] : new int[count];//It should never even come close to 1024.
		{
			Bundle current = bundle;
			for (int i = count - 1; ; i--)
			{
				if (current.Parent is not null)
				{
					path[i] = current.Parent.Bundles.IndexOf(current);
					current = current.Parent;
				}
				else
				{
					break;
				}
			}
		}
		return new BundlePath(path);
	}

	public static CollectionPath GetPath(this AssetCollection collection)
	{
		return new CollectionPath(collection.Bundle.GetPath(), collection.Bundle.Collections.IndexOf(collection));
	}

	public static AssetPath GetPath(this IUnityObjectBase asset)
	{
		return new AssetPath(asset.Collection.GetPath(), asset.PathID);
	}

	private static int IndexOf<T>(this IReadOnlyList<T> list, T item)
	{
		for (int i = 0; i < list.Count; i++)
		{
			if (EqualityComparer<T>.Default.Equals(list[i], item))
			{
				return i;
			}
		}
		return -1;
	}

	public static Bundle? TryGetBundle(this GameBundle gameBundle, BundlePath path)
	{
		Bundle current = gameBundle;
		foreach (int index in (ReadOnlySpan<int>)path)
		{
			if (index < 0 || index >= current.Bundles.Count)
			{
				return null;
			}
			current = current.Bundles[index];
		}
		return current;
	}

	public static bool TryGetBundle(this GameBundle gameBundle, BundlePath path, [NotNullWhen(true)] out Bundle? bundle)
	{
		bundle = gameBundle.TryGetBundle(path);
		return bundle is not null;
	}

	public static AssetCollection? TryGetCollection(this GameBundle gameBundle, CollectionPath path)
	{
		Bundle? bundle = gameBundle.TryGetBundle(path.BundlePath);
		if (bundle is null || path.Index < 0 || path.Index >= bundle.Collections.Count)
		{
			return null;
		}
		return bundle.Collections[path.Index];
	}

	public static bool TryGetCollection(this GameBundle gameBundle, CollectionPath path, [NotNullWhen(true)] out AssetCollection? collection)
	{
		collection = gameBundle.TryGetCollection(path);
		return collection is not null;
	}

	public static ResourceFile? TryGetResource(this GameBundle gameBundle, ResourcePath path)
	{
		Bundle? bundle = gameBundle.TryGetBundle(path.BundlePath);
		if (bundle is null || path.Index < 0 || path.Index >= bundle.Resources.Count)
		{
			return null;
		}
		return bundle.Resources[path.Index];
	}

	public static bool TryGetResource(this GameBundle gameBundle, ResourcePath path, [NotNullWhen(true)] out ResourceFile? resource)
	{
		resource = gameBundle.TryGetResource(path);
		return resource is not null;
	}

	public static FailedFile? TryGetFailedFile(this GameBundle gameBundle, FailedFilePath path)
	{
		Bundle? bundle = gameBundle.TryGetBundle(path.BundlePath);
		if (bundle is null || path.Index < 0 || path.Index >= bundle.FailedFiles.Count)
		{
			return null;
		}
		return bundle.FailedFiles[path.Index];
	}

	public static bool TryGetFailedFile(this GameBundle gameBundle, FailedFilePath path, [NotNullWhen(true)] out FailedFile? failedFile)
	{
		failedFile = gameBundle.TryGetFailedFile(path);
		return failedFile is not null;
	}

	public static IUnityObjectBase? TryGetAsset(this GameBundle gameBundle, AssetPath path)
	{
		AssetCollection? collection = gameBundle.TryGetCollection(path.CollectionPath);
		if (collection is null)
		{
			return null;
		}
		// Can't use TryGetAsset because that returns null for NullObject objects.
		return collection.Assets.TryGetValue(path.PathID, out IUnityObjectBase? asset) ? asset : null;
	}

	public static bool TryGetAsset(this GameBundle gameBundle, AssetPath path, [NotNullWhen(true)] out IUnityObjectBase? asset)
	{
		asset = gameBundle.TryGetAsset(path);
		return asset is not null;
	}
}

```

`Source/AssetRipper.GUI.Web/Paths/PathLinking.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.GUI.Web.Pages.Assets;
using AssetRipper.GUI.Web.Pages.Bundles;
using AssetRipper.GUI.Web.Pages.Collections;
using AssetRipper.GUI.Web.Pages.FailedFiles;
using AssetRipper.GUI.Web.Pages.Resources;
using AssetRipper.GUI.Web.Pages.Scenes;
using System.Runtime.CompilerServices;

namespace AssetRipper.GUI.Web.Paths;

internal static class PathLinking
{
	private const string DefaultClasses = "btn btn-dark p-0 m-0";

	public static void WriteLink(TextWriter writer, Bundle bundle, string? name = null, string? @class = DefaultClasses)
	{
		WriteLink(writer, bundle.GetPath(), name is not null ? name : bundle.Name, @class);
	}

	public static void WriteLink(TextWriter writer, AssetCollection collection, string? name = null, string? @class = DefaultClasses)
	{
		WriteLink(writer, collection.GetPath(), name is not null ? name : collection.Name, @class);
	}

	public static void WriteLink(TextWriter writer, IUnityObjectBase asset, string? name = null, string? @class = DefaultClasses)
	{
		WriteLink(writer, asset.GetPath(), name is not null ? name : asset.GetBestName(), @class);
	}

	public static void WriteLink<T>(TextWriter writer, T path, string name, string? @class = DefaultClasses) where T : IPath<T>
	{
		new A(writer).WithHref(GetUrl(path)).MaybeWithClass(@class).Close(name);
	}

	private static string GetUrl<T>(T path) where T : IPath<T>
	{
		if (typeof(T) == typeof(AssetPath))
		{
			return AssetAPI.GetViewUrl(Unsafe.As<T, AssetPath>(ref path));
		}
		else if (typeof(T) == typeof(CollectionPath))
		{
			return CollectionAPI.GetViewUrl(Unsafe.As<T, CollectionPath>(ref path));
		}
		else if (typeof(T) == typeof(ScenePath))
		{
			return SceneAPI.GetViewUrl(Unsafe.As<T, ScenePath>(ref path));
		}
		else if (typeof(T) == typeof(BundlePath))
		{
			return BundleAPI.GetViewUrl(Unsafe.As<T, BundlePath>(ref path));
		}
		else if (typeof(T) == typeof(ResourcePath))
		{
			return ResourceAPI.GetViewUrl(Unsafe.As<T, ResourcePath>(ref path));
		}
		else if (typeof(T) == typeof(FailedFilePath))
		{
			return FailedFileAPI.GetViewUrl(Unsafe.As<T, FailedFilePath>(ref path));
		}
		else
		{
			return "";//Exceptions prevent inlining
		}
	}

	private static A MaybeWithClass(this A @this, string? @class)
	{
		return @class is null ? @this : @this.WithClass(@class);
	}
}

```

`Source/AssetRipper.GUI.Web/Paths/PathSerializerContext.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.GUI.Web.Paths;

[JsonSerializable(typeof(AssetPath))]
[JsonSerializable(typeof(BundlePath))]
[JsonSerializable(typeof(CollectionPath))]
[JsonSerializable(typeof(ScenePath))]
[JsonSerializable(typeof(ResourcePath))]
[JsonSerializable(typeof(FailedFilePath))]
internal sealed partial class PathSerializerContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.GUI.Web/Paths/ResourcePath.cs`:

```cs
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AssetRipper.GUI.Web.Paths;

public readonly record struct ResourcePath([property: JsonPropertyName("B")] BundlePath BundlePath, [property: JsonPropertyName("I")] int Index) : IPath<ResourcePath>
{
	public string ToJson()
	{
		return JsonSerializer.Serialize(this, PathSerializerContext.Default.ResourcePath);
	}

	public static ResourcePath FromJson(string json)
	{
		return JsonSerializer.Deserialize(json, PathSerializerContext.Default.ResourcePath);
	}
}

```

`Source/AssetRipper.GUI.Web/Paths/ScenePath.cs`:

```cs
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AssetRipper.GUI.Web.Paths;

public readonly record struct ScenePath([property: JsonPropertyName("C")] CollectionPath FirstCollection) : IPath<ScenePath>
{
	public static explicit operator ScenePath(CollectionPath first) => new ScenePath(first);

	public string ToJson()
	{
		return JsonSerializer.Serialize(this, PathSerializerContext.Default.ScenePath);
	}

	public static ScenePath FromJson(string json)
	{
		return JsonSerializer.Deserialize(json, PathSerializerContext.Default.ScenePath);
	}
}

```

`Source/AssetRipper.GUI.Web/Paths/StringExtensions.cs`:

```cs
using System.Net;

namespace AssetRipper.GUI.Web.Paths;

internal static class StringExtensions
{
	[return: NotNullIfNotNull(nameof(value))]
	public static string? ToHtml(this string? value) => WebUtility.HtmlEncode(value);
	[return: NotNullIfNotNull(nameof(value))]
	public static string? ToUrl(this string? value) => WebUtility.UrlEncode(value);
}

```

`Source/AssetRipper.GUI.Web/RoutingExtensions.cs`:

```cs
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Routing;

namespace AssetRipper.GUI.Web;

internal static class RoutingExtensions
{
	internal static RouteHandlerBuilder MapGet(this IEndpointRouteBuilder endpoints, [StringSyntax("Route")] string pattern, RequestDelegate requestDelegate)
	{
		// RouteHandlerBuilder is always returned from this method.
		// We cast it, so we can access Produces<T> and similar methods.
		RouteHandlerBuilder mapped = (RouteHandlerBuilder)EndpointRouteBuilderExtensions.MapGet(endpoints, pattern, requestDelegate);

		// We need to add MethodInfo to the metadata, so that it will be used in the api explorer.
		// https://github.com/dotnet/aspnetcore/issues/44005#issuecomment-1248717069
		// https://github.com/dotnet/aspnetcore/issues/44970
		return mapped.WithMetadata(requestDelegate.Method);
	}

	internal static RouteHandlerBuilder MapPost(this IEndpointRouteBuilder endpoints, [StringSyntax("Route")] string pattern, RequestDelegate requestDelegate)
	{
		// RouteHandlerBuilder is always returned from this method.
		// We cast it, so we can access Produces<T> and similar methods.
		RouteHandlerBuilder mapped = (RouteHandlerBuilder)EndpointRouteBuilderExtensions.MapPost(endpoints, pattern, requestDelegate);

		// We need to add MethodInfo to the metadata, so that it will be used in the api explorer.
		// https://github.com/dotnet/aspnetcore/issues/44005#issuecomment-1248717069
		// https://github.com/dotnet/aspnetcore/issues/44970
		return mapped.WithMetadata(requestDelegate.Method);
	}

	internal static RouteHandlerBuilder MapGet(this IEndpointRouteBuilder endpoints, [StringSyntax("Route")] string pattern, Func<IResult> handler)
	{
		return endpoints.MapGet(pattern, (context) =>
		{
			IResult result = handler.Invoke();
			return result.ExecuteAsync(context);
		});
	}

	internal static RouteHandlerBuilder MapStaticFile(this IEndpointRouteBuilder endpoints, [StringSyntax("Route")] string path, string contentType)
	{
		return endpoints.MapGet(path, async (context) =>
		{
			string fileName = Path.GetFileName(path);
			byte[] data = await StaticContentLoader.LoadEmbedded(path);
			await Results.Bytes(data, contentType, fileName).ExecuteAsync(context);
		}).Produces<byte[]>(StatusCodes.Status200OK, contentType);
	}

	internal static RouteHandlerBuilder MapRemoteFile(this IEndpointRouteBuilder endpoints, [StringSyntax("Route")] string path, string contentType, string source, string? integrity = null)
	{
		return endpoints.MapGet(path, async (context) =>
		{
			try
			{
				string fileName = Path.GetFileName(path);
				byte[] data = await StaticContentLoader.LoadRemote(path, source, integrity);
				if (data.Length == 0)
				{
					await Results.NotFound().ExecuteAsync(context);
				}
				else
				{
					await Results.Bytes(data, contentType, fileName).ExecuteAsync(context);
				}
			}
			catch (Exception ex)
			{
				await Results.InternalServerError(ex.ToString()).ExecuteAsync(context);
			}
		}).Produces<byte[]>(StatusCodes.Status200OK, contentType);
	}
}

```

`Source/AssetRipper.GUI.Web/StaticContent/css/site.css`:

```css
html {
	font-size: 14px;
}

@media (min-width: 768px) {
	html {
		font-size: 16px;
	}
}

.btn:focus, .btn:active:focus, .btn-link.nav-link:focus, .form-control:focus, .form-check-input:focus {
	box-shadow: 0 0 0 0.1rem white, 0 0 0 0.25rem #258cfb;
}

html {
	position: relative;
	min-height: 100%;
}

body {
	margin: 0;
	padding: 0;
	min-height: 100vh; /* Ensure the body takes up at least the full height of the viewport */
	display: flex;
	flex-direction: column;
}

main {
	flex: 1; /* Allow the main content to grow and fill available space */
}

footer {
	padding: 10px;
	margin-top: auto; /* Push the footer to the bottom of the container */
}

/* This lets the dropdown descriptions in the settings menu render correctly. */
.dropdown-description.disabled {
	display: none; /* Hide disabled elements */
}
```

`Source/AssetRipper.GUI.Web/StaticContent/js/commands_page.js`:

```js
const { createApp } = Vue

const app = createApp({
	data() {
		return {
			load_path: '',
			load_path_exists: false,
			export_path: '',
			export_path_has_files: false,
			create_subfolder: false
		}
	},
	methods: {
		async handleLoadPathChange() {
			// Add a debounce mechanism to avoid too many requests in a short time
			if (this.debouncedInput) {
				clearTimeout(this.debouncedInput);
			}

			this.debouncedInput = setTimeout(async () => {
				try {
					this.load_path_exists = await this.fetchDirectoryExists(this.load_path) || await this.fetchFileExists(this.load_path);
				} catch (error) {
					console.error('Error fetching data:', error);
				}
			}, 300); // Adjust the debounce time as needed (300 milliseconds in this example)
		},
		async handleExportPathChange() {
			// Add a debounce mechanism to avoid too many requests in a short time
			if (this.debouncedInput) {
				clearTimeout(this.debouncedInput);
			}

			this.debouncedInput = setTimeout(async () => {
				try {
					if (this.create_subfolder) {
						this.export_path_has_files = false;
					} else {
						this.export_path_has_files = await this.fetchDirectoryExists(this.export_path) && !(await this.fetchDirectoryEmpty(this.export_path));
					}
				} catch (error) {
					console.error('Error fetching data:', error);
				}
			}, 300); // Adjust the debounce time as needed (300 milliseconds in this example)
		},
		async handleSelectLoadFile() {
			// Add a debounce mechanism to avoid too many requests in a short time
			if (this.debouncedInput) {
				clearTimeout(this.debouncedInput);
			}

			this.debouncedInput = setTimeout(async () => {
				try {
					const response = await fetch(`/Dialogs/OpenFile`);
					this.load_path = await response.json();
				} catch (error) {
					console.error('Error fetching data:', error);
				}
				await this.handleLoadPathChange();
			}, 300); // Adjust the debounce time as needed (300 milliseconds in this example)
		},
		async handleSelectLoadFolder() {
			// Add a debounce mechanism to avoid too many requests in a short time
			if (this.debouncedInput) {
				clearTimeout(this.debouncedInput);
			}

			this.debouncedInput = setTimeout(async () => {
				try {
					const response = await fetch(`/Dialogs/OpenFolder`);
					this.load_path = await response.json();
				} catch (error) {
					console.error('Error fetching data:', error);
				}
				await this.handleLoadPathChange();
			}, 300); // Adjust the debounce time as needed (300 milliseconds in this example)
		},
		async handleSelectExportFolder() {
			// Add a debounce mechanism to avoid too many requests in a short time
			if (this.debouncedInput) {
				clearTimeout(this.debouncedInput);
			}

			this.debouncedInput = setTimeout(async () => {
				try {
					const response = await fetch(`/Dialogs/OpenFolder`);
					this.export_path = await response.json();
				} catch (error) {
					console.error('Error fetching data:', error);
				}
				await this.handleExportPathChange();
			}, 300); // Adjust the debounce time as needed (300 milliseconds in this example)
		},
		async fetchFileExists(path) {
			const response = await fetch(`/IO/File/Exists?Path=${encodeURIComponent(path)}`);
			return await response.json();
		},
		async fetchDirectoryExists(path) {
			const response = await fetch(`/IO/Directory/Exists?Path=${encodeURIComponent(path)}`);
			return await response.json();
		},
		async fetchDirectoryEmpty(path) {
			const response = await fetch(`/IO/Directory/Empty?Path=${encodeURIComponent(path)}`);
			return await response.json();
		},
	}
})

const mountedApp = app.mount('#app')
```

`Source/AssetRipper.GUI.Web/StaticContent/js/mesh_preview.js`:

```js
// Get the canvas element
const canvas = document.getElementById('babylonRenderCanvas');

// Retrieve the GLB file path from the custom attribute
const glbPath = canvas.getAttribute('glb-data-path');

// Create Babylon.js engine
const engine = new BABYLON.Engine(canvas, true);

// Create the scene
const createScene = function () {
	const scene = new BABYLON.Scene(engine);

	// Create a basic light
	const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);

	// Create an ArcRotateCamera that rotates around a target position
	const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 2, 2, new BABYLON.Vector3(0, 0, 0), scene);
	camera.attachControl(canvas, true);

	// Load the GLB file from the path stored in the custom attribute
	BABYLON.SceneLoader.Append("", glbPath, scene, function (scene) {
		scene.createDefaultCameraOrLight(true, true, true);
		scene.activeCamera.alpha += Math.PI;
	});

	return scene;
};

// Create the scene
const scene = createScene();

// Render the scene
engine.runRenderLoop(function () {
	engine.resize();
	scene.render();
});

// Resize the engine on window resize
window.addEventListener('resize', function () {
	engine.resize();
});

```

`Source/AssetRipper.GUI.Web/StaticContent/js/site.js`:

```js
// For enabling and disabling descriptions based on the selected option in a select element
document.addEventListener('DOMContentLoaded', function () {
	// Get all select elements on the page
	var selects = document.querySelectorAll('select');

	// Iterate through each select element
	selects.forEach(function (select) {
		// Add event listener to the select element to update the descriptions
		select.addEventListener('change', function () {
			for (let i = 0; i < select.options.length; i++) {
				var option = select.options[i];
				var descriptionId = option.getAttribute('option-description');
				var description = document.getElementById(descriptionId);
				if (description) {
					if (i == select.selectedIndex) {
						//Enable description
						description.classList.remove('disabled');
					}
					else {
						//Disable description
						description.classList.add('disabled');
					}
				}
			}
		});

		// Trigger initial update to display the description for the default selected option
		select.dispatchEvent(new Event('change'));
	});
});

// For loading dynamic content into pre elements
document.addEventListener("DOMContentLoaded", async () => {
	const preElements = document.querySelectorAll('pre[dynamic-text-content]');

	preElements.forEach(async (preElement) => {
		const url = preElement.getAttribute('dynamic-text-content');

		try {
			const response = await fetch(url);
			if (!response.ok) {
				throw new Error(`Network response was not ok: ${response.statusText}`);
			}
			const data = await response.text();
			preElement.textContent = data;
		} catch (error) {
			console.error('Error fetching the content:', error);
			preElement.textContent = `Failed to load content: ${error.message}`;
		}
	});
});
```

`Source/AssetRipper.GUI.Web/StaticContentLoader.cs`:

```cs
using System.Collections.Concurrent;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

namespace AssetRipper.GUI.Web;

public static partial class StaticContentLoader
{
	private const string Prefix = "AssetRipper.GUI.Web.StaticContent.";
	private static ConcurrentDictionary<string, byte[]> Cache { get; } = new();

	public static void Add(string path, byte[] data)
	{
		Cache.TryAdd(path, data);
	}

	public static void Add(string path, string data)
	{
		Add(path, Encoding.UTF8.GetBytes(data));
	}

	public static bool Contains(string path)
	{
		return Cache.ContainsKey(path);
	}

	public static async ValueTask<byte[]> LoadEmbedded(string path)
	{
		if (Cache.TryGetValue(path, out byte[]? result))
		{
			return result;
		}
		else
		{
			return await LoadInternal(path);
		}
	}

	public static async ValueTask<byte[]> LoadRemote(string path, string source, string? integrity = null)
	{
		if (Cache.TryGetValue(path, out byte[]? result))
		{
			return result;
		}
		else
		{
			using HttpClient client = HttpClientBuilder.CreateHttpClient();

			byte[] data;
			HttpResponseMessage response = await client.GetAsync(source);
			if (response.IsSuccessStatusCode)
			{
				data = await response.Content.ReadAsByteArrayAsync();
			}
			else
			{
				Cache.TryAdd(path, []);
				return [];
			}

			if (ValidateIntegrity(data, integrity))
			{
				Cache.TryAdd(path, data);
				return data;
			}
			else
			{
				Cache.TryAdd(path, []);
				return [];
			}
		}
	}

	private static async Task<byte[]> LoadInternal(string path)
	{
		using Stream stream = typeof(StaticContentLoader).Assembly.GetManifestResourceStream(ToResourceName(path))
			?? throw new NullReferenceException($"Could not load static file: {path}");

		using MemoryStream memoryStream = new((int)stream.Length);

		await stream.CopyToAsync(memoryStream);

		byte[] result = memoryStream.ToArray();

		Cache.TryAdd(path, result);

		return result;
	}

	private static string ToResourceName(string path)
	{
		ArgumentException.ThrowIfNullOrEmpty(path);
		string realPath = path[0] is '/' or '\\' ? path[1..] : path;
		return Prefix + DirectorySeparator().Replace(realPath, ".");
	}

	private static bool ValidateIntegrity(byte[] data, string? integrity)
	{
		if (string.IsNullOrEmpty(integrity))
		{
			return true;
		}

		const string Sha384Prefix = "sha384-";
		if (integrity.StartsWith(Sha384Prefix, StringComparison.Ordinal))
		{
			byte[] hash = SHA384.HashData(data);
			byte[] integrityHash = Convert.FromBase64String(integrity[Sha384Prefix.Length..]);
			return hash.SequenceEqual(integrityHash);
		}
		else
		{
			return false;
		}
	}

	[GeneratedRegex(@"[/\\]")]
	private static partial Regex DirectorySeparator();
}

```

`Source/AssetRipper.GUI.Web/Usings.cs`:

```cs
global using AssetRipper.GUI.Localizations;
global using AssetRipper.Text.Html;

```

`Source/AssetRipper.GUI.Web/VuePage.cs`:

```cs
namespace AssetRipper.GUI.Web;

public abstract class VuePage : DefaultPage
{
	protected override void WriteScriptReferences(TextWriter writer)
	{
		base.WriteScriptReferences(writer);
		OnlineDependencies.Vue.WriteScriptReference(writer);
	}
}

```

`Source/AssetRipper.GUI.Web/WebApplicationLauncher.cs`:

```cs
using AssetRipper.GUI.Web.Documentation;
using AssetRipper.GUI.Web.Pages;
using AssetRipper.GUI.Web.Pages.Assets;
using AssetRipper.GUI.Web.Pages.Bundles;
using AssetRipper.GUI.Web.Pages.Collections;
using AssetRipper.GUI.Web.Pages.FailedFiles;
using AssetRipper.GUI.Web.Pages.Resources;
using AssetRipper.GUI.Web.Pages.Scenes;
using AssetRipper.GUI.Web.Pages.Search;
using AssetRipper.GUI.Web.Pages.Settings;
using AssetRipper.GUI.Web.Paths;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Utils;
using AssetRipper.Web.Extensions;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Hosting.Server;
using Microsoft.AspNetCore.Hosting.Server.Features;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.Extensions.Primitives;
using SwaggerThemes;
using System.Diagnostics;

namespace AssetRipper.GUI.Web;

public static class WebApplicationLauncher
{
	internal static class Defaults
	{
		public const int Port = 0;
		public const bool Log = true;
		public const string? LogPath = null;
		public const bool Headless = false;
	}

	public static void Launch(string[] args)
	{
		Arguments? arguments = Arguments.Parse(args);

		if (arguments is null)
		{
			return;
		}

		foreach (string localWebFile in arguments.LocalWebFiles ?? [])
		{
			if (File.Exists(localWebFile))
			{
				string fileName = Path.GetFileName(localWebFile);
				string webPrefix = Path.GetExtension(fileName) switch
				{
					".css" => "/css/",
					".js" => "/js/",
					_ => "/"
				};
				StaticContentLoader.Add(webPrefix + fileName, File.ReadAllBytes(localWebFile));
			}
			else
			{
				Console.WriteLine($"File '{localWebFile}' does not exist.");
			}
		}

		Launch(arguments.Port, arguments.Headless, arguments.Log, arguments.LogPath);
	}

	public static void Launch(int port = Defaults.Port, bool headless = Defaults.Headless, bool log = Defaults.Log, string? logPath = Defaults.LogPath)
	{
		GameFileLoader.Headless = headless;

		WelcomeMessage.Print();

		if (log)
		{
			if (string.IsNullOrEmpty(logPath))
			{
				logPath = ExecutingDirectory.Combine($"AssetRipper_{DateTime.Now:yyyyMMdd_HHmmss}.log");
				RotateLogs(logPath);
			}
			Logger.Add(new FileLogger(logPath));
		}
		Logger.LogSystemInformation("AssetRipper");
		Logger.Add(new ConsoleLogger());

		Localization.LoadLanguage(GameFileLoader.Settings.LanguageCode);

		WebApplicationBuilder builder = WebApplication.CreateSlimBuilder(new WebApplicationOptions()
		{
#if DEBUG
			EnvironmentName = Environments.Development,
#else
			EnvironmentName = Environments.Production,
#endif
		});

		builder.WebHost.UseUrls($"http://127.0.0.1:{port}");

		builder.Services.AddTransient<ErrorHandlingMiddleware>(static (_) => new());
		builder.Services.ConfigureHttpJsonOptions(options =>
		{
			options.SerializerOptions.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);
			options.SerializerOptions.TypeInfoResolverChain.Insert(1, PathSerializerContext.Default);
			options.SerializerOptions.TypeInfoResolverChain.Insert(2, NullSerializerContext.Instance);
		});

		builder.Services.AddOpenApi(options =>
		{
			options.AddOperationTransformer(new ClearOperationTagsTransformer());
			options.AddOperationTransformer(new InsertionOperationTransformer());
			options.AddDocumentTransformer(new ClearDocumentTagsTransformer());
			options.AddDocumentTransformer(new SortDocumentPathsTransformer());
		});

		builder.Services.AddEndpointsApiExplorer();

		builder.Logging.ConfigureLoggingLevel();

		WebApplication app = builder.Build();

		// Configure the HTTP request pipeline.
#if !DEBUG
		app.UseMiddleware<ErrorHandlingMiddleware>();
#endif
		if (!headless)
		{
			app.Lifetime.ApplicationStarted.Register(() =>
			{
				string? address = app.Services.GetRequiredService<IServer>().Features.Get<IServerAddressesFeature>()?.Addresses.FirstOrDefault();
				if (address is not null)
				{
					OpenUrl(address);
				}
			});
		}

		app.MapOpenApi(DocumentationPaths.OpenApi);
		app.UseSwaggerUI(Theme.Gruvbox, null, c =>
		{
			// Point to the static OpenAPI file
			c.SwaggerEndpoint(DocumentationPaths.OpenApi, "AssetRipper API");
		});

		//Static files
		app.MapStaticFile("/favicon.ico", "image/x-icon");
		app.MapStaticFile("/css/site.css", "text/css");
		app.MapStaticFile("/js/site.js", "text/javascript");
		app.MapStaticFile("/js/commands_page.js", "text/javascript");
		app.MapStaticFile("/js/mesh_preview.js", "text/javascript");
		OnlineDependencies.MapDependencies(app);

		//Normal Pages
		app.MapGet("/", (context) =>
		{
			context.Response.DisableCaching();
			return IndexPage.Instance.WriteToResponse(context.Response);
		})
			.WithSummary("The home page")
			.ProducesHtmlPage();
		app.MapGet("/Commands", CommandsPage.Instance.ToResult).ProducesHtmlPage();
		app.MapGet("/Privacy", PrivacyPage.Instance.ToResult).ProducesHtmlPage();
		app.MapGet("/Licenses", LicensesPage.Instance.ToResult).ProducesHtmlPage();
		app.MapGet("/PremiumFeatures", PremiumFeaturesPage.Instance.ToResult).ProducesHtmlPage();

		app.MapGet("/ConfigurationFiles", (context) =>
		{
			context.Response.DisableCaching();
			return ConfigurationFilesPage.Instance.WriteToResponse(context.Response);
		}).ProducesHtmlPage();
		app.MapPost("/ConfigurationFiles/Singleton/Add", ConfigurationFilesPage.HandleSingletonAddPostRequest);
		app.MapPost("/ConfigurationFiles/Singleton/Remove", ConfigurationFilesPage.HandleSingletonRemovePostRequest);
		app.MapPost("/ConfigurationFiles/List/Add", ConfigurationFilesPage.HandleListAddPostRequest);
		app.MapPost("/ConfigurationFiles/List/Remove", ConfigurationFilesPage.HandleListRemovePostRequest);
		app.MapPost("/ConfigurationFiles/List/Replace", ConfigurationFilesPage.HandleListReplacePostRequest);

		app.MapGet("/Settings/Edit", (context) =>
		{
			context.Response.DisableCaching();
			return SettingsPage.Instance.WriteToResponse(context.Response);
		}).ProducesHtmlPage();
		app.MapPost("/Settings/Update", SettingsPage.HandlePostRequest);

		//Assets
		app.MapGet(AssetAPI.Urls.View, AssetAPI.GetView).ProducesHtmlPage();
		app.MapGet(AssetAPI.Urls.Image, AssetAPI.GetImageData)
			.Produces<byte[]>(contentType: "application/octet-stream")
			.WithAssetPathParameter()
			.WithImageExtensionParameter();
		app.MapGet(AssetAPI.Urls.Audio, AssetAPI.GetAudioData)
			.Produces<byte[]>(contentType: "application/octet-stream")
			.WithAssetPathParameter();
		app.MapGet(AssetAPI.Urls.Model, AssetAPI.GetModelData)
			.Produces<byte[]>(contentType: "application/octet-stream")
			.WithAssetPathParameter();
		app.MapGet(AssetAPI.Urls.Font, AssetAPI.GetFontData)
			.Produces<byte[]>(contentType: "application/octet-stream")
			.WithAssetPathParameter();
		app.MapGet(AssetAPI.Urls.Video, AssetAPI.GetVideoData)
			.Produces<byte[]>(contentType: "application/octet-stream")
			.WithAssetPathParameter();
		app.MapGet(AssetAPI.Urls.Json, AssetAPI.GetJson)
			.Produces<string>(contentType: "application/json")
			.WithAssetPathParameter();
		app.MapGet(AssetAPI.Urls.Yaml, AssetAPI.GetYaml)
			.Produces<string>(contentType: "text/yaml")
			.WithAssetPathParameter();
		app.MapGet(AssetAPI.Urls.Text, AssetAPI.GetText)
			.Produces<string>(contentType: "text/plain")
			.WithAssetPathParameter();
		app.MapGet(AssetAPI.Urls.Binary, AssetAPI.GetBinaryData)
			.Produces<byte[]>(contentType: "application/octet-stream")
			.WithAssetPathParameter();

		//Bundles
		app.MapGet(BundleAPI.Urls.View, BundleAPI.GetView).ProducesHtmlPage();

		//Collections
		app.MapGet(CollectionAPI.Urls.View, CollectionAPI.GetView).ProducesHtmlPage();
		app.MapGet(CollectionAPI.Urls.Count, CollectionAPI.GetCount)
			.WithSummary("Get the number of elements in the collection.")
			.Produces<int>();

		//Failed Files
		app.MapGet(FailedFileAPI.Urls.View, FailedFileAPI.GetView).ProducesHtmlPage();
		app.MapGet(FailedFileAPI.Urls.StackTrace, FailedFileAPI.GetStackTrace)
			.Produces<string>();

		//Resources
		app.MapGet(ResourceAPI.Urls.View, ResourceAPI.GetView).ProducesHtmlPage();
		app.MapGet(ResourceAPI.Urls.Data, ResourceAPI.GetData)
			.Produces<byte[]>(contentType: "application/octet-stream");

		//Search
		app.MapGet(SearchAPI.Urls.View, SearchAPI.GetView).ProducesHtmlPage();

		//Scenes
		app.MapGet(SceneAPI.Urls.View, SceneAPI.GetView).ProducesHtmlPage();

		app.MapPost("/Localization", (context) =>
		{
			context.Response.DisableCaching();
			if (context.Request.Query.TryGetValue("code", out StringValues code))
			{
				string? language = code;
				Localization.LoadLanguage(language);
				GameFileLoader.Settings.LanguageCode = Localization.CurrentLanguageCode;
				GameFileLoader.Settings.MaybeSaveToDefaultPath();
			}
			return Results.Redirect("/").ExecuteAsync(context);
		})
			.WithQueryStringParameter("Code", "Language code", true)
			.Produces(StatusCodes.Status302Found);

		//Commands
		app.MapPost("/Export/UnityProject", Commands.HandleCommand<Commands.ExportUnityProject>)
			.AcceptsFormDataContainingPath()
			.Produces(StatusCodes.Status302Found);
		app.MapPost("/Export/PrimaryContent", Commands.HandleCommand<Commands.ExportPrimaryContent>)
			.AcceptsFormDataContainingPath()
			.Produces(StatusCodes.Status302Found);
		app.MapPost("/LoadFile", Commands.HandleCommand<Commands.LoadFile>)
			.AcceptsFormDataContainingPath()
			.Produces(StatusCodes.Status302Found);
		app.MapPost("/LoadFolder", Commands.HandleCommand<Commands.LoadFolder>)
			.AcceptsFormDataContainingPath()
			.Produces(StatusCodes.Status302Found);
		app.MapPost("/Reset", Commands.HandleCommand<Commands.Reset>);

		//Dialogs
		app.MapGet("/Dialogs/SaveFile", Dialogs.SaveFile.HandleGetRequest).Produces<string>();
		app.MapGet("/Dialogs/OpenFolder", Dialogs.OpenFolder.HandleGetRequest).Produces<string>();
		app.MapGet("/Dialogs/OpenFolders", Dialogs.OpenFolders.HandleGetRequest).Produces<string>();
		app.MapGet("/Dialogs/OpenFile", Dialogs.OpenFile.HandleGetRequest).Produces<string>();
		app.MapGet("/Dialogs/OpenFiles", Dialogs.OpenFiles.HandleGetRequest).Produces<string>();

		//File API
		app.MapGet("/IO/File/Exists", (context) =>
		{
			context.Response.DisableCaching();
			if (context.Request.Query.TryGetValue("Path", out StringValues path))
			{
				bool exists = File.Exists(path);
				return Results.Json(exists, AppJsonSerializerContext.Default.Boolean).ExecuteAsync(context);
			}
			else
			{
				return Results.BadRequest().ExecuteAsync(context);
			}
		})
			.Produces<bool>()
			.WithQueryStringParameter("Path", required: true);

		app.MapGet("/IO/Directory/Exists", (context) =>
		{
			context.Response.DisableCaching();
			if (context.Request.Query.TryGetValue("Path", out StringValues path))
			{
				bool exists = Directory.Exists(path);
				return Results.Json(exists, AppJsonSerializerContext.Default.Boolean).ExecuteAsync(context);
			}
			else
			{
				return Results.BadRequest().ExecuteAsync(context);
			}
		})
			.Produces<bool>()
			.WithQueryStringParameter("Path", required: true);

		app.MapGet("/IO/Directory/Empty", (context) =>
		{
			context.Response.DisableCaching();
			if (context.Request.Query.TryGetValue("Path", out StringValues stringValues))
			{
				string? path = stringValues;
				bool empty = !Directory.Exists(path) || !Directory.EnumerateFileSystemEntries(path).Any();
				return Results.Json(empty, AppJsonSerializerContext.Default.Boolean).ExecuteAsync(context);
			}
			else
			{
				return Results.BadRequest().ExecuteAsync(context);
			}
		})
			.Produces<bool>()
			.WithQueryStringParameter("Path", required: true);

		app.Run();
	}

	private static ILoggingBuilder ConfigureLoggingLevel(this ILoggingBuilder builder)
	{
		builder.Services.Add(ServiceDescriptor.Singleton<IConfigureOptions<LoggerFilterOptions>>(
			new LifetimeOrWarnConfigureOptions()));
		return builder;
	}

	private sealed class LifetimeOrWarnConfigureOptions : ConfigureOptions<LoggerFilterOptions>
	{
		public LifetimeOrWarnConfigureOptions() : base(AddRule)
		{
		}

		private static void AddRule(LoggerFilterOptions options)
		{
			options.Rules.Add(new LoggerFilterRule(null, null, LogLevel.Information, static (provider, category, logLevel) =>
			{
				return category is "Microsoft.Hosting.Lifetime" || logLevel >= LogLevel.Warning;
			}));
		}
	}

	private static void OpenUrl(string url)
	{
		try
		{
			if (OperatingSystem.IsWindows())
			{
				Process.Start(new ProcessStartInfo(url) { UseShellExecute = true });
			}
			else if (OperatingSystem.IsLinux())
			{
				Process.Start("xdg-open", url);
			}
			else if (OperatingSystem.IsMacOS())
			{
				Process.Start("open", url);
			}
		}
		catch (Exception ex)
		{
			Logger.Error($"Failed to launch web browser for: {url}", ex);
		}
	}

	private static void RotateLogs(string path)
	{
		const int MaxLogFiles = 5;
		string? directory = Path.GetDirectoryName(path);
		if (directory is null)
		{
			return;
		}

		FileInfo[] logFiles = new DirectoryInfo(directory)
			.GetFiles("AssetRipper_*.log")
			.OrderBy(f => f.Name)
			.ToArray();

		for (int i = 0; i <= logFiles.Length - MaxLogFiles; i++)
		{
			try
			{
				logFiles[i].Delete();
			}
			catch (IOException)
			{
				// Could not delete log file, ignore
			}
		}
	}
}

```

`Source/AssetRipper.GUI.Web/WelcomeMessage.cs`:

```cs
namespace AssetRipper.GUI.Web;

public static class WelcomeMessage
{
	private const string AsciiArt = """
		                       _   _____  _                       
		    /\                | | |  __ \(_)                      
		   /  \   ___ ___  ___| |_| |__) |_ _ __  _ __   ___ _ __ 
		  / /\ \ / __/ __|/ _ \ __|  _  /| | '_ \| '_ \ / _ \ '__|
		 / ____ \\__ \__ \  __/ |_| | \ \| | |_) | |_) |  __/ |   
		/_/    \_\___/___/\___|\__|_|  \_\_| .__/| .__/ \___|_|   
		                                   | |   | |              
		                                   |_|   |_|              
		""";

	private const string Directions = """
		In a moment, a line will appear: "Now listening on:" followed by a url.
		Open that url in any web browser to access the AssetRipper user interface.
		""";

	public static void Print()
	{
		Console.WriteLine(AsciiArt);
		Console.WriteLine();
		Console.WriteLine(Directions);
		Console.WriteLine();
	}
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/AssetRipper.IO.Files.SourceGenerator.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\Other\AssetRipper.IO.Files.SourceGenerator\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.IO.Files.SourceGenerator\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.IO.Endian" Version="2.0.2" />
		<PackageReference Include="AssetRipper.Text.SourceGeneration" Version="1.2.3" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/FileIdentifier/FileIdentifier.json`:

```json
{
	"Name": "FileIdentifier",
	"Namespace": "AssetRipper.IO.Files.SerializedFiles.FileIdentifiers",
	"ClassType": "record class",
	"Summary": "A serialized file may be linked with other serialized files to create shared dependencies.",
	"Remarks": "",
	"Properties": {
		"PathName": {
			"Summary": "Actual file path. This path is relative to the path of the current file.",
			"Remarks": "The folder \"library\" often needs to be translated to \"resources\" in order to find the file on the file system."
		},
		"Type": {
			"Summary": "The type of the file",
			"Remarks": ""
		},
		"AssetPath": {
			"Summary": "Virtual asset path. Used for cached files, otherwise it's empty.",
			"Remarks": "The file with that path usually doesn't exist, so it's probably an alias."
		},
		"Guid": {
			"Summary": "Actually UnityGuid",
			"Remarks": ""
		}
	},
	"Usings": [
		"AssetRipper.Primitives"
	]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/FileIdentifier/Version1.json`:

```json
{
	"Name": "FileIdentifier",
	"Version": 1,
	"SerializableFields": [
		{
			"TypeName": "string",
			"FieldName": "PathName",
			"Special": {
				"Identifier": "NullTerminated",
				"Parameter": ""
			}
		}
	],
	"ExtraFields": []
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/FileIdentifier/Version5.json`:

```json
{
	"Name": "FileIdentifier",
	"Version": 5,
	"SerializableFields": [
		{
			"TypeName": "UnityGuid",
			"FieldName": "Guid",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "Type",
			"Special": {
				"Identifier": "enum",
				"Parameter": "AssetType"
			}
		},
		{
			"TypeName": "string",
			"FieldName": "PathName",
			"Special": {
				"Identifier": "NullTerminated",
				"Parameter": ""
			}
		}
	],
	"ExtraFields": []
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/FileIdentifier/Version6.json`:

```json
{
	"Name": "FileIdentifier",
	"Version": 6,
	"SerializableFields": [
		{
			"TypeName": "string",
			"FieldName": "AssetPath",
			"Special": {
				"Identifier": "NullTerminated",
				"Parameter": ""
			}
		},
		{
			"TypeName": "UnityGuid",
			"FieldName": "Guid",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "Type",
			"Special": {
				"Identifier": "enum",
				"Parameter": "AssetType"
			}
		},
		{
			"TypeName": "string",
			"FieldName": "PathName",
			"Special": {
				"Identifier": "NullTerminated",
				"Parameter": ""
			}
		}
	],
	"ExtraFields": []
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/LocalSerializedObjectIdentifier/LocalSerializedObjectIdentifier.json`:

```json
{
	"Name": "LocalSerializedObjectIdentifier",
	"Namespace": "AssetRipper.IO.Files.SerializedFiles.LocalSerializedObjectIdentifiers",
	"ClassType": "record class",
	"Summary": "",
	"Remarks": "",
	"Properties": {
		"LocalSerializedFileIndex": null,
		"LocalIdentifierInFile": null
	},
	"Usings": []
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/LocalSerializedObjectIdentifier/Version1.json`:

```json
{
	"Name": "LocalSerializedObjectIdentifier",
	"Version": 1,
	"SerializableFields": [
		{
			"TypeName": "int",
			"FieldName": "LocalSerializedFileIndex",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "LocalIdentifierInFile",
			"Special": null
		}
	],
	"ExtraFields": []
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/LocalSerializedObjectIdentifier/Version14.json`:

```json
{
	"Name": "LocalSerializedObjectIdentifier",
	"Version": 14,
	"SerializableFields": [
		{
			"TypeName": "int",
			"FieldName": "LocalSerializedFileIndex",
			"Special": null
		},
		{
			"TypeName": "align4",
			"FieldName": "",
			"Special": null
		},
		{
			"TypeName": "long",
			"FieldName": "LocalIdentifierInFile",
			"Special": null
		}
	],
	"ExtraFields":[ ]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/ObjectInfo/ObjectInfo.json`:

```json
{
	"Name": "ObjectInfo",
	"Namespace": "AssetRipper.IO.Files.SerializedFiles.ObjectInformation",
	"ClassType": "record class",
	"Summary": "Contains information for a block of raw serialized object data.",
	"Remarks": "",
	"Properties": {
		"FileID": {
			"Summary": "ObjectID",
			"Remarks": "Unique ID that identifies the object. Can be used as a key for a map.",
			"GetExpression": "",
			"SetExpression": ""
		},
		"ByteStart": {
			"Summary": "Offset to the object data.",
			"Remarks": "Add to <see cref=\"SerializedFileHeader.DataOffset\"/> to get the absolute offset within the serialized file.",
			"GetExpression": "-1",
			"SetExpression": ""
		},
		"ByteSize": {
			"Summary": "Size of the object data.",
			"Remarks": "",
			"GetExpression": "-1",
			"SetExpression": ""
		},
		"TypeID": {
			"Summary": "Type ID of the object, which is mapped to <see cref=\"SerializedType.TypeID\"/>. Equals to classID if the object is not <see cref=\"ClassIDType.MonoBehaviour\"/>",
			"Remarks": "",
			"GetExpression": "-1",
			"SetExpression": ""
		},
		"SerializedTypeIndex": {
			"Summary": "Type index in <see cref=\"SerializedFileMetadata.Types\"/> array.",
			"Remarks": "",
			"GetExpression": "-1",
			"SetExpression": ""
		},
		"ClassID": {
			"Summary": "Class ID of the object.",
			"Remarks": "",
			"GetExpression": "(short)TypeID",
			"SetExpression": "TypeID = value"
		},
		"IsDestroyed": {
			"Summary": "",
			"Remarks": "",
			"GetExpression": "",
			"SetExpression": ""
		},
		"ScriptTypeIndex": {
			"Summary": "",
			"Remarks": "",
			"GetExpression": "",
			"SetExpression": ""
		},
		"Stripped": {
			"Summary": "",
			"Remarks": "",
			"GetExpression": "false",
			"SetExpression": ""
		}
	},
	"Usings": []
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/ObjectInfo/Version1.json`:

```json
{
	"Name": "ObjectInfo",
	"Version": 1,
	"SerializableFields": [
		{
			"TypeName": "int",
			"FieldName": "FileID",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteStart",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "TypeID",
			"Special": null
		},
		{
			"TypeName": "short",
			"FieldName": "ClassID",
			"Special": null
		},
		{
			"TypeName": "ushort",
			"FieldName": "IsDestroyed",
			"Special": null
		}
	],
	"ExtraFields":[]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/ObjectInfo/Version11.json`:

```json
{
	"Name": "ObjectInfo",
	"Version": 11,
	"SerializableFields": [
		{
			"TypeName": "int",
			"FieldName": "FileID",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteStart",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "TypeID",
			"Special": null
		},
		{
			"TypeName": "short",
			"FieldName": "ClassID",
			"Special": null
		},
		{
			"TypeName": "short",
			"FieldName": "ScriptTypeIndex",
			"Special": null
		}
	],
	"ExtraFields":[]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/ObjectInfo/Version14.json`:

```json
{
	"Name": "ObjectInfo",
	"Version": 14,
	"SerializableFields": [
		{
			"TypeName": "align4",
			"FieldName": "",
			"Special": null
		},
		{
			"TypeName": "long",
			"FieldName": "FileID",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteStart",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "TypeID",
			"Special": null
		},
		{
			"TypeName": "short",
			"FieldName": "ClassID",
			"Special": null
		},
		{
			"TypeName": "short",
			"FieldName": "ScriptTypeIndex",
			"Special": null
		}
	],
	"ExtraFields":[]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/ObjectInfo/Version15.json`:

```json
{
	"Name": "ObjectInfo",
	"Version": 15,
	"SerializableFields": [
		{
			"TypeName": "align4",
			"FieldName": "",
			"Special": null
		},
		{
			"TypeName": "long",
			"FieldName": "FileID",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteStart",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "TypeID",
			"Special": null
		},
		{
			"TypeName": "short",
			"FieldName": "ClassID",
			"Special": null
		},
		{
			"TypeName": "short",
			"FieldName": "ScriptTypeIndex",
			"Special": null
		},
		{
			"TypeName": "bool",
			"FieldName": "Stripped",
			"Special": null
		}
	],
	"ExtraFields":[]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/ObjectInfo/Version16.json`:

```json
{
	"Name": "ObjectInfo",
	"Version": 16,
	"SerializableFields": [
		{
			"TypeName": "align4",
			"FieldName": "",
			"Special": null
		},
		{
			"TypeName": "long",
			"FieldName": "FileID",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteStart",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "TypeID",
			"Special": null
		},
		{
			"TypeName": "short",
			"FieldName": "ScriptTypeIndex",
			"Special": null
		},
		{
			"TypeName": "bool",
			"FieldName": "Stripped",
			"Special": null
		}
	],
	"ExtraFields":[]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/ObjectInfo/Version17.json`:

```json
{
	"Name": "ObjectInfo",
	"Version": 17,
	"SerializableFields": [
		{
			"TypeName": "align4",
			"FieldName": "",
			"Special": null
		},
		{
			"TypeName": "long",
			"FieldName": "FileID",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteStart",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "SerializedTypeIndex",
			"Special": null
		}
	],
	"ExtraFields":[]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/ObjectInfo/Version22.json`:

```json
{
	"Name": "ObjectInfo",
	"Version": 22,
	"SerializableFields": [
		{
			"TypeName": "align4",
			"FieldName": "",
			"Special": null
		},
		{
			"TypeName": "long",
			"FieldName": "FileID",
			"Special": null
		},
		{
			"TypeName": "long",
			"FieldName": "ByteStart",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "SerializedTypeIndex",
			"Special": null
		}
	],
	"ExtraFields":[]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/SerializedFileHeader/SerializedFileHeader.json`:

```json
{
	"Name": "SerializedFileHeader",
	"Namespace": "AssetRipper.IO.Files.SerializedFiles.Header",
	"ClassType": "record class",
	"Summary": "The file header is found at the beginning of an asset file. The header is always using big endian byte order.",
	"Remarks": "",
	"Properties": {
		"Version": {
			"Summary": "File format version. The number is required for backward compatibility and is normally incremented after the file format has been changed in a major update.",
			"Remarks": ""
		},
		"SwapEndianess": {
			"Summary": "This controls the byte order of the data structure. False is little endian. True is big endian.",
			"Remarks": "This field is normally set to 0."
		},
		"MetadataSize": {
			"Summary": "Size of the metadata section in the file",
			"Remarks": ""
		},
		"FileSize": {
			"Summary": "Size of the whole file",
			"Remarks": ""
		},
		"DataOffset": {
			"Summary": "Offset to the serialized object data. It starts at the data for the first object.",
			"Remarks": ""
		},
		"Unknown22": {
			"Summary": "An unknown field introduced in version 22.",
			"Remarks": ""
		}
	},
	"Usings": []
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/SerializedFileHeader/Version1.json`:

```json
{
	"Name": "SerializedFileHeader",
	"Version": 1,
	"SerializableFields": [
		{
			"TypeName": "int",
			"FieldName": "MetadataSize",
			"Special": null
		},
		{
			"TypeName": "uint",
			"FieldName": "FileSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "Version",
			"Special": {
				"Identifier": "enum",
				"Parameter": "FormatVersion"
			}
		},
		{
			"TypeName": "uint",
			"FieldName": "DataOffset",
			"Special": null
		}
	],
	"ExtraFields": []
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/SerializedFileHeader/Version22.json`:

```json
{
	"Name": "SerializedFileHeader",
	"Version": 22,
	"SerializableFields": [
		{
			"TypeName": "uint",
			"FieldName": "",
			"Special": null
		},
		{
			"TypeName": "uint",
			"FieldName": "",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "Version",
			"Special": {
				"Identifier": "enum",
				"Parameter": "FormatVersion"
			}
		},
		{
			"TypeName": "uint",
			"FieldName": "",
			"Special": null
		},
		{
			"TypeName": "bool",
			"FieldName": "SwapEndianess",
			"Special": null
		},
		{
			"TypeName": "align4",
			"FieldName": "",
			"Special": null
		},
		{
			"TypeName": "uint",
			"FieldName": "MetadataSize",
			"Special": null
		},
		{
			"TypeName": "long",
			"FieldName": "FileSize",
			"Special": null
		},
		{
			"TypeName": "long",
			"FieldName": "DataOffset",
			"Special": null
		},
		{
			"TypeName": "long",
			"FieldName": "Unknown22",
			"Special": null
		}
	],
	"ExtraFields": []
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/SerializedFileHeader/Version9.json`:

```json
{
	"Name": "SerializedFileHeader",
	"Version": 9,
	"SerializableFields": [
		{
			"TypeName": "int",
			"FieldName": "MetadataSize",
			"Special": null
		},
		{
			"TypeName": "uint",
			"FieldName": "FileSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "Version",
			"Special": {
				"Identifier": "enum",
				"Parameter": "FormatVersion"
			}
		},
		{
			"TypeName": "uint",
			"FieldName": "DataOffset",
			"Special": null
		},
		{
			"TypeName": "bool",
			"FieldName": "SwapEndianess",
			"Special": null
		},
		{
			"TypeName": "align4",
			"FieldName": "",
			"Special": null
		}
	],
	"ExtraFields": []
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/TypeTreeNode/TypeTreeNode.json`:

```json
{
	"Name": "TypeTreeNode",
	"Namespace": "AssetRipper.IO.Files.SerializedFiles.TypeTrees",
	"ClassType": "record class",
	"Summary": "",
	"Remarks": "",
	"Properties": {
		"Version": {
			"Summary": "Field type version, starts with 1 and is incremented after the type information has been significantly updated in a new release.",
			"Remarks": "Equal to serializedVersion in Yaml format files"
		},
		"Level": {
			"Summary": "Depth of current type relative to root.",
			"Remarks": ""
		},
		"TypeFlags": {
			"Summary": "Array flag, set to 1 if type is \"Array\" or \"TypelessData\".",
			"Remarks": ""
		},
		"Type": {
			"Summary": "Name of the data type. This can be the name of any substructure or a static predefined type.",
			"Remarks": ""
		},
		"Name": {
			"Summary": "Name of the field.",
			"Remarks": ""
		},
		"TypeStrOffset": {
			"Summary": "Type offset in the string buffer.",
			"Remarks": ""
		},
		"NameStrOffset": {
			"Summary": "Name offset in the string buffer.",
			"Remarks": ""
		},
		"ByteSize": {
			"Summary": "Size of the data value in bytes, e.g. 4 for int. -1 means that there is an array somewhere inside the hierarchy.",
			"Remarks": "Note: The padding for the alignment is not included in the size."
		},
		"Index": {
			"Summary": "Index of the field that is unique within a tree.",
			"Remarks": "Normally starts with 0 and is incremented with each additional field."
		},
		"MetaFlag": {
			"Summary": "Meta flags of the field.",
			"Remarks": ""
		},
		"RefTypeHash": null
	},
	"Usings": []
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/TypeTreeNode/Version1.json`:

```json
{
	"Name": "TypeTreeNode",
	"Version": 1,
	"SerializableFields": [
		{
			"TypeName": "string",
			"FieldName": "Type",
			"Special": {
				"Identifier": "NullTerminated",
				"Parameter": null
			}
		},
		{
			"TypeName": "string",
			"FieldName": "Name",
			"Special": {
				"Identifier": "NullTerminated",
				"Parameter": null
			}
		},
		{
			"TypeName": "int",
			"FieldName": "ByteSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "Index",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "TypeFlags",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "Version",
			"Special": null
		},
		{
			"TypeName": "uint",
			"FieldName": "MetaFlag",
			"Special": {
				"Identifier": "enum",
				"Parameter": "TransferMetaFlags"
			}
		}
	],
	"ExtraFields":[
		{
			"TypeName": "byte",
			"FieldName": "Level",
			"Special": null
		}
	]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/TypeTreeNode/Version10.json`:

```json
{
	"Name": "TypeTreeNode",
	"Version": 10,
	"SerializableFields": [
		{
			"TypeName": "ushort",
			"FieldName": "Version",
			"Special": null
		},
		{
			"TypeName": "byte",
			"FieldName": "Level",
			"Special": null
		},
		{
			"TypeName": "byte",
			"FieldName": "TypeFlags",
			"Special": null
		},
		{
			"TypeName": "uint",
			"FieldName": "TypeStrOffset",
			"Special": null
		},
		{
			"TypeName": "uint",
			"FieldName": "NameStrOffset",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "Index",
			"Special": null
		},
		{
			"TypeName": "uint",
			"FieldName": "MetaFlag",
			"Special": {
				"Identifier": "enum",
				"Parameter": "TransferMetaFlags"
			}
		}
	],
	"ExtraFields":[
		{
			"TypeName": "string",
			"FieldName": "Type",
			"Special": null
		},
		{
			"TypeName": "string",
			"FieldName": "Name",
			"Special": null
		}
	]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/TypeTreeNode/Version19.json`:

```json
{
	"Name": "TypeTreeNode",
	"Version": 19,
	"SerializableFields": [
		{
			"TypeName": "ushort",
			"FieldName": "Version",
			"Special": null
		},
		{
			"TypeName": "byte",
			"FieldName": "Level",
			"Special": null
		},
		{
			"TypeName": "byte",
			"FieldName": "TypeFlags",
			"Special": null
		},
		{
			"TypeName": "uint",
			"FieldName": "TypeStrOffset",
			"Special": null
		},
		{
			"TypeName": "uint",
			"FieldName": "NameStrOffset",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "Index",
			"Special": null
		},
		{
			"TypeName": "uint",
			"FieldName": "MetaFlag",
			"Special": {
				"Identifier": "enum",
				"Parameter": "TransferMetaFlags"
			}
		},
		{
			"TypeName": "ulong",
			"FieldName": "RefTypeHash",
			"Special": null
		}
	],
	"ExtraFields":[
		{
			"TypeName": "string",
			"FieldName": "Type",
			"Special": null
		},
		{
			"TypeName": "string",
			"FieldName": "Name",
			"Special": null
		}
	]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Formats/SerializedFile/TypeTreeNode/VersionIndependent.json`:

```json
{
	"Name": "TypeTreeNode",
	"Version": -1,
	"SerializableFields": [],
	"ExtraFields":[
		{
			"TypeName": "string",
			"FieldName": "Type",
			"Special": null
		},
		{
			"TypeName": "string",
			"FieldName": "Name",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "ByteSize",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "Index",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "TypeFlags",
			"Special": null
		},
		{
			"TypeName": "int",
			"FieldName": "Version",
			"Special": null
		},
		{
			"TypeName": "uint",
			"FieldName": "MetaFlag",
			"Special": {
				"Identifier": "enum",
				"Parameter": "TransferMetaFlags"
			}
		},
		{
			"TypeName": "byte",
			"FieldName": "Level",
			"Special": null
		}
	]
}
```

`Source/AssetRipper.IO.Files.SourceGenerator/Generator.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SourceGenerator.Json;

namespace AssetRipper.IO.Files.SourceGenerator;

public static class Generator
{
	internal static void MakeType(IndentedTextWriter writer, TypeDeclaration declaration, TypeDefinition definition, Dictionary<string, string> propertyTypeDictionary)
	{
		bool isReadOnly = declaration.ContainsModifier("readonly");
		bool isStruct = declaration.ContainsModifier("struct");
		bool isRecord = declaration.ContainsModifier("record");
		writer.WriteGeneratedCodeWarning();
		foreach (string @using in declaration.Usings.Append("AssetRipper.IO.Endian").Order())
		{
			writer.WriteUsing(@using);
		}
		writer.WriteFileScopedNamespace(declaration.Namespace);
		MaybeWriteDocumentation(writer, declaration.Summary, declaration.Remarks);
		writer.WriteLine($"public partial {declaration.ClassType} {declaration.Name}_{definition.Version} : I{declaration.Name}");
		using (new CurlyBrackets(writer))
		{
			HashSet<string?> properties = new();
			foreach (FieldDefinition serializableField in definition.SerializableFields)
			{
				MaybeWriteProperty(writer, declaration, propertyTypeDictionary, isReadOnly, serializableField);
				properties.Add(serializableField.FieldName);
			}
			foreach (FieldDefinition extraField in definition.ExtraFields)
			{
				MaybeWriteProperty(writer, declaration, propertyTypeDictionary, isReadOnly, extraField);
				properties.Add(extraField.FieldName);
			}
			foreach ((string propertyName, string propertyType) in propertyTypeDictionary)
			{
				if (!properties.Contains(propertyName))
				{
					declaration.Properties.TryGetValue(propertyName, out PropertyDocumentation? documentation);
					MaybeWriteDocumentation(writer, documentation?.Summary, documentation?.Remarks);
					WriteDefaultProperty(writer, isReadOnly, propertyName, propertyType, documentation);
				}
			}
			WriteReadMethod(writer, definition);
			WriteWriteMethod(writer, definition);
		}
	}

	private static void WriteDefaultProperty(IndentedTextWriter writer, bool isReadOnly, string propertyName, string propertyType, PropertyDocumentation? documentation)
	{
		writer.WriteLine($"public {propertyType} {propertyName}");
		using (new CurlyBrackets(writer))
		{
			if (string.IsNullOrEmpty(documentation?.GetExpression))
			{
				writer.WriteLine("get => default;");
			}
			else
			{
				writer.WriteLine($"get => {documentation.GetExpression};");
			}

			if (!isReadOnly)
			{
				if (string.IsNullOrEmpty(documentation?.SetExpression))
				{
					writer.WriteLine("set { }");
				}
				else
				{
					writer.WriteLine($"set => {documentation.SetExpression};");
				}
			}
		}
		writer.WriteLine();
	}

	private static bool MaybeWriteProperty(IndentedTextWriter writer, TypeDeclaration declaration, Dictionary<string, string> propertyTypeDictionary, bool isReadOnly, FieldDefinition field)
	{
		if (string.IsNullOrEmpty(field.FieldName))
		{
			return false;
		}

		string propertyName = field.FieldName;
		string fieldName = $"m_{propertyName}";
		string fieldType = field.TypeName;

		string propertyType;
		bool castGetAccessor;
		bool castSetAccessor;
		if (field.TypeIsEnum(out string? enumName))
		{
			propertyType = enumName;
			castGetAccessor = true;
			castSetAccessor = true;
		}
		else
		{
			propertyType = propertyTypeDictionary[propertyName];
			castGetAccessor = false; //assume implicit conversions available
			castSetAccessor = propertyType != fieldType;
		}

		string processMethodName = $"On{propertyName}Assignment";

		declaration.TryGetPropertyDocumentation(propertyName, out string? summary, out string? remarks);
		MaybeWriteDocumentation(writer, summary, remarks);
		string defaultValue = field.TypeIsString(out _) ? "string.Empty" : "new()";
		writer.WriteLine(isReadOnly
			? $"private readonly {fieldType} {fieldName} = {defaultValue};"
			: $"private {fieldType} {fieldName} = {defaultValue};");
		writer.WriteLine();

		MaybeWriteDocumentation(writer, summary, remarks);
		writer.WriteLine($"public {propertyType} {propertyName}");
		using (new CurlyBrackets(writer))
		{
			writer.WriteLine(castGetAccessor ? $"get => ({propertyType}){fieldName};" : $"get => {fieldName};");
			if (!isReadOnly)
			{
				writer.WriteLine("set");
				using (new CurlyBrackets(writer))
				{
					writer.WriteLine(castSetAccessor ? $"{fieldName} = ({fieldType})value;" : $"{fieldName} = value;");
					writer.WriteLine($"{processMethodName}(value);");
				}
			}
		}
		writer.WriteLine();

		if (!isReadOnly)
		{
			writer.WriteSummaryDocumentation($"Called when <see cref=\"{propertyName}\"/> is set.");
			writer.WriteLine($"partial void {processMethodName}({propertyType} value);");
			writer.WriteLine();
		}

		return true;
	}

	private static void MaybeWriteDocumentation(IndentedTextWriter writer, string? summary, string? remarks)
	{
		if (!string.IsNullOrEmpty(summary))
		{
			writer.WriteSummaryDocumentation(summary);
		}
		if (!string.IsNullOrEmpty(remarks))
		{
			writer.WriteRemarksDocumentation(remarks);
		}
	}

	private static void WriteReadMethod(IndentedTextWriter writer, TypeDefinition definition)
	{
		const string readMethodName = nameof(IEndianReadable<>.Read);
		const string postReadMethodName = $"On{readMethodName}Finished";

		writer.WriteLine($"public void {readMethodName}({nameof(EndianReader)} reader)");
		using (new CurlyBrackets(writer))
		{
			foreach (FieldDefinition serializableField in definition.SerializableFields)
			{
				string assignment = string.IsNullOrEmpty(serializableField.FieldName) ? "" : $"m_{serializableField.FieldName} = ";
				if (serializableField.TypeIsByteAlignment4())
				{
					writer.WriteLine($"reader.{nameof(EndianReader.AlignStream)}();");
				}
				else if (serializableField.TypeIsString(out StringSerialization stringSerialization))
				{
					if (stringSerialization == StringSerialization.NullTerminated)
					{
						writer.WriteLine($"{assignment}reader.{nameof(EndianReader.ReadStringZeroTerm)}();");
					}
					else
					{
						throw new Exception("Can't handle this string type");
					}
				}
				else
				{
					if (PrimitiveHandler.GetTypeNameForKeyword(serializableField.TypeName, out string? typeName))
					{
						writer.WriteLine($"{assignment}reader.Read{typeName}();");
					}
					else
					{
						writer.WriteLine($"{assignment}reader.{nameof(EndianReader.ReadEndian)}<{serializableField.TypeName}>();");
					}
				}
			}
			writer.WriteLine($"{postReadMethodName}(reader);");
		}
		writer.WriteLine();

		writer.WriteSummaryDocumentation($"Called when <see cref=\"{readMethodName}\"/> is finished.");
		writer.WriteLine($"partial void {postReadMethodName}({nameof(EndianReader)} reader);");
		writer.WriteLine();
	}

	private static void WriteWriteMethod(IndentedTextWriter writer, TypeDefinition definition)
	{
		const string writeMethodName = nameof(IEndianWritable.Write);
		const string postWriteMethodName = $"On{writeMethodName}Finished";

		writer.WriteLine($"public void {writeMethodName}({nameof(EndianWriter)} writer)");
		using (new CurlyBrackets(writer))
		{
			foreach (FieldDefinition serializableField in definition.SerializableFields)
			{
				if (serializableField.TypeIsByteAlignment4())
				{
					writer.WriteLine($"writer.{nameof(EndianWriter.AlignStream)}();");
				}
				else if (serializableField.TypeIsString(out StringSerialization stringSerialization))
				{
					if (stringSerialization == StringSerialization.NullTerminated)
					{
						string parameter = string.IsNullOrEmpty(serializableField.FieldName)
						? "\"\""
						: $"m_{serializableField.FieldName}";
						writer.WriteLine($"writer.{nameof(EndianWriter.WriteStringZeroTerm)}({parameter});");
					}
					else
					{
						throw new Exception("Can't handle this string type");
					}
				}
				else
				{
					string parameter = string.IsNullOrEmpty(serializableField.FieldName)
						? $"default({serializableField.TypeName})"
						: $"m_{serializableField.FieldName}";
					if (PrimitiveHandler.GetTypeNameForKeyword(serializableField.TypeName, out string? typeName))
					{
						writer.WriteLine($"writer.{nameof(EndianWriter.Write)}({parameter});");
					}
					else
					{
						writer.WriteLine($"writer.{nameof(EndianWriter.WriteEndian)}({parameter});");
					}
				}
			}
			writer.WriteLine($"{postWriteMethodName}(writer);");
		}
		writer.WriteLine();

		writer.WriteSummaryDocumentation($"Called when <see cref=\"{writeMethodName}\"/> is finished.");
		writer.WriteLine($"partial void {postWriteMethodName}({nameof(EndianWriter)} writer);");
		writer.WriteLine();
	}

	internal static void MakeInterface(IndentedTextWriter writer, TypeDeclaration declaration, Dictionary<string, string> propertyTypeDictionary)
	{
		bool isReadOnly = declaration.ContainsModifier("readonly");
		writer.WriteGeneratedCodeWarning();
		foreach (string @using in declaration.Usings.Append("AssetRipper.IO.Endian").Order())
		{
			writer.WriteUsing(@using);
		}
		writer.WriteFileScopedNamespace(declaration.Namespace);
		MaybeWriteDocumentation(writer, declaration.Summary, declaration.Remarks);
		writer.WriteLine($"public partial interface I{declaration.Name} : {nameof(IEndianWritable)}");
		using (new CurlyBrackets(writer))
		{
			foreach ((string propertyName, string propertyType) in propertyTypeDictionary)
			{
				declaration.TryGetPropertyDocumentation(propertyName, out string? summary, out string? remarks);
				MaybeWriteDocumentation(writer, summary, remarks);
				writer.WriteLine(isReadOnly ? $"public {propertyType} {propertyName} {{ get; }}" : $"public {propertyType} {propertyName} {{ get; set; }}");
				writer.WriteLine();
			}
		}
	}
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/InternalSerializerContext.cs`:

```cs
using AssetRipper.IO.Files.SourceGenerator.Json;
using System.Text.Json.Serialization;

namespace AssetRipper.IO.Files.SourceGenerator;

[JsonSerializable(typeof(TypeDeclaration))]
[JsonSerializable(typeof(TypeDefinition))]
internal partial class InternalSerializerContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/Json/EnumField.cs`:

```cs
namespace AssetRipper.IO.Files.SourceGenerator.Json;

internal sealed class EnumField
{
	string Name { get; set; } = string.Empty;
	long Value { get; set; }
	string? Summary { get; set; }
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/Json/FieldDefinition.cs`:

```cs
namespace AssetRipper.IO.Files.SourceGenerator.Json;

internal sealed class FieldDefinition
{
	/// <summary>
	/// The name of this field's type.
	/// </summary>
	public string TypeName { get; set; } = string.Empty;
	/// <summary>
	/// The name of this field.
	/// </summary>
	/// <remarks>
	/// Null is assumed to be filler bytes. In that case, <see cref="TypeName"/> must be a primitive type of predefined size.
	/// </remarks>
	public string? FieldName { get; set; }
	/// <summary>
	/// Special flags for this field. For example:
	/// <list type="bullet">
	/// <item>enum</item>
	/// </list>
	/// </summary>
	public SpecialDetails? Special { get; set; }

	public override string ToString() => $"{TypeName} {FieldName}";

	public bool TypeIsEnum([NotNullWhen(true)] out string? enumName)
	{
		if (Special?.Identifier == "enum")
		{
			enumName = Special.Parameter;
			return enumName is not null;
		}
		else
		{
			enumName = null;
			return false;
		}
	}

	public bool TypeIsString(out StringSerialization type)
	{
		if (TypeName == "string")
		{
			type = Special?.Identifier switch
			{
				"NullTerminated" => StringSerialization.NullTerminated,
				_ => StringSerialization.Unknown,
			};
			return true;
		}
		else
		{
			type = default;
			return false;
		}
	}

	public bool TypeIsByteAlignment4() => TypeName == "align4";

	public bool TypeIsByteAlignment16() => TypeName == "align16";
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/Json/FormatDeclaration.cs`:

```cs
namespace AssetRipper.IO.Files.SourceGenerator.Json;

internal sealed class FormatDeclaration
{
	/// <summary>
	/// The name of this format.
	/// </summary>
	/// <remarks>
	/// This name will serve as the identifier for this format in both other json files and generated source files.
	/// </remarks>
	public string Name { get; set; } = string.Empty;
	/// <summary>
	/// The sub-namespace for this format.
	/// </summary>
	public string Namespace { get; set; } = string.Empty;
	/// <summary>
	/// The magic bytes identifying this format.
	/// </summary>
	/// <remarks>
	/// Only entries of length 1 or 2 are allowed. Length 1 strings are treated as Ascii. Length 2 strings are treated as hexidecimals.
	/// </remarks>
	public string[] Magic { get; set; } = Array.Empty<string>();
	/// <summary>
	/// The size and offset of this format's version enum.
	/// </summary>
	/// <remarks>
	/// Null indicates that this format doesn't include a version number.
	/// </remarks>
	public VersionIdentifier? VersionIdentifier { get; set; }
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/Json/PropertyDocumentation.cs`:

```cs
namespace AssetRipper.IO.Files.SourceGenerator.Json;

internal sealed class PropertyDocumentation
{
	/// <summary>
	/// The summary for this field in xml documentation.
	/// </summary>
	public string? Summary { get; set; }
	/// <summary>
	/// The remarks for this field in xml documentation.
	/// </summary>
	public string? Remarks { get; set; }
	/// <summary>
	/// The default expression to use in a get accessor if no backing field is present. Do not include a semicolon.
	/// </summary>
	public string? GetExpression { get; set; }
	/// <summary>
	/// The default expression to use in a set accessor if no backing field is present. Do not include a semicolon.
	/// </summary>
	public string? SetExpression { get; set; }
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/Json/SpecialDetails.cs`:

```cs
namespace AssetRipper.IO.Files.SourceGenerator.Json;

public sealed class SpecialDetails
{
	public string? Identifier { get; set; }
	public string? Parameter { get; set; }
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/Json/StringType.cs`:

```cs
namespace AssetRipper.IO.Files.SourceGenerator.Json;

public enum StringSerialization
{
	Unknown,
	NullTerminated,
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/Json/TypeDeclaration.cs`:

```cs
namespace AssetRipper.IO.Files.SourceGenerator.Json;

internal sealed class TypeDeclaration
{
	/// <summary>
	/// The name of this type.
	/// </summary>
	/// <remarks>
	/// This name will serve as the identifier for this type in both other json files and generated source files.
	/// </remarks>
	public string Name { get; set; } = string.Empty;
	/// <summary>
	/// The namespace for this type. Must start with "AssetRipper.IO.Files."
	/// </summary>
	public string Namespace { get; set; } = string.Empty;
	/// <summary>
	/// The class type of this type. For example:
	/// <list type="bullet">
	/// <item>struct</item>
	/// <item>readonly struct</item>
	/// <item>record struct</item>
	/// <item>readonly record struct</item>
	/// <item>class</item>
	/// <item>record class</item>
	/// <item>record</item>
	/// </list>
	/// </summary>
	public string ClassType { get; set; } = string.Empty;
	//public bool GenerateBaseClass { get; set; }
	/// <summary>
	/// The summary for this type in xml documentation.
	/// </summary>
	public string? Summary { get; set; }
	/// <summary>
	/// The remarks for this type in xml documentation.
	/// </summary>
	public string? Remarks { get; set; }
	/// <summary>
	/// The magic bytes identifying this format.
	/// </summary>
	public Dictionary<string, PropertyDocumentation?> Properties { get; set; } = new();
	/// <summary>
	/// The additional usings required for this type.
	/// </summary>
	public string[] Usings { get; set; } = Array.Empty<string>();

	public override string ToString()
	{
		return Name;
	}

	public bool TryGetPropertyDocumentation(string property, out string? summary, out string? remarks)
	{
		Properties.TryGetValue(property, out PropertyDocumentation? documentation);
		if (documentation is not null)
		{
			summary = documentation.Summary;
			remarks = documentation.Remarks;
			return !string.IsNullOrEmpty(summary) || !string.IsNullOrEmpty(remarks);
		}
		else
		{
			summary = null;
			remarks = null;
			return false;
		}
	}

	public bool ContainsModifier(string modifier)
	{
		return ClassType.Contains(modifier, StringComparison.Ordinal);
	}
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/Json/TypeDefinition.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.IO.Files.SourceGenerator.Json;

internal sealed class TypeDefinition
{
	/// <summary>
	/// The name of this format.
	/// </summary>
	/// <remarks>
	/// This must match <see cref="TypeDeclaration.Name"/>.
	/// </remarks>
	public string Name { get; set; } = string.Empty;
	/// <summary>
	/// The specific version of this <see cref="TypeDefinition"/>.
	/// </summary>
	/// <remarks>
	/// This value must correspond to one declared in <see cref="VersionIdentifier.Fields"/>.
	/// If this is equal to one, it's assumed to be version-less.
	/// </remarks>
	public long Version { get; set; }
	public List<FieldDefinition> SerializableFields { get; set; } = new();
	public List<FieldDefinition> ExtraFields { get; set; } = new();
	[JsonIgnore]
	public IEnumerable<FieldDefinition> AllFields => SerializableFields.Union(ExtraFields);

	public override string ToString()
	{
		return Name;
	}
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/Json/VersionIdentifier.cs`:

```cs
namespace AssetRipper.IO.Files.SourceGenerator.Json;

internal sealed class VersionIdentifier
{
	/// <summary>
	/// The byte offset of the version number.
	/// </summary>
	public int Offset { get; set; }
	/// <summary>
	/// Is the version number big endian or little endian?
	/// </summary>
	public bool BigEndian { get; set; }
	/// <summary>
	/// The name of the enum to generate.
	/// </summary>
	public string EnumName { get; set; } = string.Empty;
	/// <summary>
	/// Must be a primitive integer.
	/// </summary>
	public string EnumType { get; set; } = string.Empty;
	/// <summary>
	/// The fields for the generated enumeration.
	/// </summary>
	/// <remarks>
	/// The fields must be one-to-one.
	/// </remarks>
	public List<EnumField> Fields { get; set; } = new();
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/ParameterExtensions.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;

namespace AssetRipper.IO.Files.SourceGenerator;

internal static class ParameterExtensions
{
	public static bool IsParams(this ParameterInfo parameter)
	{
		return parameter.GetCustomAttribute<ParamCollectionAttribute>() is not null;
	}

	public static string GetParamsPrefix(this ParameterInfo parameter)
	{
		return parameter.IsParams() ? "params " : "";
	}
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/PrimitiveHandler.cs`:

```cs
using AssetRipper.Primitives;

namespace AssetRipper.IO.Files.SourceGenerator;

internal static class PrimitiveHandler
{
	private static int GetByteSize(string type)
	{
		return type switch
		{
			"sbyte" or "byte" => 1,
			"short" or "ushort" or "Half" => 2,
			"int" or "uint" or "float" => 4,
			"long" or "ulong" or "double" => 8,
			"decimal" => 16,
			"nint" or "nuint" => throw new NotSupportedException(),
			_ => throw new ArgumentOutOfRangeException(nameof(type)),
		};
	}

	public static string GetCommonType(string type1, string type2)
	{
		if (type1 == type2)
		{
			return type1;
		}
		else if (IsInteger(type1) && IsInteger(type2))
		{
			int size1 = GetByteSize(type1);
			int size2 = GetByteSize(type2);

			if (size1 == size2)//different sign
			{
				string signedType = IsSignedInteger(type1) ? type1 : type2;
				return signedType switch
				{
					"sbyte" => "short",
					"short" => "int",
					"int" => "long",
					"long" => throw new NotSupportedException(),
					_ => throw new ArgumentOutOfRangeException(),
				};
			}
			else if (IsSignedInteger(type1) || IsSignedInteger(type2))
			{
				string largerType = size1 > size2 ? type1 : type2;
				return largerType switch
				{
					"short" => "short",
					"ushort" or "int" => "int",
					"uint" or "long" => "long",
					"ulong" => throw new NotSupportedException(),
					_ => throw new ArgumentOutOfRangeException(),
				};
			}
			else
			{
				string largerType = size1 > size2 ? type1 : type2;
				return largerType;
			}
		}
		else if (IsFloatingPoint(type1) && IsFloatingPoint(type2))
		{
			int size1 = GetByteSize(type1);
			int size2 = GetByteSize(type2);
			string largerType = size1 > size2 ? type1 : type2;
			return largerType;
		}
		else
		{
			throw new NotSupportedException();
		}
	}

	public static bool IsInteger(string type) => IsSignedInteger(type) || IsUnsignedInteger(type);

	public static bool IsSignedInteger(string type) => type is "sbyte" or "short" or "int" or "nint" or "long";

	public static bool IsUnsignedInteger(string type) => type is "byte" or "ushort" or "uint" or "nuint" or "ulong";

	public static bool IsFloatingPoint(string type) => type is "Half" or "float" or "double" or "decimal";

	public static bool IsNumber(string type) => IsInteger(type) || IsFloatingPoint(type);

	public static bool GetTypeNameForKeyword(string keyword, [NotNullWhen(true)] out string? typeName)
	{
		typeName = keyword switch
		{
			"bool" => nameof(Boolean),
			"char" => nameof(Char),
			"sbyte" => nameof(SByte),
			"byte" => nameof(Byte),
			"short" => nameof(Int16),
			"ushort" => nameof(UInt16),
			"int" => nameof(Int32),
			"uint" => nameof(UInt32),
			"long" => nameof(Int64),
			"ulong" => nameof(UInt64),
			"nint" => nameof(IntPtr),
			"nuint" => nameof(UIntPtr),
			"float" => nameof(Single),
			"double" => nameof(Double),
			"decimal" => nameof(Decimal),
			"string" => nameof(String),
			nameof(UnityGuid) => nameof(UnityGuid),
			_ => null
		};
		return typeName is not null;
	}
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/Program.cs`:

```cs
using System.Reflection;
using System.Text;

namespace AssetRipper.IO.Files.SourceGenerator;

internal static class Program
{
	public const string SourceDirectory = "../../../../";
	public const string GeneratorProjectDirectory = SourceDirectory + "AssetRipper.IO.Files.SourceGenerator/";
	public const string OutputDirectory = SourceDirectory + "AssetRipper.IO.Files/";
	static void Main(string[] args)
	{
		SerializedFileClassGenerator.GenerateSerializedFileClasses();
		WriteFileSystemClass();
		WriteLocalFileSystemClass();
		WriteVirtualFileSystemClass();
	}

	/// <inheritdoc cref="File.WriteAllBytesAsync(string, byte[], CancellationToken)"/>
	private static void WriteFileSystemClass()
	{
		using IndentedTextWriter writer = IndentedTextWriterFactory.Create(OutputDirectory, "FileSystem");
		writer.WriteGeneratedCodeWarning();
		writer.WriteLineNoTabs();
		writer.WriteFileScopedNamespace("AssetRipper.IO.Files");
		writer.WriteLineNoTabs();
		writer.WriteLine("public abstract partial class FileSystem");
		using (new CurlyBrackets(writer))
		{
			foreach ((string classPropertyName, List<FileSystemApi> classApiList) in apiDictionary)
			{
				writer.WriteLine($"public abstract {classPropertyName}Implementation {classPropertyName} {{ get; }}");
				writer.WriteLineNoTabs();
				writer.WriteLine($"public abstract partial class {classPropertyName}Implementation(FileSystem fileSystem)");
				using (new CurlyBrackets(writer))
				{
					writer.WriteLine("protected FileSystem Parent { get; } = fileSystem;");
					foreach (string otherClassPropertyName in apiDictionary.Keys)
					{
						if (otherClassPropertyName != classPropertyName)
						{
							writer.WriteLine($"protected {otherClassPropertyName}Implementation {otherClassPropertyName} => Parent.{otherClassPropertyName};");
						}
						else
						{
							writer.WriteLine($"protected {otherClassPropertyName}Implementation {otherClassPropertyName} => this;");
						}
					}

					foreach (FileSystemApi api in classApiList)
					{
						// Inherit documentation from System.IO
						writer.WriteLine($"/// <inheritdoc cref=\"{api.FullName}({api.ParametersWithoutNames})\"/>");

						string virtualKeyword = api.Type is FileSystemApiType.Sealed ? "" : "virtual ";
						writer.WriteLine($"public {virtualKeyword}{api.BaseReturnType} {api.Name}({api.ParametersWithTypes})");
						using (new CurlyBrackets(writer))
						{
							if (api.Type is FileSystemApiType.Throw)
							{
								writer.WriteLine("throw new global::System.NotSupportedException();");
							}
							else
							{
								string returnKeyword = api.VoidReturn ? "" : "return ";
								writer.WriteLine($"{returnKeyword}{api.FullName}({api.ParametersWithoutTypes});");
							}
						}
						writer.WriteLineNoTabs();
					}
					writer.WriteComment("Override methods below to provide custom implementation");
					writer.WriteLine("public sealed override string ToString() => base.ToString();");
					writer.WriteLine("public sealed override bool Equals(object obj) => base.Equals(obj);");
					writer.WriteLine("public sealed override int GetHashCode() => base.GetHashCode();");
				}
				writer.WriteLineNoTabs();
			}
		}
	}

	private static void WriteLocalFileSystemClass()
	{
		using IndentedTextWriter writer = IndentedTextWriterFactory.Create(OutputDirectory, "LocalFileSystem");
		writer.WriteGeneratedCodeWarning();
		writer.WriteLineNoTabs();
		writer.WriteFileScopedNamespace("AssetRipper.IO.Files");
		writer.WriteLineNoTabs();
		writer.WriteLine("public sealed partial class LocalFileSystem : FileSystem");
		using (new CurlyBrackets(writer))
		{
			foreach ((string classPropertyName, List<FileSystemApi> classApiList) in apiDictionary)
			{
				writer.WriteLine($"public override Local{classPropertyName}Implementation {classPropertyName} {{ get; }}");
				writer.WriteLineNoTabs();
				writer.WriteLine($"public sealed partial class Local{classPropertyName}Implementation(LocalFileSystem fileSystem) : {classPropertyName}Implementation(fileSystem)");
				using (new CurlyBrackets(writer))
				{
					foreach (FileSystemApi api in classApiList)
					{
						if (api.Type is not FileSystemApiType.Throw)
						{
							continue;
						}

						writer.WriteLine($"public override {api.DerivedReturnType} {api.Name}({api.ParametersWithTypes})");
						using (new CurlyBrackets(writer))
						{
							string returnKeyword = api.VoidReturn ? "" : "return ";
							writer.WriteLine($"{returnKeyword}{api.FullName}({api.ParametersWithoutTypes});");
						}
						writer.WriteLineNoTabs();
					}
				}
				writer.WriteLineNoTabs();
			}

			writer.WriteLine("public LocalFileSystem()");
			using (new CurlyBrackets(writer))
			{
				foreach (string classPropertyName in apiDictionary.Keys)
				{
					writer.WriteLine($"{classPropertyName} = new(this);");
				}
			}
		}
	}

	private static void WriteVirtualFileSystemClass()
	{
		using IndentedTextWriter writer = IndentedTextWriterFactory.Create(OutputDirectory, "VirtualFileSystem");
		writer.WriteGeneratedCodeWarning();
		writer.WriteLineNoTabs();
		writer.WriteFileScopedNamespace("AssetRipper.IO.Files");
		writer.WriteLineNoTabs();
		writer.WriteLine("public sealed partial class VirtualFileSystem : FileSystem");
		using (new CurlyBrackets(writer))
		{
			foreach ((string classPropertyName, List<FileSystemApi> classApiList) in apiDictionary)
			{
				writer.WriteLine($"public override Virtual{classPropertyName}Implementation {classPropertyName} {{ get; }}");
				writer.WriteLineNoTabs();
				writer.WriteLine($"public sealed partial class Virtual{classPropertyName}Implementation(VirtualFileSystem fileSystem) : {classPropertyName}Implementation(fileSystem)");
				using (new CurlyBrackets(writer))
				{
					writer.WriteLine("private new VirtualFileSystem Parent => (VirtualFileSystem)base.Parent;");
					foreach (string otherClassPropertyName in apiDictionary.Keys)
					{
						if (otherClassPropertyName != classPropertyName)
						{
							writer.WriteLine($"private new Virtual{otherClassPropertyName}Implementation {otherClassPropertyName} => Parent.{otherClassPropertyName};");
						}
						else
						{
							writer.WriteLine($"private new Virtual{otherClassPropertyName}Implementation {otherClassPropertyName} => this;");
						}
					}
				}
				writer.WriteLineNoTabs();
			}

			writer.WriteLine("public VirtualFileSystem()");
			using (new CurlyBrackets(writer))
			{
				foreach (string classPropertyName in apiDictionary.Keys)
				{
					writer.WriteLine($"{classPropertyName} = new(this);");
				}
			}
		}
	}

	private static readonly Dictionary<string, List<FileSystemApi>> apiDictionary = new()
	{
		[nameof(File)] =
		[
			new((Func<string, FileStream>)File.Create),
			new(File.Delete),
			new(File.Exists),
			new(File.OpenRead),
			new(File.OpenWrite),
			new(File.ReadAllBytes),
			new((Func<string, string>)File.ReadAllText),
			new((Func<string, Encoding, string>)File.ReadAllText),
			new((Action<string, ReadOnlySpan<byte>>)File.WriteAllBytes),
			new((Action<string, ReadOnlySpan<char>>)File.WriteAllText),
			new((Action<string, ReadOnlySpan<char>, Encoding>)File.WriteAllText),
		],
		[nameof(Directory)] =
		[
			new((Func<string, string, SearchOption, IEnumerable<string>>)Directory.EnumerateDirectories),
			new((Func<string, string, SearchOption, IEnumerable<string>>)Directory.EnumerateFiles),
			new((Func<string, string, SearchOption, IEnumerable<string>>)Directory.GetDirectories),
			new((Func<string, string, SearchOption, IEnumerable<string>>)Directory.GetFiles),
			new((Func<string, string, IEnumerable<string>>)Directory.EnumerateDirectories),
			new((Func<string, string, IEnumerable<string>>)Directory.EnumerateFiles),
			new((Func<string, string, IEnumerable<string>>)Directory.GetDirectories),
			new((Func<string, string, IEnumerable<string>>)Directory.GetFiles),
			new((Func<string, IEnumerable<string>>)Directory.EnumerateDirectories),
			new((Func<string, IEnumerable<string>>)Directory.EnumerateFiles),
			new((Func<string, IEnumerable<string>>)Directory.GetDirectories),
			new((Func<string, IEnumerable<string>>)Directory.GetFiles),
			new(Directory.Exists),
		],
		[nameof(Path)] =
		[
			new((Func<string, string, string>)Path.Join) { Type = FileSystemApiType.Virtual },
			new((Func<string, string, string, string>)Path.Join) { Type = FileSystemApiType.Virtual },
			new((Func<string, string, string, string, string>)Path.Join) { Type = FileSystemApiType.Virtual },
			new((Func<ReadOnlySpan<string?>, string>)Path.Join) { Type = FileSystemApiType.Virtual },
			new((Func<ReadOnlySpan<char>, ReadOnlySpan<char>>)Path.GetDirectoryName) { Type = FileSystemApiType.Sealed },
			new((Func<string?, string?>)Path.GetDirectoryName) { Type = FileSystemApiType.Sealed },
			new((Func<ReadOnlySpan<char>, ReadOnlySpan<char>>)Path.GetExtension) { Type = FileSystemApiType.Sealed },
			new((Func<string?, string?>)Path.GetExtension) { Type = FileSystemApiType.Sealed },
			new((Func<ReadOnlySpan<char>, ReadOnlySpan<char>>)Path.GetFileName) { Type = FileSystemApiType.Sealed },
			new((Func<string, string>)Path.GetFileName) { Type = FileSystemApiType.Sealed },
			new((Func<ReadOnlySpan<char>, ReadOnlySpan<char>>)Path.GetFileNameWithoutExtension) { Type = FileSystemApiType.Sealed },
			new((Func<string, string>)Path.GetFileNameWithoutExtension) { Type = FileSystemApiType.Sealed },
			new((Func<string, string>)Path.GetFullPath),
			new(Path.GetRelativePath) { Type = FileSystemApiType.Sealed },
			new((Func<ReadOnlySpan<char>, bool>)Path.IsPathRooted),
		],
	};

	private enum FileSystemApiType
	{
		Throw,
		Virtual,
		Sealed,
	}

	private sealed record class FileSystemApi
	{
		public required Delegate Delegate { get; init; }
		public MethodInfo MethodInfo => Delegate.Method;
		public FileSystemApiType Type { get; init; } = FileSystemApiType.Throw;
		public string DeclaringType => MethodInfo.DeclaringType!.GetGlobalQualifiedName();
		public string BaseReturnType
		{
			get
			{
				Type returnType = MethodInfo.ReturnType == typeof(FileStream) ? typeof(Stream) : MethodInfo.ReturnType;
				return returnType.GetGlobalQualifiedName();
			}
		}
		public string DerivedReturnType => MethodInfo.ReturnType.GetGlobalQualifiedName();
		public bool VoidReturn => MethodInfo.ReturnType == typeof(void);
		public string Name => MethodInfo.Name;
		public string FullName => $"{DeclaringType}.{Name}";
		public IEnumerable<(string, string)> Parameters => MethodInfo.GetParameters()
			.Select(parameter => (parameter.GetParamsPrefix() + parameter.ParameterType.GetGlobalQualifiedName(), parameter.Name!));
		public string ParametersWithTypes => string.Join(", ", Parameters.Select(parameter => $"{parameter.Item1} {parameter.Item2}"));
		public string ParametersWithoutTypes => string.Join(", ", Parameters.Select(parameter => parameter.Item2));
		public string ParametersWithoutNames => string.Join(", ", Parameters.Select(parameter => parameter.Item1));

		public FileSystemApi()
		{
		}

		[SetsRequiredMembers]
		public FileSystemApi(Delegate @delegate)
		{
			Delegate = @delegate;
		}
	}
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/SerializedFileClassGenerator.cs`:

```cs
using AssetRipper.IO.Files.SourceGenerator.Json;
using System.Text.Json;

namespace AssetRipper.IO.Files.SourceGenerator;

internal static class SerializedFileClassGenerator
{
	internal static void GenerateSerializedFileClasses()
	{
		GenerateForDirectory(Program.GeneratorProjectDirectory + "Formats/SerializedFile/LocalSerializedObjectIdentifier/");
		GenerateForDirectory(Program.GeneratorProjectDirectory + "Formats/SerializedFile/ObjectInfo/");
		GenerateForDirectory(Program.GeneratorProjectDirectory + "Formats/SerializedFile/TypeTreeNode/");
		GenerateForDirectory(Program.GeneratorProjectDirectory + "Formats/SerializedFile/SerializedFileHeader/");
		GenerateForDirectory(Program.GeneratorProjectDirectory + "Formats/SerializedFile/FileIdentifier/");
	}

	private static Dictionary<string, string> BuildPropertyTypeDictionary(List<TypeDefinition> versions)
	{
		if (versions.Count < 1)
		{
			throw new ArgumentException(null, nameof(versions));
		}

		Dictionary<string, string> result = new();
		foreach (TypeDefinition definition in versions)
		{
			foreach (FieldDefinition field in definition.AllFields)
			{
				if (!string.IsNullOrEmpty(field.FieldName))
				{
					string fieldType = field.TypeIsEnum(out string? enumName) ? enumName : field.TypeName;
					if (result.TryGetValue(field.FieldName, out string? type))
					{
						type = PrimitiveHandler.GetCommonType(type, fieldType);
					}
					else
					{
						type = fieldType;
					}
					result[field.FieldName] = type;
				}
			}
		}
		return result;
	}

	private static void GenerateForDirectory(string directory)
	{
		ParseJsonFiles(directory, out TypeDeclaration declaration, out List<TypeDefinition> versions, out TypeDefinition? versionIndependent);

		Dictionary<string, string> propertyTypeDictionary = BuildPropertyTypeDictionary(versions);

		string destination = GetDestinationDirectory(declaration);

		Directory.CreateDirectory(destination);
		{
			using IndentedTextWriter writer = IndentedTextWriterFactory.Create(destination, $"I{declaration.Name}");
			Generator.MakeInterface(writer, declaration, propertyTypeDictionary);
		}
		foreach (TypeDefinition version in versions)
		{
			using IndentedTextWriter writer = IndentedTextWriterFactory.Create(destination, $"{declaration.Name}_{version.Version}");
			Generator.MakeType(writer, declaration, version, propertyTypeDictionary);
		}
	}

	private static string GetDestinationDirectory(TypeDeclaration declaration)
	{
		const string prefix = "AssetRipper.IO.Files.";
		if (declaration.Namespace.StartsWith(prefix, StringComparison.Ordinal))
		{
			string subDirectory = declaration.Namespace.Substring(prefix.Length).Replace('.', '/');
			return $"{Program.OutputDirectory}{subDirectory}/";
		}
		else
		{
			throw new ArgumentException(null, nameof(declaration));
		}
	}

	private static void ParseJsonFiles(string directory, [NotNull] out TypeDeclaration? declaration, out List<TypeDefinition> versions, out TypeDefinition? versionIndependent)
	{
		DirectoryInfo directoryInfo = new DirectoryInfo(directory);
		if (!directoryInfo.Exists)
		{
			throw new DirectoryNotFoundException(directory);
		}

		string declarationFileName = $"{directoryInfo.Name}.json";

		versions = new();
		versionIndependent = null;
		declaration = null;
		foreach (FileInfo fileInfo in directoryInfo.EnumerateFiles("*.json"))
		{
			string text = File.ReadAllText(fileInfo.FullName);
			if (fileInfo.Name == declarationFileName)
			{
				declaration = JsonSerializer.Deserialize(text, InternalSerializerContext.Default.TypeDeclaration);
			}
			else
			{
				TypeDefinition definition = JsonSerializer.Deserialize(text, InternalSerializerContext.Default.TypeDefinition) ?? throw new NullReferenceException();
				if (definition.Version == -1)
				{
					if (versionIndependent is null)
					{
						versionIndependent = definition;
					}
					else
					{
						throw new Exception();
					}
				}
				else
				{
					versions.Add(definition);
				}
			}
		}

		if (declaration is null)
		{
			throw new NullReferenceException();
		}
	}
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/TypeExtensions.cs`:

```cs
namespace AssetRipper.IO.Files.SourceGenerator;

internal static class TypeExtensions
{
	public static string GetGlobalQualifiedName(this Type type)
	{
		if (type == typeof(void))
		{
			return "void";
		}
		else if (type.IsGenericType)
		{
			// Handle generic types by appending generic arguments
			string genericTypeDefinition = type.GetGenericTypeDefinition().FullName!;
			string genericArguments = string.Join(", ", type.GetGenericArguments().Select(GetGlobalQualifiedName));
			return $"global::{genericTypeDefinition[..genericTypeDefinition.IndexOf('`')]}<{genericArguments}>";
		}
		else if (type.IsArray)
		{
			// Handle arrays
			return $"{type.GetElementType()!.GetGlobalQualifiedName()}[{new string(',', type.GetArrayRank() - 1)}]";
		}
		else
		{
			return $"global::{type.FullName}";
		}
	}
}

```

`Source/AssetRipper.IO.Files.SourceGenerator/Usings.cs`:

```cs
global using AssetRipper.Text.SourceGeneration;
global using System.CodeDom.Compiler;
global using System.Diagnostics.CodeAnalysis;

```

`Source/AssetRipper.IO.Files.Tests/AssetRipper.IO.Files.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<IsPackable>false</IsPackable>
		<OutputPath>..\0Bins\Other\AssetRipper.IO.Files.Tests\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.IO.Files.Tests\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
		<PackageReference Include="NUnit" Version="4.4.0" />
		<PackageReference Include="NUnit3TestAdapter" Version="6.1.0" />
		<PackageReference Include="NUnit.Analyzers" Version="4.11.2">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.IO.Files\AssetRipper.IO.Files.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.IO.Files.Tests/BrotliFileSchemeTest.cs`:

```cs
using AssetRipper.IO.Files.CompressedFiles.Brotli;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.Tests;

public class BrotliFileSchemeTests
{
	[Test]
	public void CanRead_ReturnsFalse_OnEmptyStream()
	{
		SmartStream stream = SmartStream.CreateMemory(Array.Empty<byte>());
		BrotliFileScheme scheme = new();

		bool result = scheme.CanRead(stream);

		Assert.That(result, Is.False);
	}

	[Test]
	public void CanRead_ReturnsFalse_OnNonBrotliFile()
	{
		SmartStream stream = SmartStream.CreateMemory(new byte[32]);
		BrotliFileScheme scheme = new();

		bool result = scheme.CanRead(stream);

		Assert.That(result, Is.False);
	}
}

```

`Source/AssetRipper.IO.Files.Tests/FileStreamTests.cs`:

```cs
using AssetRipper.IO.Files.BundleFiles;
using AssetRipper.IO.Files.BundleFiles.FileStream;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.Tests;

public static class FileStreamTests
{
	[TestCase(BundleVersion.BF_260_340, "3.4.0")]
	[TestCase(BundleVersion.BF_350_4x, "4.2.0")]
	[TestCase(BundleVersion.BF_520a1, "5.2.0a1")]
	[TestCase(BundleVersion.BF_520aunk, "5.2.0a10")]
	[TestCase(BundleVersion.BF_520_x, "5.3.0f1")]
	[TestCase(BundleVersion.BF_520_x, "2018.4.40f1")]
	[TestCase(BundleVersion.BF_LargeFilesSupport, "2022.1.0f1")]
	[TestCase(BundleVersion.BF_LargeFilesSupport, "2022.1.10f1")]
	[TestCase(BundleVersion.BF_2022_2, "2022.2.0f1")]
	public static void ReadIsSymmetricToWriteForEmptyBundle(BundleVersion bundleVersion, string unityVersion)
	{
		FileStreamBundleScheme scheme = new();
		FileStreamBundleFile bundle = MakeEmptyBundle(bundleVersion, unityVersion);
		using SmartStream stream = SmartStream.CreateMemory();

		bundle.Write(stream);
		long positionAfterWrite = stream.Position;
		stream.Position = 0;
		using (Assert.EnterMultipleScope())
		{
			Assert.That(positionAfterWrite, Is.GreaterThan(0));
			Assert.That(scheme.CanRead(stream));
		}

		FileStreamBundleFile readBundle = scheme.Read(stream, bundle.FilePath, bundle.Name);
		long positionAfterRead = stream.Position;
		using (Assert.EnterMultipleScope())
		{
			Assert.That(readBundle.Header, Is.EqualTo(bundle.Header));
			Assert.That(positionAfterRead, Is.EqualTo(positionAfterWrite));
		}
	}

	[Test]
	public static void CompressTypeWorks()
	{
		FileStreamBundleHeader header = new();
		header.Flags = BundleFlags.BlockInfoNeedPaddingAtStart | BundleFlags.BlocksInfoAtTheEnd;
		Assert.That(header.CompressionType, Is.EqualTo(CompressionType.None));
		header.CompressionType = CompressionType.Lzma;
		using (Assert.EnterMultipleScope())
		{
			Assert.That(header.CompressionType, Is.EqualTo(CompressionType.Lzma));
			Assert.That(header.Flags, Is.EqualTo(BundleFlags.BlockInfoNeedPaddingAtStart | BundleFlags.BlocksInfoAtTheEnd | BundleFlags.CompressionBit1));
		}
		header.CompressionType = CompressionType.Lz4;
		using (Assert.EnterMultipleScope())
		{
			Assert.That(header.CompressionType, Is.EqualTo(CompressionType.Lz4));
			Assert.That(header.Flags, Is.EqualTo(BundleFlags.BlockInfoNeedPaddingAtStart | BundleFlags.BlocksInfoAtTheEnd | BundleFlags.CompressionBit2));
		}
	}

	private static FileStreamBundleFile MakeEmptyBundle(BundleVersion bundleVersion, string unityVersion)
	{
		FileStreamBundleFile bundle = new();
		FileStreamBundleHeader header = bundle.Header;
		header.Version = bundleVersion;
		header.UnityWebBundleVersion = "5.x.x";
		header.UnityWebMinimumRevision = unityVersion;
		return bundle;
	}
}

```

`Source/AssetRipper.IO.Files.Tests/GZipFileTests.cs`:

```cs
using AssetRipper.IO.Files.CompressedFiles.GZip;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.Tests;

public static class GZipFileTests
{
	[Test]
	public static void GZipFileReadWriteSymmetry()
	{
		const string Name = "Path.Extension";
		const string FilePath = $"C://Some/Absolute/{Name}";
		const int UncompressedSize = 4067;
		byte[] randomData = RandomData.MakeRandomData(UncompressedSize);

		GZipFile file = new()
		{
			FilePath = FilePath,
			Name = Name,
		};
		file.UncompressedFile = new ResourceFile(SmartStream.CreateMemory(randomData), file.FilePath, file.Name);

		SmartStream memoryStream = SmartStream.CreateMemory();
		file.Write(memoryStream);
		using (Assert.EnterMultipleScope())
		{
			Assert.That(memoryStream.Position, Is.GreaterThan(0));
			Assert.That(memoryStream.IsNull, Is.False);
		}
		memoryStream.Position = 0;

		GZipFileScheme fileScheme = new();
		Assert.That(fileScheme.CanRead(memoryStream));
		GZipFile newFile = fileScheme.Read(memoryStream, FilePath, Name);
		using (Assert.EnterMultipleScope())
		{
			Assert.That(newFile.Name, Is.EqualTo(file.Name));
			Assert.That(newFile.FilePath, Is.EqualTo(file.FilePath));
			Assert.That(newFile.UncompressedFile, Is.Not.Null);
			Assert.That(memoryStream.Position, Is.GreaterThan(0));
			Assert.That(memoryStream.IsNull, Is.False);
		}
		byte[] decompressedData = newFile.UncompressedFile!.ToByteArray();
		Assert.That(decompressedData, Is.EqualTo(randomData));
	}
}

```

`Source/AssetRipper.IO.Files.Tests/GetUniqueNameTests.cs`:

```cs
namespace AssetRipper.IO.Files.Tests;

public static class GetUniqueNameTests
{
	[Test]
	public static void FilenameTruncationMultibyteCharacter()
	{
		using (Assert.EnterMultipleScope())
		{
			// A        length 3 cont     cont     cont
			// 01000001 11100110 10010110 10000111 00001010
			Assert.That(new VirtualFileSystem().GetUniqueName("/dir", "A文.ext", 4), Is.EqualTo(".ext"));
			Assert.That(new VirtualFileSystem().GetUniqueName("/dir", "A文.ext", 5), Is.EqualTo("A.ext"));
			Assert.That(new VirtualFileSystem().GetUniqueName("/dir", "A文.ext", 6), Is.EqualTo("A.ext"));
			Assert.That(new VirtualFileSystem().GetUniqueName("/dir", "A文.ext", 7), Is.EqualTo("A.ext"));
			Assert.That(new VirtualFileSystem().GetUniqueName("/dir", "A文.ext", 8), Is.EqualTo("A文.ext"));
			Assert.That(new VirtualFileSystem().GetUniqueName("/dir", "A文.ext", 9), Is.EqualTo("A文.ext"));
		}
	}

	[Test]
	public static void ExtensionLength()
	{
		using (Assert.EnterMultipleScope())
		{
			Assert.That(new VirtualFileSystem().GetUniqueName("/dir", "A文.ext", 7), Is.EqualTo("A.ext"));
			Assert.That(new VirtualFileSystem().GetUniqueName("/dir", "A文.ext", 8), Is.EqualTo("A文.ext"));

			Assert.That(new VirtualFileSystem().GetUniqueName("/dir", "A文.exte", 8), Is.EqualTo("A.exte"));
			Assert.That(new VirtualFileSystem().GetUniqueName("/dir", "A文.exte", 9), Is.EqualTo("A文.exte"));
		}
	}

	[Test]
	public static void WithoutExtension()
	{
		using (Assert.EnterMultipleScope())
		{
			Assert.That(new VirtualFileSystem().GetUniqueName("/dir", "A文", 3), Is.EqualTo("A"));
			Assert.That(new VirtualFileSystem().GetUniqueName("/dir", "A文", 4), Is.EqualTo("A文"));
		}
	}
}

```

`Source/AssetRipper.IO.Files.Tests/LzmaCompressionTests.cs`:

```cs
using AssetRipper.IO.Files.BundleFiles;

namespace AssetRipper.IO.Files.Tests;

public static class LzmaCompressionTests
{
	[Test]
	public static void LzmaStreamSymmetryTest()
	{
		const int UncompressedSize = 4075;
		byte[] randomData = RandomData.MakeRandomData(UncompressedSize);

		MemoryStream uncompressedStream = new MemoryStream(randomData);
		MemoryStream compressedStream = new();
		long compressedSize = LzmaCompression.CompressLzmaStream(uncompressedStream, UncompressedSize, compressedStream);
		Assert.That(uncompressedStream.Position, Is.EqualTo(UncompressedSize));

		compressedStream.Position = 0;
		MemoryStream decompressedStream = new();
		LzmaCompression.DecompressLzmaStream(compressedStream, compressedSize, decompressedStream, UncompressedSize);
		byte[] decompressedData = decompressedStream.ToArray();

		Assert.That(decompressedData, Is.EqualTo(randomData));
	}

	[Test]
	public static void LzmaStreamSymmetryTestForPartialInputStream()
	{
		const int UncompressedSize = 4077;
		const int InitialOffset = 34;
		const int TrailingCount = 50;
		byte[] randomData = RandomData.MakeRandomData(InitialOffset + UncompressedSize + TrailingCount);

		MemoryStream uncompressedStream = new MemoryStream(randomData);
		uncompressedStream.Position += InitialOffset;

		MemoryStream compressedStream = new();
		long compressedSize = LzmaCompression.CompressLzmaStream(uncompressedStream, UncompressedSize, compressedStream);
		Assert.That(uncompressedStream.Position, Is.EqualTo(InitialOffset + UncompressedSize));

		compressedStream.Position = 0;
		MemoryStream decompressedStream = new();
		LzmaCompression.DecompressLzmaStream(compressedStream, compressedSize, decompressedStream, UncompressedSize);
		byte[] decompressedData = decompressedStream.ToArray();

		Assert.That((ArraySegment<byte>)decompressedData, Is.EqualTo(new ArraySegment<byte>(randomData, InitialOffset, UncompressedSize)));
	}

	[Test]
	public static void LzmaSizeStreamSymmetryTest()
	{
		const int UncompressedSize = 4067;
		byte[] randomData = RandomData.MakeRandomData(UncompressedSize);

		MemoryStream uncompressedStream = new MemoryStream(randomData);
		MemoryStream compressedStream = new();
		long compressedSize = LzmaCompression.CompressLzmaSizeStream(uncompressedStream, UncompressedSize, compressedStream);
		Assert.That(uncompressedStream.Position, Is.EqualTo(UncompressedSize));

		compressedStream.Position = 0;
		MemoryStream decompressedStream = new();
		LzmaCompression.DecompressLzmaSizeStream(compressedStream, compressedSize, decompressedStream);
		byte[] decompressedData = decompressedStream.ToArray();

		Assert.That(decompressedData, Is.EqualTo(randomData));
	}

	[Test]
	public static void LzmaSizeStreamSymmetryTestForPartialInputStream()
	{
		const int UncompressedSize = 4087;
		const int InitialOffset = 44;
		const int TrailingCount = 40;
		byte[] randomData = RandomData.MakeRandomData(InitialOffset + UncompressedSize + TrailingCount);

		MemoryStream uncompressedStream = new MemoryStream(randomData);
		uncompressedStream.Position += InitialOffset;

		MemoryStream compressedStream = new();
		long compressedSize = LzmaCompression.CompressLzmaSizeStream(uncompressedStream, UncompressedSize, compressedStream);
		Assert.That(uncompressedStream.Position, Is.EqualTo(InitialOffset + UncompressedSize));

		compressedStream.Position = 0;
		MemoryStream decompressedStream = new();
		LzmaCompression.DecompressLzmaSizeStream(compressedStream, compressedSize, decompressedStream);
		byte[] decompressedData = decompressedStream.ToArray();

		Assert.That((ArraySegment<byte>)decompressedData, Is.EqualTo(new ArraySegment<byte>(randomData, InitialOffset, UncompressedSize)));
	}
}

```

`Source/AssetRipper.IO.Files.Tests/RandomData.cs`:

```cs
namespace AssetRipper.IO.Files.Tests;

internal static class RandomData
{
	public static byte[] MakeRandomData(int size)
	{
		byte[] data = new byte[size];
		TestContext.CurrentContext.Random.NextBytes(data);
		return data;
	}
}

```

`Source/AssetRipper.IO.Files.Tests/SerializedFileTests.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.Tests;

internal class SerializedFileTests
{
	[Theory]
	public void WritingSerializedFileDoesNotThrow(FormatVersion generation)
	{
		Assert.DoesNotThrow(() =>
		{
			SerializedFileBuilder builder = new() { Generation = generation };
			SerializedFile file = builder.Build();
			using SmartStream stream = SmartStream.CreateMemory();
			file.Write(stream);
		});
	}

	[Theory]
	public void WrittenSerializedFileCanBeRead(FormatVersion generation)
	{
		SerializedFileBuilder builder = new() { Generation = generation };
		SerializedFile file = builder.Build();
		using SmartStream stream = SmartStream.CreateMemory();
		file.Write(stream);
		stream.Flush();
		stream.Position = 0;
		Assert.That(SerializedFileScheme.Default.CanRead(stream));
	}

	[Theory]
	public void ReadingAndWritingAreConsistent(FormatVersion generation)
	{
		SerializedFileBuilder builder = new() { Generation = generation };
		SerializedFile original = builder.Build();
		AssertReadingAndWritingAreConsistent(original);
	}

	private static void AssertReadingAndWritingAreConsistent(SerializedFile original)
	{
		SerializedFile read;
		{
			using SmartStream stream = SmartStream.CreateMemory();
			original.Write(stream);
			stream.Flush();
			stream.Position = 0;
			read = SerializedFileScheme.Default.Read(stream, original.FilePath, original.Name);
		}

		using (Assert.EnterMultipleScope())
		{
			Assert.That(read.Generation, Is.EqualTo(original.Generation));
			Assert.That(read.Version, Is.EqualTo(original.Version));
			Assert.That(read.Platform, Is.EqualTo(original.Platform));
			Assert.That(read.EndianType, Is.EqualTo(original.EndianType));
			Assert.That(read.Flags, Is.EqualTo(original.Flags));
			Assert.That(read.Dependencies.ToArray(), Is.EqualTo(original.Dependencies.ToArray()));
			Assert.That(read.Objects.ToArray(), Is.EqualTo(original.Objects.ToArray()));
		}
	}

	[Theory]
	public void SerializeFileHeaderReadingMatchesWriting(FormatVersion generation)
	{
		SerializedFileHeader header = new()
		{
			Version = generation,
			MetadataSize = 256,//arbitrary number greater than 0
		};
		using MemoryStream stream = new();
		using (EndianWriter writer = new(stream, EndianType.BigEndian))
		{
			header.Write(writer);
		}
		stream.Flush();
		Assert.That(stream.Position, Is.GreaterThan(0));
		stream.Position = 0;
		SerializedFileHeader readHeader = new();
		using (EndianReader reader = new(stream, EndianType.BigEndian))
		{
			readHeader.Read(reader);
		}

		using (Assert.EnterMultipleScope())
		{
			Assert.That(stream.Position, Is.EqualTo(stream.Length));
			Assert.That(readHeader, Is.EqualTo(header));
		}
	}
}

```

`Source/AssetRipper.IO.Files.Tests/SmartStreamTests.cs`:

```cs
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.Tests;

public class SmartStreamTests
{
	[Test]
	public void StreamsHaveTheCorrectStreamType()
	{
		using (Assert.EnterMultipleScope())
		{
			Assert.That(SmartStream.CreateNull().StreamType, Is.EqualTo(SmartStreamType.Null));
			Assert.That(SmartStream.CreateTemp().StreamType, Is.EqualTo(SmartStreamType.File));
			Assert.That(SmartStream.CreateMemory().StreamType, Is.EqualTo(SmartStreamType.Memory));
		}
	}

	[Test]
	public void MemoryStreamMaintainTheirLength()
	{
		const int Length = 64;
		SmartStream memoryStream = SmartStream.CreateMemory(new byte[Length]);
		Assert.That(memoryStream.Length, Is.EqualTo(Length));
	}

	[Test]
	public void ToArrayMakesAPerfectCopyForMemorySmartStreams()
	{
		const int Length = 87;
		byte[] randomData = RandomData.MakeRandomData(Length);
		SmartStream memoryStream = SmartStream.CreateMemory(randomData);
		Assert.That(memoryStream.ToArray(), Is.EqualTo(randomData));
	}

	[Test]
	public void FreedStreamsMustBeNull()
	{
		SmartStream stream = SmartStream.CreateMemory();
		using (Assert.EnterMultipleScope())
		{
			Assert.That(stream.RefCount, Is.EqualTo(1));
			Assert.That(stream.IsNull, Is.False);
			Assert.That(stream.StreamType, Is.EqualTo(SmartStreamType.Memory));
		}
		stream.FreeReference();
		using (Assert.EnterMultipleScope())
		{
			Assert.That(stream.RefCount, Is.Zero);
			Assert.That(stream.IsNull, Is.True);
			Assert.That(stream.StreamType, Is.EqualTo(SmartStreamType.Null));
		}
	}

	[Test]
	public void NullStreamIsNullAndHasRefCountZero()
	{
		using (Assert.EnterMultipleScope())
		{
			Assert.That(SmartStream.CreateNull().RefCount, Is.Zero);
			Assert.That(SmartStream.CreateNull().IsNull);
		}
	}

	[Test]
	public void DisposedStreamThrowsForManyMembers()
	{
		using (Assert.EnterMultipleScope())
		{
			Assert.DoesNotThrow(() => SmartStream.CreateNull().Flush());
			Assert.DoesNotThrow(() => _ = SmartStream.CreateNull().CanRead);
			Assert.DoesNotThrow(() => _ = SmartStream.CreateNull().CanSeek);
			Assert.DoesNotThrow(() => _ = SmartStream.CreateNull().CanWrite);
			Assert.DoesNotThrow(() => _ = SmartStream.CreateNull().Position);
			Assert.DoesNotThrow(() => _ = SmartStream.CreateNull().Length);
			Assert.DoesNotThrow(() => _ = SmartStream.CreateNull().RefCount);
			Assert.DoesNotThrow(() => _ = SmartStream.CreateNull().IsNull);
			Assert.DoesNotThrow(() => _ = SmartStream.CreateNull().StreamType);

			//Count should match up with the number of references to ThrowIfNull
			Assert.Throws<NullReferenceException>(() => SmartStream.CreateNull().ReadExactly(new byte[2], 1, 1));
			Assert.Throws<NullReferenceException>(() => SmartStream.CreateNull().ReadExactly(new byte[2]));
			Assert.Throws<NullReferenceException>(() => SmartStream.CreateNull().ReadByte());
			Assert.Throws<NullReferenceException>(() => SmartStream.CreateNull().Seek(0, SeekOrigin.Begin));
			Assert.Throws<NullReferenceException>(() => SmartStream.CreateNull().SetLength(2));
			Assert.Throws<NullReferenceException>(() => SmartStream.CreateNull().Write(new byte[2], 1, 1));
			Assert.Throws<NullReferenceException>(() => SmartStream.CreateNull().Position = default);
			Assert.Throws<NullReferenceException>(() => SmartStream.CreateNull().ToArray());
		}
	}
}

```

`Source/AssetRipper.IO.Files.Tests/Usings.cs`:

```cs
global using NUnit.Framework;
```

`Source/AssetRipper.IO.Files.Tests/VirtualFileSystemTests.cs`:

```cs
namespace AssetRipper.IO.Files.Tests;

public class VirtualFileSystemTests
{
	[Test]
	public void StartsWithRoot()
	{
		Assert.That(new VirtualFileSystem().Count, Is.EqualTo(1));
	}

	[Test]
	public void RootExists()
	{
		Assert.That(new VirtualFileSystem().Directory.Exists("/"), Is.True);
	}

	[Test]
	public void EmptyRootExists()
	{
		Assert.That(new VirtualFileSystem().Directory.Exists(""), Is.True);
	}

	[Test]
	public void NullRootExists()
	{
		Assert.That(new VirtualFileSystem().Directory.Exists(null), Is.True);
	}

	[Test]
	public void NonexistentDirectoryDoesNotExist()
	{
		Assert.That(new VirtualFileSystem().Directory.Exists("/test"), Is.False);
	}

	[Test]
	public void CreateRootedDirectorySucceeds()
	{
		VirtualFileSystem fs = new();
		fs.Directory.Create("/test");
		Assert.That(fs.Directory.Exists("/test"), Is.True);
	}

	[Test]
	public void CreateNonrootedDirectorySucceeds()
	{
		VirtualFileSystem fs = new();
		fs.Directory.Create("test");
		Assert.That(fs.Directory.Exists("test"), Is.True);
	}

	[Test]
	public void NonrootDirectoryPathsAreValidInputToExists()
	{
		VirtualFileSystem fs = new();
		fs.Directory.Create("/test");
		Assert.That(fs.Directory.Exists("test"), Is.True);
	}

	[Test]
	public void CreatingDirectoryTwiceDoesNotThrow()
	{
		Assert.DoesNotThrow(() =>
		{
			VirtualFileSystem fs = new();
			fs.Directory.Create("/test");
			fs.Directory.Create("/test");
		});
	}

	[Test]
	public void CreatingChildDirectoryAfterCreatingParentSucceeds()
	{
		VirtualFileSystem fs = new();
		fs.Directory.Create("/test");
		fs.Directory.Create("/test/child");
		Assert.That(fs.Directory.Exists("/test/child"), Is.True);
	}

	[Test]
	public void CreatingChildDirectoryWithoutCreatingParentSucceeds()
	{
		VirtualFileSystem fs = new();
		fs.Directory.Create("/test/child");
		Assert.That(fs.Directory.Exists("/test/child"), Is.True);
	}

	[Test]
	public void CreatingChildDirectoryCreatesParent()
	{
		VirtualFileSystem fs = new();
		fs.Directory.Create("/test/child");
		Assert.That(fs.Directory.Exists("/test"), Is.True);
	}

	[Test]
	public void CreatingChildDirectoryCreatesGrandparent()
	{
		VirtualFileSystem fs = new();
		fs.Directory.Create("/test/child/grandchild");
		Assert.That(fs.Directory.Exists("/test"), Is.True);
	}

	[Test]
	public void TrailingSlashIsIgnoredDuringCreation()
	{
		VirtualFileSystem fs = new();
		fs.Directory.Create("/test/");
		using (Assert.EnterMultipleScope())
		{
			Assert.That(fs.Directory.Exists("/test"), Is.True);
			Assert.That(fs.Count, Is.EqualTo(2));// root and test
		}
	}

	[Test]
	public void TrailingSlashIsIgnoredDuringExistenceCheck()
	{
		VirtualFileSystem fs = new();
		fs.Directory.Create("/test");
		Assert.That(fs.Directory.Exists("/test/"), Is.True);
	}

	[Test]
	public void CreatingFileInNonexistentDirectoryThrows()
	{
		Assert.Throws<DirectoryNotFoundException>(() =>
		{
			VirtualFileSystem fs = new();
			fs.File.Create("/test/file");
		});
	}

	[Test]
	public void CreatingFileInExistentDirectorySucceeds()
	{
		Assert.DoesNotThrow(() =>
		{
			VirtualFileSystem fs = new();
			fs.Directory.Create("/test");
			fs.File.Create("/test/file");
		});
	}

	[Test]
	public void CreatingFileTwiceSucceeds()
	{
		Assert.DoesNotThrow(() =>
		{
			VirtualFileSystem fs = new();
			fs.Directory.Create("/test");
			fs.File.Create("/test/file");
			fs.File.Create("/test/file");
		});
	}

	[Test]
	public void CreatingRootedFileSucceeds()
	{
		Assert.DoesNotThrow(() =>
		{
			VirtualFileSystem fs = new();
			fs.File.Create("/test");
		});
	}

	[Test]
	public void NewlyCreatedFileHasLengthZero()
	{
		VirtualFileSystem fs = new();
		Stream stream = fs.File.Create("/test");
		Assert.That(stream.Length, Is.Zero);
	}

	[Test]
	public void ReadWriteTextParity()
	{
		VirtualFileSystem fs = new();
		string path = "/test";
		string contents = "Hello, world!";
		fs.File.WriteAllText(path, contents);
		string readContents = fs.File.ReadAllText(path);
		Assert.That(readContents, Is.EqualTo(contents));
	}

	[Test]
	public void ReadWriteBytesParity()
	{
		VirtualFileSystem fs = new();
		string path = "/test";
		byte[] bytes = [0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21];
		fs.File.WriteAllBytes(path, bytes);
		byte[] readBytes = fs.File.ReadAllBytes(path);
		Assert.That(readBytes, Is.EqualTo(bytes));
	}

	[Test]
	public void EnumerateFilesTopLevelDoesNotFindDeepResults()
	{
		VirtualFileSystem fs = new();
		fs.Directory.Create("/dir");
		fs.File.Create("/dir/deep");
		fs.File.Create("/test");
		IEnumerable<string> files = fs.Directory.EnumerateFiles("/", "*", SearchOption.TopDirectoryOnly);
		Assert.That(files, Is.EquivalentTo(["/test"]));
	}

	[Test]
	public void EnumerateFilesRecursiveDoesFindDeepResults()
	{
		VirtualFileSystem fs = new();
		fs.Directory.Create("/dir");
		fs.File.Create("/dir/deep");
		fs.File.Create("/test");
		IEnumerable<string> files = fs.Directory.EnumerateFiles("/", "*", SearchOption.AllDirectories);
		Assert.That(files, Is.EquivalentTo(["/dir/deep", "/test"]));
	}
}

```

`Source/AssetRipper.IO.Files.Tests/WebFileTests.cs`:

```cs
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.Streams.Smart;
using AssetRipper.IO.Files.WebFiles;

namespace AssetRipper.IO.Files.Tests;

public class WebFileTests
{
	[Test]
	public void ReadIsSymmetricToWriteForFileWithNoEntries()
	{
		WebFileScheme scheme = new();
		WebFile bundle = new();
		using SmartStream stream = SmartStream.CreateMemory();

		bundle.Write(stream);
		long positionAfterWrite = stream.Position;
		stream.Position = 0;
		using (Assert.EnterMultipleScope())
		{
			Assert.That(positionAfterWrite, Is.GreaterThan(0));
			Assert.That(scheme.CanRead(stream));
		}

		WebFile readBundle = scheme.Read(stream, bundle.FilePath, bundle.Name);
		long positionAfterRead = stream.Position;
		using (Assert.EnterMultipleScope())
		{
			Assert.That(positionAfterRead, Is.EqualTo(positionAfterWrite));
		}
	}

	[Test]
	public void ReadIsSymmetricToWriteForFileWithOneEntry()
	{
		const int ResourceFileSize = 23;
		const string ResourceFilePath = "Test/Resource.resource";
		const string ResourceName = "Resource.resource";
		WebFileScheme scheme = new();
		WebFile bundle = new();
		bundle.AddResourceFile(new ResourceFile(SmartStream.CreateMemory(new byte[ResourceFileSize]), ResourceFilePath, ResourceName));

		using SmartStream stream = SmartStream.CreateMemory();

		bundle.Write(stream);
		long positionAfterWrite = stream.Position;
		stream.Position = 0;
		using (Assert.EnterMultipleScope())
		{
			Assert.That(positionAfterWrite, Is.GreaterThan(0));
			Assert.That(scheme.CanRead(stream));
		}

		WebFile readBundle = scheme.Read(stream, bundle.FilePath, bundle.Name);
		long positionAfterRead = stream.Position;
		using (Assert.EnterMultipleScope())
		{
			Assert.That(positionAfterRead, Is.EqualTo(positionAfterWrite), () => "Incorrect end position");
			Assert.That(readBundle.ResourceFiles, Has.Count.EqualTo(1), () => "Incorrect count");
		}
		Assert.That(readBundle.ResourceFiles[0].Stream, Has.Length.EqualTo(ResourceFileSize));
	}
}

```

`Source/AssetRipper.IO.Files/AssetRipper.IO.Files.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.IO.Files\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.IO.Files\$(Configuration)\</IntermediateOutputPath>
		<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.IO.Endian" Version="2.0.2" />
		<PackageReference Include="AssetRipper.Primitives" Version="3.2.0" />
		<PackageReference Include="K4os.Compression.LZ4" Version="1.3.8" />
		<PackageReference Include="SharpCompress" Version="0.44.4" />
		<PackageReference Include="ZstdSharp.Port" Version="0.8.7" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.IO.Files/AssetType.cs`:

```cs
namespace AssetRipper.IO.Files;

public enum AssetType
{
	/// <summary>
	/// Used by released game
	/// </summary>
	Internal = 0,
	/// <summary>
	/// Library asset file. It is editor created file, it doesn't exist in Assets directory
	/// It has the format "library/cache/[first Hash byte as hex]/[Hash as hex]"
	/// </summary>
	Cached = 1,
	/// <summary>
	/// Serialized asset file. It contains all parameters inside itself
	/// </summary>
	Serialized = 2,
	/// <summary>
	/// Binary asset file. It contains all parameters inside meta file
	/// </summary>
	/// <remarks>
	/// On Unity 3, this is only used for 3D models. Images and audio use <see cref="Cached"/> instead.
	/// </remarks>
	Meta = 3,
}

```

`Source/AssetRipper.IO.Files/BuildTarget.cs`:

```cs
namespace AssetRipper.IO.Files;

/// <summary>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/BuildTarget.cs"/>
/// </summary>
public enum BuildTarget : uint
{
	ValidPlayer = 1,
	/// <summary>
	/// Build a universal macOS standalone
	/// </summary>
	StandaloneOSXUniversal = 2,
	/// <summary>
	/// Build a macOS standalone (PowerPC only)
	/// </summary>
	StandaloneOSXPPC = 3,
	/// <summary>
	/// Build a macOS standalone (Intel only)
	/// </summary>
	StandaloneOSXIntel = 4,
	/// <summary>
	/// Build a Windows standalone
	/// </summary>
	StandaloneWinPlayer = 5,
	/// <summary>
	/// Build a web player.
	/// </summary>
	WebPlayerLZMA = 6,
	/// <summary>
	/// Build a streamed web player
	/// </summary>
	WebPlayerLZMAStreamed = 7,
	Wii = 8,
	/// <summary>
	/// Build an iOS player
	/// </summary>
	iOS = 9,
	PS3 = 10,
	XBox360 = 11,
	Broadcom = 12,
	/// <summary>
	/// Build an Android .apk standalone app
	/// </summary>
	Android = 13,
	WinGLESEmu = 14,
	WinGLES20Emu = 15,
	/// <summary>
	/// Google Native Client
	/// </summary>
	GoogleNaCl = 16,
	/// <summary>
	/// Build a Linux standalone
	/// </summary>
	StandaloneLinux = 17,
	Flash = 18,
	/// <summary>
	/// Build a Windows 64-bit standalone
	/// </summary>
	StandaloneWin64Player = 19,
	/// <summary>
	/// WebGL
	/// </summary>
	WebGL = 20,
	/// <summary>
	/// Build an Windows Store Apps player
	/// </summary>
	MetroPlayerX86 = 21,
	/// <summary>
	/// Build an Windows Store Apps player
	/// </summary>
	MetroPlayerX64 = 22,
	/// <summary>
	/// Build an Windows Store Apps player
	/// </summary>
	MetroPlayerARM = 23,
	/// <summary>
	/// Build a Linux 64-bit standalone
	/// </summary>
	StandaloneLinux64 = 24,
	/// <summary>
	/// Build a Linux universal standalone
	/// </summary>
	StandaloneLinuxUniversal = 25,
	WP8Player = 26,
	/// <summary>
	/// Build a macOS Intel 64-bit standalone
	/// </summary>
	StandaloneOSXIntel64 = 27,
	/// <summary>
	/// BlackBerry
	/// </summary>
	BB10 = 28,
	/// <summary>
	/// Build a Tizen player
	/// </summary>
	Tizen = 29,
	/// <summary>
	/// Build a PS Vita Standalone
	/// </summary>
	PSP2 = 30,
	/// <summary>
	/// Build a PS4 Standalone
	/// </summary>
	PS4 = 31,
	PSM = 32,
	/// <summary>
	/// Build a Xbox One Standalone
	/// </summary>
	XboxOne = 33,
	/// <summary>
	/// Build to Samsung Smart TV platform
	/// </summary>
	SamsungTV = 34,
	/// <summary>
	/// Build to Nintendo 3DS platform
	/// </summary>
	N3DS = 35,
	/// <summary>
	/// Build a Wii U standalone
	/// </summary>
	WiiU = 36,
	/// <summary>
	/// Build to Apple's tvOS platform
	/// </summary>
	tvOS = 37,
	/// <summary>
	/// Build a Nintendo Switch player
	/// </summary>
	Switch = 38,
	Lumin = 39,
	Stadia = 40,
	CloudRendering = 41,
	GameCoreXboxSeries = 42,
	GameCoreXboxOne = 43,
	/// <summary>
	/// Build a PS5 Standalone
	/// </summary>
	PS5 = 44,
	EmbeddedLinux = 45,
	QNX = 46,

	/// <summary>
	/// Editor
	/// </summary>
	NoTarget = 0xFFFFFFFE,
	AnyPlayer = 0xFFFFFFFF,
}
public static class BuildTargetExtensions
{
	extension(BuildTarget target)
	{
		public bool IsStandalone
		{
			get
			{
				switch (target)
				{
					case BuildTarget.StandaloneWinPlayer:
					case BuildTarget.StandaloneWin64Player:
					case BuildTarget.StandaloneLinux:
					case BuildTarget.StandaloneLinux64:
					case BuildTarget.StandaloneLinuxUniversal:
					case BuildTarget.StandaloneOSXIntel:
					case BuildTarget.StandaloneOSXIntel64:
					case BuildTarget.StandaloneOSXPPC:
					case BuildTarget.StandaloneOSXUniversal:
						return true;
					default:
						return false;
				}
			}
		}

		public bool IsCompatible(BuildTarget comp)
		{
			return target == comp || (target.IsStandalone && comp.IsStandalone);
		}
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/Archive/ArchiveBundle.cs`:

```cs
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.BundleFiles.Archive;

public sealed class ArchiveBundleFile : FileBase
{
	public ArchiveBundleHeader Header { get; } = new();

	public override void Read(SmartStream stream)
	{
		throw new NotSupportedException();
	}

	public override void Write(Stream stream)
	{
		throw new NotSupportedException();
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/Archive/ArchiveBundleHeader.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles.Archive;

public sealed record class ArchiveBundleHeader : BundleHeader
{
	private const string UnityArchiveMagic = "UnityArchive";
	protected override string MagicString => UnityArchiveMagic;
	internal static bool IsBundleHeader(EndianReader reader) => IsBundleHeader(reader, UnityArchiveMagic);
}

```

`Source/AssetRipper.IO.Files/BundleFiles/Archive/ArchiveBundleScheme.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.BundleFiles.Archive;

public sealed class ArchiveBundleScheme : Scheme<ArchiveBundleFile>
{
	public override bool CanRead(SmartStream stream)
	{
		return ArchiveBundleHeader.IsBundleHeader(new EndianReader(stream, EndianType.BigEndian));
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/Archive/README.md`:

```md
I'm not certain that UnityArchive files exist, but code inherited from uTinyRipper indicated that they do exist.
```

`Source/AssetRipper.IO.Files/BundleFiles/BundleFlags.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles;

[Flags]
public enum BundleFlags
{
	None = 0,

	CompressionBit1 = 0x1,
	CompressionBit2 = 0x2,
	CompressionBit3 = 0x4,
	CompressionBit4 = 0x8,
	CompressionBit5 = 0x10,
	CompressionBit6 = 0x20,
	CompressionTypeMask = 0x3F,

	BlocksAndDirectoryInfoCombined = 0x40,
	BlocksInfoAtTheEnd = 0x80,
	OldWebPluginCompatibility = 0x100,
	/// <summary>
	/// Padding is added after blocks info, so files within asset bundles start on aligned boundaries.
	/// </summary>
	/// <remarks>
	/// Introduced in 2020.3.34f1, 2021.3.2f1, 2022.1.1f1 so that Switch patching works appropriately.<br/>
	/// <see href="https://unity3d.com/unity/whats-new/2021.3.2"/><br/>
	/// <see href="https://issuetracker.unity3d.com/issues/files-within-assetbundles-do-not-start-on-aligned-boundaries-breaking-patching-on-nintendo-switch"/><br/>
	/// This fix implies that loading newly generated AssetBundles will require using this new Unity editor/runtime combination. It is not backwards compatible.
	/// </remarks>
	BlockInfoNeedPaddingAtStart = 0x200,
	/// <summary>
	/// Chinese encryption flag prior to 2020.3.34f1, 2021.3.2f1, 2022.1.1f1.
	/// </summary>
	EncryptionOld = 0x200,
	/// <summary>
	/// Chinese encryption flag (presumeably) after 2020.3.34f1, 2021.3.2f1, 2022.1.1f1.
	/// </summary>
	EncryptionNew = 0x400,
}

public static class BundleFlagsExtensions
{
	/// <summary>
	/// The lowest 6 bits
	/// </summary>
	public static CompressionType GetCompression(this BundleFlags _this)
	{
		return (CompressionType)(_this & BundleFlags.CompressionTypeMask);
	}

	/// <summary>
	/// The 0x40 bit: <see cref="BundleFlags.BlocksAndDirectoryInfoCombined"/>
	/// </summary>
	public static bool GetBlocksAndDirectoryInfoCombined(this BundleFlags _this)
	{
		return (_this & BundleFlags.BlocksAndDirectoryInfoCombined) != 0;
	}

	/// <summary>
	/// The 0x80 bit: <see cref="BundleFlags.BlocksInfoAtTheEnd"/>
	/// </summary>
	public static bool GetBlocksInfoAtTheEnd(this BundleFlags _this)
	{
		return (_this & BundleFlags.BlocksInfoAtTheEnd) != 0;
	}

	/// <summary>
	/// The 0x100 bit: <see cref="BundleFlags.OldWebPluginCompatibility"/>
	/// </summary>
	public static bool GetOldWebPluginCompatibility(this BundleFlags _this)
	{
		return (_this & BundleFlags.OldWebPluginCompatibility) != 0;
	}

	/// <summary>
	/// The 0x200 bit: <see cref="BundleFlags.BlockInfoNeedPaddingAtStart"/>
	/// </summary>
	public static bool GetBlockInfoNeedPaddingAtStart(this BundleFlags _this)
	{
		return (_this & BundleFlags.BlockInfoNeedPaddingAtStart) != 0;
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/BundleHeader.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.BundleFiles.FileStream;
using AssetRipper.IO.Files.BundleFiles.RawWeb.Raw;
using AssetRipper.IO.Files.BundleFiles.RawWeb.Web;
using AssetRipper.IO.Files.Streams.Smart;
using System.Diagnostics;

namespace AssetRipper.IO.Files.BundleFiles;

public abstract record class BundleHeader : IEndianWritable
{
	internal BundleHeader() { }
	protected abstract string MagicString { get; }
	public BundleVersion Version { get; set; }
	/// <summary>
	/// Generation version
	/// </summary>
	public string? UnityWebBundleVersion { get; set; }
	/// <summary>
	/// Actual engine version
	/// </summary>
	public string? UnityWebMinimumRevision { get; set; }

	public virtual void Read(EndianReader reader)
	{
		string signature = reader.ReadStringZeroTerm();
		Debug.Assert(signature == MagicString);
		Version = (BundleVersion)reader.ReadInt32();
		Debug.Assert(Version >= 0);
		UnityWebBundleVersion = reader.ReadStringZeroTerm();
		UnityWebMinimumRevision = reader.ReadStringZeroTerm();
	}

	public virtual void Write(EndianWriter writer)
	{
		writer.WriteStringZeroTerm(MagicString);
		writer.Write((int)Version);
		writer.WriteStringZeroTerm(UnityWebBundleVersion ?? throw new NullReferenceException(nameof(UnityWebBundleVersion)));
		writer.WriteStringZeroTerm(UnityWebMinimumRevision ?? throw new NullReferenceException(nameof(UnityWebMinimumRevision)));
	}

	private protected static bool IsBundleHeader(EndianReader reader, string magicString)
	{
		const int MaxLength = 0x20;
		if (reader.BaseStream.Length >= MaxLength)
		{
			long position = reader.BaseStream.Position;
			bool isRead = reader.ReadStringZeroTerm(MaxLength, out string? signature);
			reader.BaseStream.Position = position;
			return isRead && signature == magicString;
		}
		return false;
	}

	public static bool IsBundleHeader(string path, FileSystem fileSystem)
	{
		using SmartStream stream = SmartStream.OpenRead(path, fileSystem);
		using EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
		return FileStreamBundleHeader.IsBundleHeader(reader)
			|| RawBundleHeader.IsBundleHeader(reader)
			|| WebBundleHeader.IsBundleHeader(reader);
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/BundleVersion.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles;

public enum BundleVersion
{
	Unknown = 0,

	BF_100_250 = 1,
	BF_260_340 = 2,
	BF_350_4x = 3,
	BF_520a1 = 4,
	BF_520aunk = 5,
	BF_520_x = 6,
	/// <summary>
	/// Several 4-byte integers were upgraded to 8-byte integers in order to support files larger than 2 GB.
	/// </summary>
	BF_LargeFilesSupport = 7,
	/// <summary>
	/// This seems to be exactly the same as <see cref="BF_LargeFilesSupport"/>.
	/// </summary>
	BF_2022_2 = 8,
}

```

`Source/AssetRipper.IO.Files/BundleFiles/CompressionType.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles;

public enum CompressionType
{
	None = 0,
	Lzma = 1,
	Lz4 = 2,
	Lz4HC = 3,
	Lzham = 4,
}

```

`Source/AssetRipper.IO.Files/BundleFiles/DirectoryInfo.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles;

public sealed record class DirectoryInfo<T> : IEndianReadable<DirectoryInfo<T>>, IEndianWritable where T : Node, IEndianReadable<T>
{
	public static DirectoryInfo<T> Read(EndianReader reader)
	{
		return new()
		{
			Nodes = reader.ReadEndianArray<T>()
		};
	}

	public void Write(EndianWriter writer)
	{
		writer.WriteEndianArray(Nodes);
	}

	public T[] Nodes { get; set; } = Array.Empty<T>();
}

```

`Source/AssetRipper.IO.Files/BundleFiles/FileStream/BlocksInfo.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles.FileStream;

public sealed record class BlocksInfo : IEndianReadable<BlocksInfo>, IEndianWritable
{
	public BlocksInfo()
	{
		UncompressedDataHash = new();
		StorageBlocks = Array.Empty<StorageBlock>();
	}

	public BlocksInfo(Hash128 uncompressedDataHash, StorageBlock[] storageBlocks)
	{
		UncompressedDataHash = uncompressedDataHash;
		StorageBlocks = storageBlocks;
	}

	public static BlocksInfo Read(EndianReader reader)
	{
		return new BlocksInfo(reader.ReadEndian<Hash128>(), reader.ReadEndianArray<StorageBlock>());
	}

	public void Write(EndianWriter writer)
	{
		UncompressedDataHash.Write(writer);
		writer.WriteEndianArray(StorageBlocks);
	}

	public Hash128 UncompressedDataHash { get; }
	public StorageBlock[] StorageBlocks { get; set; }
}

```

`Source/AssetRipper.IO.Files/BundleFiles/FileStream/BundleFileBlockReader.cs`:

```cs
using AssetRipper.IO.Files.Exceptions;
using AssetRipper.IO.Files.Streams;
using AssetRipper.IO.Files.Streams.Smart;
using K4os.Compression.LZ4;
using System.Buffers;

namespace AssetRipper.IO.Files.BundleFiles.FileStream;

internal sealed class BundleFileBlockReader : IDisposable
{
	public BundleFileBlockReader(SmartStream stream, BlocksInfo blocksInfo)
	{
		m_stream = stream;
		m_blocksInfo = blocksInfo;
		m_dataOffset = stream.Position;
	}

	~BundleFileBlockReader()
	{
		Dispose(false);
	}

	public void Dispose()
	{
		Dispose(true);
		GC.SuppressFinalize(this);
	}

	public SmartStream ReadEntry(FileStreamNode entry)
	{
		ObjectDisposedException.ThrowIf(m_isDisposed, typeof(BundleFileBlockReader));

		// Avoid storing entire non-compresed entries in memory by mapping a stream to the block location.
		if (m_blocksInfo.StorageBlocks.Length == 1 && m_blocksInfo.StorageBlocks[0].CompressionType == CompressionType.None)
		{
			if (m_dataOffset + entry.Offset + entry.Size > m_stream.Length)
			{
				throw new InvalidFormatException("Entry extends beyond the end of the stream.");
			}
			return m_stream.CreatePartial(m_dataOffset + entry.Offset, entry.Size);
		}

		// find block offsets
		int blockIndex;
		long blockCompressedOffset = 0;
		long blockDecompressedOffset = 0;
		for (blockIndex = 0; blockDecompressedOffset + m_blocksInfo.StorageBlocks[blockIndex].UncompressedSize <= entry.Offset; blockIndex++)
		{
			blockCompressedOffset += m_blocksInfo.StorageBlocks[blockIndex].CompressedSize;
			blockDecompressedOffset += m_blocksInfo.StorageBlocks[blockIndex].UncompressedSize;
		}
		long entryOffsetInsideBlock = entry.Offset - blockDecompressedOffset;

		using SmartStream entryStream = CreateStream(entry.Size);
		long left = entry.Size;
		m_stream.Position = m_dataOffset + blockCompressedOffset;

		// copy data of all blocks used by current entry to new stream
		while (left > 0)
		{
			byte[]? rentedArray;

			long blockStreamOffset;
			Stream blockStream;
			StorageBlock block = m_blocksInfo.StorageBlocks[blockIndex];
			if (m_cachedBlockIndex == blockIndex)
			{
				// data of the previous entry is in the same block as this one
				// so we don't need to unpack it once again. Instead we can use cached stream
				blockStreamOffset = 0;
				blockStream = m_cachedBlockStream;
				rentedArray = null;
				m_stream.Position += block.CompressedSize;
			}
			else
			{
				CompressionType compressType = block.CompressionType;
				if (compressType is CompressionType.None)
				{
					blockStreamOffset = m_dataOffset + blockCompressedOffset;
					blockStream = m_stream;
					rentedArray = null;
				}
				else
				{
					blockStreamOffset = 0;
					m_cachedBlockIndex = blockIndex;
					m_cachedBlockStream.Move(CreateTemporaryStream(block.UncompressedSize, out rentedArray));
					switch (compressType)
					{
						case CompressionType.Lzma:
							LzmaCompression.DecompressLzmaStream(m_stream, block.CompressedSize, m_cachedBlockStream, block.UncompressedSize);
							break;

						case CompressionType.Lz4:
						case CompressionType.Lz4HC:
							uint uncompressedSize = block.UncompressedSize;
							byte[] uncompressedBytes = new byte[uncompressedSize];
							byte[] compressedBytes = new BinaryReader(m_stream).ReadBytes((int)block.CompressedSize);
							int bytesWritten = LZ4Codec.Decode(compressedBytes, uncompressedBytes);
							if (bytesWritten < 0)
							{
								DecompressionFailedException.ThrowNoBytesWritten(entry.PathFixed, compressType);
							}
							else if (bytesWritten != uncompressedSize)
							{
								DecompressionFailedException.ThrowIncorrectNumberBytesWritten(entry.PathFixed, compressType, uncompressedSize, bytesWritten);
							}
							new MemoryStream(uncompressedBytes).CopyTo(m_cachedBlockStream);
							break;

						case CompressionType.Lzham:
							UnsupportedBundleDecompression.ThrowLzham(entry.PathFixed);
							break;

						default:
							if (ZstdCompression.IsZstd(m_stream))
							{
								ZstdCompression.DecompressStream(m_stream, block.CompressedSize, m_cachedBlockStream, block.UncompressedSize);
							}
							else
							{
								UnsupportedBundleDecompression.Throw(entry.PathFixed, compressType);
							}
							break;
					}
					blockStream = m_cachedBlockStream;
				}
			}

			// consider next offsets:
			// 1) block - if it is new stream then offset is 0, otherwise offset of this block in the bundle file
			// 2) entry - if this is first block for current entry then it is offset of this entry related to this block
			//			  otherwise 0
			long blockSize = block.UncompressedSize - entryOffsetInsideBlock;
			blockStream.Position = blockStreamOffset + entryOffsetInsideBlock;
			entryOffsetInsideBlock = 0;

			long size = Math.Min(blockSize, left);
			if (blockStream.Position + size > blockStream.Length)
			{
				throw new InvalidFormatException("Block extends beyond the end of the stream.");
			}
			using PartialStream partialStream = new(blockStream, blockStream.Position, size);
			partialStream.CopyTo(entryStream);
			blockIndex++;

			blockCompressedOffset += block.CompressedSize;
			left -= size;

			if (rentedArray != null)
			{
				ArrayPool<byte>.Shared.Return(rentedArray);
			}
		}
		if (left < 0)
		{
			DecompressionFailedException.ThrowReadMoreThanExpected(entry.PathFixed, entry.Size, entry.Size - left);
		}
		entryStream.Position = 0;
		return entryStream.CreateReference();
	}

	private void Dispose(bool disposing)
	{
		m_isDisposed = true;
		m_cachedBlockStream.FreeReference();
	}

	private static SmartStream CreateStream(long decompressedSize)
	{
		return decompressedSize switch
		{
			> MaxMemoryStreamLength => SmartStream.CreateTemp(),
			> MaxPreAllocatedMemoryStreamLength => SmartStream.CreateMemory(),
			_ => SmartStream.CreateMemory(new byte[decompressedSize]),
		};
	}

	private static SmartStream CreateTemporaryStream(long decompressedSize, out byte[]? rentedArray)
	{
		if (decompressedSize > MaxMemoryStreamLength)
		{
			rentedArray = null;
			return SmartStream.CreateTemp();
		}
		else
		{
			rentedArray = ArrayPool<byte>.Shared.Rent((int)decompressedSize);
			return SmartStream.CreateMemory(rentedArray, 0, (int)decompressedSize);
		}
	}

	/// <summary>
	/// The arbitrary maximum size of a decompressed stream to be stored in RAM. 50 MB
	/// </summary>
	/// <remarks>
	/// This number can be set to any integer value, including <see cref="int.MaxValue"/>.
	/// Previously, this was actually set to <see cref="int.MaxValue"/>, but that can cause
	/// <see href="https://github.com/AssetRipper/AssetRipper/issues/1953">highly compressed games to use too much RAM</see>.
	/// </remarks>
	private const int MaxMemoryStreamLength = 50 * 1024 * 1024;
	/// <summary>
	/// The arbitrary maximum size of a decompressed stream to be pre-allocated. 30 MB
	/// </summary>
	/// <remarks>
	/// This number can be set to any integer value less than <see cref="MaxMemoryStreamLength"/>.
	/// </remarks>
	private const int MaxPreAllocatedMemoryStreamLength = 30 * 1024 * 1024;
	private readonly SmartStream m_stream;
	private readonly BlocksInfo m_blocksInfo = new();
	private readonly long m_dataOffset;

	private readonly SmartStream m_cachedBlockStream = SmartStream.CreateNull();
	private int m_cachedBlockIndex = -1;

	private bool m_isDisposed = false;
}

```

`Source/AssetRipper.IO.Files/BundleFiles/FileStream/FileStreamBundleFile.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Exceptions;
using AssetRipper.IO.Files.Extensions;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.Streams.Smart;
using K4os.Compression.LZ4;

namespace AssetRipper.IO.Files.BundleFiles.FileStream;

public sealed class FileStreamBundleFile : FileContainer
{
	public FileStreamBundleHeader Header { get; } = new();
	public BlocksInfo BlocksInfo { get; private set; } = new();
	public DirectoryInfo<FileStreamNode> DirectoryInfo { get; set; } = new();

	public FileStreamBundleFile()
	{
	}

	public FileStreamBundleFile(string filePath, FileSystem fileSystem)
	{
		SmartStream stream = SmartStream.OpenRead(filePath, fileSystem);
		Read(stream);
	}

	public override void Read(SmartStream stream)
	{
		EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
		long basePosition = stream.Position;
		Header.Read(reader);
		long headerSize = stream.Position - basePosition;
		ReadFileStreamMetadata(stream, basePosition);//ReadBlocksInfoAndDirectory
		ReadFileStreamData(stream, basePosition, headerSize);//ReadBlocks and ReadFiles
	}

	public override void Write(Stream stream)
	{
		EndianWriter writer = new EndianWriter(stream, EndianType.BigEndian);
		long basePosition = stream.Position;
		Header.Write(writer);
		long headerSize = stream.Position - basePosition;
		WriteFileStreamMetadata(stream, basePosition);
		WriteFileStreamData(stream, basePosition, headerSize);
	}

	private void ReadFileStreamMetadata(Stream stream, long basePosition)
	{
		if (Header.Version >= BundleVersion.BF_LargeFilesSupport)
		{
			stream.Align(16);
		}
		if (Header.Flags.GetBlocksInfoAtTheEnd())
		{
			stream.Position = basePosition + (Header.Size - Header.CompressedBlocksInfoSize);
		}

		DecompressionFailedException.ThrowIfUncompressedSizeIsNegative(NameFixed, Header.UncompressedBlocksInfoSize);

		CompressionType metaCompression = Header.Flags.GetCompression();
		switch (metaCompression)
		{
			case CompressionType.None:
				{
					ReadMetadata(stream, Header.UncompressedBlocksInfoSize);
				}
				break;

			case CompressionType.Lzma:
				{
					using MemoryStream uncompressedStream = new MemoryStream(new byte[Header.UncompressedBlocksInfoSize]);
					LzmaCompression.DecompressLzmaStream(stream, Header.CompressedBlocksInfoSize, uncompressedStream, Header.UncompressedBlocksInfoSize);

					uncompressedStream.Position = 0;
					ReadMetadata(uncompressedStream, Header.UncompressedBlocksInfoSize);
				}
				break;

			case CompressionType.Lz4:
			case CompressionType.Lz4HC:
				{
					int uncompressedSize = Header.UncompressedBlocksInfoSize;
					byte[] uncompressedBytes = new byte[uncompressedSize];
					byte[] compressedBytes = new BinaryReader(stream).ReadBytes(Header.CompressedBlocksInfoSize);
					int bytesWritten = LZ4Codec.Decode(compressedBytes, uncompressedBytes);
					if (bytesWritten < 0)
					{
						DecompressionFailedException.ThrowNoBytesWritten(NameFixed, metaCompression);
					}
					else if (bytesWritten != uncompressedSize)
					{
						DecompressionFailedException.ThrowIncorrectNumberBytesWritten(NameFixed, metaCompression, uncompressedSize, bytesWritten);
					}
					ReadMetadata(new MemoryStream(uncompressedBytes), uncompressedSize);
				}
				break;

			case CompressionType.Lzham:
				UnsupportedBundleDecompression.ThrowLzham(NameFixed);
				break;

			default:
				UnsupportedBundleDecompression.Throw(NameFixed, metaCompression);
				break;
		}
	}

	private void ReadMetadata(Stream stream, int metadataSize)
	{
		long metadataPosition = stream.Position;
		using (EndianReader reader = new EndianReader(stream, EndianType.BigEndian))
		{
			BlocksInfo = BlocksInfo.Read(reader);
			if (Header.Flags.GetBlocksAndDirectoryInfoCombined())
			{
				DirectoryInfo = DirectoryInfo<FileStreamNode>.Read(reader);
			}
		}
		if (metadataSize > 0)
		{
			long metadataBytesRead = stream.Position - metadataPosition;
			if (metadataBytesRead == metadataSize)
			{
				// Note: metadataSize might not be a multiple of 4
			}
			else if ((metadataPosition % 4 == 0) && (metadataSize % 4 == 0) && (((metadataBytesRead + 3) & ~3) == metadataSize))
			{
				// The stream needed to be aligned to 4 bytes.
				// https://github.com/AssetRipper/AssetRipper/issues/1470
				// In my testing, there didn't seem to be any indicator (eg in Header.Flags) that the stream needed to be aligned to 4 bytes.
				// We just need to check if aligning the stream to 4 bytes would make the bytes read equal to the metadata size.
			}
			else
			{
				throw new Exception($"Read {stream.Position - metadataPosition} but expected {metadataSize} while reading bundle metadata");
			}
		}
	}

	private void ReadFileStreamData(SmartStream stream, long basePosition, long headerSize)
	{
		if (Header.Flags.GetBlocksInfoAtTheEnd())
		{
			stream.Position = basePosition + headerSize;
			if (Header.Version >= BundleVersion.BF_LargeFilesSupport)
			{
				stream.Align(16);
			}
		}
		if (Header.Flags.GetBlockInfoNeedPaddingAtStart())
		{
			stream.Align(16);
		}

		using BundleFileBlockReader blockReader = new BundleFileBlockReader(stream, BlocksInfo);
		foreach (FileStreamNode entry in DirectoryInfo.Nodes)
		{
			try
			{
				SmartStream entryStream = blockReader.ReadEntry(entry);
				AddResourceFile(new ResourceFile(entryStream, FilePath, entry.Path));
			}
			catch (Exception ex)
			{
				AddFailedFile(new FailedFile()
				{
					Name = entry.Path,
					FilePath = FilePath,
					StackTrace = ex.ToString(),
				});
			}
		}
	}

	private void WriteFileStreamMetadata(Stream stream, long basePosition)
	{
		if (Header.Version >= BundleVersion.BF_LargeFilesSupport)
		{
			stream.Align(16);
		}
		if (Header.Flags.GetBlocksInfoAtTheEnd())
		{
			stream.Position = basePosition + (Header.Size - Header.CompressedBlocksInfoSize);
		}

		CompressionType metaCompression = Header.Flags.GetCompression();
		switch (metaCompression)
		{
			case CompressionType.None:
				{
					WriteMetadata(stream, Header.UncompressedBlocksInfoSize);
				}
				break;

			case CompressionType.Lzma:
				throw new NotImplementedException(nameof(CompressionType.Lzma));

			//These cases will likely need to be separated.
			case CompressionType.Lz4:
			case CompressionType.Lz4HC:
				{
					//These should be set after doing this calculation instead of before
					int uncompressedSize = Header.UncompressedBlocksInfoSize;
					int compressedSize = Header.CompressedBlocksInfoSize;

					byte[] uncompressedBytes = new byte[uncompressedSize];
					WriteMetadata(new MemoryStream(uncompressedBytes), uncompressedSize);
					byte[] compressedBytes = new byte[compressedSize];
					int bytesWritten = LZ4Codec.Encode(uncompressedBytes, compressedBytes, LZ4Level.L00_FAST);
					if (bytesWritten != compressedSize)
					{
						throw new Exception($"Incorrect number of bytes written. {bytesWritten} instead of {compressedSize} for {compressedBytes.Length} compressed bytes");
					}
					new BinaryWriter(stream).Write(compressedBytes);
				}
				break;

			default:
				throw new NotSupportedException($"Bundle compression '{metaCompression}' isn't supported");
		}
	}

	private void WriteMetadata(Stream stream, int metadataSize)
	{
		long metadataPosition = stream.Position;
		using (EndianWriter writer = new EndianWriter(stream, EndianType.BigEndian))
		{
			BlocksInfo.Write(writer);
			if (Header.Flags.GetBlocksAndDirectoryInfoCombined())
			{
				DirectoryInfo.Write(writer);
			}
		}
		if (metadataSize > 0)
		{
			if (stream.Position - metadataPosition != metadataSize)
			{
				throw new Exception($"Wrote {stream.Position - metadataPosition} but expected {metadataSize} while writing bundle metadata");
			}
		}
	}

	private void WriteFileStreamData(Stream stream, long basePosition, long headerSize)
	{
		if (Header.Flags.GetBlocksInfoAtTheEnd())
		{
			stream.Position = basePosition + headerSize;
			if (Header.Version >= BundleVersion.BF_LargeFilesSupport)
			{
				stream.Align(16);
			}
		}
		if (Header.Flags.GetBlockInfoNeedPaddingAtStart())
		{
			stream.Align(16);
		}

		if (DirectoryInfo.Nodes.Length == 0)
		{
			return;
		}

		throw new NotImplementedException();
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/FileStream/FileStreamBundleHeader.cs`:

```cs
using AssetRipper.IO.Endian;
using System.Diagnostics;

namespace AssetRipper.IO.Files.BundleFiles.FileStream;

public sealed record class FileStreamBundleHeader : BundleHeader
{
	private const string UnityFSMagic = "UnityFS";
	protected override string MagicString => UnityFSMagic;
	/// <summary>
	/// Equal to file size, sometimes equal to uncompressed data size without the header
	/// </summary>
	public long Size { get; set; }
	/// <summary>
	/// UnityFS length of the possibly-compressed (LZMA, LZ4) bundle data header
	/// </summary>
	public int CompressedBlocksInfoSize { get; set; }
	public int UncompressedBlocksInfoSize { get; set; }
	public BundleFlags Flags { get; set; }

	public CompressionType CompressionType
	{
		get
		{
			return Flags.GetCompression();
		}
		set
		{
			Flags = (Flags & ~BundleFlags.CompressionTypeMask) | (BundleFlags.CompressionTypeMask & (BundleFlags)value);
		}
	}

	public override void Read(EndianReader reader)
	{
		base.Read(reader);
		Size = reader.ReadInt64();
		Debug.Assert(Size >= 0);
		CompressedBlocksInfoSize = reader.ReadInt32();
		Debug.Assert(CompressedBlocksInfoSize >= 0);
		UncompressedBlocksInfoSize = reader.ReadInt32();
		Debug.Assert(UncompressedBlocksInfoSize >= 0);
		Flags = (BundleFlags)reader.ReadInt32();
	}

	public override void Write(EndianWriter writer)
	{
		base.Write(writer);
		writer.Write(Size);
		writer.Write(CompressedBlocksInfoSize);
		writer.Write(UncompressedBlocksInfoSize);
		writer.Write((int)Flags);
	}

	internal static bool IsBundleHeader(EndianReader reader) => IsBundleHeader(reader, UnityFSMagic);
}

```

`Source/AssetRipper.IO.Files/BundleFiles/FileStream/FileStreamBundleScheme.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.BundleFiles.FileStream;

public sealed class FileStreamBundleScheme : Scheme<FileStreamBundleFile>
{
	public override bool CanRead(SmartStream stream)
	{
		return FileStreamBundleHeader.IsBundleHeader(new EndianReader(stream, EndianType.BigEndian));
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/FileStream/FileStreamNode.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles.FileStream;

public sealed record class FileStreamNode : Node, IEndianReadable<FileStreamNode>
{
	public static FileStreamNode Read(EndianReader reader)
	{
		return new()
		{
			Offset = reader.ReadInt64(),
			Size = reader.ReadInt64(),
			Flags = (NodeFlags)reader.ReadInt32(),
			Path = reader.ReadStringZeroTerm(),
		};
	}

	public override void Write(EndianWriter writer)
	{
		writer.Write(Offset);
		writer.Write(Size);
		writer.Write((int)Flags);
		writer.WriteStringZeroTerm(Path);
	}

	public NodeFlags Flags { get; set; }
}

```

`Source/AssetRipper.IO.Files/BundleFiles/FileStream/NodeFlags.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles.FileStream;

[Flags]
public enum NodeFlags
{
	Default = 0,
	Directory = 1,
	Deleted = 2,
	SerializedFile = 4,
}

```

`Source/AssetRipper.IO.Files/BundleFiles/FileStream/StorageBlock.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles.FileStream;

/// <summary>
/// Contains compression information about a block<br/>
/// Blocks are similar to chunk structure in that it contains a data blob but without file entries
/// </summary>
public sealed record class StorageBlock : IEndianReadable<StorageBlock>, IEndianWritable
{
	public static StorageBlock Read(EndianReader reader)
	{
		return new()
		{
			UncompressedSize = reader.ReadUInt32(),
			CompressedSize = reader.ReadUInt32(),
			Flags = (StorageBlockFlags)reader.ReadUInt16()
		};
	}

	public void Write(EndianWriter writer)
	{
		writer.Write(UncompressedSize);
		writer.Write(CompressedSize);
		writer.Write((ushort)Flags);
	}

	public uint UncompressedSize { get; private set; }
	public uint CompressedSize { get; private set; }
	public StorageBlockFlags Flags { get; private set; }
	public CompressionType CompressionType
	{
		get
		{
			return Flags.CompressionType;
		}
		private set
		{
			Flags = Flags.WithCompressionType(value);
		}
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/FileStream/StorageBlockFlags.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles.FileStream;

[Flags]
public enum StorageBlockFlags
{
	CompressionTypeMask = 0x3F,

	Streamed = 0x40,
}
public static class StorageBlockFlagsExtensions
{
	extension(StorageBlockFlags flags)
	{
		public CompressionType CompressionType
		{
			get
			{
				return (CompressionType)(flags & StorageBlockFlags.CompressionTypeMask);
			}
		}

		public bool IsStreamed
		{
			get
			{
				return (flags & StorageBlockFlags.Streamed) != 0;
			}
		}

		public StorageBlockFlags WithCompressionType(CompressionType compressionType)
		{
			return (flags & ~StorageBlockFlags.CompressionTypeMask) | (StorageBlockFlags)compressionType;
		}
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/Hash128.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles;

public sealed record class Hash128 : IEndianReadable<Hash128>, IEndianWritable
{
	public static Hash128 Read(EndianReader reader)
	{
		return new()
		{
			Byte0 = reader.ReadByte(),
			Byte1 = reader.ReadByte(),
			Byte2 = reader.ReadByte(),
			Byte3 = reader.ReadByte(),
			Byte4 = reader.ReadByte(),
			Byte5 = reader.ReadByte(),
			Byte6 = reader.ReadByte(),
			Byte7 = reader.ReadByte(),
			Byte8 = reader.ReadByte(),
			Byte9 = reader.ReadByte(),
			Byte10 = reader.ReadByte(),
			Byte11 = reader.ReadByte(),
			Byte12 = reader.ReadByte(),
			Byte13 = reader.ReadByte(),
			Byte14 = reader.ReadByte(),
			Byte15 = reader.ReadByte(),
		};
	}

	public void Write(EndianWriter writer)
	{
		writer.Write(Byte0);
		writer.Write(Byte1);
		writer.Write(Byte2);
		writer.Write(Byte3);
		writer.Write(Byte4);
		writer.Write(Byte5);
		writer.Write(Byte6);
		writer.Write(Byte7);
		writer.Write(Byte8);
		writer.Write(Byte9);
		writer.Write(Byte10);
		writer.Write(Byte11);
		writer.Write(Byte12);
		writer.Write(Byte13);
		writer.Write(Byte14);
		writer.Write(Byte15);
	}

	public override string ToString()
	{
		return new UnityGuid(ToArray()).ToString();
	}

	public byte[] ToArray()
	{
		return
		[
			Byte0,
			Byte1,
			Byte2,
			Byte3,
			Byte4,
			Byte5,
			Byte6,
			Byte7,
			Byte8,
			Byte9,
			Byte10,
			Byte11,
			Byte12,
			Byte13,
			Byte14,
			Byte15,
		];
	}

	public byte Byte0 { get; set; }
	public byte Byte1 { get; set; }
	public byte Byte2 { get; set; }
	public byte Byte3 { get; set; }
	public byte Byte4 { get; set; }
	public byte Byte5 { get; set; }
	public byte Byte6 { get; set; }
	public byte Byte7 { get; set; }
	public byte Byte8 { get; set; }
	public byte Byte9 { get; set; }
	public byte Byte10 { get; set; }
	public byte Byte11 { get; set; }
	public byte Byte12 { get; set; }
	public byte Byte13 { get; set; }
	public byte Byte14 { get; set; }
	public byte Byte15 { get; set; }
}

```

`Source/AssetRipper.IO.Files/BundleFiles/LzmaCompression.cs`:

```cs
using AssetRipper.IO.Files.Exceptions;
using SharpCompress.Compressors.LZMA;
using System.Buffers;
using System.Buffers.Binary;

namespace AssetRipper.IO.Files.BundleFiles;

public static class LzmaCompression
{
	/// <summary>
	/// Read LZMA properties and decompress LZMA data
	/// </summary>
	/// <param name="compressedStream">LZMA compressed stream</param>
	/// <param name="compressedSize">Compressed data length</param>
	/// <param name="decompressedStream">Stream for decompressed output</param>
	/// <param name="decompressedSize">Decompressed data length</param>
	public static void DecompressLzmaStream(Stream compressedStream, long compressedSize, Stream decompressedStream, long decompressedSize)
	{
		byte[] properties = new byte[PropertiesSize];
		long basePosition = compressedStream.Position;

		compressedStream.ReadExactly(properties, 0, PropertiesSize);

		long headSize = compressedStream.Position - basePosition;
		long headlessSize = compressedSize - headSize;

		DecompressLzmaStream(properties, compressedStream, headlessSize, decompressedStream, decompressedSize);

		if (compressedStream.Position > basePosition + compressedSize)
		{
			DecompressionFailedException.ThrowReadMoreThanExpected(CompressionType.Lzma, compressedSize, compressedStream.Position - basePosition);
		}
		compressedStream.Position = basePosition + compressedSize;
	}

	/// <summary>
	/// Read LZMA properties and decompressed size and decompress LZMA data
	/// </summary>
	/// <param name="compressedStream">LZMA compressed stream</param>
	/// <param name="compressedSize">Compressed data length</param>
	/// <param name="decompressedStream">Stream for decompressed output</param>
	public static void DecompressLzmaSizeStream(Stream compressedStream, long compressedSize, Stream decompressedStream)
	{
		byte[] properties = new byte[PropertiesSize]; //GetBuffer();
		byte[] sizeBytes = new byte[UncompressedSize]; //GetBuffer();
		long basePosition = compressedStream.Position;

		compressedStream.ReadExactly(properties, 0, PropertiesSize);
		compressedStream.ReadExactly(sizeBytes, 0, UncompressedSize);
		long decompressedSize = BinaryPrimitives.ReadInt64LittleEndian(sizeBytes);

		long headSize = compressedStream.Position - basePosition;
		long headlessSize = compressedSize - headSize;

		DecompressLzmaStream(properties, compressedStream, headlessSize, decompressedStream, decompressedSize);

		if (compressedStream.Position > basePosition + compressedSize)
		{
			DecompressionFailedException.ThrowReadMoreThanExpected(CompressionType.Lzma, compressedSize, compressedStream.Position - basePosition);
		}
		compressedStream.Position = basePosition + compressedSize;
	}

	private static void DecompressLzmaStream(byte[] properties, Stream compressedStream, long headlessSize, Stream decompressedStream, long decompressedSize)
	{
		LzmaStream lzmaStream = new LzmaStream(properties, compressedStream, headlessSize, -1, null, false);

		byte[] buffer = ArrayPool<byte>.Shared.Rent(1024);
		long totalRead = 0;
		while (totalRead < decompressedSize)
		{
			int toRead = (int)Math.Min(buffer.Length, decompressedSize - totalRead);
			int read = lzmaStream.Read(buffer, 0, toRead);
			if (read > 0)
			{
				decompressedStream.Write(buffer, 0, read);
				totalRead += read;
			}
			else
			{
				break;
			}
		}
		ArrayPool<byte>.Shared.Return(buffer);
	}

	/// <summary>
	/// Compress some data with LZMA.
	/// </summary>
	/// <param name="uncompressedStream">The source stream with uncompressed data.</param>
	/// <param name="uncompressedSize">The number of bytes to read from <paramref name="uncompressedSize"/>.</param>
	/// <param name="compressedStream">The stream in which to write the compressed data.</param>
	/// <returns>The number of compressed bytes written to <paramref name="compressedStream"/> including the 5 property bytes.</returns>
	public static long CompressLzmaStream(Stream uncompressedStream, long uncompressedSize, Stream compressedStream)
	{
		long basePosition = compressedStream.Position;
		LzmaStream lzmaStream = new LzmaStream(new(), false, compressedStream);
		compressedStream.Write(lzmaStream.Properties);
		CopyToLzma(uncompressedStream, lzmaStream, uncompressedSize);
		lzmaStream.Close();
		return compressedStream.Position - basePosition;
	}

	/// <summary>
	/// Compress some data with LZMA.
	/// </summary>
	/// <param name="uncompressedStream">The source stream with uncompressed data.</param>
	/// <param name="uncompressedSize">The number of bytes to read from <paramref name="uncompressedSize"/>.</param>
	/// <param name="compressedStream">The stream in which to write the compressed data.</param>
	/// <returns>
	/// The number of compressed bytes written to <paramref name="compressedStream"/> including the 5 property bytes
	/// and <see langword="long"/> uncompressed size value.
	/// </returns>
	public static long CompressLzmaSizeStream(Stream uncompressedStream, long uncompressedSize, Stream compressedStream)
	{
		long basePosition = compressedStream.Position;
		LzmaStream lzmaStream = new LzmaStream(new(), false, compressedStream);
		compressedStream.Write(lzmaStream.Properties);
		new BinaryWriter(compressedStream).Write(uncompressedSize);
		CopyToLzma(uncompressedStream, lzmaStream, uncompressedSize);
		lzmaStream.Close();
		return compressedStream.Position - basePosition;
	}

	private static void CopyToLzma(Stream inputStream, LzmaStream lzmaStream, long uncompressedSize)
	{
		byte[] buffer = ArrayPool<byte>.Shared.Rent(1024);
		long totalCopied = 0;
		while (totalCopied < uncompressedSize)
		{
			int read = inputStream.Read(buffer, 0, (int)Math.Min(buffer.Length, uncompressedSize - totalCopied));
			if (read == 0)
			{
				throw new EndOfStreamException();
			}
			lzmaStream.Write(buffer, 0, read);
			totalCopied += read;
		}
	}

	private const int PropertiesSize = 5;
	private const int UncompressedSize = sizeof(long);
}

```

`Source/AssetRipper.IO.Files/BundleFiles/Node.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles;

public abstract record class Node : IEndianWritable
{
	public override string ToString() => PathFixed;

	public abstract void Write(EndianWriter writer);

	public string PathFixed { get; private set; } = "";
	public string Path
	{
		get;
		set
		{
			field = value;
			PathFixed = SpecialFileNames.FixFileIdentifier(value);
		}
	} = "";
	public long Offset { get; set; }
	public long Size { get; set; }
}

```

`Source/AssetRipper.IO.Files/BundleFiles/RawWeb/BundleScene.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles.RawWeb;

/// <summary>
/// Contains compression information about chunk
/// Chunk is a structure (optionaly LZMA compressed) that contains file entries and data blob
/// </summary>
public sealed record class BundleScene : IEndianReadable<BundleScene>, IEndianWritable
{
	public static BundleScene Read(EndianReader reader)
	{
		return new()
		{
			CompressedSize = reader.ReadUInt32(),
			DecompressedSize = reader.ReadUInt32()
		};
	}

	public void Write(EndianWriter writer)
	{
		writer.Write(CompressedSize);
		writer.Write(DecompressedSize);
	}

	public uint CompressedSize { get; private set; }
	public uint DecompressedSize { get; private set; }
}

```

`Source/AssetRipper.IO.Files/BundleFiles/RawWeb/Raw/RawBundleFile.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles.RawWeb.Raw;

public sealed class RawBundleFile : RawWebBundleFile<RawBundleHeader> { }

```

`Source/AssetRipper.IO.Files/BundleFiles/RawWeb/Raw/RawBundleHeader.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles.RawWeb.Raw;

public sealed record class RawBundleHeader : RawWebBundleHeader
{
	private const string UnityRawMagic = "UnityRaw";
	protected override string MagicString => UnityRawMagic;
	internal static bool IsBundleHeader(EndianReader reader) => IsBundleHeader(reader, UnityRawMagic);
}

```

`Source/AssetRipper.IO.Files/BundleFiles/RawWeb/Raw/RawBundleScheme.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.BundleFiles.RawWeb.Raw;

public sealed class RawBundleScheme : Scheme<RawBundleFile>
{
	public override bool CanRead(SmartStream stream)
	{
		return RawBundleHeader.IsBundleHeader(new EndianReader(stream, EndianType.BigEndian));
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/RawWeb/RawWebBundleFile.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.BundleFiles.RawWeb.Raw;
using AssetRipper.IO.Files.BundleFiles.RawWeb.Web;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.BundleFiles.RawWeb;

public abstract class RawWebBundleFile<THeader> : FileContainer where THeader : RawWebBundleHeader, new()
{
	public THeader Header { get; } = new();
	public DirectoryInfo<RawWebNode> DirectoryInfo { get; set; } = new();

	public override void Read(SmartStream stream)
	{
		EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
		long basePosition = stream.Position;
		Header.Read(reader);
		long headerSize = stream.Position - basePosition;
		if (headerSize != Header.HeaderSize)
		{
			throw new Exception($"Read {headerSize} but expected {Header.HeaderSize} bytes while reading the raw/web bundle header.");
		}
		ReadRawWebMetadata(stream, out Stream dataStream, out long metadataOffset);//ReadBlocksAndDirectory
		ReadRawWebData(dataStream, metadataOffset);//also ReadBlocksAndDirectory
	}

	public override void Write(Stream stream)
	{
		EndianWriter writer = new EndianWriter(stream, EndianType.BigEndian);
		Header.Write(writer);
		throw new NotImplementedException();
	}

	private void ReadRawWebMetadata(Stream stream, out Stream dataStream, out long metadataOffset)
	{
		int metadataSize = RawWebBundleHeader.HasUncompressedBlocksInfoSize(Header.Version) ? Header.UncompressedBlocksInfoSize : 0;

		//These branches are collapsed by JIT
		if (typeof(THeader) == typeof(RawBundleHeader))
		{
			dataStream = stream;
			metadataOffset = stream.Position;
			ReadMetadata(dataStream, metadataSize);
		}
		else if (typeof(THeader) == typeof(WebBundleHeader))
		{
			// read only last chunk
			BundleScene chunkInfo = Header.Scenes[^1];
			dataStream = new MemoryStream(new byte[chunkInfo.DecompressedSize]);
			LzmaCompression.DecompressLzmaSizeStream(stream, chunkInfo.CompressedSize, dataStream);
			metadataOffset = 0;

			dataStream.Position = 0;
			ReadMetadata(dataStream, metadataSize);
		}
		else
		{
			throw new Exception($"Unsupported bundle type '{typeof(THeader)}'");
		}
	}

	private void ReadMetadata(Stream stream, int metadataSize)
	{
		long metadataPosition = stream.Position;
		using (EndianReader reader = new EndianReader(stream, EndianType.BigEndian))
		{
			DirectoryInfo = DirectoryInfo<RawWebNode>.Read(reader);
			reader.AlignStream();
		}
		if (metadataSize > 0)
		{
			if (stream.Position - metadataPosition != metadataSize)
			{
				throw new Exception($"Read {stream.Position - metadataPosition} but expected {metadataSize} while reading bundle metadata");
			}
		}
	}

	private void ReadRawWebData(Stream stream, long metadataOffset)
	{
		foreach (RawWebNode entry in DirectoryInfo.Nodes)
		{
			byte[] buffer = new byte[entry.Size];
			stream.Position = metadataOffset + entry.Offset;
			stream.ReadExactly(buffer);
			ResourceFile file = new ResourceFile(buffer, FilePath, entry.Path);
			AddResourceFile(file);
		}
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/RawWeb/RawWebBundleHeader.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles.RawWeb;

public abstract record class RawWebBundleHeader : BundleHeader
{
	public Hash128? Hash { get; set; }
	public uint Crc { get; set; }
	/// <summary>
	/// Minimum number of bytes to read for streamed bundles, equal to BundleSize for normal bundles
	/// </summary>
	public uint MinimumStreamedBytes { get; set; }
	public int HeaderSize { get; set; }
	/// <summary>
	/// Equal to 1 if it's a streamed bundle, number of LZMAChunkInfos + mainData assets otherwise
	/// </summary>
	public int NumberOfScenesToDownloadBeforeStreaming { get; set; }
	/// <summary>
	/// LZMA chunks info
	/// </summary>
	public BundleScene[] Scenes { get; set; } = Array.Empty<BundleScene>();
	public uint CompleteFileSize { get; set; }
	public int UncompressedBlocksInfoSize { get; set; }

	public sealed override void Read(EndianReader reader)
	{
		base.Read(reader);
		if (HasHash(Version))
		{
			Hash = reader.ReadEndian<Hash128>();
			Crc = reader.ReadUInt32();
		}
		MinimumStreamedBytes = reader.ReadUInt32();
		HeaderSize = reader.ReadInt32();
		NumberOfScenesToDownloadBeforeStreaming = reader.ReadInt32();
		Scenes = reader.ReadEndianArray<BundleScene>();
		if (HasCompleteFileSize(Version))
		{
			CompleteFileSize = reader.ReadUInt32();
		}
		if (HasUncompressedBlocksInfoSize(Version))
		{
			UncompressedBlocksInfoSize = (int)reader.ReadUInt32();
		}
		reader.AlignStream();
	}

	public sealed override void Write(EndianWriter writer)
	{
		base.Write(writer);
		throw new NotImplementedException();
	}

	/// <summary>
	/// 5.2.0 and greater / Bundle Version 4 +
	/// </summary>
	public static bool HasHash(BundleVersion generation) => generation >= BundleVersion.BF_520a1;
	/// <summary>
	/// 2.6.0 and greater / Bundle Version 2 +
	/// </summary>
	public static bool HasCompleteFileSize(BundleVersion generation) => generation >= BundleVersion.BF_260_340;
	/// <summary>
	/// 3.5.0 and greater / Bundle Version 3 +
	/// </summary>
	public static bool HasUncompressedBlocksInfoSize(BundleVersion generation) => generation >= BundleVersion.BF_350_4x;
}

```

`Source/AssetRipper.IO.Files/BundleFiles/RawWeb/RawWebNode.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles.RawWeb;

public sealed record class RawWebNode : Node, IEndianReadable<RawWebNode>
{
	public static RawWebNode Read(EndianReader reader)
	{
		return new()
		{
			Path = reader.ReadStringZeroTerm(),
			Offset = reader.ReadInt32(),
			Size = reader.ReadInt32(),
		};
	}

	public override void Write(EndianWriter writer)
	{
		writer.WriteStringZeroTerm(Path);
		writer.Write((int)Offset);
		writer.Write((int)Size);
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/RawWeb/Web/WebBundleFile.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles.RawWeb.Web;

public sealed class WebBundleFile : RawWebBundleFile<WebBundleHeader> { }

```

`Source/AssetRipper.IO.Files/BundleFiles/RawWeb/Web/WebBundleHeader.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles.RawWeb.Web;

public sealed record class WebBundleHeader : RawWebBundleHeader
{
	private const string UnityWebMagic = "UnityWeb";
	protected override string MagicString => UnityWebMagic;
	internal static bool IsBundleHeader(EndianReader reader) => IsBundleHeader(reader, UnityWebMagic);
}

```

`Source/AssetRipper.IO.Files/BundleFiles/RawWeb/Web/WebBundleScheme.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.BundleFiles.RawWeb.Web;

public sealed class WebBundleScheme : Scheme<WebBundleFile>
{
	public override bool CanRead(SmartStream stream)
	{
		return WebBundleHeader.IsBundleHeader(new EndianReader(stream, EndianType.BigEndian));
	}
}

```

`Source/AssetRipper.IO.Files/BundleFiles/ZstdCompression.cs`:

```cs
using AssetRipper.IO.Files.Streams;
using ZstdSharp;

namespace AssetRipper.IO.Files.BundleFiles;

public static class ZstdCompression
{
	private static readonly byte[] Signature = [0x28, 0xB5, 0x2F, 0xFD];
	public static bool IsZstd(Stream Stream)
	{
		Span<byte> buffer = stackalloc byte[4];

		long pos = Stream.Position;
		Stream.ReadExactly(buffer);
		Stream.Position = pos;

		return buffer.SequenceEqual(Signature);
	}

	public static void DecompressStream(Stream compressedStream, long compressedSize, Stream decompressedStream, long decompressedSize)
	{
		using PartialStream compressedPartialStream = new PartialStream(compressedStream, compressedStream.Position, compressedSize, true);
		using PartialStream decompressedPartialStream = new PartialStream(decompressedStream, decompressedStream.Position, decompressedSize, true);
		using DecompressionStream zstdStream = new DecompressionStream(compressedPartialStream);
		zstdStream.CopyTo(decompressedPartialStream);
	}
}

```

`Source/AssetRipper.IO.Files/CompressedFiles/Brotli/BrotliFile.cs`:

```cs
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.Streams.Smart;
using System.IO.Compression;

namespace AssetRipper.IO.Files.CompressedFiles.Brotli;

public sealed class BrotliFile : CompressedFile
{
	private static ReadOnlySpan<byte> BrotliSignature => "UnityWeb Compressed Content (brotli)"u8;

	public override void Read(SmartStream stream)
	{
		try
		{
			byte[] buffer = ReadBrotli(stream);
			UncompressedFile = new ResourceFile(buffer, FilePath, Name);
		}
		catch (Exception ex)
		{
			UncompressedFile = new FailedFile()
			{
				Name = Name,
				FilePath = FilePath,
				StackTrace = ex.ToString(),
			};
		}
	}

	internal static bool IsBrotliFile(Stream stream)
	{
		long remaining = stream.Length - stream.Position;
		if (remaining < 4)
		{
			return false;
		}

		long position = stream.Position;

		stream.Position += 1;
		byte bt = (byte)stream.ReadByte(); // read 3 bits
		int sizeBytes = bt & 0x3;

		if (stream.Position + sizeBytes > stream.Length)
		{
			stream.Position = position;
			return false;
		}

		int length = 0;
		for (int i = 0; i < sizeBytes; i++)
		{
			byte nbt = (byte)stream.ReadByte();  // read next 8 bits
			int bits = (bt >> 2) | ((nbt & 0x3) << 6);
			bt = nbt;
			length += bits << (8 * i);
		}

		if (length != BrotliSignature.Length
			|| stream.Position + length > stream.Length)
		{
			stream.Position = position;
			return false;
		}

		Span<byte> buffer = stackalloc byte[BrotliSignature.Length];
		stream.ReadExactly(buffer);
		stream.Position = position;
		return buffer.SequenceEqual(BrotliSignature);
	}

	private static byte[] ReadBrotli(Stream stream)
	{
		using MemoryStream memoryStream = new MemoryStream();
		using BrotliStream brotliStream = new BrotliStream(stream, CompressionMode.Decompress);
		brotliStream.CopyTo(memoryStream);
		return memoryStream.ToArray();
	}

	public override void Write(Stream stream)
	{
		throw new NotImplementedException();
	}
}

```

`Source/AssetRipper.IO.Files/CompressedFiles/Brotli/BrotliFileScheme.cs`:

```cs
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.CompressedFiles.Brotli;

public sealed class BrotliFileScheme : Scheme<BrotliFile>
{
	public override bool CanRead(SmartStream stream)
	{
		return BrotliFile.IsBrotliFile(stream);
	}
}

```

`Source/AssetRipper.IO.Files/CompressedFiles/CompressedFile.cs`:

```cs
using AssetRipper.IO.Files.ResourceFiles;

namespace AssetRipper.IO.Files.CompressedFiles;

public abstract class CompressedFile : FileBase
{
	public FileBase? UncompressedFile { get; set; }

	public override void ReadContents()
	{
		if (UncompressedFile is ResourceFile resourceFile)
		{
			UncompressedFile = SchemeReader.ReadFile(resourceFile);
		}
	}

	public override void ReadContentsRecursively()
	{
		ReadContents();
		UncompressedFile?.ReadContentsRecursively();
	}
}

```

`Source/AssetRipper.IO.Files/CompressedFiles/GZip/GZipFile.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.Streams.Smart;
using System.IO.Compression;

namespace AssetRipper.IO.Files.CompressedFiles.GZip;

public sealed class GZipFile : CompressedFile
{
	private const ushort GZipMagic = 0x1F8B;

	public override void Read(SmartStream stream)
	{
		try
		{
			using SmartStream memoryStream = SmartStream.CreateMemory();
			using (GZipStream gzipStream = new GZipStream(stream, CompressionMode.Decompress, true))
			{
				gzipStream.CopyTo(memoryStream);
			}
			memoryStream.Position = 0;
			UncompressedFile = new ResourceFile(memoryStream, FilePath, Name);
		}
		catch (Exception ex)
		{
			UncompressedFile = new FailedFile()
			{
				Name = Name,
				FilePath = FilePath,
				StackTrace = ex.ToString(),
			};
		}
	}

	public override void Write(Stream stream)
	{
		using MemoryStream memoryStream = new();
		UncompressedFile?.Write(memoryStream);
		memoryStream.Position = 0;
		using GZipStream gzipStream = new GZipStream(stream, CompressionMode.Compress, true);
		memoryStream.CopyTo(gzipStream);
	}

	internal static bool IsGZipFile(EndianReader reader)
	{
		long position = reader.BaseStream.Position;
		ushort gzipMagic = ReadGZipMagic(reader);
		reader.BaseStream.Position = position;
		return gzipMagic == GZipMagic;
	}

	private static ushort ReadGZipMagic(EndianReader reader)
	{
		long remaining = reader.BaseStream.Length - reader.BaseStream.Position;
		if (remaining >= sizeof(ushort))
		{
			return reader.ReadUInt16();
		}
		return 0;
	}
}

```

`Source/AssetRipper.IO.Files/CompressedFiles/GZip/GZipFileScheme.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.CompressedFiles.GZip;

public sealed class GZipFileScheme : Scheme<GZipFile>
{
	public override bool CanRead(SmartStream stream)
	{
		using EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
		return GZipFile.IsGZipFile(reader);
	}
}

```

`Source/AssetRipper.IO.Files/Converters/SerializedFileMetadataConverter.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.IO.Files.Converters;

public static class SerializedFileMetadataConverter
{
	public static void CombineFormats(FormatVersion generation, SerializedFileMetadata origin)
	{
		if (!SerializedFileMetadata.HasEnableTypeTree(generation))
		{
			origin.EnableTypeTree = true;
		}
		if (generation >= FormatVersion.RefactorTypeData)
		{
			for (int i = 0; i < origin.Object.Length; i++)
			{
				origin.Object[i].Initialize(origin.Types);
			}
		}
	}
}

```

`Source/AssetRipper.IO.Files/Exceptions/DecompressionFailedException.cs`:

```cs
using AssetRipper.IO.Files.BundleFiles;

namespace AssetRipper.IO.Files.Exceptions;

public sealed class DecompressionFailedException : Exception
{
	private DecompressionFailedException(string message) : base(message) { }

	[DoesNotReturn]
	internal static void ThrowNoBytesWritten(string fileName, CompressionType compression)
	{
		throw new DecompressionFailedException($"Could not write any bytes for '{fileName}' while decompressing {compression}. File: {fileName}");
	}

	[DoesNotReturn]
	internal static void ThrowReadMoreThanExpected(CompressionType compression, long expected, long actual)
	{
		throw new DecompressionFailedException($"Read more than expected while decompressing {compression}. Expected {expected}, but was {actual}.");
	}

	[DoesNotReturn]
	internal static void ThrowReadMoreThanExpected(string fileName, long expected, long actual)
	{
		throw new DecompressionFailedException($"Read more than expected for '{fileName}' while decompressing. Expected {expected}, but was {actual}.");
	}

	[DoesNotReturn]
	internal static void ThrowIncorrectNumberBytesWritten(string fileName, CompressionType compression, long expected, long actual)
	{
		throw new DecompressionFailedException($"Incorrect number of bytes written for '{fileName}' while decompressing {compression}. Expected {expected}, but was {actual}.");
	}

	internal static void ThrowIfUncompressedSizeIsNegative(string fileName, long uncompressedSize)
	{
		if (uncompressedSize < 0)
		{
			throw new DecompressionFailedException($"Uncompressed size cannot be negative: {uncompressedSize}. File: {fileName}");
		}
	}
}

```

`Source/AssetRipper.IO.Files/Exceptions/InvalidFormatException.cs`:

```cs
namespace AssetRipper.IO.Files.Exceptions;

public sealed class InvalidFormatException : Exception
{
	public InvalidFormatException(string message) : base(message)
	{
	}
}

```

`Source/AssetRipper.IO.Files/Exceptions/UnsupportedBundleDecompression.cs`:

```cs
using AssetRipper.IO.Files.BundleFiles;

namespace AssetRipper.IO.Files.Exceptions;

public sealed class UnsupportedBundleDecompression : NotSupportedException
{
	private UnsupportedBundleDecompression(string message) : base(message) { }

	[DoesNotReturn]
	public static void ThrowLzham(string fileName)
	{
		throw new UnsupportedBundleDecompression($"Lzham decompression is not currently supported. File: {fileName}");
	}

	[DoesNotReturn]
	public static void Throw(string fileName, CompressionType compression)
	{
		throw new UnsupportedBundleDecompression($"Bundle compression '{compression}' is not supported. '{fileName}' is likely encrypted or using a custom compression algorithm.");
	}
}

```

`Source/AssetRipper.IO.Files/Extensions/StreamExtensions.cs`:

```cs
namespace AssetRipper.IO.Files.Extensions;

public static class StreamExtensions
{
	public static void Align(this Stream _this) => _this.Align(4);
	public static void Align(this Stream _this, int alignment)
	{
		long pos = _this.Position;
		long mod = pos % alignment;
		if (mod != 0)
		{
			_this.Position += alignment - mod;
		}
	}
}

```

`Source/AssetRipper.IO.Files/FailedFile.cs`:

```cs
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files;

public class FailedFile : FileBase
{
	public string StackTrace { get; set; } = "";

	public override void Read(SmartStream stream)
	{
	}

	public override void Write(Stream stream)
	{
		throw new NotSupportedException();
	}
}

```

`Source/AssetRipper.IO.Files/FileBase.cs`:

```cs
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files;

/// <summary>
/// The base class for files.
/// </summary>
public abstract class FileBase : IDisposable
{
	public override string? ToString()
	{
		return string.IsNullOrEmpty(NameFixed) ? NameFixed : base.ToString();
	}

	public string FilePath { get; set; } = string.Empty;
	public string Name
	{
		get;
		set
		{
			field = value;
			NameFixed = SpecialFileNames.FixFileIdentifier(value);
		}
	} = string.Empty;
	public string NameFixed { get; private set; } = string.Empty;

	public abstract void Read(SmartStream stream);
	public abstract void Write(Stream stream);
	public virtual void ReadContents() { }
	public virtual void ReadContentsRecursively() => ReadContents();
	public virtual byte[] ToByteArray()
	{
		MemoryStream memoryStream = new();
		Write(memoryStream);
		return memoryStream.ToArray();
	}

	~FileBase() => Dispose(false);

	protected virtual void Dispose(bool disposing) { }

	public void Dispose()
	{
		Dispose(true);
		GC.SuppressFinalize(this);
	}
}

```

`Source/AssetRipper.IO.Files/FileContainer.cs`:

```cs
using AssetRipper.IO.Files.CompressedFiles;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.SerializedFiles;

namespace AssetRipper.IO.Files;

public abstract class FileContainer : FileBase
{
	public IEnumerable<SerializedFile> FetchSerializedFiles()
	{
		foreach (SerializedFile file in SerializedFiles)
		{
			yield return file;
		}
		foreach (FileContainer list in FileLists)
		{
			foreach (SerializedFile file in list.FetchSerializedFiles())
			{
				yield return file;
			}
		}
	}

	public void AddFile(FileBase? file)
	{
		switch (file)
		{
			case SerializedFile serializedFile:
				AddSerializedFile(serializedFile);
				return;
			case ResourceFile resourceFile:
				AddResourceFile(resourceFile);
				return;
			case FileContainer fileList:
				AddFileContainer(fileList);
				return;
			case CompressedFile compressedFile:
				AddFile(compressedFile.UncompressedFile);
				return;
			case FailedFile failedFile:
				AddFailedFile(failedFile);
				return;
			case null:
				return;
			default:
				throw new NotSupportedException(file.GetType().ToString());
		}
	}

	public void AddSerializedFile(SerializedFile file)
	{
		if (m_serializedFiles is null)
		{
			m_serializedFiles = [file];
		}
		else
		{
			m_serializedFiles.Add(file);
		}
		OnSerializedFileAdded(file);
	}

	public void AddFileContainer(FileContainer container)
	{
		if (m_fileLists is null)
		{
			m_fileLists = [container];
		}
		else
		{
			m_fileLists.Add(container);
		}
		OnFileContainerAdded(container);
	}

	public void AddResourceFile(ResourceFile resource)
	{
		if (m_resourceFiles is null)
		{
			m_resourceFiles = [resource];
		}
		else
		{
			m_resourceFiles.Add(resource);
		}
		OnResourceFileAdded(resource);
	}

	public void AddFailedFile(FailedFile file)
	{
		if (m_failedFiles is null)
		{
			m_failedFiles = [file];
		}
		else
		{
			m_failedFiles.Add(file);
		}
	}

	protected virtual void OnSerializedFileAdded(SerializedFile file) { }

	protected virtual void OnFileContainerAdded(FileContainer container) { }

	protected virtual void OnResourceFileAdded(ResourceFile resource) { }

	public override void ReadContents()
	{
		if (m_resourceFiles is { Count: > 0 })
		{
			ResourceFile[] resourceFiles = m_resourceFiles.ToArray();
			m_resourceFiles.Clear();
			for (int i = 0; i < resourceFiles.Length; i++)
			{
				AddFile(SchemeReader.ReadFile(resourceFiles[i]));
			}
		}
	}

	public override void ReadContentsRecursively()
	{
		ReadContents();
		foreach (FileContainer container in FileLists)
		{
			container.ReadContentsRecursively();
		}
	}

	public IReadOnlyList<SerializedFile> SerializedFiles => m_serializedFiles ?? [];
	public IReadOnlyList<FileContainer> FileLists => m_fileLists ?? [];
	public IReadOnlyList<ResourceFile> ResourceFiles => m_resourceFiles ?? [];
	public IReadOnlyList<FailedFile> FailedFiles => m_failedFiles ?? [];

	public IEnumerable<FileBase> AllFiles
	{
		get
		{
			foreach (ResourceFile resource in ResourceFiles)
			{
				yield return resource;
			}
			foreach (SerializedFile file in SerializedFiles)
			{
				yield return file;
			}
			foreach (FileContainer container in FileLists)
			{
				yield return container;
			}
			foreach (FailedFile file in FailedFiles)
			{
				yield return file;
			}
		}
	}

	private List<SerializedFile>? m_serializedFiles;
	private List<FileContainer>? m_fileLists;
	private List<ResourceFile>? m_resourceFiles;
	private List<FailedFile>? m_failedFiles;
}

```

`Source/AssetRipper.IO.Files/FileSystem.cs`:

```cs
using System.Buffers;
using System.Text;
using System.Text.RegularExpressions;

namespace AssetRipper.IO.Files;

public partial class FileSystem
{
	/// <summary>
	/// <see href="https://en.wikipedia.org/wiki/Comparison_of_file_systems#Limits"/>
	/// </summary>
	private const int ActualMaxFileNameLength = 255;
	/// <summary>
	/// We reserve 10 characters for handling file name conflicts, an underscore and up to 9 digits.
	/// This allows us to handle up to 1 billion duplicates, far more than we'll ever need.
	/// </summary>
	private const int ReservedCharacterCount = 10;
	public const int MaxFileNameLength = ActualMaxFileNameLength - ReservedCharacterCount;

	public abstract string TemporaryDirectory { get; set; }

	public partial class FileImplementation
	{
		public string CreateTemporary()
		{
			Directory.Create(Parent.TemporaryDirectory);
			string path = Path.Join(Parent.TemporaryDirectory, GetRandomString());
			File.Create(path).Dispose();
			return path;
		}
	}

	public partial class DirectoryImplementation
	{
		public virtual void Create(string path) => throw new NotSupportedException();

		public virtual void Delete(string path) => throw new NotSupportedException();

		public string CreateTemporary()
		{
			string path = Path.Join(Parent.TemporaryDirectory, GetRandomString()[0..8]);
			Directory.Create(path);
			return path;
		}
	}

	public void DeleteTemporaryDirectory()
	{
		if (Directory.Exists(TemporaryDirectory))
		{
			Directory.Delete(TemporaryDirectory);
		}
	}

	public string GetUniqueName(string dirPath, string fileName, int maxNameLength)
	{
		string? ext = null;
		string? name = null;
		string validFileName = fileName;
		if (Encoding.UTF8.GetByteCount(fileName) > maxNameLength)
		{
			ext = Path.GetExtension(validFileName);
			name = Utf8Truncation.TruncateToUTF8ByteLength(fileName, maxNameLength - Encoding.UTF8.GetByteCount(ext));
			validFileName = name + ext;
		}

		if (!Directory.Exists(dirPath))
		{
			return validFileName;
		}

		name ??= Path.GetFileNameWithoutExtension(validFileName);
		if (!IsReservedName(name))
		{
			if (!File.Exists(Path.Join(dirPath, validFileName)))
			{
				return validFileName;
			}
		}

		ext ??= Path.GetExtension(validFileName);

		string key = Path.Join(dirPath, $"{name}{ext}");
		UniqueNamesByInitialPath.TryGetValue(key, out int initial);

		for (int counter = initial; counter < int.MaxValue; counter++)
		{
			string proposedName = $"{name}_{counter}{ext}";
			if (!File.Exists(Path.Join(dirPath, proposedName)))
			{
				UniqueNamesByInitialPath[key] = counter;
				return proposedName;
			}
		}
		throw new Exception($"Can't generate unique name for file {fileName} in directory {dirPath}");
	}

	private Dictionary<string, int> UniqueNamesByInitialPath { get; } = [];

	public static string RemoveCloneSuffixes(string path)
	{
		return path.Replace("(Clone)", null);
	}

	public static string RemoveInstanceSuffixes(string path)
	{
		return path.Replace("(Instance)", null);
	}

	public static string FixInvalidFileNameCharacters(string path)
	{
		return FileNameRegex.Replace(path, "_");
	}

	private static Regex CreateFileNameRegex()
	{
		string invalidChars = GetInvalidFileNameChars();
		string escapedChars = Regex.Escape(invalidChars);
		// Updated regex to include commas, square brackets, and ASCII control characters
		return new Regex($@"[{escapedChars},\[\]\x00-\x1F]", RegexOptions.Compiled);
	}

	/// <summary>
	/// Gets all the invalid characters including the colon on Linux
	/// </summary>
	/// <returns></returns>
	private static string GetInvalidFileNameChars()
	{
		char[] defaultBadCharacters = System.IO.Path.GetInvalidFileNameChars();
		string result = new string(defaultBadCharacters);
		if (defaultBadCharacters.Contains(':'))
		{
			return result;
		}
		else
		{
			return result + ':';
		}
	}

	private static Regex FileNameRegex { get; } = CreateFileNameRegex();

	public static string FixInvalidPathCharacters(string path)
	{
		return TrimEntries(PathRegex.Replace(path, "_"));

		static string TrimEntries(string path)
		{
			if (path.Contains(" /", StringComparison.Ordinal) || path.Contains("/ ", StringComparison.Ordinal))
			{
				string[] entries = path.Split('/', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
				return string.Join('/', entries);
			}
			else
			{
				return path.Trim();
			}
		}
	}

	private static Regex CreatePathRegex()
	{
		string invalidChars = new string(System.IO.Path.GetInvalidFileNameChars().Except(['\\', '/']).ToArray());
		string escapedChars = Regex.Escape(invalidChars);
		// Updated regex to include commas, square brackets, and ASCII control characters
		return new Regex($@"[{escapedChars},\[\]\x00-\x1F]", RegexOptions.Compiled);
	}

	private static Regex PathRegex { get; } = CreatePathRegex();

	public static bool IsReservedName(string name)
	{
		return OperatingSystem.IsWindows() && name.Length is 3 or 4 && ReservedNames.Contains(name);
	}

	private static HashSet<string> ReservedNames { get; } = new(StringComparer.OrdinalIgnoreCase)
	{
		"aux", "con", "nul", "prn",
		"com1", "com2", "com3", "com4", "com5", "com6", "com7", "com8", "com9",
		"lpt1", "lpt2", "lpt3", "lpt4", "lpt5", "lpt6", "lpt7", "lpt8", "lpt9",
	};

	private protected static string GetRandomString() => Guid.NewGuid().ToString();
}

```

`Source/AssetRipper.IO.Files/FileSystem.g.cs`:

```cs
// Auto-generated code. Do not modify manually.

namespace AssetRipper.IO.Files;

public abstract partial class FileSystem
{
	public abstract FileImplementation File { get; }

	public abstract partial class FileImplementation(FileSystem fileSystem)
	{
		protected FileSystem Parent { get; } = fileSystem;
		protected FileImplementation File => this;
		protected DirectoryImplementation Directory => Parent.Directory;
		protected PathImplementation Path => Parent.Path;
		/// <inheritdoc cref="global::System.IO.File.Create(global::System.String)"/>
		public virtual global::System.IO.Stream Create(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.File.Delete(global::System.String)"/>
		public virtual void Delete(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.File.Exists(global::System.String)"/>
		public virtual global::System.Boolean Exists(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.File.OpenRead(global::System.String)"/>
		public virtual global::System.IO.Stream OpenRead(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.File.OpenWrite(global::System.String)"/>
		public virtual global::System.IO.Stream OpenWrite(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.File.ReadAllBytes(global::System.String)"/>
		public virtual global::System.Byte[] ReadAllBytes(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.File.ReadAllText(global::System.String)"/>
		public virtual global::System.String ReadAllText(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.File.ReadAllText(global::System.String, global::System.Text.Encoding)"/>
		public virtual global::System.String ReadAllText(global::System.String path, global::System.Text.Encoding encoding)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.File.WriteAllBytes(global::System.String, global::System.ReadOnlySpan<global::System.Byte>)"/>
		public virtual void WriteAllBytes(global::System.String path, global::System.ReadOnlySpan<global::System.Byte> bytes)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.File.WriteAllText(global::System.String, global::System.ReadOnlySpan<global::System.Char>)"/>
		public virtual void WriteAllText(global::System.String path, global::System.ReadOnlySpan<global::System.Char> contents)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.File.WriteAllText(global::System.String, global::System.ReadOnlySpan<global::System.Char>, global::System.Text.Encoding)"/>
		public virtual void WriteAllText(global::System.String path, global::System.ReadOnlySpan<global::System.Char> contents, global::System.Text.Encoding encoding)
		{
			throw new global::System.NotSupportedException();
		}

		// Override methods below to provide custom implementation
		public sealed override string ToString() => base.ToString();
		public sealed override bool Equals(object obj) => base.Equals(obj);
		public sealed override int GetHashCode() => base.GetHashCode();
	}

	public abstract DirectoryImplementation Directory { get; }

	public abstract partial class DirectoryImplementation(FileSystem fileSystem)
	{
		protected FileSystem Parent { get; } = fileSystem;
		protected FileImplementation File => Parent.File;
		protected DirectoryImplementation Directory => this;
		protected PathImplementation Path => Parent.Path;
		/// <inheritdoc cref="global::System.IO.Directory.EnumerateDirectories(global::System.String, global::System.String, global::System.IO.SearchOption)"/>
		public virtual global::System.Collections.Generic.IEnumerable<global::System.String> EnumerateDirectories(global::System.String path, global::System.String searchPattern, global::System.IO.SearchOption searchOption)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Directory.EnumerateFiles(global::System.String, global::System.String, global::System.IO.SearchOption)"/>
		public virtual global::System.Collections.Generic.IEnumerable<global::System.String> EnumerateFiles(global::System.String path, global::System.String searchPattern, global::System.IO.SearchOption searchOption)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Directory.GetDirectories(global::System.String, global::System.String, global::System.IO.SearchOption)"/>
		public virtual global::System.String[] GetDirectories(global::System.String path, global::System.String searchPattern, global::System.IO.SearchOption searchOption)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Directory.GetFiles(global::System.String, global::System.String, global::System.IO.SearchOption)"/>
		public virtual global::System.String[] GetFiles(global::System.String path, global::System.String searchPattern, global::System.IO.SearchOption searchOption)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Directory.EnumerateDirectories(global::System.String, global::System.String)"/>
		public virtual global::System.Collections.Generic.IEnumerable<global::System.String> EnumerateDirectories(global::System.String path, global::System.String searchPattern)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Directory.EnumerateFiles(global::System.String, global::System.String)"/>
		public virtual global::System.Collections.Generic.IEnumerable<global::System.String> EnumerateFiles(global::System.String path, global::System.String searchPattern)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Directory.GetDirectories(global::System.String, global::System.String)"/>
		public virtual global::System.String[] GetDirectories(global::System.String path, global::System.String searchPattern)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Directory.GetFiles(global::System.String, global::System.String)"/>
		public virtual global::System.String[] GetFiles(global::System.String path, global::System.String searchPattern)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Directory.EnumerateDirectories(global::System.String)"/>
		public virtual global::System.Collections.Generic.IEnumerable<global::System.String> EnumerateDirectories(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Directory.EnumerateFiles(global::System.String)"/>
		public virtual global::System.Collections.Generic.IEnumerable<global::System.String> EnumerateFiles(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Directory.GetDirectories(global::System.String)"/>
		public virtual global::System.String[] GetDirectories(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Directory.GetFiles(global::System.String)"/>
		public virtual global::System.String[] GetFiles(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Directory.Exists(global::System.String)"/>
		public virtual global::System.Boolean Exists(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		// Override methods below to provide custom implementation
		public sealed override string ToString() => base.ToString();
		public sealed override bool Equals(object obj) => base.Equals(obj);
		public sealed override int GetHashCode() => base.GetHashCode();
	}

	public abstract PathImplementation Path { get; }

	public abstract partial class PathImplementation(FileSystem fileSystem)
	{
		protected FileSystem Parent { get; } = fileSystem;
		protected FileImplementation File => Parent.File;
		protected DirectoryImplementation Directory => Parent.Directory;
		protected PathImplementation Path => this;
		/// <inheritdoc cref="global::System.IO.Path.Join(global::System.String, global::System.String)"/>
		public virtual global::System.String Join(global::System.String path1, global::System.String path2)
		{
			return global::System.IO.Path.Join(path1, path2);
		}

		/// <inheritdoc cref="global::System.IO.Path.Join(global::System.String, global::System.String, global::System.String)"/>
		public virtual global::System.String Join(global::System.String path1, global::System.String path2, global::System.String path3)
		{
			return global::System.IO.Path.Join(path1, path2, path3);
		}

		/// <inheritdoc cref="global::System.IO.Path.Join(global::System.String, global::System.String, global::System.String, global::System.String)"/>
		public virtual global::System.String Join(global::System.String path1, global::System.String path2, global::System.String path3, global::System.String path4)
		{
			return global::System.IO.Path.Join(path1, path2, path3, path4);
		}

		/// <inheritdoc cref="global::System.IO.Path.Join(params global::System.ReadOnlySpan<global::System.String>)"/>
		public virtual global::System.String Join(params global::System.ReadOnlySpan<global::System.String> paths)
		{
			return global::System.IO.Path.Join(paths);
		}

		/// <inheritdoc cref="global::System.IO.Path.GetDirectoryName(global::System.ReadOnlySpan<global::System.Char>)"/>
		public global::System.ReadOnlySpan<global::System.Char> GetDirectoryName(global::System.ReadOnlySpan<global::System.Char> path)
		{
			return global::System.IO.Path.GetDirectoryName(path);
		}

		/// <inheritdoc cref="global::System.IO.Path.GetDirectoryName(global::System.String)"/>
		public global::System.String GetDirectoryName(global::System.String path)
		{
			return global::System.IO.Path.GetDirectoryName(path);
		}

		/// <inheritdoc cref="global::System.IO.Path.GetExtension(global::System.ReadOnlySpan<global::System.Char>)"/>
		public global::System.ReadOnlySpan<global::System.Char> GetExtension(global::System.ReadOnlySpan<global::System.Char> path)
		{
			return global::System.IO.Path.GetExtension(path);
		}

		/// <inheritdoc cref="global::System.IO.Path.GetExtension(global::System.String)"/>
		public global::System.String GetExtension(global::System.String path)
		{
			return global::System.IO.Path.GetExtension(path);
		}

		/// <inheritdoc cref="global::System.IO.Path.GetFileName(global::System.ReadOnlySpan<global::System.Char>)"/>
		public global::System.ReadOnlySpan<global::System.Char> GetFileName(global::System.ReadOnlySpan<global::System.Char> path)
		{
			return global::System.IO.Path.GetFileName(path);
		}

		/// <inheritdoc cref="global::System.IO.Path.GetFileName(global::System.String)"/>
		public global::System.String GetFileName(global::System.String path)
		{
			return global::System.IO.Path.GetFileName(path);
		}

		/// <inheritdoc cref="global::System.IO.Path.GetFileNameWithoutExtension(global::System.ReadOnlySpan<global::System.Char>)"/>
		public global::System.ReadOnlySpan<global::System.Char> GetFileNameWithoutExtension(global::System.ReadOnlySpan<global::System.Char> path)
		{
			return global::System.IO.Path.GetFileNameWithoutExtension(path);
		}

		/// <inheritdoc cref="global::System.IO.Path.GetFileNameWithoutExtension(global::System.String)"/>
		public global::System.String GetFileNameWithoutExtension(global::System.String path)
		{
			return global::System.IO.Path.GetFileNameWithoutExtension(path);
		}

		/// <inheritdoc cref="global::System.IO.Path.GetFullPath(global::System.String)"/>
		public virtual global::System.String GetFullPath(global::System.String path)
		{
			throw new global::System.NotSupportedException();
		}

		/// <inheritdoc cref="global::System.IO.Path.GetRelativePath(global::System.String, global::System.String)"/>
		public global::System.String GetRelativePath(global::System.String relativeTo, global::System.String path)
		{
			return global::System.IO.Path.GetRelativePath(relativeTo, path);
		}

		/// <inheritdoc cref="global::System.IO.Path.IsPathRooted(global::System.ReadOnlySpan<global::System.Char>)"/>
		public virtual global::System.Boolean IsPathRooted(global::System.ReadOnlySpan<global::System.Char> path)
		{
			throw new global::System.NotSupportedException();
		}

		// Override methods below to provide custom implementation
		public sealed override string ToString() => base.ToString();
		public sealed override bool Equals(object obj) => base.Equals(obj);
		public sealed override int GetHashCode() => base.GetHashCode();
	}

}

```

`Source/AssetRipper.IO.Files/IScheme.cs`:

```cs
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files;

public interface IScheme
{
	/// <summary>
	/// Checks if the file can be read by this scheme.
	/// </summary>
	/// <remarks>
	/// Implementations are expected to reset the <paramref name="stream"/> to its initial position.
	/// </remarks>
	/// <param name="stream">The stream for the file.</param>
	/// <returns>True if the file can be read.</returns>
	bool CanRead(SmartStream stream);
	FileBase Read(SmartStream stream, string filePath, string fileName);
}

```

`Source/AssetRipper.IO.Files/LocalFileSystem.cs`:

```cs
namespace AssetRipper.IO.Files;

public partial class LocalFileSystem : FileSystem
{
	public static LocalFileSystem Instance { get; } = new();

	public partial class LocalFileImplementation
	{
	}

	public partial class LocalDirectoryImplementation
	{
		public override void Create(string path) => System.IO.Directory.CreateDirectory(path);

		public override void Delete(string path) => System.IO.Directory.Delete(path, true);
	}

	private static string ExecutingDirectory => AppContext.BaseDirectory;

	public string LocalTemporaryDirectory => Path.Join(ExecutingDirectory, "temp", GetRandomString()[0..4]);

	public override string TemporaryDirectory
	{
		get
		{
			if (string.IsNullOrEmpty(field))
			{
				field = LocalTemporaryDirectory;
			}
			return field;
		}
		set
		{
			if (!string.IsNullOrWhiteSpace(value))
			{
				field = Path.GetFullPath(value);
			}
		}
	}
}

```

`Source/AssetRipper.IO.Files/LocalFileSystem.g.cs`:

```cs
// Auto-generated code. Do not modify manually.

namespace AssetRipper.IO.Files;

public sealed partial class LocalFileSystem : FileSystem
{
	public override LocalFileImplementation File { get; }

	public sealed partial class LocalFileImplementation(LocalFileSystem fileSystem) : FileImplementation(fileSystem)
	{
		public override global::System.IO.FileStream Create(global::System.String path)
		{
			return global::System.IO.File.Create(path);
		}

		public override void Delete(global::System.String path)
		{
			global::System.IO.File.Delete(path);
		}

		public override global::System.Boolean Exists(global::System.String path)
		{
			return global::System.IO.File.Exists(path);
		}

		public override global::System.IO.FileStream OpenRead(global::System.String path)
		{
			return global::System.IO.File.OpenRead(path);
		}

		public override global::System.IO.FileStream OpenWrite(global::System.String path)
		{
			return global::System.IO.File.OpenWrite(path);
		}

		public override global::System.Byte[] ReadAllBytes(global::System.String path)
		{
			return global::System.IO.File.ReadAllBytes(path);
		}

		public override global::System.String ReadAllText(global::System.String path)
		{
			return global::System.IO.File.ReadAllText(path);
		}

		public override global::System.String ReadAllText(global::System.String path, global::System.Text.Encoding encoding)
		{
			return global::System.IO.File.ReadAllText(path, encoding);
		}

		public override void WriteAllBytes(global::System.String path, global::System.ReadOnlySpan<global::System.Byte> bytes)
		{
			global::System.IO.File.WriteAllBytes(path, bytes);
		}

		public override void WriteAllText(global::System.String path, global::System.ReadOnlySpan<global::System.Char> contents)
		{
			global::System.IO.File.WriteAllText(path, contents);
		}

		public override void WriteAllText(global::System.String path, global::System.ReadOnlySpan<global::System.Char> contents, global::System.Text.Encoding encoding)
		{
			global::System.IO.File.WriteAllText(path, contents, encoding);
		}

	}

	public override LocalDirectoryImplementation Directory { get; }

	public sealed partial class LocalDirectoryImplementation(LocalFileSystem fileSystem) : DirectoryImplementation(fileSystem)
	{
		public override global::System.Collections.Generic.IEnumerable<global::System.String> EnumerateDirectories(global::System.String path, global::System.String searchPattern, global::System.IO.SearchOption searchOption)
		{
			return global::System.IO.Directory.EnumerateDirectories(path, searchPattern, searchOption);
		}

		public override global::System.Collections.Generic.IEnumerable<global::System.String> EnumerateFiles(global::System.String path, global::System.String searchPattern, global::System.IO.SearchOption searchOption)
		{
			return global::System.IO.Directory.EnumerateFiles(path, searchPattern, searchOption);
		}

		public override global::System.String[] GetDirectories(global::System.String path, global::System.String searchPattern, global::System.IO.SearchOption searchOption)
		{
			return global::System.IO.Directory.GetDirectories(path, searchPattern, searchOption);
		}

		public override global::System.String[] GetFiles(global::System.String path, global::System.String searchPattern, global::System.IO.SearchOption searchOption)
		{
			return global::System.IO.Directory.GetFiles(path, searchPattern, searchOption);
		}

		public override global::System.Collections.Generic.IEnumerable<global::System.String> EnumerateDirectories(global::System.String path, global::System.String searchPattern)
		{
			return global::System.IO.Directory.EnumerateDirectories(path, searchPattern);
		}

		public override global::System.Collections.Generic.IEnumerable<global::System.String> EnumerateFiles(global::System.String path, global::System.String searchPattern)
		{
			return global::System.IO.Directory.EnumerateFiles(path, searchPattern);
		}

		public override global::System.String[] GetDirectories(global::System.String path, global::System.String searchPattern)
		{
			return global::System.IO.Directory.GetDirectories(path, searchPattern);
		}

		public override global::System.String[] GetFiles(global::System.String path, global::System.String searchPattern)
		{
			return global::System.IO.Directory.GetFiles(path, searchPattern);
		}

		public override global::System.Collections.Generic.IEnumerable<global::System.String> EnumerateDirectories(global::System.String path)
		{
			return global::System.IO.Directory.EnumerateDirectories(path);
		}

		public override global::System.Collections.Generic.IEnumerable<global::System.String> EnumerateFiles(global::System.String path)
		{
			return global::System.IO.Directory.EnumerateFiles(path);
		}

		public override global::System.String[] GetDirectories(global::System.String path)
		{
			return global::System.IO.Directory.GetDirectories(path);
		}

		public override global::System.String[] GetFiles(global::System.String path)
		{
			return global::System.IO.Directory.GetFiles(path);
		}

		public override global::System.Boolean Exists(global::System.String path)
		{
			return global::System.IO.Directory.Exists(path);
		}

	}

	public override LocalPathImplementation Path { get; }

	public sealed partial class LocalPathImplementation(LocalFileSystem fileSystem) : PathImplementation(fileSystem)
	{
		public override global::System.String GetFullPath(global::System.String path)
		{
			return global::System.IO.Path.GetFullPath(path);
		}

		public override global::System.Boolean IsPathRooted(global::System.ReadOnlySpan<global::System.Char> path)
		{
			return global::System.IO.Path.IsPathRooted(path);
		}

	}

	public LocalFileSystem()
	{
		File = new(this);
		Directory = new(this);
		Path = new(this);
	}
}

```

`Source/AssetRipper.IO.Files/ResourceFiles/ResourceFile.cs`:

```cs
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.ResourceFiles;

public sealed class ResourceFile : FileBase
{
	public ResourceFile(SmartStream stream, string filePath, string name)
	{
		Stream = stream.CreateReference();
		FilePath = filePath;
		Name = name;
	}

	public ResourceFile(byte[] data, string filePath, string name, bool writable = true)
	{
		Stream = SmartStream.CreateMemory(data, 0, data.Length, writable);
		FilePath = filePath;
		Name = name;
	}

	public ResourceFile(string filePath, string name, FileSystem fileSystem)
	{
		Stream = SmartStream.OpenReadMulti(filePath, fileSystem);
		FilePath = filePath;
		Name = name;
	}

	public bool IsDefaultResourceFile() => IsDefaultResourceFile(Name);

	public static bool IsDefaultResourceFile(string fileName)
	{
		string extension = Path.GetExtension(fileName).ToLowerInvariant();
		return extension is ResourceFileExtension or StreamingFileExtension;
	}

	public override string ToString() => Name;

	protected override void Dispose(bool disposing)
	{
		base.Dispose(disposing);
		Stream.Dispose();
	}

	public override void Read(SmartStream stream)
	{
		throw new NotSupportedException();
	}

	public override void Write(Stream stream)
	{
		Stream.CopyTo(stream);
	}

	public override byte[] ToByteArray()
	{
		return Stream.ToArray();
	}

	public SmartStream Stream { get; }

	public const string ResourceFileExtension = ".resource";
	public const string StreamingFileExtension = ".ress";
}

```

`Source/AssetRipper.IO.Files/Scheme.cs`:

```cs
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files;

public abstract class Scheme<T> : IScheme where T : FileBase, new()
{
	public abstract bool CanRead(SmartStream stream);

	public T Read(SmartStream stream, string filePath, string fileName)
	{
		T file = new();
		file.FilePath = filePath;
		file.Name = fileName;
		file.Read(stream);
		return file;
	}

	FileBase IScheme.Read(SmartStream stream, string filePath, string fileName) => Read(stream, filePath, fileName);
}

```

`Source/AssetRipper.IO.Files/SchemeReader.cs`:

```cs
using AssetRipper.IO.Files.BundleFiles.Archive;
using AssetRipper.IO.Files.BundleFiles.FileStream;
using AssetRipper.IO.Files.BundleFiles.RawWeb.Raw;
using AssetRipper.IO.Files.BundleFiles.RawWeb.Web;
using AssetRipper.IO.Files.CompressedFiles.Brotli;
using AssetRipper.IO.Files.CompressedFiles.GZip;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.Streams;
using AssetRipper.IO.Files.Streams.Smart;
using AssetRipper.IO.Files.WebFiles;

namespace AssetRipper.IO.Files;

public static class SchemeReader
{
	private static readonly Stack<IScheme> schemes = new()
	{
		SerializedFileScheme.Default,
		new GZipFileScheme(),
		new BrotliFileScheme(),
		new WebFileScheme(),
		new ArchiveBundleScheme(),
		new WebBundleScheme(),
		new RawBundleScheme(),
		new FileStreamBundleScheme(),
	};

	public static FileBase LoadFile(string filePath, FileSystem fileSystem)
	{
		SmartStream stream = SmartStream.OpenReadMulti(filePath, fileSystem);
		return ReadFile(stream, MultiFileStream.GetFilePath(filePath), MultiFileStream.GetFileName(filePath));
	}

	public static FileBase ReadFile(byte[] buffer, string filePath, string fileName)
	{
		SmartStream smartStream = SmartStream.CreateMemory(buffer, 0, buffer.Length, false);
		return ReadFile(smartStream, filePath, fileName);
	}

	public static FileBase ReadFile(SmartStream stream, string filePath, string fileName)
	{
		foreach (IScheme scheme in schemes)
		{
			if (scheme.CanRead(stream))
			{
				return scheme.Read(stream, filePath, fileName);
			}
		}

		return new ResourceFile(stream, filePath, fileName);
	}

	public static FileBase ReadFile(ResourceFile file)
	{
		return ReadFile(file.Stream.CreateReference(), file.FilePath, file.Name);
	}

	public static bool IsReadableFile(string filePath, FileSystem fileSystem)
	{
		using SmartStream stream = SmartStream.OpenReadMulti(filePath, fileSystem);
		foreach (IScheme scheme in schemes)
		{
			if (scheme.CanRead(stream))
			{
				return true;
			}
		}
		return false;
	}

	/// <summary>
	/// Required for the initialization of <see cref="schemes"/>
	/// </summary>
	private static void Add(this Stack<IScheme> stack, IScheme scheme) => stack.Push(scheme);
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/FileIdentifiers/EndianExtensions.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.SerializedFiles.FileIdentifiers;

internal static class EndianExtensions
{
	public static UnityGuid ReadUnityGuid(this EndianReader reader)
	{
		return new UnityGuid(reader.ReadUInt32(), reader.ReadUInt32(), reader.ReadUInt32(), reader.ReadUInt32());
	}

	public static void Write(this EndianWriter writer, UnityGuid guid)
	{
		writer.Write(guid.Data0);
		writer.Write(guid.Data1);
		writer.Write(guid.Data2);
		writer.Write(guid.Data3);
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/FileIdentifiers/FileIdentifier_1.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles.FileIdentifiers;

public partial record class FileIdentifier_1
{
	public string PathNameFixed { get; private set; } = "";

	partial void OnPathNameAssignment(string value)
	{
		PathNameFixed = SpecialFileNames.FixFileIdentifier(value);
	}

	public string GetFilePath()
	{
		if (Type == AssetType.Meta)
		{
			return Guid.ToString();
		}
		return PathNameFixed;
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/FileIdentifiers/FileIdentifier_1.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
using AssetRipper.Primitives;
namespace AssetRipper.IO.Files.SerializedFiles.FileIdentifiers;
/// <summary>
/// A serialized file may be linked with other serialized files to create shared dependencies.
/// </summary>
public partial record class FileIdentifier_1 : IFileIdentifier
{
	/// <summary>
	/// Actual file path. This path is relative to the path of the current file.
	/// </summary>
	/// <remarks>
	/// The folder "library" often needs to be translated to "resources" in order to find the file on the file system.
	/// </remarks>
	private string m_PathName = string.Empty;
	
	/// <summary>
	/// Actual file path. This path is relative to the path of the current file.
	/// </summary>
	/// <remarks>
	/// The folder "library" often needs to be translated to "resources" in order to find the file on the file system.
	/// </remarks>
	public string PathName
	{
		get => m_PathName;
		set
		{
			m_PathName = value;
			OnPathNameAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="PathName"/> is set.
	/// </summary>
	partial void OnPathNameAssignment(string value);
	
	/// <summary>
	/// Actually UnityGuid
	/// </summary>
	public UnityGuid Guid
	{
		get => default;
		set { }
	}
	
	/// <summary>
	/// The type of the file
	/// </summary>
	public AssetType Type
	{
		get => default;
		set { }
	}
	
	/// <summary>
	/// Virtual asset path. Used for cached files, otherwise it's empty.
	/// </summary>
	/// <remarks>
	/// The file with that path usually doesn't exist, so it's probably an alias.
	/// </remarks>
	public string AssetPath
	{
		get => default;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		m_PathName = reader.ReadStringZeroTerm();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.WriteStringZeroTerm(m_PathName);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/FileIdentifiers/FileIdentifier_5.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles.FileIdentifiers;

public partial record class FileIdentifier_5
{
	public string PathNameFixed { get; private set; } = "";

	partial void OnPathNameAssignment(string value)
	{
		PathNameFixed = SpecialFileNames.FixFileIdentifier(value);
	}

	public string GetFilePath()
	{
		if (Type == AssetType.Meta)
		{
			return Guid.ToString();
		}
		return PathNameFixed;
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/FileIdentifiers/FileIdentifier_5.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
using AssetRipper.Primitives;
namespace AssetRipper.IO.Files.SerializedFiles.FileIdentifiers;
/// <summary>
/// A serialized file may be linked with other serialized files to create shared dependencies.
/// </summary>
public partial record class FileIdentifier_5 : IFileIdentifier
{
	/// <summary>
	/// Actually UnityGuid
	/// </summary>
	private UnityGuid m_Guid = new();
	
	/// <summary>
	/// Actually UnityGuid
	/// </summary>
	public UnityGuid Guid
	{
		get => m_Guid;
		set
		{
			m_Guid = value;
			OnGuidAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Guid"/> is set.
	/// </summary>
	partial void OnGuidAssignment(UnityGuid value);
	
	/// <summary>
	/// The type of the file
	/// </summary>
	private int m_Type = new();
	
	/// <summary>
	/// The type of the file
	/// </summary>
	public AssetType Type
	{
		get => (AssetType)m_Type;
		set
		{
			m_Type = (int)value;
			OnTypeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Type"/> is set.
	/// </summary>
	partial void OnTypeAssignment(AssetType value);
	
	/// <summary>
	/// Actual file path. This path is relative to the path of the current file.
	/// </summary>
	/// <remarks>
	/// The folder "library" often needs to be translated to "resources" in order to find the file on the file system.
	/// </remarks>
	private string m_PathName = string.Empty;
	
	/// <summary>
	/// Actual file path. This path is relative to the path of the current file.
	/// </summary>
	/// <remarks>
	/// The folder "library" often needs to be translated to "resources" in order to find the file on the file system.
	/// </remarks>
	public string PathName
	{
		get => m_PathName;
		set
		{
			m_PathName = value;
			OnPathNameAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="PathName"/> is set.
	/// </summary>
	partial void OnPathNameAssignment(string value);
	
	/// <summary>
	/// Virtual asset path. Used for cached files, otherwise it's empty.
	/// </summary>
	/// <remarks>
	/// The file with that path usually doesn't exist, so it's probably an alias.
	/// </remarks>
	public string AssetPath
	{
		get => default;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		m_Guid = reader.ReadUnityGuid();
		m_Type = reader.ReadInt32();
		m_PathName = reader.ReadStringZeroTerm();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.Write(m_Guid);
		writer.Write(m_Type);
		writer.WriteStringZeroTerm(m_PathName);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/FileIdentifiers/FileIdentifier_6.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles.FileIdentifiers;

public partial record class FileIdentifier_6
{
	public string PathNameFixed { get; private set; } = "";

	partial void OnPathNameAssignment(string value)
	{
		PathNameFixed = SpecialFileNames.FixFileIdentifier(value);
	}

	public string GetFilePath()
	{
		if (Type == AssetType.Meta)
		{
			return Guid.ToString();
		}
		return PathNameFixed;
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/FileIdentifiers/FileIdentifier_6.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
using AssetRipper.Primitives;
namespace AssetRipper.IO.Files.SerializedFiles.FileIdentifiers;
/// <summary>
/// A serialized file may be linked with other serialized files to create shared dependencies.
/// </summary>
public partial record class FileIdentifier_6 : IFileIdentifier
{
	/// <summary>
	/// Virtual asset path. Used for cached files, otherwise it's empty.
	/// </summary>
	/// <remarks>
	/// The file with that path usually doesn't exist, so it's probably an alias.
	/// </remarks>
	private string m_AssetPath = string.Empty;
	
	/// <summary>
	/// Virtual asset path. Used for cached files, otherwise it's empty.
	/// </summary>
	/// <remarks>
	/// The file with that path usually doesn't exist, so it's probably an alias.
	/// </remarks>
	public string AssetPath
	{
		get => m_AssetPath;
		set
		{
			m_AssetPath = value;
			OnAssetPathAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="AssetPath"/> is set.
	/// </summary>
	partial void OnAssetPathAssignment(string value);
	
	/// <summary>
	/// Actually UnityGuid
	/// </summary>
	private UnityGuid m_Guid = new();
	
	/// <summary>
	/// Actually UnityGuid
	/// </summary>
	public UnityGuid Guid
	{
		get => m_Guid;
		set
		{
			m_Guid = value;
			OnGuidAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Guid"/> is set.
	/// </summary>
	partial void OnGuidAssignment(UnityGuid value);
	
	/// <summary>
	/// The type of the file
	/// </summary>
	private int m_Type = new();
	
	/// <summary>
	/// The type of the file
	/// </summary>
	public AssetType Type
	{
		get => (AssetType)m_Type;
		set
		{
			m_Type = (int)value;
			OnTypeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Type"/> is set.
	/// </summary>
	partial void OnTypeAssignment(AssetType value);
	
	/// <summary>
	/// Actual file path. This path is relative to the path of the current file.
	/// </summary>
	/// <remarks>
	/// The folder "library" often needs to be translated to "resources" in order to find the file on the file system.
	/// </remarks>
	private string m_PathName = string.Empty;
	
	/// <summary>
	/// Actual file path. This path is relative to the path of the current file.
	/// </summary>
	/// <remarks>
	/// The folder "library" often needs to be translated to "resources" in order to find the file on the file system.
	/// </remarks>
	public string PathName
	{
		get => m_PathName;
		set
		{
			m_PathName = value;
			OnPathNameAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="PathName"/> is set.
	/// </summary>
	partial void OnPathNameAssignment(string value);
	
	public void Read(EndianReader reader)
	{
		m_AssetPath = reader.ReadStringZeroTerm();
		m_Guid = reader.ReadUnityGuid();
		m_Type = reader.ReadInt32();
		m_PathName = reader.ReadStringZeroTerm();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.WriteStringZeroTerm(m_AssetPath);
		writer.Write(m_Guid);
		writer.Write(m_Type);
		writer.WriteStringZeroTerm(m_PathName);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/FileIdentifiers/IFileIdentifier.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles.FileIdentifiers;

public partial interface IFileIdentifier
{
	/// <summary>
	/// <see cref="PathName"/> without prefixes such as archive:/directory/fileName
	/// </summary>
	string PathNameFixed { get; }

	string GetFilePath();
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/FileIdentifiers/IFileIdentifier.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
using AssetRipper.Primitives;
namespace AssetRipper.IO.Files.SerializedFiles.FileIdentifiers;
/// <summary>
/// A serialized file may be linked with other serialized files to create shared dependencies.
/// </summary>
public partial interface IFileIdentifier : IEndianWritable
{
	/// <summary>
	/// Actual file path. This path is relative to the path of the current file.
	/// </summary>
	/// <remarks>
	/// The folder "library" often needs to be translated to "resources" in order to find the file on the file system.
	/// </remarks>
	public string PathName { get; set; }
	
	/// <summary>
	/// Actually UnityGuid
	/// </summary>
	public UnityGuid Guid { get; set; }
	
	/// <summary>
	/// The type of the file
	/// </summary>
	public AssetType Type { get; set; }
	
	/// <summary>
	/// Virtual asset path. Used for cached files, otherwise it's empty.
	/// </summary>
	/// <remarks>
	/// The file with that path usually doesn't exist, so it's probably an alias.
	/// </remarks>
	public string AssetPath { get; set; }
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/FormatVersion.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles;

/// <summary>
/// SerializedFileFormatVersion in the pdb
/// </summary>
public enum FormatVersion
{
	Unsupported = 1,
	Unknown_2 = 2,
	Unknown_3 = 3,
	/// <summary>
	/// 1.2.0 to 2.0.0
	/// </summary>
	Unknown_5 = 5,
	/// <summary>
	/// 2.1.0 to 2.6.1
	/// </summary>
	Unknown_6 = 6,
	/// <summary>
	/// 3.0.0b
	/// </summary>
	Unknown_7 = 7,
	/// <summary>
	/// 3.0.0 to 3.4.2
	/// </summary>
	Unknown_8 = 8,
	/// <summary>
	/// 3.5.0 to 4.7.2
	/// </summary>
	Unknown_9 = 9,
	/// <summary>
	/// 5.0.0aunk1
	/// </summary>
	Unknown_10 = 10,
	/// <summary>
	/// 5.0.0aunk2
	/// </summary>
	HasScriptTypeIndex = 11,
	/// <summary>
	/// 5.0.0aunk3
	/// </summary>
	Unknown_12 = 12,
	/// <summary>
	/// 5.0.0aunk4
	/// </summary>
	HasTypeTreeHashes = 13,
	/// <summary>
	/// 5.0.0unk
	/// </summary>
	Unknown_14 = 14,
	/// <summary>
	/// 5.0.1 to 5.4.0
	/// </summary>
	SupportsStrippedObject = 15,
	/// <summary>
	/// 5.5.0a
	/// </summary>
	RefactoredClassId = 16,
	/// <summary>
	/// 5.5.0unk to 2018.4
	/// </summary>
	RefactorTypeData = 17,
	/// <summary>
	/// 2019.1a
	/// </summary>
	RefactorShareableTypeTreeData = 18,
	/// <summary>
	/// 2019.1unk
	/// </summary>
	TypeTreeNodeWithTypeFlags = 19,
	/// <summary>
	/// 2019.2
	/// </summary>
	SupportsRefObject = 20,
	/// <summary>
	/// 2019.3 to 2019.4
	/// </summary>
	StoresTypeDependencies = 21,
	/// <summary>
	/// 2020.1 to x
	/// </summary>
	LargeFilesSupport = 22,
}
internal static class FormatVersionExtensions
{
	private static UnityVersion ToDefaultUnityVersion(this FormatVersion generation)
	{
		return generation switch
		{
			< FormatVersion.Unknown_5 => new UnityVersion(1, 2, 2),
			FormatVersion.Unknown_5 => new UnityVersion(1, 6),
			FormatVersion.Unknown_6 => new UnityVersion(2, 5),
			FormatVersion.Unknown_7 => new UnityVersion(3, 0, 0, UnityVersionType.Beta, 1),
			_ => throw new ArgumentOutOfRangeException(nameof(generation)),
		};
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Header/ISerializedFileHeader.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.Header;
/// <summary>
/// The file header is found at the beginning of an asset file. The header is always using big endian byte order.
/// </summary>
public partial interface ISerializedFileHeader : IEndianWritable
{
	/// <summary>
	/// Size of the metadata section in the file
	/// </summary>
	public long MetadataSize { get; set; }
	
	/// <summary>
	/// Size of the whole file
	/// </summary>
	public long FileSize { get; set; }
	
	/// <summary>
	/// File format version. The number is required for backward compatibility and is normally incremented after the file format has been changed in a major update.
	/// </summary>
	public FormatVersion Version { get; set; }
	
	/// <summary>
	/// Offset to the serialized object data. It starts at the data for the first object.
	/// </summary>
	public long DataOffset { get; set; }
	
	/// <summary>
	/// This controls the byte order of the data structure. False is little endian. True is big endian.
	/// </summary>
	/// <remarks>
	/// This field is normally set to 0.
	/// </remarks>
	public bool SwapEndianess { get; set; }
	
	/// <summary>
	/// An unknown field introduced in version 22.
	/// </summary>
	public long Unknown22 { get; set; }
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Header/SerializedFileHeader_1.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.Header;
/// <summary>
/// The file header is found at the beginning of an asset file. The header is always using big endian byte order.
/// </summary>
public partial record class SerializedFileHeader_1 : ISerializedFileHeader
{
	/// <summary>
	/// Size of the metadata section in the file
	/// </summary>
	private int m_MetadataSize = new();
	
	/// <summary>
	/// Size of the metadata section in the file
	/// </summary>
	public long MetadataSize
	{
		get => m_MetadataSize;
		set
		{
			m_MetadataSize = (int)value;
			OnMetadataSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="MetadataSize"/> is set.
	/// </summary>
	partial void OnMetadataSizeAssignment(long value);
	
	/// <summary>
	/// Size of the whole file
	/// </summary>
	private uint m_FileSize = new();
	
	/// <summary>
	/// Size of the whole file
	/// </summary>
	public long FileSize
	{
		get => m_FileSize;
		set
		{
			m_FileSize = (uint)value;
			OnFileSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="FileSize"/> is set.
	/// </summary>
	partial void OnFileSizeAssignment(long value);
	
	/// <summary>
	/// File format version. The number is required for backward compatibility and is normally incremented after the file format has been changed in a major update.
	/// </summary>
	private int m_Version = new();
	
	/// <summary>
	/// File format version. The number is required for backward compatibility and is normally incremented after the file format has been changed in a major update.
	/// </summary>
	public FormatVersion Version
	{
		get => (FormatVersion)m_Version;
		set
		{
			m_Version = (int)value;
			OnVersionAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Version"/> is set.
	/// </summary>
	partial void OnVersionAssignment(FormatVersion value);
	
	/// <summary>
	/// Offset to the serialized object data. It starts at the data for the first object.
	/// </summary>
	private uint m_DataOffset = new();
	
	/// <summary>
	/// Offset to the serialized object data. It starts at the data for the first object.
	/// </summary>
	public long DataOffset
	{
		get => m_DataOffset;
		set
		{
			m_DataOffset = (uint)value;
			OnDataOffsetAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="DataOffset"/> is set.
	/// </summary>
	partial void OnDataOffsetAssignment(long value);
	
	/// <summary>
	/// This controls the byte order of the data structure. False is little endian. True is big endian.
	/// </summary>
	/// <remarks>
	/// This field is normally set to 0.
	/// </remarks>
	public bool SwapEndianess
	{
		get => default;
		set { }
	}
	
	/// <summary>
	/// An unknown field introduced in version 22.
	/// </summary>
	public long Unknown22
	{
		get => default;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		m_MetadataSize = reader.ReadInt32();
		m_FileSize = reader.ReadUInt32();
		m_Version = reader.ReadInt32();
		m_DataOffset = reader.ReadUInt32();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.Write(m_MetadataSize);
		writer.Write(m_FileSize);
		writer.Write(m_Version);
		writer.Write(m_DataOffset);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Header/SerializedFileHeader_22.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.Header;
/// <summary>
/// The file header is found at the beginning of an asset file. The header is always using big endian byte order.
/// </summary>
public partial record class SerializedFileHeader_22 : ISerializedFileHeader
{
	/// <summary>
	/// File format version. The number is required for backward compatibility and is normally incremented after the file format has been changed in a major update.
	/// </summary>
	private int m_Version = new();
	
	/// <summary>
	/// File format version. The number is required for backward compatibility and is normally incremented after the file format has been changed in a major update.
	/// </summary>
	public FormatVersion Version
	{
		get => (FormatVersion)m_Version;
		set
		{
			m_Version = (int)value;
			OnVersionAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Version"/> is set.
	/// </summary>
	partial void OnVersionAssignment(FormatVersion value);
	
	/// <summary>
	/// This controls the byte order of the data structure. False is little endian. True is big endian.
	/// </summary>
	/// <remarks>
	/// This field is normally set to 0.
	/// </remarks>
	private bool m_SwapEndianess = new();
	
	/// <summary>
	/// This controls the byte order of the data structure. False is little endian. True is big endian.
	/// </summary>
	/// <remarks>
	/// This field is normally set to 0.
	/// </remarks>
	public bool SwapEndianess
	{
		get => m_SwapEndianess;
		set
		{
			m_SwapEndianess = value;
			OnSwapEndianessAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="SwapEndianess"/> is set.
	/// </summary>
	partial void OnSwapEndianessAssignment(bool value);
	
	/// <summary>
	/// Size of the metadata section in the file
	/// </summary>
	private uint m_MetadataSize = new();
	
	/// <summary>
	/// Size of the metadata section in the file
	/// </summary>
	public long MetadataSize
	{
		get => m_MetadataSize;
		set
		{
			m_MetadataSize = (uint)value;
			OnMetadataSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="MetadataSize"/> is set.
	/// </summary>
	partial void OnMetadataSizeAssignment(long value);
	
	/// <summary>
	/// Size of the whole file
	/// </summary>
	private long m_FileSize = new();
	
	/// <summary>
	/// Size of the whole file
	/// </summary>
	public long FileSize
	{
		get => m_FileSize;
		set
		{
			m_FileSize = value;
			OnFileSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="FileSize"/> is set.
	/// </summary>
	partial void OnFileSizeAssignment(long value);
	
	/// <summary>
	/// Offset to the serialized object data. It starts at the data for the first object.
	/// </summary>
	private long m_DataOffset = new();
	
	/// <summary>
	/// Offset to the serialized object data. It starts at the data for the first object.
	/// </summary>
	public long DataOffset
	{
		get => m_DataOffset;
		set
		{
			m_DataOffset = value;
			OnDataOffsetAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="DataOffset"/> is set.
	/// </summary>
	partial void OnDataOffsetAssignment(long value);
	
	/// <summary>
	/// An unknown field introduced in version 22.
	/// </summary>
	private long m_Unknown22 = new();
	
	/// <summary>
	/// An unknown field introduced in version 22.
	/// </summary>
	public long Unknown22
	{
		get => m_Unknown22;
		set
		{
			m_Unknown22 = value;
			OnUnknown22Assignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Unknown22"/> is set.
	/// </summary>
	partial void OnUnknown22Assignment(long value);
	
	public void Read(EndianReader reader)
	{
		reader.ReadUInt32();
		reader.ReadUInt32();
		m_Version = reader.ReadInt32();
		reader.ReadUInt32();
		m_SwapEndianess = reader.ReadBoolean();
		reader.AlignStream();
		m_MetadataSize = reader.ReadUInt32();
		m_FileSize = reader.ReadInt64();
		m_DataOffset = reader.ReadInt64();
		m_Unknown22 = reader.ReadInt64();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.Write(default(uint));
		writer.Write(default(uint));
		writer.Write(m_Version);
		writer.Write(default(uint));
		writer.Write(m_SwapEndianess);
		writer.AlignStream();
		writer.Write(m_MetadataSize);
		writer.Write(m_FileSize);
		writer.Write(m_DataOffset);
		writer.Write(m_Unknown22);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Header/SerializedFileHeader_9.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.Header;
/// <summary>
/// The file header is found at the beginning of an asset file. The header is always using big endian byte order.
/// </summary>
public partial record class SerializedFileHeader_9 : ISerializedFileHeader
{
	/// <summary>
	/// Size of the metadata section in the file
	/// </summary>
	private int m_MetadataSize = new();
	
	/// <summary>
	/// Size of the metadata section in the file
	/// </summary>
	public long MetadataSize
	{
		get => m_MetadataSize;
		set
		{
			m_MetadataSize = (int)value;
			OnMetadataSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="MetadataSize"/> is set.
	/// </summary>
	partial void OnMetadataSizeAssignment(long value);
	
	/// <summary>
	/// Size of the whole file
	/// </summary>
	private uint m_FileSize = new();
	
	/// <summary>
	/// Size of the whole file
	/// </summary>
	public long FileSize
	{
		get => m_FileSize;
		set
		{
			m_FileSize = (uint)value;
			OnFileSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="FileSize"/> is set.
	/// </summary>
	partial void OnFileSizeAssignment(long value);
	
	/// <summary>
	/// File format version. The number is required for backward compatibility and is normally incremented after the file format has been changed in a major update.
	/// </summary>
	private int m_Version = new();
	
	/// <summary>
	/// File format version. The number is required for backward compatibility and is normally incremented after the file format has been changed in a major update.
	/// </summary>
	public FormatVersion Version
	{
		get => (FormatVersion)m_Version;
		set
		{
			m_Version = (int)value;
			OnVersionAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Version"/> is set.
	/// </summary>
	partial void OnVersionAssignment(FormatVersion value);
	
	/// <summary>
	/// Offset to the serialized object data. It starts at the data for the first object.
	/// </summary>
	private uint m_DataOffset = new();
	
	/// <summary>
	/// Offset to the serialized object data. It starts at the data for the first object.
	/// </summary>
	public long DataOffset
	{
		get => m_DataOffset;
		set
		{
			m_DataOffset = (uint)value;
			OnDataOffsetAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="DataOffset"/> is set.
	/// </summary>
	partial void OnDataOffsetAssignment(long value);
	
	/// <summary>
	/// This controls the byte order of the data structure. False is little endian. True is big endian.
	/// </summary>
	/// <remarks>
	/// This field is normally set to 0.
	/// </remarks>
	private bool m_SwapEndianess = new();
	
	/// <summary>
	/// This controls the byte order of the data structure. False is little endian. True is big endian.
	/// </summary>
	/// <remarks>
	/// This field is normally set to 0.
	/// </remarks>
	public bool SwapEndianess
	{
		get => m_SwapEndianess;
		set
		{
			m_SwapEndianess = value;
			OnSwapEndianessAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="SwapEndianess"/> is set.
	/// </summary>
	partial void OnSwapEndianessAssignment(bool value);
	
	/// <summary>
	/// An unknown field introduced in version 22.
	/// </summary>
	public long Unknown22
	{
		get => default;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		m_MetadataSize = reader.ReadInt32();
		m_FileSize = reader.ReadUInt32();
		m_Version = reader.ReadInt32();
		m_DataOffset = reader.ReadUInt32();
		m_SwapEndianess = reader.ReadBoolean();
		reader.AlignStream();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.Write(m_MetadataSize);
		writer.Write(m_FileSize);
		writer.Write(m_Version);
		writer.Write(m_DataOffset);
		writer.Write(m_SwapEndianess);
		writer.AlignStream();
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/IO/ISerializedReadable.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles.IO;

public interface ISerializedReadable
{
	void Read(SerializedReader reader);
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/IO/ISerializedWritable.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles.IO;

public interface ISerializedWritable
{
	void Write(SerializedWriter writer);
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/IO/SerializedReader.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.IO.Files.SerializedFiles.IO;

public sealed class SerializedReader : EndianReader
{
	public SerializedReader(Stream stream, EndianType endianess, FormatVersion generation) : base(stream, endianess)
	{
		Generation = generation;
	}

	public T ReadSerialized<T>() where T : ISerializedReadable, new()
	{
		T t = new();
		t.Read(this);
		return t;
	}

	public T[] ReadSerializedArray<T>() where T : ISerializedReadable, new()
	{
		int count = ReadInt32();
		T[] array = new T[count];
		for (int i = 0; i < count; i++)
		{
			T instance = new();
			instance.Read(this);
			array[i] = instance;
		}
		return array;
	}

	public T[] ReadSerializedTypeArray<T>(bool hasTypeTree) where T : SerializedTypeBase, new()
	{
		int count = ReadInt32();
		T[] array = new T[count];
		for (int i = 0; i < count; i++)
		{
			T instance = new();
			instance.Read(this, hasTypeTree);
			array[i] = instance;
		}
		return array;
	}

	public FormatVersion Generation { get; }

	/// <summary>
	/// Gets set after reading the metadata version
	/// </summary>
	public UnityVersion Version { get; set; }
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/IO/SerializedWriter.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.IO.Files.SerializedFiles.IO;

public sealed class SerializedWriter : EndianWriter
{
	public SerializedWriter(Stream stream, EndianType endianess, FormatVersion generation, UnityVersion version) : base(stream, endianess)
	{
		Generation = generation;
		Version = version;
	}

	public void WriteSerialized<T>(T value) where T : ISerializedWritable
	{
		value.Write(this);
	}

	public void WriteSerializedArray<T>(T[] buffer) where T : ISerializedWritable
	{
		FillInnerBuffer(buffer.Length);
		Write(m_buffer, 0, sizeof(int));

		for (int i = 0; i < buffer.Length; i++)
		{
			buffer[i].Write(this);
		}
	}

	public void WriteSerializedTypeArray<T>(T[] buffer, bool hasTypeTree) where T : SerializedTypeBase
	{
		FillInnerBuffer(buffer.Length);
		Write(m_buffer, 0, sizeof(int));

		for (int i = 0; i < buffer.Length; i++)
		{
			buffer[i].Write(this, hasTypeTree);
		}
	}

	public FormatVersion Generation { get; }

	public UnityVersion Version { get; }
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/LocalSerializedObjectIdentifiers/ILocalSerializedObjectIdentifier.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.LocalSerializedObjectIdentifiers;
public partial interface ILocalSerializedObjectIdentifier : IEndianWritable
{
	public int LocalSerializedFileIndex { get; set; }
	
	public long LocalIdentifierInFile { get; set; }
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/LocalSerializedObjectIdentifiers/LocalSerializedObjectIdentifier_1.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.LocalSerializedObjectIdentifiers;
public partial record class LocalSerializedObjectIdentifier_1 : ILocalSerializedObjectIdentifier
{
	private int m_LocalSerializedFileIndex = new();
	
	public int LocalSerializedFileIndex
	{
		get => m_LocalSerializedFileIndex;
		set
		{
			m_LocalSerializedFileIndex = value;
			OnLocalSerializedFileIndexAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="LocalSerializedFileIndex"/> is set.
	/// </summary>
	partial void OnLocalSerializedFileIndexAssignment(int value);
	
	private int m_LocalIdentifierInFile = new();
	
	public long LocalIdentifierInFile
	{
		get => m_LocalIdentifierInFile;
		set
		{
			m_LocalIdentifierInFile = (int)value;
			OnLocalIdentifierInFileAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="LocalIdentifierInFile"/> is set.
	/// </summary>
	partial void OnLocalIdentifierInFileAssignment(long value);
	
	public void Read(EndianReader reader)
	{
		m_LocalSerializedFileIndex = reader.ReadInt32();
		m_LocalIdentifierInFile = reader.ReadInt32();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.Write(m_LocalSerializedFileIndex);
		writer.Write(m_LocalIdentifierInFile);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/LocalSerializedObjectIdentifiers/LocalSerializedObjectIdentifier_14.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.LocalSerializedObjectIdentifiers;
public partial record class LocalSerializedObjectIdentifier_14 : ILocalSerializedObjectIdentifier
{
	private int m_LocalSerializedFileIndex = new();
	
	public int LocalSerializedFileIndex
	{
		get => m_LocalSerializedFileIndex;
		set
		{
			m_LocalSerializedFileIndex = value;
			OnLocalSerializedFileIndexAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="LocalSerializedFileIndex"/> is set.
	/// </summary>
	partial void OnLocalSerializedFileIndexAssignment(int value);
	
	private long m_LocalIdentifierInFile = new();
	
	public long LocalIdentifierInFile
	{
		get => m_LocalIdentifierInFile;
		set
		{
			m_LocalIdentifierInFile = value;
			OnLocalIdentifierInFileAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="LocalIdentifierInFile"/> is set.
	/// </summary>
	partial void OnLocalIdentifierInFileAssignment(long value);
	
	public void Read(EndianReader reader)
	{
		m_LocalSerializedFileIndex = reader.ReadInt32();
		reader.AlignStream();
		m_LocalIdentifierInFile = reader.ReadInt64();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.Write(m_LocalSerializedFileIndex);
		writer.AlignStream();
		writer.Write(m_LocalIdentifierInFile);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/ObjectInformation/IObjectInfo.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.ObjectInformation;
/// <summary>
/// Contains information for a block of raw serialized object data.
/// </summary>
public partial interface IObjectInfo : IEndianWritable
{
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	public long FileID { get; set; }
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	public long ByteStart { get; set; }
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	public int ByteSize { get; set; }
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	public int TypeID { get; set; }
	
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	public short ClassID { get; set; }
	
	public ushort IsDestroyed { get; set; }
	
	public short ScriptTypeIndex { get; set; }
	
	public bool Stripped { get; set; }
	
	/// <summary>
	/// Type index in <see cref="SerializedFileMetadata.Types"/> array.
	/// </summary>
	public int SerializedTypeIndex { get; set; }
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/ObjectInformation/ObjectInfo_1.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.ObjectInformation;
/// <summary>
/// Contains information for a block of raw serialized object data.
/// </summary>
public partial record class ObjectInfo_1 : IObjectInfo
{
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	private int m_FileID = new();
	
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	public long FileID
	{
		get => m_FileID;
		set
		{
			m_FileID = (int)value;
			OnFileIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="FileID"/> is set.
	/// </summary>
	partial void OnFileIDAssignment(long value);
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	private int m_ByteStart = new();
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	public long ByteStart
	{
		get => m_ByteStart;
		set
		{
			m_ByteStart = (int)value;
			OnByteStartAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteStart"/> is set.
	/// </summary>
	partial void OnByteStartAssignment(long value);
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	private int m_ByteSize = new();
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	public int ByteSize
	{
		get => m_ByteSize;
		set
		{
			m_ByteSize = value;
			OnByteSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteSize"/> is set.
	/// </summary>
	partial void OnByteSizeAssignment(int value);
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	private int m_TypeID = new();
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	public int TypeID
	{
		get => m_TypeID;
		set
		{
			m_TypeID = value;
			OnTypeIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="TypeID"/> is set.
	/// </summary>
	partial void OnTypeIDAssignment(int value);
	
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	private short m_ClassID = new();
	
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	public short ClassID
	{
		get => m_ClassID;
		set
		{
			m_ClassID = value;
			OnClassIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ClassID"/> is set.
	/// </summary>
	partial void OnClassIDAssignment(short value);
	
	private ushort m_IsDestroyed = new();
	
	public ushort IsDestroyed
	{
		get => m_IsDestroyed;
		set
		{
			m_IsDestroyed = value;
			OnIsDestroyedAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="IsDestroyed"/> is set.
	/// </summary>
	partial void OnIsDestroyedAssignment(ushort value);
	
	public short ScriptTypeIndex
	{
		get => default;
		set { }
	}
	
	public bool Stripped
	{
		get => false;
		set { }
	}
	
	/// <summary>
	/// Type index in <see cref="SerializedFileMetadata.Types"/> array.
	/// </summary>
	public int SerializedTypeIndex
	{
		get => -1;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		m_FileID = reader.ReadInt32();
		m_ByteStart = reader.ReadInt32();
		m_ByteSize = reader.ReadInt32();
		m_TypeID = reader.ReadInt32();
		m_ClassID = reader.ReadInt16();
		m_IsDestroyed = reader.ReadUInt16();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.Write(m_FileID);
		writer.Write(m_ByteStart);
		writer.Write(m_ByteSize);
		writer.Write(m_TypeID);
		writer.Write(m_ClassID);
		writer.Write(m_IsDestroyed);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/ObjectInformation/ObjectInfo_11.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.ObjectInformation;
/// <summary>
/// Contains information for a block of raw serialized object data.
/// </summary>
public partial record class ObjectInfo_11 : IObjectInfo
{
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	private int m_FileID = new();
	
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	public long FileID
	{
		get => m_FileID;
		set
		{
			m_FileID = (int)value;
			OnFileIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="FileID"/> is set.
	/// </summary>
	partial void OnFileIDAssignment(long value);
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	private int m_ByteStart = new();
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	public long ByteStart
	{
		get => m_ByteStart;
		set
		{
			m_ByteStart = (int)value;
			OnByteStartAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteStart"/> is set.
	/// </summary>
	partial void OnByteStartAssignment(long value);
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	private int m_ByteSize = new();
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	public int ByteSize
	{
		get => m_ByteSize;
		set
		{
			m_ByteSize = value;
			OnByteSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteSize"/> is set.
	/// </summary>
	partial void OnByteSizeAssignment(int value);
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	private int m_TypeID = new();
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	public int TypeID
	{
		get => m_TypeID;
		set
		{
			m_TypeID = value;
			OnTypeIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="TypeID"/> is set.
	/// </summary>
	partial void OnTypeIDAssignment(int value);
	
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	private short m_ClassID = new();
	
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	public short ClassID
	{
		get => m_ClassID;
		set
		{
			m_ClassID = value;
			OnClassIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ClassID"/> is set.
	/// </summary>
	partial void OnClassIDAssignment(short value);
	
	private short m_ScriptTypeIndex = new();
	
	public short ScriptTypeIndex
	{
		get => m_ScriptTypeIndex;
		set
		{
			m_ScriptTypeIndex = value;
			OnScriptTypeIndexAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ScriptTypeIndex"/> is set.
	/// </summary>
	partial void OnScriptTypeIndexAssignment(short value);
	
	public ushort IsDestroyed
	{
		get => default;
		set { }
	}
	
	public bool Stripped
	{
		get => false;
		set { }
	}
	
	/// <summary>
	/// Type index in <see cref="SerializedFileMetadata.Types"/> array.
	/// </summary>
	public int SerializedTypeIndex
	{
		get => -1;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		m_FileID = reader.ReadInt32();
		m_ByteStart = reader.ReadInt32();
		m_ByteSize = reader.ReadInt32();
		m_TypeID = reader.ReadInt32();
		m_ClassID = reader.ReadInt16();
		m_ScriptTypeIndex = reader.ReadInt16();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.Write(m_FileID);
		writer.Write(m_ByteStart);
		writer.Write(m_ByteSize);
		writer.Write(m_TypeID);
		writer.Write(m_ClassID);
		writer.Write(m_ScriptTypeIndex);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/ObjectInformation/ObjectInfo_14.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.ObjectInformation;
/// <summary>
/// Contains information for a block of raw serialized object data.
/// </summary>
public partial record class ObjectInfo_14 : IObjectInfo
{
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	private long m_FileID = new();
	
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	public long FileID
	{
		get => m_FileID;
		set
		{
			m_FileID = value;
			OnFileIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="FileID"/> is set.
	/// </summary>
	partial void OnFileIDAssignment(long value);
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	private int m_ByteStart = new();
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	public long ByteStart
	{
		get => m_ByteStart;
		set
		{
			m_ByteStart = (int)value;
			OnByteStartAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteStart"/> is set.
	/// </summary>
	partial void OnByteStartAssignment(long value);
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	private int m_ByteSize = new();
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	public int ByteSize
	{
		get => m_ByteSize;
		set
		{
			m_ByteSize = value;
			OnByteSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteSize"/> is set.
	/// </summary>
	partial void OnByteSizeAssignment(int value);
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	private int m_TypeID = new();
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	public int TypeID
	{
		get => m_TypeID;
		set
		{
			m_TypeID = value;
			OnTypeIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="TypeID"/> is set.
	/// </summary>
	partial void OnTypeIDAssignment(int value);
	
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	private short m_ClassID = new();
	
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	public short ClassID
	{
		get => m_ClassID;
		set
		{
			m_ClassID = value;
			OnClassIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ClassID"/> is set.
	/// </summary>
	partial void OnClassIDAssignment(short value);
	
	private short m_ScriptTypeIndex = new();
	
	public short ScriptTypeIndex
	{
		get => m_ScriptTypeIndex;
		set
		{
			m_ScriptTypeIndex = value;
			OnScriptTypeIndexAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ScriptTypeIndex"/> is set.
	/// </summary>
	partial void OnScriptTypeIndexAssignment(short value);
	
	public ushort IsDestroyed
	{
		get => default;
		set { }
	}
	
	public bool Stripped
	{
		get => false;
		set { }
	}
	
	/// <summary>
	/// Type index in <see cref="SerializedFileMetadata.Types"/> array.
	/// </summary>
	public int SerializedTypeIndex
	{
		get => -1;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		reader.AlignStream();
		m_FileID = reader.ReadInt64();
		m_ByteStart = reader.ReadInt32();
		m_ByteSize = reader.ReadInt32();
		m_TypeID = reader.ReadInt32();
		m_ClassID = reader.ReadInt16();
		m_ScriptTypeIndex = reader.ReadInt16();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.AlignStream();
		writer.Write(m_FileID);
		writer.Write(m_ByteStart);
		writer.Write(m_ByteSize);
		writer.Write(m_TypeID);
		writer.Write(m_ClassID);
		writer.Write(m_ScriptTypeIndex);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/ObjectInformation/ObjectInfo_15.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.ObjectInformation;
/// <summary>
/// Contains information for a block of raw serialized object data.
/// </summary>
public partial record class ObjectInfo_15 : IObjectInfo
{
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	private long m_FileID = new();
	
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	public long FileID
	{
		get => m_FileID;
		set
		{
			m_FileID = value;
			OnFileIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="FileID"/> is set.
	/// </summary>
	partial void OnFileIDAssignment(long value);
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	private int m_ByteStart = new();
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	public long ByteStart
	{
		get => m_ByteStart;
		set
		{
			m_ByteStart = (int)value;
			OnByteStartAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteStart"/> is set.
	/// </summary>
	partial void OnByteStartAssignment(long value);
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	private int m_ByteSize = new();
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	public int ByteSize
	{
		get => m_ByteSize;
		set
		{
			m_ByteSize = value;
			OnByteSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteSize"/> is set.
	/// </summary>
	partial void OnByteSizeAssignment(int value);
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	private int m_TypeID = new();
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	public int TypeID
	{
		get => m_TypeID;
		set
		{
			m_TypeID = value;
			OnTypeIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="TypeID"/> is set.
	/// </summary>
	partial void OnTypeIDAssignment(int value);
	
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	private short m_ClassID = new();
	
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	public short ClassID
	{
		get => m_ClassID;
		set
		{
			m_ClassID = value;
			OnClassIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ClassID"/> is set.
	/// </summary>
	partial void OnClassIDAssignment(short value);
	
	private short m_ScriptTypeIndex = new();
	
	public short ScriptTypeIndex
	{
		get => m_ScriptTypeIndex;
		set
		{
			m_ScriptTypeIndex = value;
			OnScriptTypeIndexAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ScriptTypeIndex"/> is set.
	/// </summary>
	partial void OnScriptTypeIndexAssignment(short value);
	
	private bool m_Stripped = new();
	
	public bool Stripped
	{
		get => m_Stripped;
		set
		{
			m_Stripped = value;
			OnStrippedAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Stripped"/> is set.
	/// </summary>
	partial void OnStrippedAssignment(bool value);
	
	public ushort IsDestroyed
	{
		get => default;
		set { }
	}
	
	/// <summary>
	/// Type index in <see cref="SerializedFileMetadata.Types"/> array.
	/// </summary>
	public int SerializedTypeIndex
	{
		get => -1;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		reader.AlignStream();
		m_FileID = reader.ReadInt64();
		m_ByteStart = reader.ReadInt32();
		m_ByteSize = reader.ReadInt32();
		m_TypeID = reader.ReadInt32();
		m_ClassID = reader.ReadInt16();
		m_ScriptTypeIndex = reader.ReadInt16();
		m_Stripped = reader.ReadBoolean();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.AlignStream();
		writer.Write(m_FileID);
		writer.Write(m_ByteStart);
		writer.Write(m_ByteSize);
		writer.Write(m_TypeID);
		writer.Write(m_ClassID);
		writer.Write(m_ScriptTypeIndex);
		writer.Write(m_Stripped);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/ObjectInformation/ObjectInfo_16.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.ObjectInformation;
/// <summary>
/// Contains information for a block of raw serialized object data.
/// </summary>
public partial record class ObjectInfo_16 : IObjectInfo
{
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	private long m_FileID = new();
	
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	public long FileID
	{
		get => m_FileID;
		set
		{
			m_FileID = value;
			OnFileIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="FileID"/> is set.
	/// </summary>
	partial void OnFileIDAssignment(long value);
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	private int m_ByteStart = new();
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	public long ByteStart
	{
		get => m_ByteStart;
		set
		{
			m_ByteStart = (int)value;
			OnByteStartAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteStart"/> is set.
	/// </summary>
	partial void OnByteStartAssignment(long value);
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	private int m_ByteSize = new();
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	public int ByteSize
	{
		get => m_ByteSize;
		set
		{
			m_ByteSize = value;
			OnByteSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteSize"/> is set.
	/// </summary>
	partial void OnByteSizeAssignment(int value);
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	private int m_TypeID = new();
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	public int TypeID
	{
		get => m_TypeID;
		set
		{
			m_TypeID = value;
			OnTypeIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="TypeID"/> is set.
	/// </summary>
	partial void OnTypeIDAssignment(int value);
	
	private short m_ScriptTypeIndex = new();
	
	public short ScriptTypeIndex
	{
		get => m_ScriptTypeIndex;
		set
		{
			m_ScriptTypeIndex = value;
			OnScriptTypeIndexAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ScriptTypeIndex"/> is set.
	/// </summary>
	partial void OnScriptTypeIndexAssignment(short value);
	
	private bool m_Stripped = new();
	
	public bool Stripped
	{
		get => m_Stripped;
		set
		{
			m_Stripped = value;
			OnStrippedAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Stripped"/> is set.
	/// </summary>
	partial void OnStrippedAssignment(bool value);
	
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	public short ClassID
	{
		get => (short)TypeID;
		set => TypeID = value;
	}
	
	public ushort IsDestroyed
	{
		get => default;
		set { }
	}
	
	/// <summary>
	/// Type index in <see cref="SerializedFileMetadata.Types"/> array.
	/// </summary>
	public int SerializedTypeIndex
	{
		get => -1;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		reader.AlignStream();
		m_FileID = reader.ReadInt64();
		m_ByteStart = reader.ReadInt32();
		m_ByteSize = reader.ReadInt32();
		m_TypeID = reader.ReadInt32();
		m_ScriptTypeIndex = reader.ReadInt16();
		m_Stripped = reader.ReadBoolean();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.AlignStream();
		writer.Write(m_FileID);
		writer.Write(m_ByteStart);
		writer.Write(m_ByteSize);
		writer.Write(m_TypeID);
		writer.Write(m_ScriptTypeIndex);
		writer.Write(m_Stripped);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/ObjectInformation/ObjectInfo_17.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.ObjectInformation;
/// <summary>
/// Contains information for a block of raw serialized object data.
/// </summary>
public partial record class ObjectInfo_17 : IObjectInfo
{
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	private long m_FileID = new();
	
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	public long FileID
	{
		get => m_FileID;
		set
		{
			m_FileID = value;
			OnFileIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="FileID"/> is set.
	/// </summary>
	partial void OnFileIDAssignment(long value);
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	private int m_ByteStart = new();
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	public long ByteStart
	{
		get => m_ByteStart;
		set
		{
			m_ByteStart = (int)value;
			OnByteStartAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteStart"/> is set.
	/// </summary>
	partial void OnByteStartAssignment(long value);
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	private int m_ByteSize = new();
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	public int ByteSize
	{
		get => m_ByteSize;
		set
		{
			m_ByteSize = value;
			OnByteSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteSize"/> is set.
	/// </summary>
	partial void OnByteSizeAssignment(int value);
	
	/// <summary>
	/// Type index in <see cref="SerializedFileMetadata.Types"/> array.
	/// </summary>
	private int m_SerializedTypeIndex = new();
	
	/// <summary>
	/// Type index in <see cref="SerializedFileMetadata.Types"/> array.
	/// </summary>
	public int SerializedTypeIndex
	{
		get => m_SerializedTypeIndex;
		set
		{
			m_SerializedTypeIndex = value;
			OnSerializedTypeIndexAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="SerializedTypeIndex"/> is set.
	/// </summary>
	partial void OnSerializedTypeIndexAssignment(int value);
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	public int TypeID
	{
		get => -1;
		set { }
	}
	
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	public short ClassID
	{
		get => (short)TypeID;
		set => TypeID = value;
	}
	
	public ushort IsDestroyed
	{
		get => default;
		set { }
	}
	
	public short ScriptTypeIndex
	{
		get => default;
		set { }
	}
	
	public bool Stripped
	{
		get => false;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		reader.AlignStream();
		m_FileID = reader.ReadInt64();
		m_ByteStart = reader.ReadInt32();
		m_ByteSize = reader.ReadInt32();
		m_SerializedTypeIndex = reader.ReadInt32();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.AlignStream();
		writer.Write(m_FileID);
		writer.Write(m_ByteStart);
		writer.Write(m_ByteSize);
		writer.Write(m_SerializedTypeIndex);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/ObjectInformation/ObjectInfo_22.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.ObjectInformation;
/// <summary>
/// Contains information for a block of raw serialized object data.
/// </summary>
public partial record class ObjectInfo_22 : IObjectInfo
{
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	private long m_FileID = new();
	
	/// <summary>
	/// ObjectID
	/// </summary>
	/// <remarks>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </remarks>
	public long FileID
	{
		get => m_FileID;
		set
		{
			m_FileID = value;
			OnFileIDAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="FileID"/> is set.
	/// </summary>
	partial void OnFileIDAssignment(long value);
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	private long m_ByteStart = new();
	
	/// <summary>
	/// Offset to the object data.
	/// </summary>
	/// <remarks>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </remarks>
	public long ByteStart
	{
		get => m_ByteStart;
		set
		{
			m_ByteStart = value;
			OnByteStartAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteStart"/> is set.
	/// </summary>
	partial void OnByteStartAssignment(long value);
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	private int m_ByteSize = new();
	
	/// <summary>
	/// Size of the object data.
	/// </summary>
	public int ByteSize
	{
		get => m_ByteSize;
		set
		{
			m_ByteSize = value;
			OnByteSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteSize"/> is set.
	/// </summary>
	partial void OnByteSizeAssignment(int value);
	
	/// <summary>
	/// Type index in <see cref="SerializedFileMetadata.Types"/> array.
	/// </summary>
	private int m_SerializedTypeIndex = new();
	
	/// <summary>
	/// Type index in <see cref="SerializedFileMetadata.Types"/> array.
	/// </summary>
	public int SerializedTypeIndex
	{
		get => m_SerializedTypeIndex;
		set
		{
			m_SerializedTypeIndex = value;
			OnSerializedTypeIndexAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="SerializedTypeIndex"/> is set.
	/// </summary>
	partial void OnSerializedTypeIndexAssignment(int value);
	
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/>. Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
	/// </summary>
	public int TypeID
	{
		get => -1;
		set { }
	}
	
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	public short ClassID
	{
		get => (short)TypeID;
		set => TypeID = value;
	}
	
	public ushort IsDestroyed
	{
		get => default;
		set { }
	}
	
	public short ScriptTypeIndex
	{
		get => default;
		set { }
	}
	
	public bool Stripped
	{
		get => false;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		reader.AlignStream();
		m_FileID = reader.ReadInt64();
		m_ByteStart = reader.ReadInt64();
		m_ByteSize = reader.ReadInt32();
		m_SerializedTypeIndex = reader.ReadInt32();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.AlignStream();
		writer.Write(m_FileID);
		writer.Write(m_ByteStart);
		writer.Write(m_ByteSize);
		writer.Write(m_SerializedTypeIndex);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Parser/FileIdentifier.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.FileIdentifiers;
using AssetRipper.IO.Files.SerializedFiles.IO;

namespace AssetRipper.IO.Files.SerializedFiles.Parser;

/// <summary>
/// A serialized file may be linked with other serialized files to create shared dependencies.
/// </summary>
public struct FileIdentifier : ISerializedReadable, ISerializedWritable
{
	/// <summary>
	/// 2.1.0 and greater
	/// </summary>
	public static bool HasAssetPath(FormatVersion generation) => generation >= FormatVersion.Unknown_6;
	/// <summary>
	/// 1.2.0 and greater
	/// </summary>
	public static bool HasHash(FormatVersion generation) => generation >= FormatVersion.Unknown_5;

	public bool IsFile(SerializedFile? file)
	{
		return file is not null && file.NameFixed == PathName;
	}

	public void Read(SerializedReader reader)
	{
		if (HasAssetPath(reader.Generation))
		{
			AssetPath = reader.ReadStringZeroTerm();
		}
		if (HasHash(reader.Generation))
		{
			Guid = reader.ReadUnityGuid();
			Type = (AssetType)reader.ReadInt32();
		}
		PathNameOrigin = reader.ReadStringZeroTerm();
		PathName = SpecialFileNames.FixFileIdentifier(PathNameOrigin);
	}

	public readonly void Write(SerializedWriter writer)
	{
		if (HasAssetPath(writer.Generation))
		{
			writer.WriteStringZeroTerm(AssetPath);
		}
		if (HasHash(writer.Generation))
		{
			writer.Write(Guid);
			writer.Write((int)Type);
		}
		writer.WriteStringZeroTerm(PathNameOrigin);
	}

	public readonly string GetFilePath()
	{
		if (Type == AssetType.Meta)
		{
			return Guid.ToString();
		}
		return PathName;
	}

	public override readonly string? ToString()
	{
		if (Type == AssetType.Meta)
		{
			return Guid.ToString();
		}
		return PathNameOrigin ?? base.ToString();
	}

	/// <summary>
	/// File path without such prefixes as archive:/directory/fileName
	/// </summary>
	public string PathName { get; set; }

	/// <summary>
	/// Virtual asset path. Used for cached files, otherwise it's empty.
	/// The file with that path usually doesn't exist, so it's probably an alias.
	/// </summary>
	public string AssetPath { get; set; }
	/// <summary>
	/// The type of the file
	/// </summary>
	public AssetType Type { get; set; }
	/// <summary>
	/// Actual file path. This path is relative to the path of the current file.
	/// The folder "library" often needs to be translated to "resources" in order to find the file on the file system.
	/// </summary>
	public string PathNameOrigin { get; set; }

	public UnityGuid Guid { get; set; }
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Parser/LocalSerializedObjectIdentifier.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;

namespace AssetRipper.IO.Files.SerializedFiles.Parser;

public struct LocalSerializedObjectIdentifier : ISerializedReadable, ISerializedWritable
{
	public void Read(SerializedReader reader)
	{
		LocalSerializedFileIndex = reader.ReadInt32();
		if (ObjectInfo.IsLongID(reader.Generation))
		{
			reader.AlignStream();
			LocalIdentifierInFile = reader.ReadInt64();
		}
		else
		{
			LocalIdentifierInFile = reader.ReadInt32();
		}
	}

	public void Write(SerializedWriter writer)
	{
		writer.Write(LocalSerializedFileIndex);
		if (ObjectInfo.IsLongID(writer.Generation))
		{
			writer.AlignStream();
			writer.Write(LocalIdentifierInFile);
		}
		else
		{
			writer.Write((int)LocalIdentifierInFile);
		}
	}

	public override string ToString()
	{
		return $"[{LocalSerializedFileIndex}, {LocalIdentifierInFile}]";
	}

	public int LocalSerializedFileIndex { get; set; }
	public long LocalIdentifierInFile { get; set; }
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Parser/ObjectInfo.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;

namespace AssetRipper.IO.Files.SerializedFiles.Parser;

/// <summary>
/// Contains information for a block of raw serialized object data.
/// </summary>
public struct ObjectInfo : ISerializedReadable, ISerializedWritable
{
	/// <summary>
	/// 5.0.0unk and greater / Format Version at least 14
	/// </summary>
	public static bool IsLongID(FormatVersion generation) => generation >= FormatVersion.Unknown_14;
	/// <summary>
	/// Less than 5.5.0 / Format Version less than 16
	/// </summary>
	public static bool HasClassID(FormatVersion generation) => generation < FormatVersion.RefactoredClassId;
	/// <summary>
	/// Less than 5.0.0unk / Format Version less than 11
	/// </summary>
	public static bool HasIsDestroyed(FormatVersion generation) => generation < FormatVersion.HasScriptTypeIndex;
	/// <summary>
	/// 5.0.0unk to 5.5.0unk exclusive / Format Version at least 11 but less than 17
	/// </summary>
	public static bool HasScriptID(FormatVersion generation) => generation >= FormatVersion.HasScriptTypeIndex && generation < FormatVersion.RefactorTypeData;
	/// <summary>
	/// 5.0.1 to 5.5.0unk exclusive / Format Version at least 15 but less than 17
	/// </summary>
	public static bool HasStripped(FormatVersion generation) => generation >= FormatVersion.SupportsStrippedObject && generation < FormatVersion.RefactorTypeData;
	/// <summary>
	/// 2020.1.0 and greater / Format Version at least 22
	/// </summary>
	public static bool HasLargeFilesSupport(FormatVersion generation) => generation >= FormatVersion.LargeFilesSupport;

	public void Read(SerializedReader reader)
	{
		if (IsLongID(reader.Generation))
		{
			reader.AlignStream();
			FileID = reader.ReadInt64();
		}
		else
		{
			FileID = reader.ReadInt32();
		}

		if (HasLargeFilesSupport(reader.Generation))
		{
			ByteStart = reader.ReadInt64();
		}
		else
		{
			ByteStart = reader.ReadUInt32();
		}

		ByteSize = reader.ReadInt32();
		if (reader.Generation >= FormatVersion.RefactorTypeData)
		{
			SerializedTypeIndex = reader.ReadInt32();
		}
		else
		{
			SerializedTypeIndex = -1;
			TypeID = reader.ReadInt32();
		}
		if (HasClassID(reader.Generation))
		{
			ClassID = reader.ReadInt16();
		}
		if (HasScriptID(reader.Generation))
		{
			ScriptTypeIndex = reader.ReadInt16();
		}
		else if (HasIsDestroyed(reader.Generation))
		{
			IsDestroyed = reader.ReadUInt16();
		}
		if (HasStripped(reader.Generation))
		{
			Stripped = reader.ReadBoolean();
		}
	}

	public readonly void Write(SerializedWriter writer)
	{
		if (IsLongID(writer.Generation))
		{
			writer.AlignStream();
			writer.Write(FileID);
		}
		else
		{
			writer.Write((int)FileID);
		}

		if (HasLargeFilesSupport(writer.Generation))
		{
			writer.Write(ByteStart);
		}
		else
		{
			writer.Write((uint)ByteStart);
		}

		writer.Write(ByteSize);
		if (writer.Generation >= FormatVersion.RefactorTypeData)
		{
			writer.Write(SerializedTypeIndex);
		}
		else
		{
			writer.Write(TypeID);
		}
		if (HasClassID(writer.Generation))
		{
			writer.Write(ClassID);
		}
		if (HasScriptID(writer.Generation))
		{
			writer.Write(ScriptTypeIndex);
		}
		else if (HasIsDestroyed(writer.Generation))
		{
			writer.Write(IsDestroyed);
		}
		if (HasStripped(writer.Generation))
		{
			writer.Write(Stripped);
		}
	}

	public override readonly string ToString()
	{
		return $"{ClassID}[{FileID}]";
	}

	public readonly SerializedType? GetSerializedType(ReadOnlySpan<SerializedType> types)
	{
		if (SerializedTypeIndex >= 0)
		{
			return types[SerializedTypeIndex];
		}
		else if (types.Length == 0)
		{
			return default; //It's common on Unity 4 and lower for the array to be empty.
		}
		else
		{
			SerializedType? result = null;
			foreach (SerializedType type in types)
			{
				if (type.TypeID == TypeID && type.IsStrippedType == Stripped)
				{
					if (result is null)
					{
						result = type;
					}
					else
					{
						throw new Exception($"Multiple types with the same ID {TypeID} and stripped {Stripped} found");
					}
				}
			}
			return result ?? throw new Exception($"Type with ID {TypeID} and stripped {Stripped} not found");
		}
	}

	public void Initialize(ReadOnlySpan<SerializedType> types)
	{
		if (SerializedTypeIndex >= 0)
		{
			SerializedType type = types[SerializedTypeIndex];
			TypeID = type.TypeID;
			if (type.TypeID < short.MaxValue)
			{
				ClassID = (short)type.TypeID;
			}
			ScriptTypeIndex = type.ScriptTypeIndex;
			Stripped = type.IsStrippedType;
		}
	}

	/// <summary>
	/// ObjectID<br/>
	/// Unique ID that identifies the object. Can be used as a key for a map.
	/// </summary>
	public long FileID { get; set; }
	/// <summary>
	/// Offset to the object data.<br/>
	/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
	/// </summary>
	public long ByteStart { get; set; }
	/// <summary>
	/// Size of the object data.
	/// </summary>
	public int ByteSize { get; set; }
	/// <summary>
	/// Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/><br/>
	/// Equals to classID if the object is not MonoBehaviour"/>
	/// </summary>
	public int TypeID { get; set; }
	/// <summary>
	/// Type index in <see cref="SerializedFileMetadata.Types"/> array<br/>
	/// </summary>
	public int SerializedTypeIndex { get; set; }
	/// <summary>
	/// Class ID of the object.
	/// </summary>
	public short ClassID { get; set; }
	public ushort IsDestroyed { get; set; }
	public short ScriptTypeIndex { get; set; }
	public bool Stripped { get; set; }
	/// <summary>
	/// The data referenced by <see cref="ByteStart"/> and <see cref="ByteSize"/>.
	/// </summary>
	public byte[]? ObjectData { get; set; }
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Parser/SerializedFileHeader.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.SerializedFiles.Parser;

/// <summary>
/// The file header is found at the beginning of an asset file. The header is always using big endian byte order.
/// </summary>
public sealed record class SerializedFileHeader
{
	/// <summary>
	/// Size of the metadata parts of the file
	/// </summary>
	public long MetadataSize { get; set; }
	/// <summary>
	/// Size of the whole file
	/// </summary>
	public long FileSize { get; set; }
	/// <summary>
	/// File format version. The number is required for backward compatibility and is normally incremented after the file format has been changed in a major update
	/// </summary>
	public FormatVersion Version { get; set; }
	/// <summary>
	/// Offset to the serialized object data. It starts at the data for the first object
	/// </summary>
	public long DataOffset { get; set; }
	/// <summary>
	/// Presumably controls the byte order of the data structure. This field is normally set to 0, which may indicate a little endian byte order.
	/// </summary>
	public bool Endianess { get; set; }

	public const int HeaderMinSize = 16;

	public const int MetadataMinSize = 13;


	/// <summary>
	/// 3.5.0 and greater / Format Version 9 +
	/// </summary>
	public static bool HasEndianess(FormatVersion generation) => generation >= FormatVersion.Unknown_9;

	/// <summary>
	/// 2020.1.0 and greater / Format Version 22 +
	/// </summary>
	public static bool HasLargeFilesSupport(FormatVersion generation) => generation >= FormatVersion.LargeFilesSupport;

	public static bool IsSerializedFileHeader(EndianReader reader, long fileSize)
	{
		long initialPosition = reader.BaseStream.Position;

		//Sanity check that there is enough room here first.
		if (reader.BaseStream.Position + HeaderMinSize > reader.BaseStream.Length)
		{
			return false;
		}

		//Pre-22 format: 
		// - Metadata Size
		// - File Size
		// - Generation
		int metadataSize = reader.ReadInt32();
		ulong headerDefinedFileSize = reader.ReadUInt32();

		// Read generation first, the format changed hugely in gen 22 (unity 2020)
		// Generation is always at [base + 0x8]
		int generation = reader.ReadInt32();
		if (!Enum.IsDefined(typeof(FormatVersion), generation))
		{
			reader.BaseStream.Position = initialPosition;
			return false;
		}

		if (generation >= 22)
		{
			//22 Format:
			//First known value is at 0x14, and is metadata size as a 32-bit integer.
			//Then the file size as a 64-bit integer.
			reader.BaseStream.Position = initialPosition + 0x14;
			metadataSize = reader.ReadInt32();
			headerDefinedFileSize = reader.ReadUInt64();
		}

		reader.BaseStream.Position = initialPosition;

		return metadataSize >= MetadataMinSize
			&& headerDefinedFileSize >= HeaderMinSize + MetadataMinSize
			&& fileSize >= 0
			&& headerDefinedFileSize == (ulong)fileSize;
	}

	public void Read(EndianReader reader)
	{
		//For gen 22+ these will be zero
		MetadataSize = reader.ReadInt32();
		FileSize = reader.ReadUInt32();

		//Read generation
		Version = (FormatVersion)reader.ReadInt32();

		//For gen 22+ this will be zero
		DataOffset = reader.ReadUInt32();

		if (HasEndianess(Version))
		{
			Endianess = reader.ReadBoolean();
			reader.AlignStream();
		}
		if (HasLargeFilesSupport(Version))
		{
			MetadataSize = reader.ReadUInt32();
			FileSize = reader.ReadInt64();
			DataOffset = reader.ReadInt64();
			reader.ReadInt64(); // unknown
		}

		if (MetadataSize <= 0)
		{
			throw new Exception($"Invalid metadata size {MetadataSize}");
		}

		if (!Enum.IsDefined(typeof(FormatVersion), Version))
		{
			throw new Exception($"Unsupported file generation {Version}'");
		}
	}

	public void Write(EndianWriter writer)
	{
		//0x00
		if (HasLargeFilesSupport(Version))
		{
			writer.Write(0);
			writer.Write(0u);
		}
		else
		{
			writer.Write((int)MetadataSize);
			writer.Write((uint)FileSize);
		}

		//0x08
		writer.Write((int)Version);

		//0x0c
		if (HasLargeFilesSupport(Version))
		{
			writer.Write(0u);
		}
		else
		{
			writer.Write((uint)DataOffset);
		}

		//0x10
		if (HasEndianess(Version))
		{
			writer.Write(Endianess);
			writer.AlignStream();
		}

		//0x14
		if (HasLargeFilesSupport(Version))
		{
			writer.Write((uint)MetadataSize);
			writer.Write(FileSize);
			writer.Write(DataOffset);
			writer.Write(0L);
		}
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Parser/SerializedFileMetadata.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.IO;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.SerializedFiles.Parser;

public sealed class SerializedFileMetadata
{
	/// <summary>
	/// Less than 3.5.0
	/// </summary>
	public static bool HasEndian(FormatVersion generation) => generation < FormatVersion.Unknown_9;
	/// <summary>
	/// Less than 3.5.0
	/// </summary>
	public static bool IsMetadataAtTheEnd(FormatVersion generation) => generation < FormatVersion.Unknown_9;

	/// <summary>
	/// 3.0.0b and greater
	/// </summary>
	public static bool HasSignature(FormatVersion generation) => generation >= FormatVersion.Unknown_7;
	/// <summary>
	/// 3.0.0 and greater
	/// </summary>
	public static bool HasPlatform(FormatVersion generation) => generation >= FormatVersion.Unknown_8;
	/// <summary>
	/// 5.0.0Unk2 and greater
	/// </summary>
	public static bool HasEnableTypeTree(FormatVersion generation) => generation >= FormatVersion.HasTypeTreeHashes;
	/// <summary>
	/// 3.0.0b to 4.x.x
	/// </summary>
	public static bool HasLongFileID(FormatVersion generation) => generation >= FormatVersion.Unknown_7 && generation < FormatVersion.Unknown_14;
	/// <summary>
	/// 5.0.0Unk0 and greater
	/// </summary>
	public static bool HasScriptTypes(FormatVersion generation) => generation >= FormatVersion.HasScriptTypeIndex;
	/// <summary>
	/// 1.2.0 and greater
	/// </summary>
	public static bool HasUserInformation(FormatVersion generation) => generation >= FormatVersion.Unknown_5;
	/// <summary>
	/// 2019.2 and greater
	/// </summary>
	public static bool HasRefTypes(FormatVersion generation) => generation >= FormatVersion.SupportsRefObject;

	public void Read(SmartStream stream, SerializedFileHeader header)
	{
		bool swapEndianess = ReadSwapEndianess(stream, header);
		EndianType endianess = swapEndianess ? EndianType.BigEndian : EndianType.LittleEndian;
		using SerializedReader reader = new SerializedReader(stream, endianess, header.Version);
		Read(reader);
	}

	private bool ReadSwapEndianess(SmartStream stream, SerializedFileHeader header)
	{
		if (HasEndian(header.Version))
		{
			int num = stream.ReadByte();
			//This is not and should not be aligned.
			//Aligment only happens for the endian boolean on version 9 and greater.
			//This coincides with endianess being stored in the header on version 9 and greater.
			return num switch
			{
				< 0 => throw new EndOfStreamException(),
				_ => SwapEndianess = num != 0,
			};
		}
		else
		{
			return header.Endianess;
		}
	}

	private void Read(SerializedReader reader)
	{
		if (HasSignature(reader.Generation))
		{
			string signature = reader.ReadStringZeroTerm();
			if (!UnityVersion.TryParse(signature, out UnityVersion version, out _))
			{
				// Assume version is stripped if it can't be parsed.
				version = default;
			}
			UnityVersion = version;
			reader.Version = version;
		}
		if (HasPlatform(reader.Generation))
		{
			TargetPlatform = (BuildTarget)reader.ReadUInt32();
		}

		EnableTypeTree = ReadEnableTypeTree(reader);

		Types = reader.ReadSerializedTypeArray<SerializedType>(EnableTypeTree);

		if (HasLongFileID(reader.Generation))
		{
			LongFileID = reader.ReadUInt32();
		}

		//TODO: pass LongFileID to ObjectInfo
		Object = reader.ReadSerializedArray<ObjectInfo>();

		if (HasScriptTypes(reader.Generation))
		{
			ScriptTypes = reader.ReadSerializedArray<LocalSerializedObjectIdentifier>();
		}

		Externals = reader.ReadSerializedArray<FileIdentifier>();

		if (HasRefTypes(reader.Generation))
		{
			RefTypes = reader.ReadSerializedTypeArray<SerializedTypeReference>(EnableTypeTree);
		}
		if (HasUserInformation(reader.Generation))
		{
			UserInformation = reader.ReadStringZeroTerm();
		}
	}

	private static bool ReadEnableTypeTree(SerializedReader reader)
	{
		if (HasEnableTypeTree(reader.Generation))
		{
			return reader.ReadBoolean();
		}
		else
		{
			return true;
		}
	}

	public void Write(SerializedWriter writer)
	{
		if (HasEndian(writer.Generation))
		{
			writer.Write(writer.EndianType == EndianType.BigEndian ? (byte)1 : (byte)0);
		}
		if (HasSignature(writer.Generation))
		{
			writer.WriteStringZeroTerm(UnityVersion.ToString());
		}
		if (HasPlatform(writer.Generation))
		{
			writer.Write((uint)TargetPlatform);
		}
		if (HasEnableTypeTree(writer.Generation))
		{
			writer.Write(EnableTypeTree);
		}

		writer.WriteSerializedTypeArray(Types, EnableTypeTree);
		if (HasLongFileID(writer.Generation))
		{
			writer.Write(LongFileID);
		}

		writer.WriteSerializedArray(Object);
		if (HasScriptTypes(writer.Generation))
		{
			writer.WriteSerializedArray(ScriptTypes);
		}
		writer.WriteSerializedArray(Externals);
		if (HasRefTypes(writer.Generation))
		{
			writer.WriteSerializedTypeArray(RefTypes, EnableTypeTree);
		}
		if (HasUserInformation(writer.Generation))
		{
			writer.WriteStringZeroTerm(UserInformation);
		}
	}

	public UnityVersion UnityVersion { get; set; }
	public BuildTarget TargetPlatform { get; set; }
	public bool EnableTypeTree { get; set; }
	public SerializedType[] Types { get; set; } = Array.Empty<SerializedType>();
	/// <summary>
	/// Indicate that <see cref="ObjectInfo.FileID"/> is 8 bytes size<br/>
	/// Serialized files with this field enabled supposedly don't exist
	/// </summary>
	public uint LongFileID { get; set; }
	public bool SwapEndianess { get; set; }
	public ObjectInfo[] Object { get; set; } = Array.Empty<ObjectInfo>();
	public LocalSerializedObjectIdentifier[] ScriptTypes { get; set; } = Array.Empty<LocalSerializedObjectIdentifier>();
	public FileIdentifier[] Externals { get; set; } = Array.Empty<FileIdentifier>();
	public string UserInformation { get; set; } = "";
	public SerializedTypeReference[] RefTypes { get; set; } = Array.Empty<SerializedTypeReference>();
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Parser/SerializedType.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;

namespace AssetRipper.IO.Files.SerializedFiles.Parser;

public sealed class SerializedType : SerializedTypeBase
{
	public int[] TypeDependencies { get; set; } = Array.Empty<int>();

	protected override bool IgnoreScriptTypeForHash(FormatVersion formatVersion, UnityVersion unityVersion)
	{
		//This code is most likely correct, but not guaranteed.
		//Reverse engineering it was painful, and it's possible that mistakes were made.
		return !unityVersion.Equals(0, 0, 0) && unityVersion < WriteIDHashForScriptTypeVersion;
	}

	protected override void ReadTypeDependencies(SerializedReader reader)
	{
		TypeDependencies = reader.ReadInt32Array();
	}

	protected override void WriteTypeDependencies(SerializedWriter writer)
	{
		writer.WriteArray(TypeDependencies);
	}

	private static UnityVersion WriteIDHashForScriptTypeVersion { get; } = new UnityVersion(2018, 3, 0, UnityVersionType.Alpha, 1);
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Parser/SerializedTypeBase.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;

namespace AssetRipper.IO.Files.SerializedFiles.Parser;

public abstract class SerializedTypeBase
{
	public int TypeID
	{
		get
		{
			return RawTypeID;
		}
		set
		{
			RawTypeID = value;
		}
	}

	/// <summary>
	/// For versions less than 17, it specifies <see cref="TypeID"/> or -<see cref="ScriptTypeIndex"/> -1 for MonoBehaviour
	/// </summary>
	public int OriginalTypeID
	{
		get
		{
			return RawTypeID;
		}
		set
		{
			RawTypeID = value;
		}
	}
	public int RawTypeID { get; set; }
	public bool IsStrippedType { get; set; }
	/// <summary>
	/// For <see cref="ClassIDType.MonoBehaviour"/> specifies script type
	/// </summary>
	public short ScriptTypeIndex { get; set; }
	/// <summary>
	/// The type of the class.
	/// </summary>
	public TypeTrees.TypeTree OldType { get; } = new();
	/// <summary>
	/// Hash128
	/// </summary>
	public byte[] ScriptID { get; set; } = Array.Empty<byte>();
	public byte[] OldTypeHash { get; set; } = Array.Empty<byte>();

	public void Read(SerializedReader reader, bool hasTypeTree)
	{
		RawTypeID = reader.ReadInt32();
		int typeIdLocal;
		if (reader.Generation < FormatVersion.RefactoredClassId)
		{
			typeIdLocal = RawTypeID < 0 ? -1 : RawTypeID;
			IsStrippedType = false;
			ScriptTypeIndex = -1;
		}
		else
		{
			typeIdLocal = RawTypeID;
			IsStrippedType = reader.ReadBoolean();
		}

		if (reader.Generation >= FormatVersion.RefactorTypeData)
		{
			ScriptTypeIndex = reader.ReadInt16();
		}

		if (reader.Generation >= FormatVersion.HasTypeTreeHashes)
		{
			bool readScriptID = (typeIdLocal == -1)
				|| (typeIdLocal == 114)
				|| (!IgnoreScriptTypeForHash(reader.Generation, reader.Version) && ScriptTypeIndex >= 0);
			if (readScriptID)
			{
				ScriptID = reader.ReadBytes(16);//actually read as 4 uint
			}
			OldTypeHash = reader.ReadBytes(16);//actually read as 4 uint
		}

		if (hasTypeTree)
		{
			OldType.Read(reader);
			if (reader.Generation < FormatVersion.HasTypeTreeHashes)
			{
				//OldTypeHash gets recalculated here in a complicated way on 2023.
			}
			else if (reader.Generation >= FormatVersion.StoresTypeDependencies)
			{
				ReadTypeDependencies(reader);
			}
		}
	}

	protected abstract void ReadTypeDependencies(SerializedReader reader);

	protected abstract bool IgnoreScriptTypeForHash(FormatVersion formatVersion, UnityVersion unityVersion);

	protected abstract void WriteTypeDependencies(SerializedWriter writer);

	public void Write(SerializedWriter writer, bool hasTypeTree)
	{
		writer.Write(RawTypeID);
		if (writer.Generation >= FormatVersion.RefactoredClassId)
		{
			writer.Write(IsStrippedType);
		}
		if (writer.Generation >= FormatVersion.RefactorTypeData)
		{
			writer.Write(ScriptTypeIndex);
		}
		if (writer.Generation >= FormatVersion.HasTypeTreeHashes)
		{
			bool writeScriptID = (RawTypeID == -1)
				|| (RawTypeID == 114)
				|| (!IgnoreScriptTypeForHash(writer.Generation, writer.Version) && ScriptTypeIndex >= 0);
			if (writeScriptID)
			{
				writer.Write(ScriptID);//actually written as 4 uint
			}
			writer.Write(OldTypeHash);//actually written as 4 uint
		}

		if (hasTypeTree)
		{
			OldType.Write(writer);
			if (writer.Generation >= FormatVersion.StoresTypeDependencies)
			{
				WriteTypeDependencies(writer);
			}
		}
	}

	public override string ToString()
	{
		return TypeID.ToString();
	}

	/// <summary>
	/// 5.5.0a and greater, ie format version 16+
	/// </summary>
	public static bool HasIsStrippedType(FormatVersion generation) => generation >= FormatVersion.RefactoredClassId;
	/// <summary>
	/// 5.5.0 and greater, ie format version 17+
	/// </summary>
	public static bool HasScriptTypeIndex(FormatVersion generation) => generation >= FormatVersion.RefactorTypeData;
	/// <summary>
	/// 5.0.0unk2 and greater, ie format version 13+
	/// </summary>
	public static bool HasHash(FormatVersion generation) => generation >= FormatVersion.HasTypeTreeHashes;
	/// <summary>
	/// 2019.3 and greater, ie format version 21+
	/// </summary>
	public static bool HasTypeDependencies(FormatVersion generation) => generation >= FormatVersion.StoresTypeDependencies;
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Parser/SerializedTypeReference.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;

namespace AssetRipper.IO.Files.SerializedFiles.Parser;

/// <summary>
/// A reference type for a serializeable C# type.
/// </summary>
/// <remarks>
/// These are used for fields with the [SerializeReference] attribute.
/// </remarks>
public sealed class SerializedTypeReference : SerializedTypeBase
{
	public string ClassName { get; set; } = "";
	public string Namespace { get; set; } = "";
	public string AsmName { get; set; } = "";

	public string FullName
	{
		get
		{
			return string.IsNullOrEmpty(Namespace)
				? ClassName
				: $"{Namespace}.{ClassName}";
		}
	}

	protected override bool IgnoreScriptTypeForHash(FormatVersion formatVersion, UnityVersion unityVersion)
	{
		return false;
	}

	protected override void ReadTypeDependencies(SerializedReader reader)
	{
		ClassName = reader.ReadStringZeroTerm();
		Namespace = reader.ReadStringZeroTerm();
		AsmName = reader.ReadStringZeroTerm();
	}

	protected override void WriteTypeDependencies(SerializedWriter writer)
	{
		writer.WriteStringZeroTerm(ClassName);
		writer.WriteStringZeroTerm(Namespace);
		writer.WriteStringZeroTerm(AsmName);
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Parser/TypeTrees/CommonString.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees;

public static class CommonString
{
	public static IReadOnlyDictionary<uint, string> StringBuffer { get; } = new Dictionary<uint, string>
	{
		{0, "AABB"},
		{5, "AnimationClip"},
		{19, "AnimationCurve"},
		{34, "AnimationState"},
		{49, "Array"},
		{55, "Base"},
		{60, "BitField"},
		{69, "bitset"},
		{76, "bool"},
		{81, "char"},
		{86, "ColorRGBA"},
		{96, "Component"},
		{106, "data"},
		{111, "deque"},
		{117, "double"},
		{124, "dynamic_array"},
		{138, "FastPropertyName"},
		{155, "first"},
		{161, "float"},
		{167, "Font"},
		{172, "GameObject"},
		{183, "Generic Mono"},
		{196, "GradientNEW"},
		{208, "GUID"},
		{213, "GUIStyle"},
		{222, "int"},
		{226, "list"},
		{231, "long long"},
		{241, "map"},
		{245, "Matrix4x4f"},
		{256, "MdFour"},
		{263, "MonoBehaviour"},
		{277, "MonoScript"},
		{288, "m_ByteSize"},
		{299, "m_Curve"},
		{307, "m_EditorClassIdentifier"},
		{331, "m_EditorHideFlags"},
		{349, "m_Enabled"},
		{359, "m_ExtensionPtr"},
		{374, "m_GameObject"},
		{387, "m_Index"},
		{395, "m_IsArray"},
		{405, "m_IsStatic"},
		{416, "m_MetaFlag"},
		{427, "m_Name"},
		{434, "m_ObjectHideFlags"},
		{452, "m_PrefabInternal"},
		{469, "m_PrefabParentObject"},
		{490, "m_Script"},
		{499, "m_StaticEditorFlags"},
		{519, "m_Type"},
		{526, "m_Version"},
		{536, "Object"},
		{543, "pair"},
		{548, "PPtr<Component>"},
		{564, "PPtr<GameObject>"},
		{581, "PPtr<Material>"},
		{596, "PPtr<MonoBehaviour>"},
		{616, "PPtr<MonoScript>"},
		{633, "PPtr<Object>"},
		{646, "PPtr<Prefab>"},
		{659, "PPtr<Sprite>"},
		{672, "PPtr<TextAsset>"},
		{688, "PPtr<Texture>"},
		{702, "PPtr<Texture2D>"},
		{718, "PPtr<Transform>"},
		{734, "Prefab"},
		{741, "Quaternionf"},
		{753, "Rectf"},
		{759, "RectInt"},
		{767, "RectOffset"},
		{778, "second"},
		{785, "set"},
		{789, "short"},
		{795, "size"},
		{800, "SInt16"},
		{807, "SInt32"},
		{814, "SInt64"},
		{821, "SInt8"},
		{827, "staticvector"},
		{840, "string"},
		{847, "TextAsset"},
		{857, "TextMesh"},
		{866, "Texture"},
		{874, "Texture2D"},
		{884, "Transform"},
		{894, "TypelessData"},
		{907, "UInt16"},
		{914, "UInt32"},
		{921, "UInt64"},
		{928, "UInt8"},
		{934, "unsigned int"},
		{947, "unsigned long long"},
		{966, "unsigned short"},
		{981, "vector"},
		{988, "Vector2f"},
		{997, "Vector3f"},
		{1006, "Vector4f"},
		{1015, "m_ScriptingClassIdentifier"},
		{1042, "Gradient"},
		{1051, "Type*"},
		{1057, "int2_storage"},
		{1070, "int3_storage"},
		{1083, "BoundsInt"},
		{1093, "m_CorrespondingSourceObject"},
		{1121, "m_PrefabInstance"},
		{1138, "m_PrefabAsset"},
		{1152, "FileSize"},
		{1161, "Hash128"},
		{1169, "RenderingLayerMask"},
		{1188, "fixed_array" },
		{1200, "EntityId"},
	};
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Parser/TypeTrees/TypeTree.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.IO;
using System.Diagnostics;
using System.Text;

namespace AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees;

public sealed class TypeTree : ISerializedReadable, ISerializedWritable
{
	public void Read(SerializedReader reader)
	{
		if (TypeTreeNode.IsFormat5(reader.Generation))
		{
			IsFormat5 = true;

			int nodesCount = reader.ReadInt32();
			if (nodesCount < 0)
			{
				throw new InvalidDataException($"Node count cannot be negative: {nodesCount}");
			}

			int stringBufferSize = reader.ReadInt32();
			if (stringBufferSize < 0)
			{
				throw new InvalidDataException($"String buffer size cannot be negative: {stringBufferSize}");
			}

			Nodes.Clear();
			Nodes.Capacity = nodesCount;
			for (int i = 0; i < nodesCount; i++)
			{
				TypeTreeNode node = new TypeTreeNode();
				node.Read(reader);
				Nodes.Add(node);
			}
			if (stringBufferSize == 0)
			{
				StringBuffer = Array.Empty<byte>();
			}
			else
			{
				StringBuffer = new byte[stringBufferSize];
				reader.Read(StringBuffer, 0, StringBuffer.Length);
			}
			SetNamesFromBuffer();
		}
		else
		{
			IsFormat5 = false;
			Nodes.Clear();
			ReadTreeNode(reader, Nodes, 0);
		}
	}

	public void Write(SerializedWriter writer)
	{
		if (TypeTreeNode.IsFormat5(writer.Generation))
		{
			writer.Write(Nodes.Count);
			writer.Write(StringBuffer.Length);
			foreach (TypeTreeNode node in Nodes)
			{
				node.Write(writer);
			}
			writer.Write(StringBuffer, 0, StringBuffer.Length);
		}
		else
		{
			int index = 0;
			WriteTreeNode(writer, ref index);
		}
	}

	private static void ReadTreeNode(SerializedReader reader, ICollection<TypeTreeNode> nodes, byte depth)
	{
		TypeTreeNode node = new TypeTreeNode();
		node.Read(reader);
		node.Level = depth;
		nodes.Add(node);

		int childCount = reader.ReadInt32();
		for (int i = 0; i < childCount; i++)
		{
			ReadTreeNode(reader, nodes, (byte)(depth + 1));
		}
	}

	private void WriteTreeNode(SerializedWriter writer, ref int index)
	{
		Nodes[index].Write(writer);
		int childCount = GetChildCount(index);
		writer.Write(childCount);
		index++;
		for (int i = 0; i < childCount; i++)
		{
			WriteTreeNode(writer, ref index);
		}
	}

	public override string? ToString()
	{
		if (Nodes == null)
		{
			return base.ToString();
		}

		return Nodes[0].ToString();
	}

	public StringBuilder ToString(StringBuilder sb)
	{
		if (Nodes != null)
		{
			foreach (TypeTreeNode node in Nodes)
			{
				node.ToString(sb).AppendLine();
			}
		}
		return sb;
	}

	private int GetChildCount(int index)
	{
		int count = 0;
		int depth = Nodes[index].Level + 1;
		for (int i = index + 1; i < Nodes.Count; i++)
		{
			int nodeDepth = Nodes[i].Level;
			if (nodeDepth < depth)
			{
				break;
			}
			if (nodeDepth == depth)
			{
				count++;
			}
		}
		return count;
	}

	public string Dump
	{
		get
		{
			StringBuilder sb = new StringBuilder();
			ToString(sb);
			return sb.ToString();
		}
	}

	private void SetNamesFromBuffer()
	{
		Debug.Assert(IsFormat5);
		Dictionary<uint, string> customTypes = new Dictionary<uint, string>();
		using (MemoryStream stream = new MemoryStream(StringBuffer))
		{
			using EndianReader reader = new EndianReader(stream, EndianType.LittleEndian);
			while (stream.Position < stream.Length)
			{
				uint position = (uint)stream.Position;
				string name = reader.ReadStringZeroTerm();
				customTypes.Add(position, name);
			}
		}

		foreach (TypeTreeNode node in Nodes)
		{
			node.Type = GetTypeName(customTypes, node.TypeStrOffset);
			node.Name = GetTypeName(customTypes, node.NameStrOffset);
		}
	}

	private static string GetTypeName(Dictionary<uint, string> customTypes, uint value)
	{
		bool isCustomType = (value & 0x80000000) == 0;
		if (isCustomType)
		{
			return customTypes[value];
		}
		else
		{
			uint offset = value & ~0x80000000;
			if (CommonString.StringBuffer.TryGetValue(offset, out string? nodeTypeName))
			{
				return nodeTypeName;
			}
			else
			{
				throw new Exception($"Unsupported asset class type name '{offset}'");
			}
		}
	}

	public List<TypeTreeNode> Nodes { get; } = new();
	public byte[] StringBuffer { get; set; } = Array.Empty<byte>();
	/// <summary>
	/// 5.0.0a1 and greater<br/>
	/// Generation 10
	/// </summary>
	private bool IsFormat5 { get; set; }
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/Parser/TypeTrees/TypeTreeNode.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;
using System.Text;

namespace AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees;

public class TypeTreeNode : ISerializedReadable, ISerializedWritable
{
	/// <summary>
	/// 5.0.0a1 and greater<br/>
	/// Generation 10
	/// </summary>
	public static bool IsFormat5(FormatVersion generation) => generation >= FormatVersion.Unknown_10;
	/// <summary>
	/// 2019.1 and greater<br/>
	/// Generation 19
	/// </summary>
	public static bool HasRefTypeHash(FormatVersion generation) => generation >= FormatVersion.TypeTreeNodeWithTypeFlags;

	public TypeTreeNode() { }

	public TypeTreeNode(string type, string name, int level, bool align)
	{
		Type = type;
		Name = name;
		Level = (byte)level;
		MetaFlag = align ? TransferMetaFlags.AlignBytes : TransferMetaFlags.NoTransferFlags;
	}

	public TypeTreeNode(string type, string name, int level, int byteSize, int index, int version, int typeFlags, TransferMetaFlags metaFlag)
	{
		Type = type;
		Name = name;
		Level = (byte)level;
		ByteSize = byteSize;
		Index = index;
		Version = version;
		TypeFlags = typeFlags;
		MetaFlag = metaFlag;
	}

	public void Read(SerializedReader reader)
	{
		if (IsFormat5(reader.Generation))
		{
			Version = reader.ReadUInt16();
			Level = reader.ReadByte();
			TypeFlags = reader.ReadByte();
			TypeStrOffset = reader.ReadUInt32();
			NameStrOffset = reader.ReadUInt32();
			ByteSize = reader.ReadInt32();
			Index = reader.ReadInt32();
			MetaFlag = (TransferMetaFlags)reader.ReadUInt32();
			if (HasRefTypeHash(reader.Generation))
			{
				RefTypeHash = reader.ReadUInt64();
			}
		}
		else
		{
			Type = reader.ReadStringZeroTerm();
			Name = reader.ReadStringZeroTerm();
			ByteSize = reader.ReadInt32();
			Index = reader.ReadInt32();
			TypeFlags = reader.ReadInt32();
			Version = reader.ReadInt32();
			MetaFlag = (TransferMetaFlags)reader.ReadUInt32();
		}
	}

	public void Write(SerializedWriter writer)
	{
		if (IsFormat5(writer.Generation))
		{
			writer.Write((ushort)Version);
			writer.Write(Level);
			writer.Write((byte)TypeFlags);
			writer.Write(TypeStrOffset);
			writer.Write(NameStrOffset);
			writer.Write(ByteSize);
			writer.Write(Index);
			writer.Write((uint)MetaFlag);
			if (HasRefTypeHash(writer.Generation))
			{
				writer.Write(RefTypeHash);
			}
		}
		else
		{
			writer.WriteStringZeroTerm(Type);
			writer.WriteStringZeroTerm(Name);
			writer.Write(ByteSize);
			writer.Write(Index);
			writer.Write(TypeFlags);
			writer.Write(Version);
			writer.Write((uint)MetaFlag);
		}
	}

	public override string? ToString()
	{
		if (Type == null)
		{
			return base.ToString();
		}
		else
		{
			return $"{Type} {Name}";
		}
	}

	public StringBuilder ToString(StringBuilder sb)
	{
		sb.Append('\t', Level).Append(Type).Append(' ').Append(Name);
		sb.AppendFormat(" // ByteSize{0}{1:x}{2}, Index{3}{4:x}{5}, Version{6}{7:x}{8}, IsArray{{{9}}}, MetaFlag{10}{11:x}{12}",
				"{", ByteSize, "}",
				"{", Index, "}",
				"{", Version, "}",
				TypeFlags,
				"{", (uint)MetaFlag, "}");
		return sb;
	}

	/// <summary>
	/// Field type version, starts with 1 and is incremented after the type information has been significantly updated in a new release.<br/>
	/// Equal to serializedVersion in Yaml format files
	/// </summary>
	public int Version { get; set; }
	/// <summary>
	/// Depth of current type relative to root
	/// </summary>
	public byte Level { get; set; }
	/// <summary>
	/// Array flag, set to 1 if type is "Array" or "TypelessData".
	/// </summary>
	public int TypeFlags { get; set; }
	/// <summary>
	/// Type offset in <see cref="TypeTree.StringBuffer"/>
	/// </summary>
	public uint TypeStrOffset { get; set; }
	/// <summary>
	/// Name offset in <see cref="TypeTree.StringBuffer"/>
	/// </summary>
	public uint NameStrOffset { get; set; }
	/// <summary>
	/// Name of the data type. This can be the name of any substructure or a static predefined type.
	/// </summary>
	public string Type { get; set; } = "";
	/// <summary>
	/// Name of the field.
	/// </summary>
	public string Name { get; set; } = "";
	/// <summary>
	/// Size of the data value in bytes, e.g. 4 for int. -1 means that there is an array somewhere inside its hierarchy<br/>
	/// Note: The padding for the alignment is not included in the size.
	/// </summary>
	public int ByteSize { get; set; }
	/// <summary>
	/// Index of the field that is unique within a tree.<br/>
	/// Normally starts with 0 and is incremented with each additional field.
	/// </summary>
	public int Index { get; set; }
	/// <summary>
	/// Metaflags of the field
	/// </summary>
	public TransferMetaFlags MetaFlag { get; set; }
	public ulong RefTypeHash { get; set; }
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/SerializedFile.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Converters;
using AssetRipper.IO.Files.SerializedFiles.IO;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using AssetRipper.IO.Files.Streams.Smart;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace AssetRipper.IO.Files.SerializedFiles;

/// <summary>
/// Serialized files contain binary serialized objects and optional run-time type information.
/// They have file name extensions like .asset, .assets, .sharedAssets but may also have no extension at all
/// </summary>
public sealed class SerializedFile : FileBase
{
	private FileIdentifier[]? m_dependencies;
	private ObjectInfo[]? m_objects;
	private SerializedType[]? m_types;
	private LocalSerializedObjectIdentifier[]? m_scriptTypes;
	private SerializedTypeReference[]? m_refTypes;

	public FormatVersion Generation { get; private set; }
	public UnityVersion Version { get; private set; }
	public BuildTarget Platform { get; private set; }
	public TransferInstructionFlags Flags
	{
		get
		{
			TransferInstructionFlags flags;
			if (SerializedFileMetadata.HasPlatform(Generation) && Platform == BuildTarget.NoTarget)
			{
				if (FilePath.EndsWith(".unity", StringComparison.Ordinal))
				{
					flags = TransferInstructionFlags.SerializeEditorMinimalScene;
				}
				else
				{
					flags = TransferInstructionFlags.NoTransferInstructionFlags;
				}
			}
			else
			{
				flags = TransferInstructionFlags.SerializeGameRelease;
			}

			if (SpecialFileNames.IsEngineResource(Name) || (Generation < FormatVersion.Unknown_10 && SpecialFileNames.IsBuiltinExtra(Name)))
			{
				flags |= TransferInstructionFlags.IsBuiltinResourcesFile;
			}
			if (EndianType is EndianType.BigEndian)
			{
				flags |= TransferInstructionFlags.SwapEndianess;
			}
			return flags;
		}
	}
	public EndianType EndianType { get; private set; }
	public ReadOnlySpan<FileIdentifier> Dependencies => m_dependencies;
	public ReadOnlySpan<ObjectInfo> Objects => m_objects;
	public ReadOnlySpan<SerializedType> Types => m_types;
	public ReadOnlySpan<LocalSerializedObjectIdentifier> ScriptTypes => m_scriptTypes;
	public ReadOnlySpan<SerializedTypeReference> RefTypes => m_refTypes;
	public bool HasTypeTree { get; private set; }

	private static EndianType GetEndianType(SerializedFileHeader header, SerializedFileMetadata metadata)
	{
		bool swapEndianess = SerializedFileHeader.HasEndianess(header.Version) ? header.Endianess : metadata.SwapEndianess;
		return swapEndianess ? EndianType.BigEndian : EndianType.LittleEndian;
	}

	public static bool IsSerializedFile(Stream stream)
	{
		using EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
		return SerializedFileHeader.IsSerializedFileHeader(reader, stream.Length);
	}

	public override string ToString()
	{
		return NameFixed;
	}

	public override void Read(SmartStream stream)
	{
		SerializedFileHeader header = new();
		using (EndianReader reader = new EndianReader(stream, EndianType.BigEndian))
		{
			header.Read(reader);
		}
		if (SerializedFileMetadata.IsMetadataAtTheEnd(header.Version))
		{
			stream.Position = header.FileSize - header.MetadataSize;
		}
		SerializedFileMetadata metadata = new();
		metadata.Read(stream, header);

		SerializedFileMetadataConverter.CombineFormats(header.Version, metadata);

		for (int i = 0; i < metadata.Object.Length; i++)
		{
			ref ObjectInfo objectInfo = ref metadata.Object[i];
			stream.Position = header.DataOffset + objectInfo.ByteStart;
			byte[] objectData = new byte[objectInfo.ByteSize];
			stream.ReadExactly(objectData);
			objectInfo.ObjectData = objectData;
		}

		SetProperties(header, metadata);
	}

	private void SetProperties(SerializedFileHeader header, SerializedFileMetadata metadata)
	{
		Generation = header.Version;
		Version = metadata.UnityVersion;
		Platform = metadata.TargetPlatform;
		EndianType = GetEndianType(header, metadata);
		m_dependencies = metadata.Externals;
		m_objects = metadata.Object;
		m_types = metadata.Types;
		m_scriptTypes = metadata.ScriptTypes;
		m_refTypes = metadata.RefTypes;
		HasTypeTree = metadata.EnableTypeTree;
	}

	public override void Write(Stream stream)
	{
		long initialPosition = stream.Position;
		SerializedFileHeader header = new()
		{
			Version = Generation,
			Endianess = EndianType == EndianType.BigEndian,
		};
		header.Write(new EndianWriter(stream, EndianType.BigEndian));

		using SerializedWriter writer = new(stream, EndianType, Generation, Version);
		SerializedFileMetadata metadata = new()
		{
			UnityVersion = Version,
			TargetPlatform = Platform,
			Externals = m_dependencies ?? Array.Empty<FileIdentifier>(),
			Object = GetNewObjectInfoArray(m_objects),
			Types = m_types ?? Array.Empty<SerializedType>(),
			ScriptTypes = m_scriptTypes ?? Array.Empty<LocalSerializedObjectIdentifier>(),
			RefTypes = m_refTypes ?? Array.Empty<SerializedTypeReference>(),
			EnableTypeTree = HasTypeTree,
		};
		long metadataPosition;
		long metadataSize;
		long objectDataPosition;
		if (SerializedFileMetadata.IsMetadataAtTheEnd(Generation))
		{
			AlignStream(writer, 16); // objectDataPosition must be aligned to 16 bytes
			objectDataPosition = stream.Position;
			WriteObjectData(writer, metadata.Object);
			metadataPosition = stream.Position;
			metadata.Write(writer);
			metadataSize = stream.Position - metadataPosition;
		}
		else
		{
			metadataPosition = stream.Position;
			metadata.Write(writer);
			metadataSize = stream.Position - metadataPosition;
			AlignStream(writer, 16); // objectDataPosition must be aligned to 16 bytes
			objectDataPosition = stream.Position;
			WriteObjectData(writer, metadata.Object);
		}

		long finalPosition = stream.Position;

		stream.Position = initialPosition;
		header.FileSize = finalPosition - initialPosition;
		header.MetadataSize = metadataSize;
		header.DataOffset = objectDataPosition - initialPosition;
		header.Write(new EndianWriter(stream, EndianType.BigEndian));

		stream.Position = finalPosition;

		static void WriteObjectData(SerializedWriter writer, ObjectInfo[] objects)
		{
			foreach (ObjectInfo objectInfo in objects)
			{
				if (objectInfo.ObjectData is not null)
				{
					writer.Write(objectInfo.ObjectData);
				}
				AlignStream(writer, 8); // each object data must be aligned to 8 bytes
			}
		}

		static ObjectInfo[] GetNewObjectInfoArray(ObjectInfo[]? objects)
		{
			if (objects is null)
			{
				return Array.Empty<ObjectInfo>();
			}

			ObjectInfo[] newObjects = new ObjectInfo[objects.Length];
			Array.Copy(objects, newObjects, objects.Length);

			long byteStart = 0;
			for (int i = 0; i < newObjects.Length; i++)
			{
				ref ObjectInfo objectInfo = ref newObjects[i];
				objectInfo.ByteStart = byteStart;
				objectInfo.ByteSize = objectInfo.ObjectData?.Length ?? 0;

				byteStart += objectInfo.ByteSize;
				byteStart += 8 - (byteStart % 8); // each object data must be aligned to 8 bytes
			}

			return newObjects;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		static void AlignStream(SerializedWriter writer, [ConstantExpected] int alignment)
		{
			Debug.Assert(alignment > 0);
			Debug.Assert(BitOperations.IsPow2(alignment));
			long bytesSinceLastAlignment = writer.BaseStream.Position & (alignment - 1);
			if (bytesSinceLastAlignment != 0)
			{
				int padding = alignment - (int)bytesSinceLastAlignment;
				Span<byte> buffer = stackalloc byte[padding];
				buffer.Clear();
				writer.Write(buffer);
			}
		}
	}

	public static SerializedFile FromFile(string filePath, FileSystem fileSystem)
	{
		string fileName = fileSystem.Path.GetFileName(filePath);
		SmartStream stream = SmartStream.OpenRead(filePath, fileSystem);
		return SerializedFileScheme.Default.Read(stream, filePath, fileName);
	}

	public static SerializedFile FromBuilder(SerializedFileBuilder builder)
	{
		return new()
		{
			Generation = builder.Generation,
			Version = builder.Version,
			Platform = builder.Platform,
			EndianType = builder.EndianType,
			m_dependencies = builder.Dependencies.ToArray(),
			m_objects = builder.Objects.ToArray(),
			m_types = builder.Types.ToArray(),
			m_refTypes = builder.RefTypes.ToArray(),
			HasTypeTree = builder.HasTypeTree,
		};
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/SerializedFileBuilder.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.IO.Files.SerializedFiles;

public sealed class SerializedFileBuilder
{
	public FormatVersion Generation { get; set; }
	public UnityVersion Version { get; set; }
	public BuildTarget Platform { get; set; }
	public EndianType EndianType { get; set; }
	public List<FileIdentifier> Dependencies { get; } = new();
	public List<ObjectInfo> Objects { get; } = new();
	public List<SerializedType> Types { get; } = new();
	public List<SerializedTypeReference> RefTypes { get; } = new();
	public bool HasTypeTree { get; set; }

	public SerializedFile Build()
	{
		return SerializedFile.FromBuilder(this);
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/SerializedFileException.cs`:

```cs
using System.Text;

namespace AssetRipper.IO.Files.SerializedFiles;

public sealed class SerializedFileException : Exception
{
	public SerializedFileException(string message, UnityVersion version, BuildTarget platform, int classIdType, string fileName, string filePath) : base(message)
	{
		ArgumentException.ThrowIfNullOrEmpty(fileName);
		ArgumentException.ThrowIfNullOrEmpty(filePath);

		Version = version;
		Platform = platform;
		ClassIdType = classIdType;
		FileName = fileName;
		FilePath = filePath;
	}

	public SerializedFileException(string message, Exception innerException, UnityVersion version, BuildTarget platform, int classIdType, string fileName, string filePath) : base(message, innerException)
	{
		ArgumentException.ThrowIfNullOrEmpty(fileName);
		ArgumentException.ThrowIfNullOrEmpty(filePath);

		Version = version;
		Platform = platform;
		ClassIdType = classIdType;
		FileName = fileName;
		FilePath = filePath;
	}

	public override string ToString()
	{
		StringBuilder sb = new();
		sb.Append("SerializedFileException:");
		sb.Append(" v:").Append(Version.ToString());
		sb.Append(" p:").Append(Platform.ToString());
		sb.Append(" t:").Append(ClassIdType);
		sb.Append(" n:").Append(FileName).AppendLine();
		sb.Append("Path:").Append(FilePath).AppendLine();
		sb.Append("Message: ").Append(Message).AppendLine();
		if (InnerException != null)
		{
			sb.Append("Inner: ").Append(InnerException.ToString()).AppendLine();
		}
		sb.Append("StackTrace: ").Append(StackTrace);
		return sb.ToString();
	}

	public UnityVersion Version { get; }
	public BuildTarget Platform { get; }
	public int ClassIdType { get; }
	public string FileName { get; }
	public string FilePath { get; }
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/SerializedFileScheme.cs`:

```cs
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.SerializedFiles;

public sealed class SerializedFileScheme : Scheme<SerializedFile>
{
	public static SerializedFileScheme Default { get; } = new();

	public override bool CanRead(SmartStream stream)
	{
		return SerializedFile.IsSerializedFile(stream);
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TransferInstructionFlags.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles;

[Flags]
public enum TransferInstructionFlags : uint
{
	NoTransferInstructionFlags = 0x0,
	/// <summary>
	/// Should we convert PPtrs into pathID, fileID using the PerisistentManager or should we just store the memory InstanceID in the fileID?
	/// </summary>
	/// <remarks>
	/// Also called ReadWriteFromSerializedFile
	/// </remarks>
	NeedsInstanceIDRemapping = 0x1,
	/// <summary>
	/// Only serialize data needed for .meta files
	/// </summary>
	AssetMetaDataOnly = 0x2,
	/// <summary>
	/// Also called HandleDrivenProperties
	/// </summary>
	YamlGlobalPPtrReference = 0x4,
	LoadAndUnloadAssetsDuringBuild = 0x8,
	/// <summary>
	/// Should we serialize debug properties (eg. Serialize mono private variables)?
	/// </summary>
	SerializeDebugProperties = 0x10,
	/// <summary>
	/// Should we ignore Debug properties when calculating the TypeTree index?
	/// </summary>
	IgnoreDebugPropertiesForIndex = 0x20,
	/// <summary>
	/// Used by the build player to make materials cull any properties that aren't used anymore.
	/// </summary>
	BuildPlayerOnlySerializeBuildProperties = 0x40,
	/// <summary>
	/// Also called IsCloningObject
	/// </summary>
	Workaround35MeshSerializationFuckup = 0x80,
	/// <summary>
	/// Is this a game or a project file?
	/// </summary>
	SerializeGameRelease = 0x100,
	/// <summary>
	/// Should we swap endianess when reading / writing a file?
	/// </summary>
	SwapEndianess = 0x200,
	/// <summary>
	/// Should global managers be saved when writing the game build?
	/// </summary>
	/// <remarks>
	/// Also called ResolveStreamedResourceSources
	/// </remarks>
	SaveGlobalManagers = 0x400,
	DontReadObjectsFromDiskBeforeWriting = 0x800,
	/// <summary>
	/// Should we backup mono mono variables for an assembly reload?
	/// </summary>
	SerializeMonoReload = 0x1000,
	/// <summary>
	/// Can Unity fast path calculating all meta data? This lets it skip a bunch of code when serializing mono data.
	/// </summary>
	DontRequireAllMetaFlags = 0x2000,
	SerializeForPrefabSystem = 0x4000,
	/// <summary>
	/// Also called SerializeForSlimPlayer
	/// </summary>
	WarnAboutLeakedObjects = 0x8000,
	LoadPrefabAsScene = 0x10000,
	SerializeCopyPasteTransfer = 0x20000,
	/// <summary>
	/// Also called SkipSerializeToTempFile
	/// </summary>
	EditorPlayMode = 0x40000,
	BuildResourceImage = 0x80000,
	DontWriteUnityVersion = 0x100000,
	/// <summary>
	/// Binary scene files in the Editor.
	/// </summary>
	/// <remarks>
	/// Causes PrefabInstance.RootGameObject to not be included in type trees.
	/// Prefab.RootGameObject is unaffected, ie this flag only has an impact on 2018.3+.
	/// </remarks>
	SerializeEditorMinimalScene = 0x200000,
	GenerateBakedPhysixMeshes = 0x400000,
	ThreadedSerialization = 0x800000,
	IsBuiltinResourcesFile = 0x1000000,
	PerformUnloadDependencyTracking = 0x2000000,
	DisableWriteTypeTree = 0x4000000,
	AutoreplaceEditorWindow = 0x8000000,
	DontCreateMonoBehaviourScriptWrapper = 0x10000000,
	SerializeForInspector = 0x20000000,
	/// <summary>
	/// When writing with typetrees disabled, allow later Unity versions an attempt to read SerializedFile.
	/// </summary>
	SerializedAssetBundleVersion = 0x40000000,
	AllowTextSerialization = 0x80000000,
}

public static class TransferInstructionFlagsExtensions
{
	public static bool IsRelease(this TransferInstructionFlags _this)
	{
		return (_this & TransferInstructionFlags.SerializeGameRelease) != 0;
	}
	public static bool IsForPrefab(this TransferInstructionFlags _this)
	{
		return (_this & TransferInstructionFlags.SerializeForPrefabSystem) != 0;
	}
	public static bool IsEditorScene(this TransferInstructionFlags _this)
	{
		return (_this & TransferInstructionFlags.SerializeEditorMinimalScene) != 0;
	}
	public static bool IsBuiltinResources(this TransferInstructionFlags _this)
	{
		return (_this & TransferInstructionFlags.IsBuiltinResourcesFile) != 0;
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TransferMetaFlags.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles;

[Flags]
public enum TransferMetaFlags : uint
{
	NoTransferFlags = 0x0,
	/// <summary>
	/// Putting this mask in a transfer will make the variable be hidden in the property editor.
	/// </summary>
	HideInEditor = 0x1,
	Unknown1 = 0x2,
	Unknown2 = 0x4,
	Unknown3 = 0x8,
	/// <summary>
	/// Makes a variable not editable in the property editor.
	/// </summary>
	NotEditable = 0x10,
	Unknown5 = 0x20,
	/// <summary>
	/// There are 3 types of PPtrs: <see cref="StrongPPtr"/>, default (weak pointer)
	/// a Strong PPtr forces the referenced object to be cloned.
	/// A Weak PPtr doesnt clone the referenced object, but if the referenced object is being cloned anyway (eg. If another (strong) pptr references this object)
	/// this PPtr will be remapped to the cloned object.
	/// If an object referenced by a WeakPPtr is not cloned, it will stay the same when duplicating and cloning, but be NULLed when templating.
	/// </summary>
	StrongPPtr = 0x40,
	Unknown7 = 0x80,
	/// <summary>
	/// Makes an integer variable appear as a checkbox in the editor.
	/// </summary>
	TreatIntegerValueAsBoolean = 0x100,
	Unknown9 = 0x200,
	Unknown10 = 0x400,
	/// <summary>
	/// Show in simplified editor
	/// </summary>
	SimpleEditor = 0x800,
	/// <summary>
	/// For when the options of a serializer tell you to serialize debug properties (<see cref="TransferInstructionFlags.SerializeDebugProperties"/>).
	/// All debug properties have to be marked <see cref="DebugProperty"/>.
	/// Debug properties are shown in expert mode in the inspector but are not serialized normally.
	/// </summary>
	DebugProperty = 0x1000,
	Unknown13 = 0x2000,
	AlignBytes = 0x4000,
	AnyChildUsesAlignBytes = 0x8000,
	IgnoreWithInspectorUndo = 0x10000,
	Unknown17 = 0x20000,
	EditorDisplaysCharacterMap = 0x40000,
	/// <summary>
	/// Ignore this property when reading or writing .meta files
	/// </summary>
	IgnoreInMetaFiles = 0x80000,
	/// <summary>
	/// When reading meta files and this property is not present, read array entry name instead (for backwards compatibility).
	/// </summary>
	TransferAsArrayEntryNameInMetaFiles = 0x100000,
	/// <summary>
	/// When writing YAML Files, uses the flow mapping style (all properties in one line, with "{}").
	/// </summary>
	TransferUsingFlowMappingStyle = 0x200000,
	/// <summary>
	/// Tells SerializedProperty to generate bitwise difference information for this field.
	/// </summary>
	GenerateBitwiseDifferences = 0x400000,
	DontAnimate = 0x800000,
	TransferHex64 = 0x1000000,
	CharPropertyMask = 0x2000000,
	DontValidateUTF8 = 0x4000000,
	FixedBuffer = 0x8000000,
	DisallowSerializedPropertyModification = 0x10000000,
	Unknown29 = 0x20000000,
	Unknown30 = 0x40000000,
	Unknown31 = 0x80000000,
}

public static class TransferMetaFlagsExtensions
{
	public static bool IsHideInEditor(this TransferMetaFlags _this) => (_this & TransferMetaFlags.HideInEditor) != 0;
	public static bool IsNotEditable(this TransferMetaFlags _this) => (_this & TransferMetaFlags.NotEditable) != 0;
	public static bool IsStrongPPtr(this TransferMetaFlags _this) => (_this & TransferMetaFlags.StrongPPtr) != 0;
	public static bool IsTreatIntegerValueAsBoolean(this TransferMetaFlags _this) => (_this & TransferMetaFlags.TreatIntegerValueAsBoolean) != 0;
	public static bool IsSimpleEditor(this TransferMetaFlags _this) => (_this & TransferMetaFlags.SimpleEditor) != 0;
	public static bool IsDebugProperty(this TransferMetaFlags _this) => (_this & TransferMetaFlags.DebugProperty) != 0;
	public static bool IsAlignBytes(this TransferMetaFlags _this) => (_this & TransferMetaFlags.AlignBytes) != 0;
	public static bool IsAnyChildUsesAlignBytes(this TransferMetaFlags _this) => (_this & TransferMetaFlags.AnyChildUsesAlignBytes) != 0;
	public static bool IsIgnoreWithInspectorUndo(this TransferMetaFlags _this) => (_this & TransferMetaFlags.IgnoreWithInspectorUndo) != 0;
	public static bool IsEditorDisplaysCharacterMap(this TransferMetaFlags _this) => (_this & TransferMetaFlags.EditorDisplaysCharacterMap) != 0;
	public static bool IsIgnoreInMetaFiles(this TransferMetaFlags _this) => (_this & TransferMetaFlags.IgnoreInMetaFiles) != 0;
	public static bool IsTransferAsArrayEntryNameInMetaFiles(this TransferMetaFlags _this) => (_this & TransferMetaFlags.TransferAsArrayEntryNameInMetaFiles) != 0;
	public static bool IsTransferUsingFlowMappingStyle(this TransferMetaFlags _this) => (_this & TransferMetaFlags.TransferUsingFlowMappingStyle) != 0;
	public static bool IsGenerateBitwiseDifferences(this TransferMetaFlags _this) => (_this & TransferMetaFlags.GenerateBitwiseDifferences) != 0;
	public static bool IsDontAnimate(this TransferMetaFlags _this) => (_this & TransferMetaFlags.DontAnimate) != 0;
	public static bool IsTransferHex64(this TransferMetaFlags _this) => (_this & TransferMetaFlags.TransferHex64) != 0;
	public static bool IsCharPropertyMask(this TransferMetaFlags _this) => (_this & TransferMetaFlags.CharPropertyMask) != 0;
	public static bool IsDontValidateUTF8(this TransferMetaFlags _this) => (_this & TransferMetaFlags.DontValidateUTF8) != 0;
	public static bool IsFixedBuffer(this TransferMetaFlags _this) => (_this & TransferMetaFlags.FixedBuffer) != 0;
	public static bool IsDisallowSerializedPropertyModification(this TransferMetaFlags _this) => (_this & TransferMetaFlags.DisallowSerializedPropertyModification) != 0;
	public static IEnumerable<string> Split(this TransferMetaFlags flags)
	{
		if (flags == TransferMetaFlags.NoTransferFlags)
		{
			yield return nameof(TransferMetaFlags.NoTransferFlags);
		}
		else
		{
			if (flags.HasFlag(TransferMetaFlags.HideInEditor))
			{
				yield return nameof(TransferMetaFlags.HideInEditor);
			}

			if (flags.HasFlag(TransferMetaFlags.Unknown1))
			{
				yield return nameof(TransferMetaFlags.Unknown1);
			}

			if (flags.HasFlag(TransferMetaFlags.Unknown2))
			{
				yield return nameof(TransferMetaFlags.Unknown2);
			}

			if (flags.HasFlag(TransferMetaFlags.Unknown3))
			{
				yield return nameof(TransferMetaFlags.Unknown3);
			}

			if (flags.HasFlag(TransferMetaFlags.NotEditable))
			{
				yield return nameof(TransferMetaFlags.NotEditable);
			}

			if (flags.HasFlag(TransferMetaFlags.Unknown5))
			{
				yield return nameof(TransferMetaFlags.Unknown5);
			}

			if (flags.HasFlag(TransferMetaFlags.StrongPPtr))
			{
				yield return nameof(TransferMetaFlags.StrongPPtr);
			}

			if (flags.HasFlag(TransferMetaFlags.Unknown7))
			{
				yield return nameof(TransferMetaFlags.Unknown7);
			}

			if (flags.HasFlag(TransferMetaFlags.TreatIntegerValueAsBoolean))
			{
				yield return nameof(TransferMetaFlags.TreatIntegerValueAsBoolean);
			}

			if (flags.HasFlag(TransferMetaFlags.Unknown9))
			{
				yield return nameof(TransferMetaFlags.Unknown9);
			}

			if (flags.HasFlag(TransferMetaFlags.Unknown10))
			{
				yield return nameof(TransferMetaFlags.Unknown10);
			}

			if (flags.HasFlag(TransferMetaFlags.SimpleEditor))
			{
				yield return nameof(TransferMetaFlags.SimpleEditor);
			}

			if (flags.HasFlag(TransferMetaFlags.DebugProperty))
			{
				yield return nameof(TransferMetaFlags.DebugProperty);
			}

			if (flags.HasFlag(TransferMetaFlags.Unknown13))
			{
				yield return nameof(TransferMetaFlags.Unknown13);
			}

			if (flags.HasFlag(TransferMetaFlags.AlignBytes))
			{
				yield return nameof(TransferMetaFlags.AlignBytes);
			}

			if (flags.HasFlag(TransferMetaFlags.AnyChildUsesAlignBytes))
			{
				yield return nameof(TransferMetaFlags.AnyChildUsesAlignBytes);
			}

			if (flags.HasFlag(TransferMetaFlags.IgnoreWithInspectorUndo))
			{
				yield return nameof(TransferMetaFlags.IgnoreWithInspectorUndo);
			}

			if (flags.HasFlag(TransferMetaFlags.Unknown17))
			{
				yield return nameof(TransferMetaFlags.Unknown17);
			}

			if (flags.HasFlag(TransferMetaFlags.EditorDisplaysCharacterMap))
			{
				yield return nameof(TransferMetaFlags.EditorDisplaysCharacterMap);
			}

			if (flags.HasFlag(TransferMetaFlags.IgnoreInMetaFiles))
			{
				yield return nameof(TransferMetaFlags.IgnoreInMetaFiles);
			}

			if (flags.HasFlag(TransferMetaFlags.TransferAsArrayEntryNameInMetaFiles))
			{
				yield return nameof(TransferMetaFlags.TransferAsArrayEntryNameInMetaFiles);
			}

			if (flags.HasFlag(TransferMetaFlags.TransferUsingFlowMappingStyle))
			{
				yield return nameof(TransferMetaFlags.TransferUsingFlowMappingStyle);
			}

			if (flags.HasFlag(TransferMetaFlags.GenerateBitwiseDifferences))
			{
				yield return nameof(TransferMetaFlags.GenerateBitwiseDifferences);
			}

			if (flags.HasFlag(TransferMetaFlags.DontAnimate))
			{
				yield return nameof(TransferMetaFlags.DontAnimate);
			}

			if (flags.HasFlag(TransferMetaFlags.TransferHex64))
			{
				yield return nameof(TransferMetaFlags.TransferHex64);
			}

			if (flags.HasFlag(TransferMetaFlags.CharPropertyMask))
			{
				yield return nameof(TransferMetaFlags.CharPropertyMask);
			}

			if (flags.HasFlag(TransferMetaFlags.DontValidateUTF8))
			{
				yield return nameof(TransferMetaFlags.DontValidateUTF8);
			}

			if (flags.HasFlag(TransferMetaFlags.FixedBuffer))
			{
				yield return nameof(TransferMetaFlags.FixedBuffer);
			}

			if (flags.HasFlag(TransferMetaFlags.DisallowSerializedPropertyModification))
			{
				yield return nameof(TransferMetaFlags.DisallowSerializedPropertyModification);
			}

			if (flags.HasFlag(TransferMetaFlags.Unknown29))
			{
				yield return nameof(TransferMetaFlags.Unknown29);
			}

			if (flags.HasFlag(TransferMetaFlags.Unknown30))
			{
				yield return nameof(TransferMetaFlags.Unknown30);
			}

			if (flags.HasFlag(TransferMetaFlags.Unknown31))
			{
				yield return nameof(TransferMetaFlags.Unknown31);
			}
		}
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/CommonString.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;

public static class CommonString
{
	public static readonly Dictionary<uint, string> StringBuffer = new()
	{
		{0, "AABB"},
		{5, "AnimationClip"},
		{19, "AnimationCurve"},
		{34, "AnimationState"},
		{49, "Array"},
		{55, "Base"},
		{60, "BitField"},
		{69, "bitset"},
		{76, "bool"},
		{81, "char"},
		{86, "ColorRGBA"},
		{96, "Component"},
		{106, "data"},
		{111, "deque"},
		{117, "double"},
		{124, "dynamic_array"},
		{138, "FastPropertyName"},
		{155, "first"},
		{161, "float"},
		{167, "Font"},
		{172, "GameObject"},
		{183, "Generic Mono"},
		{196, "GradientNEW"},
		{208, "GUID"},
		{213, "GUIStyle"},
		{222, "int"},
		{226, "list"},
		{231, "long long"},
		{241, "map"},
		{245, "Matrix4x4f"},
		{256, "MdFour"},
		{263, "MonoBehaviour"},
		{277, "MonoScript"},
		{288, "m_ByteSize"},
		{299, "m_Curve"},
		{307, "m_EditorClassIdentifier"},
		{331, "m_EditorHideFlags"},
		{349, "m_Enabled"},
		{359, "m_ExtensionPtr"},
		{374, "m_GameObject"},
		{387, "m_Index"},
		{395, "m_IsArray"},
		{405, "m_IsStatic"},
		{416, "m_MetaFlag"},
		{427, "m_Name"},
		{434, "m_ObjectHideFlags"},
		{452, "m_PrefabInternal"},
		{469, "m_PrefabParentObject"},
		{490, "m_Script"},
		{499, "m_StaticEditorFlags"},
		{519, "m_Type"},
		{526, "m_Version"},
		{536, "Object"},
		{543, "pair"},
		{548, "PPtr<Component>"},
		{564, "PPtr<GameObject>"},
		{581, "PPtr<Material>"},
		{596, "PPtr<MonoBehaviour>"},
		{616, "PPtr<MonoScript>"},
		{633, "PPtr<Object>"},
		{646, "PPtr<Prefab>"},
		{659, "PPtr<Sprite>"},
		{672, "PPtr<TextAsset>"},
		{688, "PPtr<Texture>"},
		{702, "PPtr<Texture2D>"},
		{718, "PPtr<Transform>"},
		{734, "Prefab"},
		{741, "Quaternionf"},
		{753, "Rectf"},
		{759, "RectInt"},
		{767, "RectOffset"},
		{778, "second"},
		{785, "set"},
		{789, "short"},
		{795, "size"},
		{800, "SInt16"},
		{807, "SInt32"},
		{814, "SInt64"},
		{821, "SInt8"},
		{827, "staticvector"},
		{840, "string"},
		{847, "TextAsset"},
		{857, "TextMesh"},
		{866, "Texture"},
		{874, "Texture2D"},
		{884, "Transform"},
		{894, "TypelessData"},
		{907, "UInt16"},
		{914, "UInt32"},
		{921, "UInt64"},
		{928, "UInt8"},
		{934, "unsigned int"},
		{947, "unsigned long long"},
		{966, "unsigned short"},
		{981, "vector"},
		{988, "Vector2f"},
		{997, "Vector3f"},
		{1006, "Vector4f"},
		{1015, "m_ScriptingClassIdentifier"},
		{1042, "Gradient"},
		{1051, "Type*"},
		{1057, "int2_storage"},
		{1070, "int3_storage"},
		{1083, "BoundsInt"},
		{1093, "m_CorrespondingSourceObject"},
		{1121, "m_PrefabInstance"},
		{1138, "m_PrefabAsset"},
		{1152, "FileSize"},
		{1161, "Hash128"},
		{1169, "RenderingLayerMask"},
		{1188, "fixed_array"},
		{1200, "EntityId"},
	};
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/ITypeTree.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;

public interface ITypeTree : IReadOnlyList<ITypeTreeNode>, IEndianWritable
{
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/ITypeTreeNode.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;

public partial interface ITypeTreeNode
{
	void Read(EndianReader reader);
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/ITypeTreeNode.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;
public partial interface ITypeTreeNode : IEndianWritable
{
	/// <summary>
	/// Name of the data type. This can be the name of any substructure or a static predefined type.
	/// </summary>
	public string Type { get; set; }
	
	/// <summary>
	/// Name of the field.
	/// </summary>
	public string Name { get; set; }
	
	/// <summary>
	/// Size of the data value in bytes, e.g. 4 for int. -1 means that there is an array somewhere inside the hierarchy.
	/// </summary>
	/// <remarks>
	/// Note: The padding for the alignment is not included in the size.
	/// </remarks>
	public int ByteSize { get; set; }
	
	/// <summary>
	/// Index of the field that is unique within a tree.
	/// </summary>
	/// <remarks>
	/// Normally starts with 0 and is incremented with each additional field.
	/// </remarks>
	public int Index { get; set; }
	
	/// <summary>
	/// Array flag, set to 1 if type is "Array" or "TypelessData".
	/// </summary>
	public int TypeFlags { get; set; }
	
	/// <summary>
	/// Field type version, starts with 1 and is incremented after the type information has been significantly updated in a new release.
	/// </summary>
	/// <remarks>
	/// Equal to serializedVersion in Yaml format files
	/// </remarks>
	public int Version { get; set; }
	
	/// <summary>
	/// Meta flags of the field.
	/// </summary>
	public TransferMetaFlags MetaFlag { get; set; }
	
	/// <summary>
	/// Depth of current type relative to root.
	/// </summary>
	public byte Level { get; set; }
	
	/// <summary>
	/// Type offset in the string buffer.
	/// </summary>
	public uint TypeStrOffset { get; set; }
	
	/// <summary>
	/// Name offset in the string buffer.
	/// </summary>
	public uint NameStrOffset { get; set; }
	
	public ulong RefTypeHash { get; set; }
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/ReadOnlyList.cs`:

```cs
using System.Collections;

namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;

internal sealed class ReadOnlyList<TSource, TOut> : IReadOnlyList<TOut> where TSource : TOut
{
	public ReadOnlyList(IReadOnlyList<TSource> source)
	{
		this.Source = source ?? throw new ArgumentNullException(nameof(source));
	}

	public TOut this[int index] => Source[index];

	public int Count => Source.Count;

	public IReadOnlyList<TSource> Source { get; }

	public IEnumerator<TOut> GetEnumerator()
	{
		foreach (TSource sourceElement in Source)
		{
			yield return sourceElement;
		}
	}

	IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/TypeTree.cs`:

```cs
using AssetRipper.IO.Endian;
using System.Collections;

namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;

public abstract class TypeTree<T> : ITypeTree where T : ITypeTreeNode, new()
{
	public List<T> Nodes { get; } = new();
	public byte[] StringBuffer { get; set; } = Array.Empty<byte>();

	public ITypeTreeNode this[int index] => Nodes[index];

	public int Count => Nodes.Count;

	public IEnumerator<ITypeTreeNode> GetEnumerator()
	{
		foreach (T node in Nodes)
		{
			yield return node;
		}
	}

	IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

	public abstract void Read(EndianReader reader);

	public abstract void Write(EndianWriter writer);

	public string Dump() => TypeTreeDumper.Dump(this);
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/TypeTreeDumper.cs`:

```cs
using System.Text;

namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;

public static class TypeTreeDumper
{
	public static string Dump(ITypeTree tree)
	{
		StringBuilder sb = new();
		tree.ToString(sb);
		return sb.ToString();
	}

	private static StringBuilder ToString(this ITypeTree tree, StringBuilder sb)
	{
		foreach (ITypeTreeNode node in tree)
		{
			node.ToString(sb).AppendLine();
		}
		return sb;
	}

	private static StringBuilder ToString(this ITypeTreeNode node, StringBuilder sb)
	{
		sb.Append('\t', node.Level).Append(node.Type).Append(' ').Append(node.Name);
		sb.Append($" // ByteSize{"{"}{node.ByteSize:x}{"}"}, Index{"{"}{node.Index:x}{"}"}, Version{"{"}{node.Version:x}{"}"}, IsArray{{{node.TypeFlags}}}, MetaFlag{"{"}{(uint)node.MetaFlag:x}{"}"}");
		return sb;
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/TypeTreeNode_1.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;
public partial record class TypeTreeNode_1 : ITypeTreeNode
{
	/// <summary>
	/// Name of the data type. This can be the name of any substructure or a static predefined type.
	/// </summary>
	private string m_Type = string.Empty;
	
	/// <summary>
	/// Name of the data type. This can be the name of any substructure or a static predefined type.
	/// </summary>
	public string Type
	{
		get => m_Type;
		set
		{
			m_Type = value;
			OnTypeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Type"/> is set.
	/// </summary>
	partial void OnTypeAssignment(string value);
	
	/// <summary>
	/// Name of the field.
	/// </summary>
	private string m_Name = string.Empty;
	
	/// <summary>
	/// Name of the field.
	/// </summary>
	public string Name
	{
		get => m_Name;
		set
		{
			m_Name = value;
			OnNameAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Name"/> is set.
	/// </summary>
	partial void OnNameAssignment(string value);
	
	/// <summary>
	/// Size of the data value in bytes, e.g. 4 for int. -1 means that there is an array somewhere inside the hierarchy.
	/// </summary>
	/// <remarks>
	/// Note: The padding for the alignment is not included in the size.
	/// </remarks>
	private int m_ByteSize = new();
	
	/// <summary>
	/// Size of the data value in bytes, e.g. 4 for int. -1 means that there is an array somewhere inside the hierarchy.
	/// </summary>
	/// <remarks>
	/// Note: The padding for the alignment is not included in the size.
	/// </remarks>
	public int ByteSize
	{
		get => m_ByteSize;
		set
		{
			m_ByteSize = value;
			OnByteSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteSize"/> is set.
	/// </summary>
	partial void OnByteSizeAssignment(int value);
	
	/// <summary>
	/// Index of the field that is unique within a tree.
	/// </summary>
	/// <remarks>
	/// Normally starts with 0 and is incremented with each additional field.
	/// </remarks>
	private int m_Index = new();
	
	/// <summary>
	/// Index of the field that is unique within a tree.
	/// </summary>
	/// <remarks>
	/// Normally starts with 0 and is incremented with each additional field.
	/// </remarks>
	public int Index
	{
		get => m_Index;
		set
		{
			m_Index = value;
			OnIndexAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Index"/> is set.
	/// </summary>
	partial void OnIndexAssignment(int value);
	
	/// <summary>
	/// Array flag, set to 1 if type is "Array" or "TypelessData".
	/// </summary>
	private int m_TypeFlags = new();
	
	/// <summary>
	/// Array flag, set to 1 if type is "Array" or "TypelessData".
	/// </summary>
	public int TypeFlags
	{
		get => m_TypeFlags;
		set
		{
			m_TypeFlags = value;
			OnTypeFlagsAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="TypeFlags"/> is set.
	/// </summary>
	partial void OnTypeFlagsAssignment(int value);
	
	/// <summary>
	/// Field type version, starts with 1 and is incremented after the type information has been significantly updated in a new release.
	/// </summary>
	/// <remarks>
	/// Equal to serializedVersion in Yaml format files
	/// </remarks>
	private int m_Version = new();
	
	/// <summary>
	/// Field type version, starts with 1 and is incremented after the type information has been significantly updated in a new release.
	/// </summary>
	/// <remarks>
	/// Equal to serializedVersion in Yaml format files
	/// </remarks>
	public int Version
	{
		get => m_Version;
		set
		{
			m_Version = value;
			OnVersionAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Version"/> is set.
	/// </summary>
	partial void OnVersionAssignment(int value);
	
	/// <summary>
	/// Meta flags of the field.
	/// </summary>
	private uint m_MetaFlag = new();
	
	/// <summary>
	/// Meta flags of the field.
	/// </summary>
	public TransferMetaFlags MetaFlag
	{
		get => (TransferMetaFlags)m_MetaFlag;
		set
		{
			m_MetaFlag = (uint)value;
			OnMetaFlagAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="MetaFlag"/> is set.
	/// </summary>
	partial void OnMetaFlagAssignment(TransferMetaFlags value);
	
	/// <summary>
	/// Depth of current type relative to root.
	/// </summary>
	private byte m_Level = new();
	
	/// <summary>
	/// Depth of current type relative to root.
	/// </summary>
	public byte Level
	{
		get => m_Level;
		set
		{
			m_Level = value;
			OnLevelAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Level"/> is set.
	/// </summary>
	partial void OnLevelAssignment(byte value);
	
	/// <summary>
	/// Type offset in the string buffer.
	/// </summary>
	public uint TypeStrOffset
	{
		get => default;
		set { }
	}
	
	/// <summary>
	/// Name offset in the string buffer.
	/// </summary>
	public uint NameStrOffset
	{
		get => default;
		set { }
	}
	
	public ulong RefTypeHash
	{
		get => default;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		m_Type = reader.ReadStringZeroTerm();
		m_Name = reader.ReadStringZeroTerm();
		m_ByteSize = reader.ReadInt32();
		m_Index = reader.ReadInt32();
		m_TypeFlags = reader.ReadInt32();
		m_Version = reader.ReadInt32();
		m_MetaFlag = reader.ReadUInt32();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.WriteStringZeroTerm(m_Type);
		writer.WriteStringZeroTerm(m_Name);
		writer.Write(m_ByteSize);
		writer.Write(m_Index);
		writer.Write(m_TypeFlags);
		writer.Write(m_Version);
		writer.Write(m_MetaFlag);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/TypeTreeNode_10.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;
public partial record class TypeTreeNode_10 : ITypeTreeNode
{
	/// <summary>
	/// Field type version, starts with 1 and is incremented after the type information has been significantly updated in a new release.
	/// </summary>
	/// <remarks>
	/// Equal to serializedVersion in Yaml format files
	/// </remarks>
	private ushort m_Version = new();
	
	/// <summary>
	/// Field type version, starts with 1 and is incremented after the type information has been significantly updated in a new release.
	/// </summary>
	/// <remarks>
	/// Equal to serializedVersion in Yaml format files
	/// </remarks>
	public int Version
	{
		get => m_Version;
		set
		{
			m_Version = (ushort)value;
			OnVersionAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Version"/> is set.
	/// </summary>
	partial void OnVersionAssignment(int value);
	
	/// <summary>
	/// Depth of current type relative to root.
	/// </summary>
	private byte m_Level = new();
	
	/// <summary>
	/// Depth of current type relative to root.
	/// </summary>
	public byte Level
	{
		get => m_Level;
		set
		{
			m_Level = value;
			OnLevelAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Level"/> is set.
	/// </summary>
	partial void OnLevelAssignment(byte value);
	
	/// <summary>
	/// Array flag, set to 1 if type is "Array" or "TypelessData".
	/// </summary>
	private byte m_TypeFlags = new();
	
	/// <summary>
	/// Array flag, set to 1 if type is "Array" or "TypelessData".
	/// </summary>
	public int TypeFlags
	{
		get => m_TypeFlags;
		set
		{
			m_TypeFlags = (byte)value;
			OnTypeFlagsAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="TypeFlags"/> is set.
	/// </summary>
	partial void OnTypeFlagsAssignment(int value);
	
	/// <summary>
	/// Type offset in the string buffer.
	/// </summary>
	private uint m_TypeStrOffset = new();
	
	/// <summary>
	/// Type offset in the string buffer.
	/// </summary>
	public uint TypeStrOffset
	{
		get => m_TypeStrOffset;
		set
		{
			m_TypeStrOffset = value;
			OnTypeStrOffsetAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="TypeStrOffset"/> is set.
	/// </summary>
	partial void OnTypeStrOffsetAssignment(uint value);
	
	/// <summary>
	/// Name offset in the string buffer.
	/// </summary>
	private uint m_NameStrOffset = new();
	
	/// <summary>
	/// Name offset in the string buffer.
	/// </summary>
	public uint NameStrOffset
	{
		get => m_NameStrOffset;
		set
		{
			m_NameStrOffset = value;
			OnNameStrOffsetAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="NameStrOffset"/> is set.
	/// </summary>
	partial void OnNameStrOffsetAssignment(uint value);
	
	/// <summary>
	/// Size of the data value in bytes, e.g. 4 for int. -1 means that there is an array somewhere inside the hierarchy.
	/// </summary>
	/// <remarks>
	/// Note: The padding for the alignment is not included in the size.
	/// </remarks>
	private int m_ByteSize = new();
	
	/// <summary>
	/// Size of the data value in bytes, e.g. 4 for int. -1 means that there is an array somewhere inside the hierarchy.
	/// </summary>
	/// <remarks>
	/// Note: The padding for the alignment is not included in the size.
	/// </remarks>
	public int ByteSize
	{
		get => m_ByteSize;
		set
		{
			m_ByteSize = value;
			OnByteSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteSize"/> is set.
	/// </summary>
	partial void OnByteSizeAssignment(int value);
	
	/// <summary>
	/// Index of the field that is unique within a tree.
	/// </summary>
	/// <remarks>
	/// Normally starts with 0 and is incremented with each additional field.
	/// </remarks>
	private int m_Index = new();
	
	/// <summary>
	/// Index of the field that is unique within a tree.
	/// </summary>
	/// <remarks>
	/// Normally starts with 0 and is incremented with each additional field.
	/// </remarks>
	public int Index
	{
		get => m_Index;
		set
		{
			m_Index = value;
			OnIndexAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Index"/> is set.
	/// </summary>
	partial void OnIndexAssignment(int value);
	
	/// <summary>
	/// Meta flags of the field.
	/// </summary>
	private uint m_MetaFlag = new();
	
	/// <summary>
	/// Meta flags of the field.
	/// </summary>
	public TransferMetaFlags MetaFlag
	{
		get => (TransferMetaFlags)m_MetaFlag;
		set
		{
			m_MetaFlag = (uint)value;
			OnMetaFlagAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="MetaFlag"/> is set.
	/// </summary>
	partial void OnMetaFlagAssignment(TransferMetaFlags value);
	
	/// <summary>
	/// Name of the data type. This can be the name of any substructure or a static predefined type.
	/// </summary>
	private string m_Type = string.Empty;
	
	/// <summary>
	/// Name of the data type. This can be the name of any substructure or a static predefined type.
	/// </summary>
	public string Type
	{
		get => m_Type;
		set
		{
			m_Type = value;
			OnTypeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Type"/> is set.
	/// </summary>
	partial void OnTypeAssignment(string value);
	
	/// <summary>
	/// Name of the field.
	/// </summary>
	private string m_Name = string.Empty;
	
	/// <summary>
	/// Name of the field.
	/// </summary>
	public string Name
	{
		get => m_Name;
		set
		{
			m_Name = value;
			OnNameAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Name"/> is set.
	/// </summary>
	partial void OnNameAssignment(string value);
	
	public ulong RefTypeHash
	{
		get => default;
		set { }
	}
	
	public void Read(EndianReader reader)
	{
		m_Version = reader.ReadUInt16();
		m_Level = reader.ReadByte();
		m_TypeFlags = reader.ReadByte();
		m_TypeStrOffset = reader.ReadUInt32();
		m_NameStrOffset = reader.ReadUInt32();
		m_ByteSize = reader.ReadInt32();
		m_Index = reader.ReadInt32();
		m_MetaFlag = reader.ReadUInt32();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.Write(m_Version);
		writer.Write(m_Level);
		writer.Write(m_TypeFlags);
		writer.Write(m_TypeStrOffset);
		writer.Write(m_NameStrOffset);
		writer.Write(m_ByteSize);
		writer.Write(m_Index);
		writer.Write(m_MetaFlag);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/TypeTreeNode_19.g.cs`:

```cs
// Auto-generated code. Do not modify manually.
using AssetRipper.IO.Endian;
namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;
public partial record class TypeTreeNode_19 : ITypeTreeNode
{
	/// <summary>
	/// Field type version, starts with 1 and is incremented after the type information has been significantly updated in a new release.
	/// </summary>
	/// <remarks>
	/// Equal to serializedVersion in Yaml format files
	/// </remarks>
	private ushort m_Version = new();
	
	/// <summary>
	/// Field type version, starts with 1 and is incremented after the type information has been significantly updated in a new release.
	/// </summary>
	/// <remarks>
	/// Equal to serializedVersion in Yaml format files
	/// </remarks>
	public int Version
	{
		get => m_Version;
		set
		{
			m_Version = (ushort)value;
			OnVersionAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Version"/> is set.
	/// </summary>
	partial void OnVersionAssignment(int value);
	
	/// <summary>
	/// Depth of current type relative to root.
	/// </summary>
	private byte m_Level = new();
	
	/// <summary>
	/// Depth of current type relative to root.
	/// </summary>
	public byte Level
	{
		get => m_Level;
		set
		{
			m_Level = value;
			OnLevelAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Level"/> is set.
	/// </summary>
	partial void OnLevelAssignment(byte value);
	
	/// <summary>
	/// Array flag, set to 1 if type is "Array" or "TypelessData".
	/// </summary>
	private byte m_TypeFlags = new();
	
	/// <summary>
	/// Array flag, set to 1 if type is "Array" or "TypelessData".
	/// </summary>
	public int TypeFlags
	{
		get => m_TypeFlags;
		set
		{
			m_TypeFlags = (byte)value;
			OnTypeFlagsAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="TypeFlags"/> is set.
	/// </summary>
	partial void OnTypeFlagsAssignment(int value);
	
	/// <summary>
	/// Type offset in the string buffer.
	/// </summary>
	private uint m_TypeStrOffset = new();
	
	/// <summary>
	/// Type offset in the string buffer.
	/// </summary>
	public uint TypeStrOffset
	{
		get => m_TypeStrOffset;
		set
		{
			m_TypeStrOffset = value;
			OnTypeStrOffsetAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="TypeStrOffset"/> is set.
	/// </summary>
	partial void OnTypeStrOffsetAssignment(uint value);
	
	/// <summary>
	/// Name offset in the string buffer.
	/// </summary>
	private uint m_NameStrOffset = new();
	
	/// <summary>
	/// Name offset in the string buffer.
	/// </summary>
	public uint NameStrOffset
	{
		get => m_NameStrOffset;
		set
		{
			m_NameStrOffset = value;
			OnNameStrOffsetAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="NameStrOffset"/> is set.
	/// </summary>
	partial void OnNameStrOffsetAssignment(uint value);
	
	/// <summary>
	/// Size of the data value in bytes, e.g. 4 for int. -1 means that there is an array somewhere inside the hierarchy.
	/// </summary>
	/// <remarks>
	/// Note: The padding for the alignment is not included in the size.
	/// </remarks>
	private int m_ByteSize = new();
	
	/// <summary>
	/// Size of the data value in bytes, e.g. 4 for int. -1 means that there is an array somewhere inside the hierarchy.
	/// </summary>
	/// <remarks>
	/// Note: The padding for the alignment is not included in the size.
	/// </remarks>
	public int ByteSize
	{
		get => m_ByteSize;
		set
		{
			m_ByteSize = value;
			OnByteSizeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="ByteSize"/> is set.
	/// </summary>
	partial void OnByteSizeAssignment(int value);
	
	/// <summary>
	/// Index of the field that is unique within a tree.
	/// </summary>
	/// <remarks>
	/// Normally starts with 0 and is incremented with each additional field.
	/// </remarks>
	private int m_Index = new();
	
	/// <summary>
	/// Index of the field that is unique within a tree.
	/// </summary>
	/// <remarks>
	/// Normally starts with 0 and is incremented with each additional field.
	/// </remarks>
	public int Index
	{
		get => m_Index;
		set
		{
			m_Index = value;
			OnIndexAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Index"/> is set.
	/// </summary>
	partial void OnIndexAssignment(int value);
	
	/// <summary>
	/// Meta flags of the field.
	/// </summary>
	private uint m_MetaFlag = new();
	
	/// <summary>
	/// Meta flags of the field.
	/// </summary>
	public TransferMetaFlags MetaFlag
	{
		get => (TransferMetaFlags)m_MetaFlag;
		set
		{
			m_MetaFlag = (uint)value;
			OnMetaFlagAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="MetaFlag"/> is set.
	/// </summary>
	partial void OnMetaFlagAssignment(TransferMetaFlags value);
	
	private ulong m_RefTypeHash = new();
	
	public ulong RefTypeHash
	{
		get => m_RefTypeHash;
		set
		{
			m_RefTypeHash = value;
			OnRefTypeHashAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="RefTypeHash"/> is set.
	/// </summary>
	partial void OnRefTypeHashAssignment(ulong value);
	
	/// <summary>
	/// Name of the data type. This can be the name of any substructure or a static predefined type.
	/// </summary>
	private string m_Type = string.Empty;
	
	/// <summary>
	/// Name of the data type. This can be the name of any substructure or a static predefined type.
	/// </summary>
	public string Type
	{
		get => m_Type;
		set
		{
			m_Type = value;
			OnTypeAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Type"/> is set.
	/// </summary>
	partial void OnTypeAssignment(string value);
	
	/// <summary>
	/// Name of the field.
	/// </summary>
	private string m_Name = string.Empty;
	
	/// <summary>
	/// Name of the field.
	/// </summary>
	public string Name
	{
		get => m_Name;
		set
		{
			m_Name = value;
			OnNameAssignment(value);
		}
	}
	
	/// <summary>
	/// Called when <see cref="Name"/> is set.
	/// </summary>
	partial void OnNameAssignment(string value);
	
	public void Read(EndianReader reader)
	{
		m_Version = reader.ReadUInt16();
		m_Level = reader.ReadByte();
		m_TypeFlags = reader.ReadByte();
		m_TypeStrOffset = reader.ReadUInt32();
		m_NameStrOffset = reader.ReadUInt32();
		m_ByteSize = reader.ReadInt32();
		m_Index = reader.ReadInt32();
		m_MetaFlag = reader.ReadUInt32();
		m_RefTypeHash = reader.ReadUInt64();
		OnReadFinished(reader);
	}
	
	/// <summary>
	/// Called when <see cref="Read"/> is finished.
	/// </summary>
	partial void OnReadFinished(EndianReader reader);
	
	public void Write(EndianWriter writer)
	{
		writer.Write(m_Version);
		writer.Write(m_Level);
		writer.Write(m_TypeFlags);
		writer.Write(m_TypeStrOffset);
		writer.Write(m_NameStrOffset);
		writer.Write(m_ByteSize);
		writer.Write(m_Index);
		writer.Write(m_MetaFlag);
		writer.Write(m_RefTypeHash);
		OnWriteFinished(writer);
	}
	
	/// <summary>
	/// Called when <see cref="Write"/> is finished.
	/// </summary>
	partial void OnWriteFinished(EndianWriter writer);
	
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/TypeTree_1.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;

public sealed class TypeTree_1 : TypeTree<TypeTreeNode_1>
{
	public override void Read(EndianReader reader)
	{
		Nodes.Clear();
		ReadTreeNode(reader, Nodes, 0);
	}

	public override void Write(EndianWriter writer)
	{
		int index = 0;
		WriteTreeNode(writer, ref index);
	}

	private static void ReadTreeNode(EndianReader reader, List<TypeTreeNode_1> nodes, byte depth)
	{
		TypeTreeNode_1 node = new();
		node.Read(reader);
		node.Level = depth;
		nodes.Add(node);

		int childCount = reader.ReadInt32();
		for (int i = 0; i < childCount; i++)
		{
			ReadTreeNode(reader, nodes, (byte)(depth + 1));
		}
	}

	private void WriteTreeNode(EndianWriter writer, ref int index)
	{
		Nodes[index].Write(writer);
		int childCount = GetChildCount(index);
		writer.Write(childCount);
		index++;
		for (int i = 0; i < childCount; i++)
		{
			WriteTreeNode(writer, ref index);
		}
	}

	private int GetChildCount(int index)
	{
		int count = 0;
		int depth = Nodes[index].Level + 1;
		for (int i = index + 1; i < Nodes.Count; i++)
		{
			int nodeDepth = Nodes[i].Level;
			if (nodeDepth < depth)
			{
				break;
			}
			if (nodeDepth == depth)
			{
				count++;
			}
		}
		return count;
	}
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/TypeTree_10.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;

public sealed class TypeTree_10 : TypeTree_New<TypeTreeNode_10>
{
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/TypeTree_19.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;

public sealed class TypeTree_19 : TypeTree_New<TypeTreeNode_19>
{
}

```

`Source/AssetRipper.IO.Files/SerializedFiles/TypeTrees/TypeTree_New.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.SerializedFiles.TypeTrees;

/// <summary>
/// The base class for <see cref="ITypeTree"/>s using the new format, ie <see cref="FormatVersion.Unknown_10"/> and higher.
/// </summary>
/// <typeparam name="T"></typeparam>
public abstract class TypeTree_New<T> : TypeTree<T> where T : ITypeTreeNode, new()
{
	public sealed override void Read(EndianReader reader)
	{
		int nodesCount = reader.ReadInt32();
		if (nodesCount < 0)
		{
			throw new InvalidDataException($"Node count cannot be negative: {nodesCount}");
		}

		int stringBufferSize = reader.ReadInt32();
		if (stringBufferSize < 0)
		{
			throw new InvalidDataException($"String buffer size cannot be negative: {stringBufferSize}");
		}

		Nodes.Clear();
		Nodes.Capacity = nodesCount;
		for (int i = 0; i < nodesCount; i++)
		{
			T node = new();
			node.Read(reader);
			Nodes.Add(node);
		}
		if (stringBufferSize == 0)
		{
			StringBuffer = Array.Empty<byte>();
		}
		else
		{
			StringBuffer = new byte[stringBufferSize];
			reader.Read(StringBuffer, 0, StringBuffer.Length);
		}

		SetNamesFromBuffer();
	}

	public sealed override void Write(EndianWriter writer)
	{
		writer.Write(Nodes.Count);
		writer.Write(StringBuffer.Length);
		foreach (T node in Nodes)
		{
			node.Write(writer);
		}
		writer.Write(StringBuffer, 0, StringBuffer.Length);
	}

	private void SetNamesFromBuffer()
	{
		if (StringBuffer.Length > 0)
		{
			Dictionary<uint, string> customTypes = new();
			using (MemoryStream stream = new MemoryStream(StringBuffer))
			{
				using EndianReader reader = new EndianReader(stream, EndianType.LittleEndian);
				while (stream.Position < stream.Length)
				{
					uint position = (uint)stream.Position;
					string name = reader.ReadStringZeroTerm();
					customTypes.Add(position, name);
				}
			}

			foreach (T node in Nodes)
			{
				node.Type = GetTypeName(customTypes, node.TypeStrOffset);
				node.Name = GetTypeName(customTypes, node.NameStrOffset);
			}
		}
	}

	private static string GetTypeName(Dictionary<uint, string> customTypes, uint value)
	{
		bool isCustomType = (value & 0x80000000) == 0;
		if (isCustomType)
		{
			return customTypes[value];
		}
		else
		{
			uint offset = value & ~0x80000000;
			if (CommonString.StringBuffer.TryGetValue(offset, out string? nodeTypeName))
			{
				return nodeTypeName;
			}
			else
			{
				throw new Exception($"Unsupported asset class type name '{offset}''");
			}
		}
	}
}

```

`Source/AssetRipper.IO.Files/SpecialFileNames.cs`:

```cs
namespace AssetRipper.IO.Files;

public static class SpecialFileNames
{
	public static bool IsEngineResource(string? fileName)
	{
		return IsDefaultResource(fileName) || IsEditorResource(fileName);
	}

	public static bool IsDefaultResource(string? fileName)
	{
		return fileName is DefaultResourceName1 or DefaultResourceName2;
	}

	public static bool IsEditorResource(string? fileName)
	{
		return fileName is EditorResourceName;
	}

	public static bool IsBuiltinExtra(string? fileName)
	{
		return fileName is BuiltinExtraName1 or BuiltinExtraName2;
	}

	public static bool IsDefaultResourceOrBuiltinExtra(string? fileName)
	{
		return IsDefaultResource(fileName) || IsBuiltinExtra(fileName);
	}

	public static bool IsEngineGeneratedF(string? fileName)
	{
		return fileName is EngineGeneratedF;
	}

	public static string FixFileIdentifier(string name)
	{
		name = name.ToLowerInvariant();
		name = FixDependencyName(name);
		name = FixResourcePath(name);
		return name;
	}

	public static string FixDependencyName(string dependency)
	{
		if (dependency.StartsWith(LibraryFolder, StringComparison.Ordinal))
		{
			return dependency.Substring(LibraryFolder.Length);
		}
		else if (dependency.StartsWith(ResourcesFolder, StringComparison.Ordinal))
		{
			return dependency.Substring(ResourcesFolder.Length);
		}
		return dependency;
	}

	public static string FixResourcePath(string resourcePath)
	{
		const string archivePrefix = "archive:/";
		if (resourcePath.StartsWith(archivePrefix, StringComparison.Ordinal))
		{
			return Path.GetFileName(resourcePath);
		}
		else
		{
			return resourcePath;
		}
	}

	/// <summary>
	/// Remove .dll extension from the assembly name and add the "Assembly - " prefix if appropriate.
	/// </summary>
	/// <param name="assembly">An assembly name.</param>
	/// <returns>A new string if changed, otherwise the original string.</returns>
	public static string FixAssemblyName(string assembly)
	{
		return RemoveAssemblyFileExtension(IsAssemblyIdentifier(assembly) ? $"Assembly - {assembly}" : assembly);
	}

	/// <summary>
	/// Remove .dll extension from the assembly name.
	/// </summary>
	/// <param name="assembly">An assembly name.</param>
	/// <returns>A new string if changed, otherwise the original string.</returns>
	public static string RemoveAssemblyFileExtension(string assembly)
	{
		return assembly.EndsWith(AssemblyExtension, StringComparison.Ordinal) ? assembly[..^AssemblyExtension.Length] : assembly;
	}

	public static string AddAssemblyFileExtension(string assembly)
	{
		return assembly.EndsWith(AssemblyExtension, StringComparison.Ordinal) ? assembly : assembly + AssemblyExtension;
	}

	public static bool IsProjectAssembly(string assembly)
	{
		const string PrefixName = "Assembly";
		return assembly.StartsWith($"{PrefixName} - ", StringComparison.Ordinal) || assembly.StartsWith($"{PrefixName}-", StringComparison.Ordinal);
	}

	private static bool IsAssemblyIdentifier(string assembly)
	{
		return assembly
			is "Boo"
			or "Boo - first pass"
			or "CSharp"
			or "CSharp - first pass"
			or "UnityScript"
			or "UnityScript - first pass";
	}

	public const string LibraryFolder = "library/";
	public const string ResourcesFolder = "resources/";
	public const string DefaultResourceName1 = "unity default resources";
	public const string DefaultResourceName2 = "unity_default_resources";
	public const string EditorResourceName = "unity editor resources";
	public const string BuiltinExtraName1 = "unity builtin extra";
	public const string BuiltinExtraName2 = "unity_builtin_extra";
	public const string EngineGeneratedF = "0000000000000000f000000000000000";
	public const string AssemblyExtension = ".dll";
}

```

`Source/AssetRipper.IO.Files/Streams/MultiFileStream.cs`:

```cs
using System.Text.RegularExpressions;

namespace AssetRipper.IO.Files.Streams;

public sealed partial class MultiFileStream : Stream
{
	private MultiFileStream(IEnumerable<Stream> streams)
	{
		m_streams = streams.ToArray();
		if (m_streams.Count == 0)
		{
			throw new ArgumentException("No streams were provided.", nameof(streams));
		}

		foreach (Stream stream in m_streams)
		{
			if (!stream.CanSeek)
			{
				throw new Exception($"Stream {stream} isn't seekable");
			}
		}

		Length = m_streams.Sum(t => t.Length);
		CanRead = m_streams.All(t => t.CanRead);
		CanWrite = m_streams.All(t => t.CanWrite);
		UpdateCurrentStream();
	}

	~MultiFileStream()
	{
		Dispose(false);
	}

	/// <summary>
	/// Determines if the path could be part of a multi file
	/// </summary>
	/// <param name="path">The path to check</param>
	/// <returns>True if the path matches the multi file regex</returns>
	public static bool IsMultiFile(string path)
	{
		return SplitFileRegex.IsMatch(path);
	}

	public static bool Exists(string path, FileSystem fileSystem)
	{
		if (IsMultiFile(path))
		{
			SplitPathWithoutExtension(path, fileSystem, out string directory, out string file);
			return Exists(directory, file, fileSystem);
		}
		else if (fileSystem.File.Exists(path))
		{
			return true;
		}
		else
		{
			SplitPath(path, fileSystem, out string directory, out string file, true);
			if (string.IsNullOrEmpty(file))
			{
				return false;
			}
			else
			{
				return Exists(directory, file, fileSystem);
			}
		}
	}

	public static Stream OpenRead(string path, FileSystem fileSystem)
	{
		if (IsMultiFile(path))
		{
			SplitPathWithoutExtension(path, fileSystem, out string directory, out string file);
			return OpenRead(directory, file, fileSystem);
		}
		else if (fileSystem.File.Exists(path))
		{
			return fileSystem.File.OpenRead(path);
		}
		else
		{
			SplitPath(path, fileSystem, out string directory, out string file);
			return OpenRead(directory, file, fileSystem);
		}
	}

	public static string GetFilePath(string path)
	{
		if (IsMultiFile(path))
		{
			int index = path.LastIndexOf('.');
			return path[..index];
		}
		return path;
	}

	public static string GetFileName(string path)
	{
		if (IsMultiFile(path))
		{
			return Path.GetFileNameWithoutExtension(path);
		}
		return Path.GetFileName(path);
	}

	public static string[] GetFiles(string path, FileSystem fileSystem)
	{
		if (IsMultiFile(path))
		{
			SplitPathWithoutExtension(path, fileSystem, out string directory, out string file);
			return GetFiles(directory, file, fileSystem);
		}

		if (fileSystem.File.Exists(path))
		{
			return [path];
		}
		return [];
	}

	public static bool IsNameEquals(string fileName, string compare)
	{
		fileName = GetFileName(fileName);
		return fileName == compare;
	}

	/// <summary>
	/// Determines if a multi file exists
	/// </summary>
	/// <param name="dirPath">The directory containing the multi file</param>
	/// <param name="fileName">The name of the multi file without the split extension</param>
	/// <returns>True if a valid multi file exists in that directory with that name</returns>
	private static bool Exists(string dirPath, string fileName, FileSystem fileSystem)
	{
		string filePath = fileSystem.Path.Join(dirPath, fileName);
		string splitFilePath = filePath + ".split";

		string[] splitFiles = GetFiles(dirPath, fileName, fileSystem);
		if (splitFiles.Length == 0)
		{
			return false;
		}

		for (int i = 0; i < splitFiles.Length; i++)
		{
			string indexFileName = splitFilePath + i;
			if (!splitFiles.Contains(indexFileName))
			{
				return false;
			}
		}
		return true;
	}

	private static string[] GetFiles(string dirPath, string fileName, FileSystem fileSystem)
	{
		if (!fileSystem.Directory.Exists(dirPath))
		{
			return [];
		}

		string filePatern = fileName + ".split*";
		return fileSystem.Directory.GetFiles(dirPath, filePatern);
	}

	private static Stream OpenRead(string dirPath, string fileName, FileSystem fileSystem)
	{
		string filePath = fileSystem.Path.Join(dirPath, fileName);
		string splitFilePath = filePath + ".split";

		string[] splitFiles = GetFiles(dirPath, fileName, fileSystem);
		for (int i = 0; i < splitFiles.Length; i++)
		{
			string indexFileName = splitFilePath + i;
			if (!splitFiles.Contains(indexFileName))
			{
				throw new Exception($"Try to open splited file part '{filePath}' but file part '{indexFileName}' wasn't found");
			}
		}

		splitFiles = splitFiles.OrderBy(t => t, SplitNameComparer.Instance).ToArray();
		Stream[] streams = new Stream[splitFiles.Length];
		try
		{
			for (int i = 0; i < splitFiles.Length; i++)
			{
				Stream stream = fileSystem.File.OpenRead(splitFiles[i]);
				streams[i] = stream;
			}

			return new MultiFileStream(streams);
		}
		catch
		{
			foreach (Stream stream in streams)
			{
				if (stream == null)
				{
					break;
				}
				stream.Dispose();
			}
			throw;
		}
	}

	private static void SplitPath(string path, FileSystem fileSystem, out string directory, out string file) => SplitPath(path, fileSystem, out directory, out file, false);
	private static void SplitPath(string path, FileSystem fileSystem, out string directory, out string file, bool allowNullReturn)
	{
		directory = fileSystem.Path.GetDirectoryName(path) ?? throw new Exception("Could not get directory name");
		directory = string.IsNullOrEmpty(directory) ? "." : directory;
		file = fileSystem.Path.GetFileName(path);
		if (string.IsNullOrEmpty(file) && !allowNullReturn)
		{
			throw new Exception($"Can't determine file name for {path}");
		}
	}

	private static void SplitPathWithoutExtension(string path, FileSystem fileSystem, out string directory, out string file)
	{
		directory = fileSystem.Path.GetDirectoryName(path) ?? throw new Exception("Could not get directory name");
		directory = string.IsNullOrEmpty(directory) ? "." : directory;
		file = fileSystem.Path.GetFileNameWithoutExtension(path);
		if (string.IsNullOrEmpty(file))
		{
			throw new Exception($"Can't determine file name for {path}");
		}
	}

	public override void Flush()
	{
		m_currentStream.Flush();
	}

	public override long Seek(long offset, SeekOrigin origin)
	{
		switch (origin)
		{
			case SeekOrigin.Begin:
				Position = offset;
				break;
			case SeekOrigin.Current:
				Position += offset;
				break;
			case SeekOrigin.End:
				Position = Length - offset;
				break;
		}
		return Position;
	}

	public override void SetLength(long value)
	{
		throw new NotSupportedException();
	}

	public override int ReadByte()
	{
		int value = m_currentStream.ReadByte();
		if (value >= 0)
		{
			m_position++;
			if (m_position == m_currentEnd)
			{
				NextStream();
			}
		}
		return value;
	}

	public override int Read(byte[] buffer, int offset, int count)
	{
		int read = m_currentStream.Read(buffer, offset, count);
		m_position += read;
		if (m_position == m_currentEnd)
		{
			NextStream();
		}

		return read;
	}

	public override void WriteByte(byte value)
	{
		m_currentStream.WriteByte(value);
		m_position++;
		if (m_position == m_currentEnd)
		{
			NextStream();
		}
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		while (count > 0)
		{
			long available = m_currentEnd - m_position;
			int toWrite = count < available ? count : (int)available;
			m_currentStream.Write(buffer, offset, toWrite);
			m_position += toWrite;
			if (m_position == m_currentEnd)
			{
				NextStream();
			}

			offset += toWrite;
			count -= toWrite;
		}
	}

	protected override void Dispose(bool disposing)
	{
		foreach (Stream stream in m_streams)
		{
			stream.Dispose();
		}
		base.Dispose(disposing);
	}

	private void NextStream()
	{
		int nextStreamIndex = m_streamIndex + 1;
		if (nextStreamIndex < m_streams.Count)
		{
			m_currentBegin += m_currentStream.Length;
			m_streamIndex = nextStreamIndex;
			m_currentStream = m_streams[m_streamIndex];
			m_currentStream.Position = 0;
			m_currentEnd += m_currentStream.Length;
		}
	}

	[MemberNotNull(nameof(m_currentStream))]
	private void UpdateCurrentStream()
	{
		m_currentBegin = 0;
		m_currentEnd = 0;
		for (int i = 0; i < m_streams.Count; i++)
		{
			m_streamIndex = i;
			m_currentStream = m_streams[m_streamIndex];
			m_currentEnd = m_currentBegin + m_currentStream.Length;
			if (m_currentEnd > m_position)
			{
				m_currentStream.Position = m_position - m_currentBegin;
				return;
			}

			m_currentBegin += m_currentStream.Length;
		}
		m_currentBegin -= m_currentStream!.Length;
		m_currentStream.Position = m_position - m_currentBegin;
	}

	public override long Position
	{
		get => m_position;
		set
		{
			ArgumentOutOfRangeException.ThrowIfNegative(value);

			m_position = value;
			if (value < m_currentBegin || value >= m_currentEnd)
			{
				UpdateCurrentStream();
			}
			else
			{
				m_currentStream.Position = value - m_currentBegin;
			}
		}
	}

	public override long Length { get; }

	public override bool CanRead { get; }
	public override bool CanWrite { get; }
	public override bool CanSeek => true;

	/// <summary>
	/// Always has at least one element.
	/// </summary>
	private readonly IReadOnlyList<Stream> m_streams;

	private Stream m_currentStream;
	private int m_streamIndex;
	private long m_position;
	private long m_currentBegin;
	private long m_currentEnd;

	[GeneratedRegex(@".+\.split[0-9]+$")]
	private static partial Regex SplitFileRegex { get; }
}

```

`Source/AssetRipper.IO.Files/Streams/PartialStream.cs`:

```cs
namespace AssetRipper.IO.Files.Streams;

/// <summary>
/// A stream implementation for accessing a subset of another stream
/// </summary>
public sealed class PartialStream : Stream
{
	public PartialStream(Stream baseStream, long offset, long length) : this(baseStream, offset, length, true) { }

	public PartialStream(Stream baseStream, long offset, long length, bool leaveOpen)
	{
		if (offset + length > baseStream.Length)
		{
			throw new ArgumentException("The base stream is not long enough for the given offset and length.");
		}
		m_stream = baseStream ?? throw new ArgumentNullException(nameof(baseStream));
		m_baseOffset = offset;
		Length = length;
		m_leaveOpen = leaveOpen;
	}

	~PartialStream()
	{
		Dispose(false);
	}

	/// <inheritdoc/>
	public override void Flush()
	{
		m_stream.Flush();
	}

	/// <inheritdoc/>
	public override int Read(byte[] buffer, int offset, int count)
	{
		count = (int)Math.Max(Math.Min(count, Length - Position), 0);
		int read = m_stream.Read(buffer, offset, count);
		return read;
	}

	public override int Read(Span<byte> buffer)
	{
		int count = buffer.Length;
		count = (int)Math.Max(Math.Min(count, Length - Position), 0);
		return m_stream.Read(buffer[..count]);
	}

	public override int ReadByte()
		=> m_stream.ReadByte();

	/// <inheritdoc/>
	public override long Seek(long offset, SeekOrigin origin)
	{
		if (origin == SeekOrigin.Begin)
		{
			return m_stream.Seek(m_baseOffset + offset, SeekOrigin.Begin) - m_baseOffset;
		}
		else if (origin == SeekOrigin.End)
		{
			return m_stream.Seek(m_baseOffset + Length + offset, SeekOrigin.Begin) - m_baseOffset;
		}
		else
		{
			return m_stream.Seek(offset, origin) - m_baseOffset;
		}
	}

	/// <inheritdoc/>
	public override void SetLength(long value)
	{
		throw new NotSupportedException();
	}

	/// <inheritdoc/>
	public override void Write(byte[] buffer, int offset, int count)
	{
		if (Position + count > Length)
		{
			throw new Exception("Partial stream's position is out of range");
		}
		m_stream.Write(buffer, offset, count);
	}

	/// <inheritdoc/>
	protected override void Dispose(bool disposing)
	{
		if (m_leaveOpen)
		{
			if (!m_isDisposed)
			{
				m_isDisposed = true;
			}
		}
		else
		{
			m_stream?.Dispose();
		}
		base.Dispose(disposing);
	}

	/// <inheritdoc/>
	public override bool CanRead => m_stream.CanRead;
	/// <inheritdoc/>
	public override bool CanSeek => m_stream.CanSeek;
	/// <inheritdoc/>
	public override bool CanWrite => m_stream.CanWrite;
	/// <inheritdoc/>
	public override long Length { get; }

	/// <inheritdoc/>
	public override long Position
	{
		get => m_stream.Position - m_baseOffset;
		set
		{
			if (value < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(value), "Non-negative number required");
			}
			m_stream.Position = m_baseOffset + value;
		}
	}

	private readonly Stream m_stream;
	private readonly long m_baseOffset;
	private readonly bool m_leaveOpen;

	private bool m_isDisposed;
}

```

`Source/AssetRipper.IO.Files/Streams/RandomAccessStream.cs`:

```cs
using AssetRipper.IO.Files.Streams.Smart;
using Microsoft.Win32.SafeHandles;

namespace AssetRipper.IO.Files.Streams;

/// <summary>
/// Read a slice of a file using a SafeFileHandle directly with System.IO.RandomAccess.
/// This allows a container file with multiple logical files (eg, AssetBundles)
/// to be streamed as if they are separate files, without buffering the entire file at once.
/// </summary>
internal sealed class RandomAccessStream : Stream
{
	public SafeFileHandle Handle { get; }

	public FileStream Parent { get; }

	public long BaseOffset { get; }

	/// <summary>
	/// Raw position in file.
	/// </summary>
	private long position = 0;

	public override bool CanRead => true;

	public override bool CanSeek => true;

	public override bool CanWrite => false;

	public override long Length { get; }

	// position corrected for logical file offset.
	public override long Position
	{
		get => position - BaseOffset;
		set => position = value + BaseOffset;
	}

	public RandomAccessStream(FileStream parent, long offset, long length)
	{
		if (parent.Length < offset + length)
		{
			throw new ArgumentException("The parent stream is not long enough for the given offset and length.");
		}
		Parent = parent;
		Handle = parent.SafeFileHandle;
		BaseOffset = offset;
		Length = length;
		position = BaseOffset;
	}

	public override void Flush()
	{
		// Read-only streams shouldn't flush.
	}

	public override int Read(byte[] buffer, int offset, int count)
	{
		return Read(buffer.AsSpan(offset, count));
	}

	public override int Read(Span<byte> buffer)
	{
		long toRead = Math.Min(buffer.Length, Length - Position);
		int read = RandomAccess.Read(Handle, buffer[..(int)toRead], position);
		position += read;
		return read;
	}

	public override int ReadByte()
	{
		if (Position >= Length)
		{
			return -1;
		}

		Span<byte> result = stackalloc byte[1];
		int read = RandomAccess.Read(Handle, result, position);
		if (read > 0)
		{
			position += read;
			return result[0];
		}

		return -1;
	}

	public override long Seek(long offset, SeekOrigin origin)
	{
		switch (origin)
		{
			case SeekOrigin.Current:
				Position += offset;
				break;
			case SeekOrigin.Begin:
				Position = offset;
				break;
			case SeekOrigin.End:
				position = (Length - offset) + BaseOffset;
				break;
		}
		return Position;
	}

	public override void SetLength(long value)
	{
		throw new NotSupportedException();
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		throw new NotSupportedException();
	}


	~RandomAccessStream()
	{
		GC.KeepAlive(Parent);
	}
}

```

`Source/AssetRipper.IO.Files/Streams/Smart/SmartStream.SmartRefCount.cs`:

```cs
namespace AssetRipper.IO.Files.Streams.Smart;

public partial class SmartStream
{
	private class SmartRefCount
	{
		public static SmartRefCount operator ++(SmartRefCount _this)
		{
			_this.RefCount++;
			return _this;
		}

		public static SmartRefCount operator --(SmartRefCount _this)
		{
			_this.RefCount--;
			return _this;
		}

		public void Increase()
		{
			RefCount++;
		}

		public void Decrease()
		{
			RefCount--;
		}

		public override string ToString()
		{
			return RefCount.ToString();
		}

		public bool IsZero => RefCount == 0;

		public int RefCount
		{
			get;
			private set
			{
				ArgumentOutOfRangeException.ThrowIfNegative(value);
				field = value;
			}
		} = 0;
	}
}

```

`Source/AssetRipper.IO.Files/Streams/Smart/SmartStream.cs`:

```cs
namespace AssetRipper.IO.Files.Streams.Smart;

public sealed partial class SmartStream : Stream
{
	private SmartStream()
	{
		RefCounter = new();
	}

	private SmartStream(Stream baseStream)
	{
		Stream = baseStream ?? throw new ArgumentNullException(nameof(baseStream));
		RefCounter = new();
		RefCounter++;
	}

	private SmartStream(SmartStream copy)
	{
		Assign(copy);
	}

	public static SmartStream OpenRead(string path, FileSystem fileSystem)
	{
		return new SmartStream(fileSystem.File.OpenRead(path));
	}

	public static SmartStream OpenReadMulti(string path, FileSystem fileSystem)
	{
		return new SmartStream(MultiFileStream.OpenRead(path, fileSystem));
	}

	public static SmartStream CreateTemp()
	{
		string tempFile = LocalFileSystem.Instance.File.CreateTemporary();
		return new SmartStream(new FileStream(tempFile, FileMode.Open, FileAccess.ReadWrite, FileShare.None, 4096, FileOptions.DeleteOnClose));
	}

	public static SmartStream CreateMemory()
	{
		return new SmartStream(new MemoryStream());
	}

	public static SmartStream CreateMemory(byte[] buffer)
	{
		return new SmartStream(new MemoryStream(buffer));
	}

	public static SmartStream CreateMemory(byte[] buffer, int offset, int size, bool writable = true)
	{
		return new SmartStream(new MemoryStream(buffer, offset, size, writable));
	}

	/// <summary>
	/// Create a <see cref="SmartStream"/> with no backing stream.
	/// </summary>
	/// <returns>A new <see cref="SmartStream"/> for which <see cref="IsNull"/> is true.</returns>
	public static SmartStream CreateNull() => new();

	/// <summary>
	/// Copy the reference from another <see cref="SmartStream"/>.
	/// </summary>
	/// <param name="source">The <see cref="SmartStream"/> to copy a reference from.</param>
	[MemberNotNull(nameof(RefCounter))]
	public void Assign(SmartStream source)
	{
		FreeReference();

		Stream = source.Stream;
		RefCounter = source.RefCounter;
		if (!IsNull)
		{
			RefCounter++;
		}
	}

	/// <summary>
	/// Move the reference from another <see cref="SmartStream"/> to <see langword="this"/>.
	/// </summary>
	/// <remarks>
	/// The reference for <paramref name="source"/> is freed.
	/// </remarks>
	/// <param name="source">The <see cref="SmartStream"/> from which to move the reference.</param>
	public void Move(SmartStream source)
	{
		Assign(source);
		source.FreeReference();
	}

	/// <summary>
	/// Create a new reference to the backing stream.
	/// </summary>
	/// <returns>A new <see cref="SmartStream"/> that references the same stream as <see langword="this"/>.</returns>
	public SmartStream CreateReference()
	{
		return new SmartStream(this);
	}

	[MemberNotNull(nameof(Stream))]
	public SmartStream CreatePartial(long offset, long size)
	{
		ThrowIfNull();

		// Create a partial stream if the base stream is compatible with RandomAccessStream.
		RandomAccessStream? partialStream = Stream switch
		{
			// root case
			FileStream fileStream => new RandomAccessStream(fileStream, offset, size),

			// branch case
			RandomAccessStream parentPartial => new RandomAccessStream(
				parentPartial.Parent,
				parentPartial.BaseOffset + offset,
				size),

			// incompatible
			_ => null
		};

		if (partialStream is not null)
		{
			return new SmartStream(this) { Stream = partialStream };
		}

		// Copy otherwise.
		byte[] buffer = new byte[(int)size];
		long initialPosition = Stream.Position;
		Stream.Position = offset;
		Stream.ReadExactly(buffer);
		Stream.Position = initialPosition;
		return SmartStream.CreateMemory(buffer);
	}

	public override void Flush()
	{
		Stream?.Flush();
	}

	[MemberNotNull(nameof(Stream))]
	public override int Read(byte[] buffer, int offset, int count)
	{
		ThrowIfNull();
		return Stream.Read(buffer, offset, count);
	}

	[MemberNotNull(nameof(Stream))]
	public override int Read(Span<byte> buffer)
	{
		ThrowIfNull();
		return Stream.Read(buffer);
	}

	[MemberNotNull(nameof(Stream))]
	public override int ReadByte()
	{
		ThrowIfNull();
		return Stream.ReadByte();
	}

	[MemberNotNull(nameof(Stream))]
	public override long Seek(long offset, SeekOrigin origin)
	{
		ThrowIfNull();
		return Stream.Seek(offset, origin);
	}

	[MemberNotNull(nameof(Stream))]
	public override void SetLength(long value)
	{
		ThrowIfNull();
		Stream.SetLength(value);
	}

	[MemberNotNull(nameof(Stream))]
	public override void Write(byte[] buffer, int offset, int count)
	{
		ThrowIfNull();
		Stream.Write(buffer, offset, count);
	}

	/// <summary>
	/// Free the reference to the backing stream and become null.
	/// </summary>
	public void FreeReference()
	{
		if (!IsNull)
		{
			RefCounter--;
			if (RefCounter.IsZero)
			{
				Stream.Dispose();
			}
			Stream = null;
		}
	}

	protected override void Dispose(bool disposing)
	{
		FreeReference();
		base.Dispose(disposing);
	}

	[MemberNotNullWhen(true, nameof(Stream))]
	public override bool CanRead => Stream?.CanRead ?? false;

	[MemberNotNullWhen(true, nameof(Stream))]
	public override bool CanSeek => Stream?.CanSeek ?? false;

	[MemberNotNullWhen(true, nameof(Stream))]
	public override bool CanWrite => Stream?.CanWrite ?? false;

	public override long Position
	{
		get => Stream?.Position ?? 0;
		[MemberNotNull(nameof(Stream))]
		set
		{
			ThrowIfNull();
			Stream.Position = value;
		}
	}

	public override long Length => Stream?.Length ?? 0;

	/// <summary>
	/// The type of stream backing this <see cref="SmartStream"/>.
	/// </summary>
	public SmartStreamType StreamType => Stream switch
	{
		null => SmartStreamType.Null,
		MemoryStream => SmartStreamType.Memory,
		FileStream or MultiFileStream => SmartStreamType.File,
		_ => throw new InvalidOperationException(),
	};

	/// <summary>
	/// Write the contents to a byte array, regardless of the <see cref="Position"/> property.
	/// </summary>
	/// <returns>A new byte array.</returns>
	[MemberNotNull(nameof(Stream))]
	public byte[] ToArray()
	{
		ThrowIfNull();
		return Stream switch
		{
			MemoryStream memoryStream => memoryStream.ToArray(),
			_ => StreamToByteArray(Stream),
		};

		static byte[] StreamToByteArray(Stream stream)
		{
			long initialPosition = stream.Position;
			stream.Position = 0;
			byte[] data = new byte[stream.Length];
			stream.CopyTo(new MemoryStream(data));
			stream.Position = initialPosition;
			return data;
		}
	}

	/// <summary>
	/// Throw if <see cref="Stream"/> is null.
	/// </summary>
	/// <exception cref="NullReferenceException"><see cref="Stream"/> is null.</exception>
	[MemberNotNull(nameof(Stream))]
	private void ThrowIfNull()
	{
		if (IsNull)
		{
			throw new NullReferenceException(nameof(Stream));
		}
	}

	/// <summary>
	/// If true, this has no backing stream.
	/// </summary>
	[MemberNotNullWhen(false, nameof(Stream))]
	public bool IsNull => Stream == null;

	/// <summary>
	/// The number of references to the backing stream.
	/// </summary>
	public int RefCount => RefCounter.RefCount;

	/// <summary>
	/// The shared reference counter for the backing stream.
	/// </summary>
	private SmartRefCount RefCounter { get; set; }

	/// <summary>
	/// The backing stream. It is shared with the other <see cref="SmartStream"/>s that reference it.
	/// </summary>
	private Stream? Stream { get; set; }
}

```

`Source/AssetRipper.IO.Files/Streams/Smart/SmartStreamType.cs`:

```cs
namespace AssetRipper.IO.Files.Streams.Smart;

public enum SmartStreamType
{
	/// <summary>
	/// The <see cref="SmartStream"/> is not backed by a <see cref="Stream"/>.
	/// </summary>
	Null,
	/// <summary>
	/// The <see cref="SmartStream"/> is backed by a <see cref="FileStream"/> or <see cref="MultiFileStream"/>.
	/// </summary>
	File,
	/// <summary>
	/// The <see cref="SmartStream"/> is backed by a <see cref="MemoryStream"/>.
	/// </summary>
	Memory,
}

```

`Source/AssetRipper.IO.Files/Streams/SplitNameComparer.cs`:

```cs
namespace AssetRipper.IO.Files.Streams;

internal sealed class SplitNameComparer : IComparer<string>
{
	public static SplitNameComparer Instance { get; } = new();

	public int Compare(string? x, string? y)
	{
		int xNumber = GetSplitIndex(x);
		int yNumber = GetSplitIndex(y);
		return xNumber.CompareTo(yNumber);
	}

	private static int GetSplitIndex(string? value)
	{
		if (string.IsNullOrEmpty(value))
		{
			return -1;
		}

		int i;
		for (i = value.Length - 1; i >= 0; i--)
		{
			if (!char.IsDigit(value[i]))
			{
				i++;
				break;
			}
		}
		string number = value.Substring(i);
		return int.Parse(number);
	}
}

```

`Source/AssetRipper.IO.Files/Usings.cs`:

```cs
global using AssetRipper.Primitives;
global using System;

```

`Source/AssetRipper.IO.Files/Utf8Truncation.cs`:

```cs
using System.Buffers;
using System.Text;

namespace AssetRipper.IO.Files;

internal static class Utf8Truncation
{
	public static string TruncateToUTF8ByteLength(string str, int maxLength)
	{
		int currentByteLength = Encoding.UTF8.GetByteCount(str);
		byte[] bytes = ArrayPool<byte>.Shared.Rent(currentByteLength);
		Encoding.UTF8.GetBytes(str, bytes);
		int validLength = FindValidByteLength(bytes.AsSpan(0, currentByteLength), maxLength);
		string result = Encoding.UTF8.GetString(bytes.AsSpan(0, validLength));
		ArrayPool<byte>.Shared.Return(bytes);
		return result;
	}

	private static int FindValidByteLength(ReadOnlySpan<byte> bytes, int maxLength)
	{
		int validLength = maxLength;

		// ascii char:      0_
		// two-byte char:   110_   10_
		// three-byte char: 1110_  10_ _10_
		// four-byte char : 11110_ 10_ _10_ _10

		if (maxLength >= bytes.Length)
		{
			return bytes.Length;
		}

		// next byte is a beginning, so we can safely truncate to maxLength
		byte nextByte = bytes[maxLength];
		if ((nextByte & 0b11_000000) != 0b10_000000)
		{
			return maxLength;
		}

		// move to end of the last full sequence
		for (int i = maxLength - 1; i >= 0; i--)
		{
			byte currentByte = bytes[i];

			if ((currentByte & 0b11_000000) == 0b10_000000)
			{
				// continuation byte
				validLength--;
			}
			else if ((currentByte & 0b10000000) == 0b10000000)
			{
				// start of multi-byte sequence
				validLength--;
				break;
			}
			else
			{
				// ascii char
				break;
			}
		}

		return validLength;
	}
}

```

`Source/AssetRipper.IO.Files/VirtualFileSystem.cs`:

```cs
using AssetRipper.IO.Files.Streams.Smart;
using System.Buffers;
using System.Diagnostics;
using System.Text;

namespace AssetRipper.IO.Files;

public partial class VirtualFileSystem : FileSystem
{
	private readonly DirectoryEntry root = new("", null);

	private sealed class DirectoryEntry
	{
		public string Name { get; }
		public DirectoryEntry? Parent { get; }
		public Dictionary<string, DirectoryEntry> Children { get; } = [];
		public Dictionary<string, FileEntry> Files { get; } = [];

		[MemberNotNullWhen(false, nameof(Parent))]
		public bool IsRoot => Parent is null;

		public string FullName
		{
			get
			{
				if (IsRoot)
				{
					return "/";
				}
				else if (Parent.IsRoot)
				{
					return $"/{Name}";
				}
				else
				{
					return $"{Parent.FullName}/{Name}";
				}
			}
		}

		public int TotalFileCount
		{
			get
			{
				int count = Files.Count;
				foreach (DirectoryEntry child in Children.Values)
				{
					count += child.TotalFileCount;
				}
				return count;
			}
		}

		public int TotalDirectoryCount
		{
			get
			{
				int count = Children.Count;
				foreach (DirectoryEntry child in Children.Values)
				{
					count += child.TotalDirectoryCount;
				}
				return count;
			}
		}

		public DirectoryEntry(string name, DirectoryEntry? parent)
		{
			Name = name;
			Parent = parent;
		}

		public DirectoryEntry CreateDirectory(string name)
		{
			if (!Children.TryGetValue(name, out DirectoryEntry? directory))
			{
				directory = new(name, this);
				Children[name] = directory;
			}
			return directory;
		}

		public DirectoryEntry OpenDirectory(string name)
		{
			return TryOpenDirectory(name) ?? throw new DirectoryNotFoundException($"Directory '{name}' not found.");
		}

		public DirectoryEntry? TryOpenDirectory(string name)
		{
			if (!Children.TryGetValue(name, out DirectoryEntry? directory))
			{
				return null;
			}
			return directory;
		}

		public FileEntry CreateFile(string name)
		{
			if (Files.TryGetValue(name, out FileEntry? file))
			{
				file.Stream.SetLength(0);
			}
			else
			{
				SmartStream stream = SmartStream.CreateMemory();
				file = new(name, this, stream);
				Files[name] = file;
			}

			return file;
		}

		public FileEntry OpenFile(string name)
		{
			return TryOpenFile(name) ?? throw new FileNotFoundException($"File '{name}' not found.");
		}

		public FileEntry? TryOpenFile(string name)
		{
			if (!Files.TryGetValue(name, out FileEntry? file))
			{
				return null;
			}
			return file;
		}
	}

	private sealed class FileEntry
	{
		public string Name { get; }
		public DirectoryEntry Parent { get; }
		public SmartStream Stream { get; }
		public string FullName
		{
			get
			{
				if (Parent.IsRoot)
				{
					return $"/{Name}";
				}
				else
				{
					return $"{Parent.FullName}/{Name}";
				}
			}
		}
		public FileEntry(string name, DirectoryEntry parent, SmartStream stream)
		{
			Name = name;
			Parent = parent;
			Stream = stream;
		}
	}

	/// <summary>
	/// The number of virtual files and directories.
	/// </summary>
	public int Count => root.TotalFileCount + root.TotalDirectoryCount + 1;

	public override string TemporaryDirectory
	{
		get;
		set
		{
			if (!string.IsNullOrWhiteSpace(value))
			{
				field = Path.GetFullPath(value);
			}
		}
	} = "/temp";

	/// <summary>
	/// Clears the virtual file system.
	/// </summary>
	public void Clear()
	{
		root.Children.Clear();
		root.Files.Clear();
	}

	private DirectoryEntry OpenDirectory(ReadOnlySpan<string> parts)
	{
		DirectoryEntry current = root;
		foreach (string part in parts)
		{
			current = current.OpenDirectory(part);
		}
		return current;
	}

	private DirectoryEntry? TryOpenDirectory(ReadOnlySpan<string> parts)
	{
		DirectoryEntry? current = root;
		foreach (string part in parts)
		{
			current = current.TryOpenDirectory(part);
			if (current is null)
			{
				return null;
			}
		}
		return current;
	}

	public partial class VirtualFileImplementation
	{
		public override SmartStream Create(string path)
		{
			string[] pathParts = Path.GetPathParts(path);
			if (pathParts.Length == 0)
			{
				throw new ArgumentException("Path cannot be empty.", nameof(path));
			}

			ReadOnlySpan<string> directoryParts = pathParts.AsSpan(0, pathParts.Length - 1);
			string fileName = pathParts[^1];
			DirectoryEntry directory = Parent.OpenDirectory(directoryParts);
			return directory.CreateFile(fileName).Stream.CreateReference();
		}
		public SmartStream Open(string path)
		{
			string[] pathParts = Path.GetPathParts(path);
			if (pathParts.Length == 0)
			{
				throw new ArgumentException("Path cannot be empty.", nameof(path));
			}

			ReadOnlySpan<string> directoryParts = pathParts.AsSpan(0, pathParts.Length - 1);
			string fileName = pathParts[^1];
			DirectoryEntry directory = Parent.OpenDirectory(directoryParts);
			return directory.OpenFile(fileName).Stream.CreateReference();
		}
		public override SmartStream OpenRead(string path) => Open(path);
		public override SmartStream OpenWrite(string path) => Open(path);
		public override void Delete(string path)
		{
			string[] pathParts = Path.GetPathParts(path);
			if (pathParts.Length == 0)
			{
				throw new ArgumentException("Path cannot be empty.", nameof(path));
			}

			ReadOnlySpan<string> directoryParts = pathParts.AsSpan(0, pathParts.Length - 1);
			string fileName = pathParts[^1];
			DirectoryEntry directory = Parent.OpenDirectory(directoryParts);
			if (directory.Files.Remove(fileName, out FileEntry? file))
			{
				file.Stream.Dispose();
			}
		}
		public override bool Exists(string? path)
		{
			string[] pathParts = Path.GetPathParts(path);
			ReadOnlySpan<string> directoryParts = pathParts.AsSpan(0, pathParts.Length - 1);
			string fileName = pathParts[^1];

			return Parent.TryOpenDirectory(directoryParts)?.TryOpenFile(fileName) is not null;
		}
		public override string ReadAllText(string path) => ReadAllText(path, Encoding.UTF8);
		public override string ReadAllText(string path, Encoding encoding) => encoding.GetString(ReadAllBytes(path));
		public override void WriteAllText(string path, ReadOnlySpan<char> contents) => WriteAllText(path, contents, Encoding.UTF8);
		public override void WriteAllText(string path, ReadOnlySpan<char> contents, Encoding encoding)
		{
			int byteCount = encoding.GetByteCount(contents);
			byte[] array = ArrayPool<byte>.Shared.Rent(byteCount);
			Span<byte> span = array.AsSpan(0, byteCount);
			int bytesWritten = encoding.GetBytes(contents, span);
			Debug.Assert(bytesWritten == byteCount);
			WriteAllBytes(path, span);
			ArrayPool<byte>.Shared.Return(array);
		}
		public override byte[] ReadAllBytes(string path)
		{
			using SmartStream stream = Open(path);
			byte[] buffer = new byte[stream.Length];
			stream.Position = 0;
			stream.ReadExactly(buffer);
			return buffer;
		}
		public override void WriteAllBytes(string path, ReadOnlySpan<byte> bytes)
		{
			using SmartStream stream = Create(path);
			stream.SetLength(bytes.Length);
			stream.Position = 0;
			stream.Write(bytes);
		}
	}

	public partial class VirtualDirectoryImplementation
	{
		public override void Create(string? path)
		{
			string[] parts = Path.GetPathParts(path);
			DirectoryEntry current = Parent.root;
			foreach (string part in parts)
			{
				current = current.CreateDirectory(part);
			}
		}

		public override IEnumerable<string> EnumerateDirectories(string? path, string searchPattern, SearchOption searchOption)
		{
			if (searchPattern != "*")
			{
				throw new NotImplementedException("Only '*' search pattern is supported.");
			}

			string[] parts = Path.GetPathParts(path);
			DirectoryEntry directory = Parent.OpenDirectory(parts);
			if (searchOption == SearchOption.TopDirectoryOnly)
			{
				foreach (DirectoryEntry child in directory.Children.Values)
				{
					yield return child.FullName;
				}
			}
			else
			{
				Stack<DirectoryEntry> stack = new();
				stack.Push(directory);
				while (stack.Count > 0)
				{
					DirectoryEntry current = stack.Pop();
					foreach (DirectoryEntry child in current.Children.Values)
					{
						yield return child.FullName;
						stack.Push(child);
					}
				}
			}
		}

		public override IEnumerable<string> EnumerateFiles(string? path, string searchPattern, SearchOption searchOption)
		{
			string[] pathParts = Path.GetPathParts(path);

			string extension;
			if (searchPattern == "*")
			{
				extension = string.Empty;
			}
			else if (searchPattern.StartsWith("*.") && searchPattern.Length > 2)
			{
				extension = searchPattern[1..];
				if (extension.Contains('*') || extension.Contains('?'))
				{
					throw new NotImplementedException("Only '*' and '*.<extension>' search patterns are supported.");
				}
			}
			else
			{
				throw new NotImplementedException("Only '*' and '*.<extension>' search patterns are supported.");
			}

			DirectoryEntry directory = Parent.OpenDirectory(pathParts);
			if (searchOption == SearchOption.TopDirectoryOnly)
			{
				foreach (FileEntry file in directory.Files.Values)
				{
					if (file.Name.EndsWith(extension, StringComparison.Ordinal))
					{
						yield return file.FullName;
					}
				}
			}
			else
			{
				Stack<DirectoryEntry> stack = new();
				stack.Push(directory);
				while (stack.Count > 0)
				{
					DirectoryEntry current = stack.Pop();
					foreach (FileEntry file in current.Files.Values)
					{
						if (file.Name.EndsWith(extension, StringComparison.Ordinal))
						{
							yield return file.FullName;
						}
					}
					foreach (DirectoryEntry child in current.Children.Values)
					{
						stack.Push(child);
					}
				}
			}
		}

		public override IEnumerable<string> EnumerateDirectories(string path, string searchPattern)
		{
			return EnumerateDirectories(path, searchPattern, SearchOption.TopDirectoryOnly);
		}

		public override IEnumerable<string> EnumerateDirectories(string path)
		{
			return EnumerateDirectories(path, "*", SearchOption.TopDirectoryOnly);
		}

		public override IEnumerable<string> EnumerateFiles(string path, string searchPattern)
		{
			return EnumerateFiles(path, searchPattern, SearchOption.TopDirectoryOnly);
		}

		public override IEnumerable<string> EnumerateFiles(string path)
		{
			return EnumerateFiles(path, "*", SearchOption.TopDirectoryOnly);
		}

		public override string[] GetDirectories(string path, string searchPattern, SearchOption searchOption)
		{
			return EnumerateDirectories(path, searchPattern, searchOption).ToArray();
		}

		public override string[] GetDirectories(string path, string searchPattern)
		{
			return EnumerateDirectories(path, searchPattern).ToArray();
		}

		public override string[] GetDirectories(string path)
		{
			return EnumerateDirectories(path).ToArray();
		}

		public override string[] GetFiles(string path, string searchPattern, SearchOption searchOption)
		{
			return EnumerateFiles(path, searchPattern, searchOption).ToArray();
		}

		public override string[] GetFiles(string path, string searchPattern)
		{
			return EnumerateFiles(path, searchPattern).ToArray();
		}

		public override string[] GetFiles(string path)
		{
			return EnumerateFiles(path).ToArray();
		}

		public override bool Exists(string? path)
		{
			string[] parts = Path.GetPathParts(path);
			DirectoryEntry current = Parent.root;
			foreach (string part in parts)
			{
				if (!current.Children.TryGetValue(part, out DirectoryEntry? next))
				{
					return false;
				}
				current = next;
			}
			return true;
		}
	}

	public partial class VirtualPathImplementation
	{
		public override string GetFullPath(string? path)
		{
			// The "current directory" is always the root directory.
			// We also don't support ".." and ".".

			if (path is null or "" or "/" or "\\")
			{
				return "/";
			}

			string normalizedPath = path.Replace('\\', '/');
			if (normalizedPath[^1] is '/')
			{
				normalizedPath = normalizedPath[..^1];
			}
			return normalizedPath[0] is '/' ? normalizedPath : $"/{normalizedPath}";
		}

		public override bool IsPathRooted(ReadOnlySpan<char> path)
		{
			return path.Length > 0 && path[0] is '/' or '\\';
		}

		internal string[] GetPathParts(string? path)
		{
			string fullPath = GetFullPath(path);
			return fullPath.Split('/', StringSplitOptions.RemoveEmptyEntries);
		}

		public override string Join(string path1, string path2)
		{
			return GetFullPath(base.Join(path1, path2));
		}

		public override string Join(string path1, string path2, string path3)
		{
			return GetFullPath(base.Join(path1, path2, path3));
		}

		public override string Join(string path1, string path2, string path3, string path4)
		{
			return GetFullPath(base.Join(path1, path2, path3, path4));
		}

		public override string Join(params ReadOnlySpan<string> paths)
		{
			return GetFullPath(base.Join(paths));
		}
	}
}

```

`Source/AssetRipper.IO.Files/VirtualFileSystem.g.cs`:

```cs
// Auto-generated code. Do not modify manually.

namespace AssetRipper.IO.Files;

public sealed partial class VirtualFileSystem : FileSystem
{
	public override VirtualFileImplementation File { get; }

	public sealed partial class VirtualFileImplementation(VirtualFileSystem fileSystem) : FileImplementation(fileSystem)
	{
		private new VirtualFileSystem Parent => (VirtualFileSystem)base.Parent;
		private new VirtualFileImplementation File => this;
		private new VirtualDirectoryImplementation Directory => Parent.Directory;
		private new VirtualPathImplementation Path => Parent.Path;
	}

	public override VirtualDirectoryImplementation Directory { get; }

	public sealed partial class VirtualDirectoryImplementation(VirtualFileSystem fileSystem) : DirectoryImplementation(fileSystem)
	{
		private new VirtualFileSystem Parent => (VirtualFileSystem)base.Parent;
		private new VirtualFileImplementation File => Parent.File;
		private new VirtualDirectoryImplementation Directory => this;
		private new VirtualPathImplementation Path => Parent.Path;
	}

	public override VirtualPathImplementation Path { get; }

	public sealed partial class VirtualPathImplementation(VirtualFileSystem fileSystem) : PathImplementation(fileSystem)
	{
		private new VirtualFileSystem Parent => (VirtualFileSystem)base.Parent;
		private new VirtualFileImplementation File => Parent.File;
		private new VirtualDirectoryImplementation Directory => Parent.Directory;
		private new VirtualPathImplementation Path => this;
	}

	public VirtualFileSystem()
	{
		File = new(this);
		Directory = new(this);
		Path = new(this);
	}
}

```

`Source/AssetRipper.IO.Files/WebFiles/WebFile.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.Streams;
using AssetRipper.IO.Files.Streams.Smart;
using System.Diagnostics;

namespace AssetRipper.IO.Files.WebFiles;

public sealed class WebFile : FileContainer
{
	private const string Signature = "UnityWebData1.0";

	public static bool IsWebFile(string webPath, FileSystem fileSystem)
	{
		using Stream stream = MultiFileStream.OpenRead(webPath, fileSystem);
		return IsWebFile(stream);
	}

	public static bool IsWebFile(Stream stream)
	{
		using EndianReader reader = new EndianReader(stream, EndianType.LittleEndian);
		return IsWebFile(reader);
	}

	public override void Read(SmartStream stream)
	{
		long basePosition = stream.Position;
		List<WebFileEntry> entries = new();
		using (EndianReader reader = new EndianReader(stream, EndianType.LittleEndian))
		{
			string signature = reader.ReadStringZeroTerm();
			Debug.Assert(signature == Signature, $"Signature '{signature}' doesn't match to '{Signature}'");

			int headerLength = reader.ReadInt32(); //total size of the header including the signature and all the entries.
			while (reader.BaseStream.Position - basePosition < headerLength)
			{
				entries.Add(WebFileEntry.Read(reader));
			}
		}

		foreach (WebFileEntry entry in entries)
		{
			byte[] buffer = new byte[entry.Size];
			stream.Position = entry.Offset + basePosition;
			stream.ReadExactly(buffer, 0, buffer.Length);
			ResourceFile file = new ResourceFile(buffer, FilePath, entry.Name);
			AddResourceFile(file);
		}
	}

	public override void Write(Stream stream)
	{
		using EndianWriter writer = new EndianWriter(stream, EndianType.LittleEndian);
		Write(writer);
	}

	public void Write(EndianWriter writer, bool alignEntries = true)
	{
		long basePosition = writer.BaseStream.Position;
		writer.WriteStringZeroTerm(Signature);
		long headerSizePosition = writer.BaseStream.Position;

		List<(string, byte[])> entryDataList = AllFiles.Select(f => (f.Name, f.ToByteArray())).ToList();

		//Write entries
		long entriesStartPosition = headerSizePosition + sizeof(int);
		writer.BaseStream.Position = entriesStartPosition;
		int currentOffset = (int)(entriesStartPosition - basePosition);
		long[] offsetPositions = new long[entryDataList.Count];
		for (int i = 0; i < entryDataList.Count; i++)
		{
			(string entryName, byte[] entryData) = entryDataList[i];
			offsetPositions[i] = writer.BaseStream.Position;
			writer.BaseStream.Position += sizeof(int);
			writer.Write(entryData.Length);
			writer.Write(entryName);
			currentOffset += entryData.Length;
		}
		long entriesEndPosition = writer.BaseStream.Position;

		//Write header size
		writer.BaseStream.Position = headerSizePosition;
		writer.Write((int)(entriesEndPosition - basePosition));
		writer.BaseStream.Position = entriesEndPosition;

		//Write data for the entries
		for (int i = 0; i < entryDataList.Count; i++)
		{
			byte[] entryData = entryDataList[i].Item2;
			if (alignEntries)
			{
				writer.AlignStream();//Optional, but data alignment is generally a good thing.
			}
			long dataPosition = writer.BaseStream.Position;
			writer.BaseStream.Position = offsetPositions[i];
			writer.Write((int)(dataPosition - basePosition));
			writer.BaseStream.Position = dataPosition;
			writer.Write(entryData);
		}
	}

	internal static bool IsWebFile(EndianReader reader)
	{
		if (reader.BaseStream.Length - reader.BaseStream.Position > Signature.Length)
		{
			long position = reader.BaseStream.Position;
			bool isRead = reader.ReadStringZeroTerm(Signature.Length + 1, out string? signature);
			reader.BaseStream.Position = position;
			if (isRead)
			{
				return signature == Signature;
			}
		}
		return false;
	}
}

```

`Source/AssetRipper.IO.Files/WebFiles/WebFileEntry.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.WebFiles;

public sealed class WebFileEntry : IEndianReadable<WebFileEntry>, IEndianWritable
{
	public static WebFileEntry Read(EndianReader reader)
	{
		return new()
		{
			Offset = reader.ReadInt32(),
			Size = reader.ReadInt32(),
			Name = reader.ReadString()
		};
	}

	public void Write(EndianWriter writer)
	{
		writer.Write(Offset);
		writer.Write(Size);
		writer.Write(Name);
	}

	public override string ToString() => SpecialFileNames.FixFileIdentifier(Name);

	public int Offset { get; private set; }
	public int Size { get; private set; }
	public string Name { get; private set; } = "";
}

```

`Source/AssetRipper.IO.Files/WebFiles/WebFileScheme.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Streams.Smart;

namespace AssetRipper.IO.Files.WebFiles;

public sealed class WebFileScheme : Scheme<WebFile>
{
	public override bool CanRead(SmartStream stream)
	{
		using EndianReader reader = new EndianReader(stream, EndianType.LittleEndian);
		return WebFile.IsWebFile(reader);
	}
}

```

`Source/AssetRipper.Import/AssetCreation/GameAssetFactory.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.IO;
using AssetRipper.Assets.Metadata;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.Import.Structure.Assembly.Serializable;
using AssetRipper.Import.Structure.Assembly.TypeTrees;
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using AssetRipper.SerializationLogic;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Subclasses.AABB;
using AssetRipper.SourceGenerated.Subclasses.AABBInt;
using AssetRipper.SourceGenerated.Subclasses.AnimationCurve_Single;
using AssetRipper.SourceGenerated.Subclasses.ColorRGBA32;
using AssetRipper.SourceGenerated.Subclasses.ColorRGBAf;
using AssetRipper.SourceGenerated.Subclasses.Gradient;
using AssetRipper.SourceGenerated.Subclasses.GUID;
using AssetRipper.SourceGenerated.Subclasses.GUIStyle;
using AssetRipper.SourceGenerated.Subclasses.Hash128;
using AssetRipper.SourceGenerated.Subclasses.LayerMask;
using AssetRipper.SourceGenerated.Subclasses.Matrix4x4f;
using AssetRipper.SourceGenerated.Subclasses.PropertyName;
using AssetRipper.SourceGenerated.Subclasses.Quaternionf;
using AssetRipper.SourceGenerated.Subclasses.Rectf;
using AssetRipper.SourceGenerated.Subclasses.RectOffset;
using AssetRipper.SourceGenerated.Subclasses.SphericalHarmonicsL2;
using AssetRipper.SourceGenerated.Subclasses.Vector2f;
using AssetRipper.SourceGenerated.Subclasses.Vector2Int;
using AssetRipper.SourceGenerated.Subclasses.Vector3f;
using AssetRipper.SourceGenerated.Subclasses.Vector3Int;
using AssetRipper.SourceGenerated.Subclasses.Vector4f;

namespace AssetRipper.Import.AssetCreation;

public sealed class GameAssetFactory : AssetFactoryBase
{
	public GameAssetFactory(IAssemblyManager assemblyManager)
	{
		AssemblyManager = assemblyManager ?? throw new ArgumentNullException(nameof(assemblyManager));
	}

	private IAssemblyManager AssemblyManager { get; }

	public override IUnityObjectBase? ReadAsset(AssetInfo assetInfo, ReadOnlyArraySegment<byte> assetData, SerializedType? assetType)
	{
		if (assetInfo.Collection.Version.LessThan(3, 5))
		{
			//Assets with a stripped version can't be read.
			//Similarly, Unity versions before 3.5 are not supported.
			//Most asset types changed in 3.5, so this has minimal impact.
			return new UnreadableObject(assetInfo, assetData.ToArray());
		}
		else if (assetInfo.ClassID == (int)ClassIDType.MonoBehaviour)
		{
			return ReadMonoBehaviour(MonoBehaviour.Create(assetInfo), assetData, AssemblyManager, assetType);
		}
		else
		{
			return ReadNormalObject(assetInfo, assetData);
		}
	}

	private static IMonoBehaviour ReadMonoBehaviour(IMonoBehaviour monoBehaviour, ReadOnlyArraySegment<byte> assetData, IAssemblyManager assemblyManager, SerializedType? type)
	{
		EndianSpanReader reader = new EndianSpanReader(assetData, monoBehaviour.Collection.EndianType);
		try
		{
			monoBehaviour.Read(ref reader);
			SerializableStructure? structure;
			if (type is not null && TypeTreeNodeStruct.TryMakeFromTypeTree(type.OldType, out TypeTreeNodeStruct rootNode))
			{
				structure = SerializableTreeType.FromRootNode(rootNode, true).CreateSerializableStructure();
				if (structure.Type.Fields.Count > 0 && structure.Type.Fields[^1] is { Type.Name: "ManagedReferencesRegistry", Name: "references" })
				{
					Logger.Error(LogCategory.Import, $"MonoBehaviour has a field with the [SerializeReference] attribute, which is not currently supported.");
					monoBehaviour.Structure = null;
				}
				else if (structure.TryRead(ref reader, monoBehaviour))
				{
					monoBehaviour.Structure = structure;
				}
				else
				{
					monoBehaviour.Structure = null;
				}
			}
			else
			{
				monoBehaviour.Structure = new UnloadedStructure(monoBehaviour, assemblyManager, assetData.Slice(reader.Position));
			}
		}
		catch (Exception ex)
		{
			LogMonoBehaviorReadException(monoBehaviour, ex);
		}
		return monoBehaviour;
	}

	private static IUnityObjectBase ReadNormalObject(AssetInfo assetInfo, ReadOnlyArraySegment<byte> assetData)
	{
		IUnityObjectBase asset = TryReadNormalObject(assetInfo, assetData, assetInfo.Collection.Version, out string? error);
		if (error is null)
		{
			return asset;
		}
		else if (SpecialFileNames.IsDefaultResourceOrBuiltinExtra(assetInfo.Collection.Name))
		{
			if (asset is IShader)
			{
				Logger.Info(LogCategory.Import, $"Shader with PathID {asset.PathID} in {assetInfo.Collection.Name} uses engine type trees.");
			}
			else
			{
				Logger.Warning(LogCategory.Import, error);
			}
			return asset;
		}
		else if (assetInfo.Collection.Version.Type == UnityVersionType.Patch)
		{
			UnityVersion oldVersion = assetInfo.Collection.Version;
			UnityVersion newVersion = new UnityVersion(oldVersion.Major, oldVersion.Minor, unchecked((ushort)(oldVersion.Build + 1u)));
			IUnityObjectBase newAsset = TryReadNormalObject(assetInfo, assetData, newVersion, out string? newError);
			if (newError is null)
			{
				return newAsset;
			}
		}

		Logger.Error(LogCategory.Import, error);
		UnreadableObject unreadable = new UnreadableObject(asset.AssetInfo, assetData.ToArray());
		unreadable.Name = (asset as INamed)?.Name;
		return unreadable;
	}

	private static IUnityObjectBase TryReadNormalObject(AssetInfo assetInfo, ReadOnlySpan<byte> assetData, UnityVersion version, out string? error)
	{
		IUnityObjectBase? asset = CreateAsset(assetInfo, version);
		if (asset is null)
		{
			error = null;
			return new UnknownObject(assetInfo, assetData.ToArray());
		}
		EndianSpanReader reader = new EndianSpanReader(assetData, asset.Collection.EndianType);
		try
		{
			asset.Read(ref reader);
			if (reader.Position != reader.Length)
			{
				if (IsAllZero(assetData[reader.Position..]))
				{
					//Assume padding.
					error = null;
				}
				else if (reader.Length - reader.Position == 24 && asset is ITexture2D texture)
				{
					//Some Chinese Unity versions have extra fields appended to the global type trees.
					ReadExtraTextureFields(texture, ref reader);
					error = null;
				}
				else
				{
					error = MakeError_IncorrectNumberOfBytesRead(asset, ref reader);
				}
			}
			else
			{
				error = null;
			}
		}
		catch (Exception ex)
		{
			error = MakeError_ReadException(asset, ex);
		}
		return asset;

		static bool IsAllZero(ReadOnlySpan<byte> span)
		{
			foreach (byte b in span)
			{
				if (b != 0)
				{
					return false;
				}
			}
			return true;
		}
	}

	private static IUnityObjectBase? CreateAsset(AssetInfo assetInfo, UnityVersion version)
	{
		IUnityObjectBase? asset = AssetFactory.CreateSerialized(assetInfo, version);
		if (asset is null && TypeTreeNodeStruct.TryMakeFromTpk((ClassIDType)assetInfo.ClassID, version, out TypeTreeNodeStruct releaseRoot, out TypeTreeNodeStruct editorRoot))
		{
			return TypeTreeObject.Create(assetInfo, releaseRoot, editorRoot);
		}
		else
		{
			return asset;
		}
	}

	private static string MakeError_IncorrectNumberOfBytesRead(IUnityObjectBase asset, ref EndianSpanReader reader)
	{
		return $"Read {reader.Position} but expected {reader.Length} for asset type {(ClassIDType)asset.ClassID}. V: {asset.Collection.Version} P: {asset.Collection.Platform} N: {asset.Collection.Name} Path: {asset.Collection.FilePath}";
	}

	/// <summary>
	/// A special case for Chinese textures containing an extra 24 bytes at the end.
	/// </summary>
	/// <param name="reader"></param>
	private static void ReadExtraTextureFields(ITexture2D texture, ref EndianSpanReader reader)
	{
		//int m_OriginalWidth // ByteSize{4}, Index{26}, Version{1}, IsArray{0}, MetaFlag{10}
		//int m_OriginalHeight // ByteSize{4}, Index{27}, Version{1}, IsArray{0}, MetaFlag{10}
		//GUID m_OriginalAssetGuid // ByteSize{10}, Index{28}, Version{1}, IsArray{0}, MetaFlag{10}
		//unsigned int data[0] // ByteSize{4}, Index{29}, Version{1}, IsArray{0}, MetaFlag{10}
		//unsigned int data[1] // ByteSize{4}, Index{2a}, Version{1}, IsArray{0}, MetaFlag{10}
		//unsigned int data[2] // ByteSize{4}, Index{2b}, Version{1}, IsArray{0}, MetaFlag{10}
		//unsigned int data[3] // ByteSize{4}, Index{2c}, Version{1}, IsArray{0}, MetaFlag{10}
		texture.OriginalWidth_C28 = reader.ReadInt32();
		texture.OriginalHeight_C28 = reader.ReadInt32();
		texture.OriginalAssetGuid_C28.ReadRelease(ref reader);//Release and Editor are the same for GUID.
		Logger.Warning(LogCategory.Import, $"Texture {texture.Name} had an extra 24 bytes, which were assumed to be non-standard Chinese fields.");
	}

	private static void LogMonoBehaviorReadException(IMonoBehaviour monoBehaviour, Exception ex)
	{
		Logger.Error(LogCategory.Import, $"Unable to read {monoBehaviour}, because script {monoBehaviour.Structure} layout mismatched binary content ({ex.GetType().Name}).");
	}

	private static string MakeError_ReadException(IUnityObjectBase asset, Exception ex)
	{
		return $"Error during reading of asset type {(ClassIDType)asset.ClassID}. V: {asset.Collection.Version} P: {asset.Collection.Platform} N: {asset.Collection.Name} Path: {asset.Collection.FilePath}\n{ex}";
	}

	public static IUnityAssetBase CreateEngineAsset(string name, UnityVersion version)
	{
		return name switch
		{
			MonoUtils.GuidName => GUID.Create(),
			MonoUtils.Hash128Name => Hash128.Create(version),
			MonoUtils.Vector2Name => Vector2f.Create(),
			MonoUtils.Vector2IntName => Vector2Int.Create(),
			MonoUtils.Vector3Name => Vector3f.Create(),
			MonoUtils.Vector3IntName => Vector3Int.Create(),
			MonoUtils.Vector4Name => Vector4f.Create(),
			MonoUtils.RectName => Rectf.Create(),
			MonoUtils.BoundsName => AABB.Create(),
			MonoUtils.BoundsIntName => AABBInt.Create(),
			MonoUtils.QuaternionName => Quaternionf.Create(),
			MonoUtils.Matrix4x4Name => Matrix4x4f.Create(),
			MonoUtils.ColorName => ColorRGBAf.Create(),
			MonoUtils.Color32Name => ColorRGBA32.Create(),
			MonoUtils.LayerMaskName => LayerMask.Create(),
			MonoUtils.AnimationCurveName => AnimationCurve_Single.Create(version),
			//This is the new Gradient. The old one was (most likely) not exposed to user code.
			MonoUtils.GradientName => Gradient.Create(version),
			MonoUtils.RectOffsetName => RectOffset.Create(),
			MonoUtils.GUIStyleName => GUIStyle.Create(version),
			MonoUtils.PropertyNameName => PropertyName.Create(version),
			MonoUtils.SphericalHarmonicsL2Name => SphericalHarmonicsL2.Create(version),
			_ => throw new NotSupportedException(name),
		};
	}
}

```

`Source/AssetRipper.Import/AssetCreation/RawDataObject.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.IO.Writing;
using AssetRipper.Assets.Metadata;
using AssetRipper.Checksum;
using AssetRipper.SourceGenerated;

namespace AssetRipper.Import.AssetCreation;

public abstract class RawDataObject : NullObject
{
	public sealed override string ClassName => ((ClassIDType)ClassID).ToString();
	public byte[] RawData { get; }
	/// <summary>
	/// A Crc32 hash of <see cref="RawData"/>
	/// </summary>
	public uint RawDataHash { get; }

	public RawDataObject(AssetInfo assetInfo, byte[] data) : base(assetInfo)
	{
		RawData = data;
		RawDataHash = Crc32Algorithm.HashData(data);
	}

	public sealed override void WriteEditor(AssetWriter writer) => writer.Write(RawData);

	public sealed override void WriteRelease(AssetWriter writer) => writer.Write(RawData);
}

```

`Source/AssetRipper.Import/AssetCreation/TypeTreeObject.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.IO.Writing;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.Import.Structure.Assembly.Serializable;
using AssetRipper.Import.Structure.Assembly.TypeTrees;
using AssetRipper.IO.Endian;
using System.Diagnostics;

namespace AssetRipper.Import.AssetCreation;

[DebuggerDisplay($"{{{nameof(GetDebuggerDisplay)}(),nq}}")]
public abstract class TypeTreeObject : NullObject
{
	public bool IsPlayerSettings => ClassID == 129;
	public abstract SerializableStructure ReleaseFields { get; }
	public abstract SerializableStructure EditorFields { get; }
	public sealed override bool FlowMappedInYaml => EditorFields.FlowMappedInYaml;
	public sealed override int SerializedVersion => EditorFields.SerializedVersion;
	public sealed override string ClassName => EditorFields.Type.Name;

	private TypeTreeObject(AssetInfo assetInfo) : base(assetInfo)
	{
	}

	public sealed override void WriteRelease(AssetWriter writer) => ReleaseFields.WriteRelease(writer);

	public sealed override void WriteEditor(AssetWriter writer) => EditorFields.WriteEditor(writer);

	public sealed override void WalkRelease(AssetWalker walker) => ReleaseFields.WalkRelease(walker);

	public sealed override void WalkEditor(AssetWalker walker) => EditorFields.WalkEditor(walker);

	public static TypeTreeObject Create(AssetInfo assetInfo, TypeTreeNodeStruct root) => new SingleTypeTreeObject(assetInfo, root);

	public static TypeTreeObject Create(AssetInfo assetInfo, TypeTreeNodeStruct releaseRoot, TypeTreeNodeStruct editorRoot) => new DoubleTypeTreeObject(assetInfo, releaseRoot, editorRoot);

	private string GetDebuggerDisplay() => ClassName;

	private sealed class SingleTypeTreeObject : TypeTreeObject
	{
		public SerializableStructure Fields { get; }
		public override SerializableStructure ReleaseFields => Fields;
		public override SerializableStructure EditorFields => Fields;

		public SingleTypeTreeObject(AssetInfo assetInfo, TypeTreeNodeStruct root) : base(assetInfo)
		{
			Fields = SerializableTreeType.FromRootNode(root).CreateSerializableStructure();
		}

		public override void ReadRelease(ref EndianSpanReader reader)
		{
			Fields.Read(ref reader, Collection.Version, Collection.Flags);
		}

		public override void ReadEditor(ref EndianSpanReader reader)
		{
			Fields.Read(ref reader, Collection.Version, Collection.Flags);
		}

		public override void WalkStandard(AssetWalker walker)
		{
			Fields.WalkStandard(walker);
		}

		public override void Reset()
		{
			Fields.Reset();
		}

		public override IEnumerable<(string, PPtr)> FetchDependencies()
		{
			return Fields.FetchDependencies();
		}
	}

	private sealed class DoubleTypeTreeObject : TypeTreeObject
	{
		public override SerializableStructure ReleaseFields { get; }
		public override SerializableStructure EditorFields { get; }

		public DoubleTypeTreeObject(AssetInfo assetInfo, TypeTreeNodeStruct releaseRoot, TypeTreeNodeStruct editorRoot) : base(assetInfo)
		{
			ReleaseFields = SerializableTreeType.FromRootNode(releaseRoot).CreateSerializableStructure();
			EditorFields = SerializableTreeType.FromRootNode(editorRoot).CreateSerializableStructure();
		}

		public override void ReadRelease(ref EndianSpanReader reader)
		{
			ReleaseFields.Read(ref reader, Collection.Version, Collection.Flags);
			ConvertFields(ReleaseFields, EditorFields);
		}

		public override void ReadEditor(ref EndianSpanReader reader)
		{
			EditorFields.Read(ref reader, Collection.Version, Collection.Flags);
			ConvertFields(EditorFields, ReleaseFields);
		}

		public override void WalkStandard(AssetWalker walker)
		{
			if (walker.EnterAsset(this))
			{
				if (walker.EnterField(this, "Release"))
				{
					ReleaseFields.WalkStandard(walker);
					walker.ExitField(this, "Release");
				}
				walker.DivideAsset(this);
				if (walker.EnterField(this, "Editor"))
				{
					EditorFields.WalkStandard(walker);
					walker.ExitField(this, "Editor");
				}
				walker.ExitAsset(this);
			}
		}

		public override void Reset()
		{
			ReleaseFields.Reset();
			EditorFields.Reset();
		}

		public override IEnumerable<(string, PPtr)> FetchDependencies()
		{
			return ReleaseFields.FetchDependencies().Union(EditorFields.FetchDependencies());
		}

		private void ConvertFields(SerializableStructure source, SerializableStructure target)
		{
			target.CopyValues(source, new PPtrConverter(Collection, Collection));
		}
	}
}

```

`Source/AssetRipper.Import/AssetCreation/UnknownObject.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.Import.AssetCreation;

public sealed class UnknownObject : RawDataObject, INamed
{
	public Utf8String Name
	{
		get => $"Unknown{ClassName}_{RawDataHash:X}";
		set { }
	}

	public UnknownObject(AssetInfo assetInfo, byte[] data) : base(assetInfo, data) { }
}

```

`Source/AssetRipper.Import/AssetCreation/UnreadableObject.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.Import.AssetCreation;

public sealed class UnreadableObject : RawDataObject, INamed
{
	[AllowNull]
	[field: MaybeNull]
	public Utf8String Name
	{
		get
		{
			return Utf8String.IsNullOrEmpty(field)
				? $"Unreadable{ClassName}_{RawDataHash:X}"
				: field;
		}

		set;
	}

	public UnreadableObject(AssetInfo assetInfo, byte[] data) : base(assetInfo, data) { }
}

```

`Source/AssetRipper.Import/AssetRipper.Import.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.Import\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Import\$(Configuration)\</IntermediateOutputPath>
		<AllowUnsafeBlocks>true</AllowUnsafeBlocks>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AsmResolver.DotNet" Version="6.0.0-beta.5" />
		<PackageReference Include="AssetRipper.Cpp2IL.Core" Version="1.0.0" />
		<PackageReference Include="AssetRipper.Mining.PredefinedAssets" Version="1.5.0" />
		<PackageReference Include="AssetRipper.Primitives" Version="3.2.0" />
		<PackageReference Include="AssetRipper.Tpk" Version="1.1.0" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Assets\AssetRipper.Assets.csproj" />
		<ProjectReference Include="..\AssetRipper.Numerics\AssetRipper.Numerics.csproj" />
		<ProjectReference Include="..\AssetRipper.SerializationLogic\AssetRipper.SerializationLogic.csproj" />
		<ProjectReference Include="..\AssetRipper.SourceGenerated.Extensions\AssetRipper.SourceGenerated.Extensions.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Import/AssetRipperRuntimeInformation.cs`:

```cs
using AssetRipper.Import.Utils;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;
using System.Text;

namespace AssetRipper.Import;

public static partial class AssetRipperRuntimeInformation
{
	public static class Build
	{
		public static bool Debug
		{
			get
			{
#if DEBUG
				return true;
#else
				return false;
#endif
			}
		}

		/// <summary>
		/// Either "Debug" or "Release"
		/// </summary>
		public static string Configuration => Debug ? "Debug" : "Release";

		/// <summary>
		/// Either "Compiled" or "Published"
		/// </summary>
		public static string Type => File.Exists(ExecutingDirectory.Combine("AssetRipper.Assets.dll")) ? "Compiled" : "Published";

		public static string? Version => typeof(AssetRipperRuntimeInformation).Assembly.GetName().Version?.ToString();
	}

	public static string ProcessArchitecture
	{
		get
		{
			if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
			{
				return "x64";
			}
			else if (RuntimeInformation.ProcessArchitecture == Architecture.X86)
			{
				return "x86";
			}
			else if (RuntimeInformation.ProcessArchitecture == Architecture.Arm)
			{
				return "Arm";
			}
			else if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
			{
				return "Arm64";
			}
			else
			{
				return "Unknown";
			}
		}
	}

	/// <summary>
	/// Get the current time.
	/// </summary>
	/// <remarks>
	/// This format matches the format used in <see cref="CompileTime"/>
	/// </remarks>
	/// <returns>A string like "Thu Nov 24 18:39:37 UTC 2022"</returns>
	public static string CurrentTime
	{
		get
		{
			DateTime now = DateTime.UtcNow;
			StringBuilder sb = new();
			sb.Append(now.DayOfWeek switch
			{
				DayOfWeek.Sunday => "Sun",
				DayOfWeek.Monday => "Mon",
				DayOfWeek.Tuesday => "Tue",
				DayOfWeek.Wednesday => "Wed",
				DayOfWeek.Thursday => "Thu",
				DayOfWeek.Friday => "Fri",
				DayOfWeek.Saturday => "Sat",
				_ => throw new NotSupportedException(),
			});
			sb.Append(' ');
			sb.Append(now.Month switch
			{
				1 => "Jan",
				2 => "Feb",
				3 => "Mar",
				4 => "Apr",
				5 => "May",
				6 => "Jun",
				7 => "Jul",
				8 => "Aug",
				9 => "Sep",
				10 => "Oct",
				11 => "Nov",
				12 => "Dec",
				_ => throw new NotSupportedException(),
			});
			sb.Append(' ');
			sb.Append($"{now.Day,2}");
			sb.Append(' ');
			sb.Append(now.TimeOfDay.Hours.ToString("00", CultureInfo.InvariantCulture));
			sb.Append(':');
			sb.Append(now.TimeOfDay.Minutes.ToString("00", CultureInfo.InvariantCulture));
			sb.Append(':');
			sb.Append(now.TimeOfDay.Seconds.ToString("00", CultureInfo.InvariantCulture));
			sb.Append(" UTC ");
			sb.Append(now.Year);
			return sb.ToString();
		}
	}

	/// <summary>
	/// Get the time the application was compiled.
	/// </summary>
	/// <remarks>
	/// This format matches the format used in <see cref="CurrentTime"/>
	/// </remarks>
	/// <returns>A string like "Thu Nov 24 18:39:37 UTC 2022"</returns>
	public static string CompileTime
	{
		get
		{
			string path = ExecutingDirectory.Combine("compile_time.txt");
			if (File.Exists(path))
			{
				return File.ReadAllText(path).Trim();
			}
			else
			{
				return "Unknown";
			}
		}
	}

	public static class OS
	{
		public static string Name
		{
			get
			{
				if (OperatingSystem.IsWindows())
				{
					return "Windows";
				}
				else if (OperatingSystem.IsLinux())
				{
					return "Linux";
				}
				else if (OperatingSystem.IsMacOS())
				{
					return "MacOS";
				}
				else if (OperatingSystem.IsBrowser())
				{
					return "Browser";
				}
				else if (OperatingSystem.IsAndroid())
				{
					return "Android";
				}
				else if (OperatingSystem.IsIOS())
				{
					return "iOS";
				}
				else if (OperatingSystem.IsFreeBSD())
				{
					return "FreeBSD";
				}
				else
				{
					return "Other";
				}
			}
		}

		public static string Version => Environment.OSVersion.VersionString;
	}

	public static string RamQuantity
	{
		get
		{
			if (TryGetSystemMemory(out long totalMemoryInKilobytes))
			{
				return $"{totalMemoryInKilobytes / 1024 / 1024} GB";
			}
			else
			{
				return "Unknown GB";
			}
		}
	}

	private static bool TryGetSystemMemory(out long totalMemoryInKilobytes)
	{
		if (OperatingSystem.IsWindows())
		{
			return TryGetSystemMemoryWindows(out totalMemoryInKilobytes);
		}
		else if (OperatingSystem.IsLinux())
		{
			return TryGetSystemMemoryLinux(out totalMemoryInKilobytes);
		}
		else if (OperatingSystem.IsMacOS())
		{
			return TryGetSystemMemoryMacOS(out totalMemoryInKilobytes);
		}
		else
		{
			totalMemoryInKilobytes = default;
			return false;
		}
	}

	[SupportedOSPlatform("windows")]
	[LibraryImport("kernel32.dll", EntryPoint = "GetPhysicallyInstalledSystemMemory")]
	[return: MarshalAs(UnmanagedType.Bool)]
	private static partial bool TryGetSystemMemoryWindows(out long totalMemoryInKilobytes);

	[SupportedOSPlatform("macos")]
	private static bool TryGetSystemMemoryMacOS(out long totalMemoryInKilobytes)
	{
		try
		{
			using Process process = new()
			{
				StartInfo = new ProcessStartInfo
				{
					FileName = "/usr/sbin/sysctl",
					Arguments = "hw.memsize",
					RedirectStandardOutput = true,
					UseShellExecute = false,
					CreateNoWindow = true
				}
			};
			process.Start();
			string output = process.StandardOutput.ReadToEnd();
			process.WaitForExit();

			// Output is in format: hw.memsize: 17179869184
			string[] parts = output.Split(' ', StringSplitOptions.RemoveEmptyEntries);
			if (parts.Length == 2 && long.TryParse(parts[1], out long memoryInBytes))
			{
				totalMemoryInKilobytes = memoryInBytes / 1024;
				return true;
			}
		}
		catch
		{
		}
		totalMemoryInKilobytes = default;
		return false;
	}

	[SupportedOSPlatform("linux")]
	private static bool TryGetSystemMemoryLinux(out long totalMemoryInKilobytes)
	{
		totalMemoryInKilobytes = 0;
		try
		{
			using StreamReader reader = new("/proc/meminfo");
			string? line;
			while ((line = reader.ReadLine()) != null)
			{
				if (line.StartsWith("MemTotal:", StringComparison.Ordinal))
				{
					string[] parts = line.Split(' ', StringSplitOptions.RemoveEmptyEntries);
					if (parts.Length == 3 && long.TryParse(parts[1], out long memoryInKilobytes))
					{
						totalMemoryInKilobytes = memoryInKilobytes;
						return true;
					}
				}
			}
		}
		catch
		{
		}
		return false;
	}
}

```

`Source/AssetRipper.Import/Configuration/CoreConfiguration.cs`:

```cs
using AssetRipper.Import.Logging;
using AssetRipper.Import.Utils;
using System.Diagnostics;

namespace AssetRipper.Import.Configuration;

public class CoreConfiguration
{
	#region Import Settings
	/// <summary>
	/// Disabling scripts can allow some games to export when they previously did not.
	/// </summary>
	public bool DisableScriptImport => ImportSettings.ScriptContentLevel == ScriptContentLevel.Level0;

	public ImportSettings ImportSettings
	{
		get => SingletonData.GetStoredValue<ImportSettings>(nameof(ImportSettings));
		set => SingletonData.SetStoredValue(nameof(ImportSettings), value);
	}

	#endregion

	#region Export Settings
	/// <summary>
	/// The root path to export to
	/// </summary>
	public string ExportRootPath { get; set; } = "";
	/// <summary>
	/// The path to create a new unity project in
	/// </summary>
	public string ProjectRootPath => Path.Join(ExportRootPath, "ExportedProject");
	public string AssetsPath => Path.Join(ProjectRootPath, "Assets");
	public string ProjectSettingsPath => Path.Join(ProjectRootPath, "ProjectSettings");
	public string AuxiliaryFilesPath => Path.Join(ExportRootPath, "AuxiliaryFiles");
	#endregion

	#region Project Settings
	public UnityVersion Version { get; private set; }
	#endregion

	public SingletonDataStorage SingletonData { get; } = new();
	public ListDataStorage ListData { get; } = new();

	public CoreConfiguration()
	{
		ResetToDefaultValues();
		AddDebugData();
		SingletonData.Add(nameof(ImportSettings), new JsonDataInstance<ImportSettings>(ImportSettingsContext.Default.ImportSettings));
	}

	public void SetProjectSettings(UnityVersion version)
	{
		Version = version;
	}

	public virtual void ResetToDefaultValues()
	{
		ExportRootPath = ExecutingDirectory.Combine("Ripped");
		SingletonData.Clear();
		ListData.Clear();
	}

	public virtual void LogConfigurationValues()
	{
		Logger.Info(LogCategory.General, $"Configuration Settings:");
		Logger.Info(LogCategory.General, $"{nameof(ExportRootPath)}: {ExportRootPath}");
		ImportSettings.Log();
	}

	[Conditional("DEBUG")]
	private void AddDebugData()
	{
		SingletonData.Add("README", "This is a singleton entry. It is used to store information that can be contained in a single file.");
		ListData.Add("README", ["This is a list entry. It is used to store information that might be contained in multiple files."]);
		ListData.Add("Fibonacci", [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]);
		ListData.Add("Unused Key", []);
	}
}

```

`Source/AssetRipper.Import/Configuration/DataEntry.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public abstract class DataEntry
{
	public abstract void Clear();
}

```

`Source/AssetRipper.Import/Configuration/DataInstance.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public abstract class DataInstance : DataEntry
{
	public abstract string Text { get; set; }
}
public class DataInstance<T> : DataInstance
{
	private readonly DataSerializer<T> serializer;
	public DataInstance(DataSerializer<T> serializer)
	{
		this.serializer = serializer;
		Value = serializer.CreateNew();
	}
	public DataInstance(DataSerializer<T> serializer, T value)
	{
		this.serializer = serializer;
		Value = value;
	}
	public T Value { get; set; }
	public sealed override string Text
	{
		get => serializer.Serialize(Value);
		set => Value = serializer.Deserialize(value);
	}
	public sealed override void Clear() => Value = serializer.CreateNew();
}

```

`Source/AssetRipper.Import/Configuration/DataSerializer.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public abstract class DataSerializer<T>
{
	public abstract T Deserialize(string text);
	public abstract string Serialize(T value);
	public abstract T CreateNew();
}

```

`Source/AssetRipper.Import/Configuration/DataSet.cs`:

```cs
using System.Collections;

namespace AssetRipper.Import.Configuration;

public abstract class DataSet : DataEntry, IEnumerable
{
	public StringAccessor Strings => this;
	public abstract void RemoveAt(int index);
	public abstract int Count { get; }
	protected abstract string GetAsString(int index);
	protected abstract void SetFromString(int index, string value);
	protected abstract void AddString(string value);
	protected abstract void AddStrings(IEnumerable<string> values);
	public abstract IEnumerator GetEnumerator();

	public readonly record struct StringAccessor(DataSet Values) : IReadOnlyList<string>
	{
		public string this[int index]
		{
			get => Values.GetAsString(index);
			set => Values.SetFromString(index, value);
		}

		public int Count => Values.Count;

		public void Add(string item) => Values.AddString(item);

		public void AddRange(IEnumerable<string> collection) => Values.AddStrings(collection);

		public void Clear() => Values.Clear();

		public void RemoveAt(int index) => Values.RemoveAt(index);

		public IEnumerator<string> GetEnumerator()
		{
			for (int i = 0; i < Values.Count; i++)
			{
				yield return Values.GetAsString(i);
			}
		}

		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

		public static implicit operator StringAccessor(DataSet values) => new(values);
		public static implicit operator DataSet(StringAccessor accessor) => accessor.Values;
	}
}
public class DataSet<T> : DataSet, IReadOnlyList<T>
{
	private readonly List<T> list = new();
	private readonly DataSerializer<T> serializer;

	public DataSet(DataSerializer<T> serializer)
	{
		this.serializer = serializer;
		list = new();
	}

	public DataSet(DataSerializer<T> serializer, List<T> list)
	{
		this.serializer = serializer;
		this.list = list;
	}

	public sealed override int Count => list.Count;

	public T this[int index]
	{
		get => list[index];
		set => list[index] = value;
	}

	public void Add(T item) => list.Add(item);

	public void AddNew() => Add(serializer.CreateNew());

	protected sealed override void AddString(string value) => Add(serializer.Deserialize(value));

	protected sealed override void AddStrings(IEnumerable<string> values)
	{
		EnsureCapacityIfCountAvailable(values);
		foreach (string value in values)
		{
			AddString(value);
		}

		void EnsureCapacityIfCountAvailable(IEnumerable<string> values)
		{
			if (values is IReadOnlyCollection<string> collection)
			{
				list.EnsureCapacity(list.Count + collection.Count);
			}
		}
	}

	public sealed override void Clear() => list.Clear();

	public bool Contains(T item) => list.Contains(item);

	public sealed override void RemoveAt(int index) => list.RemoveAt(index);

	protected sealed override string GetAsString(int index) => serializer.Serialize(this[index]);

	protected sealed override void SetFromString(int index, string value) => this[index] = serializer.Deserialize(value);

	public override IEnumerator<T> GetEnumerator() => list.GetEnumerator();
}

```

`Source/AssetRipper.Import/Configuration/DataStorage.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public class DataStorage<T> where T : DataEntry
{
	protected readonly Dictionary<string, T> data = new();

	public IEnumerable<string> Keys => data.Keys;

	public T? this[string key]
	{
		get => data.TryGetValue(key, out T? value) ? value : default;
	}

	public bool TryGetValue<TValue>(string key, [NotNullWhen(true)] out TValue? value) where TValue : T
	{
		if (data.TryGetValue(key, out T? storedValue))
		{
			value = storedValue as TValue;
			return value is not null;
		}
		else
		{
			value = default;
			return false;
		}
	}

	public TValue GetValue<TValue>(string key) where TValue : T
	{
		if (TryGetValue(key, out TValue? storedValue))
		{
			return storedValue;
		}
		else
		{
			throw new KeyNotFoundException();
		}
	}

	public void Add(string key, T value)
	{
		data.Add(key, value);
	}

	public void Clear()
	{
		foreach (T value in data.Values)
		{
			value.Clear();
		}
	}
}

```

`Source/AssetRipper.Import/Configuration/ImportSettings.cs`:

```cs
using AssetRipper.Import.Logging;
using System.Text.Json.Serialization;

namespace AssetRipper.Import.Configuration;

public sealed record class ImportSettings
{
	/// <summary>
	/// The level of scripts to export
	/// </summary>
	public ScriptContentLevel ScriptContentLevel { get; set; } = ScriptContentLevel.Level2;

	/// <summary>
	/// Including the streaming assets directory can cause some games to fail while exporting.
	/// </summary>
	[JsonIgnore]
	public bool IgnoreStreamingAssets
	{
		get => StreamingAssetsMode == StreamingAssetsMode.Ignore;
		set
		{
			StreamingAssetsMode = value ? StreamingAssetsMode.Ignore : StreamingAssetsMode.Extract;
		}
	}

	/// <summary>
	/// How the StreamingAssets folder is handled
	/// </summary>
	public StreamingAssetsMode StreamingAssetsMode { get; set; } = StreamingAssetsMode.Extract;

	/// <summary>
	/// The default version used when no version is specified, ie when the version has been stripped.
	/// </summary>
	[JsonConverter(typeof(UnityVersionJsonConverter))]
	public UnityVersion DefaultVersion { get; set; }

	/// <summary>
	/// The target version to convert all assets to. Experimental
	/// </summary>
	[JsonConverter(typeof(UnityVersionJsonConverter))]
	public UnityVersion TargetVersion { get; set; }

	public void Log()
	{
		Logger.Info(LogCategory.General, $"{nameof(ScriptContentLevel)}: {ScriptContentLevel}");
		Logger.Info(LogCategory.General, $"{nameof(StreamingAssetsMode)}: {StreamingAssetsMode}");
		Logger.Info(LogCategory.General, $"{nameof(DefaultVersion)}: {DefaultVersion}");
		Logger.Info(LogCategory.General, $"{nameof(TargetVersion)}: {TargetVersion}");
	}
}

```

`Source/AssetRipper.Import/Configuration/ImportSettingsContext.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.Import.Configuration;

[JsonSourceGenerationOptions(WriteIndented = true)]
[JsonSerializable(typeof(ImportSettings))]
internal sealed partial class ImportSettingsContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.Import/Configuration/JsonDataInstance.cs`:

```cs
using System.Text.Json.Serialization.Metadata;

namespace AssetRipper.Import.Configuration;

public class JsonDataInstance<T> : DataInstance<T> where T : new()
{
	public JsonDataInstance(JsonTypeInfo<T> typeInfo) : base(new JsonDataSerializer<T>(typeInfo))
	{
	}
}

```

`Source/AssetRipper.Import/Configuration/JsonDataSerializer.cs`:

```cs
using System.Text.Json;
using System.Text.Json.Serialization.Metadata;

namespace AssetRipper.Import.Configuration;

public sealed class JsonDataSerializer<T> : DataSerializer<T> where T : new()
{
	private readonly JsonTypeInfo<T> typeInfo;

	public JsonDataSerializer(JsonTypeInfo<T> typeInfo)
	{
		this.typeInfo = typeInfo;
	}

	public override T Deserialize(string text)
	{
		if (string.IsNullOrEmpty(text))
		{
			return CreateNew();
		}

		// Forgiving parsing
		try
		{
			return JsonSerializer.Deserialize(text, typeInfo) ?? CreateNew();
		}
		catch
		{
			return CreateNew();
		}
	}

	public override string Serialize(T value)
	{
		string result = JsonSerializer.Serialize(value, typeInfo);
		return result is "null" ? "" : result;
	}

	public override T CreateNew() => new();
}

```

`Source/AssetRipper.Import/Configuration/JsonDataSet.cs`:

```cs
using System.Text.Json.Serialization.Metadata;

namespace AssetRipper.Import.Configuration;

public sealed class JsonDataSet<T> : DataSet<T> where T : new()
{
	public JsonDataSet(JsonTypeInfo<T> typeInfo) : base(new JsonDataSerializer<T>(typeInfo))
	{
	}

	public JsonDataSet(JsonTypeInfo<T> typeInfo, List<T> list) : base(new JsonDataSerializer<T>(typeInfo), list)
	{
	}
}

```

`Source/AssetRipper.Import/Configuration/ListDataStorage.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public sealed class ListDataStorage : DataStorage<DataSet>
{
	public void Add(string key, List<string> value)
	{
		Add(key, new StringDataSet(value));
	}

	public void Add<T>(string key, List<T> value) where T : IParsable<T>, new()
	{
		Add(key, new ParsableDataSet<T>(value));
	}
}

```

`Source/AssetRipper.Import/Configuration/ParsableDataInstance.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public class ParsableDataInstance<T> : DataInstance<T> where T : IParsable<T>, new()
{
	public ParsableDataInstance() : base(ParsableDataSerializer<T>.Instance)
	{
	}
}

```

`Source/AssetRipper.Import/Configuration/ParsableDataSerializer.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public sealed class ParsableDataSerializer<T> : DataSerializer<T> where T : IParsable<T>, new()
{
	public static ParsableDataSerializer<T> Instance { get; } = new();

	public override T Deserialize(string text)
	{
		if (string.IsNullOrEmpty(text))
		{
			return CreateNew();
		}

		// Forgiving parsing
		if (T.TryParse(text, null, out T? value))
		{
			return value;
		}
		else
		{
			return CreateNew();
		}
	}

	public override string Serialize(T value) => value.ToString() ?? "";
	public override T CreateNew() => new();
}

```

`Source/AssetRipper.Import/Configuration/ParsableDataSet.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public sealed class ParsableDataSet<T> : DataSet<T> where T : IParsable<T>, new()
{
	public ParsableDataSet() : base(ParsableDataSerializer<T>.Instance)
	{
	}

	public ParsableDataSet(List<T> list) : base(ParsableDataSerializer<T>.Instance, list)
	{
	}
}

```

`Source/AssetRipper.Import/Configuration/ScriptContentLevel.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public enum ScriptContentLevel
{
	/// <summary>
	/// Scripts are not loaded.
	/// </summary>
	Level0,
	/// <summary>
	/// Methods are stubbed during processing.
	/// </summary>
	Level1,
	/// <summary>
	/// This level is the default. It has full methods for Mono games and empty methods for IL2Cpp games.
	/// </summary>
	Level2,
	/// <summary>
	/// IL2Cpp methods are safely recovered where possible.
	/// </summary>
	Level3,
	/// <summary>
	/// IL2Cpp methods are recovered without regard to safety. Currently the same as <see cref="Level2"/>
	/// </summary>
	//Level4,
}

```

`Source/AssetRipper.Import/Configuration/SingletonDataStorage.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public sealed class SingletonDataStorage : DataStorage<DataInstance>
{
	public void Add(string key, string value)
	{
		Add(key, new StringDataInstance() { Value = value });
	}

	public bool TryGetStoredValue<T>(string key, [MaybeNullWhen(false)] out T value)
	{
		if (data.TryGetValue(key, out DataInstance? storedValue) && storedValue is DataInstance<T> instance)
		{
			value = instance.Value;
			return true;
		}
		else
		{
			value = default;
			return false;
		}
	}

	public T GetStoredValue<T>(string key)
	{
		if (data.TryGetValue(key, out DataInstance? storedValue) && storedValue is DataInstance<T> instance)
		{
			return instance.Value;
		}
		else
		{
			throw new KeyNotFoundException();
		}
	}

	public void SetStoredValue<T>(string key, T value)
	{
		if (data.TryGetValue(key, out DataInstance? storedValue) && storedValue is DataInstance<T> instance)
		{
			instance.Value = value;
		}
		else
		{
			throw new KeyNotFoundException();
		}
	}
}

```

`Source/AssetRipper.Import/Configuration/StreamingAssetsMode.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public enum StreamingAssetsMode
{
	Ignore,
	Extract,
}

```

`Source/AssetRipper.Import/Configuration/StringDataInstance.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public class StringDataInstance : DataInstance<string>
{
	public StringDataInstance() : base(StringDataSerializer.Instance)
	{
	}
}

```

`Source/AssetRipper.Import/Configuration/StringDataSerializer.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public sealed class StringDataSerializer : DataSerializer<string>
{
	public static StringDataSerializer Instance { get; } = new();

	public override string Deserialize(string text) => text;
	public override string Serialize(string value) => value;
	public override string CreateNew() => "";
}

```

`Source/AssetRipper.Import/Configuration/StringDataSet.cs`:

```cs
namespace AssetRipper.Import.Configuration;

public sealed class StringDataSet : DataSet<string>
{
	public StringDataSet() : base(StringDataSerializer.Instance)
	{
	}

	public StringDataSet(List<string> list) : base(StringDataSerializer.Instance, list)
	{
	}
}

```

`Source/AssetRipper.Import/Configuration/UnityVersionJsonConverter.cs`:

```cs
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AssetRipper.Import.Configuration;

public sealed class UnityVersionJsonConverter : JsonConverter<UnityVersion>
{
	public override UnityVersion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		return UnityVersion.Parse(reader.GetString() ?? throw new JsonException("String was read as null"));
	}

	public override void Write(Utf8JsonWriter writer, UnityVersion value, JsonSerializerOptions options)
	{
		writer.WriteStringValue(value.ToString());
	}
}

```

`Source/AssetRipper.Import/Logging/CleanFileLogger.cs`:

```cs
namespace AssetRipper.Import.Logging;

/// <summary>
/// A file logger that doesn't include log types in the output.
/// </summary>
public class CleanFileLogger : FileLoggerBase
{
	public CleanFileLogger() : base() { }

	/// <param name="filePath">The absolute path to the log file</param>
	public CleanFileLogger(string filePath) : base(filePath) { }

	public sealed override void Log(LogType type, LogCategory category, string message)
	{
		try
		{
			File.AppendAllText(filePath, $"{message}{Environment.NewLine}");
		}
		catch (IOException)
		{
			//Could not log to file
		}
	}
}

```

`Source/AssetRipper.Import/Logging/ConsoleLogger.cs`:

```cs
namespace AssetRipper.Import.Logging;

public class ConsoleLogger : ILogger
{
	public ConsoleLogger() : this(false) { }
	/// <param name="resizeConsole">If true, on Windows it will resize the console to 80% of the maximum size.</param>
	public ConsoleLogger(bool resizeConsole)
	{
		if (resizeConsole && OperatingSystem.IsWindows())
		{
			try
			{
				Console.WindowWidth = (int)(Console.LargestWindowWidth * 0.8f);
				Console.WindowHeight = (int)(Console.LargestWindowHeight * 0.8f);
				Console.BufferHeight = 2000;
			}
			catch
			{
				// pull/563 : happens when running in any context where the console is not actually attached to a TTY
			}
		}
	}

	public void BlankLine(int numLines)
	{
		for (int i = 0; i < numLines; i++)
		{
			Console.WriteLine();
		}
	}

	public void Log(LogType type, LogCategory category, string message)
	{
		if (type == LogType.Info)
		{
			if (category == LogCategory.None)
			{
				Console.WriteLine(message);
			}
			else
			{
				Console.WriteLine($"{category} : {message}");
			}

			return;
		}

		ConsoleColor foreColor = Console.ForegroundColor;

		switch (type)
		{
			case LogType.Debug:
				Console.ForegroundColor = ConsoleColor.DarkBlue;
				break;

			case LogType.Verbose:
				Console.ForegroundColor = ConsoleColor.DarkGray;
				break;

			case LogType.Warning:
				Console.ForegroundColor = ConsoleColor.DarkYellow;
				break;

			case LogType.Error:
				Console.ForegroundColor = ConsoleColor.DarkRed;
				break;
		}

		if (category == LogCategory.None)
		{
			Console.WriteLine(message);
		}
		else
		{
			Console.WriteLine($"{category} : {message}");
		}

		Console.ForegroundColor = foreColor;
	}
}

```

`Source/AssetRipper.Import/Logging/FileLogger.cs`:

```cs
using System.Text;

namespace AssetRipper.Import.Logging;

public class FileLogger : FileLoggerBase
{
	private readonly StringBuilder stringBuilder = new();

	public FileLogger() : base() { }

	/// <param name="filePath">The absolute path to the log file</param>
	public FileLogger(string filePath) : base(filePath) { }

	public sealed override void Log(LogType type, LogCategory category, string message)
	{
		stringBuilder.Clear();

		if (category != LogCategory.None)
		{
			stringBuilder.Append($"{category.ToString()} ");
		}

		switch (type)
		{
			case LogType.Warning:
			case LogType.Error:
				stringBuilder.Append($"[{type.ToString()}] ");
				break;
		}
		stringBuilder.Append(": ");
		stringBuilder.Append(message);
		stringBuilder.Append(Environment.NewLine);
		try
		{
			File.AppendAllText(filePath, stringBuilder.ToString());
		}
		catch (IOException)
		{
			//Could not log to file
		}
	}
}

```

`Source/AssetRipper.Import/Logging/FileLoggerBase.cs`:

```cs
using AssetRipper.Import.Utils;

namespace AssetRipper.Import.Logging;

public abstract class FileLoggerBase : ILogger
{
	protected readonly string filePath;

	public FileLoggerBase() : this(ExecutingDirectory.Combine("AssetRipper.log")) { }

	/// <param name="filePath">The absolute path to the log file</param>
	public FileLoggerBase(string filePath)
	{
		if (string.IsNullOrWhiteSpace(filePath))
		{
			throw new ArgumentException("Invalid path", nameof(filePath));
		}

		this.filePath = filePath;

		File.Create(this.filePath).Close();
	}

	public abstract void Log(LogType type, LogCategory category, string message);

	public void BlankLine(int numLines)
	{
		try
		{
			File.AppendAllLines(filePath, Enumerable.Repeat("", numLines));
		}
		catch (IOException)
		{
			//Could not log to file
		}
	}
}

```

`Source/AssetRipper.Import/Logging/ILogger.cs`:

```cs
namespace AssetRipper.Import.Logging;

public interface ILogger
{
	void Log(LogType type, LogCategory category, string message);

	void BlankLine(int numLines);
}

```

`Source/AssetRipper.Import/Logging/LogCategory.cs`:

```cs
namespace AssetRipper.Import.Logging;

public enum LogCategory
{
	General,
	Import,
	Export,
	ExportProgress,
	Cpp2IL,
	System,
	LibVlc,
	Avalonia,
	Plugin,
	Processing,

	None,
	Debug,
}

```

`Source/AssetRipper.Import/Logging/LogType.cs`:

```cs
namespace AssetRipper.Import.Logging;

public enum LogType
{
	Info,
	Warning,
	Error,
	Verbose,
	Debug,
}

```

`Source/AssetRipper.Import/Logging/Logger.cs`:

```cs
using System.Text;

namespace AssetRipper.Import.Logging;

public static class Logger
{
	private static readonly object _lock = new();
	private static readonly List<ILogger> loggers = new();
	public static bool AllowVerbose { get; set; }

	public static event Action<string, object?> OnStatusChanged = (_, _) => { };

	static Logger()
	{
		Cpp2IL.Core.Logging.Logger.InfoLog += (message, source) => LogCpp2IL(LogType.Info, message);
		Cpp2IL.Core.Logging.Logger.WarningLog += (message, source) => LogCpp2IL(LogType.Verbose, message);
		Cpp2IL.Core.Logging.Logger.ErrorLog += (message, source) => LogCpp2IL(LogType.Error, message);
		Cpp2IL.Core.Logging.Logger.VerboseLog += (message, source) => LogCpp2IL(LogType.Verbose, message);
	}

	private static void LogCpp2IL(LogType logType, string message)
	{
		Log(logType, LogCategory.Cpp2IL, message.Trim());
	}

	public static void Log(LogType type, LogCategory category, string message)
	{
		if (AssetRipperRuntimeInformation.Build.Debug && type == LogType.Debug)
		{
			return;
		}

		if (type == LogType.Verbose && !AllowVerbose)
		{
			return;
		}

		ArgumentNullException.ThrowIfNull(message);

		lock (_lock)
		{
			foreach (ILogger instance in loggers)
			{
				instance?.Log(type, category, message);
			}
		}
	}

	public static void Log(LogType type, LogCategory category, string[] messages)
	{
		ArgumentNullException.ThrowIfNull(messages);

		foreach (string message in messages)
		{
			Log(type, category, message);
		}
	}

	public static void BlankLine() => BlankLine(1);
	public static void BlankLine(int numLines)
	{
		foreach (ILogger instance in loggers)
		{
			instance?.BlankLine(numLines);
		}
	}

	public static void Info(string message) => Log(LogType.Info, LogCategory.None, message);
	public static void Info(LogCategory category, string message) => Log(LogType.Info, category, message);
	public static void Warning(string message) => Log(LogType.Warning, LogCategory.None, message);
	public static void Warning(LogCategory category, string message) => Log(LogType.Warning, category, message);
	public static void Error(string message) => Log(LogType.Error, LogCategory.None, message);
	public static void Error(LogCategory category, string message) => Log(LogType.Error, category, message);
	public static void Error(Exception e) => Error(LogCategory.None, null, e);
	public static void Error(string message, Exception e) => Error(LogCategory.None, message, e);
	public static void Error(LogCategory category, string? message, Exception e)
	{
		StringBuilder sb = new();
		if (message != null)
		{
			sb.AppendLine(message);
		}

		sb.AppendLine(e.ToString());
		Log(LogType.Error, category, sb.ToString());
	}
	public static void Verbose(string message) => Log(LogType.Verbose, LogCategory.None, message);
	public static void Verbose(LogCategory category, string message) => Log(LogType.Verbose, category, message);
	public static void Debug(string message) => Log(LogType.Debug, LogCategory.None, message);
	public static void Debug(LogCategory category, string message) => Log(LogType.Debug, category, message);

	private static void ErrorIfBigEndian()
	{
		if (!BitConverter.IsLittleEndian)
		{
			Error("Big Endian processors are not supported!");
		}
	}

	public static void LogSystemInformation(string programName)
	{
		Log(LogType.Info, LogCategory.System, programName);
		Log(LogType.Info, LogCategory.System, $"System Version: {AssetRipperRuntimeInformation.OS.Version}");
		Log(LogType.Info, LogCategory.System, $"Operating System: {AssetRipperRuntimeInformation.OS.Name} {AssetRipperRuntimeInformation.ProcessArchitecture}");
		ErrorIfBigEndian();
		Log(LogType.Info, LogCategory.System, $"AssetRipper Version: {AssetRipperRuntimeInformation.Build.Version}");
		Log(LogType.Info, LogCategory.System, $"AssetRipper Build Type: {AssetRipperRuntimeInformation.Build.Configuration} {AssetRipperRuntimeInformation.Build.Type}");
		Log(LogType.Info, LogCategory.System, $"UTC Current Time: {AssetRipperRuntimeInformation.CurrentTime}");
		Log(LogType.Info, LogCategory.System, $"UTC Compile Time: {AssetRipperRuntimeInformation.CompileTime}");
	}

	public static void Add(ILogger logger) => loggers.Add(logger);

	public static void Remove(ILogger logger) => loggers.Remove(logger);

	public static void Clear() => loggers.Clear();

	public static void SendStatusChange(string newStatus, object? context = null) => OnStatusChanged(newStatus, context);
}

```

`Source/AssetRipper.Import/Structure/Assembly/Managers/BaseManager.Resolver.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;

namespace AssetRipper.Import.Structure.Assembly.Managers;

public partial class BaseManager
{
	private sealed class Resolver : IAssemblyResolver
	{
		private static readonly SignatureComparer Comparer = new(SignatureComparisonFlags.VersionAgnostic);
		private readonly Dictionary<AssemblyDescriptor, AssemblyDefinition> cache = new(Comparer);
		private readonly BaseManager assemblyManager;

		public Resolver(BaseManager assemblyManager)
		{
			this.assemblyManager = assemblyManager;
		}

		public void AddToCache(AssemblyDescriptor descriptor, AssemblyDefinition definition)
		{
			if (cache.ContainsKey(descriptor))
			{
				throw new ArgumentException("The cache already contains an entry of assembly " + descriptor.FullName + ".", "descriptor");
			}
			if (!Comparer.Equals(descriptor, definition))
			{
				throw new ArgumentException("Assembly descriptor and definition do not refer to the same assembly.");
			}
			cache.Add(descriptor, definition);
		}

		public void ClearCache()
		{
			cache.Clear();
		}

		public bool HasCached(AssemblyDescriptor descriptor)
		{
			return cache.ContainsKey(descriptor);
		}

		public bool RemoveFromCache(AssemblyDescriptor descriptor)
		{
			return cache.Remove(descriptor);
		}

		public AssemblyDefinition? Resolve(AssemblyDescriptor assembly)
		{
			if (cache.TryGetValue(assembly, out AssemblyDefinition? value))
			{
				return value;
			}
			value = ResolveImplementation(assembly);
			if (value != null)
			{
				cache.Add(assembly, value);
			}
			return value;
		}

		private AssemblyDefinition? ResolveImplementation(AssemblyDescriptor assembly)
		{
			string? name = assembly.Name;
			if (name is not null && assemblyManager.m_assemblies.TryGetValue(name, out AssemblyDefinition? assemblyDefinition))
			{
				return assemblyDefinition;
			}
			else
			{
				return null;
			}
		}
	}

}

```

`Source/AssetRipper.Import/Structure/Assembly/Managers/BaseManager.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Builder;
using AsmResolver.DotNet.Signatures;
using AsmResolver.PE.Builder;
using AssetRipper.Import.Structure.Platforms;
using AssetRipper.IO.Files;
using AssetRipper.SerializationLogic;

namespace AssetRipper.Import.Structure.Assembly.Managers;

public partial class BaseManager : IAssemblyManager
{
	public bool IsSet => ScriptingBackend != ScriptingBackend.Unknown;
	public virtual ScriptingBackend ScriptingBackend => ScriptingBackend.Unknown;

	protected readonly Dictionary<string, AssemblyDefinition?> m_assemblies = new();
	protected readonly Dictionary<AssemblyDefinition, Stream> m_assemblyStreams = new(SignatureComparer.Default);
	protected readonly Dictionary<string, bool> m_validTypes = new();
	private readonly Dictionary<FieldSerializer, Dictionary<ITypeDefOrRef, SerializableType>> monoTypeCache = new();

	private event Action<string> m_requestAssemblyCallback;
	private readonly Dictionary<string, SerializableType> m_serializableTypes = new();
	private readonly Resolver assemblyResolver;
	public IAssemblyResolver AssemblyResolver => assemblyResolver;

	public BaseManager(Action<string> requestAssemblyCallback)
	{
		m_requestAssemblyCallback = requestAssemblyCallback ?? throw new ArgumentNullException(nameof(requestAssemblyCallback));
		assemblyResolver = new Resolver(this);
	}

	public virtual void Initialize(PlatformGameStructure gameStructure) { }

	protected static string GetUniqueName(ITypeDefOrRef type)
	{
		string assembly = SpecialFileNames.RemoveAssemblyFileExtension(type.Scope?.Name ?? "");
		return ScriptIdentifier.ToUniqueName(assembly, type.FullName);
	}

	public virtual void Load(string filePath, FileSystem fileSystem)
	{
		Stream stream = fileSystem.File.OpenRead(filePath);
		AssemblyDefinition assembly;
		try
		{
			assembly = AssemblyDefinition.FromStream(stream);
		}
		catch (BadImageFormatException badImageFormatException)
		{
			throw new BadImageFormatException($"Could not read {filePath}", badImageFormatException);
		}

		string fileName = fileSystem.Path.GetFileNameWithoutExtension(filePath);
		m_assemblies.Add(fileName, assembly);

		m_assemblyStreams.Add(assembly, stream);

		Add(assembly);
	}

	public void Add(AssemblyDefinition assembly)
	{
		assembly.InitializeResolvers(this);
		string assemblyName = ToAssemblyName(assembly);
		m_assemblies[assemblyName] = assembly;
	}

	public Stream GetStreamForAssembly(AssemblyDefinition assembly)
	{
		if (m_assemblyStreams.TryGetValue(assembly, out Stream? result))
		{
			return result;
		}
		else
		{
			MemoryStream memoryStream = new();
			assembly.ManifestModule?.ToPEImage(new ManagedPEImageBuilder(), false).ToPEFile(new ManagedPEFileBuilder()).Write(memoryStream);
			m_assemblyStreams.Add(assembly, memoryStream);
			return memoryStream;
		}
	}

	public void ClearStreamCache()
	{
		m_assemblyStreams.Clear();
	}

	private static string ToAssemblyName(AssemblyDefinition assembly)
	{
		return SpecialFileNames.RemoveAssemblyFileExtension(assembly.Name?.ToString() ?? "");
	}

	public virtual void Read(Stream stream, string fileName)
	{
		AssemblyDefinition assembly = AssemblyDefinition.FromStream(stream);
		assembly.InitializeResolvers(this);
		fileName = Path.GetFileNameWithoutExtension(fileName);
		string assemblyName = ToAssemblyName(assembly);
		m_assemblies.Add(fileName, assembly);
		m_assemblies[assemblyName] = assembly;
		m_assemblyStreams.Add(assembly, stream);
	}

	public virtual void Unload(string fileName)
	{
		if (m_assemblies.TryGetValue(fileName, out AssemblyDefinition? assembly))
		{
			m_assemblies.Remove(fileName);
			if (assembly is not null && m_assemblyStreams.TryGetValue(assembly, out Stream? stream))
			{
				m_assemblyStreams.Remove(assembly);
				stream.Dispose();
			}
		}
	}

	public virtual bool IsAssemblyLoaded(string assembly)
	{
		return m_assemblies.ContainsKey(assembly);
	}

	public virtual bool IsPresent(ScriptIdentifier scriptID)
	{
		if (!IsSet)
		{
			return false;
		}

		if (scriptID.IsDefault)
		{
			return false;
		}
		else
		{
			return FindType(scriptID.Assembly, scriptID.Namespace, scriptID.Name) != null;
		}
	}

	public virtual bool IsValid(ScriptIdentifier scriptID)
	{
		if (!IsSet)
		{
			return false;
		}

		if (scriptID.IsDefault)
		{
			return false;
		}

		TypeDefinition? type = FindType(scriptID);
		if (type == null)
		{
			return false;
		}

		if (type.IsAbstract)
		{
			return false;
		}

		return true;
	}

	public virtual TypeDefinition GetTypeDefinition(ScriptIdentifier scriptID)
	{
		return FindType(scriptID) ?? throw new ArgumentException($"Can't find type {scriptID.UniqueName}");
	}

	public virtual ScriptIdentifier GetScriptID(string assembly, string @namespace, string name)
	{
		if (!IsSet)
		{
			return default;
		}

		TypeDefinition? type = FindType(assembly, @namespace, name);
		if (type == null)
		{
			return default;
		}
		return new ScriptIdentifier(assembly, type.Namespace ?? "", type.Name ?? "");
	}

	public bool TryGetSerializableType(
		ScriptIdentifier scriptID,
		UnityVersion version,
		[NotNullWhen(true)] out SerializableType? scriptType,
		[NotNullWhen(false)] out string? failureReason)
	{
		if (m_serializableTypes.TryGetValue(scriptID.UniqueName, out scriptType))
		{
			failureReason = null;
			return true;
		}
		TypeDefinition? type = FindType(scriptID);
		if (type is null)
		{
			scriptType = null;
			failureReason = $"Can't find type: {scriptID.UniqueName}";
			return false;
		}
		else
		{
			FieldSerializer fieldSerializer = new(version);
			if (!monoTypeCache.TryGetValue(fieldSerializer, out Dictionary<ITypeDefOrRef, SerializableType>? typeCache))
			{
				typeCache = new(SignatureComparer.Default);
				monoTypeCache[fieldSerializer] = typeCache;
			}

			if (typeCache.TryGetValue(type, out SerializableType? monoType)
				|| fieldSerializer.TryCreateSerializableType(type, typeCache, out monoType, out failureReason))
			{
				scriptType = monoType;
				failureReason = null;
				return true;
			}
			else
			{
				scriptType = null;
				return false;
			}
		}
	}

	internal void AddSerializableType(ITypeDefOrRef type, SerializableType scriptType)
	{
		string uniqueName = GetUniqueName(type);
		AddSerializableType(uniqueName, scriptType);
	}

	internal void InvokeRequestAssemblyCallback(string assemblyName) => m_requestAssemblyCallback.Invoke(assemblyName);

	internal void AddSerializableType(string uniqueName, SerializableType scriptType) => m_serializableTypes.Add(uniqueName, scriptType);

	protected AssemblyDefinition? FindAssembly(string name)
	{
		if (m_assemblies.TryGetValue(name, out AssemblyDefinition? assembly))
		{
			return assembly;
		}

		InvokeRequestAssemblyCallback(name);
		if (m_assemblies.TryGetValue(name, out assembly))
		{
			return assembly;
		}
		m_assemblies.Add(name, null);
		return null;
	}

	protected TypeDefinition? FindType(string assembly, string @namespace, string name)
	{
		AssemblyDefinition? definition = FindAssembly(assembly);
		if (definition == null)
		{
			return null;
		}

		foreach (ModuleDefinition module in definition.Modules)
		{
			TypeDefinition? type = module.GetType(@namespace, name);
			if (type != null)
			{
				return type;
			}
		}
		return null;
	}

	protected TypeDefinition? FindType(ScriptIdentifier scriptID)
	{
		return FindType(scriptID.Assembly, scriptID.Namespace, scriptID.Name);
	}

	public virtual IEnumerable<AssemblyDefinition> GetAssemblies()
	{
		return m_assemblies.Values.Where(x => x is not null).Distinct()!;
	}

	public void Dispose()
	{
		Dispose(true);
		GC.SuppressFinalize(this);
	}

	protected void Dispose(bool disposing)
	{
		if (disposing)
		{
			ClearStreamCache();
		}
	}

	~BaseManager() => Dispose(false);
}

```

`Source/AssetRipper.Import/Structure/Assembly/Managers/IAssemblyManager.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Import.Structure.Platforms;
using AssetRipper.IO.Files;
using AssetRipper.SerializationLogic;

namespace AssetRipper.Import.Structure.Assembly.Managers;

public interface IAssemblyManager : IDisposable
{
	void Initialize(PlatformGameStructure gameStructure);
	void Load(string filePath, FileSystem fileSystem);
	void Add(AssemblyDefinition assembly);
	void Read(Stream stream, string fileName);
	void Unload(string fileName);

	bool IsAssemblyLoaded(string assembly);
	bool IsPresent(ScriptIdentifier scriptID);
	bool IsValid(ScriptIdentifier scriptID);
	bool TryGetSerializableType(
		ScriptIdentifier scriptID,
		UnityVersion version,
		[NotNullWhen(true)] out SerializableType? scriptType,
		[NotNullWhen(false)] out string? failureReason);
	TypeDefinition GetTypeDefinition(ScriptIdentifier scriptID);
	IEnumerable<AssemblyDefinition> GetAssemblies();
	ScriptIdentifier GetScriptID(string assembly, string @namespace, string name);
	Stream GetStreamForAssembly(AssemblyDefinition assembly);
	void ClearStreamCache();

	bool IsSet { get; }
	ScriptingBackend ScriptingBackend { get; }

	public sealed AssemblyDefinition? Mscorlib => GetAssemblies().FirstOrDefault(a => a.Name == "mscorlib");
	public sealed bool HasMscorlib2 => Mscorlib?.Version.Major == 2;
}
public static class AssemblyManagerExtensions
{
	public static void SaveAssembly(this IAssemblyManager manager, AssemblyDefinition assembly, string path, FileSystem fileSystem)
	{
		using Stream writeStream = fileSystem.File.Create(path);
		manager.SaveAssembly(assembly, writeStream);
	}
	public static void SaveAssembly(this IAssemblyManager manager, AssemblyDefinition assembly, Stream writeStream)
	{
		Stream readStream = manager.GetStreamForAssembly(assembly);
		readStream.Position = 0;
		readStream.CopyTo(writeStream);
	}
}

```

`Source/AssetRipper.Import/Structure/Assembly/Managers/IL2CppManager.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Import.Configuration;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Platforms;
using AssetRipper.IO.Files;
using Cpp2IL.Core.Api;
using Cpp2IL.Core.InstructionSets;
using Cpp2IL.Core.Model.Contexts;
using Cpp2IL.Core.OutputFormats;
using Cpp2IL.Core.ProcessingLayers;
using LibCpp2IL;
using Cpp2IlApi = Cpp2IL.Core.Cpp2IlApi;

namespace AssetRipper.Import.Structure.Assembly.Managers;

public sealed class IL2CppManager : BaseManager
{
	static IL2CppManager()
	{
		InstructionSetRegistry.RegisterInstructionSet<X86InstructionSet>(DefaultInstructionSets.X86_32);
		InstructionSetRegistry.RegisterInstructionSet<X86InstructionSet>(DefaultInstructionSets.X86_64);
		InstructionSetRegistry.RegisterInstructionSet<WasmInstructionSet>(DefaultInstructionSets.WASM);
		InstructionSetRegistry.RegisterInstructionSet<ArmV7InstructionSet>(DefaultInstructionSets.ARM_V7);
		bool useNewArm64 = false;
		if (useNewArm64)
		{
			InstructionSetRegistry.RegisterInstructionSet<NewArmV8InstructionSet>(DefaultInstructionSets.ARM_V8);
		}
		else
		{
			InstructionSetRegistry.RegisterInstructionSet<Arm64InstructionSet>(DefaultInstructionSets.ARM_V8);
		}

		LibCpp2IlBinaryRegistry.RegisterBuiltInBinarySupport();
	}

	public static List<Cpp2IlProcessingLayer> DefaultProcessingLayers { get; } =
	[
		new AttributeAnalysisProcessingLayer(),
		new MethodOverrideNameFixer(),
	];

	public static AsmResolverDllOutputFormatDefault DefaultOutputFormat { get; } = new();

	public static List<Cpp2IlProcessingLayer>? RecoveryProcessingLayers { get; set; }

	public static AsmResolverDllOutputFormat? RecoveryOutputFormat { get; set; }

	public static event Action? ClearStaticState;

	public string? GameAssemblyPath { get; private set; }
	public string? UnityPlayerPath { get; private set; }
	public string? GameDataPath { get; private set; }
	public string? MetaDataPath { get; private set; }
	public UnityVersion UnityVersion { get; private set; }
	/// <summary>
	/// For when analysis is reimplimented in Cpp2IL.
	/// </summary>
	private readonly ScriptContentLevel contentLevel;

	public IL2CppManager(Action<string> requestAssemblyCallback, ScriptContentLevel level) : base(requestAssemblyCallback)
	{
		contentLevel = level;
	}

	public override ScriptingBackend ScriptingBackend => ScriptingBackend.IL2Cpp;

	public override void Initialize(PlatformGameStructure gameStructure)
	{
		string? gameDataPath = gameStructure.GameDataPath;
		if (string.IsNullOrWhiteSpace(gameDataPath))
		{
			throw new ArgumentException($"{nameof(gameStructure.GameDataPath)} cannot be null or whitespace.", nameof(gameStructure));
		}

		GameDataPath = gameDataPath;
		GameAssemblyPath = gameStructure.Il2CppGameAssemblyPath;
		UnityPlayerPath = gameStructure.UnityPlayerPath;
		MetaDataPath = gameStructure.Il2CppMetaDataPath;

		UnityVersion = gameStructure.Version ?? Cpp2IlApi.DetermineUnityVersion(UnityPlayerPath, GameDataPath);

		if (UnityVersion == default)
		{
			throw new Exception("Could not determine the unity version");
		}
		else
		{
			Logger.Info(LogCategory.Import, $"During Il2Cpp initialization, found Unity version: {UnityVersion}");
		}

		Logger.SendStatusChange("loading_step_parse_il2cpp_metadata");

		ClearStaticState?.Invoke();

		Cpp2IlApi.InitializeLibCpp2Il(GameAssemblyPath!, MetaDataPath!, UnityVersion, false);

		Logger.SendStatusChange("loading_step_generate_dummy_dll");

		List<Cpp2IlProcessingLayer> processingLayers = contentLevel == ScriptContentLevel.Level3
			? RecoveryProcessingLayers ?? DefaultProcessingLayers
			: DefaultProcessingLayers;

		foreach (Cpp2IlProcessingLayer cpp2IlProcessingLayer in processingLayers)
		{
			cpp2IlProcessingLayer.PreProcess(GetCurrentAppContext(), processingLayers);
		}

		foreach (Cpp2IlProcessingLayer cpp2IlProcessingLayer in processingLayers)
		{
			cpp2IlProcessingLayer.Process(GetCurrentAppContext());
		}

		AsmResolverDllOutputFormat outputFormat = contentLevel == ScriptContentLevel.Level3
			? RecoveryOutputFormat ?? DefaultOutputFormat
			: DefaultOutputFormat;

		List<AssemblyDefinition> assemblies = outputFormat.BuildAssemblies(GetCurrentAppContext());

		foreach (AssemblyDefinition assembly in assemblies)
		{
			assembly.InitializeResolvers(this);
			m_assemblies.Add(assembly.Name ?? throw new NullReferenceException(), assembly);
		}
	}

	private static ApplicationAnalysisContext GetCurrentAppContext()
	{
		return Cpp2IlApi.CurrentAppContext ?? throw new NullReferenceException();
	}

	public override void Load(string filePath, FileSystem fileSystem)
	{
		throw new NotSupportedException();
	}

	public override void Read(Stream stream, string fileName)
	{
		throw new NotSupportedException();
	}

	~IL2CppManager()
	{
		Dispose(false);
	}
}

```

`Source/AssetRipper.Import/Structure/Assembly/Managers/MethodOverrideNameFixer.cs`:

```cs
using Cpp2IL.Core.Api;
using Cpp2IL.Core.Model.Contexts;
using System.Diagnostics;

namespace AssetRipper.Import.Structure.Assembly.Managers;

/// <summary>
/// Method names do not always match the names of the methods they override (eg because of obfuscation). This class fixes that.
/// </summary>
internal sealed class MethodOverrideNameFixer : Cpp2IlProcessingLayer
{
	public override string Name => nameof(MethodOverrideNameFixer);

	public override string Id => Name;

	public override void Process(ApplicationAnalysisContext appContext, Action<int, int>? progressCallback = null)
	{
		HashSet<MethodAnalysisContext> methodsAnalyzed = new();
		foreach (MethodAnalysisContext method in appContext.AllTypes.SelectMany(t => t.Methods))
		{
			AnalyzeMethod(method, methodsAnalyzed);
		}
	}

	private static void AnalyzeMethod(MethodAnalysisContext method, HashSet<MethodAnalysisContext> methodsAnalyzed)
	{
		Debug.Assert(method is not ConcreteGenericMethodAnalysisContext);

		if (methodsAnalyzed.Contains(method))
			return;

		MethodAnalysisContext? baseMethod = method.BaseMethod;
		if (baseMethod is null)
			return;

		if (baseMethod is ConcreteGenericMethodAnalysisContext concreteGenericMethod)
		{
			AnalyzeMethod(concreteGenericMethod.BaseMethodContext, methodsAnalyzed);
		}
		else
		{
			AnalyzeMethod(baseMethod, methodsAnalyzed);
		}

		if (baseMethod.Name != method.Name)
		{
			method.OverrideName = baseMethod.Name;
		}
	}
}

```

`Source/AssetRipper.Import/Structure/Assembly/Managers/ModuleExtensions.cs`:

```cs
using AsmResolver.DotNet;

namespace AssetRipper.Import.Structure.Assembly.Managers;

internal static class ModuleExtensions
{
	public static TypeDefinition? GetType(this ModuleDefinition module, string @namespace, string name)
	{
		IList<TypeDefinition> types = module.TopLevelTypes;
		foreach (TypeDefinition type in types)
		{
			if ((type.Namespace ?? "") == @namespace && type.Name == name)
			{
				return type;
			}
		}

		return null;
	}

	public static void SetResolver(this ModuleDefinition module, IAssemblyResolver assemblyResolver)
	{
		module.MetadataResolver = new DefaultMetadataResolver(assemblyResolver);
	}

	public static void InitializeResolvers(this AssemblyDefinition assembly, BaseManager assemblyManager)
	{
		for (int i = 0; i < assembly.Modules.Count; i++)
		{
			assembly.Modules[i].SetResolver(assemblyManager.AssemblyResolver);
		}
	}
}

```

`Source/AssetRipper.Import/Structure/Assembly/Managers/MonoManager.cs`:

```cs
using AsmResolver.PE.File;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Platforms;

namespace AssetRipper.Import.Structure.Assembly.Managers;

public sealed class MonoManager : BaseManager
{
	public const string AssemblyExtension = ".dll";

	public override ScriptingBackend ScriptingBackend => ScriptingBackend.Mono;

	public MonoManager(Action<string> requestAssemblyCallback) : base(requestAssemblyCallback) { }

	public override void Initialize(PlatformGameStructure gameStructure)
	{
		Logger.Info(LogCategory.Import, $"During Mono initialization, found {gameStructure.Assemblies.Count} assemblies");
		foreach ((string assemblyName, string assemblyPath) in gameStructure.Assemblies)
		{
			try
			{
				using Stream stream = gameStructure.FileSystem.File.OpenRead(assemblyPath);
				PEFile peFile = PEFile.FromStream(stream);
				if (!peFile.OptionalHeader.GetDataDirectory(DataDirectoryIndex.ClrDirectory).IsPresentInPE)
				{
					Logger.Info(LogCategory.Import, $"Skipping native assembly: {assemblyName}");
				}
				else
				{
					Load(assemblyPath, gameStructure.FileSystem);
				}
			}
			catch (BadImageFormatException)
			{
				Logger.Info(LogCategory.Import, $"Skipping non-PE file: {assemblyName}");
			}
		}
	}

	public static bool IsMonoAssembly(string fileName)
	{
		if (fileName.EndsWith(AssemblyExtension, StringComparison.Ordinal))
		{
			return true;
		}
		return false;
	}
}

```

`Source/AssetRipper.Import/Structure/Assembly/MonoBehaviourExtensions.cs`:

```cs
using AssetRipper.Import.Structure.Assembly.Serializable;
using AssetRipper.SourceGenerated.Classes.ClassID_114;

namespace AssetRipper.Import.Structure.Assembly;

public static class MonoBehaviourExtensions
{
	public static SerializableStructure? LoadStructure(this IMonoBehaviour monoBehaviour)
	{
		if (monoBehaviour.Structure is SerializableStructure structure)
		{
			return structure;
		}
		return (monoBehaviour.Structure as UnloadedStructure)?.LoadStructure();
	}
}

```

`Source/AssetRipper.Import/Structure/Assembly/MonoScriptExtensions.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.SerializationLogic;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Subclasses.Hash128;
using System.Buffers.Binary;

namespace AssetRipper.Import.Structure.Assembly;

public static class MonoScriptExtensions
{
	/// <summary>
	/// Before 2018.2 or Release or after 2022.2
	/// </summary>
	public static bool HasAssemblyName(this IMonoScript monoScript)
	{
		return monoScript.Collection.Flags.IsRelease() || !monoScript.IsReleaseOnly_AssemblyName();
	}

	public static string GetValidAssemblyName(this IMonoScript monoScript)
	{
		string name = SpecialFileNames.FixAssemblyName(monoScript.AssemblyName);
		return string.IsNullOrEmpty(name) ? "Assembly-CSharp" : name;
	}

	/// <summary>
	/// Apply <see cref="SpecialFileNames.FixAssemblyName(string)"/> to <see cref="IMonoScript.AssemblyName"/>.
	/// </summary>
	/// <param name="monoScript">The relevant MonoScript.</param>
	/// <returns></returns>
	public static string GetAssemblyNameFixed(this IMonoScript monoScript)
	{
		return SpecialFileNames.FixAssemblyName(monoScript.AssemblyName);
	}

	public static SerializableType? GetBehaviourType(this IMonoScript monoScript, IAssemblyManager assemblyManager)
	{
		return monoScript.GetBehaviourType(assemblyManager, out _);
	}

	public static SerializableType? GetBehaviourType(this IMonoScript monoScript, IAssemblyManager assemblyManager, out string? failureReason)
	{
		// Note: We use the MonoScript collection version here, not the MonoBehaviour version.
		// It probably doesn't matter because MonoScript and MonoBehaviour versions are usually the same,
		// and even when they are different, they still have the same major and minor version.
		// Also, Unity doesn't change serialization very often at all.

		ScriptIdentifier scriptID = assemblyManager.GetScriptID(monoScript.GetAssemblyNameFixed(), monoScript.Namespace, monoScript.ClassName_R);
		if (!assemblyManager.IsSet)
		{
			failureReason = null;
		}
		else if (!assemblyManager.IsValid(scriptID))
		{
			failureReason = "Script ID is invalid";
		}
		else if (assemblyManager.TryGetSerializableType(scriptID, monoScript.Collection.Version, out SerializableType? result, out failureReason))
		{
			return result;
		}
		return null;
	}

	public static string GetFullName(this IMonoScript monoScript)
	{
		if (string.IsNullOrEmpty(monoScript.Namespace))
		{
			return monoScript.ClassName_R;
		}
		else
		{
			return $"{monoScript.Namespace}.{monoScript.ClassName_R}";
		}
	}

	public static ScriptIdentifier GetScriptID(this IMonoScript monoScript, IAssemblyManager assemblyManager)
	{
		return assemblyManager.GetScriptID(monoScript.GetAssemblyNameFixed(), monoScript.Namespace, monoScript.ClassName_R);
	}

	public static TypeDefinition GetTypeDefinition(this IMonoScript monoScript, IAssemblyManager assemblyManager)
	{
		ScriptIdentifier scriptID = monoScript.GetScriptID(assemblyManager);
		return assemblyManager.GetTypeDefinition(scriptID);
	}

	public static bool IsScriptPresents(this IMonoScript monoScript, IAssemblyManager assemblyManager)
	{
		ScriptIdentifier scriptID = monoScript.GetScriptID(assemblyManager);
		return assemblyManager.IsPresent(scriptID);
	}

	public static Hash128_5 GetPropertiesHash(this IMonoScript monoScript)
	{
		if (monoScript.Has_PropertiesHash_Hash128_5())
		{
			return monoScript.PropertiesHash_Hash128_5;
		}
		else
		{
			Span<byte> hash = stackalloc byte[4];
			//I have reason to believe that this depends on the endianness of the file containing the MonoScript,
			//but most platforms are little endian, so I don't really know for sure.
			if (monoScript.Collection.EndianType == EndianType.BigEndian)
			{
				BinaryPrimitives.WriteUInt32BigEndian(hash, monoScript.PropertiesHash_UInt32);
			}
			else
			{
				BinaryPrimitives.WriteUInt32LittleEndian(hash, monoScript.PropertiesHash_UInt32);
			}
			return new()
			{
				Bytes__0 = hash[0],
				Bytes__1 = hash[1],
				Bytes__2 = hash[2],
				Bytes__3 = hash[3],
			};
		}
	}
}

```

`Source/AssetRipper.Import/Structure/Assembly/ScriptIdentifier.cs`:

```cs
namespace AssetRipper.Import.Structure.Assembly;

public readonly record struct ScriptIdentifier
{
	public ScriptIdentifier(string assembly, string @namespace, string name)
	{
		ArgumentException.ThrowIfNullOrEmpty(assembly);
		ArgumentNullException.ThrowIfNull(@namespace);
		ArgumentException.ThrowIfNullOrEmpty(name);
		Assembly = assembly;
		Namespace = @namespace;
		Name = name;
	}

	public static string ToUniqueName(string assembly, string @namespace, string name)
	{
		return @namespace == string.Empty ? $"[{assembly}]{name}" : $"[{assembly}]{@namespace}.{name}";
	}

	public static string ToUniqueName(string assembly, string fullName)
	{
		return $"[{assembly}]{fullName}";
	}

	public override string? ToString()
	{
		return IsDefault ? base.ToString() : Namespace == string.Empty ? $"{Name}" : $"{Namespace}.{Name}";
	}

	public bool IsDefault => Name == null;
	public string UniqueName => ToUniqueName(Assembly, Namespace, Name);

	public string Assembly { get; }
	public string Namespace { get; }
	public string Name { get; }
}

```

`Source/AssetRipper.Import/Structure/Assembly/ScriptingBackend.cs`:

```cs
namespace AssetRipper.Import.Structure.Assembly;

public enum ScriptingBackend
{
	Unknown,

	Mono,
	IL2Cpp
}

```

`Source/AssetRipper.Import/Structure/Assembly/Serializable/EndianSpanReaderExtensions.cs`:

```cs
using AssetRipper.IO.Endian;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace AssetRipper.Import.Structure.Assembly.Serializable;

internal static class EndianSpanReaderExtensions
{
	public static T[] ReadPrimitiveArray<T>(this ref EndianSpanReader reader, UnityVersion version) where T : unmanaged
	{
		int count = reader.ReadInt32();
		int index = 0;
		ThrowIfNegativeCount(count);
		ThrowIfNotEnoughSpaceForArray(ref reader, count, Unsafe.SizeOf<T>());
		T[] array = count == 0 ? [] : new T[count];
		while (index < count)
		{
			try
			{
				array[index] = reader.ReadPrimitive<T>();
			}
			catch (Exception ex)
			{
				throw new EndOfStreamException($"End of stream. Read {index}, expected {count} elements", ex);
			}
			index++;
		}
		if (IsAlignArrays(version))
		{
			reader.Align();
		}
		return array;
	}

	public static T[][] ReadPrimitiveArrayArray<T>(this ref EndianSpanReader reader, UnityVersion version) where T : unmanaged
	{
		int count = reader.ReadInt32();
		int index = 0;
		ThrowIfNegativeCount(count);
		ThrowIfNotEnoughSpaceForArray(ref reader, count, sizeof(int));
		T[][] array = count == 0 ? [] : new T[count][];
		while (index < count)
		{
			try
			{
				array[index] = reader.ReadPrimitiveArray<T>(version);
			}
			catch (Exception ex)
			{
				throw new EndOfStreamException($"End of stream. Read {index}, expected {count} elements", ex);
			}
			index++;
		}
		if (IsAlignArrays(version))
		{
			reader.Align();
		}
		return array;
	}

	public static Utf8String ReadUtf8StringAligned(this ref EndianSpanReader reader)
	{
		Utf8String result = reader.ReadUtf8String();
		reader.Align();//Alignment after strings has happened since 2.1.0
		return result;
	}

	public static string[] ReadStringArray(this ref EndianSpanReader reader, UnityVersion version)
	{
		int count = reader.ReadInt32();
		int index = 0;
		ThrowIfNegativeCount(count);
		ThrowIfNotEnoughSpaceForArray(ref reader, count, sizeof(int));
		string[] array = count == 0 ? [] : new string[count];
		while (index < count)
		{
			try
			{
				array[index] = reader.ReadUtf8StringAligned();
			}
			catch (Exception ex)
			{
				throw new EndOfStreamException($"End of stream. Read {index}, expected {count} elements", ex);
			}
			index++;
		}
		if (IsAlignArrays(version))
		{
			reader.Align();
		}
		return array;
	}

	public static string[][] ReadStringArrayArray(this ref EndianSpanReader reader, UnityVersion version)
	{
		int count = reader.ReadInt32();
		int index = 0;
		ThrowIfNegativeCount(count);
		ThrowIfNotEnoughSpaceForArray(ref reader, count, sizeof(int));
		string[][] array = count == 0 ? [] : new string[count][];
		while (index < count)
		{
			try
			{
				array[index] = reader.ReadStringArray(version);
			}
			catch (Exception ex)
			{
				throw new EndOfStreamException($"End of stream. Read {index}, expected {count} elements", ex);
			}
			index++;
		}
		if (IsAlignArrays(version))
		{
			reader.Align();
		}
		return array;
	}

	private static bool IsAlignArrays(UnityVersion version) => version.GreaterThanOrEquals(2017);

	[DebuggerHidden]
	private static void ThrowIfNegativeCount(int count)
	{
		if (count < 0)
		{
			throw new InvalidDataException($"Count cannot be negative: {count}");
		}
	}

	[DebuggerHidden]
	private static void ThrowIfNotEnoughSpaceForArray(ref EndianSpanReader reader, int elementNumberToRead, int elementSize)
	{
		int remainingBytes = reader.Length - reader.Position;
		if (remainingBytes < (long)elementNumberToRead * elementSize)
		{
			throw new EndOfStreamException($"Stream only has {remainingBytes} bytes in the stream, so {elementNumberToRead} elements of size {elementSize} cannot be read.");
		}
	}
}

```

`Source/AssetRipper.Import/Structure/Assembly/Serializable/SerializablePair.cs`:

```cs
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.IO.Writing;
using AssetRipper.Assets.Traversal;
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.SerializationLogic;

namespace AssetRipper.Import.Structure.Assembly.Serializable;

public sealed class SerializablePair
{
	public int Depth { get; }
	public SerializableType Type { get; }
	public SerializableValue First { get; }
	public SerializableValue Second { get; }
	private SerializableType.Field FirstField => Type.Fields[0];
	private SerializableType.Field SecondField => Type.Fields[1];

	public SerializablePair(SerializableType type, int depth)
	{
		if (type.Fields.Count != 2)
		{
			throw new ArgumentException("Pair type must have exactly two fields", nameof(type));
		}

		Type = type;
		Depth = depth;
	}

	public void Read(ref EndianSpanReader reader, UnityVersion version, TransferInstructionFlags flags)
	{
		First.Read(ref reader, version, flags, Depth, FirstField);
		Second.Read(ref reader, version, flags, Depth, SecondField);
	}

	public void Write(AssetWriter writer)
	{
		First.Write(writer, FirstField);
		Second.Write(writer, SecondField);
	}

	public void WalkEditor(AssetWalker walker)
	{
		if (Type.Type is PrimitiveType.MapPair)
		{
			// Needs to also handle GUID and Hash128, but those are not used in PlayerSettings, so it doesn't matter right now.
			if (FirstField.Type.Type == PrimitiveType.String)
			{
				KeyValuePair<string, SerializableValue> pair = new(First.AsString, Second);
				if (walker.EnterDictionaryPair(pair))
				{
					walker.VisitPrimitive(pair.Key);
					walker.DividePair(pair);
					Second.WalkEditor(walker, SecondField);
					walker.ExitDictionaryPair(pair);
				}
			}
			else
			{
				KeyValuePair<SerializableValue, SerializableValue> pair = new(First, Second);
				if (walker.EnterDictionaryPair(pair))
				{
					First.WalkEditor(walker, FirstField);
					walker.DivideDictionaryPair(pair);
					Second.WalkEditor(walker, SecondField);
					walker.ExitDictionaryPair(pair);
				}
			}
		}
		else
		{
			KeyValuePair<SerializableValue, SerializableValue> pair = new(First, Second);
			if (walker.EnterPair(pair))
			{
				First.WalkEditor(walker, FirstField);
				walker.DividePair(pair);
				Second.WalkEditor(walker, SecondField);
				walker.ExitPair(pair);
			}
		}
	}

	public void Initialize(UnityVersion version)
	{
		First.Initialize(version, Depth, FirstField);
		Second.Initialize(version, Depth, SecondField);
	}

	public void CopyValues(SerializablePair source, PPtrConverter converter)
	{
		First.CopyValues(source.First, Depth, FirstField, converter);
		Second.CopyValues(source.Second, Depth, SecondField, converter);
	}

	public void Reset()
	{
		First.Reset();
		Second.Reset();
	}
}

```

`Source/AssetRipper.Import/Structure/Assembly/Serializable/SerializableStructure.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.IO.Writing;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.Import.Logging;
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.SerializationLogic;
using AssetRipper.SourceGenerated.Classes.ClassID_114;

namespace AssetRipper.Import.Structure.Assembly.Serializable;

public sealed class SerializableStructure : UnityAssetBase, IDeepCloneable
{
	private UnityVersion Version { get; set; }
	public override int SerializedVersion => Type.Version;
	public override bool FlowMappedInYaml => Type.FlowMappedInYaml;

	internal SerializableStructure(SerializableType type, int depth)
	{
		Depth = depth;
		Type = type ?? throw new ArgumentNullException(nameof(type));
		Fields = new SerializableValue[type.Fields.Count];
	}

	public void Read(ref EndianSpanReader reader, UnityVersion version, TransferInstructionFlags flags)
	{
		Version = version;
		for (int i = 0; i < Fields.Length; i++)
		{
			SerializableType.Field etalon = Type.Fields[i];
			if (IsAvailable(etalon))
			{
				Fields[i].Read(ref reader, version, flags, Depth, etalon);
			}
		}
	}

	public void Write(AssetWriter writer)
	{
		for (int i = 0; i < Fields.Length; i++)
		{
			SerializableType.Field etalon = Type.Fields[i];
			if (IsAvailable(etalon))
			{
				Fields[i].Write(writer, etalon);
			}
		}
	}
	public override void WriteEditor(AssetWriter writer) => Write(writer);
	public override void WriteRelease(AssetWriter writer) => Write(writer);

	public override void WalkEditor(AssetWalker walker)
	{
		if (walker.EnterAsset(this))
		{
			bool hasEmittedFirstField = false;
			for (int i = 0; i < Fields.Length; i++)
			{
				SerializableType.Field etalon = Type.Fields[i];
				if (IsAvailable(etalon))
				{
					if (hasEmittedFirstField)
					{
						walker.DivideAsset(this);
					}
					else
					{
						hasEmittedFirstField = true;
					}
					if (walker.EnterField(this, etalon.Name))
					{
						Fields[i].WalkEditor(walker, etalon);
						walker.ExitField(this, etalon.Name);
					}
				}
			}
			walker.ExitAsset(this);
		}
	}
	//For now, only the editor version is implemented.
	public override void WalkRelease(AssetWalker walker) => WalkEditor(walker);
	public override void WalkStandard(AssetWalker walker) => WalkEditor(walker);

	public override IEnumerable<(string, PPtr)> FetchDependencies()
	{
		for (int i = 0; i < Fields.Length; i++)
		{
			SerializableType.Field etalon = Type.Fields[i];
			if (IsAvailable(etalon))
			{
				foreach ((string, PPtr) pair in Fields[i].FetchDependencies(etalon))
				{
					yield return pair;
				}
			}
		}
	}

	public override string ToString() => Type.FullName;

	private bool IsAvailable(in SerializableType.Field field)
	{
		if (Depth <= GetMaxDepthLevel(Version))
		{
			return true;
		}
		if (field.ArrayDepth > 0)
		{
			return false;
		}
		if (field.Type.Type == PrimitiveType.Complex)
		{
			return MonoUtils.IsEngineStruct(field.Type.Namespace, field.Type.Name);
		}
		return true;
	}

	public bool TryRead(ref EndianSpanReader reader, IMonoBehaviour monoBehaviour)
	{
		try
		{
			Read(ref reader, monoBehaviour.Collection.Version, monoBehaviour.Collection.Flags);
		}
		catch (Exception ex)
		{
			LogMonoBehaviorReadException(this, ex);
			return false;
		}
		if (reader.Position != reader.Length)
		{
			LogMonoBehaviourMismatch(this, reader.Position, reader.Length);
			return false;
		}
		return true;
	}

	private static void LogMonoBehaviourMismatch(SerializableStructure structure, int actual, int expected)
	{
		Logger.Error(LogCategory.Import, $"Unable to read MonoBehaviour Structure, because script {structure} layout mismatched binary content (read {actual} bytes, expected {expected} bytes).");
	}

	private static void LogMonoBehaviorReadException(SerializableStructure structure, Exception ex)
	{
		Logger.Error(LogCategory.Import, $"Unable to read MonoBehaviour Structure, because script {structure} layout mismatched binary content ({ex.GetType().Name}).");
	}

	public int Depth { get; }
	public SerializableType Type { get; }
	public SerializableValue[] Fields { get; }

	public ref SerializableValue this[string name]
	{
		get
		{
			if (TryGetIndex(name, out int index))
			{
				return ref Fields[index];
			}
			throw new KeyNotFoundException($"Field {name} wasn't found in {Type.Name}");
		}
	}

	public bool ContainsField(string name) => TryGetIndex(name, out _);

	public bool TryGetField(string name, out SerializableValue field)
	{
		if (TryGetIndex(name, out int index))
		{
			field = Fields[index];
			return true;
		}
		field = default;
		return false;
	}

	public SerializableValue? TryGetField(string name)
	{
		if (TryGetIndex(name, out int index))
		{
			return Fields[index];
		}
		return null;
	}

	public bool TryGetIndex(string name, out int index)
	{
		for (int i = 0; i < Fields.Length; i++)
		{
			if (Type.Fields[i].Name == name)
			{
				index = i;
				return true;
			}
		}
		index = -1;
		return false;
	}

	public override void CopyValues(IUnityAssetBase? source, PPtrConverter converter)
	{
		CopyValues((SerializableStructure?)source, converter);
	}

	public void CopyValues(SerializableStructure? source, PPtrConverter converter)
	{
		if (source is null)
		{
			Reset();
			return;
		}
		if (source.Depth != Depth)
		{
			throw new ArgumentException($"Depth {source.Depth} doesn't match with {Depth}", nameof(source));
		}
		Version = source.Version;
		if (source.Type == Type)
		{
			for (int i = 0; i < Fields.Length; i++)
			{
				SerializableValue sourceField = source.Fields[i];
				if (sourceField.CValue is null)
				{
					Fields[i] = sourceField;
				}
				else
				{
					Fields[i].CopyValues(sourceField, Depth, Type.Fields[i], converter);
				}
			}
		}
		else
		{
			for (int i = 0; i < Fields.Length; i++)
			{
				string fieldName = Type.Fields[i].Name;
				int index = -1;
				for (int j = 0; j < source.Type.Fields.Count; j++)
				{
					if (fieldName == source.Type.Fields[j].Name)
					{
						index = j;
					}
				}
				SerializableValue sourceField = index < 0 ? default : source.Fields[index];
				Fields[i].CopyValues(sourceField, Depth, Type.Fields[i], converter);
			}
		}
	}

	public SerializableStructure DeepClone(PPtrConverter converter)
	{
		SerializableStructure clone = new(Type, Depth);
		clone.CopyValues(this, converter);
		return clone;
	}

	IUnityAssetBase IDeepCloneable.DeepClone(PPtrConverter converter) => DeepClone(converter);

	public override void Reset()
	{
		foreach (SerializableValue field in Fields)
		{
			field.Reset();
		}
	}

	public void InitializeFields(UnityVersion version)
	{
		Version = version;
		for (int i = 0; i < Fields.Length; i++)
		{
			SerializableType.Field etalon = Type.Fields[i];
			if (IsAvailable(etalon))
			{
				Fields[i].Initialize(version, Depth, etalon);
			}
		}
	}

	/// <summary>
	/// Unity has a maximum serialization depth to prevent infinite recursion in cyclic references.
	/// In Unity versions prior to 2020.2.0a21, this limit is 7. From 2020.2.0a21 onwards, the limit was increased to 10.
	/// </summary>
	/// <remarks>
	/// <see href="https://forum.unity.com/threads/serialization-depth-limit-and-recursive-serialization.1263599/"/><br/>
	/// <see href="https://forum.unity.com/threads/getting-a-serialization-depth-limit-7-error-for-no-reason.529850/"/><br/>
	/// <see href="https://forum.unity.com/threads/4-5-serialization-depth.248321/"/>
	/// </remarks>
	private static int GetMaxDepthLevel(UnityVersion version) => version.GreaterThanOrEquals(2020, 2, 0, UnityVersionType.Alpha, 21) ? 10 : 7;
}

```

`Source/AssetRipper.Import/Structure/Assembly/Serializable/SerializableTypeExtensions.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Import.AssetCreation;
using AssetRipper.SerializationLogic;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Object;

namespace AssetRipper.Import.Structure.Assembly.Serializable;

public static class SerializableTypeExtensions
{
	public static SerializableStructure CreateSerializableStructure(this SerializableType type)
	{
		return new SerializableStructure(type, 0);
	}

	public static IUnityAssetBase CreateInstance(this SerializableType type, int depth, UnityVersion version)
	{
		if (type.IsEngineStruct())
		{
			return GameAssetFactory.CreateEngineAsset(type.Name, version);
		}
		if (type.IsEnginePointer())
		{
			return PPtr_Object.Create(version);
		}
		SerializableStructure structure = new(type, depth);
		structure.InitializeFields(version);
		return structure;
	}
}

```

`Source/AssetRipper.Import/Structure/Assembly/Serializable/SerializableValue.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.IO.Writing;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.SerializationLogic;
using System.Collections;
using System.Diagnostics;

namespace AssetRipper.Import.Structure.Assembly.Serializable;

[DebuggerDisplay($"{{{nameof(GetDebuggerDisplay)}(),nq}}")]
public record struct SerializableValue([property: DebuggerBrowsable(DebuggerBrowsableState.Never)] ulong PValue, object CValue)
{
	#region AsType Properties

	// For brevity, we hide a lot of the properties in the debugger. We only show:
	// * Boolean
	// * Char
	// * Signed integer (long)
	// * Unsigned integer (ulong)
	// * Single
	// * Double
	// * Object

	public bool AsBoolean
	{
		readonly get => PValue != 0;
		set => SetPrimitive(value ? 1U : 0U);
	}

	public char AsChar
	{
		readonly get => unchecked((char)PValue);
		set => SetPrimitive(unchecked((byte)value));
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public sbyte AsSByte
	{
		readonly get => unchecked((sbyte)PValue);
		set => SetPrimitive(unchecked((byte)value));
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public byte AsByte
	{
		readonly get => unchecked((byte)PValue);
		set => SetPrimitive(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public short AsInt16
	{
		readonly get => unchecked((short)PValue);
		set => SetPrimitive(unchecked((ushort)value));
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public ushort AsUInt16
	{
		readonly get => unchecked((ushort)PValue);
		set => SetPrimitive(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public int AsInt32
	{
		readonly get => unchecked((int)PValue);
		set => SetPrimitive(unchecked((uint)value));
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public uint AsUInt32
	{
		readonly get => unchecked((uint)PValue);
		set => SetPrimitive(value);
	}

	public long AsInt64
	{
		readonly get => unchecked((long)PValue);
		set => SetPrimitive(unchecked((ulong)value));
	}

	public ulong AsUInt64
	{
		readonly get => PValue;
		set => SetPrimitive(value);
	}

	public float AsSingle
	{
		readonly get => BitConverter.UInt32BitsToSingle(AsUInt32);
		set => AsUInt32 = BitConverter.SingleToUInt32Bits(value);
	}

	public double AsDouble
	{
		readonly get => BitConverter.UInt64BitsToDouble(AsUInt64);
		set => AsUInt64 = BitConverter.DoubleToUInt64Bits(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public string AsString
	{
		readonly get => CValue as string ?? "";
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public IUnityAssetBase AsAsset
	{
		readonly get => CValue as IUnityAssetBase ?? EmptyAsset.Instance;
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public readonly SerializableStructure AsStructure => (SerializableStructure)CValue;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public readonly IPPtr AsPPtr => CValue as IPPtr ?? NullPPtr.Instance;

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public SerializablePair AsPair
	{
		readonly get => (SerializablePair)CValue;
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public bool[] AsBooleanArray
	{
		readonly get => CValue as bool[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public char[] AsCharArray
	{
		readonly get => CValue as char[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public sbyte[] AsSByteArray
	{
		readonly get => CValue as sbyte[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public byte[] AsByteArray
	{
		readonly get => CValue as byte[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public short[] AsInt16Array
	{
		readonly get => CValue as short[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public ushort[] AsUInt16Array
	{
		readonly get => CValue as ushort[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public int[] AsInt32Array
	{
		readonly get => CValue as int[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public uint[] AsUInt32Array
	{
		readonly get => CValue as uint[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public long[] AsInt64Array
	{
		readonly get => CValue as long[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public ulong[] AsUInt64Array
	{
		readonly get => CValue as ulong[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public float[] AsSingleArray
	{
		readonly get => CValue as float[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public double[] AsDoubleArray
	{
		readonly get => CValue as double[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public string[] AsStringArray
	{
		readonly get => CValue as string[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public IUnityAssetBase[] AsAssetArray
	{
		readonly get => CValue as IUnityAssetBase[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public SerializablePair[] AsPairArray
	{
		readonly get => CValue as SerializablePair[] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public bool[][] AsBooleanArrayArray
	{
		readonly get => CValue as bool[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public char[][] AsCharArrayArray
	{
		readonly get => CValue as char[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public sbyte[][] AsSByteArrayArray
	{
		readonly get => CValue as sbyte[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public byte[][] AsByteArrayArray
	{
		readonly get => CValue as byte[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public short[][] AsInt16ArrayArray
	{
		readonly get => CValue as short[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public ushort[][] AsUInt16ArrayArray
	{
		readonly get => CValue as ushort[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public int[][] AsInt32ArrayArray
	{
		readonly get => CValue as int[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public uint[][] AsUInt32ArrayArray
	{
		readonly get => CValue as uint[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public long[][] AsInt64ArrayArray
	{
		readonly get => CValue as long[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public ulong[][] AsUInt64ArrayArray
	{
		readonly get => CValue as ulong[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public float[][] AsSingleArrayArray
	{
		readonly get => CValue as float[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public double[][] AsDoubleArrayArray
	{
		readonly get => CValue as double[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public string[][] AsStringArrayArray
	{
		readonly get => CValue as string[][] ?? [];
		set => SetReference(value);
	}

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	public IUnityAssetBase[][] AsAssetArrayArray
	{
		readonly get => CValue as IUnityAssetBase[][] ?? [];
		set => SetReference(value);
	}

	private void SetPrimitive(ulong value)
	{
		if (CValue is not null)
		{
			throw new InvalidOperationException("Value is not a primitive type.");
		}
		else
		{
			PValue = value;
		}
	}

	private void SetReference<T>(T value) where T : class
	{
		if (CValue is not null and not T)
		{
			throw new InvalidOperationException($"Object value is not a {typeof(T).Name}, but instead {CValue.GetType().Name}.");
		}
		else if (PValue != 0)
		{
			throw new InvalidOperationException($"Primitive value is not zero, but instead {PValue}.");
		}
		else
		{
			CValue = value;
		}
	}
	#endregion

	public readonly ref SerializableValue this[string name] => ref AsStructure[name];

	public static SerializableValue FromPrimitive<T>(T value) where T : notnull
	{
		SerializableValue result = default;
		if (typeof(T) == typeof(bool))
		{
			result.AsBoolean = (bool)(object)value;
		}
		else if (typeof(T) == typeof(char))
		{
			result.AsChar = (char)(object)value;
		}
		else if (typeof(T) == typeof(sbyte))
		{
			result.AsSByte = (sbyte)(object)value;
		}
		else if (typeof(T) == typeof(byte))
		{
			result.AsByte = (byte)(object)value;
		}
		else if (typeof(T) == typeof(short))
		{
			result.AsInt16 = (short)(object)value;
		}
		else if (typeof(T) == typeof(ushort))
		{
			result.AsUInt16 = (ushort)(object)value;
		}
		else if (typeof(T) == typeof(int))
		{
			result.AsInt32 = (int)(object)value;
		}
		else if (typeof(T) == typeof(uint))
		{
			result.AsUInt32 = (uint)(object)value;
		}
		else if (typeof(T) == typeof(long))
		{
			result.AsInt64 = (long)(object)value;
		}
		else if (typeof(T) == typeof(ulong))
		{
			result.AsUInt64 = (ulong)(object)value;
		}
		else if (typeof(T) == typeof(float))
		{
			result.AsSingle = (float)(object)value;
		}
		else if (typeof(T) == typeof(double))
		{
			result.AsDouble = (double)(object)value;
		}
		else if (typeof(T) == typeof(string))
		{
			result.AsString = (string)(object)value;
		}
		else if (typeof(T) == typeof(Utf8String))
		{
			result.AsString = ((Utf8String)(object)value).String;
		}
		else
		{
			throw new NotSupportedException($"Type {typeof(T)} is not supported.");
		}
		return result;
	}

	public void Read(ref EndianSpanReader reader, UnityVersion version, TransferInstructionFlags flags, int depth, in SerializableType.Field etalon)
	{
		switch (etalon.ArrayDepth)
		{
			case 0:
				switch (etalon.Type.Type)
				{
					case PrimitiveType.Bool:
						AsBoolean = reader.ReadBoolean();
						break;
					case PrimitiveType.Char:
						AsChar = reader.ReadChar();
						break;
					case PrimitiveType.SByte:
						AsSByte = reader.ReadSByte();
						break;
					case PrimitiveType.Byte:
						AsByte = reader.ReadByte();
						break;
					case PrimitiveType.Short:
						AsInt16 = reader.ReadInt16();
						break;
					case PrimitiveType.UShort:
						AsUInt16 = reader.ReadUInt16();
						break;
					case PrimitiveType.Int:
						AsInt32 = reader.ReadInt32();
						break;
					case PrimitiveType.UInt:
						AsUInt32 = reader.ReadUInt32();
						break;
					case PrimitiveType.Long:
						AsInt64 = reader.ReadInt64();
						break;
					case PrimitiveType.ULong:
						AsUInt64 = reader.ReadUInt64();
						break;
					case PrimitiveType.Single:
						AsSingle = reader.ReadSingle();
						break;
					case PrimitiveType.Double:
						AsDouble = reader.ReadDouble();
						break;
					case PrimitiveType.String:
						AsString = reader.ReadUtf8StringAligned().String;
						break;
					case PrimitiveType.Complex:
						AsAsset = CreateAndReadComplexStructure(ref reader, version, flags, depth, etalon);
						break;
					case PrimitiveType.Pair:
					case PrimitiveType.MapPair:
						{
							SerializablePair pair = new(etalon.Type, depth + 1);
							pair.Read(ref reader, version, flags);
							AsPair = pair;
						}
						break;
					default:
						throw new NotSupportedException(etalon.Type.Type.ToString());
				}
				break;
			case 1:
				switch (etalon.Type.Type)
				{
					case PrimitiveType.Bool:
						AsBooleanArray = reader.ReadPrimitiveArray<bool>(version);
						break;
					case PrimitiveType.Char:
						AsCharArray = reader.ReadPrimitiveArray<char>(version);
						break;
					case PrimitiveType.SByte:
						AsSByteArray = reader.ReadPrimitiveArray<sbyte>(version);
						break;
					case PrimitiveType.Byte:
						AsByteArray = reader.ReadPrimitiveArray<byte>(version);
						break;
					case PrimitiveType.Short:
						AsInt16Array = reader.ReadPrimitiveArray<short>(version);
						break;
					case PrimitiveType.UShort:
						AsUInt16Array = reader.ReadPrimitiveArray<ushort>(version);
						break;
					case PrimitiveType.Int:
						AsInt32Array = reader.ReadPrimitiveArray<int>(version);
						break;
					case PrimitiveType.UInt:
						AsUInt32Array = reader.ReadPrimitiveArray<uint>(version);
						break;
					case PrimitiveType.Long:
						AsInt64Array = reader.ReadPrimitiveArray<long>(version);
						break;
					case PrimitiveType.ULong:
						AsUInt64Array = reader.ReadPrimitiveArray<ulong>(version);
						break;
					case PrimitiveType.Single:
						AsSingleArray = reader.ReadPrimitiveArray<float>(version);
						break;
					case PrimitiveType.Double:
						AsDoubleArray = reader.ReadPrimitiveArray<double>(version);
						break;
					case PrimitiveType.String:
						AsStringArray = reader.ReadStringArray(version);
						break;
					case PrimitiveType.Pair:
					case PrimitiveType.MapPair:
						{
							int count = reader.ReadInt32();

							long remainingBytes = reader.Length - reader.Position;
							if (remainingBytes < count)
							{
								throw new EndOfStreamException($"When reading field {etalon.Name}, Stream only has {remainingBytes} bytes remaining, so {count} pair elements of type {etalon.Type.Name} cannot be read.");
							}
							SerializablePair[] pairs = CreateArray<SerializablePair>(count);

							for (int i = 0; i < count; i++)
							{
								SerializablePair pair = new(etalon.Type, depth + 1);
								pair.Read(ref reader, version, flags);
								pairs[i] = pair;
							}

							AsPairArray = pairs;
						}
						break;
					case PrimitiveType.Complex:
						{
							int count = reader.ReadInt32();
							ThrowIfNotEnoughSpaceToReadArray(reader, etalon, count);

							IUnityAssetBase[] structures = CreateArray<IUnityAssetBase>(count);
							for (int i = 0; i < count; i++)
							{
								structures[i] = CreateAndReadComplexStructure(ref reader, version, flags, depth, etalon);
							}
							AsAssetArray = structures;
						}
						break;
					default:
						throw new NotSupportedException(etalon.Type.Type.ToString());
				}
				break;
			case 2:
				switch (etalon.Type.Type)
				{
					case PrimitiveType.Bool:
						AsBooleanArrayArray = reader.ReadPrimitiveArrayArray<bool>(version);
						break;
					case PrimitiveType.Char:
						AsCharArrayArray = reader.ReadPrimitiveArrayArray<char>(version);
						break;
					case PrimitiveType.SByte:
						AsSByteArrayArray = reader.ReadPrimitiveArrayArray<sbyte>(version);
						break;
					case PrimitiveType.Byte:
						AsByteArrayArray = reader.ReadPrimitiveArrayArray<byte>(version);
						break;
					case PrimitiveType.Short:
						AsInt16ArrayArray = reader.ReadPrimitiveArrayArray<short>(version);
						break;
					case PrimitiveType.UShort:
						AsUInt16ArrayArray = reader.ReadPrimitiveArrayArray<ushort>(version);
						break;
					case PrimitiveType.Int:
						AsInt32ArrayArray = reader.ReadPrimitiveArrayArray<int>(version);
						break;
					case PrimitiveType.UInt:
						AsUInt32ArrayArray = reader.ReadPrimitiveArrayArray<uint>(version);
						break;
					case PrimitiveType.Long:
						AsInt64ArrayArray = reader.ReadPrimitiveArrayArray<long>(version);
						break;
					case PrimitiveType.ULong:
						AsUInt64ArrayArray = reader.ReadPrimitiveArrayArray<ulong>(version);
						break;
					case PrimitiveType.Single:
						AsSingleArrayArray = reader.ReadPrimitiveArrayArray<float>(version);
						break;
					case PrimitiveType.Double:
						AsDoubleArrayArray = reader.ReadPrimitiveArrayArray<double>(version);
						break;
					case PrimitiveType.String:
						AsStringArrayArray = reader.ReadStringArrayArray(version);
						break;
					case PrimitiveType.Complex:
						{
							int outerCount = reader.ReadInt32();
							ThrowIfNotEnoughSpaceToReadArray(reader, etalon, outerCount);
							IUnityAssetBase[][] result = CreateArray<IUnityAssetBase[]>(outerCount);

							for (int i = 0; i < outerCount; i++)
							{
								int innerCount = reader.ReadInt32();
								ThrowIfNotEnoughSpaceToReadArray(reader, etalon, innerCount);

								IUnityAssetBase[] structures = CreateArray<IUnityAssetBase>(innerCount);
								for (int j = 0; j < innerCount; j++)
								{
									structures[j] = CreateAndReadComplexStructure(ref reader, version, flags, depth, etalon);
								}
								result[i] = structures;

								if (etalon.Align)
								{
									reader.Align();
								}
							}

							AsAssetArrayArray = result;
						}
						break;
					default:
						throw new NotSupportedException(etalon.Type.Type.ToString());
				}
				break;
			default:
				throw new NotSupportedException(etalon.ArrayDepth.ToString());
		}

		if (etalon.Align)
		{
			reader.Align();
		}

		static IUnityAssetBase CreateAndReadComplexStructure(ref EndianSpanReader reader, UnityVersion version, TransferInstructionFlags flags, int depth, SerializableType.Field etalon)
		{
			IUnityAssetBase asset = etalon.Type.CreateInstance(depth + 1, version);
			if (asset is SerializableStructure structure)
			{
				structure.Read(ref reader, version, flags);
			}
			else
			{
				asset.Read(ref reader, flags);
			}

			return asset;
		}
	}

	private static void ThrowIfNotEnoughSpaceToReadArray(EndianSpanReader reader, SerializableType.Field etalon, int count)
	{
		long remainingBytes = reader.Length - reader.Position;
		if (remainingBytes < count)
		{
			throw new EndOfStreamException($"When reading field {etalon.Name}, Stream only has {remainingBytes} bytes remaining, so {count} complex elements of type {etalon.Type.Name} cannot be read.");
		}
	}

	public readonly void Write(AssetWriter writer, in SerializableType.Field etalon)
	{
		switch (etalon.ArrayDepth)
		{
			case 0:
				switch (etalon.Type.Type)
				{
					case PrimitiveType.Bool:
						writer.Write(AsBoolean);
						break;
					case PrimitiveType.Char:
						writer.Write(AsChar);
						break;
					case PrimitiveType.SByte:
						writer.Write(AsSByte);
						break;
					case PrimitiveType.Byte:
						writer.Write(AsByte);
						break;
					case PrimitiveType.Short:
						writer.Write(AsInt16);
						break;
					case PrimitiveType.UShort:
						writer.Write(AsUInt16);
						break;
					case PrimitiveType.Int:
						writer.Write(AsInt32);
						break;
					case PrimitiveType.UInt:
						writer.Write(AsUInt32);
						break;
					case PrimitiveType.Long:
						writer.Write(AsInt64);
						break;
					case PrimitiveType.ULong:
						writer.Write(AsUInt64);
						break;
					case PrimitiveType.Single:
						writer.Write(AsSingle);
						break;
					case PrimitiveType.Double:
						writer.Write(AsDouble);
						break;
					case PrimitiveType.String:
						writer.Write(AsString);
						break;
					case PrimitiveType.Complex:
						AsAsset.Write(writer);
						break;
					case PrimitiveType.Pair:
					case PrimitiveType.MapPair:
						AsPair.Write(writer);
						break;
					default:
						throw new NotSupportedException(etalon.Type.Type.ToString());
				}
				break;
			case 1:
				switch (etalon.Type.Type)
				{
					case PrimitiveType.Bool:
						writer.WriteArray(AsBooleanArray);
						break;
					case PrimitiveType.Char:
						writer.WriteArray(AsCharArray);
						break;
					case PrimitiveType.SByte:
						writer.WriteArray(AsSByteArray);
						break;
					case PrimitiveType.Byte:
						writer.WriteArray(AsByteArray);
						break;
					case PrimitiveType.Short:
						writer.WriteArray(AsInt16Array);
						break;
					case PrimitiveType.UShort:
						writer.WriteArray(AsUInt16Array);
						break;
					case PrimitiveType.Int:
						writer.WriteArray(AsInt32Array);
						break;
					case PrimitiveType.UInt:
						writer.WriteArray(AsUInt32Array);
						break;
					case PrimitiveType.Long:
						writer.WriteArray(AsInt64Array);
						break;
					case PrimitiveType.ULong:
						writer.WriteArray(AsUInt64Array);
						break;
					case PrimitiveType.Single:
						writer.WriteArray(AsSingleArray);
						break;
					case PrimitiveType.Double:
						writer.WriteArray(AsDoubleArray);
						break;
					case PrimitiveType.String:
						writer.WriteArray(AsStringArray);
						break;
					case PrimitiveType.Complex:
						writer.WriteAssetArray(AsAssetArray);
						break;
					case PrimitiveType.Pair:
					case PrimitiveType.MapPair:
						{
							SerializablePair[] pairs = AsPairArray;
							writer.Write(pairs.Length);
							foreach (SerializablePair pair in pairs)
							{
								pair.Write(writer);
							}
						}
						break;
					default:
						throw new NotSupportedException(etalon.Type.Type.ToString());
				}
				break;
			case 2:
				throw new NotImplementedException();
			default:
				throw new NotSupportedException(etalon.ArrayDepth.ToString());
		}
		if (etalon.Align)
		{
			writer.AlignStream();
		}
	}

	public readonly void WalkEditor(AssetWalker walker, in SerializableType.Field etalon)
	{
		switch (etalon.ArrayDepth)
		{
			case 0:
				switch (etalon.Type.Type)
				{
					case PrimitiveType.Bool:
						walker.VisitPrimitive(AsBoolean);
						break;
					case PrimitiveType.Char:
						walker.VisitPrimitive(AsChar);
						break;
					case PrimitiveType.SByte:
						walker.VisitPrimitive(AsSByte);
						break;
					case PrimitiveType.Byte:
						walker.VisitPrimitive(AsByte);
						break;
					case PrimitiveType.Short:
						walker.VisitPrimitive(AsInt16);
						break;
					case PrimitiveType.UShort:
						walker.VisitPrimitive(AsUInt16);
						break;
					case PrimitiveType.Int:
						walker.VisitPrimitive(AsInt32);
						break;
					case PrimitiveType.UInt:
						walker.VisitPrimitive(AsUInt32);
						break;
					case PrimitiveType.Long:
						walker.VisitPrimitive(AsInt64);
						break;
					case PrimitiveType.ULong:
						walker.VisitPrimitive(AsUInt64);
						break;
					case PrimitiveType.Single:
						walker.VisitPrimitive(AsSingle);
						break;
					case PrimitiveType.Double:
						walker.VisitPrimitive(AsDouble);
						break;
					case PrimitiveType.String:
						walker.VisitPrimitive(AsString);
						break;
					case PrimitiveType.Complex:
						AsAsset.WalkEditor(walker);
						break;
					case PrimitiveType.Pair:
						AsPair.WalkEditor(walker);
						break;
					default:
						throw new NotSupportedException(etalon.Type.Type.ToString());
				}
				break;
			case 1:
				switch (etalon.Type.Type)
				{
					case PrimitiveType.Bool:
						VisitPrimitiveArray(walker, AsBooleanArray);
						break;
					case PrimitiveType.Char:
						VisitPrimitiveArray(walker, AsCharArray);
						break;
					case PrimitiveType.SByte:
						VisitPrimitiveArray(walker, AsSByteArray);
						break;
					case PrimitiveType.Byte:
						VisitPrimitiveArray(walker, AsByteArray);
						break;
					case PrimitiveType.Short:
						VisitPrimitiveArray(walker, AsInt16Array);
						break;
					case PrimitiveType.UShort:
						VisitPrimitiveArray(walker, AsUInt16Array);
						break;
					case PrimitiveType.Int:
						VisitPrimitiveArray(walker, AsInt32Array);
						break;
					case PrimitiveType.UInt:
						VisitPrimitiveArray(walker, AsUInt32Array);
						break;
					case PrimitiveType.Long:
						VisitPrimitiveArray(walker, AsInt64Array);
						break;
					case PrimitiveType.ULong:
						VisitPrimitiveArray(walker, AsUInt64Array);
						break;
					case PrimitiveType.Single:
						VisitPrimitiveArray(walker, AsSingleArray);
						break;
					case PrimitiveType.Double:
						VisitPrimitiveArray(walker, AsDoubleArray);
						break;
					case PrimitiveType.String:
						VisitPrimitiveArray(walker, AsStringArray);
						break;
					case PrimitiveType.Complex:
						{
							IUnityAssetBase[] structures = AsAssetArray;
							if (walker.EnterList(structures))
							{
								int length = structures.Length;
								if (length > 0)
								{
									int i = 0;
									while (true)
									{
										structures[i].WalkEditor(walker);
										i++;
										if (i >= length)
										{
											break;
										}
										walker.DivideList(structures);
									}
								}
								walker.ExitList(structures);
							}
						}
						break;
					case PrimitiveType.MapPair:
						if (etalon.Type.Fields[0].Type.Type is PrimitiveType.String)
						{
							new PairCollection<string>(AsPairArray).WalkEditor(walker);
						}
						else
						{
							new PairCollection<SerializableValue>(AsPairArray).WalkEditor(walker);
						}
						break;
					case PrimitiveType.Pair:
					default:
						throw new NotSupportedException(etalon.Type.Type.ToString());
				}
				break;
			case 2:
				throw new NotImplementedException();
			default:
				throw new NotSupportedException(etalon.ArrayDepth.ToString());
		}
	}

	private static void VisitPrimitiveArray<T>(AssetWalker walker, T[] array) where T : notnull
	{
		if (walker.EnterList(array))
		{
			int length = array.Length;
			if (length > 0)
			{
				int i = 0;
				while (true)
				{
					walker.VisitPrimitive(array[i]);
					i++;
					if (i >= length)
					{
						break;
					}
					walker.DivideList(array);
				}
			}
			walker.ExitList(array);
		}
	}

	internal void CopyValues(SerializableValue source, int depth, in SerializableType.Field etalon, PPtrConverter converter)
	{
		switch (etalon.ArrayDepth)
		{
			case 0:
				if (etalon.Type.Type == PrimitiveType.Complex)
				{
					IUnityAssetBase thisStructure = etalon.Type.CreateInstance(depth + 1, converter.TargetCollection.Version);
					if (source.CValue is IUnityAssetBase sourceStructure)
					{
						thisStructure.CopyValues(sourceStructure, converter);
					}
					PValue = default;
					CValue = thisStructure;
				}
				else if (etalon.Type.Type is PrimitiveType.String)
				{
					PValue = default;
					CValue = source.CValue as string ?? "";
				}
				else if (etalon.Type.Type is PrimitiveType.MapPair or PrimitiveType.Pair)
				{
					PValue = default;
					SerializablePair thisPair = new(etalon.Type, depth + 1);
					thisPair.Initialize(converter.TargetCollection.Version);
					if (source.CValue is SerializablePair sourcePair)
					{
						thisPair.CopyValues(sourcePair, converter);
					}
					CValue = thisPair;
				}
				else
				{
					PValue = source.PValue;
					CValue = default!;
				}
				break;
			case 1:
				PValue = default;
				switch (etalon.Type.Type)
				{
					case PrimitiveType.Bool:
						{
							ReadOnlySpan<bool> span = source.CValue as bool[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.Char:
						{
							ReadOnlySpan<char> span = source.CValue as char[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.SByte:
						{
							ReadOnlySpan<byte> span = source.CValue as byte[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.Byte:
						{
							ReadOnlySpan<byte> span = source.CValue as byte[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.Short:
						{
							ReadOnlySpan<short> span = source.CValue as short[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.UShort:
						{
							ReadOnlySpan<ushort> span = source.CValue as ushort[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.Int:
						{
							ReadOnlySpan<int> span = source.CValue as int[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.UInt:
						{
							ReadOnlySpan<uint> span = source.CValue as uint[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.Long:
						{
							ReadOnlySpan<long> span = source.CValue as long[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.ULong:
						{
							ReadOnlySpan<ulong> span = source.CValue as ulong[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.Single:
						{
							ReadOnlySpan<float> span = source.CValue as float[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.Double:
						{
							ReadOnlySpan<double> span = source.CValue as double[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.String:
						{
							ReadOnlySpan<string> span = source.CValue as string[];
							CValue = span.ToArray();
						}
						break;
					case PrimitiveType.Complex:
						{
							if (source.CValue is IUnityAssetBase[] sourceStructures)
							{
								IUnityAssetBase[] thisStructures = new IUnityAssetBase[sourceStructures.Length];
								for (int i = 0; i < sourceStructures.Length; i++)
								{
									IUnityAssetBase sourceStructure = sourceStructures[i];
									IUnityAssetBase thisStructure = etalon.Type.CreateInstance(depth + 1, converter.TargetCollection.Version);
									thisStructure.CopyValues(sourceStructure, converter);
									thisStructures[i] = thisStructure;
								}
								CValue = thisStructures;
							}
							else
							{
								CValue = Array.Empty<IUnityAssetBase>();
							}
						}
						break;
					case PrimitiveType.MapPair or PrimitiveType.Pair:
						{
							if (source.CValue is SerializablePair[] sourcePairs)
							{
								SerializablePair[] thisPairs = new SerializablePair[sourcePairs.Length];
								for (int i = 0; i < sourcePairs.Length; i++)
								{
									SerializablePair sourcePair = sourcePairs[i];
									SerializablePair thisPair = new(etalon.Type, depth + 1);
									thisPair.Initialize(converter.TargetCollection.Version);
									thisPair.CopyValues(sourcePair, converter);
									thisPairs[i] = thisPair;
								}
								CValue = thisPairs;
							}
							else
							{
								CValue = Array.Empty<SerializablePair>();
							}
						}
						break;
					default:
						throw new NotSupportedException(etalon.Type.Type.ToString());
				}
				break;
			case 2:
				throw new NotImplementedException();
			default:
				throw new NotSupportedException(etalon.ArrayDepth.ToString());
		}
	}

	internal void Initialize(UnityVersion version, int depth, in SerializableType.Field etalon)
	{
		PValue = default;
		CValue = etalon.ArrayDepth switch
		{
			0 => etalon.Type.Type switch
			{
				PrimitiveType.String => "",
				PrimitiveType.Complex => etalon.Type.CreateInstance(depth + 1, version),
				_ => default!,
			},
			1 => etalon.Type.Type switch
			{
				PrimitiveType.Bool => Array.Empty<bool>(),
				PrimitiveType.Char => Array.Empty<char>(),
				PrimitiveType.SByte => Array.Empty<sbyte>(),
				PrimitiveType.Byte => Array.Empty<byte>(),
				PrimitiveType.Short => Array.Empty<short>(),
				PrimitiveType.UShort => Array.Empty<ushort>(),
				PrimitiveType.Int => Array.Empty<int>(),
				PrimitiveType.UInt => Array.Empty<uint>(),
				PrimitiveType.Long => Array.Empty<long>(),
				PrimitiveType.ULong => Array.Empty<ulong>(),
				PrimitiveType.Single => Array.Empty<float>(),
				PrimitiveType.Double => Array.Empty<double>(),
				PrimitiveType.String => Array.Empty<string>(),
				PrimitiveType.Complex => Array.Empty<IUnityAssetBase>(),
				PrimitiveType.Pair or PrimitiveType.MapPair => Array.Empty<SerializablePair>(),
				_ => throw new NotSupportedException(etalon.Type.Type.ToString()),
			},
			2 => etalon.Type.Type switch
			{
				PrimitiveType.Bool => Array.Empty<bool[]>(),
				PrimitiveType.Char => Array.Empty<char[]>(),
				PrimitiveType.SByte => Array.Empty<sbyte[]>(),
				PrimitiveType.Byte => Array.Empty<byte[]>(),
				PrimitiveType.Short => Array.Empty<short[]>(),
				PrimitiveType.UShort => Array.Empty<ushort[]>(),
				PrimitiveType.Int => Array.Empty<int[]>(),
				PrimitiveType.UInt => Array.Empty<uint[]>(),
				PrimitiveType.Long => Array.Empty<long[]>(),
				PrimitiveType.ULong => Array.Empty<ulong[]>(),
				PrimitiveType.Single => Array.Empty<float[]>(),
				PrimitiveType.Double => Array.Empty<double[]>(),
				PrimitiveType.String => Array.Empty<string[]>(),
				PrimitiveType.Complex => Array.Empty<IUnityAssetBase[]>(),
				_ => throw new NotSupportedException(etalon.Type.Type.ToString()),
			},
			_ => throw new NotSupportedException(etalon.ArrayDepth.ToString()),
		};
	}

	public readonly IEnumerable<(string, PPtr)> FetchDependencies(SerializableType.Field etalon)
	{
		if (etalon.Type.Type == PrimitiveType.Complex)
		{
			if (etalon.IsArray)
			{
				IUnityAssetBase[] structures = (IUnityAssetBase[])CValue;
				for (int i = 0; i < structures.Length; i++)
				{
					foreach ((string path, PPtr pptr) in structures[i].FetchDependencies())
					{
						yield return ($"{etalon.Name}[{i}].{path}", pptr);
					}
				}
			}
			else
			{
				Debug.Assert(etalon.ArrayDepth == 0);
				IUnityAssetBase structure = (IUnityAssetBase)CValue;
				foreach ((string path, PPtr pptr) in structure.FetchDependencies())
				{
					yield return ($"{etalon.Name}.{path}", pptr);
				}
			}
		}
	}

	public void Reset()
	{
		PValue = default;
		switch (CValue)
		{
			case null:
				break;
			case string:
				CValue = "";
				break;
			case IUnityAssetBase asset:
				asset.Reset();
				break;
			case SerializablePair pair:
				pair.Reset();
				break;
			case bool[]:
				CValue = Array.Empty<bool>();
				break;
			case char[]:
				CValue = Array.Empty<char>();
				break;
			case sbyte[]:
				CValue = Array.Empty<sbyte>();
				break;
			case byte[]:
				CValue = Array.Empty<byte>();
				break;
			case short[]:
				CValue = Array.Empty<short>();
				break;
			case ushort[]:
				CValue = Array.Empty<ushort>();
				break;
			case int[]:
				CValue = Array.Empty<int>();
				break;
			case uint[]:
				CValue = Array.Empty<uint>();
				break;
			case long[]:
				CValue = Array.Empty<long>();
				break;
			case ulong[]:
				CValue = Array.Empty<ulong>();
				break;
			case Half[]:
				CValue = Array.Empty<Half>();
				break;
			case float[]:
				CValue = Array.Empty<float>();
				break;
			case double[]:
				CValue = Array.Empty<double>();
				break;
			case string[]:
				CValue = Array.Empty<string>();
				break;
			case IUnityAssetBase[]:
				CValue = Array.Empty<IUnityAssetBase>();
				break;
			case SerializablePair[]:
				CValue = Array.Empty<SerializablePair>();
				break;
			case bool[][]:
				CValue = Array.Empty<bool[]>();
				break;
			case char[][]:
				CValue = Array.Empty<char[]>();
				break;
			case sbyte[][]:
				CValue = Array.Empty<sbyte[]>();
				break;
			case byte[][]:
				CValue = Array.Empty<byte[]>();
				break;
			case short[][]:
				CValue = Array.Empty<short[]>();
				break;
			case ushort[][]:
				CValue = Array.Empty<ushort[]>();
				break;
			case int[][]:
				CValue = Array.Empty<int[]>();
				break;
			case uint[][]:
				CValue = Array.Empty<uint[]>();
				break;
			case long[][]:
				CValue = Array.Empty<long[]>();
				break;
			case ulong[][]:
				CValue = Array.Empty<ulong[]>();
				break;
			case Half[][]:
				CValue = Array.Empty<Half[]>();
				break;
			case float[][]:
				CValue = Array.Empty<float[]>();
				break;
			case double[][]:
				CValue = Array.Empty<double[]>();
				break;
			case string[][]:
				CValue = Array.Empty<string[]>();
				break;
			case IUnityAssetBase[][]:
				CValue = Array.Empty<IUnityAssetBase[]>();
				break;
		}
	}

	private readonly string GetDebuggerDisplay()
	{
		return CValue?.ToString() ?? PValue.ToString();
	}

	private static T[] CreateArray<T>(int length) => length is 0 ? [] : new T[length];

	private sealed class PairCollection<TKey>(SerializablePair[] array) : IReadOnlyCollection<KeyValuePair<TKey, SerializableValue>>
		where TKey : notnull
	{
		public int Count => array.Length;

		private static KeyValuePair<TKey, SerializableValue> Convert(SerializablePair pair)
		{
			if (typeof(TKey) == typeof(string))
			{
				return new KeyValuePair<TKey, SerializableValue>((TKey)(object)pair.First.AsString, pair.Second);
			}
			else if (typeof(TKey) == typeof(SerializableValue))
			{
				return new KeyValuePair<TKey, SerializableValue>((TKey)(object)pair.First, pair.Second);
			}
			else
			{
				throw new InvalidOperationException();
			}
		}

		public IEnumerator<KeyValuePair<TKey, SerializableValue>> GetEnumerator()
		{
			foreach (SerializablePair pair in array)
			{
				yield return Convert(pair);
			}
		}

		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

		public void WalkEditor(AssetWalker walker)
		{
			if (walker.EnterDictionary(this))
			{
				int length = array.Length;
				if (length > 0)
				{
					int i = 0;
					while (true)
					{
						array[i].WalkEditor(walker);
						i++;
						if (i >= length)
						{
							break;
						}
						walker.DivideDictionary(this);
					}
				}
				walker.ExitDictionary(this);
			}
		}
	}
}

```

`Source/AssetRipper.Import/Structure/Assembly/Serializable/UnloadedStructure.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.IO.Writing;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.IO.Endian;
using AssetRipper.SourceGenerated.Classes.ClassID_114;

namespace AssetRipper.Import.Structure.Assembly.Serializable;

/// <summary>
/// This is a placeholder asset that lazily reads the actual structure sometime after all the assets have been loaded.
/// This allows MonoBehaviours to be loaded before their referenced MonoScript.
/// </summary>
public sealed class UnloadedStructure : UnityAssetBase, IDeepCloneable
{
	private sealed class StatelessAsset : UnityAssetBase, IDeepCloneable
	{
		public static StatelessAsset Instance { get; } = new();
		private StatelessAsset()
		{
		}

		public override void Reset()
		{
		}

		public override bool? AddToEqualityComparer(IUnityAssetBase other, AssetEqualityComparer comparer)
		{
			return other is StatelessAsset;
		}

		IUnityAssetBase IDeepCloneable.DeepClone(PPtrConverter converter) => this;
	}

	/// <summary>
	/// The <see cref="IMonoBehaviour"/> that <see langword="this"/> is the <see cref="IMonoBehaviour.Structure"/> for.
	/// </summary>
	public IMonoBehaviour MonoBehaviour { get; }

	public IAssemblyManager AssemblyManager { get; }

	/// <summary>
	/// The segment of data for this structure.
	/// </summary>
	public ReadOnlyArraySegment<byte> StructureData { get; }

	public UnloadedStructure(IMonoBehaviour monoBehaviour, IAssemblyManager assemblyManager, ReadOnlyArraySegment<byte> structureData)
	{
		MonoBehaviour = monoBehaviour;
		AssemblyManager = assemblyManager;
		StructureData = structureData;
	}

	private void ThrowIfNotStructure()
	{
		if (!ReferenceEquals(MonoBehaviour.Structure, this))
		{
			throw new InvalidOperationException("The MonoBehaviour structure has already been loaded.");
		}
	}

	public SerializableStructure? LoadStructure()
	{
		ThrowIfNotStructure();
		string? failureReason = null;
		SerializableStructure? structure = MonoBehaviour.ScriptP?.GetBehaviourType(AssemblyManager, out failureReason)?.CreateSerializableStructure();
		if (structure is not null)
		{
			EndianSpanReader reader = new EndianSpanReader(StructureData, MonoBehaviour.Collection.EndianType);
			if (structure.TryRead(ref reader, MonoBehaviour))
			{
				MonoBehaviour.Structure = structure;
				return structure;
			}
		}
		else if (failureReason is not null)
		{
			Logger.Warning(LogCategory.Import, $"Could not read MonoBehaviour structure for `{MonoBehaviour.ScriptP?.GetFullName()}`. Reason: {failureReason}");
		}

		MonoBehaviour.Structure = null;
		return null;
	}

	private UnityAssetBase LoadStructureOrStatelessAsset()
	{
		return (UnityAssetBase?)LoadStructure() ?? StatelessAsset.Instance;
	}

	public IUnityAssetBase DeepClone(PPtrConverter converter)
	{
		return LoadStructure()?.DeepClone(converter) ?? (IUnityAssetBase)StatelessAsset.Instance;
	}

	#region UnityAssetBase Overrides
	public override bool FlowMappedInYaml => LoadStructure()?.FlowMappedInYaml ?? base.FlowMappedInYaml;

	public override int SerializedVersion => LoadStructure()?.SerializedVersion ?? base.SerializedVersion;

	public override void WalkEditor(AssetWalker walker)
	{
		LoadStructureOrStatelessAsset().WalkEditor(walker);
	}

	public override void WalkRelease(AssetWalker walker)
	{
		LoadStructureOrStatelessAsset().WalkRelease(walker);
	}

	public override void WalkStandard(AssetWalker walker)
	{
		LoadStructureOrStatelessAsset().WalkStandard(walker);
	}

	public override IEnumerable<(string, PPtr)> FetchDependencies()
	{
		return LoadStructure()?.FetchDependencies() ?? [];
	}

	public override void WriteEditor(AssetWriter writer) => LoadStructure()?.WriteEditor(writer);

	public override void WriteRelease(AssetWriter writer) => LoadStructure()?.WriteRelease(writer);

	public override void CopyValues(IUnityAssetBase? source, PPtrConverter converter)
	{
		SerializableStructure? loadedStructure = LoadStructure();
		if (source is not UnloadedStructure unloadedSource)
		{
			loadedStructure?.CopyValues(source, converter);
		}
		else if (ReferenceEquals(this, unloadedSource))
		{
			loadedStructure?.CopyValues(loadedStructure, converter);
		}
		else
		{
			loadedStructure?.CopyValues(unloadedSource.LoadStructure(), converter);
		}
	}

	public override void Reset() => LoadStructure()?.Reset();

	public override bool? AddToEqualityComparer(IUnityAssetBase other, AssetEqualityComparer comparer)
	{
		return LoadStructureOrStatelessAsset().AddToEqualityComparer(other, comparer);
	}
	#endregion
}

```

`Source/AssetRipper.Import/Structure/Assembly/TypeTrees/SerializableTreeType.cs`:

```cs
using AssetRipper.SerializationLogic;
using AssetRipper.SourceGenerated.Extensions;
using System.Diagnostics;

namespace AssetRipper.Import.Structure.Assembly.TypeTrees;

public sealed class SerializableTreeType : SerializableType
{
	private SerializableTreeType(string name, PrimitiveType type, int version, bool flowMappedInYaml) : base(null, type, name)
	{
		Version = version;
		FlowMappedInYaml = flowMappedInYaml;
	}

	public override int Version { get; }
	public override bool FlowMappedInYaml { get; }

	public static SerializableTreeType FromRootNode(TypeTreeNodeStruct rootNode, bool monoBehaviourStructure = false)
	{
		ToPrimititeType(rootNode, out string typeName, out PrimitiveType primitiveType, out int arrayDepth, out _, out TypeTreeNodeStruct primitiveNode);
		Debug.Assert(arrayDepth == 0, "Array depth should be 0 for root node");
		Debug.Assert(primitiveNode == rootNode, "Primitive node should be the same as root node");
		Debug.Assert(!monoBehaviourStructure || primitiveType is PrimitiveType.Complex, "MonoBehaviour structure should be complex type");

		SerializableTreeType serializableTreeType = new SerializableTreeType(typeName, primitiveType, rootNode.Version, rootNode.FlowMappedInYaml);

		List<Field> fields = new();
		int startIndex = monoBehaviourStructure ? FindStartingIndexForMonoBehaviour(rootNode) : 0;
		for (int i = startIndex; i < rootNode.SubNodes.Count; i++)
		{
			AddNode(rootNode.SubNodes[i], fields);
		}
		serializableTreeType.Fields = fields;
		serializableTreeType.SetMaxDepth();
		return serializableTreeType;
	}

	private static void AddNode(TypeTreeNodeStruct node, List<Field> fields)
	{
		ToPrimititeType(node, out string typeName, out PrimitiveType primitiveType, out int arrayDepth, out bool alignBytes, out TypeTreeNodeStruct primitiveNode);

		SerializableType serializableType;
		if (primitiveType is PrimitiveType.Complex or PrimitiveType.Pair or PrimitiveType.MapPair)
		{
			if (primitiveNode.IsPPtr)
			{
				serializableType = SerializablePointerType.Shared;
			}
			else
			{
				serializableType = FromStructureNode(typeName, primitiveNode, primitiveType);
			}
		}
		else
		{
			serializableType = new SerializableTreeType(typeName, primitiveType, primitiveNode.Version, primitiveNode.FlowMappedInYaml)
			{
				MaxDepth = 0
			};
		}

		fields.Add(new Field(serializableType, arrayDepth, node.Name, alignBytes));
	}

	private static SerializableTreeType FromStructureNode(string name, TypeTreeNodeStruct node, PrimitiveType type)
	{
		SerializableTreeType serializableTreeType = new SerializableTreeType(name, type, node.Version, node.FlowMappedInYaml);
		List<Field> fields = new();
		foreach (TypeTreeNodeStruct subNode in node.SubNodes)
		{
			AddNode(subNode, fields);
		}
		serializableTreeType.Fields = fields;
		serializableTreeType.SetMaxDepth();
		return serializableTreeType;
	}

	private static int FindStartingIndexForMonoBehaviour(TypeTreeNodeStruct rootNode)
	{
		int nameIndex = rootNode.SubNodes.IndexOf(node => node.Name == "m_Name");
		int editorClassIdIndex = rootNode.SubNodes.IndexOf(node => node.Name == "m_EditorClassIdentifier");
		int startIndex = Math.Max(nameIndex, editorClassIdIndex) + 1;
		return startIndex;
	}

	private static void ToPrimititeType(TypeTreeNodeStruct node, out string typeName, out PrimitiveType primitiveType, out int arrayDepth, out bool alignBytes, out TypeTreeNodeStruct primitiveNode)
	{
		bool isMap = false;
		alignBytes = false;
		typeName = "";
		arrayDepth = 0;
		while (true)
		{
			alignBytes |= node.AlignBytes;
			if (node.IsArray)
			{
				arrayDepth++;
				node = node[1];
			}
			else if (node.IsVector)
			{
				alignBytes |= node[0].AlignBytes;
				arrayDepth++;
				node = node[0][1];
			}
			else if (node.IsNamedVector)
			{
				//It's important that typeName is set before node is reassigned.
				SetIfEmpty(ref typeName, node.TypeName);
				alignBytes |= node[0].AlignBytes;
				arrayDepth++;
				node = node[0][1];
			}
			else if (node.IsMap)
			{
				isMap = true;
				alignBytes |= node[0].AlignBytes;
				arrayDepth++;
				node = node[0][1];
			}
			else
			{
				SetIfEmpty(ref typeName, node.TypeName);
				break;
			}
		}


		primitiveType = node.Count == 0
			? node.TypeName switch
			{
				"bool" => PrimitiveType.Bool,
				"char" or "UInt8" => PrimitiveType.Byte,
				"SInt8" => PrimitiveType.SByte,
				"short" or "SInt16" => PrimitiveType.Short,
				"ushort" or "UInt16" or "unsigned short" => node.TreatIntegerAsChar ? PrimitiveType.Char : PrimitiveType.UShort,
				"int" or "SInt32" or "Type*" => PrimitiveType.Int,
				"uint" or "UInt32" or "unsigned int" => PrimitiveType.UInt,
				"SInt64" or "long long" => PrimitiveType.Long,
				"UInt64" or "FileSize" or "unsigned long long" => PrimitiveType.ULong,
				"float" => PrimitiveType.Single,
				"double" => PrimitiveType.Double,
				_ => PrimitiveType.Complex,
			}
			: false switch
			{
				_ when node.IsString => PrimitiveType.String,
				_ when node.IsPair => isMap ? PrimitiveType.MapPair : PrimitiveType.Pair,
				_ => PrimitiveType.Complex,
			};
		primitiveNode = node;

		static void SetIfEmpty(ref string local, string value)
		{
			if (string.IsNullOrEmpty(local))
			{
				local = value;
			}
		}
	}

	private void SetMaxDepth()
	{
		int maxDepth = 0;
		foreach (Field field in Fields)
		{
			Debug.Assert(field.Type.IsMaxDepthKnown, "The depth of this type is not known.");
			maxDepth = Math.Max(maxDepth, field.Type.MaxDepth + 1);
		}
		MaxDepth = maxDepth;
	}
}

```

`Source/AssetRipper.Import/Structure/Assembly/TypeTrees/TypeTreeNodeStruct.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees;
using AssetRipper.SerializationLogic;
using AssetRipper.SourceGenerated;
using AssetRipper.Tpk;
using AssetRipper.Tpk.Shared;
using AssetRipper.Tpk.TypeTrees;
using System.Collections;
using System.Diagnostics;

namespace AssetRipper.Import.Structure.Assembly.TypeTrees;

public readonly struct TypeTreeNodeStruct : IReadOnlyList<TypeTreeNodeStruct>, IEquatable<TypeTreeNodeStruct>
{
	[field: MaybeNull]
	private static TpkTypeTreeBlob TypeTreeBlob
	{
		get
		{
			field ??= (TpkTypeTreeBlob)TpkFile.FromStream(SourceTpk.GetStream()).GetDataBlob();
			return field;
		}
	}

	public string TypeName { get; }
	public string Name { get; }
	public int Version { get; }
	public TransferMetaFlags MetaFlag { get; }
	public IReadOnlyList<TypeTreeNodeStruct> SubNodes => subNodes;
	public bool AlignBytes => MetaFlag.IsAlignBytes();
	public bool TreatIntegerAsChar => MetaFlag.IsCharPropertyMask();
	public bool FlowMappedInYaml => MetaFlag.IsTransferUsingFlowMappingStyle();

	private readonly TypeTreeNodeStruct[] subNodes;

	public int Count => subNodes.Length;

	public TypeTreeNodeStruct this[int index] => subNodes[index];

	public TypeTreeNodeStruct this[string name] => subNodes.First(t => t.Name == name);

	public bool IsArray
	{
		get
		{
			if (TypeName is "Array" or "TypelessData" && SubNodes.Count == 2)
			{
				TypeTreeNodeStruct sizeNode = SubNodes[0];
				return sizeNode.Name == "size" && sizeNode.SubNodes.Count == 0 && SubNodes[1].Name == "data";
			}
			return false;
		}
	}

	public bool IsTypelessData
	{
		get
		{
			if (TypeName is "TypelessData" && SubNodes.Count == 2)
			{
				TypeTreeNodeStruct sizeNode = SubNodes[0];
				return sizeNode.Name == "size" && sizeNode.SubNodes.Count == 0 && SubNodes[1].Name == "data";
			}
			return false;
		}
	}

	public bool IsVector
	{
		get
		{
			return TypeName is "vector" or "staticvector" or "set" && SubNodes.Count == 1 && SubNodes[0].IsArray;
		}
	}

	/// <summary>
	/// This is the same as a vector, except the <see cref="TypeName"/> of the element type node is used
	/// instead of "vector" or any of the other predefined type names for arrays and lists.
	/// </summary>
	/// <remarks>
	/// This was first noticed in a scriptable object where the field was a <see cref="List{T}"/> of a serializable class.
	/// </remarks>
	public bool IsNamedVector
	{
		get
		{
			if (SubNodes.Count == 1 && SubNodes[0].IsArray && SubNodes[0].Name is "Array")
			{
				string elementTypeName = SubNodes[0].SubNodes[1].TypeName;
				return elementTypeName == TypeName || elementTypeName is "Generic Mono";
				//Generic Mono has only been found on Unity 3.
				//https://github.com/AssetRipper/AssetRipper/issues/1328
			}
			return false;
		}
	}

	public bool IsPair
	{
		get
		{
			return TypeName is "pair" && SubNodes.Count == 2 && SubNodes[0].Name == "first" && SubNodes[1].Name == "second";
		}
	}

	public bool IsMap
	{
		get
		{
			return TypeName is "map" && SubNodes.Count == 1 && SubNodes[0].IsArray && SubNodes[0].SubNodes[1].IsPair;
		}
	}

	/// <summary>
	/// This contains the data for an asset's [SerializeReference] fields.
	/// </summary>
	/// <remarks>
	/// This is the last top-level field in the asset's type tree.
	/// </remarks>
	public bool IsManagedReferencesRegistry
	{
		get
		{
			return TypeName is "ManagedReferencesRegistry" && Name is "references" && SubNodes.Count > 1;
		}
	}

	/// <summary>
	/// This is the data for a [SerializeReference] object reference.
	/// </summary>
	/// <remarks>
	/// If the type tree is flattened into a list, this is the last entry in the list.
	/// </remarks>
	public bool IsReferencedObjectData
	{
		get
		{
			return TypeName is "ReferencedObjectData" && Name is "data" && SubNodes.Count is 0;
		}
	}

	public bool IsByte
	{
		get
		{
			return Count is 0 && TypeName is "char" or "UInt8";
		}
	}

	public bool IsString
	{
		get
		{
			return Count is 1 && TypeName is "string" && this[0].IsArray && this[0][1].IsByte;
		}
	}

	public bool IsPPtr
	{
		get
		{
			if (SubNodes.Count != 2)
			{
				return false;
			}

			TypeTreeNodeStruct fileIdNode = SubNodes[0];
			if (fileIdNode.Name is not "m_FileID" || fileIdNode.SubNodes.Count > 0)
			{
				return false;
			}

			TypeTreeNodeStruct pathIdNode = SubNodes[1];
			if (pathIdNode.Name is not "m_PathID" || pathIdNode.SubNodes.Count > 0)
			{
				return false;
			}

			//Note: custom MonoBehaviour fields have a '$' after the '<', eg PPtr<$GameObject>
			return TypeName.StartsWith("PPtr<", StringComparison.Ordinal) && TypeName.EndsWith('>');
		}
	}

	public TypeTreeNodeStruct(string typeName, string name, int version, TransferMetaFlags metaFlags, TypeTreeNodeStruct[] subNodes)
	{
		TypeName = typeName;
		Name = name;
		Version = version;
		MetaFlag = metaFlags;
		this.subNodes = subNodes;
	}

	private TypeTreeNodeStruct(TypeTreeNode node, TypeTreeNodeStruct[] subNodes)
	{
		TypeName = node.Type;
		Name = node.Name;
		Version = node.Version;
		MetaFlag = node.MetaFlag;
		this.subNodes = subNodes;
	}

	private TypeTreeNodeStruct(TpkUnityNode node, TypeTreeNodeStruct[] subNodes, TpkStringBuffer stringBuffer)
	{
		TypeName = stringBuffer[node.TypeName];
		Name = stringBuffer[node.Name];
		Version = node.Version;
		MetaFlag = (TransferMetaFlags)node.MetaFlag;
		this.subNodes = subNodes;
	}

	public override string ToString() => $"{TypeName} {Name} ({subNodes?.Length ?? 0} SubNodes)";

	public static bool TryMakeFromTypeTree(TypeTree tree, out TypeTreeNodeStruct rootNode)
	{
		if (tree.Nodes.Count == 0)
		{
			rootNode = default;
			return false;
		}
		else
		{
			rootNode = FromNodeList(tree.Nodes, 0);
			return true;
		}
	}

	public static bool TryMakeFromTpk(ClassIDType classID, UnityVersion version, out TypeTreeNodeStruct releaseTree, out TypeTreeNodeStruct editorTree)
	{
		TpkTypeTreeBlob blob = TypeTreeBlob;
		TpkClassInformation? classInformation = blob.ClassInformation.FirstOrDefault(c => c.ID == (int)classID);
		if (classInformation is not null)
		{
			TpkUnityClass @class = GetItemForVersion(classInformation.Classes, version);
			releaseTree = FromTpkNode(blob.NodeBuffer[@class.ReleaseRootNode], blob.StringBuffer, blob.NodeBuffer);
			editorTree = FromTpkNode(blob.NodeBuffer[@class.EditorRootNode], blob.StringBuffer, blob.NodeBuffer);
			return true;
		}

		releaseTree = default;
		editorTree = default;
		return false;
	}

	private static TypeTreeNodeStruct FromTpkNode(TpkUnityNode node, TpkStringBuffer stringBuffer, TpkUnityNodeBuffer nodeBuffer)
	{
		TypeTreeNodeStruct[] subNodes = new TypeTreeNodeStruct[node.SubNodes.Length];
		for (int i = 0; i < node.SubNodes.Length; i++)
		{
			subNodes[i] = FromTpkNode(nodeBuffer[node.SubNodes[i]], stringBuffer, nodeBuffer);
		}
		return new(node, subNodes, stringBuffer);
	}

	private static TypeTreeNodeStruct FromNodeList(List<TypeTreeNode> list, int index)
	{
		TypeTreeNode node = list[index];
		int level = node.Level;
		if (index + 1 == list.Count || list[index + 1].Level <= level)
		{
			//Has no sub nodes
			return new TypeTreeNodeStruct(node, []);
		}
		else
		{
			Debug.Assert(list[index + 1].Level == level + 1);
			int subNodeCount = 0;
			for (int i = index + 1; i < list.Count; i++)
			{
				int subNodeLevel = list[i].Level;
				if (subNodeLevel == level + 1)
				{
					subNodeCount++;
				}
				else if (subNodeLevel <= level)
				{
					break;
				}
			}
			TypeTreeNodeStruct[] subNodes = new TypeTreeNodeStruct[subNodeCount];
			int subNodeIndex = 0;
			for (int i = index + 1; i < list.Count; i++)
			{
				int subNodeLevel = list[i].Level;
				if (subNodeLevel == level + 1)
				{
					subNodes[subNodeIndex] = FromNodeList(list, i);
					subNodeIndex++;
				}
				else if (subNodeLevel <= level)
				{
					break;
				}
			}
			Debug.Assert(subNodeIndex == subNodeCount);
			return new TypeTreeNodeStruct(node, subNodes);
		}
	}

	public static TypeTreeNodeStruct FromSerializableType(SerializableType type)
	{
		return FromSerializableType(type, "Base", false, out _);
	}

	private static TypeTreeNodeStruct FromSerializableType(SerializableType type, string name, bool alignBytes, out bool anyChildUsesAlignBytes)
	{
		anyChildUsesAlignBytes = false;

		TypeTreeNodeStruct[] subNodes;
		switch (type.Fields.Count)
		{
			case 0:
				if (type.Type is PrimitiveType.String)
				{
					subNodes =
					[
						new("Array", "Array", 1, TransferMetaFlags.NoTransferFlags,
						[
							new("SInt32", "size", 1, TransferMetaFlags.NoTransferFlags, []),
							new("char", "data", 1, TransferMetaFlags.NoTransferFlags, []),
						]),
					];
				}
				else if (type.IsEnginePointer())
				{
					subNodes =
					[
						new("SInt32", "m_FileID", 1, TransferMetaFlags.NoTransferFlags, []),
						new("SInt64", "m_PathID", 1, TransferMetaFlags.NoTransferFlags, []),
						// Might need to handle m_PathID being SInt32 on older versions.
					];
				}
				else
				{
					subNodes = [];
				}

				break;
			default:
				subNodes = new TypeTreeNodeStruct[type.Fields.Count];

				for (int i = 0; i < type.Fields.Count; i++)
				{
					SerializableType.Field field = type.Fields[i];
					subNodes[i] = FromSerializableTypeField(field, out bool anyFieldChildUsesAlignBytes);
					anyChildUsesAlignBytes |= field.Align | anyFieldChildUsesAlignBytes;
				}
				break;
		}

		TransferMetaFlags metaFlag = TransferMetaFlags.NoTransferFlags;
		if (alignBytes)
		{
			metaFlag |= TransferMetaFlags.AlignBytes;
		}
		if (anyChildUsesAlignBytes)
		{
			metaFlag |= TransferMetaFlags.AnyChildUsesAlignBytes;
		}
		if (type.FlowMappedInYaml)
		{
			metaFlag |= TransferMetaFlags.TransferUsingFlowMappingStyle;
		}
		if (type.Type is PrimitiveType.Char)
		{
			metaFlag |= TransferMetaFlags.CharPropertyMask;
		}

		string typeName = type.Type switch
		{
			PrimitiveType.Bool => "bool",
			PrimitiveType.Char => "UInt16",
			PrimitiveType.Byte => "UInt8",
			PrimitiveType.SByte => "SInt8",
			PrimitiveType.Short => "SInt16",
			PrimitiveType.UShort => "UInt16",
			PrimitiveType.Int => "SInt32",
			PrimitiveType.UInt => "UInt32",
			PrimitiveType.Long => "SInt64",
			PrimitiveType.ULong => "UInt64",
			PrimitiveType.Single => "float",
			PrimitiveType.Double => "double",
			PrimitiveType.String => "string",
			PrimitiveType.Complex => type.IsEnginePointer() ? "PPtr<Object>" : type.Name,
			_ => type.Name,
		};

		return new(typeName, name, type.Version, metaFlag, subNodes);
	}

	private static TypeTreeNodeStruct FromSerializableTypeField(SerializableType.Field field, out bool anyChildUsesAlignBytes)
	{
		switch (field.ArrayDepth)
		{
			case 0:
				return FromSerializableType(field.Type, field.Name, field.Align, out anyChildUsesAlignBytes);
			case 1:
				{
					// Note: treatment of alignment is incorrect.
					// In particular, this code treats field.Align as shared between the array and its elements.
					// This is certainly not correct, but fixing it to store separate would require changing the code in a bunch of places.
					// Also, alignment is not important for the current use case. I just included it to lay the groundwork for future use.

					TypeTreeNodeStruct sizeNode = new("int", "size", 1, TransferMetaFlags.NoTransferFlags, []);
					TypeTreeNodeStruct dataNode = FromSerializableType(field.Type, "data", field.Align, out anyChildUsesAlignBytes);
					anyChildUsesAlignBytes |= field.Align;

					TransferMetaFlags metaFlag = TransferMetaFlags.NoTransferFlags;
					if (field.Align)
					{
						metaFlag |= TransferMetaFlags.AlignBytes;
					}
					if (anyChildUsesAlignBytes)
					{
						metaFlag |= TransferMetaFlags.AnyChildUsesAlignBytes;
					}

					return new("Array", field.Name, 0, metaFlag, [sizeNode, dataNode]);
				}
			case 2:
				throw new NotImplementedException("Array depth 2 is not implemented.");
			default:
				throw new NotSupportedException($"Array depth {field.ArrayDepth} is not supported.");
		}
	}

	public IEnumerator<TypeTreeNodeStruct> GetEnumerator() => SubNodes.GetEnumerator();

	IEnumerator IEnumerable.GetEnumerator() => SubNodes.GetEnumerator();

	public override bool Equals(object? obj)
	{
		return obj is TypeTreeNodeStruct @struct && Equals(@struct);
	}

	public bool Equals(TypeTreeNodeStruct other)
	{
		if (TypeName != other.TypeName || Name != other.Name || Version != other.Version || MetaFlag != other.MetaFlag)
		{
			return false;
		}

		if (ReferenceEquals(SubNodes, other.SubNodes))
		{
			return true;
		}

		if (SubNodes is null || other.SubNodes is null || SubNodes.Count != other.SubNodes.Count)
		{
			return false;
		}

		for (int i = 0; i < SubNodes.Count; i++)
		{
			if (!SubNodes[i].Equals(other.SubNodes[i]))
			{
				return false;
			}
		}

		return true;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(TypeName, Name, Version, MetaFlag, SubNodes.Count);
	}

	public static bool operator ==(TypeTreeNodeStruct left, TypeTreeNodeStruct right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(TypeTreeNodeStruct left, TypeTreeNodeStruct right)
	{
		return !(left == right);
	}

	private static TpkUnityClass GetItemForVersion(List<KeyValuePair<UnityVersion, TpkUnityClass?>> list, UnityVersion version)
	{
		if (list.Count == 0)
		{
			throw new ArgumentException("List is empty.", nameof(list));
		}

		if (list[0].Key > version)
		{
			return list[0].Value ?? throw new ArgumentException("First element should never be null.", nameof(list));
		}

		for (int i = 0; i < list.Count - 1; i++)
		{
			if (list[i].Key <= version && version < list[i + 1].Key)
			{
				TpkUnityClass? result = list[i].Value;
				if (result is not null)
				{
					return result;
				}
				else
				{
					return list[i - 1].Value ?? throw new ArgumentException("Consecutive elements should never both be null.", nameof(list));
				}
			}
		}

		if (list[^1].Value is null)
		{
			return list[^2].Value ?? throw new ArgumentException("Second to last element should never be null when the last element is null.", nameof(list));
		}
		else
		{
			return list[^1].Value!;
		}
	}
}

```

`Source/AssetRipper.Import/Structure/GameInitializer.CustomResourceProvider.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Platforms;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.ResourceFiles;

namespace AssetRipper.Import.Structure;

internal sealed partial record class GameInitializer
{
	private sealed record class CustomResourceProvider(
		PlatformGameStructure? PlatformStructure,
		PlatformGameStructure? MixedStructure,
		FileSystem FileSystem)
		: IResourceProvider
	{
		public ResourceFile? FindResource(string resName)
		{
			string fixedName = SpecialFileNames.FixResourcePath(resName);
			string? resPath = RequestResource(fixedName);
			if (resPath is null)
			{
				Logger.Log(LogType.Warning, LogCategory.Import, $"Resource file '{resName}' hasn't been found");
				return null;
			}

			ResourceFile resourceFile = new ResourceFile(resPath, fixedName, FileSystem);
			Logger.Info(LogCategory.Import, $"Resource file '{resName}' has been loaded");
			return resourceFile;
		}

		private string? RequestResource(string resource)
		{
			return PlatformStructure?.RequestResource(resource) ?? MixedStructure?.RequestResource(resource);
		}
	}
}

```

`Source/AssetRipper.Import/Structure/GameInitializer.EngineResourceInjector.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.Mining.PredefinedAssets;
using AssetRipper.SourceGenerated;
using AssetRipper.Tpk;
using AssetRipper.Tpk.EngineAssets;
using Object = AssetRipper.Mining.PredefinedAssets.Object;

namespace AssetRipper.Import.Structure;

internal sealed partial record class GameInitializer
{
	private static class EngineResourceInjector
	{
		private sealed class InjectedEngineCollection : VirtualAssetCollection
		{
			public InjectedEngineCollection(string name, UnityVersion version, InjectedEngineBundle bundle) : base(bundle)
			{
				Name = name;
				Version = version;
				OriginalVersion = version;
				Platform = BuildTarget.NoTarget;
				Flags = TransferInstructionFlags.SerializeGameRelease | TransferInstructionFlags.IsBuiltinResourcesFile;
			}

			public void AddAssets(Dictionary<long, Object> assets)
			{
				foreach ((long pathID, Object @object) in assets)
				{
					IUnityObjectBase asset = AssetFactory.Create(new AssetInfo(this, pathID, @object.TypeID));
					if (asset is INamed named && @object is NamedObject namedObject)
					{
						named.Name = namedObject.Name;
					}
					AddAsset(asset);
				}
			}
		}

		private sealed class InjectedEngineBundle : VirtualBundle<InjectedEngineCollection>
		{
			public override string Name => "Generated Engine Collections";
		}

		public static void InjectEngineFilesIfNecessary(GameBundle gameBundle, UnityVersion targetVersion)
		{
			bool injectDefaultResources = gameBundle.ResolveCollection(SpecialFileNames.DefaultResourceName1) is null;
			bool injectExtraResources = gameBundle.ResolveCollection(SpecialFileNames.BuiltinExtraName2) is null;
			if (!injectDefaultResources && !injectExtraResources)
			{
				return;
			}

			if (targetVersion == default)
			{
				targetVersion = gameBundle.GetMaxUnityVersion();
			}

			InjectedEngineBundle bundle = new();
			gameBundle.AddBundle(bundle);

			EngineResourceData data = GetData(targetVersion);
			if (injectDefaultResources)
			{
				InjectedEngineCollection collection = new(SpecialFileNames.DefaultResourceName1, targetVersion, bundle);
				collection.AddAssets(data.DefaultResources);
			}
			if (injectExtraResources)
			{
				InjectedEngineCollection collection = new(SpecialFileNames.BuiltinExtraName2, targetVersion, bundle);
				collection.AddAssets(data.ExtraResources);
			}
		}

		private static EngineResourceData GetData(UnityVersion version)
		{
			TpkFile tpk = TpkFile.FromStream(EngineAssetsTpk.GetStream());
			TpkEngineAssetsBlob blob = (TpkEngineAssetsBlob)tpk.GetDataBlob();
			if (blob.Data.Count == 0)
			{
				return new EngineResourceData();
			}

			int index;
			if (version <= blob.Data[0].Key)
			{
				index = 0;
			}
			else
			{
				index = blob.Data.Count - 1;
				for (int i = 1; i < blob.Data.Count; i++)
				{
					if (version <= blob.Data[i].Key)
					{
						index = i - 1;
						break;
					}
				}
			}

			string json = blob.Data[index].Value;
			return EngineResourceData.FromJson(json);
		}
	}
}

```

`Source/AssetRipper.Import/Structure/GameInitializer.StructureDependencyProvider.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Platforms;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.Import.Structure;

internal sealed partial record class GameInitializer
{
	private sealed record class StructureDependencyProvider(
		PlatformGameStructure? PlatformStructure,
		PlatformGameStructure? MixedStructure,
		FileSystem FileSystem)
		: IDependencyProvider
	{
		public FileBase? FindDependency(FileIdentifier identifier)
		{
			string? systemFilePath = RequestDependency(identifier.PathName);
			return systemFilePath is null ? null : SchemeReader.LoadFile(systemFilePath, FileSystem);
		}

		/// <summary>
		/// Attempts to find the path for the dependency with that name.
		/// </summary>
		private string? RequestDependency(string dependency)
		{
			return PlatformStructure?.RequestDependency(dependency) ?? MixedStructure?.RequestDependency(dependency);
		}

		public void ReportMissingDependency(FileIdentifier identifier)
		{
			Logger.Log(LogType.Warning, LogCategory.Import, $"Dependency '{identifier}' wasn't found");
		}
	}
}

```

`Source/AssetRipper.Import/Structure/GameInitializer.VersionChanger.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Generics;
using AssetRipper.Import.Structure.Assembly.Serializable;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_0;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Subclasses.ComponentPair;
using System.Runtime.CompilerServices;

namespace AssetRipper.Import.Structure;

internal sealed partial record class GameInitializer
{
	private static class VersionChanger
	{
		public static void ChangeVersions(IEnumerable<AssetCollection> collections, UnityVersion targetVersion)
		{
			List<IUnityObjectBase> list = new();

			foreach (AssetCollection collection in collections)
			{
				if (collection.Version == targetVersion)
				{
					continue;
				}

				list.Clear();
				list.EnsureCapacity(collection.Count);
				list.AddRange(collection);
				foreach (IUnityObjectBase original in list)
				{
					if (original is not IObject)
					{
						continue;
					}

					IUnityObjectBase replacement = AssetFactory.Create(original.AssetInfo, targetVersion);
					if (original.GetType() == replacement.GetType())
					{
						continue;
					}

					replacement.CopyValues(original);
					HandleDifferingFields(original, replacement);
					collection.ReplaceAsset(replacement);
				}

				Version(collection) = targetVersion;
			}
		}

		private static void HandleDifferingFields(IUnityObjectBase original, IUnityObjectBase replacement)
		{
			if (original is IRenderer renderer)
			{
				IRenderer newRenderer = (IRenderer)replacement;
				if (renderer.Has_StaticBatchInfo_C25())
				{
					if (newRenderer.Has_SubsetIndices_C25())
					{
						AssetList<uint> list = newRenderer.SubsetIndices_C25;
						list.AddRange(Enumerable.Range(renderer.StaticBatchInfo_C25.FirstSubMesh, renderer.StaticBatchInfo_C25.SubMeshCount).Select(i => (uint)i));
					}
				}
				else
				{
					if (newRenderer.Has_StaticBatchInfo_C25())
					{
						AssetList<uint> list = renderer.SubsetIndices_C25;
						unchecked
						{
							if (list.Count is > 0 and <= ushort.MaxValue && list[0] <= ushort.MaxValue)
							{
								bool compatible = true;
								for (int i = 0; i < list.Count - 1; i++)
								{
									if (list[i] + 1 != list[i + 1])
									{
										compatible = false;
										break;
									}
								}
								if (compatible)
								{
									newRenderer.StaticBatchInfo_C25.FirstSubMesh = (ushort)list[0];
									newRenderer.StaticBatchInfo_C25.SubMeshCount = (ushort)list.Count;
								}
							}
						}
					}
				}
			}
			else if (original is IMonoBehaviour monoBehaviour)
			{
				IMonoBehaviour newMonoBehaviour = (IMonoBehaviour)replacement;
				if (monoBehaviour.Structure is UnloadedStructure unloadedStructure)
				{
					newMonoBehaviour.Structure = new UnloadedStructure(newMonoBehaviour, unloadedStructure.AssemblyManager, unloadedStructure.StructureData);
				}
				else
				{
					newMonoBehaviour.Structure = monoBehaviour.Structure;
				}
			}
			else if (original is IGameObject gameObject)
			{
				IGameObject newGameObject = (IGameObject)replacement;
				PPtrConverter converter = new(gameObject, newGameObject);
				if (newGameObject.Components.Count > 0 && newGameObject.Components[0].Has_ClassID() && !gameObject.Components[0].Has_ClassID())
				{
					foreach (IComponentPair pair in newGameObject.Components)
					{
						if (pair.Component.TryGetAsset(newGameObject.Collection, out IComponent? component))
						{
							pair.ClassID = component.ClassID;
						}
						else
						{
							pair.ClassID = (int)ClassIDType.Component;
						}
					}
				}
			}
			else if (original is ITexture2D texture)
			{
				ITexture2D newTexture = (ITexture2D)replacement;
				if (newTexture.TextureSettings_C28.Has_WrapU() && texture.TextureSettings_C28.Has_WrapMode())
				{
					newTexture.TextureSettings_C28.WrapU = texture.TextureSettings_C28.WrapMode;
				}
				else if (newTexture.TextureSettings_C28.Has_WrapMode() && texture.TextureSettings_C28.Has_WrapU())
				{
					newTexture.TextureSettings_C28.WrapMode = texture.TextureSettings_C28.WrapU;
				}

				if (newTexture.Has_CompleteImageSize_C28_UInt32() && texture.Has_CompleteImageSize_C28_Int32() && texture.CompleteImageSize_C28_Int32 > 0)
				{
					newTexture.CompleteImageSize_C28_UInt32 = (uint)texture.CompleteImageSize_C28_Int32;
				}
				else if (newTexture.Has_CompleteImageSize_C28_Int32() && texture.Has_CompleteImageSize_C28_UInt32() && texture.CompleteImageSize_C28_UInt32 < int.MaxValue)
				{
					newTexture.CompleteImageSize_C28_Int32 = (int)texture.CompleteImageSize_C28_UInt32;
				}

				if (newTexture.Has_MipMap_C28() && texture.Has_MipCount_C28())
				{
					newTexture.MipMap_C28 = texture.MipCount_C28 > 1;
				}
				else if (newTexture.Has_MipCount_C28() && texture.Has_MipMap_C28())
				{
					if (texture.MipMap_C28)
					{
						// Calculate mip count from max dimension
						int size = int.Max(texture.Width_C28, texture.Height_C28);
						int mipCount = 1;
						while (size > 1)
						{
							mipCount++;
							size >>= 1;
						}
						newTexture.MipCount_C28 = mipCount;
					}
					else
					{
						newTexture.MipCount_C28 = 1;
					}
				}
			}
		}

		// We use an unsafe accessor to avoid the need for public access to the property backing field.
		[UnsafeAccessor(UnsafeAccessorKind.Field, Name = $"<{nameof(AssetCollection.Version)}>k__BackingField")]
		private static extern ref UnityVersion Version(AssetCollection collection);
	}
}

```

`Source/AssetRipper.Import/Structure/GameInitializer.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.IO;
using AssetRipper.Import.Structure.Platforms;
using AssetRipper.IO.Files;

namespace AssetRipper.Import.Structure;

internal sealed partial record class GameInitializer : DefaultGameInitializer
{
	public UnityVersion TargetVersion { get; }

	public GameInitializer(PlatformGameStructure? platformStructure, PlatformGameStructure? mixedStructure, FileSystem fileSystem, UnityVersion defaultVersion, UnityVersion targetVersion)
		: base(new StructureDependencyProvider(platformStructure, mixedStructure, fileSystem), new CustomResourceProvider(platformStructure, mixedStructure, fileSystem), defaultVersion)
	{
		TargetVersion = targetVersion;
	}

	public override void OnPathsLoaded(GameBundle gameBundle, AssetFactoryBase assetFactory)
	{
		EngineResourceInjector.InjectEngineFilesIfNecessary(gameBundle, TargetVersion);
	}

	public override void OnDependenciesInitialized(GameBundle gameBundle, AssetFactoryBase assetFactory)
	{
		if (TargetVersion != default)
		{
			VersionChanger.ChangeVersions(gameBundle.FetchAssetCollections(), TargetVersion);
		}
	}
}

```

`Source/AssetRipper.Import/Structure/GameStructure.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Import.AssetCreation;
using AssetRipper.Import.Configuration;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.Import.Structure.Platforms;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.ResourceFiles;

namespace AssetRipper.Import.Structure;

public sealed class GameStructure : IDisposable
{
	public GameBundle FileCollection { get; private set; }
	public PlatformGameStructure? PlatformStructure { get; private set; }
	public PlatformGameStructure? MixedStructure { get; private set; }
	public IAssemblyManager AssemblyManager { get; set; }
	public FileSystem FileSystem { get; }

	private GameStructure(List<string> paths, FileSystem fileSystem, CoreConfiguration configuration)
	{
		Logger.SendStatusChange("loading_step_detect_platform");
		FileSystem = fileSystem;
		PlatformChecker.CheckPlatform(paths, fileSystem, out PlatformGameStructure? platformStructure, out MixedGameStructure? mixedStructure);
		PlatformStructure = platformStructure;
		PlatformStructure?.CollectFiles(configuration.ImportSettings.IgnoreStreamingAssets);
		MixedStructure = mixedStructure;
		//MixedStructure?.CollectFiles(configuration.IgnoreStreamingAssets);
		//The PlatformGameStructure constructor adds all the paths to the Assemblies and Files dictionaries
		//No bundles or assemblies have been loaded yet

		Logger.SendStatusChange("loading_step_initialize_layout");

		InitializeAssemblyManager(configuration);

		Logger.SendStatusChange("loading_step_begin_scheme_processing");

		InitializeGameCollection(configuration.ImportSettings.DefaultVersion, configuration.ImportSettings.TargetVersion);

		if (!FileCollection.HasAnyAssetCollections())
		{
			Logger.Log(LogType.Warning, LogCategory.Import, "The game structure processor could not find any valid assets.");
		}
	}

	public bool IsValid => FileCollection.HasAnyAssetCollections();

	public string? Name => PlatformStructure?.Name ?? MixedStructure?.Name;

	public static GameStructure Load(IEnumerable<string> paths, FileSystem fileSystem, CoreConfiguration configuration)
	{
		List<string> toProcess = ZipExtractor.Process(paths, fileSystem);
		if (toProcess.Count == 0)
		{
			throw new ArgumentException("Game files not found", nameof(paths));
		}

		return new GameStructure(toProcess, fileSystem, configuration);
	}

	[MemberNotNull(nameof(FileCollection))]
	private void InitializeGameCollection(UnityVersion defaultVersion, UnityVersion targetVersion)
	{
		Logger.SendStatusChange("loading_step_create_file_collection");

		GameAssetFactory assetFactory = new GameAssetFactory(AssemblyManager);

		IEnumerable<string> filePaths;
		if (PlatformStructure is null || MixedStructure is null)
		{
			filePaths = (PlatformStructure ?? MixedStructure)?.Files.Values() ?? [];
		}
		else
		{
			filePaths = PlatformStructure.Files.Union(MixedStructure.Files).Select(pair => pair.Value);
		}

		FileCollection = GameBundle.FromPaths(
			filePaths,
			assetFactory,
			FileSystem,
			new GameInitializer(PlatformStructure, MixedStructure, FileSystem, defaultVersion, targetVersion));
	}

	[MemberNotNull(nameof(AssemblyManager))]
	private void InitializeAssemblyManager(CoreConfiguration configuration)
	{
		ScriptingBackend scriptBackend = GetScriptingBackend(configuration.DisableScriptImport);
		Logger.Info(LogCategory.Import, $"Files use the '{scriptBackend}' scripting backend.");

		AssemblyManager = scriptBackend switch
		{
			ScriptingBackend.Mono => new MonoManager(OnRequestAssembly),
			ScriptingBackend.IL2Cpp => new IL2CppManager(OnRequestAssembly, configuration.ImportSettings.ScriptContentLevel),
			_ => new BaseManager(OnRequestAssembly),
		};

		Logger.SendStatusChange("loading_step_load_assemblies");

		try
		{
			//Loads any Mono or IL2Cpp assemblies
			AssemblyManager.Initialize(PlatformStructure ?? MixedStructure ?? throw new Exception("No platform structure"));
		}
		catch (Exception ex)
		{
			Logger.Error(LogCategory.Import, "Could not initialize assembly manager. Switching to the 'Unknown' scripting backend.");
			Logger.Error(ex);
			AssemblyManager = new BaseManager(OnRequestAssembly);
		}
	}

	private ScriptingBackend GetScriptingBackend(bool disableScriptImport)
	{
		if (disableScriptImport)
		{
			Logger.Info(LogCategory.Import, "Script import disabled by settings.");
			return ScriptingBackend.Unknown;
		}
		if (PlatformStructure != null)
		{
			ScriptingBackend backend = PlatformStructure.Backend;
			if (backend != ScriptingBackend.Unknown)
			{
				return backend;
			}
		}
		if (MixedStructure != null)
		{
			ScriptingBackend backend = MixedStructure.Backend;
			if (backend != ScriptingBackend.Unknown)
			{
				return backend;
			}
		}
		return ScriptingBackend.Unknown;
	}

	private void OnRequestAssembly(string assembly)
	{
		string assemblyName = $"{assembly}.dll";
		ResourceFile? resFile = FileCollection.ResolveResource(assemblyName);
		if (resFile is not null)
		{
			resFile.Stream.Position = 0;
			AssemblyManager.Read(resFile.Stream.CreateReference(), assemblyName);
		}
		else
		{
			string? path = RequestAssembly(assembly);
			if (path is null)
			{
				Logger.Log(LogType.Warning, LogCategory.Import, $"Assembly '{assembly}' hasn't been found");
				return;
			}
			AssemblyManager.Load(path, FileSystem);
		}
		Logger.Info(LogCategory.Import, $"Assembly '{assembly}' has been loaded");
	}

	public string? RequestAssembly(string assembly)
	{
		return PlatformStructure?.RequestAssembly(assembly) ?? MixedStructure?.RequestAssembly(assembly);
	}

	public void Dispose()
	{
		Dispose(true);
		GC.SuppressFinalize(this);
	}

	private void Dispose(bool _)
	{
		AssemblyManager?.Dispose();
		FileCollection?.Dispose();
	}
}

```

`Source/AssetRipper.Import/Structure/KeyValuePairListExtensions.cs`:

```cs
namespace AssetRipper.Import.Structure;

internal static class KeyValuePairListExtensions
{
	public static IEnumerable<TValue> Values<TKey, TValue>(this List<KeyValuePair<TKey, TValue>> list)
	{
		foreach (KeyValuePair<TKey, TValue> pair in list)
		{
			yield return pair.Value;
		}
	}

	public static void Add<TKey, TValue>(this List<KeyValuePair<TKey, TValue>> list, TKey key, TValue value)
	{
		list.Add(new KeyValuePair<TKey, TValue>(key, value));
	}
}

```

`Source/AssetRipper.Import/Structure/Platforms/AndroidGameStructure.cs`:

```cs
using AssetRipper.IO.Files;

namespace AssetRipper.Import.Structure.Platforms;

internal sealed class AndroidGameStructure : PlatformGameStructure
{
	public AndroidGameStructure(string rootPath, FileSystem fileSystem) : this(rootPath, string.Empty, fileSystem)
	{
	}

	public AndroidGameStructure(string rootPath, string? obbPath, FileSystem fileSystem) : base(rootPath, fileSystem)
	{
		string apkDataPath = FileSystem.Path.Join(rootPath, AssetName, BinName, DataFolderName);
		if (!FileSystem.Directory.Exists(apkDataPath))
		{
			throw new Exception($"Data directory hasn't been found");
		}
		List<string> dataPaths = [apkDataPath];

		GameDataPath = apkDataPath;
		StreamingAssetsPath = null;
		ResourcesPath = FileSystem.Path.Join(GameDataPath, ResourcesName);
		ManagedPath = FileSystem.Path.Join(GameDataPath, ManagedName);
		LibPath = FileSystem.Path.Join(RootPath, LibName);
		Il2CppGameAssemblyPath = GetIl2CppGameAssemblyPath(LibPath);
		Il2CppMetaDataPath = FileSystem.Path.Join(ManagedPath, MetadataName, DefaultGlobalMetadataName);
		UnityPlayerPath = null;
		Version = GetUnityVersionFromDataDirectory(GameDataPath);

		if (HasIl2CppFiles())
		{
			Backend = Assembly.ScriptingBackend.IL2Cpp;
		}
		else if (IsMono(ManagedPath))
		{
			Backend = Assembly.ScriptingBackend.Mono;
		}
		else
		{
			Backend = Assembly.ScriptingBackend.Unknown;
		}

		if (obbPath != null)
		{
			m_obbRoot = obbPath;
			if (!FileSystem.Directory.Exists(obbPath))
			{
				throw new Exception($"Obb directory '{obbPath}' doesn't exist");
			}

			string obbDataPath = FileSystem.Path.Join(obbPath, AssetName, BinName, DataFolderName);
			if (!FileSystem.Directory.Exists(obbDataPath))
			{
				throw new Exception($"Obb data directory '{obbDataPath}' wasn't found");
			}
			dataPaths.Add(obbDataPath);
		}
		DataPaths = dataPaths.ToArray();
	}

	public override void CollectFiles(bool skipStreamingAssets)
	{
		base.CollectFiles(skipStreamingAssets);
		CollectApkAssetBundles(Files);
	}

	public static bool IsAndroidStructure(string path, FileSystem fileSystem)
	{
		if (!fileSystem.Directory.Exists(path))
		{
			return false;
		}

		int match = GetRootAndroidDirectoryMatch(path, fileSystem);
		if (match <= 8)
		{
			return false;
		}

		string dataPath = fileSystem.Path.Join(path, AssetName, BinName, DataFolderName);

		return fileSystem.Directory.Exists(dataPath);
	}

	public static bool IsAndroidObbStructure(string path, FileSystem fileSystem)
	{
		if (!fileSystem.Directory.Exists(path))
		{
			return false;
		}

		int match = GetRootAndroidDirectoryMatch(path, fileSystem);
		if (match != 8)
		{
			return false;
		}

		string dataPath = fileSystem.Path.Join(path, AssetName, BinName, DataFolderName);

		return fileSystem.Directory.Exists(dataPath);
	}

	private static int GetRootAndroidDirectoryMatch(string directory, FileSystem fileSystem)
	{
		int matches = 0;
		foreach (string subDirectory in fileSystem.Directory.EnumerateDirectories(directory))
		{
			switch (fileSystem.Path.GetFileName(subDirectory))
			{
				case AssetName:
					matches |= 8;
					break;

				case MetaName:
					matches |= 4;
					break;

				case LibName:
					matches |= 2;
					break;
			}
		}
		return matches;
	}

	private void CollectApkAssetBundles(List<KeyValuePair<string, string>> files)
	{
		string assetPath = FileSystem.Path.Join(RootPath, AssetName);

		CollectAssetBundles(assetPath, files);
		foreach (string subDirectory in FileSystem.Directory.EnumerateDirectories(assetPath))
		{
			if (FileSystem.Path.GetFileName(subDirectory) == BinName)
			{
				continue;
			}
			CollectAssetBundlesRecursively(subDirectory, files);
		}
	}

	private string? GetIl2CppGameAssemblyPath(string libDirectory)
	{
		if (string.IsNullOrEmpty(libDirectory) || !FileSystem.Directory.Exists(libDirectory))
		{
			return null;
		}

		return FileSystem.Directory.EnumerateFiles(libDirectory, Il2CppGameAssemblyName, SearchOption.AllDirectories).FirstOrDefault();
	}

	private string? GetAndroidUnityAssemblyPath(string libDirectory)
	{
		if (string.IsNullOrEmpty(libDirectory) || !FileSystem.Directory.Exists(libDirectory))
		{
			return null;
		}

		return FileSystem.Directory.EnumerateFiles(libDirectory, AndroidUnityAssemblyName, SearchOption.AllDirectories).FirstOrDefault();
	}

	private bool IsMono(string managedDirectory)
	{
		if (string.IsNullOrEmpty(managedDirectory) || !FileSystem.Directory.Exists(managedDirectory))
		{
			return false;
		}

		return FileSystem.Directory.EnumerateFiles(managedDirectory, "*.dll").Any();
	}

	public string LibPath { get; private set; }

	private const string AssetName = "assets";
	private const string MetaName = "META-INF";
	private const string BinName = "bin";
	private const string Il2CppGameAssemblyName = "libil2cpp.so";
	private const string AndroidUnityAssemblyName = "libunity.so";

	private readonly string? m_obbRoot;
}

```

`Source/AssetRipper.Import/Structure/Platforms/LinuxGameStructure.cs`:

```cs
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.IO.Files;
using System.Diagnostics;

namespace AssetRipper.Import.Structure.Platforms;

internal sealed class LinuxGameStructure : PlatformGameStructure
{
	public LinuxGameStructure(string rootPath, FileSystem fileSystem) : base(GetActualRootPath(rootPath, fileSystem), fileSystem)
	{
		Debug.Assert(RootPath is not null);
		if (rootPath != RootPath)
		{
			Logger.Info(LogCategory.Import, "An executable file or data directory was found, so the parent directory is being used instead.");
		}

		if (!GetDataDirectory(RootPath, FileSystem, out string? dataPath, out string? name))
		{
			throw new DirectoryNotFoundException($"Data directory wasn't found");
		}

		Name = name;
		GameDataPath = dataPath;
		StreamingAssetsPath = FileSystem.Path.Join(GameDataPath, StreamingName);
		ResourcesPath = FileSystem.Path.Join(GameDataPath, ResourcesName);
		ManagedPath = FileSystem.Path.Join(GameDataPath, ManagedName);
		UnityPlayerPath = FileSystem.Path.Join(RootPath, DefaultUnityPlayerName);
		Version = null;
		Il2CppGameAssemblyPath = FileSystem.Path.Join(RootPath, DefaultGameAssemblyName);
		Il2CppMetaDataPath = FileSystem.Path.Join(GameDataPath, "il2cpp_data", MetadataName, DefaultGlobalMetadataName);

		if (HasIl2CppFiles())
		{
			Backend = ScriptingBackend.IL2Cpp;
		}
		else if (HasMonoAssemblies(ManagedPath))
		{
			Backend = ScriptingBackend.Mono;
		}
		else
		{
			Backend = ScriptingBackend.Unknown;
		}

		DataPaths = [GameDataPath];
	}

	public static bool Exists(string path, FileSystem fileSystem)
	{
		string directory;
		if (IsExecutableFile(path, fileSystem))
		{
			directory = fileSystem.Path.GetDirectoryName(path) ?? throw new Exception("Could not get file directory");
		}
		else if (IsUnityDataDirectory(path, fileSystem))
		{
			return true;
		}
		else
		{
			directory = path;
		}

		return fileSystem.Directory.Exists(directory) && IsRootDirectory(directory, fileSystem);
	}

	private static bool IsUnityDataDirectory(string folderPath, FileSystem fileSystem)
	{
		const string Suffix = $"_{DataFolderName}";
		if (string.IsNullOrEmpty(folderPath) || !folderPath.EndsWith(Suffix, StringComparison.Ordinal))
		{
			return false;
		}

		if (!fileSystem.Directory.Exists(folderPath))
		{
			return false;
		}

		string folderName = fileSystem.Path.GetFileName(folderPath);
		string gameName = folderName[..^Suffix.Length];
		string rootPath = fileSystem.Path.GetDirectoryName(folderPath);
		string x86Path = fileSystem.Path.Join(rootPath, gameName + x86Extension);
		string x64Path = fileSystem.Path.Join(rootPath, gameName + x64Extension);
		string x86_64Path = fileSystem.Path.Join(rootPath, gameName + x86_64Extension);
		if (fileSystem.File.Exists(x86Path) || fileSystem.File.Exists(x64Path) || fileSystem.File.Exists(x86_64Path))
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	private static bool IsExecutableFile(string filePath, FileSystem fileSystem)
	{
		return !string.IsNullOrEmpty(filePath)
			&& (filePath.EndsWith(x86Extension, StringComparison.Ordinal) || filePath.EndsWith(x64Extension, StringComparison.Ordinal) || filePath.EndsWith(x86_64Extension, StringComparison.Ordinal))
			&& fileSystem.File.Exists(filePath);
	}

	private static string GetActualRootPath(string rootPath, FileSystem fileSystem)
	{
		ArgumentException.ThrowIfNullOrEmpty(rootPath);
		if (IsExecutableFile(rootPath, fileSystem))
		{
			return fileSystem.Path.GetDirectoryName(rootPath) ?? throw new Exception("Could not get file directory");
		}
		else if (IsUnityDataDirectory(rootPath, fileSystem))
		{
			return fileSystem.Path.GetDirectoryName(rootPath) ?? throw new Exception("Could not get parent directory");
		}
		else
		{
			return rootPath;
		}
	}

	private static bool IsRootDirectory(string rootDiectory, FileSystem fileSystem)
	{
		return GetDataDirectory(rootDiectory, fileSystem, out _, out _);
	}

	private static bool GetDataDirectory(string rootDiectory, FileSystem fileSystem, [NotNullWhen(true)] out string? dataPath, [NotNullWhen(true)] out string? name)
	{
		foreach (string file in fileSystem.Directory.EnumerateFiles(rootDiectory))
		{
			string extension = fileSystem.Path.GetExtension(file);
			if (extension is x86Extension or x64Extension or x86_64Extension)
			{
				name = fileSystem.Path.GetFileNameWithoutExtension(file);
				string dataFolder = $"{name}_{DataFolderName}";
				dataPath = fileSystem.Path.Join(rootDiectory, dataFolder);
				if (fileSystem.Directory.Exists(dataPath))
				{
					return true;
				}
			}
		}

		name = null;
		dataPath = null;
		return false;
	}


	private const string x86Extension = ".x86";
	private const string x64Extension = ".x64";
	private const string x86_64Extension = ".x86_64";
}

```

`Source/AssetRipper.Import/Structure/Platforms/MacGameStructure.cs`:

```cs
using AssetRipper.IO.Files;
using System.Diagnostics;

namespace AssetRipper.Import.Structure.Platforms;

internal sealed class MacGameStructure : PlatformGameStructure
{
	public MacGameStructure(string rootPath, FileSystem fileSystem) : base(rootPath, fileSystem)
	{
		string resourcePath = FileSystem.Path.Join(rootPath, ContentsName, ResourcesName);
		if (!FileSystem.Directory.Exists(resourcePath))
		{
			throw new DirectoryNotFoundException("Resources directory wasn't found");
		}
		string dataPath = FileSystem.Path.Join(resourcePath, DataFolderName);
		if (!FileSystem.Directory.Exists(dataPath))
		{
			throw new DirectoryNotFoundException("Data directory wasn't found");
		}
		DataPaths = [dataPath, resourcePath];

		Debug.Assert(rootPath.EndsWith(AppExtension, StringComparison.Ordinal));
		Name = FileSystem.Path.GetFileNameWithoutExtension(rootPath);
		GameDataPath = dataPath;
		StreamingAssetsPath = FileSystem.Path.Join(GameDataPath, StreamingName);
		ResourcesPath = FileSystem.Path.Join(GameDataPath, ResourcesName);
		ManagedPath = FileSystem.Path.Join(GameDataPath, ManagedName);
		UnityPlayerPath = FileSystem.Path.Join(RootPath, ContentsName, FrameworksName, MacUnityPlayerName);
		Version = null;

		Il2CppGameAssemblyPath = FileSystem.Path.Join(RootPath, ContentsName, FrameworksName, "GameAssembly.dylib");
		Il2CppMetaDataPath = FileSystem.Path.Join(GameDataPath, "il2cpp_data", MetadataName, DefaultGlobalMetadataName);

		if (HasIl2CppFiles())
		{
			Backend = Assembly.ScriptingBackend.IL2Cpp;
		}
		else if (HasMonoAssemblies(ManagedPath))
		{
			Backend = Assembly.ScriptingBackend.Mono;
		}
		else
		{
			Backend = Assembly.ScriptingBackend.Unknown;
		}
	}

	public static bool Exists(string path, FileSystem fileSystem)
	{
		if (!fileSystem.Directory.Exists(path))
		{
			return false;
		}
		if (fileSystem.Path.GetExtension(path) != AppExtension)
		{
			return false;
		}

		string dataPath = fileSystem.Path.Join(path, ContentsName, ResourcesName, DataFolderName);
		if (!fileSystem.Directory.Exists(dataPath))
		{
			return false;
		}
		string resourcePath = fileSystem.Path.Join(path, ContentsName, ResourcesName);
		if (!fileSystem.Directory.Exists(resourcePath))
		{
			return false;
		}
		return true;
	}


	private const string ContentsName = "Contents";
	private const string FrameworksName = "Frameworks";
	private const string MacUnityPlayerName = "UnityPlayer.dylib";
	private const string AppExtension = ".app";
}

```

`Source/AssetRipper.Import/Structure/Platforms/MixedGameStructure.cs`:

```cs
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.Streams;

namespace AssetRipper.Import.Structure.Platforms;

public sealed class MixedGameStructure : PlatformGameStructure
{
	public MixedGameStructure(IEnumerable<string> paths, FileSystem fileSystem) : base(fileSystem)
	{
		HashSet<string> dataPaths = [];
		foreach (string path in SelectUniquePaths(paths))
		{
			if (MultiFileStream.Exists(path, FileSystem))
			{
				string name = MultiFileStream.GetFileName(path);
				AddFile(Files, name, path);
				string directory = FileSystem.Path.GetDirectoryName(path) ?? throw new Exception("Could not get directory name");
				dataPaths.Add(directory);
			}
			else if (FileSystem.Directory.Exists(path))
			{
				CollectFromDirectory(path, Files, Assemblies, dataPaths);
			}
			else
			{
				throw new Exception($"Neither file nor directory at '{path}' exists");
			}
		}

		DataPaths = dataPaths.ToArray();
		Name = Files.Count == 0 ? string.Empty : Files.First().Key;
		GameDataPath = null;
		ManagedPath = null;
		UnityPlayerPath = null;
		Version = null;
		Il2CppGameAssemblyPath = null;
		Il2CppMetaDataPath = null;
		Backend = Assemblies.Count > 0 ? ScriptingBackend.Mono : ScriptingBackend.Unknown;
	}

	private static IEnumerable<string> SelectUniquePaths(IEnumerable<string> paths)
	{
		return paths.Select(t => MultiFileStream.GetFilePath(t)).Distinct();
	}

	private void CollectFromDirectory(string root, List<KeyValuePair<string, string>> files, Dictionary<string, string> assemblies, ISet<string> dataPaths)
	{
		int count = files.Count;
		CollectSerializedGameFiles(root, files);
		CollectWebFiles(root, files);
		CollectAssetBundles(root, files);
		CollectAssembliesSafe(root, assemblies);
		if (files.Count != count)
		{
			dataPaths.Add(root);
		}

		foreach (string subDirectory in FileSystem.Directory.EnumerateDirectories(root))
		{
			CollectFromDirectory(subDirectory, files, assemblies, dataPaths);
		}
	}

	private void CollectWebFiles(string root, List<KeyValuePair<string, string>> files)
	{
		foreach (string levelFile in FileSystem.Directory.EnumerateFiles(root))
		{
			string extension = FileSystem.Path.GetExtension(levelFile);
			switch (extension)
			{
				case WebGLGameStructure.DataExtension:
				case WebGLGameStructure.DataGzExtension:
					{
						string name = FileSystem.Path.GetFileNameWithoutExtension(levelFile);
						AddFile(files, name, levelFile);
					}
					break;

				case WebGLGameStructure.UnityWebExtension:
					{
						string fileName = FileSystem.Path.GetFileName(levelFile);
						if (fileName.EndsWith(WebGLGameStructure.DataWebExtension, StringComparison.Ordinal))
						{
							string name = fileName.Substring(0, fileName.Length - WebGLGameStructure.DataWebExtension.Length);
							AddFile(files, name, levelFile);
						}
					}
					break;
			}
		}
	}

	private void CollectAssembliesSafe(string root, Dictionary<string, string> assemblies)
	{
		foreach (string file in FileSystem.Directory.EnumerateFiles(root))
		{
			string name = FileSystem.Path.GetFileName(file);
			if (MonoManager.IsMonoAssembly(name))
			{
				if (assemblies.TryGetValue(name, out string? value))
				{
					Logger.Log(LogType.Warning, LogCategory.Import, $"Duplicate assemblies found: '{value}' & '{file}'");
				}
				else
				{
					assemblies.Add(name, file);
				}
			}
		}
	}
}

```

`Source/AssetRipper.Import/Structure/Platforms/PS4GameStructure.cs`:

```cs
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.IO.Files;

namespace AssetRipper.Import.Structure.Platforms;

internal sealed class PS4GameStructure : PlatformGameStructure
{
	private const string PS4ExecutableName = "eboot.bin";
	private const string PS4DataFolderName = "Media";
	private const string ModulesName = "Modules";
	private const string PS4IL2CppGameAssemblyName = "Il2CppUserAssemblies.prx";

	private string ModulesPath { get; set; }

	public PS4GameStructure(string rootPath, FileSystem fileSystem) : base(rootPath, fileSystem)
	{
		if (!GetDataDirectory(rootPath, fileSystem, out string? dataPath))
		{
			throw new DirectoryNotFoundException($"Data directory wasn't found");
		}

		Name = FileSystem.Path.GetFileName(rootPath);
		GameDataPath = dataPath;
		ResourcesPath = FileSystem.Path.Join(GameDataPath, ResourcesName);
		ManagedPath = FileSystem.Path.Join(GameDataPath, ManagedName);
		ModulesPath = FileSystem.Path.Join(GameDataPath, ModulesName);
		UnityPlayerPath = null;
		string globalGameManagersPath = FileSystem.Path.Join(GameDataPath, GlobalGameManagersName);
		Version = GetUnityVersionFromDataDirectory(globalGameManagersPath);
		Il2CppGameAssemblyPath = FileSystem.Path.Join(ModulesPath, PS4IL2CppGameAssemblyName);
		Il2CppMetaDataPath = FileSystem.Path.Join(GameDataPath, MetadataName, DefaultGlobalMetadataName);

		if (HasIl2CppFiles())
		{
			Backend = ScriptingBackend.IL2Cpp;
		}
		else if (HasMonoAssemblies(ManagedPath))
		{
			Backend = ScriptingBackend.Mono;
		}
		else
		{
			Backend = ScriptingBackend.Unknown;
		}

		DataPaths = [GameDataPath];
	}

	public static bool Exists(string path, FileSystem fileSystem)
	{
		return fileSystem.Directory.Exists(path) && IsRootPS4Directory(path, fileSystem);
	}

	private static bool IsRootPS4Directory(string rootDirectory, FileSystem fileSystem)
	{
		return GetDataDirectory(rootDirectory, fileSystem, out _);
	}

	private static bool GetDataDirectory(string rootDirectory, FileSystem fileSystem, [NotNullWhen(true)] out string? dataPath)
	{
		foreach (string file in fileSystem.Directory.EnumerateFiles(rootDirectory))
		{
			if (fileSystem.Path.GetFileName(file) == PS4ExecutableName)
			{
				dataPath = fileSystem.Path.Join(rootDirectory, PS4DataFolderName);
				if (fileSystem.Directory.Exists(dataPath))
				{
					return true;
				}
			}
		}

		dataPath = null;
		return false;
	}
}

```

`Source/AssetRipper.Import/Structure/Platforms/PlatformChecker.cs`:

```cs
using AssetRipper.Import.Logging;
using AssetRipper.IO.Files;

namespace AssetRipper.Import.Structure.Platforms;

public static class PlatformChecker
{
	public static bool CheckPlatform(List<string> paths, FileSystem fileSystem, [NotNullWhen(true)] out PlatformGameStructure? platformStructure, [NotNullWhen(true)] out MixedGameStructure? mixedStructure)
	{
		platformStructure = null;
		mixedStructure = null;

		if (CheckWindows(paths, fileSystem, out WindowsGameStructure? pcGameStructure))
		{
			platformStructure = pcGameStructure;
		}
		else if (CheckLinux(paths, fileSystem, out LinuxGameStructure? linuxGameStructure))
		{
			platformStructure = linuxGameStructure;
		}
		else if (CheckMac(paths, fileSystem, out MacGameStructure? macGameStructure))
		{
			platformStructure = macGameStructure;
		}
		else if (CheckAndroid(paths, fileSystem, out AndroidGameStructure? androidGameStructure))
		{
			platformStructure = androidGameStructure;
		}
		else if (CheckiOS(paths, fileSystem, out iOSGameStructure? iosGameStructure))
		{
			platformStructure = iosGameStructure;
		}
		else if (CheckSwitch(paths, fileSystem, out SwitchGameStructure? switchGameStructure))
		{
			platformStructure = switchGameStructure;
		}
		else if (CheckPS4(paths, fileSystem, out PS4GameStructure? ps4GameStructure))
		{
			platformStructure = ps4GameStructure;
		}
		else if (CheckWebGL(paths, fileSystem, out WebGLGameStructure? webglGameStructure))
		{
			platformStructure = webglGameStructure;
		}
		else if (CheckWebPlayer(paths, fileSystem, out WebPlayerGameStructure? webplayerGameStructure))
		{
			platformStructure = webplayerGameStructure;
		}
		else if (CheckWiiU(paths, fileSystem, out WiiUGameStructure? wiiUGameStructure))
		{
			platformStructure = wiiUGameStructure;
		}

		if (CheckMixed(paths, fileSystem, out MixedGameStructure? mixedGameStructure))
		{
			mixedStructure = mixedGameStructure;
		}

		return platformStructure != null || mixedStructure != null;
	}


	private static bool CheckWindows(List<string> paths, FileSystem fileSystem, [NotNullWhen(true)] out WindowsGameStructure? gameStructure)
	{
		foreach (string path in paths)
		{
			if (WindowsGameStructure.Exists(path, fileSystem))
			{
				gameStructure = new WindowsGameStructure(path, fileSystem);
				paths.Remove(path);
				Logger.Info(LogCategory.Import, $"Windows game structure has been found at '{path}'");
				return true;
			}
		}
		gameStructure = null;
		return false;
	}

	private static bool CheckLinux(List<string> paths, FileSystem fileSystem, [NotNullWhen(true)] out LinuxGameStructure? gameStructure)
	{
		foreach (string path in paths)
		{
			if (LinuxGameStructure.Exists(path, fileSystem))
			{
				gameStructure = new LinuxGameStructure(path, fileSystem);
				paths.Remove(path);
				Logger.Info(LogCategory.Import, $"Linux game structure has been found at '{path}'");
				return true;
			}
		}
		gameStructure = null;
		return false;
	}

	private static bool CheckMac(List<string> paths, FileSystem fileSystem, [NotNullWhen(true)] out MacGameStructure? gameStructure)
	{
		foreach (string path in paths)
		{
			if (MacGameStructure.Exists(path, fileSystem))
			{
				gameStructure = new MacGameStructure(path, fileSystem);
				paths.Remove(path);
				Logger.Info(LogCategory.Import, $"Mac game structure has been found at '{path}'");
				return true;
			}
		}
		gameStructure = null;
		return false;
	}

	private static bool CheckAndroid(List<string> paths, FileSystem fileSystem, [NotNullWhen(true)] out AndroidGameStructure? gameStructure)
	{
		string? androidStructure = null;
		string? obbStructure = null;
		foreach (string path in paths)
		{
			if (AndroidGameStructure.IsAndroidStructure(path, fileSystem))
			{
				if (androidStructure == null)
				{
					androidStructure = path;
				}
				else
				{
					throw new Exception("2 Android game stuctures has been found");
				}
			}
			else if (AndroidGameStructure.IsAndroidObbStructure(path, fileSystem))
			{
				if (obbStructure == null)
				{
					obbStructure = path;
				}
				else
				{
					throw new Exception("2 Android obb game stuctures has been found");
				}
			}
		}

		if (androidStructure != null)
		{
			gameStructure = new AndroidGameStructure(androidStructure, obbStructure, fileSystem);
			paths.Remove(androidStructure);
			Logger.Info(LogCategory.Import, $"Android game structure has been found at '{androidStructure}'");
			if (obbStructure != null)
			{
				paths.Remove(obbStructure);
				Logger.Info(LogCategory.Import, $"Android obb game structure has been found at '{obbStructure}'");
			}
			return true;
		}

		gameStructure = null;
		return false;
	}

	private static bool CheckiOS(List<string> paths, FileSystem fileSystem, [NotNullWhen(true)] out iOSGameStructure? gameStructure)
	{
		foreach (string path in paths)
		{
			if (iOSGameStructure.Exists(path, fileSystem))
			{
				gameStructure = new iOSGameStructure(path, fileSystem);
				paths.Remove(path);
				Logger.Info(LogCategory.Import, $"iOS game structure has been found at '{path}'");
				return true;
			}
		}
		gameStructure = null;
		return false;
	}

	private static bool CheckPS4(List<string> paths, FileSystem fileSystem, [NotNullWhen(true)] out PS4GameStructure? gameStructure)
	{
		foreach (string path in paths)
		{
			if (PS4GameStructure.Exists(path, fileSystem))
			{
				gameStructure = new PS4GameStructure(path, fileSystem);
				paths.Remove(path);
				Logger.Info(LogCategory.Import, $"PS4 game structure has been found at '{path}'");
				return true;
			}
		}
		gameStructure = null;
		return false;
	}

	private static bool CheckSwitch(List<string> paths, FileSystem fileSystem, [NotNullWhen(true)] out SwitchGameStructure? gameStructure)
	{
		foreach (string path in paths)
		{
			if (SwitchGameStructure.Exists(path, fileSystem))
			{
				gameStructure = new SwitchGameStructure(path, fileSystem);
				paths.Remove(path);
				Logger.Info(LogCategory.Import, $"Switch game structure has been found at '{path}'");
				return true;
			}
		}
		gameStructure = null;
		return false;
	}

	private static bool CheckWebGL(List<string> paths, FileSystem fileSystem, [NotNullWhen(true)] out WebGLGameStructure? gameStructure)
	{
		foreach (string path in paths)
		{
			if (WebGLGameStructure.Exists(path, fileSystem))
			{
				gameStructure = new WebGLGameStructure(path, fileSystem);
				paths.Remove(path);
				Logger.Info(LogCategory.Import, $"WebPlayer game structure has been found at '{path}'");
				return true;
			}
		}
		gameStructure = null;
		return false;
	}

	private static bool CheckWebPlayer(List<string> paths, FileSystem fileSystem, [NotNullWhen(true)] out WebPlayerGameStructure? gameStructure)
	{
		foreach (string path in paths)
		{
			if (WebPlayerGameStructure.Exists(path, fileSystem))
			{
				gameStructure = new WebPlayerGameStructure(path, fileSystem);
				paths.Remove(path);
				Logger.Info(LogCategory.Import, $"WebPlayer game structure has been found at '{path}'");
				return true;
			}
		}
		gameStructure = null;
		return false;
	}

	private static bool CheckWiiU(List<string> paths, FileSystem fileSystem, [NotNullWhen(true)] out WiiUGameStructure? gameStructure)
	{
		foreach (string path in paths)
		{
			if (WiiUGameStructure.Exists(path, fileSystem))
			{
				gameStructure = new WiiUGameStructure(path, fileSystem);
				paths.Remove(path);
				Logger.Info(LogCategory.Import, $"WiiU game structure has been found at '{path}'");
				return true;
			}
		}
		gameStructure = null;
		return false;
	}

	private static bool CheckMixed(List<string> paths, FileSystem fileSystem, [NotNullWhen(true)] out MixedGameStructure? gameStructure)
	{
		if (paths.Count > 0)
		{
			gameStructure = new MixedGameStructure(paths, fileSystem);
			if (paths.Count == 1)
			{
				Logger.Info(LogCategory.Import, $"Mixed game structure has been found at {paths[0]}");
			}
			else
			{
				Logger.Info(LogCategory.Import, $"Mixed game structure has been found for {paths.Count} paths");
			}

			paths.Clear();
			return true;
		}
		gameStructure = null;
		return false;
	}
}

```

`Source/AssetRipper.Import/Structure/Platforms/PlatformGameStructure.cs`:

```cs
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.BundleFiles;
using AssetRipper.IO.Files.BundleFiles.FileStream;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.Streams;
using System.Text.RegularExpressions;

namespace AssetRipper.Import.Structure.Platforms;

public abstract partial class PlatformGameStructure
{
	public FileSystem FileSystem { get; }
	public string? Name { get; protected set; }
	public string? RootPath { get; }
	public string? GameDataPath { get; protected set; }
	public string? StreamingAssetsPath { get; protected set; }
	public string? ResourcesPath { get; protected set; }
	public ScriptingBackend Backend { get; protected set; } = ScriptingBackend.Unknown;
	public string? ManagedPath { get; protected set; }
	public string? Il2CppGameAssemblyPath { get; protected set; }
	public string? Il2CppMetaDataPath { get; protected set; }
	public string? UnityPlayerPath { get; protected set; }
	public UnityVersion? Version { get; protected set; }

	public IReadOnlyList<string> DataPaths { get; protected set; } = [];

	/// <summary>Name : FullName</summary>
	public List<KeyValuePair<string, string>> Files { get; } = [];
	/// <summary>AssemblyName : AssemblyPath</summary>
	public Dictionary<string, string> Assemblies { get; } = [];

	protected static readonly Regex s_levelTemplate = LevelTemplateRegex();
	protected static readonly Regex s_sharedAssetTemplate = SharedAssetTemplateRegex();

	protected const string DataFolderName = "Data";
	protected const string ManagedName = "Managed";
	protected const string LibName = "lib";
	protected const string ResourcesName = "Resources";
	protected const string UnityName = "unity";
	protected const string StreamingName = "StreamingAssets";
	protected const string MetadataName = "Metadata";
	protected const string DefaultUnityPlayerName = "UnityPlayer.dll";
	protected const string DefaultGameAssemblyName = "GameAssembly.dll";
	protected const string DefaultGlobalMetadataName = "global-metadata.dat";

	protected const string DataName = "data";
	protected const string DataBundleName = DataName + AssetBundleExtension;
	protected const string DataPackBundleName = DataName + "pack" + AssetBundleExtension;
	protected const string MainDataName = "mainData";
	protected const string GlobalGameManagersName = "globalgamemanagers";
	protected const string GlobalGameManagerAssetsName = "globalgamemanagers.assets";
	protected const string ResourcesAssetsName = "resources.assets";
	protected const string LevelPrefix = "level";

	protected const string AssetBundleExtension = ".unity3d";
	protected const string AlternateBundleExtension = ".bundle";
	protected const string Lz4BundleName = DataName + AssetBundleExtension;

	public PlatformGameStructure(FileSystem fileSystem)
	{
		ArgumentNullException.ThrowIfNull(fileSystem);
		FileSystem = fileSystem;
	}

	public PlatformGameStructure(string rootPath, FileSystem fileSystem) : this(fileSystem)
	{
		ArgumentException.ThrowIfNullOrEmpty(rootPath);
		if (!FileSystem.Directory.Exists(rootPath))
		{
			throw new DirectoryNotFoundException($"Root directory '{rootPath}' doesn't exist");
		}
		RootPath = rootPath;
	}

	public static bool IsPrimaryEngineFile(string fileName)
	{
		if (fileName == MainDataName ||
			fileName == GlobalGameManagersName ||
			fileName == GlobalGameManagerAssetsName ||
			fileName == ResourcesAssetsName ||
			s_levelTemplate.IsMatch(fileName) ||
			s_sharedAssetTemplate.IsMatch(fileName))
		{
			return true;
		}
		return false;
	}

	/// <summary>Attempts to find the path for the dependency with that name.</summary>
	public string? RequestDependency(string dependency)
	{
		string? dependencyPath = Files.FirstOrDefault(t => t.Key == dependency).Value;
		if (!string.IsNullOrEmpty(dependencyPath))
		{
			return dependencyPath;
		}

		foreach (string dataPath in DataPaths)
		{
			string filePath = FileSystem.Path.Join(dataPath, dependency);
			if (MultiFileStream.Exists(filePath, FileSystem))
			{
				return filePath;
			}

			if (SpecialFileNames.IsDefaultResource(dependency))
			{
				return FindEngineDependency(dataPath, SpecialFileNames.DefaultResourceName1) ??
					FindEngineDependency(dataPath, SpecialFileNames.DefaultResourceName2);
			}
			else if (SpecialFileNames.IsBuiltinExtra(dependency))
			{
				return FindEngineDependency(dataPath, SpecialFileNames.BuiltinExtraName1) ??
					FindEngineDependency(dataPath, SpecialFileNames.BuiltinExtraName2);
			}
		}
		return null;
	}

	public string? RequestAssembly(string assembly)
	{
		string assemblyName = $"{assembly}{MonoManager.AssemblyExtension}";
		if (Assemblies.TryGetValue(assemblyName, out string? assemblyPath))
		{
			return assemblyPath;
		}
		return null;
	}

	public string? RequestResource(string resource)
	{
		foreach (string dataPath in DataPaths)
		{
			string path = FileSystem.Path.Join(dataPath, resource);
			if (MultiFileStream.Exists(path, FileSystem))
			{
				return path;
			}
		}
		return null;
	}

	public virtual void CollectFiles(bool skipStreamingAssets)
	{
		if (this is MixedGameStructure)
		{
			return;
		}

		foreach (string dataPath in DataPaths)
		{
			CollectGameFiles(dataPath, Files);
		}
		CollectMainAssemblies();
		if (!skipStreamingAssets)
		{
			CollectStreamingAssets();
		}
	}

	protected void CollectGameFiles(string root, List<KeyValuePair<string, string>> files)
	{
		Logger.Info(LogCategory.Import, "Collecting game files...");
		CollectCompressedGameFiles(root, files);
		CollectSerializedGameFiles(root, files);
	}

	/// <summary>
	/// Finds data.unity3d and datapack.unity3d when Lz4 compressed
	/// 
	/// Accoding to comments in Unity source file in the function at
	/// PlatformDependent/AndroidPlayer/Source/ApkFile.cpp:268,
	/// the datapack asset is only present if Gradle built an AAB with Unity
	/// data asset pack inside and then bundletool converted AAB into universal APK.
	/// </summary>
	protected void CollectCompressedGameFiles(string root, List<KeyValuePair<string, string>> files)
	{
		string dataBundlePath = FileSystem.Path.Join(root, DataBundleName);
		if (MultiFileStream.Exists(dataBundlePath, FileSystem))
		{
			AddAssetBundle(files, DataBundleName, dataBundlePath);
		}

		string dataPackBundlePath = FileSystem.Path.Join(root, DataPackBundleName);
		if (MultiFileStream.Exists(dataPackBundlePath, FileSystem))
		{
			AddAssetBundle(files, DataPackBundleName, dataPackBundlePath);
		}
	}

	/// <summary>
	/// Collects global game managers and all the level files
	/// </summary>
	protected void CollectSerializedGameFiles(string root, List<KeyValuePair<string, string>> files)
	{
		string filePath = FileSystem.Path.Join(root, GlobalGameManagersName);
		if (MultiFileStream.Exists(filePath, FileSystem))
		{
			AddFile(files, GlobalGameManagersName, filePath);
		}
		else
		{
			filePath = FileSystem.Path.Join(root, MainDataName);
			if (MultiFileStream.Exists(filePath, FileSystem))
			{
				AddFile(files, MainDataName, filePath);
			}
		}

		foreach (string levelFile in FileSystem.Directory.EnumerateFiles(root))
		{
			string name = FileSystem.Path.GetFileName(levelFile);
			if (s_levelTemplate.IsMatch(name))
			{
				string levelName = MultiFileStream.GetFileName(name);
				AddFile(files, levelName, levelFile);
			}
		}
	}

	/// <summary>
	/// Collect bundles from the Streaming Assets folder
	/// </summary>
	protected void CollectStreamingAssets()
	{
		if (string.IsNullOrWhiteSpace(StreamingAssetsPath))
		{
			return;
		}

		Logger.Info(LogCategory.Import, "Collecting Streaming Assets...");
		if (FileSystem.Directory.Exists(StreamingAssetsPath))
		{
			CollectAssetBundlesRecursively(StreamingAssetsPath, Files);
		}
	}

	/// <summary>
	/// Collect asset bundles only from this directory
	/// </summary>
	protected void CollectAssetBundles(string root, List<KeyValuePair<string, string>> files)
	{
		foreach (string file in FileSystem.Directory.EnumerateFiles(root))
		{
			if (BundleHeader.IsBundleHeader(file, FileSystem))
			{
				string name = FileSystem.Path.GetFileNameWithoutExtension(file).ToLowerInvariant();
				AddAssetBundle(files, name, file);
			}
		}
	}

	/// <summary>
	/// Collect asset bundles from this directory and all subdirectories
	/// </summary>
	protected void CollectAssetBundlesRecursively(string root, List<KeyValuePair<string, string>> files)
	{
		CollectAssetBundles(root, files);
		foreach (string directory in FileSystem.Directory.EnumerateDirectories(root))
		{
			CollectAssetBundlesRecursively(directory, files);
		}
	}

	protected void CollectAssemblies(string root, Dictionary<string, string> assemblies)
	{
		foreach (string file in FileSystem.Directory.EnumerateFiles(root))
		{
			string name = FileSystem.Path.GetFileName(file);
			if (MonoManager.IsMonoAssembly(name))
			{
				assemblies.TryAdd(name, file);
			}
		}
	}

	protected void CollectMainAssemblies()
	{
		if (Backend != ScriptingBackend.Mono)
		{
			return;//Only needed for Mono
		}
		else if (!string.IsNullOrWhiteSpace(ManagedPath) && FileSystem.Directory.Exists(ManagedPath))
		{
			CollectAssemblies(ManagedPath, Assemblies);
		}
		else if (!string.IsNullOrEmpty(GameDataPath))
		{
			string libPath = FileSystem.Path.Join(FileSystem.Path.GetFullPath(GameDataPath), LibName);
			if (FileSystem.Directory.Exists(libPath))
			{
				CollectAssemblies(GameDataPath, Assemblies);
				CollectAssemblies(libPath, Assemblies);
			}
		}
	}

	private string? FindEngineDependency(string path, string dependency)
	{
		string filePath = FileSystem.Path.Join(path, dependency);
		if (FileSystem.File.Exists(filePath))
		{
			return filePath;
		}

		string resourcePath = FileSystem.Path.Join(path, ResourcesName);
		filePath = FileSystem.Path.Join(resourcePath, dependency);
		if (FileSystem.File.Exists(filePath))
		{
			return filePath;
		}

		// really old versions contains file in this directory
		string unityPath = FileSystem.Path.Join(path, UnityName);
		filePath = FileSystem.Path.Join(unityPath, dependency);
		if (FileSystem.File.Exists(filePath))
		{
			return filePath;
		}
		return null;
	}

	/// <summary>
	/// Add game file
	/// </summary>
	protected static void AddFile(List<KeyValuePair<string, string>> files, string name, string path)
	{
		files.Add(name, path);
		Logger.Info(LogCategory.Import, $"Game file '{name}' has been found");
	}

	protected static void AddAssetBundle(List<KeyValuePair<string, string>> files, string name, string path)
	{
		files.Add(name, path);
		Logger.Info(LogCategory.Import, $"Asset bundle '{name}' has been found");
	}

	protected UnityVersion GetUnityVersionFromSerializedFile(string filePath)
	{
		return SerializedFile.FromFile(filePath, FileSystem).Version;
	}

	protected UnityVersion GetUnityVersionFromBundleFile(string filePath)
	{
		string version = new FileStreamBundleFile(filePath, FileSystem).Header.UnityWebMinimumRevision ?? "";
		return UnityVersion.Parse(version);
	}

	protected UnityVersion? GetUnityVersionFromDataDirectory(string dataDirectoryPath)
	{
		string globalGameManagersPath = FileSystem.Path.Join(dataDirectoryPath, GlobalGameManagersName);
		if (FileSystem.File.Exists(globalGameManagersPath))
		{
			return GetUnityVersionFromSerializedFile(globalGameManagersPath);
		}
		string dataBundlePath = FileSystem.Path.Join(dataDirectoryPath, DataBundleName);
		if (FileSystem.File.Exists(dataBundlePath))
		{
			return GetUnityVersionFromBundleFile(dataBundlePath);
		}
		return null;
	}

	protected bool HasMonoAssemblies(string managedDirectory)
	{
		if (string.IsNullOrEmpty(managedDirectory) || !FileSystem.Directory.Exists(managedDirectory))
		{
			return false;
		}

		return FileSystem.Directory.GetFiles(managedDirectory, "*.dll").Length > 0;
	}

	protected bool HasIl2CppFiles()
	{
		return Il2CppGameAssemblyPath != null &&
			Il2CppMetaDataPath != null &&
			FileSystem.File.Exists(Il2CppGameAssemblyPath) &&
			FileSystem.File.Exists(Il2CppMetaDataPath);
	}

	[GeneratedRegex("^level(0|[1-9][0-9]*)(\\.split0)?$", RegexOptions.Compiled)]
	private static partial Regex LevelTemplateRegex();

	[GeneratedRegex("^sharedassets[0-9]+\\.assets", RegexOptions.Compiled)]
	private static partial Regex SharedAssetTemplateRegex();
}

```

`Source/AssetRipper.Import/Structure/Platforms/SwitchGameStructure.cs`:

```cs
using AssetRipper.IO.Files;

namespace AssetRipper.Import.Structure.Platforms;

internal sealed class SwitchGameStructure : PlatformGameStructure
{
	private const string ExefsName = "exefs";
	private const string RomName = "romfs";
	private const string MainName = "main";

	public SwitchGameStructure(string rootPath, FileSystem fileSystem) : base(rootPath, fileSystem)
	{
		if (!GetDataSwitchDirectory(rootPath, FileSystem, out string? dataPath))
		{
			throw new DirectoryNotFoundException($"Data directory wasn't found");
		}

		Name = FileSystem.Path.GetFileName(rootPath);
		GameDataPath = dataPath;
		StreamingAssetsPath = FileSystem.Path.Join(GameDataPath, StreamingName);
		ResourcesPath = FileSystem.Path.Join(GameDataPath, ResourcesName);
		ManagedPath = FileSystem.Path.Join(GameDataPath, ManagedName);
		UnityPlayerPath = null;
		Version = GetUnityVersionFromDataDirectory(GameDataPath);
		Il2CppGameAssemblyPath = FileSystem.Path.Join(rootPath, ExefsName, MainName);
		Il2CppMetaDataPath = FileSystem.Path.Join(ManagedPath, MetadataName, DefaultGlobalMetadataName);
		Backend = HasIl2CppFiles() ? Assembly.ScriptingBackend.IL2Cpp : Assembly.ScriptingBackend.Unknown;

		DataPaths = [GameDataPath];
	}

	public static bool Exists(string path, FileSystem fileSystem)
	{
		return fileSystem.Directory.Exists(path)
			&& fileSystem.Directory.Exists(fileSystem.Path.Join(path, ExefsName))
			&& GetDataSwitchDirectory(path, fileSystem, out _);
	}

	private static bool GetDataSwitchDirectory(string rootDirectory, FileSystem fileSystem, [NotNullWhen(true)] out string? dataPath)
	{
		dataPath = null;
		string romPath = fileSystem.Path.Join(rootDirectory, RomName);
		if (!fileSystem.Directory.Exists(romPath))
		{
			return false;
		}

		string ldataPath = fileSystem.Path.Join(romPath, DataFolderName);
		if (!fileSystem.Directory.Exists(ldataPath))
		{
			return false;
		}

		dataPath = ldataPath;
		return true;
	}
}

```

`Source/AssetRipper.Import/Structure/Platforms/WebGLGameStructure.cs`:

```cs
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.IO.Files;

namespace AssetRipper.Import.Structure.Platforms;

internal sealed class WebGLGameStructure : PlatformGameStructure
{
	public WebGLGameStructure(string rootPath, FileSystem fileSystem) : base(rootPath, fileSystem)
	{
		string buildPath = FileSystem.Path.Join(rootPath, BuildName);
		if (FileSystem.Directory.Exists(buildPath))
		{
			foreach (string file in FileSystem.Directory.EnumerateFiles(buildPath))
			{
				if (file.EndsWith(DataWebExtension, StringComparison.Ordinal))
				{
					Name = fileSystem.Path.GetFileName(file)[..^DataWebExtension.Length];
					Files.Add(Name, file);
					break;
				}
			}
			DataPaths = [rootPath, buildPath];
		}
		else
		{
			string developmentPath = FileSystem.Path.Join(rootPath, DevelopmentName);
			if (FileSystem.Directory.Exists(developmentPath))
			{
				foreach (string file in FileSystem.Directory.EnumerateFiles(developmentPath))
				{
					if (file.EndsWith(DataExtension, StringComparison.Ordinal))
					{
						Name = fileSystem.Path.GetFileName(file)[..^DataExtension.Length];
						Files.Add(Name, file);
						break;
					}
				}
				DataPaths = [rootPath, developmentPath];
			}
			else
			{
				string releasePath = FileSystem.Path.Join(rootPath, ReleaseName);
				if (FileSystem.Directory.Exists(releasePath))
				{
					foreach (string file in FileSystem.Directory.EnumerateFiles(releasePath))
					{
						if (file.EndsWith(DataGzExtension, StringComparison.Ordinal))
						{
							Name = fileSystem.Path.GetFileName(file)[..^DataGzExtension.Length];
							Files.Add(Name, file);
							break;
						}
					}
					DataPaths = [rootPath, releasePath];
				}
				else
				{
					throw new DirectoryNotFoundException("Build directory wasn't found");
				}
			}
		}

		Name = FileSystem.Path.GetFileName(rootPath);
		GameDataPath = rootPath;
		StreamingAssetsPath = rootPath;
		ResourcesPath = null;
		ManagedPath = null;
		UnityPlayerPath = null;
		Version = null;
		Il2CppGameAssemblyPath = null;
		Il2CppMetaDataPath = null;
		Backend = ScriptingBackend.Unknown;

		if (Files.Count == 0)
		{
			throw new Exception("No files were found");
		}
	}

	public static bool Exists(string root, FileSystem fileSystem)
	{
		if (!fileSystem.Directory.Exists(root))
		{
			return false;
		}

		foreach (string htmlFile in fileSystem.Directory.EnumerateFiles(root))
		{
			if (!htmlFile.EndsWith(HtmlExtension, StringComparison.Ordinal))
			{
				continue;
			}

			foreach (string directory in fileSystem.Directory.EnumerateDirectories(root))
			{
				switch (fileSystem.Path.GetFileName(directory))
				{
					case DevelopmentName:
						{
							foreach (string file in fileSystem.Directory.EnumerateFiles(directory))
							{
								if (file.EndsWith(DataExtension, StringComparison.Ordinal))
								{
									return true;
								}
							}
						}
						break;

					case ReleaseName:
						{
							foreach (string file in fileSystem.Directory.EnumerateFiles(directory))
							{
								if (file.EndsWith(DataGzExtension, StringComparison.Ordinal))
								{
									return true;
								}
							}
						}
						break;

					case BuildName:
						{
							foreach (string file in fileSystem.Directory.EnumerateFiles(directory))
							{
								if (file.EndsWith(DataWebExtension, StringComparison.Ordinal))
								{
									return true;
								}
							}
						}
						break;
				}
			}

			return false;
		}
		return false;
	}

	private const string DevelopmentName = "Development";
	private const string ReleaseName = "Release";
	private const string BuildName = "Build";

	private const string HtmlExtension = ".html";
	public const string DataExtension = ".data";
	public const string DataGzExtension = ".datagz";
	public const string UnityWebExtension = ".unityweb";
	public const string DataWebExtension = DataExtension + UnityWebExtension;
}

```

`Source/AssetRipper.Import/Structure/Platforms/WebPlayerGameStructure.cs`:

```cs
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.IO.Files;
using System.Diagnostics;

namespace AssetRipper.Import.Structure.Platforms;

internal sealed class WebPlayerGameStructure : PlatformGameStructure
{
	public WebPlayerGameStructure(string rootPath, FileSystem fileSystem) : base(rootPath, fileSystem)
	{
		Debug.Assert(RootPath is not null);

		if (!GetWebPlayerName(RootPath, FileSystem, out string? name))
		{
			throw new Exception($"Web player asset bundle data wasn't found");
		}

		Name = name;
		GameDataPath = null;
		StreamingAssetsPath = null;
		ResourcesPath = null;
		ManagedPath = null;
		UnityPlayerPath = null;
		Il2CppGameAssemblyPath = null;
		Il2CppMetaDataPath = null;
		Version = null;
		Backend = ScriptingBackend.Unknown;

		DataPaths = [RootPath];

		string assetBundlePath = fileSystem.Path.Join(RootPath, Name + AssetBundleExtension);
		Files.Add(Name, assetBundlePath);
	}

	public static bool Exists(string path, FileSystem fileSystem)
	{
		return fileSystem.Directory.Exists(path) && GetWebPlayerName(path, fileSystem, out _);
	}

	public static bool GetWebPlayerName(string root, FileSystem fileSystem, [NotNullWhen(true)] out string? name)
	{
		foreach (string file in fileSystem.Directory.EnumerateFiles(root))
		{
			if (fileSystem.Path.GetExtension(file) == HtmlExtension)
			{
				name = fileSystem.Path.GetFileNameWithoutExtension(file);
				string assetBundlePath = fileSystem.Path.Join(root, name + AssetBundleExtension);
				if (fileSystem.File.Exists(assetBundlePath))
				{
					return true;
				}
			}
		}
		name = null;
		return false;
	}

	private const string HtmlExtension = ".html";
}

```

`Source/AssetRipper.Import/Structure/Platforms/WiiUGameStructure.cs`:

```cs
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.IO.Files;

namespace AssetRipper.Import.Structure.Platforms;

internal sealed class WiiUGameStructure : PlatformGameStructure
{
	public WiiUGameStructure(string rootPath, FileSystem fileSystem) : base(rootPath, fileSystem)
	{
		Name = fileSystem.Path.GetFileName(rootPath);
		GameDataPath = fileSystem.Path.Join(RootPath, ContentName, DataFolderName);
		if (!fileSystem.Directory.Exists(GameDataPath))
		{
			throw new DirectoryNotFoundException($"Data directory wasn't found");
		}
		StreamingAssetsPath = fileSystem.Path.Join(GameDataPath, StreamingName);
		ResourcesPath = fileSystem.Path.Join(GameDataPath, ResourcesName);
		ManagedPath = fileSystem.Path.Join(GameDataPath, ManagedName);
		UnityPlayerPath = null;
		Version = null;
		Il2CppGameAssemblyPath = null;
		Il2CppMetaDataPath = null;
		//WiiU doesn't support IL2Cpp
		//See https://docs.unity3d.com/2017.4/Documentation/Manual/ScriptingRestrictions.html

		if (HasMonoAssemblies(ManagedPath))
		{
			Backend = ScriptingBackend.Mono;
		}
		else
		{
			Backend = ScriptingBackend.Unknown;
		}

		DataPaths = [GameDataPath];
	}

	public static bool Exists(string rootPath, FileSystem fileSystem)
	{
		string gameDataPath = fileSystem.Path.Join(rootPath, ContentName, DataFolderName);
		return fileSystem.Directory.Exists(gameDataPath);
	}

	private const string ContentName = "content";
}

```

`Source/AssetRipper.Import/Structure/Platforms/WindowsGameStructure.cs`:

```cs
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.IO.Files;
using System.Diagnostics;

namespace AssetRipper.Import.Structure.Platforms;

internal sealed class WindowsGameStructure : PlatformGameStructure
{
	public WindowsGameStructure(string rootPath, FileSystem fileSystem) : base(GetActualRootPath(rootPath, fileSystem), fileSystem)
	{
		Debug.Assert(RootPath is not null);
		if (rootPath != RootPath)
		{
			Logger.Info(LogCategory.Import, "An executable file or data directory was found, so the parent directory is being used instead.");
		}

		if (!GetDataDirectory(RootPath, fileSystem, out string? dataPath, out string? name))
		{
			throw new DirectoryNotFoundException($"Data directory wasn't found");
		}

		Name = name;
		GameDataPath = dataPath;
		StreamingAssetsPath = FileSystem.Path.Join(GameDataPath, StreamingName);
		ResourcesPath = FileSystem.Path.Join(GameDataPath, ResourcesName);
		ManagedPath = FileSystem.Path.Join(GameDataPath, ManagedName);
		UnityPlayerPath = FileSystem.Path.Join(RootPath, DefaultUnityPlayerName);
		Version = null;
		Il2CppGameAssemblyPath = FileSystem.Path.Join(RootPath, DefaultGameAssemblyName);
		Il2CppMetaDataPath = FileSystem.Path.Join(GameDataPath, "il2cpp_data", MetadataName, DefaultGlobalMetadataName);

		if (HasIl2CppFiles())
		{
			Backend = ScriptingBackend.IL2Cpp;
		}
		else if (HasMonoAssemblies(ManagedPath))
		{
			Backend = ScriptingBackend.Mono;
		}
		else
		{
			Backend = ScriptingBackend.Unknown;
		}

		DataPaths = [GameDataPath];
	}

	public static bool Exists(string path, FileSystem fileSystem)
	{
		string directory;
		if (IsExecutableFile(path, fileSystem))
		{
			directory = fileSystem.Path.GetDirectoryName(path) ?? throw new Exception("Could not get file directory");
		}
		else if (IsUnityDataDirectory(path, fileSystem))
		{
			return true;
		}
		else
		{
			directory = path;
		}

		return fileSystem.Directory.Exists(directory) && IsRootDirectory(directory, fileSystem);
	}

	private static bool IsUnityDataDirectory(string folderPath, FileSystem fileSystem)
	{
		const string Suffix = $"_{DataFolderName}";
		if (string.IsNullOrEmpty(folderPath) || !folderPath.EndsWith(Suffix, StringComparison.Ordinal))
		{
			return false;
		}

		if (!fileSystem.Directory.Exists(folderPath))
		{
			return false;
		}

		string folderName = fileSystem.Path.GetFileName(folderPath);
		string gameName = folderName[..^Suffix.Length];
		string rootPath = fileSystem.Path.GetDirectoryName(folderPath);
		string exePath = fileSystem.Path.Join(rootPath, gameName + ExeExtension);
		if (fileSystem.File.Exists(exePath))
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	private static bool IsExecutableFile(string filePath, FileSystem fileSystem)
	{
		return !string.IsNullOrEmpty(filePath) && filePath.EndsWith(ExeExtension, StringComparison.OrdinalIgnoreCase) && fileSystem.File.Exists(filePath);
	}

	private static string GetActualRootPath(string rootPath, FileSystem fileSystem)
	{
		ArgumentException.ThrowIfNullOrEmpty(rootPath);
		if (IsExecutableFile(rootPath, fileSystem))
		{
			return fileSystem.Path.GetDirectoryName(rootPath) ?? throw new Exception("Could not get file directory");
		}
		else if (IsUnityDataDirectory(rootPath, fileSystem))
		{
			return fileSystem.Path.GetDirectoryName(rootPath) ?? throw new Exception("Could not get parent directory");
		}
		else
		{
			return rootPath;
		}
	}

	private static bool IsRootDirectory(string rootDirectory, FileSystem fileSystem)
	{
		return GetDataDirectory(rootDirectory, fileSystem, out string? _, out string? _);
	}

	private static bool GetDataDirectory(string rootDirectory, FileSystem fileSystem, [NotNullWhen(true)] out string? dataPath, [NotNullWhen(true)] out string? name)
	{
		name = "";
		int exeCount = 0;
		foreach (string file in fileSystem.Directory.EnumerateFiles(rootDirectory))
		{
			if (file.EndsWith(ExeExtension, StringComparison.OrdinalIgnoreCase))
			{
				exeCount++;
				name = fileSystem.Path.GetFileNameWithoutExtension(file);
				string dataFolder = $"{name}_{DataFolderName}";
				dataPath = fileSystem.Path.Join(rootDirectory, dataFolder);
				if (fileSystem.Directory.Exists(dataPath))
				{
					return true;
				}
			}
		}

		if (exeCount > 0)
		{
			name = exeCount == 1 ? name : fileSystem.Path.GetFileName(rootDirectory);
			dataPath = fileSystem.Path.Join(rootDirectory, DataFolderName);
			if (fileSystem.Directory.Exists(dataPath))
			{
				return true;
			}
		}

		name = null;
		dataPath = null;
		return false;
	}


	private const string ExeExtension = ".exe";
}

```

`Source/AssetRipper.Import/Structure/Platforms/iOSGameStructure.cs`:

```cs
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.IO.Files;

namespace AssetRipper.Import.Structure.Platforms;

internal sealed class iOSGameStructure : PlatformGameStructure
{
	public iOSGameStructure(string rootPath, FileSystem fileSystem) : base(rootPath, fileSystem)
	{
		if (!GetDataiOSDirectory(rootPath, FileSystem, out string? dataPath, out string? appPath, out string? name))
		{
			throw new DirectoryNotFoundException($"Data directory wasn't found");
		}

		Name = name;
		GameDataPath = dataPath;
		StreamingAssetsPath = FileSystem.Path.Join(rootPath, iOSStreamingName);
		ResourcesPath = FileSystem.Path.Join(dataPath, ResourcesName);
		ManagedPath = FileSystem.Path.Join(dataPath, ManagedName);
		UnityPlayerPath = null;
		Version = GetUnityVersionFromDataDirectory(GameDataPath);
		Il2CppGameAssemblyPath = FileSystem.Path.Join(appPath, name);
		Il2CppMetaDataPath = FileSystem.Path.Join(ManagedPath, MetadataName, DefaultGlobalMetadataName);

		if (HasIl2CppFiles())
		{
			Backend = ScriptingBackend.IL2Cpp;
		}
		else if (HasMonoAssemblies(ManagedPath))
		{
			Backend = ScriptingBackend.Mono;
		}
		else
		{
			Backend = ScriptingBackend.Unknown;
		}

		DataPaths = [GameDataPath];
	}

	public static bool Exists(string path, FileSystem fileSystem)
	{
		if (!fileSystem.Directory.Exists(path))
		{
			return false;
		}

		return GetDataiOSDirectory(path, fileSystem, out _, out _, out _);
	}

	private static bool GetDataiOSDirectory(string rootDirectory, FileSystem fileSystem, [NotNullWhen(true)] out string? dataPath, [NotNullWhen(true)] out string? appPath, [NotNullWhen(true)] out string? appName)
	{
		string payloadPath = fileSystem.Path.Join(rootDirectory, PayloadName);
		if (!fileSystem.Directory.Exists(payloadPath))
		{
			dataPath = null;
			appPath = null;
			appName = null;
			return false;
		}

		foreach (string directory in fileSystem.Directory.EnumerateDirectories(payloadPath))
		{
			string name = fileSystem.Path.GetFileName(directory);
			if (name.EndsWith(AppExtension, StringComparison.Ordinal))
			{
				appPath = directory;
				appName = name[..^AppExtension.Length];
				dataPath = fileSystem.Path.Join(directory, DataFolderName);
				if (fileSystem.Directory.Exists(dataPath))
				{
					return true;
				}
			}
		}

		dataPath = null;
		appPath = null;
		appName = null;
		return false;
	}

	private void CollectiOSStreamingAssets(string root, List<KeyValuePair<string, string>> files)
	{
		string streamingPath = FileSystem.Path.Join(root, iOSStreamingName);
		if (FileSystem.Directory.Exists(streamingPath))
		{
			CollectAssetBundlesRecursively(streamingPath, files);
		}
	}


	private const string iOSStreamingName = "Raw";

	private const string PayloadName = "Payload";
	private const string AppExtension = ".app";
}

```

`Source/AssetRipper.Import/Structure/ZipExtractor.cs`:

```cs
using AssetRipper.Import.Logging;
using AssetRipper.IO.Files;
using SharpCompress.Archives;
using SharpCompress.Archives.Zip;
using SharpCompress.Common;

namespace AssetRipper.Import.Structure;

internal static class ZipExtractor
{
	private const string ZipExtension = ".zip";
	private const string ApkExtension = ".apk";
	private const string ApksExtension = ".apks";
	private const string ApkPlusExtension = ".apk+";
	private const string ObbExtension = ".obb";
	private const string XapkExtension = ".xapk";
	private const string VpkExtension = ".vpk"; //PS Vita
	private const string IpaExtension = ".ipa"; //iOS App Store Package
	private const uint ZipNormalMagic = 0x04034B50;
	private const uint ZipEmptyMagic = 0x06054B50;
	private const uint ZipSpannedMagic = 0x08074B50;

	public static List<string> Process(IEnumerable<string> paths, FileSystem fileSystem)
	{
		List<string> result = [];
		foreach (string path in paths)
		{
			switch (GetFileExtension(path, fileSystem))
			{
				case ZipExtension:
				case ApkExtension:
				case ObbExtension:
				case VpkExtension:
				case IpaExtension:
					result.Add(ExtractZip(path, fileSystem));
					break;
				case ApksExtension:
				case ApkPlusExtension:
				case XapkExtension:
					result.Add(ExtractXapk(path, fileSystem));
					break;
				default:
					result.Add(path);
					break;
			}
		}
		return result;
	}

	private static string ExtractZip(string zipFilePath, FileSystem fileSystem)
	{
		if (!HasCompatibleMagic(zipFilePath, fileSystem))
		{
			return zipFilePath;
		}

		string outputDirectory = fileSystem.Directory.CreateTemporary();
		DecompressZipArchive(zipFilePath, outputDirectory, fileSystem);
		return outputDirectory;
	}

	private static string ExtractXapk(string xapkFilePath, FileSystem fileSystem)
	{
		if (!HasCompatibleMagic(xapkFilePath, fileSystem))
		{
			return xapkFilePath;
		}

		string intermediateDirectory = fileSystem.Directory.CreateTemporary();
		string outputDirectory = fileSystem.Directory.CreateTemporary();
		DecompressZipArchive(xapkFilePath, intermediateDirectory, fileSystem);
		foreach (string filePath in fileSystem.Directory.GetFiles(intermediateDirectory))
		{
			if (GetFileExtension(filePath, fileSystem) == ApkExtension)
			{
				DecompressZipArchive(filePath, outputDirectory, fileSystem);
			}
		}
		return outputDirectory;
	}

	private static void DecompressZipArchive(string zipFilePath, string outputDirectory, FileSystem fileSystem)
	{
		Logger.Info(LogCategory.Import, $"Decompressing files...{Environment.NewLine}\tFrom: {zipFilePath}{Environment.NewLine}\tTo: {outputDirectory}");
		using Stream stream = fileSystem.File.OpenRead(zipFilePath);
		using ZipArchive archive = ZipArchive.Open(stream);
		foreach (ZipArchiveEntry entry in archive.Entries)
		{
			WriteEntryToDirectory(entry, outputDirectory, fileSystem);
		}
	}

	private static void WriteEntryToDirectory(ZipArchiveEntry entry, string outputDirectory, FileSystem fileSystem)
	{
		string filePath;
		string fullOutputDirectory = fileSystem.Path.GetFullPath(outputDirectory);

		if (!fileSystem.Directory.Exists(fullOutputDirectory))
		{
			throw new ExtractionException($"Directory does not exist to extract to: {fullOutputDirectory}");
		}

		string fileName = fileSystem.Path.GetFileName(entry.Key ?? throw new NullReferenceException("Entry Key is null")) ?? throw new NullReferenceException("File is null");
		fileName = FileSystem.FixInvalidFileNameCharacters(fileName);

		string directory = fileSystem.Path.GetDirectoryName(entry.Key ?? throw new NullReferenceException("Entry Key is null")) ?? throw new NullReferenceException("Directory is null");
		string fullDirectory = fileSystem.Path.GetFullPath(fileSystem.Path.Join(fullOutputDirectory, directory));

		if (!fileSystem.Directory.Exists(fullDirectory))
		{
			if (!fullDirectory.StartsWith(fullOutputDirectory, StringComparison.Ordinal))
			{
				throw new ExtractionException("Entry is trying to create a directory outside of the destination directory.");
			}

			fileSystem.Directory.Create(fullDirectory);
		}
		filePath = fileSystem.Path.Join(fullDirectory, fileName);

		if (!entry.IsDirectory)
		{
			filePath = fileSystem.Path.GetFullPath(filePath);

			if (!filePath.StartsWith(fullOutputDirectory,StringComparison.Ordinal))
			{
				throw new ExtractionException("Entry is trying to write a file outside of the destination directory.");
			}

			using Stream stream = fileSystem.File.Create(filePath);
			entry.WriteTo(stream);
		}
		else if (!fileSystem.Directory.Exists(filePath))
		{
			fileSystem.Directory.Create(filePath);
		}
	}

	private static string? GetFileExtension(string path, FileSystem fileSystem)
	{
		if (fileSystem.File.Exists(path))
		{
			return fileSystem.Path.GetExtension(path);
		}
		else
		{
			return null;
		}
	}

	private static bool HasCompatibleMagic(string path, FileSystem fileSystem)
	{
		uint magic = GetMagicNumber(path, fileSystem);
		return magic == ZipNormalMagic || magic == ZipEmptyMagic || magic == ZipSpannedMagic;
	}

	private static uint GetMagicNumber(string path, FileSystem fileSystem)
	{
		using Stream stream = fileSystem.File.OpenRead(path);
		return new BinaryReader(stream).ReadUInt32();
	}
}

```

`Source/AssetRipper.Import/Usings.cs`:

```cs
global using AssetRipper.Primitives;

```

`Source/AssetRipper.Import/Utils/ExecutingDirectory.cs`:

```cs
namespace AssetRipper.Import.Utils;

public static class ExecutingDirectory
{
	static ExecutingDirectory()
	{
		Info = new DirectoryInfo(AppContext.BaseDirectory);
	}

	public static DirectoryInfo Info { get; }
	public static string Name => Info.Name;
	public static string Path => Info.FullName;

	public static string Combine(string relativePath) => System.IO.Path.Join(Path, relativePath);
	public static string Combine(string path1, string path2) => System.IO.Path.Join(Path, path1, path2);
	public static string Combine(string path1, string path2, string path3) => System.IO.Path.Join(Path, path1, path2, path3);
	public static string Combine(params string[] parameters) => System.IO.Path.Join(Path, System.IO.Path.Join(parameters));
}

```

`Source/AssetRipper.Numerics.Tests/AssetRipper.Numerics.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<IsPackable>false</IsPackable>
		<OutputPath>..\0Bins\Other\AssetRipper.Numerics.Tests\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Numerics.Tests\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
		<PackageReference Include="NUnit" Version="4.4.0" />
		<PackageReference Include="NUnit3TestAdapter" Version="6.1.0" />
		<PackageReference Include="NUnit.Analyzers" Version="4.11.2">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Numerics\AssetRipper.Numerics.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Numerics.Tests/BoneWeight4Tests.cs`:

```cs
namespace AssetRipper.Numerics.Tests;

public class BoneWeight4Tests
{
	[Test]
	public void DefaultCanBeNormalized()
	{
		BoneWeight4 boneWeight = new BoneWeight4().NormalizeWeights();
		using (Assert.EnterMultipleScope())
		{
			Assert.That(boneWeight.Weight0, Is.EqualTo(0.25f));
			Assert.That(boneWeight.Weight1, Is.EqualTo(0.25f));
			Assert.That(boneWeight.Weight2, Is.EqualTo(0.25f));
			Assert.That(boneWeight.Weight3, Is.EqualTo(0.25f));
			Assert.That(boneWeight.Normalized);
		}
	}
}

```

`Source/AssetRipper.Numerics.Tests/Color32Tests.cs`:

```cs
using System.Drawing;
using System.Runtime.CompilerServices;

namespace AssetRipper.Numerics.Tests;

public class Color32Tests
{
	private Color32 _color;

	[SetUp]
	public void SetUp()
	{
		_color = new Color32(0x0A, 0x14, 0x1E, 0x28);
	}

	[Test]
	public void Color32_RgbaReturnsCorrectValue()
	{
		Assert.That(_color.Rgba, Is.EqualTo(0x281E140Au));
	}

	[Test]
	public void Color32_FromRgbaReturnsCorrectValue()
	{
		Assert.That(Color32.FromRgba(0x281E140A), Is.EqualTo(_color));
	}

	[Test]
	public void Color32_ExplicitColorFloatOperatorReturnsCorrectValue()
	{
		ColorFloat colorFloat = (ColorFloat)_color;
		Assert.That(colorFloat, Is.EqualTo(new ColorFloat(0.0392156877f, 0.0784313753f, 0.117647059f, 0.156862751f)));
	}

	[Test]
	public void Color32_ExplicitColor32OperatorReturnsCorrectValue()
	{
		Color32 color32 = (Color32)new ColorFloat(0.0392156877f, 0.0784313753f, 0.117647059f, 0.156862751f);
		Assert.That(color32, Is.EqualTo(new Color32(10, 20, 30, 40)));
	}

	[Test]
	public void Color32_BlackReturnsCorrectValue()
	{
		Assert.That(Color32.Black, Is.EqualTo(new Color32(byte.MinValue, byte.MinValue, byte.MinValue, byte.MaxValue)));
	}

	[Test]
	public void Color32_WhiteReturnsCorrectValue()
	{
		Assert.That(Color32.White, Is.EqualTo(new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue)));
	}

	[Test]
	public void RgbaPropertyMatchesShiftOperators()
	{
		Color32 color = new Color32(33, 57, 199, 255);
		uint value = unchecked((uint)(color.R | color.G << 8 | color.B << 16 | color.A << 24));
		Assert.That(color.Rgba, Is.EqualTo(value));
	}

	[Test]
	public void RgbaPropertyMatchesUnsafeAs()
	{
		Color32 color = new Color32(33, 57, 199, 255);
		uint value = Unsafe.As<Color32, uint>(ref color);
		Assert.That(color.Rgba, Is.EqualTo(value));
	}

	[Test]
	public void ConversionToSystemDrawingColorIsCorrect()
	{
		using (Assert.EnterMultipleScope())
		{
			Color color = (Color)_color;
			Assert.That(color.R, Is.EqualTo(_color.R));
			Assert.That(color.G, Is.EqualTo(_color.G));
			Assert.That(color.B, Is.EqualTo(_color.B));
			Assert.That(color.A, Is.EqualTo(_color.A));
		}
	}
}

```

`Source/AssetRipper.Numerics.Tests/ColorFloatTests.cs`:

```cs
namespace AssetRipper.Numerics.Tests;

public class ColorFloatTests
{
	[Test]
	public void ColorFloat_Addition_ReturnsExpectedResult()
	{
		ColorFloat color1 = new ColorFloat(0.1f, 0.2f, 0.3f, 0.4f);
		ColorFloat color2 = new ColorFloat(0.5f, 0.6f, 0.7f, 0.8f);
		ColorFloat expectedResult = new ColorFloat(0.6f, 0.8f, 1.0f, 1.2f);

		ColorFloat actualResult = color1 + color2;

		Assert.That(actualResult, Is.EqualTo(expectedResult));
	}

	[Test]
	public void ColorFloat_Subtraction_ReturnsExpectedResult()
	{
		ColorFloat color1 = new ColorFloat(5.0f, 6.0f, 7.0f, 8.0f);
		ColorFloat color2 = new ColorFloat(1.0f, 2.0f, 3.0f, 4.0f);
		ColorFloat expectedResult = new ColorFloat(4.0f, 4.0f, 4.0f, 4.0f);

		ColorFloat actualResult = color1 - color2;

		Assert.That(actualResult, Is.EqualTo(expectedResult));
	}

	[Test]
	public void ColorFloat_Clamp_ReturnsExpectedResult()
	{
		ColorFloat color1 = new ColorFloat(-0.1f, 1.2f, 0.3f, -1.3f);
		ColorFloat expectedResult = new ColorFloat(0.0f, 1.0f, 0.3f, 0.0f);

		ColorFloat actualResult = color1.Clamp();

		Assert.That(actualResult, Is.EqualTo(expectedResult));
	}

	[Test]
	public void ColorFloat_Multiplication_ReturnsExpectedResult()
	{
		ColorFloat color1 = new ColorFloat(0.1f, 0.2f, 0.3f, 0.4f);
		float factor = 2.0f;
		ColorFloat expectedResult = new ColorFloat(0.2f, 0.4f, 0.6f, 0.8f);

		ColorFloat actualResult = color1 * factor;

		Assert.That(actualResult, Is.EqualTo(expectedResult));
	}

	[Test]
	public void ColorFloat_StaticMethods_BlackAndWhiteTest_ReturnsExpectedResult()
	{
		ColorFloat black = ColorFloat.Black;
		ColorFloat white = ColorFloat.White;

		Assert.That(black, Is.EqualTo(new ColorFloat(0, 0, 0, 1)));
		Assert.That(white, Is.EqualTo(new ColorFloat(1, 1, 1, 1)));
	}
}

```

`Source/AssetRipper.Numerics.Tests/DiscontinuousRangeTests.cs`:

```cs
namespace AssetRipper.Numerics.Tests;

public class DiscontinuousRangeTests
{
	private static readonly Range<float> MinToZero = new(float.MinValue, 0);
	private static readonly Range<float> ZeroToThree = new(0, 3);
	private static readonly Range<float> ThreeToFour = new(3, 4);
	private static readonly Range<float> FourToFive = new(4, 5);
	private static readonly Range<float> FiveToSeven = new(5, 7);
	private static readonly Range<float> SevenToNine = new(7, 9);
	private static readonly Range<float> NineToTen = new(9, 10);
	private static readonly Range<float> ZeroToTen = new(0, 110);
	private static readonly Range<float> ZeroToEleven = new(0, 11);
	private static readonly Range<float> TenToTwenty = new(10, 20);
	private static readonly Range<float> ZeroToTwenty = new(0, 20);
	private static readonly Range<float> ZeroToMax = new(0, float.MaxValue);
	private static readonly Range<float> TwentyToMax = new(20, float.MaxValue);
	private static readonly Range<float> MinToMax = new(float.MinValue, float.MaxValue);

	[Test]
	public void DisjointConstructionSucceedsAndHasCorrectCount()
	{
		DiscontinuousRange<float> range = new(ZeroToThree, SevenToNine, FourToFive);
		Assert.That(range, Has.Count.EqualTo(3));
	}

	[Test]
	public void OverlappingConstructionSucceedsAndHasCorrectCount()
	{
		DiscontinuousRange<float> range = new(ZeroToThree, SevenToNine, ZeroToEleven, FourToFive);
		Assert.That(range, Has.Count.EqualTo(1));
	}

	[Test]
	public void EmptyHasCountZero()
	{
		Assert.That(DiscontinuousRange<float>.Empty.Count, Is.Zero);
	}

	[Test]
	public void CommutativeConstruction()
	{
		DiscontinuousRange<float> range1 = new(ZeroToThree, SevenToNine, FourToFive);
		DiscontinuousRange<float> range2 = new(SevenToNine, FourToFive, ZeroToThree);
		AssertEqual(range1, range2);
	}

	[Test]
	public void MergingConstruction()
	{
		DiscontinuousRange<float> range1 = new(TenToTwenty, TwentyToMax, ZeroToTen);
		DiscontinuousRange<float> expected = new(ZeroToMax);
		AssertEqual(range1, expected);
	}

	[Test]
	public void UnionTest()
	{
		DiscontinuousRange<float> range1 = new(TwentyToMax, ZeroToTen);
		DiscontinuousRange<float> range2 = new(ZeroToTwenty);
		DiscontinuousRange<float> expected = new(ZeroToMax);
		AssertEqual(range1.Union(range2), expected);
	}

	[Test]
	public void NegationTest()
	{
		DiscontinuousRange<float> range1 = new(MinToZero);
		DiscontinuousRange<float> expected = new(ZeroToMax);
		AssertEqual(range1.Negate(float.MinValue, float.MaxValue), expected);
	}

	[Test]
	public void SubtractMiddleTest()
	{
		DiscontinuousRange<float> range1 = new(MinToMax);
		DiscontinuousRange<float> expected = new(MinToZero, TwentyToMax);
		AssertEqual(range1.Subtract(ZeroToTwenty), expected);
	}

	[Test]
	public void SubtractLeftTest()
	{
		DiscontinuousRange<float> range1 = new(MinToMax);
		DiscontinuousRange<float> expected = new(ZeroToMax);
		AssertEqual(range1.Subtract(MinToZero), expected);
	}

	[Test]
	public void SubtractRightTest()
	{
		DiscontinuousRange<float> range1 = new(MinToMax);
		DiscontinuousRange<float> expected = new(MinToZero);
		AssertEqual(range1.Subtract(ZeroToMax), expected);
	}

	[Test]
	public void SubtractAllTest()
	{
		DiscontinuousRange<float> range1 = new(TenToTwenty);
		DiscontinuousRange<float> expected = DiscontinuousRange<float>.Empty;
		AssertEqual(range1.Subtract(ZeroToMax), expected);
	}

	[Test]
	public void SubtractLeftOverlappingTest()
	{
		DiscontinuousRange<float> range1 = new(ZeroToMax);
		DiscontinuousRange<float> range2 = new(MinToZero, ZeroToTwenty);
		DiscontinuousRange<float> expected = new(TwentyToMax);
		AssertEqual(range1.Subtract(range2), expected);
	}

	[Test]
	public void SubtractEndsTest()
	{
		DiscontinuousRange<float> range1 = new(ZeroToMax);
		DiscontinuousRange<float> range2 = new(MinToZero, TwentyToMax);
		DiscontinuousRange<float> expected = new(ZeroToTwenty);
		AssertEqual(range1.Subtract(range2), expected);
	}

	[Test]
	public void SubtractManyTest()
	{
		DiscontinuousRange<float> range1 = new(ZeroToMax);
		DiscontinuousRange<float> range2 = new(MinToZero, ZeroToThree, ThreeToFour, FiveToSeven, SevenToNine, TenToTwenty);
		DiscontinuousRange<float> expected = new(FourToFive, NineToTen, TwentyToMax);
		AssertEqual(range1.Subtract(range2), expected);
	}

	/// <summary>
	/// Because NUnit refuses to call ToString()
	/// </summary>
	/// <param name="actual"></param>
	/// <param name="expected"></param>
	private static void AssertEqual<T>(DiscontinuousRange<T> actual, DiscontinuousRange<T> expected) where T : notnull, IComparable<T>, IEquatable<T>
	{
		if (!actual.Equals(expected))
		{
			Assert.Fail($"Expected: {expected}\nBut was: {actual}");
		}
	}
}

```

`Source/AssetRipper.Numerics.Tests/MathTests.cs`:

```cs
namespace AssetRipper.Numerics.Tests;

public class MathTests
{
	[Test]
	public void TestAsVector3ExtensionMethod()
	{
		Vector4 v = new Vector4(1, 2, 3, 4);
		Assert.That(v.AsVector3(), Is.EqualTo(new Vector3(1, 2, 3)));
	}
}

```

`Source/AssetRipper.Numerics.Tests/QuaternionTests.cs`:

```cs
namespace AssetRipper.Numerics.Tests;

public class QuaternionTests
{
	[Test]
	public void ConvertingToQuaternionAndBackGivesTheSameValues()
	{
		//Many sets of values give exactly equal results
		Vector3 euler1 = new Vector3(-67f, 45f, -162f);
		Vector3 converted1 = ConvertEulerToQuaternionAndBackToEuler(euler1);
		Assert.That(converted1, Is.EqualTo(euler1));

		//Some however are only near equal due to rounding errors
		Vector3 euler2 = new Vector3(-67f, 45f, 178f);
		Vector3 converted2 = ConvertEulerToQuaternionAndBackToEuler(euler2);
		Assert.That(euler2.EqualsByDot(converted2));
	}

	private static Vector3 ConvertEulerToQuaternionAndBackToEuler(Vector3 original)
	{
		Quaternion quaternion = original.ToQuaternion(true);
		return quaternion.ToEulerAngle(true);
	}

	[Test]
	public void ToQuaternionCreatesUnitQuaternions()
	{
		Vector3 euler = new Vector3(-67f, 45f, -182f);
		Quaternion quaternion = euler.ToQuaternion(true);
		Assert.That(quaternion.IsUnitQuaternion());
	}
}

```

`Source/AssetRipper.Numerics.Tests/RangeTests.cs`:

```cs
namespace AssetRipper.Numerics.Tests;

public class RangeTests
{
	private static readonly Range<int> ZeroToTen = new Range<int>(0, 10);
	private static readonly Range<int> OneToTen = new Range<int>(1, 10);
	private static readonly Range<int> OneToEleven = new Range<int>(1, 11);
	private static readonly Range<int> ZeroToEleven = new Range<int>(0, 11);
	private static readonly Range<int> TenToTwenty = new Range<int>(10, 20);
	private static readonly Range<int> ZeroToTwenty = new Range<int>(0, 20);

	[Test]
	public void IntersectionTest1()
	{
		Assert.That(OneToTen, Is.EqualTo(ZeroToTen.MakeIntersection(OneToEleven)));
	}

	[Test]
	public void IntersectingUnionTest()
	{
		Assert.That(ZeroToEleven, Is.EqualTo(ZeroToTen.MakeUnion(OneToEleven)));
	}

	[Test]
	public void NonintersectingUnionTest()
	{
		Assert.That(ZeroToTwenty, Is.EqualTo(ZeroToTen.MakeUnion(TenToTwenty)));
	}

	[Test]
	public void ContainsItself()
	{
		Assert.That(ZeroToTen.Contains(ZeroToTen));
	}

	[Test]
	public void ContainsStart()
	{
		Assert.That(ZeroToTen.Contains(0));
	}

	[Test]
	public void ContainsMiddle()
	{
		Assert.That(ZeroToTen.Contains(5));
	}

	[Test]
	public void DoesNotContainEnd()
	{
		Assert.That(!ZeroToTen.Contains(10));
	}

	[Test]
	public void DoesNotContainLess()
	{
		Assert.That(!ZeroToTen.Contains(-10));
	}

	[Test]
	public void DoesNotContainMore()
	{
		Assert.That(!ZeroToTen.Contains(100));
	}

	[Test]
	public void EndBeforeStartThrows()
	{
		Assert.Throws<ArgumentException>(() => new Range<int>(4, 3));
	}

	[Test]
	public void EndEqualsStartThrows()
	{
		Assert.Throws<ArgumentException>(() => new Range<int>(4, 4));
	}

	[Test]
	public void StrictComparisons()
	{
		using (Assert.EnterMultipleScope())
		{
			//Correct
			Assert.That(ZeroToTen.IsStrictlyLess(TenToTwenty));
			Assert.That(TenToTwenty.IsStrictlyGreater(ZeroToTen));

			//Reversed
			Assert.That(!TenToTwenty.IsStrictlyLess(ZeroToTen));
			Assert.That(!ZeroToTen.IsStrictlyGreater(TenToTwenty));

			//Overlapping
			Assert.That(!TenToTwenty.IsStrictlyLess(ZeroToEleven));
			Assert.That(!ZeroToEleven.IsStrictlyLess(TenToTwenty));
			Assert.That(!TenToTwenty.IsStrictlyGreater(ZeroToEleven));
			Assert.That(!ZeroToEleven.IsStrictlyGreater(TenToTwenty));
		}
	}
}

```

`Source/AssetRipper.Numerics.Tests/RelativeDistanceTests.cs`:

```cs
namespace AssetRipper.Numerics.Tests;

public class RelativeDistanceTests
{
	private float[] randomFloats;

	[SetUp]
	public void Setup()
	{
		randomFloats = MakeFloats(60);
	}

	private static float[] MakeFloats(int count)
	{
		float[] result = new float[count];
		for (int i = 0; i < count; i++)
		{
			result[i] = 4 * TestContext.CurrentContext.Random.NextSingle() - 2;//-2 to 2
		}
		return result;
	}

	[Test]
	public void ValuesOfOppositeSignsHaveDistanceOne()
	{
		Assert.That(RelativeDistanceMethods.RelativeDistance(5f, -3f), Is.EqualTo(1f));
	}

	[Test]
	public void EqualValuesHaveDistanceZero()
	{
		using (Assert.EnterMultipleScope())
		{
			foreach (float value in randomFloats)
			{
				AssertEqualZero(value);
			}
		}

		static void AssertEqualZero(float value)
		{
			float distance = RelativeDistanceMethods.RelativeDistance(value, value);
			Assert.That(distance, Is.Zero, () => $"Value {value} did not have zero distance with itself.");
		}
	}

	[Test]
	public void DistanceIsNonnegativeAndSymmetric()
	{
		using (Assert.EnterMultipleScope())
		{
			for (int i = 0; i < randomFloats.Length - 1; i++)
			{
				float value1 = randomFloats[i];
				float value2 = randomFloats[i + 1];
				AssertSymmetry(value1, value2);
			}
		}

		static void AssertSymmetry(float value1, float value2)
		{
			float distanceA = RelativeDistanceMethods.RelativeDistance(value1, value2);
			Assert.That(distanceA, Is.GreaterThanOrEqualTo(0f), () => $"Values {value1} and {value2} had negative distance.");
			float distanceB = RelativeDistanceMethods.RelativeDistance(value2, value1);
			Assert.That(distanceA, Is.EqualTo(distanceB), () => $"Values {value1} and {value2} did not exhibit symmetry.");
		}
	}

	[Test]
	public void TriangleInequalityHolds()
	{
		using (Assert.EnterMultipleScope())
		{
			for (int i = 0; i < randomFloats.Length - 2; i++)
			{
				float value1 = randomFloats[i];
				float value2 = randomFloats[i + 1];
				float value3 = randomFloats[i + 2];
				AssertTriangleInequality(value1, value2, value3);
			}
		}

		static void AssertTriangleInequality(float value1, float value2, float value3)
		{
			float distanceA = RelativeDistanceMethods.RelativeDistance(value1, value2);
			float distanceB = RelativeDistanceMethods.RelativeDistance(value2, value3);
			float distanceC = RelativeDistanceMethods.RelativeDistance(value1, value3);
			Assert.That(distanceA + distanceB, Is.GreaterThanOrEqualTo(distanceC), () => $"Values {value1}, {value2}, and {value3} did not adhere to the triangle inequality.");
		}
	}

	[Test]
	public void DistanceIsTheSameInMultipleDimensions()
	{
		using (Assert.EnterMultipleScope())
		{
			for (int i = 0; i < randomFloats.Length - 1; i++)
			{
				float value1 = randomFloats[i];
				float value2 = randomFloats[i + 1];
				AssertMultipleDimensionEquality(value1, value2);
			}
		}

		static void AssertMultipleDimensionEquality(float value1, float value2)
		{
			float distance1D = RelativeDistanceMethods.RelativeDistance(value1, value2);
			float distance2D = RelativeDistanceMethods.RelativeDistance(new Vector2(value1, 0), new Vector2(value2, 0));
			float distance3D = RelativeDistanceMethods.RelativeDistance(new Vector3(value1, 0, 0), new Vector3(value2, 0, 0));
			float distance4D = RelativeDistanceMethods.RelativeDistance(new Vector4(value1, 0, 0, 0), new Vector4(value2, 0, 0, 0));
			using (Assert.EnterMultipleScope())
			{
				Assert.That(distance2D, Is.EqualTo(distance1D), () => $"Values {value1} and {value2} did not have the same distance in 2 dimensions.");
				Assert.That(distance3D, Is.EqualTo(distance1D), () => $"Values {value1} and {value2} did not have the same distance in 3 dimensions.");
				Assert.That(distance4D, Is.EqualTo(distance1D), () => $"Values {value1} and {value2} did not have the same distance in 4 dimensions.");
			}
		}
	}

	[Test]
	public void ComparingZeroWithItselfIsZero()
	{
		using (Assert.EnterMultipleScope())
		{
			Assert.That(RelativeDistanceMethods.RelativeDistance(0f, 0f), Is.Zero, () => $"1D distance between zero was not zero.");
			Assert.That(RelativeDistanceMethods.RelativeDistance(Vector2.Zero, Vector2.Zero), Is.Zero, () => $"2D distance between zero was not zero.");
			Assert.That(RelativeDistanceMethods.RelativeDistance(Vector3.Zero, Vector3.Zero), Is.Zero, () => $"3D distance between zero was not zero.");
			Assert.That(RelativeDistanceMethods.RelativeDistance(Vector4.Zero, Vector4.Zero), Is.Zero, () => $"4D distance between zero was not zero.");
		}
	}
}

```

`Source/AssetRipper.Numerics.Tests/TransformationTests.cs`:

```cs
namespace AssetRipper.Numerics.Tests;

internal class TransformationTests
{
	[Test]
	public void MoveThenScale()
	{
		Transformation transformation1 = new Transformation(new Vector3(0, .5f, 0), Quaternion.Identity, Vector3.One);
		Transformation transformation2 = new Transformation(Vector3.Zero, Quaternion.Identity, new Vector3(1, 2, 1));
		Transformation expectedResult = new Transformation(new Vector3(0, 1, 0), Quaternion.Identity, new Vector3(1, 2, 1));
		Assert.That(transformation1 * transformation2, Is.EqualTo(expectedResult));
	}

	[Test]
	public void MoveAndRotateThenScale()
	{
		Transformation transformation1 = new Transformation(new Vector3(0, .5f, 0), new Quaternion(0, 0, MathF.Sqrt(2) / 2, MathF.Sqrt(2) / 2), Vector3.One);
		Transformation transformation2 = new Transformation(Vector3.Zero, Quaternion.Identity, new Vector3(1, 2, 1));
		Transformation expectedResult = new Transformation(new Vector3(0, 1, 0), new Quaternion(0, 0, MathF.Sqrt(2) / 2, MathF.Sqrt(2) / 2), new Vector3(2, 1, 1));
		AssertApproximatelyEqual(transformation1 * transformation2, expectedResult, 0.00001f);
		Assert.That(!ApproximatelyEqual(transformation2 * transformation1, expectedResult, 0.00001f));
	}

	[Test]
	public void Identity()
	{
		Transformation actual = new Transformation(Vector3.Zero, Quaternion.Identity, Vector3.One);
		AssertApproximatelyEqual(actual, Transformation.Identity, 0.00001f);
	}

	[Test]
	public void RemoveTranslation()
	{
		Vector3 translation = new Vector3(2, 5, -8);
		Quaternion rotation = Quaternion.CreateFromYawPitchRoll(2, 0.5f, 3);
		Vector3 scale = new Vector3(0.8f, 2, 3);
		Transformation withTranslation = Transformation.Create(translation, rotation, scale);
		Transformation withoutTranslation = Transformation.Create(Vector3.Zero, rotation, scale);
		AssertApproximatelyEqual(withTranslation.RemoveTranslation(), withoutTranslation, 0.00001f);
	}

	[Test]
	public void Inversion()
	{
		Transformation original = new Transformation(new Vector3(2, 5, -8), Quaternion.CreateFromYawPitchRoll(2, 0.5f, 3), new Vector3(0.8f, 2, 3));
		Transformation inverted = original.Invert();
		AssertApproximatelyEqual(original * inverted, Transformation.Identity, 0.00001f);
		AssertApproximatelyEqual(inverted * original, Transformation.Identity, 0.00001f);
	}

	[Test]
	public void InversionFromComponents()
	{
		Vector3 translation = new Vector3(2, 5, -8);
		Quaternion rotation = Quaternion.CreateFromYawPitchRoll(2, 0.5f, 3);
		Vector3 scale = new Vector3(0.8f, 2, 3);
		Transformation original = Transformation.Create(translation, rotation, scale);
		Transformation inverted = Transformation.CreateInverse(translation, rotation, scale);
		AssertApproximatelyEqual(original * inverted, Transformation.Identity, 0.00001f);
		AssertApproximatelyEqual(inverted * original, Transformation.Identity, 0.00001f);
	}

	[Test]
	public void InversionFromComponentsTranslation()
	{
		Vector3 translation = new Vector3(2, 5, -8);
		Quaternion rotation = Quaternion.Identity;
		Vector3 scale = Vector3.One;
		Transformation original = Transformation.Create(translation, rotation, scale);
		Transformation inverted = Transformation.CreateInverse(translation, rotation, scale);
		AssertApproximatelyEqual(original * inverted, Transformation.Identity, 0.00001f);
		AssertApproximatelyEqual(inverted * original, Transformation.Identity, 0.00001f);
	}

	[Test]
	public void InversionFromComponentsRotation()
	{
		Vector3 translation = Vector3.Zero;
		Quaternion rotation = Quaternion.CreateFromYawPitchRoll(2, 0.5f, 3);
		Vector3 scale = Vector3.One;
		Transformation original = Transformation.Create(translation, rotation, scale);
		Transformation inverted = Transformation.CreateInverse(translation, rotation, scale);
		AssertApproximatelyEqual(original * inverted, Transformation.Identity, 0.00001f);
		AssertApproximatelyEqual(inverted * original, Transformation.Identity, 0.00001f);
	}

	[Test]
	public void InversionFromComponentsScale()
	{
		Vector3 translation = Vector3.Zero;
		Quaternion rotation = Quaternion.Identity;
		Vector3 scale = new Vector3(0.8f, 2, 3);
		Transformation original = Transformation.Create(translation, rotation, scale);
		Transformation inverted = Transformation.CreateInverse(translation, rotation, scale);
		AssertApproximatelyEqual(original * inverted, Transformation.Identity, 0.00001f);
		AssertApproximatelyEqual(inverted * original, Transformation.Identity, 0.00001f);
	}

	private static void AssertApproximatelyEqual(Transformation actual, Transformation expected, float maxDeviation)
	{
		AssertApproximatelyEqual(actual.Matrix, expected.Matrix, maxDeviation);
	}

	private static void AssertApproximatelyEqual(Matrix4x4 actual, Matrix4x4 expected, float maxDeviation)
	{
		using (Assert.EnterMultipleScope())
		{
			AssertApproximatelyEqual(actual.M11, expected.M11, maxDeviation, nameof(Matrix4x4.M11));
			AssertApproximatelyEqual(actual.M12, expected.M12, maxDeviation, nameof(Matrix4x4.M12));
			AssertApproximatelyEqual(actual.M13, expected.M13, maxDeviation, nameof(Matrix4x4.M13));
			AssertApproximatelyEqual(actual.M14, expected.M14, maxDeviation, nameof(Matrix4x4.M14));
			AssertApproximatelyEqual(actual.M21, expected.M21, maxDeviation, nameof(Matrix4x4.M21));
			AssertApproximatelyEqual(actual.M22, expected.M22, maxDeviation, nameof(Matrix4x4.M22));
			AssertApproximatelyEqual(actual.M23, expected.M23, maxDeviation, nameof(Matrix4x4.M23));
			AssertApproximatelyEqual(actual.M24, expected.M24, maxDeviation, nameof(Matrix4x4.M24));
			AssertApproximatelyEqual(actual.M31, expected.M31, maxDeviation, nameof(Matrix4x4.M31));
			AssertApproximatelyEqual(actual.M32, expected.M32, maxDeviation, nameof(Matrix4x4.M32));
			AssertApproximatelyEqual(actual.M33, expected.M33, maxDeviation, nameof(Matrix4x4.M33));
			AssertApproximatelyEqual(actual.M34, expected.M34, maxDeviation, nameof(Matrix4x4.M34));
			AssertApproximatelyEqual(actual.M41, expected.M41, maxDeviation, nameof(Matrix4x4.M41));
			AssertApproximatelyEqual(actual.M42, expected.M42, maxDeviation, nameof(Matrix4x4.M42));
			AssertApproximatelyEqual(actual.M43, expected.M43, maxDeviation, nameof(Matrix4x4.M43));
			AssertApproximatelyEqual(actual.M44, expected.M44, maxDeviation, nameof(Matrix4x4.M44));
		}
	}

	private static void AssertApproximatelyEqual(float actual, float expected, float maxDeviation, string name)
	{
		if (ApproximatelyEqual(actual, expected, maxDeviation))
		{
			Assert.Fail($"{name}\nExpected: {expected}\nActual: {actual}");
		}
	}

	private static bool ApproximatelyEqual(Transformation actual, Transformation expected, float maxDeviation)
	{
		return ApproximatelyEqual(actual.Matrix, expected.Matrix, maxDeviation);
	}

	private static bool ApproximatelyEqual(Matrix4x4 actual, Matrix4x4 expected, float maxDeviation)
	{
		return ApproximatelyEqual(actual.M11, expected.M11, maxDeviation)
			&& ApproximatelyEqual(actual.M12, expected.M12, maxDeviation)
			&& ApproximatelyEqual(actual.M13, expected.M13, maxDeviation)
			&& ApproximatelyEqual(actual.M14, expected.M14, maxDeviation)
			&& ApproximatelyEqual(actual.M21, expected.M21, maxDeviation)
			&& ApproximatelyEqual(actual.M22, expected.M22, maxDeviation)
			&& ApproximatelyEqual(actual.M23, expected.M23, maxDeviation)
			&& ApproximatelyEqual(actual.M24, expected.M24, maxDeviation)
			&& ApproximatelyEqual(actual.M31, expected.M31, maxDeviation)
			&& ApproximatelyEqual(actual.M32, expected.M32, maxDeviation)
			&& ApproximatelyEqual(actual.M33, expected.M33, maxDeviation)
			&& ApproximatelyEqual(actual.M34, expected.M34, maxDeviation)
			&& ApproximatelyEqual(actual.M41, expected.M41, maxDeviation)
			&& ApproximatelyEqual(actual.M42, expected.M42, maxDeviation)
			&& ApproximatelyEqual(actual.M43, expected.M43, maxDeviation)
			&& ApproximatelyEqual(actual.M44, expected.M44, maxDeviation);
	}

	private static bool ApproximatelyEqual(float actual, float expected, float maxDeviation)
	{
		return float.Abs(actual - expected) > maxDeviation;
	}

	[Test]
	public void VectorMultiplicationTest()
	{
		//Arrange
		Vector3 vector = new Vector3(2, 4, 6);
		Transformation transformation = new Transformation(
			new Matrix4x4(2, 3, 4, 5,
						 6, 7, 8, 9,
						10, 11, 12, 13,
						14, 15, 16, 17));

		//Act
		Vector3 expected = Vector3.Transform(vector, transformation.Matrix);
		Vector3 actual = vector * transformation;

		//Assert
		Assert.That(actual, Is.EqualTo(expected));
	}

	[Test]
	public void MultiplyTransformationsTest()
	{
		//Arrange
		Transformation t1 = Transformation.Identity;
		Transformation t2 = Transformation.Create(
					new Vector3(5, 5, 5),
					new Quaternion(1, 1, 1, 1),
					new Vector3(2, 2, 2));

		//Act
		Transformation expected = new Transformation(
						new Matrix4x4(-6, 8, 0, 0,
									 0, -6, 8, 0,
									 8, 0, -6, 0,
									 5, 5, 5, 1));
		Transformation actual = t1 * t2;

		//Assert
		Assert.That(actual, Is.EqualTo(expected));
	}

	[Test]
	public void CreateInverseTest()
	{
		//Arrange
		Vector3 translation = new Vector3(1, 2, 3);
		Quaternion rotation = new Quaternion(0.5f, 0.5f, 0.5f, 0.5f);
		Vector3 scale = new Vector3(2, 2, 2);

		//Act
		Transformation transform = Transformation.Create(translation, rotation, scale);
		Transformation inverse = transform.Invert();
		Matrix4x4 expected = Invert(transform.Matrix);
		Matrix4x4 actual = inverse.Matrix;

		//Assert
		Assert.That(actual, Is.EqualTo(expected));

		static Matrix4x4 Invert(Matrix4x4 matrix)
		{
			return Matrix4x4.Invert(matrix, out Matrix4x4 result) ? result : throw new System.Exception("Failed to invert matrix.");
		}
	}

	[Test]
	public void TransposeTest()
	{
		//Arrange
		Matrix4x4 matrix = new Matrix4x4(1, 2, 3, 4,
								   5, 6, 7, 8,
								   9, 10, 11, 12,
								   13, 14, 15, 16);
		Transformation transformation = new Transformation(matrix);

		//Act
		Transformation expected = new Transformation(Matrix4x4.Transpose(matrix));
		Transformation actual = transformation.Transpose();

		//Assert
		Assert.That(actual.Matrix, Is.EqualTo(expected.Matrix));
	}

	[Test]
	public void RemoveTranslationTest()
	{
		//Arrange
		Vector3 translation = new Vector3(1, 2, 3);
		Quaternion rotation = Quaternion.Identity;
		Vector3 scale = new Vector3(2, 2, 2);

		//Act
		Transformation transform = Transformation.Create(translation, rotation, scale);
		Transformation expected = new Transformation(Matrix4x4.CreateScale(scale) * Matrix4x4.CreateFromQuaternion(rotation));
		Transformation actual = transform.RemoveTranslation();

		//Assert
		Assert.That(actual.Matrix, Is.EqualTo(expected.Matrix));
	}

	[Test]
	public void ConvertToMatrixTest()
	{
		//Arrange
		Vector3 translation = new Vector3(1, 2, 3);
		Quaternion rotation = new Quaternion(1, 2, 3, 4);
		Vector3 scale = new Vector3(2, 2, 2);

		//Act
		Transformation expected = Matrix4x4.CreateScale(scale) * Matrix4x4.CreateFromQuaternion(rotation) * Matrix4x4.CreateTranslation(translation);
		Transformation actual = new Transformation(translation, rotation, scale);

		//Assert
		Assert.That(actual, Is.EqualTo(expected));
	}
}

```

`Source/AssetRipper.Numerics.Tests/Usings.cs`:

```cs
global using NUnit.Framework;
global using System.Numerics;

```

`Source/AssetRipper.Numerics/AssetRipper.Numerics.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.Numerics\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Numerics\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

</Project>

```

`Source/AssetRipper.Numerics/BoneWeight1.cs`:

```cs
namespace AssetRipper.Numerics;

public record struct BoneWeight1(float Weight, int Index)
{
}

```

`Source/AssetRipper.Numerics/BoneWeight4.cs`:

```cs
using System.Diagnostics.Contracts;
using System.Runtime.CompilerServices;

namespace AssetRipper.Numerics;

public record struct BoneWeight4
{
	public const int Count = 4;
	public WeightArray Weights;
	public IndexArray Indices;

	public BoneWeight4(float weight0, float weight1, float weight2, float weight3, int index0, int index1, int index2, int index3)
		: this(new WeightArray(weight0, weight1, weight2, weight3), new IndexArray(index0, index1, index2, index3))
	{
	}

	public BoneWeight4(WeightArray weights, IndexArray indices)
	{
		Weights = weights;
		Indices = indices;
	}

	public float Weight0
	{
		readonly get => Weights[0];
		set => Weights[0] = value;
	}

	public float Weight1
	{
		readonly get => Weights[1];
		set => Weights[1] = value;
	}

	public float Weight2
	{
		readonly get => Weights[2];
		set => Weights[2] = value;
	}

	public float Weight3
	{
		readonly get => Weights[3];
		set => Weights[3] = value;
	}

	public int Index0
	{
		readonly get => Indices[0];
		set => Indices[0] = value;
	}

	public int Index1
	{
		readonly get => Indices[1];
		set => Indices[1] = value;
	}

	public int Index2
	{
		readonly get => Indices[2];
		set => Indices[2] = value;
	}

	public int Index3
	{
		readonly get => Indices[3];
		set => Indices[3] = value;
	}

	public readonly bool AnyWeightsNegative => Weight0 < 0f || Weight1 < 0f || Weight2 < 0f || Weight3 < 0f;

	public readonly float Sum => Weight0 + Weight1 + Weight2 + Weight3;

	public readonly bool Normalized => Sum == 1f;

	[Pure]
	public readonly BoneWeight4 NormalizeWeights()
	{
		float sum = Sum;
		if (sum == 0f)
		{
			return new BoneWeight4(.25f, .25f, .25f, .25f, Index0, Index1, Index2, Index3);
		}
		else
		{
			float invSum = 1f / sum;
			return new BoneWeight4(Weight0 * invSum, Weight1 * invSum, Weight2 * invSum, Weight3 * invSum, Index0, Index1, Index2, Index3);
		}
	}

	public override readonly string ToString()
	{
		return $"{nameof(BoneWeight4)}: {{ {nameof(Weights)} = {Weights}, {nameof(Indices)} = {Indices} }}";
	}

	[InlineArray(Count)]
	public struct WeightArray : IEquatable<WeightArray>
	{
		private float _element0;

		public WeightArray(float weight0, float weight1, float weight2, float weight3)
		{
			this[0] = weight0;
			this[1] = weight1;
			this[2] = weight2;
			this[3] = weight3;
		}

		public override readonly bool Equals(object? obj)
		{
			return obj is WeightArray array && Equals(array);
		}

		public readonly bool Equals(WeightArray other)
		{
			return ((ReadOnlySpan<float>)this).SequenceEqual(other);
		}

		public override readonly int GetHashCode()
		{
			return HashCode.Combine(this[0], this[1], this[2], this[3]);
		}

		public static bool operator ==(WeightArray left, WeightArray right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(WeightArray left, WeightArray right)
		{
			return !(left == right);
		}

		public readonly void Deconstruct(out float weight0, out float weight1, out float weight2, out float weight3)
		{
			weight0 = this[0];
			weight1 = this[1];
			weight2 = this[2];
			weight3 = this[3];
		}

		public override readonly string ToString()
		{
			return $"[{this[0]}, {this[1]}, {this[2]}, {this[3]}]";
		}
	}

	[InlineArray(Count)]
	public struct IndexArray : IEquatable<IndexArray>
	{
		private int _element0;

		public IndexArray(int index0, int index1, int index2, int index3)
		{
			this[0] = index0;
			this[1] = index1;
			this[2] = index2;
			this[3] = index3;
		}

		public override readonly bool Equals(object? obj)
		{
			return obj is IndexArray array && Equals(array);
		}

		public readonly bool Equals(IndexArray other)
		{
			return ((ReadOnlySpan<int>)this).SequenceEqual(other);
		}

		public override readonly int GetHashCode()
		{
			return HashCode.Combine(this[0], this[1], this[2], this[3]);
		}

		public static bool operator ==(IndexArray left, IndexArray right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(IndexArray left, IndexArray right)
		{
			return !(left == right);
		}

		public readonly void Deconstruct(out int index0, out int index1, out int index2, out int index3)
		{
			index0 = this[0];
			index1 = this[1];
			index2 = this[2];
			index3 = this[3];
		}

		public override readonly string ToString()
		{
			return $"[{this[0]}, {this[1]}, {this[2]}, {this[3]}]";
		}
	}
}

```

`Source/AssetRipper.Numerics/Color32.cs`:

```cs
using System.Drawing;
using System.Runtime.CompilerServices;

namespace AssetRipper.Numerics;

/// <summary>
/// A struct that represents a color with 32 bits.
/// </summary>
public readonly record struct Color32(byte R, byte G, byte B, byte A)
{
	private const float ByteMaxValue = byte.MaxValue;

	/// <summary>
	/// Gets the color represented as a 32 bit unsigned integer.
	/// </summary>
	public uint Rgba
	{
		get
		{
			Color32 color = this;
			return Unsafe.As<Color32, uint>(ref color);
		}
	}

	/// <summary>
	/// Converts a 32 bit unsigned integer into a color.
	/// </summary>
	/// <param name="rgba">The value to convert</param>
	/// <returns>The resulting color.</returns>
	public static Color32 FromRgba(uint rgba)
	{
		return Unsafe.As<uint, Color32>(ref rgba);
	}

	/// <summary>
	/// Converts the color to a floating-point representation.
	/// </summary>
	/// <param name="color">The color to convert.</param>
	public static explicit operator ColorFloat(Color32 color)
	{
		return new ColorFloat(color.R / ByteMaxValue, color.G / ByteMaxValue, color.B / ByteMaxValue, color.A / ByteMaxValue);
	}

	/// <summary>
	/// Converts the floating-point representation to a color.
	/// </summary>
	/// <param name="color">The floating-point representation to convert.</param>
	public static explicit operator Color32(ColorFloat color)
	{
		byte r = ConvertFloatToByte(color.R);
		byte g = ConvertFloatToByte(color.G);
		byte b = ConvertFloatToByte(color.B);
		byte a = ConvertFloatToByte(color.A);
		return new Color32(r, g, b, a);
	}

	public static explicit operator Color(Color32 color)
	{
		int argb = (color.A << 24) | (color.R << 16) | (color.G << 8) | color.B;
		return Color.FromArgb(argb);
	}

	private static byte ConvertFloatToByte(float value)
	{
		if (float.IsNaN(value))
		{
			return byte.MinValue;
		}

		float scaledValue = value * byte.MaxValue;
		if (scaledValue <= 0)
		{
			return byte.MinValue;
		}
		else if (scaledValue >= byte.MaxValue)
		{
			return byte.MaxValue;
		}
		else
		{
			return (byte)scaledValue;
		}
	}

	/// <summary>
	/// Gets the color black.
	/// </summary>
	public static Color32 Black => new Color32(byte.MinValue, byte.MinValue, byte.MinValue, byte.MaxValue);

	/// <summary>
	/// Gets the color white.
	/// </summary>
	public static Color32 White => new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);

	/// <summary>
	/// Gets the string representation of the color.
	/// </summary>
	/// <returns>The string representation of the color.</returns>
	public override string ToString()
	{
		return $"[R:{R} G:{G} B:{B} A:{A}]";
	}
}

```

`Source/AssetRipper.Numerics/ColorFloat.cs`:

```cs
namespace AssetRipper.Numerics;

/// <summary>
/// Represents an RGBA color value as four single precision floating point values.
/// </summary>
public readonly record struct ColorFloat(Vector4 Vector)
{
	/// <summary>
	/// Initializes a new instance of the <see cref="ColorFloat"/> struct with RGBA values.
	/// </summary>
	/// <param name="R">The red value, between 0 and 1.</param>
	/// <param name="G">The green value, between 0 and 1.</param>
	/// <param name="B">The blue value, between 0 and 1.</param>
	/// <param name="A">The alpha value, between 0 and 1.</param>
	public ColorFloat(float R, float G, float B, float A) : this(new Vector4(R, G, B, A)) { }

	/// <summary>
	/// Gets the red value, between 0 and 1.
	/// </summary>
	public float R => Vector.X;

	/// <summary>
	/// Gets the green value, between 0 and 1.
	/// </summary>
	public float G => Vector.Y;

	/// <summary>
	/// Gets the blue value, between 0 and 1.
	/// </summary>
	public float B => Vector.Z;

	/// <summary>
	/// Gets the alpha value, between 0 and 1.
	/// </summary>
	public float A => Vector.W;

	/// <summary>
	/// Clamps the color values of the color within the range of 0 to 1 and returns the resulting color.
	/// </summary>
	/// <returns>A new instance of <see cref="ColorFloat"/> with clamped color values.</returns>
	public ColorFloat Clamp()
	{
		return new ColorFloat(
			Math.Min(Math.Max(R, 0), 1),
			Math.Min(Math.Max(G, 0), 1),
			Math.Min(Math.Max(B, 0), 1),
			Math.Min(Math.Max(A, 0), 1)
		);
	}

	/// <summary>
	/// Adds two <see cref="ColorFloat"/> values and returns the resulting color.
	/// </summary>
	/// <param name="a">The first color to add.</param>
	/// <param name="b">The second color to add.</param>
	/// <returns>A new instance of <see cref="ColorFloat"/> that is the result of adding the two input colors.</returns>
	public static ColorFloat operator +(ColorFloat a, ColorFloat b)
	{
		return new ColorFloat(a.Vector + b.Vector);
	}

	/// <summary>
	/// Subtracts two <see cref="ColorFloat"/> values and returns the resulting color.
	/// </summary>
	/// <param name="a">The color to subtract from.</param>
	/// <param name="b">The color to subtract.</param>
	/// <returns>A new instance of <see cref="ColorFloat"/> that is the result of subtracting the second color from the first color.</returns>
	public static ColorFloat operator -(ColorFloat a, ColorFloat b)
	{
		return new ColorFloat(a.Vector - b.Vector);
	}

	/// <summary>
	/// Multiplies a <see cref="ColorFloat"/> values by a scalar and returns the resulting color.
	/// </summary>
	/// <param name="a">The color to multiply.</param>
	/// <param name="b">The scalar value to multiply the color by.</param>
	/// <returns>A new instance of <see cref="ColorFloat"/> that is the result of multiplying the color with the scalar value.</returns>
	public static ColorFloat operator *(ColorFloat a, float b)
	{
		return new ColorFloat(a.Vector * b);
	}

	/// <summary>
	/// Multiplies a <see cref="ColorFloat"/> values by a scalar and returns the resulting color.
	/// </summary>
	/// <param name="b">The scalar value to multiply the color by.</param>
	/// <param name="a">The color to multiply.</param>
	/// <returns>A new instance of <see cref="ColorFloat"/> that is the result of multiplying the color with the scalar value.</returns>
	public static ColorFloat operator *(float b, ColorFloat a)
	{
		return new ColorFloat(a.Vector * b);
	}

	/// <summary>
	/// Divides a <see cref="ColorFloat"/> values by a scalar and returns the resulting color.
	/// </summary>
	/// <param name="a">The color to divide.</param>
	/// <param name="b">The scalar value to divide the color by.</param>
	/// <returns>A new instance of <see cref="ColorFloat"/> that is the result of dividing the color with the scalar value.</returns>
	public static ColorFloat operator /(ColorFloat a, float b)
	{
		return new ColorFloat(a.Vector / b);
	}

	/// <summary>
	/// Gets a pre-defined color with RGBA values of (0, 0, 0, 1).
	/// </summary>
	public static ColorFloat Black => new ColorFloat(0, 0, 0, 1);

	/// <summary>
	/// Gets a pre-defined color with RGBA values of (1, 1, 1, 1).
	/// </summary>
	public static ColorFloat White => new ColorFloat(1, 1, 1, 1);

	/// <inheritdoc/>
	public override string ToString()
	{
		return $"[R:{R:0.00} G:{G:0.00} B:{B:0.00} A:{A:0.00}]";
	}
}

```

`Source/AssetRipper.Numerics/DiscontinuousRange.cs`:

```cs
using System.Collections;
using System.Text;

namespace AssetRipper.Numerics;

/// <summary>
/// An immutable structure representing a discontinuous, possibly empty, range of objects.
/// </summary>
/// <typeparam name="T"></typeparam>
public readonly struct DiscontinuousRange<T> : IEquatable<DiscontinuousRange<T>>, IEquatable<Range<T>>, IReadOnlyList<Range<T>>
	where T : notnull, IComparable<T>, IEquatable<T>
{
	private static readonly List<Range<T>> defaultRangeList = new List<Range<T>>(0);
	private readonly List<Range<T>> rangeList;

	public static DiscontinuousRange<T> Empty { get; } = new();

	public DiscontinuousRange()
	{
		rangeList = defaultRangeList;
	}

	public DiscontinuousRange(Range<T> range)
	{
		rangeList = new List<Range<T>>(1) { range };
	}

	public DiscontinuousRange(IEnumerable<Range<T>> ranges)
	{
		rangeList = new();
		Add(ranges);
		if (rangeList.Count == 0)
		{
			rangeList = defaultRangeList;
		}
	}

	public DiscontinuousRange(IReadOnlyList<Range<T>> ranges)
	{
		if (ranges.Count == 0)
		{
			rangeList = defaultRangeList;
		}
		else
		{
			rangeList = new List<Range<T>>(ranges.Count);
			Add(ranges);
		}
	}

	public DiscontinuousRange(params Range<T>[] ranges)
	{
		rangeList = new List<Range<T>>(ranges.Length);
		Add(ranges);
	}

	/// <summary>
	/// Used only for internal creations of the range list.
	/// </summary>
	/// <param name="ranges"></param>
	private DiscontinuousRange(List<Range<T>> rangeList)
	{
		this.rangeList = rangeList;
	}

	/// <summary>
	/// Constructor for the union of two ranges.
	/// </summary>
	/// <param name="range1"></param>
	/// <param name="range2"></param>
	public DiscontinuousRange(DiscontinuousRange<T> range1, DiscontinuousRange<T> range2)
	{
		if (range1.Count == 0)
		{
			rangeList = range2.rangeList;//prevent unnecessary allocation of an additional list
		}
		else if (range2.Count == 0)
		{
			rangeList = range1.rangeList;//prevent unnecessary allocation of an additional list
		}
		else
		{
			rangeList = new List<Range<T>>(range1.Count);
			rangeList.AddRange(range1.rangeList);//Copy the elements of range1
			Add(range2.rangeList);//Add the elements of range2
		}
	}

	public int Count => rangeList.Count;

	public Range<T> this[int index] => rangeList[index];

	public override bool Equals(object? obj)
	{
		return obj is Range<T> range && Equals(range)
			|| obj is DiscontinuousRange<T> discontinuousRange && Equals(discontinuousRange);
	}

	public bool Equals(Range<T> other)
	{
		return Count == 1 && this[0] == other;
	}

	public bool Equals(DiscontinuousRange<T> other)
	{
		if (Count != other.Count)
		{
			return false;
		}

		for (int i = 0; i < rangeList.Count; i++)
		{
			if (!this[i].Equals(other[i]))
			{
				return false;
			}
		}

		return true;
	}

	public bool Contains(T point)
	{
		return rangeList.Any(r => r.Contains(point));
	}

	public bool Contains(Range<T> range)
	{
		return rangeList.Any(r => r.Contains(range));
	}

	public bool Contains(DiscontinuousRange<T> other)
	{
		foreach (Range<T> range in other.rangeList)
		{
			if (!Contains(range))
			{
				return false;
			}
		}
		return true;
	}

	public bool Intersects(Range<T> range)
	{
		return rangeList.Any(r => r.Intersects(range));
	}

	public bool Intersects(DiscontinuousRange<T> other)
	{
		int i = 0;
		int j = 0;
		while (i < Count && j < other.Count)
		{
			Range<T> thisRange = this[i];
			Range<T> otherRange = other[j];
			if (thisRange.Intersects(otherRange))
			{
				return true;
			}
			else if (thisRange.IsStrictlyLess(otherRange))
			{
				i++;
			}
			else//otherRange is strictly less than thisRange
			{
				j++;
			}
		}
		return false;
	}

	public override int GetHashCode()
	{
		HashCode hc = new();
		for (int i = Count - 1; i >= 0; i--)
		{
			hc.Add(this[i]);
		}
		return hc.ToHashCode();
	}

	/// <summary>
	/// Only used during initialization
	/// </summary>
	/// <param name="range"></param>
	private void Add(Range<T> range)
	{
		int firstUnionIndex = Count;
		int lastUnionIndex = Count;
		for (int i = 0; i < Count; i++)
		{
			if (this[i].CanUnion(range))
			{
				if (firstUnionIndex == Count)
				{
					firstUnionIndex = i;
				}
				lastUnionIndex = i;
			}
			else if (firstUnionIndex < Count)
			{
				break;
			}
			else if (rangeList[i].IsStrictlyGreater(range))
			{
				rangeList.Insert(i, range);
				return;
			}
		}

		if (firstUnionIndex == Count)
		{
			rangeList.Add(range);
		}
		else
		{
			rangeList[firstUnionIndex] = rangeList[firstUnionIndex].MakeUnion(range);
			if (firstUnionIndex < lastUnionIndex)
			{
				rangeList.RemoveRange(firstUnionIndex + 1, lastUnionIndex - firstUnionIndex);
			}
		}
	}

	/// <summary>
	/// Only used during initialization
	/// </summary>
	/// <param name="ranges"></param>
	private void Add(IEnumerable<Range<T>> ranges)
	{
		foreach (Range<T> range in ranges)
		{
			Add(range);
		}
	}

	/// <summary>
	/// Only used during initialization
	/// </summary>
	/// <param name="ranges"></param>
	private void Add(Range<T>[] ranges)
	{
		for (int i = 0; i < ranges.Length; i++)
		{
			Add(ranges[i]);
		}
	}

	/// <summary>
	/// This range contains no points and is equal to the <see cref="Empty"/> range.
	/// </summary>
	/// <returns></returns>
	public bool IsEmpty() => Count == 0;

	/// <summary>
	/// This range is continuous.
	/// </summary>
	/// <remarks>
	/// The <see cref="Empty"/> range is treated as not continuous.
	/// </remarks>
	/// <returns></returns>
	public bool IsContinuous() => Count == 1;

	/// <summary>
	/// This range is continuous.
	/// </summary>
	/// <remarks>
	/// The <see cref="Empty"/> range is treated as not continuous.
	/// </remarks>
	/// <param name="range"></param>
	/// <returns></returns>
	public bool IsContinuous(out Range<T> range)
	{
		if (Count == 1)
		{
			range = this[0];
			return true;
		}
		else
		{
			range = default;
			return false;
		}
	}

	public DiscontinuousRange<T> Negate(T minimum, T maximum)
	{
		if (IsEmpty())
		{
			return new DiscontinuousRange<T>(new Range<T>(minimum, maximum));
		}
		else
		{
			List<Range<T>> newRangeList = new List<Range<T>>(Count + 1);//Count + 1 is the maximum possible size of this list.

			T start = rangeList[0].Start;
			if (!start.Equals(minimum))
			{
				newRangeList.Add(new Range<T>(minimum, start));
			}

			for (int i = 0; i < Count - 1; i++)
			{
				newRangeList.Add(new Range<T>(rangeList[i].End, rangeList[i].Start));
			}

			T end = rangeList[Count - 1].End;
			if (!end.Equals(maximum))
			{
				newRangeList.Add(new Range<T>(end, maximum));
			}

			return new DiscontinuousRange<T>(newRangeList);
		}
	}

	public IEnumerator<Range<T>> GetEnumerator() => rangeList.GetEnumerator();

	IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

	public static bool operator ==(DiscontinuousRange<T> left, DiscontinuousRange<T> right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(DiscontinuousRange<T> left, DiscontinuousRange<T> right)
	{
		return !(left == right);
	}

	public static implicit operator DiscontinuousRange<T>(Range<T> range) => new DiscontinuousRange<T>(range);

	public static explicit operator Range<T>(DiscontinuousRange<T> range)
	{
		return range.IsContinuous(out Range<T> continuousRange)
			? continuousRange
			: throw new ArgumentException($"{nameof(range)} is not continuous.", nameof(range));
	}

	public static DiscontinuousRange<T> Union(DiscontinuousRange<T> range1, DiscontinuousRange<T> range2)
	{
		return new DiscontinuousRange<T>(range1, range2);
	}

	public DiscontinuousRange<T> Union(DiscontinuousRange<T> other)
	{
		return new DiscontinuousRange<T>(this, other);
	}

	public static DiscontinuousRange<T> Intersect(DiscontinuousRange<T> range1, DiscontinuousRange<T> range2)
	{
		return range1.Intersect(range2);
	}

	public DiscontinuousRange<T> Intersect(DiscontinuousRange<T> other)
	{
		List<Range<T>> ranges = new();
		int i = 0;
		int j = 0;
		while (i < Count && j < other.Count)
		{
			Range<T> thisRange = this[i];
			Range<T> otherRange = other[j];
			if (thisRange.Intersects(otherRange, out Range<T> intersection))
			{
				ranges.Add(intersection);
				if (thisRange.End.CompareTo(otherRange.End) <= 0)
				{
					i++;
				}
				else
				{
					j++;
				}
			}
			else if (thisRange.IsStrictlyLess(otherRange))
			{
				i++;
			}
			else//otherRange is strictly less than thisRange
			{
				j++;
			}
		}
		return new DiscontinuousRange<T>(ranges);
	}

	public DiscontinuousRange<T> Subtract(DiscontinuousRange<T> other)
	{
		List<Range<T>> ranges = new();
		int i = 0;
		int j = 0;
		bool endedInside = false;
		T? nextStartingPoint = default;
		while (i < Count && j < other.Count)
		{
			Range<T> thisRange = this[i];
			Range<T> otherRange = other[j];
			if (thisRange.IsStrictlyLess(otherRange))
			{
				if (endedInside)
				{
					ranges.Add(new Range<T>(nextStartingPoint!, thisRange.End));
					endedInside = false;
					nextStartingPoint = default;
				}
				i++;
			}
			else if (thisRange.IsStrictlyGreater(otherRange))
			{
				j++;
			}
			else
			{
				if (thisRange.Start.IsLess(otherRange.Start))
				{
					if (endedInside)
					{
						ranges.Add(new Range<T>(nextStartingPoint!, otherRange.Start));
						endedInside = false;
						nextStartingPoint = default;
					}
					else
					{
						ranges.Add(new Range<T>(thisRange.Start, otherRange.Start));
					}
				}
				if (thisRange.End.IsLessEqual(otherRange.End))
				{
					i++;
				}
				else
				{
					if (j < other.Count - 1)
					{
						endedInside = true;
						nextStartingPoint = otherRange.End;
					}
					else
					{
						ranges.Add(new Range<T>(otherRange.End, thisRange.End));
					}
					j++;
				}
			}
		}
		return new DiscontinuousRange<T>(ranges);
	}

	public override string ToString()
	{
		if (Count == 0)
		{
			return "Empty";
		}
		else
		{
			StringBuilder sb = new();
			sb.Append(this[0]);
			for (int i = 1; i < Count; i++)
			{
				sb.Append(", ");
				sb.Append(this[i]);
			}
			return sb.ToString();
		}
	}
}

```

`Source/AssetRipper.Numerics/GeometricMath.cs`:

```cs
namespace AssetRipper.Numerics;

public static class GeometricMath
{
	private const float kEpsilon = 0.00001F;

	/// <summary>
	/// Angle increase when 2nd line is moving in clockwise direction
	/// </summary>
	/// <returns>Angle in degrees</returns>
	public static float AngleFrom3Points(Vector2 point1, Vector2 point2, Vector2 point3)
	{
		float transformedP1X = point1.X - point2.X;
		float transformedP1Y = point1.Y - point2.Y;
		float transformedP2X = point3.X - point2.X;
		float transformedP2Y = point3.Y - point2.Y;

		double angleToP1 = Math.Atan2(transformedP1Y, transformedP1X);
		double angleToP2 = Math.Atan2(transformedP2Y, transformedP2X);

		double angle = angleToP1 - angleToP2;
		if (angle < 0)
		{
			angle += 2 * Math.PI;
		}

		return (float)(360.0 * angle / (2.0 * Math.PI));
	}
}

```

`Source/AssetRipper.Numerics/IComparableExtensions.cs`:

```cs
namespace AssetRipper.Numerics;

internal static class IComparableExtensions
{
	public static bool IsLess<T>(this T left, T right) where T : IComparable<T>
	{
		return left.CompareTo(right) < 0;
	}

	public static bool IsLessEqual<T>(this T left, T right) where T : IComparable<T>
	{
		return left.CompareTo(right) <= 0;
	}

	public static bool IsGreater<T>(this T left, T right) where T : IComparable<T>
	{
		return left.CompareTo(right) > 0;
	}

	public static bool IsGreaterEqual<T>(this T left, T right) where T : IComparable<T>
	{
		return left.CompareTo(right) >= 0;
	}
}

```

`Source/AssetRipper.Numerics/QuaternionExtensions.cs`:

```cs
namespace AssetRipper.Numerics;

/// <summary>
/// Provides extension methods for the Quaternion struct.
/// </summary>
public static class QuaternionExtensions
{
	/// <summary>
	/// Returns the value of the specified index of the Quaternion.
	/// </summary>
	/// <param name="quaternion">The Quaternion instance.</param>
	/// <param name="index">The index of the Quaternion.</param>
	/// <returns>The value of the specified index of the Quaternion.</returns>
	public static float GetAt(this Quaternion quaternion, int index)
	{
		return index switch
		{
			0 => quaternion.X,
			1 => quaternion.Y,
			2 => quaternion.Z,
			3 => quaternion.W,
			_ => throw new IndexOutOfRangeException($"Index {index} is out of bound"),
		};
	}

	/// <summary>
	/// Sets the value of the specified index of the Quaternion.
	/// </summary>
	/// <param name="quaternion">The Quaternion instance.</param>
	/// <param name="index">The index of the Quaternion.</param>
	/// <param name="value">The value to be set.</param>
	public static void SetAt(this ref Quaternion quaternion, int index, float value)
	{
		switch (index)
		{
			case 0:
				quaternion.X = value;
				return;
			case 1:
				quaternion.Y = value;
				return;
			case 2:
				quaternion.Z = value;
				return;
			case 3:
				quaternion.W = value;
				return;
			default:
				throw new IndexOutOfRangeException($"Index {index} is out of bound");
		}
	}

	/// <summary>
	/// Flips the sign of the value of the specified index of the Quaternion.
	/// </summary>
	/// <param name="quaternion">The Quaternion instance.</param>
	/// <param name="index">The index of the Quaternion.</param>
	public static void FlipSignAt(this ref Quaternion quaternion, int index)
	{
		switch (index)
		{
			case 0:
				quaternion.X = -quaternion.X;
				return;
			case 1:
				quaternion.Y = -quaternion.Y;
				return;
			case 2:
				quaternion.Z = -quaternion.Z;
				return;
			case 3:
				quaternion.W = -quaternion.W;
				return;
			default:
				throw new IndexOutOfRangeException($"Index {index} is out of bound");
		}
	}

	/// <summary>
	/// Converts a quaternion to Euler angles.
	/// </summary>
	/// <param name="quaternion">The Quaternion instance.</param>
	/// <param name="asDegrees">
	/// If true, the Euler angles will be in degrees. If false, radians are used.
	/// </param>
	/// <returns>
	/// A Vector3 containing the Euler angles of the Quaternion.
	/// </returns>
	public static Vector3 ToEulerAngle(this Quaternion quaternion, bool asDegrees)
	{
		double eax;
		double eay;
		double eaz;

		float qx = quaternion.X;
		float qy = -quaternion.Y;
		float qz = -quaternion.Z;
		float qw = quaternion.W;

		double[,] M = new double[4, 4];

		double Nq = (qx * qx) + (qy * qy) + (qz * qz) + (qw * qw);
		double s = Nq > 0.0 ? 2.0 / Nq : 0.0;
		double xs = qx * s, ys = qy * s, zs = qz * s;
		double wx = qw * xs, wy = qw * ys, wz = qw * zs;
		double xx = qx * xs, xy = qx * ys, xz = qx * zs;
		double yy = qy * ys, yz = qy * zs, zz = qz * zs;

		M[0, 0] = 1.0 - (yy + zz); M[0, 1] = xy - wz; M[0, 2] = xz + wy;
		M[1, 0] = xy + wz; M[1, 1] = 1.0 - (xx + zz); M[1, 2] = yz - wx;
		M[2, 0] = xz - wy; M[2, 1] = yz + wx; M[2, 2] = 1.0 - (xx + yy);
		M[3, 0] = M[3, 1] = M[3, 2] = M[0, 3] = M[1, 3] = M[2, 3] = 0.0; M[3, 3] = 1.0;

		double test = Math.Sqrt((M[0, 0] * M[0, 0]) + (M[1, 0] * M[1, 0]));
		if (test > 16 * 1.19209290E-07F)//FLT_EPSILON
		{
			eax = Math.Atan2(M[2, 1], M[2, 2]);
			eay = Math.Atan2(-M[2, 0], test);
			eaz = Math.Atan2(M[1, 0], M[0, 0]);
		}
		else
		{
			eax = Math.Atan2(-M[1, 2], M[1, 1]);
			eay = Math.Atan2(-M[2, 0], test);
			eaz = 0;
		}

		return new()
		{
			X = GetAngle(eax, asDegrees),
			Y = GetAngle(eay, asDegrees),
			Z = GetAngle(eaz, asDegrees),
		};
	}

	private static float GetAngle(double radians, bool convertToDegrees)
	{
		return (float)(convertToDegrees ? RadiansToDegrees(radians) : radians);
	}

	private static double RadiansToDegrees(double radians)
	{
		return radians * 180.0 / Math.PI;
	}

	/// <summary>
	/// Returns the dot product of two Quaternions.
	/// </summary>
	/// <param name="a">The first Quaternion.</param>
	/// <param name="b">The second Quaternion.</param>
	/// <returns>The dot product of two Quaternions.</returns>
	public static double Dot(this Quaternion a, Quaternion b)
	{
		return ((double)a.X * b.X) + ((double)a.Y * b.Y) + ((double)a.Z * b.Z) + ((double)a.W * b.W);
	}

	/// <summary>
	/// Returns a value indicating if this Quaternion is an unit quaternion.
	/// </summary>
	/// <param name="a">The Quaternion instance.</param>
	/// <returns>
	/// True if this Quaternion is an unit quaternion.
	/// </returns>
	public static bool IsUnitQuaternion(this Quaternion a)
	{
		return ((a.X * a.X) + (a.Y * a.Y) + (a.Z * a.Z) + (a.W * a.W)) > 1d - kEpsilon;
	}

	/// <summary>
	/// Returns a value indicating if this Quaternion is the zero Quaternion.
	/// </summary>
	/// <param name="a">The Quaternion instance.</param>
	/// <returns>True if this Quaternion is the zero Quaternion.</returns>
	public static bool IsZero(this Quaternion a)
	{
		return a.X == 0 && a.Y == 0 && a.Z == 0 && a.W == 0;
	}

	/// <summary>
	/// Returns a value indicating if this Quaternion is nearly equal to another using dot product.
	/// </summary>
	/// <param name="a">The first Quaternion.</param>
	/// <param name="b">The second Quaternion.</param>
	/// <returns>True if they are nearly equal.</returns>
	public static bool EqualsByDot(this Quaternion a, Quaternion b)
	{
		return a.Dot(b) > 1.0f - kEpsilon;
	}

	private const float kEpsilon = 0.00001F;
}

```

`Source/AssetRipper.Numerics/Range.cs`:

```cs
namespace AssetRipper.Numerics;

public readonly struct Range<T> : IEquatable<Range<T>> where T : notnull, IComparable<T>, IEquatable<T>
{
	/// <summary>
	/// Represents the inclusive start of the Range.
	/// </summary>
	public T Start { get; }

	/// <summary>
	/// Represents the exclusive end of the Range.
	/// </summary>
	/// <remarks>
	/// This must be greater than <see cref="Start"/>.
	/// </remarks>
	public T End { get; }

	public Range(T start, T end)
	{
		if (start.IsGreaterEqual(end))
		{
			throw new ArgumentException($"{nameof(start)} {start} must be less than {nameof(end)} {end}");
		}

		Start = start;
		End = end;
	}

	public bool Contains(T value)
	{
		return Start.IsLessEqual(value) && End.IsGreater(value);
	}

	public bool Contains(Range<T> range)
	{
		return Start.IsLessEqual(range.Start) && End.IsGreaterEqual(range.End);
	}

	public bool IsStrictlyLess(Range<T> other)
	{
		return End.IsLessEqual(other.Start);
	}

	public bool IsStrictlyGreater(Range<T> other)
	{
		return Start.IsGreaterEqual(other.End);
	}

	public bool Intersects(Range<T> other)
	{
		return Contains(other.Start) || other.Contains(Start);
	}

	public bool Intersects(Range<T> other, out Range<T> intersection)
	{
		if (Intersects(other))
		{
			intersection = MakeIntersectionInternal(other);
			return true;
		}
		else
		{
			intersection = default;
			return false;
		}
	}

	public bool CanUnion(Range<T> other)
	{
		return Intersects(other) || Start.Equals(other.End) || End.Equals(other.Start);
	}

	public bool CanUnion(Range<T> other, out Range<T> union)
	{
		if (CanUnion(other))
		{
			union = MakeUnionInternal(other);
			return true;
		}
		else
		{
			union = default;
			return false;
		}
	}

	public Range<T> MakeUnion(Range<T> other)
	{
		return CanUnion(other)
			? MakeUnionInternal(other)
			: throw new ArgumentException("These ranges cannot be unioned", nameof(other));
	}

	private Range<T> MakeUnionInternal(Range<T> other)
	{
		return new Range<T>(Minimum(Start, other.Start), Maximum(End, other.End));
	}

	public Range<T> MakeIntersection(Range<T> other)
	{
		return Intersects(other)
			? MakeIntersectionInternal(other)
			: throw new ArgumentException("These ranges do not intersect", nameof(other));
	}

	private Range<T> MakeIntersectionInternal(Range<T> other)
	{
		return new Range<T>(Maximum(Start, other.Start), Minimum(End, other.End));
	}

	private static T Minimum(T left, T right)
	{
		return left.IsLess(right) ? left : right;
	}

	private static T Maximum(T left, T right)
	{
		return left.IsGreater(right) ? left : right;
	}

	public override bool Equals(object? obj)
	{
		return obj is Range<T> range && Equals(range);
	}

	public bool Equals(Range<T> other)
	{
		return Start.Equals(other.Start) && End.Equals(other.End);
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(Start, End);
	}

	public static bool operator ==(Range<T> left, Range<T> right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(Range<T> left, Range<T> right)
	{
		return !(left == right);
	}

	public override string ToString()
	{
		return $"{Start} : {End}";
	}
}

```

`Source/AssetRipper.Numerics/RectangleFExtensions.cs`:

```cs
using System.Drawing;

namespace AssetRipper.Numerics;

public static class RectangleFExtensions
{
	public static Vector2 Size(this RectangleF rectangle)
	{
		return rectangle.Size.ToVector2();
	}
}

```

`Source/AssetRipper.Numerics/RelativeDistanceMethods.cs`:

```cs
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace AssetRipper.Numerics;

/// <summary>
/// A collection of methods calculating the relative distance between two points.
/// All methods return a <see langword="float"/> between 0 and 1 (inclusive).
/// 0 indicates equality and 1 indicates great distance
/// For the array methods, the return value is an average of the relative distances for the individual points.
/// </summary>
public static class RelativeDistanceMethods
{
	[MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
	public static float RelativeDistance(float x1, float x2)
	{
		return x1 == x2 ? 0 : MathF.Abs(x1 - x2) / (MathF.Abs(x1) + MathF.Abs(x2));
	}

	//between zero and positive infinity
	public static float RelativeDistance2(float x1, float x2)
	{
		float ratio = (x1 - x2) / (x1 + x2);
		return ratio * ratio;
	}

	public static float RelativeDistance(Vector2 v1, Vector2 v2)
	{
		return v1 == v2 ? 0 : Vector2.Distance(v1, v2) / (v1.Length() + v2.Length());
	}

	public static float RelativeDistance2(Vector2 v1, Vector2 v2)
	{
		return Vector2.DistanceSquared(v1, v2) / (v1 + v2).LengthSquared();
	}

	public static float RelativeDistance(Vector3 v1, Vector3 v2)
	{
		return v1 == v2 ? 0 : Vector3.Distance(v1, v2) / (v1.Length() + v2.Length());
	}

	public static float RelativeDistance(Vector4 v1, Vector4 v2)
	{
		return v1 == v2 ? 0 : Vector4.Distance(v1, v2) / (v1.Length() + v2.Length());
	}

	public static void RelativeDistance(float[] x1, float[] x2, out float sum, out int count)
	{
		Debug.Assert(x1.Length == x2.Length);
		sum = 0;
		for (int i = 0; i < x1.Length; i++)
		{
			sum += RelativeDistance(x1[i], x2[i]);
		}
		count = x1.Length;
	}

	public static void RelativeDistance(Vector2[] v1, Vector2[] v2, out float sum, out int count)
	{
		Debug.Assert(v1.Length == v2.Length);
		sum = 0;
		for (int i = 0; i < v1.Length; i++)
		{
			sum += RelativeDistance(v1[i], v2[i]);
		}
		count = v1.Length;
	}

	public static void RelativeDistance(Vector3[] v1, Vector3[] v2, out float sum, out int count)
	{
		Debug.Assert(v1.Length == v2.Length);
		sum = 0;
		for (int i = 0; i < v1.Length; i++)
		{
			sum += RelativeDistance(v1[i], v2[i]);
		}
		count = v1.Length;
	}

	public static void RelativeDistance(Vector4[] v1, Vector4[] v2, out float sum, out int count)
	{
		Debug.Assert(v1.Length == v2.Length);
		sum = 0;
		for (int i = 0; i < v1.Length; i++)
		{
			sum += RelativeDistance(v1[i], v2[i]);
		}
		count = v1.Length;
	}

	public static void RelativeDistance(ColorFloat[] v1, ColorFloat[] v2, out float sum, out int count)
	{
		Debug.Assert(v1.Length == v2.Length);
		sum = 0;
		for (int i = 0; i < v1.Length; i++)
		{
			sum += RelativeDistance(v1[i], v2[i]);
		}
		count = v1.Length;
	}

	public static float RelativeDistance(ColorFloat v1, ColorFloat v2)
	{
		return RelativeDistance(v1.Vector, v2.Vector);
	}

	public static void RelativeDistance(BoneWeight4[] v1, BoneWeight4[] v2, out float sum, out int count)
	{
		Debug.Assert(v1.Length == v2.Length);
		sum = 0;
		for (int i = 0; i < v1.Length; i++)
		{
			sum += RelativeDistance(v1[i], v2[i]);
		}
		count = v1.Length;
	}

	public static float RelativeDistance(BoneWeight4 v1, BoneWeight4 v2)
	{
		return (RelativeDistance(v1.Weight0, v2.Weight0)
			+ RelativeDistance(v1.Weight1, v2.Weight1)
			+ RelativeDistance(v1.Weight2, v2.Weight2)
			+ RelativeDistance(v1.Weight3, v2.Weight3)) / 4;
	}

	public static void RelativeDistance(Matrix4x4[] v1, Matrix4x4[] v2, out float sum, out int count)
	{
		Debug.Assert(v1.Length == v2.Length);
		sum = 0;
		for (int i = 0; i < v1.Length; i++)
		{
			sum += RelativeDistance(v1[i], v2[i]);
		}
		count = v1.Length;
	}

	public static float RelativeDistance(Matrix4x4 v1, Matrix4x4 v2)
	{
		return (RelativeDistance(v1.M11, v2.M11)
			+ RelativeDistance(v1.M12, v2.M12)
			+ RelativeDistance(v1.M13, v2.M13)
			+ RelativeDistance(v1.M14, v2.M14)
			+ RelativeDistance(v1.M21, v2.M21)
			+ RelativeDistance(v1.M22, v2.M22)
			+ RelativeDistance(v1.M23, v2.M23)
			+ RelativeDistance(v1.M24, v2.M24)
			+ RelativeDistance(v1.M31, v2.M31)
			+ RelativeDistance(v1.M32, v2.M32)
			+ RelativeDistance(v1.M33, v2.M33)
			+ RelativeDistance(v1.M34, v2.M34)
			+ RelativeDistance(v1.M41, v2.M41)
			+ RelativeDistance(v1.M42, v2.M42)
			+ RelativeDistance(v1.M43, v2.M43)
			+ RelativeDistance(v1.M44, v2.M44)) / 16;
	}
}

```

`Source/AssetRipper.Numerics/Transformation.cs`:

```cs
namespace AssetRipper.Numerics;

/// <summary>
/// Represents a transformation composed of a translation, rotation, and scale
/// </summary>
public readonly record struct Transformation(Matrix4x4 Matrix)
{
	/// <summary>
	/// Initializes a new instance of the <see cref="Transformation"/> class with the provided translation, rotation, and scale
	/// </summary>
	/// <param name="translation">The translation component of the transformation</param>
	/// <param name="rotation">The rotation component of the transformation</param>
	/// <param name="scale">The scale component of the transformation</param>
	public Transformation(Vector3 translation, Quaternion rotation, Vector3 scale) : this(ConvertToMatrix(translation, rotation, scale)) { }

	/// <summary>
	/// Gets an <see cref="Identity"/> transformation that does nothing
	/// </summary>
	public static Transformation Identity { get; } = new Transformation(Matrix4x4.Identity);

	/// <summary>
	/// Gets an <see cref="Identity"/> transformation that switches coordinates from left-handedness to right-handedness
	/// </summary>
	/// <remarks>
	/// This is useful when converting coordinates from Unity to Gltf
	/// </remarks>
	public static Transformation IdentityWithInvertedX { get; } = new Transformation(new Matrix4x4(-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));

	/// <summary>
	/// Transforms a position vector by the transformation matrix
	/// </summary>
	/// <param name="position">The position vector to transform</param>
	/// <param name="transform">The transformation to apply</param>
	/// <returns>The transformed vector</returns>
	public static Vector3 operator *(Vector3 position, Transformation transform)
	{
		return Vector3.Transform(position, transform.Matrix);
	}

	/// <summary>
	/// Composes two transformations
	/// </summary>
	/// <param name="left">The first transformation to compose</param>
	/// <param name="right">The second transformation to compose</param>
	/// <returns>The composed transformation</returns>
	public static Transformation operator *(Transformation left, Transformation right)
	{
		return new Transformation(left.Matrix * right.Matrix);
	}

	/// <summary>
	/// Implicitly converts a <see cref="Transformation"/> to a <see cref="Matrix4x4"/>
	/// </summary>
	/// <param name="transformation">The transformation to convert</param>
	public static implicit operator Matrix4x4(Transformation transformation)
	{
		return transformation.Matrix;
	}

	/// <summary>
	/// Implicitly converts a <see cref="Matrix4x4"/> to a <see cref="Transformation"/>
	/// </summary>
	/// <param name="matrix">The matrix to convert</param>
	public static implicit operator Transformation(Matrix4x4 matrix)
	{
		return new Transformation(matrix);
	}

	/// <summary>
	/// Creates a new <see cref="Transformation"/> with the provided translation, rotation, and scale
	/// </summary>
	/// <param name="translation">The translation component of the transformation</param>
	/// <param name="rotation">The rotation component of the transformation</param>
	/// <param name="scale">The scale component of the transformation</param>
	public static Transformation Create(Vector3 translation, Quaternion rotation, Vector3 scale)
	{
		return new Transformation(translation, rotation, scale);
	}

	private static Matrix4x4 ConvertToMatrix(Vector3 translation, Quaternion rotation, Vector3 scale)
	{
		return Matrix4x4.CreateScale(scale) * Matrix4x4.CreateFromQuaternion(rotation) * Matrix4x4.CreateTranslation(translation);
	}

	/// <summary>
	/// Creates a new <see cref="Transformation"/> with the inverse of the provided translation, rotation, and scale
	/// </summary>
	/// <param name="translation">The translation component of the transformation</param>
	/// <param name="rotation">The rotation component of the transformation</param>
	/// <param name="scale">The scale component of the transformation</param>
	public static Transformation CreateInverse(Vector3 translation, Quaternion rotation, Vector3 scale)
	{
		Vector3 inverseTranslation = Vector3.Negate(translation);
		Quaternion inverseRotation = InvertQuaternion(rotation);
		Vector3 inverseScale = Vector3.One / scale;
		Matrix4x4 matrix = Matrix4x4.CreateTranslation(inverseTranslation) * Matrix4x4.CreateFromQuaternion(inverseRotation) * Matrix4x4.CreateScale(inverseScale);
		return new Transformation(matrix);
	}

	private static Quaternion InvertQuaternion(Quaternion rotation)
	{
		if (rotation.IsZero())
		{
			return Quaternion.Identity;
		}
		else
		{
			return Quaternion.Inverse(rotation);
		}
	}

	/// <summary>
	/// Inverts the transformation
	/// </summary>
	/// <returns>The inverted transformation</returns>
	public Transformation Invert()
	{
		if (Matrix4x4.Invert(Matrix, out Matrix4x4 inverted))
		{
			return new Transformation(inverted);
		}
		else
		{
			throw new Exception("Could not invert matrix");
		}
	}

	/// <summary>
	/// Transposes the transformation
	/// </summary>
	/// <returns>The transposed transformation</returns>
	public Transformation Transpose()
	{
		return new Transformation(Matrix4x4.Transpose(Matrix));
	}

	/// <summary>
	/// Removes the translation component of the transformation
	/// </summary>
	/// <returns>The transformed vector</returns>
	public Transformation RemoveTranslation()
	{
		return new Transformation(ResetFourthRow(Matrix));
	}

	private static Matrix4x4 ResetFourthRow(Matrix4x4 matrix)
	{
		return new Matrix4x4(
			matrix.M11, matrix.M12, matrix.M13, matrix.M14,
			matrix.M21, matrix.M22, matrix.M23, matrix.M24,
			matrix.M31, matrix.M32, matrix.M33, matrix.M34,
			0, 0, 0, 1);
	}

	public override string ToString() => Matrix.ToString();
}

```

`Source/AssetRipper.Numerics/Usings.cs`:

```cs
global using System;
global using System.Numerics;

```

`Source/AssetRipper.Numerics/Vector2i.cs`:

```cs
namespace AssetRipper.Numerics;

public struct Vector2i : IEquatable<Vector2i>
{
	public int X;
	public int Y;

	public Vector2i()
	{
		X = 0;
		Y = 0;
	}

	public Vector2i(int x, int y)
	{
		X = x;
		Y = y;
	}

	public override string ToString()
	{
		return $"[{X}, {Y}]";
	}

	public override bool Equals(object? obj)
	{
		return obj is Vector2i i && Equals(i);
	}

	public bool Equals(Vector2i other)
	{
		return X == other.X && Y == other.Y;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(X, Y);
	}

	public static bool operator ==(Vector2i left, Vector2i right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(Vector2i left, Vector2i right)
	{
		return !(left == right);
	}
}

```

`Source/AssetRipper.Numerics/Vector3Extensions.cs`:

```cs
namespace AssetRipper.Numerics;

public static class Vector3Extensions
{
	public static Quaternion ToQuaternion(this Vector3 source, bool isDegrees)
	{
		// Abbreviations for the various angular functions
		double cy = Math.Cos(GetRadians(source.Z, isDegrees) * 0.5);
		double sy = Math.Sin(GetRadians(source.Z, isDegrees) * 0.5);
		double cp = Math.Cos(GetRadians(source.Y, isDegrees) * 0.5);
		double sp = Math.Sin(GetRadians(source.Y, isDegrees) * 0.5);
		double cr = Math.Cos(GetRadians(source.X, isDegrees) * 0.5);
		double sr = Math.Sin(GetRadians(source.X, isDegrees) * 0.5);

		return new()
		{
			W = -(float)((cr * cp * cy) + (sr * sp * sy)),
			X = -(float)((sr * cp * cy) - (cr * sp * sy)),
			Y = (float)((cr * sp * cy) + (sr * cp * sy)),
			Z = (float)((cr * cp * sy) - (sr * sp * cy)),
		};
	}

	private static double GetRadians(double angle, bool isDegrees)
	{
		return isDegrees ? (angle * Math.PI / 180.0) : angle;
	}

	public static void Normalize(this Vector3 instance)
	{
		float length = instance.Length();
		if (length > kEpsilon)
		{
			instance.X /= length;
			instance.Y /= length;
			instance.Z /= length;
		}
		else
		{
			instance.X = 0;
			instance.Y = 0;
			instance.Z = 0;
		}
	}

	public static float Dot(this Vector3 instance, Vector3 other)
	{
		return (instance.X * other.X) + (instance.Y * other.Y) + (instance.Z * other.Z);
	}

	public static bool EqualsByDot(this Vector3 instance, Vector3 other)
	{
		float instanceLength = instance.Length();
		float otherLength = other.Length();

		if (instanceLength < kEpsilon)
		{
			return otherLength < kEpsilon;
		}

		if (otherLength < kEpsilon)
		{
			return false;
		}

		float dot = instance.Dot(other);
		float deviation = 1f - (dot / instanceLength / otherLength);
		return deviation < kEpsilon;
	}

	private const float kEpsilon = 0.00001F;
}

```

`Source/AssetRipper.Numerics/Vector3i.cs`:

```cs
namespace AssetRipper.Numerics;

public struct Vector3i : IEquatable<Vector3i>
{
	public int X;
	public int Y;
	public int Z;

	public Vector3i(int x, int y, int z)
	{
		X = x;
		Y = y;
		Z = z;
	}

	public int GetValueByMember(int member)
	{
		member %= 3;
		if (member == 0)
		{
			return X;
		}

		if (member == 1)
		{
			return Y;
		}

		return Z;
	}

	public int GetMemberByValue(int value)
	{
		if (X == value)
		{
			return 0;
		}

		if (Y == value)
		{
			return 1;
		}

		if (Z == value)
		{
			return 2;
		}

		throw new ArgumentException($"Member with value {value} wasn't found");
	}

	public bool ContainsValue(int value)
	{
		if (X == value || Y == value || Z == value)
		{
			return true;
		}

		return false;
	}

	public override string ToString()
	{
		return $"[{X}, {Y}, {Z}]";
	}

	public override bool Equals(object? obj)
	{
		return obj is Vector3i i && Equals(i);
	}

	public bool Equals(Vector3i other)
	{
		return X == other.X && Y == other.Y && Z == other.Z;
	}

	public static bool operator ==(Vector3i left, Vector3i right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(Vector3i left, Vector3i right)
	{
		return !(left == right);
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(X, Y, Z);
	}

	public static Vector3i Zero => default;
}

```

`Source/AssetRipper.Numerics/VectorExtensions.cs`:

```cs
namespace AssetRipper.Numerics;

public static class VectorExtensions
{
	public static Vector3 InvertX(this Vector3 vector)
	{
		return new Vector3(-vector.X, vector.Y, vector.Z);
	}
}

```

`Source/AssetRipper.Processing.SourceGenerator/AssetRipper.Processing.SourceGenerator.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>netstandard2.0</TargetFramework>
		<IsAotCompatible>false</IsAotCompatible>
		<AppendTargetFrameworkToOutputPath>true</AppendTargetFrameworkToOutputPath>
		<EnforceExtendedAnalyzerRules>true</EnforceExtendedAnalyzerRules>
		<PolySharpExcludeGeneratedTypes>System.Runtime.CompilerServices.ModuleInitializerAttribute</PolySharpExcludeGeneratedTypes>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="4.14.0">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
		<PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="5.0.0" />
		<PackageReference Include="PolySharp" Version="1.15.0">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
		<PackageReference Include="SourceGenerator.Foundations" Version="2.0.14" />
	</ItemGroup>

	<ItemGroup>
		<!-- Generator dependencies -->
		<PackageReference Include="AssetRipper.Text.SourceGeneration" Version="1.2.3" PrivateAssets="all" GeneratePathProperty="true" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Processing.SourceGenerator/PolyfillGenerator.cs`:

```cs
using AssetRipper.Text.SourceGeneration;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using SGF;
using System.CodeDom.Compiler;
using System.Text;

namespace AssetRipper.Processing.SourceGenerator;

[IncrementalGenerator]
public class PolyfillGenerator() : IncrementalGenerator(nameof(PolyfillGenerator))
{
	public override void OnInitialize(SgfInitializationContext context)
	{
		context.RegisterPostInitializationOutput(static (context) =>
		{
			byte[] assemblyBytes = CompilePolyfills();
			string code = GenerateCode(assemblyBytes);
			context.AddSource("EmbeddedAssembly.cs", code);
		});
	}

	private static string GenerateCode(byte[] assemblyBytes)
	{
		StringWriter stringWriter = new() { NewLine = "\n" };
		using IndentedTextWriter writer = IndentedTextWriterFactory.Create(stringWriter);

		writer.WriteGeneratedCodeWarning();
		writer.WriteLineNoTabs();
		writer.WriteFileScopedNamespace("AssetRipper.Processing.Assemblies");
		writer.WriteLineNoTabs();
		writer.WriteLine("static partial class EmbeddedAssembly");
		using (new CurlyBrackets(writer))
		{
			writer.WriteLine("private static readonly byte[] Bytes = new byte[]");
			using (new CurlyBracketsWithSemicolon(writer))
			{
				foreach (byte b in assemblyBytes)
				{
					writer.WriteLine(b.ToString() + ",");
				}
			}
		}

		return stringWriter.ToString();
	}

	private static byte[] CompilePolyfills()
	{
		List<SyntaxTree> syntaxTrees = [];

		foreach (string code in Polyfills.Get())
		{
			AddCode(syntaxTrees, code);
		}

		using MemoryStream polyfillOutputStream = new();

		// Emit compiled assembly into MemoryStream
		CSharpCompilation compilation = CreateCompilation(syntaxTrees, []);
		EmitResult result = compilation.Emit(polyfillOutputStream);
		return result.Success ? polyfillOutputStream.ToArray() : [];
	}

	private static void AddCode(List<SyntaxTree> syntaxTrees, string code)
	{
		SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(code, encoding: Encoding.UTF8);
		syntaxTrees.Add(syntaxTree);
	}

	private static CSharpCompilation CreateCompilation(IEnumerable<SyntaxTree> syntaxTrees, IEnumerable<MetadataReference> references)
	{
		// Define compilation options
		CSharpCompilationOptions compilationOptions = new(OutputKind.DynamicallyLinkedLibrary);

		// Create the compilation
		CSharpCompilation compilation = CSharpCompilation.Create(
			"System.Polyfill",
			syntaxTrees,
			references,
			compilationOptions
		);
		return compilation;
	}
}

```

`Source/AssetRipper.Processing.SourceGenerator/Polyfills.cs`:

```cs
namespace AssetRipper.Processing.SourceGenerator;

/// <summary>
/// Contains source files for the polyfill assembly.
/// Some are hand-written, and others are copied from the .NET runtime.
/// </summary>
/// <remarks>
/// <seealso href="https://source.dot.net/"/>
/// </remarks>
internal static class Polyfills
{
	public static IEnumerable<string> Get() =>
	[
		Object,
		ValueType,
		Enum,
		Type,
		SByte,
		Byte,
		Int16,
		UInt16,
		Int32,
		UInt32,
		Int64,
		UInt64,
		Single,
		Double,
		Void,
		Boolean,
		Char,
		String,
		Attribute,
		AttributeTargets,
		AttributeUsageAttribute,
		FlagsAttribute,
		AssemblyVersionAttribute,
		MethodImplAttributes,
		MethodCodeType,
		MethodImplOptions,
		MethodImplAttribute,
		TypeForwardedToAttribute,
		IsUnmanagedAttribute,
	];

	private const string Object = """
		namespace System
		{
			public class Object
			{
				public virtual string? ToString() => null;
				public virtual bool Equals(object? obj) => false;
				public virtual int GetHashCode() => 0;
				public Type GetType() => null;
			}
		}
		""";

	private const string ValueType = """
		namespace System
		{
			public abstract class ValueType
			{
			}
		}
		""";

	private const string Enum = """
		namespace System
		{
			public abstract class Enum : ValueType
			{
			}
		}
		""";

	private const string Type = """
		namespace System
		{
			public class Type
			{
				//public static Type GetTypeFromHandle(RuntimeTypeHandle handle) => null;
			}
		}
		""";

	private const string SByte = """
		namespace System
		{
			public readonly struct SByte
			{
				private readonly sbyte m_value;
			}
		}
		""";

	private const string Byte = """
		namespace System
		{
			public readonly struct Byte
			{
				private readonly byte m_value;
			}
		}
		""";

	private const string Int16 = """
		namespace System
		{
			public readonly struct Int16
			{
				private readonly short m_value;
			}
		}
		""";

	private const string UInt16 = """
		namespace System
		{
			public readonly struct UInt16
			{
				private readonly ushort m_value;
			}
		}
		""";

	private const string Int32 = """
		namespace System
		{
			public readonly struct Int32
			{
				private readonly int m_value;
			}
		}
		""";

	private const string UInt32 = """
		namespace System
		{
			public readonly struct UInt32
			{
				private readonly int m_value;
			}
		}
		""";

	private const string Int64 = """
		namespace System
		{
			public readonly struct Int64
			{
				private readonly long m_value;
			}
		}
		""";

	private const string UInt64 = """
		namespace System
		{
			public readonly struct UInt64
			{
				private readonly ulong m_value;
			}
		}
		""";

	private const string Single = """
		namespace System
		{
			public readonly struct Single
			{
				private readonly float m_value;
			}
		}
		""";

	private const string Double = """
		namespace System
		{
			public readonly struct Double
			{
				private readonly double m_value;
			}
		}
		""";

	private const string Void = """
		namespace System
		{
			public readonly struct Void
			{
			}
		}
		""";

	private const string Boolean = """
		namespace System
		{
			public readonly struct Boolean
			{
				private readonly bool m_value;
			}
		}
		""";

	private const string Char = """
		namespace System
		{
			public readonly struct Char
			{
				private readonly char m_value;
			}
		}
		""";

	private const string String = """
		namespace System
		{
			public sealed class String
			{
			}
		}
		""";

	private const string Attribute = """
		namespace System
		{
			public abstract class Attribute
			{
			}
		}
		""";

	private const string AttributeTargets = """
		// Licensed to the .NET Foundation under one or more agreements.
		// The .NET Foundation licenses this file to you under the MIT license.

		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////

		namespace System
		{
			// Enum used to indicate all the elements of the
			// VOS it is valid to attach this element to.
			[Flags]
			public enum AttributeTargets
			{
				Assembly = 0x0001,
				Module = 0x0002,
				Class = 0x0004,
				Struct = 0x0008,
				Enum = 0x0010,
				Constructor = 0x0020,
				Method = 0x0040,
				Property = 0x0080,
				Field = 0x0100,
				Event = 0x0200,
				Interface = 0x0400,
				Parameter = 0x0800,
				Delegate = 0x1000,
				ReturnValue = 0x2000,
				GenericParameter = 0x4000,

				All = Assembly | Module | Class | Struct | Enum | Constructor |
								Method | Property | Field | Event | Interface | Parameter |
								Delegate | ReturnValue | GenericParameter
			}
		}
		""";

	private const string AttributeUsageAttribute = """
		// Licensed to the .NET Foundation under one or more agreements.
		// The .NET Foundation licenses this file to you under the MIT license.

		namespace System
		{
			/// <summary>
			/// Specifies the usage of another attribute class.
			/// </summary>
			[AttributeUsage(AttributeTargets.Class, Inherited = true)]
			public sealed class AttributeUsageAttribute : Attribute
			{
				private readonly AttributeTargets _attributeTarget;
				private bool _allowMultiple;
				private bool _inherited;

				internal static readonly AttributeUsageAttribute Default = new AttributeUsageAttribute(AttributeTargets.All);

				public AttributeUsageAttribute(AttributeTargets validOn)
				{
					_attributeTarget = validOn;
					_inherited = true;
				}

				internal AttributeUsageAttribute(AttributeTargets validOn, bool allowMultiple, bool inherited)
				{
					_attributeTarget = validOn;
					_allowMultiple = allowMultiple;
					_inherited = inherited;
				}

				public AttributeTargets ValidOn => _attributeTarget;

				public bool AllowMultiple
				{
					get => _allowMultiple;
					set => _allowMultiple = value;
				}

				public bool Inherited
				{
					get => _inherited;
					set => _inherited = value;
				}
			}
		}
		""";

	private const string FlagsAttribute = """
		// Licensed to the .NET Foundation under one or more agreements.
		// The .NET Foundation licenses this file to you under the MIT license.

		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////

		namespace System
		{
			// Custom attribute to indicate that the enum
			// should be treated as a bitfield (or set of flags).
			// An IDE may use this information to provide a richer
			// development experience.
			[AttributeUsage(AttributeTargets.Enum, Inherited = false)]
			public class FlagsAttribute : Attribute
			{
				public FlagsAttribute()
				{
				}
			}
		}
		""";

	private const string AssemblyVersionAttribute = """
		// Licensed to the .NET Foundation under one or more agreements.
		// The .NET Foundation licenses this file to you under the MIT license.

		namespace System.Reflection
		{
			[AttributeUsage(AttributeTargets.Assembly, Inherited = false)]
			public sealed class AssemblyVersionAttribute : Attribute
			{
				public AssemblyVersionAttribute(string version)
				{
					Version = version;
				}

				public string Version { get; }
			}
		}
		""";

	private const string MethodImplAttributes = """
		// Licensed to the .NET Foundation under one or more agreements.
		// The .NET Foundation licenses this file to you under the MIT license.

		namespace System.Reflection
		{
			// This Enum matches the CorMethodImpl defined in CorHdr.h
			public enum MethodImplAttributes
			{
				// code impl mask
				CodeTypeMask = 0x0003,   // Flags about code type.
				IL = 0x0000,   // Method impl is IL.
				Native = 0x0001,   // Method impl is native.
				OPTIL = 0x0002,   // Method impl is OPTIL
				Runtime = 0x0003,   // Method impl is provided by the runtime.
									// end code impl mask

				// managed mask
				ManagedMask = 0x0004,   // Flags specifying whether the code is managed or unmanaged.
				Unmanaged = 0x0004,   // Method impl is unmanaged, otherwise managed.
				Managed = 0x0000,   // Method impl is managed.
									// end managed mask

				// implementation info and interop
				ForwardRef = 0x0010,   // Indicates method is not defined; used primarily in merge scenarios.
				PreserveSig = 0x0080,   // Indicates method sig is exported exactly as declared.

				InternalCall = 0x1000,   // Internal Call...

				Synchronized = 0x0020,   // Method is single threaded through the body.
				NoInlining = 0x0008,   // Method may not be inlined.
				AggressiveInlining = 0x0100,   // Method should be inlined if possible.
				NoOptimization = 0x0040,   // Method may not be optimized.
				AggressiveOptimization = 0x0200, // Method may contain hot code and should be aggressively optimized.

				MaxMethodImplVal = 0xffff,
			}
		}
		""";

	private const string MethodCodeType = """
		// Licensed to the .NET Foundation under one or more agreements.
		// The .NET Foundation licenses this file to you under the MIT license.

		using System.Reflection;

		namespace System.Runtime.CompilerServices
		{
			public enum MethodCodeType
			{
				IL = MethodImplAttributes.IL,
				Native = MethodImplAttributes.Native,
				OPTIL = MethodImplAttributes.OPTIL,
				Runtime = MethodImplAttributes.Runtime
			}
		}
		""";

	private const string MethodImplOptions = """
		// Licensed to the .NET Foundation under one or more agreements.
		// The .NET Foundation licenses this file to you under the MIT license.

		namespace System.Runtime.CompilerServices
		{
			// This Enum matches the miImpl flags defined in corhdr.h. It is used to specify
			// certain method properties.
			[Flags]
			public enum MethodImplOptions
			{
				Unmanaged = 0x0004,
				NoInlining = 0x0008,
				ForwardRef = 0x0010,
				Synchronized = 0x0020,
				NoOptimization = 0x0040,
				PreserveSig = 0x0080,
				AggressiveInlining = 0x0100,
				AggressiveOptimization = 0x0200,
				InternalCall = 0x1000
			}
		}
		""";

	private const string MethodImplAttribute = """
		// Licensed to the .NET Foundation under one or more agreements.
		// The .NET Foundation licenses this file to you under the MIT license.

		namespace System.Runtime.CompilerServices
		{
			// Custom attribute to specify additional method properties.
			[AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor, Inherited = false)]
			public sealed class MethodImplAttribute : Attribute
			{
				public MethodCodeType MethodCodeType;

				public MethodImplAttribute(MethodImplOptions methodImplOptions)
				{
					Value = methodImplOptions;
				}

				public MethodImplAttribute(short value)
				{
					Value = (MethodImplOptions)value;
				}

				public MethodImplAttribute()
				{
				}

				public MethodImplOptions Value { get; }
			}
		}
		""";

	private const string TypeForwardedToAttribute = """
		// Licensed to the .NET Foundation under one or more agreements.
		// The .NET Foundation licenses this file to you under the MIT license.

		namespace System.Runtime.CompilerServices
		{
			[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)]
			public sealed class TypeForwardedToAttribute : Attribute
			{
				public TypeForwardedToAttribute(Type destination)
				{
					Destination = destination;
				}

				public Type Destination { get; }
			}
		}
		""";

	/// <summary>
	/// Modified version of the IsUnmanagedAttribute from the .NET runtime.
	/// References to System.ComponentModel have been removed because they're in System.dll instead of mscorlib.
	/// </summary>
	private const string IsUnmanagedAttribute = """
		// Licensed to the .NET Foundation under one or more agreements.
		// The .NET Foundation licenses this file to you under the MIT license.

		//using System.ComponentModel;

		namespace System.Runtime.CompilerServices
		{
			/// <summary>
			/// Reserved for use by a compiler for tracking metadata.
			/// This attribute should not be used by developers in source code.
			/// </summary>
			//[EditorBrowsable(EditorBrowsableState.Never)]
			[AttributeUsage(AttributeTargets.All)]
			public sealed class IsUnmanagedAttribute : Attribute
			{
				/// <summary>Initializes the attribute.</summary>
				public IsUnmanagedAttribute()
				{
				}
			}
		}
		""";
}

```

`Source/AssetRipper.Processing/AnimationClips/AnimationClipConverter.CurveData.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated;

namespace AssetRipper.Processing.AnimationClips;

public partial struct AnimationClipConverter
{
	private readonly record struct CurveData(string Path, string Attribute, ClassIDType ClassID, IUnityObjectBase? Script = null)
	{
	}
}

```

`Source/AssetRipper.Processing/AnimationClips/AnimationClipConverter.cs`:

```cs
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Generics;
using AssetRipper.Checksum;
using AssetRipper.IO.Endian;
using AssetRipper.Processing.AnimationClips.Editor;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip;
using AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.GenericBinding;
using AssetRipper.SourceGenerated.Extensions.Enums.Keyframe.TangentMode;
using AssetRipper.SourceGenerated.Subclasses.AnimationClipBindingConstant;
using AssetRipper.SourceGenerated.Subclasses.Clip;
using AssetRipper.SourceGenerated.Subclasses.ConstantClip;
using AssetRipper.SourceGenerated.Subclasses.DenseClip;
using AssetRipper.SourceGenerated.Subclasses.FloatCurve;
using AssetRipper.SourceGenerated.Subclasses.GenericBinding;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Quaternionf;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Single;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Vector3f;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Object;
using AssetRipper.SourceGenerated.Subclasses.PPtrCurve;
using AssetRipper.SourceGenerated.Subclasses.PPtrKeyframe;
using AssetRipper.SourceGenerated.Subclasses.QuaternionCurve;
using AssetRipper.SourceGenerated.Subclasses.StreamedClip;
using AssetRipper.SourceGenerated.Subclasses.Vector3Curve;
using System.Buffers;
using System.Buffers.Binary;
using System.Runtime.InteropServices;

namespace AssetRipper.Processing.AnimationClips;

public readonly partial struct AnimationClipConverter
{
	private AnimationClipConverter(IAnimationClip clip, PathChecksumCache checksumCache)
	{
		m_clip = clip;
		m_customCurveResolver = new CustomCurveResolver(clip);
		m_checksumCache = checksumCache;
	}

	public static void Process(IAnimationClip clip, PathChecksumCache checksumCache)
	{
		AnimationClipConverter converter = new(clip, checksumCache);
		converter.ProcessInner();
	}

	private void ProcessInner()
	{
		if (m_clip.Has_ClipBindingConstant_C74())
		{
			IClip clip = m_clip.MuscleClip_C74.Clip.Data;

			IReadOnlyList<StreamedFrame> streamedFrames = GenerateFramesFromStreamedClip(clip.StreamedClip);
			ProcessStreams(streamedFrames);

			int streamedCurveCount = clip.StreamedClip.CurveCount();
			ProcessDenses(clip.DenseClip, streamedCurveCount);

			if (clip.Has_ConstantClip())
			{
				int preConstantCurves = streamedCurveCount + (int)clip.DenseClip.CurveCount;
				float lastConstantTime = CalculateLastConstantTime(streamedFrames, m_clip.MuscleClip_C74.StopTime);
				ProcessConstant(clip.ConstantClip, preConstantCurves, lastConstantTime);
			}

			m_clip.MuscleClipInfo_C74.Initialize(m_clip.MuscleClip_C74);
		}
	}

	private void ProcessStreams(IReadOnlyList<StreamedFrame> streamedFrames)
	{
		Span<float> curveValues = [0, 0, 0, 0];
		Span<float> inSlopeValues = [0, 0, 0, 0];
		Span<float> outSlopeValues = [0, 0, 0, 0];
		bool UseNegInfSlopes = m_clip.SupportsNegativeInfinitySlopes();

		if (streamedFrames.Count > 1)
		{
			streamedFrames[0].Time = 0f; // fix first frame for PPtrCurves to have Time=0 instead of float.MinValue
		}
		int frameCount = streamedFrames.Count - 1; // last StreamedFrame is dummy so must be skipped
		for (int frameIdx = 0; frameIdx < frameCount; frameIdx++)
		{
			// last real frame doesn't need outSlope calculation, and will have inSlope from previous iteration
			bool doSlopeCalc = frameIdx != frameCount - 1;

			StreamedFrame frame = streamedFrames[frameIdx];
			for (int curveIdx = 0; curveIdx < frame.Curves.Length;)
			{
				int curveID = frame.Curves[curveIdx].Index;
				IGenericBinding binding = GetBinding(curveID);
				string path = GetCurvePath(binding.Path);
				StreamedCurveKey curve;
				if (binding.IsTransform())
				{
					int transformDim = binding.TransformType().GetDimension();
					if (frameIdx == 0) // first StreamedFrame only contains PPtrCurves, skip
					{
						curveIdx += transformDim;
						continue;
					}
					for (int offset = 0; offset < transformDim; offset++)
					{
						curve = frame.Curves[curveIdx];
						if (doSlopeCalc)
						{
							if (TryGetNextFrame(streamedFrames, frameIdx, curveID, out StreamedFrame? nextFrame, out int nextCurveIdx))
							{
								StreamedCurveKey nextCurve = nextFrame.Curves[nextCurveIdx + offset];
								curve.CalculateSlopes(frame.Time, nextFrame.Time, nextCurve, UseNegInfSlopes);
							}
						}
						curveValues[offset] = curve.Value;
						inSlopeValues[offset] = curve.InSlope;
						outSlopeValues[offset] = curve.OutSlope;
						curveIdx++;
					}
					AddTransformCurve(frame.Time, binding, curveValues, inSlopeValues, outSlopeValues, 0, path);
					continue;
				}
				curve = frame.Curves[curveIdx];
				if (!binding.IsPPtrCurve()) // Skip slope calculation for PPtrCurves
				{
					if (frameIdx == 0) // first StreamedFrame only contains PPtrCurves, skip
					{
						curveIdx++;
						continue;
					}
					if (doSlopeCalc)
					{
						if (TryGetNextFrame(streamedFrames, frameIdx, curveID, out StreamedFrame? nextFrame, out int nextCurveIdx))
						{
							StreamedCurveKey nextCurve = nextFrame.Curves[nextCurveIdx];
							curve.CalculateSlopes(frame.Time, nextFrame.Time, nextCurve, UseNegInfSlopes);
						}
					}
				}
				if (binding.CustomType == (byte)BindingCustomType.None)
				{
					AddDefaultCurve(binding, path, frame.Time, curve.Value, curve.InSlope, curve.OutSlope);
				}
				else
				{
					AddCustomCurve(binding, path, frame.Time, curve.Value, curve.InSlope, curve.OutSlope);
				}
				curveIdx++;
			}
		}
	}

	private void ProcessDenses(DenseClip dense, int preDenseCurves)
	{
		ReadOnlySpan<float> slopeValues = [0, 0, 0, 0]; // no slopes - 0 values

		float[] rentedArray = ArrayPool<float>.Shared.Rent(dense.SampleArray.Count);
		dense.SampleArray.CopyTo(rentedArray);
		ReadOnlySpan<float> curveValues = new(rentedArray, 0, dense.SampleArray.Count);

		for (int frameIndex = 0; frameIndex < dense.FrameCount; frameIndex++)
		{
			float time = frameIndex / dense.SampleRate + dense.BeginTime;
			int frameOffset = frameIndex * (int)dense.CurveCount;
			for (int curveIndex = 0; curveIndex < dense.CurveCount;)
			{
				int index = preDenseCurves + curveIndex;
				IGenericBinding binding = GetBinding(index);
				string path = GetCurvePath(binding.Path);
				int framePosition = frameOffset + curveIndex;
				if (binding.IsTransform())
				{
					AddTransformCurve(time, binding, curveValues, slopeValues, slopeValues, framePosition, path);
					curveIndex += binding.TransformType().GetDimension();
				}
				else if (binding.CustomType == (byte)BindingCustomType.None)
				{
					AddDefaultCurve(binding, path, time, dense.SampleArray[framePosition]);
					curveIndex++;
				}
				else
				{
					AddCustomCurve(binding, path, time, dense.SampleArray[framePosition]);
					curveIndex++;
				}
			}
		}
		ArrayPool<float>.Shared.Return(rentedArray);
	}

	private void ProcessConstant(ConstantClip constant, int preConstantCurves, float lastFrame)
	{
		float[] rentedArray = ArrayPool<float>.Shared.Rent(constant.Data.Count);
		constant.Data.CopyTo(rentedArray);
		ReadOnlySpan<float> curveValues = new(rentedArray, 0, constant.Data.Count);

		ReadOnlySpan<float> slopeValues = [0, 0, 0, 0]; // no slopes - 0 values

		float time = 0f;
		int Is1or2Frames = time == lastFrame ? 1 : 2; // a constant curve can be made with 1 or 2 frames
		for (int i = 0; i < Is1or2Frames; i++, time += lastFrame)
		{
			for (int curveIndex = 0; curveIndex < constant.Data.Count;)
			{
				int index = preConstantCurves + curveIndex;
				IGenericBinding binding = GetBinding(index);
				string path = GetCurvePath(binding.Path);
				if (binding.IsTransform())
				{
					AddTransformCurve(time, binding, curveValues, slopeValues, slopeValues, curveIndex, path);
					curveIndex += binding.TransformType().GetDimension();
				}
				else if (binding.CustomType == (byte)BindingCustomType.None)
				{
					AddDefaultCurve(binding, path, time, constant.Data[curveIndex]);
					curveIndex++;
				}
				else
				{
					AddCustomCurve(binding, path, time, constant.Data[curveIndex]);
					curveIndex++;
				}
			}
		}
		ArrayPool<float>.Shared.Return(rentedArray);
	}

	private void AddCustomCurve(IGenericBinding binding, string path, float time, float value, float inTangent = 0, float outTangent = 0)
	{
		switch ((BindingCustomType)binding.CustomType)
		{
			case BindingCustomType.AnimatorMuscle:
				AddAnimatorMuscleCurve(binding, time, value, inTangent, outTangent);
				break;

			default:
				string attribute = m_customCurveResolver.ToAttributeName((BindingCustomType)binding.CustomType, binding.Attribute, path);
				CurveData curve = new(path, attribute, binding.GetClassID(), binding.Script.TryGetAsset(m_clip.Collection));
				if (binding.IsPPtrCurve())
				{
					AddPPtrKeyframe(curve, time, (int)value);
				}
				else
				{
					AddFloatKeyframe(curve, time, value, inTangent, outTangent);
				}
				break;
		}
	}

	private void AddTransformCurve(float time, IGenericBinding binding, ReadOnlySpan<float> curveValues,
		ReadOnlySpan<float> inSlopeValues, ReadOnlySpan<float> outSlopeValues, int offset, string path)
	{
		switch (binding.TransformType())
		{
			case TransformType.Translation:
				{
					if (!m_translations.TryGetValue(path, out IVector3Curve? curve))
					{
						curve = m_clip.PositionCurves_C74.AddNew();
						curve.SetValues(path);
						m_translations.Add(path, curve);
					}

					float x = curveValues[offset + 0];
					float y = curveValues[offset + 1];
					float z = curveValues[offset + 2];

					float inX = inSlopeValues[0];
					float inY = inSlopeValues[1];
					float inZ = inSlopeValues[2];

					float outX = outSlopeValues[0];
					float outY = outSlopeValues[1];
					float outZ = outSlopeValues[2];

					IKeyframe_Vector3f key = curve.Curve.Curve.AddNew();

					key.Value.SetValues(x, y, z);
					key.InSlope.SetValues(inX, inY, inZ);
					key.OutSlope.SetValues(outX, outY, outZ);
					key.Time = time;
					// this enum member is version agnostic
					key.TangentMode = TangentMode.FreeFree.ToTangent(Version);
					key.WeightedMode = (int)WeightedMode.None;
					key.InWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
					key.OutWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
				}
				break;

			case TransformType.Rotation:
				{
					if (!m_rotations.TryGetValue(path, out IQuaternionCurve? curve))
					{
						curve = m_clip.RotationCurves_C74.AddNew();
						curve.SetValues(path);
						m_rotations.Add(path, curve);
					}

					float x = curveValues[offset + 0];
					float y = curveValues[offset + 1];
					float z = curveValues[offset + 2];
					float w = curveValues[offset + 3];

					float inX = inSlopeValues[0];
					float inY = inSlopeValues[1];
					float inZ = inSlopeValues[2];
					float inW = inSlopeValues[3];

					float outX = outSlopeValues[0];
					float outY = outSlopeValues[1];
					float outZ = outSlopeValues[2];
					float outW = outSlopeValues[3];

					IKeyframe_Quaternionf key = curve.Curve.Curve.AddNew();

					key.Value.SetValues(x, y, z, w);
					key.InSlope.SetValues(inX, inY, inZ, inW);
					key.OutSlope.SetValues(outX, outY, outZ, outW);
					key.Time = time;
					// this enum member is version agnostic
					key.TangentMode = TangentMode.FreeFree.ToTangent(Version);
					key.WeightedMode = (int)WeightedMode.None;
					key.InWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
					key.OutWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
				}
				break;

			case TransformType.Scaling:
				{
					if (!m_scales.TryGetValue(path, out IVector3Curve? curve))
					{
						curve = m_clip.ScaleCurves_C74.AddNew();
						curve.SetValues(path);
						m_scales.Add(path, curve);
					}

					float x = curveValues[offset + 0];
					float y = curveValues[offset + 1];
					float z = curveValues[offset + 2];

					float inX = inSlopeValues[0];
					float inY = inSlopeValues[1];
					float inZ = inSlopeValues[2];

					float outX = outSlopeValues[0];
					float outY = outSlopeValues[1];
					float outZ = outSlopeValues[2];

					IKeyframe_Vector3f key = curve.Curve.Curve.AddNew();

					key.Value.SetValues(x, y, z);
					key.InSlope.SetValues(inX, inY, inZ);
					key.OutSlope.SetValues(outX, outY, outZ);
					key.Time = time;
					// this enum member is version agnostic
					key.TangentMode = TangentMode.FreeFree.ToTangent(Version);
					key.WeightedMode = (int)WeightedMode.None;
					key.InWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
					key.OutWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
				}
				break;

			case TransformType.EulerRotation:
				{
					if (!m_eulers.TryGetValue(path, out IVector3Curve? curve))
					{
						if (!m_clip.Has_EulerCurves_C74())
						{
							break;
						}
						curve = m_clip.EulerCurves_C74.AddNew();
						curve.SetValues(path, (RotationOrder)binding.CustomType);
						m_eulers.Add(path, curve);
					}

					float x = curveValues[offset + 0];
					float y = curveValues[offset + 1];
					float z = curveValues[offset + 2];

					float inX = inSlopeValues[0];
					float inY = inSlopeValues[1];
					float inZ = inSlopeValues[2];

					float outX = outSlopeValues[0];
					float outY = outSlopeValues[1];
					float outZ = outSlopeValues[2];

					IKeyframe_Vector3f key = curve.Curve.Curve.AddNew();

					key.Value.SetValues(x, y, z);
					key.InSlope.SetValues(inX, inY, inZ);
					key.OutSlope.SetValues(outX, outY, outZ);
					key.Time = time;
					// this enum member is version agnostic
					key.TangentMode = TangentMode.FreeFree.ToTangent(Version);
					key.WeightedMode = (int)WeightedMode.None;
					key.InWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
					key.OutWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
				}
				break;

			default:
				throw new NotImplementedException(binding.TransformType().ToString());
		}
	}

	private void AddDefaultCurve(IGenericBinding binding, string path, float time, float value, float inTangent = 0, float outTangent = 0)
	{
		switch (binding.GetClassID())
		{
			case ClassIDType.GameObject:
				AddGameObjectCurve(binding, path, time, value, inTangent, outTangent);
				break;

			case ClassIDType.MonoBehaviour:
				AddScriptCurve(binding, path, time, value, inTangent, outTangent);
				break;

			default:
				AddEngineCurve(binding, path, time, value, inTangent, outTangent);
				break;
		}
	}

	private void AddGameObjectCurve(IGenericBinding binding, string path, float time, float value, float inTangent, float outTangent)
	{
		if (GameObject.TryGetPath(binding.Attribute, out string? propertyName))
		{
			CurveData curve = new(path, propertyName, ClassIDType.GameObject);
			AddFloatKeyframe(curve, time, value, inTangent, outTangent);
		}
		else
		{
			// that means that dev exported animation clip with missing component
			CurveData curve = new(path, GetReversedPath(MissedPropertyPrefix, binding.Attribute), ClassIDType.GameObject);
			AddFloatKeyframe(curve, time, value, inTangent, outTangent);
		}
	}

	private void AddScriptCurve(IGenericBinding binding, string path, float time, float value, float inTangent, float outTangent)
	{
		if (binding.Script.TryGetAsset(m_clip.Collection) is IMonoScript script)
		{
			m_checksumCache.Add(script);
		}

		if (!m_checksumCache.TryGetPath(binding.Attribute, out string? propertyName))
		{
			propertyName = GetReversedPath(ScriptPropertyPrefix, binding.Attribute);
		}

		CurveData curve = new(path, propertyName, ClassIDType.MonoBehaviour, binding.Script.TryGetAsset(m_clip.Collection));

		if (binding.IsPPtrCurve())
		{
			AddPPtrKeyframe(curve, time, (int)value);
		}
		else
		{
			AddFloatKeyframe(curve, time, value, inTangent, outTangent);
		}
	}

	private void AddEngineCurve(IGenericBinding binding, string path, float time, float value, float inTangent, float outTangent)
	{
		if (!FieldHashes.TryGetPath(binding.GetClassID(), binding.Attribute, out string? propertyName))
		{
			propertyName = GetReversedPath(TypeTreePropertyPrefix, binding.Attribute);
		}

		CurveData curve = new(path, propertyName, binding.GetClassID());

		if (binding.IsPPtrCurve())
		{
			AddPPtrKeyframe(curve, time, (int)value);
		}
		else
		{
			AddFloatKeyframe(curve, time, value, inTangent, outTangent);
		}
	}

	private void AddAnimatorMuscleCurve(IGenericBinding binding, float time, float value, float inTangent, float outTangent)
	{
		string attributeString = HumanoidMuscleTypeExtensions.ToAttributeString(binding.GetHumanoidMuscle(Version));
		CurveData curve = new(string.Empty, attributeString, ClassIDType.Animator);
		AddFloatKeyframe(curve, time, value, inTangent, outTangent);
	}

	private void AddFloatKeyframe(in CurveData curveData, float time, float value, float inTangent, float outTangent)
	{
		if (!m_floats.TryGetValue(curveData, out IFloatCurve? curve))
		{
			curve = m_clip.FloatCurves_C74.AddNew();
			curve.Path = curveData.Path;
			curve.Attribute = curveData.Attribute;
			curve.ClassID = (int)curveData.ClassID;
			curve.Script.SetAsset(m_clip.Collection, curveData.Script as IMonoScript);
			curve.Curve.SetDefaultRotationOrderAndCurveLoopType();
			//Todo: set IFloatCurve.Flags or verify that 0 is an acceptable value.
			m_floats.Add(curveData, curve);
		}

		IKeyframe_Single floatKey = curve.Curve.Curve.AddNew();
		floatKey.SetValues(Version, time, value, inTangent, outTangent, DefaultFloatWeight);
	}

	private void AddPPtrKeyframe(in CurveData curveData, float time, int index)
	{
		if (!m_pptrs.TryGetValue(curveData, out IPPtrCurve? curve))
		{
			if (!m_clip.Has_PPtrCurves_C74())
			{
				return;
			}
			curve = m_clip.PPtrCurves_C74.AddNew();
			curve.Path = curveData.Path;
			curve.Attribute = curveData.Attribute;
			curve.ClassID = (int)curveData.ClassID;
			curve.Script.SetAsset(m_clip.Collection, curveData.Script as IMonoScript);
			//Not certain this enum is correct, but it seems to be. 2 is the correct value for this field.
			//See: https://github.com/AssetRipper/AssetRipper/issues/1158
			curve.Flags = (int)SourceGenerated.NativeEnums.Global.EditorCurveBindingFlags.PPtr;
			m_pptrs.Add(curveData, curve);
		}

		IPPtr_Object? value = index < 0 ? null : ClipBindingConstant.PptrCurveMapping[index];
		IPPtrKeyframe key = curve.Curve.AddNew();
		key.Time = time;
		key.Value.CopyValues(value, new PPtrConverter(m_clip));
	}

	private IGenericBinding GetBinding(int index)
	{
		if (m_bindingsCache.TryGetValue(index, out IGenericBinding? binding))
		{
			return binding;
		}
		int curves = 0;
		AccessListBase<IGenericBinding> bindings = ClipBindingConstant.GenericBindings;
		for (int i = 0; i < bindings.Count; i++)
		{
			binding = bindings[i];
			if (binding.GetClassID() == ClassIDType.Transform)
			{
				curves += binding.TransformType().GetDimension();
			}
			else
			{
				curves += 1;
			}
			if (curves > index)
			{
				m_bindingsCache[index] = binding;
				if (binding.IsTransform() && binding.TransformType().GetDimension() < 1)
				{
					// If an animation was malformed, this avoids the possibility of an infinite FOR loop when processing Transform bindings
					throw new IndexOutOfRangeException("Transform AnimationCurve can't have Dimension less than 1.");
				}
				return binding;
			}
		}
		throw new ArgumentException($"Binding with index {index} hasn't been found", nameof(index));
	}

	private static bool TryGetNextFrame(IReadOnlyList<StreamedFrame> streamedFrames, int currentFrame, int curveID, [MaybeNullWhen(false)] out StreamedFrame nextFrame, out int curveIdx)
	{
		for (int frameIndex = currentFrame + 1; frameIndex < streamedFrames.Count; frameIndex++)
		{
			nextFrame = streamedFrames[frameIndex];
			for (curveIdx = 0; curveIdx < nextFrame.Curves.Length; curveIdx++)
			{
				StreamedCurveKey curve = nextFrame.Curves[curveIdx];
				if (curve.Index == curveID)
				{
					return true;
				}
			}
		}
		nextFrame = null;
		curveIdx = -1;
		return false;
	}

	private string GetCurvePath(uint hash)
	{
		if (m_checksumCache.TryGetPath(hash, out string? path))
		{
			return path;
		}
		else
		{
			return GetReversedPath(UnknownPathPrefix, hash);
		}
	}

	public IReadOnlyList<StreamedFrame> GenerateFramesFromStreamedClip(IStreamedClip clip)
	{
		List<StreamedFrame> frames = new();
		Span<byte> buffer = new byte[clip.Data.Count * sizeof(uint)];
		AssetCollection collection = m_clip.Collection;
		CopyDataToBuffer(clip, collection, buffer);

		EndianSpanReader reader = new(buffer, collection.EndianType);
		while (reader.Position < reader.Length)
		{
			StreamedFrame frame = new();
			frame.Read(ref reader, collection.Version);
			frames.Add(frame);
		}
		return frames;

		static bool CpuEndiannessMatchesCollection(AssetCollection collection)
		{
			return (BitConverter.IsLittleEndian && collection.EndianType is EndianType.LittleEndian)
				|| (!BitConverter.IsLittleEndian && collection.EndianType is EndianType.BigEndian);
		}

		static void CopyDataToBuffer(IStreamedClip clip, AssetCollection collection, Span<byte> buffer)
		{
			if (CpuEndiannessMatchesCollection(collection))
			{
				Span<uint> span = MemoryMarshal.Cast<byte, uint>(buffer);
				clip.Data.CopyTo(span);
			}
			else
			{
				for (int i = 0; i < clip.Data.Count; i++)
				{
					if (BitConverter.IsLittleEndian)
					{
						BinaryPrimitives.WriteUInt32LittleEndian(buffer.Slice(i * sizeof(uint)), clip.Data[i]);
					}
					else
					{
						BinaryPrimitives.WriteUInt32BigEndian(buffer.Slice(i * sizeof(uint)), clip.Data[i]);
					}
				}
			}
		}
	}

	private float CalculateLastConstantTime(IReadOnlyList<StreamedFrame> streamedFrames, float stopTime)
	{
		if (stopTime == 0f || streamedFrames.Count <= 1) // streamedFrames[streamedFrames.Count-1] has dummy Infinity Time
		{
			return stopTime;
		}
		float sampleRate = m_clip.SampleRate_C74;
		// using frame indexes for precise calculation
		int lastFrame = (int)float.Round(stopTime * sampleRate);
		StreamedFrame lastStreamedFrame = streamedFrames[streamedFrames.Count - 2];
		// careful of streamedFrames[0], has Time=float.MinValue
		int lastSFFrame = lastStreamedFrame.Time > 0 ? (int)float.Round(lastStreamedFrame.Time * sampleRate) : 0;
		if (lastFrame - lastSFFrame == 1)
		{
			// check if last StreamedFrame has a PPtrCurve, because it adds 1 extra frame to MuscleClip.StopTime
			foreach (StreamedCurveKey curve in lastStreamedFrame.Curves)
			{
				IGenericBinding binding = GetBinding(curve.Index);
				if (binding.IsPPtrCurve())
				{
					// careful of streamedFrames[0], has Time=float.MinValue
					return lastStreamedFrame.Time > 0 ? lastStreamedFrame.Time : 0f;
				}
			}
		}
		return stopTime;
	}

	private static string GetReversedPath([ConstantExpected] string prefix, uint hash)
	{
		return Crc32Algorithm.ReverseAscii(hash, $"{prefix}0x{hash:X}_");
	}

	private UnityVersion Version => m_clip.Collection.Version;

	private const string UnknownPathPrefix = "path_";
	private const string MissedPropertyPrefix = "missed_";
	private const string ScriptPropertyPrefix = "script_";
	private const string TypeTreePropertyPrefix = "typetree_";

	/// <summary>
	/// The default weight for a keyframe.
	/// </summary>
	/// <remarks>
	/// The default Vector3 is 1/3, 1/3, 1/3
	/// The default Quaternion is 1/3, 1/3, 1/3, 1/3
	/// </remarks>
	private const float DefaultFloatWeight = 1.0f / 3.0f;

	private readonly Dictionary<string, IVector3Curve> m_translations = new();
	private readonly Dictionary<string, IQuaternionCurve> m_rotations = new();
	private readonly Dictionary<string, IVector3Curve> m_scales = new();
	private readonly Dictionary<string, IVector3Curve> m_eulers = new();
	private readonly Dictionary<CurveData, IFloatCurve> m_floats = new();
	private readonly Dictionary<CurveData, IPPtrCurve> m_pptrs = new();

	private readonly PathChecksumCache m_checksumCache;
	private readonly IAnimationClip m_clip;
	private readonly CustomCurveResolver m_customCurveResolver;
	private readonly Dictionary<int, IGenericBinding> m_bindingsCache = new(); //cache results from GetBinding(curveID)
	private IAnimationClipBindingConstant ClipBindingConstant => m_clip.ClipBindingConstant_C74!; //This class only supports 4.3 and newer.
}

```

`Source/AssetRipper.Processing/AnimationClips/CustomCurveResolver.cs`:

```cs
using AssetRipper.Checksum;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_108;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_120;
using AssetRipper.SourceGenerated.Classes.ClassID_137;
using AssetRipper.SourceGenerated.Classes.ClassID_198;
using AssetRipper.SourceGenerated.Classes.ClassID_20;
using AssetRipper.SourceGenerated.Classes.ClassID_2083052967;
using AssetRipper.SourceGenerated.Classes.ClassID_224;
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Classes.ClassID_33;
using AssetRipper.SourceGenerated.Classes.ClassID_330;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_96;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.GenericBinding;
using System.Text.RegularExpressions;

namespace AssetRipper.Processing.AnimationClips;

/// <summary>
/// Resolves the attribute names for custom curves
/// </summary>
/// <remarks>
/// This has to remain a class due to the lazy initialization of <see cref="CustomCurveResolver.Roots"/>.
/// </remarks>
public partial class CustomCurveResolver
{
	public CustomCurveResolver(IAnimationClip clip)
	{
		m_clip = clip ?? throw new ArgumentNullException(nameof(clip));
	}

	public string ToAttributeName(BindingCustomType type, uint attribute, string path)
	{
		switch (type)
		{
			case BindingCustomType.BlendShape:
				{
					const string Prefix = "blendShape.";
					if (UnknownPathRegex.IsMatch(path))
					{
						return Prefix + path;
					}

					foreach (IGameObject root in Roots)
					{
						ITransform rootTransform = root.GetTransform();
						ITransform? child = rootTransform.FindChild(path);
						if (child == null)
						{
							continue;
						}
						ISkinnedMeshRenderer? skin = child.GameObject_C4P?.TryGetComponent<ISkinnedMeshRenderer>();
						if (skin == null)
						{
							continue;
						}
						IMesh? mesh = skin.MeshP;
						if (mesh == null)
						{
							continue;
						}
						string? shapeName = mesh.FindBlendShapeNameByCRC(attribute);
						if (shapeName == null)
						{
							continue;
						}

						return Prefix + shapeName;
					}
					return Prefix + Crc32Algorithm.ReverseAscii(attribute, $"path_0x{attribute:X}_");
				}

			case BindingCustomType.Renderer:
				return "m_Materials"
					+ "." + "Array" //from the common string
					+ "." + "data" //from the common string
					+ $"[{attribute}]";

			case BindingCustomType.RendererMaterial:
				{
					const string Prefix = "material.";
					if (UnknownPathRegex.IsMatch(path))
					{
						return Prefix + path;
					}

					foreach (IGameObject root in Roots)
					{
						ITransform rootTransform = root.GetTransform();
						ITransform? child = rootTransform.FindChild(path);
						if (child == null)
						{
							continue;
						}

						uint crc28 = attribute & 0xFFFFFFF;
						IRenderer? renderer = child.GameObject_C4P?.TryGetComponent<IRenderer>();
						if (renderer == null)
						{
							continue;
						}
						string? property = renderer.FindMaterialPropertyNameByCRC28(crc28);
						if (property == null)
						{
							continue;
						}

						if ((attribute & 0x80000000) != 0)
						{
							return Prefix + property;
						}

						uint subPropIndex = attribute >> 28 & 3;
						bool isRgba = (attribute & 0x40000000) != 0;
						char subProperty = subPropIndex switch
						{
							0 => isRgba ? 'r' : 'x',
							1 => isRgba ? 'g' : 'y',
							2 => isRgba ? 'b' : 'z',
							_ => isRgba ? 'a' : 'w',
						};
						return Prefix + property + "." + subProperty;
					}
					return Prefix + Crc32Algorithm.ReverseAscii(attribute, $"path_0x{attribute:X}_");
				}

			case BindingCustomType.SpriteRenderer:
				{
					if (attribute == 0)
					{
						return "m_Sprite";
					}
				}
				return ThrowUnknownAttributeException(type, attribute);

			case BindingCustomType.MonoBehaviour:
				{
					if (MonoBehaviour.TryGetPath(attribute, out string? foundPath))
					{
						return foundPath;
					}
				}
				return ThrowUnknownAttributeException(type, attribute);

			case BindingCustomType.Light:
				{
					if (Light.TryGetPath(attribute, out string? foundPath))
					{
						return foundPath;
					}
				}
				return ThrowUnknownAttributeException(type, attribute);

			case BindingCustomType.RendererShadows:
				{
					if (Renderer.TryGetPath(attribute, out string? foundPath))
					{
						return foundPath;
					}
				}
				return ThrowUnknownAttributeException(type, attribute);

			case BindingCustomType.ParticleSystem:
				{
					if (ParticleSystem.TryGetPath(attribute, out string? foundPath))
					{
						return foundPath;
					}
					else
					{
						//This has at least one ordinal property name,
						//So the precalculated hashes are insufficient for recovery.
						//Binary analysis may be required.
						//Example failed attributes:
						//0x45ECBD03 (1173142787)
						//0x483A8AB1 (1211796145)
						//0x72FE5CE2 (1929272546)
						//https://github.com/AssetRipper/AssetRipper/issues/1025
					}
				}
				return Crc32Algorithm.ReverseAscii(attribute, $"ParticleSystem_0x{attribute:X}_");

			case BindingCustomType.RectTransform:
				{
					if (RectTransform.TryGetPath(attribute, out string? foundPath))
					{
						return foundPath;
					}
				}
				return ThrowUnknownAttributeException(type, attribute);

			case BindingCustomType.LineRenderer:
				{
					if (LineRenderer.TryGetPath(attribute, out string? foundPath))
					{
						return foundPath;
					}
				}
				return ThrowUnknownAttributeException(type, attribute);

			case BindingCustomType.TrailRenderer:
				{
					if (TrailRenderer.TryGetPath(attribute, out string? foundPath))
					{
						return foundPath;
					}
				}
				return ThrowUnknownAttributeException(type, attribute);

			case BindingCustomType.PositionConstraint:
				{
					uint property = attribute & 0xF;
					return property switch
					{
						0 => "m_RestTranslation.x",
						1 => "m_RestTranslation.y",
						2 => "m_RestTranslation.z",
						3 => "m_Weight",
						4 => "m_TranslationOffset.x",
						5 => "m_TranslationOffset.y",
						6 => "m_TranslationOffset.z",
						7 => "m_AffectTranslationX",
						8 => "m_AffectTranslationY",
						9 => "m_AffectTranslationZ",
						10 => "m_Active",
						11 => $"m_Sources.Array.data[{attribute >> 8}].sourceTransform",
						12 => $"m_Sources.Array.data[{attribute >> 8}].weight",
						_ => ThrowUnknownAttributeException(type, attribute)
					};
				}

			case BindingCustomType.RotationConstraint:
				{
					uint property = attribute & 0xF;
					return property switch
					{
						0 => "m_RestRotation.x",
						1 => "m_RestRotation.y",
						2 => "m_RestRotation.z",
						3 => "m_Weight",
						4 => "m_RotationOffset.x",
						5 => "m_RotationOffset.y",
						6 => "m_RotationOffset.z",
						7 => "m_AffectRotationX",
						8 => "m_AffectRotationY",
						9 => "m_AffectRotationZ",
						10 => "m_Active",
						11 => $"m_Sources.Array.data[{attribute >> 8}].sourceTransform",
						12 => $"m_Sources.Array.data[{attribute >> 8}].weight",
						_ => ThrowUnknownAttributeException(type, attribute)
					};
				}

			case BindingCustomType.ScaleConstraint:
				{
					uint property = attribute & 0xF;
					return property switch
					{
						0 => "m_ScaleAtRest.x",
						1 => "m_ScaleAtRest.y",
						2 => "m_ScaleAtRest.z",
						3 => "m_Weight",
						4 => "m_ScalingOffset.x",
						5 => "m_ScalingOffset.y",
						6 => "m_ScalingOffset.z",
						7 => "m_AffectScalingX",
						8 => "m_AffectScalingY",
						9 => "m_AffectScalingZ",
						10 => "m_Active",
						11 => $"m_Sources.Array.data[{attribute >> 8}].sourceTransform",
						12 => $"m_Sources.Array.data[{attribute >> 8}].weight",
						_ => ThrowUnknownAttributeException(type, attribute)
					};
				}

			case BindingCustomType.AimConstraint:
				{
					uint property = attribute & 0xF;
					return property switch
					{
						0 => "m_Weight",
						1 => "m_AffectRotationX",
						2 => "m_AffectRotationY",
						3 => "m_AffectRotationZ",
						4 => "m_Active",
						5 => "m_WorldUpObject",
						6 => $"m_Sources.Array.data[{attribute >> 8}].sourceTransform",
						7 => $"m_Sources.Array.data[{attribute >> 8}].weight",
						_ => ThrowUnknownAttributeException(type, attribute)
					};
				}

			case BindingCustomType.ParentConstraint:
				{
					uint property = attribute & 0xF;
					return property switch
					{
						0 => "m_Weight",
						1 => "m_AffectTranslationX",
						2 => "m_AffectTranslationY",
						3 => "m_AffectTranslationZ",
						4 => "m_AffectRotationX",
						5 => "m_AffectRotationY",
						6 => "m_AffectRotationZ",
						7 => "m_Active",
						8 => $"m_TranslationOffsets.Array.data[{attribute >> 8}].x",
						9 => $"m_TranslationOffsets.Array.data[{attribute >> 8}].y",
						10 => $"m_TranslationOffsets.Array.data[{attribute >> 8}].z",
						11 => $"m_RotationOffsets.Array.data[{attribute >> 8}].x",
						12 => $"m_RotationOffsets.Array.data[{attribute >> 8}].y",
						13 => $"m_RotationOffsets.Array.data[{attribute >> 8}].z",
						14 => $"m_Sources.Array.data[{attribute >> 8}].sourceTransform",
						15 => $"m_Sources.Array.data[{attribute >> 8}].weight",
						_ => ThrowUnknownAttributeException(type, attribute)
					};
				}

			case BindingCustomType.LookAtConstraint:
				{
					uint property = attribute & 0xF;
					return property switch
					{
						0 => "m_Weight",
						1 => "m_Active",
						2 => "m_WorldUpObject",
						3 => $"m_Sources.Array.data[{attribute >> 8}].sourceTransform",
						4 => $"m_Sources.Array.data[{attribute >> 8}].weight",
						5 => "m_Roll",
						_ => ThrowUnknownAttributeException(type, attribute)
					};
				}

			case BindingCustomType.Camera:
				{
					if (Camera.TryGetPath(attribute, out string? foundPath))
					{
						return foundPath;
					}
				}
				return ThrowUnknownAttributeException(type, attribute);

			case BindingCustomType.VisualEffect:
				{
					if (VisualEffect.TryGetPath(attribute, out string? foundPath))
					{
						return foundPath;
					}
					else
					{
						//This has at least one ordinal property name,
						//So the precalculated hashes are insufficient for recovery.
						//Binary analysis may be required.
						//Example failed attributes:
						//0xF781B1D9 (4152472025)
						//0x4CB2F934 (1286797620)
						//https://github.com/AssetRipper/AssetRipper/issues/1047
					}
				}
				return Crc32Algorithm.ReverseAscii(attribute, $"VisualEffect_0x{attribute:X}_");

			case BindingCustomType.ParticleForceField:
				{
					if (ParticleSystemForceField.TryGetPath(attribute, out string? foundPath))
					{
						return foundPath;
					}
					else
					{
						//This has at least one ordinal property name,
						//So the precalculated hashes are insufficient for recovery.
						//Binary analysis may be required.
						//Example failed attributes:
						//0x8D909E70 (2375065200)
						//https://github.com/AssetRipper/AssetRipper/issues/1239
					}
				}
				return Crc32Algorithm.ReverseAscii(attribute, $"ParticleForceField_0x{attribute:X}_");

			case BindingCustomType.UserDefined:
				return Crc32Algorithm.ReverseAscii(attribute, $"UserDefined_0x{attribute:X}_");

			case BindingCustomType.MeshFilter:
				{
					if (MeshFilter.TryGetPath(attribute, out string? foundPath))
					{
						return foundPath;
					}
					else
					{
						//This has at least one ordinal property name,
						//So the precalculated hashes are insufficient for recovery.
						//Binary analysis may be required.
						//Example failed attributes:
						//0xDFF2AF49 (3757223753)
					}
				}
				return Crc32Algorithm.ReverseAscii(attribute, $"MeshFilter_0x{attribute:X}_");

			default:
				throw new ArgumentException($"Binding type {type} not implemented", nameof(type));
		}

		[DoesNotReturn]
		static string ThrowUnknownAttributeException(BindingCustomType type, uint attribute)
		{
			throw new ArgumentException($"Unknown attribute 0x{attribute:X} ({attribute}) for {type}");
		}
	}

	[field: MaybeNull]
	private IGameObject[] Roots
	{
		get
		{
			field ??= m_clip.FindRoots().ToArray();
			return field;
		}
	}

	private readonly IAnimationClip m_clip;

	/// <summary>
	/// Matches AnimationClipConverter.GetReversedPath(AnimationClipConverter.UnknownPathPrefix, hash)
	/// </summary>
	[GeneratedRegex("^path_0x[0-9A-F]{1,10}_[H-Wh-w]{6}[HJLN]$", RegexOptions.Compiled)]
	private static partial Regex UnknownPathRegex { get; }
}

```

`Source/AssetRipper.Processing/AnimationClips/Editor/StreamedCurveKey.cs`:

```cs
using AssetRipper.IO.Endian;
using System.Numerics;

namespace AssetRipper.Processing.AnimationClips.Editor;

public sealed record class StreamedCurveKey
{
	public StreamedCurveKey() { }
	public StreamedCurveKey(int index, Vector3 coefficient, float value)
	{
		Index = index;
		Coefficient = coefficient;
		RightSidedLimit = value;
		LeftSidedLimit = RightSidedLimit;
	}

	public void Read(ref EndianSpanReader reader)
	{
		Index = reader.ReadInt32();
		Coefficient = new(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
		RightSidedLimit = reader.ReadSingle();
		LeftSidedLimit = RightSidedLimit;
	}

	public void CalculateSlopes(float time, float nextTime, StreamedCurveKey nextKey, bool UseNegInfSlopes)
	{
		if (Coefficient != default) // != (0,0,0) => regular slopes
		{
			double deltaTime = (double)nextTime - time;
			SetRegularSlopes(deltaTime, nextKey, out double _CoeffX, out double _CoeffY);

			if (UseNegInfSlopes && nextKey.Coefficient == default) // calculate next LSL only if next slope calculation needs it
			{
				nextKey.LeftSidedLimit = (_CoeffX + _CoeffY + Coefficient.Z) * deltaTime + RightSidedLimit;
				nextKey.ExactLeftSidedLimit = false;
			}
		}

		// set Special slope to this.OutSlope, because has priority over nextKey.InSlope on shaping the curve
		// nextKey.InSlope can stay Zero

		else if (UseNegInfSlopes)
		{
			// * there is one curve configuration that can fail and set incorrect slopes
			CalculateSpecialSlopes(nextKey); // Infinity, -Infinity or Zero
		}
		else
		{
			// should be a perfect reconstruction
			SetNonNegSpecialSlopes(nextKey); // Infinity or Zero
		}
	}

	private void SetRegularSlopes(double deltaX, StreamedCurveKey nextKey, out double _CoeffX, out double _CoeffY)
	{
		OutSlope = Coefficient.Z;
		_CoeffX = Coefficient.X * deltaX * deltaX;
		_CoeffY = Coefficient.Y * deltaX;
		nextKey.InSlope = (float)(3 * _CoeffX + 2 * _CoeffY + Coefficient.Z); // may need some kind of rounding if wanting to get an inSlope of exactly 0
	}

	private void SetNonNegSpecialSlopes(StreamedCurveKey nextKey)
	{
		if (RightSidedLimit != nextKey.RightSidedLimit)
		{
			OutSlope = float.PositiveInfinity;
			// nextKey.InSlope is already 0
		}
		// else { this.OutSlope and nextKey.InSlope are already 0 }
	}

	private void CalculateSpecialSlopes(StreamedCurveKey nextKey)
	{
		bool isDiscontinuous = HasDifferentLimits();
		if (RightSidedLimit == nextKey.RightSidedLimit)
		{
			// OutSlope IS Zero or -Infinity
			// but -Inf can also recreate Zero curves, so that will be used
			SetNegInfSlope(nextKey, isDiscontinuous);
			return;
		}

		if (isDiscontinuous) // * this estimation can be source of error
		{
			// OutSlope SHOULD be -Infinity
			SetNegInfSlope(nextKey, true);
			return;
		}

		// OutSlope SHOULD be Zero or +Infinity
		// but +Inf can also recreate Zero curves, so that will be used
		SetPosInfSlope();
	}

	private void SetNegInfSlope(StreamedCurveKey nextKey, bool isDiscontinuous)
	{
		OutSlope = float.NegativeInfinity;
		// nextKey.InSlope is already 0

		// set next LSL only if next slope calculation needs it
		if (nextKey.Coefficient == default)
		{
			nextKey.LeftSidedLimit = RightSidedLimit;
		}

		// fix Value for true -Infinity slopes
		if (isDiscontinuous)
		{
			RightSidedLimit = (float)LeftSidedLimit;
		}
	}

	private void SetPosInfSlope()
	{
		OutSlope = float.PositiveInfinity;
		// nextKey.InSlope is already 0

		/// Don't modify nextKey.LeftSidedLimit here!
		/// If nextKey.LeftSidedLimit is kept equal to nextKey.RightSidedLimit,
		/// then nextKey can't produce OutSlope of -Infinity
		/// +Inf outslope followed by -Inf outslope is an "illegal configuration".
	}

	private bool HasDifferentLimits()
	{
		if (RightSidedLimit != LeftSidedLimit)
		{
			if (ExactLeftSidedLimit)
			{
				return true;
			}

			// check percentage difference. this estimation can be source of error
			double diff = double.Abs((double)RightSidedLimit - LeftSidedLimit);
			double div = double.Max(double.Abs(LeftSidedLimit), float.Abs(RightSidedLimit));
			const float ROUNDING_ERROR = 5e-7f; // arbitrary small value
			/// normally the difference between Right and Left Sided Limits
			/// should be "big"/much greater than a rounding error.
			if (diff / div > ROUNDING_ERROR)
			{
				return true;
			}
		}
		return false;
	}

	/// <summary>
	/// Index for its GenericBinding inside AnimationClip's BindingConstant.
	/// </summary>
	public int Index { get; private set; }
	/// <summary>
	/// Coefficients of the Cubic Bezier Equation between this Key and the next, for the same Curve.
	/// </summary>
	public Vector3 Coefficient { get; private set; }
	/// <summary>
	/// Value of the binded property during this keyframe.
	/// </summary>
	/// /// <remarks>
	/// This value could change after Slope calculation.
	/// </remarks>
	public float Value { get => RightSidedLimit; private set => RightSidedLimit = value; }
	/// <summary>
	/// Value of the key, when approached from its right side.
	/// </summary>
	/// <remarks>
	/// outSlope=-Infinity creates a discontinuity on the curve,
	/// making the CurveKey value differ from its left side.
	/// </remarks>
	private float RightSidedLimit { get; set; }
	/// <summary>
	/// Value of the key, when approached from its left side
	/// </summary>
	/// <remarks>
	/// outSlope=-Infinity creates a discontinuity on the curve,
	/// making the CurveKey value differ from its right side.
	/// </remarks>
	private double LeftSidedLimit { get; set; }
	/// <summary>
	/// Used only to calculate slopes.
	/// </summary>
	/// <remarks>
	/// Should be <c>false</c> if <c>LeftSidedLimit</c> was set from an arithmetic calculation
	/// instead of from <c>Read()</c>, meaning its not 100% reliable for equality comparison.
	/// </remarks>
	private bool ExactLeftSidedLimit { get; set; } = true;
	public float InSlope { get; private set; }
	public float OutSlope { get; private set; }
}

```

`Source/AssetRipper.Processing/AnimationClips/Editor/StreamedFrame.cs`:

```cs
using AssetRipper.IO.Endian;
using System.Diagnostics;

namespace AssetRipper.Processing.AnimationClips.Editor;

[DebuggerDisplay($"{{{nameof(GetDebuggerDisplay)}(),nq}}")]
public sealed class StreamedFrame
{
	public void Read(ref EndianSpanReader reader, UnityVersion version)
	{
		Time = reader.ReadSingle();
		Curves = ReadAssetArray(ref reader, version);
	}

	public float Time { get; set; }
	public StreamedCurveKey[] Curves { get; set; } = Array.Empty<StreamedCurveKey>();

	private static StreamedCurveKey[] ReadAssetArray(ref EndianSpanReader reader, UnityVersion version)
	{
		int curveCount = reader.ReadInt32();
		ThrowIfNegative(curveCount);

		StreamedCurveKey[] curvesArray = curveCount == 0 ? Array.Empty<StreamedCurveKey>() : new StreamedCurveKey[curveCount];
		if (curveCount > 0)
		{
			StreamedCurveKey instance = ReadNextCurve(ref reader);
			curvesArray[0] = instance;

			int saveIdx = 1;
			for (int readIdx = 1; readIdx < curveCount; readIdx++, saveIdx++)
			{
				instance = ReadNextCurve(ref reader);
				if (curvesArray[saveIdx - 1].Index == instance.Index)
				{
					saveIdx--; // keep only last curve from sequence of duplicated binding/Index
				}
				curvesArray[saveIdx] = instance;
			}
			if (saveIdx != curveCount)
			{
				curvesArray = curvesArray.AsSpan(0, saveIdx).ToArray();
			}
		}

		if (version.GreaterThanOrEquals(2017, 1))
		{
			reader.Align();
		}
		return curvesArray;

		static StreamedCurveKey ReadNextCurve(ref EndianSpanReader reader)
		{
			StreamedCurveKey instance = new();
			instance.Read(ref reader);
			return instance;
		}

		static void ThrowIfNegative(int count)
		{
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(count), $"Cannot be negative: {count}");
			}
		}
	}

	private string GetDebuggerDisplay()
	{
		return $$"""{ {{nameof(Time)}} : {{Time}}, {{nameof(Curves)}}.Length : {{Curves?.Length}} }""";
	}
}

```

`Source/AssetRipper.Processing/AnimationClips/PathChecksumCache.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Metadata;
using AssetRipper.Checksum;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.SerializationLogic;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_111;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Classes.ClassID_90;
using AssetRipper.SourceGenerated.Classes.ClassID_95;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Processing.AnimationClips;

/// <summary>
/// Attempts to recover field paths from <see cref="uint"/> hash values.
/// </summary>
/// <remarks>
/// Replicates Unity CRC32 checksum usage for field names and paths.
/// </remarks>
public readonly struct PathChecksumCache
{
	public PathChecksumCache(GameData gameData)
	{
		this.assemblyManager = gameData.AssemblyManager;
		BuildPathsCache(gameData.GameBundle);
	}

	private readonly Dictionary<string, uint> cachedPropertyNames = new() { { string.Empty, 0 } };
	private readonly Dictionary<uint, string> cachedChecksums = new() { { 0, string.Empty } };
	private readonly HashSet<AssetInfo> processedAssets = new();
	private readonly IAssemblyManager assemblyManager;

	private void AddAnimatorPathsToCache(IAnimator animator)
	{
		IAvatar? avatar = animator.AvatarP;
		if (avatar != null)
		{
			AddAvatarTOS(avatar);
			return;
		}

		if (animator.Has_HasTransformHierarchy() && !animator.HasTransformHierarchy)
		{
			return;
		}

		IGameObject? gameObject = animator.GameObjectP;
		if (gameObject is null)
		{
			return;
		}
		AddGameObjectPathsToCacheRecursive(gameObject, string.Empty);
	}

	private void AddGameObjectPathsToCacheRecursive(IGameObject parent, string parentPath)
	{
		ITransform transform = parent.GetTransform();

		foreach (ITransform? childTransform in transform.Children_C4P)
		{
			IGameObject? child = childTransform?.GameObject_C4P;
			if (child is null)
			{
				continue;
			}

			string path = string.IsNullOrEmpty(parentPath)
				? child.Name
				: $"{parentPath}/{child.Name}";

			uint pathHash = Crc32Algorithm.HashUTF8(path);
			AddKeys(pathHash, path);

			AddGameObjectPathsToCacheRecursive(child, path);
		}
	}

	private void AddAnimationPathsToCache(IAnimation animation)
	{
		IGameObject? go = animation.GameObjectP;
		if (go is null)
		{
			return;
		}
		AddGameObjectPathsToCacheRecursive(go, string.Empty);
	}

	private void AddAvatarTOS(IAvatar avatar)
	{
		foreach ((uint key, Utf8String value) in avatar.TOS)
		{
			AddKeys(key, value);
		}
	}

	private void BuildPathsCache(GameBundle bundle)
	{
		foreach (IUnityObjectBase asset in bundle.FetchAssets())
		{
			switch (asset)
			{
				case IAvatar avatar:
					AddAvatarTOS(avatar);
					break;
				case IAnimator animator:
					AddAnimatorPathsToCache(animator);
					break;
				case IAnimation animation:
					AddAnimationPathsToCache(animation);
					break;
			}
		}
	}

	public uint Add(string path)
	{
		if (cachedPropertyNames.TryGetValue(path, out uint value))
		{
			return value;
		}

		uint output = Crc32Algorithm.HashUTF8(path);

		AddKeys(output, path);
		return output;
	}

	public void Add(IMonoScript script)
	{
		if (!processedAssets.Add(script.AssetInfo))
		{
			return;
		}

		SerializableType? behaviour = script.GetBehaviourType(assemblyManager);

		if (behaviour is null)
		{
			return;
		}

		for (int f = 0; f < behaviour.Fields.Count; f++)
		{
			SerializableType.Field field = behaviour.Fields[f];
			AddFieldRecursively(field);
		}
	}

	private void AddFieldRecursively(SerializableType.Field field, string path = "", int depth = 0)
	{
		// Time out if we go too deeply to prevent infinite recursion
		if (depth > 10)
		{
			return;
		}

		if (field.Type.IsPrimitive())
		{
			// Only primitive fields can be animated.
			Add($"{path}{field.Name}");
		}
		else
		{
			string basePath = $"{path}{field.Name}.";
			for (int i = 0; i < field.Type.Fields.Count; i++)
			{
				AddFieldRecursively(field.Type.Fields[i], basePath, depth + 1);
			}
		}
	}

	public bool TryGetPath(uint identifier, [NotNullWhen(true)] out string? path)
	{
		return cachedChecksums.TryGetValue(identifier, out path);
	}

	public void Reset()
	{
		cachedPropertyNames.Clear();
		cachedChecksums.Clear();
		processedAssets.Clear();
	}

	private void AddKeys(uint checksum, string propertyName)
	{
		cachedPropertyNames[propertyName] = checksum;
		cachedChecksums[checksum] = propertyName;
	}
}

```

`Source/AssetRipper.Processing/AnimatorControllers/AnimatorControllerProcessor.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.Logging;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_1107;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.NativeEnums.Animation;
using AssetRipper.SourceGenerated.Subclasses.AnimatorControllerLayer;
using AssetRipper.SourceGenerated.Subclasses.AnimatorControllerParameter;
using AssetRipper.SourceGenerated.Subclasses.ControllerConstant;
using AssetRipper.SourceGenerated.Subclasses.LayerConstant;
using AssetRipper.SourceGenerated.Subclasses.ValueConstant;
using System.Diagnostics;

namespace AssetRipper.Processing.AnimatorControllers;

public sealed class AnimatorControllerProcessor : IAssetProcessor
{
	public void Process(GameData gameData)
	{
		Logger.Info(LogCategory.Processing, "Reconstruct AnimatorController Assets");

		List<IAnimatorController> animatorControllers = gameData.GameBundle
			.FetchAssetCollections()
			.Where(c => c.Flags.IsRelease())
			.SelectMany(c => c.OfType<IAnimatorController>())
			.ToList();

		ProcessedAssetCollection processedCollection = gameData.AddNewProcessedCollection("Generated AnimatorController Dependencies");
		foreach (IAnimatorController controller in animatorControllers)
		{
			Process(controller, processedCollection);
		}

		List<HashSet<IUnityObjectBase>> assetSets = [];
		Dictionary<IUnityObjectBase, List<int>> assetToSetIndices = new();
		foreach (IAnimatorController controller in animatorControllers)
		{
			int setIndex = assetSets.Count;
			HashSet<IUnityObjectBase> assetSet = [];
			assetSets.Add(assetSet);

			foreach (IUnityObjectBase dependency in controller.FetchEditorHierarchy().WhereNotNull())
			{
				assetSet.Add(dependency);
				if (!assetToSetIndices.TryGetValue(dependency, out List<int>? setIndices))
				{
					setIndices = [setIndex];
					assetToSetIndices.Add(dependency, setIndices);
				}
				else if (!setIndices.Contains(setIndex))
				{
					setIndices.Add(setIndex);
				}
			}
		}

		foreach ((IUnityObjectBase asset, List<int> setIndices) in assetToSetIndices)
		{
			if (setIndices.Count <= 1)
			{
				continue;
			}

			for (int i = 1; i < setIndices.Count; i++)
			{
				int currentSetIndex = setIndices[i];
				HashSet<IUnityObjectBase> currentSet = assetSets[currentSetIndex];
				currentSet.Remove(asset);

				IUnityObjectBase clonedAsset = processedCollection.CreateAsset(asset.ClassID, AssetFactory.Create);
				SingleReplacementAssetResolver resolver = new(asset, clonedAsset);
				clonedAsset.CopyValues(asset, new PPtrConverter(asset.Collection, clonedAsset.Collection, resolver));

				foreach (IUnityObjectBase otherAsset in currentSet)
				{
					otherAsset.CopyValues(otherAsset, new PPtrConverter(otherAsset.Collection, otherAsset.Collection, resolver));
				}

				Debug.Assert(!currentSet.OfType<IAnimatorController>().First().FetchEditorHierarchy().Contains(asset));
				Debug.Assert(currentSet.OfType<IAnimatorController>().First().FetchEditorHierarchy().Contains(clonedAsset));

				currentSet.Add(clonedAsset);
			}
		}
		assetToSetIndices.Clear();

		Debug.Assert(assetSets.Count == animatorControllers.Count);
		for (int i = 0; i < animatorControllers.Count; i++)
		{
			IAnimatorController controller = animatorControllers[i];
			HashSet<IUnityObjectBase> assetSet = assetSets[i];
			Debug.Assert(controller.FetchEditorHierarchy().WhereNotNull().Distinct().Count() == assetSet.Count);
			Debug.Assert(controller.FetchEditorHierarchy().WhereNotNull().All(assetSet.Contains));
			foreach (IUnityObjectBase asset in assetSet)
			{
				Debug.Assert(asset.MainAsset is null);
				asset.MainAsset = controller;
			}
		}
	}

	private static void Process(IAnimatorController controller, ProcessedAssetCollection processedCollection)
	{
		IControllerConstant controllerConstant = controller.Controller;
		IAnimatorStateMachine[] StateMachines = new IAnimatorStateMachine[controllerConstant.StateMachineArray.Count];
		for (int i = 0; i < controllerConstant.StateMachineArray.Count; i++)
		{
			IAnimatorStateMachine stateMachine = VirtualAnimationFactory.CreateRootAnimatorStateMachine(processedCollection, controller, i);
			StateMachines[i] = stateMachine;
		}

		controller.AnimatorParameters.Clear();
		controller.AnimatorParameters.Capacity = controllerConstant.Values.Data.ValueArray.Count;
		for (int i = 0; i < controllerConstant.Values.Data.ValueArray.Count; i++)
		{
			IAnimatorControllerParameter newParameter = controller.AnimatorParameters.AddNew();
			InitializeParameter(newParameter, controller, i);
		}

		controller.AnimatorLayers.Clear();
		controller.AnimatorLayers.Capacity = controllerConstant.LayerArray.Count;
		for (int i = 0; i < controllerConstant.LayerArray.Count; i++)
		{
			uint stateMachineIndex = controllerConstant.LayerArray[i].Data.StateMachineIndex;
			IAnimatorStateMachine stateMachine = StateMachines[stateMachineIndex];
			IAnimatorControllerLayer newLayer = controller.AnimatorLayers.AddNew();
			InitializeLayer(newLayer, stateMachine, controller, i);
		}
	}

	private static void InitializeLayer(IAnimatorControllerLayer animatorControllerLayer, IAnimatorStateMachine stateMachine, IAnimatorController controller, int layerIndex)
	{
		ILayerConstant layer = controller.Controller.LayerArray[layerIndex].Data;

		animatorControllerLayer.Name = controller.TOS[layer.Binding];

		animatorControllerLayer.StateMachine.SetAsset(controller.Collection, stateMachine);

#warning TODO: animator
		//Mask = new();

		animatorControllerLayer.BlendingMode = layer.LayerBlendingMode;
		animatorControllerLayer.SyncedLayerIndex = layer.StateMachineSynchronizedLayerIndex == 0 ? -1 : (int)layer.StateMachineIndex;
		animatorControllerLayer.DefaultWeight = layer.DefaultWeight;
		animatorControllerLayer.IKPass = layer.IKPass;
		animatorControllerLayer.SyncedLayerAffectsTiming = layer.SyncedLayerAffectsTiming;
		if (animatorControllerLayer.Has_Controller())
		{
			animatorControllerLayer.Controller.SetAsset(controller.Collection, controller);
		}
	}

	private static void InitializeParameter(IAnimatorControllerParameter parameter, IAnimatorController controller, int paramIndex)
	{
		IValueConstant value = controller.Controller.Values.Data.ValueArray[paramIndex];
		parameter.Name = controller.TOS[value.ID];
		AnimatorControllerParameterType type = value.GetTypeValue();
		switch (type)
		{
			case AnimatorControllerParameterType.Trigger:
				parameter.DefaultBool = controller.Controller.DefaultValues.Data.BoolValues[(int)value.Index];
				break;

			case AnimatorControllerParameterType.Bool:
				parameter.DefaultBool = controller.Controller.DefaultValues.Data.BoolValues[(int)value.Index];
				break;

			case AnimatorControllerParameterType.Int:
				parameter.DefaultInt = controller.Controller.DefaultValues.Data.IntValues[(int)value.Index];
				break;

			case AnimatorControllerParameterType.Float:
				parameter.DefaultFloat = controller.Controller.DefaultValues.Data.FloatValues[(int)value.Index];
				break;

			default:
				throw new NotSupportedException($"Parameter type '{type}' isn't supported");
		}
		parameter.Type = (int)type;
		if (parameter.Has_Controller())
		{
			parameter.Controller.SetAsset(controller.Collection, controller);
		}
	}
}

```

`Source/AssetRipper.Processing/AnimatorControllers/AnimatorStateContext.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.StateConstant;
using AssetRipper.SourceGenerated.Subclasses.StateMachineConstant;

namespace AssetRipper.Processing.AnimatorControllers;

internal sealed class AnimatorStateContext
{
	public readonly int DefaultStateIndex;
	public bool HasStates() => IndexedStates.Length > 0;

	private readonly ProcessedAssetCollection VirtualFile;
	private readonly IAnimatorController Controller;
	private readonly IStateMachineConstant StateMachineConstant;
	private readonly int LayerIndex;
	/// <summary>
	/// Stores all AnimatorState data, also linking each AnimatorState with its index from StateConstantArray
	/// </summary>
	private readonly StateData[] IndexedStates;
	private readonly BidirectionalDictionary<string, uint> stateMachinePathNamesAndIDs;

	public AnimatorStateContext(ProcessedAssetCollection virtualFile, IAnimatorController controller, IStateMachineConstant stateMachineConstant, int layerIndex)
	{
		VirtualFile = virtualFile;
		Controller = controller;
		StateMachineConstant = stateMachineConstant;
		LayerIndex = layerIndex;

		DefaultStateIndex = stateMachineConstant.DefaultState != uint.MaxValue ? (int)stateMachineConstant.DefaultState : 0;

		IndexedStates = new StateData[stateMachineConstant.StateConstantArray.Count];
		stateMachinePathNamesAndIDs = new();
	}

	/// <summary>
	/// Create all AnimatorStates, and group them by StateMachine paths
	/// </summary>
	public void Process()
	{
		if (!HasStates())
		{
			return;
		}

		Controller.TOS.TryAdd(0, Utf8String.Empty);

		for (int i = 0; i < IndexedStates.Length; i++)
		{
			IStateConstant stateConstant = StateMachineConstant.StateConstantArray[i].Data;
			IAnimatorState state = VirtualAnimationFactory.CreateAnimatorState(VirtualFile, Controller, Controller.TOS, LayerIndex, stateConstant);

			string stateMachineFullPath = MakeStateMachinePath(Controller.TOS, stateConstant.GetId(), state.Name.String); // [stateMachinePath].StateName
			if (!stateMachinePathNamesAndIDs.TryGetValue(stateMachineFullPath, out uint stateMachineFullPathID))
			{
				stateMachineFullPathID = Checksum.Crc32Algorithm.HashUTF8(stateMachineFullPath);
				stateMachinePathNamesAndIDs.Add(stateMachineFullPath, stateMachineFullPathID);
			}

			IndexedStates[i] = new(state, stateConstant, stateMachineFullPathID);
		}

		if (StateMachineConstant.StateMachineCount() > stateMachinePathNamesAndIDs.Count) // can only happen on Unity 5+
		{
			// there are StateMachines that don't contain States
			// generate more possible StateMachine paths to locate this StateMachines
			// *not useful when these StateMachines come last in hierachy (don't have child StateMachines with States)
			string[] originalStateMachinePathNames = stateMachinePathNamesAndIDs.Keys.ToArray();
			foreach (string originalStateMachinePathName in originalStateMachinePathNames)
			{
				string stateMachinePath = originalStateMachinePathName;
				// periods are used for concatenating State and StateMachine Names to get their paths.
				// Unity Editor doesn't allow periods in State and StateMachine Names.
				int pathDelimiterPos = stateMachinePath.LastIndexOf('.');
				// loop and trim StateMachine names from end of path
				while (pathDelimiterPos != -1)
				{
					stateMachinePath = stateMachinePath[..pathDelimiterPos];
					if (stateMachinePathNamesAndIDs.ContainsKey(stateMachinePath))
					{
						break;
					}
					else
					{
						uint stateMachinePathID = Checksum.Crc32Algorithm.HashUTF8(stateMachinePath);
						stateMachinePathNamesAndIDs.Add(stateMachinePath, stateMachinePathID);
					}
					pathDelimiterPos = stateMachinePath.LastIndexOf('.');
				}
			}
		}
	}

	public IStateConstant GetStateConstant(int index)
	{
		return IndexedStates[index].StateConstant;
	}

	public IAnimatorState GetState(int index)
	{
		return IndexedStates[index].State;
	}

	public int GetStateIndex(IAnimatorState? state)
	{
		if (state == null)
			return -1;

		return IndexedStates.IndexOf(s => s.State == state);
	}

	public uint GetParentForState(int index)
	{
		return IndexedStates[index].ParentStateMachineID;
	}

	public string GetStateMachinePath(int stateIndex)
	{
		uint stateMachinePathID = IndexedStates[stateIndex].ParentStateMachineID;
		return stateMachinePathNamesAndIDs[stateMachinePathID];
	}

	public void AddStateMachineFullPath(string fullPath, uint fullPathID)
	{
		stateMachinePathNamesAndIDs.Add(fullPath, fullPathID);
	}

	public bool TryGetStateMachinePath(uint fullPathID, out string fullPath)
	{
		if (stateMachinePathNamesAndIDs.TryGetValue(fullPathID, out string? pathName))
		{
			fullPath = pathName;
			return true;
		}

		fullPath = string.Empty;
		return false;
	}

	public bool TryGetStateMachinePathID(string fullPath, out uint fullPathID)
	{
		if (!string.IsNullOrEmpty(fullPath) && stateMachinePathNamesAndIDs.TryGetValue(fullPath, out uint fullPathId))
		{
			fullPathID = fullPathId;
			return true;
		}

		fullPathID = 0;
		return false;
	}

	public IEnumerable<string> GetUniqueStateMachinePaths()
	{
		return stateMachinePathNamesAndIDs.Keys;
	}

	public int GetUniqueStateMachinePathsCount()
	{
		return stateMachinePathNamesAndIDs.Count;
	}

	public IEnumerable<int> StateIndicesForStateMachine(uint fullPathID) // yield AnimatorStates from provided StateMachine FullPath
	{
		for (int i = 0; i < IndexedStates.Length; i++)
		{
			if (IndexedStates[i].ParentStateMachineID == fullPathID)
			{
				yield return i;
			}
		}
	}

	public IEnumerable<int> StateIndicesForStateMachine(string fullPath) // yield AnimatorStates from provided StateMachine FullPath
	{
		if (TryGetStateMachinePathID(fullPath, out uint fullPathID))
		{
			return StateIndicesForStateMachine(fullPathID);
		}
		return Array.Empty<int>();
	}

	private static string MakeStateMachinePath(AssetDictionary<uint, Utf8String> TOS, uint statePathID, string stateName)
	{
		string fullPath = TOS[statePathID];
		string stateMachinePath = fullPath[..(fullPath.Length - stateName.Length - 1)];
		return stateMachinePath;
	}

	/// <summary>
	/// Stores AnimatorState related data together.
	/// </summary>
	private readonly record struct StateData(IAnimatorState State, IStateConstant StateConstant, uint ParentStateMachineID);
}

```

`Source/AssetRipper.Processing/AnimatorControllers/AnimatorStateMachineContext.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Generics;
using AssetRipper.Checksum;
using AssetRipper.SourceGenerated.Classes.ClassID_1101;
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_1107;
using AssetRipper.SourceGenerated.Classes.ClassID_1109;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.ChildAnimatorState;
using AssetRipper.SourceGenerated.Subclasses.ChildAnimatorStateMachine;
using AssetRipper.SourceGenerated.Subclasses.LayerConstant;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorState;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorStateMachine;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorStateTransition;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorTransition;
using AssetRipper.SourceGenerated.Subclasses.SelectorStateConstant;
using AssetRipper.SourceGenerated.Subclasses.SelectorTransitionConstant;
using AssetRipper.SourceGenerated.Subclasses.StateConstant;
using AssetRipper.SourceGenerated.Subclasses.StateMachineConstant;
using AssetRipper.SourceGenerated.Subclasses.TransitionConstant;
using System.Diagnostics;
using System.Numerics;

namespace AssetRipper.Processing.AnimatorControllers;

internal sealed class AnimatorStateMachineContext
{
	public IAnimatorStateMachine RootStateMachine => IndexedStateMachines[0].StateMachine;

	private const uint StateMachineTransitionFlag = 30000;

	private readonly ProcessedAssetCollection VirtualFile;
	private readonly IAnimatorController Controller;
	private readonly IStateMachineConstant StateMachineConstant;
	private readonly int LayerIndex;
	private readonly ILayerConstant Layer;
	private readonly AnimatorStateContext StateContext;
	private readonly bool IsUnity5;

	[field: MaybeNull]
	private StateMachineData[] IndexedStateMachines
	{
		get => field ?? throw new NullReferenceException(nameof(IndexedStateMachines));
		set;
	}

	/// <summary>
	/// Restrictions for parenting Unknown StateMachines. Dict keys are the StateMachine array indexes
	/// </summary>
	private readonly Dictionary<int, ParentingRestrictions> UnknownStateMachineRestrictions = new();
	private readonly Dictionary<int, List<int>> UnknownStateMachinesRelations = new();

	private int UnknownFullPaths = 0;
	/// <summary>
	/// Used/Created when Unknown StateMachines couldn't be placed in any other FullPath StateMachine
	/// </summary>
	private IAnimatorStateMachine? ExtraStateMachine = null;
	/// <summary>
	/// A temporary invalid name: "."
	/// </summary>
	private static readonly Utf8String StateMachineFlagName = new(".");

	public AnimatorStateMachineContext(ProcessedAssetCollection virtualFile, IAnimatorController controller, int stateMachineIndex)
	{
		VirtualFile = virtualFile;
		Controller = controller;
		StateMachineConstant = controller.Controller.StateMachineArray[stateMachineIndex].Data;
		LayerIndex = controller.Controller.GetLayerIndexByStateMachineIndex(stateMachineIndex, out Layer);
		StateContext = new(virtualFile, controller, StateMachineConstant, LayerIndex);
		IsUnity5 = StateMachineConstant.Has_SelectorStateConstantArray();
	}

	/// <summary>
	/// Create all AnimatorStateMachines (Root and Children)
	/// </summary>
	public void Process()
	{
		StateContext.Process();

		InitializeStateMachines();

		if (IsUnity5) // Unity 5+
		{
			AssignStateMachineNames(); // assign Names and parents (FullPaths) to fully determined StateMachines

			// Goal for Unknown-FullPath StateMachines: place them as deep in hierarchy as possible.
			// Try to keep Unknown StateMachines that have Transitions between each other together,
			//   not nesting Unknown StateMachines into anothers, but having them "side-by-side" under the same fully determined (FullPath) parent.
			// Unknown StateMachines shouldn't contain any other StateMachine, except the following case...
			if (UnknownFullPaths != 0)
			{
				// Only child StateMachines (and child States) have access to their parent StateMachine ExitState
				// Try use this to find the true parents for some Unknown-FullPath StateMachines
				// Solve more FullPaths; may leave some StateMachines "flagged"
				// Flagged StateMachines have a set parent, but that parent is Unknown-FullPath, so the Flagged StateMachine can't solve its FullPath yet
				LocateUnknownStateMachinesWithExitStateTransition();

				if (UnknownFullPaths != 0)
				{
					// If the previous method didn't solve all Unknown StateMachines,
					//   will need to find restrictions for placing them in hierarchy.
					RestrictUnknownStateMachinePossibleParents();
				}
			}

			AssignStateMachineChildStates(); // assign child States to StateMachines and Create State Transitions

			CreateAnyStateTransitions(); // create AnyState Transitions for Root StateMachine

			if (UnknownFullPaths != 0)
			{
				// All State Transitions have been used for assigning possible StateMachine parents (parents only with FullPaths)
				//   to StateMachines with Unknown-FullPaths (Unknowns don't have Name neither).
				// There can still be Unknowns with no assigned possible parent.

				// Will try to use Entry StateMachine Transitions to locate them the same way like with State Transitions (deeper hierarchy wins),
				//   also only assigning parents with FullPath.
				LocateUnknownStateMachinesWithEntryTransition(true);

				// Then will try use Exit StateMachine Transitions to locate Unknowns.
				// Transitions from Unknowns to States will also follow "deeper hierarchy" rule.
				LocateUnknownStateMachinesWithEntryTransition(false);

				// During Entry and Exit Transitions scan, when a source Unknown went to a destination Unknown,
				//   a link was saved in UnknownStateMachinesRelations.
				// Use those links to try assign/share parents.
				ShareParentsBetweenUnknownStateMachines();

				// There may be Unknowns without possible parent (no connections/Transitions to FullPaths, or parenting was too restricted),
				//   and there may also be some Flaggeds.
				// Iterate through all FullPath StateMachines again and try find valid parents for Unknowns.
				FindParentsForLastUnknownStateMachines();

				// Finalize parenting for Unknown StateMachines with possible parent (generate FullPaths and Names for them)
				PromoteCurrentParentings();

				// All StateMachines have Name and possible parent now
			}

			CreateEntryTransitions(); // create Entry Transitions and set StateMachine Default States

			AssignChildStateMachines(); // Assign Child StateMachines and Create StateMachine Transitions
		}
		else // Unity 4-
		{
			// create AnyStateTransitions for Root StateMachine
			CreateAnyStateTransitions();
		}

		// Set StateMachine Children Positions for Editor
		SetChildrenPositions();
	}

	private void FindParentsForLastUnknownStateMachines()
	{
		bool allUnknownsReceivedParent = true;
		for (int i = 1; i < IndexedStateMachines.Length; i++) // skipping Root StateMachine at 0
		{
			StateMachineData stateMachineData = IndexedStateMachines[i];
			if (!stateMachineData.Name.IsEmpty || stateMachineData.ParentFullPathID != 0)
				continue; // iterate only through Unknowns without a possible parent

			bool parentAssigned = false;
			foreach (StateMachineData possibleParentData in IndexedStateMachines)
			{
				if (possibleParentData.Name.IsEmpty || possibleParentData.Name == StateMachineFlagName)
					continue; // only use FullPaths as parents

				parentAssigned = TryAssignPossibleParent(i, possibleParentData.FullPathID, false);
				if (parentAssigned)
					break; // if parent was assigned, don't check the rest of possible parents
			}

			allUnknownsReceivedParent = allUnknownsReceivedParent && parentAssigned;
		}

		if (!allUnknownsReceivedParent)
		{
			// If no valid parent found for the last Unknowns,
			//   will have to create an Extra StateMachine under Root, and put them in there (last resort, very unlikely)
			ExtraStateMachine = VirtualAnimationFactory.CreateStateMachine(VirtualFile, Controller, LayerIndex);
			ExtraStateMachine.Name = "Extra StateMachine";
			StateContext.AddStateMachineFullPath($"{RootStateMachine.Name}.{ExtraStateMachine.Name}", 0); // this will link all Unknowns without possible parent to ExtraStateMachine

			// give ExtraStateMachine a (Default) State to turn it into a FullPath StateMachine, in case of "re-ripping" this Animator Controller
			IAnimatorState ExtraState = VirtualAnimationFactory.CreateDefaultAnimatorState(VirtualFile);
			ChildAnimatorState childState = ExtraStateMachine.ChildStates!.AddNew();
			childState.State.SetAsset(ExtraStateMachine.Collection, ExtraState);
			ExtraStateMachine.DefaultStateP = ExtraState;
		}
	}

	private void PromoteCurrentParentings()
	{
		List<int> stateMachineIndexes = new();

		for (int i = 1; i < IndexedStateMachines.Length; i++) // skipping Root StateMachine at 0
		{
			StateMachineData stateMachine = IndexedStateMachines[i];
			if (stateMachine.Name.IsEmpty || // include Unknown StateMachines
				stateMachine.Name == StateMachineFlagName) // and Flagged StateMachines, in case its Unknown parent gets resolved
			{
				stateMachineIndexes.Add(i);
			}
		}

		GenerateFullPathsForUnknownStateMachines(stateMachineIndexes);
	}

	private void ShareParentsBetweenUnknownStateMachines()
	{
		bool linksUpdated = true;
		while (linksUpdated)
		{
			linksUpdated = false;

			foreach (KeyValuePair<int, List<int>> kvp in UnknownStateMachinesRelations)
			{
				int stateMachineIndex = kvp.Key;
				uint shareParentFullPathID = IndexedStateMachines[stateMachineIndex].ParentFullPathID;

				if (shareParentFullPathID == 0)
					continue; // skip StateMachines that don't have a possible parent to share

				List<int> linkedStateMachineIndexes = kvp.Value;
				foreach (int linkedStateMachineIndex in linkedStateMachineIndexes)
				{
					if (TryAssignPossibleParent(linkedStateMachineIndex, shareParentFullPathID))
					{
						// Can't have infinite loop, because of "strictly deeper in hierarchy" restriction in TryAssignPossibleParent.
						// There isn't infinite possible parents always deeper than previous ones.
						linksUpdated = true;
					}
				}
			}
		}
	}

	private void InitializeStateMachines()
	{
		if (StateMachineConstant.Has_SelectorStateConstantArray())
		{
			// Unity 5+

			int stateMachineCount = StateMachineConstant.StateMachineCount();
			IndexedStateMachines = new StateMachineData[stateMachineCount];

			// assuming SelectorStateConstantArray follows the sequence: [Entry1, Exit1, Entry2, Exit2, ...]
			// just in case, next code can handle StateMachines missing Entry or Exit SelectorStateConstant
			int stateMachineIndex = 0;
			uint? lastFullPathID = null;
			foreach (SelectorStateConstant ssc in StateMachineConstant.SelectorStateConstantArray)
			{
				SelectorTransitionConstant[]? transitions = ssc.TransitionConstantArray.Count == 0 ? null :
					ssc.TransitionConstantArray.Select(ptr => ptr.Data).ToArray();
				uint sscFullPathID = ssc.FullPathID;
				if (lastFullPathID != sscFullPathID)
				{
					IAnimatorStateMachine newStateMachine = VirtualAnimationFactory.CreateStateMachine(VirtualFile, Controller, LayerIndex, sscFullPathID);
					IndexedStateMachines[stateMachineIndex] = new(newStateMachine, sscFullPathID);
					if (ssc.IsEntry)
					{
						IndexedStateMachines[stateMachineIndex].EntryTransitions = transitions;
					}
					else
					{
						IndexedStateMachines[stateMachineIndex].ExitTransitions = transitions;
					}

					lastFullPathID = ssc.FullPathID;
					stateMachineIndex++;
				}
				else
				{
					if (ssc.IsEntry)
					{
						IndexedStateMachines[stateMachineIndex - 1].EntryTransitions = transitions;
					}
					else
					{
						IndexedStateMachines[stateMachineIndex - 1].ExitTransitions = transitions;
					}
				}
			}

			if (!StateContext.HasStates())
			{
				// No States to help resolve StateMachine Names
				// still can give Name to Root StateMachine using Layer
				string rootStateMachineName = Controller.TOS[Layer.Binding].String.Replace('.', '_');
				IndexedStateMachines[0].Name = rootStateMachineName;
			}
		}
		else
		{
			// Unity 4.x-

			int stateMachineCount = StateContext.HasStates() ? StateContext.GetUniqueStateMachinePathsCount() : 1;
			IndexedStateMachines = new StateMachineData[stateMachineCount];

			// StateMachines don't have FullPaths.
			// can set Names, Child States (with their Transitions),
			// Default State and Child StateMachines now
			if (!StateContext.HasStates())
			{
				// empty Main StateMachine. its better to resolve Name now
				IAnimatorStateMachine stateMachine = VirtualAnimationFactory.CreateStateMachine(VirtualFile, Controller, LayerIndex);
				stateMachine.Name = Controller.TOS[Layer.Binding].String.Replace('.', '_');
				IndexedStateMachines[0] = new(stateMachine);
			}
			else
			{
				// set Root StateMachine Name from DefaultState Path
				IAnimatorStateMachine mainStateMachine = VirtualAnimationFactory.CreateStateMachine(VirtualFile, Controller, LayerIndex);
				string mainStateMachineName = StateContext.GetStateMachinePath(StateContext.DefaultStateIndex);
				mainStateMachine.Name = mainStateMachineName;
				mainStateMachine.DefaultStateP = StateContext.GetState(StateContext.DefaultStateIndex);
				mainStateMachine.SetChildStateMachineCapacity(IndexedStateMachines.Length - 1);

				// ensure Root StateMachine will be at index 0
				IndexedStateMachines[0] = new(mainStateMachine);
				// initialize the rest of StateMachines
				int j = 1;
				foreach (string stateMachineName in StateContext.GetUniqueStateMachinePaths())
				{
					if (stateMachineName != mainStateMachineName)
					{
						IAnimatorStateMachine stateMachine = VirtualAnimationFactory.CreateStateMachine(VirtualFile, Controller, LayerIndex);
						stateMachine.Name = stateMachineName;
						IndexedStateMachines[j] = new(stateMachine);
						j++;
						// set Child StateMachines
						mainStateMachine.ChildStateMachineP.Add(stateMachine);
					}
				}

				// set Child States with their Transitions
				for (int i = 0; i < IndexedStateMachines.Length; i++)
				{
					StateMachineData stateMachineData = IndexedStateMachines[i];
					int childStateCount = StateContext.StateIndicesForStateMachine(stateMachineData.FullPathID).Count();
					stateMachineData.StateMachine.SetChildStateCapacity(childStateCount);
					foreach (int stateIndex in StateContext.StateIndicesForStateMachine(stateMachineData.FullPathID))
					{
						AddStateAndTransitionsToStateMachine(i, stateIndex);
					}
				}
			}
		}

		Debug.Assert(IndexedStateMachines.Select(x => x.StateMachine).Distinct().Count() == IndexedStateMachines.Length);
	}

	private void AddStateAndTransitionsToStateMachine(int parentStateMachineIndex, int stateIndex)
	{
		// -- add child State to stateMachine --
		IAnimatorState state = StateContext.GetState(stateIndex);
		IStateConstant stateConstant = StateContext.GetStateConstant(stateIndex);
		IAnimatorStateMachine parentStateMachine = IndexedStateMachines[parentStateMachineIndex].StateMachine;
		if (parentStateMachine.Has_ChildStates())
		{
			ChildAnimatorState childState = parentStateMachine.ChildStates.AddNew();
			// set childState.Position later, when having all Children set
			childState.State.SetAsset(parentStateMachine.Collection, state);
		}
		else
		{
			parentStateMachine.StatesP.Add(state);
		}
		// set state.Position later, when having all Children set

		// -- add State Transitions --
		AssetList<PPtr_AnimatorStateTransition_4>? transitionList = null;
		if (state.Has_Transitions())
		{
			//Not sure if it's correct for the state transitions to be non-empty, but I encountered it in some files.
			state.Transitions.Capacity = state.Transitions.Count + stateConstant.TransitionConstantArray.Count;
		}
		else if (parentStateMachine.Has_OrderedTransitions())
		{
			//I'm not sure if this is correct, but it seems to be the only logical way to store the transitions before Unity 5.
			//IAnimatorStateMachine.LocalTransitions only exists until Unity 4.2.0, so by process of elimination, this is the only option.

			AssetPair<PPtr_AnimatorState_4, AssetList<PPtr_AnimatorStateTransition_4>> pair = parentStateMachine.OrderedTransitions.AddNew();
			pair.Key.SetAsset(parentStateMachine.Collection, state);
			transitionList = pair.Value;
		}
		for (int j = 0; j < stateConstant.TransitionConstantArray.Count; j++)
		{
			ITransitionConstant transitionConstant = stateConstant.TransitionConstantArray[j].Data;
			IAnimatorStateTransition? transition = CreateAnimatorStateTransition(parentStateMachineIndex, transitionConstant);
			if (transition != null)
			{
				if (state.Has_Transitions())
				{
					state.TransitionsP.Add(transition);
				}
				else
				{
					transitionList?.AddNew().SetAsset(parentStateMachine.Collection, transition);
				}
			}
		}
	}

	private IAnimatorStateTransition? CreateAnimatorStateTransition(int parentStateMachineIndex, ITransitionConstant Transition)
	{
		if (!TryGetDestinationState(Transition.DestinationState, out IAnimatorState? stateDestination, out int stateMachineDestinationIndex, out bool isEntryDestination))
		{
			return null;
		}

		IAnimatorStateTransition animatorStateTransition = VirtualAnimationFactory.CreateAnimatorStateTransition(VirtualFile, Controller.TOS, Transition);

		if (stateDestination != null) // destination is State
		{
			animatorStateTransition.DestinationStateP = stateDestination;
		}
		else if (IsUnity5 && stateMachineDestinationIndex != -1) // destination is StateMachine
		{
			IAnimatorStateMachine stateMachineDestination = IndexedStateMachines[stateMachineDestinationIndex].StateMachine;
			if (isEntryDestination)
			{
				animatorStateTransition.DestinationStateMachineP = stateMachineDestination;

				if (stateMachineDestination.Name.IsEmpty || stateMachineDestination.Name == StateMachineFlagName) // try locate StateMachine with Unknown FullPath
				{
					if (stateMachineDestination.Name == StateMachineFlagName) // Flagged StateMachine has a set parent already, apply possible parent to its Unknown parent
						stateMachineDestinationIndex = GetUnknownParentForFlaggedStateMachine(stateMachineDestinationIndex);

					uint parentStateMachineFullPathID = IndexedStateMachines[parentStateMachineIndex].FullPathID; // new possible parent. will have FullPath because it contains a State (from this Transition)
					TryAssignPossibleParent(stateMachineDestinationIndex, parentStateMachineFullPathID);
				}
			}
			else
			{
				animatorStateTransition.IsExit = true;
			}
		}

		return animatorStateTransition;
	}

	private bool TryGetDestinationState(uint destinationState, out IAnimatorState? stateDestination, out int stateMachineDestinationIndex, out bool isEntryDestination)
	{
		stateDestination = null;
		stateMachineDestinationIndex = -1;
		isEntryDestination = false;
		if (destinationState == uint.MaxValue)
		{
			return false;
		}
		if (destinationState >= StateMachineTransitionFlag)
		{
			// Entry and Exit from StateMachines
			if (StateMachineConstant.Has_SelectorStateConstantArray())
			{
				uint stateIndex = destinationState % StateMachineTransitionFlag;
				if (stateIndex >= StateMachineConstant.SelectorStateConstantArray.Count)
				{
					return false;
				}

				SelectorStateConstant selectorState = StateMachineConstant.SelectorStateConstantArray[(int)stateIndex].Data;
				stateMachineDestinationIndex = GetStateMachineIndexForId(selectorState.FullPathID);
				isEntryDestination = selectorState.IsEntry;
				return true;
			}
			return false;
		}
		else
		{
			// State
			stateDestination = StateContext.GetState((int)destinationState);
			return true;
		}
	}

	private int GetStateMachineIndexForId(uint fullPathID)
	{
		return IndexedStateMachines.IndexOf(ism => ism.FullPathID == fullPathID);
	}

	private static bool IsDeeperHierarchy(string currentPath, string newPath)
	{
		int currentDepth = currentPath.Count(ch => ch == '.');
		int newDepth = newPath.Count(ch => ch == '.');
		return newDepth > currentDepth;
	}

	private void CreateAnyStateTransitions()
	{
		int anyStateTransitionCount = StateMachineConstant.AnyStateTransitionConstantArray.Count;
		if (anyStateTransitionCount > 0 && StateContext.HasStates())
		{
			if (RootStateMachine.Has_AnyStateTransitions())
			{
				RootStateMachine.AnyStateTransitions.Capacity = anyStateTransitionCount;
				RootStateMachine.AnyStateTransitionsP.AddRange(GetAnyStateTransitions());
			}
			else
			{
				AssetList<PPtr_AnimatorStateTransition_4> newList = RootStateMachine.OrderedTransitions.AddNew().Value;
				newList.Capacity = anyStateTransitionCount;
				PPtrAccessList<PPtr_AnimatorStateTransition_4, IAnimatorStateTransition> anyStateTransitions2 = new(newList, RootStateMachine.Collection);
				anyStateTransitions2.AddRange(GetAnyStateTransitions());
			}
		}

		IEnumerable<IAnimatorStateTransition> GetAnyStateTransitions()
		{
			for (int i = 0; i < anyStateTransitionCount; i++)
			{
				ITransitionConstant transitionConstant = StateMachineConstant.AnyStateTransitionConstantArray[i].Data;
				IAnimatorStateTransition? transition = CreateAnimatorStateTransition(0, transitionConstant);
				if (transition != null)
				{
					yield return transition;
				}
			}
		}
	}

	private void AssignStateMachineNames()
	{
		if (!StateContext.HasStates())
			return;

		foreach (StateMachineData stateMachineData in IndexedStateMachines)
		{
			if (StateContext.TryGetStateMachinePath(stateMachineData.FullPathID, out string stateMachineFullPath))
			{
				// periods are used for concatenating State and StateMachine Names to get their paths.
				// Unity Editor doesn't allow periods in State and StateMachine Names.
				int pathDelimiterPos = stateMachineFullPath.LastIndexOf('.');
				if (pathDelimiterPos != -1)
				{
					string parentStateMachineFullPath = stateMachineFullPath[..pathDelimiterPos];
					if (StateContext.TryGetStateMachinePathID(parentStateMachineFullPath, out uint parentStateMachineFullPathID)) // this shouldn't fail because the FullPath was already found 
					{
						// the child StateMachine's PathID will match its parent StateMachine's FullPathID
						stateMachineData.ParentFullPathID = parentStateMachineFullPathID; // this links the i'th stateMachine with its true parent
						stateMachineData.Name = stateMachineFullPath[(pathDelimiterPos + 1)..]; // can set its true Name
					}
				}
				else
				{
					// if FullPath doesn't have delimiter '.' , it should be Root StateMachine
					stateMachineData.Name = stateMachineFullPath;
				}
			}
			else
			{
				UnknownFullPaths++;
				// StateMachine with non recoverable FullPath, because doesn't contain States.
				// Keep StateMachine Name empty as signal to keep looking for a fully determined (FullPath) StateMachine parent
				//   through Transition connections.
			}
		}
	}

	private void AssignStateMachineChildStates()
	{
		if (!StateContext.HasStates())
			return;

		// Assign Child States and State Transitions.
		// Has to be after assigning StateMachine Names/FullPaths and finding parenting restrictions,
		//   to apply extra analysis for locating Unknown-FullPath StateMachines
		for (int i = 0; i < IndexedStateMachines.Length; i++)
		{
			StateMachineData stateMachineData = IndexedStateMachines[i];
			if (stateMachineData.Name.IsEmpty)
				continue; // Unknown StateMachines don't contain States
			uint fullPathID = stateMachineData.FullPathID;
			int childStateCount = StateContext.StateIndicesForStateMachine(fullPathID).Count();
			stateMachineData.StateMachine.SetChildStateCapacity(childStateCount);
			if (childStateCount == 0)
				continue;
			foreach (int stateIndex in StateContext.StateIndicesForStateMachine(fullPathID))
			{
				AddStateAndTransitionsToStateMachine(i, stateIndex);
			}
		}
	}

	private void LocateUnknownStateMachinesWithEntryTransition(bool doEntryTransitions)
	{
		for (int _stateMachineSourceIndex = 0; _stateMachineSourceIndex < IndexedStateMachines.Length; _stateMachineSourceIndex++)
		{
			int stateMachineSourceIndex = _stateMachineSourceIndex;
			StateMachineData stateMachineSource = IndexedStateMachines[stateMachineSourceIndex];
			SelectorTransitionConstant[]? Transitions = doEntryTransitions ? stateMachineSource.EntryTransitions : stateMachineSource.ExitTransitions;
			if (Transitions == null)
				continue;

			if (stateMachineSource.Name == StateMachineFlagName)
			{
				// Flagged StateMachine has a set parent already, but that parent is Unknown-FullPath, so transfer the relations to parent
				stateMachineSourceIndex = GetUnknownParentForFlaggedStateMachine(stateMachineSourceIndex);
				stateMachineSource = IndexedStateMachines[stateMachineSourceIndex];
			}

			foreach (SelectorTransitionConstant selectorTransition in Transitions)
			{
				if (!TryGetDestinationState(selectorTransition.Destination, out IAnimatorState? stateDestination, out int stateMachineDestinationIndex, out bool isEntryDestination))
					continue;

				if (stateDestination != null) // destination is State
				{
					if (!stateMachineSource.Name.IsEmpty)
						continue; // try assign possible parent only to Unknown StateMachines
					int stateIndex = (int)selectorTransition.Destination;
					AssignPossibleParentFromState(stateMachineSourceIndex, stateIndex);
				}
				else if ((doEntryTransitions || isEntryDestination) && // skip Exit Transition with ExitState destination
					stateMachineDestinationIndex != -1) // destination is StateMachine
				{
					StateMachineData stateMachineDestination = IndexedStateMachines[stateMachineDestinationIndex];
					if (stateMachineDestination.Name == StateMachineFlagName)
					{
						// Flagged StateMachine has a set parent already, but that parent is Unknown-FullPath, so transfer the relations to parent
						stateMachineDestinationIndex = GetUnknownParentForFlaggedStateMachine(stateMachineDestinationIndex);
						stateMachineDestination = IndexedStateMachines[stateMachineDestinationIndex];
					}

					int decision = (stateMachineSource.Name.IsEmpty ? 1 : 0) + (stateMachineDestination.Name.IsEmpty ? 2 : 0);
					switch (decision) // just want to avoid nesting IFs
					{
						case 0: // both have FullPaths already
							break;

						case 1: // Unknown StateMachine Source goes to FullPath StateMachine Destination
							if (doEntryTransitions)
							{
								TryAssignPossibleParent(stateMachineSourceIndex, stateMachineDestination.FullPathID);
							}
							else // due to the Exit Transition restrictions, will offer parent of Destination as possible parent for Source
							{
								if (stateMachineDestinationIndex != 0) // skip Root StateMachine, doesn't have parent!
									TryAssignPossibleParent(stateMachineSourceIndex, stateMachineDestination.ParentFullPathID);
							}
							break;

						case 2: // FullPath StateMachine Source goes to Unknown StateMachine Destination
							if (doEntryTransitions)
							{
								TryAssignPossibleParent(stateMachineDestinationIndex, stateMachineSource.FullPathID);
							}
							else // due to the Exit Transition restrictions, will offer parent of Source as possible parent for Destination
							{
								if (stateMachineSourceIndex != 0) // skip Root StateMachine, doesn't have parent!
									TryAssignPossibleParent(stateMachineDestinationIndex, stateMachineSource.ParentFullPathID);
							}
							break;

						case 3: // both are Unknown StateMachines, link them together for resolving hierarchy later
							{
								if (!UnknownStateMachinesRelations.TryGetValue(stateMachineSourceIndex, out List<int>? relatedStateMachinesIndexes))
								{
									relatedStateMachinesIndexes = new();
									UnknownStateMachinesRelations[stateMachineSourceIndex] = relatedStateMachinesIndexes;
								}
								if (!relatedStateMachinesIndexes.Contains(stateMachineDestinationIndex))
									relatedStateMachinesIndexes.Add(stateMachineDestinationIndex);
								if (!UnknownStateMachinesRelations.TryGetValue(stateMachineDestinationIndex, out relatedStateMachinesIndexes))
								{
									relatedStateMachinesIndexes = new();
									UnknownStateMachinesRelations[stateMachineDestinationIndex] = relatedStateMachinesIndexes;
								}
								if (!relatedStateMachinesIndexes.Contains(stateMachineSourceIndex))
									relatedStateMachinesIndexes.Add(stateMachineSourceIndex);
							}
							break;
					}
				}
			}
		}
	}

	private int GetUnknownParentForFlaggedStateMachine(int flagStateMachineIndex)
	{
		// There can be Flagged StateMachines nested into other Flaggeds,
		//   but going up its sub-hierarchy there will always be an Unknown-FullPath StateMachine (no Name)

		uint parentFullPathID = IndexedStateMachines[flagStateMachineIndex].ParentFullPathID;
		int parentIndex = GetStateMachineIndexForId(parentFullPathID);
		while (!IndexedStateMachines[parentIndex].Name.IsEmpty)
		{
			parentFullPathID = IndexedStateMachines[parentIndex].ParentFullPathID;
			parentIndex = GetStateMachineIndexForId(parentFullPathID);
		}
		return parentIndex;
	}

	private void CreateEntryTransitions()
	{
		foreach (StateMachineData stateMachineData in IndexedStateMachines)
		{
			IAnimatorStateMachine stateMachine = stateMachineData.StateMachine;
			SelectorTransitionConstant[]? entryTransitions = stateMachineData.EntryTransitions;
			if (entryTransitions == null)
			{
				continue;
			}

			// Entry Transitions for StateMachine
			stateMachine.SetEntryTransitionsCapacity(entryTransitions.Length - 1);
			for (int j = 0; j < entryTransitions.Length - 1; j++)
			{
				SelectorTransitionConstant selectorTransition = entryTransitions[j];
				IAnimatorTransition? transition = CreateAnimatorTransition(selectorTransition);
				if (transition != null)
				{
					stateMachine.EntryTransitionsP.Add(transition);
				}
			}

			// Default State for StateMachine
			uint destination = entryTransitions[^1].Destination;
			if (destination != uint.MaxValue)
			{
				int defaultStateIndex = (int)destination;
				IAnimatorState defaultState = StateContext.GetState(defaultStateIndex);
				stateMachine.DefaultStateP = defaultState;
			}
		}
	}

	private IAnimatorTransition? CreateAnimatorTransition(SelectorTransitionConstant transition)
	{
		if (!TryGetDestinationState(transition.Destination, out IAnimatorState? stateDestination, out int stateMachineDestinationIndex, out bool isEntryDestination))
		{
			return null;
		}

		IAnimatorTransition animatorTransition = VirtualAnimationFactory.CreateAnimatorTransition(VirtualFile, Controller.TOS, transition);

		if (stateDestination != null)
		{
			animatorTransition.DestinationStateP = stateDestination;
		}
		else if (IsUnity5 && stateMachineDestinationIndex != -1)
		{
			if (isEntryDestination)
			{
				IAnimatorStateMachine stateMachineDestination = IndexedStateMachines[stateMachineDestinationIndex].StateMachine;
				animatorTransition.DestinationStateMachineP = stateMachineDestination;
			}
			else
			{
				animatorTransition.IsExit = true;
			}
		}

		return animatorTransition;
	}

	private void AssignChildStateMachines()
	{
		for (int childIndex = 1; childIndex < IndexedStateMachines.Length; childIndex++) // skipping 0 because its the Root StateMachine
		{
			StateMachineData childStateMachineData = IndexedStateMachines[childIndex];
			IAnimatorStateMachine childStateMachine = childStateMachineData.StateMachine;
			IAnimatorStateMachine parentStateMachine;
			if (childStateMachineData.ParentFullPathID == 0) // Unknown StateMachines without possible parent are assigned to ExtraStateMachine
			{
				parentStateMachine = ExtraStateMachine!;
			}
			else
			{
				int parentIndex = GetStateMachineIndexForId(childStateMachineData.ParentFullPathID);
				parentStateMachine = IndexedStateMachines[parentIndex].StateMachine;
			}

			// set Child StateMachine for its found Parent
			if (parentStateMachine.Has_ChildStateMachines())
			{
				ChildAnimatorStateMachine child = parentStateMachine.ChildStateMachines.AddNew();
				child.StateMachine.SetAsset(parentStateMachine.Collection, childStateMachine);
			}
			else
			{
				PPtr_AnimatorStateMachine_4 child = parentStateMachine.ChildStateMachine.AddNew();
				child.SetAsset(parentStateMachine.Collection, childStateMachine);
			}

			// add StateMachine Transitions (Transitions from Child are stored in Parent)
			SelectorTransitionConstant[]? exitTransitions = childStateMachineData.ExitTransitions;
			if (exitTransitions != null)
			{
				// check if its the default exit transition, to not add it
				if (exitTransitions.Length == 1 && exitTransitions[0].ConditionConstantArray.Count == 0)
				{
					uint stateDestinationId = exitTransitions[0].Destination;
					if (stateDestinationId < StateMachineTransitionFlag)
					{
						int stateDestinationIndex = (int)stateDestinationId;
						int defaultStateIndex = StateContext.GetStateIndex(parentStateMachine.DefaultStateP);
						if (defaultStateIndex == stateDestinationIndex)
						{
							continue;
						}
					}
				}

				AssetPair<PPtr_AnimatorStateMachine_5, AssetList<PPtr_AnimatorTransition>> newPair =
						parentStateMachine.StateMachineTransitions!.AddNew();
				newPair.Key.SetAsset(parentStateMachine.Collection, childStateMachine);
				PPtrAccessList<PPtr_AnimatorTransition, IAnimatorTransition> transitions = new(newPair.Value, parentStateMachine.Collection);
				for (int j = 0; j < exitTransitions.Length; j++)
				{
					SelectorTransitionConstant selectorTransition = exitTransitions[j];
					IAnimatorTransition? transition = CreateAnimatorTransition(selectorTransition);
					if (transition != null)
					{
						transitions.Add(transition);
					}
				}

				if (transitions.Count != 0)
				{
					newPair.Value.Capacity = newPair.Value.Count;
				}
				else
				{
					parentStateMachine.StateMachineTransitions.RemoveAt(^1);
				}
			}
		}

		// set ExtraStateMachine as child of RootStateMachine
		if (ExtraStateMachine != null)
		{
			ChildAnimatorStateMachine child = RootStateMachine.ChildStateMachines!.AddNew();
			child.StateMachine.SetAsset(RootStateMachine.Collection, ExtraStateMachine);

			ExtraStateMachine.TrimChildStateMachines(); // fix Child List Capacity
		}

		// fix Child List Capacity
		foreach (StateMachineData parent in IndexedStateMachines)
		{
			parent.StateMachine.TrimChildStateMachines();
		}
	}

	private void SetChildrenPositions()
	{
		foreach (StateMachineData stateMachineData in IndexedStateMachines)
		{
			ProcessChildrenPosForStateMachine(stateMachineData.StateMachine);
		}
		if (ExtraStateMachine != null)
		{
			ProcessChildrenPosForStateMachine(ExtraStateMachine);
		}
	}

	private void ProcessChildrenPosForStateMachine(IAnimatorStateMachine stateMachine)
	{
		const int StateOffsetX = 250;
		const int StateOffsetY = 100;

		int stateCount = stateMachine.ChildStatesCount();
		int stateMachineCount = stateMachine.ChildStateMachinesCount();
		int totalChildrenCount = stateCount + stateMachineCount;
		int side = (int)Math.Ceiling(Math.Sqrt(totalChildrenCount));

		for (int y = 0, i = 0; y < side && i < totalChildrenCount; y++)
		{
			for (int x = 0; x < side && i < totalChildrenCount; x++, i++)
			{
				Vector3 position = new() { X = x * StateOffsetX, Y = y * StateOffsetY };
				// Position all Child States first
				if (i < stateCount)
				{
					IAnimatorState? state;
					if (stateMachine.Has_ChildStates())
					{
						ChildAnimatorState childState = stateMachine.ChildStates[i];
						childState.Position.CopyValues(position);
						childState.State.TryGetAsset(stateMachine.Collection, out state);
					}
					else
					{
						state = stateMachine.StatesP[i];
					}
					state?.Position.CopyValues(position);
				}
				// Position all Child StateMachines second 
				else if (stateMachine.Has_ChildStateMachines())
				{
					ChildAnimatorStateMachine csm = stateMachine.ChildStateMachines[i - stateCount];
					csm.Position.CopyValues(position);
				}
				else
				{
					stateMachine.ChildStateMachinePosition.AddNew().CopyValues(position);
				}
			}
		}

		stateMachine.AnyStatePosition.SetValues(0.0f, -StateOffsetY, 0.0f);
		stateMachine.EntryPosition?.SetValues(StateOffsetX, -StateOffsetY, 0.0f);
		stateMachine.ExitPosition?.SetValues(2.0f * StateOffsetX, -StateOffsetY, 0.0f);
		stateMachine.ParentStateMachinePosition.SetValues(0.0f, -2.0f * StateOffsetY, 0.0f);
	}

	private void AssignPossibleParentFromState(int stateMachineIndex, int stateIndex) // try assign deeper hierarchy parent for stateMachine
	{
		uint possibleParentStateMachineFullPathID = StateContext.GetParentForState(stateIndex); // get parent StateMachine of State (will have FullPath)
		TryAssignPossibleParent(stateMachineIndex, possibleParentStateMachineFullPathID);
	}

	private bool TryAssignPossibleParent(int stateMachineIndex, uint possibleParentStateMachineFullPathID, bool recursive = true)
	{
		uint currentParentFullPathID = IndexedStateMachines[stateMachineIndex].ParentFullPathID; // current possible parent for Unknown stateMachine
		if (!StateContext.TryGetStateMachinePath(currentParentFullPathID, out string destinationPath)) // if current parent is not set yet (0)
		{
			if (StateContext.TryGetStateMachinePath(possibleParentStateMachineFullPathID, out string parentPath)) // always true for FullPath, getting parentPath here
			{
				if (ParentRestrictionsPassed(stateMachineIndex, possibleParentStateMachineFullPathID, parentPath)) // if passes parent restrictions
				{
					IndexedStateMachines[stateMachineIndex].ParentFullPathID = possibleParentStateMachineFullPathID; // possible parent assigned
					return true;
				}
				if (!recursive)
					return false;
				// if offered parent wasn't valid, try with its parent. Recursive
				int possibleParentIndex = GetStateMachineIndexForId(possibleParentStateMachineFullPathID);
				if (possibleParentIndex != 0) // Root StateMachine doesn't have parent
				{
					return TryAssignPossibleParent(stateMachineIndex, IndexedStateMachines[possibleParentIndex].ParentFullPathID);
				}
			}
		}
		else if (currentParentFullPathID != possibleParentStateMachineFullPathID && // else if possible parent is different that current
			StateContext.TryGetStateMachinePath(possibleParentStateMachineFullPathID, out string parentPath) && // always true for FullPath, getting parentPath here
			IsDeeperHierarchy(destinationPath, parentPath)) // if new possible parent has deeper hierarchy
		{
			if (ParentRestrictionsPassed(stateMachineIndex, possibleParentStateMachineFullPathID, parentPath)) // if passes parent restrictions
			{
				IndexedStateMachines[stateMachineIndex].ParentFullPathID = possibleParentStateMachineFullPathID; // possible parent assigned
				return true;
			}
			if (!recursive)
				return false;
			// if offered parent wasn't valid, try with its parent. Recursive
			int possibleParentIndex = GetStateMachineIndexForId(possibleParentStateMachineFullPathID);
			if (possibleParentIndex != 0) // Root StateMachine doesn't have parent
			{
				return TryAssignPossibleParent(stateMachineIndex, IndexedStateMachines[possibleParentIndex].ParentFullPathID);
			}
		}
		return false;
	}

	private void LocateUnknownStateMachinesWithExitStateTransition()
	{
		List<int> TryAssignNames = new();
		for (int stateMachineIndex = 0; stateMachineIndex < IndexedStateMachines.Length; stateMachineIndex++)
		{
			StateMachineData stateMachine = IndexedStateMachines[stateMachineIndex];
			if (!stateMachine.Name.IsEmpty) // check Unknown FullPaths only
				continue;
			SelectorTransitionConstant[]? exitTransitions = stateMachine.ExitTransitions;
			if (exitTransitions == null)
				continue;
			foreach (SelectorTransitionConstant selectorTransition in exitTransitions)
			{
				if (!TryGetDestinationState(selectorTransition.Destination, out IAnimatorState? stateDestination, out int stateMachineDestinationIndex, out bool isEntryDestination)
					|| stateDestination != null // check Transitions with StateMachine destination only
					|| isEntryDestination) // destination has to be the StateMachine's Exit State (not Entry destination)
					continue;

				// set definitive parent for stateMachineIndex
				uint parentFullPathID = IndexedStateMachines[stateMachineDestinationIndex].FullPathID;
				stateMachine.ParentFullPathID = parentFullPathID;
				// change Name to signal it has a definitive parent, but final Name/Path is still to be determined
				stateMachine.Name = StateMachineFlagName;
				TryAssignNames.Add(stateMachineIndex);
				break;
			}
		}

		GenerateFullPathsForUnknownStateMachines(TryAssignNames);

		// Now there can exist some Flagged StateMachines: Unknown-FullPath StateMachines with their true parents already found,
		//   but those parents are still Unknown-FullPath StateMachines themselves.
		// This found "sub hierarchies" are still not fully "anchored" to the complete StateMachine hierarchy.
		// Avoid assigning Flagged StateMachines as parents, only use FullPath StateMachines for that.
	}

	/// <summary>
	/// Generate Names and FullPaths for Unknown StateMachines, that have FullPath parent
	/// </summary>
	private void GenerateFullPathsForUnknownStateMachines(List<int> FlaggedOrUnknownStateMachineIndexes)
	{
		int listCount = FlaggedOrUnknownStateMachineIndexes.Count;
		bool shouldTryAssignNames = listCount > 0;
		while (shouldTryAssignNames)
		{
			shouldTryAssignNames = false; // infinite loop proof. only true if List depletes, and List doesn't get new items here
			for (int i = listCount - 1; i >= 0; i--)
			{
				int stateMachineIndex = FlaggedOrUnknownStateMachineIndexes[i]; // StateMachine to get a FullPath
				StateMachineData stateMachineData = IndexedStateMachines[stateMachineIndex];
				if (StateContext.TryGetStateMachinePath(stateMachineData.ParentFullPathID, out string parentFullPath)) // if its parent has FullPath...
				{
					// ...generate its own FullPath and Name
					uint stateMachineFullPathID = stateMachineData.FullPathID;
					string newFullPath = GetReversedFullPath(parentFullPath, stateMachineFullPathID);
					int pathDelimiterPos = newFullPath.LastIndexOf('.');
					string newName = newFullPath[(pathDelimiterPos + 1)..]; // Name will be "EMPTY_" + something
					stateMachineData.Name = newName;
					StateContext.AddStateMachineFullPath(newFullPath, stateMachineFullPathID); // this "promotes" the Unknown StateMachine to be a FullPath StateMachine
					FlaggedOrUnknownStateMachineIndexes.RemoveAt(i);
					UnknownFullPaths--;
					shouldTryAssignNames = true; // if the stateMachine was promoted, it could now be a valid parent for another StateMachine in the list; scan again
				}
			}
			listCount = FlaggedOrUnknownStateMachineIndexes.Count;
		}
	}

	private void RestrictUnknownStateMachinePossibleParents()
	{
		for (int stateMachineSourceIndex = 0; stateMachineSourceIndex < IndexedStateMachines.Length; stateMachineSourceIndex++)
		{
			StateMachineData sourceStateMachineData = IndexedStateMachines[stateMachineSourceIndex];
			// only Exit Transitions can restrict StateMachine parenting, other Transitions are fully unrestricted
			SelectorTransitionConstant[]? exitTransitions = sourceStateMachineData.ExitTransitions;
			if (exitTransitions == null)
				continue;
			foreach (SelectorTransitionConstant selectorTransition in exitTransitions)
			{
				if (!TryGetDestinationState(selectorTransition.Destination, out IAnimatorState? stateDestination, out int stateMachineDestinationIndex, out bool isEntryDestination)
					|| stateDestination != null // check Transitions with StateMachine destination only
					|| !isEntryDestination) // destination has to be a StateMachine's Entry port
					continue;
				StateMachineData stateMachineDestination = IndexedStateMachines[stateMachineDestinationIndex];

				// Rule 1) destination StateMachine cannot be in/under source StateMachine
				if (StateContext.TryGetStateMachinePath(sourceStateMachineData.FullPathID, out string stateMachineSourceFullPath)) // if source has FullPath...
				{
					// ...it can restrict destination StateMachine
					if (!stateMachineDestination.Name.IsEmpty)
					{
						if (stateMachineDestination.Name != StateMachineFlagName)
							continue; // don't try to restrict a FullPath StateMachine!

						// Flagged StateMachine has a set parent already, but that parent is Unknown-FullPath, so transfer the restrictions to parent
						stateMachineDestinationIndex = GetUnknownParentForFlaggedStateMachine(stateMachineDestinationIndex);
					}
					if (!UnknownStateMachineRestrictions.TryGetValue(stateMachineDestinationIndex, out ParentingRestrictions pr))
					{
						pr = new();
						UnknownStateMachineRestrictions[stateMachineDestinationIndex] = pr;
					}
					if (pr.NotUnder.All(fullPath => !stateMachineSourceFullPath.StartsWith(fullPath)))
						pr.NotUnder.Add(stateMachineSourceFullPath);
				}
				// Rule 2) destination StateMachine cannot be parent of source StateMachine
				else if (!stateMachineDestination.Name.IsEmpty && stateMachineDestination.Name != StateMachineFlagName) // source is Unknown or Flagged; if destination has FullPath...
				{
					// ...it can restrict source StateMachine
					if (sourceStateMachineData.Name == StateMachineFlagName)
					{
						// Flagged StateMachine has a set parent already, this restriction isn't needed
						continue;
					}
					if (!UnknownStateMachineRestrictions.TryGetValue(stateMachineSourceIndex, out ParentingRestrictions pr))
					{
						pr = new();
						UnknownStateMachineRestrictions[stateMachineSourceIndex] = pr;
					}
					if (!pr.NoDirect.Contains(stateMachineDestination.FullPathID))
						pr.NoDirect.Add(stateMachineDestination.FullPathID);
				}
			}
		}

		// simplify restrictions
		foreach (ParentingRestrictions pr in UnknownStateMachineRestrictions.Values)
		{
			if (pr.NotUnder.Count > 1) // remove StateMachine FullPaths from NotUnder when contained in another NotUnder FullPath
			{
				string[] temp = pr.NotUnder.Where(fullPath => pr.NotUnder.All(otherFullPath => fullPath == otherFullPath || !fullPath.StartsWith(otherFullPath))).ToArray();
				pr.NotUnder.Clear();
				pr.NotUnder.AddRange(temp);
			}

			for (int i = pr.NoDirect.Count - 1; i >= 0; i--) // remove StateMachine FullPaths from NoDirect when contained in NotUnder 
			{
				if (StateContext.TryGetStateMachinePath(pr.NoDirect[i], out string fullPath)) // always true, getting fullPath here
				{
					if (pr.NotUnder.Any(_fullPath => fullPath.StartsWith(_fullPath)))
						pr.NoDirect.RemoveAt(i);
				}
			}
		}
	}

	private bool ParentRestrictionsPassed(int stateMachineIndex, uint parentFullPathID, string parentFullPath)
	{
		if (!UnknownStateMachineRestrictions.TryGetValue(stateMachineIndex, out ParentingRestrictions pr))
			return true;
		if (pr.NoDirect.Contains(parentFullPathID) ||
			pr.NotUnder.Any(badFullPath => parentFullPath.StartsWith(badFullPath)))
			return false;
		return true;
	}

	private static string GetReversedFullPath(string parentFullPath, uint fullPathID)
	{
		return Crc32Algorithm.ReverseUTF8(fullPathID, $"{parentFullPath}.EMPTY_");
	}

	/// <summary>
	/// Stores parenting/hierarchy restrictions for Unknown StateMachines.
	/// </summary>
	/// <param name="NoDirect">FullPathIDs of not allowed parents.</param>
	/// <param name="NotUnder">FullPaths of not allowed parents to be under.</param>
	private readonly record struct ParentingRestrictions()
	{
		public readonly List<string> NotUnder = new();
		public readonly List<uint> NoDirect = new();
	}

	private record class StateMachineData(IAnimatorStateMachine StateMachine, uint FullPathID = 0)
	{
		public uint ParentFullPathID;
		public SelectorTransitionConstant[]? EntryTransitions;
		public SelectorTransitionConstant[]? ExitTransitions;

		public Utf8String Name { get { return StateMachine.Name; } set { StateMachine.Name = value; } }
	}
}

```

`Source/AssetRipper.Processing/AnimatorControllers/BidirectionalDictionary.cs`:

```cs
using System.Collections;

namespace AssetRipper.Processing.AnimatorControllers;

/// <summary>
/// Bidirectional Dictionary, valid for 2 different Types T1 and T2
/// </summary>
public sealed class BidirectionalDictionary<T1, T2> : IDictionary<T1, T2>
	where T1 : notnull
	where T2 : notnull
{
	private readonly Dictionary<T1, T2> forward = new();
	private readonly Dictionary<T2, T1> backward = new();

	public int Count { get { return forward.Count; } }

	public bool IsReadOnly { get { return false; } }

	public T2 this[T1 item1]
	{
		get
		{
			return forward[item1];
		}
		set
		{
			forward[item1] = value;
			backward[value] = item1;
		}
	}

	public T1 this[T2 item2]
	{
		get
		{
			return backward[item2];
		}
		set
		{
			forward[value] = item2;
			backward[item2] = value;
		}
	}

	public ICollection<T1> Keys { get { return forward.Keys; } }

	public ICollection<T2> Values { get { return backward.Keys; } }

	public void Add(T1 item1, T2 item2)
	{
		ArgumentNullException.ThrowIfNull(item1);
		ArgumentNullException.ThrowIfNull(item2);
		if (forward.ContainsKey(item1))
		{
			throw new ArgumentException("An element with the same key already exists.", nameof(item1));
		}
		if (backward.ContainsKey(item2))
		{
			throw new ArgumentException("An element with the same key already exists.", nameof(item2));
		}
		forward.Add(item1, item2);
		backward.Add(item2, item1);
	}

	public void Add(KeyValuePair<T1, T2> item1_item2)
	{
		Add(item1_item2.Key, item1_item2.Value);
	}

	public void Add(KeyValuePair<T2, T1> item2_item1)
	{
		Add(item2_item1.Value, item2_item1.Key);
	}

	public void Clear()
	{
		forward.Clear();
		backward.Clear();
	}

	public bool Contains(KeyValuePair<T1, T2> item1_item2)
	{
		return forward.Contains(item1_item2);
	}

	public bool Contains(KeyValuePair<T2, T1> item2_item1)
	{
		return backward.Contains(item2_item1);
	}

	public bool ContainsKey(T1 item1)
	{
		return forward.ContainsKey(item1);
	}

	public bool ContainsKey(T2 item2)
	{
		return backward.ContainsKey(item2);
	}

	public void CopyTo(KeyValuePair<T1, T2>[] array, int arrayIndex)
	{
		ArgumentNullException.ThrowIfNull(array);
		ArgumentOutOfRangeException.ThrowIfNegative(arrayIndex);
		ArgumentOutOfRangeException.ThrowIfGreaterThan(forward.Count, array.Length - arrayIndex);

		foreach (KeyValuePair<T1, T2> kvp in forward)
		{
			array[arrayIndex] = kvp;
			arrayIndex++;
		}
	}

	public void CopyTo(KeyValuePair<T2, T1>[] array, int arrayIndex)
	{
		ArgumentNullException.ThrowIfNull(array);
		ArgumentOutOfRangeException.ThrowIfNegative(arrayIndex);
		ArgumentOutOfRangeException.ThrowIfGreaterThan(backward.Count, array.Length - arrayIndex);

		foreach (KeyValuePair<T2, T1> kvp in backward)
		{
			array[arrayIndex] = kvp;
			arrayIndex++;
		}
	}

	public IEnumerator GetEnumerator()
	{
		return forward.GetEnumerator();
	}

	IEnumerator<KeyValuePair<T1, T2>> IEnumerable<KeyValuePair<T1, T2>>.GetEnumerator()
	{
		return forward.GetEnumerator();
	}

	public bool Remove(T1 item1)
	{
		if (forward.TryGetValue(item1, out T2? item2))
		{
			backward.Remove(item2);
			forward.Remove(item1);
			return true;
		}
		return false;
	}

	public bool Remove(T2 item2)
	{
		if (backward.TryGetValue(item2, out T1? item1))
		{
			forward.Remove(item1);
			backward.Remove(item2);
			return true;
		}
		return false;
	}

	public bool Remove(KeyValuePair<T1, T2> item1_item2)
	{
		if (forward.Contains(item1_item2))
		{
			forward.Remove(item1_item2.Key);
			backward.Remove(item1_item2.Value);
			return true;
		}
		return false;
	}

	public bool Remove(KeyValuePair<T2, T1> item2_item1)
	{
		if (backward.Contains(item2_item1))
		{
			forward.Remove(item2_item1.Value);
			backward.Remove(item2_item1.Key);
			return true;
		}
		return false;
	}

	public bool TryGetValue(T1 item1, [MaybeNullWhen(false)] out T2 item2)
	{
		return forward.TryGetValue(item1, out item2);
	}

	public bool TryGetValue(T2 item2, [MaybeNullWhen(false)] out T1 item1)
	{
		return backward.TryGetValue(item2, out item1);
	}
}

```

`Source/AssetRipper.Processing/AnimatorControllers/VirtualAnimationFactory.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_1101;
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_1107;
using AssetRipper.SourceGenerated.Classes.ClassID_1109;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_206;
using AssetRipper.SourceGenerated.Classes.ClassID_207;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.AnimatorCondition;
using AssetRipper.SourceGenerated.Subclasses.BlendTreeConstant;
using AssetRipper.SourceGenerated.Subclasses.BlendTreeNodeConstant;
using AssetRipper.SourceGenerated.Subclasses.ChildMotion;
using AssetRipper.SourceGenerated.Subclasses.ConditionConstant;
using AssetRipper.SourceGenerated.Subclasses.LeafInfoConstant;
using AssetRipper.SourceGenerated.Subclasses.SelectorTransitionConstant;
using AssetRipper.SourceGenerated.Subclasses.StateConstant;
using AssetRipper.SourceGenerated.Subclasses.TransitionConstant;

namespace AssetRipper.Processing.AnimatorControllers;

public static class VirtualAnimationFactory
{
	// Example of default BlendTree Name:
	// https://github.com/ds5678/Binoculars/blob/d6702ed3a1db39b1a2788956ff195b2590c3d08b/Unity/Assets/Models/binoculars_animator.controller#L106
	private static Utf8String BlendTreeName { get; } = new Utf8String("Blend Tree");

	private static Utf8String AnimatorStateName { get; } = new Utf8String("New State");

	private static IMotion? CreateMotion(ProcessedAssetCollection virtualFile, IAnimatorController controller, IStateConstant stateConstant, int nodeIndex)
	{
		if (stateConstant.BlendTreeConstantArray.Count == 0)
		{
			return default; // null Motion
		}
		else
		{
			IBlendTreeNodeConstant node = stateConstant.GetBlendTree().NodeArray[nodeIndex].Data;
			if (node.IsBlendTree())
			{
				return CreateBlendTree(virtualFile, controller, stateConstant, nodeIndex); // BlendTree Motion
			}
			else
			{
				int clipIndex = -1;
				if (stateConstant.Has_LeafInfoArray())
				{
					for (int i = 0; i < stateConstant.LeafInfoArray.Count; i++)
					{
						LeafInfoConstant leafInfo = stateConstant.LeafInfoArray[i];
						int index = leafInfo.IDArray.IndexOf(node.ClipID);
						if (index >= 0)
						{
							clipIndex = (int)leafInfo.IndexOffset + index;
							break;
						}
					}
				}
				else
				{
					clipIndex = unchecked((int)node.ClipID);
				}

				if (clipIndex == -1)
				{
					return default; // null Motion
				}
				else
				{
					return controller.AnimationClipsP[clipIndex] as IMotion; // AnimationClip Motion (inherited since Unity 4)
				}
			}
		}
	}

	private static IBlendTree CreateBlendTree(ProcessedAssetCollection virtualFile, IAnimatorController controller, IStateConstant state, int nodeIndex)
	{
		IBlendTree blendTree = virtualFile.CreateBlendTree();
		blendTree.HideFlagsE = HideFlags.HideInHierarchy;

		IBlendTreeNodeConstant node = state.GetBlendTree().NodeArray[nodeIndex].Data;

		blendTree.Name = BlendTreeName;

		blendTree.Childs.Capacity = node.ChildIndices.Count;
		for (int i = 0; i < node.ChildIndices.Count; i++)
		{
			AddAndInitializeNewChild(virtualFile, controller, state, blendTree, nodeIndex, i);
		}

		if (node.BlendEventID != uint.MaxValue)
		{
			blendTree.BlendParameter = controller.TOS[node.BlendEventID];
		}
		if (node.BlendEventYID != uint.MaxValue)
		{
			blendTree.BlendParameterY = controller.TOS[node.BlendEventYID];
		}
		blendTree.MinThreshold = node.GetMinThreshold();
		blendTree.MaxThreshold = node.GetMaxThreshold();
		blendTree.UseAutomaticThresholds = false;
		blendTree.NormalizedBlendValues = node.BlendDirectData?.Data.NormalizedBlendValues ?? false;
		if (blendTree.Has_BlendType_Int32())
		{
			blendTree.BlendType_Int32 = (int)node.BlendType;
		}
		else
		{
			blendTree.BlendType_UInt32 = node.BlendType;
		}

		return blendTree;
	}

	private static IChildMotion AddAndInitializeNewChild(ProcessedAssetCollection virtualFile, IAnimatorController controller, IStateConstant state, IBlendTree tree, int nodeIndex, int childIndex)
	{
		IChildMotion childMotion = tree.Childs.AddNew();
		IBlendTreeConstant treeConstant = state.GetBlendTree();
		IBlendTreeNodeConstant node = treeConstant.NodeArray[nodeIndex].Data;
		int childNodeIndex = (int)node.ChildIndices[childIndex];
		// https://github.com/AssetRipper/AssetRipper/issues/1566
		// Strangely, some BlendTree nodes have the same index as the child node index.
		// In the case of the above issue, both indices were 0.
		IMotion? motion = nodeIndex != childNodeIndex
			? CreateMotion(virtualFile, controller, state, childNodeIndex)
			: null; // tree might be more accurate here since the indices are the same, but it doesn't make sense for a BlendTree to be a child of itself.

		childMotion.Motion.SetAsset(tree.Collection, motion);

		IBlendTreeNodeConstant childNode = treeConstant.NodeArray[childNodeIndex].Data;
		if (childNode.IsBlendTree())
		{
			// BlendTree ChildMotions are not allowed to use TimeScale or Mirror
			// https://github.com/Unity-Technologies/UnityCsReference/blob/4e215c07ca8e9a32a589043202fd919bdfc0a26d/Editor/Mono/Inspector/BlendTreeInspector.cs#L1469
			// https://github.com/Unity-Technologies/UnityCsReference/blob/4e215c07ca8e9a32a589043202fd919bdfc0a26d/Editor/Mono/Inspector/BlendTreeInspector.cs#L1488
			childMotion.TimeScale = 1;
			childMotion.Mirror = false;
		}
		else
		{
			childMotion.TimeScale = 1 / childNode.Duration;
			childMotion.Mirror = childNode.Mirror;
		}
		childMotion.CycleOffset = childNode.CycleOffset;

		childMotion.Threshold = node.GetThreshold(childIndex);
		childMotion.Position?.CopyValues(node.GetPosition(childIndex));
		if (node.TryGetDirectBlendParameter(childIndex, out uint directID))
		{
			childMotion.DirectBlendParameter = controller.TOS[directID];
		}

		return childMotion;
	}

	/// <summary>
	/// Create a fully solved Root AnimatorStateMachine for the corresponding index
	/// </summary>
	public static IAnimatorStateMachine CreateRootAnimatorStateMachine(ProcessedAssetCollection virtualFile, IAnimatorController controller, int stateMachineIndex)
	{
		AnimatorStateMachineContext stateMachineContext = new(virtualFile, controller, stateMachineIndex);
		stateMachineContext.Process();
		return stateMachineContext.RootStateMachine;
	}

	public static IAnimatorStateMachine CreateStateMachine(ProcessedAssetCollection virtualFile, IAnimatorController controller, int layerIndex, uint fullPathID = 0)
	{
		IAnimatorStateMachine stateMachine = virtualFile.CreateAnimatorStateMachine();
		stateMachine.HideFlagsE = HideFlags.HideInHierarchy;

		// can add StateMachineBehaviours now
		if (stateMachine.Has_StateMachineBehaviours())
		{
			IMonoBehaviour?[] stateBehaviours = controller.GetStateBehaviours(layerIndex, fullPathID);
			foreach (IMonoBehaviour? stateBehaviour in stateBehaviours)
			{
				if (stateBehaviour != null)
				{
					stateBehaviour.HideFlagsE = HideFlags.HideInHierarchy;
					stateMachine.StateMachineBehavioursP.Add(stateBehaviour);
				}
			}
		}

		return stateMachine;
	}

	public static IAnimatorState CreateAnimatorState(ProcessedAssetCollection virtualFile, IAnimatorController controller, AssetDictionary<uint, Utf8String> tos, int layerIndex, IStateConstant stateConstant)
	{
		IAnimatorState animatorState = virtualFile.CreateAnimatorState();
		animatorState.HideFlagsE = HideFlags.HideInHierarchy;

		animatorState.Name = stateConstant.GetName(tos);
		animatorState.Speed = stateConstant.Speed;
		animatorState.CycleOffset = stateConstant.CycleOffset;

		if (animatorState.Has_StateMachineBehaviours())
		{
			uint stateID = stateConstant.GetId();
			IMonoBehaviour?[] stateBehaviours = controller.GetStateBehaviours(layerIndex, stateID);
			animatorState.StateMachineBehavioursP.AddRange(stateBehaviours);
		}

		animatorState.IKOnFeet = stateConstant.IKOnFeet;
		animatorState.WriteDefaultValues = stateConstant.GetWriteDefaultValues();
		animatorState.Mirror = stateConstant.Mirror;
		animatorState.SpeedParameterActive = stateConstant.SpeedParamID > 0;
		animatorState.MirrorParameterActive = stateConstant.MirrorParamID > 0;
		animatorState.CycleOffsetParameterActive = stateConstant.CycleOffsetParamID > 0;
		animatorState.TimeParameterActive = stateConstant.TimeParamID > 0;

		IMotion? motion = CreateMotion(virtualFile, controller, stateConstant, 0);
		if (animatorState.Has_Motion())
		{
			animatorState.MotionP = motion;
		}
		else
		{
			animatorState.MotionsP.Add(motion);
		}

		animatorState.Tag = tos[stateConstant.TagID];
		animatorState.SpeedParameter = tos[stateConstant.SpeedParamID];
		animatorState.MirrorParameter = tos[stateConstant.MirrorParamID];
		animatorState.CycleOffsetParameter = tos[stateConstant.CycleOffsetParamID];
		animatorState.TimeParameter = tos[stateConstant.TimeParamID];

		return animatorState;
	}

	public static IAnimatorState CreateDefaultAnimatorState(ProcessedAssetCollection virtualFile)
	{
		IAnimatorState animatorState = virtualFile.CreateAnimatorState();
		animatorState.HideFlagsE = HideFlags.HideInHierarchy;

		animatorState.Name = AnimatorStateName;
		animatorState.Speed = 1;
		animatorState.WriteDefaultValues = true;

		return animatorState;
	}

	public static IAnimatorStateTransition CreateAnimatorStateTransition(ProcessedAssetCollection virtualFile, AssetDictionary<uint, Utf8String> TOS, ITransitionConstant Transition)
	{
		IAnimatorStateTransition animatorStateTransition = virtualFile.CreateAnimatorStateTransition();
		animatorStateTransition.HideFlags = (uint)HideFlags.HideInHierarchy;

		animatorStateTransition.Conditions.Capacity = Transition.ConditionConstantArray.Count;
		for (int i = 0; i < Transition.ConditionConstantArray.Count; i++)
		{
			ConditionConstant conditionConstant = Transition.ConditionConstantArray[i].Data;
			if (!animatorStateTransition.Has_ExitTime() || conditionConstant.ConditionMode != (int)AnimatorConditionMode.ExitTime)
			{
				IAnimatorCondition condition = animatorStateTransition.Conditions.AddNew();
				condition.ConditionMode = (int)conditionConstant.ConditionModeE;
				condition.ConditionEvent = TOS[conditionConstant.EventID];
				condition.EventTreshold = conditionConstant.EventThreshold;
				condition.ExitTime = conditionConstant.ExitTime;
			}
		}

		animatorStateTransition.Name = TOS[Transition.UserID];

		animatorStateTransition.Atomic = Transition.Atomic;
		animatorStateTransition.TransitionDuration = Transition.TransitionDuration;
		animatorStateTransition.TransitionOffset = Transition.TransitionOffset;
		animatorStateTransition.ExitTime = Transition.GetExitTime();
		animatorStateTransition.HasExitTime = Transition.GetHasExitTime();
		animatorStateTransition.HasFixedDuration = Transition.GetHasFixedDuration();
		animatorStateTransition.InterruptionSourceE = Transition.GetInterruptionSource();
		animatorStateTransition.OrderedInterruption = Transition.OrderedInterruption;
		animatorStateTransition.CanTransitionToSelf = Transition.CanTransitionToSelf;

		return animatorStateTransition;
	}

	public static IAnimatorTransition CreateAnimatorTransition(ProcessedAssetCollection virtualFile, AssetDictionary<uint, Utf8String> TOS, SelectorTransitionConstant transition)
	{
		IAnimatorTransition animatorTransition = virtualFile.CreateAnimatorTransition();
		animatorTransition.HideFlagsE = HideFlags.HideInHierarchy;

		animatorTransition.Conditions.Capacity = transition.ConditionConstantArray.Count;
		for (int i = 0; i < transition.ConditionConstantArray.Count; i++)
		{
			ConditionConstant conditionConstant = transition.ConditionConstantArray[i].Data;
			if (conditionConstant.ConditionMode != (int)AnimatorConditionMode.ExitTime)
			{
				IAnimatorCondition condition = animatorTransition.Conditions.AddNew();
				condition.ConditionMode = (int)conditionConstant.ConditionModeE;
				condition.ConditionEvent = TOS[conditionConstant.EventID];
				condition.EventTreshold = conditionConstant.EventThreshold;
			}
		}

		return animatorTransition;
	}
}

```

`Source/AssetRipper.Processing/Assemblies/AssemblyManagerExtensions.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Import.Structure.Assembly.Managers;

namespace AssetRipper.Processing.Assemblies;

internal static class AssemblyManagerExtensions
{
	public static IEnumerable<ModuleDefinition> GetAllModules(this IAssemblyManager manager)
	{
		return manager.GetAssemblies().SelectMany(a => a.Modules);
	}

	public static IEnumerable<TypeDefinition> GetAllTypes(this IAssemblyManager manager)
	{
		return manager.GetAllModules().SelectMany(m => m.GetAllTypes());
	}

	public static IEnumerable<MethodDefinition> GetAllMethods(this IAssemblyManager manager)
	{
		return manager.GetAllTypes().SelectMany(t => t.Methods);
	}
}

```

`Source/AssetRipper.Processing/Assemblies/AttributePolyfillGenerator.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Cloning;
using AsmResolver.DotNet.Signatures;
using AssetRipper.CIL;
using AssetRipper.Import.Structure.Assembly.Managers;

namespace AssetRipper.Processing.Assemblies;

/// <summary>
/// Generates polyfills for missing attributes using the Roslyn compiler.
/// During compilation, these attributes can be stripped because they're not "custom" attributes.
/// They're special and get encoded in the metadata directly.
/// </summary>
/// <remarks>
/// <see href="https://github.com/icsharpcode/ILSpy/blob/master/ICSharpCode.Decompiler/TypeSystem/Implementation/KnownAttributes.cs"/>
/// </remarks>
public sealed class AttributePolyfillGenerator : IAssetProcessor
{
	/// <summary>
	/// Injects generated attribute polyfills into the loaded game data.
	/// </summary>
	/// <param name="gameData">The loaded game data.</param>
	public void Process(GameData gameData) => Process(gameData.AssemblyManager);

	/// <summary>
	/// Generates attribute polyfills for the given assembly manager.
	/// </summary>
	/// <param name="manager">The assembly manager to modify.</param>
	private static void Process(IAssemblyManager manager)
	{
		ModuleDefinition? mscorlib = manager.Mscorlib?.ManifestModule;
		if (mscorlib is null)
		{
			return;
		}

		manager.ClearStreamCache();

		ModuleDefinition polyfillModule = EmbeddedAssembly.Load();

		MemberCloner cloner = new(mscorlib, (context) => new CustomCloneReferenceImporter(context));
		cloner.Include(polyfillModule.TopLevelTypes.Where(t => !mscorlib.HasTopLevelType(t.Namespace, t.Name)));

		MemberCloneResult cloneResult = cloner.Clone();
		foreach (TypeDefinition type in cloneResult.ClonedTopLevelTypes)
		{
			mscorlib.TopLevelTypes.Add(type);
		}
	}

	/// <summary>
	/// Custom reference importer for cloning. It handles redirects references from the source module to the target module.
	/// </summary>
	private sealed class CustomCloneReferenceImporter : CloneContextAwareReferenceImporter
	{
		/// <summary>
		/// Initializes a new instance of the <see cref="CustomCloneReferenceImporter"/> class.
		/// </summary>
		/// <param name="context">The cloning context.</param>
		public CustomCloneReferenceImporter(MemberCloneContext context) : base(context)
		{
		}

		/// <inheritdoc/>
		protected override ITypeDefOrRef ImportType(TypeDefinition type)
		{
			if (type.DeclaringType is null && TargetModule.TryGetTopLevelType(type.Namespace, type.Name, out TypeDefinition? typeDefinition))
			{
				return typeDefinition;
			}
			return base.ImportType(type);
		}

		/// <inheritdoc/>
		protected override ITypeDefOrRef ImportType(TypeReference type)
		{
			if (SignatureComparer.Default.Equals(type.Scope, TargetModule) &&
				type.DeclaringType is null &&
				TargetModule.TryGetTopLevelType(type.Namespace, type.Name, out TypeDefinition? typeDefinition))
			{
				return typeDefinition;
			}
			return base.ImportType(type);
		}
	}
}

```

`Source/AssetRipper.Processing/Assemblies/CustomAttributeExtensions.cs`:

```cs
using AsmResolver.DotNet;

namespace AssetRipper.Processing.Assemblies;

internal static class CustomAttributeExtensions
{
	public static bool IsType(this CustomAttribute attribute, string? @namespace, string? name)
	{
		ITypeDefOrRef? type = attribute.Constructor?.DeclaringType;
		return type is not null && type.Namespace == @namespace && type.Name == name;
	}

	/// <summary>
	/// System.Runtime.CompilerServices.CompilerGeneratedAttribute
	/// </summary>
	public static bool IsCompilerGeneratedAttribute(this CustomAttribute attribute)
	{
		return attribute.IsType("System.Runtime.CompilerServices", "CompilerGeneratedAttribute");
	}

	/// <summary>
	/// UnityEngine.SerializeField
	/// </summary>
	public static bool IsSerializeField(this CustomAttribute attribute)
	{
		return attribute.Constructor?.DeclaringType is { Namespace.Value: "UnityEngine", Name.Value: "SerializeField" };
	}

	/// <summary>
	/// System.NonSerializedAttribute
	/// </summary>
	public static bool IsNonSerializedAttribute(this CustomAttribute attribute)
	{
		return attribute.Constructor?.DeclaringType is { Namespace.Value: "System", Name.Value: "NonSerializedAttribute" };
	}
}

```

`Source/AssetRipper.Processing/Assemblies/EmbeddedAssembly.cs`:

```cs
using AsmResolver.DotNet;

namespace AssetRipper.Processing.Assemblies;

/// <summary>
/// This class provides the polyfill module used in the <see cref="AttributePolyfillGenerator"/>.
/// </summary>
internal static partial class EmbeddedAssembly
{
	/// <summary>
	/// Loads a module definition from the embedded byte array.
	/// </summary>
	/// <returns>The loaded module definition.</returns>
	public static ModuleDefinition Load()
	{
		return ModuleDefinition.FromBytes(Bytes);
	}
}

```

`Source/AssetRipper.Processing/Assemblies/ForwardingAssemblyGenerator.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Import.Structure.Assembly.Managers;

namespace AssetRipper.Processing.Assemblies;

/// <summary>
/// ILSpy needs System.Runtime.CompilerServices.Unsafe and System.Runtime.InteropServices to decompile some code.
/// This generates these assemblies with forwarders to the mscorlib types.
/// </summary>
public sealed class ForwardingAssemblyGenerator : IAssetProcessor
{
	public void Process(GameData gameData) => AddCompilerHelperModules(gameData.AssemblyManager);

	private static void AddCompilerHelperModules(IAssemblyManager manager)
	{
		AssemblyDefinition? mscorlib = manager.Mscorlib;
		if (mscorlib is null)
		{
			return;
		}

		manager.ClearStreamCache();

		const string UnsafeAssemblyName = "System.Runtime.CompilerServices.Unsafe";
		if (!HasAssembly(manager, UnsafeAssemblyName))
		{
			AssemblyReference corLibReference = new(mscorlib);
			AssemblyDefinition assembly = new(UnsafeAssemblyName, (Version)mscorlib.Version.Clone());
			ModuleDefinition module = new(UnsafeAssemblyName, corLibReference)
			{
				Mvid = (Guid)UnityGuid.Md5Hash(UnsafeAssemblyName),
			};
			module.AssemblyReferences.Add(corLibReference);
			assembly.Modules.Add(module);

			module.ExportedTypes.Add(new ExportedType(corLibReference, "System.Runtime.CompilerServices", "Unsafe"));

			manager.Add(assembly);
		}

		const string InteropServicesAssemblyName = "System.Runtime.InteropServices";
		if (!HasAssembly(manager, InteropServicesAssemblyName))
		{
			AssemblyReference corLibReference = new(mscorlib);
			AssemblyDefinition assembly = new(InteropServicesAssemblyName, (Version)mscorlib.Version.Clone());
			ModuleDefinition module = new(InteropServicesAssemblyName, corLibReference)
			{
				Mvid = (Guid)UnityGuid.Md5Hash(InteropServicesAssemblyName),
			};
			module.AssemblyReferences.Add(corLibReference);
			assembly.Modules.Add(module);

			const string InteropServicesNamespace = "System.Runtime.InteropServices";
			foreach (TypeDefinition type in mscorlib.ManifestModule!.TopLevelTypes.Where(t =>
				t.IsPublic &&
				t.Namespace is not null &&
				t.Namespace.Value.StartsWith(InteropServicesNamespace, StringComparison.Ordinal)))
			{
				module.ExportedTypes.Add(new ExportedType(corLibReference, type.Namespace, type.Name));
			}

			manager.Add(assembly);
		}
	}

	private static bool HasAssembly(IAssemblyManager manager, string name)
	{
		return manager.GetAssemblies().Any(a => a.Name == name);
	}
}

```

`Source/AssetRipper.Processing/Assemblies/InternalsVisibileToPublicKeyRemover.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AsmResolver.PE.DotNet.Metadata.Tables;
using AssetRipper.Import.Structure.Assembly.Managers;
using System.Text.RegularExpressions;

namespace AssetRipper.Processing.Assemblies;

/// <summary>
/// Removes the public key from the InternalsVisibleToAttribute.
/// </summary>
/// <remarks>
/// <see href="https://github.com/AssetRipper/AssetRipper/issues/1736"/>
/// </remarks>
public sealed partial class InternalsVisibileToPublicKeyRemover : IAssetProcessor
{
	public void Process(GameData gameData) => Process(gameData.AssemblyManager);
	private static void Process(IAssemblyManager manager)
	{
		foreach (AssemblyDefinition assembly in manager.GetAssemblies())
		{
			foreach (CustomAttribute customAttribute in assembly.CustomAttributes)
			{
				if (!customAttribute.IsType("System.Runtime.CompilerServices", "InternalsVisibleToAttribute"))
				{
					// Not the attribute we are looking for
				}
				else if (!TryGetSingleFixedArgument(customAttribute, out CustomAttributeArgument? argument))
				{
					// Invalid attribute signature
				}
				else if (!IsStringArgument(argument, out string? value))
				{
					// Invalid argument type
				}
				else if (!TryMatchRegex(value, out string? targetAssembly))
				{
					// No public key present, so we don't need to do anything
				}
				else
				{
					argument.Elements[0] = targetAssembly;
				}
			}
		}
	}

	private static bool IsStringArgument(CustomAttributeArgument argument, [NotNullWhen(true)] out string? value)
	{
		if (argument.ArgumentType is CorLibTypeSignature { ElementType: ElementType.String } && argument.Elements.Count == 1)
		{
			if (argument.Element is string str)
			{
				value = str;
				return true;
			}
			else if (argument.Element is AsmResolver.Utf8String str2)
			{
				value = str2;
				return true;
			}
		}
		value = null;
		return false;
	}

	private static bool TryGetSingleFixedArgument(CustomAttribute customAttribute, [NotNullWhen(true)] out CustomAttributeArgument? argument)
	{
		if (customAttribute.Signature is null or { FixedArguments.Count: not 1 } or { NamedArguments.Count: not 0 })
		{
			argument = null;
			return false;
		}
		argument = customAttribute.Signature.FixedArguments[0];
		return true;
	}

	private static bool TryMatchRegex(string value, [NotNullWhen(true)] out string? targetAssembly)
	{
		Match match = PublicKeyRegex.Match(value);
		if (match.Success)
		{
			targetAssembly = match.Groups[1].Value;
			return true;
		}
		else
		{
			targetAssembly = null;
			return false;
		}
	}

	[GeneratedRegex(@"^([\w\.]+), PublicKey=[a-fA-F0-9]+$")]
	private static partial Regex PublicKeyRegex { get; }
}

```

`Source/AssetRipper.Processing/Assemblies/MethodStubbingProcessor.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.CIL;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;

namespace AssetRipper.Processing.Assemblies;

/// <summary>
/// This processor replaces the method bodies of all methods with a minimal implementation.
/// </summary>
public sealed class MethodStubbingProcessor : IAssetProcessor
{
	public void Process(GameData gameData) => Process(gameData.AssemblyManager);

	private static void Process(IAssemblyManager manager)
	{
		if (manager.ScriptingBackend == ScriptingBackend.IL2Cpp)
		{
			return;
		}

		manager.ClearStreamCache();

		foreach (ModuleDefinition module in manager.GetAssemblies().SelectMany(a => a.Modules).Where(m => m.TopLevelTypes.Count > 0))
		{
			foreach (TypeDefinition type in module.GetAllTypes())
			{
				foreach (MethodDefinition method in type.Methods)
				{
					method.ReplaceMethodBodyWithMinimalImplementation();
				}
			}
		}
	}
}

```

`Source/AssetRipper.Processing/Assemblies/MonoExplicitPropertyRepairProcessor.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;

namespace AssetRipper.Processing.Assemblies;

/// <summary>
/// Fixes explicit property implementations in Mono assemblies.
/// </summary>
/// <remarks>
/// Mono doesn't always include properties for explicit interface implementations, so we have to create them ourselves.
/// <see href="https://github.com/AssetRipper/AssetRipper/issues/1682"/>
/// </remarks>
public sealed class MonoExplicitPropertyRepairProcessor : IAssetProcessor
{
	public void Process(GameData gameData) => Process(gameData.AssemblyManager);
	private static void Process(IAssemblyManager manager)
	{
		if (manager.ScriptingBackend == ScriptingBackend.IL2Cpp)
		{
			return; // For Il2Cpp, this issue is handled by Cpp2IL
		}

		manager.ClearStreamCache();

		List<(PropertyDefinition InterfaceProperty, TypeSignature InterfaceType, MethodDefinition Method)> getMethodsToCreate = new();
		List<(PropertyDefinition InterfaceProperty, TypeSignature InterfaceType, MethodDefinition Method)> setMethodsToCreate = new();

		foreach (ModuleDefinition module in manager.GetAssemblies().SelectMany(a => a.Modules))
		{
			foreach (TypeDefinition type in module.GetAllTypes().Where(t => t.MethodImplementations.Count > 0))
			{
				foreach (MethodImplementation methodImpl in type.MethodImplementations)
				{
					if (methodImpl.Body is not MethodDefinition method || method.DeclaringType != type || method.IsGetMethod || method.IsSetMethod)
					{
						continue;
					}

					IMethodDefOrRef? interfaceMethod = methodImpl.Declaration;
					if (interfaceMethod is null)
					{
						continue;
					}

					MethodDefinition? interfaceMethodResolved = interfaceMethod.Resolve();
					if (interfaceMethodResolved != null)
					{
						if (interfaceMethodResolved.IsGetMethod)
						{
							PropertyDefinition interfacePropertyResolved = interfaceMethodResolved.DeclaringType!.Properties.First(p => p.Semantics.Contains(interfaceMethodResolved.Semantics));
							getMethodsToCreate.Add((interfacePropertyResolved, interfaceMethod.DeclaringType!.ToTypeSignature(), method));
						}
						else if (interfaceMethodResolved.IsSetMethod)
						{
							PropertyDefinition interfacePropertyResolved = interfaceMethodResolved.DeclaringType!.Properties.First(p => p.Semantics.Contains(interfaceMethodResolved.Semantics));
							setMethodsToCreate.Add((interfacePropertyResolved, interfaceMethod.DeclaringType!.ToTypeSignature(), method));
						}
					}
				}

				if (getMethodsToCreate.Count > 0)
				{
					foreach ((PropertyDefinition InterfaceProperty, TypeSignature InterfaceType, MethodDefinition Method) entry in getMethodsToCreate)
					{
						(PropertyDefinition interfaceProperty, TypeSignature interfaceType, MethodDefinition getMethod) = entry;
						MethodDefinition? setMethod = setMethodsToCreate
							.FirstOrDefault(e => e.InterfaceProperty == interfaceProperty && SignatureComparer.Default.Equals(e.InterfaceType, interfaceType))
							.Method;

						string name = $"{interfaceType.FullName}.{interfaceProperty.Name}";
						PropertySignature propertySignature = getMethod.IsStatic
							? PropertySignature.CreateStatic(getMethod.Signature!.ReturnType, getMethod.Signature.ParameterTypes)
							: PropertySignature.CreateInstance(getMethod.Signature!.ReturnType, getMethod.Signature.ParameterTypes);
						PropertyDefinition property = new PropertyDefinition(name, interfaceProperty.Attributes, propertySignature);
						type.Properties.Add(property);
						property.SetSemanticMethods(getMethod, setMethod);
					}
				}
				if (setMethodsToCreate.Count > 0)
				{
					foreach ((PropertyDefinition InterfaceProperty, TypeSignature InterfaceType, MethodDefinition Method) entry in setMethodsToCreate)
					{
						(PropertyDefinition interfaceProperty, TypeSignature interfaceType, MethodDefinition setMethod) = entry;
						if (getMethodsToCreate.Any(e => e.InterfaceProperty == interfaceProperty && SignatureComparer.Default.Equals(e.InterfaceType, interfaceType)) == true)
						{
							continue;
						}

						string name = $"{interfaceType.FullName}.{interfaceProperty.Name}";
						PropertySignature propertySignature = setMethod.IsStatic
							? PropertySignature.CreateStatic(setMethod.Signature!.ParameterTypes[^1], setMethod.Signature.ParameterTypes.Take(setMethod.Signature.ParameterTypes.Count - 1))
							: PropertySignature.CreateInstance(setMethod.Signature!.ParameterTypes[^1], setMethod.Signature.ParameterTypes.Take(setMethod.Signature.ParameterTypes.Count - 1));
						PropertyDefinition property = new PropertyDefinition(name, interfaceProperty.Attributes, propertySignature);
						type.Properties.Add(property);
						property.SetSemanticMethods(null, setMethod);
					}
				}

				getMethodsToCreate.Clear();
				setMethodsToCreate.Clear();
			}
		}
	}
}

```

`Source/AssetRipper.Processing/Assemblies/NullRefReturnProcessor.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Signatures;
using AsmResolver.PE.DotNet.Cil;
using AssetRipper.Import.Configuration;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;

namespace AssetRipper.Processing.Assemblies;

/// <summary>
/// Returning a null by reference causes an error before C# 11. This replaces the method body with a throw statement.
/// </summary>
public sealed class NullRefReturnProcessor(ScriptContentLevel scriptContentLevel) : IAssetProcessor
{
	public void Process(GameData gameData) => Process(gameData.AssemblyManager);

	private void Process(IAssemblyManager manager)
	{
		if (manager.ScriptingBackend != ScriptingBackend.IL2Cpp && scriptContentLevel > ScriptContentLevel.Level1)
		{
			return; // Mono doesn't have method stubs, so this isn't necessary.
		}
		else if (scriptContentLevel > ScriptContentLevel.Level2)
		{
			return; // Il2Cpp doesn't have method stubs on Level 3 and above.
		}

		manager.ClearStreamCache();

		foreach (MethodDefinition method in manager.GetAllMethods())
		{
			if (method.Signature?.ReturnType is ByReferenceTypeSignature)
			{
				method.CilMethodBody = new CilMethodBody();
				CilInstructionCollection instructions = method.CilMethodBody.Instructions;
				instructions.Add(CilOpCodes.Ldnull);
				instructions.Add(CilOpCodes.Throw);
			}
		}
	}
}

```

`Source/AssetRipper.Processing/Assemblies/NullableRemovalProcessor.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Import.Structure.Assembly.Managers;

namespace AssetRipper.Processing.Assemblies;

/// <summary>
/// This processor removes nullable annotations from all locations.
/// </summary>
public sealed class NullableRemovalProcessor : IAssetProcessor
{
	public void Process(GameData gameData) => Process(gameData.AssemblyManager);

	private static void Process(IAssemblyManager manager)
	{
		manager.ClearStreamCache();
		foreach (TypeDefinition type in manager.GetAllTypes())
		{
			RemoveNullableAttributes(type);
			RemoveNullableAttributes(type.GenericParameters);
			RemoveNullableAttributes(type.Fields);
			RemoveNullableAttributes(type.Properties);
			RemoveNullableAttributes(type.Events);
			RemoveNullableAttributes(type.Methods);

			foreach (MethodDefinition method in type.Methods)
			{
				RemoveNullableAttributes(method.ParameterDefinitions);
				RemoveNullableAttributes(method.GenericParameters);
			}
		}
	}

	private static void RemoveNullableAttributes<T>(IEnumerable<T> attributeProviders) where T : IHasCustomAttribute
	{
		foreach (T attributeProvider in attributeProviders)
		{
			RemoveNullableAttributes(attributeProvider);
		}
	}

	private static void RemoveNullableAttributes(IHasCustomAttribute attributeProvider)
	{
		for (int i = attributeProvider.CustomAttributes.Count - 1; i >= 0; i--)
		{
			CustomAttribute attribute = attributeProvider.CustomAttributes[i];
			if (attribute.Constructor?.DeclaringType is { Namespace.Value: "System.Runtime.CompilerServices", Name.Value: "NullableAttribute" or "NullableContextAttribute" })
			{
				attributeProvider.CustomAttributes.RemoveAt(i);
			}
		}
	}
}

```

`Source/AssetRipper.Processing/Assemblies/ObfuscationRepairProcessor.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Import.Structure.Assembly.Managers;

namespace AssetRipper.Processing.Assemblies;

/// <summary>
/// Improves decompilation of obfuscated assemblies.
/// </summary>
public sealed class ObfuscationRepairProcessor : IAssetProcessor
{
	public void Process(GameData gameData) => Process(gameData.AssemblyManager);
	private static void Process(IAssemblyManager manager)
	{
		manager.ClearStreamCache();

		RemoveCompilerGeneratedAttributesFromSpeakableTypes(manager);

		RenameNormalProperties(manager);

		RenameExplicitProperties(manager);
	}

	/// <summary>
	/// Removes compiler-generated attributes from types with speakable names.
	/// This prevents a decompiler from assuming that the type follows compiler-generated conventions
	/// when in fact the obfuscator may have modified it in a way that breaks those conventions.
	/// </summary>
	private static void RemoveCompilerGeneratedAttributesFromSpeakableTypes(IAssemblyManager manager)
	{
		foreach (TypeDefinition type in manager.GetAllTypes())
		{
			string? name = type.Name;
			if (name is null || (name.Contains('<') && name.Contains('>')))
			{
				// Unspeakable name from the compiler. We should leave this type alone.
				continue;
			}

			for (int i = type.CustomAttributes.Count - 1; i >= 0; i--)
			{
				if (type.CustomAttributes[i].IsCompilerGeneratedAttribute())
				{
					type.CustomAttributes.RemoveAt(i);
				}
			}
		}
	}

	/// <summary>
	/// Renames normal properties and events to match the names of their get/set/add/remove/raise methods.
	/// They can differ due to obfuscation renaming them, so this changes them back to be consistent.
	/// </summary>
	/// <remarks>
	/// This is needed because differing names can cause issues when attempting to recompile decompiled code.
	/// </remarks>
	private static void RenameNormalProperties(IAssemblyManager manager)
	{
		foreach (TypeDefinition type in manager.GetAllTypes())
		{
			foreach (PropertyDefinition property in type.Properties)
			{
				if (property.GetMethod is { Name: not null } getMethod)
				{
					if (!IsExplicitOverride(type, getMethod) && getMethod.Name.Value.StartsWith("get_", StringComparison.Ordinal))
					{
						string propertyName = getMethod.Name.Value[4..];
						if (property.Name != propertyName)
						{
							property.Name = propertyName;
						}
					}
				}
				else if (property.SetMethod is { Name: not null } setMethod)
				{
					if (!IsExplicitOverride(type, setMethod) && setMethod.Name.Value.StartsWith("set_", StringComparison.Ordinal))
					{
						string propertyName = setMethod.Name.Value[4..];
						if (property.Name != propertyName)
						{
							property.Name = propertyName;
						}
					}
				}
			}
			foreach (EventDefinition @event in type.Events)
			{
				if (@event.AddMethod is { Name: not null } addMethod)
				{
					if (!IsExplicitOverride(type, addMethod) && addMethod.Name.Value.StartsWith("add_", StringComparison.Ordinal))
					{
						string eventName = addMethod.Name.Value[4..];
						if (@event.Name != eventName)
						{
							@event.Name = eventName;
						}
					}
				}
				else if (@event.RemoveMethod is { Name: not null } removeMethod)
				{
					if (!IsExplicitOverride(type, removeMethod) && removeMethod.Name.Value.StartsWith("remove_", StringComparison.Ordinal))
					{
						string eventName = removeMethod.Name.Value[7..];
						if (@event.Name != eventName)
						{
							@event.Name = eventName;
						}
					}
				}
				else if (@event.FireMethod is { Name: not null } fireMethod)
				{
					if (!IsExplicitOverride(type, fireMethod) && fireMethod.Name.Value.StartsWith("raise_", StringComparison.Ordinal))
					{
						string eventName = fireMethod.Name.Value[6..];
						if (@event.Name != eventName)
						{
							@event.Name = eventName;
						}
					}
				}
			}
		}

		static bool IsExplicitOverride(TypeDefinition type, MethodDefinition method)
		{
			return type.MethodImplementations.Any(impl => impl.Body == method);
		}
	}

	/// <summary>
	/// Renames explicit properties and events to match the names of their get/set/add/remove/raise methods.
	/// They can differ due to obfuscation renaming them, so this changes them back to be consistent.
	/// </summary>
	/// <remarks>
	/// This is needed because differing names can cause issues when attempting to recompile decompiled code.
	/// </remarks>
	private static void RenameExplicitProperties(IAssemblyManager manager)
	{
		foreach (TypeDefinition type in manager.GetAllTypes())
		{
			foreach (MethodImplementation methodImplementation in type.MethodImplementations)
			{
				if (methodImplementation.Body is not MethodDefinition body || methodImplementation.Declaration is null)
				{
					continue;
				}

				if (body.IsGetMethod || body.IsSetMethod)
				{
					PropertyDefinition? property = type.Properties.FirstOrDefault(p => p.Semantics.Any(s => s.Method == body));
					if (property is null)
					{
						continue;
					}

					string? methodName = methodImplementation.Declaration.Name;
					if (string.IsNullOrEmpty(methodName))
					{
						continue;
					}

					string? propertyName;
					if (body.IsGetMethod && methodName.StartsWith("get_", StringComparison.Ordinal))
					{
						propertyName = methodName[4..];
					}
					else if (body.IsSetMethod && methodName.StartsWith("set_", StringComparison.Ordinal))
					{
						propertyName = methodName[4..];
					}
					else
					{
						propertyName = null;
					}

					string? interfaceTypeName = methodImplementation.Declaration.DeclaringType?.FullName.Replace('+', '.');

					body.Name = string.IsNullOrEmpty(interfaceTypeName)
						? methodName
						: $"{interfaceTypeName}.{methodName}";

					if (!string.IsNullOrEmpty(propertyName))
					{
						property.Name = string.IsNullOrEmpty(interfaceTypeName)
							? propertyName
							: $"{interfaceTypeName}.{propertyName}";
					}
				}

				if (body.IsAddMethod || body.IsRemoveMethod || body.IsFireMethod)
				{
					EventDefinition? @event = type.Events.FirstOrDefault(e => e.Semantics.Any(s => s.Method == body));
					if (@event is null)
					{
						continue;
					}

					string? methodName = methodImplementation.Declaration.Name;
					if (string.IsNullOrEmpty(methodName))
					{
						continue;
					}

					string? eventName;
					if (body.IsAddMethod && methodName.StartsWith("add_", StringComparison.Ordinal))
					{
						eventName = methodName[4..];
					}
					else if (body.IsRemoveMethod && methodName.StartsWith("remove_", StringComparison.Ordinal))
					{
						eventName = methodName[7..];
					}
					else if (body.IsFireMethod && methodName.StartsWith("raise_", StringComparison.Ordinal))
					{
						eventName = methodName[6..];
					}
					else
					{
						eventName = null;
					}

					string? interfaceTypeName = methodImplementation.Declaration.DeclaringType?.FullName.Replace('+', '.');
					body.Name = string.IsNullOrEmpty(interfaceTypeName)
						? methodName
						: $"{interfaceTypeName}.{methodName}";

					if (!string.IsNullOrEmpty(eventName))
					{
						@event.Name = string.IsNullOrEmpty(interfaceTypeName)
							? eventName
							: $"{interfaceTypeName}.{eventName}";
					}
				}
			}
		}
	}
}

```

`Source/AssetRipper.Processing/Assemblies/RemoveAssemblyKeyFileAttributeProcessor.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Import.Structure.Assembly.Managers;

namespace AssetRipper.Processing.Assemblies;

/// <summary>
/// Removes System.Reflection.AssemblyKeyFileAttribute from assemblies.
/// It causes compile errors because the key file is not present.
/// </summary>
public sealed class RemoveAssemblyKeyFileAttributeProcessor : IAssetProcessor
{
	public void Process(GameData gameData) => Process(gameData.AssemblyManager);
	private static void Process(IAssemblyManager manager)
	{
		foreach (AssemblyDefinition assembly in manager.GetAssemblies())
		{
			for (int i = assembly.CustomAttributes.Count - 1; i >= 0; i--)
			{
				if (assembly.CustomAttributes[i].IsType("System.Reflection", "AssemblyKeyFileAttribute"))
				{
					assembly.CustomAttributes.RemoveAt(i);
				}
			}
		}
	}
}

```

`Source/AssetRipper.Processing/Assemblies/SafeAssemblyPublicizingProcessor.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.CIL;
using AssetRipper.Import.Structure.Assembly.Managers;

namespace AssetRipper.Processing.Assemblies;

/// <summary>
/// This processor makes (nearly) all types, methods, and fields public in the assembly.
/// It handles edge cases like determing if something should be publicized and
/// adding [NonSerialized] to newly public instance fields.
/// </summary>
public sealed class SafeAssemblyPublicizingProcessor : IAssetProcessor
{
	public void Process(GameData gameData) => Process(gameData.AssemblyManager);
	private static void Process(IAssemblyManager manager)
	{
		ModuleDefinition? mscorlib = manager.Mscorlib?.ManifestModule;
		if (mscorlib is null)
		{
			return;
		}

		if (!mscorlib.TryGetTopLevelType("System", "NonSerializedAttribute", out TypeDefinition? nonSerializedAttributeType))
		{
			return;
		}

		MethodDefinition? nonSerializedAttributeConstructor = nonSerializedAttributeType.Methods.FirstOrDefault(m => m.IsConstructor && m.Parameters.Count == 0);
		if (nonSerializedAttributeConstructor is null)
		{
			return;
		}

		manager.ClearStreamCache();

		foreach (ModuleDefinition module in manager.GetAllModules())
		{
			ICustomAttributeType importedNonSerializedAttributeConstructor = (ICustomAttributeType)module.DefaultImporter.ImportMethod(nonSerializedAttributeConstructor);

			foreach (TypeDefinition type in module.GetAllTypes())
			{
				if (type.IsModuleType)
				{
					continue;
				}

				SetPublic(type);

				// Properties and events are technically always public. It's only their associated methods that might not be public.

				foreach (MethodDefinition method in type.Methods)
				{
					if (method.IsStaticConstructor())
					{
						continue;
					}
					if (method.Name == "Finalize" && method.IsVirtual && method.IsFamily && method.DeclaringType!.MethodImplementations.Any(i => i.Body == method))
					{
						// Finalizers should not be modified.
						continue;
					}
					if (method.DeclaringType!.MethodImplementations.Any(i => i.Body == method))
					{
						// Explicit interface implementations should not be modified.
						continue;
					}
					method.IsPublic = true;
				}

				foreach (FieldDefinition field in type.Fields)
				{
					if (field.IsCompilerGenerated())
					{
						// Backing fields should not be modified.
						continue;
					}
					if (field.IsPublic)
					{
						// Already public.
						continue;
					}

					field.IsPublic = true;

					if (field.IsStatic)
					{
						// Static fields aren't serializable.
						continue;
					}

					if (!field.CustomAttributes.Any(CustomAttributeExtensions.IsSerializeField) &&
						!field.CustomAttributes.Any(CustomAttributeExtensions.IsNonSerializedAttribute))
					{
						// Need to add [NonSerialized] to prevent Unity from serializing this field now that it's public.
						field.CustomAttributes.Add(new CustomAttribute(importedNonSerializedAttributeConstructor));
					}
				}
			}
		}
	}

	private static void SetPublic(TypeDefinition type)
	{
		if (type.IsNested)
		{
			type.IsNestedPublic = true;
		}
		else
		{
			type.IsPublic = true;
		}
	}
}

```

`Source/AssetRipper.Processing/Assemblies/UnmanagedConstraintRecoveryProcessor.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AssetRipper.CIL;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;

namespace AssetRipper.Processing.Assemblies;

/// <summary>
/// Recover unmanaged constraints for generic parameters in Il2Cpp games. This prevents compile errors when using pointers to generic parameters.
/// </summary>
public sealed class UnmanagedConstraintRecoveryProcessor : IAssetProcessor
{
	public void Process(GameData gameData) => Process(gameData.AssemblyManager);

	private static void Process(IAssemblyManager manager)
	{
		if (manager.ScriptingBackend != ScriptingBackend.IL2Cpp)
		{
			return;
		}

		ModuleDefinition? mscorlib = manager.Mscorlib?.ManifestModule;
		if (mscorlib is null)
		{
			return;
		}

		if (!mscorlib.TryGetTopLevelType("System.Runtime.CompilerServices", "IsUnmanagedAttribute", out TypeDefinition? unmanagedAttributeType))
		{
			return;
		}

		MethodDefinition? unmanagedAttributeConstructor = unmanagedAttributeType.Methods.FirstOrDefault(m => m.IsConstructor && m.Parameters.Count == 0);
		if (unmanagedAttributeConstructor is null)
		{
			return;
		}

		manager.ClearStreamCache();

		foreach (MethodDefinition method in manager.GetAllMethods())
		{
			foreach (TypeSignature? parameterSignature in method.Parameters.Select(p => p.ParameterType).Append(method.Signature?.ReturnType))
			{
				if (!IsPointerToGenericParameter(parameterSignature, out GenericParameterSignature? genericParameterSignature))
				{
				}
				else if (genericParameterSignature.ParameterType is GenericParameterType.Method)
				{
					GenericParameter genericParameter = method.GenericParameters[genericParameterSignature.Index];
					AddIsUnmanagedAttribute(genericParameter, unmanagedAttributeConstructor);
				}
				else
				{
					TypeDefinition? declaringType = method.DeclaringType;
					while (declaringType is not null && declaringType.GenericParameters.Count > genericParameterSignature.Index)
					{
						GenericParameter genericParameter = declaringType.GenericParameters[genericParameterSignature.Index];
						AddIsUnmanagedAttribute(genericParameter, unmanagedAttributeConstructor);

						declaringType = declaringType.DeclaringType;
					}
				}
			}
		}
	}

	static bool IsPointerToGenericParameter(TypeSignature? type, [NotNullWhen(true)] out GenericParameterSignature? genericParameter)
	{
		genericParameter = (type as PointerTypeSignature)?.BaseType as GenericParameterSignature;
		return genericParameter != null;
	}

	static void AddIsUnmanagedAttribute(GenericParameter genericParameter, MethodDefinition constructor)
	{
		if (!genericParameter.HasCustomAttribute("System.Runtime.CompilerServices", "IsUnmanagedAttribute"))
		{
			genericParameter.AddCustomAttribute(genericParameter.DeclaringModule!.DefaultImporter.ImportMethod(constructor));
		}
	}
}

```

`Source/AssetRipper.Processing/AssetGroup.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using System.Diagnostics;

namespace AssetRipper.Processing;

public abstract class AssetGroup : UnityObjectBase
{
	protected AssetGroup(AssetInfo assetInfo) : base(assetInfo)
	{
	}

	public abstract IEnumerable<IUnityObjectBase> Assets { get; }

	public virtual void SetMainAsset()
	{
		MainAsset = this;
		foreach (IUnityObjectBase asset in Assets)
		{
			Debug.Assert(asset.MainAsset is null || asset.MainAsset == this, "Asset already has a main asset assigned.");
			asset.MainAsset = this;
		}
	}

	protected PPtr AssetToPPtr(IUnityObjectBase? asset) => Collection.ForceCreatePPtr(asset);
}

```

`Source/AssetRipper.Processing/AssetRipper.Processing.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.Processing\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Processing\$(Configuration)\</IntermediateOutputPath>
		<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.CIL" Version="1.2.2" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Import\AssetRipper.Import.csproj" />
		<ProjectReference Include="..\AssetRipper.Processing.SourceGenerator\AssetRipper.Processing.SourceGenerator.csproj" OutputItemType="Analyzer" ReferenceOutputAssembly="false" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Processing/AudioMixers/AudioEffectsDefinitions.cs`:

```cs
using AssetRipper.SourceGenerated.NativeEnums.Fmod;

namespace AssetRipper.Processing.AudioMixers;

public static class AudioEffectDefinitions
{
	/// <summary>
	/// Similar to <see cref="SourceGenerated.NativeEnums.Global.UnityEffectType"/>
	/// </summary>
	private enum UnityEffectType
	{
		Attenuation = -2,
		Send = -3,
		Receive = -4,
		DuckVolume = -5
	}

	public static bool IsPluginEffect(int effectType)
	{
		return effectType >= 1000;
	}

	public static string? EffectTypeToName(int effectType)
	{
		if (IsPluginEffect(effectType))
		{
			throw new ArgumentException("This method should not be used on custom plugin effects");
		}

		if (effectType < 0)
		{
			return (UnityEffectType)effectType switch
			{
				UnityEffectType.Attenuation => "Attenuation",
				UnityEffectType.Send => "Send",
				UnityEffectType.Receive => "Receive",
				UnityEffectType.DuckVolume => "Duck Volume",
				_ => null,
			};
		}

		return (FmodDspType)effectType switch
		{
			FmodDspType.Lowpass => "Lowpass",
			FmodDspType.Highpass => "Highpass",
			FmodDspType.Echo => "Echo",
			FmodDspType.Flange => "Flange",
			FmodDspType.Distortion => "Distortion",
			FmodDspType.Normalize => "Normalize",
			FmodDspType.Parameq => "ParamEQ",
			FmodDspType.Pitchshift => "Pitch Shifter",
			FmodDspType.Chorus => "Chorus",
			FmodDspType.Compressor => "Compressor",
			FmodDspType.Sfxreverb => "SFX Reverb",
			FmodDspType.LowpassSimple => "Lowpass Simple",
			FmodDspType.HighpassSimple => "Highpass Simple",
			_ => null,
		};
	}
}

```

`Source/AssetRipper.Processing/AudioMixers/AudioMixerProcessor.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Generics;
using AssetRipper.Checksum;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_240;
using AssetRipper.SourceGenerated.Classes.ClassID_241;
using AssetRipper.SourceGenerated.Classes.ClassID_243;
using AssetRipper.SourceGenerated.Classes.ClassID_244;
using AssetRipper.SourceGenerated.Classes.ClassID_245;
using AssetRipper.SourceGenerated.Classes.ClassID_272;
using AssetRipper.SourceGenerated.Classes.ClassID_273;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.AudioMixerConstant;
using AssetRipper.SourceGenerated.Subclasses.AudioMixerGroupView;
using AssetRipper.SourceGenerated.Subclasses.EffectConstant;
using AssetRipper.SourceGenerated.Subclasses.ExposedAudioParameter;
using AssetRipper.SourceGenerated.Subclasses.GroupConstant;
using AssetRipper.SourceGenerated.Subclasses.GUID;
using AssetRipper.SourceGenerated.Subclasses.Parameter;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AudioMixerSnapshot;
using AssetRipper.SourceGenerated.Subclasses.SnapshotConstant;

namespace AssetRipper.Processing.AudioMixers;

public sealed class AudioMixerProcessor : IAssetProcessor
{
	private static Utf8String ViewName { get; } = new("View");

	//Many uses of IAudioMixerGroupController should be IAudioMixerGroup.

	public void Process(GameData gameData)
	{
		Logger.Info(LogCategory.Processing, "Reconstruct AudioMixer Assets");

		ProcessedAssetCollection processedCollection = gameData.AddNewProcessedCollection("Generated Audio Mixer Effects");

		Dictionary<IAudioMixer, Dictionary<UnityGuid, IAudioMixerGroup>> groupGuidMixerMap = new();
		foreach (IAudioMixerGroup group in gameData.GameBundle.FetchAssets().OfType<IAudioMixerGroup>())
		{
			IAudioMixer? mixer = group.AudioMixer_C273P;
			if (mixer is not null)
			{
				group.MainAsset = mixer;
				groupGuidMixerMap.GetOrAdd(mixer).Add(group.GroupID_C273, group);
			}
		}

		foreach (IAudioMixer mixer in gameData.GameBundle.FetchAssets().OfType<IAudioMixer>())
		{
			mixer.MainAsset = mixer;
			ProcessAssets(mixer, processedCollection, groupGuidMixerMap.GetOrAdd(mixer));
		}
	}

	private static void ProcessAssets(
		IAudioMixer mixer,
		ProcessedAssetCollection virtualFile,
		IReadOnlyDictionary<UnityGuid, IAudioMixerGroup> groupGuidMap)
	{
		GuidIndexTable indexToGuid = new();
		List<IAudioMixerGroupController> groups = new();

		ProcessAudioMixerGroups(mixer, indexToGuid, groups, groupGuidMap);
		ProcessAudioMixerEffects(mixer, indexToGuid, groups, virtualFile);
		ProcessAudioMixerSnapshots(mixer, indexToGuid);
		if (mixer is IAudioMixerController mixerController)
		{
			ProcessAudioMixer(mixerController, indexToGuid, groups);
		}
	}

	private static void ProcessAudioMixerGroups(
		IAudioMixer mixer,
		GuidIndexTable indexToGuid,
		List<IAudioMixerGroupController> groups,
		IReadOnlyDictionary<UnityGuid, IAudioMixerGroup> groupGuidMap)
	{
		IAudioMixerConstant constants = mixer.MixerConstant_C240;

		groups.AddRange(mixer.MixerConstant_C240.GroupGUIDs.Select(guid => (IAudioMixerGroupController)groupGuidMap[guid]));
		for (int i = 0; i < groups.Count; i++)
		{
			IAudioMixerGroupController group = groups[i];
			IGroupConstant groupConstant = constants.Groups[i];

			group.Volume.CopyValues(indexToGuid.IndexNewGuid(groupConstant.VolumeIndex));
			group.Pitch.CopyValues(indexToGuid.IndexNewGuid(groupConstant.PitchIndex));

			// Different Unity versions vary in whether a "send" field is used in groups as well as in snapshots.
			// GroupConstant.Has_SendIndex() can be used to determine its existence.
			// If "send" does not exist in GroupConstant, it may still exist in AudioMixerGroupController, but is just ignored.
			if (groupConstant.Has_SendIndex() && group.Has_Send())
			{
				group.Send.CopyValues(indexToGuid.IndexNewGuid(groupConstant.SendIndex));
			}
			group.Mute = groupConstant.Mute;
			group.Solo = groupConstant.Solo;
			group.BypassEffects = groupConstant.BypassEffects;
		}
	}

	private static void ProcessAudioMixerEffects(
		IAudioMixer mixer,
		GuidIndexTable indexToGuid,
		IReadOnlyList<IAudioMixerGroupController> groups,
		ProcessedAssetCollection virtualFile)
	{
		IAudioMixerConstant constants = mixer.MixerConstant_C240;

		IAudioMixerEffectController[] effects = new IAudioMixerEffectController[constants.Effects.Count];

		HashSet<IAudioMixerGroupController> groupsWithAttenuation = new();

		for (int i = 0; i < effects.Length; i++)
		{
			IAudioMixerEffectController effect = virtualFile.CreateAudioMixerEffectController();
			effect.HideFlagsE = HideFlags.HideInHierarchy | HideFlags.HideInInspector;
			effects[i] = effect;
			effect.MainAsset = mixer;
		}

		Utf8String[] pluginEffectNames = ParseNameBuffer(constants.PluginEffectNameBuffer);
		int pluginEffectIndex = 0;
		for (int i = 0; i < constants.Effects.Count; i++)
		{
			EffectConstant effectConstant = constants.Effects[i];
			IAudioMixerEffectController effect = effects[i];

			IAudioMixerGroupController group = groups[(int)effectConstant.GroupConstantIndex];
			group.EffectsP.Add(effect);

			effect.EffectID.CopyValues(constants.EffectGUIDs[i]);

			if (AudioEffectDefinitions.IsPluginEffect(effectConstant.Type))
			{
				effect.EffectName = pluginEffectNames[pluginEffectIndex++];
			}
			else
			{
				string name = AudioEffectDefinitions.EffectTypeToName(effectConstant.Type) ?? "Unknown";
				effect.EffectName = name;
				if (name == "Attenuation")
				{
					groupsWithAttenuation.Add(group);
				}
			}

			bool enableWetMix = effectConstant.WetMixLevelIndex != uint.MaxValue;
			if (enableWetMix || effect.EffectName == "Send")
			{
				effect.MixLevel.CopyValues(indexToGuid.IndexNewGuid(effectConstant.WetMixLevelIndex));
			}

			for (int j = 0; j < effectConstant.ParameterIndices.Count; j++)
			{
				Parameter param = effect.Parameters.AddNew();
				// Use a dummy name here. The actual name will be recovered by AssetRipperAudioMixerPostprocessor.
				param.ParameterName = $"Param_{j}";
				param.GUID.CopyValues(indexToGuid.IndexNewGuid(effectConstant.ParameterIndices[j]));
			}

			if (effectConstant.SendTargetEffectIndex != uint.MaxValue)
			{
				effect.SendTargetP = effects[effectConstant.SendTargetEffectIndex];
			}
			effect.EnableWetMix = enableWetMix;
			effect.Bypass = effectConstant.Bypass;
		}

		// Append an Attenuation effect to a group if it has not yet got one,
		// as Unity doesn't store Attenuation effect if it is the last.
		foreach (IAudioMixerGroupController group in groups)
		{
			if (!groupsWithAttenuation.Contains(group))
			{
				IAudioMixerEffectController effect = virtualFile.CreateAudioMixerEffectController();
				effect.HideFlagsE = HideFlags.HideInHierarchy | HideFlags.HideInInspector;
				effect.EffectID.CopyValues(UnityGuid.NewGuid());
				effect.EffectName = "Attenuation";
				effect.MainAsset = mixer;

				group.EffectsP.Add(effect);
			}
		}
	}

	private static void ProcessAudioMixerSnapshots(
		IAudioMixer mixer,
		GuidIndexTable indexToGuid)
	{
		IAudioMixerConstant constants = mixer.MixerConstant_C240;
		PPtrAccessList<PPtr_AudioMixerSnapshot, IAudioMixerSnapshot> snapshots = mixer.Snapshots_C240P;
		for (int i = 0; i < snapshots.Count; i++)
		{
			IAudioMixerSnapshot? snapshot = snapshots[i];
			if (snapshot is null)
			{
				continue;
			}

			snapshot.MainAsset = mixer;

			if (snapshot is IAudioMixerSnapshotController snapshotController)
			{
				SnapshotConstant snapshotConstant = constants.Snapshots[i];
				for (int j = 0; j < snapshotConstant.Values.Count; j++)
				{
					if (indexToGuid.TryGetValue((uint)j, out UnityGuid valueGuid))
					{
						SetValue(snapshotController.FloatValues, (GUID)valueGuid, snapshotConstant.Values[j]);
					}
					else
					{
						Logger.Warning(LogCategory.Processing, $"Snapshot({snapshotController.Name_C130}) value #{j} has no binding parameter");
					}
				}

				for (int j = 0; j < snapshotConstant.TransitionIndices.Count; j++)
				{
					uint paramIndex = snapshotConstant.TransitionIndices[j];
					int transitionType = (int)snapshotConstant.TransitionTypes[j];
					if (indexToGuid.TryGetValue(paramIndex, out UnityGuid paramGuid))
					{
						SetValue(snapshotController.TransitionOverrides, (GUID)paramGuid, transitionType);
					}
					else
					{
						Logger.Warning(LogCategory.Processing, $"Snapshot({snapshotController.Name_C130}) transition #{paramIndex} has no binding parameter");
					}
				}
			}
		}
	}

	private static void ProcessAudioMixer(
		IAudioMixerController mixer,
		GuidIndexTable indexToGuid,
		IReadOnlyList<IAudioMixerGroupController> groups)
	{
		IAudioMixerConstant constants = mixer.MixerConstant_C240;
		// generate exposed parameters
		mixer.ExposedParameters.Clear();
		for (int i = 0; i < constants.ExposedParameterIndices.Count; i++)
		{
			uint paramIndex = constants.ExposedParameterIndices[i];
			uint paramNameCrc = constants.ExposedParameterNames[i];
			if (indexToGuid.TryGetValue(paramIndex, out UnityGuid paramGuid))
			{
				ExposedAudioParameter exposedParam = mixer.ExposedParameters.AddNew();
				exposedParam.Guid.CopyValues(paramGuid);
				exposedParam.Name = Crc32Algorithm.Reverse(paramNameCrc);
			}
			else
			{
				Logger.Warning(LogCategory.Processing, $"Exposed parameter #{paramIndex} has no binding parameter");
			}
		}

		// complete mixer controller
		mixer.AudioMixerGroupViews.Clear();
		IAudioMixerGroupView groupView = mixer.AudioMixerGroupViews.AddNew();
		groupView.Name = ViewName;
		foreach (IAudioMixerGroupController group in groups)
		{
			groupView.Guids.AddNew().CopyValues(group.GroupID);
		}
		mixer.CurrentViewIndex = 0;
		mixer.TargetSnapshotP = mixer.StartSnapshotP;
	}

	private static Utf8String[] ParseNameBuffer(ReadOnlySpan<byte> buffer)
	{
		Utf8String[] names = new Utf8String[CountStrings(buffer)];
		int index = 0;
		int offset = 0;
		while (buffer[offset] != 0)
		{
			int start = offset;
			while (buffer[++offset] != 0) { }

			names[index] = new Utf8String(buffer[start..offset]);

			index++;
			offset++;
		}

		return names;

		static int CountStrings(ReadOnlySpan<byte> buffer)
		{
			int count = 0;
			for (int i = 0; i < buffer.Length; i++)
			{
				if (buffer[i] == 0)
				{
					count++;
				}
			}
			if (buffer[^1] != 0)
			{
				count++;
			}
			return count;
		}
	}

	private static void SetValue<T>(AssetDictionary<GUID, T> dictionary, GUID key, T value) where T : struct
	{
		if (!dictionary.TryGetSinglePairForKey(key, out AccessPairBase<GUID, T>? pair))
		{
			pair = dictionary.AddNew();
			pair.Key.CopyValues(key);
		}
		pair.Value = value;
	}
}

```

`Source/AssetRipper.Processing/AudioMixers/GuidIndexTable.cs`:

```cs
using AssetRipper.Import.Logging;

namespace AssetRipper.Processing.AudioMixers;

internal readonly struct GuidIndexTable
{
	private readonly Dictionary<uint, UnityGuid> table = new();

	public GuidIndexTable()
	{
	}

	public UnityGuid this[uint index] => table[index];

	public bool ContainsKey(uint index) => table.ContainsKey(index);

	public bool TryGetValue(uint index, out UnityGuid guid) => table.TryGetValue(index, out guid);

	public UnityGuid IndexNewGuid(uint index)
	{
		if (table.TryGetValue(index, out UnityGuid guid))
		{
			Logger.Warning(LogCategory.Processing, $"Constant index #{index} conflicts with another one.");
		}
		else
		{
			guid = UnityGuid.NewGuid();
			table.Add(index, guid);
		}
		return guid;
	}
}

```

`Source/AssetRipper.Processing/Configuration/BundledAssetsExportMode.cs`:

```cs
namespace AssetRipper.Processing.Configuration;

public enum BundledAssetsExportMode
{
	/// <summary>
	/// Bundled assets are treated the same as assets from other files.
	/// </summary>
	GroupByAssetType,
	/// <summary>
	/// Bundled assets are grouped by their asset bundle name.<br/>
	/// For example: Assets/Asset_Bundles/NameOfAssetBundle/InternalPath1/.../InternalPathN/assetName.extension
	/// </summary>
	GroupByBundleName,
	/// <summary>
	/// Bundled assets are exported without grouping.<br/>
	/// For example: Assets/InternalPath1/.../InternalPathN/bundledAssetName.extension
	/// </summary>
	DirectExport,
}

```

`Source/AssetRipper.Processing/Configuration/ProcessingSettings.cs`:

```cs
using AssetRipper.Import.Logging;

namespace AssetRipper.Processing.Configuration;

public sealed record class ProcessingSettings
{
	public bool EnablePrefabOutlining { get; set; } = false;
	public bool EnableStaticMeshSeparation { get; set; } = true;
	public bool EnableAssetDeduplication { get; set; } = false;
	public bool RemoveNullableAttributes { get; set; } = false;
	public bool PublicizeAssemblies { get; set; } = false;
	public BundledAssetsExportMode BundledAssetsExportMode { get; set; } = BundledAssetsExportMode.DirectExport;

	public void Log()
	{
		Logger.Info(LogCategory.General, $"{nameof(EnablePrefabOutlining)}: {EnablePrefabOutlining}");
		Logger.Info(LogCategory.General, $"{nameof(EnableStaticMeshSeparation)}: {EnableStaticMeshSeparation}");
		Logger.Info(LogCategory.General, $"{nameof(EnableAssetDeduplication)}: {EnableAssetDeduplication}");
		Logger.Info(LogCategory.General, $"{nameof(BundledAssetsExportMode)}: {BundledAssetsExportMode}");
	}
}

```

`Source/AssetRipper.Processing/DeletedAssetsInformation.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;

namespace AssetRipper.Processing;

public sealed class DeletedAssetsInformation : AssetGroup
{
	public DeletedAssetsInformation(AssetInfo assetInfo) : base(assetInfo)
	{
	}

	public List<IUnityObjectBase> DeletedAssets { get; } = new();

	public override List<IUnityObjectBase> Assets => DeletedAssets;

	public override void WalkStandard(AssetWalker walker)
	{
		if (walker.EnterAsset(this))
		{
			this.WalkPPtrListField(walker, DeletedAssets);
			walker.ExitAsset(this);
		}
	}

	public override IEnumerable<(string, PPtr)> FetchDependencies()
	{
		foreach (IUnityObjectBase asset in DeletedAssets)
		{
			yield return ($"{nameof(DeletedAssets)}[]", AssetToPPtr(asset));
		}
	}
}

```

`Source/AssetRipper.Processing/Editor/EditorFormatConverter.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Processing.Editor;

internal static class EditorFormatConverter
{
	public static void Convert(IRenderer renderer)
	{
		renderer.ScaleInLightmap_C25 = 1.0f;
		renderer.ReceiveGI_C25 = (int)ReceiveGI.Lightmaps;
		renderer.PreserveUVs_C25 = false;
		renderer.IgnoreNormalsForChartDetection_C25 = false;
		renderer.ImportantGI_C25 = false;
		renderer.StitchLightmapSeams_C25 = false;
		renderer.SelectedEditorRenderState_C25 = (int)(EditorSelectedRenderState)3;
		renderer.MinimumChartSize_C25 = 4;
		renderer.AutoUVMaxDistance_C25 = 0.5f;
		renderer.AutoUVMaxAngle_C25 = 89.0f;
		renderer.LightmapParameters_C25P = null;
		if (renderer.Has_StaticBatchInfo_C25())
		{
			if (!renderer.StaticBatchInfo_C25.IsDefault())
			{
				renderer.MarkGameObjectAsStatic();
			}
		}
		else if (renderer.Has_SubsetIndices_C25())
		{
			if (renderer.SubsetIndices_C25.Count != 0)
			{
				renderer.MarkGameObjectAsStatic();
			}
		}
	}
}

```

`Source/AssetRipper.Processing/Editor/EditorFormatConverterAsync.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Generics;
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Classes.ClassID_320;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.ExposedReferenceTable;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Object;
using AssetRipper.SourceGenerated.Subclasses.PropertyName;
using System.Numerics;

namespace AssetRipper.Processing.Editor;

/// <summary>
/// 
/// </summary>
/// <remarks>
/// Rules for the methods in this class:
/// <list type="bullet">
/// <item>All methods must be static.</item>
/// <item>All public methods must return void and be named Convert.</item>
/// <item>Each public method must only take one parameter, and that parameter's type must inherit from <see cref="IUnityObjectBase"/>.</item>
/// <item>They must not resolve any PPtrs.</item>
/// </list>
/// </remarks>
internal static class EditorFormatConverterAsync
{
	public static void Convert(ITransform transform)
	{
		if (transform.Has_RootOrder_C4())
		{
			transform.RootOrder_C4 = transform.CalculateRootOrder();
		}
		if (transform.Has_LocalEulerAnglesHint_C4())
		{
			Vector3 eulerHints = new Quaternion(
				transform.LocalRotation_C4.X,
				transform.LocalRotation_C4.Y,
				transform.LocalRotation_C4.Z,
				transform.LocalRotation_C4.W).ToEulerAngle(true);
			transform.LocalEulerAnglesHint_C4.SetValues(eulerHints.X, eulerHints.Y, eulerHints.Z);
		}
	}

	public static void Convert(IPlayableDirector playableDirector)
	{
		if (playableDirector.Has_ExposedReferences_C320())
		{
			IExposedReferenceTable table = playableDirector.ExposedReferences_C320;
			table.References_Editor.Clear();
			table.References_Editor.Capacity = table.References_Release.Count;
			foreach ((IPropertyName key, PPtr_Object_5 value) in table.References_Release)
			{
				AssetPair<Utf8String, PPtr_Object_5> pair = table.References_Editor.AddNew();
				pair.Key = key.GetIdString();
				pair.Value.CopyValues(value, new PPtrConverter(playableDirector));
			}
		}
	}
}

```

`Source/AssetRipper.Processing/Editor/EditorFormatProcessor.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.AssetCreation;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.Import.Structure.Assembly.Serializable;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.Processing.AnimationClips;
using AssetRipper.Processing.Configuration;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_142;
using AssetRipper.SourceGenerated.Classes.ClassID_147;
using AssetRipper.SourceGenerated.Classes.ClassID_157;
using AssetRipper.SourceGenerated.Classes.ClassID_19;
using AssetRipper.SourceGenerated.Classes.ClassID_196;
using AssetRipper.SourceGenerated.Classes.ClassID_218;
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Classes.ClassID_30;
using AssetRipper.SourceGenerated.Classes.ClassID_320;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_47;
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_78;
using AssetRipper.SourceGenerated.Classes.ClassID_850595691;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions;
using System.Diagnostics;

namespace AssetRipper.Processing.Editor;

/// <summary>
/// <para>
/// This processor primarily handles "editor-only" fields.
/// These fields exist in the Unity Editor, but not in compiled game files.
/// Without this processing, those fields would have C# default values of zero.
/// </para>
/// <para>
/// For most fields, this is just setting the field to the Unity default.
/// However for some fields, there can be a calculation to recover an appropriate
/// value for the field. For example, <see cref="ITransform.LocalEulerAnglesHint_C4"/>
/// is set using <see cref="ITransform.LocalRotation_C4"/> with a Quaternion to
/// Euler angle conversion. Similarly, <see cref="ITransform.RootOrder_C4"/> is
/// calculated from <see cref="ITransform.Father_C4P"/> and <see cref="ITransform.Children_C4P"/>.
/// </para>
/// <para>
/// Compiled game files can be identified from binary editor files by the 
/// <see cref="TransferInstructionFlags.SerializeGameRelease"/> flag.
/// However, those binary editor files are not commonly ripped with AssetRipper.
/// More often, generated <see cref="ProcessedAssetCollection"/>s are given editor flags
/// so as to exclude them from unnecessary processing. This is the default for
/// <see cref="GameBundle.AddNewProcessedCollection(string, UnityVersion)"/>.
/// </para>
/// </summary>
public class EditorFormatProcessor : IAssetProcessor
{
	private ITagManager? tagManager;
	private readonly BundledAssetsExportMode bundledAssetsExportMode;
	private IAssemblyManager? assemblyManager;
	private PathChecksumCache? checksumCache;

	public EditorFormatProcessor(BundledAssetsExportMode bundledAssetsExportMode)
	{
		this.bundledAssetsExportMode = bundledAssetsExportMode;
	}

	public void Process(GameData gameData)
	{
		Logger.Info(LogCategory.Processing, "Editor Format Conversion");
		tagManager = gameData.GameBundle.FetchAssets().OfType<ITagManager>().FirstOrDefault();
		assemblyManager = gameData.AssemblyManager;
		checksumCache = new PathChecksumCache(gameData);

		//Sequential processing
		foreach (IUnityObjectBase asset in GetReleaseAssets(gameData))
		{
			Convert(asset);
		}

		//Parallel processing
		Parallel.ForEach(GetReleaseAssets(gameData), ConvertAsync);

		checksumCache = null;
		assemblyManager = null;
		tagManager = null;
	}

	private static IEnumerable<IUnityObjectBase> GetReleaseAssets(GameData gameData)
	{
		return GetReleaseCollections(gameData).SelectMany(c => c);
	}

	private static IEnumerable<AssetCollection> GetReleaseCollections(GameData gameData)
	{
		return gameData.GameBundle.FetchAssetCollections().Where(c => c.Flags.IsRelease());
	}

	private void Convert(IUnityObjectBase asset)
	{
		switch (asset)
		{
			//ordered by approximate frequency
			case IGameObject gameObject:
				gameObject.ConvertToEditorFormat(tagManager);
				break;
			case IRenderer renderer:
				EditorFormatConverter.Convert(renderer);
				break;
			case ISpriteAtlas spriteAtlas:
				spriteAtlas.ConvertToEditorFormat();
				break;
			case IAnimationClip animationClip:
				AnimationClipConverter.Process(animationClip, checksumCache!.Value);
				break;
			case IAssetBundle assetBundle:
				OriginalPathHelper.SetOriginalPaths(assetBundle, bundledAssetsExportMode);
				break;
			case INavMeshSettings navMeshSettings:
				navMeshSettings.ConvertToEditorFormat();
				break;
			case IResourceManager resourceManager:
				OriginalPathHelper.SetOriginalPaths(resourceManager);
				break;
			case TypeTreeObject { IsPlayerSettings: true } playerSettings:
				SerializableStructure editorStructure = playerSettings.EditorFields;
				if (editorStructure.ContainsField("webGLLinkerTarget"))
				{
					editorStructure["webGLLinkerTarget"].AsInt32 = 1;
				}
				if (editorStructure.ContainsField("allowUnsafeCode"))
				{
					editorStructure["allowUnsafeCode"].AsBoolean = true;
				}
				ApiCompatibilityLevel compatibilityLevel;
				ScriptingRuntimeVersion runtimeVersion;
				Debug.Assert(assemblyManager is not null);
				if (assemblyManager.HasMscorlib2)
				{
					compatibilityLevel = ApiCompatibilityLevel.NET_2_0;
					runtimeVersion = ScriptingRuntimeVersion.Legacy;
				}
				else
				{
					compatibilityLevel = ApiCompatibilityLevel.NET_Unity_4_8;
					runtimeVersion = ScriptingRuntimeVersion.Latest;
				}
				if (editorStructure.ContainsField("apiCompatibilityLevel"))
				{
					editorStructure["apiCompatibilityLevel"].AsInt32 = (int)compatibilityLevel;
				}
				if (editorStructure.ContainsField("scriptingRuntimeVersion"))
				{
					editorStructure["scriptingRuntimeVersion"].AsInt32 = (int)runtimeVersion;
				}
				break;
		}
	}

	private static void ConvertAsync(IUnityObjectBase asset)
	{
		switch (asset)
		{
			//ordered by approximate frequency
			case ITransform transform:
				EditorFormatConverterAsync.Convert(transform);
				break;
			case IMesh mesh:
				mesh.SetMeshOptimizationFlags(MeshOptimizationFlags.Everything);
				break;
			case ITerrain terrain:
				terrain.ScaleInLightmap = 0.0512f;
				break;
			case IPlayableDirector playableDirector:
				EditorFormatConverterAsync.Convert(playableDirector);
				break;
			case IGraphicsSettings graphicsSettings:
				graphicsSettings.ConvertToEditorFormat();
				break;
			case IQualitySettings qualitySettings:
				qualitySettings.ConvertToEditorFormat();
				break;
			case IPhysics2DSettings physics2DSettings:
				physics2DSettings.ConvertToEditorFormat();
				break;
			case ILightmapSettings lightmapSettings:
				lightmapSettings.ConvertToEditorFormat();
				break;
			case ILightingSettings lightingSettings:
				lightingSettings.ConvertToEditorFormat();
				break;
		}
	}
}

```

`Source/AssetRipper.Processing/Editor/OriginalPathHelper.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;
using AssetRipper.Processing.Configuration;
using AssetRipper.SourceGenerated.Classes.ClassID_142;
using AssetRipper.SourceGenerated.Classes.ClassID_147;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.AssetInfo;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Object;

namespace AssetRipper.Processing.Editor;

internal static class OriginalPathHelper
{
	private const string ResourcesKeyword = "Resources";
	private const string DirectorySeparator = "/";
	private const string AssetsDirectory = AssetsKeyword + DirectorySeparator;
	private const string ResourceFullPath = AssetsDirectory + ResourcesKeyword;
	private const string AssetBundleFullPath = AssetsDirectory + "Asset_Bundles";
	private const string AssetsKeyword = "Assets";

	internal static void SetOriginalPaths(IResourceManager manager)
	{
		foreach (AccessPairBase<Utf8String, IPPtr_Object> kvp in manager.Container)
		{
			IUnityObjectBase? asset = kvp.Value.TryGetAsset(manager.Collection);
			if (asset is null)
			{
				continue;
			}

			string resourcePath = Path.Join(ResourceFullPath, kvp.Key.String);
			if (asset.OriginalPath is null)
			{
				asset.OriginalPath = resourcePath;
				UndoPathLowercasing(asset);
				SetOverridePathIfShader(asset);
			}
			else if (asset.OriginalPath.Length < resourcePath.Length)
			{
				// for paths like "Resources/inner/resources/extra/file" engine creates 2 resource entries
				// "inner/resources/extra/file" and "extra/file"
				asset.OriginalPath = resourcePath;
				UndoPathLowercasing(asset);
				SetOverridePathIfShader(asset);
			}
		}
	}

	/// <summary>
	/// 
	/// </summary>
	/// <remarks>
	/// TODO: Asset bundles usually contain more assets than listed in <see cref="IAssetBundle.Container"/>. 
	/// Need to export them in AssetBundleFullPath directory if <see cref="m_BundledAssetsExportMode"/> is <see cref="BundledAssetsExportMode.GroupByBundleName"/>.
	/// Or maybe remove that mode entirely. It has dubious utility.
	/// </remarks>
	/// <param name="bundle"></param>
	/// <exception cref="Exception"></exception>
	internal static void SetOriginalPaths(IAssetBundle bundle, BundledAssetsExportMode bundledAssetsExportMode)
	{
		string bundleName = bundle.GetAssetBundleName();
		string bundleDirectory = bundleName + DirectorySeparator;
		string directory = Path.Join(AssetBundleFullPath, bundleName);
		foreach (AccessPairBase<Utf8String, IAssetInfo> kvp in bundle.Container)
		{
			// skip shared bundle assets, because we need to export them in their bundle directory
			if (kvp.Value.Asset.FileID != 0)
			{
				continue;
			}

			IUnityObjectBase? asset = kvp.Value.Asset.TryGetAsset(bundle.Collection);
			if (asset is null)
			{
				continue;
			}

			asset.AssetBundleName = bundleName;

			string assetPath = EnsurePathNotRooted(kvp.Key.String);
			if (string.IsNullOrEmpty(assetPath))
			{
				continue;
			}

			switch (bundledAssetsExportMode)
			{
				case BundledAssetsExportMode.DirectExport:
					asset.OriginalPath = EnsureStartsWithAssets(assetPath);
					break;
				case BundledAssetsExportMode.GroupByBundleName:
					if (assetPath.StartsWith(AssetsDirectory, StringComparison.OrdinalIgnoreCase))
					{
						assetPath = assetPath.Substring(AssetsDirectory.Length);
					}
					if (assetPath.StartsWith(bundleDirectory, StringComparison.OrdinalIgnoreCase))
					{
						assetPath = assetPath.Substring(bundleDirectory.Length);
					}
					asset.OriginalPath = Path.Join(directory, assetPath);
					break;
				case BundledAssetsExportMode.GroupByAssetType:
					break;
				default:
					throw new ArgumentOutOfRangeException(nameof(bundledAssetsExportMode), $"Invalid {nameof(BundledAssetsExportMode)} : {bundledAssetsExportMode}");
			}
			UndoPathLowercasing(asset);
			SetOverridePathIfShader(asset);
		}
	}

	internal static string EnsurePathNotRooted(string assetPath)
	{
		if (Path.IsPathRooted(assetPath))
		{
			string[] splitPath = assetPath.Split('/');
			for (int i = 0; i < splitPath.Length; i++)
			{
				string pathSection = splitPath[i];
				if (string.Equals(pathSection, AssetsKeyword, StringComparison.OrdinalIgnoreCase))
				{
					return string.Join(DirectorySeparator, new ReadOnlySpan<string?>(splitPath, i, splitPath.Length - i));
				}
			}
			return string.Empty;
		}
		else
		{
			return assetPath;
		}
	}

	internal static string EnsureStartsWithAssets(string assetPath)
	{
		if (assetPath.StartsWith(AssetsDirectory, StringComparison.Ordinal))
		{
			return assetPath;
		}
		else if (assetPath.StartsWith(AssetsDirectory, StringComparison.OrdinalIgnoreCase))
		{
			return $"{AssetsDirectory}{assetPath.AsSpan(AssetsDirectory.Length)}";
		}
		else
		{
			return AssetsDirectory + assetPath;
		}
	}

	/// <summary>
	/// During compilation, Unity often lowers all the characters in a path. This restores the proper capitalization for asset names.
	/// </summary>
	/// <param name="asset"></param>
	private static void UndoPathLowercasing(IUnityObjectBase asset)
	{
		string? assetName = (asset as INamed)?.Name;
		string? originalName = asset.OriginalName;
		if (assetName is not null
			&& originalName is not null
			&& assetName.Length == originalName.Length
			&& originalName == assetName.ToLowerInvariant())
		{
			asset.OriginalName = assetName;
		}
	}

	private static void SetOverridePathIfShader(IUnityObjectBase asset)
	{
		if (asset is IShader shader)
		{
			shader.OverrideDirectory ??= shader.OriginalDirectory;
			shader.OverrideName ??= shader.OriginalName;
			shader.OverrideExtension ??= shader.OriginalExtension;
		}
	}
}

```

`Source/AssetRipper.Processing/GameData.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.Structure;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.Import.Structure.Platforms;

namespace AssetRipper.Processing;

public record GameData(
	GameBundle GameBundle,
	UnityVersion ProjectVersion,
	IAssemblyManager AssemblyManager,
	PlatformGameStructure? PlatformStructure)
{
	public ProcessedAssetCollection AddNewProcessedCollection(string name)
	{
		return GameBundle.AddNewProcessedCollection(name, ProjectVersion);
	}

	public static GameData FromGameStructure(GameStructure gameStructure)
	{
		return new(gameStructure.FileCollection, gameStructure.FileCollection.GetMaxUnityVersion(), gameStructure.AssemblyManager, gameStructure.PlatformStructure);
	}
}

```

`Source/AssetRipper.Processing/IAssetProcessor.cs`:

```cs
namespace AssetRipper.Processing;

public interface IAssetProcessor
{
	void Process(GameData gameData);
}

```

`Source/AssetRipper.Processing/LightingDataProcessor.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Generics;
using AssetRipper.Import.Logging;
using AssetRipper.IO.Files.BundleFiles;
using AssetRipper.IO.Files.BundleFiles.FileStream;
using AssetRipper.SourceGenerated.Classes.ClassID_0;
using AssetRipper.SourceGenerated.Classes.ClassID_1032;
using AssetRipper.SourceGenerated.Classes.ClassID_104;
using AssetRipper.SourceGenerated.Classes.ClassID_108;
using AssetRipper.SourceGenerated.Classes.ClassID_1120;
using AssetRipper.SourceGenerated.Classes.ClassID_157;
using AssetRipper.SourceGenerated.Classes.ClassID_218;
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Classes.ClassID_258;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_33;
using AssetRipper.SourceGenerated.Classes.ClassID_850595691;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.LightmapData;
using AssetRipper.SourceGenerated.Subclasses.RendererData;
using AssetRipper.SourceGenerated.Subclasses.SceneObjectIdentifier;

namespace AssetRipper.Processing;

public class LightingDataProcessor : IAssetProcessor
{
	/// <summary>
	/// The default name of newly created <see cref="ILightingDataAsset"/>s.
	/// </summary>
	private static Utf8String LightingDataName { get; } = new("LightingData");

	public void Process(GameData gameData)
	{
		Logger.Info(LogCategory.Processing, "Lighting Data Assets");
		ProcessedAssetCollection processedCollection = gameData.AddNewProcessedCollection("Generated Lighting Data Assets");

		Dictionary<ILightmapSettings, SceneDefinition> lightmapSettingsDictionary = new();
		Dictionary<ILightProbes, SceneDefinition?> lightProbeDictionary = new();
		Dictionary<ILightingSettings, SceneDefinition?> lightingSettingsDictionary = new();

		foreach (SceneDefinition scene in gameData.GameBundle.Scenes)
		{
			//Only scenes can contain a LightmapSettings asset.
			ILightmapSettings? lightmapSettings = scene.Assets.OfType<ILightmapSettings>().FirstOrDefault();
			if (lightmapSettings is null)
			{
				continue;
			}

			IRenderSettings? renderSettings = scene.Assets.OfType<IRenderSettings>().FirstOrDefault();
			if (renderSettings is null)
			{
				// This should never happen. All scenes need a RenderSettings asset.
				continue;
			}

			lightmapSettingsDictionary.Add(lightmapSettings, scene);

			if (lightmapSettings.LightProbesP is { } lightProbes && !lightProbeDictionary.TryAdd(lightProbes, scene))
			{
				//This set of light probes is shared between scenes.
				lightProbeDictionary[lightProbes] = null;
			}

			if (lightmapSettings.LightingSettingsP is { } lightingSettings && !lightingSettingsDictionary.TryAdd(lightingSettings, scene))
			{
				//This LightingSettings is shared between scenes.
				lightingSettingsDictionary[lightingSettings] = null;
			}

			if (!lightmapSettings.Has_LightingDataAsset())
			{
				continue;
			}

			ILightingDataAsset lightingDataAsset = processedCollection.CreateLightingDataAsset();

			lightmapSettings.LightingDataAssetP = lightingDataAsset;

			PPtrConverter converter = new PPtrConverter(lightmapSettings, lightingDataAsset);

			lightingDataAsset.LightmapsMode = lightmapSettings.LightmapsMode;
			lightingDataAsset.EnlightenData = CreateEnlightenData(lightingDataAsset.Collection.Version);

			SetEnlightenSceneMapping(lightingDataAsset, lightmapSettings, converter);
			SetBakedAmbientProbes(lightingDataAsset, renderSettings);
			AddSkyboxReflection(lightingDataAsset, renderSettings);
			SetLightmaps(lightingDataAsset, lightmapSettings.Lightmaps, converter);
			SetScene(lightingDataAsset, scene, processedCollection);
			SetLightProbes(lightingDataAsset, lightmapSettings);
			SetEnlightenDataVersion(lightingDataAsset);

			foreach (IUnityObjectBase asset in scene.Assets)
			{
				switch (asset)
				{
					case IRenderer renderer:
						AddRenderer(lightingDataAsset, renderer);
						break;
					case ITerrain terrain:
						AddTerrain(lightingDataAsset, terrain);
						break;
					case ILight light:
						AddLight(lightingDataAsset, light);
						break;
				}
			}
		}

		foreach ((ILightmapSettings lightmapSettings, SceneDefinition scene) in lightmapSettingsDictionary)
		{
			ILightProbes? lightProbes = lightmapSettings.LightProbesP;
			if (lightProbes is not null && lightProbeDictionary[lightProbes] is null)
			{
				lightProbes = null;//Shared light probes should not have their path set.
			}

			ILightingSettings? lightingSettings = lightmapSettings.LightingSettingsP;
			if (lightingSettings is not null && lightingSettingsDictionary[lightingSettings] is null)
			{
				lightingSettings = null;//Shared light settings should not have their path set.
			}

			SetPathsAndMainAsset(lightmapSettings, lightProbes, lightingSettings, scene);
		}
	}

	private static void AddRenderer(ILightingDataAsset lightingDataAsset, IRenderer renderer)
	{
		//-1 indicates that it's not part of the lightmap.
		ushort lightmapIndex = renderer.GetLightmapIndex();
		if (lightmapIndex != ushort.MaxValue)// || renderer.LightmapIndexDynamic_C25 != ushort.MaxValue)
		{
			//Scene object identifiers for the renderer associated with each value in the lightmapped renderer data array
			SceneObjectIdentifier identifier = lightingDataAsset.LightmappedRendererDataIDs.AddNew();
			identifier.TargetObjectReference = renderer;

			//The lightmap index, lightmap uv scale/offset value, etc
			IRendererData rendererData = lightingDataAsset.LightmappedRendererData.AddNew();
			rendererData.LightmapIndex = lightmapIndex;

			//This seems to crash the editor when it's not set to -1.
			//See: https://github.com/AssetRipper/AssetRipper/issues/811
			rendererData.LightmapIndexDynamic = ushort.MaxValue;//renderer.LightmapIndexDynamic_C25;

			rendererData.LightmapST.CopyValues(renderer.LightmapTilingOffset_C25);
			rendererData.LightmapSTDynamic.CopyValues(renderer.LightmapTilingOffsetDynamic_C25);
			rendererData.UvMesh.SetAsset(lightingDataAsset.Collection, renderer.GameObject_C25P?.TryGetComponent<IMeshFilter>()?.MeshP);
		}
		else
		{
			// No lightmap data associated with the renderer
		}
	}

	private static void AddTerrain(ILightingDataAsset lightingDataAsset, ITerrain terrain)
	{
		//-1 indicates that it's not part of the lightmap.
		if (terrain.LightmapIndex != ushort.MaxValue)// || terrain.LightmapIndexDynamic != ushort.MaxValue)
		{
			//Scene object identifiers for the terrain associated with each value in the lightmapped renderer data array
			SceneObjectIdentifier identifier = lightingDataAsset.LightmappedRendererDataIDs.AddNew();
			identifier.TargetObjectReference = terrain;

			//The lightmap index, lightmap uv scale/offset value, etc
			IRendererData rendererData = lightingDataAsset.LightmappedRendererData.AddNew();
			rendererData.LightmapIndex = terrain.LightmapIndex;

			//This seems to crash the editor when it's not set to -1.
			//See: https://github.com/AssetRipper/AssetRipper/issues/811
			rendererData.LightmapIndexDynamic = ushort.MaxValue;//terrain.LightmapIndexDynamic;

			rendererData.LightmapST.CopyValues(terrain.LightmapTilingOffset);
			rendererData.LightmapSTDynamic.CopyValues(terrain.LightmapTilingOffsetDynamic);

			rendererData.TerrainDynamicUVST.CopyValues(terrain.DynamicUVST);
			rendererData.TerrainChunkDynamicUVST.CopyValues(terrain.ChunkDynamicUVST);
			rendererData.ExplicitProbeSetHash?.CopyValues(terrain.ExplicitProbeSetHash);
		}
		else
		{
			// No lightmap data associated with the terrain
		}
	}

	private static void AddLight(ILightingDataAsset lightingDataAsset, ILight light)
	{
		// We're not sure what the most appropriate way to check if a light belongs
		// in these arrays or not is, but just including all of them is harmless.

		SceneObjectIdentifier identifier = lightingDataAsset.Lights.AddNew();
		identifier.TargetObjectReference = light;

		//Information about whether a light is baked or not
		if (light.Has_BakingOutput())
		{
			lightingDataAsset.LightBakingOutputs?.AddNew().CopyValues(light.BakingOutput);
		}
	}

	private static void SetEnlightenSceneMapping(ILightingDataAsset lightingDataAsset, ILightmapSettings lightmapSettings, PPtrConverter converter)
	{
		lightingDataAsset.EnlightenSceneMapping.CopyValues(lightmapSettings.EnlightenSceneMapping, converter);

		foreach (IObject? renderer in lightingDataAsset.EnlightenSceneMapping.Renderers.Select(r => r.Renderer.TryGetAsset(lightingDataAsset.Collection)))
		{
			lightingDataAsset.EnlightenSceneMappingRendererIDs.AddNew().TargetObjectReference = renderer;
		}
	}

	private static void SetBakedAmbientProbes(ILightingDataAsset lightingDataAsset, IRenderSettings renderSettings)
	{
		if (renderSettings.Has_AmbientProbeInGamma())
		{
			if (lightingDataAsset.Has_BakedAmbientProbeInGamma())
			{
				lightingDataAsset.BakedAmbientProbeInGamma.CopyValues(renderSettings.AmbientProbeInGamma);
			}
			else if (lightingDataAsset.Has_BakedAmbientProbesInGamma())
			{
				lightingDataAsset.BakedAmbientProbesInGamma.AddNew().CopyValues(renderSettings.AmbientProbeInGamma);
			}
		}
		if (renderSettings.Has_AmbientProbe())
		{
			if (lightingDataAsset.Has_BakedAmbientProbeInLinear())
			{
				lightingDataAsset.BakedAmbientProbeInLinear.CopyValues(renderSettings.AmbientProbe);
			}
			else if (lightingDataAsset.Has_BakedAmbientProbesInLinear())
			{
				lightingDataAsset.BakedAmbientProbesInLinear.AddNew().CopyValues(renderSettings.AmbientProbe);
			}
		}
	}

	private static void AddSkyboxReflection(ILightingDataAsset lightingDataAsset, IRenderSettings renderSettings)
	{
		if (renderSettings.GeneratedSkyboxReflectionP is { } skyboxReflection)
		{
			lightingDataAsset.BakedReflectionProbeCubemapsP.Add(skyboxReflection);
		}
	}

	/// <summary>
	/// Add several <see cref="ILightmapData"/> to <see cref="ILightingDataAsset.Lightmaps"/>.
	/// </summary>
	/// <param name="lightingDataAsset"></param>
	/// <param name="lightmaps"></param>
	/// <param name="converter"></param>
	private static void SetLightmaps(ILightingDataAsset lightingDataAsset, AccessListBase<ILightmapData> lightmaps, PPtrConverter converter)
	{
		foreach (ILightmapData lightmapData in lightmaps)
		{
			lightingDataAsset.Lightmaps.AddNew().CopyValues(lightmapData, converter);
		}
	}

	private static void SetPathsAndMainAsset(ILightmapSettings lightmapSettings, ILightProbes? lightProbes, ILightingSettings? lightingSettings, SceneDefinition scene)
	{
		//Several assets should all be exported in a subfolder beside the scene.
		//Example:
		//Scenes
		//  MyScene.unity
		//  MyScene //This folder has the same name as the scene.
		//    LightingData.asset //This is the default name from Unity.
		//    LightProbes.asset //optional; this can be anywhere
		//    <a bunch of lightmap textures> //optional; the textures can be anywhere

		ILightingDataAsset? lightingDataAsset = lightmapSettings.LightingDataAssetP;
		if (lightingDataAsset is not null)
		{
			lightingDataAsset.MainAsset = lightingDataAsset;

			lightingDataAsset.OriginalDirectory ??= scene.Path;
			if (lightingDataAsset.Name.IsEmpty)
			{
				lightingDataAsset.Name = LightingDataName;
			}

			//This OriginalName is purely for the UI. Name is used for exporting the asset.
			lightingDataAsset.OriginalName ??= scene.Name;
		}

		//Move the light probes to the scene subfolder if it exists and is not shared with other scenes.
		if (lightProbes is not null)
		{
			lightProbes.OriginalDirectory ??= scene.Path;
		}

		//Move the light settings to the scene subfolder if it exists and is not shared with other scenes.
		//There's no requirement to place it there, but it helps with organization.
		//This is particularly useful when many LightingSettings have the same name.
		if (lightingSettings is not null)
		{
			lightingSettings.OriginalDirectory ??= scene.Path;
		}

		//Move the lightmap textures to the scene subfolder.
		foreach (ILightmapData lightmapData in lightmapSettings.Lightmaps)
		{
			if (lightmapData.DirLightmap?.TryGetAsset(lightmapSettings.Collection, out ITexture2D? dirLightmap) ?? false)
			{
				dirLightmap.OriginalDirectory ??= scene.Path;
				dirLightmap.MainAsset = lightingDataAsset;
			}
			if (lightmapData.IndirectLightmap?.TryGetAsset(lightmapSettings.Collection, out ITexture2D? indirectLightmap) ?? false)
			{
				indirectLightmap.OriginalDirectory ??= scene.Path;
				indirectLightmap.MainAsset = lightingDataAsset;
			}
			if (lightmapData.Lightmap.TryGetAsset(lightmapSettings.Collection, out ITexture2D? lightmap))
			{
				lightmap.OriginalDirectory ??= scene.Path;
				lightmap.MainAsset = lightingDataAsset;
			}
			if (lightmapData.ShadowMask?.TryGetAsset(lightmapSettings.Collection, out ITexture2D? shadowMask) ?? false)
			{
				shadowMask.OriginalDirectory ??= scene.Path;
				shadowMask.MainAsset = lightingDataAsset;
			}
		}
	}

	/// <summary>
	/// Sets <see cref="ILightingDataAsset.LightProbesP"/> from <see cref="ILightmapSettings.LightProbesP"/>.
	/// </summary>
	/// <remarks>
	/// Note: it is possible for a LightProbes asset to be shared between multiple LightingDataAsset.<br/>
	/// However, that happened when multiple scenes were loaded additively and baked together.<br/>
	/// In that situation, the LightProbes asset and each LightingDataAsset were all in one binary file.<br/>
	/// A LightingDataAssetParent was also in the file and acted as the main asset in the NativeFormatImporter.
	/// </remarks>
	/// <param name="lightingDataAsset"></param>
	/// <param name="lightmapSettings"></param>
	private static void SetLightProbes(ILightingDataAsset lightingDataAsset, ILightmapSettings lightmapSettings)
	{
		lightingDataAsset.LightProbesP = lightmapSettings.LightProbesP;
	}

	/// <summary>
	/// Sets <see cref="ILightingDataAsset.SceneP"/> or <see cref="ILightingDataAsset.SceneGUID"/>.
	/// </summary>
	/// <param name="lightingDataAsset"></param>
	/// <param name="scene"></param>
	/// <param name="processedCollection"></param>
	private static void SetScene(ILightingDataAsset lightingDataAsset, SceneDefinition scene, ProcessedAssetCollection processedCollection)
	{
		if (lightingDataAsset.Has_Scene())
		{
			ISceneAsset sceneAsset = CreateSceneAsset(processedCollection, scene);
			lightingDataAsset.SceneP = sceneAsset;
		}
		else if (lightingDataAsset.Has_SceneGUID())
		{
			lightingDataAsset.SceneGUID.CopyValues(scene.GUID);
		}
	}

	/// <summary>
	/// Sets <see cref="ILightingDataAsset.EnlightenDataVersion"/>
	/// </summary>
	/// <remarks>
	/// This value must be assigned correctly. The version varies widely based on Unity version.<br/>
	/// It seems that -1 will not suffice. 112 is the version that 2021.1 and 2021.2 use.<br/>
	/// Since Enlighten is no longer being maintained, any later version should also use 112.<br/>
	/// Supposedly, 112 has been in use since 2017 or possibly even late Unity 5.<br/>
	/// To extract the Enlighten version for each Unity version, one would have to create
	/// a test project on each version and then bake the lighting in the test project.<br/>
	/// There is no proper API to create a LightingDataAsset.
	/// </remarks>
	/// <param name="lightingDataAsset"></param>
	private static void SetEnlightenDataVersion(ILightingDataAsset lightingDataAsset)
	{
		lightingDataAsset.EnlightenDataVersion = 112;
	}

	private static ISceneAsset CreateSceneAsset(ProcessedAssetCollection collection, SceneDefinition targetScene)
	{
		ISceneAsset asset = collection.CreateSceneAsset();
		asset.TargetScene = targetScene;
		return asset;
	}

	private static byte[] CreateEnlightenData(UnityVersion version)
	{
		// For many of the lighting data assets I've encountered, they just contained the bytes of an empty asset bundle.
		BundleVersion bundleVersion = false switch
		{
			_ when version.GreaterThanOrEquals(2022, 2) => BundleVersion.BF_2022_2,
			_ when version.GreaterThanOrEquals(2020) => BundleVersion.BF_LargeFilesSupport, // This started sometime during 2019.4.X, so we use 2020 just to be safe.
			_ when version.GreaterThanOrEquals(5, 2, 0, UnityVersionType.Final) => BundleVersion.BF_520_x,
			_ => BundleVersion.BF_350_4x,
		};

		FileStreamBundleFile bundle = new();
		FileStreamBundleHeader header = bundle.Header;
		header.Version = bundleVersion;
		header.UnityWebBundleVersion = "5.x.x";
		header.UnityWebMinimumRevision = version.ToString();

		using MemoryStream stream = new();
		bundle.Write(stream);

		return stream.ToArray();
	}
}

```

`Source/AssetRipper.Processing/MainAssetProcessor.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_128;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_27;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Processing;

public class MainAssetProcessor : IAssetProcessor
{
	public void Process(GameData gameData)
	{
		Logger.Info(LogCategory.Processing, "Main Asset Pairing");
		foreach (IUnityObjectBase asset in gameData.GameBundle.FetchAssets())
		{
			switch (asset)
			{
				case IFont font:
					{
						font.MainAsset = font;
						if (font.TryGetFontMaterial(out IMaterial? fontMaterial))
						{
							fontMaterial.MainAsset = font;
						}
						if (font.TryGetFontTexture(out ITexture? fontTexture))
						{
							fontTexture.MainAsset = font;
						}
					}
					break;
				case ITerrainData terrainData:
					{
						terrainData.MainAsset = terrainData;
						foreach (ITexture2D alphaTexture in terrainData.GetSplatAlphaTextures())
						{
							//Sometimes TerrainData can be duplicated, but retain the same alpha textures.
							//https://github.com/AssetRipper/AssetRipper/issues/1356
							alphaTexture.MainAsset ??= terrainData;
						}
					}
					break;
			}
		}
	}
}

```

`Source/AssetRipper.Processing/Notes.md`:

```md
# Visual Effects

`VisualEffectAsset`s are not fully recoverable. The `VisualEffectAsset` itself is recoverable, but that is not very useful because its original structure is lost. Normal `vfx` files are structured like this:

* `MonoBehaviour` uv info - the `MonoBehaviour` that specifies various properties like the UI bounds.
  * It is referenced from the graph.
* `MonoBehaviour` graph - the graph of nodes that make up the visual effect.
  * It is referenced from the resource.
* `VisualEffectResource` - the asset that contains the name and render settings.
  * It has a "random" fileID. In the single example I've seen, it was `8926484042661614527`.

There is no `VisualEffectAsset` encoded because it is silently generated by the `VisualEffectImporter`. In the single example I've seen, its fileID was `8926484042661614526`, 1 less than the `VisualEffectResource`.

All the MonoBehaviours have a standard fileID, ie 114 followed by 15 random digits.

Without the `VisualEffectResource`, errors are thrown when adding a visual effect to a scene.

```text
NullReferenceException: VFX resource does not exist for this asset at path:
```

```

`Source/AssetRipper.Processing/Prefabs/GameObjectHierarchyObject.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_2;

namespace AssetRipper.Processing.Prefabs;

public abstract class GameObjectHierarchyObject : AssetGroup
{
	public List<IGameObject> GameObjects { get; } = [];
	public List<IComponent> Components { get; } = [];
	public List<IPrefabInstance> PrefabInstances { get; } = [];
	/// <summary>
	/// <see cref="Assets"/> that should be marked as stripped.
	/// </summary>
	public HashSet<IUnityObjectBase> StrippedAssets { get; } = new();
	/// <summary>
	/// <see cref="Assets"/> that should not be part of YAML export.
	/// </summary>
	public HashSet<IUnityObjectBase> HiddenAssets { get; } = new();

	public override IEnumerable<IUnityObjectBase> Assets
	{
		get
		{
			return ((IEnumerable<IUnityObjectBase>)GameObjects)
				.Concat(Components)
				.Concat(PrefabInstances);
		}
	}

	public IEnumerable<IUnityObjectBase> ExportableAssets
	{
		get
		{
			return Assets.Where(asset => !HiddenAssets.Contains(asset));
		}
	}

	protected GameObjectHierarchyObject(AssetInfo assetInfo) : base(assetInfo)
	{
	}

	public override IEnumerable<(string, PPtr)> FetchDependencies()
	{
		foreach (IUnityObjectBase asset in GameObjects)
		{
			yield return ($"{nameof(GameObjects)}[]", AssetToPPtr(asset));
		}
		foreach (IUnityObjectBase asset in Components)
		{
			yield return ($"{nameof(Components)}[]", AssetToPPtr(asset));
		}
		foreach (IUnityObjectBase asset in PrefabInstances)
		{
			yield return ($"{nameof(PrefabInstances)}[]", AssetToPPtr(asset));
		}
	}

	public sealed override void WalkStandard(AssetWalker walker)
	{
		if (walker.EnterAsset(this))
		{
			WalkFields(walker);
			walker.ExitAsset(this);
		}
	}

	protected virtual void WalkFields(AssetWalker walker)
	{
		this.WalkPPtrListField(walker, GameObjects);

		walker.DivideAsset(this);

		this.WalkPPtrListField(walker, Components);

		walker.DivideAsset(this);

		this.WalkPPtrListField(walker, PrefabInstances);
	}
}

```

`Source/AssetRipper.Processing/Prefabs/PrefabHierarchyObject.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_18;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.MarkerInterfaces;

namespace AssetRipper.Processing.Prefabs;

public sealed class PrefabHierarchyObject : GameObjectHierarchyObject, INamed
{
	/// <summary>
	/// The root <see cref="IGameObject"/> of the <see cref="Prefab"/>.
	/// </summary>
	/// <remarks>
	/// This is included in <see cref="GameObjectHierarchyObject.GameObjects"/> because the root GameObject is a part of the hierarchy.
	/// </remarks>
	public IGameObject Root { get; }

	/// <summary>
	/// The <see cref="IPrefabInstance"/> of the <see cref="Root"/>.
	/// </summary>
	/// <remarks>
	/// This is not included in <see cref="GameObjectHierarchyObject.PrefabInstances"/> because it is the source prefab asset, rather than a prefab instance.
	/// </remarks>
	public IPrefabInstance Prefab { get; }

	public override IEnumerable<IUnityObjectBase> Assets => base.Assets.Append(Prefab);

	public Utf8String Name { get => Root.Name; set => throw new NotSupportedException(); }

	public PrefabHierarchyObject(AssetInfo assetInfo, IGameObject root, IPrefabInstance prefab) : base(assetInfo)
	{
		Root = root;
		Prefab = prefab;

		if (Prefab is IPrefabInstanceMarker)
		{
			HiddenAssets.Add(Prefab);
		}
	}

	public override IEnumerable<(string, PPtr)> FetchDependencies()
	{
		return base.FetchDependencies().Append((nameof(Prefab), AssetToPPtr(Prefab)));
	}

	protected override void WalkFields(AssetWalker walker)
	{
		this.WalkPrimitiveField(walker, Name);

		walker.DivideAsset(this);

		base.WalkFields(walker);

		walker.DivideAsset(this);

		this.WalkPPtrField(walker, Root);

		walker.DivideAsset(this);

		this.WalkPPtrField(walker, Prefab);
	}

	public static PrefabHierarchyObject Create(ProcessedAssetCollection collection, IGameObject root, IPrefabInstance prefab)
	{
		PrefabHierarchyObject prefabHierarchy = collection.CreateAsset((int)ClassIDType.PrefabInstance, (assetInfo) => new PrefabHierarchyObject(assetInfo, root, prefab));

		foreach (IEditorExtension asset in root.FetchHierarchy())
		{
			switch (asset)
			{
				case IGameObject gameObject:
					prefabHierarchy.GameObjects.Add(gameObject);
					break;
				case IComponent component:
					prefabHierarchy.Components.Add(component);
					break;
			}
		}

		prefabHierarchy.SetMainAsset();

		return prefabHierarchy;
	}
}

```

`Source/AssetRipper.Processing/Prefabs/PrefabProcessor.cs`:

```cs
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.Logging;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_142;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Extensions;
using System.Diagnostics;

namespace AssetRipper.Processing.Prefabs;

public sealed class PrefabProcessor : IAssetProcessor
{
	public void Process(GameData gameData)
	{
		ProcessedBundle processedBundle = gameData.GameBundle.AddNewProcessedBundle("Generated Hierarchy Assets");
		ProcessedAssetCollection prefabHierarchyCollection = processedBundle.AddNewProcessedCollection("Prefab Hierarchies", gameData.ProjectVersion);
		ProcessedAssetCollection prefabInstanceCollection = processedBundle.AddNewProcessedCollection("Generated Prefabs", gameData.ProjectVersion);
		Dictionary<SceneDefinition, ProcessedAssetCollection> sceneCollectionDictionary = new();

		AddMissingTransforms(gameData, processedBundle, sceneCollectionDictionary);

		HashSet<IGameObject> gameObjectsAlreadyProcessed = new();

		//Create scene hierarchies
		foreach (SceneDefinition scene in gameData.GameBundle.Scenes.ToList())
		{
			ProcessedAssetCollection sceneCollection = GetOrCreateSceneCollection(gameData, processedBundle, sceneCollectionDictionary, scene);
			SceneHierarchyObject sceneHierarchy = SceneHierarchyObject.Create(sceneCollection, scene);
			gameObjectsAlreadyProcessed.AddRange(sceneHierarchy.GameObjects);

			Bundle? bundle = scene.Collections.Select(c => c.Bundle).FirstOrDefault(b => b is SerializedBundle);
			if (bundle is not null)
			{
				IAssetBundle? assetBundleAsset = bundle.FetchAssets().OfType<IAssetBundle>().FirstOrDefault();
				if (assetBundleAsset is not null)
				{
					Debug.Assert(!assetBundleAsset.Has_IsStreamedSceneAssetBundle() || assetBundleAsset.IsStreamedSceneAssetBundle);
					sceneHierarchy.AssetBundleName = assetBundleAsset.GetAssetBundleName();
				}
				else
				{
					sceneHierarchy.AssetBundleName = bundle.Name;
				}
			}
		}

		//Create hierarchies for prefabs with an existing PrefabInstance
		foreach (IPrefabInstance prefab in gameData.GameBundle.FetchAssets().OfType<IPrefabInstance>())
		{
			if (prefab.RootGameObjectP is { } root && !gameObjectsAlreadyProcessed.Contains(root))
			{
				prefab.SetPrefabInternal();

				PrefabHierarchyObject prefabHierarchy = PrefabHierarchyObject.Create(prefabHierarchyCollection, root, prefab);
				gameObjectsAlreadyProcessed.AddRange(prefabHierarchy.GameObjects);
			}
		}

		//Create hierarchies for prefabs without an existing PrefabInstance
		foreach (IGameObject asset in gameData.GameBundle.FetchAssets().OfType<IGameObject>())
		{
			if (gameObjectsAlreadyProcessed.Contains(asset))
			{
				continue;
			}

			IGameObject root = asset.GetRoot();
			if (gameObjectsAlreadyProcessed.Add(root))
			{
				IPrefabInstance prefab = root.CreatePrefabForRoot(prefabInstanceCollection);

				PrefabHierarchyObject prefabHierarchy = PrefabHierarchyObject.Create(prefabHierarchyCollection, root, prefab);
				gameObjectsAlreadyProcessed.AddRange(prefabHierarchy.GameObjects);
			}
		}
	}

	private static void AddMissingTransforms(GameData gameData, ProcessedBundle processedBundle, Dictionary<SceneDefinition, ProcessedAssetCollection> sceneCollectionDictionary)
	{
		ProcessedAssetCollection missingPrefabTransformCollection = processedBundle.AddNewProcessedCollection("Missing Prefab Transforms", gameData.ProjectVersion);
		foreach (IGameObject gameObject in gameData.GameBundle.FetchAssets().OfType<IGameObject>().Where(HasNoTransform))
		{
			Logger.Warning(LogCategory.Processing, $"GameObject {gameObject.Name} has no Transform. Adding one.");

			ProcessedAssetCollection collection;
			if (gameObject.Collection.IsScene)
			{
				SceneDefinition scene = gameObject.Collection.Scene;
				collection = GetOrCreateSceneCollection(gameData, processedBundle, sceneCollectionDictionary, scene);
			}
			else
			{
				collection = missingPrefabTransformCollection;
			}

			ITransform transform = collection.CreateTransform();

			transform.InitializeDefault();

			transform.GameObject_C4P = gameObject;
			gameObject.AddComponent(ClassIDType.Transform, transform);
		}
	}

	private static ProcessedAssetCollection GetOrCreateSceneCollection(GameData gameData, ProcessedBundle processedBundle, Dictionary<SceneDefinition, ProcessedAssetCollection> sceneCollectionDictionary, SceneDefinition scene)
	{
		ProcessedAssetCollection collection;
		if (sceneCollectionDictionary.TryGetValue(scene, out ProcessedAssetCollection? sceneCollection))
		{
			collection = sceneCollection;
		}
		else
		{
			collection = processedBundle.AddNewProcessedCollection(scene.Name + " (Generated Assets)", gameData.ProjectVersion);
			scene.AddCollection(collection);
			sceneCollectionDictionary.Add(scene, collection);
		}

		return collection;
	}

	private static bool HasNoTransform(IGameObject gameObject)
	{
		return !gameObject.TryGetComponent<ITransform>(out _);
	}
}

```

`Source/AssetRipper.Processing/Prefabs/SceneHierarchyObject.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_1660057539;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_3;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Processing.Prefabs;

public sealed class SceneHierarchyObject : GameObjectHierarchyObject, INamed
{
	private Utf8String? _name;
	public SceneDefinition Scene { get; }
	public List<ILevelGameManager> Managers { get; } = [];
	public ISceneRoots? SceneRoots { get; set; }

	public override IEnumerable<IUnityObjectBase> Assets => base.Assets.Concat(Managers).MaybeAppend(SceneRoots);

	public Utf8String Name
	{
		get
		{
			if (_name?.String != Scene.Name)
			{
				_name = Scene.Name;
			}
			return _name;
		}
		set => throw new NotSupportedException();
	}

	public SceneHierarchyObject(AssetInfo assetInfo, SceneDefinition scene) : base(assetInfo)
	{
		Scene = scene;
	}

	public override IEnumerable<(string, PPtr)> FetchDependencies()
	{
		foreach ((string, PPtr) pair in base.FetchDependencies())
		{
			yield return pair;
		}
		foreach (IUnityObjectBase asset in Managers)
		{
			yield return ($"{nameof(Managers)}[]", AssetToPPtr(asset));
		}
		yield return (nameof(SceneRoots), AssetToPPtr(SceneRoots));
	}

	protected override void WalkFields(AssetWalker walker)
	{
		this.WalkPrimitiveField(walker, Name);

		walker.DivideAsset(this);

		base.WalkFields(walker);

		walker.DivideAsset(this);

		this.WalkPPtrListField(walker, Managers);

		walker.DivideAsset(this);

		this.WalkPPtrField(walker, SceneRoots);
	}

	public IEnumerable<IGameObject> GetRoots()
	{
		return GameObjects.Where(GameObjectExtensions.IsRoot);
	}

	public static SceneHierarchyObject Create(ProcessedAssetCollection collection, SceneDefinition scene)
	{
		SceneHierarchyObject sceneHierarchy = collection.CreateAsset((int)ClassIDType.SceneAsset, (assetInfo) => new SceneHierarchyObject(assetInfo, scene));

		foreach (IUnityObjectBase asset in scene.Assets)
		{
			switch (asset)
			{
				case IGameObject gameObject:
					sceneHierarchy.GameObjects.Add(gameObject);
					break;
				case IMonoBehaviour monoBehaviour:
					if (monoBehaviour.IsComponentOnGameObject())
					{
						sceneHierarchy.Components.Add(monoBehaviour);
					}
					break;
				case IComponent component:
					sceneHierarchy.Components.Add(component);
					break;
				case ILevelGameManager manager:
					sceneHierarchy.Managers.Add(manager);
					break;
				case IPrefabInstance prefabInstance:
					sceneHierarchy.PrefabInstances.Add(prefabInstance);
					break;
				case ISceneRoots sceneRoots:
					sceneHierarchy.SceneRoots = sceneRoots;
					break;
			}
		}

		sceneHierarchy.SetMainAsset();

		return sceneHierarchy;
	}
}

```

`Source/AssetRipper.Processing/Scenes/SceneDefinitionProcessor.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Generics;
using AssetRipper.Import.Logging;
using AssetRipper.IO.Files;
using AssetRipper.Processing.Editor;
using AssetRipper.SourceGenerated.Classes.ClassID_1045;
using AssetRipper.SourceGenerated.Classes.ClassID_141;
using AssetRipper.SourceGenerated.Classes.ClassID_142;
using AssetRipper.SourceGenerated.Classes.ClassID_29;
using AssetRipper.SourceGenerated.Classes.ClassID_3;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.AssetInfo;
using AssetRipper.SourceGenerated.Subclasses.Scene;
using System.Diagnostics;

namespace AssetRipper.Processing.Scenes;

public sealed class SceneDefinitionProcessor : IAssetProcessor
{
	public void Process(GameData gameData)
	{
		Logger.Info(LogCategory.Processing, "Creating Scene Definitions");
		IBuildSettings? buildSettings = null;
		HashSet<AssetCollection> sceneCollections = new();
		Dictionary<AssetCollection, string> scenePaths = new();
		Dictionary<AssetCollection, UnityGuid> sceneGuids = new();
		List<IAssetBundle> sceneAssetBundles = new();

		//Find the relevant assets in this single pass over all the assets.
		foreach (AssetCollection collection in gameData.GameBundle.FetchAssetCollections())
		{
			foreach (IUnityObjectBase asset in collection)
			{
				if (asset is ILevelGameManager)
				{
					sceneCollections.Add(collection);
					if (asset is IOcclusionCullingSettings sceneSettings && sceneSettings.Has_SceneGUID())
					{
						sceneGuids[collection] = sceneSettings.SceneGUID;
					}
				}
				else if (asset is IBuildSettings buildSettings1)
				{
					buildSettings = buildSettings1;
				}
				else if (asset is IAssetBundle assetBundle && assetBundle.IsStreamedSceneAssetBundle)
				{
					sceneAssetBundles.Add(assetBundle);
				}
			}
		}

		//Currently, these paths are treated as lower precedent than paths defined in asset bundles, but they should never conflict.
		foreach (AssetCollection sceneCollection in sceneCollections)
		{
			if (SceneHelpers.TryGetScenePath(sceneCollection, buildSettings, out string? scenePath))
			{
				scenePaths[sceneCollection] = scenePath;
			}
		}

		//Extract scene paths from asset bundles.
		foreach (IAssetBundle assetBundleAsset in sceneAssetBundles)
		{
			Bundle bundle = assetBundleAsset.Collection.Bundle;
			if (bundle is not SerializedBundle)
			{
				Logger.Log(LogType.Warning, LogCategory.Processing, $"Scene name recovery is not supported for bundles of type {bundle.GetType().Name}");
			}
			else if (assetBundleAsset.Has_SceneHashes() && assetBundleAsset.SceneHashes.Count > 0)
			{
				foreach ((Utf8String scenePath, Utf8String collectionName) in assetBundleAsset.SceneHashes)
				{
					string path = Path.ChangeExtension(scenePath, null);
					path = OriginalPathHelper.EnsurePathNotRooted(path);
					path = OriginalPathHelper.EnsureStartsWithAssets(path);

					string name = SpecialFileNames.FixFileIdentifier(collectionName);

					AssetCollection sceneCollection = bundle.Collections.First(collection => collection.Name == name);
					sceneCollections.Add(sceneCollection);//Just to be safe
					scenePaths[sceneCollection] = path;
				}
			}
			else
			{
				int startingIndex = 0;
				foreach (AccessPairBase<Utf8String, IAssetInfo> pair in assetBundleAsset.Container)
				{
					Debug.Assert(pair.Value.Asset.IsNull(), "Scene pointer is not null");

					string path = Path.ChangeExtension(pair.Key.String, null);
					path = OriginalPathHelper.EnsurePathNotRooted(path);
					path = OriginalPathHelper.EnsureStartsWithAssets(path);
					int index = IndexOf(bundle.Collections, sceneCollections, startingIndex);
					if (index < 0)
					{
						throw new Exception($"Scene collection not found in {bundle.Name} at or after index {startingIndex}");
					}

					AssetCollection sceneCollection = bundle.Collections[index];
					sceneCollections.Add(sceneCollection);//Just to be safe
					scenePaths[sceneCollection] = path;
					startingIndex = index + 1;
				}
			}
		}

		//Make the scene definitions
		List<SceneDefinition> sceneDefinitions = new();
		foreach (AssetCollection sceneCollection in sceneCollections)
		{
			SceneDefinition sceneDefinition;
			UnityGuid guid = sceneGuids.TryGetValue(sceneCollection, out UnityGuid sceneGuid) ? sceneGuid : default;
			if (scenePaths.TryGetValue(sceneCollection, out string? path))
			{
				sceneDefinition = SceneDefinition.FromPath(path, guid);
			}
			else
			{
				sceneDefinition = SceneDefinition.FromName(sceneCollection.Name, guid);
			}
			sceneDefinition.AddCollection(sceneCollection);
			sceneDefinitions.Add(sceneDefinition);
		}

		//Generate settings for the project
		{
			ProcessedAssetCollection processedCollection = gameData.AddNewProcessedCollection("Generated Settings");

			if (buildSettings is not null)
			{
				IEditorBuildSettings editorBuildSettings = processedCollection.CreateEditorBuildSettings();
				{
					int numScenes = buildSettings.Scenes.Count;
					editorBuildSettings.Scenes.Capacity = numScenes;
					for (int i = 0; i < numScenes; i++)
					{
						IScene scene = editorBuildSettings.Scenes.AddNew();
						scene.Enabled = true;
						scene.Path = buildSettings.Scenes[i];
						//Guid gets handled later.
					}
				}
			}

			//EditorSettings
			//Is this the best place to create this? It doesn't have anything to do with scenes.
			processedCollection.CreateEditorSettings()
				.SetToDefaults();
		}
	}

	private static int IndexOf(IReadOnlyList<AssetCollection> list, HashSet<AssetCollection> containingSet, int startingIndex)
	{
		for (int i = startingIndex; i < list.Count; i++)
		{
			if (containingSet.Contains(list[i]))
			{
				return i;
			}
		}
		return -1;
	}
}

```

`Source/AssetRipper.Processing/Scenes/SceneHelpers.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_141;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_3;
using AssetRipper.SourceGenerated.Extensions;
using System.Text.RegularExpressions;

namespace AssetRipper.Processing.Scenes;

public static partial class SceneHelpers
{
	private const string AssetsName = "Assets/";
	private const string LibaryPackageCacheName = "Library/PackageCache/";
	private const string LevelName = "level";
	private const string MainSceneName = "maindata";

	public static bool TryGetFileNameToSceneIndex(string name, UnityVersion version, out int index)
	{
		if (HasMainData(version))
		{
			if (name == MainSceneName)
			{
				index = 0;
				return true;
			}

			if (SceneNameFormat.IsMatch(name))
			{
				index = int.Parse(name.AsSpan(LevelName.Length)) + 1;
				return true;
			}
		}
		else
		{
			if (SceneNameFormat.IsMatch(name))
			{
				index = int.Parse(name.AsSpan(LevelName.Length));
				return true;
			}
		}

		index = -1;
		return false;
	}

	/// <summary>
	/// Less than 5.3.0
	/// </summary>
	public static bool HasMainData(UnityVersion version) => version.LessThan(5, 3);

	/// <summary>
	/// GameObjects, Classes inheriting from LevelGameManager, MonoBehaviours with GameObjects, Components, and PrefabInstances
	/// </summary>
	public static bool IsSceneCompatible(IUnityObjectBase asset)
	{
		return asset switch
		{
			IGameObject => true,
			ILevelGameManager => true,
			IMonoBehaviour monoBeh => monoBeh.IsComponentOnGameObject(),
			IComponent => true,
			IPrefabInstance => true,
			_ => false,
		};
	}

	public static string SceneIndexToFileName(int index, UnityVersion version)
	{
		if (HasMainData(version))
		{
			if (index == 0)
			{
				return MainSceneName;
			}
			return $"{LevelName}{index - 1}";
		}
		return $"{LevelName}{index}";
	}

	public static bool TryGetScenePath(AssetCollection collection, [NotNullWhen(true)] IBuildSettings? buildSettings, [NotNullWhen(true)] out string? result)
	{
		if (buildSettings is not null && TryGetFileNameToSceneIndex(collection.Name, collection.OriginalVersion, out int index))
		{
			if (index >= buildSettings.Scenes.Count)
			{
				//This can happen in the following situation:
				//1. A game is built with N scenes and published to a distribution platform.
				//2. One of the scenes is removed from the project, for whatever reason.
				//3. The game is built again, with the new scene list.
				//4. When updating the game, the developer forgets to delete the Nth scene file.
				//5. Now, there are N-1 scenes in the BuildSettings, but N scene files for AssetRipper to find.
				result = null;
				return false;
			}
			string scenePath = buildSettings.Scenes[index].String;
			string extension = Path.GetExtension(scenePath);
			if (scenePath.StartsWith(AssetsName, StringComparison.Ordinal))
			{
				result = scenePath[..^extension.Length];
				return true;
			}
			else if (scenePath.StartsWith(LibaryPackageCacheName, StringComparison.Ordinal))
			{
				result = scenePath[..^extension.Length];
				return true;
			}
			else if (Path.IsPathRooted(scenePath))
			{
				// pull/uTiny 617
				// NOTE: absolute project path may contain Assets/ in its name so in this case we get incorrect scene path, but there is no way to bypass this issue
				int startIndex = scenePath.IndexOf(AssetsName);
				if (startIndex < 0)
				{
					startIndex = scenePath.IndexOf(LibaryPackageCacheName);
				}
				if (startIndex < 0)
				{
					result = null;
					return false;
				}
				result = scenePath[startIndex..^extension.Length];
				return true;
			}
			else if (scenePath.Length == 0)
			{
				// If a game is built without included scenes, Unity creates one with empty name.
				result = null;
				return false;
			}
			else
			{
				result = Path.Join("Assets", "Scenes", scenePath);
				return true;
			}
		}
		result = null;
		return false;
	}

	public static bool IsSceneDuplicate(int sceneIndex, IBuildSettings? buildSettings)
	{
		if (buildSettings == null)
		{
			return false;
		}

		string sceneName = buildSettings.Scenes[sceneIndex].String;
		for (int i = 0; i < buildSettings.Scenes.Count; i++)
		{
			if (buildSettings.Scenes[i] == sceneName)
			{
				if (i != sceneIndex)
				{
					return true;
				}
			}
		}
		return false;
	}

	[GeneratedRegex("^level(0|([1-9][0-9]*))$")]
	private static partial Regex SceneNameFormat { get; }
}

```

`Source/AssetRipper.Processing/ScriptableObject/ScriptableObjectGroup.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.SourceGenerated.Classes.ClassID_114;

namespace AssetRipper.Processing.ScriptableObject;

public sealed class ScriptableObjectGroup : AssetGroup, INamed
{
	public ScriptableObjectGroup(AssetInfo assetInfo, IMonoBehaviour root) : base(assetInfo)
	{
		Root = root;
	}

	public IMonoBehaviour Root { get; }
	public List<IMonoBehaviour> Children { get; } = [];

	public override IEnumerable<IMonoBehaviour> Assets => Children.Prepend(Root);

	public Utf8String Name { get => Root.Name; set => throw new NotSupportedException(); }

	public string? FileExtension { get; set; }

	public override IEnumerable<(string, PPtr)> FetchDependencies()
	{
		yield return (nameof(Root), AssetToPPtr(Root));
		foreach (IMonoBehaviour child in Children)
		{
			yield return ($"{nameof(Children)}[]", AssetToPPtr(child));
		}
	}

	public override void WalkStandard(AssetWalker walker)
	{
		if (walker.EnterAsset(this))
		{
			this.WalkPrimitiveField(walker, Name);
			walker.DivideAsset(this);
			this.WalkPrimitiveField(walker, FileExtension ?? "", nameof(FileExtension));
			walker.DivideAsset(this);
			this.WalkPPtrField(walker, Root);
			walker.DivideAsset(this);
			this.WalkPPtrListField(walker, Children);
			walker.ExitAsset(this);
		}
	}
}

```

`Source/AssetRipper.Processing/ScriptableObject/ScriptableObjectProcessor.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Serializable;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Processing.ScriptableObject;

public class ScriptableObjectProcessor : IAssetProcessor
{
	public void Process(GameData gameData)
	{
		Logger.Info(LogCategory.Processing, "Processing Scriptable Object Groups");
		ProcessedAssetCollection collection = gameData.AddNewProcessedCollection("Generated Scriptable Object Groups");

		// Assets that can be a child of a group
		HashSet<IMonoBehaviour> uniqueAssets = new();

		// Assets that cannot be a child of a group
		HashSet<IMonoBehaviour> nonuniqueAssets = new();

		List<IMonoBehaviour> timelineAssets = new();
		List<IMonoBehaviour> postProcessProfiles = new();

		foreach (IMonoBehaviour monoBehaviour in gameData.GameBundle.FetchAssets().OfType<IMonoBehaviour>())
		{
			if (monoBehaviour.MainAsset is not null)
			{
			}
			else if (monoBehaviour.IsTimelineAsset())
			{
				nonuniqueAssets.Add(monoBehaviour);
				timelineAssets.Add(monoBehaviour);
			}
			else if (monoBehaviour.IsPostProcessProfile())
			{
				nonuniqueAssets.Add(monoBehaviour);
				postProcessProfiles.Add(monoBehaviour);
			}
		}

		foreach (IMonoBehaviour timelineAsset in timelineAssets)
		{
			foreach (IMonoBehaviour child in FindTimelineAssetChildren(timelineAsset))
			{
				AddChild(uniqueAssets, nonuniqueAssets, child);
			}
		}
		foreach (IMonoBehaviour postProcessProfile in postProcessProfiles)
		{
			foreach (IMonoBehaviour child in FindPostProcessProfileChildren(postProcessProfile))
			{
				AddChild(uniqueAssets, nonuniqueAssets, child);
			}
		}

		nonuniqueAssets.Clear();

		foreach (IMonoBehaviour timelineAsset in timelineAssets)
		{
			ScriptableObjectGroup group = CreateGroup(collection, timelineAsset);
			group.FileExtension = "playable";
			group.Children.AddRange(FindTimelineAssetChildren(timelineAsset).Where(uniqueAssets.Contains));
			group.SetMainAsset();
		}
		foreach (IMonoBehaviour postProcessProfile in postProcessProfiles)
		{
			ScriptableObjectGroup group = CreateGroup(collection, postProcessProfile);
			group.Children.AddRange(FindPostProcessProfileChildren(postProcessProfile).Where(uniqueAssets.Contains));
			group.SetMainAsset();
		}
	}

	private static void AddChild(HashSet<IMonoBehaviour> uniqueAssets, HashSet<IMonoBehaviour> nonuniqueAssets, IMonoBehaviour child)
	{
		if (child.MainAsset is not null)
		{
		}
		else if (nonuniqueAssets.Contains(child))
		{
		}
		else if (uniqueAssets.Add(child))
		{
		}
		else
		{
			uniqueAssets.Remove(child);
			nonuniqueAssets.Add(child);
		}
	}

	private static ScriptableObjectGroup CreateGroup(ProcessedAssetCollection collection, IMonoBehaviour root)
	{
		return collection.CreateAsset(-1, root, static (assetInfo, root) => new ScriptableObjectGroup(assetInfo, root));
	}

	private static IEnumerable<IMonoBehaviour> FindTimelineAssetChildren(IMonoBehaviour root)
	{
		SerializableStructure? structure = root.LoadStructure();
		if (structure is null)
		{
			return [];
		}

		HashSet<IMonoBehaviour> children = [];
		if (structure.TryGetField("m_Tracks", out SerializableValue tracks))
		{
			foreach (IPPtr pptr in tracks.AsAssetArray.Cast<IPPtr>())
			{
				if (!root.Collection.TryGetAsset(pptr.FileID, pptr.PathID, out IMonoBehaviour? child))
				{
					continue;
				}

				SerializableStructure? childStructure = child.LoadStructure();
				if (childStructure is null)
				{
					continue;
				}

				if (!childStructure.TryGetField("m_Parent", out SerializableValue parent))
				{
					continue;
				}

				if (root.Collection.TryGetAsset(parent.AsPPtr.FileID, parent.AsPPtr.PathID) != root)
				{
					continue;
				}

				children.Add(child);

				if (childStructure.TryGetField("m_Clips", out SerializableValue clips))
				{
					foreach (SerializableStructure clip in clips.AsAssetArray.Cast<SerializableStructure>())
					{
						if (clip.TryGetField("m_Asset", out SerializableValue asset) && root.Collection.TryGetAsset(asset.AsPPtr.FileID, asset.AsPPtr.PathID, out IMonoBehaviour? clipAsset))
						{
							children.Add(clipAsset);
						}
					}
				}

				if (childStructure.TryGetField("m_Markers", out SerializableValue markers) && markers.AsStructure.TryGetField("m_Objects", out SerializableValue objects))
				{
					foreach (IPPtr markerPtr in objects.AsAssetArray.Cast<IPPtr>())
					{
						if (root.Collection.TryGetAsset(markerPtr.FileID, markerPtr.PathID, out IMonoBehaviour? marker))
						{
							children.Add(marker);
						}
					}
				}
			}
		}
		if (structure.TryGetField("m_MarkerTrack", out SerializableValue markerTrack))
		{
			if (root.Collection.TryGetAsset(markerTrack.AsPPtr.FileID, markerTrack.AsPPtr.PathID, out IMonoBehaviour? child))
			{
				children.Add(child);
			}
		}

		return children;
	}

	private static IEnumerable<IMonoBehaviour> FindPostProcessProfileChildren(IMonoBehaviour root)
	{
		SerializableStructure? structure = root.LoadStructure();
		if (structure is null)
		{
			return [];
		}

		HashSet<IMonoBehaviour> children = [];
		if (structure.TryGetField("settings", out SerializableValue settings))
		{
			foreach (IPPtr pptr in settings.AsAssetArray.Cast<IPPtr>())
			{
				if (!root.Collection.TryGetAsset(pptr.FileID, pptr.PathID, out IMonoBehaviour? child))
				{
					continue;
				}

				children.Add(child);
			}
		}

		return children;
	}
}

```

`Source/AssetRipper.Processing/Textures/SpriteInformationObject.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;
using System.Diagnostics;

namespace AssetRipper.Processing.Textures;

public sealed class SpriteInformationObject : AssetGroup, INamed
{
	public SpriteInformationObject(AssetInfo assetInfo, ITexture2D texture) : base(assetInfo)
	{
		Texture = texture;
	}

	public ITexture2D Texture { get; }
	public IReadOnlyDictionary<ISprite, ISpriteAtlas?> Sprites => dictionary;
	private readonly Dictionary<ISprite, ISpriteAtlas?> dictionary = new();

	Utf8String INamed.Name
	{
		get => Texture.Name;
		set { }
	}

	public override IEnumerable<IUnityObjectBase> Assets
	{
		get
		{
			yield return Texture;
			foreach ((ISprite sprite, ISpriteAtlas? atlas) in dictionary)
			{
				yield return sprite;
				if (atlas is not null)
				{
					yield return atlas;
				}
			}
		}
	}

	public override void WalkStandard(AssetWalker walker)
	{
		if (walker.EnterAsset(this))
		{
			this.WalkPPtrField(walker, Texture);
			walker.DivideAsset(this);
			this.WalkDictionaryPPtrField(walker, Sprites);
			walker.ExitAsset(this);
		}
	}

	public override IEnumerable<(string, PPtr)> FetchDependencies()
	{
		yield return (nameof(Texture), AssetToPPtr(Texture));
		foreach ((ISprite sprite, ISpriteAtlas? atlas) in dictionary)
		{
			yield return (nameof(Sprites) + "[].Key", AssetToPPtr(sprite));
			if (atlas is not null)
			{
				yield return (nameof(Sprites) + "[].Value", AssetToPPtr(atlas));
			}
		}
	}

	internal void AddToDictionary(ISprite sprite, ISpriteAtlas? atlas)
	{
		if (dictionary.TryGetValue(sprite, out ISpriteAtlas? mappedAtlas))
		{
			if (mappedAtlas is null)
			{
				dictionary[sprite] = atlas;
			}
			else if (atlas is not null && atlas != mappedAtlas)
			{
				throw new Exception($"{nameof(atlas)} is not the same as {nameof(mappedAtlas)}");
			}
		}
		else
		{
			dictionary.Add(sprite, atlas);
		}
	}

	public override void SetMainAsset()
	{
		Debug.Assert(Texture.MainAsset is null);
		base.SetMainAsset();
	}
}

```

`Source/AssetRipper.Processing/Textures/SpriteProcessor.ObjectFactory.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.SourceGenerated.Classes.ClassID_28;

namespace AssetRipper.Processing.Textures;

public sealed partial class SpriteProcessor
{
	private readonly struct ObjectFactory
	{
		private readonly ProcessedAssetCollection processedCollection;
		private readonly Dictionary<ITexture2D, SpriteInformationObject> dictionary = new();

		public IEnumerable<SpriteInformationObject> Assets => dictionary.Values;

		public ObjectFactory(GameData gameData)
		{
			processedCollection = gameData.AddNewProcessedCollection("Sprite Data Storage");
		}

		public SpriteInformationObject GetOrCreate(ITexture2D texture)
		{
			if (!dictionary.TryGetValue(texture, out SpriteInformationObject? result))
			{
				result = MakeSpriteInformationObject(texture);
				dictionary.Add(texture, result);
			}
			return result;
		}

		SpriteInformationObject MakeSpriteInformationObject(ITexture2D texture)
		{
			return processedCollection.CreateAsset(-1, texture, static (assetInfo, texture) => new SpriteInformationObject(assetInfo, texture));
		}
	}
}

```

`Source/AssetRipper.Processing/Textures/SpriteProcessor.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Cloning;
using AssetRipper.IO.Files;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.SecondarySpriteTexture;
using AssetRipper.SourceGenerated.Subclasses.SpriteAtlasData;
using AssetRipper.SourceGenerated.Subclasses.SpriteRenderData;
using System.Drawing;
using System.Numerics;

namespace AssetRipper.Processing.Textures;

public sealed partial class SpriteProcessor : IAssetProcessor
{
	public void Process(GameData gameData)
	{
		ObjectFactory factory = new ObjectFactory(gameData);
		foreach (IUnityObjectBase asset in gameData.GameBundle
			.FetchAssetCollections()
			.Where(c => !SpecialFileNames.IsDefaultResourceOrBuiltinExtra(c.Name))
			.SelectMany(c => c))
		{
			if (asset is ITexture2D texture)
			{
				if (texture.MainAsset is null)
				{
					factory.GetOrCreate(texture);
				}
			}
			else if (asset is ISprite sprite)
			{
				ITexture2D? spriteTexture = sprite.TryGetTexture();
				if (spriteTexture is not null)
				{
					SpriteInformationObject spriteInformationObject = factory.GetOrCreate(spriteTexture);
					ISpriteAtlas? atlas = sprite.SpriteAtlasP;
					spriteInformationObject.AddToDictionary(sprite, atlas);
				}

				ProcessSprite(sprite);
			}
			else if (asset is ISpriteAtlas atlas && atlas.RenderDataMap.Count > 0)
			{
				foreach (ISprite packedSprite in atlas.PackedSpritesP.WhereNotNull())
				{
					if (TryGetPackedSpriteTexture(atlas, packedSprite, out ITexture2D? spriteTexture))
					{
						SpriteInformationObject spriteInformationObject = factory.GetOrCreate(spriteTexture);
						spriteInformationObject.AddToDictionary(packedSprite, atlas);
					}
				}
			}
		}
		foreach (SpriteInformationObject asset in factory.Assets)
		{
			asset.SetMainAsset();
		}
	}

	private static bool TryGetPackedSpriteTexture(ISpriteAtlas atlas, ISprite packedSprite, [NotNullWhen(true)] out ITexture2D? spriteTexture)
	{
		if (packedSprite.Has_RenderDataKey() && atlas.RenderDataMap.TryGetValue(packedSprite.RenderDataKey, out ISpriteAtlasData? atlasData))
		{
			spriteTexture = atlasData.Texture.TryGetAsset(atlas.Collection);
		}
		else
		{
			spriteTexture = null;
		}
		return spriteTexture is not null;
	}

	private static void ProcessSprite(ISprite sprite)
	{
		// SpriteAtlas is a new feature since Unity 2017.
		// For older versions of Unity, SpriteAtlas doesn't exist,
		// and the correct metadata of Sprite is stored in the m_RD field.
		// Otherwise, if a SpriteAtlas reference is serialized into this sprite,
		// we must recover the m_RD field of the sprite from the SpriteAtlas.
		ISpriteAtlas? atlas = sprite.SpriteAtlasP;
		if (atlas is not null)
		{
			if (sprite.Has_RenderDataKey() &&
				atlas.RenderDataMap.TryGetValue(sprite.RenderDataKey, out ISpriteAtlasData? spriteData))
			{
				PPtrConverter converter = new PPtrConverter(atlas, sprite);
				ISpriteRenderData m_RD = sprite.RD;
				m_RD.Texture.CopyValues(spriteData.Texture, converter);
				if (m_RD.Has_AlphaTexture())
				{
					m_RD.AlphaTexture.CopyValues(spriteData.AlphaTexture, converter);
				}
				m_RD.TextureRect.CopyValues(spriteData.TextureRect);
				if (m_RD.Has_AtlasRectOffset() && spriteData.Has_AtlasRectOffset())
				{
					m_RD.AtlasRectOffset.CopyValues(spriteData.AtlasRectOffset);
				}
				m_RD.SettingsRaw = spriteData.SettingsRaw;
				if (m_RD.Has_UvTransform())
				{
					m_RD.UvTransform.CopyValues(spriteData.UvTransform);
				}
				m_RD.DownscaleMultiplier = spriteData.DownscaleMultiplier;
				if (m_RD.Has_SecondaryTextures() && spriteData.Has_SecondaryTextures())
				{
					m_RD.SecondaryTextures.Clear();
					foreach (SecondarySpriteTexture spt in spriteData.SecondaryTextures)
					{
						m_RD.SecondaryTextures.AddNew().CopyValues(spt, converter);
					}
				}
			}

			// Must clear the reference to SpriteAtlas, since Unity Editor will crash trying to pack an already-packed sprite otherwise.
			sprite.SpriteAtlasP = null;
			sprite.AtlasTags?.Clear();
		}

		// Some sprite properties must be recalculated with regard to SpriteAtlas. See the comments inside the following method.
		sprite.GetSpriteCoordinatesInAtlas(atlas, out RectangleF rect, out Vector2 pivot, out Vector4 border);
		sprite.Rect.CopyValues(rect);
		sprite.Pivot?.CopyValues(pivot);
		sprite.Border?.CopyValues(border);

		// Calculate and overwrite Offset. It is the offset in pixels of the pivot to the center of Rect.
		sprite.Offset.X = (pivot.X - 0.5f) * rect.Width;
		sprite.Offset.Y = (pivot.Y - 0.5f) * rect.Height;

		// Calculate and overwrite TextureRectOffset. It is the offset in pixels of m_RD.TextureRect to Rect.
		sprite.RD.TextureRectOffset.X = sprite.RD.TextureRect.X - rect.X;
		sprite.RD.TextureRectOffset.Y = sprite.RD.TextureRect.Y - rect.Y;
	}
}

```

`Source/AssetRipper.Processing/TraversalHelperMethods.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using System.Runtime.CompilerServices;

namespace AssetRipper.Processing;

public static class TraversalHelperMethods
{
	private interface IWalkHandler<TValue>
	{
		static abstract void Walk(AssetWalker walker, TValue value);
	}

	private readonly struct DictionaryWalkHandler<TKey, TValue, TKeyHandler, TValueHandler> : IWalkHandler<IReadOnlyCollection<KeyValuePair<TKey, TValue>>>
		where TKey : notnull
		where TValue : notnull
		where TKeyHandler : IWalkHandler<TKey>
		where TValueHandler : IWalkHandler<TValue>
	{
		public static void Walk(AssetWalker walker, IReadOnlyCollection<KeyValuePair<TKey, TValue>> list)
		{
			if (walker.EnterDictionary(list))
			{
				int count = list.Count;
				if (count > 0)
				{
					int i = 0;
					foreach (KeyValuePair<TKey, TValue> pair in list)
					{
						if (walker.EnterDictionaryPair(pair))
						{
							TKeyHandler.Walk(walker, pair.Key);
							walker.DivideDictionaryPair(pair);
							TValueHandler.Walk(walker, pair.Value);
							walker.ExitDictionaryPair(pair);
						}
						i++;
						if (i >= count)
						{
							break;
						}
						walker.DivideDictionary(list);
					}
				}
				walker.ExitDictionary(list);
			}
		}
	}

	private readonly struct ListWalkHandler<TElement, TElementHandler> : IWalkHandler<IReadOnlyList<TElement>>
		where TElement : notnull
		where TElementHandler : IWalkHandler<TElement>
	{
		public static void Walk(AssetWalker walker, IReadOnlyList<TElement> list)
		{
			if (walker.EnterList(list))
			{
				int count = list.Count;
				if (count > 0)
				{
					int i = 0;
					while (true)
					{
						TElementHandler.Walk(walker, list[i]);
						i++;
						if (i >= count)
						{
							break;
						}
						walker.DivideList(list);
					}
				}
				walker.ExitList(list);
			}
		}
	}

	private readonly struct PrimitiveWalkHandler<TPrimitive> : IWalkHandler<TPrimitive>
		where TPrimitive : notnull
	{
		public static void Walk(AssetWalker walker, TPrimitive value)
		{
			walker.VisitPrimitive(value);
		}
	}

	private readonly struct IPPtrWalkHandler<TAsset> : IWalkHandler<IPPtr<TAsset>>
		where TAsset : IUnityObjectBase
	{
		public static void Walk(AssetWalker walker, IPPtr<TAsset> value)
		{
			walker.VisitPPtr(value);
		}
	}

	private readonly struct PPtrWalkHandler<TAsset> : IWalkHandler<PPtr<TAsset>>
		where TAsset : IUnityObjectBase
	{
		public static void Walk(AssetWalker walker, PPtr<TAsset> value)
		{
			walker.VisitPPtr(value);
		}
	}

	private readonly struct AssetStandardWalkHandler<TAsset> : IWalkHandler<TAsset>
		where TAsset : IUnityAssetBase
	{
		public static void Walk(AssetWalker walker, TAsset asset)
		{
			asset.WalkStandard(walker);
		}
	}

	public static void WalkPrimitiveField<TPrimitive>(this IUnityAssetBase @this, AssetWalker walker, TPrimitive value, [CallerArgumentExpression(nameof(value))] string name = "")
		where TPrimitive : notnull
	{
		if (walker.EnterField(@this, name))
		{
			walker.VisitPrimitive(value);
			walker.ExitField(@this, name);
		}
	}

	public static void WalkPrimitiveListField<TPrimitive>(this IUnityAssetBase @this, AssetWalker walker, AssetList<TPrimitive> list, [CallerArgumentExpression(nameof(list))] string name = "")
		where TPrimitive : notnull, new()
	{
		if (walker.EnterField(@this, name))
		{
			ListWalkHandler<TPrimitive, PrimitiveWalkHandler<TPrimitive>>.Walk(walker, list);
			walker.ExitField(@this, name);
		}
	}

	public static void WalkPPtrField<TAsset>(this IUnityAssetBase @this, AssetWalker walker, IPPtr<TAsset> value, [CallerArgumentExpression(nameof(value))] string name = "")
		where TAsset : IUnityObjectBase
	{
		if (walker.EnterField(@this, name))
		{
			walker.VisitPPtr(value);
			walker.ExitField(@this, name);
		}
	}

	public static void WalkPPtrField<TAsset>(this IUnityAssetBase @this, AssetWalker walker, PPtr<TAsset> value, [CallerArgumentExpression(nameof(value))] string name = "")
		where TAsset : IUnityObjectBase
	{
		if (walker.EnterField(@this, name))
		{
			walker.VisitPPtr(value);
			walker.ExitField(@this, name);
		}
	}

	public static void WalkPPtrField<TAsset>(this IUnityObjectBase @this, AssetWalker walker, TAsset? asset, [CallerArgumentExpression(nameof(asset))] string name = "")
		where TAsset : IUnityObjectBase
	{
		if (walker.EnterField(@this, name))
		{
			@this.VisitPPtr(walker, asset);
			walker.ExitField(@this, name);
		}
	}

	public static void VisitPPtr<TAsset>(this IUnityObjectBase @this, AssetWalker walker, TAsset? asset)
		where TAsset : IUnityObjectBase
	{
		walker.VisitPPtr(@this.Collection.ForceCreatePPtr(asset));
	}

	public static void WalkPPtrListField<TAsset>(this IUnityAssetBase @this, AssetWalker walker, IReadOnlyList<IPPtr<TAsset>> list, [CallerArgumentExpression(nameof(list))] string name = "")
		where TAsset : IUnityObjectBase
	{
		if (walker.EnterField(@this, name))
		{
			ListWalkHandler<IPPtr<TAsset>, IPPtrWalkHandler<TAsset>>.Walk(walker, list);
			walker.ExitField(@this, name);
		}
	}

	public static void WalkPPtrListField<TAsset>(this IUnityAssetBase @this, AssetWalker walker, IReadOnlyList<PPtr<TAsset>> list, [CallerArgumentExpression(nameof(list))] string name = "")
		where TAsset : IUnityObjectBase
	{
		if (walker.EnterField(@this, name))
		{
			ListWalkHandler<PPtr<TAsset>, PPtrWalkHandler<TAsset>>.Walk(walker, list);
			walker.ExitField(@this, name);
		}
	}

	public static void WalkPPtrListField<TAsset>(this IUnityObjectBase @this, AssetWalker walker, IReadOnlyList<TAsset> list, [CallerArgumentExpression(nameof(list))] string name = "")
		where TAsset : IUnityObjectBase
	{
		if (walker.EnterField(@this, name))
		{
			PPtr<TAsset>[] pptrs = new PPtr<TAsset>[list.Count];
			for (int i = 0; i < list.Count; i++)
			{
				pptrs[i] = @this.Collection.ForceCreatePPtr(list[i]);
			}
			ListWalkHandler<PPtr<TAsset>, PPtrWalkHandler<TAsset>>.Walk(walker, pptrs);
			walker.ExitField(@this, name);
		}
	}

	public static void WalkDictionaryPPtrField<TKey, TValue>(this IUnityAssetBase @this, AssetWalker walker, IReadOnlyCollection<KeyValuePair<PPtr<TKey>, PPtr<TValue>>> list, [CallerArgumentExpression(nameof(list))] string name = "")
		where TKey : IUnityObjectBase
		where TValue : IUnityObjectBase
	{
		if (walker.EnterField(@this, name))
		{
			DictionaryWalkHandler<PPtr<TKey>, PPtr<TValue>, PPtrWalkHandler<TKey>, PPtrWalkHandler<TValue>>.Walk(walker, list);
			walker.ExitField(@this, name);
		}
	}

#nullable disable
	public static void WalkDictionaryPPtrField<TKey, TValue>(this IUnityObjectBase @this, AssetWalker walker, IReadOnlyCollection<KeyValuePair<TKey, TValue>> list, [CallerArgumentExpression(nameof(list))] string name = "")
		where TKey : IUnityObjectBase
		where TValue : IUnityObjectBase
	{
		IReadOnlyCollection<KeyValuePair<PPtr<TKey>, PPtr<TValue>>> pairs = [..list.Select(pairs =>
		{
			return new KeyValuePair<PPtr<TKey>, PPtr<TValue>>(@this.Collection.ForceCreatePPtr(pairs.Key), @this.Collection.ForceCreatePPtr(pairs.Value));
		})];

		@this.WalkDictionaryPPtrField(walker, pairs, name);
	}
#nullable restore

	public static void WalkStandardAssetField<TAsset>(this IUnityAssetBase @this, AssetWalker walker, TAsset asset, [CallerArgumentExpression(nameof(asset))] string name = "")
		where TAsset : IUnityAssetBase
	{
		if (walker.EnterField(@this, name))
		{
			asset.WalkStandard(walker);
			walker.ExitField(@this, name);
		}
	}

	public static void WalkStandardAssetListField<TAsset>(this IUnityAssetBase @this, AssetWalker walker, AssetList<TAsset> list, [CallerArgumentExpression(nameof(list))] string name = "")
		where TAsset : IUnityAssetBase, new()
	{
		if (walker.EnterField(@this, name))
		{
			ListWalkHandler<TAsset, AssetStandardWalkHandler<TAsset>>.Walk(walker, list);
			walker.ExitField(@this, name);
		}
	}
}

```

`Source/AssetRipper.Processing/Usings.cs`:

```cs
global using AssetRipper.Primitives;

```

`Source/AssetRipper.SerializationLogic.Tests/AssetRipper.SerializationLogic.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<IsPackable>false</IsPackable>
		<IsAotCompatible>false</IsAotCompatible>
		<OutputPath>..\0Bins\Other\AssetRipper.SerializationLogic.Tests\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.SerializationLogic.Tests\$(Configuration)\</IntermediateOutputPath>
		<NoWarn>CS0169</NoWarn><!--Unused field-->
		<NoWarn>CS0649</NoWarn><!--Field is never assigned to-->
		<AllowUnsafeBlocks>true</AllowUnsafeBlocks>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
		<PackageReference Include="NUnit" Version="4.4.0" />
		<PackageReference Include="NUnit3TestAdapter" Version="6.1.0" />
		<PackageReference Include="NUnit.Analyzers" Version="4.11.2">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.SerializationLogic\AssetRipper.SerializationLogic.csproj" />
		<ProjectReference Include="..\UnityEngine\UnityEngine.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.SerializationLogic.Tests/CyclicalReferenceTests.cs`:

```cs
namespace AssetRipper.SerializationLogic.Tests;

public class CyclicalReferenceTests
{
	[Serializable]
	private class SelfReferencingClass
	{
		public SelfReferencingClass? selfReference;
	}

	[Test]
	public void CyclicalReferenceClassIsHandled_D1()
	{
		SerializableType serializableType = SerializableTypes.Create<SelfReferencingClass>();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(0)); // Infinite recursion disqualifies a field from serialization
	}

	[Serializable]
	private class CyclicalReferenceClass_C1_D2
	{
		public CyclicalReferenceClass_C2_D2? reference;
	}

	[Serializable]
	private class CyclicalReferenceClass_C2_D2
	{
		public CyclicalReferenceClass_C1_D2? reference;
	}

	[Test]
	public void CyclicalReferenceClassIsHandled_D2()
	{
		List<SerializableType> serializableType = SerializableTypes.CreateMultiple<CyclicalReferenceClass_C1_D2>();
		using (Assert.EnterMultipleScope())
		{
			foreach (SerializableType type in serializableType)
			{
				Assert.That(type.Fields, Has.Count.EqualTo(0), $"{type.Name} should have no fields.");
			}
		}
	}

	[Serializable]
	private class CyclicalReferenceClass_C1_D3
	{
		public CyclicalReferenceClass_C2_D3? reference;
	}

	[Serializable]
	private class CyclicalReferenceClass_C2_D3
	{
		public CyclicalReferenceClass_C3_D3? reference;
	}

	[Serializable]
	private class CyclicalReferenceClass_C3_D3
	{
		public CyclicalReferenceClass_C1_D3? reference;
	}

	[Test]
	public void CyclicalReferenceClassIsHandled_D3()
	{
		List<SerializableType> serializableType = SerializableTypes.CreateMultiple<CyclicalReferenceClass_C1_D3>();
		using (Assert.EnterMultipleScope())
		{
			foreach (SerializableType type in serializableType)
			{
				Assert.That(type.Fields, Has.Count.EqualTo(0), $"{type.Name} should have no fields.");
			}
		}
	}

	[Serializable]
	private class CyclicalReferenceClass_C1_D4
	{
		public CyclicalReferenceClass_C2_D4? reference;
	}

	[Serializable]
	private class CyclicalReferenceClass_C2_D4
	{
		public CyclicalReferenceClass_C3_D4? reference;
	}

	[Serializable]
	private class CyclicalReferenceClass_C3_D4
	{
		public CyclicalReferenceClass_C4_D4? reference;
	}

	[Serializable]
	private class CyclicalReferenceClass_C4_D4
	{
		public CyclicalReferenceClass_C1_D4? reference;
	}

	[Test]
	public void CyclicalReferenceClassIsHandled_D4()
	{
		List<SerializableType> serializableType = SerializableTypes.CreateMultiple<CyclicalReferenceClass_C1_D4>();
		using (Assert.EnterMultipleScope())
		{
			foreach (SerializableType type in serializableType)
			{
				Assert.That(type.Fields, Has.Count.EqualTo(0), $"{type.Name} should have no fields.");
			}
		}
	}

	[Serializable]
	private class CyclicalReferenceClass_C1_D3_V1
	{
		public CyclicalReferenceClass_C2_D3_V1? reference;
	}

	[Serializable]
	private class CyclicalReferenceClass_C2_D3_V1
	{
		public CyclicalReferenceClass_C3_D3_V1? reference1;
		public CyclicalReferenceClass_C3_D3_V1? reference2;
	}

	[Serializable]
	private class CyclicalReferenceClass_C3_D3_V1
	{
		public CyclicalReferenceClass_C1_D3_V1? reference;
	}

	[Test]
	public void CyclicalReferenceClassIsHandled_D3_V1()
	{
		// Variant 1: Two references to the same class
		List<SerializableType> serializableType = SerializableTypes.CreateMultiple<CyclicalReferenceClass_C1_D3_V1>();
		using (Assert.EnterMultipleScope())
		{
			foreach (SerializableType type in serializableType)
			{
				Assert.That(type.Fields, Has.Count.EqualTo(0), $"{type.Name} should have no fields.");
			}
		}
	}

	[Serializable]
	private class CyclicalReferenceClass_C1_D3_V2
	{
		public CyclicalReferenceClass_C2_D3_V2? reference;
	}

	[Serializable]
	private class CyclicalReferenceClass_C2_D3_V2
	{
		public CyclicalReferenceClass_C3_D3_V2? reference1;
		public CyclicalReferenceClass_C1_D3_V2? reference2;
	}

	[Serializable]
	private class CyclicalReferenceClass_C3_D3_V2
	{
		public CyclicalReferenceClass_C1_D3_V2? reference;
	}

	[Test]
	public void CyclicalReferenceClassIsHandled_D3_V2()
	{
		// Variant 2: Reference to child class, then reference to parent class
		List<SerializableType> serializableType = SerializableTypes.CreateMultiple<CyclicalReferenceClass_C1_D3_V2>();
		using (Assert.EnterMultipleScope())
		{
			foreach (SerializableType type in serializableType)
			{
				Assert.That(type.Fields, Has.Count.EqualTo(0), $"{type.Name} should have no fields.");
			}
		}
	}

	[Serializable]
	private class CyclicalReferenceClass_C1_D3_V3
	{
		public CyclicalReferenceClass_C2_D3_V3? reference;
	}

	[Serializable]
	private class CyclicalReferenceClass_C2_D3_V3
	{
		public CyclicalReferenceClass_C1_D3_V3? reference1;
		public CyclicalReferenceClass_C3_D3_V3? reference2;
	}

	[Serializable]
	private class CyclicalReferenceClass_C3_D3_V3
	{
		public CyclicalReferenceClass_C1_D3_V3? reference;
	}

	[Test]
	public void CyclicalReferenceClassIsHandled_D3_V3()
	{
		// Variant 3: Reference to parent class, then reference to child class
		List<SerializableType> serializableType = SerializableTypes.CreateMultiple<CyclicalReferenceClass_C1_D3_V3>();
		using (Assert.EnterMultipleScope())
		{
			foreach (SerializableType type in serializableType)
			{
				Assert.That(type.Fields, Has.Count.EqualTo(0), $"{type.Name} should have no fields.");
			}
		}
	}

	[Serializable]
	public class BaseClass<T>
	{
		public string? field1;
		public T? field2;
	}
	[Serializable]
	public class DerivedClass1 : BaseClass<string>
	{
	}
	[Serializable]
	public class DerivedClass2 : BaseClass<DerivedClass2>
	{
	}

	[Test]
	public void CyclicalReferenceGenericClassIsHandled()
	{
		SerializableType serializableType1 = SerializableTypes.Create<DerivedClass1>();
		Assert.That(serializableType1.Fields, Has.Count.EqualTo(2)); // No cycles, both fields are serialized
		SerializableType serializableType2 = SerializableTypes.Create<DerivedClass2>();
		Assert.That(serializableType2.Fields, Has.Count.EqualTo(1)); // One cycle, only field1 is serialized
	}
}

```

`Source/AssetRipper.SerializationLogic.Tests/EmptySerializableClass.cs`:

```cs
namespace AssetRipper.SerializationLogic.Tests;

/// <summary>
/// This is used to clone and generate new serializable types for testing purposes.
/// </summary>
[Serializable]
internal class EmptySerializableClass
{
}

```

`Source/AssetRipper.SerializationLogic.Tests/FieldSerializationTests.cs`:

```cs
using AsmResolver.PE.DotNet.Metadata.Tables;
using AssetRipper.Primitives;

namespace AssetRipper.SerializationLogic.Tests;

public class FieldSerializationTests
{
	private class CustomMonoBehaviourWithPrivateFields : UnityEngine.MonoBehaviour
	{
		[UnityEngine.SerializeField]
		private int field1;

		private int field2; // Not serialized
	}

	[Test]
	public void PrivateFieldsAreCorrectlyDiscriminated()
	{
		SerializableType serializableType = SerializableTypes.Create<CustomMonoBehaviourWithPrivateFields>();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
		SerializableType.Field field = serializableType.Fields[0];
		Assert.That(field.Name, Is.EqualTo("field1"));
	}

	private class CustomMonoBehaviourWithPublicFields : UnityEngine.MonoBehaviour
	{
		[NonSerialized]
		public int field1;

		public int field2;
	}

	[Test]
	public void PublicFieldsAreCorrectlyDiscriminated()
	{
		SerializableType serializableType = SerializableTypes.Create<CustomMonoBehaviourWithPublicFields>();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
		SerializableType.Field field = serializableType.Fields[0];
		Assert.That(field.Name, Is.EqualTo(nameof(CustomMonoBehaviourWithPublicFields.field2)));
	}

	private class CustomMonoBehaviourWithListField : UnityEngine.MonoBehaviour
	{
		public List<string>? listOfStrings;
	}

	[Test]
	public void ResolutionForUnityTypesWorksAsExpected()
	{
		SerializableType serializableType = SerializableTypes.Create<CustomMonoBehaviourWithListField>();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
		SerializableType.Field field = serializableType.Fields[0];
		using (Assert.EnterMultipleScope())
		{
			Assert.That(field.Name, Is.EqualTo(nameof(CustomMonoBehaviourWithListField.listOfStrings)));
			Assert.That(field.Type.Type, Is.EqualTo(PrimitiveType.String));
			Assert.That(field.ArrayDepth, Is.EqualTo(1));
		}
	}

	[Serializable]
	private class TestGenericClass<T>
	{
		public List<T>? listOfT;
	}

	private class CustomMonoBehaviourWithGenericField : UnityEngine.MonoBehaviour
	{
		public TestGenericClass<string>? testGenericClass;
	}

	[Test]
	public void DeserializationSupportsGenericTypes()
	{
		SerializableType serializableType = SerializableTypes.Create<CustomMonoBehaviourWithGenericField>();

		Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
		SerializableType.Field field = serializableType.Fields[0];
		using (Assert.EnterMultipleScope())
		{
			Assert.That(field.Name, Is.EqualTo(nameof(CustomMonoBehaviourWithGenericField.testGenericClass)));
			Assert.That(field.Type.Type, Is.EqualTo(PrimitiveType.Complex));
			Assert.That(field.ArrayDepth, Is.Zero);
			Assert.That(field.Type.Fields, Has.Count.EqualTo(1));
		}
		SerializableType.Field subField = field.Type.Fields[0];
		using (Assert.EnterMultipleScope())
		{
			Assert.That(subField.Name, Is.EqualTo(nameof(TestGenericClass<>.listOfT)));
			Assert.That(subField.Type.Type, Is.EqualTo(PrimitiveType.String));
			Assert.That(subField.ArrayDepth, Is.EqualTo(1));
		}
	}

	[TestCase("2019.4", false)]
	[TestCase("2020.1.0a3", true)]
	public void GenericInstanceSerializationStartedWithUnity2020(string version, bool serialize)
	{
		// https://github.com/AssetRipper/AssetRipper/issues/1792
		SerializableType serializableType = SerializableTypes.Create<CustomMonoBehaviourWithGenericField>(UnityVersion.Parse(version));
		if (serialize)
		{
			Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
			SerializableType.Field field = serializableType.Fields[0];
			using (Assert.EnterMultipleScope())
			{
				Assert.That(field.Name, Is.EqualTo(nameof(CustomMonoBehaviourWithGenericField.testGenericClass)));
				Assert.That(field.Type.Type, Is.EqualTo(PrimitiveType.Complex));
				Assert.That(field.ArrayDepth, Is.Zero);
			}
		}
		else
		{
			Assert.That(serializableType.Fields, Has.Count.EqualTo(0));
		}
	}

	private class DerivedObject : UnityEngine.Object
	{
	}

	private class CustomMonoBehaviourWithObjectField : UnityEngine.MonoBehaviour
	{
		public UnityEngine.Object? pptr;
	}

	private class CustomMonoBehaviourWithDerivedObjectField : UnityEngine.MonoBehaviour
	{
		public DerivedObject? pptr;
	}

	private class CustomMonoBehaviourWithMonoBehaviourField : UnityEngine.MonoBehaviour
	{
		public UnityEngine.Object? pptr;
	}

	private abstract class GenericAbstractMonoBehaviour<T> : UnityEngine.MonoBehaviour
	{
	}

	private class NonGenericDerivedMonoBehaviour : GenericAbstractMonoBehaviour<int>
	{
	}

	private class CustomMonoBehaviourWithNonGenericDerivedMonoBehaviourField : UnityEngine.MonoBehaviour
	{
		public NonGenericDerivedMonoBehaviour? pptr;
	}

	private class CustomMonoBehaviourWithGenericAbstractMonoBehaviourField : UnityEngine.MonoBehaviour
	{
		public GenericAbstractMonoBehaviour<int>? pptr;
	}

	[TestCase(typeof(CustomMonoBehaviourWithObjectField))]
	[TestCase(typeof(CustomMonoBehaviourWithDerivedObjectField))]
	[TestCase(typeof(CustomMonoBehaviourWithMonoBehaviourField))]
	[TestCase(typeof(CustomMonoBehaviourWithNonGenericDerivedMonoBehaviourField))]
	[TestCase(typeof(CustomMonoBehaviourWithGenericAbstractMonoBehaviourField))]
	public void DeserializationSupportsPPtrFields(Type type)
	{
		SerializableType serializableType = SerializableTypes.Create(type);
		Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
		SerializableType.Field field = serializableType.Fields[0];
		using (Assert.EnterMultipleScope())
		{
			Assert.That(field.Type, Is.EqualTo(SerializablePointerType.Shared));
			Assert.That(field.ArrayDepth, Is.Zero);
		}
	}

	[Serializable]
	private class ClassWithLongField
	{
		public long value;
	}

	[TestCase("4.4", false)]
	[TestCase("5.3", false)]
	[TestCase("5.9", false)]
	[TestCase("2017.1", true)]
	public void LongIntegerSerializationStartedWithUnity2017(string version, bool serialize)
	{
		// https://github.com/AssetRipper/AssetRipper/issues/647
		SerializableType serializableType = SerializableTypes.Create<ClassWithLongField>(UnityVersion.Parse(version));
		if (serialize)
		{
			Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
			SerializableType.Field field = serializableType.Fields[0];
			using (Assert.EnterMultipleScope())
			{
				Assert.That(field.Name, Is.EqualTo(nameof(ClassWithLongField.value)));
				Assert.That(field.Type.Type, Is.EqualTo(PrimitiveType.Long));
				Assert.That(field.ArrayDepth, Is.Zero);
			}
		}
		else
		{
			Assert.That(serializableType.Fields, Has.Count.EqualTo(0));
		}
	}

	[Serializable]
	private struct StructWithIntField
	{
		public int value;
	}

	[Test]
	public void DeserializationSupportsStructsWithIntField()
	{
		SerializableType serializableType = SerializableTypes.Create<StructWithIntField>();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
		SerializableType.Field field = serializableType.Fields[0];
		using (Assert.EnterMultipleScope())
		{
			Assert.That(field.Name, Is.EqualTo(nameof(StructWithIntField.value)));
			Assert.That(field.Type.Type, Is.EqualTo(PrimitiveType.Int));
			Assert.That(field.ArrayDepth, Is.Zero);
		}
	}

	[Serializable]
	private unsafe struct StructWithFixedSizeBuffer
	{
		public fixed int values[4];
	}

	[Test]
	public void DeserializationSupportsStructsWithFixedSizeBuffer()
	{
		SerializableType serializableType = SerializableTypes.Create<StructWithFixedSizeBuffer>();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
		SerializableType.Field field = serializableType.Fields[0];
		using (Assert.EnterMultipleScope())
		{
			Assert.That(field.Name, Is.EqualTo(nameof(StructWithFixedSizeBuffer.values)));
			Assert.That(field.Type.Type, Is.EqualTo(PrimitiveType.Int));
			Assert.That(field.ArrayDepth, Is.EqualTo(1));
		}
	}

	[Serializable]
	private class ClassWithStructField
	{
		public StructWithIntField value;
	}

	[TestCase("4.4", false)]
	[TestCase("4.6", true)]
	public void StructSerializationStartedWithUnity4_5(string version, bool serialize)
	{
		// https://github.com/AssetRipper/AssetRipper/issues/1534
		SerializableType serializableType = SerializableTypes.Create<ClassWithStructField>(UnityVersion.Parse(version));
		if (serialize)
		{
			Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
			SerializableType.Field field = serializableType.Fields[0];
			using (Assert.EnterMultipleScope())
			{
				Assert.That(field.Name, Is.EqualTo(nameof(ClassWithStructField.value)));
				Assert.That(field.Type.Type, Is.EqualTo(PrimitiveType.Complex));
				Assert.That(field.ArrayDepth, Is.Zero);
			}
		}
		else
		{
			Assert.That(serializableType.Fields, Has.Count.EqualTo(0));
		}
	}

	[Serializable]
	private class DerivedClassWithNewField : ClassWithLongField
	{
		public new float value;
	}

	[Test]
	public void DeserializationSupportsFieldsWithSameName()
	{
		SerializableType serializableType = SerializableTypes.Create<DerivedClassWithNewField>();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(2));
		SerializableType.Field field1 = serializableType.Fields[0];
		SerializableType.Field field2 = serializableType.Fields[1];
		using (Assert.EnterMultipleScope())
		{
			Assert.That(field1.Name, Is.EqualTo(field2.Name));

			Assert.That(field1.Name, Is.EqualTo(nameof(ClassWithLongField.value)));
			Assert.That(field1.Type.Type, Is.EqualTo(PrimitiveType.Long));
			Assert.That(field1.ArrayDepth, Is.Zero);

			Assert.That(field2.Name, Is.EqualTo(nameof(DerivedClassWithNewField.value)));
			Assert.That(field2.Type.Type, Is.EqualTo(PrimitiveType.Single));
			Assert.That(field2.ArrayDepth, Is.Zero);
		}
	}

	[TestCase(typeof(UnityEngine.Vector2))]
	[TestCase(typeof(UnityEngine.Vector3))]
	[TestCase(typeof(UnityEngine.Vector4))]
	[TestCase(typeof(UnityEngine.Rect))]
	[TestCase(typeof(UnityEngine.RectInt))]
	[TestCase(typeof(UnityEngine.Quaternion))]
	[TestCase(typeof(UnityEngine.Matrix4x4))]
	[TestCase(typeof(UnityEngine.Color))]
	[TestCase(typeof(UnityEngine.Color32))]
	[TestCase(typeof(UnityEngine.LayerMask))]
	[TestCase(typeof(UnityEngine.Bounds))]
	[TestCase(typeof(UnityEngine.BoundsInt))]
	[TestCase(typeof(UnityEngine.Vector3Int))]
	[TestCase(typeof(UnityEngine.Vector2Int))]
	public void DeserializationSupportsEngineStructsWithoutSerializableAttributeOnUnity4(Type type)
	{
		TypeDefinition typeDefinition = SerializableClassGenerator.CreateEmptySerializableClass();
		FieldDefinition fieldDefinition = new("engineStructField", FieldAttributes.Public, new FieldSignature(ReferenceAssemblies.GetType(type).ToTypeSignature()));
		typeDefinition.Fields.Add(fieldDefinition);

		SerializableType serializableType = SerializableTypes.Create(typeDefinition, new(4));
		Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
	}

	[Serializable]
	private class ClassWithVolatileField
	{
		public volatile bool value;
	}

	[Test]
	public void DeserializationSupportsVolatileFields()
	{
		SerializableType serializableType = SerializableTypes.Create<ClassWithVolatileField>();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
		SerializableType.Field field = serializableType.Fields[0];
		using (Assert.EnterMultipleScope())
		{
			Assert.That(field.Name, Is.EqualTo(nameof(ClassWithVolatileField.value)));
			Assert.That(field.Type.Type, Is.EqualTo(PrimitiveType.Bool));
			Assert.That(field.ArrayDepth, Is.Zero);
		}
	}

	[Serializable]
	private abstract class AbstractSerializableClass
	{
		public int value;
	}

	[Serializable]
	private class ClassWithAbstractField
	{
		public AbstractSerializableClass? value;
	}

	[Test]
	public void FieldsWithAbstractTypesShouldNotBeSerialized()
	{
		SerializableType serializableType = SerializableTypes.Create<ClassWithAbstractField>();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(0));
	}

	[Serializable]
	private class ClassWithAbstractListField
	{
		public AbstractSerializableClass? value;
	}

	[Test]
	public void ListFieldsWithAbstractTypesShouldNotBeSerialized()
	{
		SerializableType serializableType = SerializableTypes.Create<ClassWithAbstractListField>();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(0));
	}

	[Serializable]
	private class BaseClassWithSelfField
	{
		public int baseField;
		public BaseClassWithSelfField? nonSerializedField;
	}

	[Serializable]
	private class DerivedClassWithBaseClassField : BaseClassWithSelfField
	{
		public BaseClassWithSelfField? serializedField;
	}

	[Test]
	public void FieldWhoseTypeIsBaseShouldBeSerialized()
	{
		SerializableType serializableType = SerializableTypes.Create<DerivedClassWithBaseClassField>();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(2));
	}

	private class BaseClassWithoutSerializableAttribute
	{
		public int baseField;
	}

	[Serializable]
	private class DerivedClassWithSerializableAttribute : BaseClassWithoutSerializableAttribute
	{
		public int derivedField;
	}

	[Test]
	public void FieldsFromBaseTypesAreStillSerializedEvenWithoutSerializableAttributeOnBaseType()
	{
		SerializableType serializableType = SerializableTypes.Create<DerivedClassWithSerializableAttribute>();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(2));
	}
}

```

`Source/AssetRipper.SerializationLogic.Tests/ReferenceAssemblies.cs`:

```cs
using System.Collections.Concurrent;
using System.Reflection;

namespace AssetRipper.SerializationLogic.Tests;

public static class ReferenceAssemblies
{
	public static AssemblyReference CorLib => (AssemblyReference)GetModule(typeof(ReferenceAssemblies)).CorLibTypeFactory.CorLibScope;

	private static ModuleDefinition GetModule<T>() => GetModule(typeof(T));
	private static ModuleDefinition GetModule(Type type) => GetModule(type.Assembly);
	private static ModuleDefinition GetModule(Assembly assembly)
	{
		return modules.GetOrAdd(assembly, a => new Lazy<ModuleDefinition>(() => ModuleDefinition.FromFile(a.Location), LazyThreadSafetyMode.ExecutionAndPublication)).Value;
	}

	public static TypeDefinition GetType<T>() => GetType(typeof(T));
	public static TypeDefinition GetType(Type type)
	{
		ModuleDefinition module = GetModule(type);
		string fullName = type.FullName ?? throw new ArgumentException("Type has no FullName", nameof(type));

		Lazy<Dictionary<string, TypeDefinition>> lazyMap = typesCache.GetOrAdd(module, m => new Lazy<Dictionary<string, TypeDefinition>>(() =>
			m.GetAllTypes()
				.Where(t => t.FullName != null)
				.ToDictionary(t => t.FullName!, t => t, StringComparer.Ordinal), LazyThreadSafetyMode.ExecutionAndPublication));

		Dictionary<string, TypeDefinition> map = lazyMap.Value;

		if (!map.TryGetValue(fullName, out TypeDefinition? typeDef))
		{
			throw new InvalidOperationException($"Type '{fullName}' not found in module '{module.Name}'.");
		}

		return typeDef;
	}

	private static readonly ConcurrentDictionary<Assembly, Lazy<ModuleDefinition>> modules = new();
	private static readonly ConcurrentDictionary<ModuleDefinition, Lazy<Dictionary<string, TypeDefinition>>> typesCache = new();
}

```

`Source/AssetRipper.SerializationLogic.Tests/ReferenceAssembliesTests.cs`:

```cs
namespace AssetRipper.SerializationLogic.Tests;

public class ReferenceAssembliesTests
{
	[Test]
	public void ResolutionForUnityTypesWorksAsExpected()
	{
		TypeDefinition customMonoBehaviour = ReferenceAssemblies.GetType<NestedMonoBehaviour>();
		Assert.That(customMonoBehaviour, Is.Not.Null);
		Assert.That(customMonoBehaviour.BaseType, Is.Not.Null);
		TypeDefinition? monoBehaviour = customMonoBehaviour.BaseType?.Resolve();
		Assert.That(monoBehaviour, Is.Not.Null);
		Assert.That(monoBehaviour?.Name?.ToString(), Is.EqualTo(nameof(UnityEngine.MonoBehaviour)));
	}

	private class NestedMonoBehaviour : UnityEngine.MonoBehaviour
	{
	}
}

```

`Source/AssetRipper.SerializationLogic.Tests/SerializableClassGenerator.cs`:

```cs
using AsmResolver.DotNet.Cloning;

namespace AssetRipper.SerializationLogic.Tests;

internal static class SerializableClassGenerator
{
	public static TypeDefinition CreateEmptySerializableClass() => CreateEmptySerializableClass(null, null);
	public static TypeDefinition CreateEmptySerializableClass(string name) => CreateEmptySerializableClass(null, name);
	public static TypeDefinition CreateEmptySerializableClass(string? @namespace, string? name)
	{
		TypeDefinition emptySerializableClass = ReferenceAssemblies.GetType<EmptySerializableClass>();
		ModuleDefinition module = new("TestModule", ReferenceAssemblies.CorLib);
		MemberCloner cloner = new(module);
		cloner.Include(emptySerializableClass);
		TypeDefinition clonedType = cloner.Clone().ClonedTopLevelTypes.Single();
		if (!string.IsNullOrEmpty(@namespace))
		{
			clonedType.Namespace = @namespace;
		}
		if (!string.IsNullOrEmpty(name))
		{
			clonedType.Name = name;
		}
		module.TopLevelTypes.Add(clonedType);
		return clonedType;
	}
}

```

`Source/AssetRipper.SerializationLogic.Tests/SerializableTypes.cs`:

```cs
using AssetRipper.Primitives;

namespace AssetRipper.SerializationLogic.Tests;

public static class SerializableTypes
{
	public static SerializableType Create<T>() => Create<T>(DefaultUnityVersion);
	public static SerializableType Create<T>(UnityVersion version) => Create(typeof(T), version);
	public static SerializableType Create(Type type) => Create(type, DefaultUnityVersion);
	public static SerializableType Create(Type type, UnityVersion version) => Create(ReferenceAssemblies.GetType(type), version);
	public static SerializableType Create(TypeDefinition type) => Create(type, DefaultUnityVersion);
	public static SerializableType Create(TypeDefinition type, UnityVersion version)
	{
		FieldSerializer serializer = new(version);
		if (serializer.TryCreateSerializableType(type, out SerializableType? serializableType, out string? failureReason))
		{
			return serializableType;
		}
		else
		{
			Assert.Fail($"Failed to create serializable type: {failureReason}");
			return default!;
		}
	}

	public static List<SerializableType> CreateMultiple<T>() => CreateMultiple<T>(DefaultUnityVersion);
	public static List<SerializableType> CreateMultiple<T>(UnityVersion version) => CreateMultiple(typeof(T), version);
	public static List<SerializableType> CreateMultiple(Type type) => CreateMultiple(type, DefaultUnityVersion);
	public static List<SerializableType> CreateMultiple(Type type, UnityVersion version) => CreateMultiple(ReferenceAssemblies.GetType(type), version);
	public static List<SerializableType> CreateMultiple(TypeDefinition type) => CreateMultiple(type, DefaultUnityVersion);
	public static List<SerializableType> CreateMultiple(TypeDefinition type, UnityVersion version)
	{
		FieldSerializer serializer = new(version);
		Dictionary<ITypeDefOrRef, SerializableType> typeCache = [];
		if (serializer.TryCreateSerializableType(type, typeCache, out _, out string? failureReason))
		{
			return typeCache.Values.ToList();
		}
		else
		{
			Assert.Fail($"Failed to create serializable type: {failureReason}");
			return [];
		}
	}

	/// <summary>
	/// Assume a recent Unity version if not specified.
	/// </summary>
	private static UnityVersion DefaultUnityVersion => new(6000);
}

```

`Source/AssetRipper.SerializationLogic.Tests/Usings.cs`:

```cs
global using AsmResolver.DotNet;
global using AsmResolver.DotNet.Signatures;
global using NUnit.Framework;

```

`Source/AssetRipper.SerializationLogic/AsmUtils.cs`:

```cs
using AssetRipper.SerializationLogic.Extensions;

namespace AssetRipper.SerializationLogic;

internal static class AsmUtils
{
	public static IEnumerable<TypeDefinition> AllInterfacesImplementedBy(TypeDefinition typeDefinition)
	{
		return TypeAndBaseTypesOf(typeDefinition).SelectMany(t => t.Interfaces).Select(i => i.Interface!.CheckedResolve()).Distinct();
	}

	public static IEnumerable<TypeDefinition> TypeAndBaseTypesOf(ITypeDescriptor? typeReference)
	{
		while (typeReference != null)
		{
			TypeDefinition typeDefinition = typeReference.CheckedResolve();
			yield return typeDefinition;
			typeReference = typeDefinition.BaseType;
		}
	}

	public static IEnumerable<TypeDefinition> BaseTypesOf(ITypeDescriptor typeReference)
	{
		return TypeAndBaseTypesOf(typeReference).Skip(1);
	}

	public static bool IsGenericList(ITypeDescriptor type)
	{
		return (type.ToTypeSignature() as GenericInstanceTypeSignature)?.GenericType.Name == "List`1"
			&& type.SafeNamespace() == "System.Collections.Generic";
	}

	public static bool IsGenericDictionary(ITypeDescriptor type)
	{
		if (type.ToTypeSignature() is GenericInstanceTypeSignature genericInstanceTypeSignature)
		{
			type = genericInstanceTypeSignature.GenericType;
		}

		return type.Name == "Dictionary`2" && type.SafeNamespace() == "System.Collections.Generic";
	}

	public static TypeSignature ElementTypeOfCollection(TypeSignature type)
	{
		if (type is SzArrayTypeSignature szArrayTypeSignature)
		{
			return szArrayTypeSignature.BaseType;
		}

		if (type is ArrayTypeSignature arrayTypeSignature)
		{
			return arrayTypeSignature.BaseType;
		}

		if (IsGenericList(type))
		{
			return ((GenericInstanceTypeSignature)type).TypeArguments.Single();
		}

		throw new ArgumentException(null, nameof(type));
	}
}

```

`Source/AssetRipper.SerializationLogic/AssetRipper.SerializationLogic.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.SerializationLogic\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.SerializationLogic\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AsmResolver.DotNet" Version="6.0.0-beta.5" />
		<PackageReference Include="AssetRipper.Primitives" Version="3.2.0" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.SerializationLogic/EngineTypePredicates.cs`:

```cs
using AssetRipper.SerializationLogic.Extensions;

namespace AssetRipper.SerializationLogic;

internal static class EngineTypePredicates
{
	private static readonly HashSet<string> TypesThatShouldHaveHadSerializableAttribute = new HashSet<string>
	{
		"Vector3",
		"Vector2",
		"Vector4",
		"Rect",
		"RectInt",
		"Quaternion",
		"Matrix4x4",
		"Color",
		"Color32",
		"LayerMask",
		"Bounds",
		"BoundsInt",
		"Vector3Int",
		"Vector2Int",
	};

	private const string Gradient = "UnityEngine.Gradient";
	private const string GUIStyle = "UnityEngine.GUIStyle";
	private const string RectOffset = "UnityEngine.RectOffset";
	private const string UnityEngineObject = "UnityEngine.Object";

	public const string MonoBehaviour = "MonoBehaviour";
	public const string ScriptableObject = "ScriptableObject";

	public const string UnityEngineNamespace = "UnityEngine";
	public const string SerializeFieldAttribute = "SerializeField";
	public const string SerializeReferenceAttribute = "SerializeReference";

	private static readonly string[] serializableClasses =
	[
		"AnimationCurve",
		"Gradient",
		"GUIStyle",
		"RectOffset"
	];

	private static readonly string[] serializableStructs =
	[
		// NOTE: assumes all types here are NOT interfaces
		"UnityEngine.Color32",
		"UnityEngine.Matrix4x4",
		"UnityEngine.Rendering.SphericalHarmonicsL2",
		"UnityEngine.PropertyName",
	];

	public static bool IsSerializableUnityClass(ITypeDescriptor type)
	{
		foreach (string unityClasses in serializableClasses)
		{
			if (type.IsAssignableTo(UnityEngineNamespace, unityClasses))
			{
				return true;
			}
		}
		return false;
	}

	public static bool IsSerializableUnityStruct(ITypeDescriptor type)
	{
		foreach (string unityStruct in serializableStructs)
		{
			// NOTE: structs cannot inherit from structs, and can only inherit from interfaces
			//	   since we know all types in serializableStructs are not interfaces,
			//	   we can just do a direct comparison.
			if (type.FullName == unityStruct)
			{
				return true;
			}
		}

		if (type.FullName.StartsWith("UnityEngine.LazyLoadReference`1", StringComparison.Ordinal))
		{
			return true;
		}

		return false;
	}

	public static bool IsUnityEngineObject(ITypeDescriptor type)
	{
		return type.IsAssignableTo(UnityEngineNamespace, nameof(Object));
	}

	public static bool ShouldHaveHadSerializableAttribute(ITypeDescriptor type)
	{
		return IsUnityEngineValueType(type);
	}

	public static bool IsUnityEngineValueType(ITypeDescriptor type)
	{
		return type.SafeNamespace() == "UnityEngine" && TypesThatShouldHaveHadSerializableAttribute.Contains(type.Name ?? "");
	}
}

```

`Source/AssetRipper.SerializationLogic/Extensions/FieldDefinitionExtensions.cs`:

```cs
namespace AssetRipper.SerializationLogic.Extensions;

internal static class FieldDefinitionExtensions
{
	public static bool IsConst(this FieldDefinition field)
	{
		return field.IsLiteral && !field.IsInitOnly;
	}
}

```

`Source/AssetRipper.SerializationLogic/Extensions/HasCustomAttributesExtensions.cs`:

```cs
using AsmResolver;

namespace AssetRipper.SerializationLogic.Extensions;

internal static class HasCustomAttributesExtensions
{
	public static bool HasSerializeFieldAttribute(this IHasCustomAttribute owner)
	{
		return owner.HasCustomAttribute(EngineTypePredicates.UnityEngineNamespace, EngineTypePredicates.SerializeFieldAttribute);
	}

	public static bool HasSerializeReferenceAttribute(this IHasCustomAttribute owner)
	{
		return owner.HasCustomAttribute(EngineTypePredicates.UnityEngineNamespace, EngineTypePredicates.SerializeReferenceAttribute);
	}

	public static bool HasFixedBufferAttribute(this IHasCustomAttribute owner)
	{
		return owner.HasCustomAttribute("System.Runtime.CompilerServices", "FixedBufferAttribute");
	}

	public static CustomAttribute? GetCustomAttribute(this IHasCustomAttribute owner, string? ns, string? name)
	{
		for (int i = 0; i < owner.CustomAttributes.Count; i++)
		{
			CustomAttribute attribute = owner.CustomAttributes[i];
			ITypeDefOrRef? declaringType = attribute.Type;
			if (declaringType == null)
			{
				continue;
			}
			if (declaringType.Namespace == ns && declaringType.Name == name)
			{
				return attribute;
			}
		}
		return null;
	}

	public static CustomAttribute? GetCustomAttribute(this IHasCustomAttribute owner, Utf8String? ns, Utf8String? name)
	{
		for (int i = 0; i < owner.CustomAttributes.Count; i++)
		{
			CustomAttribute attribute = owner.CustomAttributes[i];
			ITypeDefOrRef? declaringType = attribute.Type;
			if (declaringType == null)
			{
				continue;
			}
			if (declaringType.Namespace == ns && declaringType.Name == name)
			{
				return attribute;
			}
		}
		return null;
	}

	public static int GetFixedBufferSize(this IHasCustomAttribute owner)
	{
		CustomAttribute? attribute = owner.GetCustomAttribute("System.Runtime.CompilerServices", "FixedBufferAttribute")
			?? throw new InvalidOperationException("The owner does not have a FixedBufferAttribute.");

		int size = (int)(attribute.Signature?.FixedArguments[1].Element ?? 0);

		return size;
	}

	public static TypeSignature GetFixedBufferElementType(this IHasCustomAttribute owner)
	{
		CustomAttribute? attribute = owner.GetCustomAttribute("System.Runtime.CompilerServices", "FixedBufferAttribute")
			?? throw new InvalidOperationException("The owner does not have a FixedBufferAttribute.");
		object elementType = attribute.Signature?.FixedArguments[0].Element
			?? throw new InvalidOperationException("The FixedBufferAttribute does not have a valid element type.");
		return (TypeSignature)elementType;
	}
}

```

`Source/AssetRipper.SerializationLogic/Extensions/MethodDefinitionExtensions.cs`:

```cs
namespace AssetRipper.SerializationLogic.Extensions;

internal static class MethodDefinitionExtensions
{
	public static bool SameAs(this MethodDefinition self, MethodDefinition other)
	{
		// FIXME: should be able to compare MethodDefinition references directly
		return self.FullName == other.FullName;
	}

	public static string PropertyName(this MethodDefinition self)
	{
		if (self.Name is null || self.Name.Length < 5)
		{
			throw new ArgumentException(null, nameof(self));
		}

		return self.Name.Value.Substring(4);
	}

	public static bool IsConversionOperator(this MethodDefinition method)
	{
		if (!method.IsSpecialName)
		{
			return false;
		}

		return method.Name == "op_Implicit" || method.Name == "op_Explicit";
	}

	public static bool IsSimpleSetter(this MethodDefinition original)
	{
		return original.IsSetMethod && original.Parameters.Count == 1;
	}

	public static bool IsSimpleGetter(this MethodDefinition original)
	{
		return original.IsGetMethod && original.Parameters.Count == 0;
	}

	public static bool IsSimplePropertyAccessor(this MethodDefinition method)
	{
		return method.IsSimpleGetter() || method.IsSimpleSetter();
	}

	public static bool IsDefaultConstructor(MethodDefinition m)
	{
		return m.IsConstructor && !m.IsStatic && m.Parameters.Count == 0;
	}
}

```

`Source/AssetRipper.SerializationLogic/Extensions/ResolutionExtensions.cs`:

```cs
namespace AssetRipper.SerializationLogic.Extensions;

internal static class ResolutionExtensions
{
	public static TypeDefinition CheckedResolve(this ITypeDescriptor reference)
	{
		if (reference.ContextModule == null)
		{
			throw new ResolutionException(reference);
		}

		if (reference is not TypeDefinition definition)
		{
			definition = reference.Resolve() ?? throw new ResolutionException(reference);
		}

		return definition;
	}

	public static MethodDefinition CheckedResolve(this IMethodDefOrRef reference)
	{
		if (reference.ContextModule == null)
		{
			throw new ResolutionException(reference);
		}

		if (reference is not MethodDefinition definition)
		{
			definition = reference.Resolve() ?? throw new ResolutionException(reference);
		}

		return definition;
	}
}

```

`Source/AssetRipper.SerializationLogic/Extensions/TypeDefinitionExtensions.cs`:

```cs
namespace AssetRipper.SerializationLogic.Extensions;

internal static class TypeDefinitionExtensions
{
	public static bool IsSubclassOf(this TypeDefinition type, string ns, string name)
	{
		ITypeDefOrRef? baseType = type.BaseType;
		while (baseType != null)
		{
			if (baseType.Namespace == ns && baseType.Name == name)
			{
				return true;
			}
			baseType = baseType.Resolve()?.BaseType;
		}

		return false;
	}

	public static bool IsSubclassOf(this TypeDefinition type, string baseTypeName)
	{
		ITypeDefOrRef? baseType = type.BaseType;
		if (baseType == null)
		{
			return false;
		}

		if (baseType.FullName == baseTypeName)
		{
			return true;
		}

		TypeDefinition? baseTypeDef = baseType.Resolve();
		if (baseTypeDef == null)
		{
			return false;
		}

		return baseTypeDef.IsSubclassOf(baseTypeName);
	}

	public static bool InheritsFromMonoBehaviour(this TypeDefinition type)
	{
		return type.InheritsFrom(EngineTypePredicates.UnityEngineNamespace, EngineTypePredicates.MonoBehaviour);
	}

	public static bool InheritsFromScriptableObject(this TypeDefinition type)
	{
		return type.InheritsFrom(EngineTypePredicates.UnityEngineNamespace, EngineTypePredicates.ScriptableObject);
	}

	public static bool InheritsFromObject(this TypeDefinition type)
	{
		return type.InheritsFrom(EngineTypePredicates.UnityEngineNamespace, "Object");
	}

	public static TypeDefinition? TryGetBaseClass(this TypeDefinition current)
	{
		return current.BaseType?.Resolve();
	}

	public static bool TryGetPrimitiveType(this TypeDefinition typeDefinition, out PrimitiveType primitiveType)
	{
		if ((typeDefinition.DeclaringModule?.Assembly?.IsCorLib ?? false) && typeDefinition.ToTypeSignature() is CorLibTypeSignature corLibTypeSignature)
		{
			primitiveType = corLibTypeSignature.ToPrimitiveType();
			return primitiveType.IsCSharpPrimitive();
		}
		else
		{
			primitiveType = PrimitiveType.Complex;
			return false;
		}
	}
}

```

`Source/AssetRipper.SerializationLogic/Extensions/TypeDescriptorExtensions.cs`:

```cs
namespace AssetRipper.SerializationLogic.Extensions;

internal static class TypeDescriptorExtensions
{
	public static string? SafeNamespace(this ITypeDescriptor type)
	{
		//We want to avoid calling ToTypeSignature where possible because it's expensive, so check each case manually.
		return type switch
		{
			TypeDefinition td => td.Namespace,
			TypeReference tr => tr.Namespace,
			TypeSpecification { Signature: GenericInstanceTypeSignature gts } => gts.GenericType.SafeNamespace(),
			TypeSpecification ts => ts.Namespace,
			GenericInstanceTypeSignature gts => gts.GenericType.SafeNamespace(),
			TypeSignature sig => sig.Namespace,
			_ => type.Namespace,
		};
	}

	public static bool IsAssignableTo(this ITypeDescriptor typeRef, string ns, string name)
	{
		if (typeRef.ToTypeSignature() is GenericInstanceTypeSignature genericInstanceTypeSignature)
		{
			return genericInstanceTypeSignature.GenericType.IsAssignableTo(ns, name);
		}

		if (typeRef.Namespace == ns && typeRef.Name == name)
		{
			return true;
		}

		return typeRef.Resolve()?.IsSubclassOf(ns, name) ?? false;
		// If we can't resolve our typeref or one of its base types,
		// let's assume it is not assignable to our target type
	}

	public static bool IsAssignableTo(this ITypeDescriptor typeRef, string typeName)
	{
		if (typeRef.ToTypeSignature() is GenericInstanceTypeSignature genericInstanceTypeSignature)
		{
			return genericInstanceTypeSignature.GenericType.IsAssignableTo(typeName);
		}

		if (typeRef.FullName == typeName)
		{
			return true;
		}

		return typeRef.Resolve()?.IsSubclassOf(typeName) ?? false;
		// If we can't resolve our typeref or one of its base types,
		// let's assume it is not assignable to our target type
	}

	public static bool InheritsFromObject(this ITypeDescriptor type)
	{
		return type.IsAssignableTo("UnityEngine", "Object");
	}

	public static bool IsEnum(this ITypeDescriptor type)
	{
		return type.IsValueType && !type.IsPrimitive() && type.CheckedResolve().IsEnum;
	}

	public static bool IsStruct(this ITypeDescriptor type)
	{
		return type.IsValueType && !type.IsPrimitive() && !type.IsEnum() && !IsSystemDecimal(type);
	}

	public static bool IsPrimitive(this ITypeDescriptor type)
	{
		return type.ToTypeSignature() is CorLibTypeSignature;
	}

	public static bool IsArray(this ITypeDescriptor type)
	{
		if (type is TypeDefinition or TypeReference)
		{
			//Easy out without having to work out the type sig, which is slow
			return false;
		}

		return type.ToTypeSignature() is SzArrayTypeSignature or ArrayTypeSignature;
	}

	private static bool IsSystemDecimal(ITypeDescriptor type)
	{
		return type.FullName == "System.Decimal";
	}
}

```

`Source/AssetRipper.SerializationLogic/FieldSerializer.Logic.cs`:

```cs
using AsmResolver.PE.DotNet.Metadata.Tables;
using AssetRipper.Primitives;
using AssetRipper.SerializationLogic.Extensions;

namespace AssetRipper.SerializationLogic;

public readonly partial struct FieldSerializer(UnityVersion version)
{
	/// <summary>
	/// Not sure about the exact version boundary, structs are supposedly only serializable on 4.5.0 and greater.
	/// </summary>
	private bool IsStructSerializable { get; } = version.GreaterThanOrEquals(4, 5);
	private bool IsInt8Serializable => IsInt16Serializable;
	/// <summary>
	/// Not sure about the exact version boundary, but int8, int16, uint16, and uint32 were added around 5.0.0.
	/// </summary>
	/// <remarks>
	/// <see href="https://github.com/AssetRipper/AssetRipper/issues/1851"/>
	/// </remarks>
	private bool IsInt16Serializable { get; } = version.GreaterThanOrEquals(5);
	private bool IsUInt32Serializable => IsInt16Serializable;
	private bool IsCharSerializable => IsInt64Serializable;
	/// <summary>
	/// Not sure about the exact version boundary, but online references suggest that 2017 was the first version to support this.
	/// </summary>
	/// <remarks>
	/// <see href="https://github.com/AssetRipper/AssetRipper/issues/647"/>
	/// </remarks>
	private bool IsInt64Serializable { get; } = version.GreaterThanOrEquals(2017);
	/// <summary>
	/// Prior to the first alpha of 2020, System.Collections.Generic.List`1 and UnityEngine.ExposedReference`1 were the only supported generic types.
	/// </summary>
	private bool IsGenericInstanceSerializable => version.GreaterThanOrEquals(2020);

	private bool WillUnitySerialize(FieldDefinition fieldDefinition, TypeSignature fieldType)
	{
		if (fieldDefinition == null)
		{
			return false;
		}

		//skip static, const and NotSerialized fields before even checking the type
		if (fieldDefinition.IsStatic || fieldDefinition.IsConst() || fieldDefinition.IsNotSerialized || fieldDefinition.IsInitOnly)
		{
			return false;
		}

		// The field must have correct visibility/decoration to be serialized.
		if (!fieldDefinition.IsPublic &&
			!ShouldHaveHadAllFieldsPublic(fieldDefinition) &&
			!fieldDefinition.HasSerializeFieldAttribute() &&
			!fieldDefinition.HasSerializeReferenceAttribute())
		{
			return false;
		}

		// Don't try to resolve types that come from Windows assembly,
		// as serialization weaver will fail to resolve that (due to it being in platform specific SDKs)
		if (ShouldNotTryToResolve(fieldDefinition.Signature!.FieldType))
		{
			return false;
		}

		if (fieldDefinition.HasFixedBufferAttribute())
		{
			return true;
		}

		// Resolving types is more complex and slower than checking their names or attributes,
		// thus keep those checks below

		//the type of the field must be serializable in the first place.

		if (fieldType is CustomModifierTypeSignature customModifierType)
		{
			fieldType = customModifierType.BaseType;
		}

		if (fieldType is CorLibTypeSignature corLibTypeSignature && corLibTypeSignature.ElementType == ElementType.String)
		{
			return true;
		}

		if (fieldType.IsValueType)
		{
			return IsValueTypeSerializable(fieldType);
		}

		if (fieldType is SzArrayTypeSignature || AsmUtils.IsGenericList(fieldType))
		{
			if (!fieldDefinition.HasSerializeReferenceAttribute())
			{
				return IsSupportedCollection(fieldType);
			}
		}

		if (!IsReferenceTypeSerializable(fieldType) && !fieldDefinition.HasSerializeReferenceAttribute())
		{
			return false;
		}

		if (IsDelegate(fieldType))
		{
			return false;
		}

		return true;
	}

	private static bool IsDelegate(ITypeDescriptor typeReference)
	{
		return typeReference.IsAssignableTo("System", "Delegate");
	}

	private static IEnumerable<FieldDefinition> AllFieldsFor(TypeDefinition definition)
	{
		TypeDefinition? baseType = definition.BaseType?.Resolve();

		if (baseType != null)
		{
			foreach (FieldDefinition baseField in AllFieldsFor(baseType))
			{
				yield return baseField;
			}
		}

		foreach (FieldDefinition field in definition.Fields)
		{
			yield return field;
		}
	}

	private static bool ShouldNotTryToResolve(ITypeDescriptor typeReference)
	{
		if (typeReference is TypeDefinition)
		{
			//Early-out if we're already resolved.
			return false;
		}

		string? typeReferenceScopeName = typeReference.Scope?.Name;
		if (typeReferenceScopeName == "Windows")
		{
			return true;
		}

		if (typeReferenceScopeName == "mscorlib")
		{
			TypeDefinition? resolved = typeReference.Resolve();
			return resolved == null;
		}

		try
		{   // This will throw an exception if typereference thinks it's referencing a .dll,
			// but actually there's .winmd file in the current directory. RRW will fix this
			// at a later step, so we will not try to resolve this type. This is OK, as any
			// type defined in a winmd cannot be serialized.
			typeReference.Resolve();
		}
		catch
		{
			return true;
		}

		return false;
	}

	private bool IsValueTypeSerializable(TypeSignature typeReference)
	{
		if (typeReference.IsPrimitive())
		{
			return IsSerializablePrimitive((CorLibTypeSignature)typeReference);
		}

		if (typeReference.IsEnum())
		{
			// Enums are serializable as long as their underlying type is serializable
			TypeDefinition typeDefinition = typeReference.CheckedResolve();
			CorLibTypeSignature underlyingType = (CorLibTypeSignature)typeDefinition.GetEnumUnderlyingType()!;
			return IsSerializablePrimitive(underlyingType);
		}
		else
		{
			return EngineTypePredicates.IsSerializableUnityStruct(typeReference) || ShouldImplementIDeserializable(typeReference);
		}
	}

	private bool IsReferenceTypeSerializable(TypeSignature fieldType)
	{
		if (fieldType is CorLibTypeSignature { ElementType: ElementType.String } corLibTypeSignature)
		{
			return IsSerializablePrimitive(corLibTypeSignature);
		}

		if (AsmUtils.IsGenericDictionary(fieldType))
		{
			return false;
		}

		if (EngineTypePredicates.IsUnityEngineObject(fieldType) || EngineTypePredicates.IsSerializableUnityClass(fieldType) || ShouldImplementIDeserializable(fieldType))
		{
			return true;
		}

		return false;
	}

	private bool IsTypeSerializable(TypeSignature fieldType)
	{
		if (fieldType is CorLibTypeSignature { ElementType: ElementType.String })
		{
			return true;
		}

		if (fieldType.IsValueType)
		{
			return IsValueTypeSerializable(fieldType);
		}

		return IsReferenceTypeSerializable(fieldType);
	}

	private bool IsSerializablePrimitive(CorLibTypeSignature typeReference)
	{
		return typeReference.ElementType switch
		{
			ElementType.I1 => IsInt8Serializable,
			ElementType.I2 or ElementType.U2 => IsInt16Serializable,
			ElementType.U4 => IsUInt32Serializable,
			ElementType.I8 or ElementType.U8 => IsInt64Serializable,
			ElementType.Char => IsCharSerializable,
			ElementType.Boolean or ElementType.U1 or ElementType.I4 or ElementType.R4 or ElementType.R8 or ElementType.String => true,
			_ => false,
		};
	}

	private bool IsSupportedCollection(TypeSignature fieldType)
	{
		if (fieldType is SzArrayTypeSignature || AsmUtils.IsGenericList(fieldType))
		{
			return IsTypeSerializable(AsmUtils.ElementTypeOfCollection(fieldType));
		}

		return false;
	}

	private static bool ShouldHaveHadAllFieldsPublic(FieldDefinition field)
	{
		return field.DeclaringType is not null && EngineTypePredicates.IsUnityEngineValueType(field.DeclaringType);
	}

	private static bool IsNonSerialized([NotNullWhen(false)] ITypeDescriptor? typeDeclaration)
	{
		if (typeDeclaration == null)
		{
			return true;
		}

		if (typeDeclaration.ToTypeSignature() is GenericInstanceTypeSignature genericInstanceTypeSignature
			&& genericInstanceTypeSignature.TypeArguments.Any(t => t is GenericParameterSignature))
		{
			return true;
		}

		if (typeDeclaration.ToTypeSignature() is CorLibTypeSignature { ElementType: ElementType.Object })
		{
			return true;
		}

		if (typeDeclaration.IsArray())
		{
			return true;
		}

		if (typeDeclaration.IsEnum())
		{
			return true;
		}

		//MB and SO are not serializable
		if (typeDeclaration is { Namespace: EngineTypePredicates.UnityEngineNamespace, Name: EngineTypePredicates.MonoBehaviour or EngineTypePredicates.ScriptableObject })
		{
			return true;
		}

		//Check namespace
		return typeDeclaration.Namespace == "System" || (typeDeclaration.Namespace?.StartsWith("System.", StringComparison.Ordinal) ?? false);
	}

	private bool ShouldImplementIDeserializable([NotNullWhen(true)] ITypeDescriptor? typeDeclaration)
	{
		if (typeDeclaration is { Namespace: EngineTypePredicates.UnityEngineNamespace, Name: "ExposedReference`1" })
		{
			return true;
		}

		if (IsNonSerialized(typeDeclaration))
		{
			return false;
		}

		if (EngineTypePredicates.ShouldHaveHadSerializableAttribute(typeDeclaration))
		{
			return true;
		}

		TypeDefinition resolvedTypeDeclaration = typeDeclaration.CheckedResolve();

		bool isSerializable = resolvedTypeDeclaration.IsSerializable;

		//If serializable, also check we're not abstract
		isSerializable &= !resolvedTypeDeclaration.IsAbstract;

		//If serializable, also check we're not an interface
		isSerializable &= !resolvedTypeDeclaration.IsInterface;

		//If serializable, also check we're not compiler generated
		isSerializable &= !resolvedTypeDeclaration.IsCompilerGenerated();

		//If serializable, also check we're not a generic instance
		isSerializable &= IsGenericInstanceSerializable || typeDeclaration.ToTypeSignature() is not GenericInstanceTypeSignature;

		if (typeDeclaration.IsValueType)
		{
			return isSerializable && IsStructSerializable;
		}

		//Reference types can be serializable, or they can be MB/SO.
		return isSerializable || resolvedTypeDeclaration.InheritsFromMonoBehaviour() || resolvedTypeDeclaration.InheritsFromScriptableObject();
	}
}

```

`Source/AssetRipper.SerializationLogic/FieldSerializer.cs`:

```cs
using AssetRipper.SerializationLogic.Extensions;
using System.Diagnostics;
using static AssetRipper.SerializationLogic.SerializableType;

namespace AssetRipper.SerializationLogic;

public readonly partial struct FieldSerializer
{
	public bool TryCreateSerializableType(TypeDefinition typeDefinition,
		[NotNullWhen(true)] out SerializableType? result,
		[NotNullWhen(false)] out string? failureReason)
	{
		return TryCreateSerializableType(typeDefinition, new(SignatureComparer.Default), out result, out failureReason);
	}

	public bool TryCreateSerializableType(
		TypeDefinition typeDefinition,
		Dictionary<ITypeDefOrRef, SerializableType> typeCache,
		[NotNullWhen(true)] out SerializableType? result,
		[NotNullWhen(false)] out string? failureReason)
	{
		Stack<MonoType> typeStack = new();
		bool returnValue = TryCreateSerializableType(typeDefinition, typeCache, typeStack, out result, out failureReason);
		Debug.Assert(typeStack.Count == 0, "The type stack should be empty after processing.");
		return returnValue;
	}

	private bool TryCreateSerializableType(
		TypeSignature typeSignature,
		Dictionary<ITypeDefOrRef, SerializableType> typeCache,
		Stack<MonoType> typeStack,
		[NotNullWhen(true)] out SerializableType? result,
		[NotNullWhen(false)] out string? failureReason)
	{
		if (typeSignature is GenericInstanceTypeSignature genericInstanceType)
		{
			return TryCreateSerializableType(genericInstanceType, typeCache, typeStack, out result, out failureReason);
		}
		TypeDefinition? typeDefinition = typeSignature.Resolve();
		if (typeDefinition is null)
		{
			result = null;
			failureReason = $"Failed to resolve type signature {typeSignature.FullName}.";
			return false;
		}
		else
		{
			return TryCreateSerializableType(typeDefinition, typeCache, typeStack, out result, out failureReason);
		}
	}

	private bool TryCreateSerializableType(
		TypeDefinition typeDefinition,
		Dictionary<ITypeDefOrRef, SerializableType> typeCache,
		Stack<MonoType> typeStack,
		[NotNullWhen(true)] out SerializableType? result,
		[NotNullWhen(false)] out string? failureReason)
	{
		if (typeCache.TryGetValue(typeDefinition, out SerializableType? cachedType))
		{
			result = cachedType;
			failureReason = null;
			return true;
		}
		if (typeDefinition.GenericParameters.Count > 0)
		{
			result = null;
			failureReason = "Generic types are not serializable.";
			return false;
		}
		if (typeDefinition.TryGetPrimitiveType(out PrimitiveType primitiveType))
		{
			result = SerializablePrimitiveType.GetOrCreate(primitiveType);
			typeCache.Add(typeDefinition, result);
			failureReason = null;
			return true;
		}

		//Ensure we allocate some initial space so that we have less chance of needing to resize the list.
		List<Field> fields = [];

		//Caching before completion prevents infinite loops.
		MonoType monoType = new(typeDefinition, fields);
		typeCache.Add(typeDefinition, monoType);
		typeStack.Push(monoType);

		if (typeDefinition.BaseType is not null)
		{
			if (!TryCreateSerializableType(typeDefinition.BaseType.ToTypeSignature(), typeCache, typeStack, out SerializableType? baseType, out failureReason))
			{
				typeCache.Remove(typeDefinition);
				typeStack.Pop();
				result = null;
				return false;
			}
			else
			{
				fields.EnsureCapacity(baseType.Fields.Count + typeDefinition.Fields.Count);
				fields.AddRange(baseType.Fields);
			}
		}
		else
		{
			fields.EnsureCapacity(typeDefinition.Fields.Count);
		}

		if (TryCreateSerializableFields(typeStack, monoType, fields, GetFieldsInType(typeDefinition), typeCache, out failureReason))
		{
			monoType.SetDepth();
			typeStack.Pop();
			result = monoType;
			return true;
		}
		else
		{
			typeCache.Remove(typeDefinition);
			typeStack.Pop();
			result = null;
			return false;
		}
	}

	private bool TryCreateSerializableType(
		GenericInstanceTypeSignature genericInst,
		Dictionary<ITypeDefOrRef, SerializableType> typeCache,
		Stack<MonoType> typeStack,
		[NotNullWhen(true)] out SerializableType? result,
		[NotNullWhen(false)] out string? failureReason)
	{
		ITypeDefOrRef typeCacheKey = genericInst.ToTypeDefOrRef();
		if (typeCache.TryGetValue(typeCacheKey, out SerializableType? cachedType))
		{
			result = cachedType;
			failureReason = null;
			return true;
		}

		List<Field> fields = [];

		MonoType monoType = new(genericInst.GenericType, fields);
		typeCache.Add(typeCacheKey, monoType);
		typeStack.Push(monoType);

		if (!TryGetBaseType(genericInst, out TypeSignature? baseType))
		{
			typeCache.Remove(typeCacheKey);
			typeStack.Pop();
			result = null;
			failureReason = $"Failed to resolve base type of {genericInst.FullName}.";
			return false;
		}
		else if (baseType is not null)
		{
			if (!TryCreateSerializableType(baseType, typeCache, typeStack, out SerializableType? baseMonoType, out failureReason))
			{
				typeCache.Remove(typeCacheKey);
				typeStack.Pop();
				result = null;
				return false;
			}
			else
			{
				fields.EnsureCapacity(baseMonoType.Fields.Count + genericInst.GenericType.Resolve()!.Fields.Count);
				fields.AddRange(baseMonoType.Fields);
			}
		}
		else
		{
			fields.EnsureCapacity(genericInst.GenericType.Resolve()!.Fields.Count);
		}

		if (TryCreateSerializableFields(typeStack, monoType, fields, GetFieldsInType(genericInst), typeCache, out failureReason))
		{
			monoType.SetDepth();
			typeStack.Pop();
			result = monoType;
			return true;
		}
		else
		{
			typeCache.Remove(typeCacheKey);
			typeStack.Pop();
			result = null;
			return false;
		}
	}

	private bool TryCreateSerializableFields(
		Stack<MonoType> typeStack,
		MonoType monoType,
		List<Field> fields,
		IEnumerable<(FieldDefinition, TypeSignature)> enumerable,
		Dictionary<ITypeDefOrRef, SerializableType> typeCache,
		[NotNullWhen(false)] out string? failureReason)
	{
		foreach ((FieldDefinition, TypeSignature) pair in enumerable)
		{
			(FieldDefinition fieldDefinition, TypeSignature fieldType) = pair;
			if (WillUnitySerialize(fieldDefinition, fieldType))
			{
				if (fieldDefinition.HasSerializeReferenceAttribute())
				{
					failureReason = $"{fieldDefinition.DeclaringType?.FullName}.{fieldDefinition.Name} uses the [SerializeReference] attribute, which is currently not supported.";
					return false;
				}

				int arrayDepth = 0;
				if (fieldDefinition.HasFixedBufferAttribute())
				{
					fieldType = fieldDefinition.GetFixedBufferElementType();
					arrayDepth = 1;
				}

				if (fieldType is CustomModifierTypeSignature customModifierType)
				{
					fieldType = customModifierType.BaseType;
				}

				if (TryCreateSerializableField(typeStack, fieldDefinition.Name ?? "", fieldType, arrayDepth, typeCache, out Field field, out failureReason))
				{
					if (monoType.IsCyclicReference(field.Type))
					{
						// Infinite recursion disqualifies a field from serialization.
					}
					else if (!field.Type.IsMaxDepthKnown)
					{
						// New cycle reference detected.
						List<MonoType> cycleList = new(typeStack.Count);
						foreach (MonoType monoTypeInStack in typeStack)
						{
							cycleList.Add(monoTypeInStack);
							if (monoTypeInStack == field.Type)
							{
								break;
							}
						}

						for (int i = 0; i < cycleList.Count; i++)
						{
							for (int j = 0; j <= i; j++)
							{
								SerializableType type1 = cycleList[i];
								SerializableType type2 = cycleList[j];
								type1.AddCyclicReference(type2);
								type2.AddCyclicReference(type1);
							}
						}
					}
					else
					{
						fields.Add(field);
					}
				}
				else
				{
					return false;
				}
			}
		}
		failureReason = null;
		return true;
	}

	private bool TryCreateSerializableField(
		Stack<MonoType> typeStack,
		string name,
		TypeSignature typeSignature,
		int arrayDepth,
		Dictionary<ITypeDefOrRef, SerializableType> typeCache,
		out Field result,
		[NotNullWhen(false)] out string? failureReason)
	{
		switch (typeSignature)
		{
			case TypeDefOrRefSignature typeDefOrRefSignature:
				TypeDefinition typeDefinition = typeDefOrRefSignature.Type.CheckedResolve();
				SerializableType fieldType;
				if (typeDefinition.IsEnum)
				{
					CorLibTypeSignature enumValueType = (CorLibTypeSignature?)typeDefinition.GetEnumUnderlyingType() ?? throw new("Failed to resolve enum underlying type.");
					PrimitiveType primitiveType = enumValueType.ToPrimitiveType();
					fieldType = SerializablePrimitiveType.GetOrCreate(primitiveType);
				}
				else if (typeDefinition.InheritsFromObject())
				{
					fieldType = SerializablePointerType.Shared;
				}
				else if (typeCache.TryGetValue(typeDefinition, out SerializableType? cachedMonoType))
				{
					//This needs to come after the InheritsFromObject check so that those fields get properly converted into PPtr assets.
					fieldType = cachedMonoType;
				}
				else if (TryCreateSerializableType(typeDefinition, typeCache, typeStack, out SerializableType? monoType, out failureReason))
				{
					fieldType = monoType;
				}
				else
				{
					result = default;
					return false;
				}

				result = new Field(fieldType, arrayDepth, name, true);
				failureReason = null;
				return true;

			case CorLibTypeSignature corLibTypeSignature:
				result = new Field(SerializablePrimitiveType.GetOrCreate(corLibTypeSignature.ToPrimitiveType()), arrayDepth, name, true);
				failureReason = null;
				return true;

			case SzArrayTypeSignature szArrayTypeSignature:
				return TryCreateSerializableField(typeStack, name, szArrayTypeSignature.BaseType, arrayDepth + 1, typeCache, out result, out failureReason);

			case GenericInstanceTypeSignature genericInstanceTypeSignature:
				if (genericInstanceTypeSignature.InheritsFromObject())
				{
					result = new Field(SerializablePointerType.Shared, arrayDepth, name, true);
					failureReason = null;
					return true;
				}
				else if (typeCache.TryGetValue(genericInstanceTypeSignature.ToTypeDefOrRef(), out SerializableType? cachedGenericMonoType))
				{
					result = new Field(cachedGenericMonoType, arrayDepth, name, true);
					failureReason = null;
					return true;
				}
				else if (genericInstanceTypeSignature.GenericType is { Namespace.Value: "System.Collections.Generic", Name.Value: "List`1" })
				{
					return TryCreateSerializableField(typeStack, name, genericInstanceTypeSignature.TypeArguments[0], arrayDepth + 1, typeCache, out result, out failureReason);
				}
				else if (TryCreateSerializableType(genericInstanceTypeSignature, typeCache, typeStack, out SerializableType? monoType, out failureReason))
				{
					result = new(monoType, arrayDepth, name, true);
					return true;
				}
				else
				{
					result = default;
					return false;
				}

			default:
				result = default;
				failureReason = $"{typeSignature.FullName} not supported.";
				return false;
		}
	}

	private static bool TryGetBaseType(GenericInstanceTypeSignature genericInstanceType, out TypeSignature? baseType)
	{
		TypeDefinition? typeDefinition = genericInstanceType.GenericType.Resolve();
		if (typeDefinition is null)
		{
			baseType = null;
			return false;
		}

		baseType = typeDefinition.BaseType?.ToTypeSignature().InstantiateGenericTypes(new GenericContext(genericInstanceType, null));
		return true;
	}

	private static IEnumerable<(FieldDefinition, TypeSignature)> GetFieldsInType(TypeDefinition typeDefinition)
	{
		return typeDefinition.Fields.Select(field =>
		{
			TypeSignature fieldType = field.Signature!.FieldType;
			return (field, fieldType);
		});
	}

	private static IEnumerable<(FieldDefinition, TypeSignature)> GetFieldsInType(GenericInstanceTypeSignature genericInst)
	{
		TypeDefinition? typeDefinition = genericInst.Resolve();
		if (typeDefinition is null)
		{
			return [];
		}
		return typeDefinition.Fields.Select(field =>
		{
			TypeSignature fieldType = field.Signature!.FieldType;
			GenericContext genericContext = new GenericContext(genericInst, null);
			TypeSignature instanceTypeSignature = fieldType.InstantiateGenericTypes(genericContext);
			return (field, instanceTypeSignature);
		});
	}
}

```

`Source/AssetRipper.SerializationLogic/MonoType.cs`:

```cs
using System.Diagnostics;

namespace AssetRipper.SerializationLogic;

internal sealed class MonoType : SerializableType
{
	private MonoType(ITypeDefOrRef type) : base(type.Namespace ?? "", PrimitiveType.Complex, type.Name ?? "")
	{
	}

	internal MonoType(ITypeDefOrRef type, IReadOnlyList<Field> fields) : this(type)
	{
		Fields = fields;
	}

	internal void SetDepth()
	{
		Debug.Assert(IsMaxDepthKnown == false, "The depth of this type is already known.");
		int maxDepth = 0;
		foreach (Field field in Fields)
		{
			if (field.Type.IsMaxDepthKnown)
			{
				maxDepth = Math.Max(maxDepth, field.Type.MaxDepth + 1);
			}
			else
			{
				maxDepth = -1;
				break;
			}
		}
		MaxDepth = maxDepth;
	}
}

```

`Source/AssetRipper.SerializationLogic/MonoUtils.cs`:

```cs
namespace AssetRipper.SerializationLogic;

public static class MonoUtils
{
	#region Constants
	public const string ObjectName = "Object";
	public const string CObjectName = "object";
	public const string ValueType = "ValueType";
	public const string VoidName = "Void";
	public const string CVoidName = "void";
	public const string BooleanName = "Boolean";
	public const string BoolName = "bool";
	public const string IntPtrName = "IntPtr";
	public const string UIntPtrName = "UIntPtr";
	public const string CharName = "Char";
	public const string CCharName = "char";
	public const string SByteName = "SByte";
	public const string CSByteName = "sbyte";
	public const string ByteName = "Byte";
	public const string CByteName = "byte";
	public const string Int16Name = "Int16";
	public const string ShortName = "short";
	public const string UInt16Name = "UInt16";
	public const string UShortName = "ushort";
	public const string Int32Name = "Int32";
	public const string IntName = "int";
	public const string UInt32Name = "UInt32";
	public const string UIntName = "uint";
	public const string Int64Name = "Int64";
	public const string LongName = "long";
	public const string UInt64Name = "UInt64";
	public const string ULongName = "ulong";
	public const string HalfName = "Half";
	public const string SingleName = "Single";
	public const string FloatName = "float";
	public const string DoubleName = "Double";
	public const string CDoubleName = "double";
	public const string StringName = "String";
	public const string CStringName = "string";

	public const string SystemNamespace = "System";
	public const string SystemCollectionGenericNamespace = "System.Collections.Generic";
	public const string UnityEngineNamespace = "UnityEngine";
	public const string UnityEngineRenderingNamespace = "UnityEngine.Rendering";
	public const string CompilerServicesNamespace = "System.Runtime.CompilerServices";

	public const string CompilerGeneratedName = "CompilerGeneratedAttribute";
	private const string EnumValueFieldName = "value__";

	public const string GuidName = "GUID";
	public const string Hash128Name = "Hash128";

	public const string Vector2Name = "Vector2";
	public const string Vector2IntName = "Vector2Int";
	public const string Vector3Name = "Vector3";
	public const string Vector3IntName = "Vector3Int";
	public const string Vector4Name = "Vector4";
	public const string RectName = "Rect";
	public const string BoundsName = "Bounds";
	public const string BoundsIntName = "BoundsInt";
	public const string QuaternionName = "Quaternion";
	public const string Matrix4x4Name = "Matrix4x4";
	public const string ColorName = "Color";
	public const string Color32Name = "Color32";
	public const string LayerMaskName = "LayerMask";
	public const string FloatCurveName = "FloatCurve";
	public const string Vector3CurveName = "Vector3Curve";
	public const string QuaternionCurveName = "QuaternionCurve";
	public const string PPtrCurveName = "PPtrCurve";
	public const string AnimationCurveName = "AnimationCurve";
	public const string GradientName = "Gradient";
	public const string RectOffsetName = "RectOffset";
	public const string GUIStyleName = "GUIStyle";
	public const string PropertyNameName = "PropertyName";
	public const string SphericalHarmonicsL2Name = "SphericalHarmonicsL2";

	private const string MulticastDelegateName = "MulticastDelegate";
	private const string ListName = "List`1";
	private const string ExposedReferenceName = "ExposedReference`1";

	private const string ScriptableObjectName = "ScriptableObject";
	private const string ComponentName = "Component";
	private const string BehaviourName = "Behaviour";
	private const string MonoBehaviourName = "MonoBehaviour";

	#endregion

	#region Boolean ITypeDefOrRef Methods
	public static bool IsPrimitive(ITypeDefOrRef type) => IsPrimitive(type.Namespace, type.Name);
	public static bool IsPrimitive(string? @namespace, string? name)
	{
		if (@namespace == SystemNamespace)
		{
			switch (name)
			{
				case VoidName:
				case CVoidName:
				case BooleanName:
				case BoolName:
				case SByteName:
				case CSByteName:
				case ByteName:
				case CByteName:
				case CharName:
				case CCharName:
				case Int16Name:
				case ShortName:
				case UInt16Name:
				case UShortName:
				case Int32Name:
				case IntName:
				case UInt32Name:
				case UIntName:
				case Int64Name:
				case LongName:
				case UInt64Name:
				case ULongName:
				case SingleName:
				case FloatName:
				case DoubleName:
				case CDoubleName:
					return true;
			}
		}
		return false;
	}

	public static bool IsObject(ITypeDefOrRef type) => IsObject(type.Namespace, type.Name);
	public static bool IsObject(string? @namespace, string? name)
	{
		return @namespace == SystemNamespace && (name == ObjectName || name == CObjectName);
	}

	public static bool IsList(ITypeDefOrRef type) => IsList(type.Namespace, type.Name);
	public static bool IsList(string? @namespace, string? name)
	{
		return @namespace == SystemCollectionGenericNamespace && name == ListName;
	}

	public static bool IsEngineObject(ITypeDefOrRef type) => IsEngineObject(type.Namespace, type.Name);
	public static bool IsEngineObject(string? @namespace, string? name)
	{
		return @namespace == UnityEngineNamespace && name == ObjectName;
	}

	public static bool IsScriptableObject(ITypeDefOrRef type) => IsScriptableObject(type.Namespace, type.Name);
	public static bool IsScriptableObject(string? @namespace, string? name)
	{
		return @namespace == UnityEngineNamespace && name == ScriptableObjectName;
	}

	public static bool IsComponent(ITypeDefOrRef type) => IsComponent(type.Namespace, type.Name);
	public static bool IsComponent(string? @namespace, string? name)
	{
		return @namespace == UnityEngineNamespace && name == ComponentName;
	}

	public static bool IsBehaviour(ITypeDefOrRef type) => IsBehaviour(type.Namespace, type.Name);
	public static bool IsBehaviour(string? @namespace, string? name)
	{
		return @namespace == UnityEngineNamespace && name == BehaviourName;
	}

	public static bool IsMonoBehaviour(ITypeDefOrRef type) => IsMonoBehaviour(type.Namespace, type.Name);
	public static bool IsMonoBehaviour(string? @namespace, string? name)
	{
		return @namespace == UnityEngineNamespace && name == MonoBehaviourName;
	}

	public static bool IsEngineStruct(ITypeDefOrRef type) => IsEngineStruct(type.Namespace, type.Name);
	public static bool IsEngineStruct(string? @namespace, string? name)
	{
		if (@namespace == UnityEngineNamespace)
		{
			switch (name)
			{
				case GuidName:
				case Hash128Name:
				case Vector2Name:
				case Vector2IntName:
				case Vector3Name:
				case Vector3IntName:
				case Vector4Name:
				case RectName:
				case BoundsName:
				case BoundsIntName:
				case QuaternionName:
				case Matrix4x4Name:
				case ColorName:
				case Color32Name:
				case LayerMaskName:
				case AnimationCurveName:
				case GradientName:
				case RectOffsetName:
				case GUIStyleName:
					return true;

				case PropertyNameName:
					return true;
			}
		}
		else if (@namespace == UnityEngineRenderingNamespace)
		{
			return name == SphericalHarmonicsL2Name;
		}
		return false;
	}

	public static bool IsExposedReference(ITypeDefOrRef type) => IsExposedReference(type.Namespace, type.Name);
	public static bool IsExposedReference(string? @namespace, string? name)
	{
		return @namespace == UnityEngineNamespace && name == ExposedReferenceName;
	}

	public static bool IsPrime(ITypeDefOrRef type) => IsPrime(type.Namespace, type.Name);
	public static bool IsPrime(string? @namespace, string? name)
	{
		if (IsObject(@namespace, name))
		{
			return true;
		}

		if (IsMonoPrime(@namespace, name))
		{
			return true;
		}

		return false;
	}

	public static bool IsMonoPrime(ITypeDefOrRef type) => IsMonoPrime(type.Namespace, type.Name);
	public static bool IsMonoPrime(string? @namespace, string? name)
	{
		if (IsMonoBehaviour(@namespace, name))
		{
			return true;
		}

		if (IsBehaviour(@namespace, name))
		{
			return true;
		}

		if (IsComponent(@namespace, name))
		{
			return true;
		}

		if (IsEngineObject(@namespace, name))
		{
			return true;
		}

		return false;
	}

	public static bool IsBuiltinGeneric(ITypeDefOrRef type) => IsBuiltinGeneric(type.Namespace, type.Name);
	public static bool IsBuiltinGeneric(string? @namespace, string? name)
	{
		return IsList(@namespace, name) || IsExposedReference(@namespace, name);
	}
	#endregion

	#region Helpers
	public static PrimitiveType ToPrimitiveType(ITypeDefOrRef? type)
	{
		TypeDefinition? definition = type?.Resolve();
		if (definition?.IsEnum ?? false)
		{
			foreach (FieldDefinition field in definition.Fields)
			{
				if (field.Name == EnumValueFieldName)
				{
					type = field.Signature?.FieldType.ToTypeDefOrRef().Resolve();
					break;
				}
			}
		}

		return ToPrimitiveType(type?.Namespace, type?.Name);
	}

	public static PrimitiveType ToPrimitiveType(string? @namespace, string? name)
	{
		if (@namespace == SystemNamespace)
		{
			return name switch
			{
				VoidName => PrimitiveType.Void,
				BooleanName => PrimitiveType.Bool,
				CharName => PrimitiveType.Char,
				SByteName => PrimitiveType.SByte,
				ByteName => PrimitiveType.Byte,
				Int16Name => PrimitiveType.Short,
				UInt16Name => PrimitiveType.UShort,
				Int32Name => PrimitiveType.Int,
				UInt32Name => PrimitiveType.UInt,
				Int64Name => PrimitiveType.Long,
				UInt64Name => PrimitiveType.ULong,
				SingleName => PrimitiveType.Single,
				DoubleName => PrimitiveType.Double,
				StringName => PrimitiveType.String,
				_ => PrimitiveType.Complex,
			};
		}
		return PrimitiveType.Complex;
	}
	#endregion
}

```

`Source/AssetRipper.SerializationLogic/Notes.md`:

```md
# Serialization Notes

https://docs.unity3d.com/Manual/script-Serialization.html

## `[SerializeReference]`

The biggest indicator of `[SerializeReference]` in type trees is that the last node is `ReferencedObjectData data`.

> Compiled with 6000.0.0b15

```
// classID{114}: MonoBehaviour
MonoBehaviour Base // ByteSize{ffffffff}, Index{0}, Version{1}, IsArray{0}, MetaFlag{8000}
	PPtr<GameObject> m_GameObject // ByteSize{c}, Index{1}, Version{1}, IsArray{0}, MetaFlag{41}
		int m_FileID // ByteSize{4}, Index{2}, Version{1}, IsArray{0}, MetaFlag{41}
		SInt64 m_PathID // ByteSize{8}, Index{3}, Version{1}, IsArray{0}, MetaFlag{41}
	UInt8 m_Enabled // ByteSize{1}, Index{4}, Version{1}, IsArray{0}, MetaFlag{4101}
	PPtr<MonoScript> m_Script // ByteSize{c}, Index{5}, Version{1}, IsArray{0}, MetaFlag{0}
		int m_FileID // ByteSize{4}, Index{6}, Version{1}, IsArray{0}, MetaFlag{800001}
		SInt64 m_PathID // ByteSize{8}, Index{7}, Version{1}, IsArray{0}, MetaFlag{800001}
	string m_Name // ByteSize{ffffffff}, Index{8}, Version{1}, IsArray{0}, MetaFlag{88001}
		Array Array // ByteSize{ffffffff}, Index{9}, Version{1}, IsArray{1}, MetaFlag{84001}
			int size // ByteSize{4}, Index{a}, Version{1}, IsArray{0}, MetaFlag{80001}
			char data // ByteSize{1}, Index{b}, Version{1}, IsArray{0}, MetaFlag{80001}
	SerializableClass fieldWithoutAttribute // ByteSize{ffffffff}, Index{c}, Version{1}, IsArray{0}, MetaFlag{8000}
		string key // ByteSize{ffffffff}, Index{d}, Version{1}, IsArray{0}, MetaFlag{8000}
			Array Array // ByteSize{ffffffff}, Index{e}, Version{1}, IsArray{1}, MetaFlag{4001}
				int size // ByteSize{4}, Index{f}, Version{1}, IsArray{0}, MetaFlag{1}
				char data // ByteSize{1}, Index{10}, Version{1}, IsArray{0}, MetaFlag{1}
		int value // ByteSize{4}, Index{11}, Version{1}, IsArray{0}, MetaFlag{0}
	managedReference fieldWithAttribute // ByteSize{8}, Index{12}, Version{1}, IsArray{2}, MetaFlag{0}
		SInt64 rid // ByteSize{8}, Index{13}, Version{1}, IsArray{0}, MetaFlag{0}
	SerializableClass listWithoutAttribute // ByteSize{ffffffff}, Index{14}, Version{1}, IsArray{0}, MetaFlag{8000}
		Array Array // ByteSize{ffffffff}, Index{15}, Version{1}, IsArray{1}, MetaFlag{8000}
			int size // ByteSize{4}, Index{16}, Version{1}, IsArray{0}, MetaFlag{0}
			SerializableClass data // ByteSize{ffffffff}, Index{17}, Version{1}, IsArray{0}, MetaFlag{8000}
				string key // ByteSize{ffffffff}, Index{18}, Version{1}, IsArray{0}, MetaFlag{8000}
					Array Array // ByteSize{ffffffff}, Index{19}, Version{1}, IsArray{1}, MetaFlag{4001}
						int size // ByteSize{4}, Index{1a}, Version{1}, IsArray{0}, MetaFlag{1}
						char data // ByteSize{1}, Index{1b}, Version{1}, IsArray{0}, MetaFlag{1}
				int value // ByteSize{4}, Index{1c}, Version{1}, IsArray{0}, MetaFlag{0}
	SerializableClass listWithAttribute // ByteSize{ffffffff}, Index{1d}, Version{1}, IsArray{8}, MetaFlag{0}
		Array Array // ByteSize{ffffffff}, Index{1e}, Version{1}, IsArray{1}, MetaFlag{0}
			int size // ByteSize{4}, Index{1f}, Version{1}, IsArray{0}, MetaFlag{0}
			managedRefArrayItem data // ByteSize{8}, Index{20}, Version{1}, IsArray{2}, MetaFlag{0}
				SInt64 rid // ByteSize{8}, Index{21}, Version{1}, IsArray{0}, MetaFlag{0}
	ManagedReferencesRegistry references // ByteSize{ffffffff}, Index{22}, Version{1}, IsArray{4}, MetaFlag{8001}
		int version // ByteSize{4}, Index{23}, Version{1}, IsArray{0}, MetaFlag{1}
		vector RefIds // ByteSize{ffffffff}, Index{24}, Version{1}, IsArray{0}, MetaFlag{8001}
			Array Array // ByteSize{ffffffff}, Index{25}, Version{1}, IsArray{1}, MetaFlag{c001}
				int size // ByteSize{4}, Index{26}, Version{1}, IsArray{0}, MetaFlag{1}
				ReferencedObject data // ByteSize{ffffffff}, Index{27}, Version{1}, IsArray{0}, MetaFlag{8001}
					SInt64 rid // ByteSize{8}, Index{28}, Version{1}, IsArray{0}, MetaFlag{1}
					ReferencedManagedType type // ByteSize{ffffffff}, Index{29}, Version{1}, IsArray{0}, MetaFlag{208001}
						string class // ByteSize{ffffffff}, Index{2a}, Version{1}, IsArray{0}, MetaFlag{208001}
							Array Array // ByteSize{ffffffff}, Index{2b}, Version{1}, IsArray{1}, MetaFlag{204001}
								int size // ByteSize{4}, Index{2c}, Version{1}, IsArray{0}, MetaFlag{200001}
								char data // ByteSize{1}, Index{2d}, Version{1}, IsArray{0}, MetaFlag{200001}
						string ns // ByteSize{ffffffff}, Index{2e}, Version{1}, IsArray{0}, MetaFlag{208001}
							Array Array // ByteSize{ffffffff}, Index{2f}, Version{1}, IsArray{1}, MetaFlag{204001}
								int size // ByteSize{4}, Index{30}, Version{1}, IsArray{0}, MetaFlag{200001}
								char data // ByteSize{1}, Index{31}, Version{1}, IsArray{0}, MetaFlag{200001}
						string asm // ByteSize{ffffffff}, Index{32}, Version{1}, IsArray{0}, MetaFlag{208001}
							Array Array // ByteSize{ffffffff}, Index{33}, Version{1}, IsArray{1}, MetaFlag{204001}
								int size // ByteSize{4}, Index{34}, Version{1}, IsArray{0}, MetaFlag{200001}
								char data // ByteSize{1}, Index{35}, Version{1}, IsArray{0}, MetaFlag{200001}
					ReferencedObjectData data // ByteSize{0}, Index{36}, Version{1}, IsArray{0}, MetaFlag{1}
```

## Empty Structs

Empty types can still be serializable even though they have no content.

> Compiled with 6000.0.0b15

```
// classID{114}: MonoBehaviour
MonoBehaviour Base // ByteSize{ffffffff}, Index{0}, Version{1}, IsArray{0}, MetaFlag{8000}
	PPtr<GameObject> m_GameObject // ByteSize{c}, Index{1}, Version{1}, IsArray{0}, MetaFlag{41}
		int m_FileID // ByteSize{4}, Index{2}, Version{1}, IsArray{0}, MetaFlag{41}
		SInt64 m_PathID // ByteSize{8}, Index{3}, Version{1}, IsArray{0}, MetaFlag{41}
	UInt8 m_Enabled // ByteSize{1}, Index{4}, Version{1}, IsArray{0}, MetaFlag{4101}
	PPtr<MonoScript> m_Script // ByteSize{c}, Index{5}, Version{1}, IsArray{0}, MetaFlag{0}
		int m_FileID // ByteSize{4}, Index{6}, Version{1}, IsArray{0}, MetaFlag{800001}
		SInt64 m_PathID // ByteSize{8}, Index{7}, Version{1}, IsArray{0}, MetaFlag{800001}
	string m_Name // ByteSize{ffffffff}, Index{8}, Version{1}, IsArray{0}, MetaFlag{88001}
		Array Array // ByteSize{ffffffff}, Index{9}, Version{1}, IsArray{1}, MetaFlag{84001}
			int size // ByteSize{4}, Index{a}, Version{1}, IsArray{0}, MetaFlag{80001}
			char data // ByteSize{1}, Index{b}, Version{1}, IsArray{0}, MetaFlag{80001}
	StructWithFields listOfFields // ByteSize{ffffffff}, Index{c}, Version{1}, IsArray{0}, MetaFlag{8000}
		Array Array // ByteSize{ffffffff}, Index{d}, Version{1}, IsArray{1}, MetaFlag{8000}
			int size // ByteSize{4}, Index{e}, Version{1}, IsArray{0}, MetaFlag{0}
			StructWithFields data // ByteSize{ffffffff}, Index{f}, Version{1}, IsArray{0}, MetaFlag{8000}
				string key // ByteSize{ffffffff}, Index{10}, Version{1}, IsArray{0}, MetaFlag{8000}
					Array Array // ByteSize{ffffffff}, Index{11}, Version{1}, IsArray{1}, MetaFlag{4001}
						int size // ByteSize{4}, Index{12}, Version{1}, IsArray{0}, MetaFlag{1}
						char data // ByteSize{1}, Index{13}, Version{1}, IsArray{0}, MetaFlag{1}
				int value // ByteSize{4}, Index{14}, Version{1}, IsArray{0}, MetaFlag{0}
	EmptyStruct listOfNothing // ByteSize{ffffffff}, Index{15}, Version{1}, IsArray{0}, MetaFlag{0}
		Array Array // ByteSize{ffffffff}, Index{16}, Version{1}, IsArray{1}, MetaFlag{0}
			int size // ByteSize{4}, Index{17}, Version{1}, IsArray{0}, MetaFlag{0}
			EmptyStruct data // ByteSize{0}, Index{18}, Version{1}, IsArray{0}, MetaFlag{0}
	StructWithFields fields // ByteSize{ffffffff}, Index{19}, Version{1}, IsArray{0}, MetaFlag{8000}
		string key // ByteSize{ffffffff}, Index{1a}, Version{1}, IsArray{0}, MetaFlag{8000}
			Array Array // ByteSize{ffffffff}, Index{1b}, Version{1}, IsArray{1}, MetaFlag{4001}
				int size // ByteSize{4}, Index{1c}, Version{1}, IsArray{0}, MetaFlag{1}
				char data // ByteSize{1}, Index{1d}, Version{1}, IsArray{0}, MetaFlag{1}
		int value // ByteSize{4}, Index{1e}, Version{1}, IsArray{0}, MetaFlag{0}
	EmptyStruct nothing // ByteSize{0}, Index{1f}, Version{1}, IsArray{0}, MetaFlag{0}
```
```

`Source/AssetRipper.SerializationLogic/PrimitiveType.cs`:

```cs
using AsmResolver.PE.DotNet.Metadata.Tables;

namespace AssetRipper.SerializationLogic;

public enum PrimitiveType
{
	Void,
	Bool,
	Char,
	SByte,
	Byte,
	Short,
	UShort,
	Int,
	UInt,
	Long,
	ULong,
	Single,
	Double,
	String,
	Pair,
	MapPair,
	Complex,
}
public static class PrimitiveTypeExtensions
{
	public static bool IsCSharpPrimitive(this PrimitiveType _this)
	{
		return _this is PrimitiveType.String || _this.GetSize() > 0;
	}

	public static int GetSize(this PrimitiveType _this)
	{
		switch (_this)
		{
			case PrimitiveType.Void:
				return 0;

			case PrimitiveType.Bool:
			case PrimitiveType.Byte:
			case PrimitiveType.SByte:
				return 1;

			case PrimitiveType.Char:
			case PrimitiveType.Short:
			case PrimitiveType.UShort:
				return 2;

			case PrimitiveType.Int:
			case PrimitiveType.UInt:
			case PrimitiveType.Single:
				return 4;

			case PrimitiveType.Long:
			case PrimitiveType.ULong:
			case PrimitiveType.Double:
				return 8;

			case PrimitiveType.Pair:
			case PrimitiveType.MapPair:
			case PrimitiveType.String:
			case PrimitiveType.Complex:
				return -1;

			default:
				throw new NotSupportedException();
		}
	}

	public static string ToSystemTypeName(this PrimitiveType _this)
	{
		return _this switch
		{
			PrimitiveType.Bool => nameof(Boolean),
			PrimitiveType.Char => nameof(Char),
			PrimitiveType.Byte => nameof(Byte),
			PrimitiveType.SByte => nameof(SByte),
			PrimitiveType.Short => nameof(Int16),
			PrimitiveType.UShort => nameof(UInt16),
			PrimitiveType.Int => nameof(Int32),
			PrimitiveType.UInt => nameof(UInt32),
			PrimitiveType.Long => nameof(Int64),
			PrimitiveType.ULong => nameof(UInt64),
			PrimitiveType.Single => nameof(Single),
			PrimitiveType.Double => nameof(Double),
			PrimitiveType.String => nameof(String),
			_ => throw new NotSupportedException(),
		};
	}

	public static PrimitiveType ToPrimitiveType(this CorLibTypeSignature type)
	{
		return type.ElementType.ToPrimitiveType();
	}

	public static PrimitiveType ToPrimitiveType(this ElementType elementType)
	{
		return elementType switch
		{
			ElementType.Boolean => PrimitiveType.Bool,
			ElementType.Char => PrimitiveType.Char,
			ElementType.I1 => PrimitiveType.SByte,
			ElementType.U1 => PrimitiveType.Byte,
			ElementType.I2 => PrimitiveType.Short,
			ElementType.U2 => PrimitiveType.UShort,
			ElementType.I4 => PrimitiveType.Int,
			ElementType.U4 => PrimitiveType.UInt,
			ElementType.I8 => PrimitiveType.Long,
			ElementType.U8 => PrimitiveType.ULong,
			ElementType.R4 => PrimitiveType.Single,
			ElementType.R8 => PrimitiveType.Double,
			ElementType.String => PrimitiveType.String,
			_ => PrimitiveType.Complex,
		};
	}
}

```

`Source/AssetRipper.SerializationLogic/ResolutionException.cs`:

```cs
namespace AssetRipper.SerializationLogic;

internal class ResolutionException : Exception
{
	public ResolutionException()
	{
	}

	public ResolutionException(IFullNameProvider reference) : base($"Could not resolve {reference.FullName}")
	{
	}
}

```

`Source/AssetRipper.SerializationLogic/SerializablePointerType.cs`:

```cs
namespace AssetRipper.SerializationLogic;

public sealed class SerializablePointerType : SerializableType
{
	public static SerializablePointerType Shared { get; } = new();

	private SerializablePointerType() : base("UnityEngine", PrimitiveType.Complex, "Object")
	{
		MaxDepth = 0;
	}
}

```

`Source/AssetRipper.SerializationLogic/SerializablePrimitiveType.cs`:

```cs
namespace AssetRipper.SerializationLogic;

public sealed class SerializablePrimitiveType : SerializableType
{
	private static readonly Dictionary<PrimitiveType, SerializablePrimitiveType> cache = new();

	private SerializablePrimitiveType(PrimitiveType primitiveType) : base("System", primitiveType, primitiveType.ToSystemTypeName())
	{
		MaxDepth = 0;
	}

	public static SerializablePrimitiveType GetOrCreate(PrimitiveType primitiveType)
	{
		if (!cache.TryGetValue(primitiveType, out SerializablePrimitiveType? result))
		{
			result = new SerializablePrimitiveType(primitiveType);
			cache.Add(primitiveType, result);
		}
		return result;
	}
}

```

`Source/AssetRipper.SerializationLogic/SerializableType.cs`:

```cs
namespace AssetRipper.SerializationLogic;

public abstract class SerializableType
{
	public readonly record struct Field(SerializableType Type, int ArrayDepth, string Name, bool Align)
	{
		public override string? ToString()
		{
			if (Type == null)
			{
				return base.ToString();
			}

			return $"{Type}{string.Concat(Enumerable.Repeat("[]", ArrayDepth))} {Name}";
		}

		public bool IsArray => ArrayDepth == 1;
	}

	protected SerializableType(string? @namespace, PrimitiveType type, string name)
	{
		ArgumentNullException.ThrowIfNull(name);
		Namespace = @namespace;
		Type = type;
		Name = name;
	}

	public bool IsPrimitive()
	{
		return Type.IsCSharpPrimitive();
	}

	public bool IsEngineStruct()
	{
		return MonoUtils.IsEngineStruct(Namespace, Name);
	}

	public bool IsEnginePointer()
	{
		return MonoUtils.IsObject(Namespace, Name) || MonoUtils.IsMonoPrime(Namespace, Name);
	}

	public override string ToString() => FullName;

	public string FullName => string.IsNullOrEmpty(Namespace) ? Name : $"{Namespace}.{Name}";

	public string? Namespace { get; }
	public PrimitiveType Type { get; }
	public string Name { get; }
	public IReadOnlyList<Field> Fields { get; protected set; } = [];
	public virtual int Version => 1;
	public virtual bool FlowMappedInYaml => false;
	/// <summary>
	/// The maximum depth of the structure.
	/// </summary>
	/// <remarks>
	/// A type with no fields has a depth of 0, such as a primitive type, including strings.<br/>
	/// A type with a single field has a depth of 1 + the depth of that field.<br/>
	/// Arrays do not increase depth. For example, a type with a string[] field has a depth of 1, not 2.<br/>
	/// Despite technically having two numeric fields, PPtrs are treated as primitive types with a depth of 0.<br/>
	/// A negative value means that the depth is not yet known.
	/// </remarks>
	public int MaxDepth { get; protected set; } = -1;
	public bool IsMaxDepthKnown => MaxDepth >= 0;
	private HashSet<SerializableType>? _cyclicReferences;

	internal protected void AddCyclicReference(SerializableType other)
	{
		_cyclicReferences ??= [];
		_cyclicReferences.Add(other);
	}

	internal protected bool IsCyclicReference(SerializableType other)
	{
		return _cyclicReferences is not null && _cyclicReferences.Contains(other);
	}
}

```

`Source/AssetRipper.SerializationLogic/Usings.cs`:

```cs
global using AsmResolver.DotNet;
global using AsmResolver.DotNet.Signatures;

```

`Source/AssetRipper.SourceGenerated.Extensions.SourceGenerator/AssetRipper.SourceGenerated.Extensions.SourceGenerator.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>netstandard2.0</TargetFramework>
		<IsAotCompatible>false</IsAotCompatible>
		<AppendTargetFrameworkToOutputPath>true</AppendTargetFrameworkToOutputPath>
		<EnforceExtendedAnalyzerRules>true</EnforceExtendedAnalyzerRules>
		<PolySharpExcludeGeneratedTypes>System.Runtime.CompilerServices.ModuleInitializerAttribute</PolySharpExcludeGeneratedTypes>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="4.14.0">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
		<PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="5.0.0" />
		<PackageReference Include="PolySharp" Version="1.15.0">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
		<PackageReference Include="SourceGenerator.Foundations" Version="2.0.14" />
	</ItemGroup>

	<ItemGroup>
		<!-- Generator dependencies -->
		<PackageReference Include="AssetRipper.Text.SourceGeneration" Version="1.2.3" PrivateAssets="all" GeneratePathProperty="true" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.SourceGenerated.Extensions.SourceGenerator/ClassIDType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.SourceGenerator;

// Copy-pasted from decompilation and removed abstract classes
public enum ClassIDType
{
	GameObject = 1,
	Component = 2,
	Transform = 4,
	TimeManager = 5,
	AudioManager = 11,
	ParticleAnimator = 12,
	InputManager = 13,
	EllipsoidParticleEmitter = 15,
	Pipeline = 17,
	Physics2DSettings = 19,
	Camera = 20,
	Material = 21,
	MeshRenderer = 23,
	ParticleRenderer = 26,
	Texture2D = 28,
	OcclusionCullingSettings = 29,
	GraphicsSettings = 30,
	MeshFilter = 33,
	OcclusionPortal = 41,
	Mesh = 43,
	Skybox = 45,
	QualitySettings = 47,
	Shader = 48,
	TextAsset = 49,
	Rigidbody2D = 50,
	NotificationManager = 52,
	Rigidbody = 54,
	PhysicsManager = 55,
	CircleCollider2D = 58,
	HingeJoint = 59,
	PolygonCollider2D = 60,
	BoxCollider2D = 61,
	PhysicsMaterial2D = 62,
	MeshCollider = 64,
	BoxCollider = 65,
	CompositeCollider2D = 66,
	EdgeCollider2D = 68,
	CapsuleCollider2D = 70,
	AnimationManager = 71,
	ComputeShader = 72,
	AnimationClip = 74,
	ConstantForce = 75,
	WorldParticleCollider = 76,
	TagManager = 78,
	AudioListener = 81,
	AudioSource = 82,
	AudioClip = 83,
	RenderTexture = 84,
	CustomRenderTexture = 86,
	MeshParticleEmitter = 87,
	Cubemap = 89,
	Avatar = 90,
	AnimatorController = 91,
	GUILayer = 92,
	RuntimeAnimatorController = 93,
	ShaderNameRegistry = 94,
	Animator = 95,
	TrailRenderer = 96,
	DelayedCallManager = 98,
	TextMesh = 102,
	RenderSettings = 104,
	Light = 108,
	ShaderInclude = 109,
	Animation = 111,
	MonoBehaviour = 114,
	MonoScript = 115,
	MonoManager = 116,
	Texture3D = 117,
	NewAnimationTrack = 118,
	Projector = 119,
	LineRenderer = 120,
	Flare = 121,
	Halo = 122,
	LensFlare = 123,
	FlareLayer = 124,
	HaloLayer = 125,
	NavMeshProjectSettings = 126,
	HaloManager = 127,
	Font = 128,
	GUITexture = 131,
	GUIText = 132,
	PhysicsMaterial = 134,
	SphereCollider = 135,
	CapsuleCollider = 136,
	SkinnedMeshRenderer = 137,
	FixedJoint = 138,
	RaycastCollider = 140,
	BuildSettings = 141,
	AssetBundle = 142,
	CharacterController = 143,
	CharacterJoint = 144,
	SpringJoint = 145,
	WheelCollider = 146,
	ResourceManager = 147,
	NetworkView = 148,
	NetworkManager = 149,
	PreloadData = 150,
	MovieTexture = 152,
	ConfigurableJoint = 153,
	TerrainCollider = 154,
	MasterServerInterface = 155,
	TerrainData = 156,
	LightmapSettings = 157,
	WebCamTexture = 158,
	EditorSettings = 159,
	InteractiveCloth = 160,
	ClothRenderer = 161,
	EditorUserSettings = 162,
	SkinnedCloth = 163,
	AudioReverbFilter = 164,
	AudioHighPassFilter = 165,
	AudioChorusFilter = 166,
	AudioReverbZone = 167,
	AudioEchoFilter = 168,
	AudioLowPassFilter = 169,
	AudioDistortionFilter = 170,
	SparseTexture = 171,
	WindZone = 182,
	Cloth = 183,
	SubstanceArchive = 184,
	ProceduralMaterial = 185,
	ProceduralTexture = 186,
	Texture2DArray = 187,
	CubemapArray = 188,
	OffMeshLink = 191,
	OcclusionArea = 192,
	Tree = 193,
	NavMeshData_194 = 194,
	NavMeshAgent = 195,
	NavMeshSettings = 196,
	LightProbes_197 = 197,
	ParticleSystem = 198,
	ParticleSystemRenderer = 199,
	ShaderVariantCollection = 200,
	LODGroup = 205,
	BlendTree = 206,
	NavMeshObstacle = 208,
	SortingGroup = 210,
	SpriteRenderer = 212,
	Sprite = 213,
	CachedSpriteAtlas = 214,
	ReflectionProbe = 215,
	Terrain = 218,
	LightProbeGroup = 220,
	AnimatorOverrideController = 221,
	CanvasRenderer = 222,
	Canvas = 223,
	RectTransform = 224,
	CanvasGroup = 225,
	BillboardAsset = 226,
	BillboardRenderer = 227,
	SpeedTreeWindAsset = 228,
	SpringJoint2D = 231,
	DistanceJoint2D = 232,
	HingeJoint2D = 233,
	SliderJoint2D = 234,
	WheelJoint2D = 235,
	ClusterInputManager = 236,
	NavMeshData_238 = 238,
	AudioMixer = 240,
	AudioMixerController = 241,
	AudioMixerGroupController = 243,
	AudioMixerEffectController = 244,
	AudioMixerSnapshotController = 245,
	ConstantForce2D = 247,
	AreaEffector2D = 249,
	PointEffector2D = 250,
	PlatformEffector2D = 251,
	SurfaceEffector2D = 252,
	BuoyancyEffector2D = 253,
	RelativeJoint2D = 254,
	FixedJoint2D = 255,
	FrictionJoint2D = 256,
	TargetJoint2D = 257,
	LightProbes_258 = 258,
	LightProbeProxyVolume = 259,
	SampleClip = 271,
	AudioMixerSnapshot = 272,
	AudioMixerGroup = 273,
	NScreenBridge = 280,
	AssetBundleManifest = 290,
	UnityAdsManager = 292,
	RuntimeInitializeOnLoadManager = 300,
	CloudWebServicesManager = 301,
	CloudServiceHandlerBehaviour = 302,
	UnityAnalyticsManager = 303,
	CrashReportManager = 304,
	PerformanceReportingManager = 305,
	UnityConnectSettings = 310,
	AvatarMask_319 = 319,
	PlayableDirector = 320,
	VideoClip_327 = 327,
	VideoPlayer = 328,
	VideoClip_329 = 329,
	ParticleSystemForceField = 330,
	SpriteMask = 331,
	WorldAnchor = 362,
	OcclusionCullingData = 363,
	MarshallingTestObject = 900,
	PrefabInstance = 1001,
	EditorExtensionImpl = 1002,
	AssetDatabaseV1 = 1004,
	Mesh3DSImporter = 1005,
	TextureImporter = 1006,
	ShaderImporter = 1007,
	ComputeShaderImporter = 1008,
	AvatarMask_1011 = 1011,
	AvatarSkeletonMask = 1012,
	AudioImporter = 1020,
	HierarchyState = 1026,
	GUIDSerializer = 1027,
	AssetMetaData = 1028,
	DefaultAsset = 1029,
	DefaultImporter = 1030,
	TextScriptImporter = 1031,
	SceneAsset = 1032,
	NativeFormatImporter = 1034,
	MonoImporter = 1035,
	AssetServerCache = 1037,
	LibraryAssetImporter = 1038,
	FBXImporter = 1041,
	TrueTypeFontImporter = 1042,
	MovieImporter = 1044,
	EditorBuildSettings = 1045,
	DDSImporter = 1046,
	InspectorExpandedState = 1048,
	AnnotationManager = 1049,
	PluginImporter = 1050,
	EditorUserBuildSettings = 1051,
	PVRImporter = 1052,
	ASTCImporter = 1053,
	KTXImporter = 1054,
	IHVImageFormatImporter = 1055,
	AnimatorStateTransition = 1101,
	AnimatorState = 1102,
	HumanTemplate = 1105,
	AnimatorStateMachine = 1107,
	PreviewAnimationClip = 1108,
	AnimatorTransition = 1109,
	SpeedTreeImporter = 1110,
	AnimatorTransitionBase = 1111,
	SubstanceImporter = 1112,
	LightmapParameters = 1113,
	LightingDataAsset = 1120,
	SketchUpImporter = 1124,
	BuildReport = 1125,
	PackedAssets = 1126,
	VideoClipImporter = 1127,
	StyleSheetImporter = 1128,
	TilemapCollider2D = 19719996,
	ImportLog = 41386430,
	GraphicsStateCollection = 55640938,
	VFXRenderer = 73398921,
	SerializableManagedRefTestClass = 76251197,
	Grid = 156049354,
	ScenesUsingAssets = 156483287,
	ArticulationBody = 171741748,
	Preset = 181963792,
	EmptyObject = 277625683,
	TestObjectWithSpecialLayoutOne = 293259124,
	AssemblyDefinitionReferenceImporter = 294290339,
	SiblingDerived = 334799969,
	TestObjectWithSerializedMapStringNonAlignedStruct = 342846651,
	AudioResource = 355983997,
	SubDerived = 367388927,
	AssetImportInProgressProxy = 369655926,
	PluginBuildInfo = 382020655,
	MemorySettings = 387306366,
	BuildMetaDataImporter = 403037116,
	BuildInstructionImporter = 403037117,
	EditorProjectAccess = 426301858,
	PrefabImporter = 468431735,
	TestObjectWithSerializedArray = 478637458,
	TestObjectWithSerializedAnimationCurve = 478637459,
	TilemapRenderer = 483693784,
	ScriptableCamera = 488575907,
	SpriteAtlasAsset = 612988286,
	SpriteAtlasDatabase = 638013454,
	AudioBuildInfo = 641289076,
	CachedSpriteAtlasRuntimeData = 644342135,
	MultiplayerManager = 655991488,
	AssemblyDefinitionReferenceAsset = 662584278,
	BuiltAssetBundleInfoSet = 668709126,
	SpriteAtlas = 687078895,
	DifferentMarshallingTestObject = 702665669,
	RayTracingShaderImporter = 747330370,
	BuildArchiveImporter = 780535461,
	PreviewImporter = 815301076,
	RayTracingShader = 825902497,
	LightingSettings = 850595691,
	PlatformModuleSetup = 877146078,
	VersionControlSettings = 890905787,
	CustomCollider2D = 893571522,
	AimConstraint = 895512359,
	VFXManager = 937362698,
	RoslynAnalyzerConfigAsset = 947337230,
	RuleSetFileAsset = 954905827,
	VisualEffectSubgraphOperator = 994735403,
	VisualEffectSubgraphBlock = 994735404,
	Prefab = 1001480554,
	LocalizationImporter = 1027052791,
	Derived = 1091556383,
	PropertyModificationsTargetTestObject = 1111377672,
	ReferencesArtifactGenerator = 1114811875,
	AssemblyDefinitionAsset = 1152215463,
	SceneVisibilityState = 1154873562,
	LookAtConstraint = 1183024399,
	SpriteAtlasImporter = 1210832254,
	MultiArtifactTestImporter = 1223240404,
	AudioContainerElement = 1233149941,
	GameObjectRecorder = 1268269756,
	AudioRandomContainer = 1307931743,
	LightingDataAssetParent = 1325145578,
	PresetManager = 1386491679,
	TestObjectWithSpecialLayoutTwo = 1392443030,
	StreamingManager = 1403656975,
	LowerResBlitTexture = 1480428607,
	VideoBuildInfo = 1521398425,
	C4DImporter = 1541671625,
	StreamingController = 1542919678,
	ShaderContainer = 1557264870,
	RenderPassAttachment = 1571458007,
	RoslynAdditionalFileAsset = 1597193336,
	TestObjectVectorPairStringBool = 1628831178,
	RoslynAdditionalFileImporter = 1642787288,
	MultiplayerRolesData = 1652712579,
	SceneRoots = 1660057539,
	BrokenPrefabAsset = 1731078267,
	AndroidAssetPackImporter = 1736697216,
	VulkanDeviceFilterLists = 1740304944,
	AssemblyDefinitionImporter = 1766753193,
	ParentConstraint = 1773428102,
	RuleSetFileImporter = 1777034230,
	PositionConstraint = 1818360608,
	RotationConstraint = 1818360609,
	ScaleConstraint = 1818360610,
	Tilemap = 1839735485,
	PackageManifest = 1896753125,
	PackageManifestImporter = 1896753126,
	RoslynAnalyzerConfigImporter = 1903396204,
	UIRenderer = 1931382933,
	TerrainLayer = 1953259897,
	SpriteShapeRenderer = 1971053207,
	NativeObjectType = 1977754360,
	TestObjectWithSerializedMapStringBool = 1981279845,
	SerializableManagedHost = 1995898324,
	VisualEffectAsset = 2058629509,
	VisualEffectImporter = 2058629510,
	VisualEffectResource = 2058629511,
	VisualEffect = 2083052967,
	LocalizationAsset = 2083778819,
	ScriptedImporter = 2089858483,
	ShaderIncludeImporter = 2103361453,
	TilemapEditorUserSettings = 2126867596
}

```

`Source/AssetRipper.SourceGenerated.Extensions.SourceGenerator/CreateMethodGenerator.cs`:

```cs
using AssetRipper.Text.SourceGeneration;
using SGF;
using System.CodeDom.Compiler;

namespace AssetRipper.SourceGenerated.Extensions.SourceGenerator;

[IncrementalGenerator]
public class CreateMethodGenerator() : IncrementalGenerator(nameof(CreateMethodGenerator))
{
	public override void OnInitialize(SgfInitializationContext context)
	{
		context.RegisterPostInitializationOutput(static (context) =>
		{
			context.AddSource("AssetCreator.g.cs", GenerateCode());
		});
	}

	private static string GenerateCode()
	{
		StringWriter stringWriter = new() { NewLine = "\n" };
		using IndentedTextWriter writer = IndentedTextWriterFactory.Create(stringWriter);

		writer.WriteGeneratedCodeWarning();
		writer.WriteLineNoTabs();
		writer.WriteUsing("AssetRipper.Assets.Collections");
		writer.WriteUsing("AssetRipper.Primitives");
		foreach (ClassIDType classId in GetValues())
		{
			writer.WriteUsing($"AssetRipper.SourceGenerated.Classes.ClassID_{(int)classId}");
		}
		writer.WriteLineNoTabs();
		writer.WriteFileScopedNamespace("AssetRipper.SourceGenerated.Extensions");
		writer.WriteLineNoTabs();
		writer.WriteLine("public static partial class AssetCreator");
		using (new CurlyBrackets(writer))
		{
			writer.WriteLine("extension(ProcessedAssetCollection collection)");
			using (new CurlyBrackets(writer))
			{
				foreach (ClassIDType classId in GetValues())
				{
					string enumValueName = classId.ToString();
					string name = GetName(enumValueName);
					writer.WriteLine($"public I{name} Create{name}() => collection.CreateAsset((int)ClassIDType.{enumValueName}, {name}.Create);");
				}
			}
			foreach (ClassIDType classId in GetValues())
			{
				string name = GetName(classId.ToString());
				writer.WriteLine($"public static I{name} Create{name}(UnityVersion version) => CreateCollection(version).Create{name}();");
			}
		}

		return stringWriter.ToString();
	}

	private static string GetName(string enumValueName)
	{
		int index = enumValueName.IndexOf('_');
		if (index < 0)
		{
			return enumValueName;
		}
		else
		{
			return enumValueName.Substring(0, index);
		}
	}

	private static IEnumerable<ClassIDType> GetValues()
	{
		foreach (ClassIDType value in Enum.GetValues(typeof(ClassIDType)).Cast<ClassIDType>())
		{
			if (value is ClassIDType.NavMeshData_194 or ClassIDType.LightProbes_197 or ClassIDType.VideoClip_327 or ClassIDType.AvatarMask_1011)
			{
				continue;
			}

			yield return value;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AABBExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.AABB;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AABBExtensions
{
	public static void CopyValuesFrom(this IAABB instance, Vector3 center, Vector3 extent)
	{
		instance.Center.CopyValues(center);
		instance.Extent.CopyValues(extent);
	}

	public static void Reset(this IAABB instance)
	{
		instance.Center.Reset();
		instance.Extent.Reset();
	}

	public static void CalculateFromVertexArray(this IAABB instance, ReadOnlySpan<Vector3> vertices)
	{
		if (vertices.Length == 0)
		{
			instance.Reset();
		}
		else
		{
			Vector3 first = vertices[0];
			float minX = first.X;
			float minY = first.Y;
			float minZ = first.Z;
			float maxX = first.X;
			float maxY = first.Y;
			float maxZ = first.Z;
			for (int i = 1; i < vertices.Length; i++)
			{
				Vector3 vertex = vertices[i];
				if (vertex.X < minX)
				{
					minX = vertex.X;
				}
				else if (vertex.X > maxX)
				{
					maxX = vertex.X;
				}

				if (vertex.Y < minY)
				{
					minY = vertex.Y;
				}
				else if (vertex.Y > maxY)
				{
					maxY = vertex.Y;
				}

				if (vertex.Z < minZ)
				{
					minZ = vertex.Z;
				}
				else if (vertex.Z > maxZ)
				{
					maxZ = vertex.Z;
				}
			}
			Vector3 center = new Vector3((maxX + minX) / 2, (maxY + minY) / 2, (maxZ + minZ) / 2);
			Vector3 extent = new Vector3((maxX - minX) / 2, (maxY - minY) / 2, (maxZ - minZ) / 2);
			instance.CopyValuesFrom(center, extent);
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AnimationClipExtensions.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_111;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_95;
using AssetRipper.SourceGenerated.NativeEnums.Global;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AnimationClipExtensions
{
	public static bool GetLegacy(this IAnimationClip clip)
	{
		if (clip.Has_Legacy_C74())
		{
			return clip.Legacy_C74;
		}
		return clip.AnimationType_C74 == (int)AnimationType.Legacy;
	}

	public static IEnumerable<IGameObject> FindRoots(this IAnimationClip clip)
	{
		foreach (IUnityObjectBase asset in clip.Collection.Bundle.FetchAssetsInHierarchy())
		{
			if (asset is IAnimator animator)
			{
				if (animator.ContainsAnimationClip(clip))
				{
					IGameObject? gameObject = animator.GameObjectP;
					if (gameObject is not null)
					{
						yield return gameObject;
					}
				}
			}
			else if (asset is IAnimation animation)
			{
				if (animation.ContainsAnimationClip(clip))
				{
					IGameObject? gameObject = animation.GameObjectP;
					if (gameObject is not null)
					{
						yield return gameObject;
					}
				}
			}
		}

		yield break;
	}

	public static bool SupportsNegativeInfinitySlopes(this IAnimationClip clip) => clip.Collection.Version.GreaterThan(2021);
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AnimationCurveExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.AnimationCurve_Quaternionf;
using AssetRipper.SourceGenerated.Subclasses.AnimationCurve_Single;
using AssetRipper.SourceGenerated.Subclasses.AnimationCurve_Vector3f;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Single;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AnimationCurveExtensions
{
	public static void SetDefaultRotationOrderAndCurveLoopType(this IAnimationCurve_Single animationCurve)
	{
		animationCurve.PreInfinityE = CurveLoopTypes.CycleWithOffset;
		animationCurve.PostInfinityE = CurveLoopTypes.CycleWithOffset;
		animationCurve.RotationOrderE = RotationOrder.OrderZXY;
	}

	public static void SetValues(this IAnimationCurve_Single animationCurve, UnityVersion version, float defaultValue, float defaultWeight)
	{
		animationCurve.SetDefaultRotationOrderAndCurveLoopType();
		animationCurve.Curve.Capacity = 2;
		animationCurve.Curve.AddNew().SetValues(version, 0.0f, defaultValue, defaultWeight);
		animationCurve.Curve.AddNew().SetValues(version, 1.0f, defaultValue, defaultWeight);
	}

	public static void SetValues(this IAnimationCurve_Single animationCurve, UnityVersion version, float value1, float value2, float defaultWeight)
	{
		animationCurve.SetDefaultRotationOrderAndCurveLoopType();
		animationCurve.Curve.Capacity = 2;
		animationCurve.Curve.AddNew().SetValues(version, 0.0f, value1, defaultWeight);
		animationCurve.Curve.AddNew().SetValues(version, 1.0f, value2, defaultWeight);
	}

	public static void SetValues(this IAnimationCurve_Single animationCurve, UnityVersion version, float value1, float inSlope1, float outSlope1, float value2, float inSlope2, float outSlope2, float defaultWeight)
	{
		animationCurve.SetDefaultRotationOrderAndCurveLoopType();
		animationCurve.Curve.Capacity = 2;
		animationCurve.Curve.AddNew().SetValues(version, 0.0f, value1, inSlope1, outSlope1, defaultWeight);
		animationCurve.Curve.AddNew().SetValues(version, 1.0f, value2, inSlope2, outSlope2, defaultWeight);
	}

	public static void SetValues(this IAnimationCurve_Single animationCurve, UnityVersion version, IKeyframe_Single keyframe)
	{
		animationCurve.SetDefaultRotationOrderAndCurveLoopType();
		animationCurve.Curve.Capacity = 1;
		animationCurve.Curve.AddNew().CopyValues(keyframe);
	}

	public static void SetValues(this IAnimationCurve_Single animationCurve, UnityVersion version, IKeyframe_Single keyframe1, IKeyframe_Single keyframe2)
	{
		animationCurve.SetDefaultRotationOrderAndCurveLoopType();
		animationCurve.Curve.Capacity = 2;
		animationCurve.Curve.AddNew().CopyValues(keyframe1);
		animationCurve.Curve.AddNew().CopyValues(keyframe2);
	}

	public static void SetValues(this IAnimationCurve_Single animationCurve, UnityVersion version, IReadOnlyList<IKeyframe_Single> keyframes)
	{
		animationCurve.SetDefaultRotationOrderAndCurveLoopType();
		animationCurve.Curve.Capacity = keyframes.Count;
		for (int i = 0; i < keyframes.Count; i++)
		{
			animationCurve.Curve.AddNew().CopyValues(keyframes[i]);
		}
	}

	public static void SetValues(this IAnimationCurve_Single animationCurve, UnityVersion version, IReadOnlyList<IKeyframe_Single> keyframes, CurveLoopTypes preInfinity, CurveLoopTypes postInfinity)
	{
		animationCurve.PreInfinityE = preInfinity;
		animationCurve.PostInfinityE = postInfinity;
		animationCurve.RotationOrderE = RotationOrder.OrderZXY;
		animationCurve.Curve.Capacity = keyframes.Count;
		for (int i = 0; i < keyframes.Count; i++)
		{
			animationCurve.Curve.AddNew().CopyValues(keyframes[i]);
		}
	}

	public static void SetDefaultRotationOrderAndCurveLoopType(this IAnimationCurve_Vector3f animationCurve)
	{
		animationCurve.PreInfinityE = CurveLoopTypes.CycleWithOffset;
		animationCurve.PostInfinityE = CurveLoopTypes.CycleWithOffset;
		animationCurve.RotationOrderE = RotationOrder.OrderZXY;
	}

	public static void SetDefaultRotationOrderAndCurveLoopType(this IAnimationCurve_Quaternionf animationCurve)
	{
		animationCurve.PreInfinityE = CurveLoopTypes.CycleWithOffset;
		animationCurve.PostInfinityE = CurveLoopTypes.CycleWithOffset;
		animationCurve.RotationOrderE = RotationOrder.OrderZXY;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AnimationExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_111;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimationClip;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AnimationExtensions
{
	public static bool ContainsAnimationClip(this IAnimation animation, IAnimationClip clip)
	{
		foreach (IPPtr_AnimationClip clipPtr in animation.Animations)
		{
			if (clipPtr.IsAsset(animation.Collection, clip))
			{
				return true;
			}
		}
		return false;
	}

	public static bool GetAnimateOnlyIfVisible(this IAnimation animation)
	{
		// 2.6.0 to 3.4.0 exclusive
		//if (animation.Has_AnimateOnlyIfVisible_C111())
		{
			//return animation.AnimateOnlyIfVisible_C111;
		}
		//else if (animation.Has_CullingType_C111())
		{
			return animation.CullingTypeE != AnimationCullingType.AlwaysAnimate;
		}
		//else
		//{
		//	return false;
		//}
	}

	public static AnimationCullingType GetAnimationCullingType(this IAnimation animation)
	{
		// 2.6.0 to 3.4.0 exclusive
		//if (animation.Has_AnimateOnlyIfVisible_C111())
		{
			//return animation.AnimateOnlyIfVisible_C111 ? AnimationCullingType.BasedOnRenderers : AnimationCullingType.AlwaysAnimate;
		}
		//else if (animation.Has_CullingType_C111())
		{
			return animation.CullingTypeE;
		}
		//else
		//{
		//	return default;
		//}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AnimatorControllerExtensions.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_1101;
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_1107;
using AssetRipper.SourceGenerated.Classes.ClassID_1109;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_206;
using AssetRipper.SourceGenerated.Classes.ClassID_207;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.AnimatorControllerLayer;
using AssetRipper.SourceGenerated.Subclasses.ChildAnimatorState;
using AssetRipper.SourceGenerated.Subclasses.ChildAnimatorStateMachine;
using AssetRipper.SourceGenerated.Subclasses.ChildMotion;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimationClip;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorState;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorStateTransition;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorTransition;
using AssetRipper.SourceGenerated.Subclasses.PPtr_MonoBehaviour;
using AssetRipper.SourceGenerated.Subclasses.StateBehavioursPair;
using AssetRipper.SourceGenerated.Subclasses.StateKey;
using AssetRipper.SourceGenerated.Subclasses.StateMachineBehaviourVectorDescription;
using AssetRipper.SourceGenerated.Subclasses.StateMotionPair;
using AssetRipper.SourceGenerated.Subclasses.StateRange;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AnimatorControllerExtensions
{
	public static bool ContainsAnimationClip(this IAnimatorController controller, IAnimationClip clip)
	{
		foreach (IPPtr_AnimationClip clipPtr in controller.AnimationClips)
		{
			if (clipPtr.IsAsset(controller.Collection, clip))
			{
				return true;
			}
		}
		return false;
	}

	public static IMonoBehaviour?[] GetStateBehaviours(this IAnimatorController controller, int layerIndex, uint stateID)
	{
		if (controller.Has_StateMachineBehaviourVectorDescription())
		{
			StateKey key = new();
			key.SetValues(layerIndex, stateID);
			if (controller.StateMachineBehaviourVectorDescription.StateMachineBehaviourRanges.TryGetValue(key, out StateRange? range))
			{
				return GetStateBehaviours(controller.StateMachineBehaviourVectorDescription, controller.StateMachineBehavioursP, range);
			}
		}
		return [];
	}

	private static IMonoBehaviour?[] GetStateBehaviours(
		IStateMachineBehaviourVectorDescription controllerStateMachineBehaviourVectorDescription,
		PPtrAccessList<PPtr_MonoBehaviour_5, IMonoBehaviour> controllerStateMachineBehaviours,
		StateRange range)
	{
		IMonoBehaviour?[] stateMachineBehaviours = new IMonoBehaviour?[range.Count];
		for (int i = 0; i < range.Count; i++)
		{
			int index = (int)controllerStateMachineBehaviourVectorDescription.StateMachineBehaviourIndices[(int)range.StartIndex + i];
			IMonoBehaviour? stateMachineBehaviour = controllerStateMachineBehaviours[index];
			stateMachineBehaviour?.HideFlagsE = HideFlags.HideInHierarchy;
			stateMachineBehaviours[i] = stateMachineBehaviour;
		}
		return stateMachineBehaviours;
	}

	public static IEnumerable<IUnityObjectBase?> FetchEditorHierarchy(this IAnimatorController animatorController)
	{
		yield return animatorController;

		foreach (IAnimatorControllerLayer layer in animatorController.AnimatorLayers)
		{
			//Ignoring layer.Controller, layer.Mask, and layer.SkeletonMask
			if (layer.Has_Behaviours())
			{
				foreach (IStateBehavioursPair pair in layer.Behaviours)
				{
					IAnimatorState? state = pair.State.TryGetAsset(animatorController.Collection);
					if (state is not null)
					{
						foreach (IUnityObjectBase? reference in state.FetchHierarchy())
						{
							yield return reference;
						}
					}
					foreach (PPtr_MonoBehaviour_5 stateMachineBehaviour in pair.StateMachineBehaviours)
					{
						yield return stateMachineBehaviour.TryGetAsset(animatorController.Collection);
					}
				}
				foreach (IStateMotionPair pair in layer.Motions)
				{
					IAnimatorState? state = pair.State.TryGetAsset(animatorController.Collection);
					if (state is not null)
					{
						foreach (IUnityObjectBase? reference in state.FetchHierarchy())
						{
							yield return reference;
						}
					}

					//AnimationClip also inherits from Motion, but we don't want to include that.
					IBlendTree? blendTree = pair.Motion.TryGetAsset(animatorController.Collection) as IBlendTree;
					if (blendTree is not null)
					{
						foreach (IUnityObjectBase? reference in blendTree.FetchHierarchy())
						{
							yield return reference;
						}
					}
				}
			}
			IAnimatorStateMachine? stateMachine = layer.StateMachine.TryGetAsset(animatorController.Collection);
			if (stateMachine is not null)
			{
				foreach (IUnityObjectBase? reference in stateMachine.FetchEditorHierarchy())
				{
					yield return reference;
				}
			}
		}
		//Ignoring animatorController.AnimatorParameters.Controller
		//It has no other PPtr's.
	}

	private static IEnumerable<IUnityObjectBase?> FetchEditorHierarchy(this IAnimatorStateMachine stateMachine)
	{
		yield return stateMachine;
		if (stateMachine.Has_ChildStateMachines())
		{
			foreach (IAnimatorStateTransition? anyStateTransition in stateMachine.AnyStateTransitionsP)
			{
				yield return anyStateTransition;
			}
			foreach (ChildAnimatorStateMachine childAnimatorStateMachine in stateMachine.ChildStateMachines)
			{
				IAnimatorStateMachine? childStateMachine = childAnimatorStateMachine.StateMachine.TryGetAsset(stateMachine.Collection);
				if (childStateMachine is not null)
				{
					foreach (IUnityObjectBase? reference in childStateMachine.FetchEditorHierarchy())
					{
						yield return reference;
					}
				}
			}
			foreach (ChildAnimatorState childState in stateMachine.ChildStates)
			{
				IAnimatorState? state = childState.State.TryGetAsset(stateMachine.Collection);
				if (state is not null)
				{
					foreach (IUnityObjectBase? reference in state.FetchHierarchy())
					{
						yield return reference;
					}
				}
			}
			foreach (IAnimatorTransition? entryTransition in stateMachine.EntryTransitionsP)
			{
				yield return entryTransition;
			}
			foreach (IMonoBehaviour? behaviour in stateMachine.StateMachineBehavioursP)
			{
				yield return behaviour;
			}
			foreach (AssetList<PPtr_AnimatorTransition> list in stateMachine.StateMachineTransitions.Values)
			{
				//Skipping keys because they're IAnimatorStateMachine
				foreach (PPtr_AnimatorTransition transition in list)
				{
					yield return transition.TryGetAsset(stateMachine.Collection);
				}
			}
		}
		else
		{
			foreach (IAnimatorStateMachine? childStateMachine in stateMachine.ChildStateMachineP)
			{
				if (childStateMachine is not null)
				{
					foreach (IUnityObjectBase? reference in childStateMachine.FetchEditorHierarchy())
					{
						yield return reference;
					}
				}
			}
			if (stateMachine.Has_LocalTransitions())
			{
				foreach ((PPtr_AnimatorState_4 statePPtr, AssetList<PPtr_AnimatorStateTransition_4> list) in stateMachine.LocalTransitions)
				{
					IAnimatorState? state = statePPtr.TryGetAsset(stateMachine.Collection);
					if (state is not null)
					{
						foreach (IUnityObjectBase? reference in state.FetchHierarchy())
						{
							yield return reference;
						}
					}
					foreach (PPtr_AnimatorStateTransition_4 transition in list)
					{
						yield return transition.TryGetAsset(stateMachine.Collection);
					}
				}
			}
			foreach ((PPtr_AnimatorState_4 statePPtr, AssetList<PPtr_AnimatorStateTransition_4> list) in stateMachine.OrderedTransitions)
			{
				IAnimatorState? state = statePPtr.TryGetAsset(stateMachine.Collection);
				if (state is not null)
				{
					foreach (IUnityObjectBase? reference in state.FetchHierarchy())
					{
						yield return reference;
					}
				}
				foreach (PPtr_AnimatorStateTransition_4 transition in list)
				{
					yield return transition.TryGetAsset(stateMachine.Collection);
				}
			}
			foreach (IAnimatorState? state in stateMachine.StatesP)
			{
				if (state is not null)
				{
					foreach (IUnityObjectBase? reference in state.FetchHierarchy())
					{
						yield return reference;
					}
				}
			}
		}
		//Ignoring DefaultState because redundant
	}

	private static IEnumerable<IUnityObjectBase?> FetchHierarchy(this IBlendTree blendTree)
	{
		yield return blendTree;
		foreach (IChildMotion childMotion in blendTree.Childs)
		{
			//AnimationClips are excluded from the hierarchy
			IBlendTree? child = childMotion.Motion.TryGetAsset(blendTree.Collection) as IBlendTree;
			if (child is not null)
			{
				foreach (IUnityObjectBase? reference in child.FetchHierarchy())
				{
					yield return reference;
				}
			}
		}
	}

	private static IEnumerable<IUnityObjectBase?> FetchHierarchy(this IAnimatorState state)
	{
		yield return state;

		if (state.Has_Motions())
		{
			foreach (IMotion? motion in state.MotionsP)
			{
				if (motion is IBlendTree blendTree)
				{
					foreach (IUnityObjectBase? reference in blendTree.FetchHierarchy())
					{
						yield return reference;
					}
				}
			}
		}
		else
		{
			if (state.MotionP is IBlendTree blendTree)
			{
				foreach (IUnityObjectBase? reference in blendTree.FetchHierarchy())
				{
					yield return reference;
				}
			}
		}
		//Ignoring ParentStateMachine
		if (state.Has_StateMachineBehaviours())
		{
			foreach (IMonoBehaviour? behaviour in state.StateMachineBehavioursP)
			{
				yield return behaviour;
			}
		}
		if (state.Has_Transitions())
		{
			foreach (IAnimatorStateTransition? transition in state.TransitionsP)
			{
				yield return transition;
			}
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AnimatorControllerParameterExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.NativeEnums.Animation;
using AssetRipper.SourceGenerated.Subclasses.AnimatorControllerParameter;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AnimatorControllerParameterExtensions
{
	public static AnimatorControllerParameterType GetTypeValue(this IAnimatorControllerParameter parameter)
	{
		return (AnimatorControllerParameterType)parameter.Type;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AnimatorExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Classes.ClassID_93;
using AssetRipper.SourceGenerated.Classes.ClassID_95;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AnimatorExtensions
{
	public static bool ContainsAnimationClip(this IAnimator animator, IAnimationClip clip)
	{
		if (animator.Has_Controller_PPtr_AnimatorController_4())
		{
			IAnimatorController? controller = animator.Controller_PPtr_AnimatorController_4P;
			return controller is not null && controller.ContainsAnimationClip(clip);
		}
		else if (animator.Has_Controller_PPtr_RuntimeAnimatorController_4_3())
		{
			IRuntimeAnimatorController? controller = animator.Controller_PPtr_RuntimeAnimatorController_4_3P;
			return controller is not null && controller.ContainsAnimationClip(clip);
		}
		else if (animator.Has_Controller_PPtr_RuntimeAnimatorController_5())
		{
			IRuntimeAnimatorController? controller = animator.Controller_PPtr_RuntimeAnimatorController_5P;
			return controller is not null && controller.ContainsAnimationClip(clip);
		}
		else
		{
			return false;
		}
	}

	public static AnimatorUpdateMode GetUpdateMode(this IAnimator animator)
	{
		return animator.Has_UpdateMode() ? animator.UpdateModeE : AnimatorUpdateMode.Normal;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AnimatorOverrideControllerExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_221;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_93;
using AssetRipper.SourceGenerated.Subclasses.AnimationClipOverride;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AnimatorOverrideControllerExtensions
{
	public static bool ContainsAnimationClip(this IAnimatorOverrideController controller, IAnimationClip clip)
	{
		foreach (IAnimationClipOverride overClip in controller.Clips)
		{
			if (overClip.OriginalClip.IsAsset(controller.Collection, clip))
			{
				return true;
			}
			else if (overClip.OverrideClip.IsAsset(controller.Collection, clip))
			{
				return true;
			}
		}
		IRuntimeAnimatorController? baseController = controller.ControllerP;
		if (baseController != null)
		{
			return baseController.ContainsAnimationClip(clip);
		}
		return false;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AnimatorStateMachineExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_1107;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AnimatorStateMachineExtensions
{
	public static void SetChildStateCapacity(this IAnimatorStateMachine stateMachine, int c)
	{
		if (stateMachine.Has_ChildStates())
		{
			stateMachine.ChildStates.Capacity = c;
		}
		else
		{
			stateMachine.States.Capacity = c;
		}
	}

	public static void SetChildStateMachineCapacity(this IAnimatorStateMachine stateMachine, int c)
	{
		if (stateMachine.Has_ChildStateMachines())
		{
			stateMachine.ChildStateMachines.Capacity = c;
		}
		else
		{
			stateMachine.ChildStateMachine.Capacity = c;
			stateMachine.ChildStateMachinePosition.Capacity = c;
		}
	}

	public static void TrimChildStateMachines(this IAnimatorStateMachine stateMachine)
	{
		stateMachine.SetChildStateMachineCapacity(stateMachine.ChildStateMachinesCount());
	}

	public static void SetEntryTransitionsCapacity(this IAnimatorStateMachine stateMachine, int c)
	{
		if (stateMachine.Has_EntryTransitions())
		{
			stateMachine.EntryTransitions.Capacity = c;
		}
	}

	public static int ChildStatesCount(this IAnimatorStateMachine stateMachine)
	{
		if (stateMachine.Has_ChildStates())
		{
			return stateMachine.ChildStates.Count;
		}
		return stateMachine.StatesP.Count;
	}

	public static int ChildStateMachinesCount(this IAnimatorStateMachine stateMachine)
	{
		if (stateMachine.Has_ChildStateMachines())
		{
			return stateMachine.ChildStateMachines.Count;
		}
		return stateMachine.ChildStateMachine.Count;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ArrayExtensions.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions;

public static class ArrayExtensions
{
	public static bool IsNullOrEmpty<T>([NotNullWhen(false)] this T[]? array) => array is null || array.Length == 0;
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AssetBundleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_142;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AssetBundleExtensions
{
	/// <summary>
	/// 5.0.0 and greater
	/// </summary>
	public static bool HasPathExtension(UnityVersion version) => version.GreaterThanOrEquals(5);

	/// <summary>
	/// 5.0.0 and greater
	/// </summary>
	public static bool HasPathExtension(this IAssetBundle bundle) => HasPathExtension(bundle.Collection.Version);

	public static string GetAssetBundleName(this IAssetBundle bundle)
	{
		if (bundle.Has_AssetBundleName_R() && !bundle.AssetBundleName_R.IsEmpty)
		{
			return bundle.AssetBundleName_R;
		}
		else
		{
			return bundle.Collection.Bundle.Name;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AssetCreator.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using System.Reflection;

namespace AssetRipper.SourceGenerated.Extensions;

/// <summary>
/// A helper class for creating assets, generally for unit testing.
/// </summary>
public static partial class AssetCreator
{
	public static T Create<T>(ClassIDType classID, UnityVersion version, Func<AssetInfo, T> factory) where T : IUnityObjectBase
	{
		return CreateCollection(version).CreateAsset((int)classID, factory);
	}

	/// <summary>
	/// Create a new asset using reflection.
	/// </summary>
	/// <remarks>
	/// The type must have a constructor which takes an <see cref="AssetInfo"/> as its only parameter.
	/// </remarks>
	/// <typeparam name="T">The type of asset to create.</typeparam>
	/// <returns>A new asset.</returns>
	public static T CreateUnsafe<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.NonPublicConstructors)] T>() where T : UnityObjectBase
	{
		return Create(default, default, (assetInfo) =>
		{
			return (T?)Activator.CreateInstance(typeof(T), BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, [assetInfo], null)
				?? throw new NullReferenceException();
		});
	}

	/// <summary>
	/// Create a new asset using reflection.
	/// </summary>
	/// <remarks>
	/// The type must have a constructor which takes an <see cref="AssetInfo"/> as its only parameter.
	/// </remarks>
	/// <param name="type">The type of asset to create.</param>
	/// <returns>A new asset.</returns>
	[RequiresDynamicCode("")]
	public static UnityObjectBase CreateUnsafe([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.NonPublicConstructors)] Type type)
	{
#pragma warning disable IL2111 // Method with parameters or return value with `DynamicallyAccessedMembersAttribute` is accessed via reflection. Trimmer can't guarantee availability of the requirements of the method.
		return (UnityObjectBase?)typeof(AssetCreator).GetMethod(nameof(CreateUnsafe), 1, BindingFlags.Public | BindingFlags.Static, null, [], null)
			!.MakeGenericMethod(type)
			.Invoke(null, null) ?? throw new NullReferenceException();
#pragma warning restore IL2111 // Method with parameters or return value with `DynamicallyAccessedMembersAttribute` is accessed via reflection. Trimmer can't guarantee availability of the requirements of the method.
	}

	public static ProcessedAssetCollection CreateCollection(UnityVersion version)
	{
		GameBundle gameBundle = new();
		ProcessedAssetCollection collection = gameBundle.AddNewProcessedCollection(nameof(AssetCreator), version);
		return collection;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AssetRipper.SourceGenerated.Extensions.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.SourceGenerated.Extensions\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.SourceGenerated.Extensions\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Assets\AssetRipper.Assets.csproj" />
		<ProjectReference Include="..\AssetRipper.Numerics\AssetRipper.Numerics.csproj" />
		<ProjectReference Include="..\AssetRipper.SourceGenerated.Extensions.SourceGenerator\AssetRipper.SourceGenerated.Extensions.SourceGenerator.csproj" OutputItemType="Analyzer" ReferenceOutputAssembly="false" />
	</ItemGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.Checksum" Version="1.1.0" />
		<PackageReference Include="AssetRipper.SourceGenerated" Version="1.3.10" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.SourceGenerated.Extensions/AudioClipExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.NativeEnums.Fmod;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AudioClipExtensions
{
	public static byte[] GetAudioData(this IAudioClip audioClip)
	{
		if (audioClip.Has_AudioData() && audioClip.AudioData.Length > 0)
		{
			return audioClip.AudioData;
		}
		else if (audioClip.Has_Resource())
		{
			return audioClip.Resource.GetContent(audioClip.Collection) ?? Array.Empty<byte>();
		}
		//else if (audioClip.StreamingInfo != null && audioClip.LoadType == (int)Classes.AudioClip.AudioClipLoadType.Streaming)
		//{
		//	return audioClip.StreamingInfo.GetContent(audioClip.SerializedFile) ?? Array.Empty<byte>();
		//}
		else
		{
			return Array.Empty<byte>();
		}
	}

	public static bool CheckAssetIntegrity(this IAudioClip audioClip)
	{
		if (audioClip.Has_AudioData() && audioClip.AudioData.Length > 0)
		{
			return true;
		}
		else if (audioClip.Resource != null)
		{
			return audioClip.Resource.CheckIntegrity(audioClip.Collection);
		}
		//else if (audioClip.StreamingInfo != null && audioClip.LoadType == (int)Classes.AudioClip.AudioClipLoadType.Streaming)
		//{
		//	return audioClip.StreamingInfo.CheckIntegrity(audioClip.SerializedFile);
		//}
		else
		{
			return true;
		}
	}

	/// <summary>
	/// Only present when <see cref="IAudioClip.Has_Format"/> is true.
	/// </summary>
	public static FmodSoundFormat GetSoundFormat(this IAudioClip audioClip) => (FmodSoundFormat)audioClip.Format;

	/// <summary>
	/// Only present when <see cref="IAudioClip.Has_Type"/> is true.
	/// </summary>
	public static FmodSoundType GetSoundType(this IAudioClip audioClip) => (FmodSoundType)audioClip.Type;
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AudioCompressionFormatExtentions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AudioCompressionFormatExtentions
{
	public static string ToRawExtension(this AudioCompressionFormat compressionFormat)
	{
		switch (compressionFormat)
		{
			case AudioCompressionFormat.PCM:
			case AudioCompressionFormat.Vorbis:
			case AudioCompressionFormat.ADPCM:
			case AudioCompressionFormat.MP3:
			case AudioCompressionFormat.GCADPCM:
				return "fsb";
			case AudioCompressionFormat.VAG:
			case AudioCompressionFormat.HEVAG:
				return "vag";
			case AudioCompressionFormat.XMA:
				return "wav";
			case AudioCompressionFormat.AAC:
				return "m4a";
			case AudioCompressionFormat.ATRAC9:
				return "at9";
			default:
				return "audioClip";
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AvatarConstantExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Subclasses.AvatarConstant;
using AssetRipper.SourceGenerated.Subclasses.OffsetPtr_SkeletonPose;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AvatarConstantExtensions
{
	public static IOffsetPtr_SkeletonPose GetDefaultPose(this IAvatarConstant constant)
	{
		return constant.Has_DefaultPose() ? constant.DefaultPose : constant.SkeletonPose;
	}

	public static AssetList<uint> GetSkeletonNameIDArray(this IAvatarConstant constant)
	{
		return constant.Has_SkeletonNameIDArray() ? constant.SkeletonNameIDArray : constant.Skeleton.Data.ID;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/AvatarExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_90;

namespace AssetRipper.SourceGenerated.Extensions;

public static class AvatarExtensions
{
	public static Utf8String? FindBonePath(this IAvatar avatar, uint hash)
	{
		avatar.TOS.TryGetValue(hash, out Utf8String? result);
		return result;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/BlendShapeDataExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.BlendShapeData;
using AssetRipper.SourceGenerated.Subclasses.MeshBlendShapeChannel;

namespace AssetRipper.SourceGenerated.Extensions;

public static class BlendShapeDataExtensions
{
	public static string? FindShapeNameByCRC(this IBlendShapeData blendShapeData, uint crc)
	{
		foreach (MeshBlendShapeChannel blendChannel in blendShapeData.Channels)
		{
			if (blendChannel.NameHash == crc)
			{
				return blendChannel.Name.String;
			}
		}
		return null;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/BlendTreeExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_206;
using BlendTreeType = AssetRipper.SourceGenerated.Enums.BlendTreeType_1;

namespace AssetRipper.SourceGenerated.Extensions;

public static class BlendTreeExtensions
{
	public static BlendTreeType GetBlendType(this IBlendTree tree)
	{
		return tree.Has_BlendType_Int32() ? tree.BlendType_Int32E : tree.BlendType_UInt32E;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/BlendTreeNodeConstantExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.BlendTreeNodeConstant;
using System.Numerics;
using BlendTreeType = AssetRipper.SourceGenerated.Enums.BlendTreeType_1;

namespace AssetRipper.SourceGenerated.Extensions;

public static class BlendTreeNodeConstantExtensions
{
	public static float GetThreshold(this IBlendTreeNodeConstant constant, int index)
	{
		if (constant.Has_Blend1dData())
		{
			if (constant.BlendTypeE == BlendTreeType.Simple1D)
			{
				return constant.Blend1dData.Data.ChildThresholdArray[index];
			}
		}
		else if (constant.Has_ChildThresholdArray())
		{
			return constant.ChildThresholdArray[index];
		}
		return 0.0f;
	}

	public static Vector2 GetPosition(this IBlendTreeNodeConstant constant, int index)
	{
		if (constant.Has_Blend2dData() && constant.BlendTypeE != BlendTreeType.Simple1D && constant.BlendTypeE != BlendTreeType.Direct)
		{
			return constant.Blend2dData.Data.ChildPositionArray[index];
		}
		return default;
	}

	public static float GetMinThreshold(this IBlendTreeNodeConstant constant)
	{
		if (constant.Has_Blend1dData() && constant.BlendTypeE == BlendTreeType.Simple1D)
		{
			return constant.Blend1dData.Data.ChildThresholdArray.Min();
		}
		return 0.0f;
	}

	public static float GetMaxThreshold(this IBlendTreeNodeConstant constant)
	{
		if (constant.Has_Blend1dData() && constant.BlendTypeE == BlendTreeType.Simple1D)
		{
			return constant.Blend1dData.Data.ChildThresholdArray.Max();
		}
		return 1.0f;
	}

	public static bool TryGetDirectBlendParameter(this IBlendTreeNodeConstant constant, int index, out uint parameter)
	{
		if (constant.Has_BlendDirectData() && constant.BlendTypeE == BlendTreeType.Direct)
		{
			parameter = constant.BlendDirectData.Data.ChildBlendEventIDArray[index];
			return true;
		}
		parameter = default;
		return false;
	}

	public static bool IsBlendTree(this IBlendTreeNodeConstant constant) => constant.ChildIndices.Count > 0;
}

```

`Source/AssetRipper.SourceGenerated.Extensions/BoneWeights4Extensions.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Subclasses.BoneWeights4;

namespace AssetRipper.SourceGenerated.Extensions;

public static class BoneWeights4Extensions
{
	public static BoneWeight4 ToCommonClass(this IBoneWeights4 weights)
	{
		return new BoneWeight4(weights.Weight_0_, weights.Weight_1_, weights.Weight_2_, weights.Weight_3_,
			weights.BoneIndex_0_, weights.BoneIndex_1_, weights.BoneIndex_2_, weights.BoneIndex_3_);
	}

	public static void CopyValues(this IBoneWeights4 vector, BoneWeight4 source)
	{
		vector.Weight_0_ = source.Weight0;
		vector.Weight_1_ = source.Weight1;
		vector.Weight_2_ = source.Weight2;
		vector.Weight_3_ = source.Weight3;
		vector.BoneIndex_0_ = source.Index0;
		vector.BoneIndex_1_ = source.Index1;
		vector.BoneIndex_2_ = source.Index2;
		vector.BoneIndex_3_ = source.Index3;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Bounds.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.AABB;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public record struct Bounds(
	Vector3 Center,
	Vector3 Extent)
{
	public static implicit operator Bounds(AABB aabb)
	{
		return new Bounds(aabb.Center, aabb.Extent);
	}

	public readonly void CopyTo(AABB destination)
	{
		destination.Center.CopyValues(Center);
		destination.Extent.CopyValues(Extent);
	}

	public static Bounds CalculateFromVertexArray(ReadOnlySpan<Vector3> vertices)
	{
		if (vertices.Length == 0)
		{
			return default;
		}
		else
		{
			Vector3 first = vertices[0];
			float minX = first.X;
			float minY = first.Y;
			float minZ = first.Z;
			float maxX = first.X;
			float maxY = first.Y;
			float maxZ = first.Z;
			for (int i = 1; i < vertices.Length; i++)
			{
				Vector3 vertex = vertices[i];
				if (vertex.X < minX)
				{
					minX = vertex.X;
				}
				else if (vertex.X > maxX)
				{
					maxX = vertex.X;
				}

				if (vertex.Y < minY)
				{
					minY = vertex.Y;
				}
				else if (vertex.Y > maxY)
				{
					maxY = vertex.Y;
				}

				if (vertex.Z < minZ)
				{
					minZ = vertex.Z;
				}
				else if (vertex.Z > maxZ)
				{
					maxZ = vertex.Z;
				}
			}
			Vector3 center = new Vector3((maxX + minX) / 2, (maxY + minY) / 2, (maxZ + minZ) / 2);
			Vector3 extent = new Vector3((maxX - minX) / 2, (maxY - minY) / 2, (maxZ - minZ) / 2);
			return new(center, extent);
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/BufferBindingExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.BufferBinding;

namespace AssetRipper.SourceGenerated.Extensions;

public static class BufferBindingExtensions
{
	public static void SetValues(this IBufferBinding binding, string name, int index)
	{
		//binding.Name = name;//Name doesn't exist
		binding.NameIndex = -1;
		binding.Index = index;
		binding.ArraySize = 0;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/BuildTargetGroup.cs`:

```cs
using AssetRipper.IO.Files;

namespace AssetRipper.SourceGenerated.Extensions;

public enum BuildTargetGroup
{
	/// <summary>
	/// Unknown target.
	/// </summary>
	Unknown = 0,
	/// <summary>
	/// Mac/PC standalone target.
	/// </summary>
	Standalone = 1,
	/// <summary>
	/// Mac/PC webplayer target.
	/// </summary>
	WebPlayer = 2,
	Wii = 3,
	/// <summary>
	/// Apple iOS target.
	/// </summary>
	iPhone = 4,
	/// <summary>
	/// Apple iOS target.
	/// </summary>
	iOS = 4,
	PS3 = 5,
	XBOX360 = 6,
	/// <summary>
	/// Android target.
	/// </summary>
	Android = 7,
	GLESEmu = 9,
	/// <summary>
	/// Google Native Client
	/// </summary>
	NaCl = 11,
	FlashPlayer = 12,
	/// <summary>
	/// WebGL.
	/// </summary>
	WebGL = 13,
	/// <summary>
	/// Windows Store Apps target.
	/// </summary>
	WSA = 14,
	Metro = 14,
	WP8 = 15,
	BlackBerry = 16,
	/// <summary>
	/// Samsung Tizen target.
	/// </summary>
	Tizen = 17,
	/// <summary>
	/// Sony PS Vita target.
	/// </summary>
	PSP2 = 18,
	/// <summary>
	/// Sony Playstation 4 target.
	/// </summary>
	PS4 = 19,
	PSM = 20,
	/// <summary>
	/// Microsoft Xbox One target.
	/// </summary>
	XboxOne = 21,
	SamsungTV = 22,
	/// <summary>
	/// Nintendo 3DS target.
	/// </summary>
	N3DS = 23,
	/// <summary>
	/// Nintendo Wii U target.
	/// </summary>
	WiiU = 24,
	/// <summary>
	/// Apple's tvOS target.
	/// </summary>
	tvOS = 25,
	/// <summary>
	/// Facebook target.
	/// </summary>
	Facebook = 26,
	/// <summary>
	/// Nintendo Switch target.
	/// </summary>
	Switch = 27,
}

public static class BuildTargetGroupExtensions
{
	public static BuildTargetGroup PlatformToBuildGroup(this BuildTarget _this)
	{
		switch (_this)
		{
			case BuildTarget.StandaloneOSXUniversal:
			case BuildTarget.StandaloneOSXPPC:
			case BuildTarget.StandaloneOSXIntel:
			case BuildTarget.StandaloneWinPlayer:
			case BuildTarget.StandaloneLinux:
			case BuildTarget.StandaloneWin64Player:
			case BuildTarget.StandaloneLinux64:
			case BuildTarget.StandaloneLinuxUniversal:
			case BuildTarget.StandaloneOSXIntel64:
				return BuildTargetGroup.Standalone;

			case BuildTarget.WebPlayerLZMA:
			case BuildTarget.WebPlayerLZMAStreamed:
				return BuildTargetGroup.WebPlayer;

			case BuildTarget.Wii:
				return BuildTargetGroup.Wii;

			case BuildTarget.iOS:
				return BuildTargetGroup.iOS;

			case BuildTarget.PS3:
				return BuildTargetGroup.PS3;

			case BuildTarget.XBox360:
				return BuildTargetGroup.XBOX360;

			case BuildTarget.Android:
				return BuildTargetGroup.Android;

			case BuildTarget.WinGLESEmu:
			case BuildTarget.WinGLES20Emu:
				return BuildTargetGroup.GLESEmu;

			case BuildTarget.GoogleNaCl:
				return BuildTargetGroup.NaCl;

			case BuildTarget.Flash:
				return BuildTargetGroup.FlashPlayer;

			case BuildTarget.WebGL:
				return BuildTargetGroup.WebGL;

			case BuildTarget.MetroPlayerX86:
			case BuildTarget.MetroPlayerX64:
			case BuildTarget.MetroPlayerARM:
				return BuildTargetGroup.WSA;

			case BuildTarget.WP8Player:
				return BuildTargetGroup.WP8;

			case BuildTarget.BB10:
				return BuildTargetGroup.BlackBerry;

			case BuildTarget.Tizen:
				return BuildTargetGroup.Tizen;

			case BuildTarget.PSP2:
				return BuildTargetGroup.PSP2;

			case BuildTarget.PS4:
				return BuildTargetGroup.PS4;

			case BuildTarget.PSM:
				return BuildTargetGroup.PSM;

			case BuildTarget.XboxOne:
				return BuildTargetGroup.XboxOne;

			case BuildTarget.SamsungTV:
				return BuildTargetGroup.SamsungTV;

			case BuildTarget.N3DS:
				return BuildTargetGroup.N3DS;

			case BuildTarget.WiiU:
				return BuildTargetGroup.WiiU;

			case BuildTarget.tvOS:
				return BuildTargetGroup.tvOS;

			case BuildTarget.Switch:
				return BuildTargetGroup.Switch;

			default:
				throw new NotSupportedException($"Platform {_this} is not supported.");
		}
	}

	public static string ToExportString(this BuildTargetGroup _this)
	{
		return _this switch
		{
			BuildTargetGroup.Unknown => "Unknown",
			BuildTargetGroup.Standalone => "Standalone",
			BuildTargetGroup.WebPlayer => "WebPlayer",
			BuildTargetGroup.Wii => "Wii",
			BuildTargetGroup.iOS => "iPhone",
			BuildTargetGroup.PS3 => "PS3",
			BuildTargetGroup.XBOX360 => "XBOX360",
			BuildTargetGroup.Android => "Android",
			BuildTargetGroup.GLESEmu => "GLESEmu",
			BuildTargetGroup.NaCl => "NaCl",
			BuildTargetGroup.FlashPlayer => "FlashPlayer",
			BuildTargetGroup.WebGL => "WebGL",
			BuildTargetGroup.Metro => "Windows Store Apps",
			BuildTargetGroup.WP8 => "WP8",
			BuildTargetGroup.BlackBerry => "BlackBerry",
			BuildTargetGroup.Tizen => "Tizen",
			BuildTargetGroup.PSP2 => "PSP2",
			BuildTargetGroup.PS4 => "PS4",
			BuildTargetGroup.PSM => "PSM",
			BuildTargetGroup.XboxOne => "XboxOne",
			BuildTargetGroup.SamsungTV => "SamsungTV",
			BuildTargetGroup.N3DS => "Nintendo 3DS",
			BuildTargetGroup.WiiU => "WiiU",
			BuildTargetGroup.tvOS => "tvOS",
			BuildTargetGroup.Facebook => "Facebook",
			BuildTargetGroup.Switch => "Nintendo Switch",
			_ => throw new NotSupportedException($"Value: {_this}"),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/BuiltinShaderSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.BuiltinShaderSettings;
using BuiltinShaderMode = AssetRipper.SourceGenerated.Enums.BuiltinShaderMode_1;

namespace AssetRipper.SourceGenerated.Extensions;

public static class BuiltinShaderSettingsExtensions
{
	public static BuiltinShaderMode GetMode(this IBuiltinShaderSettings settings)
	{
		return (BuiltinShaderMode)settings.Mode;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ByteArrayExtensions.cs`:

```cs
using AssetRipper.IO.Endian;
using System.Text;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ByteArrayExtensions
{
	public static byte[] SwapBytes(this byte[] _this, int size)
	{
		byte[] buffer = new byte[_this.Length];
		using (MemoryStream dst = new MemoryStream(buffer))
		{
			using BinaryWriter writer = new BinaryWriter(dst);
			using MemoryStream src = new MemoryStream(_this);
			using EndianReader reader = new EndianReader(src, EndianType.BigEndian);
			if (size == 2)
			{
				for (int i = 0; i < _this.Length; i += 2)
				{
					writer.Write(reader.ReadUInt16());
				}
			}
			else if (size == 4)
			{
				for (int i = 0; i < _this.Length; i += 4)
				{
					writer.Write(reader.ReadUInt32());
				}
			}
			else
			{
				throw new ArgumentException(size.ToString(), nameof(size));
			}
		}
		return buffer;
	}

	public static string ToFormattedHex(this byte[] _this)
	{
		StringBuilder sb = new StringBuilder();
		int count = 0;
		foreach (byte b in _this)
		{
			sb.Append(b.ToString("X2"));
			count++;
			if (count >= 16)
			{
				sb.AppendLine();
				count = 0;
			}
			else if (count % 4 == 0)
			{
				sb.Append('\t');
			}
			else
			{
				sb.Append(' ');
			}
		}
		return sb.ToString();
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/CameraExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_20;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class CameraExtensions
{
	public static FieldOfViewAxis GetFOVAxisMode(this ICamera camera) => (FieldOfViewAxis)camera.FOVAxisMode_C20;

	public static GateFitMode GetGateFitMode(this ICamera camera) => (GateFitMode)camera.GateFitMode_C20;

	public static StereoTargetEyeMask GetStereoTargetEyeMask(this ICamera camera) => (StereoTargetEyeMask)camera.TargetEye_C20;
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ChannelInfoExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.VertexFormat;
using AssetRipper.SourceGenerated.Subclasses.ChannelInfo;

namespace AssetRipper.SourceGenerated.Extensions;

/*
	/// <summary>
	/// Stream index
	/// BinaryData:[Stream0][Align][Stream1][Align]...
	/// </summary>
	byte Stream { get; set; }
	/// <summary>
	/// Offset inside stream
	/// Stream:[FirstVertex: VertexOffset,NormalOffset,TangentOffset...][SecondVertex: VertexOffset,NormalOffset,TangentOffset...]...
	/// </summary>
	byte Offset { get; set; }
	/// <summary>
	/// Data format: float, int, byte
	/// </summary>
	byte Format { get; set; }
	/// <summary>
	/// An unprocessed byte value containing the data dimension
	/// </summary>
	byte Dimension { get; set; }
 */

public static class ChannelInfoExtensions
{
	public static bool IsSet(this IChannelInfo channelInfo) => channelInfo.Dimension > 0;

	/// <summary>
	/// Data dimention: Vector3, Vector2, Vector1
	/// </summary>
	public static byte GetDataDimension(this IChannelInfo channelInfo)
	{
		return (byte)(channelInfo.Dimension & 0b00001111);
	}

	/// <summary>
	/// Data dimention: Vector3, Vector2, Vector1
	/// </summary>
	public static void SetDataDimension(this IChannelInfo channelInfo, byte value)
	{
		channelInfo.Dimension = (byte)(channelInfo.Dimension & 0b11110000 | value & 0b00001111);
	}

	public static byte GetStride(this IChannelInfo channelInfo, UnityVersion version)
	{
		return channelInfo.GetVertexFormat(version).CalculateStride(version, channelInfo.GetDataDimension());
	}

	public static VertexFormat GetVertexFormat(this IChannelInfo channelInfo, UnityVersion version)
	{
		if (VertexFormatExtensions.VertexFormat2019Relevant(version))
		{
			return ((VertexFormat2019)channelInfo.Format).ToVertexFormat();
		}
		else if (VertexFormatExtensions.VertexFormat2017Relevant(version))
		{
			return ((VertexFormat2017)channelInfo.Format).ToVertexFormat();
		}
		else
		{
			return ((VertexChannelFormat)channelInfo.Format).ToVertexFormat();
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ClassIDTypeExtention.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions;

public static class ClassIDTypeExtention
{
	public static int ToInt(this ClassIDType _this)
	{
		return (int)_this;
	}

	/// <summary>
	/// Transform and RectTransform
	/// </summary>
	public static bool IsTransform(this ClassIDType _this)
	{
		return _this is ClassIDType.Transform or ClassIDType.RectTransform;
	}

	/// <summary>
	/// Classes that inherit from LevelGameManager
	/// </summary>
	public static bool IsSceneSettings(this ClassIDType _this)
	{
		return _this is ClassIDType.OcclusionCullingSettings or ClassIDType.RenderSettings or ClassIDType.LightmapSettings or ClassIDType.NavMeshSettings;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ClipExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Subclasses.AnimationClipBindingConstant;
using AssetRipper.SourceGenerated.Subclasses.Clip;
using AssetRipper.SourceGenerated.Subclasses.GenericBinding;
using AssetRipper.SourceGenerated.Subclasses.OffsetPtr_ValueArrayConstant;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ClipExtensions
{
	public static bool IsSet(this IClip clip)
	{
		return clip.StreamedClip.IsSet()
			|| clip.DenseClip.IsSet()
			|| clip.Has_ConstantClip() && clip.ConstantClip.IsSet();
	}

	public static void ConvertValueArrayToGenericBinding(this IClip clip, IAnimationClipBindingConstant bindings)
	{
		if (clip.Has_Binding())
		{
			AccessListBase<IGenericBinding> genericBindings = bindings.GenericBindings;
			IOffsetPtr_ValueArrayConstant values = clip.Binding;
			for (int i = 0; i < values.Data.ValueArray.Count;)
			{
				uint curveID = values.Data.ValueArray[i].ID;
				uint curveTypeID = values.Data.ValueArray[i].TypeID;
				IGenericBinding binding = genericBindings.AddNew();

				if (curveTypeID == 4174552735) //CRC(PositionX))
				{
					binding.Path = curveID;
					binding.Attribute = 1; //kBindTransformPosition
					binding.SetClassID(ClassIDType.Transform);
					i += 3;
				}
				else if (curveTypeID == 2211994246) //CRC(QuaternionX))
				{
					binding.Path = curveID;
					binding.Attribute = 2; //kBindTransformRotation
					binding.SetClassID(ClassIDType.Transform);
					i += 4;
				}
				else if (curveTypeID == 1512518241) //CRC(ScaleX))
				{
					binding.Path = curveID;
					binding.Attribute = 3; //kBindTransformScale
					binding.SetClassID(ClassIDType.Transform);
					i += 3;
				}
				else
				{
					binding.Path = 0;
					binding.Attribute = curveID;
					binding.SetClassID(ClassIDType.Animator);
					i++;
				}
			}
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/CollisionModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.CollisionModule;

namespace AssetRipper.SourceGenerated.Extensions;

public static class CollisionModuleExtensions
{
	public static ParticleSystemCollisionType GetCollisionType(this ICollisionModule module)
	{
		return (ParticleSystemCollisionType)module.Type;
	}

	public static ParticleSystemCollisionMode GetCollisionMode(this ICollisionModule module)
	{
		return (ParticleSystemCollisionMode)module.CollisionMode;
	}

	public static ParticleSystemCollisionQuality GetCollisionQuality(this ICollisionModule module)
	{
		return (ParticleSystemCollisionQuality)module.Quality;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ColorRGBA32Extensions.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Subclasses.ColorRGBA32;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ColorRGBA32Extensions
{
	extension(ColorRGBA32 color)
	{
		public void SetValues(byte r, byte g, byte b, byte a)
		{
			color.Rgba = unchecked((uint)(r | g << 8 | b << 16 | a << 24));
		}

		public void SetAsBlack() => color.SetValues(byte.MinValue, byte.MinValue, byte.MinValue, byte.MaxValue);

		public void SetAsWhite() => color.SetValues(uint.MaxValue);

		public byte R
		{
			get => unchecked((byte)color.Rgba);
			set => color.SetValues(value, color.G, color.B, color.A);
		}

		public byte G
		{
			get => unchecked((byte)(color.Rgba >> 8));
			set => color.SetValues(color.R, value, color.B, color.A);
		}

		public byte B
		{
			get => unchecked((byte)(color.Rgba >> 16));
			set => color.SetValues(color.R, color.G, value, color.A);
		}

		public byte A
		{
			get => unchecked((byte)(color.Rgba >> 24));
			set => color.SetValues(color.R, color.G, color.B, value);
		}

		public ColorFloat ToColorFloat()
		{
			return (ColorFloat)Color32.FromRgba(color.Rgba);
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ColorRGBAfExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.ColorRGBAf;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ColorRGBAfExtensions
{
	public static void SetAsBlack(this IColorRGBAf color) => color.SetValues(0f, 0f, 0f, 1f);

	public static void SetAsWhite(this IColorRGBAf color) => color.SetValues(1f, 1f, 1f, 1f);
}

```

`Source/AssetRipper.SourceGenerated.Extensions/CompressedAnimationCurveExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Subclasses.CompressedAnimationCurve;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Quaternionf;
using AssetRipper.SourceGenerated.Subclasses.QuaternionCurve;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class CompressedAnimationCurveExtensions
{
	public static void Unpack(this CompressedAnimationCurve compressedAnimationCurve, UnityVersion version, IQuaternionCurve destinationCurve)
	{
		int[] timesValues = compressedAnimationCurve.Times.UnpackInts();
		float[] times = new float[timesValues.Length];
		for (int i = 0; i < times.Length; i++)
		{
			times[i] = timesValues[i] * 0.01f;
		}
		Quaternion[] rotations = compressedAnimationCurve.Values.Unpack();
		float[] slopes = compressedAnimationCurve.Slopes.Unpack();


		AccessListBase<IKeyframe_Quaternionf> keyframes = destinationCurve.Curve.Curve; //new KeyframeTpl<Quaternionf>[rotations.Length];
		keyframes.Clear();
		keyframes.Capacity = rotations.Length;

		for (int i = 0, j = 4; i < rotations.Length; i++, j += 4)
		{
			float time = times[i];
			Quaternion rotation = rotations[i];
			Quaternion inSlope = new Quaternion(slopes[j - 4], slopes[j - 3], slopes[j - 2], slopes[j - 1]);
			Quaternion outSlope = new Quaternion(slopes[j + 0], slopes[j + 1], slopes[j + 2], slopes[j + 3]);
			IKeyframe_Quaternionf keyframe = keyframes.AddNew();
			keyframe.SetValues(version, time, rotation, inSlope, outSlope, 1.0f / 3.0f);
		}
		destinationCurve.Path = compressedAnimationCurve.Path;
		destinationCurve.Curve.SetDefaultRotationOrderAndCurveLoopType();
		destinationCurve.Curve.PreInfinity = compressedAnimationCurve.PreInfinity;
		destinationCurve.Curve.PostInfinity = compressedAnimationCurve.PostInfinity;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/CompressedMeshExtensions.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Subclasses.CompressedMesh;
using AssetRipper.SourceGenerated.Subclasses.PackedBitVector_Single;
using System.Buffers;
using System.Numerics;
using System.Runtime.InteropServices;

namespace AssetRipper.SourceGenerated.Extensions;

public static class CompressedMeshExtensions
{
	extension(ICompressedMesh compressedMesh)
	{
		public bool IsSet => compressedMesh.Vertices.NumItems > 0;

		public void Decompress(out Vector3[]? vertices,
			out Vector3[]? normals,
			out Vector4[]? tangents,
			out ColorFloat[]? colors,
			out Vector2[]? uv0,
			out Vector2[]? uv1,
			out Vector2[]? uv2,
			out Vector2[]? uv3,
			out Vector2[]? uv4,
			out Vector2[]? uv5,
			out Vector2[]? uv6,
			out Vector2[]? uv7,
			out BoneWeight4[]? skin,
			out Matrix4x4[]? bindPose,
			out uint[]? processedIndexBuffer)
		{
			vertices = default;
			normals = default;
			tangents = default;
			colors = default;
			skin = default;
			bindPose = default;
			processedIndexBuffer = default;

			//Vertex
			if (compressedMesh.Vertices.NumItems > 0)
			{
				vertices = compressedMesh.GetVertices();
			}
			//UV
			compressedMesh.GetUV(out uv0, out uv1, out uv2, out uv3, out uv4, out uv5, out uv6, out uv7);
			//BindPose
			if (compressedMesh.Has_BindPoses() && compressedMesh.BindPoses.NumItems > 0)
			{
				bindPose = compressedMesh.GetBindPoses();
			}
			//Normal
			if (compressedMesh.Normals.NumItems > 0)
			{
				normals = compressedMesh.GetNormals();
			}
			//Tangent
			if (compressedMesh.Tangents.NumItems > 0)
			{
				tangents = compressedMesh.GetTangents();
			}
			//FloatColor / Color
			if (compressedMesh.Has_FloatColors() && compressedMesh.FloatColors.NumItems > 0
				|| compressedMesh.Has_Colors() && compressedMesh.Colors.NumItems > 0)
			{
				colors = compressedMesh.GetFloatColors();
			}
			//Skin
			if (compressedMesh.Weights.NumItems > 0)
			{
				skin = compressedMesh.GetWeights();
			}
			//IndexBuffer
			if (compressedMesh.Triangles.NumItems > 0)
			{
				processedIndexBuffer = compressedMesh.GetTriangles();
			}
		}

		private int GetVertexCount()
		{
			return (int)compressedMesh.Vertices.NumItems / 3;//3 floats in a Vector3
		}

		public void GetUV(out Vector2[]? uv0, out Vector2[]? uv1, out Vector2[]? uv2, out Vector2[]? uv3, out Vector2[]? uv4, out Vector2[]? uv5, out Vector2[]? uv6, out Vector2[]? uv7)
		{
			int vertexCount = compressedMesh.GetVertexCount();
			if (compressedMesh.UV.NumItems > 0)
			{
				UVInfo m_UVInfo = compressedMesh.UVInfo;
				if (compressedMesh.Has_UVInfo() && m_UVInfo != UVInfo.Zero)
				{
					int uvSrcOffset = 0;
					uv0 = ReadChannel(compressedMesh.UV, m_UVInfo, 0, vertexCount, ref uvSrcOffset);
					uv1 = ReadChannel(compressedMesh.UV, m_UVInfo, 1, vertexCount, ref uvSrcOffset);
					uv2 = ReadChannel(compressedMesh.UV, m_UVInfo, 2, vertexCount, ref uvSrcOffset);
					uv3 = ReadChannel(compressedMesh.UV, m_UVInfo, 3, vertexCount, ref uvSrcOffset);
					uv4 = ReadChannel(compressedMesh.UV, m_UVInfo, 4, vertexCount, ref uvSrcOffset);
					uv5 = ReadChannel(compressedMesh.UV, m_UVInfo, 5, vertexCount, ref uvSrcOffset);
					uv6 = ReadChannel(compressedMesh.UV, m_UVInfo, 6, vertexCount, ref uvSrcOffset);
					uv7 = ReadChannel(compressedMesh.UV, m_UVInfo, 7, vertexCount, ref uvSrcOffset);
				}
				else
				{
					uv0 = MeshHelper.FloatArrayToVector2(compressedMesh.UV.Unpack(2, 2, 0, vertexCount));
					if (compressedMesh.UV.NumItems >= vertexCount * sizeof(float))
					{
						uv1 = MeshHelper.FloatArrayToVector2(compressedMesh.UV.Unpack(2, 2, vertexCount * 2, vertexCount));
					}
					else
					{
						uv1 = default;
					}
					uv2 = default;
					uv3 = default;
					uv4 = default;
					uv5 = default;
					uv6 = default;
					uv7 = default;
				}
			}
			else
			{
				uv0 = default;
				uv1 = default;
				uv2 = default;
				uv3 = default;
				uv4 = default;
				uv5 = default;
				uv6 = default;
				uv7 = default;
			}
		}

		public void SetUV(ReadOnlySpan<Vector2> uv0, ReadOnlySpan<Vector2> uv1, ReadOnlySpan<Vector2> uv2, ReadOnlySpan<Vector2> uv3, ReadOnlySpan<Vector2> uv4, ReadOnlySpan<Vector2> uv5, ReadOnlySpan<Vector2> uv6, ReadOnlySpan<Vector2> uv7)
		{
			if (!compressedMesh.Has_UVInfo() || AllEmpty(uv2, uv3, uv4, uv5, uv6, uv7))
			{
				compressedMesh.UVInfo = 0;
				if (uv0.Length == 0)
				{
					compressedMesh.UV.Pack(default);
				}
				else if (uv1.Length == 0)
				{
					compressedMesh.UV.Pack(uv0);
				}
				else if (uv0.Length != uv1.Length)
				{
					throw new ArgumentException("UV arrays must be the same length.");
				}
				else
				{
					int length = uv0.Length + uv1.Length;
					using RentedArray<Vector2> concatenated = new(length);
					uv0.CopyTo(concatenated);
					uv1.CopyTo(concatenated.Slice(uv0.Length));
					compressedMesh.UV.Pack<Vector2>(concatenated);
				}
			}
			else
			{
				int totalLength = uv0.Length + uv1.Length + uv2.Length + uv3.Length + uv4.Length + uv5.Length + uv6.Length + uv7.Length;
				using RentedArray<Vector2> buffer = new(totalLength);
				int currentOffset = 0;
				UVInfo uvInfo = default;
				UpdateBuffer(uv0, 0, buffer, ref currentOffset, ref uvInfo);
				UpdateBuffer(uv1, 1, buffer, ref currentOffset, ref uvInfo);
				UpdateBuffer(uv2, 2, buffer, ref currentOffset, ref uvInfo);
				UpdateBuffer(uv3, 3, buffer, ref currentOffset, ref uvInfo);
				UpdateBuffer(uv4, 4, buffer, ref currentOffset, ref uvInfo);
				UpdateBuffer(uv5, 5, buffer, ref currentOffset, ref uvInfo);
				UpdateBuffer(uv6, 6, buffer, ref currentOffset, ref uvInfo);
				UpdateBuffer(uv7, 7, buffer, ref currentOffset, ref uvInfo);
				compressedMesh.UV.Pack<Vector2>(buffer);
				compressedMesh.UVInfo = uvInfo;
			}

			static bool AllEmpty(ReadOnlySpan<Vector2> uv2, ReadOnlySpan<Vector2> uv3, ReadOnlySpan<Vector2> uv4, ReadOnlySpan<Vector2> uv5, ReadOnlySpan<Vector2> uv6, ReadOnlySpan<Vector2> uv7)
			{
				return uv2.Length == 0 && uv3.Length == 0 && uv4.Length == 0 && uv5.Length == 0 && uv6.Length == 0 && uv7.Length == 0;
			}
		}

		// To do: convert back to local function
		// https://github.com/dotnet/roslyn/issues/78913
		// https://github.com/dotnet/roslyn/issues/78915
		private static void UpdateBuffer(ReadOnlySpan<Vector2> uv, int uvIndex, Span<Vector2> buffer, ref int currentOffset, ref UVInfo uvInfo)
		{
			if (uv.Length > 0)
			{
				uvInfo = uvInfo.AddChannelInfo(uvIndex, true, 2);
				uv.CopyTo(buffer[currentOffset..]);
				currentOffset += uv.Length;
			}
		}

		public BoneWeight4[] GetWeights()
		{
			int[] weights = compressedMesh.Weights.UnpackInts();
			int[] boneIndices = compressedMesh.BoneIndices.UnpackInts();

			//In theory, the array length should be exactly the same as the number of vertices, but it's better to be safe.
			BoneWeight4[] skin = ArrayPool<BoneWeight4>.Shared.Rent((int)compressedMesh.Weights.NumItems);

			int bonePos = 0;
			int boneIndexPos = 0;
			int j = 0;
			int sum = 0;

			for (int i = 0; i < compressedMesh.Weights.NumItems; i++)
			{
				//read bone index and weight.
				{
					BoneWeight4 boneWeight = skin[bonePos];
					boneWeight.Weights[j] = weights[i] / 31f;
					boneWeight.Indices[j] = boneIndices[boneIndexPos++];
					skin[bonePos] = boneWeight;
				}
				j++;
				sum += weights[i];

				//the weights add up to one. fill the rest for this vertex with zero, and continue with next one.
				if (sum >= 31)
				{
					for (; j < 4; j++)
					{
						BoneWeight4 boneWeight = skin[bonePos];
						boneWeight.Weights[j] = 0;
						boneWeight.Indices[j] = 0;
						skin[bonePos] = boneWeight;
					}
					bonePos++;
					j = 0;
					sum = 0;
				}
				//we read three weights, but they don't add up to one. calculate the fourth one, and read
				//missing bone index. continue with next vertex.
				else if (j == 3)
				{
					BoneWeight4 boneWeight = skin[bonePos];
					boneWeight.Weights[j] = (31 - sum) / 31f;
					boneWeight.Indices[j] = boneIndices[boneIndexPos++];
					skin[bonePos] = boneWeight;
					bonePos++;
					j = 0;
					sum = 0;
				}
			}

			BoneWeight4[] result = skin.AsSpan(0, bonePos).ToArray();
			ArrayPool<BoneWeight4>.Shared.Return(skin);
			return result;
		}

		public void SetWeights(ReadOnlySpan<BoneWeight4> skin)
		{
			if (skin.Length > 0)
			{
				int i_weight = 0;
				int i_boneIndex = 0;
				int[] weightList = ArrayPool<int>.Shared.Rent(skin.Length * 3);
				int[] boneIndexList = ArrayPool<int>.Shared.Rent(skin.Length * 4);

				foreach (BoneWeight4 boneWeight in skin)
				{
					int sum = 0;
					for (int j = 0; j < 4; j++)
					{
						int weight = (int)(boneWeight.Weights[j] * 31);
						sum += weight;
						if (j != 3)
						{
							//We never store the last weight because it can be calculated from the sum of the other weights.
							weightList[i_weight] = weight;
							i_weight++;
						}

						boneIndexList[i_boneIndex] = boneWeight.Indices[j];
						i_boneIndex++;

						if (sum >= 31)
						{
							break;
						}
					}
				}

				compressedMesh.Weights.PackInts(weightList.AsSpan(0, i_weight));
				compressedMesh.BoneIndices.PackInts(boneIndexList.AsSpan(0, i_boneIndex));

				ArrayPool<int>.Shared.Return(weightList);
				ArrayPool<int>.Shared.Return(boneIndexList);
			}
			else
			{
				compressedMesh.Weights.Reset();
				compressedMesh.BoneIndices.Reset();
			}
		}

		public Vector3[] GetNormals()
		{
			float[] normalData = compressedMesh.Normals.Unpack(2, 2);
			int[] signs = compressedMesh.NormalSigns.UnpackInts();
			Vector3[] normals = new Vector3[compressedMesh.Normals.NumItems / 2];
			for (int i = 0; i < compressedMesh.Normals.NumItems / 2; ++i)
			{
				float x = normalData[i * 2 + 0];
				float y = normalData[i * 2 + 1];
				float zsqr = 1 - x * x - y * y;
				float z;
				if (zsqr >= 0)
				{
					z = (float)Math.Sqrt(zsqr);
				}
				else
				{
					z = 0;
					Vector3 normal = Vector3.Normalize(new Vector3(x, y, z));
					x = normal.X;
					y = normal.Y;
					z = normal.Z;
				}
				if (signs[i] == 0)
				{
					z = -z;
				}

				normals[i] = new Vector3(x, y, z);
			}

			return normals;
		}

		public void SetNormals(ReadOnlySpan<Vector3> normals)
		{
			MakeFloatAndSignArrays(normals, out float[] floats, out uint[] signs);
			compressedMesh.Normals.Pack(floats);
			compressedMesh.NormalSigns.PackUInts(signs);
		}

		public Vector4[] GetTangents()
		{
			float[] tangentData = compressedMesh.Tangents.Unpack(2, 2);
			int[] signs = compressedMesh.TangentSigns.UnpackInts();
			Vector4[] tangents = new Vector4[compressedMesh.Tangents.NumItems / 2];
			for (int i = 0; i < compressedMesh.Tangents.NumItems / 2; ++i)
			{
				float x = tangentData[i * 2 + 0];
				float y = tangentData[i * 2 + 1];
				float zsqr = 1 - x * x - y * y;
				float z;
				if (zsqr >= 0f)
				{
					z = (float)Math.Sqrt(zsqr);
				}
				else
				{
					z = 0;
					Vector3 tangent = Vector3.Normalize(new Vector3(x, y, z));
					x = tangent.X;
					y = tangent.Y;
					z = tangent.Z;
				}
				if (signs[i * 2 + 0] == 0)
				{
					z = -z;
				}

				float w = signs[i * 2 + 1] == 0 ? -1.0f : 1.0f;
				tangents[i] = new Vector4(x, y, z, w);
			}

			return tangents;
		}

		public void SetTangents(ReadOnlySpan<Vector4> tangents)
		{
			MakeFloatAndSignArrays(tangents, out float[] floats, out uint[] signs);
			compressedMesh.Tangents.Pack(floats);
			compressedMesh.TangentSigns.PackUInts(signs);
		}

		/// <summary>
		/// Only available before Unity 5
		/// </summary>
		/// <param name="compressedMesh"></param>
		/// <returns></returns>
		public Matrix4x4[] GetBindPoses()
		{
			if (compressedMesh.Has_BindPoses())
			{
				const int MatrixFloats = 16;
				Matrix4x4[] bindPose = new Matrix4x4[compressedMesh.BindPoses.NumItems / MatrixFloats];
				float[] m_BindPoses_Unpacked = compressedMesh.BindPoses.Unpack(MatrixFloats, MatrixFloats);
				MemoryMarshal.Cast<float, Matrix4x4>(m_BindPoses_Unpacked).CopyTo(bindPose);

				// The Unity memory layout is transposed from the .NET Core memory layout.
				for (int i = 0; i < bindPose.Length; i++)
				{
					bindPose[i] = Matrix4x4.Transpose(bindPose[i]);
				}

				return bindPose;
			}
			else
			{
				return [];
			}
		}

		/// <summary>
		/// Only available before Unity 5
		/// </summary>
		/// <param name="compressedMesh"></param>
		/// <param name="bindPoses"></param>
		public void SetBindPoses(ReadOnlySpan<Matrix4x4> bindPoses)
		{
			if (!compressedMesh.Has_BindPoses())
			{
			}
			else if (bindPoses.Length == 0)
			{
				compressedMesh.BindPoses.Pack([]);
			}
			else
			{
				// The Unity memory layout is transposed from the .NET Core memory layout.
				using RentedArray<Matrix4x4> temp = new(bindPoses.Length);
				for (int i = 0; i < temp.Length; i++)
				{
					temp[i] = Matrix4x4.Transpose(bindPoses[i]);
				}
				compressedMesh.BindPoses.Pack(MemoryMarshal.Cast<Matrix4x4, float>(temp));
			}
		}

		public Vector3[] GetVertices()
		{
			float[] verticesData = compressedMesh.Vertices.Unpack(3, 3);
			return MeshHelper.FloatArrayToVector3(verticesData);
		}

		public void SetVertices(ReadOnlySpan<Vector3> vertices)
		{
			compressedMesh.Vertices.Pack(MemoryMarshal.Cast<Vector3, float>(vertices));
		}

		public ColorFloat[] GetFloatColors()
		{
			if (compressedMesh.Has_FloatColors())
			{
				return MeshHelper.FloatArrayToColorFloat(compressedMesh.FloatColors.Unpack(1, 1));
			}
			else if (compressedMesh.Has_Colors())
			{
				compressedMesh.Colors.NumItems *= 4;
				compressedMesh.Colors.BitSize /= 4;
				int[] tempColors = compressedMesh.Colors.UnpackInts();
				ColorFloat[] colors = new ColorFloat[compressedMesh.Colors.NumItems / 4];
				for (int v = 0; v < compressedMesh.Colors.NumItems / 4; v++)
				{
					colors[v] = (ColorFloat)new Color32((byte)tempColors[4 * v], (byte)tempColors[4 * v + 1], (byte)tempColors[4 * v + 2], (byte)tempColors[4 * v + 3]);
				}
				compressedMesh.Colors.NumItems /= 4;
				compressedMesh.Colors.BitSize *= 4;
				return colors;
			}
			else
			{
				return [];
			}
		}

		public void SetFloatColors(ReadOnlySpan<ColorFloat> colors)
		{
			if (compressedMesh.Has_FloatColors())
			{
				compressedMesh.FloatColors.Pack(colors);
			}
			else if (compressedMesh.Has_Colors())
			{
				Color32[] buffer = ArrayPool<Color32>.Shared.Rent(colors.Length);
				for (int i = 0; i < colors.Length; i++)
				{
					buffer[i] = (Color32)colors[i];
				}
				compressedMesh.Colors.PackUInts(MemoryMarshal.Cast<Color32, uint>(new ReadOnlySpan<Color32>(buffer, 0, colors.Length)));
				ArrayPool<Color32>.Shared.Return(buffer);
			}
		}

		public uint[] GetTriangles()
		{
			return compressedMesh.Triangles.UnpackUInts();
		}

		public void SetTriangles(ReadOnlySpan<uint> triangles)
		{
			compressedMesh.Triangles.PackUInts(triangles);
		}
	}

	private static Vector2[]? ReadChannel(PackedBitVector_Single packedVector, UVInfo uvInfo, int channelIndex, int vertexCount, ref int currentOffset)
	{
		uvInfo.GetChannelInfo(channelIndex, out bool exists, out int uvDim);
		if (exists)
		{
			Vector2[] m_UV = MeshHelper.FloatArrayToVector2(packedVector.Unpack(uvDim, uvDim, currentOffset, vertexCount), uvDim);
			currentOffset += uvDim * vertexCount;
			return m_UV;
		}
		else
		{
			return null;
		}
	}

	private static void MakeFloatAndSignArrays(ReadOnlySpan<Vector3> normals, out float[] floats, out uint[] signs)
	{
		floats = new float[normals.Length * 2];
		signs = new uint[normals.Length];
		for (int i = 0; i < normals.Length; i++)
		{
			//Normals should already be normalized, but it's better to be safe.
			Vector3 vector = Vector3.Normalize(normals[i]);
			floats[2 * i] = vector.X;
			floats[2 * i + 1] = vector.Y;
			signs[i] = vector.Z < 0 ? 0u : 1u;
		}
	}

	private static void MakeFloatAndSignArrays(ReadOnlySpan<Vector4> tangents, out float[] floats, out uint[] signs)
	{
		floats = new float[tangents.Length * 2];
		signs = new uint[tangents.Length * 2];
		for (int i = 0; i < tangents.Length; i++)
		{
			//Tangents should already be normalized, but it's better to be safe.
			Vector3 vector = Vector3.Normalize(tangents[i].AsVector3());
			floats[2 * i] = vector.X;
			floats[2 * i + 1] = vector.Y;
			signs[2 * i] = vector.Z < 0 ? 0u : 1u;
			signs[2 * i + 1] = tangents[i].W < 0 ? 0u : 1u;
		}
	}

	private readonly ref struct RentedArray<T>
	{
		private readonly T[]? array;

		public int Length { get; }

		public RentedArray(int length)
		{
			Length = length;
			array = ArrayPool<T>.Shared.Rent(length);
		}

		public ref T this[int index] => ref AsSpan()[index];

		public void Dispose()
		{
			if (array != null)
			{
				ArrayPool<T>.Shared.Return(array);
			}
		}

		public Span<T> AsSpan() => new Span<T>(array, 0, Length);

		public Span<T> Slice(int start) => new Span<T>(array, start, Length - start);

		//Implicit conversions to Span<T> and ReadOnlySpan<T>
		public static implicit operator Span<T>(RentedArray<T> rentedArray) => rentedArray.AsSpan();
		public static implicit operator ReadOnlySpan<T>(RentedArray<T> rentedArray) => rentedArray.AsSpan();
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ConstantClipExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.ConstantClip;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ConstantClipExtensions
{
	public static bool IsSet(this IConstantClip clip) => clip.Data.Count > 0;
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ControllerConstantExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.ControllerConstant;
using AssetRipper.SourceGenerated.Subclasses.LayerConstant;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ControllerConstantExtensions
{
	public static ILayerConstant GetLayerByStateMachineIndex(this IControllerConstant controllerConstant, int index)
	{
		for (int i = 0; i < controllerConstant.LayerArray.Count; i++)
		{
			ILayerConstant layer = controllerConstant.LayerArray[i].Data;
			if (layer.StateMachineIndex == index && layer.StateMachineSynchronizedLayerIndex == 0)
			{
				return layer;
			}
		}
		throw new ArgumentOutOfRangeException(nameof(index));
	}

	public static int GetLayerIndexByStateMachineIndex(this IControllerConstant controllerConstant, int index, out ILayerConstant layer)
	{
		for (int i = 0; i < controllerConstant.LayerArray.Count; i++)
		{
			layer = controllerConstant.LayerArray[i].Data;
			if (layer.StateMachineIndex == index && layer.StateMachineSynchronizedLayerIndex == 0)
			{
				return i;
			}
		}
		throw new ArgumentOutOfRangeException(nameof(index));
	}

	public static int GetLayerIndex(this IControllerConstant controllerConstant, ILayerConstant layer)
	{
		for (int i = 0; i < controllerConstant.LayerArray.Count; i++)
		{
			ILayerConstant checkLayer = controllerConstant.LayerArray[i].Data;
			if (checkLayer.StateMachineIndex == layer.StateMachineIndex && checkLayer.StateMachineSynchronizedLayerIndex == layer.StateMachineSynchronizedLayerIndex)
			{
				return i;
			}
		}
		throw new ArgumentException("Layer hasn't been found", nameof(layer));
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/CrashReportingSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.CrashReportingSettings;

namespace AssetRipper.SourceGenerated.Extensions;

public static class CrashReportingSettingsExtensions
{
	public static void ConvertToEditorFormat(this ICrashReportingSettings settings)
	{
		if (settings.Has_NativeEventUrl() && settings.NativeEventUrl.Data.Length == 0)
		{
			settings.NativeEventUrl = "https://perf-events.cloud.unity3d.com/symbolicate"; //not sure where this url came from
		}

		// NOTE: editor has different value than player
		settings.LogBufferSize = 10;

		settings.CaptureEditorExceptions = true;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/CubemapArrayExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_188;

namespace AssetRipper.SourceGenerated.Extensions;

public static class CubemapArrayExtensions
{
	public static int GetHeight(this ICubemapArray texture)
	{
		return texture.Width;
	}

	public static int GetDepth(this ICubemapArray texture)
	{
		return texture.CubemapCount * 6;// Not sure about this
	}

	public static byte[] GetImageData(this ICubemapArray texture)
	{
		if (texture.ImageData.Length > 0)
		{
			return texture.ImageData;
		}
		else if (texture.Has_StreamData() && texture.StreamData.IsSet())
		{
			return texture.StreamData.GetContent(texture.Collection);
		}
		else
		{
			return [];
		}
	}

	public static bool CheckAssetIntegrity(this ICubemapArray texture)
	{
		if (texture.ImageData.Length > 0)
		{
			return true;
		}
		else if (texture.Has_StreamData())
		{
			return texture.StreamData.CheckIntegrity(texture.Collection);
		}
		else
		{
			return false;
		}
	}

	public static int GetCompleteImageSize(this ICubemapArray texture)
	{
		int depth = texture.GetDepth();
		return depth > 0 ? (int)texture.DataSize / depth : 0;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/CustomDataModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.CustomDataModule;

namespace AssetRipper.SourceGenerated.Extensions;

public static class CustomDataModuleExtensions
{
	public static ParticleSystemCustomDataMode GetMode0(this ICustomDataModule module)
	{
		return (ParticleSystemCustomDataMode)module.Mode0;
	}

	public static ParticleSystemCustomDataMode GetMode1(this ICustomDataModule module)
	{
		return (ParticleSystemCustomDataMode)module.Mode1;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/DenseClipExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.DenseClip;

namespace AssetRipper.SourceGenerated.Extensions;

public static class DenseClipExtensions
{
	public static bool IsSet(this IDenseClip clip) => clip.SampleArray.Count > 0;
}

```

`Source/AssetRipper.SourceGenerated.Extensions/EditorSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_159;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class EditorSettingsExtensions
{
	private const string DefaultExtensions = "txt;xml;fnt;cd;asmdef;rsp" + ";" + AsmrefExtension;
	private const string AsmrefExtension = "asmref";
	private const string HiddenMeta = "Hidden Meta Files";
	private const string VisibleMeta = "Visible Meta Files";

	public static void SetToDefaults(this IEditorSettings settings)
	{
		settings.ExternalVersionControlSupport_Utf8String = VisibleMeta;
		settings.ExternalVersionControlSupport_Int32 = (int)ExternalVersionControl.Generic;

		settings.SerializationModeE = SerializationMode.ForceText;
		settings.SerializeInlineMappingsOnOneLine = true;
		settings.SpritePackerPaddingPower = 1;
		settings.EtcTextureCompressorBehavior = 1;
		settings.EtcTextureFastCompressor = 1;
		settings.EtcTextureNormalCompressor = 2;
		settings.EtcTextureBestCompressor = 4;
		settings.ProjectGenerationIncludedExtensions = DefaultExtensions;
		settings.ProjectGenerationRootNamespace = Utf8String.Empty;
		if (settings.Has_CollabEditorSettings())
		{
			settings.CollabEditorSettings.InProgressEnabled = true;
		}
		settings.UserGeneratedProjectSuffix = Utf8String.Empty;
		settings.EnableTextureStreamingInEditMode = true;
		settings.EnableTextureStreamingInPlayMode = true;
		settings.AsyncShaderCompilation = true;

		//Version 2 is the default whenever this property is available.
		//Similarly, version 1 is marked obsolete in those versions.
		//https://docs.unity3d.com/Manual/AssetDatabase.html
		settings.AssetPipelineModeE = AssetPipelineMode.Version2;

		settings.CacheServerModeE = CacheServerMode_1.AsPreferences;
		settings.CacheServerEndpoint = Utf8String.Empty;
		settings.CacheServerNamespacePrefix = (Utf8String)"default"u8;
		settings.CacheServerEnableDownload = true;
		settings.CacheServerEnableUpload = true;

		settings.ShowLightmapResolutionOverlay = true;
		settings.UseLegacyProbeSampleCount = true;
		settings.EnterPlayModeOptionsE = EnterPlayModeOptions.DisableDomainReload | EnterPlayModeOptions.DisableSceneReload;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/EmissionModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.EmissionModule;
using AssetRipper.SourceGenerated.Subclasses.MinMaxCurve;

namespace AssetRipper.SourceGenerated.Extensions;

public static class EmissionModuleExtensions
{
	public static IMinMaxCurve? GetRateOverTime(this IEmissionModule module)
	{
		if (module.Has_RateOverTime())
		{
			return module.RateOverTime;
		}
		else if (module.Has_Type() && module.TypeE == ParticleSystemEmissionType.Time)
		{
			return module.Rate;
		}
		else
		{
			return null;
		}
	}

	public static IMinMaxCurve? GetRateOverDistance(this IEmissionModule module)
	{
		if (module.Has_RateOverDistance())
		{
			return module.RateOverDistance;
		}
		else if (module.Has_Type() && module.TypeE == ParticleSystemEmissionType.Distance)
		{
			return module.Rate;
		}
		else
		{
			return null;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/EndianWriterExtensions.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.Numerics;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

internal static class EndianWriterExtensions
{
	public static void Write(this EndianWriter writer, Vector2 value)
	{
		writer.Write(value.X);
		writer.Write(value.Y);
	}
	public static void Write(this EndianWriter writer, Vector3 value)
	{
		writer.Write(value.X);
		writer.Write(value.Y);
		writer.Write(value.Z);
	}
	public static void Write(this EndianWriter writer, Vector4 value)
	{
		writer.Write(value.X);
		writer.Write(value.Y);
		writer.Write(value.Z);
		writer.Write(value.W);
	}
	public static void Write(this EndianWriter writer, Color32 value)
	{
		writer.Write(value.R);
		writer.Write(value.G);
		writer.Write(value.B);
		writer.Write(value.A);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/EnlightenSceneMappingExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.EnlightenSceneMapping;

namespace AssetRipper.SourceGenerated.Extensions;

public static class EnlightenSceneMappingExtensions
{
	public static bool IsEmpty(this IEnlightenSceneMapping mapping)
	{
		return mapping.Renderers.Count == 0
			&& mapping.SystemAtlases.Count == 0
			&& mapping.Systems.Count == 0
			&& mapping.TerrainChunks.Count == 0
			&& (mapping.Probesets?.Count ?? 0) == 0;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/EnumerableExtensions.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions;

public static class EnumerableExtensions
{
	public static IEnumerable<T> WhereNotNull<T>(this IEnumerable<T?> enumerable) where T : notnull
	{
		foreach (T? item in enumerable)
		{
			if (item is not null)
			{
				yield return item;
			}
		}
	}

	public static IEnumerable<T> ThrowIfNull<T>(this IEnumerable<T?> enumerable) where T : notnull
	{
		foreach (T? item in enumerable)
		{
			if (item is null)
			{
				throw new NullReferenceException();
			}
			yield return item;
		}
	}

	public static IEnumerable<T> MaybeAppend<T>(this IEnumerable<T> enumerable, T? item)
	{
		return item is not null ? enumerable.Append(item) : enumerable;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/AnimationClip/Bones/ArmType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.Bones;

public enum ArmType
{
	LeftHand = 0,
	RightHand = 1,

	Last,
}

public static class ArmTypeExtensions
{
	public static BoneType ToBoneType(this ArmType _this)
	{
		return _this switch
		{
			ArmType.LeftHand => BoneType.LeftHand,
			ArmType.RightHand => BoneType.RightHand,
			_ => throw new ArgumentException(_this.ToString()),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/AnimationClip/Bones/BoneType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.Bones;

public enum BoneType
{
	Hips = 0,
	LeftUpperLeg = 1,
	RightUpperLeg = 2,
	LeftLowerLeg = 3,
	RightLowerLeg = 4,
	LeftFoot = 5,
	RightFoot = 6,
	Spine = 7,
	Chest = 8,
	UpperChest = 9,
	Neck = 10,
	Head = 11,
	LeftShoulder = 12,
	RightShoulder = 13,
	LeftUpperArm = 14,
	RightUpperArm = 15,
	LeftLowerArm = 16,
	RightLowerArm = 17,
	LeftHand = 18,
	RightHand = 19,
	LeftToes = 20,
	RightToes = 21,
	LeftEye = 22,
	RightEye = 23,
	Jaw = 24,

	Last,
}

public static class BoneTypeExtensions
{
	/// <summary>
	/// 5.6.0 and greater
	/// </summary>
	public static bool IsIncludeUpperChest(UnityVersion version) => version.GreaterThanOrEquals(5, 6);

	public static BoneType Update(this BoneType _this, UnityVersion version)
	{
		if (!IsIncludeUpperChest(version))
		{
			if (_this >= BoneType.UpperChest)
			{
				_this++;
			}
		}
		return _this;
	}

	public static string ToAttributeString(this BoneType _this)
	{
		if (_this < BoneType.Last)
		{
			return _this.ToString();
		}
		throw new ArgumentException(_this.ToString());
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/AnimationClip/Bones/FingerDoFType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.Bones;

public enum FingerDoFType
{
	_1Stretched = 0,
	Spread = 1,
	_2Stretched = 2,
	_3Stretched = 3,

	Last,
}

public static class FingerDoFTypeExtensions
{
	public static string ToAttributeString(this FingerDoFType _this)
	{
		return _this switch
		{
			FingerDoFType._1Stretched => "1 Stretched",
			FingerDoFType.Spread => "Spread",
			FingerDoFType._2Stretched => "2 Stretched",
			FingerDoFType._3Stretched => "3 Stretched",
			_ => throw new ArgumentException(_this.ToString()),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/AnimationClip/Bones/FingerType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.Bones;

public enum FingerType
{
	Thumb = 0,
	Index = 1,
	Middle = 2,
	Ring = 3,
	Little = 4,

	Last,
}

public static class FingerTypeExtensions
{
	public static string ToAttributeString(this FingerType _this)
	{
		if (_this < FingerType.Last)
		{
			return _this.ToString();
		}
		throw new ArgumentException(_this.ToString());
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/AnimationClip/Bones/LimbType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.Bones;

public enum LimbType
{
	LeftFoot = 0,
	RightFoot = 1,
	LeftHand = 2,
	RightHand = 3,

	Last,
}

public static class LimbTypeExtensions
{
	public static BoneType ToBoneType(this LimbType _this)
	{
		return _this switch
		{
			LimbType.LeftFoot => BoneType.LeftFoot,
			LimbType.RightFoot => BoneType.RightFoot,
			LimbType.LeftHand => BoneType.LeftHand,
			LimbType.RightHand => BoneType.RightHand,
			_ => throw new ArgumentException(_this.ToString()),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/AnimationClip/Bones/MuscleType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.Bones;

public enum MuscleType
{
	SpineFrontBack = 0,
	SpineLeftRight = 1,
	SpineTwistLeftRight = 2,
	ChestFrontBack = 3,
	ChestLeftRight = 4,
	ChestTwistLeftRight = 5,
	UpperchestFrontBack = 6,
	UpperchestLeftRight = 7,
	UpperchestTwisLeftRight = 8,
	NeckNodDownUp = 9,
	NeckTiltLeftRight = 10,
	NeckTurnLeftRight = 11,
	HeadNodDownUp = 12,
	HeadTiltLeftRight = 13,
	HeadTurnLeftRight = 14,
	LeftEyeDownUp = 15,
	LeftEyeInOut = 16,
	RightEyeDownUp = 17,
	RightEyeInOut = 18,
	JawClose = 19,
	JawLeftRight = 20,
	LeftUpperLegFrontBack = 21,
	LeftUpperLegInOut = 22,
	LeftUpperLegTwistInOut = 23,
	LeftLowerLegStretch = 24,
	LeftLowerLegTwistInOut = 25,
	LeftFootUpDown = 26,
	LeftFootTwistInOut = 27,
	LeftToesUpDown = 28,
	RightUpperLegFrontBack = 29,
	RightUpperLegInOut = 30,
	RightUpperLegTwistInOut = 31,
	RightLowerLegStretch = 32,
	RightLowerLegTwistInOut = 33,
	RightFootUpDown = 34,
	RightFootTwistInOut = 35,
	RightToesUpDown = 36,
	LeftShoulderDownUp = 37,
	LeftShoulderFrontBack = 38,
	LeftArmDownUp = 39,
	LeftArmFrontBack = 40,
	LeftArmTwistInOut = 41,
	LeftForearmStretch = 42,
	LeftForearmTwistInOut = 43,
	LeftHandDownUp = 44,
	LeftHandInOut = 45,
	RightShoulderDownUp = 46,
	RightShoulderFrontBack = 47,
	RightArmDownUp = 48,
	RightArmFrontBack = 49,
	RightArmTwistInOut = 50,
	RightForearmStretch = 51,
	RightForearmTwistInOut = 52,
	RightHandDownUp = 53,
	RightHandInOut = 54,

	Last,
}

public static class MuscleTypeExtensions
{
	/// <summary>
	/// 5.6.0 and greater
	/// </summary>
	public static bool IsIncludeUpperChest(UnityVersion version) => BoneTypeExtensions.IsIncludeUpperChest(version);

	public static MuscleType Update(this MuscleType _this, UnityVersion version)
	{
		if (!IsIncludeUpperChest(version))
		{
			if (_this >= MuscleType.UpperchestFrontBack)
			{
				_this += 3;
			}
		}
		return _this;
	}

	public static string ToAttributeString(this MuscleType _this)
	{
		return _this switch
		{
			MuscleType.SpineFrontBack => "Spine Front-Back",
			MuscleType.SpineLeftRight => "Spine Left-Right",
			MuscleType.SpineTwistLeftRight => "Spine Twist Left-Right",
			MuscleType.ChestFrontBack => "Chest Front-Back",
			MuscleType.ChestLeftRight => "Chest Left-Right",
			MuscleType.ChestTwistLeftRight => "Chest Twist Left-Right",
			MuscleType.UpperchestFrontBack => "UpperChest Front-Back",
			MuscleType.UpperchestLeftRight => "UpperChest Left-Right",
			MuscleType.UpperchestTwisLeftRight => "UpperChest Twist Left-Right",
			MuscleType.NeckNodDownUp => "Neck Nod Down-Up",
			MuscleType.NeckTiltLeftRight => "Neck Tilt Left-Right",
			MuscleType.NeckTurnLeftRight => "Neck Turn Left-Right",
			MuscleType.HeadNodDownUp => "Head Nod Down-Up",
			MuscleType.HeadTiltLeftRight => "Head Tilt Left-Right",
			MuscleType.HeadTurnLeftRight => "Head Turn Left-Right",
			MuscleType.LeftEyeDownUp => "Left Eye Down-Up",
			MuscleType.LeftEyeInOut => "Left Eye In-Out",
			MuscleType.RightEyeDownUp => "Right Eye Down-Up",
			MuscleType.RightEyeInOut => "Right Eye In-Out",
			MuscleType.JawClose => "Jaw Close",
			MuscleType.JawLeftRight => "Jaw Left-Right",
			MuscleType.LeftUpperLegFrontBack => "Left Upper Leg Front-Back",
			MuscleType.LeftUpperLegInOut => "Left Upper Leg In-Out",
			MuscleType.LeftUpperLegTwistInOut => "Left Upper Leg Twist In-Out",
			MuscleType.LeftLowerLegStretch => "Left Lower Leg Stretch",
			MuscleType.LeftLowerLegTwistInOut => "Left Lower Leg Twist In-Out",
			MuscleType.LeftFootUpDown => "Left Foot Up-Down",
			MuscleType.LeftFootTwistInOut => "Left Foot Twist In-Out",
			MuscleType.LeftToesUpDown => "Left Toes Up-Down",
			MuscleType.RightUpperLegFrontBack => "Right Upper Leg Front-Back",
			MuscleType.RightUpperLegInOut => "Right Upper Leg In-Out",
			MuscleType.RightUpperLegTwistInOut => "Right Upper Leg Twist In-Out",
			MuscleType.RightLowerLegStretch => "Right Lower Leg Stretch",
			MuscleType.RightLowerLegTwistInOut => "Right Lower Leg Twist In-Out",
			MuscleType.RightFootUpDown => "Right Foot Up-Down",
			MuscleType.RightFootTwistInOut => "Right Foot Twist In-Out",
			MuscleType.RightToesUpDown => "Right Toes Up-Down",
			MuscleType.LeftShoulderDownUp => "Left Shoulder Down-Up",
			MuscleType.LeftShoulderFrontBack => "Left Shoulder Front-Back",
			MuscleType.LeftArmDownUp => "Left Arm Down-Up",
			MuscleType.LeftArmFrontBack => "Left Arm Front-Back",
			MuscleType.LeftArmTwistInOut => "Left Arm Twist In-Out",
			MuscleType.LeftForearmStretch => "Left Forearm Stretch",
			MuscleType.LeftForearmTwistInOut => "Left Forearm Twist In-Out",
			MuscleType.LeftHandDownUp => "Left Hand Down-Up",
			MuscleType.LeftHandInOut => "Left Hand In-Out",
			MuscleType.RightShoulderDownUp => "Right Shoulder Down-Up",
			MuscleType.RightShoulderFrontBack => "Right Shoulder Front-Back",
			MuscleType.RightArmDownUp => "Right Arm Down-Up",
			MuscleType.RightArmFrontBack => "Right Arm Front-Back",
			MuscleType.RightArmTwistInOut => "Right Arm Twist In-Out",
			MuscleType.RightForearmStretch => "Right Forearm Stretch",
			MuscleType.RightForearmTwistInOut => "Right Forearm Twist In-Out",
			MuscleType.RightHandDownUp => "Right Hand Down-Up",
			MuscleType.RightHandInOut => "Right Hand In-Out",
			_ => throw new ArgumentException(_this.ToString()),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/AnimationClip/Bones/TDoFBoneType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.Bones;

public enum TDoFBoneType
{
	Spine = 0,
	Chest = 1,
	UpperChest = 2,
	Neck = 3,
	Head = 4,
	LeftUpperLeg = 5,
	LeftLowerLeg = 6,
	LeftFoot = 7,
	LeftToes = 8,
	RightUpperLeg = 9,
	RightLowerLeg = 10,
	RightFoot = 11,
	RightToes = 12,
	LeftShoulder = 13,
	LeftUpperArm = 14,
	LeftLowerArm = 15,
	LeftHand = 16,
	RightShoulder = 17,
	RightUpperArm = 18,
	RightLowerArm = 19,
	RightHand = 20,

	Last,
}

public static class TDoFBoneTypeExtensions
{
	/// <summary>
	/// 5.6.0 and greater
	/// </summary>
	public static bool IsIncludeUpperChest(UnityVersion version) => BoneTypeExtensions.IsIncludeUpperChest(version);
	/// <summary>
	/// 2017.3 and greater
	/// </summary>
	public static bool IsIncludeHead(UnityVersion version) => version.GreaterThanOrEquals(2017, 3);
	/// <summary>
	/// 2017.3 and greater
	/// </summary>
	public static bool IsIncludeLeftLowerLeg(UnityVersion version) => version.GreaterThanOrEquals(2017, 3);
	/// <summary>
	/// 2017.3 and greater
	/// </summary>
	public static bool IsIncludeRightLowerLeg(UnityVersion version) => version.GreaterThanOrEquals(2017, 3);
	/// <summary>
	/// 2017.3 and greater
	/// </summary>
	public static bool IsIncludeLeftUpperArm(UnityVersion version) => version.GreaterThanOrEquals(2017, 3);
	/// <summary>
	/// 2017.3 and greater
	/// </summary>
	public static bool IsIncludeRightUpperArm(UnityVersion version) => version.GreaterThanOrEquals(2017, 3);

	public static TDoFBoneType Update(this TDoFBoneType _this, UnityVersion version)
	{
		if (!IsIncludeUpperChest(version))
		{
			if (_this >= TDoFBoneType.UpperChest)
			{
				_this++;
			}
		}
		if (!IsIncludeHead(version))
		{
			if (_this >= TDoFBoneType.Head)
			{
				_this++;
			}
		}
		if (!IsIncludeLeftLowerLeg(version))
		{
			if (_this >= TDoFBoneType.LeftLowerLeg)
			{
				_this += 3;
			}
		}
		if (!IsIncludeRightLowerLeg(version))
		{
			if (_this >= TDoFBoneType.RightLowerLeg)
			{
				_this += 3;
			}
		}
		if (!IsIncludeLeftUpperArm(version))
		{
			if (_this >= TDoFBoneType.LeftUpperArm)
			{
				_this += 3;
			}
		}
		if (!IsIncludeRightUpperArm(version))
		{
			if (_this >= TDoFBoneType.RightUpperArm)
			{
				_this += 3;
			}
		}
		return _this;
	}

	public static BoneType ToBoneType(this TDoFBoneType _this)
	{
		return _this switch
		{
			TDoFBoneType.Spine => BoneType.Spine,
			TDoFBoneType.Chest => BoneType.Chest,
			TDoFBoneType.UpperChest => BoneType.UpperChest,
			TDoFBoneType.Neck => BoneType.Neck,
			TDoFBoneType.Head => BoneType.Head,
			TDoFBoneType.LeftUpperLeg => BoneType.LeftUpperLeg,
			TDoFBoneType.LeftLowerLeg => BoneType.LeftLowerLeg,
			TDoFBoneType.LeftFoot => BoneType.LeftFoot,
			TDoFBoneType.LeftToes => BoneType.LeftToes,
			TDoFBoneType.RightUpperLeg => BoneType.RightUpperLeg,
			TDoFBoneType.RightLowerLeg => BoneType.RightLowerLeg,
			TDoFBoneType.RightFoot => BoneType.RightFoot,
			TDoFBoneType.RightToes => BoneType.RightToes,
			TDoFBoneType.LeftShoulder => BoneType.LeftShoulder,
			TDoFBoneType.LeftUpperArm => BoneType.LeftUpperArm,
			TDoFBoneType.LeftLowerArm => BoneType.LeftLowerArm,
			TDoFBoneType.LeftHand => BoneType.LeftHand,
			TDoFBoneType.RightShoulder => BoneType.RightShoulder,
			TDoFBoneType.RightUpperArm => BoneType.RightUpperArm,
			TDoFBoneType.RightLowerArm => BoneType.RightLowerArm,
			TDoFBoneType.RightHand => BoneType.RightHand,
			_ => throw new ArgumentException(_this.ToString()),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/AnimationClip/GenericBinding/BindingCustomType.cs`:

```cs
using AssetRipper.SourceGenerated.NativeEnums.Global;

namespace AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.GenericBinding;

/// <summary>
/// Based on <see cref="BindType"/>
/// </summary>
public enum BindingCustomType : byte
{
	None = 0,
	Transform = 4,
	AnimatorMuscle = 8,

	BlendShape = 20,
	Renderer = 21,
	RendererMaterial = 22,
	SpriteRenderer = 23,
	MonoBehaviour = 24,
	Light = 25,
	RendererShadows = 26,
	ParticleSystem = 27,
	RectTransform = 28,
	LineRenderer = 29,
	TrailRenderer = 30,
	PositionConstraint = 31,
	RotationConstraint = 32,
	ScaleConstraint = 33,
	AimConstraint = 34,
	ParentConstraint = 35,
	LookAtConstraint = 36,
	Camera = 37,
	VisualEffect = 38,
	ParticleForceField = 39,
	UserDefined = 40,
	MeshFilter = 41,
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/AnimationClip/GenericBinding/TransformType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.GenericBinding;

public enum TransformType
{
	Translation = 1,
	Rotation = 2,
	Scaling = 3,
	EulerRotation = 4,
}

public static class TransformTypeExtensions
{
	public static bool IsValid(this TransformType _this)
	{
		return _this >= TransformType.Translation && _this <= TransformType.EulerRotation;
	}

	public static int GetDimension(this TransformType _this)
	{
		switch (_this)
		{
			case TransformType.Translation:
			case TransformType.Scaling:
			case TransformType.EulerRotation:
				return 3;

			case TransformType.Rotation:
				return 4;

			default:
				throw new NotImplementedException($"Binding type {_this} is not implemented");
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/AnimationClip/HumanoidMuscleType.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip;
using AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.Bones;

namespace AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip;

public enum HumanoidMuscleType
{
	Motion = 0,
	Root = Motion + 7,
	Limbs = Root + 7,
	Muscles = Limbs + LimbType.Last * 7,
	Fingers = Muscles + MuscleType.Last,
	TDoFBones = Fingers + ArmType.Last * FingerType.Last * FingerDoFType.Last,

	Last = TDoFBones + TDoFBoneType.Last * 3,
}

public static class HumanoidMuscleTypeExtensions
{
	public static HumanoidMuscleType Update(this HumanoidMuscleType _this, UnityVersion version)
	{
		if (_this < HumanoidMuscleType.Muscles)
		{
			return _this;
		}

		MuscleType muscle = (MuscleType)(_this - HumanoidMuscleType.Muscles);
		MuscleType fixedMuscle = muscle.Update(version);
		_this = HumanoidMuscleType.Muscles + (int)fixedMuscle;
		if (_this < HumanoidMuscleType.TDoFBones)
		{
			return _this;
		}

		TDoFBoneType tdof = (TDoFBoneType)(_this - HumanoidMuscleType.TDoFBones);
		TDoFBoneType fixedTdof = tdof.Update(version);
		_this = HumanoidMuscleType.TDoFBones + (int)fixedTdof;
		return _this;
	}

	public static string ToAttributeString(this HumanoidMuscleType _this)
	{
		if (_this < HumanoidMuscleType.Root)
		{
			int delta = _this - HumanoidMuscleType.Motion;
			return nameof(HumanoidMuscleType.Motion) + GetTransformPostfix(delta % 7);
		}
		if (_this < HumanoidMuscleType.Limbs)
		{
			int delta = _this - HumanoidMuscleType.Root;
			return nameof(HumanoidMuscleType.Root) + GetTransformPostfix(delta % 7);
		}
		if (_this < HumanoidMuscleType.Muscles)
		{
			int delta = _this - HumanoidMuscleType.Limbs;
			LimbType limb = (LimbType)(delta / 7);
			return limb.ToBoneType().ToAttributeString() + GetTransformPostfix(delta % 7);
		}
		if (_this < HumanoidMuscleType.Fingers)
		{
			int delta = _this - HumanoidMuscleType.Muscles;
			MuscleType muscle = (MuscleType)delta;
			return muscle.ToAttributeString();
		}
		if (_this < HumanoidMuscleType.TDoFBones)
		{
			const int armSize = (int)FingerType.Last * (int)FingerDoFType.Last;
			const int dofSize = (int)FingerDoFType.Last;
			int delta = _this - HumanoidMuscleType.Fingers;
			ArmType arm = (ArmType)(delta / armSize);
			delta %= armSize;
			FingerType finger = (FingerType)(delta / dofSize);
			delta %= dofSize;
			FingerDoFType dof = (FingerDoFType)delta;
			return $"{arm.ToBoneType().ToAttributeString()}.{finger.ToAttributeString()}.{dof.ToAttributeString()}";
		}
		if (_this < HumanoidMuscleType.Last)
		{
			int delta = _this - HumanoidMuscleType.TDoFBones;
			TDoFBoneType tdof = (TDoFBoneType)(delta / 3);
			return $"{tdof.ToBoneType().ToAttributeString()}{GetTDoFTransformPostfix(delta % 3)}";
		}
		throw new ArgumentException(_this.ToString());
	}

	private static string GetTransformPostfix(int index)
	{
		return index switch
		{
			0 => "T.x",
			1 => "T.y",
			2 => "T.z",
			3 => "Q.x",
			4 => "Q.y",
			5 => "Q.z",
			6 => "Q.w",
			_ => throw new ArgumentException(index.ToString()),
		};
	}

	private static string GetTDoFTransformPostfix(int index)
	{
		return index switch
		{
			0 => "TDOF.x",
			1 => "TDOF.y",
			2 => "TDOF.z",
			_ => throw new ArgumentException(index.ToString()),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Keyframe/TangentMode/TangentMode.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Keyframe.TangentMode;

public enum TangentMode
{
	Free = 0,
	Broken = 1,
	Auto = 2,
	Linear = 4,
	Constant = 6,
	ClampedAuto = 8,

	LFree = Free,
	HFree = Free,
	LAuto = Auto,
	HAuto = Auto << 4,
	LLinear = Linear,
	HLinear = Linear << 4,
	LConstant = Constant,
	HConstant = Constant << 4,
	LClampedAuto = ClampedAuto,
	HClampedAuto = ClampedAuto << 4,

	ClampedAutoBoth = LClampedAuto | HClampedAuto,
	AutoBoth = LAuto | HAuto,
	FreeSmooth = LFree | HFree,
	FreeFree = Broken | LFree | HFree,
	FreeLinear = Broken | LFree | HLinear,
	FreeConstant = Broken | LFree | HConstant,
	LinearFree = Broken | LLinear | HFree,
	LinearLinear = Broken | LLinear | HLinear,
	LinearConstant = Broken | LLinear | HConstant,
	ConstantFree = Broken | LConstant | HFree,
	ConstantLinear = Broken | LConstant | HLinear,
	ConstantConstant = Broken | LConstant | HConstant,
}

public static class TangentModeExtensions
{
	/// <summary>
	/// 5.5.0 and greater
	/// </summary>
	public static bool TangentMode5Relevant(UnityVersion version) => version.GreaterThanOrEquals(5, 5);

	public static int ToTangent(this TangentMode _this, UnityVersion version)
	{
		if (TangentMode5Relevant(version))
		{
			return (int)_this.ToTangentMode5();
		}
		else
		{
			return (int)_this.ToTangentMode2();
		}
	}

	public static TangentMode2 ToTangentMode2(this TangentMode _this)
	{
		int value = (int)_this;
		int mask = (int)TangentMode.HConstant;
		int mask2 = (int)TangentMode2.HConstant;
		value = value & ~mask2 | (value & mask) >> 2;
		return (TangentMode2)value;
	}

	public static TangentMode5 ToTangentMode5(this TangentMode _this)
	{
		return (TangentMode5)_this;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Keyframe/TangentMode/TangentMode2.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Keyframe.TangentMode;

/// <summary>
/// Less than 5.5.0
/// </summary>
public enum TangentMode2
{
	Free = 0,
	Broken = 1,
	Auto = 2,
	Linear = 4,
	Constant = 6,

	LFree = Free,
	HFree = Free,
	LAuto = Auto,
	HAuto = Auto << 2,
	LLinear = Linear,
	HLinear = Linear << 2,
	LConstant = Constant,
	HConstant = Constant << 2,
}

public static class TangentMode2Extensions
{
	public static TangentMode ToTangentMode(this TangentMode2 _this)
	{
		int value = (int)_this;
		int mask = (int)TangentMode2.HConstant;
		value = value & ~mask | (value & mask) << 2;
		return (TangentMode)value;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Keyframe/TangentMode/TangentMode5.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Keyframe.TangentMode;

/// <summary>
/// 5.5.0 and greater
/// </summary>
public enum TangentMode5
{
	Free = 0,
	Broken = 1,
	Auto = 2,
	Linear = 4,
	Constant = 6,
	ClampedAuto = 8,

	LFree = Free,
	HFree = Free,
	LAuto = Auto,
	HAuto = Auto << 4,
	LLinear = Linear,
	HLinear = Linear << 4,
	LConstant = Constant,
	HConstant = Constant << 4,
	LClampedAuto = ClampedAuto,
	HClampedAuto = ClampedAuto << 4,
}

public static class TangentMode5Extensions
{
	public static TangentMode ToTangentMode(this TangentMode5 _this)
	{
		return (TangentMode)_this;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/GPUPlatform.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader;

/// <summary>
/// Graphic API. Also called ShaderCompilerPlatform<br/>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/Graphics/ShaderCompilerData.cs"/>
/// </summary>
public enum GPUPlatform
{
	/// <summary>
	/// For inner use only
	/// </summary>
	unknown = -1,
	/// <summary>
	/// For non initialized variable.
	/// </summary>
	none = 0,
	openGL = 0,
	d3d9 = 1,
	xbox360 = 2,
	ps3 = 3,
	/// <summary>
	/// Direct3D 11 (FL10.0 and up) and Direct3D 12, compiled with MS D3DCompiler
	/// </summary>
	d3d11 = 4,
	/// <summary>
	/// OpenGL ES 2.0 / WebGL 1.0, compiled with MS D3DCompiler + HLSLcc
	/// </summary>
	gles = 5,
	/// <summary>
	/// OpenGL ES 3.0+ / WebGL 2.0, compiled with MS D3DCompiler + HLSLcc
	/// </summary>
	glesdesktop = 6,
	flash = 7,
	d3d11_9x = 8,
	gles3 = 9,
	psp2 = 10,
	/// <summary>
	/// Sony PS4
	/// </summary>
	ps4 = 11,
	/// <summary>
	/// MS XboxOne
	/// </summary>
	xboxone = 12,
	psm = 13,
	/// <summary>
	/// Apple Metal, compiled with MS D3DCompiler + HLSLcc
	/// </summary>
	metal = 14,
	/// <summary>
	/// Desktop OpenGL 3+, compiled with MS D3DCompiler + HLSLcc
	/// </summary>
	glcore = 15,
	n3ds = 16,
	wiiu = 17,
	/// <summary>
	/// Vulkan SPIR-V, compiled with MS D3DCompiler + HLSLcc
	/// </summary>
	vulkan = 18,
	/// <summary>
	/// Nintendo Switch (NVN)
	/// </summary>
	Switch = 19,
	/// <summary>
	/// Xbox One D3D12
	/// </summary>
	xboxone_d3d12 = 20,
	/// <summary>
	/// Game Core
	/// </summary>
	GameCoreXboxOne = 21,
	GameCoreScarlett = 22,
	/// <summary>
	/// PS5
	/// </summary>
	PS5 = 23,
	/// <summary>
	/// PS5 NGGC
	/// </summary>
	PS5NGGC = 24,
}
public static class GPUPlatformExtensions
{
	public static bool IsDirectX(this GPUPlatform platform)
	{
		return platform is GPUPlatform.d3d9 or GPUPlatform.d3d11 or GPUPlatform.d3d11_9x;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/GpuProgramType/ShaderGpuProgramType.cs`:

```cs
using AssetRipper.IO.Files;

namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.GpuProgramType;

/// <remarks>
/// This is a native-only type. It has no managed equivalent.
/// </remarks>
public enum ShaderGpuProgramType
{
	Unknown = 0,
	GLLegacy = 1,
	GLES31AEP = 2,
	GLES31 = 3,
	GLES3 = 4,
	GLES = 5,
	GLCore32 = 6,
	GLCore41 = 7,
	GLCore43 = 8,
	DX9VertexSM20 = 9,
	DX9VertexSM30 = 10,
	DX9PixelSM20 = 11,
	DX9PixelSM30 = 12,
	DX10Level9Vertex = 13,
	DX10Level9Pixel = 14,
	DX11VertexSM40 = 15,
	DX11VertexSM50 = 16,
	DX11PixelSM40 = 17,
	DX11PixelSM50 = 18,
	DX11GeometrySM40 = 19,
	DX11GeometrySM50 = 20,
	DX11HullSM50 = 21,
	DX11DomainSM50 = 22,
	MetalVS = 23,
	MetalFS = 24,
	SPIRV = 25,
	Console = 26,
	ConsoleVS = 26,
	ConsoleFS = 27,
	ConsoleHS = 28,
	ConsoleDS = 29,
	ConsoleGS = 30,
	RayTracing = 31,
	PS5NGGC = 32
}

public static class ShaderGpuProgramTypeExtensions
{
	/// <summary>
	/// 5.5.0 and greater
	/// </summary>
	public static bool GpuProgramType55Relevant(UnityVersion version) => version.GreaterThanOrEquals(5, 5);

	public static bool IsGL(this ShaderGpuProgramType _this)
	{
		switch (_this)
		{
			case ShaderGpuProgramType.GLLegacy:
			case ShaderGpuProgramType.GLCore32:
			case ShaderGpuProgramType.GLCore41:
			case ShaderGpuProgramType.GLCore43:
			case ShaderGpuProgramType.GLES:
			case ShaderGpuProgramType.GLES3:
			case ShaderGpuProgramType.GLES31:
			case ShaderGpuProgramType.GLES31AEP:
				return true;

			default:
				return false;
		}
	}

	public static bool IsMetal(this ShaderGpuProgramType _this)
	{
		return _this switch
		{
			ShaderGpuProgramType.MetalFS or ShaderGpuProgramType.MetalVS => true,
			_ => false,
		};
	}

	public static bool IsDX(this ShaderGpuProgramType _this)
	{
		switch (_this)
		{
			case ShaderGpuProgramType.DX9PixelSM20:
			case ShaderGpuProgramType.DX9PixelSM30:
			case ShaderGpuProgramType.DX9VertexSM20:
			case ShaderGpuProgramType.DX9VertexSM30:
			case ShaderGpuProgramType.DX10Level9Pixel:
			case ShaderGpuProgramType.DX10Level9Vertex:
			case ShaderGpuProgramType.DX11DomainSM50:
			case ShaderGpuProgramType.DX11GeometrySM40:
			case ShaderGpuProgramType.DX11GeometrySM50:
			case ShaderGpuProgramType.DX11HullSM50:
			case ShaderGpuProgramType.DX11PixelSM40:
			case ShaderGpuProgramType.DX11PixelSM50:
			case ShaderGpuProgramType.DX11VertexSM40:
			case ShaderGpuProgramType.DX11VertexSM50:
				return true;

			default:
				return false;
		}
	}

	public static bool IsDX9(this ShaderGpuProgramType _this)
	{
		switch (_this)
		{
			case ShaderGpuProgramType.DX9PixelSM20:
			case ShaderGpuProgramType.DX9PixelSM30:
			case ShaderGpuProgramType.DX9VertexSM20:
			case ShaderGpuProgramType.DX9VertexSM30:
				return true;

			default:
				return false;
		}
	}

	public static GPUPlatform ToGPUPlatform(this ShaderGpuProgramType _this, BuildTarget platform)
	{
		switch (_this)
		{
			case ShaderGpuProgramType.Unknown:
				return GPUPlatform.unknown;

			case ShaderGpuProgramType.GLES:
				return GPUPlatform.gles;

			case ShaderGpuProgramType.GLES3:
			case ShaderGpuProgramType.GLES31:
			case ShaderGpuProgramType.GLES31AEP:
				return GPUPlatform.gles3;

			case ShaderGpuProgramType.GLCore32:
			case ShaderGpuProgramType.GLCore41:
			case ShaderGpuProgramType.GLCore43:
				return GPUPlatform.glcore;

			case ShaderGpuProgramType.GLLegacy:
				return GPUPlatform.openGL;

			case ShaderGpuProgramType.DX9VertexSM20:
			case ShaderGpuProgramType.DX9VertexSM30:
			case ShaderGpuProgramType.DX9PixelSM20:
			case ShaderGpuProgramType.DX9PixelSM30:
				return GPUPlatform.d3d9;

			case ShaderGpuProgramType.DX10Level9Pixel:
			case ShaderGpuProgramType.DX10Level9Vertex:
				return GPUPlatform.d3d11_9x;

			case ShaderGpuProgramType.DX11VertexSM40:
			case ShaderGpuProgramType.DX11VertexSM50:
			case ShaderGpuProgramType.DX11PixelSM40:
			case ShaderGpuProgramType.DX11PixelSM50:
			case ShaderGpuProgramType.DX11GeometrySM40:
			case ShaderGpuProgramType.DX11GeometrySM50:
			case ShaderGpuProgramType.DX11HullSM50:
			case ShaderGpuProgramType.DX11DomainSM50:
				return GPUPlatform.d3d11;

			case ShaderGpuProgramType.MetalVS:
			case ShaderGpuProgramType.MetalFS:
				return GPUPlatform.metal;

			case ShaderGpuProgramType.SPIRV:
				return GPUPlatform.vulkan;

			case ShaderGpuProgramType.ConsoleVS:
			case ShaderGpuProgramType.ConsoleFS:
			case ShaderGpuProgramType.ConsoleHS:
			case ShaderGpuProgramType.ConsoleDS:
			case ShaderGpuProgramType.ConsoleGS:
				switch (platform)
				{
					case BuildTarget.PS3:
						return GPUPlatform.ps3;
					case BuildTarget.PS4:
						return GPUPlatform.ps4;
					case BuildTarget.PSM:
						return GPUPlatform.psm;
					case BuildTarget.PSP2:
						return GPUPlatform.psp2;

					case BuildTarget.XBox360:
						return GPUPlatform.xbox360;
					case BuildTarget.XboxOne:
						return GPUPlatform.xboxone;
#warning		 TODO:
					//return GPUPlatform.xboxone_d3d12;

					case BuildTarget.WiiU:
						return GPUPlatform.wiiu;

					case BuildTarget.N3DS:
						return GPUPlatform.n3ds;

					case BuildTarget.GoogleNaCl:
						return GPUPlatform.glesdesktop;

					case BuildTarget.Flash:
						return GPUPlatform.flash;

					case BuildTarget.Switch:
						return GPUPlatform.Switch;

					default:
						throw new NotSupportedException($"Unsupported console platform {platform}");
				}

			default:
				throw new NotSupportedException($"Unsupported gpu program type {_this}");
		}
	}

	public static string ToProgramDataKeyword(this ShaderGpuProgramType _this, BuildTarget platform, ShaderType type)
	{
		switch (_this)
		{
			case ShaderGpuProgramType.Unknown:
				return nameof(ShaderGpuProgramType.Unknown);

			case ShaderGpuProgramType.GLES:
				return "!!GLES";
			case ShaderGpuProgramType.GLES3:
			case ShaderGpuProgramType.GLES31:
			case ShaderGpuProgramType.GLES31AEP:
				return "!!GLES3";

			case ShaderGpuProgramType.GLCore32:
				return "!!GL3x";
			case ShaderGpuProgramType.GLCore41:
			case ShaderGpuProgramType.GLCore43:
				return "!!GL4x";

			case ShaderGpuProgramType.GLLegacy:
				{
					// for ver < 5.0
					/*if (type == ShaderType.Vertex)
					{
						return "!!ARBvp1.0";
					}
					else if (type == ShaderType.Fragment)
					{
						return "!!ARBfp1.0";
					}*/
					// but since serialization work only for >= 5.4 always return
					return "!!GLSL"; // v1.20
				}

			case ShaderGpuProgramType.DX9VertexSM20:
				return "vs_2_0";
			case ShaderGpuProgramType.DX9VertexSM30:
				return "vs_3_0";
			case ShaderGpuProgramType.DX9PixelSM20:
				return "ps_2_0";
			case ShaderGpuProgramType.DX9PixelSM30:
				return "ps_3_0";

			case ShaderGpuProgramType.DX10Level9Vertex:
				return "vs_4_0_level_9_1";
			case ShaderGpuProgramType.DX10Level9Pixel:
				return "ps_4_0_level_9_1";

			case ShaderGpuProgramType.DX11VertexSM40:
				return "vs_4_0";
			case ShaderGpuProgramType.DX11VertexSM50:
				return "vs_5_0";
			case ShaderGpuProgramType.DX11PixelSM40:
				return "ps_4_0";
			case ShaderGpuProgramType.DX11PixelSM50:
				return "ps_5_0";
			case ShaderGpuProgramType.DX11GeometrySM40:
				return "gs_4_0";
			case ShaderGpuProgramType.DX11GeometrySM50:
				return "gs_5_0";
			case ShaderGpuProgramType.DX11HullSM50:
				return "hs_5_0";
			case ShaderGpuProgramType.DX11DomainSM50:
				return "ds_5_0";

			case ShaderGpuProgramType.MetalVS:
				return "metal_vs";
			case ShaderGpuProgramType.MetalFS:
				return "metal_fs";

			case ShaderGpuProgramType.SPIRV:
				return "spirv";
		}

		switch (platform)
		{
			case BuildTarget.Flash:
				{
					if (_this == ShaderGpuProgramType.Console)
					{
						switch (type)
						{
							case ShaderType.Vertex:
								return "agal_vs";
							case ShaderType.Fragment:
								return "agal_ps";
						}
					}
				}
				break;

			case BuildTarget.PS4:
				{
					switch (_this)
					{
						case ShaderGpuProgramType.ConsoleVS:
							return "pssl_vs";
						case ShaderGpuProgramType.ConsoleFS:
							return "pssl_ps";
						case ShaderGpuProgramType.ConsoleGS:
							return "pssl_gs";
					}
				}
				break;

			case BuildTarget.Switch:
				{
					if (_this == ShaderGpuProgramType.Console)
					{
						switch (type)
						{
							case ShaderType.Vertex:
								return "nssl_vs";
							case ShaderType.Fragment:
								return "nssl_ps";
							case ShaderType.Geometry:
								return "nssl_gs";
							case ShaderType.Hull:
								return "nssl_hs";
						}
					}
				}
				break;
		}

		throw new NotSupportedException($"Unsupported gpu program type {_this} [{platform}, {type}]");
	}

	public static int ToShaderModelVersion(this ShaderGpuProgramType _this)
	{
		return _this switch
		{
			ShaderGpuProgramType.DX9VertexSM20 or ShaderGpuProgramType.DX9PixelSM20 => 20,
			ShaderGpuProgramType.DX9VertexSM30 or ShaderGpuProgramType.DX9PixelSM30 => 30,
			ShaderGpuProgramType.DX10Level9Vertex or ShaderGpuProgramType.DX10Level9Pixel => 40,
			ShaderGpuProgramType.DX11VertexSM40 or ShaderGpuProgramType.DX11PixelSM40 or ShaderGpuProgramType.DX11GeometrySM40 => 40,
			ShaderGpuProgramType.DX11VertexSM50 or ShaderGpuProgramType.DX11PixelSM50 or ShaderGpuProgramType.DX11GeometrySM50 or
			ShaderGpuProgramType.DX11HullSM50 or ShaderGpuProgramType.DX11DomainSM50 => 50,
			_ => default,
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/GpuProgramType/ShaderGpuProgramType53.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.GpuProgramType;

public enum ShaderGpuProgramType53
{
	Unknown = 0,
	GLLegacy = 1,
	GLES31AEP = 2,
	GLES31 = 3,
	GLES3 = 4,
	GLES = 5,
	GLCore32 = 6,
	GLCore41 = 7,
	GLCore43 = 8,
	DX9VertexSM20 = 9,
	DX9VertexSM30 = 10,
	DX9PixelSM20 = 11,
	DX9PixelSM30 = 12,
	DX10Level9Vertex = 13,
	DX10Level9Pixel = 14,
	DX11VertexSM40 = 15,
	DX11VertexSM50 = 16,
	DX11PixelSM40 = 17,
	DX11PixelSM50 = 18,
	DX11GeometrySM40 = 19,
	DX11GeometrySM50 = 20,
	DX11HullSM50 = 21,
	DX11DomainSM50 = 22,
	MetalVS = 23,
	MetalFS = 24,
	ConsoleVS = 25,
	ConsoleFS = 26,
	ConsoleHS = 27,
	ConsoleDS = 28,
	ConsoleGS = 29,
}

public static class ShaderGpuProgramType53Extensions
{
	public static ShaderGpuProgramType ToGpuProgramType(this ShaderGpuProgramType53 _this)
	{
		return _this switch
		{
			ShaderGpuProgramType53.Unknown => ShaderGpuProgramType.Unknown,
			ShaderGpuProgramType53.GLLegacy => ShaderGpuProgramType.GLLegacy,
			ShaderGpuProgramType53.GLES31AEP => ShaderGpuProgramType.GLES31AEP,
			ShaderGpuProgramType53.GLES31 => ShaderGpuProgramType.GLES31,
			ShaderGpuProgramType53.GLES3 => ShaderGpuProgramType.GLES3,
			ShaderGpuProgramType53.GLES => ShaderGpuProgramType.GLES,
			ShaderGpuProgramType53.GLCore32 => ShaderGpuProgramType.GLCore32,
			ShaderGpuProgramType53.GLCore41 => ShaderGpuProgramType.GLCore41,
			ShaderGpuProgramType53.GLCore43 => ShaderGpuProgramType.GLCore43,
			ShaderGpuProgramType53.DX9VertexSM20 => ShaderGpuProgramType.DX9VertexSM20,
			ShaderGpuProgramType53.DX9VertexSM30 => ShaderGpuProgramType.DX9VertexSM30,
			ShaderGpuProgramType53.DX9PixelSM20 => ShaderGpuProgramType.DX9PixelSM20,
			ShaderGpuProgramType53.DX9PixelSM30 => ShaderGpuProgramType.DX9PixelSM30,
			ShaderGpuProgramType53.DX10Level9Vertex => ShaderGpuProgramType.DX10Level9Vertex,
			ShaderGpuProgramType53.DX10Level9Pixel => ShaderGpuProgramType.DX10Level9Pixel,
			ShaderGpuProgramType53.DX11VertexSM40 => ShaderGpuProgramType.DX11VertexSM40,
			ShaderGpuProgramType53.DX11VertexSM50 => ShaderGpuProgramType.DX11VertexSM50,
			ShaderGpuProgramType53.DX11PixelSM40 => ShaderGpuProgramType.DX11PixelSM40,
			ShaderGpuProgramType53.DX11PixelSM50 => ShaderGpuProgramType.DX11PixelSM50,
			ShaderGpuProgramType53.DX11GeometrySM40 => ShaderGpuProgramType.DX11GeometrySM40,
			ShaderGpuProgramType53.DX11GeometrySM50 => ShaderGpuProgramType.DX11GeometrySM50,
			ShaderGpuProgramType53.DX11HullSM50 => ShaderGpuProgramType.DX11HullSM50,
			ShaderGpuProgramType53.DX11DomainSM50 => ShaderGpuProgramType.DX11DomainSM50,
			ShaderGpuProgramType53.MetalVS => ShaderGpuProgramType.MetalVS,
			ShaderGpuProgramType53.MetalFS => ShaderGpuProgramType.MetalFS,
			ShaderGpuProgramType53.ConsoleVS => ShaderGpuProgramType.ConsoleVS,
			ShaderGpuProgramType53.ConsoleFS => ShaderGpuProgramType.ConsoleFS,
			ShaderGpuProgramType53.ConsoleHS => ShaderGpuProgramType.ConsoleHS,
			ShaderGpuProgramType53.ConsoleDS => ShaderGpuProgramType.ConsoleDS,
			ShaderGpuProgramType53.ConsoleGS => ShaderGpuProgramType.ConsoleGS,
			_ => throw new Exception($"Unsupported gpu program type {_this}"),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/GpuProgramType/ShaderGpuProgramType55.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.GpuProgramType;

public enum ShaderGpuProgramType55
{
	Unknown = 0,
	GLLegacy = 1,
	GLES31AEP = 2,
	GLES31 = 3,
	GLES3 = 4,
	GLES = 5,
	GLCore32 = 6,
	GLCore41 = 7,
	GLCore43 = 8,
	DX9VertexSM20 = 9,
	DX9VertexSM30 = 10,
	DX9PixelSM20 = 11,
	DX9PixelSM30 = 12,
	DX10Level9Vertex = 13,
	DX10Level9Pixel = 14,
	DX11VertexSM40 = 15,
	DX11VertexSM50 = 16,
	DX11PixelSM40 = 17,
	DX11PixelSM50 = 18,
	DX11GeometrySM40 = 19,
	DX11GeometrySM50 = 20,
	DX11HullSM50 = 21,
	DX11DomainSM50 = 22,
	MetalVS = 23,
	MetalFS = 24,
	SPIRV = 25,
	Console = 26,
	//ConsoleVS			= 26,
	ConsoleFS = 27,
	ConsoleHS = 28,
	ConsoleDS = 29,
	ConsoleGS = 30,
	RayTracing = 31,
}

public static class ShaderGpuProgramType55Extensions
{
	public static ShaderGpuProgramType ToGpuProgramType(this ShaderGpuProgramType55 _this)
	{
		return _this switch
		{
			ShaderGpuProgramType55.Unknown => ShaderGpuProgramType.Unknown,
			ShaderGpuProgramType55.GLLegacy => ShaderGpuProgramType.GLLegacy,
			ShaderGpuProgramType55.GLES31AEP => ShaderGpuProgramType.GLES31AEP,
			ShaderGpuProgramType55.GLES31 => ShaderGpuProgramType.GLES31,
			ShaderGpuProgramType55.GLES3 => ShaderGpuProgramType.GLES3,
			ShaderGpuProgramType55.GLES => ShaderGpuProgramType.GLES,
			ShaderGpuProgramType55.GLCore32 => ShaderGpuProgramType.GLCore32,
			ShaderGpuProgramType55.GLCore41 => ShaderGpuProgramType.GLCore41,
			ShaderGpuProgramType55.GLCore43 => ShaderGpuProgramType.GLCore43,
			ShaderGpuProgramType55.DX9VertexSM20 => ShaderGpuProgramType.DX9VertexSM20,
			ShaderGpuProgramType55.DX9VertexSM30 => ShaderGpuProgramType.DX9VertexSM30,
			ShaderGpuProgramType55.DX9PixelSM20 => ShaderGpuProgramType.DX9PixelSM20,
			ShaderGpuProgramType55.DX9PixelSM30 => ShaderGpuProgramType.DX9PixelSM30,
			ShaderGpuProgramType55.DX10Level9Vertex => ShaderGpuProgramType.DX10Level9Vertex,
			ShaderGpuProgramType55.DX10Level9Pixel => ShaderGpuProgramType.DX10Level9Pixel,
			ShaderGpuProgramType55.DX11VertexSM40 => ShaderGpuProgramType.DX11VertexSM40,
			ShaderGpuProgramType55.DX11VertexSM50 => ShaderGpuProgramType.DX11VertexSM50,
			ShaderGpuProgramType55.DX11PixelSM40 => ShaderGpuProgramType.DX11PixelSM40,
			ShaderGpuProgramType55.DX11PixelSM50 => ShaderGpuProgramType.DX11PixelSM50,
			ShaderGpuProgramType55.DX11GeometrySM40 => ShaderGpuProgramType.DX11GeometrySM40,
			ShaderGpuProgramType55.DX11GeometrySM50 => ShaderGpuProgramType.DX11GeometrySM50,
			ShaderGpuProgramType55.DX11HullSM50 => ShaderGpuProgramType.DX11HullSM50,
			ShaderGpuProgramType55.DX11DomainSM50 => ShaderGpuProgramType.DX11DomainSM50,
			ShaderGpuProgramType55.MetalVS => ShaderGpuProgramType.MetalVS,
			ShaderGpuProgramType55.MetalFS => ShaderGpuProgramType.MetalFS,
			ShaderGpuProgramType55.SPIRV => ShaderGpuProgramType.SPIRV,
			ShaderGpuProgramType55.Console => ShaderGpuProgramType.Console,
			ShaderGpuProgramType55.ConsoleFS => ShaderGpuProgramType.Console,
			ShaderGpuProgramType55.ConsoleHS => ShaderGpuProgramType.Console,
			ShaderGpuProgramType55.ConsoleDS => ShaderGpuProgramType.Console,
			ShaderGpuProgramType55.ConsoleGS => ShaderGpuProgramType.Console,
			ShaderGpuProgramType55.RayTracing => ShaderGpuProgramType.RayTracing,
			_ => throw new Exception($"Unsupported gpu program type {_this}"),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/BlendMode.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

/// <summary>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
/// </summary>
public enum BlendMode
{
	Zero = 0,
	One = 1,
	DstColor = 2,
	SrcColor = 3,
	OneMinusDstColor = 4,
	SrcAlpha = 5,
	OneMinusSrcColor = 6,
	DstAlpha = 7,
	OneMinusDstAlpha = 8,
	SrcAlphaSaturate = 9,
	OneMinusSrcAlpha = 10,
	Count,
}

public static class BlendFactorExtensions
{
	public static bool IsZero(this BlendMode _this)
	{
		return _this == BlendMode.Zero;
	}

	public static bool IsOne(this BlendMode _this)
	{
		return _this == BlendMode.One;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/BlendOp.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

/// <summary>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
/// </summary>
public enum BlendOp
{
	Add = 0,
	Sub = 1,
	RevSub = 2,
	Min = 3,
	Max = 4,
	LogicalClear = 5,
	LogicalSet = 6,
	LogicalCopy = 7,
	LogicalCopyInverted = 8,
	LogicalNoop = 9,
	LogicalInvert = 10,
	LogicalAnd = 11,
	LogicalNand = 12,
	LogicalOr = 13,
	LogicalNor = 14,
	LogicalXor = 15,
	LogicalEquivalence = 16,
	LogicalAndReverse = 17,
	LogicalAndInverted = 18,
	LogicalOrReverse = 19,
	LogicalOrInverted = 20,
	Multiply = 21,
	Screen = 22,
	Overlay = 23,
	Darken = 24,
	Lighten = 25,
	ColorDodge = 26,
	ColorBurn = 27,
	HardLight = 28,
	SoftLight = 29,
	Difference = 30,
	Exclusion = 31,
	HSLHue = 32,
	HSLSaturation = 33,
	HSLColor = 34,
	HSLLuminosity = 35,
	Count,
}

public static class BlendOpExtensions
{
	public static bool IsAdd(this BlendOp _this)
	{
		return _this == BlendOp.Add;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/ColorWriteMask.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

/// <summary>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
/// </summary>
[Flags]
public enum ColorWriteMask
{
	None = 0x0,
	Alpha = 0x1,
	Red = 0x2,
	Green = 0x4,
	Blue = 0x8,

	All = Red | Green | Blue | Alpha, // 15
}

public static class ColorMaskExtensions
{
	public static bool IsNone(this ColorWriteMask _this)
	{
		return _this == ColorWriteMask.None;
	}

	public static bool IsRed(this ColorWriteMask _this)
	{
		return (_this & ColorWriteMask.Red) != 0;
	}

	public static bool IsGreen(this ColorWriteMask _this)
	{
		return (_this & ColorWriteMask.Green) != 0;
	}

	public static bool IsBlue(this ColorWriteMask _this)
	{
		return (_this & ColorWriteMask.Blue) != 0;
	}

	public static bool IsAlpha(this ColorWriteMask _this)
	{
		return (_this & ColorWriteMask.Alpha) != 0;
	}

	public static bool IsRBGA(this ColorWriteMask _this)
	{
		return _this == ColorWriteMask.All;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/CullMode.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

/// <summary>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
/// </summary>
public enum CullMode
{
	Off = 0,
	Front = 1,
	Back = 2,
	Count,

	Unknown = -1,
}

public static class CullExtensions
{
	public static bool IsOff(this CullMode _this)
	{
		return _this == CullMode.Off;
	}

	public static bool IsFront(this CullMode _this)
	{
		return _this == CullMode.Front;
	}

	public static bool IsBack(this CullMode _this)
	{
		return _this == CullMode.Back;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/FogMode.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

/// <summary>
/// Duplicate of RenderSettings FogMode<br/>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
/// </summary>
public enum FogMode
{
	Off = 0,
	Linear = 1,
	Exp = 2,
	Exp2 = 3,
	Count,

	Unknown = -1,
}

public static class FogModeExtensions
{
	public static bool IsUnknown(this FogMode _this)
	{
		return _this == FogMode.Unknown;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/SerializedPassType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

public enum SerializedPassType
{
	Pass = 0,
	UsePass = 1,
	GrabPass = 2,
}
public static class SerializedPassTypeExtensions
{
	public static string ToSerializedString(this SerializedPassType @this) => @this switch
	{
		SerializedPassType.Pass => "Pass",
		SerializedPassType.UsePass => "UsePass",
		SerializedPassType.GrabPass => "GrabPass",
		_ => throw new Exception($"Unsupported pass type {@this}"),
	};
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/SerializedPropertyFlag.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

/// <summary>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Shaders/ShaderProperties.cs"/>
/// </summary>
[Flags]
public enum SerializedPropertyFlag : uint
{
	None = 0,
	HideInInspector = 1 << 0,
	PerRendererData = 1 << 1,
	NoScaleOffset = 1 << 2,
	Normal = 1 << 3,
	HDR = 1 << 4,
	Gamma = 1 << 5,
	NonModifiableTextureData = 1 << 6,
	MainTexture = 1 << 7,
	MainColor = 1 << 8,
}

public static class SerializedPropertyFlagExtensions
{
	public static bool IsHideInInspector(this SerializedPropertyFlag _this)
	{
		return (_this & SerializedPropertyFlag.HideInInspector) != 0;
	}

	public static bool IsPerRendererData(this SerializedPropertyFlag _this)
	{
		return (_this & SerializedPropertyFlag.PerRendererData) != 0;
	}

	public static bool IsNoScaleOffset(this SerializedPropertyFlag _this)
	{
		return (_this & SerializedPropertyFlag.NoScaleOffset) != 0;
	}

	public static bool IsNormal(this SerializedPropertyFlag _this)
	{
		return (_this & SerializedPropertyFlag.Normal) != 0;
	}

	public static bool IsHDR(this SerializedPropertyFlag _this)
	{
		return (_this & SerializedPropertyFlag.HDR) != 0;
	}

	public static bool IsGamma(this SerializedPropertyFlag _this)
	{
		return (_this & SerializedPropertyFlag.Gamma) != 0;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/SerializedPropertyType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

/// <summary>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Shaders/ShaderProperties.cs"/>
/// </summary>
public enum SerializedPropertyType
{
	Color = 0,
	Vector = 1,
	Float = 2,
	Range = 3,
	Texture = 4,
	/// <summary>
	/// Added in 2021.1.0a2
	/// </summary>
	Int = 5,
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/StencilComp.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

public enum StencilComp
{
	Disabled = 0,
	Never = 1,
	Less = 2,
	Equal = 3,
	LEqual = 4,
	Greater = 5,
	NotEqual = 6,
	GEqual = 7,
	Always = 8,
	Count,

	Unknown = -1,
}

public static class StencilCompExtensions
{
	public static bool IsAlways(this StencilComp _this)
	{
		return _this == StencilComp.Always;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/StencilOp.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

/// <summary>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
/// </summary>
public enum StencilOp
{
	Keep = 0,
	Zero = 1,
	Replace = 2,
	IncrementSaturate = 3,
	DecrementSaturate = 4,
	Invert = 5,
	IncrementWrap = 6,
	DecrementWrap = 7,
	Count,
}

public static class StencilOpExtensions
{
	public static bool IsKeep(this StencilOp _this)
	{
		return _this == StencilOp.Keep;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/StencilType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

public enum StencilType
{
	Base,
	Front,
	Back,
}

public static class StencilTypeExtensions
{
	public static string ToSuffixString(this StencilType _this) => _this switch
	{
		StencilType.Base => string.Empty,
		StencilType.Front => "Front",
		StencilType.Back => "Back",
		_ => throw new Exception($"Unsupported stencil type {_this}"),
	};
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/ZClip.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

public enum ZClip
{
	Off = 0,
	On = 1,
}

public static class ZClipExtensions
{
	public static bool IsOn(this ZClip _this)
	{
		return _this == ZClip.On;
	}

	public static bool IsOff(this ZClip _this)
	{
		return _this == ZClip.Off;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/ZTest.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

public enum ZTest
{
	None = 0,
	Unknown = 1,
	Less = 2,
	Equal = 3,
	LEqual = 4,
	Greater = 5,
	NotEqual = 6,
	GEqual = 7,
	Always = 8,
}

public static class ZTestExtensions
{
	public static bool IsNone(this ZTest _this)
	{
		return _this == ZTest.None;
	}
	public static bool IsLEqual(this ZTest _this)
	{
		return _this == ZTest.LEqual;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/SerializedShader/ZWrite.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;

public enum ZWrite
{
	Off = 0,
	On = 1,
}

public static class ZWriteExtensions
{
	public static bool IsOff(this ZWrite _this)
	{
		return _this == ZWrite.Off;
	}

	public static bool IsOn(this ZWrite _this)
	{
		return _this == ZWrite.On;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/ShaderChannel/ShaderChannel.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.VertexFormat;

namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.ShaderChannel;

/// <summary>
/// Changed several times. Also called VertexAttribute<br/>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
/// </summary>
public enum ShaderChannel
{
	/// <summary>
	/// Also called Position
	/// </summary>
	Vertex,
	Normal,
	Tangent,
	/// <summary>
	/// Vertex Color
	/// </summary>
	Color,
	UV0,
	UV1,
	UV2,
	UV3,
	UV4,
	UV5,
	UV6,
	UV7,
	/// <summary>
	/// Also called BlendWeight
	/// </summary>
	SkinWeight,
	/// <summary>
	/// Also called BlendIndices
	/// </summary>
	SkinBoneIndex,
}

public static class ShaderChannelExtensions
{
	/// <summary>
	/// 2018.1 and greater
	/// </summary>
	public static bool ShaderChannel2018Relevant(UnityVersion version) => version.GreaterThanOrEquals(2018);
	/// <summary>
	/// 5.0.0 and greater
	/// </summary>
	public static bool ShaderChannel5Relevant(UnityVersion version) => version.GreaterThanOrEquals(5);

	public static int GetChannelCount(UnityVersion version)
	{
		if (ShaderChannel2018Relevant(version))
		{
			return 14;
		}
		else if (ShaderChannel5Relevant(version))
		{
			return 8;
		}
		else
		{
			return 6;
		}
	}

	public static VertexFormat.VertexFormat GetVertexFormat(this ShaderChannel _this, UnityVersion version)
	{
		switch (_this)
		{
			case ShaderChannel.Vertex:
				return VertexFormat.VertexFormat.Float;
			case ShaderChannel.Normal:
				return VertexFormat.VertexFormat.Float;
			case ShaderChannel.Tangent:
				return VertexFormat.VertexFormat.Float;
			case ShaderChannel.Color:
				return VertexFormatExtensions.VertexFormat2019Relevant(version) ? VertexFormat.VertexFormat.Byte : VertexFormat.VertexFormat.Color;

			case ShaderChannel.UV0:
			case ShaderChannel.UV1:
			case ShaderChannel.UV2:
			case ShaderChannel.UV3:
			case ShaderChannel.UV4:
			case ShaderChannel.UV5:
			case ShaderChannel.UV6:
			case ShaderChannel.UV7:
				return VertexFormat.VertexFormat.Float;

			case ShaderChannel.SkinWeight:
				return VertexFormat.VertexFormat.Float;
			case ShaderChannel.SkinBoneIndex:
				return VertexFormat.VertexFormat.Int;

			default:
				throw new Exception($"Unsupported channel type {_this}");
		}
	}

	public static byte GetDimention(this ShaderChannel _this, UnityVersion version)
	{
		switch (_this)
		{
			case ShaderChannel.Vertex:
				return 3;
			case ShaderChannel.Normal:
				return 3;
			case ShaderChannel.Tangent:
				return 4;
			case ShaderChannel.Color:
				return ShaderChannel5Relevant(version) ? (byte)4 : (byte)1;

			case ShaderChannel.UV0:
			case ShaderChannel.UV1:
			case ShaderChannel.UV2:
			case ShaderChannel.UV3:
			case ShaderChannel.UV4:
			case ShaderChannel.UV5:
			case ShaderChannel.UV6:
			case ShaderChannel.UV7:
				return 2;

			case ShaderChannel.SkinWeight:
			case ShaderChannel.SkinBoneIndex:
				throw new Exception($"Skin's dimention is varying");

			default:
				throw new Exception($"Unsupported channel type {_this}");
		}
	}

	public static byte GetStride(this ShaderChannel _this, UnityVersion version)
	{
		VertexFormat.VertexFormat format = _this.GetVertexFormat(version);
		int dimention = _this.GetDimention(version);
		return format.CalculateStride(version, dimention);
	}

	public static bool HasChannel(this ShaderChannel _this, UnityVersion version)
	{
		if (ShaderChannel2018Relevant(version))
		{
			return true;
		}
		else if (ShaderChannel5Relevant(version))
		{
			return _this <= ShaderChannel.UV3;
		}
		else
		{
			return _this <= ShaderChannel.UV1;
		}
	}

	public static int ToChannel(this ShaderChannel _this, UnityVersion version)
	{
		if (ShaderChannel2018Relevant(version))
		{
			return (int)_this.ToShaderChannel2018();
		}
		else if (ShaderChannel5Relevant(version))
		{
			return (int)_this.ToShaderChannel5();
		}
		else
		{
			return (int)_this.ToShaderChannel4();
		}
	}

	public static ShaderChannel4 ToShaderChannel4(this ShaderChannel _this)
	{
		return _this switch
		{
			ShaderChannel.Vertex => ShaderChannel4.Vertex,
			ShaderChannel.Normal => ShaderChannel4.Normal,
			ShaderChannel.Color => ShaderChannel4.Color,
			ShaderChannel.UV0 => ShaderChannel4.UV0,
			ShaderChannel.UV1 => ShaderChannel4.UV1,
			ShaderChannel.Tangent => ShaderChannel4.Tangent,
			_ => throw new Exception($"Unsupported channel type {_this}"),
		};
	}

	public static ShaderChannel5 ToShaderChannel5(this ShaderChannel _this)
	{
		return _this switch
		{
			ShaderChannel.Vertex => ShaderChannel5.Vertex,
			ShaderChannel.Normal => ShaderChannel5.Normal,
			ShaderChannel.Color => ShaderChannel5.Color,
			ShaderChannel.UV0 => ShaderChannel5.UV0,
			ShaderChannel.UV1 => ShaderChannel5.UV1,
			ShaderChannel.UV2 => ShaderChannel5.UV2,
			ShaderChannel.UV3 => ShaderChannel5.UV3,
			ShaderChannel.Tangent => ShaderChannel5.Tangent,
			_ => throw new Exception($"Unsupported channel type {_this}"),
		};
	}

	public static ShaderChannel2018 ToShaderChannel2018(this ShaderChannel _this)
	{
		return _this switch
		{
			ShaderChannel.Vertex => ShaderChannel2018.Vertex,
			ShaderChannel.Normal => ShaderChannel2018.Normal,
			ShaderChannel.Tangent => ShaderChannel2018.Tangent,
			ShaderChannel.Color => ShaderChannel2018.Color,
			ShaderChannel.UV0 => ShaderChannel2018.UV0,
			ShaderChannel.UV1 => ShaderChannel2018.UV1,
			ShaderChannel.UV2 => ShaderChannel2018.UV2,
			ShaderChannel.UV3 => ShaderChannel2018.UV3,
			ShaderChannel.UV4 => ShaderChannel2018.UV4,
			ShaderChannel.UV5 => ShaderChannel2018.UV5,
			ShaderChannel.UV6 => ShaderChannel2018.UV6,
			ShaderChannel.UV7 => ShaderChannel2018.UV7,
			ShaderChannel.SkinWeight => ShaderChannel2018.SkinWeight,
			ShaderChannel.SkinBoneIndex => ShaderChannel2018.SkinBoneIndex,
			_ => throw new Exception($"Unsupported channel type {_this}"),
		};
	}

	public static string ToSemantic(this ShaderChannel _this) => _this switch
	{
		ShaderChannel.Vertex => "POSITION",
		ShaderChannel.Normal => "NORMAL",
		ShaderChannel.Tangent => "TANGENT",
		ShaderChannel.Color => "COLOR",
		ShaderChannel.UV0 => "TEXCOORD0",
		ShaderChannel.UV1 => "TEXCOORD1",
		ShaderChannel.UV2 => "TEXCOORD2",
		ShaderChannel.UV3 => "TEXCOORD3",
		ShaderChannel.UV4 => "TEXCOORD4",
		ShaderChannel.UV5 => "TEXCOORD5",
		ShaderChannel.UV6 => "TEXCOORD6",
		ShaderChannel.UV7 => "TEXCOORD7",
		ShaderChannel.SkinWeight => "BLENDWEIGHT",
		ShaderChannel.SkinBoneIndex => "BLENDINDICES",
		_ => throw new Exception($"Unsupported channel type {_this}"),
	};
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/ShaderChannel/ShaderChannel2018.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.ShaderChannel;

/// <summary>
/// 2018.1 and greater version
/// </summary>
public enum ShaderChannel2018
{
	Vertex = 0,
	Normal = 1,
	Tangent = 2,
	Color = 3,
	UV0 = 4,
	UV1 = 5,
	UV2 = 6,
	UV3 = 7,
	UV4 = 8,
	UV5 = 9,
	UV6 = 10,
	UV7 = 11,
	SkinWeight = 12,
	SkinBoneIndex = 13,
}

public static class ShaderChannelV2018Extensions
{
	public static ShaderChannel ToShaderChannel(this ShaderChannel2018 _this)
	{
		return _this switch
		{
			ShaderChannel2018.Vertex => ShaderChannel.Vertex,
			ShaderChannel2018.Normal => ShaderChannel.Normal,
			ShaderChannel2018.Tangent => ShaderChannel.Tangent,
			ShaderChannel2018.Color => ShaderChannel.Color,
			ShaderChannel2018.UV0 => ShaderChannel.UV0,
			ShaderChannel2018.UV1 => ShaderChannel.UV1,
			ShaderChannel2018.UV2 => ShaderChannel.UV2,
			ShaderChannel2018.UV3 => ShaderChannel.UV3,
			ShaderChannel2018.UV4 => ShaderChannel.UV4,
			ShaderChannel2018.UV5 => ShaderChannel.UV5,
			ShaderChannel2018.UV6 => ShaderChannel.UV6,
			ShaderChannel2018.UV7 => ShaderChannel.UV7,
			ShaderChannel2018.SkinWeight => ShaderChannel.SkinWeight,
			ShaderChannel2018.SkinBoneIndex => ShaderChannel.SkinBoneIndex,
			_ => throw new Exception($"Unsupported channel type {_this}"),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/ShaderChannel/ShaderChannel4.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.ShaderChannel;

/// <summary>
/// Less than 5.0.0 version
/// </summary>
public enum ShaderChannel4
{
	Vertex = 0,
	Normal = 1,
	Color = 2,
	UV0 = 3,
	UV1 = 4,
	Tangent = 5,
}

public static class ShaderChannelV4Extensions
{
	public static ShaderChannel ToShaderChannel(this ShaderChannel4 _this)
	{
		return _this switch
		{
			ShaderChannel4.Vertex => ShaderChannel.Vertex,
			ShaderChannel4.Normal => ShaderChannel.Normal,
			ShaderChannel4.Color => ShaderChannel.Color,
			ShaderChannel4.UV0 => ShaderChannel.UV0,
			ShaderChannel4.UV1 => ShaderChannel.UV1,
			ShaderChannel4.Tangent => ShaderChannel.Tangent,
			_ => throw new Exception($"Unsupported channel type {_this}"),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/ShaderChannel/ShaderChannel5.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.ShaderChannel;

/// <summary>
/// 5.0.0 to 2017.x versions
/// </summary>
public enum ShaderChannel5
{
	Vertex = 0,
	Normal = 1,
	Color = 2,
	UV0 = 3,
	UV1 = 4,
	UV2 = 5,
	UV3 = 6,
	Tangent = 7,
}

public static class ShaderChannelV5Extensions
{
	public static ShaderChannel ToShaderChannel(this ShaderChannel5 _this)
	{
		return _this switch
		{
			ShaderChannel5.Vertex => ShaderChannel.Vertex,
			ShaderChannel5.Normal => ShaderChannel.Normal,
			ShaderChannel5.Color => ShaderChannel.Color,
			ShaderChannel5.UV0 => ShaderChannel.UV0,
			ShaderChannel5.UV1 => ShaderChannel.UV1,
			ShaderChannel5.UV2 => ShaderChannel.UV2,
			ShaderChannel5.UV3 => ShaderChannel.UV3,
			ShaderChannel5.Tangent => ShaderChannel.Tangent,
			_ => throw new Exception($"Unsupported channel type {_this}"),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/ShaderParamType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader;

/// <summary>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
/// </summary>
public enum ShaderParamType
{
	Float = 0x0,
	Int = 0x1,
	Bool = 0x2,
	Half = 0x3,
	Short = 0x4,
	UInt = 0x5,
	TypeCount = 0x6,
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/ShaderType.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader;

public enum ShaderType
{
	None = 0,
	Vertex = 1,
	Fragment = 2,
	Geometry = 3,
	Hull = 4,
	Domain = 5,
	/// <summary>
	/// 2019.3 and greater
	/// </summary>
	RayTracing = 6,

	TypeCount,
}

public static class ShaderTypeExtensions
{
	public static string ToProgramTypeString(this ShaderType _this)
	{
		return _this switch
		{
			ShaderType.Vertex => "vp",
			ShaderType.Fragment => "fp",
			ShaderType.Geometry => "gp",
			ShaderType.Hull => "hp",
			ShaderType.Domain => "dp",
			ShaderType.RayTracing => "rtp",
			_ => throw new NotSupportedException($"ShaderType {_this} isn't supported"),
		};
	}

	public static int ToProgramMask(this ShaderType _this)
	{
		return 1 << (int)_this;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/VertexComponent.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader;

public enum VertexComponent : uint
{
	None = 0xFFFFFFFF,
	Vertex = 0x0,
	Color = 0x1,
	Normal = 0x2,
	TexCoord = 0x3,
	TexCoord0 = 0x4,
	TexCoord1 = 0x5,
	TexCoord2 = 0x6,
	TexCoord3 = 0x7,
	TexCoord4 = 0x8,
	TexCoord5 = 0x9,
	TexCoord6 = 0xA,
	TexCoord7 = 0xB,
	Attrib0 = 0xC,
	Attrib1 = 0xD,
	Attrib2 = 0xE,
	Attrib3 = 0xF,
	Attrib4 = 0x10,
	Attrib5 = 0x11,
	Attrib6 = 0x12,
	Attrib7 = 0x13,
	Attrib8 = 0x14,
	Attrib9 = 0x15,
	Attrib10 = 0x16,
	Attrib11 = 0x17,
	Attrib12 = 0x18,
	Attrib13 = 0x19,
	Attrib14 = 0x1A,
	Attrib15 = 0x1B,
	Count = 0x1C,
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/VertexFormat/VertexChannelFormat.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.VertexFormat;

/// <summary>
/// Less than 2017.1
/// </summary>
public enum VertexChannelFormat : byte
{
	Float = 0,
	Float16 = 1,
	Color = 2,
	Byte = 3,
	UInt = 4,
}

public static class VertexChannelFormatV4Extension
{
	public static VertexFormat ToVertexFormat(this VertexChannelFormat _this)
	{
		return _this switch
		{
			VertexChannelFormat.Float => VertexFormat.Float,
			VertexChannelFormat.Float16 => VertexFormat.Float16,
			VertexChannelFormat.Color => VertexFormat.Color,
			_ => throw new Exception(_this.ToString()),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/VertexFormat/VertexFormat.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.ShaderChannel;

namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.VertexFormat;

/// <summary>
/// Also called VertexAttributeFormat<br/>
/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
/// </summary>
public enum VertexFormat
{
	Float,
	Float16,
	Color,
	Byte,
	Int,
}

public static class VertexFormatExtensions
{
	/// <summary>
	/// 2019.1 and greater
	/// </summary>
	public static bool VertexFormat2019Relevant(UnityVersion version) => version.GreaterThanOrEquals(2019);
	/// <summary>
	/// 2017.1 and greater
	/// </summary>
	public static bool VertexFormat2017Relevant(UnityVersion version) => version.GreaterThanOrEquals(2017);

	public static byte CalculateStride(this VertexFormat _this, UnityVersion version, int dimention)
	{
		return (byte)(_this.GetSize(version) * dimention);
	}

	public static int GetSize(this VertexFormat _this, UnityVersion version)
	{
		return _this switch
		{
			VertexFormat.Float => 4,
			VertexFormat.Float16 => 2,
			VertexFormat.Color => ShaderChannelExtensions.ShaderChannel5Relevant(version) ? 1 : 4,
			VertexFormat.Byte => 1,
			VertexFormat.Int => 4,
			_ => throw new Exception(_this.ToString()),
		};
	}

	public static byte ToFormat(this VertexFormat _this, UnityVersion version)
	{
		if (VertexFormat2019Relevant(version))
		{
			return (byte)_this.ToVertexFormat2019();
		}
		else if (VertexFormat2017Relevant(version))
		{
			return (byte)_this.ToVertexFormat2017();
		}
		else
		{
			return (byte)_this.ToVertexChannelFormat();
		}
	}

	public static VertexChannelFormat ToVertexChannelFormat(this VertexFormat _this)
	{
		return _this switch
		{
			VertexFormat.Float => VertexChannelFormat.Float,
			VertexFormat.Float16 => VertexChannelFormat.Float16,
			VertexFormat.Color => VertexChannelFormat.Color,
			_ => throw new Exception(_this.ToString()),
		};
	}

	public static VertexFormat2017 ToVertexFormat2017(this VertexFormat _this)
	{
		return _this switch
		{
			VertexFormat.Float => VertexFormat2017.Float,
			VertexFormat.Float16 => VertexFormat2017.Float16,
			VertexFormat.Color => VertexFormat2017.Color,
			VertexFormat.Byte => VertexFormat2017.UInt8,
			VertexFormat.Int => VertexFormat2017.UInt32,
			_ => throw new Exception(_this.ToString()),
		};
	}

	public static VertexFormat2019 ToVertexFormat2019(this VertexFormat _this)
	{
		return _this switch
		{
			VertexFormat.Float => VertexFormat2019.Float,
			VertexFormat.Float16 => VertexFormat2019.Float16,
			VertexFormat.Color or VertexFormat.Byte => VertexFormat2019.UNorm8,
			VertexFormat.Int => VertexFormat2019.UInt32,
			_ => throw new Exception(_this.ToString()),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/VertexFormat/VertexFormat2017.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.VertexFormat;

/// <summary>
/// 2017.1 to 2018.x.x
/// </summary>
public enum VertexFormat2017 : byte
{
	Float = 0,
	Float16 = 1,
	Color = 2,
	UNorm8 = 3,
	SNorm8 = 4,
	UNorm16 = 5,
	SNorm16 = 6,
	UInt8 = 7,
	SInt8 = 8,
	UInt16 = 9,
	SInt16 = 10,
	UInt32 = 11,
	SInt32 = 12,
}

public static class VertexFormatV5Extension
{
	public static VertexFormat ToVertexFormat(this VertexFormat2017 _this)
	{
		return _this switch
		{
			VertexFormat2017.Float => VertexFormat.Float,
			VertexFormat2017.Float16 => VertexFormat.Float16,
			VertexFormat2017.Color => VertexFormat.Color,
			VertexFormat2017.UNorm8 => VertexFormat.Byte,
			VertexFormat2017.UInt32 => VertexFormat.Int,
			_ => throw new Exception(_this.ToString()),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Enums/Shader/VertexFormat/VertexFormat2019.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions.Enums.Shader.VertexFormat;

/// <summary>
/// 2019.1 and greater
/// </summary>
public enum VertexFormat2019 : byte
{
	Float = 0,
	Float16 = 1,
	UNorm8 = 2,
	SNorm8 = 3,
	UNorm16 = 4,
	SNorm16 = 5,
	UInt8 = 6,
	SInt8 = 7,
	UInt16 = 8,
	SInt16 = 9,
	UInt32 = 10,
	SInt32 = 11,
}

public static class VertexFormat2019Extension
{
	public static VertexFormat ToVertexFormat(this VertexFormat2019 _this)
	{
		return _this switch
		{
			VertexFormat2019.Float => VertexFormat.Float,
			VertexFormat2019.Float16 => VertexFormat.Float16,
			VertexFormat2019.UNorm8 => VertexFormat.Byte,
			VertexFormat2019.UInt32 => VertexFormat.Int,
			_ => throw new Exception(_this.ToString()),
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ExternalForcesModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.ExternalForcesModule;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ExternalForcesModuleExtensions
{
	public static void SetToDefault(this IExternalForcesModule module, UnityVersion version)
	{
		module.MultiplierCurve?.SetValues(version, 1f);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ExternalVersionControlExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ExternalVersionControlExtensions
{
	private const string HiddenMeta = "Hidden Meta Files";
	private const string VisibleMeta = "Visible Meta Files";

	public static string ConvertToString(this ExternalVersionControl support)
	{
		return support switch
		{
			ExternalVersionControl.AutoDetect => "Auto detect",
			ExternalVersionControl.Disabled => HiddenMeta,
			ExternalVersionControl.Generic or ExternalVersionControl.AssetServer => VisibleMeta,
			ExternalVersionControl.Subversion => "Subversion",
			ExternalVersionControl.Perforce => "Perforce",
			_ => HiddenMeta,
		};
	}

	public static string ToStringExact(this ExternalVersionControl support)
	{
		return support switch
		{
			ExternalVersionControl.AutoDetect => "Auto detect",
			ExternalVersionControl.Disabled => "Disabled",
			ExternalVersionControl.Generic => VisibleMeta,
			ExternalVersionControl.AssetServer => "Asset Server",
			ExternalVersionControl.Subversion => "Subversion",
			ExternalVersionControl.Perforce => "Perforce",
			_ => HiddenMeta,
		};
	}

	public static ExternalVersionControl FromStringExact(string str)
	{
		return str switch
		{
			"Auto detect" => ExternalVersionControl.AutoDetect,
			"Disabled" => ExternalVersionControl.Disabled,
			"Asset Server" => ExternalVersionControl.AssetServer,
			"Subversion" => ExternalVersionControl.Subversion,
			"Perforce" => ExternalVersionControl.Perforce,
			VisibleMeta => ExternalVersionControl.Generic,
			HiddenMeta => ExternalVersionControl.Disabled,
			_ => ExternalVersionControl.Disabled,
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/FlareExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_121;

namespace AssetRipper.SourceGenerated.Extensions;

public static class FlareExtensions
{
	/// <summary>
	/// Enum describing how the individual Flare Element images are laid out inside the Flare Texture.<br/>
	/// <see href="https://docs.unity3d.com/Manual/class-Flare.html"/>
	/// </summary>
	public enum TextureLayout
	{
		OneLargeFourSmall = 0,
		OneLargeTwoMediumEightSmall = 1,
		OneTexture = 2,
		TwoGrid = 3,
		ThreeGrid = 4,
		FourGrid = 5
	}
	public static TextureLayout GetTextureLayout(this IFlare flare)
	{
		return (TextureLayout)flare.TextureLayout;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/FloatCurveExtensions.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Subclasses.FloatCurve;

namespace AssetRipper.SourceGenerated.Extensions;

public static class FloatCurveExtensions
{
	public static void SetValues(this IFloatCurve curve, AssetCollection collection, string path, string attribute, ClassIDType classID, IMonoScript script)
	{
		curve.Path = path;
		curve.Attribute = attribute;
		curve.ClassID = (int)classID;
		curve.Script.SetAsset(collection, script);
		curve.Curve.SetDefaultRotationOrderAndCurveLoopType();
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/FloatExtensions.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions;

public static class FloatExtensions
{
	public static string ToStringInvariant(this float value) => value.ToString(System.Globalization.CultureInfo.InvariantCulture);
}

```

`Source/AssetRipper.SourceGenerated.Extensions/FmodSoundTypeExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.NativeEnums.Fmod;

namespace AssetRipper.SourceGenerated.Extensions;

public static class FmodSoundTypeExtensions
{
	public static string ToRawExtension(this FmodSoundType soundType) => soundType switch
	{
		FmodSoundType.Acc => "m4a",
		FmodSoundType.Aiff => "aif",
		FmodSoundType.It => "it",
		FmodSoundType.Mod => "mod",
		FmodSoundType.Mpeg => "mp3",
		FmodSoundType.Oggvorbis => "ogg",
		FmodSoundType.S3m => "s3m",
		FmodSoundType.Wav => "wav",
		FmodSoundType.Xm => "xm",
		FmodSoundType.Xma => "wav",
		FmodSoundType.Vag => "vag",
		FmodSoundType.Audioqueue => "fsb",
		_ => "audioClip",
	};
}

```

`Source/AssetRipper.SourceGenerated.Extensions/FontExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_128;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_27;
using AssetRipper.SourceGenerated.Enums;
using System.Buffers.Binary;

namespace AssetRipper.SourceGenerated.Extensions;

public static class FontExtensions
{
	public static FontStyle GetDefaultStyle(this IFont font)
	{
		return (FontStyle)font.DefaultStyle;
	}

	public static FontRenderingMode GetFontRenderingMode(this IFont font)
	{
		return (FontRenderingMode)font.FontRenderingMode;
	}

	/// <summary>
	/// Font Material is an automatically generated material for each font.
	/// </summary>
	/// <param name="font"></param>
	/// <param name="fontMaterial"></param>
	/// <returns></returns>
	public static bool TryGetFontMaterial(this IFont font, [NotNullWhen(true)] out IMaterial? fontMaterial)
	{
		if (font.DefaultMaterialP is { Name.String: "Font Material" } material)
		{
			fontMaterial = material;
			return true;
		}
		else
		{
			fontMaterial = null;
			return false;
		}
	}

	/// <summary>
	/// Font Texture is an automatically generated texture for each font.
	/// </summary>
	/// <param name="font"></param>
	/// <param name="fontTexture"></param>
	/// <returns></returns>
	public static bool TryGetFontTexture(this IFont font, [NotNullWhen(true)] out ITexture? fontTexture)
	{
		if (font.TextureP is { Name.String: "Font Texture" } texture)
		{
			fontTexture = texture;
			return true;
		}
		else
		{
			fontTexture = null;
			return false;
		}
	}

	public static string GetFontExtension(this IFont font)
	{
		byte[] fontData = font.FontData;
		if (fontData.Length < 4)
		{
			return "ttf";// just in case
		}
		uint type = BinaryPrimitives.ReadUInt32LittleEndian(fontData);
		return type == OttoAsciiFourCC ? "otf" : "ttf";
	}

	/// <summary>
	/// OTTO ascii
	/// </summary>
	private const int OttoAsciiFourCC = 0x4F54544F;
}

```

`Source/AssetRipper.SourceGenerated.Extensions/GISettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.GISettings;

namespace AssetRipper.SourceGenerated.Extensions;

public static class GISettingsExtensions
{
	public enum EnvironmentAmbientMode
	{
		Realtime = 0,
		Baked = 1,
	}

	public static void Initialize(this IGISettings settings)
	{
		settings.BounceScale = 1.0f;
		settings.IndirectOutputScale = 1.0f;
		settings.AlbedoBoost = 1.0f;
		settings.TemporalCoherenceThreshold = 1.0f;
		settings.EnvironmentLightingMode = (uint)EnvironmentAmbientMode.Realtime;
		settings.EnableBakedLightmaps = true;
		settings.EnableRealtimeLightmaps = true;
	}

	public static EnvironmentAmbientMode GetEnvironmentLightingMode(this IGISettings settings)
	{
		return (EnvironmentAmbientMode)settings.EnvironmentLightingMode;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/GLTextureSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.GLTextureSettings;
using FilterMode = AssetRipper.SourceGenerated.Enums.FilterMode_0;

namespace AssetRipper.SourceGenerated.Extensions;

public static class GLTextureSettingsExtensions
{
	public static void SetToDefault(this IGLTextureSettings settings)
	{
		settings.FilterMode = (int)(FilterMode)(-1);
		settings.Aniso = -1;
		settings.MipBias = -100;
		settings.WrapMode = (int)(TextureWrapMode)(-1);
		settings.WrapU = (int)(TextureWrapMode)(-1);
		settings.WrapV = (int)(TextureWrapMode)(-1);
		settings.WrapW = (int)(TextureWrapMode)(-1);
	}

	public static void CopyValues(this IGLTextureSettings destination, IGLTextureSettings source)
	{
		destination.Aniso = source.Aniso;
		destination.FilterMode = source.FilterMode;
		destination.MipBias = source.MipBias;
		destination.WrapMode = source.WrapMode;
		destination.WrapU = source.WrapU;
		destination.WrapV = source.WrapV;
		destination.WrapW = source.WrapW;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/GUIStyleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.GUIStyle;

namespace AssetRipper.SourceGenerated.Extensions;

public static class GUIStyleExtensions
{
	public static ImagePosition GetImagePosition(this IGUIStyle style)
	{
		return (ImagePosition)style.ImagePosition;
	}

	public static TextAnchor GetAlignment(this IGUIStyle style)
	{
		return (TextAnchor)style.Alignment;
	}

	public static FontStyle GetFontStyle(this IGUIStyle style)
	{
		return (FontStyle)style.FontStyle;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/GameObjectExtensions.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_18;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Classes.ClassID_78;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.ComponentPair;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Component;

namespace AssetRipper.SourceGenerated.Extensions;

public static class GameObjectExtensions
{
	/// <summary>
	/// Less than 4.0.0
	/// </summary>
	private static bool IsActiveInherited(UnityVersion version) => version.LessThan(4);

	public static bool GetIsActive(this IGameObject gameObject)
	{
		return gameObject.IsActive_Boolean || gameObject.IsActive_Byte > 0;
	}

	public static void SetIsActive(this IGameObject gameObject, bool active)
	{
		gameObject.IsActive_Byte = active ? (byte)1 : (byte)0;
		gameObject.IsActive_Boolean = active;
	}

	private static bool ShouldBeActive(this IGameObject gameObject)
	{
		if (IsActiveInherited(gameObject.Collection.Version) && !gameObject.Collection.IsScene)
		{
			return true;
		}
		return gameObject.GetIsActive();
	}

	public static void ConvertToEditorFormat(this IGameObject gameObject, ITagManager? tagManager)
	{
		gameObject.SetIsActive(gameObject.ShouldBeActive());
		gameObject.TagString = tagManager.TagIDToName(gameObject.Tag);
	}

	public static IEnumerable<IPPtr_Component> FetchComponents(this IGameObject gameObject)
	{
		return gameObject.Components.Select(pair => pair.Component);
	}

	public static AccessListBase<IPPtr_Component> GetComponentPPtrList(this IGameObject gameObject)
	{
		return new ComponentPairAccessList(gameObject.Components);
	}

	public static int GetComponentCount(this IGameObject gameObject)
	{
		return gameObject.Components.Count;
	}

	public static void AddComponent(this IGameObject gameObject, ClassIDType classID, IComponent component)
	{
		IComponentPair pair = gameObject.Components.AddNew();
		pair.ClassID = (int)classID;
		pair.Component.SetAsset(gameObject.Collection, component);
	}

	public static PPtrAccessList<IPPtr_Component, IComponent> GetComponentAccessList(this IGameObject gameObject)
	{
		return new PPtrAccessList<IPPtr_Component, IComponent>(gameObject.GetComponentPPtrList(), gameObject.Collection);
	}

	public static T? TryGetComponent<T>(this IGameObject gameObject) where T : IComponent
	{
		gameObject.TryGetComponent(out T? component);
		return component;
	}

	public static bool TryGetComponent<T>(this IGameObject gameObject, [NotNullWhen(true)] out T? component) where T : IComponent
	{
		foreach (IComponent? comp in gameObject.GetComponentAccessList())
		{
			// component could have not implemented asset type
			if (comp is T t)
			{
				component = t;
				return true;
			}
		}
		component = default;
		return false;
	}

	public static T GetComponent<T>(this IGameObject gameObject) where T : IComponent
	{
		if (!gameObject.TryGetComponent(out T? component))
		{
			throw new Exception($"Component of type {typeof(T)} hasn't been found");
		}
		return component;
	}

	public static ITransform GetTransform(this IGameObject gameObject)
	{
		foreach (IComponent? component in gameObject.GetComponentAccessList())
		{
			if (component is ITransform transform)
			{
				return transform;
			}
		}
		throw new Exception("Can't find transform component");
	}

	public static bool IsRoot(this IGameObject gameObject)
	{
		return gameObject.TryGetComponent<ITransform>()?.Father_C4P is null;
	}

	public static IGameObject GetRoot(this IGameObject gameObject)
	{
		if (!gameObject.TryGetComponent(out ITransform? root))
		{
			return gameObject;
		}

		while (true)
		{
			ITransform? parent = root.Father_C4P;
			if (parent is null || parent.GameObject_C4P is null)
			{
				break;
			}
			else
			{
				root = parent;
			}
		}
		return root.GameObject_C4P!;
	}

	public static int GetRootDepth(this IGameObject gameObject)
	{
		if (!gameObject.TryGetComponent(out ITransform? root))
		{
			return 0;
		}

		int depth = 0;
		while (true)
		{
			ITransform? parent = root.Father_C4P;
			if (parent == null)
			{
				break;
			}

			root = parent;
			depth++;
		}
		return depth;
	}

	/// <summary>
	/// Fetch all the assets in the hierarchy for this <see cref="IGameObject"/>.
	/// </summary>
	/// <remarks>
	/// This includes the <paramref name="root"/>.
	/// </remarks>
	/// <param name="root"></param>
	/// <returns></returns>
	/// <exception cref="NullReferenceException">A referenced asset wasn't found.</exception>
	public static IEnumerable<IEditorExtension> FetchHierarchy(this IGameObject root)
	{
		yield return root;

		ITransform? transform = null;
		foreach (IComponent component in root.GetComponentAccessList().WhereNotNull())
		{
			yield return component;

			if (component is ITransform trfm)
			{
				transform = trfm;
			}
		}

		if (transform is null)
		{
			yield break;
		}

		foreach (IGameObject child in transform.Children_C4P.WhereNotNull().Select(t => t.GameObject_C4P).WhereNotNull())
		{
			foreach (IEditorExtension childElement in child.FetchHierarchy())
			{
				yield return childElement;
			}
		}
	}

	public static IEnumerable<IGameObject> GetChildren(this IGameObject gameObject)
	{
		ITransform transform = gameObject.GetTransform();
		return transform.Children_C4P.WhereNotNull().Select(t => t.GameObject_C4P).WhereNotNull();
	}

	public static IPrefabInstance CreatePrefabForRoot(this IGameObject root, ProcessedAssetCollection collection)
	{
		IPrefabInstance prefab = collection.CreatePrefabInstance();

		prefab.HideFlagsE = HideFlags.HideInHierarchy;
		prefab.RootGameObjectP = root;
		prefab.IsPrefabAsset = true;
		prefab.AssetBundleName = root.AssetBundleName;

		prefab.OriginalDirectory = root.OriginalDirectory;
		prefab.OriginalName = root.OriginalName;
		prefab.OriginalExtension = root.OriginalExtension;

		prefab.OverrideDirectory = root.GetBestDirectory();
		prefab.OverrideName = root.GetBestName();
		prefab.OverrideExtension = root.GetBestExtension();

		prefab.SetPrefabInternal();

		return prefab;
	}

	private sealed class ComponentPairAccessList : AccessListBase<IPPtr_Component>
	{
		private readonly AccessListBase<IComponentPair> referenceList;

		public ComponentPairAccessList(AccessListBase<IComponentPair> referenceList)
		{
			this.referenceList = referenceList;
		}

		public override IPPtr_Component this[int index]
		{
			get => referenceList[index].Component;
			set => throw new NotSupportedException();
		}

		public override int Count => referenceList.Count;

		public override int Capacity { get => referenceList.Capacity; set => referenceList.Capacity = value; }

		public override void Add(IPPtr_Component item)
		{
			throw new NotSupportedException();
		}

		public override IPPtr_Component AddNew()
		{
			IComponentPair componentPair = referenceList.AddNew();
			componentPair.ClassID = (int)ClassIDType.Component;
			return componentPair.Component;
			//throw new NotSupportedException();
			//Not sure the above code is safe since Unity might rely on the class id being correct.
		}

		public override void Clear()
		{
			referenceList.Clear();
		}

		public override bool Contains(IPPtr_Component item)
		{
			return referenceList.Any(ptr => ptr.Component.Equals(item));
		}

		public override void CopyTo(IPPtr_Component[] array, int arrayIndex)
		{
			for (int i = 0; i < referenceList.Count; i++)
			{
				array[i + arrayIndex] = referenceList[i].Component;
			}
		}

		public override int EnsureCapacity(int capacity)
		{
			return referenceList.EnsureCapacity(capacity);
		}

		public override int IndexOf(IPPtr_Component item)
		{
			return referenceList.IndexOf(pair => pair.Component.Equals(item));
		}

		public override void Insert(int index, IPPtr_Component item)
		{
			throw new NotSupportedException();
		}

		public override bool Remove(IPPtr_Component item)
		{
			int index = IndexOf(item);
			if (index < 0)
			{
				return false;
			}
			else
			{
				RemoveAt(index);
				return true;
			}
		}

		public override void RemoveAt(int index)
		{
			referenceList.RemoveAt(index);
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/GenericBindingExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip;
using AssetRipper.SourceGenerated.Extensions.Enums.AnimationClip.GenericBinding;
using AssetRipper.SourceGenerated.Subclasses.GenericBinding;

namespace AssetRipper.SourceGenerated.Extensions;

public static class GenericBindingExtensions
{
	public static HumanoidMuscleType GetHumanoidMuscle(this IGenericBinding binding, UnityVersion version)
	{
		return ((HumanoidMuscleType)binding.Attribute).Update(version);
	}

	public static bool IsTransform(this IGenericBinding binding)
	{
		return binding.GetClassID() == ClassIDType.Transform
			|| binding.GetClassID() == ClassIDType.RectTransform
			&& binding.TransformType().IsValid();
	}

	public static TransformType TransformType(this IGenericBinding binding)
	{
		return unchecked((TransformType)binding.Attribute);
	}

	public static ClassIDType GetClassID(this IGenericBinding binding)
	{
		return binding.Has_ClassID_UInt16() ? (ClassIDType)binding.ClassID_UInt16 : (ClassIDType)binding.ClassID_Int32;
	}

	public static void SetClassID(this IGenericBinding binding, ClassIDType classID)
	{
		if (binding.Has_ClassID_UInt16())
		{
			binding.ClassID_UInt16 = (ushort)classID;
		}
		else
		{
			binding.ClassID_Int32 = (int)classID;
		}
	}

	public static bool IsPPtrCurve(this IGenericBinding binding)
	{
		return binding.IsPPtrCurve != 0;
	}

	public static bool IsIntCurve(this IGenericBinding binding)
	{
		return binding.IsIntCurve != 0;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/GraphicsFormatExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class GraphicsFormatExtensions
{
	/// <summary>
	/// Converts <see cref="GraphicsFormat"/> to <see cref="TextureFormat"/>.
	/// </summary>
	/// <remarks>
	/// Note: Some conversions are not entirely accurate. For example, SRGB and UNorm are treated as the same.
	/// </remarks>
	/// <param name="format">The <see cref="GraphicsFormat"/> to convert.</param>
	/// <returns>The <see cref="TextureFormat"/> equivalent to the <paramref name="format"/> parameter.</returns>
	/// <exception cref="NotSupportedException">There is no direct conversion for the format.</exception>
	/// <exception cref="ArgumentOutOfRangeException">The format was an invalid value.</exception>
	public static TextureFormat ToTextureFormat(this GraphicsFormat format) => format switch
	{
		GraphicsFormat.None => throw new NotSupportedException(),
		GraphicsFormat.R8_SRGB => TextureFormat.R8,
		GraphicsFormat.R8G8_SRGB => TextureFormat.RG16,
		GraphicsFormat.R8G8B8_SRGB => TextureFormat.RGB24,
		GraphicsFormat.R8G8B8A8_SRGB => TextureFormat.RGBA32,
		GraphicsFormat.R8_UNorm => TextureFormat.R8,
		GraphicsFormat.R8G8_UNorm => TextureFormat.RG16,
		GraphicsFormat.R8G8B8_UNorm => TextureFormat.RGB24,
		GraphicsFormat.R8G8B8A8_UNorm => TextureFormat.RGBA32,
		GraphicsFormat.R8_SNorm => TextureFormat.R8_SIGNED,
		GraphicsFormat.R8G8_SNorm => TextureFormat.RG16_SIGNED,
		GraphicsFormat.R8G8B8_SNorm => TextureFormat.RGB24_SIGNED,
		GraphicsFormat.R8G8B8A8_SNorm => TextureFormat.RGBA32_SIGNED,
		GraphicsFormat.R8_UInt => TextureFormat.R8,
		GraphicsFormat.R8G8_UInt => TextureFormat.RG16,
		GraphicsFormat.R8G8B8_UInt => TextureFormat.RGB24,
		GraphicsFormat.R8G8B8A8_UInt => TextureFormat.RGBA32,
		GraphicsFormat.R8_SInt => TextureFormat.R8_SIGNED,
		GraphicsFormat.R8G8_SInt => TextureFormat.RG16_SIGNED,
		GraphicsFormat.R8G8B8_SInt => TextureFormat.RGB24_SIGNED,
		GraphicsFormat.R8G8B8A8_SInt => TextureFormat.RGBA32_SIGNED,
		GraphicsFormat.R16_UNorm => TextureFormat.R16,
		GraphicsFormat.R16G16_UNorm => TextureFormat.RG32,
		GraphicsFormat.R16G16B16_UNorm => TextureFormat.RGB48,
		GraphicsFormat.R16G16B16A16_UNorm => TextureFormat.RGBA64,
		GraphicsFormat.R16_SNorm => TextureFormat.R16_SIGNED,
		GraphicsFormat.R16G16_SNorm => TextureFormat.RG32_SIGNED,
		GraphicsFormat.R16G16B16_SNorm => TextureFormat.RGB48_SIGNED,
		GraphicsFormat.R16G16B16A16_SNorm => TextureFormat.RGBA64_SIGNED,
		GraphicsFormat.R16_UInt => TextureFormat.R16,
		GraphicsFormat.R16G16_UInt => TextureFormat.RG32,
		GraphicsFormat.R16G16B16_UInt => TextureFormat.RGB48,
		GraphicsFormat.R16G16B16A16_UInt => TextureFormat.RGBA64,
		GraphicsFormat.R16_SInt => TextureFormat.R16_SIGNED,
		GraphicsFormat.R16G16_SInt => TextureFormat.RG32_SIGNED,
		GraphicsFormat.R16G16B16_SInt => TextureFormat.RGB48_SIGNED,
		GraphicsFormat.R16G16B16A16_SInt => TextureFormat.RGBA64_SIGNED,
		GraphicsFormat.R32_UInt => throw new NotSupportedException(),
		GraphicsFormat.R32G32_UInt => throw new NotSupportedException(),
		GraphicsFormat.R32G32B32_UInt => throw new NotSupportedException(),
		GraphicsFormat.R32G32B32A32_UInt => throw new NotSupportedException(),
		GraphicsFormat.R32_SInt => throw new NotSupportedException(),
		GraphicsFormat.R32G32_SInt => throw new NotSupportedException(),
		GraphicsFormat.R32G32B32_SInt => throw new NotSupportedException(),
		GraphicsFormat.R32G32B32A32_SInt => throw new NotSupportedException(),
		GraphicsFormat.R16_SFloat => throw new NotSupportedException(),
		GraphicsFormat.R16G16_SFloat => throw new NotSupportedException(),
		GraphicsFormat.R16G16B16_SFloat => throw new NotSupportedException(),
		GraphicsFormat.R16G16B16A16_SFloat => throw new NotSupportedException(),
		GraphicsFormat.R32_SFloat => throw new NotSupportedException(),
		GraphicsFormat.R32G32_SFloat => throw new NotSupportedException(),
		GraphicsFormat.R32G32B32_SFloat => throw new NotSupportedException(),
		GraphicsFormat.R32G32B32A32_SFloat => throw new NotSupportedException(),
		GraphicsFormat.B8G8R8_SRGB => throw new NotSupportedException(),
		GraphicsFormat.B8G8R8A8_SRGB => TextureFormat.BGRA32_14,
		GraphicsFormat.B8G8R8_UNorm => throw new NotSupportedException(),
		GraphicsFormat.B8G8R8A8_UNorm => TextureFormat.BGRA32_14,
		GraphicsFormat.B8G8R8_SNorm => throw new NotSupportedException(),
		GraphicsFormat.B8G8R8A8_SNorm => TextureFormat.BGRA32_14,
		GraphicsFormat.B8G8R8_UInt => throw new NotSupportedException(),
		GraphicsFormat.B8G8R8A8_UInt => TextureFormat.BGRA32_14,
		GraphicsFormat.B8G8R8_SInt => throw new NotSupportedException(),
		GraphicsFormat.B8G8R8A8_SInt => TextureFormat.BGRA32_14,
		GraphicsFormat.R4G4B4A4_UNormPack16 => throw new NotSupportedException(),
		GraphicsFormat.B4G4R4A4_UNormPack16 => throw new NotSupportedException(),
		GraphicsFormat.R5G6B5_UNormPack16 => TextureFormat.RGB565,
		GraphicsFormat.B5G6R5_UNormPack16 => throw new NotSupportedException(),
		GraphicsFormat.R5G5B5A1_UNormPack16 => throw new NotSupportedException(),
		GraphicsFormat.B5G5R5A1_UNormPack16 => throw new NotSupportedException(),
		GraphicsFormat.A1R5G5B5_UNormPack16 => throw new NotSupportedException(),
		GraphicsFormat.E5B9G9R9_UFloatPack32 => throw new NotSupportedException(),
		GraphicsFormat.B10G11R11_UFloatPack32 => throw new NotSupportedException(),
		GraphicsFormat.A2B10G10R10_UNormPack32 => throw new NotSupportedException(),
		GraphicsFormat.A2B10G10R10_UIntPack32 => throw new NotSupportedException(),
		GraphicsFormat.A2B10G10R10_SIntPack32 => throw new NotSupportedException(),
		GraphicsFormat.A2R10G10B10_UNormPack32 => throw new NotSupportedException(),
		GraphicsFormat.A2R10G10B10_UIntPack32 => throw new NotSupportedException(),
		GraphicsFormat.A2R10G10B10_SIntPack32 => throw new NotSupportedException(),
		GraphicsFormat.A2R10G10B10_XRSRGBPack32 => throw new NotSupportedException(),
		GraphicsFormat.A2R10G10B10_XRUNormPack32 => throw new NotSupportedException(),
		GraphicsFormat.R10G10B10_XRSRGBPack32 => throw new NotSupportedException(),
		GraphicsFormat.R10G10B10_XRUNormPack32 => throw new NotSupportedException(),
		GraphicsFormat.A10R10G10B10_XRSRGBPack32 => throw new NotSupportedException(),
		GraphicsFormat.A10R10G10B10_XRUNormPack32 => throw new NotSupportedException(),
		GraphicsFormat.D16_UNorm => throw new NotSupportedException(),
		GraphicsFormat.D24_UNorm => throw new NotSupportedException(),
		GraphicsFormat.D24_UNorm_S8_UInt => throw new NotSupportedException(),
		GraphicsFormat.D32_SFloat => throw new NotSupportedException(),
		GraphicsFormat.D32_SFloat_S8_Uint => throw new NotSupportedException(),
		GraphicsFormat.S8_Uint => TextureFormat.Alpha8,
		GraphicsFormat.RGB_DXT1_SRGB => TextureFormat.DXT1,
		GraphicsFormat.RGB_DXT1_UNorm => TextureFormat.DXT1,
		GraphicsFormat.RGBA_DXT3_SRGB => TextureFormat.DXT3,
		GraphicsFormat.RGBA_DXT3_UNorm => TextureFormat.DXT3,
		GraphicsFormat.RGBA_DXT5_SRGB => TextureFormat.DXT5,
		GraphicsFormat.RGBA_DXT5_UNorm => TextureFormat.DXT5,
		GraphicsFormat.R_BC4_UNorm => TextureFormat.BC4,
		GraphicsFormat.R_BC4_SNorm => TextureFormat.BC4,
		GraphicsFormat.RG_BC5_UNorm => TextureFormat.BC5,
		GraphicsFormat.RG_BC5_SNorm => TextureFormat.BC5,
		GraphicsFormat.RGB_BC6H_UFloat => TextureFormat.BC6H,
		GraphicsFormat.RGB_BC6H_SFloat => TextureFormat.BC6H,
		GraphicsFormat.RGBA_BC7_SRGB => TextureFormat.BC7,
		GraphicsFormat.RGBA_BC7_UNorm => TextureFormat.BC7,
		GraphicsFormat.RGB_PVRTC_2Bpp_SRGB => TextureFormat.PVRTC_RGB2,
		GraphicsFormat.RGB_PVRTC_2Bpp_UNorm => TextureFormat.PVRTC_RGB2,
		GraphicsFormat.RGB_PVRTC_4Bpp_SRGB => TextureFormat.PVRTC_RGB4,
		GraphicsFormat.RGB_PVRTC_4Bpp_UNorm => TextureFormat.PVRTC_RGB4,
		GraphicsFormat.RGBA_PVRTC_2Bpp_SRGB => TextureFormat.PVRTC_RGBA2,
		GraphicsFormat.RGBA_PVRTC_2Bpp_UNorm => TextureFormat.PVRTC_RGBA2,
		GraphicsFormat.RGBA_PVRTC_4Bpp_SRGB => TextureFormat.PVRTC_RGBA4,
		GraphicsFormat.RGBA_PVRTC_4Bpp_UNorm => TextureFormat.PVRTC_RGBA4,
		GraphicsFormat.RGB_ETC_UNorm => TextureFormat.ETC_RGB4,
		GraphicsFormat.RGB_ETC2_SRGB => TextureFormat.ETC2_RGB,
		GraphicsFormat.RGB_ETC2_UNorm => TextureFormat.ETC2_RGB,
		GraphicsFormat.RGB_A1_ETC2_SRGB => TextureFormat.ETC2_RGBA1,
		GraphicsFormat.RGB_A1_ETC2_UNorm => TextureFormat.ETC2_RGBA1,
		GraphicsFormat.RGBA_ETC2_SRGB => TextureFormat.ETC2_RGBA8,
		GraphicsFormat.RGBA_ETC2_UNorm => TextureFormat.ETC2_RGBA8,
		GraphicsFormat.R_EAC_UNorm => TextureFormat.EAC_R,
		GraphicsFormat.R_EAC_SNorm => TextureFormat.EAC_R,
		GraphicsFormat.RG_EAC_UNorm => TextureFormat.EAC_RG,
		GraphicsFormat.RG_EAC_SNorm => TextureFormat.EAC_RG,
		GraphicsFormat.RGBA_ASTC4X4_SRGB => TextureFormat.ASTC_4x4,
		GraphicsFormat.RGBA_ASTC4X4_UNorm => TextureFormat.ASTC_4x4,
		GraphicsFormat.RGBA_ASTC5X5_SRGB => TextureFormat.ASTC_5x5,
		GraphicsFormat.RGBA_ASTC5X5_UNorm => TextureFormat.ASTC_5x5,
		GraphicsFormat.RGBA_ASTC6X6_SRGB => TextureFormat.ASTC_6x6,
		GraphicsFormat.RGBA_ASTC6X6_UNorm => TextureFormat.ASTC_6x6,
		GraphicsFormat.RGBA_ASTC8X8_SRGB => TextureFormat.ASTC_8x8,
		GraphicsFormat.RGBA_ASTC8X8_UNorm => TextureFormat.ASTC_8x8,
		GraphicsFormat.RGBA_ASTC10X10_SRGB => TextureFormat.ASTC_10x10,
		GraphicsFormat.RGBA_ASTC10X10_UNorm => TextureFormat.ASTC_10x10,
		GraphicsFormat.RGBA_ASTC12X12_SRGB => TextureFormat.ASTC_12x12,
		GraphicsFormat.RGBA_ASTC12X12_UNorm => TextureFormat.ASTC_12x12,
		GraphicsFormat.YUV2 => throw new NotSupportedException(),
		GraphicsFormat.DepthAuto => throw new NotSupportedException(),
		GraphicsFormat.ShadowAuto => throw new NotSupportedException(),
		GraphicsFormat.VideoAuto => throw new NotSupportedException(),
		GraphicsFormat.RGBA_ASTC4X4_UFloat => TextureFormat.ASTC_4x4,
		GraphicsFormat.RGBA_ASTC5X5_UFloat => TextureFormat.ASTC_5x5,
		GraphicsFormat.RGBA_ASTC6X6_UFloat => TextureFormat.ASTC_6x6,
		GraphicsFormat.RGBA_ASTC8X8_UFloat => TextureFormat.ASTC_8x8,
		GraphicsFormat.RGBA_ASTC10X10_UFloat => TextureFormat.ASTC_10x10,
		GraphicsFormat.RGBA_ASTC12X12_UFloat => TextureFormat.ASTC_12x12,
		GraphicsFormat.D16_UNorm_S8_UInt => throw new NotSupportedException(),
		_ => throw new ArgumentOutOfRangeException(nameof(format), format, null),
	};
}

```

`Source/AssetRipper.SourceGenerated.Extensions/GraphicsSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_30;
using AssetRipper.SourceGenerated.NativeEnums.Global;
using GraphicsTier = AssetRipper.SourceGenerated.Enums.GraphicsTier;
using RenderingPath = AssetRipper.SourceGenerated.Enums.RenderingPath;

namespace AssetRipper.SourceGenerated.Extensions;

public static class GraphicsSettingsExtensions
{
	public static void ConvertToEditorFormat(this IGraphicsSettings settings)
	{
		settings.BrgStripping = (int)BrgStrippingMode.KeepIfHybrid;//https://github.com/AssetRipper/TypeTreeDumps/blob/23cd2d4db3bd83a25c57ade3d5126b011422aa3c/FieldValues/2022.3.7f1.json#L761
		settings.DefaultMobileRenderingPath = (int)RenderingPath.Forward;
		settings.DefaultRenderingPath = (int)RenderingPath.Forward;
		settings.FogKeepExp = true;
		settings.FogKeepExp2 = true;
		settings.FogKeepLinear = true;
		settings.FogStripping = (int)ShaderStrippingMode.Automatic;
		settings.InstancingStripping = (int)InstancingStrippingMode.StripUnused;
		settings.LightmapKeepDirCombined = true;
		settings.LightmapKeepDirSeparate = true;
		settings.LightmapKeepDynamicDirCombined = true;
		settings.LightmapKeepDynamicDirSeparate = true;
		settings.LightmapKeepDynamicPlain = true;
		settings.LightmapKeepDynamic = true;
		settings.LightmapKeepPlain = true;
		settings.LightmapKeepShadowMask = true;
		settings.LightmapKeepSubtractive = true;
		settings.LightmapStripping = (int)ShaderStrippingMode.Automatic;

		if (settings.Has_TierSettings())
		{
			settings.TierSettings.Clear();//protection against converting GraphicsSettings multiple times
			if (settings.Has_TierSettings_Tier1())
			{
				settings.TierSettings.Capacity = 3;
				settings.TierSettings.AddNew().ConvertToEditorFormat(settings.TierSettings_Tier1, settings.GetBuildTargetGroup(), GraphicsTier.Tier1);
				settings.TierSettings.AddNew().ConvertToEditorFormat(settings.TierSettings_Tier2, settings.GetBuildTargetGroup(), GraphicsTier.Tier2);
				settings.TierSettings.AddNew().ConvertToEditorFormat(settings.TierSettings_Tier3, settings.GetBuildTargetGroup(), GraphicsTier.Tier3);
			}
			else if (settings.Has_ShaderSettings_Tier1())
			{
				settings.TierSettings.Capacity = 3;
				settings.ShaderSettings_Tier1.ConvertToEditorFormat();
				settings.ShaderSettings_Tier2.ConvertToEditorFormat();
				settings.ShaderSettings_Tier2.ConvertToEditorFormat();
				settings.TierSettings.AddNew().ConvertToEditorFormat(settings.ShaderSettings_Tier1, settings.GetBuildTargetGroup(), GraphicsTier.Tier1);
				settings.TierSettings.AddNew().ConvertToEditorFormat(settings.ShaderSettings_Tier2, settings.GetBuildTargetGroup(), GraphicsTier.Tier2);
				settings.TierSettings.AddNew().ConvertToEditorFormat(settings.ShaderSettings_Tier3, settings.GetBuildTargetGroup(), GraphicsTier.Tier3);
			}
			else if (settings.Has_ShaderSettings())
			{
				settings.TierSettings.Capacity = 1;
				settings.ShaderSettings.ConvertToEditorFormat();
				settings.TierSettings.AddNew().ConvertToEditorFormat(settings.ShaderSettings, settings.GetBuildTargetGroup(), GraphicsTier.Tier1);
			}
		}
	}

	private static BuildTargetGroup GetBuildTargetGroup(this IGraphicsSettings settings)
	{
		return settings.Collection.Platform.PlatformToBuildGroup();
	}

	/// <summary>
	/// Default: <see cref="RenderingPath.Forward"/>
	/// </summary>
	public static RenderingPath GetDefaultRenderingPath(this IGraphicsSettings settings)
	{
		return settings.Has_DefaultRenderingPath()
			? settings.DefaultRenderingPathE
			: RenderingPath.Forward;
	}

	/// <summary>
	/// Default: <see cref="RenderingPath.Forward"/>
	/// </summary>
	public static RenderingPath GetDefaultMobileRenderingPath(this IGraphicsSettings settings)
	{
		return settings.Has_DefaultMobileRenderingPath()
			? settings.DefaultMobileRenderingPathE
			: RenderingPath.Forward;
	}

	/// <summary>
	/// Default: <see cref="ShaderStrippingMode.Automatic"/>
	/// </summary>
	public static ShaderStrippingMode GetLightmapStripping(this IGraphicsSettings settings)
	{
		return (ShaderStrippingMode)settings.LightmapStripping; //default is 0, so no need to check if present
	}

	/// <summary>
	/// Default: <see cref="ShaderStrippingMode.Automatic"/>
	/// </summary>
	public static ShaderStrippingMode GetFogStripping(this IGraphicsSettings settings)
	{
		return (ShaderStrippingMode)settings.FogStripping; //default is 0, so no need to check if present
	}

	/// <summary>
	/// Default: <see cref="InstancingStrippingMode.StripUnused"/>
	/// </summary>
	public static InstancingStrippingMode GetInstancingStripping(this IGraphicsSettings settings)
	{
		return (InstancingStrippingMode)settings.InstancingStripping; //default is 0, so no need to check if present
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/GuidExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.GUID;

namespace AssetRipper.SourceGenerated.Extensions;

public static class GuidExtensions
{
	public static void CopyValues(this GUID destination, UnityGuid source)
	{
		destination.Data_0_ = source.Data0;
		destination.Data_1_ = source.Data1;
		destination.Data_2_ = source.Data2;
		destination.Data_3_ = source.Data3;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/HashSetExtensions.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions;

public static class HashSetExtensions
{
	public static void AddRange<T>(this HashSet<T> set, IEnumerable<T> values)
	{
		foreach (T value in values)
		{
			set.Add(value);
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/HeightmapExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.Heightmap;

namespace AssetRipper.SourceGenerated.Extensions;

public static class HeightmapExtensions
{
	public static int GetWidth(this IHeightmap heightmap)
	{
		return heightmap.Has_Width() ? heightmap.Width : heightmap.Resolution;
	}

	public static int GetHeight(this IHeightmap heightmap)
	{
		return heightmap.Has_Height() ? heightmap.Height : heightmap.Resolution;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/IDictionaryExtensions.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions;

public static class IDictionaryExtensions
{
	public static void AddRange<T1, T2>(this IDictionary<T1, T2> _this, IReadOnlyDictionary<T1, T2> source)
	{
		foreach (KeyValuePair<T1, T2> argument in source)
		{
			_this.Add(argument.Key, argument.Value);
		}
	}

	public static T2 GetOrAdd<T1, T2>(this IDictionary<T1, T2> _this, T1 key) where T1 : notnull where T2 : new()
	{
		if (!_this.TryGetValue(key, out T2? value))
		{
			value = new();
			_this.Add(key, value);
		}
		return value;
	}

	public static T2 GetOrAdd<T1, T2>(this IDictionary<T1, T2> _this, T1 key, Func<T2> factory) where T1 : notnull
	{
		if (!_this.TryGetValue(key, out T2? value))
		{
			value = factory();
			_this.Add(key, value);
		}
		return value;
	}

	public static TValue? TryGetValue<TKey, TValue>(this IReadOnlyDictionary<TKey, TValue> _this, TKey key) where TKey : notnull
	{
		_this.TryGetValue(key, out TValue? value);
		return value;
	}

	/// <remarks>
	/// .NET Core 3.0+ only. <see href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.getenumerator?view=net-7.0#remarks"/>
	/// </remarks>
	public static void RemoveAll<TKey, TValue>(this Dictionary<TKey, TValue> source, Predicate<KeyValuePair<TKey, TValue>> predicate) where TKey : notnull
	{
		foreach (KeyValuePair<TKey, TValue> pair in source)
		{
			if (predicate(pair))
			{
				source.Remove(pair.Key);
			}
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/IEnumerableExtensions.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions;

public static class IEnumerableExtensions
{
	public static int IndexOf<T>(this IEnumerable<T> _this, Func<T, bool> predicate)
	{
		int index = 0;
		foreach (T t in _this)
		{
			if (predicate(t))
			{
				return index;
			}
			index++;
		}
		return -1;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/IHVImageFormatImporterExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_1055;
using FilterMode = AssetRipper.SourceGenerated.Enums.FilterMode_0;

namespace AssetRipper.SourceGenerated.Extensions;

public static class IHVImageFormatImporterExtensions
{
	public static void SetToDefault(this IIHVImageFormatImporter importer)
	{
		importer.TextureSettings.FilterMode = (int)FilterMode.Bilinear;
		importer.TextureSettings.Aniso = 1;
		importer.SRGBTexture = true;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/IReadOnlyListExtensions.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions;

public static class IReadOnlyListExtensions
{
	public static int IndexOf<T>(this IReadOnlyList<T> _this, T value)
	{
		for (int i = 0; i < _this.Count; i++)
		{
			T t = _this[i];
			if (EqualityComparer<T>.Default.Equals(t, value))
			{
				return i;
			}
		}
		return -1;
	}

	public static bool Contains<T>(this IReadOnlyList<T> _this, T value)
	{
		return _this.IndexOf(value) > -1;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ImageTextureExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_189;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ImageTextureExtensions
{
	public static byte[] GetImageData(this IImageTexture texture)
	{
		if (texture.ImageData_C189.Length > 0)
		{
			return texture.ImageData_C189;
		}
		else if (texture.Has_StreamData_C189() && texture.StreamData_C189.IsSet())
		{
			return texture.StreamData_C189.GetContent(texture.Collection);
		}
		else
		{
			return [];
		}
	}

	public static bool CheckAssetIntegrity(this IImageTexture texture)
	{
		if (texture.ImageData_C189.Length > 0)
		{
			return true;
		}
		else if (texture.Has_StreamData_C189())
		{
			return texture.StreamData_C189.CheckIntegrity(texture.Collection);
		}
		else
		{
			return false;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/IndexFormatExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class IndexFormatExtensions
{
	extension(IndexFormat format)
	{
		public int Size => format is IndexFormat.UInt16 ? sizeof(ushort) : sizeof(uint);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/InheritVelocityModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.InheritVelocityModule;

namespace AssetRipper.SourceGenerated.Extensions;

public static class InheritVelocityModuleExtensions
{
	public enum InheritVelocityMode
	{
		Initial = 0,
		Current = 1,
	}
	public static InheritVelocityMode GetMode(this IInheritVelocityModule module)
	{
		return (InheritVelocityMode)module.Mode;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/InputAxisExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.InputAxis;

namespace AssetRipper.SourceGenerated.Extensions;

public static class InputAxisExtensions
{
	public enum InputAxisType
	{
		/// <summary>
		/// Actually it is any button, not just keyboard or mouse
		/// </summary>
		KeyOrMouseButton = 0,
		MouseMovement = 1,
		JoystickAxis = 2,
	}
	public enum JoystickType
	{
		AllJoysticks = 0,
		Joystick1 = 1,
		Joystick2 = 2,
		Joystick3 = 3,
		Joystick4 = 4,
		Joystick5 = 5,
		Joystick6 = 6,
		Joystick7 = 7,
		Joystick8 = 8,
		Joystick9 = 9,
		Joystick10 = 10,
		Joystick11 = 11,
		Joystick12 = 12,
		Joystick13 = 13,
		Joystick14 = 14,
		Joystick15 = 15,
		Joystick16 = 16,
	}
	public enum InputAxesDirection
	{
		X = 0,
		Y = 1,
		ScrollWheel = 2,
		_4 = 3,
		_5 = 4,
		_6 = 5,
		_7 = 6,
		_8 = 7,
		_9 = 8,
		_10 = 9,
		_11 = 10,
		_12 = 11,
		_13 = 12,
		_14 = 13,
		_15 = 14,
		_16 = 15,
		_17 = 16,
		_18 = 17,
		_19 = 18,
		_20 = 19,
		_21 = 20,
		_22 = 21,
		_23 = 22,
		_24 = 23,
		_25 = 24,
		_26 = 25,
		_27 = 26,
		_28 = 27,
	}
	public static InputAxisType GetType(this IInputAxis input)
	{
		return (InputAxisType)input.Type;
	}

	public static InputAxesDirection GetAxis(this IInputAxis input)
	{
		return (InputAxesDirection)input.Axis;
	}

	public static JoystickType GetJoyNum(this IInputAxis input)
	{
		return (JoystickType)input.JoyNum;
	}

	public static void Initialize(this IInputAxis input, string name, string positive, string altPositive)
	{
		input.Name = name;
		input.PositiveButton = positive;
		input.AltPositiveButton = altPositive;
		input.Gravity = 1000.0f;
		input.Dead = 0.001f;
		input.Sensitivity = 1000.0f;
		input.Snap = false;
		input.Invert = false;
		input.Type = (int)InputAxisType.KeyOrMouseButton;
		input.Axis = (int)InputAxesDirection.X;
		input.JoyNum = (int)JoystickType.AllJoysticks;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/KeyframeExtensions.Float.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions.Enums.Keyframe.TangentMode;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Single;

namespace AssetRipper.SourceGenerated.Extensions;

public static partial class KeyframeExtensions
{
	public const float DefaultFloatWeight = (float)(1.0 / 3.0);

	public static void SetValues(this IKeyframe_Single keyframe, UnityVersion version, float time, float value, float weight)
	{
		keyframe.Time = time;
		keyframe.Value = value;
		// this enum member is version agnostic
		keyframe.TangentMode = TangentMode.FreeSmooth.ToTangent(version);
		keyframe.WeightedModeE = WeightedMode.None;
		keyframe.InWeight = weight;
		keyframe.OutWeight = weight;
	}

	public static void SetValues(this IKeyframe_Single keyframe, UnityVersion version, float time, float value, float inSlope, float outSlope, float weight)
	{
		keyframe.Time = time;
		keyframe.Value = value;
		keyframe.InSlope = inSlope;
		keyframe.OutSlope = outSlope;
		// this enum member is version agnostic
		keyframe.TangentMode = TangentMode.FreeFree.ToTangent(version);
		keyframe.WeightedModeE = WeightedMode.None;
		keyframe.InWeight = weight;
		keyframe.OutWeight = weight;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/KeyframeExtensions.Quaternionf.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions.Enums.Keyframe.TangentMode;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Quaternionf;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static partial class KeyframeExtensions
{
	public static void SetValues(this IKeyframe_Quaternionf keyframe, UnityVersion version, float time, Quaternion value, Quaternion weight)
	{
		keyframe.Time = time;
		keyframe.Value.CopyValues(value);
		// this enum member is version agnostic
		keyframe.TangentMode = TangentMode.FreeSmooth.ToTangent(version);
		keyframe.WeightedModeE = WeightedMode.None;
		keyframe.InWeight?.CopyValues(weight);
		keyframe.OutWeight?.CopyValues(weight);
	}

	public static void SetValues(this IKeyframe_Quaternionf keyframe, UnityVersion version, float time, Quaternion value, float weight)
	{
		keyframe.Time = time;
		keyframe.Value.CopyValues(value);
		// this enum member is version agnostic
		keyframe.TangentMode = TangentMode.FreeSmooth.ToTangent(version);
		keyframe.WeightedModeE = WeightedMode.None;
		keyframe.InWeight?.SetValues(weight, weight, weight, weight);
		keyframe.OutWeight?.SetValues(weight, weight, weight, weight);
	}

	public static void SetValues(this IKeyframe_Quaternionf keyframe, UnityVersion version, float time, Quaternion value, float weightX, float weightY, float weightZ, float weightW)
	{
		keyframe.Time = time;
		keyframe.Value.CopyValues(value);
		// this enum member is version agnostic
		keyframe.TangentMode = TangentMode.FreeSmooth.ToTangent(version);
		keyframe.WeightedModeE = WeightedMode.None;
		keyframe.InWeight?.SetValues(weightX, weightY, weightZ, weightW);
		keyframe.OutWeight?.SetValues(weightX, weightY, weightZ, weightW);
	}

	public static void SetValues(this IKeyframe_Quaternionf keyframe, UnityVersion version, float time, Quaternion value, Quaternion inSlope, Quaternion outSlope, Quaternion weight)
	{
		keyframe.Time = time;
		keyframe.Value.CopyValues(value);
		keyframe.InSlope.CopyValues(inSlope);
		keyframe.OutSlope.CopyValues(outSlope);
		// this enum member is version agnostic
		keyframe.TangentMode = TangentMode.FreeFree.ToTangent(version);
		keyframe.WeightedModeE = WeightedMode.None;
		keyframe.InWeight?.CopyValues(weight);
		keyframe.OutWeight?.CopyValues(weight);
	}

	public static void SetValues(this IKeyframe_Quaternionf keyframe, UnityVersion version, float time, Quaternion value, Quaternion inSlope, Quaternion outSlope, float weight)
	{
		keyframe.Time = time;
		keyframe.Value.CopyValues(value);
		keyframe.InSlope.CopyValues(inSlope);
		keyframe.OutSlope.CopyValues(outSlope);
		// this enum member is version agnostic
		keyframe.TangentMode = TangentMode.FreeFree.ToTangent(version);
		keyframe.WeightedModeE = WeightedMode.None;
		keyframe.InWeight?.SetValues(weight, weight, weight, weight);
		keyframe.OutWeight?.SetValues(weight, weight, weight, weight);
	}

	public static void SetValues(this IKeyframe_Quaternionf keyframe, UnityVersion version, float time, Quaternion value, Quaternion inSlope, Quaternion outSlope, float weightX, float weightY, float weightZ, float weightW)
	{
		keyframe.Time = time;
		keyframe.Value.CopyValues(value);
		keyframe.InSlope.CopyValues(inSlope);
		keyframe.OutSlope.CopyValues(outSlope);
		// this enum member is version agnostic
		keyframe.TangentMode = TangentMode.FreeFree.ToTangent(version);
		keyframe.WeightedModeE = WeightedMode.None;
		keyframe.InWeight?.SetValues(weightX, weightY, weightZ, weightW);
		keyframe.OutWeight?.SetValues(weightX, weightY, weightZ, weightW);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/KeyframeExtensions.Vector3f.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions.Enums.Keyframe.TangentMode;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Vector3f;
using AssetRipper.SourceGenerated.Subclasses.Vector3f;

namespace AssetRipper.SourceGenerated.Extensions;

public static partial class KeyframeExtensions
{
	public static void SetValues(this IKeyframe_Vector3f keyframe, UnityVersion version, float time, IVector3f value, IVector3f weight)
	{
		keyframe.Time = time;
		keyframe.Value.CopyValues(value);
		// this enum member is version agnostic
		keyframe.TangentMode = TangentMode.FreeSmooth.ToTangent(version);
		keyframe.WeightedModeE = WeightedMode.None;
		keyframe.InWeight?.CopyValues(weight);
		keyframe.OutWeight?.CopyValues(weight);
	}

	public static void SetValues(this IKeyframe_Vector3f keyframe, UnityVersion version, float time, IVector3f value, IVector3f inSlope, IVector3f outSlope, IVector3f weight)
	{
		keyframe.Time = time;
		keyframe.Value.CopyValues(value);
		keyframe.InSlope.CopyValues(inSlope);
		keyframe.OutSlope.CopyValues(outSlope);
		// this enum member is version agnostic
		keyframe.TangentMode = TangentMode.FreeFree.ToTangent(version);
		keyframe.WeightedModeE = WeightedMode.None;
		keyframe.InWeight?.CopyValues(weight);
		keyframe.OutWeight?.CopyValues(weight);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/LODExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.LOD;

namespace AssetRipper.SourceGenerated.Extensions;

public static class LODExtensions
{
	public static LODFadeMode GetFadeMode(this ILOD lod)
	{
		return (LODFadeMode)lod.FadeMode;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/LODGroupExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_205;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class LODGroupExtensions
{
	public static LODFadeMode GetFadeMode(this ILODGroup group)
	{
		return group.Has_FadeMode()
			? group.FadeModeE
			: group.LODs.FirstOrDefault()?.GetFadeMode() ?? LODFadeMode.None;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/LayerConstantExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.LayerConstant;

namespace AssetRipper.SourceGenerated.Extensions;

public static class LayerConstantExtensions
{
	public static AnimatorLayerBlendingMode GetLayerBlendingMode(this ILayerConstant constant)
	{
		return (AnimatorLayerBlendingMode)constant.LayerBlendingMode;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/LightExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_108;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class LightExtensions
{
	public static LightmappingMode GetLightmapping(this ILight light)
	{
		return (LightmappingMode)light.Lightmapping;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/LightmapBakeModeExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.LightmapBakeMode;

namespace AssetRipper.SourceGenerated.Extensions;

public static class LightmapBakeModeExtensions
{
	public static LightmapBakeType GetLightmapBakeType(this ILightmapBakeMode light)
	{
		return (LightmapBakeType)light.LightmapBakeType;
	}
	public static NativeEnums.Global.MixedLightingMode GetMixedLightingMode(this ILightmapBakeMode light)
	{
		return (NativeEnums.Global.MixedLightingMode)light.MixedLightingMode;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/LightmapEditorSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_850595691;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.LightmapEditorSettings;
using FilterMode = AssetRipper.SourceGenerated.Enums.FilterMode_2;
using Lightmapper = AssetRipper.SourceGenerated.Enums.Lightmapper_0;
using LightmapsMode = AssetRipper.SourceGenerated.Enums.LightmapsMode;
using MixedLightingMode = AssetRipper.SourceGenerated.Enums.MixedLightingMode;

namespace AssetRipper.SourceGenerated.Extensions;

public static class LightmapEditorSettingsExtensions
{
	public static void SetToDefault(this ILightmapEditorSettings settings)
	{
		settings.AO = false;
		settings.AOAmount = 0;
		settings.AOContrast = 1f;
		settings.AOMaxDistance = 1f;
		settings.AtlasSize = 1024;
		settings.BakeBackend = (int)Lightmapper.Enlighten;
		settings.BakeResolution = 40f;
		settings.BounceBoost = 1f;
		settings.BounceIntensity = 1f;
		settings.Bounces = 1;
		settings.CompAOExponent = 1f;
		settings.CompAOExponentDirect = 0f;
		settings.DirectLightInLightProbes = true;
		settings.ExportTrainingData = false;
		settings.ExtractAmbientOcclusion = false;
		settings.FinalGather = false;
		settings.FinalGatherContrastThreshold = 0.05f;
		settings.FinalGatherFiltering = true;
		settings.FinalGatherGradientThreshold = 0f;
		settings.FinalGatherInterpolationPoints = 15;
		settings.FinalGatherRayCount = 256;
		settings.FinalGatherRays = 1000;
		settings.LastUsedResolution = 0f;
		settings.LightmapsBakeMode = (int)LightmapsMode.CombinedDirectional;
		settings.LightProbeSampleCountMultiplier = 4f;
		settings.LockAtlas = false;
		settings.LODSurfaceMappingDistance = 1f;
		settings.MixedBakeMode = (int)MixedLightingMode.Shadowmask;
		settings.Padding = 2;
		settings.PVRBounces = 2;
		settings.PVRCulling = true;
		settings.PVRDenoiserTypeAO = (int)DenoiserType.Optix;
		settings.PVRDenoiserTypeDirect = (int)DenoiserType.Optix;
		settings.PVRDenoiserTypeIndirect = (int)DenoiserType.Optix;
		settings.PVRDirectSampleCount = 32;
		settings.PVREnvironmentMIS = 1;
		settings.PVREnvironmentSampleCount = 256;
		settings.PVREnvironmentReferencePointCount = 2048;
		settings.PVRFiltering = 0;
		settings.PVRFilteringAtrousColorSigma = 1f;
		settings.PVRFilteringAtrousNormalSigma = 1f;
		settings.PVRFilteringAtrousPositionSigma = 1f;
		settings.PVRFilteringAtrousPositionSigmaAO = 1f;
		settings.PVRFilteringAtrousPositionSigmaDirect = 0.5f;
		settings.PVRFilteringAtrousPositionSigmaIndirect = 2f;
		settings.PVRFilteringGaussRadiusAO = 2;
		settings.PVRFilteringGaussRadiusDirect = 1;
		settings.PVRFilteringGaussRadiusIndirect = 5;
		settings.PVRFilteringMode = (int)FilterMode.Auto;
		settings.PVRFilterTypeAO = (int)FilterType.Gaussian;
		settings.PVRFilterTypeDirect = (int)FilterType.Gaussian;
		settings.PVRFilterTypeIndirect = (int)FilterType.Gaussian;
		settings.PVRSampleCount = 500;
		settings.PVRSampling = (int)Sampling.Fixed;
		settings.Quality = 0;
		settings.ReflectionCompression = (int)ReflectionCubemapCompression.Auto;
		settings.Resolution = 2f;
		settings.ShowResolutionOverlay = true;
		settings.SkyLightColor?.SetValues(.86f, .93f, 1f, 1f);
		settings.SkyLightIntensity = 0f;
		settings.StationaryBakeMode = 1;
		settings.TextureCompression = true;
		settings.TextureHeight = 1024;
		settings.TextureWidth = 1024;
		if (settings.Has_TrainingDataDestination())
		{
			settings.TrainingDataDestination = "TrainingData";
		}
	}

	public static void ConvertToEditorFormat(this ILightingSettings settings)
	{
		settings.AO = false;
		settings.AOMaxDistance = 1f;
		settings.BakeBackend = (int)Lightmapper.Enlighten;
		settings.BakeResolution = 40f;
		settings.CompAOExponent = 1f;
		settings.CompAOExponentDirect = 0f;
		settings.DisableWorkerProcessBaking = false;
		settings.ExportTrainingData = false;
		settings.ExtractAO = false;
		settings.FilterMode = (int)FilterMode.Auto;
		settings.FinalGather = false;
		settings.FinalGatherFiltering = true;
		settings.FinalGatherRayCount = 256;
		settings.ForceUpdates = false;
		settings.ForceWhiteAlbedo = false;
		settings.LightmapCompressionE = LightmapCompression.HighQuality;
		settings.LightmapMaxSize = 4096;
		settings.LightmapsBakeMode = (int)LightmapsMode.CombinedDirectional;
		settings.LightmapSizeFixed = false;
		settings.LightProbeSampleCountMultiplier = 4f;
		settings.MixedBakeMode = (int)MixedLightingMode.Shadowmask;
		settings.NumRaysToShootPerTexel = -1;
		settings.Padding = 2;
		settings.PVRBounces = 2;
		settings.PVRCulling = true;
		settings.PVRDenoiserTypeAO = (int)DenoiserType.Optix;
		settings.PVRDenoiserTypeDirect = (int)DenoiserType.Optix;
		settings.PVRDenoiserTypeIndirect = (int)DenoiserType.Optix;
		settings.PVRDirectSampleCount = 32;
		settings.PVREnvironmentImportanceSampling = true;
		settings.PVREnvironmentMIS = 1;
		settings.PVREnvironmentReferencePointCount = 2048;
		settings.PVREnvironmentSampleCount = 256;
		settings.PVRFilteringAtrousPositionSigmaAO = 1f;
		settings.PVRFilteringAtrousPositionSigmaDirect = 0.5f;
		settings.PVRFilteringAtrousPositionSigmaIndirect = 2f;
		settings.PVRFilteringGaussRadiusAO_Int32 = 2;
		settings.PVRFilteringGaussRadiusAO_Single = 2f;
		settings.PVRFilteringGaussRadiusDirect_Int32 = 1;
		settings.PVRFilteringGaussRadiusDirect_Single = 1f;
		settings.PVRFilteringGaussRadiusIndirect_Int32 = 5;
		settings.PVRFilteringGaussRadiusIndirect_Single = 5f;
		settings.PVRFilteringMode = (int)FilterMode.Auto;
		settings.PVRFilterTypeAO = (int)FilterType.Gaussian;
		settings.PVRFilterTypeDirect = (int)FilterType.Gaussian;
		settings.PVRFilterTypeIndirect = (int)FilterType.Gaussian;
		settings.PVRMinBounces = 2;
		settings.PVRRussianRouletteStartBounce = 2;
		settings.PVRSampleCount = 500;
		settings.PVRSampling = (int)Sampling.Fixed;
		settings.PVRTiledBaking = 0;
		settings.RealtimeResolution = 2f;
		settings.RespectSceneVisibilityWhenBakingGI = false;
		settings.TextureCompression = true;
		settings.TrainingDataDestination = "TrainingData";
		settings.UseMipmapLimits = true;
	}

	public static LightmapsMode GetLightmapsBakeMode(this ILightmapEditorSettings settings)
	{
		return (LightmapsMode)settings.LightmapsBakeMode;
	}

	public static ReflectionCubemapCompression GetReflectionCompression(this ILightmapEditorSettings settings)
	{
		return (ReflectionCubemapCompression)settings.ReflectionCompression;
	}

	public static MixedLightingMode GetMixedBakeMode(this ILightmapEditorSettings settings)
	{
		if (settings.Has_MixedBakeMode())
		{
			return (MixedLightingMode)settings.MixedBakeMode;
		}
		else
		{
			return (MixedLightingMode)settings.StationaryBakeMode;//need to rename
		}
	}

	public static Lightmapper GetBakeBackend(this ILightmapEditorSettings settings)
	{
		return (Lightmapper)settings.BakeBackend;
	}

	public static Sampling GetPVRSampling(this ILightmapEditorSettings settings)
	{
		return (Sampling)settings.PVRSampling;
	}

	public static FilterMode GetPVRFilteringMode(this ILightmapEditorSettings settings)
	{
		return (FilterMode)settings.PVRFilteringMode;
	}

	public static DenoiserType GetPVRDenoiserTypeDirect(this ILightmapEditorSettings settings)
	{
		return (DenoiserType)settings.PVRDenoiserTypeDirect;
	}

	public static DenoiserType GetPVRDenoiserTypeIndirect(this ILightmapEditorSettings settings)
	{
		return (DenoiserType)settings.PVRDenoiserTypeIndirect;
	}

	public static DenoiserType GetPVRDenoiserTypeAO(this ILightmapEditorSettings settings)
	{
		return (DenoiserType)settings.PVRDenoiserTypeAO;
	}

	public static FilterType GetPVRFilterTypeDirect(this ILightmapEditorSettings settings)
	{
		return (FilterType)settings.PVRFilterTypeDirect;
	}

	public static FilterType GetPVRFilterTypeIndirect(this ILightmapEditorSettings settings)
	{
		return (FilterType)settings.PVRFilterTypeIndirect;
	}

	public static FilterType GetPVRFilterTypeAO(this ILightmapEditorSettings settings)
	{
		return (FilterType)settings.PVRFilterTypeAO;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/LightmapSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_157;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class LightmapSettingsExtensions
{
	public static void ConvertToEditorFormat(this ILightmapSettings settings)
	{
		settings.LightmapEditorSettings.SetToDefault();
		if (settings.LightingSettingsP is { } lightingSettings)
		{
			settings.GIWorkflowMode = lightingSettings.GIWorkflowMode;
		}
		else
		{
			settings.GIWorkflowMode = (int)GIWorkflowMode.OnDemand;
		}
	}

	public static GIWorkflowMode GetGIWorkflowMode(this ILightmapSettings settings)
	{
		return (GIWorkflowMode)settings.GIWorkflowMode;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/LightsModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.LightsModule;

namespace AssetRipper.SourceGenerated.Extensions;

public static class LightsModuleExtensions
{
	public static void SetToDefault(this ILightsModule module, UnityVersion version)
	{
		module.RandomDistribution = true;
		module.Color = true;
		module.Range = true;
		module.Intensity = true;
		module.RangeCurve.SetValues(version, 1.0f);
		module.IntensityCurve.SetValues(version, 1.0f);
		module.MaxLights = 20;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/LineParametersExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.LineParameters;

namespace AssetRipper.SourceGenerated.Extensions;

public static class LineParametersExtensions
{
	public static void Initialize(this ILineParameters lineParameters, UnityVersion version)
	{
		lineParameters.WidthMultiplier = 1.0f;
		if (lineParameters.Has_WidthCurve())
		{
			lineParameters.WidthCurve.SetDefaultRotationOrderAndCurveLoopType();
			lineParameters.WidthCurve.Curve.AddNew().SetValues(version, 0.0f, 1.0f, KeyframeExtensions.DefaultFloatWeight);
		}
		else
		{
			lineParameters.StartWidth = 1f;
			lineParameters.EndWidth = 1f;
			//Just guessing. I did not verify these values anywhere.
		}
		if (lineParameters.Has_ColorGradient())
		{
			lineParameters.ColorGradient.Ctime0 = 0;
			lineParameters.ColorGradient.Atime0 = 0;
			lineParameters.ColorGradient.Ctime1 = ushort.MaxValue;
			lineParameters.ColorGradient.Atime1 = ushort.MaxValue;
			lineParameters.ColorGradient.NumColorKeys = 2;
			lineParameters.ColorGradient.NumAlphaKeys = 2;
			if (lineParameters.ColorGradient.Has_Key0_ColorRGBA32())
			{
				lineParameters.ColorGradient.Key0_ColorRGBA32.SetAsWhite();
				lineParameters.ColorGradient.Key1_ColorRGBA32.SetAsWhite();
			}
			else
			{
				lineParameters.ColorGradient.Key0_ColorRGBAf.SetAsWhite();
				lineParameters.ColorGradient.Key1_ColorRGBAf.SetAsWhite();
			}
		}
		else if (lineParameters.Has_EndColor() && lineParameters.Has_StartColor())
		{
			lineParameters.StartColor.SetAsWhite();
			lineParameters.EndColor.SetAsWhite();
		}
		lineParameters.NumCornerVertices = 0;
		lineParameters.NumCapVertices = 0;
		lineParameters.Alignment = (int)LineAlignment.View;
		lineParameters.TextureMode = (int)LineTextureMode.Stretch;
		lineParameters.ShadowBias = 0.5f;
		lineParameters.GenerateLightingData = false;
	}

	public static LineAlignment GetAlignment(this ILineParameters parameters)
	{
		return (LineAlignment)parameters.Alignment;
	}

	public static LineTextureMode GetTextureMode(this ILineParameters parameters)
	{
		return (LineTextureMode)parameters.TextureMode;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MaterialExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Subclasses.FastPropertyName;
using AssetRipper.SourceGenerated.Subclasses.UnityPropertySheet;
using AssetRipper.SourceGenerated.Subclasses.UnityTexEnv;

namespace AssetRipper.SourceGenerated.Extensions;

public static class MaterialExtensions
{
	public static string? FindPropertyNameByCRC28(this IMaterial material, uint crc)
	{
		return material.SavedProperties_C21.FindPropertyNameByCRC28(crc);
	}

	public static bool TryGetTextureProperty(this IMaterial material, string propertyName, [NotNullWhen(true)] out IUnityTexEnv? property)
	{
		IUnityPropertySheet savedProperties = material.SavedProperties_C21;
		if (savedProperties.Has_TexEnvs_AssetDictionary_Utf8String_UnityTexEnv_5())
		{
			savedProperties.TexEnvs_AssetDictionary_Utf8String_UnityTexEnv_5.TryGetValue((Utf8String)propertyName, out UnityTexEnv_5? texEnv);
			property = texEnv;
		}
		else if (savedProperties.Has_TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_5())
		{
			savedProperties.TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_5.TryGetValue(new() { Name = propertyName }, out UnityTexEnv_5? texEnv);
			property = texEnv;
		}
		else if (savedProperties.Has_TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_3_5())
		{
			savedProperties.TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_3_5.TryGetValue(new() { Name = propertyName }, out UnityTexEnv_3_5? texEnv);
			property = texEnv;
		}
		else
		{
			property = null;
		}
		return property is not null;
	}

	public static IEnumerable<KeyValuePair<Utf8String, IUnityTexEnv>> GetTextureProperties(this IMaterial material)
	{
		IUnityPropertySheet savedProperties = material.SavedProperties_C21;
		if (savedProperties.Has_TexEnvs_AssetDictionary_Utf8String_UnityTexEnv_5())
		{
			return savedProperties
				.TexEnvs_AssetDictionary_Utf8String_UnityTexEnv_5
				.Select((AccessPairBase<Utf8String, UnityTexEnv_5> pair) => new KeyValuePair<Utf8String, IUnityTexEnv>(pair.Key, pair.Value));
		}
		else if (savedProperties.Has_TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_5())
		{
			return savedProperties
				.TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_5
				.Select((AccessPairBase<FastPropertyName, UnityTexEnv_5> pair) => new KeyValuePair<Utf8String, IUnityTexEnv>(pair.Key.Name, pair.Value));
		}
		else if (savedProperties.Has_TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_3_5())
		{
			return savedProperties
				.TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_3_5
				.Select((AccessPairBase<FastPropertyName, UnityTexEnv_3_5> pair) => new KeyValuePair<Utf8String, IUnityTexEnv>(pair.Key.Name, pair.Value));
		}
		else
		{
			return Enumerable.Empty<KeyValuePair<Utf8String, IUnityTexEnv>>();
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Matrix4x4fExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.Matrix4x4f;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class Matrix4x4fExtensions
{
	extension(Matrix4x4f matrix)
	{
		// Note: Matrix4x4f and Matrix4x4 are not the same! Their memory layouts are different.
		// They need to be transposed because M14 maps to m30 in the field layouts. The necessity of transposition can be verified with vector math.

		public void CopyValues(Matrix4x4 source)
		{
			matrix.SetValues(
				source.M11,
				source.M21,
				source.M31,
				source.M41,
				source.M12,
				source.M22,
				source.M32,
				source.M42,
				source.M13,
				source.M23,
				source.M33,
				source.M43,
				source.M14,
				source.M24,
				source.M34,
				source.M44);
		}

		public Matrix4x4 CastToStruct()
		{
			return new Matrix4x4(
				matrix.E00,
				matrix.E10,
				matrix.E20,
				matrix.E30,
				matrix.E01,
				matrix.E11,
				matrix.E21,
				matrix.E31,
				matrix.E02,
				matrix.E12,
				matrix.E22,
				matrix.E32,
				matrix.E03,
				matrix.E13,
				matrix.E23,
				matrix.E33);
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MatrixParameterExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader;
using AssetRipper.SourceGenerated.Subclasses.MatrixParameter;

namespace AssetRipper.SourceGenerated.Extensions;

public static class MatrixParameterExtensions
{
	public static void SetValues(this IMatrixParameter parameter, string name, ShaderParamType type, int index, int rowCount, int columnCount)
	{
		//parameter.Name = name;//Name doesn't exist
		parameter.NameIndex = -1;
		parameter.Index = index;
		parameter.ArraySize = 0;
		parameter.Type = (sbyte)type;
		parameter.RowCount = (sbyte)rowCount;
		//parameter.ColumnCount = (sbyte)columnCount;//doesn't exist; default value is 4
	}

	public static ShaderParamType GetType_(this IMatrixParameter parameter)
	{
		return (ShaderParamType)parameter.Type;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MeshBlendShapeChannelExtensions.cs`:

```cs
using AssetRipper.Checksum;
using AssetRipper.SourceGenerated.Subclasses.MeshBlendShapeChannel;

namespace AssetRipper.SourceGenerated.Extensions;

public static class MeshBlendShapeChannelExtensions
{
	public static void SetValues(this IMeshBlendShapeChannel channel, string name, int frameIndex, int frameCount)
	{
		channel.Name = name;
		channel.NameHash = Crc32Algorithm.HashUTF8(name);
		channel.FrameIndex = frameIndex;
		channel.FrameCount = frameCount;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MeshBlendShapeExtensions.cs`:

```cs
using AssetRipper.Checksum;
using AssetRipper.SourceGenerated.Subclasses.MeshBlendShape;

namespace AssetRipper.SourceGenerated.Extensions;

public static class MeshBlendShapeExtensions
{
	public static bool IsCRCMatch(this IMeshBlendShape blendShape, uint crc)
	{
		return blendShape.Name_R is not null && Crc32Algorithm.MatchUTF8(blendShape.Name_R.String, crc);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MeshColliderExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_64;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class MeshColliderExtensions
{
	public static MeshColliderCookingOptions GetCookingOptions(this IMeshCollider collider)
	{
		if (collider.Has_CookingOptions())
		{
			return (MeshColliderCookingOptions)collider.CookingOptions;
		}
		else
		{
			MeshColliderCookingOptions options =
				MeshColliderCookingOptions.CookForFasterSimulation |
				MeshColliderCookingOptions.EnableMeshCleaning |
				MeshColliderCookingOptions.WeldColocatedVertices;

			if (collider.InflateMesh)
			{
				options |= MeshColliderCookingOptions.InflateConvexMesh;
			}
			return options;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MeshData.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Enums;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace AssetRipper.SourceGenerated.Extensions;

public readonly record struct MeshData(
	Vector3[] Vertices,
	Vector3[]? Normals,
	Vector4[]? Tangents,
	ColorFloat[]? Colors,
	Vector2[]? UV0,
	Vector2[]? UV1,
	Vector2[]? UV2,
	Vector2[]? UV3,
	Vector2[]? UV4,
	Vector2[]? UV5,
	Vector2[]? UV6,
	Vector2[]? UV7,
	BoneWeight4[]? Skin,
	Matrix4x4[]? BindPose,
	uint[] ProcessedIndexBuffer,
	SubMeshData[] SubMeshes)
{
	public static MeshData Empty => new([], null, null, null, null, null, null, null, null, null, null, null, null, [], [], []);

	[MemberNotNullWhen(true, nameof(Normals))]
	public bool HasNormals => Normals != null && Normals.Length == Vertices.Length;

	[MemberNotNullWhen(true, nameof(Tangents))]
	public bool HasTangents => Tangents != null && Tangents.Length == Vertices.Length;

	[MemberNotNullWhen(true, nameof(Colors))]
	public bool HasColors => Colors != null && Colors.Length == Vertices.Length;

	[MemberNotNullWhen(true, nameof(UV0))]
	public bool HasUV0 => UV0 != null && UV0.Length == Vertices.Length;

	[MemberNotNullWhen(true, nameof(UV1))]
	public bool HasUV1 => UV1 != null && UV1.Length == Vertices.Length;

	[MemberNotNullWhen(true, nameof(UV2))]
	public bool HasUV2 => UV2 != null && UV2.Length == Vertices.Length;

	[MemberNotNullWhen(true, nameof(UV3))]
	public bool HasUV3 => UV3 != null && UV3.Length == Vertices.Length;

	[MemberNotNullWhen(true, nameof(UV4))]
	public bool HasUV4 => UV4 != null && UV4.Length == Vertices.Length;

	[MemberNotNullWhen(true, nameof(UV5))]
	public bool HasUV5 => UV5 != null && UV5.Length == Vertices.Length;

	[MemberNotNullWhen(true, nameof(UV6))]
	public bool HasUV6 => UV6 != null && UV6.Length == Vertices.Length;

	[MemberNotNullWhen(true, nameof(UV7))]
	public bool HasUV7 => UV7 != null && UV7.Length == Vertices.Length;

	[MemberNotNullWhen(true, nameof(Skin))]
	public bool HasSkin => Skin != null && Skin.Length == Vertices.Length;

	public int UVCount
	{
		get
		{
			if (UV0 is null || UV0.Length != Vertices.Length)
			{
				return 0;
			}
			else if (UV1 is null || UV1.Length != Vertices.Length)
			{
				return 1;
			}
			else if (UV2 is null || UV2.Length != Vertices.Length)
			{
				return 2;
			}
			else if (UV3 is null || UV3.Length != Vertices.Length)
			{
				return 3;
			}
			else if (UV4 is null || UV4.Length != Vertices.Length)
			{
				return 4;
			}
			else if (UV5 is null || UV5.Length != Vertices.Length)
			{
				return 5;
			}
			else if (UV6 is null || UV6.Length != Vertices.Length)
			{
				return 6;
			}
			else if (UV7 is null || UV7.Length != Vertices.Length)
			{
				return 7;
			}
			else
			{
				return 8;
			}
		}
	}

	public IndexFormat IndexFormat => Vertices.Length > ushort.MaxValue ? IndexFormat.UInt32 : IndexFormat.UInt16;

	public Vector3 TryGetVertexAtIndex(uint index) => Vertices[index];
	public Vector3 TryGetNormalAtIndex(uint index) => TryGetAtIndex(Normals, index);
	public Vector4 TryGetTangentAtIndex(uint index)
	{
		Vector4 v = TryGetAtIndex(Tangents, index);
		//Unity documentation claims W should always be 1 or -1, but it's not always the case.
		return v.W switch
		{
			-1 or 1 => v,
			< 0 => new Vector4(v.X, v.Y, v.Z, -1),
			_ => new Vector4(v.X, v.Y, v.Z, 1)
		};
	}
	public ColorFloat TryGetColorAtIndex(uint index) => TryGetAtIndex(Colors, index);
	public Vector2 TryGetUV0AtIndex(uint index) => FlipY(TryGetAtIndex(UV0, index));
	public Vector2 TryGetUV1AtIndex(uint index) => FlipY(TryGetAtIndex(UV1, index));
	public Vector2 TryGetUV2AtIndex(uint index) => FlipY(TryGetAtIndex(UV2, index));
	public Vector2 TryGetUV3AtIndex(uint index) => FlipY(TryGetAtIndex(UV3, index));
	public Vector2 TryGetUV4AtIndex(uint index) => FlipY(TryGetAtIndex(UV4, index));
	public Vector2 TryGetUV5AtIndex(uint index) => FlipY(TryGetAtIndex(UV5, index));
	public Vector2 TryGetUV6AtIndex(uint index) => FlipY(TryGetAtIndex(UV6, index));
	public Vector2 TryGetUV7AtIndex(uint index) => FlipY(TryGetAtIndex(UV7, index));
	public BoneWeight4 TryGetSkinAtIndex(uint index)
	{
		BoneWeight4 s = TryGetAtIndex(Skin, index);
		if (s == default || s.AnyWeightsNegative)
		{
			//Invalid bone weights, set to a valid default.
			return new BoneWeight4(.25f, .25f, .25f, .25f, 0, 0, 0, 0);
		}
		else if (s.Sum != 1)
		{
			return s.NormalizeWeights();
		}
		else
		{
			return s;
		}
	}

	private static Vector2 FlipY(Vector2 uv) => new Vector2(uv.X, 1 - uv.Y);

	public static bool TryMakeFromMesh(IMesh mesh, out MeshData meshData)
	{
		mesh.ReadData(
			out Vector3[]? vertices,
			out Vector3[]? normals,
			out Vector4[]? tangents,
			out ColorFloat[]? colors,
			out Vector2[]? uv0,
			out Vector2[]? uv1,
			out Vector2[]? uv2,
			out Vector2[]? uv3,
			out Vector2[]? uv4,
			out Vector2[]? uv5,
			out Vector2[]? uv6,
			out Vector2[]? uv7,
			out BoneWeight4[]? skin,
			out Matrix4x4[]? bindpose,
			out uint[] processedIndexBuffer);

		SubMeshData[] subMeshes = SubMeshData.Create(mesh);

		if (vertices is null)
		{
			meshData = default;
			return false;
		}
		else
		{
			meshData = new MeshData(vertices, normals, tangents, colors, uv0, uv1, uv2, uv3, uv4, uv5, uv6, uv7, skin, bindpose, processedIndexBuffer, subMeshes);
			return true;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
	private static T TryGetAtIndex<T>(T[]? array, uint index) where T : struct
	{
		return array is null or { Length: 0 } ? default : array[index];
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MeshExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.IO.Endian;
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.CompressedMesh;
using AssetRipper.SourceGenerated.Subclasses.MeshBlendShape;
using AssetRipper.SourceGenerated.Subclasses.SubMesh;
using System.Buffers;
using System.Buffers.Binary;
using System.Numerics;
using System.Text.RegularExpressions;

namespace AssetRipper.SourceGenerated.Extensions;

public static partial class MeshExtensions
{
	[GeneratedRegex("^Combined Mesh \\(root scene\\)( [0-9]+)?$", RegexOptions.Compiled)]
	private static partial Regex CombinedMeshRegex();

	extension(IMesh mesh)
	{
		public bool IsCombinedMesh() => CombinedMeshRegex().IsMatch(mesh.Name);

		public bool IsSet()
		{
			return mesh.CompressedMesh.IsSet || mesh.VertexData.IsSet(mesh.StreamData);
		}

		public bool CheckAssetIntegrity()
		{
			if (mesh.Has_StreamData() && mesh.VertexData.IsSet(mesh.StreamData))
			{
				return mesh.StreamData.CheckIntegrity(mesh.Collection);
			}
			return true;
		}

		public bool HasAnyVertices()
		{
			return mesh.CompressedMesh.Vertices.NumItems > 0 || mesh.VertexData.VertexCount > 0;
		}

		public void ReadData(
			out Vector3[]? vertices,
			out Vector3[]? normals,
			out Vector4[]? tangents,
			out ColorFloat[]? colors,
			out Vector2[]? uv0,
			out Vector2[]? uv1,
			out Vector2[]? uv2,
			out Vector2[]? uv3,
			out Vector2[]? uv4,
			out Vector2[]? uv5,
			out Vector2[]? uv6,
			out Vector2[]? uv7,
			out BoneWeight4[]? skin,
			out Matrix4x4[]? bindPose,
			out uint[] processedIndexBuffer)
		{
			vertices = default;
			normals = default;
			tangents = default;
			colors = default;
			skin = default;
			uv0 = default;
			uv1 = default;
			uv2 = default;
			uv3 = default;
			uv4 = default;
			uv5 = default;
			uv6 = default;
			uv7 = default;

			VertexDataBlob.Create(mesh).ReadData(
				out vertices,
				out normals,
				out tangents,
				out colors,
				out uv0,
				out uv1,
				out uv2,
				out uv3,
				out uv4,
				out uv5,
				out uv6,
				out uv7,
				out skin);

			mesh.CompressedMesh.Decompress(out Vector3[]? compressed_vertices,
				out Vector3[]? compressed_normals,
				out Vector4[]? compressed_tangents,
				out ColorFloat[]? compressed_colors,
				out Vector2[]? compressed_uv0,
				out Vector2[]? compressed_uv1,
				out Vector2[]? compressed_uv2,
				out Vector2[]? compressed_uv3,
				out Vector2[]? compressed_uv4,
				out Vector2[]? compressed_uv5,
				out Vector2[]? compressed_uv6,
				out Vector2[]? compressed_uv7,
				out BoneWeight4[]? compressed_skin,
				out Matrix4x4[]? compressed_bindPose,
				out uint[]? compressed_processedIndexBuffer);

			vertices ??= compressed_vertices;
			normals ??= compressed_normals;
			tangents ??= compressed_tangents;
			colors ??= compressed_colors;
			skin ??= compressed_skin ?? mesh.Skin?.Select(b => b.ToCommonClass()).ToArray();
			uv0 ??= compressed_uv0;
			uv1 ??= compressed_uv1;
			uv2 ??= compressed_uv2;
			uv3 ??= compressed_uv3;
			uv4 ??= compressed_uv4;
			uv5 ??= compressed_uv5;
			uv6 ??= compressed_uv6;
			uv7 ??= compressed_uv7;
			bindPose = compressed_bindPose ?? mesh.BindPose.Select(Matrix4x4fExtensions.CastToStruct).ToArray();
			processedIndexBuffer = compressed_processedIndexBuffer ?? mesh.GetProcessedIndexBuffer();
		}

		/// <summary>
		/// Fill with compressed mesh data
		/// </summary>
		/// <remarks>
		/// This method assumes the mesh does not already contain data.
		/// </remarks>
		/// <param name="meshData"></param>
		public void FillWithCompressedMeshData(MeshData meshData)
		{
			mesh.SetIndexFormat(meshData.IndexFormat);

			ICompressedMesh compressedMesh = mesh.CompressedMesh;
			compressedMesh.SetVertices(meshData.Vertices);
			compressedMesh.SetNormals(meshData.Normals);
			compressedMesh.SetTangents(meshData.Tangents);
			compressedMesh.SetFloatColors(meshData.Colors);
			compressedMesh.SetWeights(meshData.Skin);
			compressedMesh.SetUV(
				meshData.UV0,
				meshData.UV1,
				meshData.UV2,
				meshData.UV3,
				meshData.UV4,
				meshData.UV5,
				meshData.UV6,
				meshData.UV7);
			if (compressedMesh.Has_BindPoses())
			{
				compressedMesh.SetBindPoses(meshData.BindPose);
			}
			else if (meshData.BindPose is not null)
			{
				foreach (Matrix4x4 matrix in meshData.BindPose)
				{
					mesh.BindPose.AddNew().CopyValues(matrix);
				}
			}
			compressedMesh.SetTriangles(meshData.ProcessedIndexBuffer);

			mesh.KeepIndices = true;//Not sure about this. Seems to be for animated meshes
			mesh.KeepVertices = true;//Not sure about this. Seems to be for animated meshes
			mesh.MeshMetrics_0_ = CalculateMeshMetric(meshData.Vertices, meshData.UV0, meshData.ProcessedIndexBuffer, meshData.SubMeshes, 0);
			mesh.MeshMetrics_1_ = CalculateMeshMetric(meshData.Vertices, meshData.UV1, meshData.ProcessedIndexBuffer, meshData.SubMeshes, 1);
			mesh.MeshUsageFlags = (int)SourceGenerated.NativeEnums.Global.MeshUsageFlags.MeshUsageFlagNone;
			mesh.CookingOptions = (int)SourceGenerated.NativeEnums.Global.MeshColliderCookingOptions.DefaultCookingFlags;
			//I copied 30 from a vanilla compressed mesh (with MeshCompression.Low), and it aligned with this enum.
			mesh.SetMeshOptimizationFlags(MeshOptimizationFlags.Everything);
			mesh.SetMeshCompression(ModelImporterMeshCompression.Low);

			AccessListBase<ISubMesh> subMeshList = mesh.SubMeshes;
			foreach (SubMeshData subMesh in meshData.SubMeshes)
			{
				subMesh.CopyTo(subMeshList.AddNew(), mesh.GetIndexFormat());
			}

			mesh.LocalAABB.CalculateFromVertexArray(meshData.Vertices);
		}

		public byte[] GetChannelsData()
		{
			if (mesh.Has_StreamData() && mesh.StreamData.IsSet())
			{
				return mesh.StreamData.GetContent(mesh.Collection);
			}
			else
			{
				return mesh.VertexData.Data;
			}
		}

		public string? FindBlendShapeNameByCRC(uint crc)
		{
			if (mesh.Has_Shapes())
			{
				return mesh.Shapes.FindShapeNameByCRC(crc);
			}
			else if (mesh.Has_ShapesList())
			{
				foreach (MeshBlendShape_4_1 blendShape in mesh.ShapesList)
				{
					if (blendShape.IsCRCMatch(crc))
					{
						return blendShape.Name.String;
					}
				}
			}
			return null;
		}

		public bool Is16BitIndices()
		{
			return mesh.GetIndexFormat() == IndexFormat.UInt16;
		}

		public IndexFormat GetIndexFormat()
		{
			if (mesh.Has_IndexFormat())
			{
				return mesh.IndexFormatE;
			}
			else
			{
				return IndexFormat.UInt16;//Versions between 3.5 and 2017.3 used 16 bit exclusively
			}
		}

		public void SetIndexFormat(IndexFormat indexFormat)
		{
			if (mesh.Has_IndexFormat())
			{
				mesh.IndexFormatE = indexFormat;
			}
			else if (indexFormat != IndexFormat.UInt16)
			{
				//Versions between 3.5 and 2017.3 used 16 bit exclusively
				throw new NotSupportedException($"Only 16 bit vertex indices are supported on {mesh.Collection.Version}.");
			}
		}

		public MeshOptimizationFlags GetMeshOptimizationFlags()
		{
			if (mesh.Has_MeshOptimizationFlags())
			{
				return (MeshOptimizationFlags)mesh.MeshOptimizationFlags;
			}
			else if (mesh.Has_MeshOptimized())
			{
				return mesh.MeshOptimized ? MeshOptimizationFlags.Everything : MeshOptimizationFlags.PolygonOrder;
			}
			else
			{
				return default;
			}
		}

		public void SetMeshOptimizationFlags(MeshOptimizationFlags value)
		{
			if (mesh.Has_MeshOptimizationFlags())
			{
				mesh.MeshOptimizationFlags = (int)value;
			}
			else if (mesh.Has_MeshOptimized())
			{
				mesh.MeshOptimized = value == MeshOptimizationFlags.Everything;
			}
		}

		public ModelImporterMeshCompression GetMeshCompression()
		{
			return (ModelImporterMeshCompression)mesh.MeshCompression;
		}

		public void SetMeshCompression(ModelImporterMeshCompression meshCompression)
		{
			mesh.MeshCompression = (byte)meshCompression;
		}

		public byte[] GetVertexDataBytes()
		{
			return mesh.VertexData.Data.Length switch
			{
				0 => mesh.StreamData?.GetContent(mesh.Collection) ?? [],
				_ => mesh.VertexData.Data,
			};
		}

		public uint[] GetProcessedIndexBuffer()
		{
			uint[] result;
			if (mesh.Is16BitIndices())
			{
				int indexCount = mesh.IndexBuffer.Length / sizeof(ushort);
				ushort[] rentedBuffer = ArrayPool<ushort>.Shared.Rent(indexCount);
				if (!BitConverter.IsLittleEndian && mesh.Collection.EndianType == EndianType.LittleEndian)
				{
					ReadOnlySpan<byte> indexBuffer = mesh.IndexBuffer;
					for (int i = 0; i < indexCount; i++)
					{
						rentedBuffer[i] = BinaryPrimitives.ReadUInt16LittleEndian(indexBuffer.Slice(i * sizeof(ushort)));
					}
				}
				else if (BitConverter.IsLittleEndian && mesh.Collection.EndianType == EndianType.BigEndian)
				{
					ReadOnlySpan<byte> indexBuffer = mesh.IndexBuffer;
					for (int i = 0; i < indexCount; i++)
					{
						rentedBuffer[i] = BinaryPrimitives.ReadUInt16BigEndian(indexBuffer.Slice(i * sizeof(ushort)));
					}
				}
				else
				{
					Buffer.BlockCopy(mesh.IndexBuffer, 0, rentedBuffer, 0, mesh.IndexBuffer.Length);
				}
				result = new uint[indexCount];
				UShortToUInt(rentedBuffer, result, indexCount);
				ArrayPool<ushort>.Shared.Return(rentedBuffer);
			}
			else
			{
				int indexCount = mesh.IndexBuffer.Length / sizeof(uint);
				result = new uint[indexCount];
				if (!BitConverter.IsLittleEndian && mesh.Collection.EndianType == EndianType.LittleEndian)
				{
					ReadOnlySpan<byte> indexBuffer = mesh.IndexBuffer;
					for (int i = 0; i < indexCount; i++)
					{
						result[i] = BinaryPrimitives.ReadUInt32LittleEndian(indexBuffer.Slice(i * sizeof(uint)));
					}
				}
				else if (BitConverter.IsLittleEndian && mesh.Collection.EndianType == EndianType.BigEndian)
				{
					ReadOnlySpan<byte> indexBuffer = mesh.IndexBuffer;
					for (int i = 0; i < indexCount; i++)
					{
						result[i] = BinaryPrimitives.ReadUInt32BigEndian(indexBuffer.Slice(i * sizeof(uint)));
					}
				}
				else
				{
					Buffer.BlockCopy(mesh.IndexBuffer, 0, result, 0, mesh.IndexBuffer.Length);
				}
			}
			return result;
		}

		public void SetProcessedIndexBuffer(uint[] indices)
		{
			if (mesh.Is16BitIndices())
			{
				mesh.IndexBuffer = new byte[indices.Length * sizeof(ushort)];
				ushort[] rentedBuffer = ArrayPool<ushort>.Shared.Rent(indices.Length);
				UIntToUShort(indices, rentedBuffer, indices.Length);

				if (!BitConverter.IsLittleEndian && mesh.Collection.EndianType == EndianType.LittleEndian)
				{
					Span<byte> indexBuffer = mesh.IndexBuffer;
					for (int i = 0; i < indices.Length; i++)
					{
						BinaryPrimitives.WriteUInt16LittleEndian(indexBuffer.Slice(i * sizeof(ushort)), (ushort)indices[i]);
					}
				}
				else if (BitConverter.IsLittleEndian && mesh.Collection.EndianType == EndianType.BigEndian)
				{
					Span<byte> indexBuffer = mesh.IndexBuffer;
					for (int i = 0; i < indices.Length; i++)
					{
						BinaryPrimitives.WriteUInt16BigEndian(indexBuffer.Slice(i * sizeof(ushort)), (ushort)indices[i]);
					}
				}
				else
				{
					Buffer.BlockCopy(rentedBuffer, 0, mesh.IndexBuffer, 0, mesh.IndexBuffer.Length);
				}

				ArrayPool<ushort>.Shared.Return(rentedBuffer);
			}
			else
			{
				mesh.IndexBuffer = new byte[indices.Length * sizeof(uint)];

				if (!BitConverter.IsLittleEndian && mesh.Collection.EndianType == EndianType.LittleEndian)
				{
					Span<byte> indexBuffer = mesh.IndexBuffer;
					for (int i = 0; i < indices.Length; i++)
					{
						BinaryPrimitives.WriteUInt32LittleEndian(indexBuffer.Slice(i * sizeof(uint)), indices[i]);
					}
				}
				else if (BitConverter.IsLittleEndian && mesh.Collection.EndianType == EndianType.BigEndian)
				{
					Span<byte> indexBuffer = mesh.IndexBuffer;
					for (int i = 0; i < indices.Length; i++)
					{
						BinaryPrimitives.WriteUInt32BigEndian(indexBuffer.Slice(i * sizeof(uint)), indices[i]);
					}
				}
				else
				{
					Buffer.BlockCopy(indices, 0, mesh.IndexBuffer, 0, mesh.IndexBuffer.Length);
				}
			}
		}
	}

	private static float CalculateMeshMetric(ReadOnlySpan<Vector3> vertexBuffer, ReadOnlySpan<Vector2> uvBuffer, uint[] indexBuffer, SubMeshData[] subMeshList, int uvSetIndex, float uvAreaThreshold = 1e-9f)
	{
		//https://docs.unity3d.com/ScriptReference/Mesh.GetUVDistributionMetric.html
		//https://docs.unity3d.com/ScriptReference/Mesh.RecalculateUVDistributionMetric.html
		//https://docs.unity3d.com/ScriptReference/Mesh.RecalculateUVDistributionMetrics.html

		const float DefaultMetric = 1.0f;
		if (vertexBuffer.Length == 0 || uvBuffer.Length == 0 || uvSetIndex >= subMeshList.Length)
		{
			return DefaultMetric;
		}

		int n = 0;
		float vertexAreaSum = 0.0f;
		float uvAreaSum = 0.0f;
		foreach ((uint ia, uint ib, uint ic) in new TriangleEnumerable(subMeshList[uvSetIndex], indexBuffer))
		{
			(Vector2 uva, Vector2 uvb, Vector2 uvc) = (uvBuffer[(int)ia], uvBuffer[(int)ib], uvBuffer[(int)ic]);
			float uvArea = TriangleArea(uva, uvb, uvc);
			if (uvArea < uvAreaThreshold)
			{
				continue;
			}

			(Vector3 va, Vector3 vb, Vector3 vc) = (vertexBuffer[(int)ia], vertexBuffer[(int)ib], vertexBuffer[(int)ic]);
			float vertexArea = TriangleArea(va, vb, vc);
			vertexAreaSum += vertexArea;
			uvAreaSum += uvArea;
			n++;
		}

		if (n is 0 || uvAreaSum == 0.0f)
		{
			return DefaultMetric;
		}
		else
		{
			//Average of triangle area divided by uv area.
			return vertexAreaSum / n / uvAreaSum;
		}
	}

	private static float TriangleArea(Vector2 a, Vector2 b, Vector2 c)
	{
		return TriangleArea(a.AsVector3(), b.AsVector3(), c.AsVector3());
	}

	private static float TriangleArea(Vector3 a, Vector3 b, Vector3 c)
	{
		return Vector3.Cross(b - a, c - a).Length() * 0.5f;
	}

	private static void UShortToUInt(ushort[] sourceArray, uint[] destinationArray, int indexCount)
	{
		if (sourceArray.Length < indexCount || destinationArray.Length < indexCount)
		{
			throw new ArgumentOutOfRangeException(nameof(indexCount));
		}

		for (int i = 0; i < indexCount; i++)
		{
			destinationArray[i] = sourceArray[i];
		}
	}

	private static void UIntToUShort(uint[] sourceArray, ushort[] destinationArray, int indexCount)
	{
		if (sourceArray.Length < indexCount || destinationArray.Length < indexCount)
		{
			throw new ArgumentOutOfRangeException(nameof(indexCount));
		}

		for (int i = 0; i < indexCount; i++)
		{
			destinationArray[i] = (ushort)sourceArray[i];
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MeshFilterExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_33;
using AssetRipper.SourceGenerated.Classes.ClassID_43;

namespace AssetRipper.SourceGenerated.Extensions;

public static class MeshFilterExtensions
{
	public static bool TryGetMesh(this IMeshFilter meshFilter, [NotNullWhen(true)] out IMesh? mesh)
	{
		mesh = meshFilter.MeshP;
		return mesh != null;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MeshHelper.cs`:

```cs
using AssetRipper.Numerics;
using System.Buffers.Binary;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace AssetRipper.SourceGenerated.Extensions;

public static class MeshHelper
{
	public enum VertexChannelFormat
	{
		kChannelFormatFloat,
		kChannelFormatFloat16,
		kChannelFormatColor,
		kChannelFormatByte,
		kChannelFormatUInt32
	}

	public enum VertexFormat2017
	{
		kVertexFormatFloat,
		kVertexFormatFloat16,
		kVertexFormatColor,
		kVertexFormatUNorm8,
		kVertexFormatSNorm8,
		kVertexFormatUNorm16,
		kVertexFormatSNorm16,
		kVertexFormatUInt8,
		kVertexFormatSInt8,
		kVertexFormatUInt16,
		kVertexFormatSInt16,
		kVertexFormatUInt32,
		kVertexFormatSInt32
	}

	public enum VertexFormat
	{
		kVertexFormatFloat,
		kVertexFormatFloat16,
		kVertexFormatUNorm8,
		kVertexFormatSNorm8,
		kVertexFormatUNorm16,
		kVertexFormatSNorm16,
		kVertexFormatUInt8,
		kVertexFormatSInt8,
		kVertexFormatUInt16,
		kVertexFormatSInt16,
		kVertexFormatUInt32,
		kVertexFormatSInt32
	}

	public static VertexFormat ToVertexFormat(int format, UnityVersion version)
	{
		if (version.LessThan(2017))
		{
			return (VertexChannelFormat)format switch
			{
				VertexChannelFormat.kChannelFormatFloat => VertexFormat.kVertexFormatFloat,
				VertexChannelFormat.kChannelFormatFloat16 => VertexFormat.kVertexFormatFloat16,
				//in 4.x is size 4
				VertexChannelFormat.kChannelFormatColor => VertexFormat.kVertexFormatUNorm8,
				VertexChannelFormat.kChannelFormatByte => VertexFormat.kVertexFormatUInt8,
				//in 5.x
				VertexChannelFormat.kChannelFormatUInt32 => VertexFormat.kVertexFormatUInt32,
				_ => throw new ArgumentOutOfRangeException(nameof(format), format, null),
			};
		}
		else if (version.LessThan(2019))
		{
			return (VertexFormat2017)format switch
			{
				VertexFormat2017.kVertexFormatFloat => VertexFormat.kVertexFormatFloat,
				VertexFormat2017.kVertexFormatFloat16 => VertexFormat.kVertexFormatFloat16,
				VertexFormat2017.kVertexFormatColor or VertexFormat2017.kVertexFormatUNorm8 => VertexFormat.kVertexFormatUNorm8,
				VertexFormat2017.kVertexFormatSNorm8 => VertexFormat.kVertexFormatSNorm8,
				VertexFormat2017.kVertexFormatUNorm16 => VertexFormat.kVertexFormatUNorm16,
				VertexFormat2017.kVertexFormatSNorm16 => VertexFormat.kVertexFormatSNorm16,
				VertexFormat2017.kVertexFormatUInt8 => VertexFormat.kVertexFormatUInt8,
				VertexFormat2017.kVertexFormatSInt8 => VertexFormat.kVertexFormatSInt8,
				VertexFormat2017.kVertexFormatUInt16 => VertexFormat.kVertexFormatUInt16,
				VertexFormat2017.kVertexFormatSInt16 => VertexFormat.kVertexFormatSInt16,
				VertexFormat2017.kVertexFormatUInt32 => VertexFormat.kVertexFormatUInt32,
				VertexFormat2017.kVertexFormatSInt32 => VertexFormat.kVertexFormatSInt32,
				_ => throw new ArgumentOutOfRangeException(nameof(format), format, null),
			};
		}
		else
		{
			return (VertexFormat)format;
		}
	}

	public static int ToChannelFormat(VertexFormat format, UnityVersion version)
	{
		if (version.LessThan(2017))
		{
			return format switch
			{
				VertexFormat.kVertexFormatFloat => (int)VertexChannelFormat.kChannelFormatFloat,
				VertexFormat.kVertexFormatFloat16 => (int)VertexChannelFormat.kChannelFormatFloat16,
				VertexFormat.kVertexFormatUNorm8 => (int)VertexChannelFormat.kChannelFormatColor,
				VertexFormat.kVertexFormatUInt8 => (int)VertexChannelFormat.kChannelFormatByte,
				VertexFormat.kVertexFormatUInt32 => (int)VertexChannelFormat.kChannelFormatUInt32,
				_ => throw new ArgumentOutOfRangeException(nameof(format), format, null),
			};
		}
		else if (version.LessThan(2019))
		{
			return format switch
			{
				VertexFormat.kVertexFormatFloat => (int)VertexFormat2017.kVertexFormatFloat,
				VertexFormat.kVertexFormatFloat16 => (int)VertexFormat2017.kVertexFormatFloat16,
				VertexFormat.kVertexFormatUNorm8 => (int)VertexFormat2017.kVertexFormatUNorm8,
				VertexFormat.kVertexFormatSNorm8 => (int)VertexFormat2017.kVertexFormatSNorm8,
				VertexFormat.kVertexFormatUNorm16 => (int)VertexFormat2017.kVertexFormatUNorm16,
				VertexFormat.kVertexFormatSNorm16 => (int)VertexFormat2017.kVertexFormatSNorm16,
				VertexFormat.kVertexFormatUInt8 => (int)VertexFormat2017.kVertexFormatUInt8,
				VertexFormat.kVertexFormatSInt8 => (int)VertexFormat2017.kVertexFormatSInt8,
				VertexFormat.kVertexFormatUInt16 => (int)VertexFormat2017.kVertexFormatUInt16,
				VertexFormat.kVertexFormatSInt16 => (int)VertexFormat2017.kVertexFormatSInt16,
				VertexFormat.kVertexFormatUInt32 => (int)VertexFormat2017.kVertexFormatUInt32,
				VertexFormat.kVertexFormatSInt32 => (int)VertexFormat2017.kVertexFormatSInt32,
				_ => throw new ArgumentOutOfRangeException(nameof(format), format, null),
			};
		}
		else
		{
			return (int)format;
		}
	}

	public static int GetChannelFormat_Color(UnityVersion version)
	{
		if (version.LessThan(2017))
		{
			return (int)VertexChannelFormat.kChannelFormatColor;
		}
		else if (version.LessThan(2019))
		{
			return (int)VertexFormat2017.kVertexFormatColor;
		}
		else
		{
			return (int)VertexFormat.kVertexFormatUNorm8;
		}
	}

	public static int GetFormatSize(VertexFormat format)
	{
		switch (format)
		{
			case VertexFormat.kVertexFormatFloat:
			case VertexFormat.kVertexFormatUInt32:
			case VertexFormat.kVertexFormatSInt32:
				return 4;
			case VertexFormat.kVertexFormatFloat16:
			case VertexFormat.kVertexFormatUNorm16:
			case VertexFormat.kVertexFormatSNorm16:
			case VertexFormat.kVertexFormatUInt16:
			case VertexFormat.kVertexFormatSInt16:
				return 2;
			case VertexFormat.kVertexFormatUNorm8:
			case VertexFormat.kVertexFormatSNorm8:
			case VertexFormat.kVertexFormatUInt8:
			case VertexFormat.kVertexFormatSInt8:
				return 1;
			default:
				throw new ArgumentOutOfRangeException(nameof(format), format, null);
		}
	}

	public static bool IsIntFormat(VertexFormat format)
	{
		return format >= VertexFormat.kVertexFormatUInt8;
	}

	public static float[] BytesToFloatArray(ReadOnlySpan<byte> inputBytes, VertexFormat format)
	{
		int size = GetFormatSize(format);
		if (inputBytes.Length % size != 0)
		{
			throw new Exception($"Input array length {inputBytes.Length} is not divisible by size {size}");
		}

		int len = inputBytes.Length / size;
		float[] result = new float[len];
		for (int i = 0; i < len; i++)
		{
			switch (format)
			{
				case VertexFormat.kVertexFormatFloat:
					result[i] = BinaryPrimitives.ReadSingleLittleEndian(inputBytes[(i * sizeof(float))..]);
					break;
				case VertexFormat.kVertexFormatFloat16:
					result[i] = (float)BinaryPrimitives.ReadHalfLittleEndian(inputBytes[(i * Unsafe.SizeOf<Half>())..]);
					break;
				case VertexFormat.kVertexFormatUNorm8:
					result[i] = inputBytes[i] / 255f;
					break;
				case VertexFormat.kVertexFormatSNorm8:
					result[i] = Math.Max(unchecked((sbyte)inputBytes[i]) / 127f, -1f);
					break;
				case VertexFormat.kVertexFormatUNorm16:
					result[i] = BinaryPrimitives.ReadUInt16LittleEndian(inputBytes[(i * sizeof(ushort))..]) / 65535f;
					break;
				case VertexFormat.kVertexFormatSNorm16:
					result[i] = Math.Max(BinaryPrimitives.ReadInt16LittleEndian(inputBytes[(i * sizeof(short))..]) / 32767f, -1f);
					break;
			}
		}
		return result;
	}

	public static int[] BytesToIntArray(ReadOnlySpan<byte> inputBytes, VertexFormat format)
	{
		int size = GetFormatSize(format);
		int len = inputBytes.Length / size;
		int[] result = new int[len];
		for (int i = 0; i < len; i++)
		{
			switch (format)
			{
				case VertexFormat.kVertexFormatUInt8:
				case VertexFormat.kVertexFormatSInt8:
					result[i] = inputBytes[i];
					break;
				case VertexFormat.kVertexFormatUInt16:
				case VertexFormat.kVertexFormatSInt16:
					result[i] = BinaryPrimitives.ReadInt16LittleEndian(inputBytes[(i * sizeof(short))..]);
					break;
				case VertexFormat.kVertexFormatUInt32:
				case VertexFormat.kVertexFormatSInt32:
					result[i] = BinaryPrimitives.ReadInt32LittleEndian(inputBytes[(i * sizeof(int))..]);
					break;
			}
		}
		return result;
	}

	public static Vector2[] FloatArrayToVector2(float[] input) => FloatArrayToVector2(input, 2);
	public static Vector2[] FloatArrayToVector2(float[] input, int dimension)
	{
		ArgumentNullException.ThrowIfNull(input);

		ArgumentOutOfRangeException.ThrowIfLessThan(dimension, 1);
		ArgumentOutOfRangeException.ThrowIfGreaterThan(dimension, 4);
		ValidateLength(input, dimension);

		Vector2[] result = GC.AllocateUninitializedArray<Vector2>(input.Length / dimension);
		switch (dimension)
		{
			case 1:
				for (int i = result.Length - 1; i >= 0; i--)
				{
					result[i] = new Vector2(input[i], 0);
				}
				break;
			case 2:
				MemoryMarshal.Cast<float, Vector2>(input).CopyTo(result);
				break;
			case 3:
				for (int i = result.Length - 1; i >= 0; i--)
				{
					result[i] = new Vector2(input[3 * i], input[3 * i + 1]);
				}
				break;
			case 4:
				for (int i = result.Length - 1; i >= 0; i--)
				{
					result[i] = new Vector2(input[4 * i], input[4 * i + 1]);
				}
				break;
		}
		return result;
	}

	public static Vector3[] FloatArrayToVector3(float[] input) => FloatArrayToVector3(input, 3);
	public static Vector3[] FloatArrayToVector3(float[] input, int dimension)
	{
		ArgumentNullException.ThrowIfNull(input);

		ArgumentOutOfRangeException.ThrowIfLessThan(dimension, 1);
		ArgumentOutOfRangeException.ThrowIfGreaterThan(dimension, 4);
		ValidateLength(input, dimension);

		//In the four dimensional case for Normals, the fourth dimension was always zero
		//This is seemingly intended to maintain data alignment

		Vector3[] result = GC.AllocateUninitializedArray<Vector3>(input.Length / dimension);
		switch (dimension)
		{
			case 1:
				for (int i = result.Length - 1; i >= 0; i--)
				{
					result[i] = new Vector3(input[i], 0, 0);
				}
				break;
			case 2:
				for (int i = result.Length - 1; i >= 0; i--)
				{
					result[i] = new Vector3(input[2 * i], input[2 * i + 1], 0);
				}
				break;
			case 3:
				MemoryMarshal.Cast<float, Vector3>(input).CopyTo(result);
				break;
			case 4:
				for (int i = result.Length - 1; i >= 0; i--)
				{
					result[i] = new Vector3(input[4 * i], input[4 * i + 1], input[4 * i + 2]);
				}
				break;
		}
		return result;
	}

	public static Vector4[] FloatArrayToVector4(float[] input) => FloatArrayToVector4(input, 4);
	public static Vector4[] FloatArrayToVector4(float[] input, int dimension)
	{
		ArgumentNullException.ThrowIfNull(input);

		ArgumentOutOfRangeException.ThrowIfLessThan(dimension, 1);
		ArgumentOutOfRangeException.ThrowIfGreaterThan(dimension, 4);
		ValidateLength(input, dimension);

		Vector4[] result = GC.AllocateUninitializedArray<Vector4>(input.Length / dimension);
		switch (dimension)
		{
			case 1:
				for (int i = result.Length - 1; i >= 0; i--)
				{
					result[i] = new Vector4(input[i], 0, 0, 0);
				}
				break;
			case 2:
				for (int i = result.Length - 1; i >= 0; i--)
				{
					result[i] = new Vector4(input[2 * i], input[2 * i + 1], 0, 0);
				}
				break;
			case 3:
				for (int i = result.Length - 1; i >= 0; i--)
				{
					result[i] = new Vector4(input[3 * i], input[3 * i + 1], input[3 * i + 2], 0);
				}
				break;
			case 4:
				MemoryMarshal.Cast<float, Vector4>(input).CopyTo(result);
				break;
		}
		return result;
	}

	private static void ValidateLength(float[] input, int dimension)
	{
		if (input.Length % dimension != 0)
		{
			throw new ArgumentException($"Input array length {input.Length} is not divisible by dimension {dimension}", nameof(input));
		}
	}

	public static ColorFloat[] FloatArrayToColorFloat(float[] input)
	{
		ArgumentNullException.ThrowIfNull(input);

		if (input.Length % 4 != 0)
		{
			throw new ArgumentException($"Input array length {input.Length} is not divisible by four", nameof(input));
		}

		return MemoryMarshal.Cast<float, ColorFloat>(input).ToArray();
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MeshOutlineGenerator.cs`:

```cs
using AssetRipper.Numerics;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public sealed class MeshOutlineGenerator
{
	private readonly struct Outline
	{
		private readonly record struct Outside(int Triangle, int Member);

		public Outline(IReadOnlyList<Vector3i> triangles, int startTriangle)
		{
			m_triangles = triangles ?? throw new ArgumentNullException(nameof(triangles));

			GenerateIndexes(startTriangle);
			GenerateOutsiders();
		}

		public void GenerateOutline()
		{
			m_outline.Clear();
			Outside outsider = m_outsiders[0];
			Vector3i tri = m_triangles[outsider.Triangle];
			int first = tri.GetValueByMember(outsider.Member);
			int second = tri.GetValueByMember(outsider.Member + 1);
			int startTriIndex = outsider.Triangle;
			m_outline.Add(first);
			m_outline.Add(second);

			Vector3i lastTri = tri;
			int lastMember = outsider.Member + 1;
			int lastVertex = lastTri.GetValueByMember(outsider.Member);
			int lastTriIndex = outsider.Triangle;
			while (true)
			{
				if (GetNextOutsider(lastTri, lastMember, out outsider))
				{
					lastTri = m_triangles[outsider.Triangle];
					lastMember = outsider.Member + 1;
					lastVertex = lastTri.GetValueByMember(outsider.Member);
					lastTriIndex = outsider.Triangle;
				}
				else
				{
					lastMember++;
					if (lastTri.GetValueByMember(lastMember) == lastVertex)
					{
						if (lastVertex != first)
						{
							break;
						}
					}
				}

				int nextVertex = lastTri.GetValueByMember(lastMember);
				if (nextVertex == first)
				{
					break;
				}

				m_outline.Add(nextVertex);
			}
		}

		public bool Contains(int triIndex) => m_indexes.Contains(triIndex);

		private int GetEdgeMask(Vector3i triangle, IReadOnlyList<int> indexes)
		{
			int edgeMask = 0;
			for (int i = 0; i < indexes.Count; i++)
			{
				Vector3i check = m_triangles[indexes[i]];
				if (check == triangle)
				{
					continue;
				}
				int edge = GetNeighborEdge(triangle, check);
				if (edge == 0)
				{
					continue;
				}
				edgeMask |= edge;
			}
			return edgeMask;
		}

		private static int GetNeighborEdge(Vector3i tri1, Vector3i tri2)
		{
			if (IsNeighbors(tri1.X, tri1.Y, tri2))
			{
				return 1 << 0;
			}
			if (IsNeighbors(tri1.Y, tri1.Z, tri2))
			{
				return 1 << 1;
			}
			if (IsNeighbors(tri1.Z, tri1.X, tri2))
			{
				return 1 << 2;
			}
			return 0;
		}

		private static bool IsNeighbors(int a, int b, Vector3i tri2)
		{
			if (a == tri2.X && b == tri2.Z)
			{
				return true;
			}
			if (b == tri2.Y && a == tri2.Z)
			{
				return true;
			}
			if (b == tri2.X && a == tri2.Y)
			{
				return true;
			}
			return false;
		}

		private void GenerateIndexes(int startTriangle)
		{
			List<int> indexes = new List<int>();
			indexes.Add(startTriangle);
			m_indexes.Add(startTriangle);
			for (int i = 0; i < indexes.Count; i++)
			{
				int index = indexes[i];
				Vector3i triangle = m_triangles[index];
				//int edgeMask = GetEdgeMask(triangle, indexes);
				for (int j = 0; j < m_triangles.Count; j++)
				{
					if (m_indexes.Contains(j))
					{
						continue;
					}
					Vector3i check = m_triangles[j];
					int edge = GetNeighborEdge(triangle, check);
					if (edge == 0)
					{
						continue;
					}
					// allow only one neighbor per edge
					//if ((edgeMask & edge) != 0)
					{
						//continue;
					}

					indexes.Add(j);
					m_indexes.Add(j);
					//edgeMask |= edge;
				}
			}
		}

		private void GenerateOutsiders()
		{
			foreach (int index in m_indexes)
			{
				if (GenerateOutsider(index, out Outside outsider))
				{
					m_outsiders.Add(outsider);
				}
			}
		}

		private bool GenerateOutsider(int index, out Outside outsider)
		{
			Vector3i triangle = m_triangles[index];
			int neighborCount = 0;
			bool xy = true;
			bool yz = true;
			bool zx = true;
			outsider = new();
			foreach (int checkIndex in m_indexes)
			{
				if (checkIndex == index)
				{
					continue;
				}
				Vector3i check = m_triangles[checkIndex];
				if (check.ContainsValue(triangle.X))
				{
					if (check.ContainsValue(triangle.Y))
					{
						xy = false;
						if (++neighborCount == 3)
						{
							return false;
						}
					}
					else if (check.ContainsValue(triangle.Z))
					{
						zx = false;
						if (++neighborCount == 3)
						{
							return false;
						}
					}
				}
				else if (check.ContainsValue(triangle.Y) && check.ContainsValue(triangle.Z))
				{
					yz = false;
					if (++neighborCount == 3)
					{
						return false;
					}
				}
			}
			int vertex = xy ? zx ? 2 : 0 : yz ? 1 : 2;
			outsider = new Outside(index, vertex);
			return true;
		}

		private bool GetNextOutsider(Vector3i triangle, int member, out Outside result)
		{
			int vertex = triangle.GetValueByMember(member);
			foreach (Outside outsider in m_outsiders)
			{
				Vector3i check = m_triangles[outsider.Triangle];
				if (check.GetValueByMember(outsider.Member) == vertex)
				{
					if (IsConnectedNeighbors(triangle, check, vertex))
					{
						result = outsider;
						return true;
					}
				}
			}
			result = default;
			return false;
		}

		private bool GetNextNeighbor(Vector3i tri, int vertex, out Vector3i result)
		{
			int member = tri.GetMemberByValue(vertex);
			int nextVertex = tri.GetValueByMember(member + 1);
			foreach (int index in m_indexes)
			{
				Vector3i check = m_triangles[index];
				if (check.ContainsValue(vertex) && check.ContainsValue(nextVertex))
				{
					if (check != tri)
					{
						result = check;
						return true;
					}
				}
			}
			result = default;
			return false;
		}

		private bool IsConnectedNeighbors(Vector3i tri1, Vector3i tri2, int vertex)
		{
			if (GetNeighborEdge(tri1, tri2) != 0)
			{
				return true;
			}

			Vector3i next = tri1;
			while (GetNextNeighbor(next, vertex, out next))
			{
				if (next == tri2)
				{
					return true;
				}
			}
			return false;
		}

		public int TriangleCount => m_indexes.Count;
		public IReadOnlyList<int> GeneratedOutline => m_outline;

		private readonly IReadOnlyList<Vector3i> m_triangles;
		private readonly HashSet<int> m_indexes = new();
		private readonly List<int> m_outline = new();
		private readonly List<Outside> m_outsiders = new();
	}

	public MeshOutlineGenerator(IReadOnlyList<Vector3> vertices, IReadOnlyList<Vector3i> triangles)
	{
		ArgumentNullException.ThrowIfNull(vertices);
		ArgumentNullException.ThrowIfNull(triangles);
		m_vertices = vertices;
		foreach (Vector3i triangle in triangles)
		{
			if (IsValidTriangle(triangle))
			{
				m_triangles.Add(triangle);
			}
		}
	}

	public List<Vector2[]> GenerateOutlines()
	{
		List<Outline> outlines = new();
		for (int i = 0; i < m_triangles.Count; i++)
		{
			bool isKnown = false;
			for (int j = 0; j < outlines.Count; j++)
			{
				if (outlines[j].Contains(i))
				{
					isKnown = true;
					break;
				}
			}
			if (isKnown)
			{
				continue;
			}

			Outline outline = new Outline(m_triangles, i);
			outline.GenerateOutline();
			outlines.Add(outline);
		}

		List<Vector2[]> result = new();
		List<Vector2> resultLine = new();
		for (int i = 0; i < outlines.Count; i++)
		{
			resultLine.Clear();
			Outline outline = outlines[i];
			for (int j = 0; j < outline.GeneratedOutline.Count; j++)
			{
				int vertex = outline.GeneratedOutline[j];
				// commented out by mafaca
				// include outlines that has common vertex with current outline
				/*for (int k = i + 1; k < outlines.Count; k++)
				{
					Outline nextOutline = outlines[k];
					int index = nextOutline.GeneratedOutline.IndexOf(vertex);
					if (index != -1)
					{
						for (int l = index; l < nextOutline.GeneratedOutline.Count; l++)
						{
							int nextVertex = nextOutline.GeneratedOutline[l];
							resultLine.Add(m_vertices[nextVertex].AsVector2());
						}
						for (int m = 0; m < index; m++)
						{
							int nextVertex = nextOutline.GeneratedOutline[m];
							resultLine.Add(m_vertices[nextVertex].AsVector2());
						}
						outlines.RemoveAt(k--);
					}
				}*/
				resultLine.Add(m_vertices[vertex].AsVector2());
			}
			result.Add(resultLine.ToArray());
		}

		return result;
	}

	private static bool IsValidTriangle(Vector3i triangle)
	{
		return triangle.X != triangle.Y && triangle.X != triangle.Z && triangle.Y != triangle.Z;
	}

	private readonly IReadOnlyList<Vector3> m_vertices;
	private readonly List<Vector3i> m_triangles = new();
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MinMaxCurveExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.MinMaxCurve;

namespace AssetRipper.SourceGenerated.Extensions;

public static class MinMaxCurveExtensions
{
	public static void SetValues(this IMinMaxCurve curve, UnityVersion version, float value)
	{
		curve.SetValues(version, ParticleSystemCurveMode.Constant, value, value, 1.0f, 1.0f);
	}

	public static void SetValues(this IMinMaxCurve curve, UnityVersion version, float minValue, float maxValue)
	{
		curve.SetValues(version, ParticleSystemCurveMode.Constant, minValue, maxValue, 1.0f, 1.0f);
	}

	public static void SetValues(this IMinMaxCurve curve, UnityVersion version, float minValue, float maxValue, float minCurve, float maxCurve)
	{
		curve.SetValues(version, ParticleSystemCurveMode.Constant, minValue, maxValue, minCurve, maxCurve);
	}

	public static void SetValues(this IMinMaxCurve curve, UnityVersion version, float minValue, float maxValue, float minCurve, float maxCurve1, float maxCurve2)
	{
		curve.SetMinMaxState(ParticleSystemCurveMode.Curve);
		curve.Scalar = maxValue;
		curve.MinScalar = minValue;

		curve.MinCurve.SetValues(version, minCurve, KeyframeExtensions.DefaultFloatWeight);
		curve.MaxCurve.SetValues(version, maxCurve1, 0.0f, 1.0f, maxCurve2, 1.0f, 0.0f, KeyframeExtensions.DefaultFloatWeight);
	}

	public static void SetValues(this IMinMaxCurve curve, UnityVersion version, ParticleSystemCurveMode mode, float minValue, float maxValue, float minCurve, float maxCurve)
	{
		curve.SetMinMaxState(mode);
		curve.MinScalar = minValue;
		curve.Scalar = maxValue;

		curve.MinCurve.SetValues(version, minCurve, KeyframeExtensions.DefaultFloatWeight);
		curve.MaxCurve.SetValues(version, maxCurve, KeyframeExtensions.DefaultFloatWeight);
	}

	public static ParticleSystemCurveMode GetMinMaxState(this IMinMaxCurve curve)
	{
		return curve.Has_MinMaxState_Int16()
			? unchecked((ParticleSystemCurveMode)curve.MinMaxState_Int16)
			: (ParticleSystemCurveMode)curve.MinMaxState_UInt16;
	}

	public static void SetMinMaxState(this IMinMaxCurve curve, ParticleSystemCurveMode mode)
	{
		curve.MinMaxState_Int16 = unchecked((short)mode);
		curve.MinMaxState_UInt16 = (ushort)mode;
	}

	private static float GetExportScalar(this IMinMaxCurve curve)
	{
		if (curve.Has_MinScalar())
		{
			return curve.Scalar;
		}
		else
		{
			if (curve.GetMinMaxState() == ParticleSystemCurveMode.TwoConstants)
			{
				return curve.Scalar * curve.MaxCurve.Curve[0].Value;
			}
			else
			{
				return curve.Scalar;
			}
		}
	}

	private static float GetExportMinScalar(this IMinMaxCurve curve)
	{
		if (curve.Has_MinScalar())
		{
			return curve.MinScalar;
		}
		else
		{
			if (curve.GetMinMaxState() == ParticleSystemCurveMode.TwoConstants)
			{
				return curve.Scalar * curve.MinCurve.Curve[0].Value;
			}
			else
			{
				return curve.Scalar;
			}
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MinMaxGradientExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.MinMaxGradient;

namespace AssetRipper.SourceGenerated.Extensions;

public static class MinMaxGradientExtensions
{
	public enum MinMaxGradientState : ushort
	{
		Color = 0,
		Gradient = 1,
		RandomBetweenTwoColors = 2,
		RandomBetweenTwoGradients = 3,
		RandomColor = 4,
	}

	public static MinMaxGradientState GetMinMaxState(this IMinMaxGradient gradient)
	{
		return gradient.Has_MinMaxState_Int16()
			? unchecked((MinMaxGradientState)gradient.MinMaxState_Int16)
			: (MinMaxGradientState)gradient.MinMaxState_UInt16;
	}

	public static void SetMinMaxState(this IMinMaxGradient gradient, MinMaxGradientState state)
	{
		gradient.MinMaxState_Int16 = unchecked((short)state);
		gradient.MinMaxState_UInt16 = (ushort)state;
	}

	public static void SetToDefault(this IMinMaxGradient gradient)
	{
		gradient.SetMinMaxState(MinMaxGradientState.Color);

		if (gradient.Has_MinColor_ColorRGBA32())
		{
			gradient.MinColor_ColorRGBA32.SetAsWhite();
		}
		else
		{
			gradient.MinColor_ColorRGBAf.SetAsWhite();
		}

		if (gradient.Has_MaxColor_ColorRGBA32())
		{
			gradient.MaxColor_ColorRGBA32.SetAsWhite();
		}
		else
		{
			gradient.MaxColor_ColorRGBAf.SetAsWhite();
		}

		//gradient.MaxGradient = new Gradient(ColorRGBAf.White, ColorRGBAf.White);
		//gradient.MinGradient = new Gradient(ColorRGBAf.White, ColorRGBAf.White);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MonoBehaviourExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_115;

namespace AssetRipper.SourceGenerated.Extensions;

public static class MonoBehaviourExtensions
{
	/// <summary>
	/// Does this MonoBehaviour belong to scene/prefab hierarchy? In other words, is <see cref="IMonoBehaviour.GameObject"/> a non-null pptr?
	/// </summary>
	public static bool IsComponentOnGameObject(this IMonoBehaviour monoBehaviour) => !monoBehaviour.GameObject.IsNull();

	public static bool TryGetScript(this IMonoBehaviour monoBehaviour, [NotNullWhen(true)] out IMonoScript? script)
	{
		script = monoBehaviour.ScriptP;
		return script is not null;
	}

	public static bool IsGuiSkin(this IMonoBehaviour monoBehaviour)
	{
		if (TryGetScript(monoBehaviour, out IMonoScript? script))
		{
			if (script.PathID is 12001 && script.Collection.Name == "unity default resources")
			{
				return true;
			}
		}
		return false;
	}

	public static bool IsBrush(this IMonoBehaviour monoBehaviour)
	{
		if (TryGetScript(monoBehaviour, out IMonoScript? script))
		{
			if (script.PathID is 12146 && script.Collection.Name == "unity default resources")
			{
				return true;
			}
		}
		return false;
	}

	public static bool IsTimelineAsset(this IMonoBehaviour monoBehaviour)
	{
		return monoBehaviour.IsType("UnityEngine.Timeline", "TimelineAsset");
	}

	public static bool IsPostProcessProfile(this IMonoBehaviour monoBehaviour)
	{
		return monoBehaviour.IsType("UnityEngine.Rendering.PostProcessing", "PostProcessProfile");
	}

	private static bool IsType(this IMonoBehaviour monoBehaviour, string @namespace, string name)
	{
		return TryGetScript(monoBehaviour, out IMonoScript? script) && script.IsType(@namespace, name);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MonoScriptExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using System.Text.RegularExpressions;

namespace AssetRipper.SourceGenerated.Extensions;

public static partial class MonoScriptExtensions
{
	[GeneratedRegex(@"^(\w+)`([1-9][0-9]*)$")]
	private static partial Regex GenericRegex { get; }

	public static bool IsFullNameEqual(this IMonoScript _this, IMonoScript other)
	{
		return _this.AssemblyName == other.AssemblyName
			&& _this.Namespace == other.Namespace
			&& _this.ClassName_R == other.ClassName_R;
	}

	public static bool IsType(this IMonoScript _this, string @namespace, string name)
	{
		return _this.Namespace == @namespace && _this.ClassName_R == name;
	}

	public static bool IsGeneric(this IMonoScript script, out string genericName, out int genericCount)
	{
		return IsGeneric(script.ClassName_R.String, out genericName, out genericCount);
	}

	public static bool IsGeneric(string className, out string genericName, out int genericCount)
	{
		Match match = GenericRegex.Match(className);
		if (match.Success)
		{
			genericName = match.Groups[1].Value;
			if (int.TryParse(match.Groups[2].Value, out genericCount))
			{
				return true;
			}
		}
		genericName = className;
		genericCount = 0;
		return false;
	}

	public static string GetNonGenericClassName(this IMonoScript script)
	{
		return IsGeneric(script, out string genericName, out _) ? genericName : script.ClassName_R.String;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MultiModeParameterExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.MultiModeParameter;
using AssetRipper.SourceGenerated.Subclasses.MultiModeParameter_MeshSpawn;

namespace AssetRipper.SourceGenerated.Extensions;

public static class MultiModeParameterExtensions
{
	public static ParticleSystemShapeMultiModeValue GetMode(this IMultiModeParameter parameter)
	{
		return (ParticleSystemShapeMultiModeValue)parameter.Mode;
	}

	public static void SetValues(this IMultiModeParameter parameter, UnityVersion version, float value)
	{
		parameter.Value = value;
		parameter.Mode = (int)ParticleSystemShapeMultiModeValue.Random;
		parameter.Spread = 0.0f;
		parameter.Speed.SetValues(version, 1.0f);
	}

	public static ParticleSystemShapeMultiModeValue GetMode(this IMultiModeParameter_MeshSpawn parameter)
	{
		return (ParticleSystemShapeMultiModeValue)parameter.Mode;
	}

	public static void SetValues(this IMultiModeParameter_MeshSpawn parameter, UnityVersion version)
	{
		parameter.Mode = (int)ParticleSystemShapeMultiModeValue.Random;
		parameter.Spread = 0.0f;
		parameter.Speed.SetValues(version, 1.0f);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/MuscleClipInfoExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.MuscleClipConstant;
using AssetRipper.SourceGenerated.Subclasses.MuscleClipInfo;

namespace AssetRipper.SourceGenerated.Extensions;

public static class MuscleClipInfoExtensions
{
	public static void Initialize(this IMuscleClipInfo info)
	{
		info.StopTime = 1.0f;
		info.KeepOriginalPositionY = true;
	}

	public static void Initialize(this IMuscleClipInfo info, IMuscleClipConstant muscleConst)
	{
		info.AdditiveReferencePoseTime = 0.0f;
		info.StartTime = muscleConst.StartTime;
		info.StopTime = muscleConst.StopTime;
		info.OrientationOffsetY = muscleConst.OrientationOffsetY;
		info.Level = muscleConst.Level;
		info.CycleOffset = muscleConst.CycleOffset;
		info.HasAdditiveReferencePose = false;
		info.LoopTime = muscleConst.LoopTime;
		info.LoopBlend = muscleConst.LoopBlend;
		info.LoopBlendOrientation = muscleConst.LoopBlendOrientation;
		info.LoopBlendPositionY = muscleConst.LoopBlendPositionY;
		info.LoopBlendPositionXZ = muscleConst.LoopBlendPositionXZ;
		info.KeepOriginalOrientation = muscleConst.KeepOriginalOrientation;
		info.KeepOriginalPositionY = muscleConst.KeepOriginalPositionY;
		info.KeepOriginalPositionXZ = muscleConst.KeepOriginalPositionXZ;
		info.HeightFromFeet = muscleConst.HeightFromFeet;
		info.Mirror = false;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/NavMeshAgentExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_195;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class NavMeshAgentExtensions
{
	public static ObstacleAvoidanceType GetObstacleAvoidanceType(this INavMeshAgent agent)
	{
		return (ObstacleAvoidanceType)agent.ObstacleAvoidanceType;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/NavMeshBuildSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.NavMeshBuildSettings;
using AssetRipper.SourceGenerated.Subclasses.NavMeshParams;

namespace AssetRipper.SourceGenerated.Extensions;

public static class NavMeshBuildSettingsExtensions
{
	public static void SetToDefault(this INavMeshBuildSettings settings)
	{
		settings.AgentTypeID = 0;
		settings.AgentRadius = 0.5f;
		settings.AgentHeight = 2.0f;
		settings.AgentSlope = 45.0f;
		settings.AgentClimb = 0.4f;
		settings.LedgeDropHeight = 0.0f;
		settings.MaxJumpAcrossDistance = 0.0f;
		settings.MinRegionArea = 2.0f;
		settings.ManualCellSize_Int32 = 0;
		settings.ManualCellSize_Boolean = false;
		settings.CellSize = 1.0f / 6.0f;
		settings.ManualTileSize_Int32 = 0;
		settings.ManualTileSize_Boolean = false;
		settings.TileSize = 256;
		settings.AccuratePlacement_Int32 = 0;
		settings.AccuratePlacement_Boolean = false;
		settings.MaxJobWorkers = 0;
		settings.PreserveTilesOutsideBounds = 0;
	}

	public static void SetValues(this INavMeshBuildSettings settings, float agentClimb, float cellSize)
	{
		settings.AgentClimb = agentClimb;
		settings.ManualCellSize_Int32 = 1;
		settings.ManualCellSize_Boolean = true;
		settings.CellSize = cellSize;
	}

	public static void SetValues(this INavMeshBuildSettings settings, INavMeshParams navParams)
	{
		settings.SetToDefault();
		settings.AgentRadius = navParams.WalkableRadius;
		settings.AgentHeight = navParams.WalkableHeight;
		settings.AgentClimb = navParams.WalkableClimb;
		settings.TileSize = (int)navParams.TileSize;
		settings.CellSize = navParams.CellSize;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/NavMeshObstacleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_208;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class NavMeshObstacleExtensions
{
	public static NavMeshObstacleShape GetShape(this INavMeshObstacle obstacle)
	{
		return obstacle.Has_Shape()
			? (NavMeshObstacleShape)obstacle.Shape
			: NavMeshObstacleShape.Capsule;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/NavMeshSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_196;
using AssetRipper.SourceGenerated.Classes.ClassID_238;

namespace AssetRipper.SourceGenerated.Extensions;

public static class NavMeshSettingsExtensions
{
	public static void ConvertToEditorFormat(this INavMeshSettings settings)
	{
		INavMeshData? data = settings.NavMeshDataP;
		if (data == null)
		{
			settings.BuildSettings.SetToDefault();
		}
		else
		{
			if (data.Has_NavMeshParams())
			{
				settings.BuildSettings.SetValues(data.NavMeshParams);
			}
			else
			{
				settings.BuildSettings.CopyValues(data.NavMeshBuildSettings);
			}
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/NoiseModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.NoiseModule;

namespace AssetRipper.SourceGenerated.Extensions;

public static class NoiseModuleExtensions
{
	public static void SetToDefaults(this INoiseModule module, UnityVersion version)
	{
		module.Strength.SetValues(version, 1.0f);
		module.StrengthY.SetValues(version, 1.0f);
		module.StrengthZ.SetValues(version, 1.0f);
		module.Frequency = 0.5f;
		module.Damping = true;
		module.Octaves = 1;
		module.OctaveMultiplier = 0.5f;
		module.OctaveScale = 2.0f;
		module.Quality = (int)ParticleSystemNoiseQuality.High;
		module.ScrollSpeed.SetValues(version, 0.0f);
		module.Remap.SetValues(version, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f);
		module.RemapY.SetValues(version, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f);
		module.RemapZ.SetValues(version, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f);
		module.PositionAmount?.SetValues(version, 1.0f);
		module.RotationAmount?.SetValues(version, 0.0f);
		module.SizeAmount?.SetValues(version, 0.0f);
	}

	public static ParticleSystemNoiseQuality GetQuality(this INoiseModule module)
	{
		return (ParticleSystemNoiseQuality)module.Quality;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/PPtrCurveExtensions.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Subclasses.PPtrCurve;

namespace AssetRipper.SourceGenerated.Extensions;

public static class PPtrCurveExtensions
{
	public static void SetValues(this IPPtrCurve curve, AssetCollection collection, string path, string attribute, ClassIDType classID, IMonoScript script)
	{
		curve.Path = path;
		curve.Attribute = attribute;
		curve.ClassID = (int)classID;
		curve.Script.SetAsset(collection, script);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/PPtrExtensions.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.SourceGenerated.Extensions;

public static class PPtrExtensions
{
	public static T? TryGetAsset<T>(this IPPtr<T> pptr, AssetCollection file) where T : IUnityObjectBase
	{
		pptr.TryGetAsset(file, out T? asset);
		return asset;
	}

	public static bool IsAsset<T>(this IPPtr<T> pptr, AssetCollection file, IUnityObjectBase asset) where T : IUnityObjectBase
	{
		if (asset.PathID != pptr.PathID)
		{
			return false;
		}
		else if (pptr.FileID == 0)
		{
			return file == asset.Collection;
		}
		else
		{
			return file.Dependencies[pptr.FileID - 1] == asset.Collection;
		}
	}

	/// <summary>
	/// PathID == 0
	/// </summary>
	public static bool IsNull(this IPPtr pptr) => pptr.PathID == 0;
}

```

`Source/AssetRipper.SourceGenerated.Extensions/PackedFloatVectorExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.PackedBitVector_Single;
using System.Runtime.InteropServices;

namespace AssetRipper.SourceGenerated.Extensions;

public static class PackedFloatVectorExtensions
{
	extension(PackedBitVector_Single packedVector)
	{
		public bool IsSet => packedVector.NumItems > 0;

		public float[] Unpack()
		{
			return packedVector.Unpack(1, 1);
		}

		public float[] Unpack(int itemCountInChunk, int chunkStride, int start = 0, int numChunks = -1)
		{
			if (chunkStride < itemCountInChunk)
			{
				throw new ArgumentException("Chunk stride must be at least as large as the item count in each chunk.");
			}

			if (numChunks == -1)
			{
				numChunks = (int)packedVector.NumItems / chunkStride;
			}

			PackedBitReader reader = new(packedVector, start);
			float[] result = new float[numChunks * itemCountInChunk];
			for (int chunk = 0; chunk < numChunks; chunk++)
			{
				for (int i = 0; i < itemCountInChunk; i++)
				{
					result[chunk * itemCountInChunk + i] = reader.Read();
				}
				for (int i = chunkStride - itemCountInChunk; i > 0; i--)
				{
					reader.Read(); // Skip to the next chunk
				}
			}
			return result;
		}

		/// <summary>
		/// A high accuracy default packing method for any <see langword="unmanaged""/> type.
		/// </summary>
		/// <param name="packedVector"></param>
		/// <param name="data"></param>
		public void Pack<T>(ReadOnlySpan<T> data) where T : unmanaged
		{
			packedVector.Pack(MemoryMarshal.Cast<T, float>(data));
		}

		/// <summary>
		/// A high accuracy default packing method
		/// </summary>
		/// <param name="packedVector"></param>
		/// <param name="data"></param>
		public void Pack(ReadOnlySpan<float> data)
		{
			packedVector.Pack(data, 24, false);
		}

		public void Pack(ReadOnlySpan<float> data, int bitSize, bool adjustBitSize)
		{
			GetMinimumAndMaximum(data, out float minf, out float maxf);

			float range = maxf - minf;

			if (adjustBitSize)
			{
				bitSize += GetBitCount(range);
			}

			if (bitSize > 32)
			{
				bitSize = 32;
			}

			packedVector.Start = minf;
			packedVector.Range = range;
			packedVector.NumItems = (uint)data.Length;
			packedVector.BitSize = (byte)bitSize;
			packedVector.Data = new byte[(packedVector.NumItems * bitSize + 7) / 8];

			float f = BitConverter.UInt32BitsToSingle((1u << packedVector.BitSize) - 1u);
			double scale = 1.0d / packedVector.Range;

			int bitIndex = 0;
			int byteIndex = 0;

			for (int i = 0; i < data.Length; ++i)
			{
				double scaled = double.Clamp((data[i] - packedVector.Start) * scale, 0, 1);
				double d = scaled * f;
				uint x = BitConverter.SingleToUInt32Bits((float)d);

				int bits = 0;
				while (bits < packedVector.BitSize)
				{
					packedVector.Data[byteIndex] |= unchecked((byte)(x >> bits << bitIndex));
					int read = Math.Min(packedVector.BitSize - bits, 8 - bitIndex);
					bitIndex += read;
					bits += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
			}
		}
	}

	private ref struct PackedBitReader
	{
		private readonly PackedBitVector_Single packedVector;
		private int bitIndex;
		private int byteIndex;
		private readonly float scale;
		private readonly uint mask;
		private readonly float halfMaxValue;

		public PackedBitReader(PackedBitVector_Single packedVector, int start)
		{
			this.packedVector = packedVector;
			bitIndex = packedVector.BitSize * start;
			byteIndex = bitIndex / 8;
			bitIndex %= 8;
			scale = 1.0f / packedVector.Range;
			mask = (1u << packedVector.BitSize) - 1u;
			halfMaxValue = scale * mask;
		}

		public float Read()
		{
			uint x = 0;

			int bits = 0;
			int bitSize = packedVector.BitSize;
			while (bits < bitSize)
			{
				x |= (uint)packedVector.Data[byteIndex] >> bitIndex << bits;
				int read = Math.Min(bitSize - bits, 8 - bitIndex);
				bitIndex += read;
				bits += read;
				if (bitIndex == 8)
				{
					byteIndex++;
					bitIndex = 0;
				}
			}
			x &= mask;
			return x / halfMaxValue + packedVector.Start;
		}
	}

	private static void GetMinimumAndMaximum(ReadOnlySpan<float> data, out float min, out float max)
	{
		min = float.PositiveInfinity;
		max = float.NegativeInfinity;
		for (int i = 0; i < data.Length; ++i)
		{
			if (max < data[i])
			{
				max = data[i];
			}

			if (min > data[i])
			{
				min = data[i];
			}
		}
	}

	private static int GetBitCount(double value)
	{
		double log = Math.Log2(value);
		return (int)Math.Ceiling(log);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/PackedIntVectorExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.PackedBitVector_Int32;
using System.Runtime.InteropServices;

namespace AssetRipper.SourceGenerated.Extensions;

public static class PackedIntVectorExtensions
{
	public static bool IsSet(this PackedBitVector_Int32 packedVector) => packedVector.NumItems > 0;

	public static void CopyValuesFrom(this PackedBitVector_Int32 instance, PackedBitVector_Int32 source)
	{
		instance.NumItems = source.NumItems;
		instance.Data = source.Data.ToArray();
		instance.BitSize = source.BitSize;
	}

	public static void PackInts(this PackedBitVector_Int32 packedVector, ReadOnlySpan<int> data)
	{
		packedVector.PackUInts(MemoryMarshal.Cast<int, uint>(data));
	}

	public static void PackUInts(this PackedBitVector_Int32 packedVector, ReadOnlySpan<uint> data)
	{
		uint maxDataValue = 0;
		for (int i = 0; i < data.Length; i++)
		{
			if (maxDataValue < data[i])
			{
				maxDataValue = data[i];
			}
		}

		packedVector.NumItems = (uint)data.Length;
		packedVector.BitSize = maxDataValue == 0xFFFFFFFF ? (byte)32 : GetBitCount(maxDataValue + 1U);
		packedVector.Data = new byte[(data.Length * packedVector.BitSize + 7) / 8];

		int bitIndex = 0;
		int byteIndex = 0;
		for (int i = 0; i < data.Length; i++)
		{
			int bitOffset = 0;
			while (bitOffset < packedVector.BitSize)
			{
				packedVector.Data[byteIndex] |= unchecked((byte)(data[i] >> bitOffset << bitIndex));
				int read = Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
				bitIndex += read;
				bitOffset += read;
				if (bitIndex == 8)
				{
					byteIndex++;
					bitIndex = 0;
				}
			}
		}
	}

	public static void PackUShorts(this PackedBitVector_Int32 packedVector, ReadOnlySpan<ushort> data)
	{
		uint maxDataValue = 0;
		for (int i = 0; i < data.Length; i++)
		{
			if (maxDataValue < data[i])
			{
				maxDataValue = data[i];
			}
		}

		packedVector.NumItems = (uint)data.Length;
		packedVector.BitSize = maxDataValue == 0xFFFFFFFF ? (byte)32 : GetBitCount(maxDataValue + 1U);
		packedVector.Data = new byte[(data.Length * packedVector.BitSize + 7) / 8];

		int bitIndex = 0;
		int byteIndex = 0;
		for (int i = 0; i < data.Length; i++)
		{
			int bitOffset = 0;
			while (bitOffset < packedVector.BitSize)
			{
				packedVector.Data[byteIndex] |= unchecked((byte)(data[i] >> bitOffset << bitIndex));
				int read = Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
				bitIndex += read;
				bitOffset += read;
				if (bitIndex == 8)
				{
					byteIndex++;
					bitIndex = 0;
				}
			}
		}
	}

	public static int[] UnpackInts(this PackedBitVector_Int32 packedVector)
	{
		int bitIndex = 0;
		int byteIndex = 0;
		int[] buffer = new int[packedVector.NumItems];
		for (int i = 0; i < packedVector.NumItems; i++)
		{
			int bitOffset = 0;
			buffer[i] = 0;
			while (bitOffset < packedVector.BitSize)
			{
				buffer[i] |= packedVector.Data[byteIndex] >> bitIndex << bitOffset;
				int read = Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
				bitIndex += read;
				bitOffset += read;
				if (bitIndex == 8)
				{
					byteIndex++;
					bitIndex = 0;
				}
			}
			buffer[i] &= unchecked((1 << packedVector.BitSize) - 1);
		}
		return buffer;
	}

	public static uint[] UnpackUInts(this PackedBitVector_Int32 packedVector)
	{
		int bitIndex = 0;
		int byteIndex = 0;
		uint[] buffer = new uint[packedVector.NumItems];
		for (int i = 0; i < packedVector.NumItems; i++)
		{
			int bitOffset = 0;
			buffer[i] = 0;
			while (bitOffset < packedVector.BitSize)
			{
				buffer[i] |= unchecked((uint)(packedVector.Data[byteIndex] >> bitIndex << bitOffset));
				int read = Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
				bitIndex += read;
				bitOffset += read;
				if (bitIndex == 8)
				{
					byteIndex++;
					bitIndex = 0;
				}
			}
			buffer[i] &= (1U << packedVector.BitSize) - 1;
		}
		return buffer;
	}

	public static ushort[] UnpackUShorts(this PackedBitVector_Int32 packedVector)
	{
		int bitIndex = 0;
		int byteIndex = 0;
		ushort[] buffer = new ushort[packedVector.NumItems];
		for (int i = 0; i < packedVector.NumItems; i++)
		{
			int bitOffset = 0;
			buffer[i] = 0;
			while (bitOffset < packedVector.BitSize)
			{
				buffer[i] |= unchecked((ushort)(packedVector.Data[byteIndex] >> bitIndex << bitOffset));
				int read = Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
				bitIndex += read;
				bitOffset += read;
				if (bitIndex == 8)
				{
					byteIndex++;
					bitIndex = 0;
				}
			}
			buffer[i] &= unchecked((ushort)((1U << packedVector.BitSize) - 1));
		}
		return buffer;
	}

	private static byte GetBitCount(uint value)
	{
		double log = Math.Log2(value);
		return (byte)Math.Ceiling(log);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/PackedQuatVectorExtensions.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Subclasses.PackedBitVector_Quaternionf;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class PackedQuatVectorExtensions
{
	public static void CopyValuesFrom(this PackedBitVector_Quaternionf instance, PackedBitVector_Quaternionf source)
	{
		instance.NumItems = source.NumItems;
		instance.Data = source.Data.ToArray();
	}

	public static void Pack(this PackedBitVector_Quaternionf packedVector, ReadOnlySpan<Quaternion> inputData)
	{
		packedVector.NumItems = (uint)inputData.Length;
		packedVector.Data = new byte[inputData.Length * 4];

		int bitIndex = 0;
		int byteIndex = 0;

		for (int i = 0; i < inputData.Length; i++)
		{
			Quaternion q = inputData[i];
			byte flags = unchecked((byte)(q.X < 0 ? 4 : 0));

			float max = Math.Abs(q.X);
			if (Math.Abs(q.Y) > max)
			{
				max = Math.Abs(q.Y);
				flags = 1;
				if (q.Y < 0)
				{
					flags |= 4;
				}
			}
			if (Math.Abs(q.Z) > max)
			{
				max = Math.Abs(q.Z);
				flags = 2;
				if (q.Z < 0)
				{
					flags |= 4;
				}
			}
			if (Math.Abs(q.W) > max)
			{
				max = Math.Abs(q.W);
				flags = 3;
				if (q.W < 0)
				{
					flags |= 4;
				}
			}
			int bitOffset = 0;
			while (bitOffset < 3)
			{
				packedVector.Data[byteIndex] |= unchecked((byte)(flags >> bitOffset << bitIndex));
				int num = Math.Min(3 - bitOffset, 8 - bitIndex);
				bitIndex += num;
				bitOffset += num;
				if (bitIndex == 8)
				{
					byteIndex++;
					bitIndex = 0;
				}
			}
			for (int j = 0; j < 4; j++)
			{
				if ((flags & 3) != j)
				{
					int bitSize = ((flags & 3) + 1) % 4 == j ? 9 : 10;
					double scaled = (q.GetAt(j) + 1d) * 0.5d;
					if (scaled < 0)
					{
						scaled = 0d;
					}
					else if (scaled > 1)
					{
						scaled = 1d;
					}

					float f = BitConverter.Int32BitsToSingle((1 << bitSize) - 1);
					uint x = BitConverter.SingleToUInt32Bits((float)(scaled * f));

					bitOffset = 0;
					while (bitOffset < bitSize)
					{
						packedVector.Data[byteIndex] |= unchecked((byte)(x >> bitOffset << bitIndex));
						int read = Math.Min(bitSize - bitOffset, 8 - bitIndex);
						bitIndex += read;
						bitOffset += read;
						if (bitIndex == 8)
						{
							byteIndex++;
							bitIndex = 0;
						}
					}
				}
			}
		}
	}

	public static Quaternion[] Unpack(this PackedBitVector_Quaternionf packedVector)
	{
		int bitIndex = 0;
		int byteIndex = 0;
		Quaternion[] buffer = new Quaternion[packedVector.NumItems];
		for (int i = 0; i < packedVector.NumItems; i++)
		{
			uint flags = 0;
			int bitOffset = 0;
			while (bitOffset < 3)
			{
				flags |= unchecked((uint)(packedVector.Data[byteIndex] >> bitIndex << bitOffset));
				int read = Math.Min(3 - bitOffset, 8 - bitIndex);
				bitIndex += read;
				bitOffset += read;
				if (bitIndex == 8)
				{
					byteIndex++;
					bitIndex = 0;
				}
			}
			flags &= 7;

			double sum = 0;
			Quaternion quaternion = default;
			for (int j = 0; j < 4; j++)
			{
				if ((flags & 3) != j)
				{
					int bitSize = ((flags & 3) + 1) % 4 == j ? 9 : 10;

					uint value = 0;
					bitOffset = 0;
					while (bitOffset < bitSize)
					{
						value |= unchecked((uint)(packedVector.Data[byteIndex] >> bitIndex << bitOffset));
						int num = Math.Min(bitSize - bitOffset, 8 - bitIndex);
						bitIndex += num;
						bitOffset += num;
						if (bitIndex == 8)
						{
							byteIndex++;
							bitIndex = 0;
						}
					}
					value &= unchecked((uint)((1 << bitSize) - 1));

					// final value's range is [-1.0f : 1.0f]
					double halfMaxValue = 0.5d * ((1 << bitSize) - 1);
					double quaternion_j = value / halfMaxValue - 1.0d;
					quaternion.SetAt(j, (float)quaternion_j);
					sum += quaternion_j * quaternion_j;
				}
			}

			int lastComponent = unchecked((int)(flags & 3));
			quaternion.SetAt(lastComponent, (float)Math.Sqrt(1.0d - sum));
			if ((flags & 4) != 0)
			{
				quaternion.FlipSignAt(lastComponent);
			}

			buffer[i] = quaternion;
		}
		return buffer;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/PackingSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.PackingParameters;
using AssetRipper.SourceGenerated.Subclasses.PackingSettings;

namespace AssetRipper.SourceGenerated.Extensions;

public static class PackingSettingsExtensions
{
	public static void Initialize(this IPackingSettings settings)
	{
		settings.Padding = 2;
		settings.BlockOffset = 1;
		settings.AllowAlphaSplitting = false;
		settings.EnableRotation = true;
		settings.EnableTightPacking = true;
		settings.EnableAlphaDilation = true;
	}

	public static void Initialize(this IPackingParameters settings) //maybe rename to PackingSettings?
	{
		settings.Padding = 2;
		settings.PaddingPower = 2; //todo: rename to Padding
		settings.BlockOffset = 1;
		settings.AllowAlphaSplitting = 0;
		settings.EnableRotation = 1;
		settings.EnableTightPacking = 1;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ParticleSystemEmissionBurstExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.ParticleSystemEmissionBurst;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ParticleSystemEmissionBurstExtensions
{
	public static void SetValues(this IParticleSystemEmissionBurst burst, UnityVersion version, float time, int minValue, int maxValue)
	{
		burst.Time = time;
		burst.CycleCount_Int32 = 1;
		burst.CycleCount_UInt32 = 1;
		burst.RepeatInterval = 0.01f;
		burst.CountCurve?.SetValues(version, minValue, maxValue);
		burst.Probability = 1.0f;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ParticleSystemExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_198;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ParticleSystemExtensions
{
	public static ParticleSystemStopAction GetStopAction(this IParticleSystem system)
	{
		return (ParticleSystemStopAction)system.StopAction;
	}

	public static ParticleSystemCullingMode GetCullingMode(this IParticleSystem system)
	{
		return (ParticleSystemCullingMode)system.CullingMode;
	}

	public static ParticleSystemRingBufferMode GetRingBufferMode(this IParticleSystem system)
	{
		return (ParticleSystemRingBufferMode)system.RingBufferMode;
	}

	public static ParticleSystemSimulationSpace GetMoveWithTransform(this IParticleSystem system)
	{
		if (system.Has_MoveWithTransform_Boolean())
		{
			return system.MoveWithTransform_Boolean ? ParticleSystemSimulationSpace.Local : ParticleSystemSimulationSpace.World;
		}
		else
		{
			return (ParticleSystemSimulationSpace)system.MoveWithTransform_Int32;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ParticleSystemForceFieldParametersExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.ParticleSystemForceFieldParameters;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ParticleSystemForceFieldParametersExtensions
{
	public static ParticleSystemForceFieldShape GetShape(this IParticleSystemForceFieldParameters parameters)
	{
		return (ParticleSystemForceFieldShape)parameters.Shape;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ParticleSystemRendererExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_199;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ParticleSystemRendererExtensions
{
	public static ParticleSystemRenderMode GetRenderMode(this IParticleSystemRenderer renderer)
	{
		return renderer.Has_RenderMode_UInt16()
			? renderer.RenderMode_UInt16E
			: renderer.RenderMode_Int32E;
	}

	public static ParticleSystemSortMode GetSortMode(this IParticleSystemRenderer renderer)
	{
		return renderer.Has_SortMode_Byte()
			? renderer.SortMode_ByteE
			: renderer.Has_SortMode_UInt16()
				? renderer.SortMode_UInt16E
				: (ParticleSystemSortMode)renderer.SortMode_Int32;
	}

	public static ParticleSystemRenderSpace GetRenderAlignment(this IParticleSystemRenderer renderer)
	{
		return renderer.Has_RenderAlignment()
			? renderer.RenderAlignmentE
			: renderer.GetRenderMode() == ParticleSystemRenderMode.Mesh
				? ParticleSystemRenderSpace.Local
				: ParticleSystemRenderSpace.View;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Physics2DSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_19;

namespace AssetRipper.SourceGenerated.Extensions;

public static class Physics2DSettingsExtensions
{
	public static void ConvertToEditorFormat(this IPhysics2DSettings settings)
	{
		settings.AlwaysShowColliders = false;
		settings.ColliderAABBColor?.SetValues(1.0f, 1.0f, 0.0f, 0.2509804f);
		settings.ColliderAsleepColor?.SetValues(0.5686275f, 0.95686275f, 0.54509807f, 0.36078432f);
		settings.ColliderAwakeColor?.SetValues(0.5686275f, 0.95686275f, 0.54509807f, 0.7529412f);
		settings.ColliderContactColor?.SetValues(1.0f, 0.0f, 1.0f, 0.6862745f);
		settings.ContactArrowScale = 0.2f;
		settings.ShowColliderAABB = false;
		settings.ShowColliderContacts = false;
		settings.ShowColliderSleep = true;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/PhysicsJobOptions2DExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.PhysicsJobOptions2D;

namespace AssetRipper.SourceGenerated.Extensions;

public static class PhysicsJobOptions2DExtensions
{
	public static void SetToDefault(this IPhysicsJobOptions2D options)
	{
		options.UseMultithreading = false;
		options.UseConsistencySorting = false;
		options.InterpolationPosesPerJob = 100;
		options.NewContactsPerJob = 30;
		options.CollideContactsPerJob = 100;
		options.ClearFlagsPerJob = 200;
		options.ClearBodyForcesPerJob = 200;
		options.SyncDiscreteFixturesPerJob = 50;
		options.SyncContinuousFixturesPerJob = 50;
		options.FindNearestContactsPerJob = 100;
		options.UpdateTriggerContactsPerJob = 100;
		options.IslandSolverCostThreshold = 100;
		options.IslandSolverBodyCostScale = 1;
		options.IslandSolverContactCostScale = 10;
		options.IslandSolverJointCostScale = 10;
		options.IslandSolverBodiesPerJob = 50;
		options.IslandSolverContactsPerJob = 50;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/PhysicsManagerExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_55;

namespace AssetRipper.SourceGenerated.Extensions;

public static class PhysicsManagerExtensions
{
	public enum BroadphaseType
	{
		SweepAndPruneBroadphase = 0,
		MultiboxPruningBroadphase = 1,
	}
	public enum ContactPairsMode
	{
		DefaultContactPairs = 0,
		EnableKinematicKinematicPairs = 1,
		EnableKinematicStaticPairs = 2,
		EnableAllContactPairs = 3,
	}
	public enum ContactsGeneration
	{
		LegacyContactsGeneration = 0,
		PersistentContactManifold = 1,
	}
	public enum FrictionType
	{
		Patch = 0,
		OneDirectional = 1,
		TwoDirectional = 2,
	}
	public enum SolverType
	{
		ProjectedGaussSiedel = 0,
		TemporalGaussSiedel = 1,
	}
	public static ContactsGeneration GetContactsGeneration(this IPhysicsManager manager)
	{
		if (manager.Has_ContactsGeneration())
		{
			return (ContactsGeneration)manager.ContactsGeneration;
		}
		else
		{
			return manager.EnablePCM ? ContactsGeneration.PersistentContactManifold : ContactsGeneration.LegacyContactsGeneration;
		}
	}

	public static ContactPairsMode GetContactPairsMode(this IPhysicsManager manager)
	{
		return (ContactPairsMode)manager.ContactPairsMode;
	}

	public static BroadphaseType GetBroadphaseType(this IPhysicsManager manager)
	{
		return (BroadphaseType)manager.BroadphaseType;
	}

	public static FrictionType GetFrictionType(this IPhysicsManager manager)
	{
		return (FrictionType)manager.FrictionType;
	}

	public static SolverType GetSolverType(this IPhysicsManager manager)
	{
		return (SolverType)manager.SolverType;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/PlatformShaderDefinesExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader;
using AssetRipper.SourceGenerated.Subclasses.PlatformShaderDefines;

namespace AssetRipper.SourceGenerated.Extensions;

public static class PlatformShaderDefinesExtensions
{
	public static GPUPlatform GetSerializationMode(this IPlatformShaderDefines settings)
	{
		return (GPUPlatform)settings.ShaderPlatform;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/PluginImporterExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_1050;
using AssetRipper.SourceGenerated.Subclasses.PlatformSettingsData_Plugin;

namespace AssetRipper.SourceGenerated.Extensions;

public static class PluginImporterExtensions
{
	public static bool HasPlatformData(this IPluginImporter importer)
	{
		return importer.Has_PlatformData_AssetDictionary_AssetPair_Utf8String_Utf8String_PlatformSettingsData_Plugin()
			|| importer.Has_PlatformData_AssetDictionary_Utf8String_PlatformSettingsData_Plugin();
	}

	public static PlatformSettingsData_Plugin AddPlatformSettings(this IPluginImporter importer, Utf8String platformKey, Utf8String platformValue)
	{
		if (importer.Has_PlatformData_AssetDictionary_AssetPair_Utf8String_Utf8String_PlatformSettingsData_Plugin())
		{
			(AssetPair<Utf8String, Utf8String> pair, PlatformSettingsData_Plugin data)
				= importer.PlatformData_AssetDictionary_AssetPair_Utf8String_Utf8String_PlatformSettingsData_Plugin.AddNew();
			pair.Key = platformKey;
			pair.Value = platformValue;
			return data;
		}
		else if (importer.Has_PlatformData_AssetDictionary_Utf8String_PlatformSettingsData_Plugin())
		{
			AssetPair<Utf8String, PlatformSettingsData_Plugin> pair
				= importer.PlatformData_AssetDictionary_Utf8String_PlatformSettingsData_Plugin.AddNew();

			pair.Key = platformKey;
			return pair.Value;
		}
		else
		{
			throw new InvalidOperationException();
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/PrefabInstanceExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_18;
using AssetRipper.SourceGenerated.MarkerInterfaces;

namespace AssetRipper.SourceGenerated.Extensions;

public static class PrefabInstanceExtensions
{
	public static string GetName(this IPrefabInstance prefab)
	{
		string? name = prefab.RootGameObjectP?.Name;
		return string.IsNullOrEmpty(name) ? prefab.ClassName : name;
	}

	public static IGameObject GetRootGameObject(this IPrefabInstance prefab)
	{
		return prefab.RootGameObjectP ?? throw new ArgumentException("Prefab has no root GameObject.", nameof(prefab));
	}

	/// <summary>
	/// Sets the <see cref="IPrefabInstance"/> as the internal prefab for all <see cref="IEditorExtension"/>s in the hierarchy.
	/// </summary>
	/// <remarks>
	/// Prior to 2018.3, Prefab was an actual asset inside "*.prefab" files.
	/// </remarks>
	/// <param name="prefab"></param>
	public static void SetPrefabInternal(this IPrefabInstance prefab)
	{
		if (prefab is IPrefabMarker prefabMarker)
		{
			foreach (IEditorExtension editorExtension in prefab.GetRootGameObject().FetchHierarchy())
			{
				editorExtension.PrefabInternal_C18P = prefabMarker;
			}
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/PropertyNameExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.PropertyName;

namespace AssetRipper.SourceGenerated.Extensions;

public static class PropertyNameExtensions
{
	public static Utf8String GetIdString(this IPropertyName _this)
	{
		//When looking at decompiled games where ID is represented as a string, it seems to always be a serialized int.
		return _this.Has_Id_Int32() ? _this.Id_Int32.ToString() : _this.Id_Utf8String;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/QualitySettingExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.QualitySetting;

namespace AssetRipper.SourceGenerated.Extensions;

public static class QualitySettingExtensions
{
	public enum AntiAliasing
	{
		Disabled = 0,
		_2X = 2,
		_4X = 4,
		_8X = 8,
	}
	public enum ShadowCascades
	{
		NoCascades = 1,
		TwoCascades = 2,
		FourCascades = 4,
	}
	public enum TextureQuality
	{
		FullRes = 0,
		HalfRes = 1,
		QuarterRes = 2,
		EighthRes = 3,
	}
	public enum VSyncCount
	{
		DontSync = 0,
		EveryVBlank = 1,
		EverySecondVBlank = 2,
	}
	public static void ConvertToEditorFormat(this IQualitySetting setting)
	{
		setting.ShadowProjection = (int)ShadowProjection.StableFit;
		setting.ShadowNearPlaneOffset = 3.0f;
		setting.ShadowCascade2Split = 1.0f / 3.0f;
		setting.ShadowCascade4Split?.SetValues(2.0f / 30.0f, 0.2f, 14.0f / 30.0f);
		setting.StreamingMipmapsAddAllCameras = true;
		setting.StreamingMipmapsMemoryBudget = 512.0f;
		setting.StreamingMipmapsRenderersPerFrame = 512;
		setting.StreamingMipmapsMaxLevelReduction = 2;
		setting.StreamingMipmapsMaxFileIORequests = 1024;
		setting.AsyncUploadTimeSlice = 2;
		setting.AsyncUploadBufferSize = 4;
		setting.ResolutionScalingFixedDPIFactor = 1.0f;
	}

	public static ShadowQuality GetShadows(this IQualitySetting setting)
	{
		return (ShadowQuality)setting.Shadows;
	}

	public static ShadowResolution GetShadowResolution(this IQualitySetting setting)
	{
		return (ShadowResolution)setting.ShadowResolution;
	}

	public static ShadowProjection Get(this IQualitySetting setting)
	{
		return (ShadowProjection)setting.ShadowProjection;
	}

	public static ShadowCascades GetShadowCascades(this IQualitySetting setting)
	{
		return (ShadowCascades)setting.ShadowCascades;
	}

	public static ShadowmaskMode GetShadowmaskMode(this IQualitySetting setting)
	{
		return (ShadowmaskMode)setting.ShadowmaskMode;
	}

	public static SkinWeights GetSkinWeights(this IQualitySetting setting)
	{
		return (SkinWeights)(setting.Has_SkinWeights() ? setting.SkinWeights : setting.BlendWeights);
		//todo: merge BlendWeights into SkinWeights in the source generation
	}

	public static TextureQuality GetTextureQuality(this IQualitySetting setting)
	{
		return (TextureQuality)setting.TextureQuality;
	}

	public static AnisotropicFiltering GetAnisotropicTextures(this IQualitySetting setting)
	{
		return (AnisotropicFiltering)setting.AnisotropicTextures;
	}

	public static AntiAliasing GetAntiAliasing(this IQualitySetting setting)
	{
		return (AntiAliasing)setting.AntiAliasing;
	}

	public static VSyncCount GetVSyncCount(this IQualitySetting setting)
	{
		return (VSyncCount)setting.VSyncCount;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/QualitySettingsExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_47;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class QualitySettingsExtensions
{
	public static void ConvertToEditorFormat(this IQualitySettings settings)
	{
		settings.PerPlatformDefaultQuality?.SetDefaultPlatformQuality();
	}

	private static void SetDefaultPlatformQuality(this AssetDictionary<Utf8String, int> dictionary)
	{
		dictionary.Clear();
		dictionary.Capacity = 14;

		dictionary.Add(BuildTargetGroup.Android, QualityLevel.Simple);
		dictionary.Add(BuildTargetGroup.N3DS, QualityLevel.Fantastic);
		dictionary.Add(BuildTargetGroup.Switch, QualityLevel.Fantastic);
		dictionary.Add(BuildTargetGroup.PS4, QualityLevel.Fantastic);
		dictionary.Add(BuildTargetGroup.PSM, QualityLevel.Fantastic);
		dictionary.Add(BuildTargetGroup.PSP2, QualityLevel.Simple);
		dictionary.Add(BuildTargetGroup.Standalone, QualityLevel.Fantastic);
		dictionary.Add(BuildTargetGroup.Tizen, QualityLevel.Simple);
		dictionary.Add(BuildTargetGroup.WebGL, QualityLevel.Good);
		dictionary.Add(BuildTargetGroup.WiiU, QualityLevel.Fantastic);
		dictionary.Add(BuildTargetGroup.Metro, QualityLevel.Fantastic);
		dictionary.Add(BuildTargetGroup.XboxOne, QualityLevel.Fantastic);
		dictionary.Add(BuildTargetGroup.iOS, QualityLevel.Simple);
		dictionary.Add(BuildTargetGroup.tvOS, QualityLevel.Simple);
	}

	private static void Add(this AssetDictionary<Utf8String, int> dictionary, BuildTargetGroup buildTargetGroup, QualityLevel qualityLevel)
	{
		Utf8String str = buildTargetGroup.ToExportString();
		dictionary.Add(str, (int)qualityLevel);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/QuaternionCurveExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.QuaternionCurve;

namespace AssetRipper.SourceGenerated.Extensions;

public static class QuaternionCurveExtensions
{
	public static void SetValues(this IQuaternionCurve curve, string path)
	{
		curve.Path = path;
		curve.Curve.SetDefaultRotationOrderAndCurveLoopType();
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/QuaternionfExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.Quaternionf;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class QuaternionfExtensions
{
	public static Quaternion CastToStruct(this IQuaternionf vector)
	{
		return new Quaternion(vector.X, vector.Y, vector.Z, vector.W);
	}

	public static void CopyValues(this IQuaternionf vector, Quaternion source)
	{
		vector.X = source.X;
		vector.Y = source.Y;
		vector.Z = source.Z;
		vector.W = source.W;
	}

	public static void SetIdentity(this IQuaternionf vector) => vector.CopyValues(Quaternion.Identity);
}

```

`Source/AssetRipper.SourceGenerated.Extensions/RectfExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.Rectf;
using System.Drawing;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class RectfExtensions
{
	public static Vector2 Center(this IRectf rectangle) => new Vector2(rectangle.X + rectangle.Width / 2.0f, rectangle.Y + rectangle.Height / 2.0f);
	public static Vector2 Position(this IRectf rectangle) => new Vector2(rectangle.X, rectangle.Y);
	public static Vector2 Size(this IRectf rectangle) => new Vector2(rectangle.Width, rectangle.Height);
	public static RectangleF CastToStruct(this IRectf rectangle)
	{
		return new RectangleF(rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height);
	}
	public static void CopyValues(this IRectf rectangle, RectangleF source)
	{
		rectangle.SetValues(source.Height, source.Width, source.X, source.Y);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/RendererExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Enums;
using System.Diagnostics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class RendererExtensions
{
	public static string? FindMaterialPropertyNameByCRC28(this IRenderer renderer, uint crc)
	{
		foreach (IMaterial? material in renderer.Materials_C25P)
		{
			string? property = material?.FindPropertyNameByCRC28(crc);
			if (property is not null)
			{
				return property;
			}
		}
		return null;
	}

	/// <summary>
	/// Set <see cref="IGameObject.StaticEditorFlags"/> on <see cref="IRenderer.GameObject_C25P"/> to indicate that the object is static.
	/// </summary>
	/// <param name="renderer">The renderer attached to a static gameobject.</param>
	public static void MarkGameObjectAsStatic(this IRenderer renderer)
	{
		//https://github.com/AssetRipper/AssetRipper/issues/702
		IGameObject? gameObject = renderer.GameObject_C25P;
		if (gameObject is not null)
		{
			//When enabling Everything, Unity sets all bits even though it only uses the first 7 bits.
			//In the yaml, this appropriately uint.MaxValue
			//If ContributeGI is disabled, it does not set the reserved bits and displays 126 in the yaml.
			gameObject.StaticEditorFlags = uint.MaxValue;
		}
	}

	public static ShadowCastingMode GetShadowCastingMode(this IRenderer renderer)
	{
		return renderer.Has_CastShadows_C25_Byte()
			? (ShadowCastingMode)renderer.CastShadows_C25_Byte
			: renderer.CastShadows_C25_Boolean
				? ShadowCastingMode.On
				: ShadowCastingMode.Off;
	}

	public static MotionVectorGenerationMode GetMotionVectors(this IRenderer renderer)
	{
		return (MotionVectorGenerationMode)renderer.MotionVectors_C25;
	}

	public static LightProbeUsage GetLightProbeUsage(this IRenderer renderer)
	{
		return renderer.Has_LightProbeUsage_C25()
			? renderer.LightProbeUsage_C25E
			: renderer.UseLightProbes_C25
				? LightProbeUsage.BlendProbes
				: LightProbeUsage.Off;
	}

	public static ReflectionProbeUsage GetReflectionProbeUsage(this IRenderer renderer)
	{
		return renderer.Has_ReflectionProbeUsage_C25_Int32()
			? renderer.ReflectionProbeUsage_C25_Int32E
			: renderer.ReflectionProbeUsage_C25_ByteE;
	}

	public static ushort GetLightmapIndex(this IRenderer renderer)
	{
		if (renderer.Has_LightmapIndex_C25_UInt16())
		{
			return renderer.LightmapIndex_C25_UInt16;
		}
		else
		{
			Debug.Assert(renderer.Has_LightmapIndex_C25_Byte());
			byte value = renderer.LightmapIndex_C25_Byte;
			return value == byte.MaxValue ? ushort.MaxValue : value;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Rigidbody2DExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_50;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class Rigidbody2DExtensions
{
	public static RigidbodyType2D GetBodyType(this IRigidbody2D body)
	{
		if (body.Has_IsKinematic())
		{
			return body.IsKinematic ? RigidbodyType2D.Kinematic : RigidbodyType2D.Static;
		}
		else
		{
			return body.BodyTypeE;
		}
	}

	public static RigidbodyInterpolation2D GetInterpolate(this IRigidbody2D body)
	{
		if (body.Has_Interpolate_Byte())
		{
			return (RigidbodyInterpolation2D)body.Interpolate_Byte;
		}
		else
		{
			return (RigidbodyInterpolation2D)body.Interpolate_Int32;
		}
	}

	public static RigidbodySleepMode2D GetSleepingMode(this IRigidbody2D body)
	{
		if (body.Has_SleepingMode_Byte())
		{
			return (RigidbodySleepMode2D)body.SleepingMode_Byte;
		}
		else
		{
			return (RigidbodySleepMode2D)body.SleepingMode_Int32;
		}
	}

	public static CollisionDetectionMode2D GetCollisionDetection(this IRigidbody2D body)
	{
		if (body.Has_CollisionDetection_Byte())
		{
			return (CollisionDetectionMode2D)body.CollisionDetection_Byte;
		}
		else
		{
			return (CollisionDetectionMode2D)body.CollisionDetection_Int32;
		}
	}

	public static RigidbodyConstraints2D GetConstraints(this IRigidbody2D body)
	{
		if (body.Has_FixedAngle())
		{
			return body.FixedAngle ? RigidbodyConstraints2D.FreezeRotation : RigidbodyConstraints2D.None;
		}
		else
		{
			return body.ConstraintsE;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/RigidbodyExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_54;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class RigidbodyExtensions
{
	public static RigidbodyInterpolation GetInterpolate(this IRigidbody body)
	{
		return (RigidbodyInterpolation)body.Interpolate;
	}

	public static RigidbodyConstraints GetConstraints(this IRigidbody body)
	{
		//if (body.Has_FreezeRotation())
		{
			//return body.FreezeRotation ? RigidbodyConstraints.FreezeRotation : RigidbodyConstraints.None;
		}
		//else
		{
			return (RigidbodyConstraints)body.Constraints;
		}
	}

	public static CollisionDetectionMode GetCollisionDetection(this IRigidbody body)
	{
		return (CollisionDetectionMode)body.CollisionDetection;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/RuntimeAnimatorControllerExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_221;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Classes.ClassID_93;

namespace AssetRipper.SourceGenerated.Extensions;

public static class RuntimeAnimatorControllerExtensions
{
	public static bool ContainsAnimationClip(this IRuntimeAnimatorController controller, IAnimationClip clip)
	{
		return controller switch
		{
			IAnimatorController animatorController => animatorController.ContainsAnimationClip(clip),
			IAnimatorOverrideController overrideController => overrideController.ContainsAnimationClip(clip),
			_ => throw new Exception(GetExceptionMessage(controller))
		};

		static string GetExceptionMessage(IRuntimeAnimatorController controller)
		{
			return $"{controller.GetType()} inherits from {nameof(IRuntimeAnimatorController)} but not {nameof(IAnimatorController)} or {nameof(IAnimatorOverrideController)}";
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SerializedPassExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader;
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;
using AssetRipper.SourceGenerated.Subclasses.SerializedPass;
using AssetRipper.SourceGenerated.Subclasses.SerializedProgram;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SerializedPassExtensions
{
	public static SerializedPassType GetType_(this ISerializedPass pass)
	{
		return (SerializedPassType)pass.Type;
	}

	public static bool HasProgram(this ISerializedPass pass, ShaderType type)
	{
		return (pass.ProgramMask & type.ToProgramMask()) != 0;
	}

	public static IEnumerable<ISerializedProgram> GetPrograms(this ISerializedPass pass)
	{
		if (pass.HasProgram(ShaderType.Vertex))
		{
			yield return pass.ProgVertex;
		}
		if (pass.HasProgram(ShaderType.Fragment))
		{
			yield return pass.ProgFragment;
		}
		if (pass.HasProgram(ShaderType.Geometry))
		{
			yield return pass.ProgGeometry;
		}
		if (pass.HasProgram(ShaderType.Hull))
		{
			yield return pass.ProgHull;
		}
		if (pass.HasProgram(ShaderType.Domain))
		{
			yield return pass.ProgDomain;
		}
		if (pass.HasProgram(ShaderType.RayTracing) && pass.Has_ProgRayTracing())
		{
			yield return pass.ProgRayTracing;
		}
	}

	public static int MaxShaderModelVersion(this ISerializedPass pass, UnityVersion version)
	{
		int maxVersion = 0;
		foreach (ISerializedProgram program in pass.GetPrograms())
		{
			maxVersion = int.Max(maxVersion, program.MaxShaderModelVersion(version));
		}
		return maxVersion;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SerializedPlayerSubProgramExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.GpuProgramType;
using AssetRipper.SourceGenerated.Subclasses.SerializedPlayerSubProgram;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SerializedPlayerSubProgramExtensions
{
	public static ShaderGpuProgramType GetProgramType(this ISerializedPlayerSubProgram subProgram, UnityVersion version)
	{
		return ((ShaderGpuProgramType55)subProgram.GpuProgramType).ToGpuProgramType();
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SerializedProgramExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.GpuProgramType;
using AssetRipper.SourceGenerated.Subclasses.SerializedPlayerSubProgram;
using AssetRipper.SourceGenerated.Subclasses.SerializedProgram;
using AssetRipper.SourceGenerated.Subclasses.SerializedSubProgram;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SerializedProgramExtensions
{
	public static int GetTierCount(this ISerializedProgram program)
	{
		int tierCount = 1;
		if (program.Has_PlayerSubPrograms())
		{
			// where is tier in PlayerSubProgram?
		}
		else
		{
			int tier = program.SubPrograms[0].ShaderHardwareTier;
			for (int i = 1; i < program.SubPrograms.Count; i++)
			{
				if (program.SubPrograms[i].ShaderHardwareTier <= tier)
				{
					break;
				}

				tierCount++;
			}
		}

		return tierCount;
	}

	public static int GetSubProgramCount(this ISerializedProgram program)
	{
		return program.Has_PlayerSubPrograms() ? program.PlayerSubPrograms.Count : program.SubPrograms.Count;
	}

	public static IReadOnlyList<ISerializedPlayerSubProgram> GetPlayerSubPrograms(this ISerializedProgram program)
	{
		if (program.Has_PlayerSubPrograms())
		{
			for (int i = 0; i < program.PlayerSubPrograms.Count; i++)
			{
				if (program.PlayerSubPrograms[i].Count > 0)
				{
					return program.PlayerSubPrograms[i];
				}
			}
		}
		return [];
	}

	public static IReadOnlyList<uint> GetParameterBlobIndices(this ISerializedProgram program)
	{
		if (program.Has_ParameterBlobIndices())
		{
			for (int i = 0; i < program.ParameterBlobIndices.Count; i++)
			{
				if (program.ParameterBlobIndices[i].Count > 0)
				{
					return program.ParameterBlobIndices[i];
				}
			}
		}
		return [];
	}

	public static int MaxShaderModelVersion(this ISerializedProgram program, UnityVersion version)
	{
		int maxVersion = 0;
		if (program.Has_PlayerSubPrograms())
		{
			foreach (ISerializedPlayerSubProgram subProgram in program.GetPlayerSubPrograms())
			{
				maxVersion = int.Max(maxVersion, subProgram.GetProgramType(version).ToShaderModelVersion());
			}
		}
		else
		{
			foreach (ISerializedSubProgram subProgram in program.SubPrograms)
			{
				maxVersion = int.Max(maxVersion, subProgram.GetProgramType(version).ToShaderModelVersion());
			}
		}
		return maxVersion;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SerializedPropertyExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;
using AssetRipper.SourceGenerated.Subclasses.SerializedProperty;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SerializedPropertyExtensions
{
	public static SerializedPropertyType GetType_(this ISerializedProperty property)
	{
		return (SerializedPropertyType)property.Type;
	}

	public static SerializedPropertyFlag GetFlags(this ISerializedProperty property)
	{
		return (SerializedPropertyFlag)property.Flags;
	}

	public static string[] GetAttributes(this ISerializedProperty property)
	{
		List<string> attributes = new(property.Attributes.Count + 6);
		foreach (Utf8String attribute in property.Attributes)
		{
			attributes.Add(attribute.ToString());
		}
		SerializedPropertyFlag flags = property.GetFlags();
		if (flags.IsHideInInspector())
		{
			attributes.Add("HideInInspector");
		}
		if (flags.IsPerRendererData())
		{
			attributes.Add("PerRendererData");
		}
		if (flags.IsNoScaleOffset())
		{
			attributes.Add("NoScaleOffset");
		}
		if (flags.IsNormal())
		{
			attributes.Add("Normal");
		}
		if (flags.IsHDR())
		{
			attributes.Add("HDR");
		}
		if (flags.IsGamma())
		{
			attributes.Add("Gamma");
		}
		return attributes.ToArray();
	}

	public static string GetTypeString(this ISerializedProperty property) => property.GetType_() switch
	{
		SerializedPropertyType.Color => "Color",
		SerializedPropertyType.Vector => "Vector",
		SerializedPropertyType.Float => "Float",
		SerializedPropertyType.Range => $"{"Range"}({property.DefValue_1_.ToStringInvariant()}, {property.DefValue_2_.ToStringInvariant()})",
		SerializedPropertyType.Texture => property.DefTexture.TexDim switch
		{
			1 => "any",
			2 => "2D",
			3 => "3D",
			4 => "Cube",
			5 => "2DArray",
			6 => "CubeArray",
			_ => throw new NotSupportedException("Texture dimension isn't supported"),
		},
		SerializedPropertyType.Int => "Int",
		_ => throw new NotSupportedException($"Serialized property type {property.Type} isn't supported"),
	};

	public static string GetDefaultValue(this ISerializedProperty property)
	{
		switch (property.GetType_())
		{
			case SerializedPropertyType.Color:
			case SerializedPropertyType.Vector:
				string v0 = property.DefValue_0_.ToStringInvariant();
				string v1 = property.DefValue_1_.ToStringInvariant();
				string v2 = property.DefValue_2_.ToStringInvariant();
				string v3 = property.DefValue_3_.ToStringInvariant();
				return $"({v0},{v1},{v2},{v3})";

			case SerializedPropertyType.Float:
			case SerializedPropertyType.Range:
			case SerializedPropertyType.Int:
				return property.DefValue_0_.ToStringInvariant();

			case SerializedPropertyType.Texture:
				return $$"""
					"{{property.DefTexture.DefaultName}}" {}
					""";

			default:
				throw new NotSupportedException($"Serialized property type {property.Type} isn't supported");
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SerializedShaderFloatValueExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.SerializedShaderFloatValue;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SerializedShaderFloatValueExtensions
{
	public static bool IsZero(this ISerializedShaderFloatValue value) => value.Val == 0.0f;
	public static bool IsMax(this ISerializedShaderFloatValue value) => value.Val == 255.0f;
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SerializedShaderRTBlendStateExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;
using AssetRipper.SourceGenerated.Subclasses.SerializedShaderRTBlendState;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SerializedShaderRTBlendStateExtensions
{
	public static BlendMode SrcBlendValue(this ISerializedShaderRTBlendState state) => (BlendMode)state.SourceBlend.Val;
	public static BlendMode DestBlendValue(this ISerializedShaderRTBlendState state) => (BlendMode)state.DestinationBlend.Val;
	public static BlendMode SrcBlendAlphaValue(this ISerializedShaderRTBlendState state) => (BlendMode)state.SourceBlendAlpha.Val;
	public static BlendMode DestBlendAlphaValue(this ISerializedShaderRTBlendState state) => (BlendMode)state.DestinationBlendAlpha.Val;
	public static BlendOp BlendOpValue(this ISerializedShaderRTBlendState state) => (BlendOp)state.BlendOp.Val;
	public static BlendOp BlendOpAlphaValue(this ISerializedShaderRTBlendState state) => (BlendOp)state.BlendOpAlpha.Val;
	public static ColorWriteMask ColMaskValue(this ISerializedShaderRTBlendState state) => (ColorWriteMask)state.ColMask.Val;
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SerializedShaderStateExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;
using AssetRipper.SourceGenerated.Subclasses.SerializedShaderState;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SerializedShaderStateExtensions
{
	public static FogMode FogModeValue(this ISerializedShaderState state) => (FogMode)state.FogMode;
	public static ZClip ZClipValue(this ISerializedShaderState state) => (ZClip)(state.ZClip?.Val ?? 0);
	public static ZTest ZTestValue(this ISerializedShaderState state) => (ZTest)state.ZTest.Val;
	public static ZWrite ZWriteValue(this ISerializedShaderState state) => (ZWrite)state.ZWrite.Val;
	public static CullMode CullingValue(this ISerializedShaderState state) => (CullMode)state.Culling.Val;
	public static bool AlphaToMaskValue(this ISerializedShaderState state) => state.AlphaToMask.Val is not 0;
	public static bool ConservativeValue(this ISerializedShaderState state) => state.Conservative?.Val is not null and not 0;
	public static string LightingValue(this ISerializedShaderState state) => state.Lighting ? "On" : "Off";
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SerializedShaderVectorValueExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.SerializedShaderVectorValue;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SerializedShaderVectorValueExtensions
{
	public static bool IsZero(this ISerializedShaderVectorValue value)
	{
		return value.X.IsZero()
			&& value.Y.IsZero()
			&& value.Z.IsZero()
			&& value.W.IsZero();
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SerializedStencilOpExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.SerializedShader;
using AssetRipper.SourceGenerated.Subclasses.SerializedStencilOp;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SerializedStencilOpExtensions
{
	public static StencilOp PassValue(this ISerializedStencilOp stencilOp) => (StencilOp)stencilOp.Pass.Val;
	public static StencilOp FailValue(this ISerializedStencilOp stencilOp) => (StencilOp)stencilOp.Fail.Val;
	public static StencilOp ZFailValue(this ISerializedStencilOp stencilOp) => (StencilOp)stencilOp.ZFail.Val;
	public static StencilComp CompValue(this ISerializedStencilOp stencilOp) => (StencilComp)stencilOp.Comp.Val;
	public static bool IsDefault(this ISerializedStencilOp stencilOp)
	{
		return stencilOp.PassValue().IsKeep()
			&& stencilOp.FailValue().IsKeep()
			&& stencilOp.ZFailValue().IsKeep()
			&& stencilOp.CompValue().IsAlways();
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SerializedSubProgramExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.GpuProgramType;
using AssetRipper.SourceGenerated.Subclasses.SerializedSubProgram;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SerializedSubProgramExtensions
{
	public static ShaderGpuProgramType GetProgramType(this ISerializedSubProgram subProgram, UnityVersion version)
	{
		if (ShaderGpuProgramTypeExtensions.GpuProgramType55Relevant(version))
		{
			return ((ShaderGpuProgramType55)subProgram.GpuProgramType).ToGpuProgramType();
		}
		else
		{
			return ((ShaderGpuProgramType53)subProgram.GpuProgramType).ToGpuProgramType();
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ShaderBindChannelExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader;
using AssetRipper.SourceGenerated.Subclasses.ShaderBindChannel;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ShaderBindChannelExtensions
{
	public static VertexComponent GetTarget(this IShaderBindChannel channel)
	{
		return (VertexComponent)channel.Target;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ShaderErrorExtensions.cs`:

```cs
using AssetRipper.IO.Files;
using AssetRipper.SourceGenerated.Subclasses.ShaderError;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ShaderErrorExtensions
{
	public static BuildTarget GetCompilerPlatform(this IShaderError error)
	{
		return (BuildTarget)(uint)error.CompilerPlatform;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ShaderExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Extensions.Enums.Shader;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ShaderExtensions
{
	public static IEnumerable<GPUPlatform>? GetPlatforms(this IShader shader)
	{
		return shader.Platforms?.Select(p => unchecked((GPUPlatform)p));
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ShadowSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.ShadowSettings;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ShadowSettingsExtensions
{
	public static LightShadows GetLightmapBakeType(this IShadowSettings settings)
	{
		return (LightShadows)settings.Type;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/ShapeModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.ShapeModule;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ShapeModuleExtensions
{
	public enum PlacementMode
	{
		BoxVolume = 0,
		ConeBase = 0,
		MeshVertex = 0,
		BoxShell = 1,
		ConeVolume = 1,
		MeshEdge = 1,
		BoxEdge = 2,
		MeshTriangle = 2,
	}

	public static ParticleSystemShapeType GetShapeType(this IShapeModule module)
	{
		return (ParticleSystemShapeType)module.Type;
	}

	public static PlacementMode GetPlacementMode(this IShapeModule module)
	{
		return (PlacementMode)module.PlacementMode;
	}

	private static ParticleSystemShapeType GetExportType(this IShapeModule module)
	{
		if (module.Has_RadiusThickness())
		{
			return module.GetShapeType();
		}
		return module.GetShapeType() switch
		{
			ParticleSystemShapeType.SphereShell => ParticleSystemShapeType.Sphere,
			ParticleSystemShapeType.HemisphereShell => ParticleSystemShapeType.Hemisphere,
			ParticleSystemShapeType.ConeShell => ParticleSystemShapeType.Cone,
			ParticleSystemShapeType.ConeVolumeShell => ParticleSystemShapeType.ConeVolume,
			ParticleSystemShapeType.CircleEdge => ParticleSystemShapeType.Circle,
			_ => module.GetShapeType(),
		};
	}

	private static float GetExportRadiusThickness(this IShapeModule module)
	{
		if (module.Has_RadiusThickness())
		{
			return module.RadiusThickness;
		}

		switch (module.GetShapeType())
		{
			case ParticleSystemShapeType.SphereShell:
			case ParticleSystemShapeType.HemisphereShell:
			case ParticleSystemShapeType.ConeShell:
			case ParticleSystemShapeType.ConeVolumeShell:
			case ParticleSystemShapeType.CircleEdge:
				return 0.0f;

			default:
				return 1.0f;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SpriteAtlasDataExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.SpriteAtlasData;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SpriteAtlasDataExtensions
{
	extension(ISpriteAtlasData data)
	{
		public bool IsPacked => (data.SettingsRaw & 1) != 0;

		public SpritePackingMode PackingMode => (SpritePackingMode)(data.SettingsRaw >> 1 & 1);

		public SpritePackingRotation PackingRotation => (SpritePackingRotation)(data.SettingsRaw >> 2 & 0xF);

		public SpriteMeshType MeshType => (SpriteMeshType)(data.SettingsRaw >> 6 & 0x1);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SpriteAtlasExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_0;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Object;
using AssetRipper.SourceGenerated.Subclasses.SpriteAtlasEditorData;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SpriteAtlasExtensions
{
	public static void ConvertToEditorFormat(this ISpriteAtlas atlas)
	{
		ISpriteAtlasEditorData data = atlas.EditorData;

		data.TextureSettings.Initialize();
		data.PackingParameters?.Initialize();
		data.PackingSettings?.Initialize();
		data.VariantMultiplier = 1;
		data.BindAsDefault = true;

		data.Packables.Clear();
		data.Packables.Capacity = atlas.PackedSprites.Count;
		PPtrAccessList<PPtr_Object_5, IObject> packables = data.Packables.ToPPtrAccessList<PPtr_Object_5, IObject>(atlas.Collection);
		foreach (ISprite? sprite in atlas.PackedSpritesP)
		{
			packables.Add(sprite);
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SpriteBoneExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.SpriteBone;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SpriteBoneExtensions
{
	public static void CopyValues(this ISpriteBone destination, ISpriteBone source)
	{
		if (destination.Has_Color() && source.Has_Color())
		{
			destination.Color.CopyValues(source.Color);
		}
		if (destination.Has_Guid() && source.Has_Guid())
		{
			destination.Guid = source.Guid;
		}
		destination.Length = source.Length;
		destination.Name = source.Name;
		destination.ParentId = source.ParentId;
		destination.Position.CopyValues(source.Position);
		destination.Rotation.CopyValues(source.Rotation);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SpriteExtensions.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.SpriteAtlasData;
using System.Drawing;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SpriteExtensions
{
	/// <summary>
	/// Pure
	/// </summary>
	/// <param name="sprite"></param>
	/// <param name="atlas"></param>
	/// <param name="sAtlasRect"></param>
	/// <param name="sAtlasPivot"></param>
	/// <param name="sAtlasBorder"></param>
	public static void GetSpriteCoordinatesInAtlas(this ISprite sprite, ISpriteAtlas? atlas, out RectangleF sAtlasRect, out Vector2 sAtlasPivot, out Vector4 sAtlasBorder)
	{
		// sprite values are relative to original image (image, it was created from).
		// since atlas shuffle and crop sprite images, we need to recalculate those values.
		// if sprite doesn't belong to an atlas, consider its image as single sprite atlas

		Vector2 cropBotLeft;
		if (atlas is not null && sprite.Has_RenderDataKey() && atlas.RenderDataMap.TryGetValue(sprite.RenderDataKey, out ISpriteAtlasData? atlasData))
		{
			sAtlasRect = atlasData.TextureRect.CastToStruct();
			cropBotLeft = (Vector2)atlasData.TextureRectOffset;
		}
		else
		{
			sAtlasRect = sprite.RD.TextureRect.CastToStruct();
			cropBotLeft = (Vector2)sprite.RD.TextureRectOffset;
		}

		Vector2 sizeDelta = sprite.Rect.Size() - sAtlasRect.Size();
		Vector2 cropTopRight = new Vector2(sizeDelta.X - cropBotLeft.X, sizeDelta.Y - cropBotLeft.Y);

		Vector2 pivot;
		if (sprite.Has_Pivot())
		{
			pivot = (Vector2)sprite.Pivot;
		}
		else
		{
			Vector2 center = new Vector2(sprite.Rect.Size().X / 2.0f, sprite.Rect.Size().Y / 2.0f);
			Vector2 pivotOffset = center + (Vector2)sprite.Offset;
			pivot = new Vector2(pivotOffset.X / sprite.Rect.Size().X, pivotOffset.Y / sprite.Rect.Size().Y);
		}

		Vector2 pivotPosition = new Vector2(pivot.X * sprite.Rect.Size().X, pivot.Y * sprite.Rect.Size().Y);
		Vector2 aAtlasPivotPosition = pivotPosition - cropBotLeft;
		sAtlasPivot = new Vector2(aAtlasPivotPosition.X / sAtlasRect.Size().X, aAtlasPivotPosition.Y / sAtlasRect.Size().Y);

		if (sprite.Has_Border())
		{
			float borderL = sprite.Border.X == 0.0f ? 0.0f : sprite.Border.X - cropBotLeft.X;
			float borderB = sprite.Border.Y == 0.0f ? 0.0f : sprite.Border.Y - cropBotLeft.Y;
			float borderR = sprite.Border.Z == 0.0f ? 0.0f : sprite.Border.Z - cropTopRight.X;
			float borderT = sprite.Border.W == 0.0f ? 0.0f : sprite.Border.W - cropTopRight.Y;
			sAtlasBorder = new Vector4(borderL, borderB, borderR, borderT);
		}
		else
		{
			sAtlasBorder = default;
		}
	}

	public static ITexture2D? TryGetTexture(this ISprite sprite)
	{
		return sprite.RD.Texture.TryGetAsset(sprite.Collection);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SpriteMetaDataExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.SpriteAtlasData;
using AssetRipper.SourceGenerated.Subclasses.SpriteBone;
using AssetRipper.SourceGenerated.Subclasses.SpriteMetaData;
using AssetRipper.SourceGenerated.Subclasses.SpriteRenderData;
using AssetRipper.SourceGenerated.Subclasses.SpriteVertex;
using AssetRipper.SourceGenerated.Subclasses.SubMesh;
using AssetRipper.SourceGenerated.Subclasses.Vector2f;
using System.Buffers.Binary;
using System.Drawing;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SpriteMetaDataExtensions
{
	public static SpriteAlignment GetAlignment(this ISpriteMetaData data)
	{
		return (SpriteAlignment)data.Alignment;
	}

	public static void FillSpriteMetaData(this ISpriteMetaData instance, ISprite sprite, ISpriteAtlas? atlas)
	{
		sprite.GetSpriteCoordinatesInAtlas(atlas, out RectangleF rect, out Vector2 pivot, out Vector4 border);
		instance.Name = sprite.Name;
		instance.Rect.CopyValues(rect);
		instance.Alignment = (int)SpriteAlignment.Custom;
		instance.Pivot.CopyValues(pivot);
		instance.Border?.CopyValues(border);
		if (instance.Has_Outline())
		{
			GenerateOutline(sprite, atlas, rect, pivot, instance.Outline);
		}
		if (instance.Has_PhysicsShape() && sprite.Has_PhysicsShape())
		{
			GeneratePhysicsShape(sprite, atlas, rect, pivot, instance.PhysicsShape);
		}
		instance.TessellationDetail = 0;
		if (instance.Has_Bones() && sprite.Has_Bones() && instance.Has_SpriteID())
		{
			// Scale bones based off of the sprite's PPU
			foreach (ISpriteBone bone in sprite.Bones)
			{
				bone.Position.Scale(sprite.PixelsToUnits);
				bone.Length *= sprite.PixelsToUnits;

				// Set root bone position
				if (bone.ParentId == -1)
				{
					bone.Position.X += sprite.Rect.Width / 2;
					bone.Position.Y += sprite.Rect.Height / 2;
				}
			}

			instance.Bones.Clear();
			instance.Bones.Capacity = sprite.Bones.Count;
			foreach (ISpriteBone bone in sprite.Bones)
			{
				instance.Bones.AddNew().CopyValues(bone);
			}

			// NOTE: sprite ID is generated by sprite binary content, but we just generate a random value
			instance.SpriteID = Guid.NewGuid().ToString("N");

			instance.SetBoneGeometry(sprite);
		}
	}

	private static void SetBoneGeometry(this ISpriteMetaData instance, ISprite origin)
	{
		Vector3[]? vertices = null;
		BoneWeight4[]? skin = null;

		if (origin.RD.Has_VertexData())
		{
			VertexDataBlob.Create(origin.RD.VertexData, origin.Collection.Version, origin.Collection.EndianType).ReadData(
				out vertices,
				out Vector3[]? _,//normals,
				out Vector4[]? _,//tangents,
				out ColorFloat[]? _,//colors,
				out Vector2[]? _,//uv0,
				out Vector2[]? _,//uv1,
				out Vector2[]? _,//uv2,
				out Vector2[]? _,//uv3,
				out Vector2[]? _,//uv4,
				out Vector2[]? _,//uv5,
				out Vector2[]? _,//uv6,
				out Vector2[]? _,//uv7),
				out skin);
		}

		if (instance.Has_Vertices())
		{
			instance.Vertices.Clear();

			// Convert Vector3f into Vector2f
			if (vertices is null)
			{
				instance.Vertices.Capacity = 0;
			}
			else
			{
				instance.Vertices.Capacity = vertices.Length;
				for (int i = 0; i < vertices.Length; i++)
				{
					Vector2f vertex = instance.Vertices.AddNew();

					// Scale and translate vertices properly
					vertex.X = vertices[i].X * origin.PixelsToUnits + origin.Rect.Width / 2;
					vertex.Y = vertices[i].Y * origin.PixelsToUnits + origin.Rect.Height / 2;
				}
			}
		}

		if (instance.Has_Indices())
		{
			instance.Indices.Clear();
			if (origin.RD.Has_IndexBuffer() && origin.RD.IndexBuffer.Length != 0)
			{
				instance.Indices.Capacity = origin.RD.IndexBuffer.Length / 2;
				for (int i = 0, j = 0; i < origin.RD.IndexBuffer.Length / 2; i++, j += 2)
				{
					//Endianness might matter here
					instance.Indices.Add(BinaryPrimitives.ReadInt16LittleEndian(origin.RD.IndexBuffer.AsSpan(j, 2)));
				}
			}
		}

#warning TODO: SpriteConverter does not generate instance.Edges

		if (instance.Has_Weights())
		{
			instance.Weights.Clear();
			if (skin is not null)
			{
				instance.Weights.EnsureCapacity(skin.Length);
				for (int i = 0; i < skin.Length; i++)
				{
					instance.Weights.AddNew().CopyValues(skin[i]);
				}
			}
		}
	}

	private static void GeneratePhysicsShape(
		ISprite sprite,
		ISpriteAtlas? atlas,
		RectangleF rect,
		Vector2 pivot,
		AssetList<AssetList<Vector2f>> shape)
	{
		if (sprite.Has_PhysicsShape() && sprite.PhysicsShape.Count > 0)
		{
			shape.Clear();
			shape.Capacity = sprite.PhysicsShape.Count;
			float pivotShiftX = rect.Width * pivot.X - rect.Width * 0.5f;
			float pivotShiftY = rect.Height * pivot.Y - rect.Height * 0.5f;
			Vector2 pivotShift = new Vector2(pivotShiftX, pivotShiftY);
			for (int i = 0; i < sprite.PhysicsShape.Count; i++)
			{
				AssetList<Vector2f> sourceList = sprite.PhysicsShape[i];
				AssetList<Vector2f> targetList = shape.AddNew();
				targetList.Capacity = sourceList.Count;
				for (int j = 0; j < sprite.PhysicsShape[i].Count; j++)
				{
					Vector2 point = (Vector2)sourceList[j] * sprite.PixelsToUnits;
					targetList.AddNew().CopyValues(point + pivotShift);
				}
			}
			shape.FixRotation(sprite, atlas);
		}
	}

	private static void FixRotation(this AssetList<AssetList<Vector2f>> outlines, ISprite sprite, ISpriteAtlas? atlas)
	{
		GetPacking(sprite, atlas, out bool isPacked, out SpritePackingRotation rotation);

		if (isPacked)
		{
			switch (rotation)
			{
				case SpritePackingRotation.FlipHorizontal:
					{
						foreach (AssetList<Vector2f> outline in outlines)
						{
							for (int i = 0; i < outline.Count; i++)
							{
								Vector2f vertex = outline[i];
								outline[i].SetValues(-vertex.X, vertex.Y);
							}
						}
					}
					break;

				case SpritePackingRotation.FlipVertical:
					{
						foreach (AssetList<Vector2f> outline in outlines)
						{
							for (int i = 0; i < outline.Count; i++)
							{
								Vector2f vertex = outline[i];
								outline[i].SetValues(vertex.X, -vertex.Y);
							}
						}
					}
					break;

				case SpritePackingRotation.Rotate90:
					{
						foreach (AssetList<Vector2f> outline in outlines)
						{
							for (int i = 0; i < outline.Count; i++)
							{
								Vector2f vertex = outline[i];
								outline[i].SetValues(vertex.Y, vertex.X);
							}
						}
					}
					break;

				case SpritePackingRotation.Rotate180:
					{
						foreach (AssetList<Vector2f> outline in outlines)
						{
							for (int i = 0; i < outline.Count; i++)
							{
								Vector2f vertex = outline[i];
								outline[i].SetValues(-vertex.X, -vertex.Y);
							}
						}
					}
					break;
			}
		}
	}

	/// <summary>
	/// Pure
	/// </summary>
	/// <param name="sprite"></param>
	/// <param name="atlas"></param>
	/// <param name="isPacked"></param>
	/// <param name="rotation"></param>
	private static void GetPacking(ISprite sprite, ISpriteAtlas? atlas, out bool isPacked, out SpritePackingRotation rotation)
	{
		if (atlas is not null && sprite.Has_RenderDataKey() && atlas.RenderDataMap.TryGetValue(sprite.RenderDataKey, out ISpriteAtlasData? atlasData))
		{
			isPacked = atlasData.IsPacked;
			rotation = atlasData.PackingRotation;
		}
		else
		{
			isPacked = sprite.RD.IsPacked;
			rotation = sprite.RD.PackingRotation;
		}
	}

	private static void GenerateOutline(
		ISprite sprite,
		ISpriteAtlas? atlas,
		RectangleF rect,
		Vector2 pivot,
		AssetList<AssetList<Vector2f>> outlines)
	{
		GenerateOutline(sprite.RD, sprite.Collection.Version, outlines);
		float pivotShiftX = rect.Width * pivot.X - rect.Width * 0.5f;
		float pivotShiftY = rect.Height * pivot.Y - rect.Height * 0.5f;
		Vector2 pivotShift = new Vector2(pivotShiftX, pivotShiftY);
		foreach (AssetList<Vector2f> outline in outlines)
		{
			for (int i = 0; i < outline.Count; i++)
			{
				Vector2 point = (Vector2)outline[i] * sprite.PixelsToUnits;
				outline[i].CopyValues(point + pivotShift);
			}
		}
		outlines.FixRotation(sprite, atlas);
	}

	private static void GenerateOutline(
		ISpriteRenderData spriteRenderData,
		UnityVersion version,
		AssetList<AssetList<Vector2f>> outlines)
	{
		outlines.Clear();
		if (spriteRenderData.Has_VertexData() && spriteRenderData.SubMeshes!.Count != 0)
		{
			for (int i = 0; i < spriteRenderData.SubMeshes.Count; i++)
			{
				Vector3[] vertices = spriteRenderData.VertexData.GenerateVertices(version, spriteRenderData.SubMeshes[i]);
				List<Vector2[]> vectorArrayList = VertexDataToOutline(spriteRenderData.IndexBuffer, vertices, spriteRenderData.SubMeshes[i]);
				outlines.AddRanges(vectorArrayList);
			}
		}
		else if (spriteRenderData.Has_Vertices() && spriteRenderData.Vertices.Count != 0)
		{
			List<Vector2[]> vectorArrayList = VerticesToOutline(spriteRenderData.Vertices, spriteRenderData.Indices);
			outlines.Capacity = vectorArrayList.Count;
			outlines.AddRanges(vectorArrayList);
		}
	}

	private static List<Vector2[]> VerticesToOutline(AccessListBase<ISpriteVertex> spriteVertexList, AssetList<ushort> spriteIndexArray)
	{
		Vector3[] vertices = new Vector3[spriteVertexList.Count];
		for (int i = 0; i < vertices.Length; i++)
		{
			vertices[i] = spriteVertexList[i].Pos;
		}

		Vector3i[] triangles = new Vector3i[spriteIndexArray.Count / 3];
		for (int i = 0, j = 0; i < triangles.Length; i++)
		{
			int x = spriteIndexArray[j++];
			int y = spriteIndexArray[j++];
			int z = spriteIndexArray[j++];
			triangles[i] = new Vector3i(x, y, z);
		}

		return new MeshOutlineGenerator(vertices, triangles).GenerateOutlines();
	}

	private static List<Vector2[]> VertexDataToOutline(ReadOnlySpan<byte> indexBuffer, Vector3[] vertices, ISubMesh submesh)
	{
		Vector3i[] triangles = new Vector3i[submesh.IndexCount / 3];
		for (int o = (int)submesh.FirstByte, ti = 0; ti < triangles.Length; o += 3 * sizeof(ushort), ti++)
		{
			ushort x = BinaryPrimitives.ReadUInt16LittleEndian(indexBuffer[o..]);
			ushort y = BinaryPrimitives.ReadUInt16LittleEndian(indexBuffer[(o + sizeof(ushort))..]);
			ushort z = BinaryPrimitives.ReadUInt16LittleEndian(indexBuffer[(o + 2 * sizeof(ushort))..]);
			triangles[ti] = new Vector3i(x, y, z);
		}

		return new MeshOutlineGenerator(vertices, triangles).GenerateOutlines();
	}

	private static void AddRanges(this AssetList<AssetList<Vector2f>> instance, List<Vector2[]> vectorArrayList)
	{
		foreach (Vector2[] vectorArray in vectorArrayList)
		{
			AssetList<Vector2f> assetList = instance.AddNew();
			assetList.Capacity = vectorArray.Length;
			foreach (Vector2 v in vectorArray)
			{
				assetList.AddNew().CopyValues(v);
			}
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SpriteRenderDataExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.SpriteRenderData;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SpriteRenderDataExtensions
{
	extension(ISpriteRenderData data)
	{
		public bool IsPacked => (data.SettingsRaw & 1) != 0;

		public SpritePackingMode PackingMode => (SpritePackingMode)(data.SettingsRaw >> 1 & 1);

		public SpritePackingRotation PackingRotation => (SpritePackingRotation)(data.SettingsRaw >> 2 & 0xF);

		public SpriteMeshType MeshType => (SpriteMeshType)(data.SettingsRaw >> 6 & 0x1);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SpriteRendererExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_212;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SpriteRendererExtensions
{
	public static SpriteTileMode GetTileMode(this ISpriteRenderer renderer)
	{
		return (SpriteTileMode)renderer.SpriteTileMode;
	}

	public static void SetTileMode(this ISpriteRenderer renderer, SpriteTileMode tileMode)
	{
		renderer.SpriteTileMode = (int)tileMode;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SpriteSheetMetaDataExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Subclasses.BoneWeights4;
using AssetRipper.SourceGenerated.Subclasses.SpriteBone;
using AssetRipper.SourceGenerated.Subclasses.SpriteMetaData;
using AssetRipper.SourceGenerated.Subclasses.SpriteSheetMetaData;
using AssetRipper.SourceGenerated.Subclasses.Vector2f;
using AssetRipper.SourceGenerated.Subclasses.Vector2Int;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SpriteSheetMetaDataExtensions
{
	public static ISpriteMetaData GetSpriteMetaData(this ISpriteSheetMetaData data, Utf8String name)
	{
		for (int i = 0; i < data.Sprites.Count; i++)
		{
			if (data.Sprites[i].Name == name)
			{
				return data.Sprites[i];
			}
		}
		throw new ArgumentException($"There is no sprite metadata with name {name}", nameof(name));
	}

	public static void CopyFromSpriteMetaData(this ISpriteSheetMetaData instance, ISpriteMetaData spriteMetaData)
	{
		if (instance.Has_Outline() && spriteMetaData.Has_Outline())
		{
			instance.Outline.CopyValues(spriteMetaData.Outline);
		}
		if (instance.Has_PhysicsShape() && spriteMetaData.Has_PhysicsShape())
		{
			instance.PhysicsShape.Clear();
			instance.PhysicsShape.CopyValues(spriteMetaData.PhysicsShape);
		}
		if (instance.Has_Bones() && spriteMetaData.Has_Bones())
		{
			instance.Bones.Clear();
			instance.Bones.Capacity = spriteMetaData.Bones.Count;
			foreach (ISpriteBone bone in spriteMetaData.Bones)
			{
				instance.Bones.AddNew().CopyValues(bone);
			}
		}
		if (instance.Has_SpriteID() && spriteMetaData.Has_SpriteID())
		{
			instance.SpriteID = spriteMetaData.SpriteID;
		}
		if (instance.Has_Vertices() && spriteMetaData.Has_Vertices())
		{
			instance.Vertices.Clear();
			instance.Vertices.Capacity = spriteMetaData.Vertices.Count;
			foreach (Vector2f vertex in spriteMetaData.Vertices)
			{
				instance.Vertices.AddNew().CopyValues(vertex);
			}
		}
		if (instance.Has_Indices() && spriteMetaData.Has_Indices())
		{
			instance.Indices.Clear();
			instance.Indices.Capacity = spriteMetaData.Indices.Count;
			foreach (int index in spriteMetaData.Indices)
			{
				instance.Indices.Add(index);
			}
		}
		if (instance.Has_Edges() && spriteMetaData.Has_Edges())
		{
			instance.Edges.Clear();
			instance.Edges.Capacity = spriteMetaData.Edges.Count;
			foreach (Vector2Int edge in spriteMetaData.Edges)
			{
				instance.Edges.AddNew().CopyValues(edge);
			}
		}
		if (instance.Has_Weights() && spriteMetaData.Has_Weights())
		{
			instance.Weights.Clear();
			instance.Weights.Capacity = spriteMetaData.Weights.Count;
			foreach (IBoneWeights4 weight in spriteMetaData.Weights)
			{
				instance.Weights.AddNew().CopyValues(weight);
			}
		}
	}

	private static void CopyValues(this AssetList<AssetList<Vector2f>> target, AssetList<AssetList<Vector2f>> source)
	{
		target.Clear();
		target.Capacity = source.Count;
		foreach (AssetList<Vector2f> sourceList in source)
		{
			AssetList<Vector2f> targetList = target.AddNew();
			targetList.Capacity = sourceList.Count;
			foreach (Vector2f item in sourceList)
			{
				targetList.AddNew().CopyValues(item);
			}
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/StateBehavioursPairExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Subclasses.PPtr_MonoBehaviour;
using AssetRipper.SourceGenerated.Subclasses.StateBehavioursPair;

namespace AssetRipper.SourceGenerated.Extensions;

public static class StateBehavioursPairExtensions
{
	public static void SetValues(this IStateBehavioursPair pair, IAnimatorController controller, IAnimatorState state, IMonoBehaviour?[] behaviours)
	{
		if (state == null)
		{
			throw new ArgumentNullException(nameof(state));
		}
		if (behaviours == null || behaviours.Length == 0)
		{
			throw new ArgumentNullException(nameof(behaviours));
		}

		pair.State.SetAsset(controller.Collection, state);

		pair.StateMachineBehaviours.Clear();
		pair.StateMachineBehaviours.Capacity = behaviours.Length;
		new PPtrAccessList<PPtr_MonoBehaviour_5, IMonoBehaviour>(pair.StateMachineBehaviours, controller.Collection).AddRange(behaviours);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/StateConstantExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Subclasses.BlendTreeConstant;
using AssetRipper.SourceGenerated.Subclasses.StateConstant;

namespace AssetRipper.SourceGenerated.Extensions;

public static class StateConstantExtensions
{
	public static bool IsBlendTree(this IStateConstant stateConstant)
	{
		if (stateConstant.BlendTreeConstantArray.Count == 0)
		{
			return false;
		}
		return stateConstant.GetBlendTree().NodeArray.Count > 1;
	}

	public static IBlendTreeConstant GetBlendTree(this IStateConstant stateConstant)
	{
		return stateConstant.BlendTreeConstantArray[0].Data;
	}

	public static bool GetWriteDefaultValues(this IStateConstant stateConstant)
	{
		return !stateConstant.Has_WriteDefaultValues() || stateConstant.WriteDefaultValues;
	}

	public static uint GetId(this IStateConstant stateConstant)
	{
		if (stateConstant.Has_FullPathID())
		{
			return stateConstant.FullPathID;
		}
		else if (stateConstant.Has_PathID())
		{
			return stateConstant.PathID;
		}
		else
		{
			return stateConstant.ID;
		}
	}

	public static Utf8String GetName(this IStateConstant stateConstant, AssetDictionary<uint, Utf8String> tos)
	{
		if (stateConstant.Has_NameID())
		{
			return tos[stateConstant.NameID];
		}

		// ParentStateMachineName.StateName
		// Periods are used for concatenating State and StateMachine Names to get their paths.
		// Unity Editor doesn't allow periods in State and StateMachine Names.
		Utf8String _statePath = tos[stateConstant.ID];
		string statePath = _statePath.String;
		int pathDelimiterPos = statePath.IndexOf('.');
		if (pathDelimiterPos != -1 && pathDelimiterPos + 1 < statePath.Length)
		{
			return new Utf8String(statePath[(pathDelimiterPos + 1)..]);
		}

		return _statePath;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/StateMachineConstantExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.SelectorStateConstant;
using AssetRipper.SourceGenerated.Subclasses.StateMachineConstant;

namespace AssetRipper.SourceGenerated.Extensions;

public static class StateMachineConstantExtensions
{
	public static int StateMachineCount(this IStateMachineConstant stateMachineConstant)
	{
		if (!stateMachineConstant.Has_SelectorStateConstantArray())
		{
			// not needed for Unity 4.x- SubStateMachine reconstruction
			return 0;
		}

		// SelectorStateConstantArray contains Entry and Exit points for StateMachines
		// SelectorStateConstantArray = [Entry1, Exit1, Entry2, Exit2, ...]
		// just in case, next code handles StateMachine missing Entry or Exit SelectorStateConstant
		int stateMachineCount = 0;
		uint? lastFullPathID = null;
		foreach (SelectorStateConstant ssc in stateMachineConstant.SelectorStateConstantArray)
		{
			if (lastFullPathID != ssc.FullPathID)
			{
				lastFullPathID = ssc.FullPathID;
				stateMachineCount++;
			}
		}
		return stateMachineCount;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/StateMotionPairExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_207;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Subclasses.StateMotionPair;

namespace AssetRipper.SourceGenerated.Extensions;

public static class StateMotionPairExtensions
{
	public static void SetValues(this IStateMotionPair pair, IAnimatorController controller, IAnimatorState state, IMotion motion)
	{
		if (state == null)
		{
			throw new ArgumentNullException(nameof(state));
		}
		if (motion == null)
		{
			throw new ArgumentNullException(nameof(motion));
		}
		pair.State.SetAsset(controller.Collection, state);
		pair.Motion.SetAsset(controller.Collection, motion);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/StaticBatchInfoExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.StaticBatchInfo;

namespace AssetRipper.SourceGenerated.Extensions;

public static class StaticBatchInfoExtensions
{
	public static void Initialize(this IStaticBatchInfo staticBatchInfo, uint[] subsetIndices)
	{
		if (subsetIndices.Length == 0)
		{
			staticBatchInfo.FirstSubMesh = 0;
			staticBatchInfo.SubMeshCount = 0;
		}
		else
		{
			staticBatchInfo.FirstSubMesh = (ushort)subsetIndices[0];
			staticBatchInfo.SubMeshCount = (ushort)subsetIndices.Length;
			for (int i = 0, j = staticBatchInfo.FirstSubMesh; i < staticBatchInfo.SubMeshCount; i++, j++)
			{
				if (subsetIndices[i] != j)
				{
					throw new Exception("Can't create static batch info from subset indices");
				}
			}
		}
	}

	public static bool IsDefault(this IStaticBatchInfo staticBatchInfo)
	{
		return staticBatchInfo.FirstSubMesh == 0 && staticBatchInfo.SubMeshCount == 0;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/StreamInfoExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.ShaderChannel;
using AssetRipper.SourceGenerated.Subclasses.StreamInfo;

namespace AssetRipper.SourceGenerated.Extensions;

public static class StreamInfoExtensions
{
	public static uint GetStride(this IStreamInfo streamInfo)
	{
		return streamInfo.Has_Stride_UInt32() ? streamInfo.Stride_UInt32 : streamInfo.Stride_Byte;
	}

	public static void SetStride(this IStreamInfo streamInfo, uint stride)
	{
		if (streamInfo.Has_Stride_Byte())
		{
			streamInfo.Stride_Byte = (byte)stride;
		}
		else
		{
			streamInfo.Stride_UInt32 = stride;
		}
	}

	public static void SetValues(this IStreamInfo streamInfo, uint mask, uint offset, uint stride)
	{
		streamInfo.ChannelMask = mask;
		streamInfo.Offset = offset;
		streamInfo.SetStride(stride);
		streamInfo.Align = 0;
		streamInfo.DividerOp = 0;
		streamInfo.Frequency = 0;
	}

	public static bool IsMatch(this IStreamInfo streamInfo, ShaderChannel4 channel)
	{
		return (streamInfo.ChannelMask & 1 << (int)channel) != 0;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/StreamedClipExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.StreamedClip;

namespace AssetRipper.SourceGenerated.Extensions;

public static class StreamedClipExtensions
{
	public static bool IsSet(this IStreamedClip clip) => clip.Data.Count > 0;

	public static int CurveCount(this IStreamedClip clip)
	{
		return clip.Has_CurveCount_UInt32() ? (int)clip.CurveCount_UInt32 : clip.CurveCount_UInt16 + clip.DiscreteCurveCount;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/StreamedResourceExtensions.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.SourceGenerated.Subclasses.StreamedResource;

namespace AssetRipper.SourceGenerated.Extensions;

public static class StreamedResourceExtensions
{
	internal static bool CheckIntegrity(Utf8String? path, ulong offset, ulong size, AssetCollection collection)
	{
		if (Utf8String.IsNullOrEmpty(path))
		{
			return true;
		}

		if (offset > long.MaxValue || size > long.MaxValue || offset + size > long.MaxValue)
		{
			return false;
		}

		if (size == 0)
		{
			// Data might be read by its type for this verison, so we can't even export raw data.
			return false;
		}

		ResourceFile? file = collection.Bundle.ResolveResource(path.String);
		if (file == null)
		{
			return false;
		}

		return file.Stream.Length >= unchecked((long)(offset + size));
	}

	internal static byte[]? GetContent(Utf8String? path, ulong offset, ulong size, AssetCollection collection)
	{
		if (Utf8String.IsNullOrEmpty(path))
		{
			return null;
		}

		if (offset > long.MaxValue || size > long.MaxValue || offset + size > long.MaxValue)
		{
			return null;
		}

		if (size == 0)
		{
			// Data might be read by its type for this verison, so we can't even export raw data.
			return null;
		}

		ResourceFile? file = collection.Bundle.ResolveResource(path.String);
		if (file == null || file.Stream.Length < unchecked((long)(offset + size)))
		{
			return null;
		}

		byte[] data = new byte[size];
		file.Stream.Position = (long)offset;
		file.Stream.ReadExactly(data);
		return data;
	}

	public static bool CheckIntegrity(this IStreamedResource streamedResource, AssetCollection collection)
	{
		return CheckIntegrity(streamedResource.Source, streamedResource.Offset, streamedResource.Size, collection);
	}

	public static byte[]? GetContent(this IStreamedResource streamedResource, AssetCollection file)
	{
		return GetContent(streamedResource.Source, streamedResource.Offset, streamedResource.Size, file);
	}

	public static bool TryGetContent(this IStreamedResource streamedResource, AssetCollection file, [NotNullWhen(true)] out byte[]? data)
	{
		data = streamedResource.GetContent(file);
		return !data.IsNullOrEmpty();
	}

	public static bool IsSet(this IStreamedResource streamedResource) => !Utf8String.IsNullOrEmpty(streamedResource.Source);
}

```

`Source/AssetRipper.SourceGenerated.Extensions/StreamingInfoExtensions.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.SourceGenerated.Subclasses.StreamingInfo;

namespace AssetRipper.SourceGenerated.Extensions;

public static class StreamingInfoExtensions
{
	public static bool IsSet(this IStreamingInfo streamingInfo) => streamingInfo.Path.Data.Length > 0;

	public static bool CheckIntegrity(this IStreamingInfo streamingInfo, AssetCollection file)
	{
		return StreamedResourceExtensions.CheckIntegrity(streamingInfo.Path, streamingInfo.GetOffset(), streamingInfo.Size, file);
	}

	public static byte[] GetContent(this IStreamingInfo streamingInfo, AssetCollection file)
	{
		return StreamedResourceExtensions.GetContent(streamingInfo.Path, streamingInfo.GetOffset(), streamingInfo.Size, file) ?? [];
	}

	public static ulong GetOffset(this IStreamingInfo streamingInfo)
	{
		return streamingInfo.Has_Offset_UInt64() ? streamingInfo.Offset_UInt64 : streamingInfo.Offset_UInt32;
	}

	public static void SetOffset(this IStreamingInfo streamingInfo, ulong value)
	{
		if (streamingInfo.Has_Offset_UInt64())
		{
			streamingInfo.Offset_UInt64 = value;
		}
		else
		{
			streamingInfo.Offset_UInt32 = (uint)value;
		}
	}

	public static void CopyValues(this IStreamingInfo destination, IStreamingInfo source)
	{
		destination.SetOffset(source.GetOffset());
		destination.Size = source.Size;
		destination.Path = source.Path;
	}

	public static void ClearValues(this IStreamingInfo streamingInfo)
	{
		streamingInfo.Offset_UInt32 = default;
		streamingInfo.Offset_UInt64 = default;
		streamingInfo.Path = Utf8String.Empty;
		streamingInfo.Size = default;
	}

	public static void GetValues(this IStreamingInfo streamingInfo, out Utf8String path, out ulong offset, out uint size)
	{
		path = streamingInfo.Path;
		offset = streamingInfo.GetOffset();
		size = streamingInfo.Size;
	}

	public static void SetValues(this IStreamingInfo streamingInfo, Utf8String path, ulong offset, uint size)
	{
		streamingInfo.Path = path;
		streamingInfo.SetOffset(offset);
		streamingInfo.Size = size;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SubEmitterDataExtensions.cs`:

```cs
using AssetRipper.Assets.Collections;
using AssetRipper.SourceGenerated.Classes.ClassID_198;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.SubEmitterData;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SubEmitterDataExtensions
{
	public static void SetValues(this ISubEmitterData data, ParticleSystemSubEmitterType type, IParticleSystem emitter, AssetCollection collection)
	{
		data.Emitter.SetAsset(collection, emitter);
		data.Type = (int)type;
		data.Properties = (int)ParticleSystemSubEmitterProperties.InheritNothing;
		data.EmitProbability = 1.0f;
	}

	public static ParticleSystemSubEmitterType GetSubEmitterType(this ISubEmitterData data)
	{
		return (ParticleSystemSubEmitterType)data.Type;
	}

	public static ParticleSystemSubEmitterProperties GetProperties(this ISubEmitterData data)
	{
		return (ParticleSystemSubEmitterProperties)data.Properties;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SubMeshData.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.SubMesh;

namespace AssetRipper.SourceGenerated.Extensions;

/// <summary>
/// 
/// </summary>
/// <param name="BaseVertex"></param>
/// <param name="FirstIndex">Offset in the index buffer.</param>
/// <param name="FirstVertex">Offset in the vertex list.</param>
/// <param name="IndexCount"></param>
/// <param name="TriangleCount"></param>
/// <param name="VertexCount"></param>
/// <param name="Topology"></param>
/// <param name="LocalBounds"></param>
public record struct SubMeshData(
	uint BaseVertex,
	int FirstIndex,
	int FirstVertex,
	int IndexCount,
	int TriangleCount,
	int VertexCount,
	MeshTopology Topology,
	Bounds LocalBounds)
{
	public static SubMeshData Create(ISubMesh subMesh, IndexFormat indexFormat)
	{
		return new SubMeshData(
			subMesh.BaseVertex,
			(int)subMesh.FirstByte / indexFormat.Size,
			(int)subMesh.FirstVertex,
			(int)subMesh.IndexCount,
			(int)subMesh.TriangleCount,
			(int)subMesh.VertexCount,
			subMesh.GetTopology(),
			subMesh.LocalAABB);
	}

	public static SubMeshData[] Create(IMesh mesh)
	{
		AccessListBase<ISubMesh> list = mesh.SubMeshes;
		if (list.Count == 0)
		{
			return [];
		}
		else
		{
			SubMeshData[] array = new SubMeshData[list.Count];
			for (int i = 0; i < list.Count; i++)
			{
				array[i] = Create(list[i], mesh.IndexFormatE);
			}
			return array;
		}
	}

	public readonly void CopyTo(ISubMesh destination, IndexFormat indexFormat)
	{
		destination.BaseVertex = BaseVertex;
		destination.FirstByte = (uint)(FirstIndex * indexFormat.Size);
		destination.FirstVertex = (uint)FirstVertex;
		destination.IndexCount = (uint)IndexCount;
		destination.TriangleCount = (uint)TriangleCount;
		destination.VertexCount = (uint)VertexCount;
		destination.SetTopology(Topology);
		LocalBounds.CopyTo(destination.LocalAABB);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SubMeshExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.SubMesh;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SubMeshExtensions
{
	extension(ISubMesh subMesh)
	{
		/// <summary>
		/// For versions &lt; 4, IsTriStrip is used here instead.<br/>
		/// For it, 0 cooresponds to <see cref="MeshTopology.Triangles"/>,<br/>
		/// and non-zero cooresponds to <see cref="MeshTopology.TriangleStrip"/>.<br/>
		/// This conveniently matches the <see cref="MeshTopology"/> enumeration.
		/// </summary>
		public MeshTopology GetTopology()
		{
			if (subMesh.Has_Topology())
			{
				return subMesh.TopologyE;
			}
			else
			{
				// https://github.com/AssetRipper/AssetRipper/issues/1759
				return subMesh.IsTriStrip != 0 ? MeshTopology.TriangleStrip : MeshTopology.Triangles;
			}
		}

		public void SetTopology(MeshTopology topology)
		{
			if (subMesh.Has_Topology())
			{
				subMesh.TopologyE = topology;
			}
			else
			{
				subMesh.IsTriStripE = topology;
			}
		}

		public uint GetFirstIndex(bool is16BitIndices)
		{
			return is16BitIndices ? subMesh.FirstByte / sizeof(ushort) : subMesh.FirstByte / sizeof(uint);
		}

		public void SetFirstIndex(bool is16BitIndices, uint firstIndex)
		{
			subMesh.FirstByte = is16BitIndices ? firstIndex * sizeof(ushort) : firstIndex * sizeof(uint);
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/SwitchSwizzle.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Enums;
using System.Diagnostics;
using System.Drawing;

namespace AssetRipper.SourceGenerated.Extensions;

public static class SwitchSwizzle
{
	private const int GobXTexelCount = 4;
	private const int GobYTexelCount = 8;
	private const int TexelByteSize = 16;

	/// <summary>
	/// In this case, "block" refers to a compressed texture block, not a gob one.
	/// </summary>
	private const int BlocksInGob = GobXTexelCount * GobYTexelCount;

	private static readonly int[] GobXPoses =
	[
		0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3
	];

	private static readonly int[] GobYPoses =
	[
		0, 1, 0, 1, 2, 3, 2, 3, 4, 5, 4, 5, 6, 7, 6, 7, 0, 1, 0, 1, 2, 3, 2, 3, 4, 5, 4, 5, 6, 7, 6, 7
	];

	/// <summary>
	/// Calculates the smallest integer greater than or equal to the result of dividing two integers.
	/// </summary>
	/// <param name="a">The dividend to be divided.</param>
	/// <param name="b">The divisor by which to divide. Must not be zero.</param>
	/// <returns>The smallest integer greater than or equal to <paramref name="a"/> divided by <paramref name="b"/>.</returns>
	private static int CeilDivide(int a, int b)
	{
		return (a + b - 1) / b;
	}

	public static byte[] Unswizzle(ITexture2D texture, byte[] data)
	{
		if (texture.ImageCount_C28 != 1)
		{
			return data;
		}

		TextureFormat realFormat = GetCorrectedSwitchTextureFormat(texture.Format_C28E);

		// Format is unsupported, we back out
		if (GetBlockDimensions(realFormat) is not { } blockDimensions)
		{
			return data;
		}

		int blockByteSize = GetBlockSize(realFormat);

		Debug.Assert(TexelByteSize % blockByteSize == 0, "Texel size should be a multiple of block size.");
		int blocksPerTexel = TexelByteSize / blockByteSize;

		Debug.Assert(blocksPerTexel > 0);
		Size texelDimensions = new(blockDimensions.Width * blocksPerTexel, blockDimensions.Height);

		byte[] newData = new byte[data.Length];

		Debug.Assert(texture.PlatformBlob_C28 is not null && texture.PlatformBlob_C28.Length >= 12);
		int texelHeight = GetTexelHeightByPlatformBlob(texture.PlatformBlob_C28, texture.Collection.EndianType);

		Size paddedDimensions = GetPaddedTextureDimensions(texture.Width_C28, texture.Height_C28, texelDimensions.Width, texelDimensions.Height, texelHeight);

		int texelCountX = CeilDivide(paddedDimensions.Width, texelDimensions.Width);
		int texelCountY = CeilDivide(paddedDimensions.Height, texelDimensions.Height);

		int gobCountX = texelCountX / GobXTexelCount;
		int gobCountY = texelCountY / GobYTexelCount;

		int srcPos = 0;
		for (int i = 0; i < gobCountY / texelHeight; i++)
		{
			for (int j = 0; j < gobCountX; j++)
			{
				for (int k = 0; k < texelHeight; k++)
				{
					for (int l = 0; l < BlocksInGob; l++)
					{
						int gobX = GobXPoses[l];
						int gobY = GobYPoses[l];
						int gobDstX = j * GobXTexelCount + gobX;
						int gobDstY = (i * texelHeight + k) * GobYTexelCount + gobY;
						int gobDstLinPos = gobDstY * texelCountX * TexelByteSize + gobDstX * TexelByteSize;

						data.AsSpan(srcPos, TexelByteSize).CopyTo(newData.AsSpan(gobDstLinPos, TexelByteSize));

						srcPos += TexelByteSize;
					}
				}
			}
		}

		// We need to remove padding from the data now, so that it matches the expected layout for later decoding.
		// The resulting arrays will have extra unused data at the end, but we need to leave it there
		// because TextureConverter expects the data to be at least texture.CompleteImageSize bytes long.

		byte[] result = newData;

		int srcBlockCountX = texelCountX * blocksPerTexel;
		int dstBlockCountX = CeilDivide(texture.Width_C28, blockDimensions.Width);
		if (dstBlockCountX != srcBlockCountX)
		{
			byte[] croppedData = new byte[newData.Length];
			int dstBlockCountY = CeilDivide(texture.Height_C28, blockDimensions.Height);
			for (int y = 0; y < dstBlockCountY; y++)
			{
				newData.AsSpan(y * srcBlockCountX * blockByteSize, dstBlockCountX * blockByteSize).CopyTo(croppedData.AsSpan(y * dstBlockCountX * blockByteSize));
			}

			result = croppedData;
		}

		if (realFormat != texture.Format_C28E)
		{
			// Convert RGBA to RGB
			Debug.Assert(blockByteSize % 4 == 0);
			Debug.Assert(blockDimensions.Height == 1);
			int actualBlockByteSize = blockByteSize / 4 * 3;
			for (int y = 0; y < texture.Height_C28; y++)
			{
				int srcOffset = y * texture.Width_C28 * blockByteSize;
				int dstOffset = y * texture.Width_C28 * actualBlockByteSize;
				for (int x = 0; x < texture.Width_C28; x++)
				{
					int srcIndex = srcOffset + x * blockByteSize;
					int dstIndex = dstOffset + x * actualBlockByteSize;

					// Because we're removing data, srcIndex should always be greater than or equal to dstIndex.
					// This allows us to safely copy in-place.
					Debug.Assert(srcIndex >= dstIndex);
					result.AsSpan(srcIndex, actualBlockByteSize).CopyTo(result.AsSpan(dstIndex, actualBlockByteSize));
				}
			}

			// Clear out the unused data at the end
			int newSize = texture.Width_C28 * texture.Height_C28 * actualBlockByteSize;
			result.AsSpan(newSize).Clear();
		}

		return result;
	}

	private static Size? GetBlockDimensions(TextureFormat textureFormat) => textureFormat switch
	{
		TextureFormat.Alpha8 => new Size(1, 1),
		TextureFormat.ARGB4444 => new Size(1, 1),
		TextureFormat.RGBA4444 => new Size(1, 1),
		TextureFormat.ARGB32 => new Size(1, 1),
		TextureFormat.BGRA32_14 or TextureFormat.BGRA32_37 => new Size(1, 1),
		TextureFormat.RGB565 => new Size(1, 1),
		TextureFormat.DXT1 => new Size(4, 4),
		TextureFormat.DXT5 => new Size(4, 4),
		TextureFormat.BC4 => new Size(4, 4),
		TextureFormat.BC5 => new Size(4, 4),
		TextureFormat.BC6H => new Size(4, 4),
		TextureFormat.BC7 => new Size(4, 4),
		TextureFormat.ASTC_RGB_4x4 or TextureFormat.ASTC_RGBA_4x4 or TextureFormat.ASTC_HDR_4x4 => new Size(4, 4),
		TextureFormat.ASTC_RGB_5x5 or TextureFormat.ASTC_RGBA_5x5 or TextureFormat.ASTC_HDR_5x5 => new Size(5, 5),
		TextureFormat.ASTC_RGB_6x6 or TextureFormat.ASTC_RGBA_6x6 or TextureFormat.ASTC_HDR_6x6 => new Size(6, 6),
		TextureFormat.ASTC_RGB_8x8 or TextureFormat.ASTC_RGBA_8x8 or TextureFormat.ASTC_HDR_8x8 => new Size(8, 8),
		TextureFormat.ASTC_RGB_10x10 or TextureFormat.ASTC_RGBA_10x10 or TextureFormat.ASTC_HDR_10x10 => new Size(10, 10),
		TextureFormat.ASTC_RGB_12x12 or TextureFormat.ASTC_RGBA_12x12 or TextureFormat.ASTC_HDR_12x12 => new Size(12, 12),
		TextureFormat.R8 or TextureFormat.R8_SIGNED => new Size(1, 1),
		TextureFormat.RG16 or TextureFormat.RG16_SIGNED => new Size(1, 1),
		TextureFormat.RGBA32 or TextureFormat.RGBA32_SIGNED => new Size(1, 1),
		TextureFormat.R16 or TextureFormat.R16_SIGNED or TextureFormat.RHalf => new Size(1, 1),
		TextureFormat.RG32 or TextureFormat.RG32_SIGNED or TextureFormat.RGHalf => new Size(1, 1),
		TextureFormat.RGBA64 or TextureFormat.RGBA64_SIGNED or TextureFormat.RGBAHalf => new Size(1, 1),
		TextureFormat.RFloat => new Size(1, 1),
		TextureFormat.RGFloat => new Size(1, 1),
		TextureFormat.RGBAFloat => new Size(1, 1),
		TextureFormat.ARGBFloat => new Size(1, 1),
		_ => null,
	};

	private static int GetBlockSize(TextureFormat textureFormat) => textureFormat switch
	{
		TextureFormat.Alpha8 => 1,
		TextureFormat.ARGB4444 => 2,
		TextureFormat.RGBA4444 => 2,
		TextureFormat.ARGB32 => 4,
		TextureFormat.BGRA32_14 or TextureFormat.BGRA32_37 => 4,
		TextureFormat.RGB565 => 2,
		TextureFormat.DXT1 => 8,
		TextureFormat.DXT5 => 16,
		TextureFormat.BC4 => 8,
		TextureFormat.BC5 => 16,
		TextureFormat.BC6H => 16,
		TextureFormat.BC7 => 16,
		TextureFormat.ASTC_RGB_4x4 or TextureFormat.ASTC_RGBA_4x4 or TextureFormat.ASTC_HDR_4x4 => 16,
		TextureFormat.ASTC_RGB_5x5 or TextureFormat.ASTC_RGBA_5x5 or TextureFormat.ASTC_HDR_5x5 => 16,
		TextureFormat.ASTC_RGB_6x6 or TextureFormat.ASTC_RGBA_6x6 or TextureFormat.ASTC_HDR_6x6 => 16,
		TextureFormat.ASTC_RGB_8x8 or TextureFormat.ASTC_RGBA_8x8 or TextureFormat.ASTC_HDR_8x8 => 16,
		TextureFormat.ASTC_RGB_10x10 or TextureFormat.ASTC_RGBA_10x10 or TextureFormat.ASTC_HDR_10x10 => 16,
		TextureFormat.ASTC_RGB_12x12 or TextureFormat.ASTC_RGBA_12x12 or TextureFormat.ASTC_HDR_12x12 => 16,
		TextureFormat.R8 or TextureFormat.R8_SIGNED => 1,
		TextureFormat.RG16 or TextureFormat.RG16_SIGNED => 2,
		TextureFormat.RGBA32 or TextureFormat.RGBA32_SIGNED => 4,
		TextureFormat.R16 or TextureFormat.R16_SIGNED or TextureFormat.RHalf => 2,
		TextureFormat.RG32 or TextureFormat.RG32_SIGNED or TextureFormat.RGHalf => 4,
		TextureFormat.RGBA64 or TextureFormat.RGBA64_SIGNED or TextureFormat.RGBAHalf => 8,
		TextureFormat.RFloat => 4,
		TextureFormat.RGFloat => 8,
		TextureFormat.RGBAFloat => 16,
		TextureFormat.ARGBFloat => 16,
		_ => throw new NotSupportedException(),
	};

	private static Size GetPaddedTextureDimensions(int width, int height, int blockWidth, int blockHeight, int gobsPerBlock)
	{
		width = CeilDivide(width, blockWidth * GobXTexelCount) * blockWidth * GobXTexelCount;
		height = CeilDivide(height, blockHeight * GobYTexelCount * gobsPerBlock) * blockHeight * GobYTexelCount * gobsPerBlock;
		return new Size(width, height);
	}

	private static int GetTexelHeightByPlatformBlob(byte[] platformBlob, EndianType endianType)
	{
		return 1 << new EndianSpanReader(platformBlob.AsSpan(8), endianType).ReadInt32();
	}

	private static TextureFormat GetCorrectedSwitchTextureFormat(TextureFormat format) => format switch
	{
		TextureFormat.RGB24 => TextureFormat.RGBA32,
		TextureFormat.RGB48 => TextureFormat.RGBA64,
		TextureFormat.RGB24_SIGNED => TextureFormat.RGBA32_SIGNED,
		TextureFormat.RGB48_SIGNED => TextureFormat.RGBA64_SIGNED,
		TextureFormat.BGR24 => TextureFormat.BGRA32_14,
		_ => format
	};
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TagManagerConstants.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions;

public static class TagManagerConstants
{
	public const string UntaggedTag = "Untagged";
	public const string RespawnTag = "Respawn";
	public const string FinishTag = "Finish";
	public const string EditorOnlyTag = "EditorOnly";
	public const string MainCameraTag = "MainCamera";
	public const string PlayerTag = "Player";
	public const string GameControllerTag = "GameController";
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TagManagerExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_78;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TagManagerExtensions
{
	/// <summary>
	/// 5.0.0 to 5.5.0 exclusive
	/// </summary>
	public static bool IsBrokenCustomTags(UnityVersion version) => version.GreaterThanOrEquals(5) && version.LessThan(5, 5);

	/// <summary>
	/// 5.0.0 to 5.5.0 exclusive
	/// </summary>
	public static bool IsBrokenCustomTags(this ITagManager tagManager) => IsBrokenCustomTags(tagManager.Collection.Version);

	public static string TagIDToName(this ITagManager? tagManager, int tagID)
	{
		switch (tagID)
		{
			case 0:
				return TagManagerConstants.UntaggedTag;
			case 1:
				return TagManagerConstants.RespawnTag;
			case 2:
				return TagManagerConstants.FinishTag;
			case 3:
				return TagManagerConstants.EditorOnlyTag;
			//case 4:
			case 5:
				return TagManagerConstants.MainCameraTag;
			case 6:
				return TagManagerConstants.PlayerTag;
			case 7:
				return TagManagerConstants.GameControllerTag;
		}
		if (tagManager != null)
		{
			// Unity doesn't verify tagID on export?
			int tagIndex = tagID - 20000;
			if (tagIndex < tagManager.Tags.Count)
			{
				if (tagIndex >= 0)
				{
					return tagManager.Tags[tagIndex].String;
				}
				else if (!tagManager.IsBrokenCustomTags())
				{
					throw new Exception($"Unknown default tag {tagID}");
				}
			}
		}
		return $"unknown_{tagID}";
	}

	public static ushort TagNameToID(this ITagManager? tagManager, string tagName)
	{
		switch (tagName)
		{
			case TagManagerConstants.UntaggedTag:
				return 0;
			case TagManagerConstants.RespawnTag:
				return 1;
			case TagManagerConstants.FinishTag:
				return 2;
			case TagManagerConstants.EditorOnlyTag:
				return 3;
			case TagManagerConstants.MainCameraTag:
				return 5;
			case TagManagerConstants.PlayerTag:
				return 6;
			case TagManagerConstants.GameControllerTag:
				return 7;
		}
		if (tagManager != null)
		{
			for (int i = 0; i < tagManager.Tags.Count; i++)
			{
				if (tagManager.Tags[i] == tagName)
				{
					return (ushort)(20000 + i);
				}
			}
		}
		return 0;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TerrainDataExtensions.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Texture2D;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TerrainDataExtensions
{
	public static IEnumerable<ITexture2D> GetSplatAlphaTextures(this ITerrainData terrainData)
	{
		return terrainData.SplatDatabase.AlphaTextures.ToPPtrAccessList<IPPtr_Texture2D, ITexture2D>(terrainData.Collection).WhereNotNull();
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TerrainExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_218;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TerrainExtensions
{
	public static ShadowCastingMode GetShadowCastingMode(this ITerrain terrain)
	{
		if (terrain.Has_ShadowCastingMode())
		{
			return terrain.ShadowCastingModeE;
		}
		else
		{
			return terrain.CastShadows ? ShadowCastingMode.TwoSided : ShadowCastingMode.Off;
		}
	}

	public static bool GetCastShadows(this ITerrain terrain)
	{
		if (terrain.Has_CastShadows())
		{
			return terrain.CastShadows;
		}
		else
		{
			return terrain.ShadowCastingModeE != ShadowCastingMode.Off;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TextWriterExtensions.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions;

public static class TextWriterExtensions
{
	public static void WriteString(this TextWriter writer, string @string, int offset, int length)
	{
		writer.Write(@string.AsSpan().Slice(offset, length));
	}

	public static void WriteIndent(this TextWriter writer, int count)
	{
		for (int i = 0; i < count; i++)
		{
			writer.Write('\t');
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Texture2DArrayExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_187;

namespace AssetRipper.SourceGenerated.Extensions;

public static class Texture2DArrayExtensions
{
	public static byte[] GetImageData(this ITexture2DArray texture)
	{
		if (texture.ImageData.Length > 0)
		{
			return texture.ImageData;
		}
		else if (texture.Has_StreamData() && texture.StreamData.IsSet())
		{
			return texture.StreamData.GetContent(texture.Collection);
		}
		else
		{
			return Array.Empty<byte>();
		}
	}

	public static bool CheckAssetIntegrity(this ITexture2DArray texture)
	{
		if (texture.ImageData.Length > 0)
		{
			return true;
		}
		else if (texture.Has_StreamData())
		{
			return texture.StreamData.CheckIntegrity(texture.Collection);
		}
		else
		{
			return false;
		}
	}

	public static int GetCompleteImageSize(this ITexture2DArray texture)
	{
		return (int)texture.DataSize / (texture.Depth > 1 ? texture.Depth : 1);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Texture2DExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Enums;
using BuildTarget = AssetRipper.IO.Files.BuildTarget;

namespace AssetRipper.SourceGenerated.Extensions;

public static class Texture2DExtensions
{
	extension(ITexture2D texture)
	{
		public int CompleteImageSize
		{
			get
			{
				if (texture.Has_CompleteImageSize_C28_UInt32())
				{
					return (int)texture.CompleteImageSize_C28_UInt32;//No texture is larger than 2GB
				}
				else
				{
					return texture.CompleteImageSize_C28_Int32;
				}
			}
		}

		/// <summary>
		/// Get the CompleteImageSize, or a calculated value if necessary
		/// </summary>
		/// <remarks>
		/// <see href="https://github.com/AssetRipper/AssetRipper/issues/1789"/>
		/// </remarks>
		public int ActualImageSize
		{
			get
			{
				int completeImageSize = texture.CompleteImageSize;
				if (completeImageSize > 0)
				{
					return completeImageSize;
				}

				// Normally, the complete image size is non-zero, so this only applies in certain situations.
				// One way this can happen is for server builds of a game.
				// In server builds, textures are often 1 pixel and have an image size equal to be zero.
				// However, they still contain a small amount of texture data, so the image size is actual non-zero.
				// We calculate the actual value below.

				int dataLength = texture.ImageDataLength;
				int count = texture.ImageCount_C28;
				if (count > 1 && dataLength % count == 0)
				{
					return dataLength / count;
				}
				else
				{
					return dataLength;
				}
			}
		}

		public bool Mips => texture.MipMap_C28 || texture.MipCount_C28 > 1;

		public bool CheckAssetIntegrity()
		{
			if (!texture.ImageData_C28.IsNullOrEmpty())
			{
				return true;
			}
			else if (texture.StreamData_C28 is not null)
			{
				return texture.StreamData_C28.CheckIntegrity(texture.Collection);
			}
			else
			{
				return false;
			}
		}

		public byte[] GetImageData()
		{
			byte[] data = texture.ImageData_C28;

			bool swapBytes = IsSwapBytes(texture.Collection.Platform, texture.Format_C28E);
			bool switchSwizzled = texture is { PlatformBlob_C28.Length: >= 12, Collection.Platform: BuildTarget.Switch };

			if (data.Length != 0)
			{
				if (swapBytes)
				{
					// Need to copy the data to avoid modifying the original
					data = data.AsSpan().ToArray();
				}
			}
			else if (texture.StreamData_C28 is not null && texture.StreamData_C28.IsSet())
			{
				data = texture.StreamData_C28.GetContent(texture.Collection);
			}

			if (swapBytes)
			{
				for (int i = 0; i < data.Length; i += 2)
				{
					(data[i], data[i + 1]) = (data[i + 1], data[i]);
				}
			}

			if (switchSwizzled)
			{
				return SwitchSwizzle.Unswizzle(texture, data);
			}

			return data;
		}

		public int ImageDataLength
		{
			get
			{
				if (texture.ImageData_C28.Length != 0)
				{
					return texture.ImageData_C28.Length;
				}
				else if (texture.StreamData_C28 is not null && texture.StreamData_C28.IsSet())
				{
					return (int)texture.StreamData_C28.Size;
				}
				else
				{
					return 0;
				}
			}
		}
	}

	private static bool IsSwapBytes(IO.Files.BuildTarget platform, TextureFormat format)
	{
		if (platform == IO.Files.BuildTarget.XBox360)
		{
			switch (format)
			{
				case TextureFormat.ARGB4444:
				case TextureFormat.RGB565:
				case TextureFormat.DXT1:
				case TextureFormat.DXT1Crunched:
				case TextureFormat.DXT3:
				case TextureFormat.DXT5:
				case TextureFormat.DXT5Crunched:
					return true;
			}
		}
		return false;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Texture3DExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_117;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class Texture3DExtensions
{
	public static byte[] GetImageData(this ITexture3D texture)
	{
		if (texture.ImageData.Length > 0)
		{
			return texture.ImageData;
		}
		else if (texture.Has_StreamData() && texture.StreamData.IsSet())
		{
			return texture.StreamData.GetContent(texture.Collection);
		}
		else
		{
			return [];
		}
	}

	public static bool CheckAssetIntegrity(this ITexture3D texture)
	{
		if (texture.ImageData.Length > 0)
		{
			return true;
		}
		else if (texture.Has_StreamData())
		{
			return texture.StreamData.CheckIntegrity(texture.Collection);
		}
		else
		{
			return false;
		}
	}

	extension (ITexture3D texture)
	{
		public int Format
		{
			get
			{
				if (texture.Has_Format_Int32())
				{
					return texture.Format_Int32;
				}
				else
				{
					return unchecked((int)texture.Format_UInt32);
				}
			}
			set
			{
				if (texture.Has_Format_Int32())
				{
					texture.Format_Int32 = value;
				}
				else
				{
					texture.Format_UInt32 = unchecked((uint)value);
				}
			}
		}
	}

	public static TextureFormat GetTextureFormat(this ITexture3D texture)
	{
		if (texture.Has_Format_Int32())
		{
			return ((GraphicsFormat)texture.Format_Int32).ToTextureFormat();
		}
		else
		{
			return ((GraphicsFormat)texture.Format_UInt32).ToTextureFormat();
		}
	}

	public static TextureUsageMode GetLightmapFormat(this ITexture3D texture)
	{
		if (texture.Has_LightmapFormat())
		{
			return texture.LightmapFormatE;
		}
		else
		{
			return texture.UsageModeE;
		}
	}

	public static int GetCompleteImageSize(this ITexture3D texture)
	{
		if (texture.Has_CompleteImageSize_UInt32())
		{
			return (int)texture.CompleteImageSize_UInt32;
		}
		else
		{
			return texture.CompleteImageSize_Int32;
		}
	}

	public static int GetMipCount(this ITexture3D texture)
	{
		if (texture.Has_MipCount())
		{
			return texture.MipCount;
		}
		else
		{
			if (texture.MipMap)
			{
				int maxSide = Math.Max(texture.Width, texture.Height);
				return Convert.ToInt32(Math.Log2(maxSide));
			}
			else
			{
				return 1;
			}
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TextureFormatExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TextureFormatExtensions
{
	public static bool IsCrunched(this TextureFormat format)
	{
		return format is TextureFormat.DXT1Crunched or TextureFormat.DXT5Crunched or TextureFormat.ETC_RGB4Crunched or TextureFormat.ETC2_RGBA8Crunched;
	}

	public static bool IsDxt(this TextureFormat format)
	{
		return format is TextureFormat.DXT1 or TextureFormat.DXT1Crunched or TextureFormat.DXT3 or TextureFormat.DXT5 or TextureFormat.DXT5Crunched;
	}

	public static bool IsRgb(this TextureFormat format)
	{
		return format
			is TextureFormat.Alpha8
			or TextureFormat.ARGB4444
			or TextureFormat.RGB24
			or TextureFormat.RGBA32
			or TextureFormat.ARGB32
			or TextureFormat.RGB565
			or TextureFormat.R16
			or TextureFormat.RGBA4444
			or TextureFormat.BGRA32_14
			or TextureFormat.RHalf
			or TextureFormat.RGHalf
			or TextureFormat.RGBAHalf
			or TextureFormat.RFloat
			or TextureFormat.RGFloat
			or TextureFormat.RGBAFloat
			or TextureFormat.RGB9e5Float
			or TextureFormat.BGRA32_37
			or TextureFormat.RG16
			or TextureFormat.R8
			or TextureFormat.RG32
			or TextureFormat.RGB48
			or TextureFormat.RGBA64
			or TextureFormat.R8_SIGNED
			or TextureFormat.RG16_SIGNED
			or TextureFormat.RGB24_SIGNED
			or TextureFormat.RGBA32_SIGNED
			or TextureFormat.R16_SIGNED
			or TextureFormat.RG32_SIGNED
			or TextureFormat.RGB48_SIGNED
			or TextureFormat.RGBA64_SIGNED;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TextureImporterExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_1006;
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TextureImporterExtensions
{
	public static void GetSwizzle(this ITextureImporter importer, out TextureImporterSwizzle channel0, out TextureImporterSwizzle channel1, out TextureImporterSwizzle channel2, out TextureImporterSwizzle channel3)
	{
		if (importer.Has_Swizzle())
		{
			uint value = importer.Swizzle;
			channel0 = (TextureImporterSwizzle)(value & 0x_00_00_00_FF);
			channel1 = (TextureImporterSwizzle)((value & 0x_00_00_FF_00) >> 8);
			channel2 = (TextureImporterSwizzle)((value & 0x_00_FF_00_00) >> 16);
			channel3 = (TextureImporterSwizzle)(value >> 24);
		}
		else
		{
			channel0 = TextureImporterSwizzle.R;
			channel1 = TextureImporterSwizzle.G;
			channel2 = TextureImporterSwizzle.B;
			channel3 = TextureImporterSwizzle.A;
		}
	}

	public static void SetSwizzle(this ITextureImporter importer, TextureImporterSwizzle channel0, TextureImporterSwizzle channel1, TextureImporterSwizzle channel2, TextureImporterSwizzle channel3)
	{
		if (importer.Has_Swizzle())
		{
			uint value = (byte)channel0 | ((uint)(byte)channel1 << 8) | ((uint)(byte)channel2 << 16) | ((uint)(byte)channel3 << 24);
			importer.Swizzle = value;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TextureParameterExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.TextureParameter;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TextureParameterExtensions
{
	public static void SetValues(this ITextureParameter parameter, string name, int index, sbyte dimension, int sampler)
	{
		//parameter.Name = name;//Name doesn't exist
		parameter.NameIndex = -1;
		parameter.Index = index;
		parameter.Dim = dimension;
		parameter.SamplerIndex = sampler;
		parameter.MultiSampled = false;
	}

	public static void SetValues(this ITextureParameter parameter, string name, int index, sbyte dimension, int sampler, bool multiSampled)
	{
		//parameter.Name = name;//Name doesn't exist
		parameter.NameIndex = -1;
		parameter.Index = index;
		parameter.Dim = dimension;
		parameter.SamplerIndex = sampler;
		parameter.MultiSampled = multiSampled;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TextureSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.TextureSettings;
using FilterMode = AssetRipper.SourceGenerated.Enums.FilterMode_0;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TextureSettingsExtensions
{
	public static TextureImporterCompression GetTextureCompression(this ITextureSettings settings)
	{
		return (TextureImporterCompression)settings.TextureCompression;
	}

	public static void SetTextureCompression(this ITextureSettings settings, TextureImporterCompression compression)
	{
		settings.TextureCompression = (int)compression;
	}

	public static FilterMode GetFilterMode(this ITextureSettings settings)
	{
		return (FilterMode)settings.FilterMode;
	}

	public static void SetFilterMode(this ITextureSettings settings, FilterMode filterMode)
	{
		settings.FilterMode = (int)filterMode;
	}

	public static ColorSpace GetColorSpace(this ITextureSettings settings)
	{
		return settings.Has_ColorSpace()
			? (ColorSpace)settings.ColorSpace
			: settings.Has_SRGB_Boolean()
				? settings.SRGB_Boolean ? ColorSpace.Linear : ColorSpace.Gamma //Not 100% sure on this
				: (ColorSpace)settings.SRGB_Int32; //Not 100% sure on this
	}

	public static bool GetSRGB(this ITextureSettings settings)
	{
		return settings.Has_SRGB_Boolean()
			? settings.SRGB_Boolean
			: settings.Has_SRGB_Int32()
				? settings.SRGB_Int32 != 0
				: settings.ColorSpace != (int)ColorSpace.Gamma; //Not 100% sure on this
	}

	public static void SetSRGB(this ITextureSettings settings, bool value)
	{
		settings.SRGB_Boolean = value;
		settings.SRGB_Int32 = value ? 1 : 0;
		settings.ColorSpace = value ? (int)ColorSpace.Linear : (int)ColorSpace.Gamma;
	}

	public static int GetAnisoLevel(this ITextureSettings settings)
	{
		return settings.Has_AnisoLevel_Int32()
			? settings.AnisoLevel_Int32
			: unchecked((int)settings.AnisoLevel_UInt32);
	}

	public static void SetAnisoLevel(this ITextureSettings settings, int value)
	{
		settings.AnisoLevel_Int32 = value;
		settings.AnisoLevel_UInt32 = unchecked((uint)value);
	}

	public static int GetCompressionQuality(this ITextureSettings settings)
	{
		return settings.Has_CompressionQuality_Int32()
			? settings.CompressionQuality_Int32
			: unchecked((int)settings.CompressionQuality_UInt32);
	}

	public static void SetCompressionQuality(this ITextureSettings settings, int value)
	{
		settings.CompressionQuality_Int32 = value;
		settings.CompressionQuality_UInt32 = unchecked((uint)value);
	}

	public static int GetMaxTextureSize(this ITextureSettings settings)
	{
		return settings.Has_MaxTextureSize_Int32()
			? settings.MaxTextureSize_Int32
			: unchecked((int)settings.MaxTextureSize_UInt32);
	}

	public static void SetMaxTextureSize(this ITextureSettings settings, int value)
	{
		settings.MaxTextureSize_Int32 = value;
		settings.MaxTextureSize_UInt32 = unchecked((uint)value);
	}

	public static bool GetGenerateMipMaps(this ITextureSettings settings)
	{
		return settings.Has_GenerateMipMaps_Int32()
			? settings.GenerateMipMaps_Int32 != 0
			: settings.GenerateMipMaps_Boolean;
	}

	public static void SetGenerateMipMaps(this ITextureSettings settings, bool value)
	{
		settings.GenerateMipMaps_Int32 = value ? 1 : 0;
		settings.GenerateMipMaps_Boolean = value;
	}

	public static bool GetReadable(this ITextureSettings settings)
	{
		return settings.Has_Readable_Int32()
			? settings.Readable_Int32 != 0
			: settings.Readable_Boolean;
	}

	public static void SetReadable(this ITextureSettings settings, bool value)
	{
		settings.Readable_Int32 = value ? 1 : 0;
		settings.Readable_Boolean = value;
	}

	public static bool GetCrunchedCompression(this ITextureSettings settings)
	{
		return settings.Has_CrunchedCompression_Int32()
			? settings.CrunchedCompression_Int32 != 0
			: settings.CrunchedCompression_Boolean;
	}

	public static void SetCrunchedCompression(this ITextureSettings settings, bool value)
	{
		settings.CrunchedCompression_Int32 = value ? 1 : 0;
		settings.CrunchedCompression_Boolean = value;
	}

	public static void Initialize(this ITextureSettings settings)
	{
		settings.SetAnisoLevel(1);
		settings.SetCompressionQuality(50);
		settings.SetMaxTextureSize(2048);
		settings.SetTextureCompression(TextureImporterCompression.Uncompressed);
		settings.SetFilterMode(FilterMode.Bilinear);
		settings.SetGenerateMipMaps(false);
		settings.SetReadable(false);
		settings.SetCrunchedCompression(false);
		settings.SetSRGB(true);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TextureUsageModeExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TextureUsageModeExtensions
{
	public static bool IsNormalmap(this TextureUsageMode _this)
	{
		return _this is TextureUsageMode.NormalmapDXT5nm or TextureUsageMode.NormalmapPlain or TextureUsageMode.NormalmapASTCnm;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TierGraphicsSettingsEditorExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.TierGraphicsSettings;
using AssetRipper.SourceGenerated.Subclasses.TierGraphicsSettingsEditor;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TierGraphicsSettingsEditorExtensions
{
	public static void ConvertToEditorFormat(this ITierGraphicsSettingsEditor settings)
	{
		settings.StandardShaderQuality = (int)ShaderQuality.High;
		settings.RenderingPath = (int)RenderingPath.Forward;
		settings.HdrMode = (int)CameraHDRMode.FP16;
		settings.RealtimeGICPUUsage = (int)RealtimeGICPUUsage.Low;
		settings.UseReflectionProbeBoxProjection = true;
		settings.UseReflectionProbeBlending = true;
		settings.UseHDR = true;
		settings.UseDetailNormalMap = true;
		settings.UseCascadedShadowMaps = true;
		settings.Prefer32BitShadowMaps = false;
		settings.EnableLPPV = true;
		settings.UseDitherMaskForAlphaBlendedShadows = true;
	}

	public static void ConvertToEditorFormat(this ITierGraphicsSettingsEditor settings, ITierGraphicsSettings tierGraphicsSettings)
	{
		settings.StandardShaderQuality = (int)ShaderQuality.High;
		settings.RenderingPath = tierGraphicsSettings.RenderingPath;
		settings.HdrMode = tierGraphicsSettings.Has_HdrMode()
			? tierGraphicsSettings.HdrMode
			: (int)CameraHDRMode.FP16;
		settings.RealtimeGICPUUsage = tierGraphicsSettings.Has_RealtimeGICPUUsage()
			? tierGraphicsSettings.RealtimeGICPUUsage
			: (int)RealtimeGICPUUsage.Low;
		settings.UseReflectionProbeBoxProjection = true;
		settings.UseReflectionProbeBlending = true;
		settings.UseHDR = !tierGraphicsSettings.Has_UseHDR() || tierGraphicsSettings.UseHDR;
		settings.UseDetailNormalMap = true;
		settings.UseCascadedShadowMaps = tierGraphicsSettings.UseCascadedShadowMaps;
		settings.Prefer32BitShadowMaps = tierGraphicsSettings.Prefer32BitShadowMaps;
		settings.EnableLPPV = !tierGraphicsSettings.Has_EnableLPPV() || tierGraphicsSettings.EnableLPPV;
		settings.UseDitherMaskForAlphaBlendedShadows = true;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TierSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.TierGraphicsSettings;
using AssetRipper.SourceGenerated.Subclasses.TierGraphicsSettingsEditor;
using AssetRipper.SourceGenerated.Subclasses.TierSettings;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TierSettingsExtensions
{
	public static void ConvertToEditorFormat(this ITierSettings settings, ITierGraphicsSettingsEditor tierGraphicsSettingsEditor, BuildTargetGroup buildTarget, GraphicsTier tier)
	{
		settings.Automatic = false;
		settings.SetBuildTarget(buildTarget);
		settings.Settings.CopyValues(tierGraphicsSettingsEditor);
		settings.Tier = (int)tier;
	}

	public static void ConvertToEditorFormat(this ITierSettings settings, ITierGraphicsSettings tierGraphicsSettings, BuildTargetGroup buildTarget, GraphicsTier tier)
	{
		settings.Automatic = false;
		settings.SetBuildTarget(buildTarget);
		settings.Settings.ConvertToEditorFormat(tierGraphicsSettings);
		settings.Tier = (int)tier;
	}

	public static BuildTargetGroup GetBuildTargetAsEnum(this ITierSettings settings)
	{
		if (settings.Has_BuildTarget_Utf8String())
		{
			return StringToBuildGroup(settings.BuildTarget_Utf8String.String);
		}
		else
		{
			return (BuildTargetGroup)settings.BuildTarget_Int32;
		}
	}

	public static string GetBuildTargetAsString(this ITierSettings settings)
	{
		if (settings.Has_BuildTarget_Utf8String())
		{
			return settings.BuildTarget_Utf8String.String;
		}
		else
		{
			return BuildGroupToString((BuildTargetGroup)settings.BuildTarget_Int32);
		}
	}

	public static void SetBuildTarget(this ITierSettings settings, BuildTargetGroup buildTarget)
	{
		if (settings.Has_BuildTarget_Utf8String())
		{
			settings.BuildTarget_Utf8String = BuildGroupToString(buildTarget);
		}
		else
		{
			settings.BuildTarget_Int32 = (int)buildTarget;
		}
	}

	private static BuildTargetGroup StringToBuildGroup(string group)
	{
		return group switch
		{
			"Standalone" => BuildTargetGroup.Standalone,
			"Web" => BuildTargetGroup.WebPlayer,
			"iPhone" => BuildTargetGroup.iPhone,
			"Android" => BuildTargetGroup.Android,
			"WebGL" => BuildTargetGroup.WebGL,
			"Windows Store Apps" => BuildTargetGroup.WSA,
			"Tizen" => BuildTargetGroup.Tizen,
			"PSP2" => BuildTargetGroup.PSP2,
			"PS4" => BuildTargetGroup.PS4,
			"PSM" => BuildTargetGroup.PSM,
			"XboxOne" => BuildTargetGroup.XboxOne,
			"Samsung TV" => BuildTargetGroup.SamsungTV,
			"Nintendo 3DS" => BuildTargetGroup.N3DS,
			"WiiU" => BuildTargetGroup.WiiU,
			"tvOS" => BuildTargetGroup.tvOS,
			_ => BuildTargetGroup.Standalone,
		};
	}

	private static string BuildGroupToString(BuildTargetGroup group)
	{
		return group switch
		{
			BuildTargetGroup.Standalone => "Standalone",
			BuildTargetGroup.WebPlayer => "Web",
			BuildTargetGroup.iPhone => "iPhone",
			BuildTargetGroup.Android => "Android",
			BuildTargetGroup.WebGL => "WebGL",
			BuildTargetGroup.WSA => "Windows Store Apps",
			BuildTargetGroup.Tizen => "Tizen",
			BuildTargetGroup.PSP2 => "PSP2",
			BuildTargetGroup.PS4 => "PS4",
			BuildTargetGroup.PSM => "PSM",
			BuildTargetGroup.XboxOne => "XboxOne",
			BuildTargetGroup.SamsungTV => "Samsung TV",
			BuildTargetGroup.N3DS => "Nintendo 3DS",
			BuildTargetGroup.WiiU => "WiiU",
			BuildTargetGroup.tvOS => "tvOS",
			_ => "Standalone",
		};
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TrailModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.TrailModule;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TrailModuleExtensions
{
	public static void SetToDefault(this ITrailModule module, UnityVersion version)
	{
		module.Ratio = 1.0f;
		module.Lifetime.SetValues(version, 1.0f);
		module.MinVertexDistance = 0.2f;
		module.RibbonCount = 1;
		module.DieWithParticles = true;
		module.SizeAffectsWidth = true;
		module.InheritParticleColor = true;
		module.ColorOverLifetime.SetToDefault();
		module.WidthOverTrail.SetValues(version, 1.0f);
		module.ColorOverTrail.SetToDefault();
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TransformExtensions.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_4;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TransformExtensions
{
	private const char PathSeparator = '/';

	public static Transformation ToTransformation(this ITransform transform)
	{
		return Transformation.Create(transform.LocalPosition_C4.CastToStruct(), transform.LocalRotation_C4.CastToStruct(), transform.LocalScale_C4.CastToStruct());
	}

	public static Transformation ToInverseTransformation(this ITransform transform)
	{
		return Transformation.CreateInverse(transform.LocalPosition_C4.CastToStruct(), transform.LocalRotation_C4.CastToStruct(), transform.LocalScale_C4.CastToStruct());
	}

	public static string GetRootPath(this ITransform transform)
	{
		string name = transform.GameObject_C4P?.Name ?? "Unnamed";
		if (transform.Father_C4P is { } father)
		{
			return $"{father.GetRootPath()}{PathSeparator}{name}";
		}
		else
		{
			return name;
		}
	}

	/// <summary>
	/// Initialize an injected Transform with some sensible default values.
	/// </summary>
	/// <remarks>
	/// Since this Transform is assumed to have no <see cref="ITransform.Father_C4"/>, its <see cref="ITransform.RootOrder_C4"/> is zero.
	/// </remarks>
	/// <param name="transform"></param>
	public static void InitializeDefault(this ITransform transform)
	{
		transform.LocalPosition_C4.SetZero();
		transform.LocalRotation_C4.SetIdentity();
		transform.LocalScale_C4.SetOne();
		transform.RootOrder_C4 = 0;
		transform.LocalEulerAnglesHint_C4?.SetZero();
	}

	public static ITransform? FindChild(this ITransform transform, string path)
	{
		if (path.Length == 0)
		{
			return transform;
		}
		return transform.FindChild(path, 0);
	}

	private static ITransform? FindChild(this ITransform transform, string path, int startIndex)
	{
		int separatorIndex = path.IndexOf(PathSeparator, startIndex);
		string childName = separatorIndex == -1 ? path[startIndex..] : path[startIndex..separatorIndex];
		foreach (ITransform child in transform.Children_C4P.WhereNotNull())
		{
			IGameObject? childGO = child.GameObject_C4P;
			if (childGO is null)
			{
				continue;
			}
			if (childGO.Name == childName)
			{
				return separatorIndex == -1 ? child : child.FindChild(path, separatorIndex + 1);
			}
		}
		return default;
	}

	/// <summary>
	/// Find the sibling index (aka the root order) of the transform
	/// </summary>
	/// <param name="transform">The relevant transform</param>
	/// <returns>The sibling index of the transform</returns>
	/// <exception cref="Exception">if the transform cannot be found among the father's children</exception>
	public static int CalculateRootOrder(this ITransform transform)
	{
		ITransform? father = transform.Father_C4P;
		if (father is null)
		{
			return 0;
		}
		for (int i = father.Children_C4.Count - 1; i >= 0; i--)
		{
			// Performance optimization: check PathID first to avoid unnecessary asset resolution.
			if (father.Children_C4[i].PathID != transform.PathID)
			{
				continue;
			}

			if (father.Children_C4P[i] == transform)
			{
				return i;
			}
		}
		throw new Exception("Transform hasn't been found among father's children");
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TransitionConstantExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.OffsetPtr_ConditionConstant;
using AssetRipper.SourceGenerated.Subclasses.TransitionConstant;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TransitionConstantExtensions
{
	public static bool GetHasFixedDuration(this ITransitionConstant transitionConstant)
	{
		return !transitionConstant.Has_HasFixedDuration() || transitionConstant.HasFixedDuration;
	}

	public static TransitionInterruptionSource GetInterruptionSource(this ITransitionConstant transitionConstant)
	{
		if (transitionConstant.Has_InterruptionSource())
		{
			return transitionConstant.InterruptionSourceE;
		}
		else
		{
			return transitionConstant.Atomic ? TransitionInterruptionSource.None : TransitionInterruptionSource.Destination;
		}
	}

	public static float GetExitTime(this ITransitionConstant transitionConstant)
	{
		if (transitionConstant.Has_ExitTime())
		{
			return transitionConstant.ExitTime;
		}
		else
		{
			foreach (OffsetPtr_ConditionConstant conditionPtr in transitionConstant.ConditionConstantArray)
			{
				if (conditionPtr.Data.ConditionModeE == AnimatorConditionMode.ExitTime)
				{
					return conditionPtr.Data.ExitTime;
				}
			}
			return 1.0f;
		}
	}

	public static bool GetHasExitTime(this ITransitionConstant transitionConstant)
	{
		if (transitionConstant.Has_HasExitTime())
		{
			return transitionConstant.HasExitTime;
		}
		else
		{
			foreach (OffsetPtr_ConditionConstant conditionPtr in transitionConstant.ConditionConstantArray)
			{
				if (conditionPtr.Data.ConditionModeE == AnimatorConditionMode.ExitTime)
				{
					return true;
				}
			}
			return false;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TriangleEnumerable.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using System.Collections;

namespace AssetRipper.SourceGenerated.Extensions;

public readonly struct TriangleEnumerable : IEnumerable<(uint, uint, uint)>
{
	private readonly MeshTopology topology;
	private readonly ArraySegment<uint> indexBuffer;

	public TriangleEnumerable(SubMeshData subMesh, uint[] indexBuffer) : this(subMesh.Topology, GetIndexBufferSegment(subMesh, indexBuffer))
	{
	}

	public TriangleEnumerable(MeshTopology topology, ArraySegment<uint> indexBuffer)
	{
		ThrowIfNotSupported(topology);
		this.topology = topology;
		this.indexBuffer = indexBuffer;
	}

	public static bool IsSupported(MeshTopology topology)
	{
		return topology is MeshTopology.Triangles or MeshTopology.TriangleStrip or MeshTopology.Quads;
	}

	public IEnumerator<(uint, uint, uint)> GetEnumerator()
	{
		switch (topology)
		{
			case MeshTopology.Triangles:
				{
					for (int i = 0; i < indexBuffer.Count; i += 3)
					{
						yield return (indexBuffer[i], indexBuffer[i + 1], indexBuffer[i + 2]);
					}
				}
				break;
			case MeshTopology.TriangleStrip:
				{
					// de-stripify :
					for (int i = 0; i < indexBuffer.Count - 2; i++)
					{
						uint a = indexBuffer[i];
						uint b = indexBuffer[i + 1];
						uint c = indexBuffer[i + 2];

						// skip degenerates
						if (a == b || a == c || b == c)
						{
							continue;
						}

						// do the winding flip-flop of strips :
						if ((i & 1) == 1)
						{
							yield return (b, a, c);
						}
						else
						{
							yield return (a, b, c);
						}
					}
				}
				break;
			case MeshTopology.Quads:
				{
					for (int q = 0; q < indexBuffer.Count; q += 4)
					{
						yield return (indexBuffer[q], indexBuffer[q + 1], indexBuffer[q + 2]);
						yield return (indexBuffer[q], indexBuffer[q + 2], indexBuffer[q + 3]);
					}
				}
				break;
		}
	}

	private static ArraySegment<uint> GetIndexBufferSegment(SubMeshData subMesh, uint[] indexBuffer)
	{
		return new ArraySegment<uint>(indexBuffer, subMesh.FirstIndex, subMesh.IndexCount);
	}

	private static void ThrowIfNotSupported(MeshTopology topology)
	{
		if (!IsSupported(topology))
		{
			throw new ArgumentException($"Mesh topology {topology} is not supported", nameof(topology));
		}
	}

	IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

```

`Source/AssetRipper.SourceGenerated.Extensions/TriggerModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.TriggerModule;

namespace AssetRipper.SourceGenerated.Extensions;

public static class TriggerModuleExtensions
{
	public enum TriggerAction
	{
		Ignore = 0,
		Kill = 1,
		Callback = 2,
	}

	public static void SetToDefault(this ITriggerModule module)
	{
		module.Inside = (int)TriggerAction.Kill;
		module.RadiusScale = 1;
	}

	public static TriggerAction GetInside(this ITriggerModule module)
	{
		return (TriggerAction)module.Inside;
	}

	public static TriggerAction GetOutside(this ITriggerModule module)
	{
		return (TriggerAction)module.Outside;
	}

	public static TriggerAction GetEnter(this ITriggerModule module)
	{
		return (TriggerAction)module.Enter;
	}

	public static TriggerAction GetExit(this ITriggerModule module)
	{
		return (TriggerAction)module.Exit;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/UAVParameterExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.UAVParameter;

namespace AssetRipper.SourceGenerated.Extensions;

public static class UAVParameterExtensions
{
	public static void SetValues(this IUAVParameter parameter, string name, int index, int originalIndex)
	{
		//parameter.Name = name;//Name doesn't exist
		parameter.NameIndex = -1;
		parameter.Index = index;
		parameter.OriginalIndex = originalIndex;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/UVInfo.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions;

public readonly record struct UVInfo(uint Value)
{
	const int kInfoBitsPerUV = 4;
	const int kUVDimensionMask = 0b0011;
	const int kUVChannelExists = 0b0100;
	const uint uvChannelMask = (1u << kInfoBitsPerUV) - 1u;
	const int kMaxTexCoordShaderChannels = 8;

	public void GetChannelInfo(int index, out bool exists, out int dimension)
	{
		ValidateIndex(index);
		uint texCoordBits = GetTextureCoordinateBits(index);
		exists = (texCoordBits & kUVChannelExists) != 0;
		dimension = 1 + (int)(texCoordBits & kUVDimensionMask);
	}

	private uint GetTextureCoordinateBits(int index)
	{
		int bitOffset = index * kInfoBitsPerUV;
		uint texCoordBits = Value >> bitOffset & uvChannelMask;
		return texCoordBits;
	}

	public UVInfo AddChannelInfo(int index, bool exists, int dimension)
	{
		ValidateIndex(index);
		ValidateDimension(dimension);

		int bitOffset = index * kInfoBitsPerUV;
		uint texCoordBits = (exists ? kUVChannelExists : 0u) | (uint)(dimension - 1);
		return Value & ~(uvChannelMask << bitOffset) | texCoordBits << bitOffset;
	}

	private static void ValidateDimension(int dimension)
	{
		if (dimension < 1 || dimension > 1 + kUVDimensionMask)
		{
			throw new ArgumentOutOfRangeException(nameof(dimension));
		}
	}

	private static void ValidateIndex(int index)
	{
		if (index < 0 || index >= kMaxTexCoordShaderChannels)
		{
			throw new ArgumentOutOfRangeException(nameof(index));
		}
	}

	//Implicit conversions
	public static implicit operator uint(UVInfo uvInfo) => uvInfo.Value;
	public static implicit operator UVInfo(uint value) => new(value);

	public override string ToString() => Value.ToString();

	public static UVInfo Zero => default;
}

```

`Source/AssetRipper.SourceGenerated.Extensions/UVModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.UVModule;

namespace AssetRipper.SourceGenerated.Extensions;

public static class UVModuleExtensions
{
	public static ParticleSystemAnimationRowMode GetRowMode(this IUVModule module)
	{
		if (module.Has_RowMode())
		{
			return (ParticleSystemAnimationRowMode)module.RowMode;
		}
		else
		{
			return module.RandomRow ? ParticleSystemAnimationRowMode.Random : ParticleSystemAnimationRowMode.Custom;
		}
	}

	public static bool GetRandomRow(this IUVModule module)
	{
		return module.RandomRow || module.RowMode == (int)ParticleSystemAnimationRowMode.Random;
	}

	public static void SetRandomRow(this IUVModule module, bool value)
	{
		if (module.Has_RandomRow())
		{
			module.RandomRow = value;
		}
		else
		{
			module.RowMode = (int)(value ? ParticleSystemAnimationRowMode.Random : ParticleSystemAnimationRowMode.Custom);
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/UnityConnectSettingsExtensions.cs`:

```cs
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.SourceGenerated.Classes.ClassID_310;

namespace AssetRipper.SourceGenerated.Extensions;

public static class UnityConnectSettingsExtensions
{
	public static void ConvertToEditorFormat(this IUnityConnectSettings settings)
	{
		settings.CrashReportingSettings?.ConvertToEditorFormat();
	}

	/// <summary>
	/// 5.4.0 and greater and (Not Release or IsSupported)
	/// </summary>
	public static bool HasCrashReportingSettings(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
	{
		if (version.LessThan(5, 4))
		{
			return false;
		}
		if (!flags.IsRelease())
		{
			return true;
		}
		switch (platform)
		{
			case BuildTarget.NoTarget:
			case BuildTarget.Android:
			case BuildTarget.iOS:
			case BuildTarget.tvOS:
			case BuildTarget.StandaloneWinPlayer:
			case BuildTarget.StandaloneWin64Player:
			case BuildTarget.StandaloneLinux:
			case BuildTarget.StandaloneLinux64:
			case BuildTarget.StandaloneLinuxUniversal:
			case BuildTarget.StandaloneOSXUniversal:
			case BuildTarget.StandaloneOSXIntel:
			case BuildTarget.StandaloneOSXIntel64:
			case BuildTarget.MetroPlayerX64:
			case BuildTarget.MetroPlayerX86:
			case BuildTarget.MetroPlayerARM:
			case BuildTarget.WebPlayerLZMA:
			case BuildTarget.WebPlayerLZMAStreamed:
			case BuildTarget.WebGL:
				return true;

			case BuildTarget.Tizen:
				return version.GreaterThanOrEquals(5, 6);

			default:
				return false;
		}
	}
	/// <summary>
	/// Less than 5.4.0 or Not Release or IsSupported
	/// </summary>
	public static bool HasUnityPurchasingSettings(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
	{
		if (version.LessThan(5, 4))
		{
			return true;
		}
		if (!flags.IsRelease())
		{
			return true;
		}
		switch (platform)
		{
			case BuildTarget.NoTarget:
			case BuildTarget.Android:
			case BuildTarget.iOS:
			case BuildTarget.tvOS:
			case BuildTarget.Tizen:
			case BuildTarget.StandaloneWinPlayer:
			case BuildTarget.StandaloneWin64Player:
			case BuildTarget.StandaloneLinux:
			case BuildTarget.StandaloneLinux64:
			case BuildTarget.StandaloneLinuxUniversal:
			case BuildTarget.StandaloneOSXUniversal:
			case BuildTarget.StandaloneOSXIntel:
			case BuildTarget.StandaloneOSXIntel64:
			case BuildTarget.MetroPlayerX64:
			case BuildTarget.MetroPlayerX86:
			case BuildTarget.MetroPlayerARM:
			case BuildTarget.WebGL:
				return true;

			default:
				return false;
		}
	}
	/// <summary>
	/// Less than 5.4.0 or Not Release or IsSupported
	/// </summary>
	public static bool HasUnityAnalyticsSettings(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
	{
		if (version.LessThan(5, 4))
		{
			return true;
		}
		if (!flags.IsRelease())
		{
			return true;
		}
		switch (platform)
		{
			case BuildTarget.NoTarget:
			case BuildTarget.Android:
			case BuildTarget.iOS:
			case BuildTarget.tvOS:
			case BuildTarget.Tizen:
			case BuildTarget.StandaloneWinPlayer:
			case BuildTarget.StandaloneWin64Player:
			case BuildTarget.StandaloneLinux:
			case BuildTarget.StandaloneLinux64:
			case BuildTarget.StandaloneLinuxUniversal:
			case BuildTarget.StandaloneOSXUniversal:
			case BuildTarget.StandaloneOSXIntel:
			case BuildTarget.StandaloneOSXIntel64:
			case BuildTarget.MetroPlayerX64:
			case BuildTarget.MetroPlayerX86:
			case BuildTarget.MetroPlayerARM:
			case BuildTarget.WebGL:
				return true;

			default:
				return false;
		}
	}
	/// <summary>
	/// 5.5.0 and greater and (Not Release or IsSupported)
	/// </summary>
	public static bool HasUnityAdsSettings(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
	{
		if (version.LessThan(5, 5))
		{
			return false;
		}
		if (!flags.IsRelease())
		{
			return true;
		}
		switch (platform)
		{
			case BuildTarget.NoTarget:
			case BuildTarget.Android:
			case BuildTarget.iOS:
			case BuildTarget.tvOS:
			case BuildTarget.Tizen:
			case BuildTarget.StandaloneWinPlayer:
			case BuildTarget.StandaloneWin64Player:
			case BuildTarget.StandaloneLinux:
			case BuildTarget.StandaloneLinux64:
			case BuildTarget.StandaloneLinuxUniversal:
			case BuildTarget.StandaloneOSXUniversal:
			case BuildTarget.StandaloneOSXIntel:
			case BuildTarget.StandaloneOSXIntel64:
			case BuildTarget.MetroPlayerX64:
			case BuildTarget.MetroPlayerX86:
			case BuildTarget.MetroPlayerARM:
			case BuildTarget.WebGL:
				return true;

			default:
				return false;
		}
	}
	/// <summary>
	/// 5.6.0 and greater and (Not Release or IsSupported)
	/// </summary>
	public static bool HasPerformanceReportingSettings(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
	{
		if (version.LessThan(5, 6))
		{
			return false;
		}
		if (!flags.IsRelease())
		{
			return true;
		}
		switch (platform)
		{
			case BuildTarget.NoTarget:
			case BuildTarget.Android:
			case BuildTarget.iOS:
			case BuildTarget.tvOS:
			case BuildTarget.Tizen:
			case BuildTarget.StandaloneWinPlayer:
			case BuildTarget.StandaloneWin64Player:
			case BuildTarget.StandaloneLinux:
			case BuildTarget.StandaloneLinux64:
			case BuildTarget.StandaloneLinuxUniversal:
			case BuildTarget.StandaloneOSXUniversal:
			case BuildTarget.StandaloneOSXIntel:
			case BuildTarget.StandaloneOSXIntel64:
			case BuildTarget.MetroPlayerX64:
			case BuildTarget.MetroPlayerX86:
			case BuildTarget.MetroPlayerARM:
			case BuildTarget.WebGL:
				return true;

			default:
				return false;
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/UnityObjectBaseExtensions.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.SourceGenerated.Extensions;

public static class UnityObjectBaseExtensions
{
	public static string GetOriginalName(this IUnityObjectBase _this)
	{
		if (_this is INamed named)
		{
			return named.Name;
		}
		else
		{
			throw new Exception($"Unable to get name for {_this.ClassID}");
		}
	}

	public static string? TryGetName(this IUnityObjectBase _this)
	{
		return (_this as INamed)?.Name;
	}

	public static string GetLogString(this IUnityObjectBase asset)
	{
		string? name = asset.TryGetName();
		if (name == null)
		{
			return $"{asset.ClassID}_{asset.PathID}";
		}
		else
		{
			return $"{asset.ClassID}_{asset.PathID}({name})";
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/UnityPropertySheetExtensions.cs`:

```cs
using AssetRipper.Checksum;
using AssetRipper.SourceGenerated.Subclasses.UnityPropertySheet;

namespace AssetRipper.SourceGenerated.Extensions;

public static class UnityPropertySheetExtensions
{
	private const string HDRPostfixName = "_HDR";
	private const string STPostfixName = "_ST";
	private const string TexelSizePostfixName = "_TexelSize";

	public static string? FindPropertyNameByCRC28(this IUnityPropertySheet sheet, uint crc)
	{
		foreach (Utf8String property in sheet.GetTexEnvNames())
		{
			string propertyString = property.String;
			string hdrName = propertyString + HDRPostfixName;
			if (Crc28Algorithm.MatchUTF8(hdrName, crc))
			{
				return hdrName;
			}
			string stName = propertyString + STPostfixName;
			if (Crc28Algorithm.MatchUTF8(stName, crc))
			{
				return stName;
			}
			string texelName = propertyString + TexelSizePostfixName;
			if (Crc28Algorithm.MatchUTF8(texelName, crc))
			{
				return texelName;
			}
		}
		foreach (Utf8String property in sheet.GetFloatNames())
		{
			string propertyString = property.String;
			if (Crc28Algorithm.MatchUTF8(propertyString, crc))
			{
				return propertyString;
			}
		}
		foreach (Utf8String property in sheet.GetIntNames())
		{
			string propertyString = property.String;
			if (Crc28Algorithm.MatchUTF8(propertyString, crc))
			{
				return propertyString;
			}
		}
		foreach (Utf8String property in sheet.GetColorNames())
		{
			string propertyString = property.String;
			if (Crc28Algorithm.MatchUTF8(propertyString, crc))
			{
				return propertyString;
			}
		}
		return null;
	}

	private static IEnumerable<Utf8String> GetTexEnvNames(this IUnityPropertySheet sheet)
	{
		if (sheet.Has_TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_3_5())
		{
			return sheet.TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_3_5.Keys.Select(n => n.Name);
		}
		else if (sheet.Has_TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_5())
		{
			return sheet.TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_5.Keys.Select(n => n.Name);
		}
		else if (sheet.Has_TexEnvs_AssetDictionary_Utf8String_UnityTexEnv_5())
		{
			return sheet.TexEnvs_AssetDictionary_Utf8String_UnityTexEnv_5.Keys;
		}
		else
		{
			throw new NotSupportedException(sheet.GetType().FullName);
		}
	}

	private static IEnumerable<Utf8String> GetColorNames(this IUnityPropertySheet sheet)
	{
		if (sheet.Has_Colors_AssetDictionary_FastPropertyName_ColorRGBAf())
		{
			return sheet.Colors_AssetDictionary_FastPropertyName_ColorRGBAf.Keys.Select(n => n.Name);
		}
		else if (sheet.Has_Colors_AssetDictionary_Utf8String_ColorRGBAf())
		{
			return sheet.Colors_AssetDictionary_Utf8String_ColorRGBAf.Keys;
		}
		else
		{
			throw new NotSupportedException(sheet.GetType().FullName);
		}
	}

	private static IEnumerable<Utf8String> GetFloatNames(this IUnityPropertySheet sheet)
	{
		if (sheet.Has_Floats_AssetDictionary_FastPropertyName_Single())
		{
			return sheet.Floats_AssetDictionary_FastPropertyName_Single.Keys.Select(n => n.Name);
		}
		else if (sheet.Has_Floats_AssetDictionary_Utf8String_Single())
		{
			return sheet.Floats_AssetDictionary_Utf8String_Single.Keys;
		}
		else
		{
			throw new NotSupportedException(sheet.GetType().FullName);
		}
	}

	private static IEnumerable<Utf8String> GetIntNames(this IUnityPropertySheet sheet)
	{
		if (sheet.Has_Ints())
		{
			return sheet.Ints.Keys;
		}
		else
		{
			return Enumerable.Empty<Utf8String>();
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/UnityVersionExtensions.cs`:

```cs
namespace AssetRipper.SourceGenerated.Extensions;

public static class UnityVersionExtensions
{
	extension(UnityVersion)
	{
		public static UnityVersion V_5_3 => new UnityVersion(5, 3);
		public static UnityVersion V_5_4 => new UnityVersion(5, 4);
		public static UnityVersion V_5_5 => new UnityVersion(5, 5);
		public static UnityVersion V_5_6 => new UnityVersion(5, 6);
		public static UnityVersion V_2017 => new UnityVersion(2017);
		public static UnityVersion V_2018 => new UnityVersion(2018);
		public static UnityVersion V_2019 => new UnityVersion(2019);
		public static UnityVersion V_2020 => new UnityVersion(2020);
		public static UnityVersion V_2021 => new UnityVersion(2021);
		public static UnityVersion V_2022 => new UnityVersion(2022);
		public static UnityVersion V_2023 => new UnityVersion(2023);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Usings.cs`:

```cs
global using AssetRipper.Primitives;

```

`Source/AssetRipper.SourceGenerated.Extensions/ValueConstantExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.NativeEnums.Animation;
using AssetRipper.SourceGenerated.Subclasses.ValueConstant;

namespace AssetRipper.SourceGenerated.Extensions;

public static class ValueConstantExtensions
{
	public static AnimatorControllerParameterType GetTypeValue(this IValueConstant valueConstant)
	{
		return (AnimatorControllerParameterType)valueConstant.Type;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Vector2fExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.Vector2f;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class Vector2fExtensions
{
	public static void Scale(this Vector2f vector, float scalar)
	{
		vector.X *= scalar;
		vector.Y *= scalar;
	}

	public static void CopyValues(this Vector2f vector, Vector2 source)
	{
		vector.X = source.X;
		vector.Y = source.Y;
	}

	public static Vector2 CastToStruct(this Vector2f vector)
	{
		return new Vector2(vector.X, vector.Y);
	}

	public static void SetOne(this Vector2f vector)
	{
		vector.X = 1.0f;
		vector.Y = 1.0f;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Vector3CurveExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Subclasses.Vector3Curve;

namespace AssetRipper.SourceGenerated.Extensions;

public static class Vector3CurveExtensions
{
	public static void SetValues(this IVector3Curve curve, string path)
	{
		curve.Path = path;
		curve.Curve.SetDefaultRotationOrderAndCurveLoopType();
	}

	public static void SetValues(this IVector3Curve curve, string path, RotationOrder rotationOrder)
	{
		curve.Path = path;
		curve.Curve.SetDefaultRotationOrderAndCurveLoopType();
		curve.Curve.RotationOrderE = rotationOrder;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Vector3fExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.Vector3f;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class Vector3fExtensions
{
	public static void Scale(this IVector3f vector, float scalar)
	{
		vector.X *= scalar;
		vector.Y *= scalar;
		vector.Z *= scalar;
	}

	public static void CopyValues(this IVector3f vector, Vector3 source)
	{
		vector.X = source.X;
		vector.Y = source.Y;
		vector.Z = source.Z;
	}

	public static void SetZero(this IVector3f vector) => vector.CopyValues(Vector3.Zero);

	public static void SetOne(this IVector3f vector) => vector.CopyValues(Vector3.One);

	public static Vector3 CastToStruct(this IVector3f vector)
	{
		return new Vector3(vector.X, vector.Y, vector.Z);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/Vector4fExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.Vector4f;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class Vector4fExtensions
{
	public static void Scale(this IVector4f vector, float scalar)
	{
		vector.X *= scalar;
		vector.Y *= scalar;
		vector.Z *= scalar;
		vector.W *= scalar;
	}

	public static Vector4 CastToStruct(this IVector4f vector)
	{
		return new Vector4(vector.X, vector.Y, vector.Z, vector.W);
	}

	public static void CopyValues(this IVector4f vector, Vector4 source)
	{
		vector.X = source.X;
		vector.Y = source.Y;
		vector.Z = source.Z;
		vector.W = source.W;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/VectorParameterExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions.Enums.Shader;
using AssetRipper.SourceGenerated.Subclasses.VectorParameter;

namespace AssetRipper.SourceGenerated.Extensions;

public static class VectorParameterExtensions
{
	public static void SetValues(this IVectorParameter parameter, string name, ShaderParamType type, int index, int columns)
	{
		//parameter.Name = name;//Name doesn't exist
		parameter.NameIndex = -1;
		parameter.Index = index;
		parameter.ArraySize = 0;
		parameter.Type = (sbyte)type;
		parameter.Dim = (sbyte)columns;
	}

	public static ShaderParamType GetType_(this IVectorParameter parameter)
	{
		return (ShaderParamType)parameter.Type;
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/VertexDataBlob.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Subclasses.ChannelInfo;
using AssetRipper.SourceGenerated.Subclasses.StreamInfo;
using AssetRipper.SourceGenerated.Subclasses.VertexData;
using System.Buffers.Binary;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public readonly record struct VertexDataBlob(
	IReadOnlyList<ChannelInfo> Channels,
	IReadOnlyList<IStreamInfo> Streams,
	byte[] Data,
	int VertexCount,
	UnityVersion Version,
	EndianType EndianType)
{
	private const int VertexStreamAlign = 16;

	public static VertexDataBlob Create(IMesh mesh)
	{
		return Create(mesh.VertexData, mesh.Collection.Version, mesh.Collection.EndianType, mesh.GetVertexDataBytes());
	}

	public static VertexDataBlob Create(IVertexData vertexData, UnityVersion version, EndianType endianType)
	{
		return Create(vertexData, version, endianType, vertexData.Data);
	}

	private static VertexDataBlob Create(IVertexData vertexData, UnityVersion version, EndianType endianType, byte[] data)
	{
		IReadOnlyList<ChannelInfo> channels;
		IReadOnlyList<IStreamInfo> streams;
		if (vertexData.Has_Channels())
		{
			channels = vertexData.Channels;
			streams = vertexData.GetStreams() ?? ConvertChannelsToStreams(vertexData.Channels, vertexData.VertexCount, version);
		}
		else
		{
			streams = vertexData.GetStreams()!;
			channels = ConvertStreamsToChannels(streams, version);
		}
		return new VertexDataBlob(channels, streams, data, (int)vertexData.VertexCount, version, endianType);
	}

	public static VertexDataBlob Create(MeshData meshData, UnityVersion version, EndianType endianType)
	{
		if (meshData.Vertices.Length == 0)
		{
			return new VertexDataBlob([], [], [], 0, version, endianType);
		}

		byte[] data;
		List<ChannelInfo> channels = new List<ChannelInfo>();
		{
			using MemoryStream memoryStream = new();
			using EndianWriter writer = new(memoryStream, endianType);

			if (version.GreaterThanOrEquals(2018))
			{
				//kShaderChannelVertex
				channels.Add(CreateChannelInfoForFloatVector(3, 0, version));
				Write(writer, meshData.Vertices);
				WriteAlignmentBytes(writer);

				//kShaderChannelNormal
				if (meshData.HasNormals)
				{
					// Maybe this should be dimension 4? I've seen models with 4D normals. The W component is always 0.
					channels.Add(CreateChannelInfoForFloatVector(3, 1, version));
					Write(writer, meshData.Normals);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 1, version));
				}

				//kShaderChannelTangent
				if (meshData.HasTangents)
				{
					channels.Add(CreateChannelInfoForFloatVector(4, 2, version));
					Write(writer, meshData.Tangents);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 2, version));
				}

				//kShaderChannelColor
				if (meshData.HasColors)
				{
					channels.Add(new ChannelInfo()
					{
						Dimension = GetColorDimension(version),
						Offset = 0,
						Format = (byte)MeshHelper.GetChannelFormat_Color(version),
						Stream = 3,
					});
					for (int i = 0; i < meshData.Colors.Length; i++)
					{
						writer.Write((Color32)meshData.Colors[i]);
					}
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 3, version));
				}

				//kShaderChannelTexCoord0
				if (meshData.HasUV0)
				{
					channels.Add(CreateChannelInfoForFloatVector(2, 4, version));
					Write(writer, meshData.UV0);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 4, version));
				}

				//kShaderChannelTexCoord1
				if (meshData.HasUV1)
				{
					channels.Add(CreateChannelInfoForFloatVector(2, 5, version));
					Write(writer, meshData.UV1);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 5, version));
				}

				//kShaderChannelTexCoord2
				if (meshData.HasUV2)
				{
					channels.Add(CreateChannelInfoForFloatVector(2, 6, version));
					Write(writer, meshData.UV2);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 6, version));
				}

				//kShaderChannelTexCoord3
				if (meshData.HasUV3)
				{
					channels.Add(CreateChannelInfoForFloatVector(2, 7, version));
					Write(writer, meshData.UV3);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 7, version));
				}

				//kShaderChannelTexCoord4
				if (meshData.HasUV4)
				{
					channels.Add(CreateChannelInfoForFloatVector(2, 8, version));
					Write(writer, meshData.UV4);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 8, version));
				}

				//kShaderChannelTexCoord5
				if (meshData.HasUV5)
				{
					channels.Add(CreateChannelInfoForFloatVector(2, 9, version));
					Write(writer, meshData.UV5);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 9, version));
				}

				//kShaderChannelTexCoord6
				if (meshData.HasUV6)
				{
					channels.Add(CreateChannelInfoForFloatVector(2, 10, version));
					Write(writer, meshData.UV6);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 10, version));
				}

				//kShaderChannelTexCoord7
				if (meshData.HasUV7)
				{
					channels.Add(CreateChannelInfoForFloatVector(2, 11, version));
					Write(writer, meshData.UV7);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 11, version));
				}

				if (version.GreaterThanOrEquals(2018, 2))
				{
					if (meshData.HasSkin)
					{
						//todo

						//kShaderChannelBlendWeight
						channels.Add(CreateChannelInfoForFloatVector(0, 12, version));
						//kShaderChannelBlendIndices
						channels.Add(CreateChannelInfoForFloatVector(0, 13, version));
					}
					else
					{
						//kShaderChannelBlendWeight
						channels.Add(CreateChannelInfoForFloatVector(0, 12, version));
						//kShaderChannelBlendIndices
						channels.Add(CreateChannelInfoForFloatVector(0, 13, version));
					}
				}
			}
			else
			{
				//kShaderChannelVertex
				channels.Add(CreateChannelInfoForFloatVector(3, 0, version));
				Write(writer, meshData.Vertices);
				WriteAlignmentBytes(writer);

				//kShaderChannelNormal
				if (meshData.HasNormals)
				{
					// Maybe this should be dimension 4? I've seen models with 4D normals. The W component is always 0.
					channels.Add(CreateChannelInfoForFloatVector(3, 1, version));
					Write(writer, meshData.Normals);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 1, version));
				}

				//kShaderChannelColor
				if (meshData.HasColors)
				{
					channels.Add(new ChannelInfo()
					{
						Dimension = GetColorDimension(version),
						Offset = 0,
						Format = (byte)MeshHelper.GetChannelFormat_Color(version),
						Stream = 2,
					});
					for (int i = 0; i < meshData.Colors.Length; i++)
					{
						writer.Write((Color32)meshData.Colors[i]);
					}
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 2, version));
				}

				//kShaderChannelTexCoord0
				if (meshData.HasUV0)
				{
					channels.Add(CreateChannelInfoForFloatVector(2, 3, version));
					Write(writer, meshData.UV0);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 3, version));
				}

				//kShaderChannelTexCoord1
				if (meshData.HasUV1)
				{
					channels.Add(CreateChannelInfoForFloatVector(2, 4, version));
					Write(writer, meshData.UV1);
					WriteAlignmentBytes(writer);
				}
				else
				{
					channels.Add(CreateChannelInfoForFloatVector(0, 4, version));
				}

				if (version.LessThan(5))
				{
					//kShaderChannelTangent
					if (meshData.HasTangents)
					{
						channels.Add(CreateChannelInfoForFloatVector(4, 5, version));
						Write(writer, meshData.Tangents);
						WriteAlignmentBytes(writer);
					}
					else
					{
						channels.Add(CreateChannelInfoForFloatVector(0, 5, version));
					}
				}
				else
				{
					//kShaderChannelTexCoord2
					if (meshData.HasUV2)
					{
						channels.Add(CreateChannelInfoForFloatVector(2, 5, version));
						Write(writer, meshData.UV2);
						WriteAlignmentBytes(writer);
					}
					else
					{
						channels.Add(CreateChannelInfoForFloatVector(0, 5, version));
					}

					//kShaderChannelTexCoord3
					if (meshData.HasUV3)
					{
						channels.Add(CreateChannelInfoForFloatVector(2, 6, version));
						Write(writer, meshData.UV3);
						WriteAlignmentBytes(writer);
					}
					else
					{
						channels.Add(CreateChannelInfoForFloatVector(0, 6, version));
					}

					//kShaderChannelTangent
					if (meshData.HasTangents)
					{
						channels.Add(CreateChannelInfoForFloatVector(4, 7, version));
						Write(writer, meshData.Tangents);
						WriteAlignmentBytes(writer);
					}
					else
					{
						channels.Add(CreateChannelInfoForFloatVector(0, 7, version));
					}
				}
			}

			writer.Flush();
			memoryStream.Flush();
			data = memoryStream.ToArray();
		}

		IReadOnlyList<IStreamInfo> streams = ConvertChannelsToStreams(channels, (uint)meshData.Vertices.Length, version);
		return new VertexDataBlob(channels, streams, data, meshData.Vertices.Length, version, endianType);
	}

	private static ChannelInfo CreateChannelInfoForFloatVector(byte dimension, byte streamIndex, UnityVersion version)
	{
		return new ChannelInfo()
		{
			Dimension = dimension,
			Offset = 0,
			Format = (byte)MeshHelper.ToChannelFormat(MeshHelper.VertexFormat.kVertexFormatFloat, version),
			Stream = streamIndex,
		};
	}

	private static byte GetColorDimension(UnityVersion version)
	{
		// Todo: Need to check various Unity versions
		if (version.GreaterThanOrEquals(2018))
		{
			return 4;
		}
		else
		{
			return 1;
		}
	}

	private static void Write(EndianWriter writer, Vector2[] vertices)
	{
		for (int i = 0; i < vertices.Length; i++)
		{
			writer.Write(vertices[i]);
		}
	}

	private static void Write(EndianWriter writer, Vector3[] vertices)
	{
		for (int i = 0; i < vertices.Length; i++)
		{
			writer.Write(vertices[i]);
		}
	}

	private static void Write(EndianWriter writer, Vector4[] vertices)
	{
		for (int i = 0; i < vertices.Length; i++)
		{
			writer.Write(vertices[i]);
		}
	}

	private static void WriteAlignmentBytes(EndianWriter writer)
	{
		int align = VertexStreamAlign - (int)writer.BaseStream.Position % VertexStreamAlign;
		if (align != VertexStreamAlign)
		{
			Span<byte> span = stackalloc byte[align];
			span.Clear();
			writer.Write(span);
		}
	}

	public MeshData ToMeshData()
	{
		if (ReadData(
			out Vector3[]? vertices,
			out Vector3[]? normals,
			out Vector4[]? tangents,
			out ColorFloat[]? colors,
			out Vector2[]? uv0,
			out Vector2[]? uv1,
			out Vector2[]? uv2,
			out Vector2[]? uv3,
			out Vector2[]? uv4,
			out Vector2[]? uv5,
			out Vector2[]? uv6,
			out Vector2[]? uv7,
			out BoneWeight4[]? skin))
		{
			return new MeshData(vertices, normals, tangents, colors, uv0, uv1, uv2, uv3, uv4, uv5, uv6, uv7, skin, [], [], []);
		}
		else
		{
			return MeshData.Empty;
		}
	}

	public VertexDataBlob MakeLittleEndian()
	{
		if (EndianType == EndianType.LittleEndian)
		{
			return this;
		}

		MeshData meshData = ToMeshData();
		return Create(meshData, Version, EndianType.LittleEndian);
	}

	public bool ReadData(
		[NotNullWhen(true)] out Vector3[]? vertices,
		out Vector3[]? normals,
		out Vector4[]? tangents,
		out ColorFloat[]? colors,
		out Vector2[]? uv0,
		out Vector2[]? uv1,
		out Vector2[]? uv2,
		out Vector2[]? uv3,
		out Vector2[]? uv4,
		out Vector2[]? uv5,
		out Vector2[]? uv6,
		out Vector2[]? uv7,
		out BoneWeight4[]? skin)
	{
		int vertexCount = VertexCount;

		vertices = default;
		normals = default;
		tangents = default;
		colors = default;
		uv0 = default;
		uv1 = default;
		uv2 = default;
		uv3 = default;
		uv4 = default;
		uv5 = default;
		uv6 = default;
		uv7 = default;
		skin = default;

		byte[] data = Data;
		if (data.Length == 0)
		{
			return false;
		}

		for (int chn = 0; chn < Channels.Count; chn++)
		{
			ChannelInfo channel = Channels[chn];

			byte dimension = GetChannelDimension(channel, chn, Version);

			if (dimension == 0)
			{
				continue;
			}
			IStreamInfo m_Stream = Streams[channel.Stream];
			if (!GetBit(m_Stream.ChannelMask, chn))
			{
				continue;
			}

			MeshHelper.VertexFormat vertexFormat = MeshHelper.ToVertexFormat(channel.Format, Version);
			int componentByteSize = MeshHelper.GetFormatSize(vertexFormat);
			byte[] componentBytes = new byte[vertexCount * dimension * componentByteSize];
			for (int v = 0; v < vertexCount; v++)
			{
				int vertexOffset = (int)m_Stream.Offset + channel.Offset + (int)m_Stream.GetStride() * v;
				for (int d = 0; d < dimension; d++)
				{
					int componentOffset = vertexOffset + componentByteSize * d;
					Buffer.BlockCopy(data, componentOffset, componentBytes, componentByteSize * (v * dimension + d), componentByteSize);
				}
			}

			if (EndianType == EndianType.BigEndian && componentByteSize > 1) //swap bytes
			{
				if (componentBytes.Length % componentByteSize != 0)
				{
					throw new InvalidDataException("Component bytes length is not divisible by component byte size");
				}

				switch (componentByteSize)
				{
					case sizeof(ushort):
						for (int i = componentBytes.Length - sizeof(ushort); i >= 0; i -= sizeof(ushort))
						{
							Span<byte> span = componentBytes.AsSpan(i);
							ushort value = BinaryPrimitives.ReadUInt16BigEndian(span);
							BinaryPrimitives.WriteUInt16LittleEndian(span, value);
						}
						break;
					case sizeof(uint):
						for (int i = componentBytes.Length - sizeof(uint); i >= 0; i -= sizeof(uint))
						{
							Span<byte> span = componentBytes.AsSpan(i);
							uint value = BinaryPrimitives.ReadUInt32BigEndian(span);
							BinaryPrimitives.WriteUInt32LittleEndian(span, value);
						}
						break;
				}
			}

			int[] componentsIntArray;
			float[] componentsFloatArray;
			if (MeshHelper.IsIntFormat(vertexFormat))
			{
				componentsIntArray = MeshHelper.BytesToIntArray(componentBytes, vertexFormat);
				componentsFloatArray = [];
			}
			else
			{
				componentsIntArray = [];
				componentsFloatArray = MeshHelper.BytesToFloatArray(componentBytes, vertexFormat);
			}

			if (Version.GreaterThanOrEquals(2018))
			{
				switch (chn)
				{
					case 0: //kShaderChannelVertex
						vertices = MeshHelper.FloatArrayToVector3(componentsFloatArray, dimension);
						break;
					case 1: //kShaderChannelNormal
						normals = MeshHelper.FloatArrayToVector3(componentsFloatArray, dimension);
						break;
					case 2: //kShaderChannelTangent
						tangents = MeshHelper.FloatArrayToVector4(componentsFloatArray, dimension);
						break;
					case 3: //kShaderChannelColor
						colors = MeshHelper.FloatArrayToColorFloat(componentsFloatArray);
						break;
					case 4: //kShaderChannelTexCoord0
						uv0 = MeshHelper.FloatArrayToVector2(componentsFloatArray, dimension);
						break;
					case 5: //kShaderChannelTexCoord1
						uv1 = MeshHelper.FloatArrayToVector2(componentsFloatArray, dimension);
						break;
					case 6: //kShaderChannelTexCoord2
						uv2 = MeshHelper.FloatArrayToVector2(componentsFloatArray, dimension);
						break;
					case 7: //kShaderChannelTexCoord3
						uv3 = MeshHelper.FloatArrayToVector2(componentsFloatArray, dimension);
						break;
					case 8: //kShaderChannelTexCoord4
						uv4 = MeshHelper.FloatArrayToVector2(componentsFloatArray, dimension);
						break;
					case 9: //kShaderChannelTexCoord5
						uv5 = MeshHelper.FloatArrayToVector2(componentsFloatArray, dimension);
						break;
					case 10: //kShaderChannelTexCoord6
						uv6 = MeshHelper.FloatArrayToVector2(componentsFloatArray, dimension);
						break;
					case 11: //kShaderChannelTexCoord7
						uv7 = MeshHelper.FloatArrayToVector2(componentsFloatArray, dimension);
						break;
					//2018.2 and up
					case 12: //kShaderChannelBlendWeight
						skin ??= new BoneWeight4[vertexCount];
						for (int i = 0; i < vertexCount; i++)
						{
							BoneWeight4 boneWeight = skin[i];
							for (int j = 0; j < dimension; j++)
							{
								boneWeight.Weights[j] = componentsFloatArray[i * dimension + j];
							}
							skin[i] = boneWeight;
						}
						break;
					case 13: //kShaderChannelBlendIndices
						skin ??= new BoneWeight4[vertexCount];
						for (int i = 0; i < vertexCount; i++)
						{
							BoneWeight4 boneWeight = skin[i];
							for (int j = 0; j < dimension; j++)
							{
								boneWeight.Indices[j] = componentsIntArray[i * dimension + j];
							}
							skin[i] = boneWeight;
						}
						break;
				}
			}
			else
			{
				switch (chn)
				{
					case 0: //kShaderChannelVertex
						vertices = MeshHelper.FloatArrayToVector3(componentsFloatArray, dimension);
						break;
					case 1: //kShaderChannelNormal
						normals = MeshHelper.FloatArrayToVector3(componentsFloatArray, dimension);
						break;
					case 2: //kShaderChannelColor
						colors = MeshHelper.FloatArrayToColorFloat(componentsFloatArray);
						break;
					case 3: //kShaderChannelTexCoord0
						uv0 = MeshHelper.FloatArrayToVector2(componentsFloatArray, dimension);
						break;
					case 4: //kShaderChannelTexCoord1
						uv1 = MeshHelper.FloatArrayToVector2(componentsFloatArray, dimension);
						break;
					case 5:
						if (Version.GreaterThanOrEquals(5)) //kShaderChannelTexCoord2
						{
							uv2 = MeshHelper.FloatArrayToVector2(componentsFloatArray, dimension);
						}
						else //kShaderChannelTangent
						{
							tangents = MeshHelper.FloatArrayToVector4(componentsFloatArray, dimension);
						}
						break;
					case 6: //kShaderChannelTexCoord3
						uv3 = MeshHelper.FloatArrayToVector2(componentsFloatArray, dimension);
						break;
					case 7: //kShaderChannelTangent
						tangents = MeshHelper.FloatArrayToVector4(componentsFloatArray, dimension);
						break;
				}
			}
		}

		return vertices is not null;
	}

	private static bool GetBit(uint mask, int index)
	{
		return (mask & (1u << index)) != 0;
	}

	public int GetStreamStride(int stream)
	{
		return (int)Streams[stream].GetStride();
	}

	public int GetStreamSize(int stream)
	{
		return GetStreamStride(stream) * VertexCount;
	}

	public int GetStreamOffset(int stream)
	{
		int offset = 0;
		for (int i = 0; i < stream; i++)
		{
			offset += GetStreamSize(i);
			offset = (offset + (VertexStreamAlign - 1)) & ~(VertexStreamAlign - 1);
		}
		return offset;
	}

	private static IStreamInfo[] ConvertChannelsToStreams(IReadOnlyList<ChannelInfo> channels, uint vertexCount, UnityVersion version)
	{
		if (channels.Count == 0)
		{
			return [];
		}

		int streamCount = channels.Max(x => x.Stream) + 1;
		IStreamInfo[] streams = new IStreamInfo[streamCount];
		long offset = 0;
		for (int s = 0; s < streamCount; s++)
		{
			uint chnMask = 0;
			uint stride = 0;
			for (int chn = 0; chn < channels.Count; chn++)
			{
				ChannelInfo channel = channels[chn];
				if (channel.Stream == s)
				{
					byte dimension = GetChannelDimension(channel, chn, version);

					if (dimension > 0)
					{
						chnMask |= 1u << chn;
						stride += dimension * (uint)MeshHelper.GetFormatSize(MeshHelper.ToVertexFormat(channel.Format, version));
					}
				}
			}

			StreamInfo_4 newStream = new()
			{
				ChannelMask = chnMask,
				Offset = (uint)offset,
				Stride_Byte = (byte)stride,
				DividerOp = 0,
				Frequency = 0,
			};
			streams[s] = newStream;

			offset += vertexCount * stride;
			offset = AlignStream(offset);
		}
		return streams;
	}

	private static byte GetChannelDimension(ChannelInfo channel, int chn, UnityVersion version)
	{
		if (version.LessThan(2018) && chn == 2 && channel.Format == 2) //kShaderChannelColor && kChannelFormatColor
		{
			return 4;
		}
		else
		{
			return channel.GetDataDimension();
		}
	}

	private static IReadOnlyList<ChannelInfo> ConvertStreamsToChannels(IReadOnlyList<IStreamInfo> streams, UnityVersion version)
	{
		List<ChannelInfo> channels = new List<ChannelInfo>(6);
		for (int s = 0; s < streams.Count; s++)
		{
			IStreamInfo m_Stream = streams[s];
			byte offset = 0;
			for (int i = 0; i < 6; i++)
			{
				if (!GetBit(m_Stream.ChannelMask, i))
				{
					continue;
				}

				ChannelInfo m_Channel = new();
				m_Channel.Stream = (byte)s;
				m_Channel.Offset = offset;
				switch (i)
				{
					case 0: //kShaderChannelVertex
					case 1: //kShaderChannelNormal
						m_Channel.Format = 0; //kChannelFormatFloat
						m_Channel.SetDataDimension(3);
						break;
					case 2: //kShaderChannelColor
						m_Channel.Format = 2; //kChannelFormatColor
						m_Channel.SetDataDimension(4);
						break;
					case 3: //kShaderChannelTexCoord0
					case 4: //kShaderChannelTexCoord1
						m_Channel.Format = 0; //kChannelFormatFloat
						m_Channel.SetDataDimension(2);
						break;
					case 5: //kShaderChannelTangent
						m_Channel.Format = 0; //kChannelFormatFloat
						m_Channel.SetDataDimension(4);
						break;
				}
				offset += (byte)(m_Channel.GetDataDimension() * MeshHelper.GetFormatSize(MeshHelper.ToVertexFormat(m_Channel.Format, version)));
				channels.Add(m_Channel);
			}
		}
		return channels;
	}

	private static long AlignStream(long offset)
	{
		return offset + (VertexStreamAlign - 1L) & ~(VertexStreamAlign - 1L);
	}

	public static bool SupportsUV2(UnityVersion version)
	{
		return version.GreaterThanOrEquals(5);
	}

	public static bool SupportsUV3(UnityVersion version)
	{
		return version.GreaterThanOrEquals(5);
	}

	public static bool SupportsUV4(UnityVersion version)
	{
		return version.GreaterThanOrEquals(2018);
	}

	public static bool SupportsUV5(UnityVersion version)
	{
		return version.GreaterThanOrEquals(2018);
	}

	public static bool SupportsUV6(UnityVersion version)
	{
		return version.GreaterThanOrEquals(2018);
	}

	public static bool SupportsUV7(UnityVersion version)
	{
		return version.GreaterThanOrEquals(2018);
	}

	public static bool SupportsSkin(UnityVersion version)
	{
		return version.GreaterThanOrEquals(2018, 2);
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/VertexDataExtensions.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.ShaderChannel;
using AssetRipper.SourceGenerated.Extensions.Enums.Shader.VertexFormat;
using AssetRipper.SourceGenerated.Subclasses.ChannelInfo;
using AssetRipper.SourceGenerated.Subclasses.StreamInfo;
using AssetRipper.SourceGenerated.Subclasses.StreamingInfo;
using AssetRipper.SourceGenerated.Subclasses.SubMesh;
using AssetRipper.SourceGenerated.Subclasses.VertexData;
using System.Numerics;

namespace AssetRipper.SourceGenerated.Extensions;

public static class VertexDataExtensions
{
	private const int VertexStreamAlign = 16;

	public static bool IsSet(this IVertexData instance, IStreamingInfo? streamingInfo)
	{
		return instance.VertexCount > 0 && (instance.Data.Length > 0 || streamingInfo is not null && streamingInfo.IsSet());
	}

	public static IReadOnlyList<IStreamInfo>? GetStreams(this IVertexData instance)
	{
		if (instance.Has_Streams())
		{
			return instance.Streams;
		}
		else if (instance.Has_Streams_0_())
		{
			return
			[
				instance.Streams_0_,
				instance.Streams_1_,
				instance.Streams_2_,
				instance.Streams_3_
			];
		}
		else
		{
			return null;
		}
	}

	public static uint GetCurrentChannels(this IVertexData instance)
	{
		if (instance.Has_CurrentChannels_Int32())
		{
			return unchecked((uint)instance.CurrentChannels_Int32);
		}
		else
		{
			return instance.CurrentChannels_UInt32;
		}
	}

	public static void SetCurrentChannels(this IVertexData instance, uint value)
	{
		if (instance.Has_CurrentChannels_Int32())
		{
			instance.CurrentChannels_Int32 = unchecked((int)value);
		}
		else
		{
			instance.CurrentChannels_UInt32 = value;
		}
	}

	/// <summary>
	/// 5.6.0
	/// </summary>
	private static bool AllowUnsetVertexChannel(UnityVersion version) => version.Equals(5, 6, 0);

	public static ChannelInfo GetChannel(this IVertexData instance, UnityVersion version, ShaderChannel channelType)
	{
		if (instance.Has_Channels())
		{
			return instance.Channels[channelType.ToChannel(version)];
		}
		else
		{
			IReadOnlyList<IStreamInfo> streams = instance.GetStreams()!;
			ChannelInfo channelInfo = new();
			ShaderChannel4 channelv4 = channelType.ToShaderChannel4();
			int streamIndex = streams.IndexOf(t => t.IsMatch(channelv4));
			if (streamIndex >= 0)
			{
				byte offset = 0;
				IStreamInfo stream = streams[streamIndex];
				for (ShaderChannel4 i = 0; i < channelv4; i++)
				{
					if (stream.IsMatch(i))
					{
						offset += i.ToShaderChannel().GetStride(version);
					}
				}

				channelInfo.Stream = (byte)streamIndex;
				channelInfo.Offset = offset;
				channelInfo.Format = channelType.GetVertexFormat(version).ToFormat(version);
				channelInfo.Dimension = channelType.GetDimention(version);
			}
			return channelInfo;
		}
	}

	public static BoneWeight4[] GenerateSkin(this IVertexData instance, UnityVersion version)
	{
		if (instance.Channels is null)
		{
			throw new NotImplementedException("GenerateSkin is not implemented for this version.");
		}
		ChannelInfo weightChannel = instance.Channels[(int)ShaderChannel2018.SkinWeight];
		ChannelInfo indexChannel = instance.Channels[(int)ShaderChannel2018.SkinBoneIndex];
		if (!weightChannel.IsSet())
		{
			return Array.Empty<BoneWeight4>();
		}

		BoneWeight4[] skin = new BoneWeight4[instance.VertexCount];
		int weightStride = instance.Channels.Where(t => t.Stream == weightChannel.Stream).Sum(t => t.GetStride(version));
		int weightStreamOffset = instance.GetStreamOffset(version, weightChannel.Stream);
		int indexStride = instance.Channels.Where(t => t.Stream == indexChannel.Stream).Sum(t => t.GetStride(version));
		int indexStreamOffset = instance.GetStreamOffset(version, indexChannel.Stream);

		using MemoryStream memStream = new MemoryStream(instance.Data);
		using BinaryReader reader = new BinaryReader(memStream);

		int weightCount = Math.Min((int)weightChannel.GetDataDimension(), 4);
		int indexCount = Math.Min((int)indexChannel.GetDataDimension(), 4);
		float[] weights = new float[Math.Max(weightCount, 4)];
		int[] indices = new int[Math.Max(indexCount, 4)];
		for (int v = 0; v < instance.VertexCount; v++)
		{
			memStream.Position = weightStreamOffset + v * weightStride + weightChannel.Offset;
			for (int i = 0; i < weightCount; i++)
			{
				weights[i] = reader.ReadSingle();
			}

			memStream.Position = indexStreamOffset + v * indexStride + indexChannel.Offset;
			for (int i = 0; i < indexCount; i++)
			{
				indices[i] = reader.ReadInt32();
			}

			skin[v] = new BoneWeight4(weights[0], weights[1], weights[2], weights[3], indices[0], indices[1], indices[2], indices[3]);
		}
		return skin;
	}

	public static Vector3[] GenerateVertices(this IVertexData instance, UnityVersion version, ISubMesh submesh)
	{
		IChannelInfo channel = instance.GetChannel(version, ShaderChannel.Vertex);
		if (!channel.IsSet())
		{
			if (AllowUnsetVertexChannel(version))
			{
				return Array.Empty<Vector3>();
			}
			else
			{
				throw new Exception("Vertices hasn't been found");
			}
		}

		Vector3[] verts = new Vector3[submesh.VertexCount];
		int streamStride = instance.GetStreamStride(version, channel.Stream);
		int streamOffset = instance.GetStreamOffset(version, channel.Stream);
		using (MemoryStream memStream = new MemoryStream(instance.Data))
		{
			using BinaryReader reader = new BinaryReader(memStream);
			memStream.Position = streamOffset + submesh.FirstVertex * streamStride + channel.Offset;
			for (int v = 0; v < submesh.VertexCount; v++)
			{
				float x = reader.ReadSingle();
				float y = reader.ReadSingle();
				float z = reader.ReadSingle();
				verts[v] = new Vector3(x, y, z);
				memStream.Position += streamStride - 12;
			}
		}
		return verts;
	}

	public static int GetStreamStride(this IVertexData instance, UnityVersion version, int stream)
	{
		return instance.HasStreamsInvariant() ?
			(int)instance.GetStreamsInvariant()[stream].GetStride() : instance.Channels!.Where(t => t.IsSet() && t.Stream == stream).Sum(t => t.GetStride(version));
	}

	public static int GetStreamSize(this IVertexData instance, UnityVersion version, int stream)
	{
		return instance.GetStreamStride(version, stream) * (int)instance.VertexCount;
	}

	public static int GetStreamOffset(this IVertexData instance, UnityVersion version, int stream)
	{
		int offset = 0;
		for (int i = 0; i < stream; i++)
		{
			offset += instance.GetStreamSize(version, i);
			offset = offset + (VertexStreamAlign - 1) & ~(VertexStreamAlign - 1);
		}
		return offset;
	}

	private static bool HasStreamsInvariant(this IVertexData instance) => instance.Has_Streams() || instance.Has_Streams_0_();

	private static IReadOnlyList<IStreamInfo> GetStreamsInvariant(this IVertexData instance)
	{
		if (instance.Has_Streams())
		{
			return instance.Streams;
		}
		else if (instance.Has_Streams_0_())
		{
			return new IStreamInfo[]
			{
				instance.Streams_0_,
				instance.Streams_1_,
				instance.Streams_2_,
				instance.Streams_3_
			};
		}
		else
		{
			return Array.Empty<IStreamInfo>();
		}
	}
}

```

`Source/AssetRipper.SourceGenerated.Extensions/VideoClipExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_329;

namespace AssetRipper.SourceGenerated.Extensions;

public static class VideoClipExtensions
{
	public static bool CheckIntegrity(this IVideoClip clip)
	{
		return clip.ExternalResources.CheckIntegrity(clip.Collection);
	}

	public static bool TryGetContent(this IVideoClip clip, [NotNullWhen(true)] out byte[]? data)
	{
		return clip.ExternalResources.TryGetContent(clip.Collection, out data);
	}

	public static byte[] GetContent(this IVideoClip clip)
	{
		return clip.ExternalResources.GetContent(clip.Collection) ?? [];
	}

	public static string GetExtensionFromPath(this IVideoClip clip)
	{
		return clip.TryGetExtensionFromPath(out string? extension) ? extension : "bytes";
	}

	public static bool TryGetExtensionFromPath(this IVideoClip clip, [NotNullWhen(true)] out string? extension)
	{
		extension = Path.GetExtension(clip.OriginalPath_R);
		if (string.IsNullOrEmpty(extension))
		{
			extension = null;
			return false;
		}
		extension = extension[1..];
		return true;
	}

	public static string? TryGetExtensionFromPath(this IVideoClip clip)
	{
		return clip.TryGetExtensionFromPath(out string? extension) ? extension : null;
	}
}

```

`Source/AssetRipper.Tests/AssetRipper.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<IsPackable>false</IsPackable>
		<OutputPath>..\0Bins\Other\AssetRipper.Tests\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Tests\$(Configuration)\</IntermediateOutputPath>
		<IsAotCompatible>false</IsAotCompatible>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
		<PackageReference Include="Moq" Version="4.20.72" />
		<PackageReference Include="NUnit" Version="4.4.0" />
		<PackageReference Include="NUnit3TestAdapter" Version="6.1.0" />
		<PackageReference Include="NUnit.Analyzers" Version="4.11.2">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Export.PrimaryContent\AssetRipper.Export.PrimaryContent.csproj" />
		<ProjectReference Include="..\AssetRipper.Export.UnityProjects\AssetRipper.Export.UnityProjects.csproj" />
		<ProjectReference Include="..\UnityEngine\UnityEngine.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Tests/CompressedMeshTests.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.CompressedMesh;
using System.Numerics;
using System.Runtime.InteropServices;

namespace AssetRipper.Tests;

internal class CompressedMeshTests
{
	private const int VertexCount = 20;
	private static readonly Random random = new Random(57089);
	private static readonly Vector3[] vectors = MakeUnitVectors(VertexCount);
	private static readonly Vector4[] tangents = MakeTangents(22);
	private static readonly Matrix4x4[] matrices = MakeMatrices(11);
	private static readonly uint[] integers = MakeUInts(24);
	private static readonly Vector2[] uv0 = MakeUV(VertexCount);
	private static readonly Vector2[] uv1 = MakeUV(VertexCount);
	private static readonly BoneWeight4[] boneWeights = MakeBoneWeights(VertexCount);

	private static Vector3[] MakeUnitVectors(int count)
	{
		Vector3[] result = new Vector3[count];
		for (int i = 0; i < count; i++)
		{
			float x = random.NextSingle();
			float y = random.NextSingle();
			float z = random.NextSingle();
			result[i] = Vector3.Normalize(new Vector3(x, y, z));
		}
		return result;
	}

	private static Vector4[] MakeTangents(int count)
	{
		Vector3[] unitVectors = MakeUnitVectors(count);
		Vector4[] result = new Vector4[unitVectors.Length];
		for (int i = 0; i < unitVectors.Length; i++)
		{
			float w = random.NextSingle() < 0.5f ? -1f : 1f;
			result[i] = new Vector4(unitVectors[i], w);
		}
		return result;
	}

	private static Vector2[] MakeUV(int count)
	{
		Vector2[] result = new Vector2[count];
		for (int i = 0; i < count; i++)
		{
			result[i] = new Vector2(random.NextSingle(), random.NextSingle());
		}
		return result;
	}

	private static uint[] MakeUInts(int count)
	{
		uint[] result = new uint[count];
		for (int i = 0; i < count; i++)
		{
			result[i] = unchecked((uint)random.Next());
		}
		return result;
	}

	private static Matrix4x4[] MakeMatrices(int count)
	{
		Matrix4x4[] result = new Matrix4x4[count];
		for (int i = 0; i < count; i++)
		{
			result[i] = new Matrix4x4(
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle(),
				random.NextSingle());
		}
		return result;
	}

	private static BoneWeight4[] MakeBoneWeights(int count)
	{
		BoneWeight4[] result = new BoneWeight4[count];
		for (int i = 0; i < count; i++)
		{
			BoneWeight4 item = new();
			const int MaxSum = 31;
			const float MaxSumF = MaxSum;
			int sum = 0;
			for (int j = 0; j < 4; j++)
			{
				if (sum == MaxSum)
				{
					item.Weights[j] = 0;
					item.Indices[j] = 0;
				}
				else
				{
					int weight;
					if (j == 3)
					{
						weight = MaxSum - sum;
					}
					else
					{
						weight = random.Next(1, MaxSum + 1 - sum);
						sum += weight;
					}
					item.Weights[j] = weight / MaxSumF;
					item.Indices[j] = random.Next(0, count);
					//This might not be the correct range for the index, but it doesn't matter for the tests.
				}
			}
			result[i] = item;
		}
		return result;
	}

	[Test]
	public void VertexAssignmentSymmetry()
	{
		CompressedMesh_5 compressedMesh = new();
		compressedMesh.SetVertices(vectors);
		Vector3[] unpackedValues = compressedMesh.GetVertices();
		AreAlmostEqual(vectors, unpackedValues, 0.000001f);
	}

	[Test]
	public void NormalAssignmentSymmetry()
	{
		CompressedMesh_5 compressedMesh = new();
		compressedMesh.SetNormals(vectors);
		Vector3[] unpackedValues = compressedMesh.GetNormals();
		AreAlmostEqual(vectors, unpackedValues, 0.00001f);
		//Note: this symmetry only happens because the vectors are already normalized.
		//This test would (and should) fail if non-normalized vectors are use.
	}

	[Test]
	public void TangentAssignmentSymmetry()
	{
		CompressedMesh_5 compressedMesh = new();
		compressedMesh.SetTangents(tangents);
		Vector4[] unpackedValues = compressedMesh.GetTangents();
		AreAlmostEqual(tangents, unpackedValues, 0.00001f);
		//Note: this symmetry only happens because the vectors are already normalized.
		//This test would (and should) fail if non-normalized vectors are use.
	}

	[Test]
	public void FloatColorsNormalAssignmentSymmetry()
	{
		CompressedMesh_5 compressedMesh = new();
		//These are technically invalid colors since they have values outside [0,1] but it doesn't matter for the test.
		ReadOnlySpan<ColorFloat> colors = MemoryMarshal.Cast<Vector4, ColorFloat>(tangents);
		compressedMesh.SetFloatColors(colors);
		ColorFloat[] unpackedValues = compressedMesh.GetFloatColors();
		AreAlmostEqual(MemoryMarshal.Cast<ColorFloat, Vector4>(colors), MemoryMarshal.Cast<ColorFloat, Vector4>(unpackedValues), 0.00001f);
	}

	[Test]
	public void BindPoseAssignmentSymmetry()
	{
		CompressedMesh_3_5 compressedMesh = new();//BindPoses only exists on versions before Unity 5.
		compressedMesh.SetBindPoses(matrices);
		Matrix4x4[] unpackedValues = compressedMesh.GetBindPoses();
		AreAlmostEqual(matrices, unpackedValues, 0.000001f);
	}

	[Test]
	public void TriangleAssignmentSymmetry()
	{
		CompressedMesh_5 compressedMesh = new();
		compressedMesh.SetTriangles(integers);
		uint[] unpackedValues = compressedMesh.GetTriangles();
		Assert.That(unpackedValues, Is.EqualTo(integers));
	}

	[Test]
	public void OldUV()
	{
		CompressedMesh_3_5 compressedMesh = new();//UV is structured differently on versions before Unity 5.
		compressedMesh.SetVertices(vectors);//Need to set the correct vertex count by filling the vertex buffer.
		compressedMesh.SetUV(uv0, uv1, null, null, null, null, null, null);
		compressedMesh.GetUV(out Vector2[]? unpackedUV0, out Vector2[]? unpackedUV1, out Vector2[]? unpackedUV2, out Vector2[]? unpackedUV3, out Vector2[]? unpackedUV4, out Vector2[]? unpackedUV5, out Vector2[]? unpackedUV6, out Vector2[]? unpackedUV7);
		using (Assert.EnterMultipleScope())
		{
			//These UV channels did not exist on versions before Unity 5.
			Assert.That(unpackedUV2, Is.Null);
			Assert.That(unpackedUV3, Is.Null);
			Assert.That(unpackedUV4, Is.Null);
			Assert.That(unpackedUV5, Is.Null);
			Assert.That(unpackedUV6, Is.Null);
			Assert.That(unpackedUV7, Is.Null);
		}
		AreAlmostEqual(uv0, unpackedUV0, 0.000001f);
		AreAlmostEqual(uv1, unpackedUV1, 0.000001f);
	}

	[Test]
	public void NewUVWith2Channels()
	{
		CompressedMesh_5 compressedMesh = new();//UV is structured differently on versions before Unity 5.
		compressedMesh.SetVertices(vectors);//Need to set the correct vertex count by filling the vertex buffer.
		compressedMesh.SetUV(uv0, uv1, null, null, null, null, null, null);
		compressedMesh.GetUV(out Vector2[]? unpackedUV0, out Vector2[]? unpackedUV1, out Vector2[]? unpackedUV2, out Vector2[]? unpackedUV3, out Vector2[]? unpackedUV4, out Vector2[]? unpackedUV5, out Vector2[]? unpackedUV6, out Vector2[]? unpackedUV7);
		using (Assert.EnterMultipleScope())
		{
			Assert.That(unpackedUV0, Is.Not.Null, () => "UV0");
			Assert.That(unpackedUV1, Is.Not.Null, () => "UV1");
			Assert.That(unpackedUV2, Is.Null, () => "UV2");
			Assert.That(unpackedUV3, Is.Null, () => "UV3");
			Assert.That(unpackedUV4, Is.Null, () => "UV4");
			Assert.That(unpackedUV5, Is.Null, () => "UV5");
			Assert.That(unpackedUV6, Is.Null, () => "UV6");
			Assert.That(unpackedUV7, Is.Null, () => "UV7");
		}
		AreAlmostEqual(uv0, unpackedUV0, 0.000001f);
		AreAlmostEqual(uv1, unpackedUV1, 0.000001f);
	}

	[Test]
	public void NewUVWith4Channels()
	{
		CompressedMesh_5 compressedMesh = new();//UV only supports more channels after Unity 5.
		compressedMesh.SetVertices(vectors);//Need to set the correct vertex count by filling the vertex buffer.
		compressedMesh.SetUV(uv0, uv1, null, uv1, null, null, uv0, null);
		Assert.That(compressedMesh.UVInfo, Is.GreaterThan(0));
		Assert.That(compressedMesh.UV.NumItems, Is.EqualTo(2 * VertexCount * 4));

		compressedMesh.GetUV(out Vector2[]? unpackedUV0, out Vector2[]? unpackedUV1, out Vector2[]? unpackedUV2, out Vector2[]? unpackedUV3, out Vector2[]? unpackedUV4, out Vector2[]? unpackedUV5, out Vector2[]? unpackedUV6, out Vector2[]? unpackedUV7);

		using (Assert.EnterMultipleScope())
		{
			Assert.That(unpackedUV0, Is.Not.Null, () => "UV0");
			Assert.That(unpackedUV1, Is.Not.Null, () => "UV1");
			Assert.That(unpackedUV2, Is.Null, () => "UV2");
			Assert.That(unpackedUV3, Is.Not.Null, () => "UV3");
			Assert.That(unpackedUV4, Is.Null, () => "UV4");
			Assert.That(unpackedUV5, Is.Null, () => "UV5");
			Assert.That(unpackedUV6, Is.Not.Null, () => "UV6");
			Assert.That(unpackedUV7, Is.Null, () => "UV7");
		}
		AreAlmostEqual(uv0, unpackedUV0, 0.000001f);
		AreAlmostEqual(uv1, unpackedUV1, 0.000001f);
		AreAlmostEqual(uv1, unpackedUV3, 0.000001f);
		AreAlmostEqual(uv0, unpackedUV6, 0.000001f);
	}

	[Test]
	public void BoneWeightAssignmentSymmetry()
	{
		CompressedMesh_5 compressedMesh = new();
		compressedMesh.SetWeights(boneWeights);
		BoneWeight4[] unpackedValues = compressedMesh.GetWeights();
		AreAlmostEqual(boneWeights, unpackedValues, 0.000001f);
	}

	private static void AreAlmostEqual(ReadOnlySpan<Vector2> expected, ReadOnlySpan<Vector2> actual, float maxDeviation)
	{
		if (expected.Length != actual.Length)
		{
			Assert.Fail($"Lengths were inequal.\nExpected: {expected.Length}\nBut was: {actual.Length}");
		}

		for (int i = 0; i < expected.Length; i++)
		{
			if (Vector2.Distance(expected[i], actual[i]) > maxDeviation)
			{
				Assert.Fail($"Values significantly differ at index {i}\nExpected: {expected[i]}\nBut was: {actual[i]}");
			}
		}
	}

	private static void AreAlmostEqual(ReadOnlySpan<Vector3> expected, ReadOnlySpan<Vector3> actual, float maxDeviation)
	{
		if (expected.Length != actual.Length)
		{
			Assert.Fail($"Lengths were inequal.\nExpected: {expected.Length}\nBut was: {actual.Length}");
		}

		for (int i = 0; i < expected.Length; i++)
		{
			if (Vector3.Distance(expected[i], actual[i]) > maxDeviation)
			{
				Assert.Fail($"Values significantly differ at index {i}\nExpected: {expected[i]}\nBut was: {actual[i]}");
			}
		}
	}

	private static void AreAlmostEqual(ReadOnlySpan<Vector4> expected, ReadOnlySpan<Vector4> actual, float maxDeviation)
	{
		if (expected.Length != actual.Length)
		{
			Assert.Fail($"Lengths were inequal.\nExpected: {expected.Length}\nBut was: {actual.Length}");
		}

		for (int i = 0; i < expected.Length; i++)
		{
			if (Vector4.Distance(expected[i], actual[i]) > maxDeviation)
			{
				Assert.Fail($"Values significantly differ at index {i}\nExpected: {expected[i]}\nBut was: {actual[i]}");
			}
		}
	}

	private static void AreAlmostEqual(ReadOnlySpan<BoneWeight4> expectedSpan, ReadOnlySpan<BoneWeight4> actualSpan, float maxDeviation)
	{
		if (expectedSpan.Length != actualSpan.Length)
		{
			Assert.Fail($"Lengths were inequal.\nExpected: {expectedSpan.Length}\nBut was: {actualSpan.Length}");
		}

		for (int i = 0; i < expectedSpan.Length; i++)
		{
			BoneWeight4 expected = expectedSpan[i];
			BoneWeight4 actual = actualSpan[i];
			if (expected.Indices != actual.Indices)
			{
				Assert.Fail($"Bone Indices significantly differ at span index {i}\nExpected: {expected.Indices}\nBut was: {actual.Indices}");
			}
			for (int j = 0; j < BoneWeight4.Count; j++)
			{
				if (float.Abs(expected.Weights[j] - actual.Weights[j]) > maxDeviation)
				{
					Assert.Fail($"Weights significantly differ at span index {i}, weight index {j}\nExpected: {expected.Weights[j]}\nBut was: {actual.Weights[j]}");
				}
			}
		}
	}

	private static void AreAlmostEqual(ReadOnlySpan<float> expected, ReadOnlySpan<float> actual, float maxDeviation)
	{
		if (expected.Length != actual.Length)
		{
			Assert.Fail($"Lengths were inequal.\nExpected: {expected.Length}\nBut was: {actual.Length}");
		}

		for (int i = 0; i < expected.Length; i++)
		{
			if (float.Abs(expected[i] - actual[i]) > maxDeviation)
			{
				Assert.Fail($"Values significantly differ at index {i}\nExpected: {expected[i]}\nBut was: {actual[i]}");
			}
		}
	}

	private static void AreAlmostEqual(ReadOnlySpan<Matrix4x4> expected, ReadOnlySpan<Matrix4x4> actual, float maxDeviation)
	{
		AreAlmostEqual(MemoryMarshal.Cast<Matrix4x4, float>(expected), MemoryMarshal.Cast<Matrix4x4, float>(actual), maxDeviation);
	}
}

```

`Source/AssetRipper.Tests/DictionaryTests.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Primitives;
using AssetRipper.SourceGenerated.Subclasses.FastPropertyName;

namespace AssetRipper.Tests;

public class DictionaryTests
{
	[Test]
	public void SimpleIntegerDictionaryTests()
	{
		AssetDictionary<int, int> dictionary = new()
		{
			{ 1, 2 },
			{ 3, 4 },
			{ 4, 4 }
		};

		using (Assert.EnterMultipleScope())
		{
			Assert.That(dictionary.ContainsKey(1));
			Assert.That(!dictionary.ContainsKey(2));
			Assert.That(dictionary[3], Is.EqualTo(4));
		}
	}

	[Test]
	public void Utf8DictionaryTests()
	{
		AssetDictionary<Utf8String, int> dictionary = new()
		{
			{ Cast("One"), 1 },
			{ Cast("Two"), 2 },
			{ Cast("Three"), 3 }
		};

		using (Assert.EnterMultipleScope())
		{
			Assert.That(dictionary, Has.Count.EqualTo(3));
			Assert.That(dictionary.ContainsKey(Cast("One")));
			Assert.That(dictionary.ContainsKey(Cast("Three")));
			Assert.That(!dictionary.ContainsKey(Cast("Four")));
#pragma warning disable NUnit2009 // The same value has been provided as both the actual and the expected argument
			Assert.That(Cast("Three").GetHashCode(), Is.EqualTo(Cast("Three").GetHashCode()));
#pragma warning restore NUnit2009 // The same value has been provided as both the actual and the expected argument
			Assert.That(Cast("Three").Equals(Cast("Three")));
			Assert.That(dictionary[Cast("Three")], Is.EqualTo(3));
		}
	}

	[Test]
	public void Utf8StringTests()
	{
		using (Assert.EnterMultipleScope())
		{
#pragma warning disable NUnit2009 // The same value has been provided as both the actual and the expected argument
			Assert.That(Cast(""), Is.EqualTo(Cast("")));
			Assert.That(Cast("One"), Is.EqualTo(Cast("One")));
			Assert.That(Cast("Two"), Is.EqualTo(Cast("Two")));
			Assert.That(Cast("Three"), Is.EqualTo(Cast("Three")));
#pragma warning restore NUnit2009 // The same value has been provided as both the actual and the expected argument
		}
	}

	private static Utf8String Cast(string str) => str;

	[Test]
	public void FastPropertyNameDictionaryTests()
	{
		AssetDictionary<FastPropertyName, int> dictionary = new();
		AddFastPropertyName(dictionary, "One", 1);
		AddFastPropertyName(dictionary, "Two", 2);
		AddFastPropertyName(dictionary, "Three", 3);

		using (Assert.EnterMultipleScope())
		{
			Assert.That(dictionary, Has.Count.EqualTo(3));
			Assert.That(dictionary.ContainsKey(MakeFastPropertyName("One")));
			Assert.That(dictionary.ContainsKey(MakeFastPropertyName("Three")));
			Assert.That(!dictionary.ContainsKey(MakeFastPropertyName("Four")));
#pragma warning disable NUnit2009 // The same value has been provided as both the actual and the expected argument
			Assert.That(MakeFastPropertyName("Three").GetHashCode(), Is.EqualTo(MakeFastPropertyName("Three").GetHashCode()));
#pragma warning restore NUnit2009 // The same value has been provided as both the actual and the expected argument
			Assert.That(MakeFastPropertyName("Three").Equals(MakeFastPropertyName("Three")));
			Assert.That(dictionary[MakeFastPropertyName("Three")], Is.EqualTo(3));
		}

		static FastPropertyName MakeFastPropertyName(string str) => new() { Name = str };

		static void AddFastPropertyName(AssetDictionary<FastPropertyName, int> dictionary, string str, int value)
		{
			AssetPair<FastPropertyName, int> pair = dictionary.AddNew();
			pair.Key.Name = str;
			pair.Value = value;
		}
	}
}

```

`Source/AssetRipper.Tests/ExportIdHandlerTests.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.UnityProjects;
using Moq;

namespace AssetRipper.Tests;

public class ExportIdHandlerTests
{
	private Mock<IUnityObjectBase> _assetMock;

	[SetUp]
	public void SetUp()
	{
		_assetMock = new Mock<IUnityObjectBase>(MockBehavior.Strict);
	}

	[Test]
	public void GetMainExportID_ValueGreaterThan100100AndNonZero_ExceptionThrown()
	{
		// Arrange
		const int classID = 100500;
		const uint value = 1u;

		// Act & Assert
		Assert.Throws<ArgumentException>(() => ExportIdHandler.GetMainExportID(classID, value));
	}

	[Test]
	public void GetMainExportID_ValueGreaterThan100000_DebugAssertFails()
	{
		// Arrange
		const int classID = 0;
		const uint value = 100001u;
		_assetMock.SetupGet(a => a.ClassID).Returns(classID);

		// Act & Assert
		Assert.That(() => ExportIdHandler.GetMainExportID(_assetMock.Object, value), Throws.Exception);
	}

	[Test]
	public void GetMainExportID_ValueLessThan100000_ReturnValue()
	{
		// Arrange
		const int classID = 0;
		const uint value = 1u;
		const uint expectedResult = classID * 100000 + value;
		_assetMock.SetupGet(a => a.ClassID).Returns(classID);

		// Act
		long actualResult = ExportIdHandler.GetMainExportID(_assetMock.Object, value);

		// Assert
		Assert.That(actualResult, Is.EqualTo(expectedResult));
	}

	[Test]
	public void GetMainExportID_ClassIDGreaterThan100100_ReturnClassID()
	{
		// Arrange
		const int classID = 100101;
		const uint expectedValue = classID;
		_assetMock.SetupGet(a => a.ClassID).Returns(classID);

		// Act
		long actualResult = ExportIdHandler.GetMainExportID(_assetMock.Object);

		// Assert
		Assert.That(actualResult, Is.EqualTo(expectedValue));
	}

	[Test]
	public void GetMainExportID_ClassIDLessThan100101_ReturnCompositeID()
	{
		// Arrange
		const int classID = 42;
		const uint value = 12345u;
		const uint expectedResult = classID * 100000 + value;
		_assetMock.SetupGet(a => a.ClassID).Returns(classID);

		// Act
		long actualResult = ExportIdHandler.GetMainExportID(_assetMock.Object, value);

		// Assert
		Assert.That(actualResult, Is.EqualTo(expectedResult));
	}

	[Test]
	public void GetPseudoRandomValue_NoConflictsInFirstMillionValues()
	{
		const int Count = 1_000_000;
		HashSet<long> generatedIds = new(Count);
		for (int i = 0; i < Count; i++)
		{
			long exportId = ExportIdHandler.GetPseudoRandomValue(i);
			Assert.That(generatedIds.Add(exportId), Is.True, $"Duplicate export ID generated: {exportId}");
		}
	}

	[Test]
	public void GetPseudoRandomExportID_NoConflictsInFirstMillionValues()
	{
		const int classID = 42;
		_assetMock.SetupGet(a => a.ClassID).Returns(classID);

		const int Count = 1_000_000;
		HashSet<long> generatedIds = new(Count);
		for (int i = 0; i < Count; i++)
		{
			long exportId = ExportIdHandler.GetPseudoRandomExportId(_assetMock.Object, i);
			Assert.That(generatedIds.Add(exportId), Is.True, $"Duplicate export ID generated: {exportId}");
		}
	}
}

```

`Source/AssetRipper.Tests/ExportTests.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Export.UnityProjects;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.IO.Files;
using AssetRipper.Primitives;
using AssetRipper.Processing;
using AssetRipper.Processing.ScriptableObject;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Extensions;
using NUnit.Framework.Internal;

namespace AssetRipper.Tests;

internal class ExportTests
{
	[Test]
	public void NamedScriptableObjectIsExported()
	{
		ProcessedAssetCollection collection = AssetCreator.CreateCollection(UnityVersion.V_2022);

		IMonoBehaviour monoBehaviour = collection.CreateMonoBehaviour();
		monoBehaviour.Name = "Name";

		VirtualFileSystem fileSystem = Export(collection);

		Assert.That(fileSystem.File.Exists("/output/ExportedProject/Assets/MonoBehaviour/Name.asset"));
	}

	[Test]
	public void NamelessScriptableObjectIsExported()
	{
		ProcessedAssetCollection collection = AssetCreator.CreateCollection(UnityVersion.V_2022);

		collection.CreateMonoBehaviour();

		VirtualFileSystem fileSystem = Export(collection);

		Assert.That(fileSystem.File.Exists("/output/ExportedProject/Assets/MonoBehaviour/MonoBehaviour.asset"));
	}

	[Test]
	public void ScriptableObjectGroupIsExported_1()
	{
		ProcessedAssetCollection collection = AssetCreator.CreateCollection(UnityVersion.V_2022);

		IMonoBehaviour behaviour1 = collection.CreateMonoBehaviour();
		IMonoBehaviour behaviour2 = collection.CreateMonoBehaviour();
		ScriptableObjectGroup group = collection.CreateAsset(default, (assetInfo) => new ScriptableObjectGroup(assetInfo, behaviour1));
		group.Children.Add(behaviour2);
		group.SetMainAsset();

		Assert.DoesNotThrow(() => Export(collection));
	}

	[Test]
	public void ScriptableObjectGroupIsExported_2()
	{
		ProcessedAssetCollection collection = AssetCreator.CreateCollection(UnityVersion.V_2022);

		IMonoBehaviour behaviour1 = collection.CreateMonoBehaviour();
		IMonoBehaviour behaviour2 = collection.CreateMonoBehaviour();
		ScriptableObjectGroup group = collection.CreateAsset(default, (assetInfo) => new ScriptableObjectGroup(assetInfo, behaviour2));
		group.Children.Add(behaviour1);
		group.SetMainAsset();

		Assert.DoesNotThrow(() => Export(collection));
	}

	[Test]
	public void ScriptableObjectGroupIsExported_3()
	{
		ProcessedAssetCollection collection = AssetCreator.CreateCollection(UnityVersion.V_2022);

		IMonoBehaviour behaviour1 = collection.CreateMonoBehaviour();
		ScriptableObjectGroup group = collection.CreateAsset(default, (assetInfo) => new ScriptableObjectGroup(assetInfo, behaviour1));
		IMonoBehaviour behaviour2 = collection.CreateMonoBehaviour();
		group.Children.Add(behaviour2);
		group.SetMainAsset();

		Assert.DoesNotThrow(() => Export(collection));
	}

	[Test]
	public void EmptyMeshIsExported()
	{
		ProcessedAssetCollection collection = AssetCreator.CreateCollection(UnityVersion.V_2022);

		collection.CreateMesh();

		VirtualFileSystem fileSystem = Export(collection);

		Assert.That(fileSystem.File.Exists("/output/ExportedProject/Assets/Mesh/Mesh.asset"));
	}

	[Test]
	public void CompressedMeshIsExported()
	{
		ProcessedAssetCollection collection = AssetCreator.CreateCollection(UnityVersion.V_2022);

		IMesh mesh = collection.CreateMesh();
		mesh.FillWithCompressedMeshData(MeshData.CreateTriangleMesh());

		VirtualFileSystem fileSystem = Export(collection);

		Assert.That(fileSystem.File.Exists("/output/ExportedProject/Assets/Mesh/Mesh.asset"));
	}

	static readonly (string AssemblyName, string AssemblyGuid)[] AssemblyGuidTestCases =
	[
		("UnityEngine.UI", "f5f67c52d1564df4a8936ccd202a3bd8"),
	];
	static readonly UnityVersion[] AssemblyGuidTestVersions =
	[
		UnityVersion.V_5_3,
		UnityVersion.V_5_4,
		UnityVersion.V_5_5,
		UnityVersion.V_5_6,
		UnityVersion.V_2017,
		UnityVersion.V_2018,
	];
	[Theory]
	public void AssembliesHaveCorrectGuid([ValueSource(nameof(AssemblyGuidTestCases))] (string, string) pair, [ValueSource(nameof(AssemblyGuidTestVersions))] UnityVersion version)
	{
		(string assemblyName, string assemblyGuid) = pair;
		MonoManager assemblyManager = CreateAssemblyManager();
		const string TypeName = "ExampleBehaviour";
		{
			assemblyManager.Load(typeof(UnityEngine.Object).Assembly.Location, LocalFileSystem.Instance);
			ModuleDefinition unityEngineModule = assemblyManager.GetAssemblies().Single().ManifestModule!;
			TypeDefinition monoBehaviourType = unityEngineModule.TopLevelTypes.Single(t => t.Name == "MonoBehaviour");
			AssemblyDefinition newAssembly = new(assemblyName, new());
			ModuleDefinition newModule = new(assemblyName, unityEngineModule.AssemblyReferences.First(a => a.IsCorLib));
			newAssembly.Modules.Add(newModule);
			TypeDefinition newType = new(null, TypeName, monoBehaviourType.Attributes, newModule.DefaultImporter.ImportType(monoBehaviourType));
			newModule.TopLevelTypes.Add(newType);
			MemoryStream stream = new();
			newModule.Write(stream);
			stream.Position = 0;
			assemblyManager.Read(stream, $"{assemblyName}.dll");
		}

		ProcessedAssetCollection collection = AssetCreator.CreateCollection(version);

		IMonoScript monoScript = collection.CreateMonoScript();
		monoScript.ClassName_R = TypeName;
		monoScript.AssemblyName = assemblyName;

		IMonoBehaviour monoBehaviour = collection.CreateMonoBehaviour();
		monoBehaviour.ScriptP = monoScript;
		monoBehaviour.Name = "TestBehaviour";

		VirtualFileSystem fileSystem = Export(collection, assemblyManager: assemblyManager);

		using (Assert.EnterMultipleScope())
		{
			Assert.That(fileSystem.File.Exists("/output/ExportedProject/Assets/MonoBehaviour/TestBehaviour.asset"));
			Assert.That(fileSystem.File.Exists("/output/ExportedProject/Assets/MonoBehaviour/TestBehaviour.asset.meta"));
		}
		Assert.That(fileSystem.File.ReadAllText("/output/ExportedProject/Assets/MonoBehaviour/TestBehaviour.asset"), Does.Contain(assemblyGuid));
	}

	private static VirtualFileSystem Export(ProcessedAssetCollection collection, string outputPath = "output", IAssemblyManager? assemblyManager = null, VirtualFileSystem? fileSystem = null)
	{
		fileSystem ??= new();
		new ExportHandler(new()).Export(CreateGameData(collection, assemblyManager), outputPath, fileSystem);
		return fileSystem;
	}

	private static GameData CreateGameData(ProcessedAssetCollection collection, IAssemblyManager? assemblyManager = null)
	{
		return new((GameBundle)collection.Bundle, collection.Version, assemblyManager ?? new BaseManager((s) => { }), null);
	}

	private static MonoManager CreateAssemblyManager()
	{
		return new MonoManager((str) => { });
	}
}

```

`Source/AssetRipper.Tests/MeshDataExtensions.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Enums;
using AssetRipper.SourceGenerated.Extensions;
using System.Numerics;

namespace AssetRipper.Tests;

internal static class MeshDataExtensions
{
	extension(MeshData)
	{
		public static MeshData CreateTriangleMesh()
		{
			Vector3[] vertices =
			[
				new Vector3(0.0f, 0.0f, 0.0f),
				new Vector3(1.0f, 0.0f, 0.0f),
				new Vector3(0.0f, 1.0f, 0.0f),
			];
			Vector3[] normals =
			[
				new Vector3(0.0f, 0.0f, 1.0f),
				new Vector3(0.0f, 0.0f, 1.0f),
				new Vector3(0.0f, 0.0f, 1.0f),
			];
			Vector4[] tangents =
			[
				new Vector4(1.0f, 0.0f, 0.0f, 1.0f),
				new Vector4(1.0f, 0.0f, 0.0f, 1.0f),
				new Vector4(1.0f, 0.0f, 0.0f, 1.0f),
			];
			ColorFloat[] colors =
			[
				new ColorFloat(1.0f, 0.0f, 0.0f, 1.0f),
				new ColorFloat(0.0f, 1.0f, 0.0f, 1.0f),
				new ColorFloat(0.0f, 0.0f, 1.0f, 1.0f),
			];
			ReadOnlySpan<Vector2> uv =
			[
				new Vector2(0.0f, 0.0f),
				new Vector2(1.0f, 0.0f),
				new Vector2(0.0f, 1.0f),
			];
			uint[] processedIndexBuffer = [0, 1, 2];
			SubMeshData[] subMeshes =
			[
				new SubMeshData(0, 0, 0, processedIndexBuffer.Length, 1, 3, MeshTopology.Triangles, new Bounds(new Vector3(0.5f, 0.5f, 0.0f), new Vector3(0.5f, 0.5f, 0.0f)))
			];
			return new MeshData(vertices, normals, tangents, colors, uv.ToArray(), uv.ToArray(), uv.ToArray(), uv.ToArray(), uv.ToArray(), uv.ToArray(), uv.ToArray(), uv.ToArray(), null, null, processedIndexBuffer, subMeshes);
		}
	}
}

```

`Source/AssetRipper.Tests/MeshDataTests.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Tests;

internal class MeshDataTests
{
	[Test]
	public void AccessingNullUV2DoesNotThrow()
	{
		MeshData meshData = MeshData.CreateTriangleMesh() with
		{
			UV2 = null
		};
		Assert.DoesNotThrow(() =>
		{
			meshData.TryGetUV2AtIndex(0);
		});
	}

	[Test]
	public void AccessingEmptyUV2DoesNotThrow()
	{
		MeshData meshData = MeshData.CreateTriangleMesh() with
		{
			UV2 = []
		};
		Assert.DoesNotThrow(() =>
		{
			meshData.TryGetUV2AtIndex(0);
		});
	}
}

```

`Source/AssetRipper.Tests/PackedBitVectorTests/FloatVectorTests.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.PackedBitVector_Single;

namespace AssetRipper.Tests.PackedBitVectorTests;

/// <summary>
/// Tests for <see cref="PackedBitVector_Single"/>
/// </summary>
public class FloatVectorTests
{
	private static readonly Random random = new Random(57089);
	private static readonly float[] floats = MakeFloats(20);

	private static float[] MakeFloats(int count)
	{
		float[] result = new float[count];
		for (int i = 0; i < count; i++)
		{
			result[i] = 10f * random.NextSingle();
		}
		return result;
	}

	[Test]
	public void BitSize24ProducesHighlyAccurateResults()
	{
		PackedBitVector_Single packedVector = new();
		packedVector.Pack(floats, 24, false);
		float[] unpackedValues = packedVector.Unpack();
		Assert.That(unpackedValues, Is.EqualTo(floats).Within(0.000001f));
	}

	[Test]
	public void BitSizeAdjustmentAlsoProducesUsableResults()
	{
		PackedBitVector_Single packedVector = new();
		packedVector.Pack(floats, 8, true);
		float[] unpackedValues = packedVector.Unpack();
		Assert.That(unpackedValues, Is.EqualTo(floats).Within(0.01f));
	}

	[Theory]
	public void PackingAndUnpackingDoesNotThrowAndGivesCorrectLength([Range(1, 32)] int bitSize)
	{
		PackedBitVector_Single packedVector = new();
		packedVector.Pack(floats, bitSize, false);
		float[] unpackedValues = packedVector.Unpack();
		Assert.That(unpackedValues, Has.Length.EqualTo(floats.Length));
	}

	[Test]
	public void DifferingChunkStrideAndChunkSizeWorks()
	{
		Assert.That(floats.Length % 4 == 0);
		PackedBitVector_Single packedVector = new();
		packedVector.Pack(floats);
		float[] actual = packedVector.Unpack(3, 4);
		float[] expected = new float[floats.Length / 4 * 3];
		for (int chunk = 0; chunk < floats.Length / 4; chunk++)
		{
			for (int i = 0; i < 3; i++)
			{
				expected[chunk * 3 + i] = floats[chunk * 4 + i];
			}
		}
		Assert.That(actual, Is.EqualTo(expected).Within(0.000001f));
	}
}

```

`Source/AssetRipper.Tests/PackedBitVectorTests/IntVectorTests.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.PackedBitVector_Int32;

namespace AssetRipper.Tests.PackedBitVectorTests;

/// <summary>
/// Tests for <see cref="PackedBitVector_Int32"/>
/// </summary>
public class IntVectorTests
{
	private static readonly Random random = new Random(57089);
	private static readonly uint[] ints = MakeInts(20);
	private static readonly ushort[] shorts = MakeShorts(20);

	[Test]
	public void UnpackedIntsAreTheSameAsTheOriginals()
	{
		PackedBitVector_Int32 packedVector = new();
		packedVector.PackUInts(ints);
		uint[] unpackedInts = packedVector.UnpackUInts();

		Assert.That(unpackedInts, Is.EqualTo(ints));
	}

	[Test]
	public void UnpackedShortsAreTheSameAsTheOriginals()
	{
		PackedBitVector_Int32 packedVector = new();
		packedVector.PackUShorts(shorts);
		ushort[] unpackedShorts = packedVector.UnpackUShorts();

		Assert.That(unpackedShorts, Is.EqualTo(shorts));
	}

	[Test]
	public void OldUnpackMethodIsConsistent()
	{
		PackedBitVector_Int32 packedVector = new();
		packedVector.PackUInts(ints);
		uint[] unpackedInts = packedVector.UnpackInts().Select(x => unchecked((uint)x)).ToArray();

		Assert.That(unpackedInts, Is.EqualTo(ints));
	}

	private static uint[] MakeInts(int count)
	{
		uint[] result = new uint[count];
		for (int i = 0; i < count; i++)
		{
			result[i] = unchecked((uint)random.Next());
		}
		return result;
	}

	private static ushort[] MakeShorts(int count)
	{
		ushort[] result = new ushort[count];
		for (int i = 0; i < count; i++)
		{
			result[i] = unchecked((ushort)random.Next(ushort.MaxValue));
		}
		return result;
	}
}

```

`Source/AssetRipper.Tests/PackedBitVectorTests/QuatVectorTests.cs`:

```cs
using AssetRipper.Numerics;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.PackedBitVector_Quaternionf;
using System.Numerics;

namespace AssetRipper.Tests.PackedBitVectorTests;

/// <summary>
/// Tests for <see cref="PackedBitVector_Quaternionf"/>
/// </summary>
public class QuatVectorTests
{
	private static readonly Random random = new Random(57089);
	private static readonly Quaternion[] quaternions = MakeQuaternions(20);

	private static Quaternion[] MakeQuaternions(int count)
	{
		Quaternion[] result = new Quaternion[count];
		for (int i = 0; i < count; i++)
		{
			result[i] = GetRandomQuaternion();
		}
		return result;
	}

	private static Quaternion GetRandomQuaternion() => GetRandomEuler().ToQuaternion(false);

	private static Vector3 GetRandomEuler()
	{
		return new Vector3(GetRandomAngle(), GetRandomAngle(), GetRandomAngle());
	}

	private static float GetRandomAngle()
	{
		return (float)(random.NextDouble() * 2d * Math.PI);
	}

	[Test]
	public void PackingAndUnpackingGiveTheSameValues()
	{
		PackedBitVector_Quaternionf packedVector = new();
		packedVector.Pack(quaternions);
		Quaternion[] unpackedQuaternions = packedVector.Unpack();

		for (int i = 0; i < quaternions.Length; i++)
		{
			bool equal = quaternions[i].EqualsByDot(unpackedQuaternions[i]);
			if (!equal)
			{
				throw new Exception($"Index {i}: Original: {quaternions[i]} Unpacked: {unpackedQuaternions[i]} Dot: {quaternions[i].Dot(unpackedQuaternions[i])}");
			}
		}
	}
}

```

`Source/AssetRipper.Tests/PathIDCalculationTests.cs`:

```cs
using AssetRipper.Export.UnityProjects;
using AssetRipper.HashAlgorithms;
using AssetRipper.IO.Files;
using AssetRipper.Primitives;
using System.Buffers.Binary;
using System.Diagnostics;

namespace AssetRipper.Tests;

internal class PathIDCalculationTests
{
	[Test]
	public void BinocularsOverlay()
	{
		const long ExpectedPathID = -3447896943880403800;
		UnityGuid guid = UnityGuid.Parse("01e291bf376af4b4994f5015f73d2fe0");
		AssetType type = AssetType.Meta;
		long fileID = ExportIdHandler.GetMainExportID(28);
		Assert.That(Compute64BitHash(guid, type, fileID), Is.EqualTo(ExpectedPathID));
	}

	private static long Compute64BitHash(UnityGuid guid, AssetType type, long fileID)
	{
		const int GuidStringLength = 32;
		Span<byte> input = stackalloc byte[GuidStringLength + sizeof(AssetType) + sizeof(long)];
		string guidString = guid.ToString();
		Debug.Assert(guidString.Length == GuidStringLength);
		for (int i = 0; i < GuidStringLength; i++)
		{
			input[i] = (byte)guidString[i];
		}
		BinaryPrimitives.WriteInt32LittleEndian(input.Slice(GuidStringLength), (int)type);
		BinaryPrimitives.WriteInt64LittleEndian(input.Slice(GuidStringLength + sizeof(AssetType)), fileID);

		Span<byte> output = stackalloc byte[16];
		MD4.HashData(input, output);

		return BinaryPrimitives.ReadInt64LittleEndian(output);
	}
}

```

`Source/AssetRipper.Tests/ScriptHashingTests.cs`:

```cs
using AssetRipper.Export.UnityProjects.Scripts;
using System.Text;

namespace AssetRipper.Tests;

internal class ScriptHashingTests
{
	[TestCase("AssetRipper.Examples", "ExampleBehaviour", -218309758)]
	[TestCase("UnityEngine", "Component", 468326297)]
	[TestCase("UnityEngine", "GameObject", -1741091355)]
	[TestCase("UnityEngine", "MonoBehaviour", 888015496)]
	[TestCase("UnityEngine", "Object", 350709172)]
	public static void VerifyCorrectness(string @namespace, string name, int expected)
	{
		int calculated = ScriptHashing.CalculateScriptFileID(@namespace, name);
		Assert.That(calculated, Is.EqualTo(expected));
	}

	[TestCaseSource(nameof(GetRandomFullNames), new object[] { 10 })]
	public static void VerifyConsistency(string @namespace, string name)
	{
		int value1 = ScriptHashing.CalculateScriptFileID(@namespace, name);
		int value2 = ScriptHashing.CalculateScriptFileID(Encoding.UTF8.GetBytes(@namespace), Encoding.UTF8.GetBytes(name));
		Assert.That(value2, Is.EqualTo(value1));
	}

	private static IEnumerable<string[]> GetRandomFullNames(int count)
	{
		for (int i = 0; i < count; i++)
		{
			string @namespace = GetRandomString(5, 50);
			string className = GetRandomString(5, 15);
			yield return new[] { @namespace, className };
		}
	}

	private static string GetRandomString(int minLength, int maxLength)
	{
		int length = TestContext.CurrentContext.Random.Next(minLength, maxLength);
		return TestContext.CurrentContext.Random.GetString(length);
	}
}

```

`Source/AssetRipper.Tests/SerializableStructureTests.cs`:

```cs
using AssetRipper.Import.Structure.Assembly.Serializable;
using AssetRipper.IO.Endian;
using AssetRipper.Primitives;
using AssetRipper.SerializationLogic;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Tests;

internal class SerializableStructureTests
{
	[Test]
	public void SphericalHarmonicsL2CanBeRead()
	{
		// https://github.com/AssetRipper/AssetRipper/issues/1970
		SerializableType serializableType = new ParentType();
		Assert.That(serializableType.Fields, Has.Count.EqualTo(1));
		SerializableStructure structure = serializableType.CreateSerializableStructure();
		byte[] data = new byte[27 * sizeof(float)];
		EndianSpanReader reader = new(data, EndianType.LittleEndian);
		structure.Read(ref reader, new UnityVersion(6000), default);
		Assert.That(reader.Position, Is.EqualTo(data.Length));
	}

	private class ParentType : SerializableType
	{
		public ParentType() : base("Namespace", PrimitiveType.Complex, "Name")
		{
			Fields = [new Field(new SphericalHarmonicsType(), 0, "field", false)];
			MaxDepth = 1;
		}
	}

	private class SphericalHarmonicsType : SerializableType
	{
		public SphericalHarmonicsType() : base("UnityEngine.Rendering", PrimitiveType.Complex, "SphericalHarmonicsL2")
		{
			// Even though its fields are serialized, they don't show up in our algorithm as they are private and have no SerializeField attribute.
			MaxDepth = 0;
		}
	}
}

```

`Source/AssetRipper.Tests/StrippedAssetTests.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Export.UnityProjects;
using AssetRipper.Primitives;
using AssetRipper.Processing.Prefabs;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.Yaml;
using NUnit.Framework.Internal;

namespace AssetRipper.Tests;

public class StrippedAssetTests
{
	[Test]
	public void IsStrippedReturnsTrueForStrippedAsset()
	{
		ProcessedAssetCollection collection = CreateCollection(new UnityVersion(2020, 1));
		IGameObject root = collection.CreateGameObject();
		IPrefabInstance prefab = collection.CreatePrefabInstance();
		PrefabHierarchyObject hierarchy = collection.CreateAsset(-1, (assetInfo) => new PrefabHierarchyObject(assetInfo, root, prefab));
		hierarchy.GameObjects.Add(root);
		hierarchy.SetMainAsset();

		hierarchy.StrippedAssets.Add(root);

		Assert.That(root.IsStripped(), Is.True);
	}

	[Test]
	public void StrippedGameObjectYamlContent()
	{
		ProcessedAssetCollection collection = CreateCollection(new UnityVersion(2020, 1));
		SceneDefinition scene = SceneDefinition.FromName("TestScene");
		scene.AddCollection(collection);
		IGameObject gameObject = collection.CreateGameObject();
		SceneHierarchyObject hierarchy = collection.CreateAsset(-1, (assetInfo) => new SceneHierarchyObject(assetInfo, scene));
		hierarchy.GameObjects.Add(gameObject);
		hierarchy.SetMainAsset();

		hierarchy.StrippedAssets.Add(gameObject);

		string yaml = GetYamlForAsset(gameObject);
		const string expected = """
			%YAML 1.1
			%TAG !u! tag:unity3d.com,2011:
			--- !u!1 &1 stripped
			GameObject:
			  m_CorrespondingSourceObject: {m_FileID: 0, m_PathID: 0, m_TargetClassID: 18}
			  m_PrefabInstance: {m_FileID: 0, m_PathID: 0, m_TargetClassID: 1001}
			  m_PrefabAsset: {m_FileID: 0, m_PathID: 0, m_TargetClassID: 1001480554}

			""";

		Assert.That(yaml.ReplaceLineEndings(), Is.EqualTo(expected.ReplaceLineEndings()));
	}

	[Test]
	public void StrippedMonoBehaviourYamlContent()
	{
		ProcessedAssetCollection collection = CreateCollection(new UnityVersion(2020, 1));
		SceneDefinition scene = SceneDefinition.FromName("TestScene");
		scene.AddCollection(collection);
		IMonoBehaviour monoBehaviour = collection.CreateMonoBehaviour();
		SceneHierarchyObject hierarchy = collection.CreateAsset(-1, (assetInfo) => new SceneHierarchyObject(assetInfo, scene));
		hierarchy.Components.Add(monoBehaviour);
		hierarchy.SetMainAsset();

		hierarchy.StrippedAssets.Add(monoBehaviour);

		string yaml = GetYamlForAsset(monoBehaviour);
		const string expected = """
			%YAML 1.1
			%TAG !u! tag:unity3d.com,2011:
			--- !u!114 &1 stripped
			MonoBehaviour:
			  m_CorrespondingSourceObject: {m_FileID: 0, m_PathID: 0, m_TargetClassID: 18}
			  m_PrefabInstance: {m_FileID: 0, m_PathID: 0, m_TargetClassID: 1001}
			  m_PrefabAsset: {m_FileID: 0, m_PathID: 0, m_TargetClassID: 1001480554}
			  m_GameObject: {m_FileID: 0, m_PathID: 0, m_TargetClassID: 1}
			  m_Enabled: 0
			  m_EditorHideFlags: 0
			  m_Script: {m_FileID: 0, m_PathID: 0, m_TargetClassID: 115}
			  m_Name:
			  m_EditorClassIdentifier:

			""";

		// Note: The source yaml from Unity had a trailing space after the colon for m_Name and m_EditorClassIdentifier.
		// AssetRipper does not currently add a trailing space, which might be a bug in its serialization.
		// However, that's unrelated to stripping, and there doesn't seem to be any issues arising from the difference.

		Assert.That(yaml.ReplaceLineEndings(), Is.EqualTo(expected.ReplaceLineEndings()));
	}

	private static string GetYamlForAsset(IUnityObjectBase asset)
	{
		using StringWriter writer = new();
		YamlWriter yamlWriter = new();
		yamlWriter.WriteHead(writer);
		YamlWalker walker = new();
		yamlWriter.WriteDocument(walker.ExportYamlDocument(asset, 1));
		yamlWriter.WriteTail(writer);
		return writer.ToString();
	}

	private static ProcessedAssetCollection CreateCollection(UnityVersion version) => new GameBundle().AddNewProcessedCollection("Collection", version);
}

```

`Source/AssetRipper.Tests/TextureImporterTests.cs`:

```cs
using AssetRipper.Primitives;
using AssetRipper.SourceGenerated.Classes.ClassID_1006;
using AssetRipper.SourceGenerated.Extensions;
using NUnit.Framework.Internal;
using Swizzle = AssetRipper.SourceGenerated.Enums.TextureImporterSwizzle;

namespace AssetRipper.Tests;

internal class TextureImporterTests
{
	[Test]
	public void DefaultSwizzleIsZero()
	{
		using (Assert.EnterMultipleScope())
		{
			ITextureImporter importer = CreateImporterWithSwizzleField();
			Assert.That(importer.Has_Swizzle(), Is.True);
			Assert.That(importer.Swizzle, Is.Zero);
		}
		using (Assert.EnterMultipleScope())
		{
			ITextureImporter importer = CreateImporterWithoutSwizzleField();
			Assert.That(importer.Has_Swizzle(), Is.False);
			Assert.That(importer.Swizzle, Is.Zero);
		}
	}

	[Test]
	public void DefaultFieldSwizzleIsRRRR()
	{
		using (Assert.EnterMultipleScope())
		{
			ITextureImporter importer = CreateImporterWithSwizzleField();
			importer.GetSwizzle(out Swizzle channel0, out Swizzle channel1, out Swizzle channel2, out Swizzle channel3);
			Assert.That(channel0, Is.EqualTo(Swizzle.R));
			Assert.That(channel1, Is.EqualTo(Swizzle.R));
			Assert.That(channel2, Is.EqualTo(Swizzle.R));
			Assert.That(channel3, Is.EqualTo(Swizzle.R));
			Assert.That(importer.Swizzle, Is.Zero);//Check that GetSwizzle hasn't changed the value.
		}
	}

	[Test]
	public void SwizzleHasCorrectRGBA()
	{
		using (Assert.EnterMultipleScope())
		{
			ITextureImporter importer = CreateImporterWithSwizzleField();
			importer.SetSwizzle(Swizzle.R, Swizzle.G, Swizzle.B, Swizzle.A);
			Assert.That(importer.Swizzle, Is.EqualTo(0x_03_02_01_00));
		}
	}

	[Test]
	public void FieldlessSwizzleIsAlwaysRGBA()
	{
		using (Assert.EnterMultipleScope())
		{
			ITextureImporter importer = CreateImporterWithoutSwizzleField();
			importer.Swizzle = 534232;//arbitrary
			Assert.That(importer.Swizzle, Is.Zero);
			importer.SetSwizzle(Swizzle.One, Swizzle.OneMinusR, Swizzle.G, Swizzle.OneMinusA);//arbitrary
			importer.GetSwizzle(out Swizzle channel0, out Swizzle channel1, out Swizzle channel2, out Swizzle channel3);
			Assert.That(channel0, Is.EqualTo(Swizzle.R));
			Assert.That(channel1, Is.EqualTo(Swizzle.G));
			Assert.That(channel2, Is.EqualTo(Swizzle.B));
			Assert.That(channel3, Is.EqualTo(Swizzle.A));
		}
	}

	[TestCaseSource(nameof(GetRandomSwizzles), new object[] { 10 })]
	public void GetSwizzleMatchesSetSwizzle(Swizzle s0, Swizzle s1, Swizzle s2, Swizzle s3)
	{
		using (Assert.EnterMultipleScope())
		{
			ITextureImporter importer = CreateImporterWithSwizzleField();
			importer.SetSwizzle(s0, s1, s2, s3);
			importer.GetSwizzle(out Swizzle channel0, out Swizzle channel1, out Swizzle channel2, out Swizzle channel3);
			Assert.That(channel0, Is.EqualTo(s0));
			Assert.That(channel1, Is.EqualTo(s1));
			Assert.That(channel2, Is.EqualTo(s2));
			Assert.That(channel3, Is.EqualTo(s3));
		}
	}

	private static IEnumerable<Swizzle[]> GetRandomSwizzles(int count)
	{
		for (int i = 0; i < count; i++)
		{
			yield return new Swizzle[] { NextSwizzle(), NextSwizzle(), NextSwizzle(), NextSwizzle() };
		}

		static Swizzle NextSwizzle() => TestContext.CurrentContext.Random.NextEnum<Swizzle>();
	}

	private static ITextureImporter CreateImporterWithSwizzleField()
	{
		return AssetCreator.CreateTextureImporter(new UnityVersion(2022, 2));
	}

	private static ITextureImporter CreateImporterWithoutSwizzleField()
	{
		return AssetCreator.CreateTextureImporter(new UnityVersion(2020, 1));
	}
}

```

`Source/AssetRipper.Tests/TpkTests.cs`:

```cs
using AssetRipper.SourceGenerated;
using AssetRipper.Tpk;
using AssetRipper.Tpk.EngineAssets;
using AssetRipper.Tpk.TypeTrees;

namespace AssetRipper.Tests;

internal class TpkTests
{
	[Test]
	public void EngineAssetsTpkSuccessfullyExtracts()
	{
		TpkFile tpk = TpkFile.FromStream(EngineAssetsTpk.GetStream());
		TpkEngineAssetsBlob blob = (TpkEngineAssetsBlob)tpk.GetDataBlob();
		Assert.That(blob.Data, Is.Not.Empty);
	}

	[Test]
	public void TypeTreeTpkSuccessfullyExtracts()
	{
		TpkFile tpk = TpkFile.FromStream(SourceTpk.GetStream());
		TpkTypeTreeBlob blob = (TpkTypeTreeBlob)tpk.GetDataBlob();
		Assert.That(blob.ClassInformation, Is.Not.Empty);
	}
}

```

`Source/AssetRipper.Tests/Traversal/ColorRGB.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Traversal;
using AssetRipper.Processing;

namespace AssetRipper.Tests.Traversal;

internal sealed class ColorRGB : UnityAssetBase
{
	private readonly float r = 1;
	private readonly float g = 0.5f;
	private readonly float b = 0;

	public override bool FlowMappedInYaml => true;

	public override void WalkStandard(AssetWalker walker)
	{
		if (walker.EnterAsset(this))
		{
			this.WalkPrimitiveField(walker, r);
			walker.DivideAsset(this);
			this.WalkPrimitiveField(walker, g);
			walker.DivideAsset(this);
			this.WalkPrimitiveField(walker, b);
			walker.ExitAsset(this);
		}
	}
}

```

`Source/AssetRipper.Tests/Traversal/ComponentListObject.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;
using AssetRipper.SourceGenerated.Subclasses.ComponentPair;

namespace AssetRipper.Tests.Traversal;

internal sealed class ComponentListObject : CustomInjectedObjectBase
{
	private readonly AssetList<ComponentPair_5_5> m_Component = new();

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		ComponentListObject:
		  m_Component:
		  - component: {m_FileID: 0, m_PathID: 0}
		  - component: {m_FileID: 0, m_PathID: 0}
		  - component: {m_FileID: 0, m_PathID: 0}
		  - component: {m_FileID: 0, m_PathID: 0}

		""";

	public ComponentListObject(AssetInfo assetInfo) : base(assetInfo)
	{
		m_Component.AddNew();
		m_Component.AddNew();
		m_Component.AddNew();
		m_Component.AddNew();
	}
}

```

`Source/AssetRipper.Tests/Traversal/CustomInjectedObjectBase.PrimitiveHelper.cs`:

```cs
using AssetRipper.Assets.Traversal;
using AssetRipper.Primitives;
using System.Reflection;

namespace AssetRipper.Tests.Traversal;

partial class CustomInjectedObjectBase
{
	private static class PrimitiveHelper
	{
		private static readonly Dictionary<Type, MethodInfo> walkCache = new();

		public static void VisitPrimitive(AssetWalker walker, Type type, object? value)
		{
			if (!walkCache.TryGetValue(type, out MethodInfo? method))
			{
				method = typeof(AssetWalker).GetMethod(nameof(AssetWalker.VisitPrimitive), BindingFlags.Public | BindingFlags.Instance)
					!.MakeGenericMethod(type);
				walkCache.Add(type, method);
			}
			method.Invoke(walker, [value]);
		}

		public static bool IsPrimitive(Type type) => type.IsPrimitive || type == typeof(string) || type == typeof(Utf8String);
	}
}

```

`Source/AssetRipper.Tests/Traversal/CustomInjectedObjectBase.Walk.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;
using AssetRipper.Processing;
using System.Reflection;

namespace AssetRipper.Tests.Traversal;

partial class CustomInjectedObjectBase
{
	private void Walk(AssetWalker walker, WalkType walkType)
	{
		if (walker.EnterAsset(this))
		{
			FieldInfo[] fields = GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
			if (fields.Length > 0)
			{
				int i = 0;
				while (true)
				{
					WalkField(walker, fields[i], walkType);
					i++;
					if (i >= fields.Length)
					{
						break;
					}
					walker.DivideAsset(this);
				}
			}
			walker.ExitAsset(this);
		}
	}

	private static MethodInfo GetFirstMethod(string name)
	{
		return typeof(AssetWalker).GetMethods(BindingFlags.Public | BindingFlags.Instance).First(m => m.Name == name);
	}

	private bool EnterList(AssetWalker walker, Type elementType, object? list)
	{
		return (bool)GetFirstMethod(nameof(AssetWalker.EnterList))
			.MakeGenericMethod(elementType)
			.Invoke(walker, [list])!;
	}

	private void ExitList(AssetWalker walker, Type elementType, object? list)
	{
		GetFirstMethod(nameof(AssetWalker.ExitList))
			.MakeGenericMethod(elementType)
			.Invoke(walker, [list]);
	}

	private bool EnterDictionary(AssetWalker walker, Type keyType, Type valueType, object? dictionary)
	{
		return (bool)GetFirstMethod(nameof(AssetWalker.EnterDictionary))
			.MakeGenericMethod(keyType, valueType)
			.Invoke(walker, [dictionary])!;
	}

	private void ExitDictionary(AssetWalker walker, Type keyType, Type valueType, object? dictionary)
	{
		GetFirstMethod(nameof(AssetWalker.ExitDictionary))
			.MakeGenericMethod(keyType, valueType)
			.Invoke(walker, [dictionary]);
	}

	private bool EnterDictionaryPair(AssetWalker walker, Type keyType, Type valueType, object? pair)
	{
		return (bool)GetFirstMethod(nameof(AssetWalker.EnterDictionaryPair))
			.MakeGenericMethod(keyType, valueType)
			.Invoke(walker, [pair])!;
	}

	private void DivideDictionaryPair(AssetWalker walker, Type keyType, Type valueType, object? pair)
	{
		GetFirstMethod(nameof(AssetWalker.DivideDictionaryPair))
			.MakeGenericMethod(keyType, valueType)
			.Invoke(walker, [pair]);
	}

	private void ExitDictionaryPair(AssetWalker walker, Type keyType, Type valueType, object? pair)
	{
		GetFirstMethod(nameof(AssetWalker.ExitDictionaryPair))
			.MakeGenericMethod(keyType, valueType)
			.Invoke(walker, [pair]);
	}

	private bool EnterPair(AssetWalker walker, Type keyType, Type valueType, object? pair)
	{
		return (bool)GetFirstMethod(nameof(AssetWalker.EnterPair))
			.MakeGenericMethod(keyType, valueType)
			.Invoke(walker, [pair])!;
	}

	private void DividePair(AssetWalker walker, Type keyType, Type valueType, object? pair)
	{
		GetFirstMethod(nameof(AssetWalker.DividePair))
			.MakeGenericMethod(keyType, valueType)
			.Invoke(walker, [pair]);
	}

	private void ExitPair(AssetWalker walker, Type keyType, Type valueType, object? pair)
	{
		GetFirstMethod(nameof(AssetWalker.ExitPair))
			.MakeGenericMethod(keyType, valueType)
			.Invoke(walker, [pair]);
	}

	private void WalkField(AssetWalker walker, FieldInfo field, WalkType walkType)
	{
		string name = GetName(field, walkType);
		if (walker.EnterField(this, name))
		{
			VisitValue(walker, walkType, field.FieldType, field.GetValue(this));

			walker.ExitField(this, name);
		}
	}

	private void VisitValue(AssetWalker walker, WalkType walkType, Type type, object? value)
	{
		if (PrimitiveHelper.IsPrimitive(type))
		{
			PrimitiveHelper.VisitPrimitive(walker, type, value);
		}
		else if (type.IsAssignableTo(typeof(IUnityObjectBase)))
		{
			typeof(TraversalHelperMethods).GetMethod(nameof(TraversalHelperMethods.VisitPPtr))!
				.MakeGenericMethod(type)
				.Invoke(null, [this, walker, value]);
		}
		else if (type.IsAssignableTo(typeof(IPPtr)))
		{
			throw new NotImplementedException(type.Name);
		}
		else if (type.IsGenericType)
		{
			Type genericTypeDefinition = type.GetGenericTypeDefinition();
			if (genericTypeDefinition == typeof(AssetList<>))
			{
				Type elementType = type.GetGenericArguments()[0];

				object? list = value;
				if (EnterList(walker, elementType, list))
				{
					int count = (int)(type.GetProperty(nameof(AssetList<>.Count))?.GetValue(list) ?? throw new NullReferenceException());
					if (count > 0)
					{
						MethodInfo divideListMethod = GetFirstMethod(nameof(AssetWalker.DivideList)).MakeGenericMethod(elementType);

						MethodInfo indexer = type.GetMethod("get_Item", BindingFlags.Public | BindingFlags.Instance)!;

						int i = 0;
						while (true)
						{
							VisitValue(walker, walkType, elementType, indexer.Invoke(list, [i]));
							i++;
							if (i >= count)
							{
								break;
							}
							divideListMethod.Invoke(walker, [list]);
						}
					}
					ExitList(walker, elementType, list);
				}
			}
			else if (genericTypeDefinition == typeof(AssetDictionary<,>))
			{
				Type keyType = type.GetGenericArguments()[0];
				Type valueType = type.GetGenericArguments()[1];

				if (EnterDictionary(walker, keyType, valueType, value))
				{
					int count = (int)type.GetProperty(nameof(AssetDictionary<,>.Count))?.GetValue(value)!;
					if (count > 0)
					{
						MethodInfo divideDictionaryMethod = GetFirstMethod(nameof(AssetWalker.DivideDictionary)).MakeGenericMethod(keyType, valueType);

						MethodInfo indexer = type.GetMethod("GetPair", BindingFlags.Public | BindingFlags.Instance)!;

						MethodInfo implicitConversion = typeof(AssetPair<,>).MakeGenericType(keyType, valueType).GetMethod("op_Implicit")!;

						int i = 0;
						while (true)
						{
							object pair = indexer.Invoke(value, [i])!;
							object keyValuePair = implicitConversion.Invoke(null, [pair])!;
							if (EnterDictionaryPair(walker, keyType, valueType, keyValuePair))
							{
								VisitValue(walker, walkType, keyType, pair.GetType().GetProperty(nameof(AssetPair<,>.Key))?.GetValue(pair)!);
								DivideDictionaryPair(walker, keyType, valueType, keyValuePair);
								VisitValue(walker, walkType, valueType, pair.GetType().GetProperty(nameof(AssetPair<,>.Value))?.GetValue(pair)!);
								ExitDictionaryPair(walker, keyType, valueType, keyValuePair);
							}
							i++;
							if (i >= count)
							{
								break;
							}
							divideDictionaryMethod.Invoke(walker, [value]);
						}
					}
					ExitDictionary(walker, keyType, valueType, value);
				}
			}
			else if (genericTypeDefinition == typeof(AssetPair<,>))
			{
				Type keyType = type.GetGenericArguments()[0];
				Type valueType = type.GetGenericArguments()[1];

				object? keyValuePair = type.GetMethod("op_Implicit")?.Invoke(null, [value])!;
				if (EnterPair(walker, keyType, valueType, keyValuePair))
				{
					VisitValue(walker, walkType, keyType, type.GetProperty(nameof(AssetPair<,>.Key))?.GetValue(value)!);
					DividePair(walker, keyType, valueType, keyValuePair);
					VisitValue(walker, walkType, valueType, type.GetProperty(nameof(AssetPair<,>.Value))?.GetValue(value)!);
					ExitPair(walker, keyType, valueType, keyValuePair);
				}
			}
			else
			{
				throw new NotImplementedException(type.Name);
			}
		}
		else if (type.IsAssignableTo(typeof(IUnityAssetBase)))
		{
			string methodName = walkType switch
			{
				WalkType.Editor => nameof(IUnityAssetBase.WalkEditor),
				WalkType.Release => nameof(IUnityAssetBase.WalkRelease),
				_ => nameof(IUnityAssetBase.WalkStandard),
			};
			typeof(IUnityAssetBase).GetMethod(methodName, BindingFlags.Public | BindingFlags.Instance)
				!.Invoke(value, [walker]);
		}
		else
		{
			throw new NotSupportedException($"Unsupported type: {type.Name}");
		}
	}

	private static string GetName(FieldInfo field, WalkType walkType)
	{
		return walkType switch
		{
			WalkType.Editor => field.GetCustomAttribute<EditorFieldAttribute>()?.Name,
			WalkType.Release => field.GetCustomAttribute<ReleaseFieldAttribute>()?.Name,
			_ => null,
		} ?? field.Name;
	}
}

```

`Source/AssetRipper.Tests/Traversal/CustomInjectedObjectBase.WalkType.cs`:

```cs
namespace AssetRipper.Tests.Traversal;

partial class CustomInjectedObjectBase
{
	private enum WalkType
	{
		Editor,
		Release,
		Standard,
	}
}

```

`Source/AssetRipper.Tests/Traversal/CustomInjectedObjectBase.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using AssetRipper.Assets.Traversal;

namespace AssetRipper.Tests.Traversal;

internal abstract partial class CustomInjectedObjectBase : UnityObjectBase
{
	protected CustomInjectedObjectBase(AssetInfo assetInfo) : base(assetInfo)
	{
	}

	public override void WalkEditor(AssetWalker walker) => Walk(walker, WalkType.Editor);

	public override void WalkRelease(AssetWalker walker) => Walk(walker, WalkType.Release);

	public override void WalkStandard(AssetWalker walker) => Walk(walker, WalkType.Standard);
}

```

`Source/AssetRipper.Tests/Traversal/DefaultJsonWalkerTests.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Export.PrimaryContent;
using AssetRipper.SourceGenerated.Extensions;
using System.Text.Json.Nodes;

namespace AssetRipper.Tests.Traversal;

internal class DefaultJsonWalkerTests
{
	[TestCaseSource(nameof(GetObjectTypes))]
	public static void SerializedCustomObjectIsValidJson(Type type)
	{
		UnityObjectBase asset = AssetCreator.CreateUnsafe(type);
		string json = new DefaultJsonWalker().SerializeStandard(asset);
		JsonNode? node = JsonNode.Parse(json);
		Assert.That(node, Is.Not.Null);
		Assert.That(node, Is.TypeOf<JsonObject>());
	}

	private static Type[] GetObjectTypes() =>
	[
		typeof(SimpleObject),
		typeof(ParentObject),
		typeof(PrimitiveListObject),
		typeof(ComponentListObject),
		typeof(ListObject),
		typeof(DictionaryObject),
		typeof(PairObject),
	];
}

```

`Source/AssetRipper.Tests/Traversal/DefaultYamlWalkerTests.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using AssetRipper.Export.UnityProjects;
using AssetRipper.Primitives;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_320;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.ColorRGBAf;
using AssetRipper.SourceGenerated.Subclasses.FastPropertyName;
using AssetRipper.SourceGenerated.Subclasses.StaticBatchInfo;
using AssetRipper.SourceGenerated.Subclasses.UnityTexEnv;
using AssetRipper.Yaml;
using System.Globalization;

namespace AssetRipper.Tests.Traversal;

internal class DefaultYamlWalkerTests
{
	[TestCaseSource(nameof(GetObjectTypes))]
	public static void SerializedObjectIsConsistent(Type type, string yamlExpected)
	{
		UnityObjectBase asset = AssetCreator.CreateUnsafe(type);
		using (Assert.EnterMultipleScope())
		{
			string yamlActual = GenerateYaml(new DefaultYamlWalker(), asset);
			Assert.That(yamlActual, Is.EqualTo(yamlExpected));
		}
	}

	private static string GenerateYaml(YamlWalker yamlWalker, IUnityObjectBase asset)
	{
		return GenerateYaml(yamlWalker, [(asset, 1)]);
	}

	private static string GenerateYaml(YamlWalker yamlWalker, ReadOnlySpan<(IUnityObjectBase, long)> assets)
	{
		using StringWriter stringWriter = new(CultureInfo.InvariantCulture) { NewLine = "\n" };
		YamlWriter writer = new();
		writer.WriteHead(stringWriter);
		foreach ((IUnityObjectBase asset, long exportID) in assets)
		{
			YamlDocument document = yamlWalker.ExportYamlDocument(asset, exportID);
			writer.WriteDocument(document);
		}
		writer.WriteTail(stringWriter);
		return stringWriter.ToString();
	}

	private static object?[][] GetObjectTypes() =>
	[
		[typeof(ComponentListObject), ComponentListObject.Yaml],
		[typeof(DictionaryObject), DictionaryObject.Yaml],
		[typeof(GuidDictionaryObject), GuidDictionaryObject.Yaml],
		[typeof(ListObject), ListObject.Yaml],
		[typeof(PairListObject), PairListObject.Yaml],
		[typeof(PairObject), PairObject.Yaml],
		[typeof(ParentObject), ParentObject.Yaml],
		[typeof(PrimitiveListObject), PrimitiveListObject.Yaml],
		[typeof(SerializedVersionObject), SerializedVersionObject.Yaml],
		[typeof(SimpleObject), SimpleObject.Yaml],
		[typeof(StringDictionaryObject), StringDictionaryObject.Yaml],
		[typeof(SubclassObject), SubclassObject.Yaml],
		[typeof(StaticSquaredDictionaryObject), StaticSquaredDictionaryObject.Yaml],
	];

	private class DefaultYamlWalker : YamlWalker
	{
		public override YamlNode CreateYamlNodeForPPtr<TAsset>(PPtr<TAsset> pptr)
		{
			return new YamlMappingNode(MappingStyle.Flow)
			{
				{ "m_FileID", pptr.FileID },
				{ "m_PathID", pptr.PathID },
			};
		}
	}

	[Test]
	public void MonoBehaviourStructureSerializationTest()
	{
		const string yamlExpected = """
			%YAML 1.1
			%TAG !u! tag:unity3d.com,2011:
			--- !u!0 &1
			MonoBehaviour:
			  m_ObjectHideFlags: 0
			  m_PrefabParentObject: {m_FileID: 0, m_PathID: 0}
			  m_PrefabInternal: {m_FileID: 0, m_PathID: 0}
			  m_GameObject: {m_FileID: 0, m_PathID: 0}
			  m_Enabled: 0
			  m_EditorHideFlags: 0
			  m_Script: {m_FileID: 0, m_PathID: 0}
			  m_Name:
			  m_EditorClassIdentifier:
			  firstSubMesh: 0
			  subMeshCount: 0

			""";
		MonoBehaviour_2017_3 monoBehaviour = AssetCreator.CreateUnsafe<MonoBehaviour_2017_3>();
		monoBehaviour.Structure = new StaticBatchInfo();
		string yamlActual = GenerateYaml(new DefaultYamlWalker(), monoBehaviour);
		Assert.That(yamlActual, Is.EqualTo(yamlExpected));
	}

	[Test]
	public void MultipleMonoBehaviourStructureSerializationTest()
	{
		const string yamlExpected = """
			%YAML 1.1
			%TAG !u! tag:unity3d.com,2011:
			--- !u!0 &1
			MonoBehaviour:
			  m_ObjectHideFlags: 0
			  m_PrefabParentObject: {m_FileID: 0, m_PathID: 0}
			  m_PrefabInternal: {m_FileID: 0, m_PathID: 0}
			  m_GameObject: {m_FileID: 0, m_PathID: 0}
			  m_Enabled: 0
			  m_EditorHideFlags: 0
			  m_Script: {m_FileID: 0, m_PathID: 0}
			  m_Name:
			  m_EditorClassIdentifier:
			  firstSubMesh: 0
			  subMeshCount: 0
			--- !u!0 &2
			MonoBehaviour:
			  m_ObjectHideFlags: 0
			  m_PrefabParentObject: {m_FileID: 0, m_PathID: 0}
			  m_PrefabInternal: {m_FileID: 0, m_PathID: 0}
			  m_GameObject: {m_FileID: 0, m_PathID: 0}
			  m_Enabled: 0
			  m_EditorHideFlags: 0
			  m_Script: {m_FileID: 0, m_PathID: 0}
			  m_Name:
			  m_EditorClassIdentifier:
			  firstSubMesh: 0
			  subMeshCount: 0

			""";
		MonoBehaviour_2017_3 monoBehaviour = AssetCreator.CreateUnsafe<MonoBehaviour_2017_3>();
		monoBehaviour.Structure = new StaticBatchInfo();
		string yamlActual = GenerateYaml(new DefaultYamlWalker(), [(monoBehaviour, 1), (monoBehaviour, 2)]);
		Assert.That(yamlActual, Is.EqualTo(yamlExpected));
	}

	[Test]
	public void MaterialSerializationTest_3_5()
	{
		const string yamlExpected = """
			%YAML 1.1
			%TAG !u! tag:unity3d.com,2011:
			--- !u!0 &1
			Material:
			  serializedVersion: 3
			  m_ObjectHideFlags: 0
			  m_PrefabParentObject: {m_FileID: 0, m_PathID: 0}
			  m_PrefabInternal: {m_FileID: 0, m_PathID: 0}
			  m_Name:
			  m_Shader: {m_FileID: 0, m_PathID: 0}
			  m_SavedProperties:
			    serializedVersion: 2
			    m_TexEnvs:
			      data:
			        first:
			          name: _MainTex
			        second:
			          m_Texture: {m_FileID: 0, m_PathID: 0}
			          m_Scale: {x: 1, y: 1}
			          m_Offset: {x: 0, y: 0}
			    m_Floats: {}
			    m_Colors:
			      data:
			        first:
			          name: _Color
			        second: {r: 1, g: 1, b: 1, a: 1}

			""";
		Material_3_5 material = AssetCreator.CreateUnsafe<Material_3_5>();

		// Texture
		{
			(FastPropertyName name, UnityTexEnv_3_5 textureEnv) = material.SavedProperties_C21.TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_3_5!.AddNew();
			name.Name = "_MainTex";
			textureEnv.Scale.X = 1f;
			textureEnv.Scale.Y = 1f;
		}

		// Color
		{
			(FastPropertyName name, ColorRGBAf color) = material.SavedProperties_C21.Colors_AssetDictionary_FastPropertyName_ColorRGBAf!.AddNew();
			name.Name = "_Color";
			color.SetAsWhite();
		}

		string yamlActual = GenerateYaml(new DefaultYamlWalker().WithUnityVersion(new UnityVersion(3, 5, 6)), material);
		Assert.That(yamlActual, Is.EqualTo(yamlExpected));
	}

	[Test]
	public void MaterialSerializationTest_5_3_8()
	{
		const string yamlExpected = """
			%YAML 1.1
			%TAG !u! tag:unity3d.com,2011:
			--- !u!0 &1
			Material:
			  serializedVersion: 6
			  m_ObjectHideFlags: 0
			  m_PrefabParentObject: {m_FileID: 0, m_PathID: 0}
			  m_PrefabInternal: {m_FileID: 0, m_PathID: 0}
			  m_Name:
			  m_Shader: {m_FileID: 0, m_PathID: 0}
			  m_ShaderKeywords:
			  m_LightmapFlags: 0
			  m_CustomRenderQueue: 0
			  stringTagMap: {}
			  m_SavedProperties:
			    serializedVersion: 2
			    m_TexEnvs:
			      data:
			        first:
			          name: _MainTex
			        second:
			          m_Texture: {m_FileID: 0, m_PathID: 0}
			          m_Scale: {x: 1, y: 1}
			          m_Offset: {x: 0, y: 0}
			    m_Floats: {}
			    m_Colors:
			      data:
			        first:
			          name: _Color
			        second: {r: 1, g: 1, b: 1, a: 1}

			""";
		Material_5_1 material = AssetCreator.CreateUnsafe<Material_5_1>();

		// Texture
		{
			(FastPropertyName name, UnityTexEnv_5 textureEnv) = material.SavedProperties_C21.TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_5!.AddNew();
			name.Name = "_MainTex";
			textureEnv.Scale.X = 1f;
			textureEnv.Scale.Y = 1f;
		}

		// Color
		{
			(FastPropertyName name, ColorRGBAf color) = material.SavedProperties_C21.Colors_AssetDictionary_FastPropertyName_ColorRGBAf!.AddNew();
			name.Name = "_Color";
			color.SetAsWhite();
		}

		string yamlActual = GenerateYaml(new DefaultYamlWalker().WithUnityVersion(new UnityVersion(5, 3, 8)), material);
		Assert.That(yamlActual, Is.EqualTo(yamlExpected));
	}

	[Test]
	public void MaterialSerializationTest_5_4()
	{
		const string yamlExpected = """
			%YAML 1.1
			%TAG !u! tag:unity3d.com,2011:
			--- !u!0 &1
			Material:
			  serializedVersion: 6
			  m_ObjectHideFlags: 0
			  m_PrefabParentObject: {m_FileID: 0, m_PathID: 0}
			  m_PrefabInternal: {m_FileID: 0, m_PathID: 0}
			  m_Name:
			  m_Shader: {m_FileID: 0, m_PathID: 0}
			  m_ShaderKeywords:
			  m_LightmapFlags: 0
			  m_CustomRenderQueue: 0
			  stringTagMap: {}
			  m_SavedProperties:
			    serializedVersion: 2
			    m_TexEnvs:
			    - first:
			        name: _MainTex
			      second:
			        m_Texture: {m_FileID: 0, m_PathID: 0}
			        m_Scale: {x: 1, y: 1}
			        m_Offset: {x: 0, y: 0}
			    m_Floats: {}
			    m_Colors:
			    - first:
			        name: _Color
			      second: {r: 1, g: 1, b: 1, a: 1}

			""";
		Material_5_1 material = AssetCreator.CreateUnsafe<Material_5_1>();

		// Texture
		{
			(FastPropertyName name, UnityTexEnv_5 textureEnv) = material.SavedProperties_C21.TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_5!.AddNew();
			name.Name = "_MainTex";
			textureEnv.Scale.X = 1f;
			textureEnv.Scale.Y = 1f;
		}

		// Color
		{
			(FastPropertyName name, ColorRGBAf color) = material.SavedProperties_C21.Colors_AssetDictionary_FastPropertyName_ColorRGBAf!.AddNew();
			name.Name = "_Color";
			color.SetAsWhite();
		}

		string yamlActual = GenerateYaml(new DefaultYamlWalker().WithUnityVersion(new UnityVersion(5, 4)), material);
		Assert.That(yamlActual, Is.EqualTo(yamlExpected));
	}

	[Test]
	public void PlayableDirectorSerializationTest()
	{
		// Based on:
		// https://github.com/Unity-Technologies/Timeline-MessageMarker/blob/711db46387de66c746e9027090c2de786fe99855/Assets/TestScene.unity#L210-L231
		const string yamlExpected = """
			%YAML 1.1
			%TAG !u! tag:unity3d.com,2011:
			--- !u!0 &1
			PlayableDirector:
			  serializedVersion: 3
			  m_ObjectHideFlags: 0
			  m_CorrespondingSourceObject: {m_FileID: 0, m_PathID: 0}
			  m_PrefabInstance: {m_FileID: 0, m_PathID: 0}
			  m_PrefabAsset: {m_FileID: 0, m_PathID: 0}
			  m_GameObject: {m_FileID: 0, m_PathID: 0}
			  m_Enabled: 0
			  m_PlayableAsset: {m_FileID: 0, m_PathID: 0}
			  m_InitialState: 0
			  m_WrapMode: 0
			  m_DirectorUpdateMode: 0
			  m_InitialTime: 0
			  m_SceneBindings:
			  - key: {m_FileID: 0, m_PathID: 0}
			    value: {m_FileID: 0, m_PathID: 0}
			  - key: {m_FileID: 0, m_PathID: 0}
			    value: {m_FileID: 0, m_PathID: 0}
			  m_ExposedReferences:
			    m_References:
			    - fc1441eaed6bd5f45a945cc3d2579dd6: {m_FileID: 0, m_PathID: 0}
			    - ec546beecf692a4419584c0b9cc42a29: {m_FileID: 0, m_PathID: 0}

			""";
		PlayableDirector_2019 director = AssetCreator.CreateUnsafe<PlayableDirector_2019>();

		director.SceneBindings_C320.AddNew();
		director.SceneBindings_C320.AddNew();
		director.ExposedReferences_C320.References_Editor.AddNew().Key = "fc1441eaed6bd5f45a945cc3d2579dd6";
		director.ExposedReferences_C320.References_Editor.AddNew().Key = "ec546beecf692a4419584c0b9cc42a29";

		string yamlActual = GenerateYaml(new DefaultYamlWalker().WithUnityVersion(new UnityVersion(2019)), director);
		Assert.That(yamlActual, Is.EqualTo(yamlExpected));
	}
}

```

`Source/AssetRipper.Tests/Traversal/DictionaryObject.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;
using AssetRipper.Primitives;
using AssetRipper.SourceGenerated.Subclasses.Vector3f;

namespace AssetRipper.Tests.Traversal;

internal sealed class DictionaryObject : CustomInjectedObjectBase
{
	private readonly AssetDictionary<Utf8String, Utf8String> emptyDictionary = [];
	private readonly AssetDictionary<Vector3f, int> vectorDictionary = new();

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		DictionaryObject:
		  emptyDictionary: {}
		  vectorDictionary:
		  - first: {x: 0, y: 0, z: 0}
		    second: 0
		  - first: {x: 0, y: 0, z: 0}
		    second: 0

		""";

	public DictionaryObject(AssetInfo assetInfo) : base(assetInfo)
	{
		vectorDictionary.AddNew();
		vectorDictionary.AddNew();
	}
}

```

`Source/AssetRipper.Tests/Traversal/EditorFieldAttribute.cs`:

```cs
namespace AssetRipper.Tests.Traversal;

[AttributeUsage(AttributeTargets.Field)]
internal sealed class EditorFieldAttribute(string name) : Attribute
{
	public string Name { get; } = name;
}

```

`Source/AssetRipper.Tests/Traversal/GuidDictionaryObject.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;
using AssetRipper.SourceGenerated.Subclasses.GUID;

namespace AssetRipper.Tests.Traversal;

internal sealed class GuidDictionaryObject : CustomInjectedObjectBase
{
	private readonly AssetDictionary<GUID, bool> guidDictionary = new();

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		GuidDictionaryObject:
		  guidDictionary:
		    00000000000000000000000000000000: 0
		    00000000000000000000000000000000: 1

		""";

	public GuidDictionaryObject(AssetInfo assetInfo) : base(assetInfo)
	{
		guidDictionary.AddNew();
		guidDictionary.AddNew().Value = true;
	}
}

```

`Source/AssetRipper.Tests/Traversal/ListObject.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.Tests.Traversal;

internal sealed class ListObject : CustomInjectedObjectBase
{
	private readonly AssetList<ColorRGB> colorList = new();
	private readonly AssetList<VectorXY> vectorList = new();

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		ListObject:
		  colorList:
		  - {r: 1, g: 0.5, b: 0}
		  - {r: 1, g: 0.5, b: 0}
		  vectorList:
		  - serializedVersion: 2
		    xy: 0
		  - serializedVersion: 2
		    xy: 0

		""";

	public ListObject(AssetInfo assetInfo) : base(assetInfo)
	{
		colorList.AddNew();
		colorList.AddNew();
		vectorList.AddNew();
		vectorList.AddNew();
	}
}

```

`Source/AssetRipper.Tests/Traversal/PairListObject.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;
using AssetRipper.Primitives;

namespace AssetRipper.Tests.Traversal;

internal sealed class PairListObject : CustomInjectedObjectBase
{
	private readonly AssetList<AssetPair<Utf8String, Utf8String>> list = new();

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		PairListObject:
		  list:
		  - :
		  - _key: _value

		""";

	public PairListObject(AssetInfo assetInfo) : base(assetInfo)
	{
		list.AddNew();
		AssetPair<Utf8String, Utf8String> pair = list.AddNew();
		pair.Key = "_key";
		pair.Value = "_value";
	}
}

```

`Source/AssetRipper.Tests/Traversal/PairObject.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;
using AssetRipper.Primitives;

namespace AssetRipper.Tests.Traversal;

internal sealed class PairObject : CustomInjectedObjectBase
{
	private readonly AssetPair<Utf8String, Utf8String> pair = new()
	{
		Key = "_key",
		Value = "_value",
	};

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		PairObject:
		  pair:
		    _key: _value

		""";

	public PairObject(AssetInfo assetInfo) : base(assetInfo)
	{
	}
}

```

`Source/AssetRipper.Tests/Traversal/ParentObject.cs`:

```cs
using AssetRipper.Assets.Metadata;
using AssetRipper.SourceGenerated.Subclasses.Vector2f;

namespace AssetRipper.Tests.Traversal;

internal sealed class ParentObject : CustomInjectedObjectBase
{
	private readonly Vector2f coordinates = new();

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		ParentObject:
		  coordinates: {x: 0, y: 0}

		""";

	public ParentObject(AssetInfo assetInfo) : base(assetInfo)
	{
	}
}

```

`Source/AssetRipper.Tests/Traversal/PrimitiveListObject.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;

namespace AssetRipper.Tests.Traversal;

internal sealed class PrimitiveListObject : CustomInjectedObjectBase
{
	private readonly AssetList<int> emptyList = [];
	private readonly AssetList<int> list = [1, 1, 2, 3, 5];

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		PrimitiveListObject:
		  emptyList:
		  list: 0100000001000000020000000300000005000000

		""";

	private PrimitiveListObject(AssetInfo assetInfo) : base(assetInfo)
	{
	}
}

```

`Source/AssetRipper.Tests/Traversal/ReleaseFieldAttribute.cs`:

```cs
namespace AssetRipper.Tests.Traversal;

[AttributeUsage(AttributeTargets.Field)]
internal sealed class ReleaseFieldAttribute(string name) : Attribute
{
	public string Name { get; } = name;
}

```

`Source/AssetRipper.Tests/Traversal/SerializedVersionObject.cs`:

```cs
using AssetRipper.Assets.Metadata;

namespace AssetRipper.Tests.Traversal;

internal sealed class SerializedVersionObject : CustomInjectedObjectBase
{
	public override int SerializedVersion => 3;

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		SerializedVersionObject:
		  serializedVersion: 3

		""";

	private SerializedVersionObject(AssetInfo assetInfo) : base(assetInfo)
	{
	}
}

```

`Source/AssetRipper.Tests/Traversal/SimpleObject.cs`:

```cs
using AssetRipper.Assets.Metadata;
using AssetRipper.SourceGenerated.Classes.ClassID_43;

namespace AssetRipper.Tests.Traversal;

internal sealed class SimpleObject : CustomInjectedObjectBase
{
#pragma warning disable CS0414
#pragma warning disable CS0169
#pragma warning disable CS0649
	private readonly bool boolean = true;
	private readonly string name = nameof(SimpleObject);
	private readonly int integer = 42;
	private readonly IMesh? mesh;
#pragma warning restore CS0414
#pragma warning restore CS0169
#pragma warning restore CS0649

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		SimpleObject:
		  boolean: 1
		  name: SimpleObject
		  integer: 42
		  mesh: {m_FileID: 0, m_PathID: 0}

		""";

	private SimpleObject(AssetInfo assetInfo) : base(assetInfo)
	{
	}
}

```

`Source/AssetRipper.Tests/Traversal/StaticSquaredDictionaryObject.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;
using AssetRipper.SourceGenerated.Subclasses.StaticBatchInfo;

namespace AssetRipper.Tests.Traversal;

internal sealed class StaticSquaredDictionaryObject : CustomInjectedObjectBase
{
	private readonly AssetDictionary<StaticBatchInfo, StaticBatchInfo> dictionary = new();

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		StaticSquaredDictionaryObject:
		  dictionary:
		  - first:
		      firstSubMesh: 0
		      subMeshCount: 0
		    second:
		      firstSubMesh: 0
		      subMeshCount: 0
		  - first:
		      firstSubMesh: 0
		      subMeshCount: 0
		    second:
		      firstSubMesh: 0
		      subMeshCount: 0

		""";

	public StaticSquaredDictionaryObject(AssetInfo assetInfo) : base(assetInfo)
	{
		dictionary.AddNew();
		dictionary.AddNew();
	}
}

```

`Source/AssetRipper.Tests/Traversal/StringDictionaryObject.cs`:

```cs
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.Metadata;
using AssetRipper.Primitives;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.SourceGenerated.Subclasses.UnityTexEnv;

namespace AssetRipper.Tests.Traversal;

internal sealed class StringDictionaryObject : CustomInjectedObjectBase
{
	public readonly AssetDictionary<Utf8String, Utf8String> stringDictionary = new() { { "key1", "value1" }, { "key2", "value2" } };
	private readonly AssetDictionary<Utf8String, UnityTexEnv_5> normalDictionary = new();

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		StringDictionaryObject:
		  stringDictionary:
		    key1: value1
		    key2: value2
		  normalDictionary:
		    _BumpMap:
		      m_Texture: {m_FileID: 0, m_PathID: 0}
		      m_Scale: {x: 1, y: 1}
		      m_Offset: {x: 0, y: 0}
		    _DetailAlbedoMap:
		      m_Texture: {m_FileID: 0, m_PathID: 0}
		      m_Scale: {x: 1, y: 1}
		      m_Offset: {x: 0, y: 0}

		""";

	public StringDictionaryObject(AssetInfo assetInfo) : base(assetInfo)
	{
		{
			AssetPair<Utf8String, UnityTexEnv_5> pair = normalDictionary.AddNew();
			pair.Key = "_BumpMap";
			pair.Value.Scale.SetOne();
		}
		{
			AssetPair<Utf8String, UnityTexEnv_5> pair = normalDictionary.AddNew();
			pair.Key = "_DetailAlbedoMap";
			pair.Value.Scale.SetOne();
		}
	}
}

```

`Source/AssetRipper.Tests/Traversal/SubclassObject.cs`:

```cs
using AssetRipper.Assets.Metadata;
using AssetRipper.SourceGenerated.Subclasses.StaticBatchInfo;

namespace AssetRipper.Tests.Traversal;

internal sealed class SubclassObject : CustomInjectedObjectBase
{
	private readonly StaticBatchInfo m_StaticBatchInfo = new();

	public const string Yaml = """
		%YAML 1.1
		%TAG !u! tag:unity3d.com,2011:
		--- !u!0 &1
		SubclassObject:
		  m_StaticBatchInfo:
		    firstSubMesh: 0
		    subMeshCount: 0

		""";

	public SubclassObject(AssetInfo assetInfo) : base(assetInfo)
	{
	}
}

```

`Source/AssetRipper.Tests/Traversal/VectorXY.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Traversal;
using AssetRipper.Processing;

namespace AssetRipper.Tests.Traversal;

internal sealed class VectorXY : UnityAssetBase
{
#pragma warning disable CS0649
	private readonly ulong xy;
#pragma warning restore CS0649

	public override int SerializedVersion => 2;

	public override void WalkStandard(AssetWalker walker)
	{
		if (walker.EnterAsset(this))
		{
			this.WalkPrimitiveField(walker, xy);
			walker.ExitAsset(this);
		}
	}
}

```

`Source/AssetRipper.Tests/Traversal/YamlWalkerTests.cs`:

```cs
using AssetRipper.Export.UnityProjects;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_142;
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Tests.Traversal;

internal class YamlWalkerTests
{
	[Test]
	public void MonoBehaviourTest()
	{
		MonoBehaviour_2017_3 asset = AssetCreator.CreateUnsafe<MonoBehaviour_2017_3>();
		new YamlWalker().ExportYamlDocument(asset, 1);
	}

	[Test]
	public void GameObjectTest()
	{
		GameObject_2018_3 asset = AssetCreator.CreateUnsafe<GameObject_2018_3>();
		new YamlWalker().ExportYamlDocument(asset, 1);
	}

	[Test]
	public void AssetBundleTest()
	{
		AssetBundle_2018_3 asset = AssetCreator.CreateUnsafe<AssetBundle_2018_3>();
		new YamlWalker().ExportYamlDocument(asset, 1);
	}
}

```

`Source/AssetRipper.Tests/TypeTreeNodeStructTests.cs`:

```cs
using AssetRipper.Import.Structure.Assembly.TypeTrees;
using AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees;
using AssetRipper.SerializationLogic;

namespace AssetRipper.Tests;

internal class TypeTreeNodeStructTests
{
	[Test]
	public void NamedVectorTest()
	{
		TypeTree tree = new();
		tree.Nodes.Add(new TypeTreeNode("MonoBehaviour", "Base", 0, true));
		tree.Nodes.Add(new TypeTreeNode("SerializableClass", "fieldName", 1, true));
		tree.Nodes.Add(new TypeTreeNode("Array", "Array", 2, false));
		tree.Nodes.Add(new TypeTreeNode("int", "size", 3, false));
		tree.Nodes.Add(new TypeTreeNode("SerializableClass", "data", 3, true));
		tree.Nodes.Add(new TypeTreeNode("float", "subFieldName1", 4, false));
		tree.Nodes.Add(new TypeTreeNode("bool", "subFieldName2", 4, true));

		Assert.That(TypeTreeNodeStruct.TryMakeFromTypeTree(tree, out TypeTreeNodeStruct rootNode));
		Assert.That(rootNode.SubNodes, Has.Count.EqualTo(1));
		TypeTreeNodeStruct mainNode = rootNode.SubNodes[0];
		Assert.That(mainNode.IsNamedVector);
	}

	[TestCase(PrimitiveType.Bool)]
	[TestCase(PrimitiveType.Char)]
	[TestCase(PrimitiveType.SByte)]
	[TestCase(PrimitiveType.Byte)]
	[TestCase(PrimitiveType.Short)]
	[TestCase(PrimitiveType.UShort)]
	[TestCase(PrimitiveType.Int)]
	[TestCase(PrimitiveType.UInt)]
	[TestCase(PrimitiveType.Long)]
	[TestCase(PrimitiveType.ULong)]
	[TestCase(PrimitiveType.Single)]
	[TestCase(PrimitiveType.Double)]
	[TestCase(PrimitiveType.String)]
	public void PrimitiveTypeRoundTripIsTheSame(PrimitiveType primitiveType)
	{
		SerializablePrimitiveType serializableType = SerializablePrimitiveType.GetOrCreate(primitiveType);
		TypeTreeNodeStruct node = TypeTreeNodeStruct.FromSerializableType(serializableType);
		SerializableTreeType serializableTreeType = SerializableTreeType.FromRootNode(node);
		Assert.That(serializableTreeType.Type, Is.EqualTo(primitiveType));
	}
}

```

`Source/AssetRipper.Tests/UVInfoTests.cs`:

```cs
using AssetRipper.SourceGenerated.Extensions;

namespace AssetRipper.Tests;

internal class UVInfoTests
{
	[Test]
	public void GetReturnsTheSetValue()
	{
		const int index = 0;
		const bool exists = true;
		const int dimension = 2;
		UVInfo uvInfo = new UVInfo().AddChannelInfo(index, exists, dimension);
		uvInfo.GetChannelInfo(index, out bool actualExists, out int actualDimension);
		using (Assert.EnterMultipleScope())
		{
			Assert.That(actualExists, Is.EqualTo(exists));
			Assert.That(actualDimension, Is.EqualTo(dimension));
		}
	}

	[Test]
	public void GetReturnsTheSetValues()
	{
		const int dimension = 2;
		UVInfo uvInfo = default;
		for (int i = 0; i < 8; i++)
		{
			uvInfo = uvInfo.AddChannelInfo(i, i % 2 == 0, dimension);
		}
		for (int i = 0; i < 8; i++)
		{
			uvInfo.GetChannelInfo(i, out bool actualExists, out int actualDimension);
			using (Assert.EnterMultipleScope())
			{
				Assert.That(actualExists, Is.EqualTo(i % 2 == 0));
				Assert.That(actualDimension, Is.EqualTo(dimension));
			}
		}
	}
}

```

`Source/AssetRipper.Tests/Usings.cs`:

```cs
global using NUnit.Framework;

```

`Source/AssetRipper.Tests/VertexDataBlobTests.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.Primitives;
using AssetRipper.SourceGenerated.Extensions;
using System.Collections;
using System.Runtime.CompilerServices;

namespace AssetRipper.Tests;

internal class VertexDataBlobTests
{
	[Theory]
	public void TriangleMeshIsPreserved([Values("3.5", "4", "5", "2017", "2018", "2018.4")] string versionString, EndianType endianType)
	{
		MeshData meshData = MeshData.CreateTriangleMesh();
		UnityVersion version = UnityVersion.Parse(versionString);
		VertexDataBlob vertexDataBlob = VertexDataBlob.Create(meshData, version, endianType);
		MeshData meshData2 = vertexDataBlob.ToMeshData();

		using (Assert.EnterMultipleScope())
		{
			AssertEquivalence(meshData2.Vertices, meshData.Vertices);
			AssertEquivalence(meshData2.Normals, meshData.Normals);
			AssertEquivalence(meshData2.Tangents, meshData.Tangents);
			AssertEquivalence(meshData2.Colors, meshData.Colors);
			AssertEquivalence(meshData2.UV0, meshData.UV0);
			AssertEquivalence(meshData2.UV1, meshData.UV1);

			if (VertexDataBlob.SupportsUV2(version))
			{
				AssertEquivalence(meshData2.UV2, meshData.UV2);
			}
			else
			{
				Assert.That(meshData2.UV2, Is.Null);
			}

			if (VertexDataBlob.SupportsUV3(version))
			{
				AssertEquivalence(meshData2.UV3, meshData.UV3);
			}
			else
			{
				Assert.That(meshData2.UV3, Is.Null);
			}

			if (VertexDataBlob.SupportsUV4(version))
			{
				AssertEquivalence(meshData2.UV4, meshData.UV4);
			}
			else
			{
				Assert.That(meshData2.UV4, Is.Null);
			}

			if (VertexDataBlob.SupportsUV5(version))
			{
				AssertEquivalence(meshData2.UV5, meshData.UV5);
			}
			else
			{
				Assert.That(meshData2.UV5, Is.Null);
			}

			if (VertexDataBlob.SupportsUV6(version))
			{
				AssertEquivalence(meshData2.UV6, meshData.UV6);
			}
			else
			{
				Assert.That(meshData2.UV6, Is.Null);
			}

			if (VertexDataBlob.SupportsUV7(version))
			{
				AssertEquivalence(meshData2.UV7, meshData.UV7);
			}
			else
			{
				Assert.That(meshData2.UV7, Is.Null);
			}

			if (VertexDataBlob.SupportsSkin(version))
			{
				AssertEquivalence(meshData2.Skin, meshData.Skin);
			}
			else
			{
				Assert.That(meshData2.Skin, Is.Null);
			}
		}
	}

	private static void AssertEquivalence(
		IEnumerable? actual,
		IEnumerable? expected,
		[CallerArgumentExpression(nameof(expected))] string constraintExpression = "",
		[CallerArgumentExpression(nameof(actual))] string actualExpression = "")
	{
		if (expected is null)
		{
			Assert.That(actual, Is.Null, actualExpression: actualExpression);
		}
		else
		{
			Assert.That(actual, Is.Not.Null, actualExpression: actualExpression);
			Assert.That(actual, Is.EquivalentTo(expected), actualExpression: actualExpression, constraintExpression: constraintExpression);
		}
	}
}

```

`Source/AssetRipper.Tools.CabMapGenerator/Arguments.cs`:

```cs
using Ookii.CommandLine;
using System.ComponentModel;

namespace AssetRipper.Tools.CabMapGenerator;

[GeneratedParser]
[ParseOptions(IsPosix = true)]
internal sealed partial class Arguments
{
	[CommandLineArgument(IsPositional = true)]
	[Description("The input files to analyze.")]
	public string[]? FilesToExport { get; set; }

	[CommandLineArgument("output", DefaultValue = null, ShortName = 'o')]
	[Description("The output file to save the information. If not specified, it will be called \"cabmap.json\".")]
	public string? OutputFile { get; set; }
}

```

`Source/AssetRipper.Tools.CabMapGenerator/AssetRipper.Tools.CabMapGenerator.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.Tools.CabMapGenerator\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Tools.CabMapGenerator\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Ookii.CommandLine" Version="5.0.0" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.IO.Files\AssetRipper.IO.Files.csproj" />
	</ItemGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Tools.CabMapGenerator/DictionarySerializerContext.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.Tools.CabMapGenerator;

[JsonSourceGenerationOptions(WriteIndented = true)]
[JsonSerializable(typeof(Dictionary<string, string>))]
internal partial class DictionarySerializerContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.Tools.CabMapGenerator/Program.cs`:

```cs
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles;
using System.Text.Json;

namespace AssetRipper.Tools.CabMapGenerator;

internal static class Program
{
	static void Main(string[] args)
	{
		Arguments? arguments = Arguments.Parse(args);
		if (arguments is null)
		{
			return;
		}

		if (arguments.FilesToExport is null or { Length: 0 })
		{
			Console.WriteLine("No files were specified for analysis.");
			return;
		}

		if (string.IsNullOrEmpty(arguments.OutputFile))
		{
			arguments.OutputFile = Path.Join(AppContext.BaseDirectory, "cabmap.json");
		}
		using FileStream stream = File.Create(arguments.OutputFile);
		Dictionary<string, string> map = new();
		LoadFiles(GetAllFilePaths(arguments.FilesToExport), map);
		JsonSerializer.Serialize(stream, map, DictionarySerializerContext.Default.DictionaryStringString);
		Console.WriteLine("Done!");
	}

	private static IEnumerable<string> GetAllFilePaths(IEnumerable<string> paths)
	{
		foreach (string path in paths)
		{
			if (File.Exists(path))
			{
				yield return path;
			}
			else if (Directory.Exists(path))
			{
				foreach (string filePath in Directory.EnumerateFiles(path))
				{
					yield return filePath;
				}
			}
			else
			{
				Console.WriteLine($"No file or directory exists at {path}");
			}
		}
	}

	private static void LoadFiles(IEnumerable<string> files, Dictionary<string, string> map)
	{
		foreach (string file in files)
		{
			LoadFile(file, map);
		}
	}

	private static void LoadFile(string fullName, Dictionary<string, string> map)
	{
#if !DEBUG
		try
#endif
		{
			FileBase file = SchemeReader.LoadFile(fullName, LocalFileSystem.Instance);
			if (file is SerializedFile serializedFile)
			{
				Console.WriteLine($"Skipping non-bundled serialized file [{serializedFile.NameFixed}]");
			}
			else if (file is FileContainer container)
			{
				file.ReadContents();
				foreach (SerializedFile serializedFile1 in container.FetchSerializedFiles())
				{
					Console.WriteLine($"Found serialized file [{serializedFile1.NameFixed}] in bundle [{container.NameFixed}]:");
					if (!map.TryAdd(serializedFile1.NameFixed, container.NameFixed))
					{
						Console.WriteLine($"Serialized file [{serializedFile1.NameFixed}] is already listed in the map.");
					}
				}
			}
			else
			{
				string message = $"Error: File is {file.GetType()}";
				Console.WriteLine(message);
			}
		}
#if !DEBUG
		catch (Exception ex)
		{
			Console.WriteLine(ex.ToString());
		}
#endif
	}
}

```

`Source/AssetRipper.Tools.DependenceGrapher/Arguments.cs`:

```cs
using Ookii.CommandLine;
using System.ComponentModel;

namespace AssetRipper.Tools.DependenceGrapher;

[GeneratedParser]
[ParseOptions(IsPosix = true)]
internal sealed partial class Arguments
{
	/// <summary>
	/// This is chosen as the default because class ID numbers are always non-negative.
	/// </summary>
	private const int DefaultClassID = -1;
	/// <summary>
	/// This is chosen as the default because Unity treats a zero path id as being a null pointer.
	/// </summary>
	private const long DefaultPathID = 0;

	[CommandLineArgument(IsPositional = true)]
	[Description("The input files to analyze.")]
	public string[]? FilesToExport { get; set; }

	[CommandLineArgument("output", DefaultValue = null, ShortName = 'o')]
	[Description("The output file to save the information. If not specified, it will be called \"output.txt\".")]
	public string? OutputFile { get; set; }

	[CommandLineArgument("cab-map", DefaultValue = null)]
	[Description("If provided, a cab map json file will be used to list bundle names for referenced files.")]
	public string? CabMapPath { get; set; }

	[CommandLineArgument("name", DefaultValue = null)]
	[Description("If used, only assets with this name will be analyzed for external references.")]
	public string? Name { get; set; }

	[CommandLineArgument("class-name", DefaultValue = null)]
	[Description("If used, only assets with this class name will be analyzed for external references.")]
	public string? ClassName { get; set; }

	[CommandLineArgument("class-id", DefaultValue = DefaultClassID)]
	[Description("If used, only assets with this class ID will be analyzed for external references.")]
	public int ClassID { get; set; }

	[CommandLineArgument("path-id", DefaultValue = DefaultPathID)]
	[Description("If used, only assets with this PathID will be analyzed for external references.")]
	public long PathID { get; set; }

	[CommandLineArgument("verbose", DefaultValue = false, ShortName = 'v')]
	[Description("If true, additional information will be outputted about referencing assets.")]
	public bool Verbose { get; set; }
}

```

`Source/AssetRipper.Tools.DependenceGrapher/AssetRipper.Tools.DependenceGrapher.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.Tools.DependenceGrapher\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Tools.DependenceGrapher\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Ookii.CommandLine" Version="5.0.0" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Import\AssetRipper.Import.csproj" />
	</ItemGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Tools.DependenceGrapher/DictionarySerializerContext.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.Tools.DependenceGrapher;

[JsonSourceGenerationOptions(WriteIndented = true)]
[JsonSerializable(typeof(Dictionary<string, string>))]
internal partial class DictionarySerializerContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.Tools.DependenceGrapher/Filters/ClassIDFilter.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Tools.DependenceGrapher.Filters;

internal sealed class ClassIDFilter : IAssetFilter
{
	public ClassIDFilter(int classID)
	{
		ClassID = classID;
	}

	public int ClassID { get; }
	public bool IsAcceptable(IUnityObjectBase asset)
	{
		return asset.ClassID == ClassID;
	}
}

```

`Source/AssetRipper.Tools.DependenceGrapher/Filters/ClassNameFilter.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Tools.DependenceGrapher.Filters;

internal sealed class ClassNameFilter : IAssetFilter
{
	public ClassNameFilter(string name)
	{
		Name = name;
	}

	public string Name { get; }
	public bool IsAcceptable(IUnityObjectBase asset)
	{
		return asset.ClassName == Name;
	}
}

```

`Source/AssetRipper.Tools.DependenceGrapher/Filters/IAssetFilter.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Tools.DependenceGrapher.Filters;

internal interface IAssetFilter
{
	bool IsAcceptable(IUnityObjectBase asset);
}

```

`Source/AssetRipper.Tools.DependenceGrapher/Filters/NameFilter.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Tools.DependenceGrapher.Filters;

internal sealed class NameFilter : IAssetFilter
{
	public NameFilter(string name)
	{
		Name = name;
	}

	public string Name { get; }
	public bool IsAcceptable(IUnityObjectBase asset)
	{
		return asset.GetName() == Name;
	}
}

```

`Source/AssetRipper.Tools.DependenceGrapher/Filters/PathIDFilter.cs`:

```cs
using AssetRipper.Assets;

namespace AssetRipper.Tools.DependenceGrapher.Filters;

internal sealed class PathIDFilter : IAssetFilter
{
	public PathIDFilter(long pathID)
	{
		PathID = pathID;
	}

	public long PathID { get; }
	public bool IsAcceptable(IUnityObjectBase asset)
	{
		return asset.PathID == PathID;
	}
}

```

`Source/AssetRipper.Tools.DependenceGrapher/ObjectExtensions.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.SourceGenerated.Classes.ClassID_2;

namespace AssetRipper.Tools.DependenceGrapher;

internal static class ObjectExtensions
{
	public static string? GetName(this IUnityObjectBase _this)
	{
		string? gameObjectName = (_this as IComponent)?.GameObject_C2P?.Name;
		if (!string.IsNullOrEmpty(gameObjectName))
		{
			return gameObjectName;
		}
		else if (_this is INamed named)
		{
			return named.Name;
		}
		else
		{
			return null;
		}
	}
}

```

`Source/AssetRipper.Tools.DependenceGrapher/Program.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using AssetRipper.Import.AssetCreation;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using AssetRipper.SourceGenerated.Extensions;
using AssetRipper.Tools.DependenceGrapher.Filters;
using System.Text.Json;

namespace AssetRipper.Tools.DependenceGrapher;

internal static class Program
{
	/// <summary>
	/// This is chosen as the default because class ID numbers are always non-negative.
	/// </summary>
	private const int DefaultClassID = -1;
	/// <summary>
	/// This is chosen as the default because Unity treats a zero path id as being a null pointer.
	/// </summary>
	private const long DefaultPathID = 0;

	static void Main(string[] args)
	{
		Arguments? arguments = Arguments.Parse(args);
		if (arguments is null)
		{
			return;
		}

		if (arguments.FilesToExport is null or { Length: 0 })
		{
			Console.WriteLine("No files were specified for analysis.");
			return;
		}

		Dictionary<string, string> cabMap;
		if (File.Exists(arguments.CabMapPath))
		{
			using FileStream cabMapStream = File.OpenRead(arguments.CabMapPath);
			cabMap = JsonSerializer.Deserialize(arguments.CabMapPath, DictionarySerializerContext.Default.DictionaryStringString) ?? new();
		}
		else
		{
			cabMap = new();
		}

		List<IAssetFilter> filters = CreateFilterList(arguments.Name, arguments.ClassName, arguments.ClassID, arguments.PathID);
		if (string.IsNullOrEmpty(arguments.OutputFile))
		{
			arguments.OutputFile = Path.Join(AppContext.BaseDirectory, "output.txt");
		}
		using FileStream stream = File.Create(arguments.OutputFile);
		using TextWriter writer = new StreamWriter(stream);
		LoadFiles(GetAllFilePaths(arguments.FilesToExport), writer, filters, arguments.Verbose, cabMap);
		writer.Flush();
		Console.WriteLine("Done!");
	}

	private static IEnumerable<string> GetAllFilePaths(IEnumerable<string> paths)
	{
		foreach (string path in paths)
		{
			if (File.Exists(path))
			{
				yield return path;
			}
			else if (Directory.Exists(path))
			{
				foreach (string filePath in Directory.EnumerateFiles(path))
				{
					yield return filePath;
				}
			}
			else
			{
				Console.WriteLine($"No file or directory exists at {path}");
			}
		}
	}

	private static void LoadFiles(IEnumerable<string> files, TextWriter writer, List<IAssetFilter> filters, bool verbose, Dictionary<string, string> cabMap)
	{
		GameAssetFactory factory = new GameAssetFactory(new BaseManager(s => { }));
		foreach (string file in files)
		{
			LoadFile(file, factory, writer, filters, verbose, cabMap);
		}
	}

	private static void LoadFile(string fullName, GameAssetFactory factory, TextWriter writer, List<IAssetFilter> filters, bool verbose, Dictionary<string, string> cabMap)
	{
#if !DEBUG
		try
#endif
		{
			FileBase file = SchemeReader.LoadFile(fullName, LocalFileSystem.Instance);
			if (file is SerializedFile serializedFile)
			{
				writer.WriteLine($"Dependencies of serialized file [{serializedFile.NameFixed}]:");
				writer.WriteLine();
				ExtractDependencies(serializedFile, factory, writer, filters, verbose, cabMap);
			}
			else if (file is FileContainer container)
			{
				file.ReadContents();
				foreach (SerializedFile serializedFile1 in container.FetchSerializedFiles())
				{
					writer.WriteLine($"Dependencies of serialized file [{serializedFile1.NameFixed}] in bundle [{container.NameFixed}]:");
					writer.WriteLine();
					ExtractDependencies(serializedFile1, factory, writer, filters, verbose, cabMap);
				}
			}
			else
			{
				string message = $"Error: File is {file.GetType()}";
				Console.WriteLine(message);
			}
		}
#if !DEBUG
		catch (Exception ex)
		{
			Console.WriteLine(ex.ToString());
		}
#endif
	}

	private static List<IAssetFilter> CreateFilterList(string? name, string? className, int classID, long pathID)
	{
		List<IAssetFilter> filters = new();
		if (!string.IsNullOrEmpty(name))
		{
			filters.Add(new NameFilter(name));
		}
		if (!string.IsNullOrEmpty(className))
		{
			filters.Add(new ClassNameFilter(className));
		}
		if (classID != DefaultClassID)
		{
			filters.Add(new ClassIDFilter(classID));
		}
		if (pathID != DefaultPathID)
		{
			filters.Add(new PathIDFilter(pathID));
		}

		return filters;
	}

	private static void ExtractDependencies(SerializedFile file, GameAssetFactory factory, TextWriter writer, List<IAssetFilter> filters, bool verbose, Dictionary<string, string> cabMap)
	{
		GameBundle bundle = new();

		SerializedAssetCollection collection = bundle.AddCollectionFromSerializedFile(file, factory);
		bundle.InitializeAllDependencyLists();
		ExtractDependencies(file, collection, writer, filters, verbose, cabMap);
	}

	private static void ExtractDependencies(SerializedFile file, SerializedAssetCollection collection, TextWriter writer, List<IAssetFilter> filters, bool verbose, Dictionary<string, string> cabMap)
	{
		Dictionary<string, LinkedList<(string, IUnityObjectBase)>> results = new();
		foreach (IUnityObjectBase asset in collection)
		{
			if (filters.All(filter => filter.IsAcceptable(asset)))
			{
				foreach ((string fieldName, PPtr<IUnityObjectBase> pptr) in asset.FetchDependencies())
				{
					if (pptr.FileID > 0)
					{
						FileIdentifier identifier = file.Dependencies[pptr.FileID - 1];
						results.GetOrAdd(identifier.GetFilePath()).AddLast((fieldName, asset));
					}
				}
			}
		}
		foreach ((string referenceFileName, LinkedList<(string, IUnityObjectBase)> list) in results)
		{
			if (cabMap.TryGetValue(referenceFileName, out string? bundleName))
			{
				writer.WriteLine($"* {referenceFileName} in {bundleName}:");
			}
			else
			{
				writer.WriteLine($"* {referenceFileName}:");
			}

			foreach ((string fieldName, IUnityObjectBase asset) in list)
			{
				if (verbose)
				{
					writer.WriteLine($"  - {asset.GetName()}: {fieldName} (Class: {asset.ClassID} {asset.ClassName}, PathID: {asset.PathID})");
				}
				else
				{
					writer.WriteLine($"  - {asset.GetName()}: {fieldName}");
				}
			}
			writer.WriteLine();
		}
	}
}

```

`Source/AssetRipper.Tools.FileExtractor/AssetRipper.Tools.FileExtractor.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.Tools.FileExtractor\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Tools.FileExtractor\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.IO.Files\AssetRipper.IO.Files.csproj" />
	</ItemGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Tools.FileExtractor/Program.cs`:

```cs
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.CompressedFiles;
using AssetRipper.IO.Files.ResourceFiles;
using FileBase = AssetRipper.IO.Files.FileBase;

namespace AssetRipper.Tools.FileExtractor;

internal class Program
{
	private static readonly string outputDirectory = Path.Join(AppContext.BaseDirectory, "Output");

	static void Main(string[] args)
	{
		Directory.CreateDirectory(outputDirectory);
		if (args.Length == 0)
		{
			Console.WriteLine("No arguments");
		}
		else
		{
			LoadFiles(args);
		}
		Console.WriteLine("Finished!");
		Console.ReadKey();
		return;
	}

	private static void LoadFiles(string[] files)
	{
		foreach (string file in files)
		{
			LoadFile(file);
		}
	}

	private static void LoadFile(string fullName)
	{
		Console.WriteLine(fullName);
		try
		{
			FileBase file = SchemeReader.LoadFile(fullName, LocalFileSystem.Instance);
			SaveContents(file);
		}
		catch (Exception ex)
		{
			Console.WriteLine(ex.ToString());
		}
	}

	private static void SaveContents(FileBase file)
	{
		if (file is FileContainer container && container.ResourceFiles.Count > 0)
		{
			foreach (ResourceFile resourceFile in container.ResourceFiles)
			{
				string path = Path.Join(outputDirectory, resourceFile.NameFixed);
				using FileStream fileStream = File.OpenWrite(path);
				resourceFile.Write(fileStream);
				Console.WriteLine($"\t{path}");
			}
		}
		else if (file is CompressedFile compressedFile && compressedFile.UncompressedFile is ResourceFile uncompressedFile)
		{
			string path = Path.Join(outputDirectory, uncompressedFile.NameFixed);
			using FileStream fileStream = File.OpenWrite(path);
			uncompressedFile.Write(fileStream);
			Console.WriteLine($"\t{path}");
		}
	}
}

```

`Source/AssetRipper.Tools.FileExtractor/README.md`:

```md
# AssetRipper.Tools.FileExtractor

This is a simple program to extract bundles and compressed files. Just drag and drop the file(s) onto the exe.
```

`Source/AssetRipper.Tools.JsonSerializer/AssetRipper.Tools.JsonSerializer.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.Tools.JsonSerializer\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Tools.JsonSerializer\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Assets\AssetRipper.Assets.csproj" />
	</ItemGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Tools.JsonSerializer/JsonAsset.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Metadata;
using AssetRipper.IO.Endian;
using System.Text.Json.Nodes;

namespace AssetRipper.Tools.JsonSerializer;

public sealed class JsonAsset : UnityObjectBase
{
	public JsonNode? Contents { get; private set; }

	public JsonAsset(AssetInfo assetInfo) : base(assetInfo)
	{
	}

	public void Read(ref EndianSpanReader reader, SerializableEntry serializableType)
	{
		Contents = serializableType.Read(ref reader);
	}
}

```

`Source/AssetRipper.Tools.JsonSerializer/JsonAssetFactory.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Exceptions;
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.IO;
using AssetRipper.Assets.Metadata;
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.Tools.JsonSerializer;

public sealed class JsonAssetFactory : AssetFactoryBase
{
	public override IUnityObjectBase? ReadAsset(AssetInfo assetInfo, ReadOnlyArraySegment<byte> assetData, SerializedType? assetType)
	{
		if (assetType?.OldType.Nodes.Count > 0)
		{
			EndianSpanReader reader = new EndianSpanReader(assetData, assetInfo.Collection.EndianType);
			SerializableEntry entry = SerializableEntry.FromTypeTree(assetType.OldType);
			JsonAsset asset = new JsonAsset(assetInfo);
			asset.Read(ref reader, entry);
			IncorrectByteCountException.ThrowIf(in reader);
			return asset;
		}
		else
		{
			Console.WriteLine($"Asset could not be read because it has no type tree. ClassID: {assetInfo.ClassID} PathID: {assetInfo.PathID}");
			return null;
		}
	}
}

```

`Source/AssetRipper.Tools.JsonSerializer/JsonObjectSerializerContext.cs`:

```cs
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;

namespace AssetRipper.Tools.JsonSerializer;

[JsonSourceGenerationOptions(WriteIndented = true)]
[JsonSerializable(typeof(JsonObject))]
internal partial class JsonObjectSerializerContext : JsonSerializerContext
{
}

```

`Source/AssetRipper.Tools.JsonSerializer/PrimitiveType.cs`:

```cs
namespace AssetRipper.Tools.JsonSerializer;

public enum PrimitiveType
{
	U1,
	U2,
	U4,
	U8,
	I1,
	I2,
	I4,
	I8,
	Float,
	Double,
	Boolean,
	Character,
	String,
}

```

`Source/AssetRipper.Tools.JsonSerializer/Program.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles;
using System.Text.Json.Nodes;

namespace AssetRipper.Tools.JsonSerializer;

internal static class Program
{
	private static readonly string outputDirectory = Path.Join(AppContext.BaseDirectory, "Output");

	static void Main(string[] args)
	{
		Directory.CreateDirectory(outputDirectory);
		if (args.Length == 0)
		{
			Console.WriteLine("No arguments");
		}
		else
		{
			LoadFiles(args);
		}
		Console.WriteLine("Done!");
		Console.ReadKey();
		return;
	}

	private static void LoadFiles(string[] files)
	{
		foreach (string file in files)
		{
			LoadFile(file);
		}
	}

	private static void LoadFile(string fullName)
	{
		Console.WriteLine(fullName);
#if !DEBUG
		try
#endif
		{
			FileBase file = SchemeReader.LoadFile(fullName, LocalFileSystem.Instance);
			if (file is SerializedFile serializedFile)
			{
				ExtractJson(serializedFile);
			}
			else if (file is FileContainer container)
			{
				file.ReadContents();
				foreach (SerializedFile serializedFile1 in container.FetchSerializedFiles())
				{
					ExtractJson(serializedFile1);
				}
			}
			else
			{
				Console.WriteLine($"File is {file.GetType()}");
			}
		}
#if !DEBUG
		catch (Exception ex)
		{
			Console.WriteLine(ex.ToString());
		}
#endif
	}

	private static void ExtractJson(SerializedFile file)
	{
		GameBundle bundle = new();
		SerializedAssetCollection collection = bundle.AddCollectionFromSerializedFile(file, new JsonAssetFactory());
		bundle.InitializeAllDependencyLists();
		ExtractJson(file, collection);
	}

	private static void ExtractJson(SerializedFile file, SerializedAssetCollection collection)
	{
		JsonArray array = new();
		JsonObject root = new()
			{
				{ "Version", file.Version.ToString() },
				{ "Assets", array }
			};
		foreach ((_, IUnityObjectBase asset) in collection.Assets)
		{
			JsonObject assetObject = new();
			array.Add((JsonNode)assetObject);
			assetObject.Add("PathID", asset.PathID);
			assetObject.Add("ClassID", asset.ClassID);
			assetObject.Add("Fields", ((JsonAsset)asset).Contents);
			//Note: this assigns assetObject as the parent of Contents.
			//Normally, this would be a cause for concern, but the asset won't be used after this.
		}
		using FileStream stream = File.Create(Path.Join(outputDirectory, $"{file.NameFixed}.json"));
		System.Text.Json.JsonSerializer.Serialize(stream, root, JsonObjectSerializerContext.Default.JsonObject);
	}
}

```

`Source/AssetRipper.Tools.JsonSerializer/SerializableArray.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees;
using System.Text.Json.Nodes;

namespace AssetRipper.Tools.JsonSerializer;

public sealed class SerializableArray : SerializableEntry
{
	public SerializableArray(SerializableEntry elementType)
	{
		ElementType = elementType;
	}

	public SerializableEntry ElementType { get; }

	public override JsonNode Read(ref EndianSpanReader reader)
	{
		JsonArray result = new();
		int size = reader.ReadInt32();
		for (int i = 0; i < size; i++)
		{
			result.Add(ElementType.Read(ref reader));
		}
		MaybeAlign(ref reader);
		return result;
	}

	public static new SerializableArray FromTypeTreeNodes(List<TypeTreeNode> list, ref int index)
	{
		index++;
		ThrowIfIncorrectName(list[index], "size");
		index++;
		ThrowIfIncorrectName(list[index], "data");
		SerializableEntry elementType = SerializableEntry.FromTypeTreeNodes(list, ref index);
		return new SerializableArray(elementType);
	}
}

```

`Source/AssetRipper.Tools.JsonSerializer/SerializableEntry.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees;
using System.Text.Json.Nodes;

namespace AssetRipper.Tools.JsonSerializer;

public abstract class SerializableEntry
{
	public bool Align { get; set; }
	public abstract JsonNode? Read(ref EndianSpanReader reader);
	protected void MaybeAlign(ref EndianSpanReader reader)
	{
		if (Align)
		{
			reader.Align();
		}
	}
	public static SerializableEntry FromTypeTree(TypeTree typeTree)
	{
		int index = 0;
		return FromTypeTreeNodes(typeTree.Nodes, ref index);
	}
	public static SerializableEntry FromTypeTreeNodes(List<TypeTreeNode> list, ref int index)
	{
		bool align = list[index].MetaFlag.IsAlignBytes();
		SerializableEntry result;
		if (SerializablePrimitive.TryMakeFromTypeTreeNodes(list, ref index, out SerializablePrimitive? primitive))
		{
			result = primitive;
		}
		else
		{
			switch (list[index].Type)
			{
				case "map":
					{
						index++;
						ThrowIfIncorrectName(list[index], "Array");
						align |= list[index].MetaFlag.IsAlignBytes();
						result = SerializableArray.FromTypeTreeNodes(list, ref index);
						break;
					}
				case "vector" or "set" or "staticvector":
					{
						index++;
						ThrowIfIncorrectName(list[index], "Array");
						align |= list[index].MetaFlag.IsAlignBytes();
						result = SerializableArray.FromTypeTreeNodes(list, ref index);
						break;
					}
				case "Array":
					result = SerializableArray.FromTypeTreeNodes(list, ref index);
					break;
				case "pair":
					result = SerializablePair.FromTypeTreeNodes(list, ref index);
					break;
				case "TypelessData":
					{
						index++;
						ThrowIfIncorrectName(list[index], "size");
						index++;
						ThrowIfIncorrectName(list[index], "data");
						index++;
						result = new SerializableTypelessData();
						break;
					}
				default:
					result = SerializableType.FromTypeTreeNodes(list, ref index);
					break;
			}
		}
		result.Align |= align;
		return result;
	}
	protected static void ThrowIfIncorrectTypeName(TypeTreeNode node, string typeName)
	{
		if (typeName != node.Type)
		{
			throw new ArgumentException("Incorrect type", nameof(node));
		}
	}
	protected static void ThrowIfIncorrectName(TypeTreeNode node, string name)
	{
		if (name != node.Name)
		{
			throw new ArgumentException("Incorrect name", nameof(node));
		}
	}
}

```

`Source/AssetRipper.Tools.JsonSerializer/SerializablePair.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees;
using System.Text.Json.Nodes;

namespace AssetRipper.Tools.JsonSerializer;

public sealed class SerializablePair : SerializableEntry
{
	public SerializableEntry First { get; }
	public SerializableEntry Second { get; }

	public SerializablePair(SerializableEntry first, SerializableEntry second)
	{
		First = first;
		Second = second;
	}

	public override JsonNode Read(ref EndianSpanReader reader)
	{
		JsonObject result = new()
		{
			{ "first", First.Read(ref reader) },
			{ "second", Second.Read(ref reader) }
		};
		MaybeAlign(ref reader);
		return result;
	}

	public static new SerializablePair FromTypeTreeNodes(List<TypeTreeNode> list, ref int index)
	{
		index++;
		ThrowIfIncorrectName(list[index], "first");
		SerializableEntry first = SerializableEntry.FromTypeTreeNodes(list, ref index);
		ThrowIfIncorrectName(list[index], "second");
		SerializableEntry second = SerializableEntry.FromTypeTreeNodes(list, ref index);
		return new SerializablePair(first, second);
	}
}

```

`Source/AssetRipper.Tools.JsonSerializer/SerializablePrimitive.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees;
using System.Text;
using System.Text.Json.Nodes;

namespace AssetRipper.Tools.JsonSerializer;

public sealed class SerializablePrimitive : SerializableEntry
{
	public SerializablePrimitive(PrimitiveType type)
	{
		Type = type;
	}

	public PrimitiveType Type { get; }
	public override JsonNode? Read(ref EndianSpanReader reader)
	{
		JsonValue? result = Type switch
		{
			PrimitiveType.U1 => JsonValue.Create(reader.ReadByte()),
			PrimitiveType.U2 => JsonValue.Create(reader.ReadUInt16()),
			PrimitiveType.U4 => JsonValue.Create(reader.ReadUInt32()),
			PrimitiveType.U8 => JsonValue.Create(reader.ReadUInt64()),
			PrimitiveType.I1 => JsonValue.Create(reader.ReadSByte()),
			PrimitiveType.I2 => JsonValue.Create(reader.ReadInt16()),
			PrimitiveType.I4 => JsonValue.Create(reader.ReadInt32()),
			PrimitiveType.I8 => JsonValue.Create(reader.ReadInt64()),
			PrimitiveType.Float => JsonValue.Create(Clamp(reader.ReadSingle())),
			PrimitiveType.Double => JsonValue.Create(Clamp(reader.ReadDouble())),
			PrimitiveType.Boolean => JsonValue.Create(reader.ReadBoolean()),
			PrimitiveType.Character => JsonValue.Create(reader.ReadChar()),
			PrimitiveType.String => JsonValue.Create(ReadString(ref reader)),
			_ => throw new NotSupportedException()
		};
		MaybeAlign(ref reader);
		return result;
	}

	private static string ReadString(ref EndianSpanReader reader)
	{
		int size = reader.ReadInt32();
		byte[] data = reader.ReadBytes(size);
		if (data.Length != size)
		{
			throw new EndOfStreamException();
		}
		return Encoding.UTF8.GetString(data);
	}

	public static bool TryMakeFromTypeTreeNodes(List<TypeTreeNode> list, ref int index, [NotNullWhen(true)] out SerializablePrimitive? primitive)
	{
		TypeTreeNode node = list[index];
		string typeName = node.Type;
		if (typeName == "string")
		{
			TransferMetaFlags metaFlags = list[index].MetaFlag;
			index++;
			ThrowIfIncorrectName(list[index], "Array");
			index++;
			ThrowIfIncorrectName(list[index], "size");
			index++;
			ThrowIfIncorrectName(list[index], "data");
			index++;
			primitive = new SerializablePrimitive(PrimitiveType.String);
			primitive.Align = metaFlags.IsAlignBytes() || metaFlags.IsAnyChildUsesAlignBytes();
			return true;
		}

		primitive = typeName switch
		{
			"bool" => new SerializablePrimitive(PrimitiveType.Boolean),
			"char" => node.ByteSize == 2
				? new SerializablePrimitive(PrimitiveType.Character) //I don't think this can happen, but just to be safe.
				: new SerializablePrimitive(PrimitiveType.U1),
			"SInt8" => new SerializablePrimitive(PrimitiveType.I1),
			"UInt8" => new SerializablePrimitive(PrimitiveType.U1),
			"short" or "SInt16" => new SerializablePrimitive(PrimitiveType.I2),
			"ushort" or "UInt16" or "unsigned short" => node.MetaFlag.IsCharPropertyMask()
				? new SerializablePrimitive(PrimitiveType.Character)
				: new SerializablePrimitive(PrimitiveType.U2),
			"int" or "SInt32" or "Type*" => new SerializablePrimitive(PrimitiveType.I4),
			"uint" or "UInt32" or "unsigned int" => new SerializablePrimitive(PrimitiveType.U4),
			"SInt64" or "long long" => new SerializablePrimitive(PrimitiveType.I8),
			"UInt64" or "FileSize" or "unsigned long long" => new SerializablePrimitive(PrimitiveType.U8),
			"float" => new SerializablePrimitive(PrimitiveType.Float),
			"double" => new SerializablePrimitive(PrimitiveType.Double),
			_ => null,
		};
		if (primitive is not null)
		{
			index++;
			return true;
		}
		else
		{
			return false;
		}
	}

	private static float Clamp(float value)
	{
		if (float.IsNaN(value))
		{
			return 0;
		}
		else if (float.IsPositiveInfinity(value))
		{
			return float.MaxValue;
		}
		else if (float.IsNegativeInfinity(value))
		{
			return float.MinValue;
		}
		else
		{
			return value;
		}
	}

	private static double Clamp(double value)
	{
		if (double.IsNaN(value))
		{
			return 0;
		}
		else if (double.IsPositiveInfinity(value))
		{
			return double.MaxValue;
		}
		else if (double.IsNegativeInfinity(value))
		{
			return double.MinValue;
		}
		else
		{
			return value;
		}
	}
}

```

`Source/AssetRipper.Tools.JsonSerializer/SerializableType.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees;
using System.Text.Json.Nodes;

namespace AssetRipper.Tools.JsonSerializer;

public sealed class SerializableType : SerializableEntry
{
	public Dictionary<string, SerializableEntry> Entries { get; } = new();

	public override JsonNode Read(ref EndianSpanReader reader)
	{
		JsonObject result = new();
		foreach ((string key, SerializableEntry value) in Entries)
		{
			result.Add(key, value.Read(ref reader));
		}
		MaybeAlign(ref reader);
		return result;
	}

	public static new SerializableType FromTypeTreeNodes(List<TypeTreeNode> list, ref int index)
	{
		SerializableType result = new();
		int depth = list[index].Level;
		index++;
		while (index < list.Count && depth < list[index].Level)
		{
			string fieldName = list[index].Name;
			result.Entries.Add(fieldName, SerializableEntry.FromTypeTreeNodes(list, ref index));
		}
		return result;
	}
}

```

`Source/AssetRipper.Tools.JsonSerializer/SerializableTypelessData.cs`:

```cs
using AssetRipper.IO.Endian;
using System.Text.Json.Nodes;

namespace AssetRipper.Tools.JsonSerializer;

public sealed class SerializableTypelessData : SerializableEntry
{
	public override JsonNode? Read(ref EndianSpanReader reader)
	{
		int size = reader.ReadInt32();
		byte[] data = reader.ReadBytes(size);
		if (data.Length != size)
		{
			throw new EndOfStreamException();
		}
		MaybeAlign(ref reader);
		return JsonValue.Create(Convert.ToBase64String(data));
	}
}

```

`Source/AssetRipper.Tools.MonoBehaviourTester/AssetRipper.Tools.MonoBehaviourTester.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.Tools.MonoBehaviourTester\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Tools.MonoBehaviourTester\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Export\AssetRipper.Export.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Tools.MonoBehaviourTester/Program.cs`:

```cs
using AssetRipper.Import.Configuration;
using AssetRipper.Import.Logging;
using AssetRipper.Import.Structure.Assembly;
using AssetRipper.Import.Structure.Assembly.Managers;
using AssetRipper.Import.Structure.Platforms;
using AssetRipper.IO.Files;
using AssetRipper.Primitives;
using AssetRipper.SerializationLogic;

namespace AssetRipper.Tools.MonoBehaviourTester;

internal static class Program
{
	public static PlatformGameStructure PlatformStructure = null!;
	public static BaseManager AssemblyManager = null!;

	public static int Main(string[] args)
	{
		Logger.Add(new ConsoleLogger(false));

		if (args.Length < 3)
		{
			Logger.Error($"Usage: {Path.GetFileName(Environment.ProcessPath)} <game path> <mono behavior assembly> <mono behavior FQN>");
			return 1;
		}

		string gamePath = args[0];
		string monoBehaviorAssembly = args[1];
		string monoBehaviorFQN = args[2];

		Logger.Info("Determining platform...");

		PlatformChecker.CheckPlatform([gamePath], LocalFileSystem.Instance, out PlatformGameStructure? platformStructure, out MixedGameStructure? _);
		if (platformStructure == null)
		{
			Logger.Error("Game structure is not supported");
			return 1;
		}

		PlatformStructure = platformStructure;
		PlatformStructure.CollectFiles(true);

		ScriptingBackend backend = PlatformStructure.Backend;

		Logger.Info("Initializing assembly manager...");

		AssemblyManager = backend switch
		{
			ScriptingBackend.Mono => new MonoManager(OnRequestAssembly),
			ScriptingBackend.IL2Cpp => new IL2CppManager(OnRequestAssembly, ScriptContentLevel.Level2),
			_ => new BaseManager(OnRequestAssembly),
		};

		try
		{
			//Loads any Mono or IL2Cpp assemblies
			AssemblyManager.Initialize(PlatformStructure);
		}
		catch (Exception ex)
		{
			Logger.Error(LogCategory.Import, "Could not initialize assembly manager. Switching to the 'Unknown' scripting backend.");
			Logger.Error(ex);
			AssemblyManager = new BaseManager(OnRequestAssembly);
		}

		Logger.Info("Parsing requested type name...");

		string ns = string.Empty;
		string type = monoBehaviorFQN;

		if (monoBehaviorFQN.Contains('.'))
		{
			ns = monoBehaviorFQN[..monoBehaviorFQN.LastIndexOf('.')];
			type = monoBehaviorFQN[(monoBehaviorFQN.LastIndexOf('.') + 1)..];
		}

		Logger.Info($"Building serializable type for namespace: {ns}, type: {type}, assembly: {monoBehaviorAssembly}...");

		ScriptIdentifier typeId = new(monoBehaviorAssembly, ns, type);

		try
		{
			if (AssemblyManager.TryGetSerializableType(typeId, UnityVersion.MaxVersion, out SerializableType? serializableType, out string? failureReason))
			{
				Logger.Info($"Got serializable type: {serializableType}");
				PrintSerializationInfo(serializableType);
			}
			else
			{
				Logger.Error($"Could not build serializable type - {failureReason}");
				return 2;
			}
		}
		catch (Exception e)
		{
			Logger.Error($"Could not build serializable type - {e.Message}");
			return 1;
		}

		return 0;
	}

	private static void OnRequestAssembly(string assembly)
	{
		string? assemblyPath = PlatformStructure.RequestAssembly(assembly);
		if (assemblyPath is null)
		{
			Logger.Log(LogType.Warning, LogCategory.Import, $"Assembly '{assembly}' hasn't been found");
			return;
		}

		AssemblyManager.Load(assemblyPath, LocalFileSystem.Instance);
		Logger.Info(LogCategory.Import, $"Assembly '{assembly}' has been loaded");
	}

	private static void PrintSerializationInfo(SerializableType type, int indent = 1)
	{
		foreach (SerializableType.Field field in type.Fields)
		{
			string typeName = field.Type.ToString();
			if (field.ArrayDepth > 0)
			{
				typeName += string.Join("", Enumerable.Repeat("[]", field.ArrayDepth));
			}

			string ptrString = field.Type.IsEnginePointer() ? ", serialized as engine pointer" : "";

			Logger.Info("".PadLeft(indent * 4) + $"{field.Name} ({typeName}, {field.Type.Type}{ptrString})");

			if (field.Type.Type == PrimitiveType.Complex)
			{
				PrintSerializationInfo(field.Type, indent + 1);
			}
		}
	}
}

```

`Source/AssetRipper.Tools.RawTextureExtractor/AssetRipper.Tools.RawTextureExtractor.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.Tools.RawTextureExtractor\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Tools.RawTextureExtractor\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Export\AssetRipper.Export.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Tools.RawTextureExtractor/Program.cs`:

```cs
using AssetRipper.Assets;
using AssetRipper.Assets.Bundles;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Generics;
using AssetRipper.Assets.IO;
using AssetRipper.Assets.Metadata;
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using AssetRipper.SourceGenerated;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_89;
using AssetRipper.SourceGenerated.Extensions;
using System.Diagnostics;

namespace AssetRipper.Tools.RawTextureExtractor;

internal static class Program
{
	private static readonly string outputDirectory = Path.Join(AppContext.BaseDirectory, "Output");

	static void Main(string[] args)
	{
		if (Directory.Exists(outputDirectory))
		{
			Directory.Delete(outputDirectory, true);
		}
		Directory.CreateDirectory(outputDirectory);
		if (args.Length == 0)
		{
			Console.WriteLine("No arguments");
		}
		else
		{
			LoadFiles(args);
			Console.WriteLine("Done!");
		}
		Console.ReadKey();
		return;
	}

	private static void LoadFiles(string[] files)
	{
		foreach (string file in files)
		{
			LoadFile(file);
		}
	}

	private static void LoadFile(string fullName)
	{
		Console.WriteLine(fullName);
#if !DEBUG
	try
#endif
		{
			FileBase file = SchemeReader.LoadFile(fullName, LocalFileSystem.Instance);
			if (file is SerializedFile serializedFile)
			{
				GameBundle bundle = new();
				SerializedAssetCollection collection = bundle.AddCollectionFromSerializedFile(serializedFile, new TextureAssetFactory());
				bundle.InitializeAllDependencyLists();
				Extract(collection);
			}
			else if (file is FileContainer container)
			{
				file.ReadContents();
				SerializedBundle serializedBundle = SerializedBundle.FromFileContainer(container, new TextureAssetFactory());
				foreach (AssetCollection collection in serializedBundle.FetchAssetCollections())
				{
					Extract(collection);
				}
			}
			else
			{
				Console.WriteLine($"File is {file.GetType()}");
			}
		}
#if !DEBUG
	catch (Exception ex)
	{
		Console.WriteLine(ex.ToString());
	}
#endif
	}

	private static void Extract(AssetCollection collection)
	{
		const string jsonExtension = ".json";

		string collectionOutputPath = Path.Join(GetReversedName(collection).Reverse().ToArray());
		Directory.CreateDirectory(collectionOutputPath);
		foreach (ITexture2D texture in collection.OfType<ITexture2D>())
		{
			byte[] data = texture.GetImageData();
			if (data.Length > 0)
			{
				string originalName = texture.Name;
				string name = originalName.Length > 0
					? FileSystem.FixInvalidFileNameCharacters(originalName)
					: $"{texture.ClassName}_{ToValidString(texture.PathID)}";
				Debug.Assert(name.Length > 0);
				string uniqueName = LocalFileSystem.Instance.GetUniqueName(collectionOutputPath, name, FileSystem.MaxFileNameLength - jsonExtension.Length);
				string dataFilePath = Path.Join(collectionOutputPath, uniqueName);
				string infoFilePath = dataFilePath + jsonExtension;
				File.WriteAllBytes(dataFilePath, data);
				string text = $$"""
					{
						"Type" : "{{texture.ClassName}}",
						"Format" : "{{texture.Format_C28E}}",
						"FileSize" : {{data.Length}},
						"ImageSize" : {{texture.CompleteImageSize}},
						"ImageCount" : {{texture.ImageCount_C28}},
						"Mips" : {{texture.Mips.ToJson()}},
						"Width" : {{texture.Width_C28}},
						"Height" : {{texture.Height_C28}}
					}
					""";
				File.WriteAllText(infoFilePath, text);
			}
		}
	}

	private static IEnumerable<string> GetReversedName(AssetCollection collection)
	{
		yield return collection.Name;
		Bundle? bundle = collection.Bundle;
		while (bundle is not null and not GameBundle)
		{
			yield return bundle.Name;
			bundle = bundle.Parent;
		}
		yield return outputDirectory;
	}

	private static string ToValidString(long value)
	{
		if (value >= 0)
		{
			return value.ToString();
		}
		else if (value == long.MinValue)
		{
			return $"N{value.ToString().AsSpan(1)}";
		}
		else
		{
			return (-value).ToString();
		}
	}

	private static string ToJson(this bool value)
	{
		return value ? "true" : "false";
	}

	private sealed class TextureAssetFactory : AssetFactoryBase
	{
		public override IUnityObjectBase? ReadAsset(AssetInfo assetInfo, ReadOnlyArraySegment<byte> assetData, SerializedType? assetType)
		{
			IUnityObjectBase? asset = CreateAsset(assetInfo);
			if (asset is not null)
			{
				EndianSpanReader reader = new EndianSpanReader(assetData, asset.Collection.EndianType);
				return TryReadAsset(ref reader, asset.Collection.Flags, asset);
			}
			else
			{
				return null;
			}
		}

		private static IUnityObjectBase? CreateAsset(AssetInfo assetInfo)
		{
			return (ClassIDType)assetInfo.ClassID switch
			{
				ClassIDType.Texture2D => Texture2D.Create(assetInfo),
				ClassIDType.Cubemap => Cubemap.Create(assetInfo),
				_ => null
			};
		}

		private static IUnityObjectBase? TryReadAsset(ref EndianSpanReader reader, TransferInstructionFlags flags, IUnityObjectBase asset)
		{
			try
			{
				asset.Read(ref reader, flags);
				if (reader.Position != reader.Length)
				{
					Console.WriteLine($"Read {reader.Position} but expected {reader.Length} for asset type {(ClassIDType)asset.ClassID}. V: {asset.Collection.Version} P: {asset.Collection.Platform} N: {asset.Collection.Name} Path: {asset.Collection.FilePath}");
					return null;
				}
				else
				{
					return asset;
				}
			}
			catch (Exception ex)
			{
				Console.WriteLine($"Error during reading of asset type {(ClassIDType)asset.ClassID}. V: {asset.Collection.Version} P: {asset.Collection.Platform} N: {asset.Collection.Name} Path: {asset.Collection.FilePath}\n{ex}");
				return null;
			}
		}
	}
}

```

`Source/AssetRipper.Tools.SystemTester/AssetRipper.Tools.SystemTester.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.Tools.SystemTester\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Tools.SystemTester\$(Configuration)\</IntermediateOutputPath>
		<ServerGarbageCollection>true</ServerGarbageCollection>
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Export.UnityProjects\AssetRipper.Export.UnityProjects.csproj" />
	</ItemGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Tools.SystemTester/Program.cs`:

```cs
using AssetRipper.Export.Configuration;
using AssetRipper.Export.UnityProjects;
using AssetRipper.Import.Logging;
using AssetRipper.IO.Files;
using AssetRipper.Processing;

namespace AssetRipper.Tools.SystemTester;

static class Program
{
	private const string TestsDirectory = "../../Tests";

	static void Main(string[] args)
	{
		Logger.Add(new ConsoleLogger(true));
		Logger.Add(new FileLogger("AssetRipper.Tools.SystemTester.log"));
		Logger.LogSystemInformation("System Tester");
		Logger.BlankLine();

		if (args.Length == 0)
		{
			RunTests();
			Console.ReadLine();
		}
		else
		{
			Rip(args, Path.Join(AppContext.BaseDirectory, "Ripped"));
		}
	}

	static void RunTests()
	{
		if (!Directory.Exists(TestsDirectory))
		{
			Logger.Log(LogType.Warning, LogCategory.General, "Tests folder did not exist. Creating...");
			Directory.CreateDirectory(TestsDirectory);
			Logger.Info(LogCategory.General, "Created. Program will now exit.");
			return;
		}

		Logger.Info(LogCategory.General, $"Running tests in {Path.GetFullPath(TestsDirectory)}");
		Logger.BlankLine();

		int numTests = 0;
		int numSuccessful = 0;
		List<(string, string)> successfulTests = new();
		List<(string, string)> unsuccessfulTests = new();
		foreach (string versionPath in Directory.GetDirectories(TestsDirectory))
		{
			string versionName = Path.GetRelativePath(TestsDirectory, versionPath);
			foreach (string testPath in Directory.GetDirectories(versionPath))
			{
				string testName = Path.GetRelativePath(versionPath, testPath);
				Logger.Info(LogCategory.General, $"Found test: '{testName}' for Unity version: '{versionName}'");
				numTests++;
				string inputPath = Path.Join(testPath, "Input");
				if (!Directory.Exists(inputPath))
				{
					Logger.Log(LogType.Error, LogCategory.General, $"No input folder for '{testName}' on Unity version '{versionName}'");
					unsuccessfulTests.Add((versionName, testName));
				}
				else
				{
					try
					{
						string[] inputFiles = Directory.GetFiles(inputPath);
						string[] inputDirectories = Directory.GetDirectories(inputPath);
						string[] inputPaths = Combine(inputFiles, inputDirectories);
						string outputPath = Path.Join(testPath, "Output");
						Rip(inputPaths, outputPath);
						Logger.Info(LogCategory.General, $"Completed test: '{testName}' for Unity version: '{versionName}'");
						Logger.BlankLine(2);
						numSuccessful++;
						successfulTests.Add((versionName, testName));
					}
					catch (Exception ex)
					{
						Logger.Log(LogType.Error, LogCategory.General, ex.ToString());
						Logger.BlankLine(2);
						unsuccessfulTests.Add((versionName, testName));
					}
				}
			}
		}

		Logger.Info(LogCategory.General, $"{numSuccessful}/{numTests} tests successfully completed");
		if (numSuccessful > 0)
		{
			Logger.Info(LogCategory.General, "Successful:");
			foreach ((string version, string test) in successfulTests)
			{
				Logger.Info(LogCategory.General, $"\t{version,-12} {test}");
			}
		}
		if (numSuccessful < numTests)
		{
			Logger.Info(LogCategory.General, "Unsuccessful:");
			foreach ((string version, string test) in unsuccessfulTests)
			{
				Logger.Info(LogCategory.General, $"\t{version,-12} {test}");
			}
		}
	}

	private static void Rip(string[] inputPaths, string outputPath)
	{
		FullConfiguration settings = new();
		settings.LogConfigurationValues();
		ExportHandler exportHandler = new(settings);
		GameData gameData = exportHandler.LoadAndProcess(inputPaths, LocalFileSystem.Instance);
		PrepareExportDirectory(outputPath);
		exportHandler.Export(gameData, outputPath, LocalFileSystem.Instance);
	}

	private static void PrepareExportDirectory(string path)
	{
		if (Directory.Exists(path))
		{
			Logger.Info(LogCategory.Export, "Clearing export directory...");
			Directory.Delete(path, true);
		}
	}

	private static T[] Combine<T>(T[] array1, T[] array2)
	{
		ArgumentNullException.ThrowIfNull(array1);
		ArgumentNullException.ThrowIfNull(array2);

		T[] result = new T[array1.Length + array2.Length];
		for (int i = 0; i < array1.Length; i++)
		{
			result[i] = array1[i];
		}
		for (int j = 0; j < array2.Length; j++)
		{
			result[j + array1.Length] = array2[j];
		}
		return result;
	}
}

```

`Source/AssetRipper.Tools.SystemTester/README.md`:

```md
# AssetRipper.Tools.SystemTester

This is an automated system testing program.

## File Structure

```
Bins
 |--Tests
 |   |--2019.4.3 //just an example
 |   |   |--Test1Name
 |   |   |   |--Input
 |   |   |   |   |-- any files or folders to be processed
 |   |   |   |--Output
 |   |   |   |   |-- the test output
 |   |   |--Test2Name
 |   |   |   |--Input
 |   |   |   |   |-- any files or folders to be processed
 |   |   |   |--Output
 |   |   |   |   |-- the test output
 |   |--2020.2.0 //just an example
 |   |   |--Test3Name
 |   |   |   |--Input
 |   |   |   |   |-- any files or folders to be processed
 |   |   |   |--Output
 |   |   |   |   |-- the test output
 |   |   |--Test4Name
 |   |   |   |--Input
 |   |   |   |   |-- any files or folders to be processed
 |   |   |   |--Output
 |   |   |   |   |-- the test output
 |   |   |--Test5Name
 |   |   |   |--Input
 |   |   |   |   |-- any files or folders to be processed
 |   |   |   |--Output
 |   |   |   |   |-- the test output
 ```
```

`Source/AssetRipper.Tools.TypeTreeExtractor/AssetRipper.Tools.TypeTreeExtractor.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<OutputPath>..\0Bins\AssetRipper.Tools.TypeTreeExtractor\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Tools.TypeTreeExtractor\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.IO.Files\AssetRipper.IO.Files.csproj" />
	</ItemGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Tools.TypeTreeExtractor/Program.cs`:

```cs
using AssetRipper.IO.Files;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using System.Text;

namespace AssetRipper.Tools.TypeTreeExtractor;

internal static class Program
{
	private static readonly string outputDirectory = System.IO.Path.Join(AppContext.BaseDirectory, "Output");

	static void Main(string[] args)
	{
		System.IO.Directory.CreateDirectory(outputDirectory);
		if (args.Length == 0)
		{
			Console.WriteLine("No arguments");
		}
		else
		{
			LoadFiles(args);
		}
		Console.ReadKey();
		return;
	}

	private static void LoadFiles(string[] files)
	{
		foreach (string file in files)
		{
			LoadFile(file);
		}
	}

	private static void LoadFile(string fullName)
	{
		Console.WriteLine(fullName);
		try
		{
			FileBase file = SchemeReader.LoadFile(fullName, LocalFileSystem.Instance);
			file.ReadContentsRecursively();
			SaveTypeTrees(file);
		}
		catch (Exception ex)
		{
			Console.WriteLine(ex.ToString());
		}
	}

	private static void SaveTypeTrees(FileBase file)
	{
		if (file is SerializedFile serializedFile)
		{
			SaveTypeTrees(serializedFile);
		}
		else if (file is FileContainer container)
		{
			SaveTypeTrees(container);
		}
	}

	private static void SaveTypeTrees(FileContainer container)
	{
		foreach (SerializedFile serializedFile in container.SerializedFiles)
		{
			SaveTypeTrees(serializedFile);
		}
		foreach (FileContainer internalContainer in container.FileLists)
		{
			SaveTypeTrees(internalContainer);
		}
	}

	private static void SaveTypeTrees(SerializedFile file)
	{
		if (!file.HasTypeTree)
		{
			return;
		}

		StringBuilder sb = new();
		foreach (SerializedType type in file.Types.ToArray().OrderBy(t => t.TypeID))
		{
			Console.WriteLine($"\tType ID: {type.TypeID,-10} Script Index: {type.ScriptTypeIndex,-5} Node Count: {type.OldType.Nodes.Count}");

			AppendTypeTree(sb, type);
		}
		foreach (SerializedTypeReference type in file.RefTypes.ToArray().OrderBy(t => t.TypeID))
		{
			Console.WriteLine($"\tType ID: {type.TypeID,-10} Script Index: {type.ScriptTypeIndex,-5} Node Count: {type.OldType.Nodes.Count}");
			Console.WriteLine($"\t\t{type.AsmName} {type.FullName}");

			AppendTypeTree(sb, type);
		}
		string text = sb.ToString();
		if (!string.IsNullOrWhiteSpace(text))
		{
			string filePath = System.IO.Path.Join(outputDirectory, file.Name + ".txt");
			System.IO.File.WriteAllText(filePath, text);
		}
	}

	private static void AppendTypeTree(StringBuilder sb, SerializedTypeBase type)
	{
		string typeTreeText = type.OldType.Dump;
		if (!string.IsNullOrEmpty(typeTreeText))
		{
			if (type is SerializedTypeReference reference)
			{
				sb.AppendLine($"// {reference.AsmName} {reference.FullName}");
			}
			AppendClassIDLine(sb, type);
			sb.AppendLine(typeTreeText);
		}
	}

	private static void AppendClassIDLine(StringBuilder sb, SerializedTypeBase type)
	{
		string typeName = type.OldType.Nodes.Count > 0 ? type.OldType.Nodes[0].Type : "Unknown";
		string strippedSuffix = type.IsStrippedType ? " Stripped" : "";
		sb.AppendLine($"// classID{{{type.TypeID}}}: {typeName}{strippedSuffix}");
	}
}

```

`Source/AssetRipper.Web/AssetRipper.Web.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.Web\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Web\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<FrameworkReference Include="Microsoft.AspNetCore.App" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Web/Content/HtmlPage.cs`:

```cs
namespace AssetRipper.Web.Content;

public abstract class HtmlPage : WebContent
{
	public override void Write(TextWriter writer) => writer.Write("<!DOCTYPE html>");

	public sealed override string ContentType => "text/html";
}

```

`Source/AssetRipper.Web/Content/JavaScript.cs`:

```cs
namespace AssetRipper.Web.Content;

public abstract class JavaScript : WebContent
{
	public sealed override string ContentType => "text/javascript";
}

```

`Source/AssetRipper.Web/Content/StyleSheet.cs`:

```cs
namespace AssetRipper.Web.Content;

public abstract class StyleSheet : WebContent
{
	public sealed override string ContentType => "text/css";
}

```

`Source/AssetRipper.Web/Content/WebContent.cs`:

```cs
using Microsoft.AspNetCore.Http;
using System.Text;

namespace AssetRipper.Web.Content;

public abstract class WebContent
{
	public abstract void Write(TextWriter writer);

	public sealed override string ToString()
	{
		StringWriter writer = new()
		{
			NewLine = "\n",
		};
		Write(writer);
		return writer.ToString();
	}

	public Task WriteToResponse(HttpResponse response)
	{
		response.ContentType = ContentType;
		return response.WriteAsync(ToString());
	}

	public IResult ToResult()
	{
		return Results.Text(ToString(), ContentType, Encoding.UTF8);
	}

	/// <summary>
	/// <see href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">Mime Type</see>
	/// </summary>
	public abstract string ContentType { get; }
}

```

`Source/AssetRipper.Web/Extensions/HttpResponseExtensions.cs`:

```cs
using Microsoft.AspNetCore.Http;

namespace AssetRipper.Web.Extensions;

public static class HttpResponseExtensions
{
	public static void DisableCaching(this HttpResponse response)
	{
		response.Headers.CacheControl = "no-store, max-age=0";
	}

	public static Task NotFound(this HttpResponse response, string? errorMessage = null)
	{
		// Set the response status code to 404 (Not Found)
		response.StatusCode = 404;

		// Optionally, we can provide a custom error message
		if (!string.IsNullOrEmpty(errorMessage))
		{
			return response.WriteAsync(errorMessage);
		}
		else
		{
			return Task.CompletedTask;
		}
	}
}

```

`Source/AssetRipper.Web/Extensions/QueryCollectionExtensions.cs`:

```cs
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Primitives;

namespace AssetRipper.Web.Extensions;

public static class QueryCollectionExtensions
{
	public static bool TryGetValue(this IQueryCollection query, string key, [NotNullWhen(true)] out string? value)
	{
		if (query.TryGetValue(key, out StringValues values))
		{
			value = values.ToString();
			return true;
		}
		else
		{
			value = null;
			return false;
		}
	}
}

```

`Source/AssetRipper.Yaml.Tests/AssetRipper.Yaml.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<IsPackable>false</IsPackable>
		<OutputPath>..\0Bins\Other\AssetRipper.Yaml.Tests\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Yaml.Tests\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
		<PackageReference Include="NUnit" Version="4.4.0" />
		<PackageReference Include="NUnit3TestAdapter" Version="6.1.0" />
		<PackageReference Include="NUnit.Analyzers" Version="4.11.2">
			<PrivateAssets>all</PrivateAssets>
			<IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
		</PackageReference>
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipper.Yaml\AssetRipper.Yaml.csproj" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Yaml.Tests/FlowMappingTests.cs`:

```cs
using NUnit.Framework;

namespace AssetRipper.Yaml.Tests;

public static class FlowMappingTests
{
	[Test]
	public static void Vector2FlowMappingTest()
	{
		YamlMappingNode mappingNode = new(MappingStyle.Flow)
		{
			{ "x", 2 },
			{ "y", 3 }
		};
		Assert.That(mappingNode.EmitToString(), Is.EqualTo("{x: 2, y: 3}"));
	}
}

```

`Source/AssetRipper.Yaml.Tests/HexTests.cs`:

```cs
using NUnit.Framework;

namespace AssetRipper.Yaml.Tests;

internal class HexTests
{
	[Test]
	public void OneFloatTest()
	{
		YamlScalarNode node = YamlScalarNode.CreateHex(1f);
		Assert.That(node.ToString(), Is.EqualTo("0x3f800000(1)"));
	}
}

```

`Source/AssetRipper.Yaml.Tests/YamlScalarNodeTests.cs`:

```cs
using NUnit.Framework;
using System.Numerics;

namespace AssetRipper.Yaml.Tests;

public class YamlScalarNodeTests
{
	[Test]
	public void NullCharacterIsDoubleQuotedAndEscaped()
	{
		YamlScalarNode node = YamlScalarNode.Create("\0");
		using (Assert.EnterMultipleScope())
		{
			Assert.That(node.Value, Is.EqualTo("\0"));
			Assert.That(node.NodeType, Is.EqualTo(YamlNodeType.Scalar));
			Assert.That(node.Style, Is.EqualTo(ScalarStyle.DoubleQuoted));
			Assert.That(node.EmitToString(), Is.EqualTo("\"\\u0000\""));
		}
	}

	[Test]
	public void EndOfTextCharacterCausesDoubleQuoting()
	{
		const string someText = "Some text\u0003";
		YamlScalarNode node = YamlScalarNode.Create(someText);
		using (Assert.EnterMultipleScope())
		{
			Assert.That(node.Value, Is.EqualTo(someText));
			Assert.That(node.NodeType, Is.EqualTo(YamlNodeType.Scalar));
			Assert.That(node.Style, Is.EqualTo(ScalarStyle.DoubleQuoted));
			Assert.That(node.EmitToString(), Is.EqualTo("\"Some text\\u0003\""));
		}
	}

	[Test]
	public void AsciiCharactersUsePlainStyle()
	{
		const string asciiCharacters = "Ascii Characters";
		YamlScalarNode node = YamlScalarNode.Create(asciiCharacters);
		using (Assert.EnterMultipleScope())
		{
			Assert.That(node.Value, Is.EqualTo(asciiCharacters));
			Assert.That(node.NodeType, Is.EqualTo(YamlNodeType.Scalar));
			Assert.That(node.Style, Is.EqualTo(ScalarStyle.Plain));
			Assert.That(node.EmitToString(), Is.EqualTo(asciiCharacters));
		}
	}

	[Test]
	public void ByteListTest() => NumericListTest<byte>([ 0x01, 0x02, 0x03 ], "010203");

	[Test]
	public void UInt16ListTest() => NumericListTest<ushort>([ 0x0102, 0x0304, 0x0506 ], "020104030605");

	[Test]
	public void UInt32ListTest() => NumericListTest<uint>([ 0x01020304, 0x05060708 ], "0403020108070605");

	[Test]
	public void UInt64ListTest() => NumericListTest<ulong>([ 0x0102030405060708, 0x090A0B0C0D0E0F10 ], "0807060504030201100f0e0d0c0b0a09");

	private static void NumericListTest<T>(IReadOnlyList<T> list, string expected) where T : unmanaged, INumber<T>
	{
		YamlScalarNode node = YamlScalarNode.CreateHex(list);
		using (Assert.EnterMultipleScope())
		{
			Assert.That(node.Value, Is.EqualTo(expected));
			Assert.That(node.NodeType, Is.EqualTo(YamlNodeType.Scalar));
			Assert.That(node.Style, Is.EqualTo(ScalarStyle.Plain));
			Assert.That(node.EmitToString(), Is.EqualTo(expected));
		}
	}
}

```

`Source/AssetRipper.Yaml/AssetRipper.Yaml.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\AssetRipper.Yaml\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\AssetRipper.Yaml\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.Primitives" Version="3.2.0" />
	</ItemGroup>

</Project>

```

`Source/AssetRipper.Yaml/Emitter.cs`:

```cs
using System.Buffers;

namespace AssetRipper.Yaml;

internal sealed class Emitter
{
	public Emitter(TextWriter writer, bool formatKeys)
	{
		ArgumentNullException.ThrowIfNull(writer);
		m_stream = writer;
		IsFormatKeys = formatKeys;
	}

	public Emitter IncreaseIndent()
	{
		m_indent++;
		return this;
	}

	public Emitter DecreaseIndent()
	{
		if (m_indent == 0)
		{
			throw new Exception($"Increase/decrease indent mismatch");
		}

		m_indent--;
		return this;
	}

	public Emitter Write(char value)
	{
		WriteDelayed();
		m_stream.Write(value);
		return this;
	}

	public Emitter WriteRaw(char value)
	{
		m_stream.Write(value);
		return this;
	}

	/// <summary>
	/// Write a unicode character in the format \uXXXX.
	/// </summary>
	/// <remarks>
	/// Only used in <see cref="ScalarStyle.DoubleQuoted"/> strings.
	/// </remarks>
	/// <param name="value">The character to write.</param>
	/// <returns><see langword="this"/></returns>
	public Emitter WriteRawUnicode(char value)
	{
		m_stream.Write($"\\u{(ushort)value:X4}");
		return this;
	}

	public Emitter Write(byte value)
	{
		WriteDelayed();
		m_stream.Write(value);
		return this;
	}

	public Emitter Write(ushort value)
	{
		WriteDelayed();
		m_stream.Write(value);
		return this;
	}

	public Emitter Write(short value)
	{
		WriteDelayed();
		m_stream.Write(value);
		return this;
	}

	public Emitter Write(uint value)
	{
		WriteDelayed();
		m_stream.Write(value);
		return this;
	}

	public Emitter Write(int value)
	{
		WriteDelayed();
		m_stream.Write(value);
		return this;
	}

	public Emitter Write(ulong value)
	{
		WriteDelayed();
		m_stream.Write(value);
		return this;
	}

	public Emitter Write(long value)
	{
		WriteDelayed();
		m_stream.Write(value);
		return this;
	}

	public Emitter Write(float value)
	{
		WriteDelayed();
		m_stream.Write(value);
		return this;
	}

	public Emitter Write(double value)
	{
		WriteDelayed();
		m_stream.Write(value);
		return this;
	}

	public Emitter Write(ReadOnlySpan<char> value)
	{
		if (!value.IsEmpty)
		{
			WriteDelayed();
			m_stream.Write(value);
		}
		return this;
	}

	public Emitter WriteFormat(ReadOnlySpan<char> value)
	{
		if (value.Length > 0)
		{
			WriteDelayed();
			if (value.Length > 2 && value.StartsWith("m_", StringComparison.Ordinal))
			{
				int length = value.Length - 2;
				char[] buffer = ArrayPool<char>.Shared.Rent(length);

				value[2..].CopyTo(buffer);
				if (char.IsUpper(buffer[0]))
				{
					buffer[0] = char.ToLowerInvariant(buffer[0]);
				}
				m_stream.Write(buffer, 0, length);

				ArrayPool<char>.Shared.Return(buffer);
			}
			else
			{
				m_stream.Write(value);
			}
		}
		return this;
	}

	public Emitter WriteRaw(ReadOnlySpan<char> value)
	{
		m_stream.Write(value);
		return this;
	}

	public Emitter WriteClose(char @char)
	{
		m_isNeedSeparator = false;
		m_isNeedWhitespace = false;
		m_isNeedLineBreak = false;
		return Write(@char);
	}

	public Emitter WriteClose(ReadOnlySpan<char> @string)
	{
		m_isNeedSeparator = false;
		m_isNeedWhitespace = false;
		return Write(@string);
	}

	public Emitter WriteWhitespace()
	{
		m_isNeedWhitespace = true;
		return this;
	}

	public Emitter WriteSeparator()
	{
		m_isNeedSeparator = true;
		return this;
	}

	public Emitter WriteLine()
	{
		m_isNeedLineBreak = true;
		return this;
	}

	public void WriteMeta(MetaType type, string value)
	{
		Write('%').Write(type.ToStringRepresentation()).WriteWhitespace();
		Write(value).WriteLine();
	}

	public void WriteDelayed()
	{
		if (m_isNeedLineBreak)
		{
			m_stream.Write('\n');
			m_isNeedSeparator = false;
			m_isNeedWhitespace = false;
			m_isNeedLineBreak = false;
			WriteIndent();
		}
		if (m_isNeedSeparator)
		{
			m_stream.Write(',');
			m_isNeedSeparator = false;
		}
		if (m_isNeedWhitespace)
		{
			m_stream.Write(' ');
			m_isNeedWhitespace = false;
		}
	}

	private void WriteIndent()
	{
		if (m_indent > 0)
		{
			ArgumentOutOfRangeException.ThrowIfGreaterThan(m_indent, 1000);
			Span<char> buffer = stackalloc char[m_indent * 2];
			buffer.Fill(' ');
			m_stream.Write(buffer);
		}
	}

	public bool IsFormatKeys { get; }
	internal bool IsKey { get; set; }

	private readonly TextWriter m_stream;

	private int m_indent = 0;
	private bool m_isNeedWhitespace = false;
	private bool m_isNeedSeparator = false;
	private bool m_isNeedLineBreak = false;
}

```

`Source/AssetRipper.Yaml/Extensions/ReverseHexString.cs`:

```cs
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace AssetRipper.Yaml.Extensions;

internal static class ReverseHexString
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int GetHexStringLength<T>() => Unsafe.SizeOf<T>() * 2;

	public static void WriteReverseHexString<T>(T value, Span<char> buffer) where T : unmanaged
	{
		if (typeof(T) == typeof(byte) || typeof(T) == typeof(sbyte))
		{
			byte x = Unsafe.As<T, byte>(ref value);
			buffer[0] = NybbleToLowercaseHexCharacter(x >> 4);
			buffer[1] = NybbleToLowercaseHexCharacter(x & 0x0F);
		}
		else if (typeof(T) == typeof(short) || typeof(T) == typeof(ushort) || typeof(T) == typeof(char))
		{
			ushort x = Unsafe.As<T, ushort>(ref value);
			buffer[0] = NybbleToLowercaseHexCharacter((x >> 4) & 0x0F);
			buffer[1] = NybbleToLowercaseHexCharacter(x & 0x0F);
			buffer[2] = NybbleToLowercaseHexCharacter(x >> 12);
			buffer[3] = NybbleToLowercaseHexCharacter((x >> 8) & 0x0F);
		}
		else if (typeof(T) == typeof(int) || typeof(T) == typeof(uint))
		{
			int x = Unsafe.As<T, int>(ref value);
			buffer[0] = NybbleToLowercaseHexCharacter((x >> 4) & 0x0F);
			buffer[1] = NybbleToLowercaseHexCharacter(x & 0x0F);
			buffer[2] = NybbleToLowercaseHexCharacter((x >> 12) & 0x0F);
			buffer[3] = NybbleToLowercaseHexCharacter((x >> 8) & 0x0F);
			buffer[4] = NybbleToLowercaseHexCharacter((x >> 20) & 0x0F);
			buffer[5] = NybbleToLowercaseHexCharacter((x >> 16) & 0x0F);
			buffer[6] = NybbleToLowercaseHexCharacter(x >> 28);
			buffer[7] = NybbleToLowercaseHexCharacter((x >> 24) & 0x0F);
		}
		else if (typeof(T) == typeof(long) || typeof(T) == typeof(ulong))
		{
			long x = Unsafe.As<T, long>(ref value);
			buffer[0] = NybbleToLowercaseHexCharacter((x >> 4) & 0x0F);
			buffer[1] = NybbleToLowercaseHexCharacter(x & 0x0F);
			buffer[2] = NybbleToLowercaseHexCharacter((x >> 12) & 0x0F);
			buffer[3] = NybbleToLowercaseHexCharacter((x >> 8) & 0x0F);
			buffer[4] = NybbleToLowercaseHexCharacter((x >> 20) & 0x0F);
			buffer[5] = NybbleToLowercaseHexCharacter((x >> 16) & 0x0F);
			buffer[6] = NybbleToLowercaseHexCharacter((x >> 28) & 0x0F);
			buffer[7] = NybbleToLowercaseHexCharacter((x >> 24) & 0x0F);
			buffer[8] = NybbleToLowercaseHexCharacter((x >> 36) & 0x0F);
			buffer[9] = NybbleToLowercaseHexCharacter((x >> 32) & 0x0F);
			buffer[10] = NybbleToLowercaseHexCharacter((x >> 44) & 0x0F);
			buffer[11] = NybbleToLowercaseHexCharacter((x >> 40) & 0x0F);
			buffer[12] = NybbleToLowercaseHexCharacter((x >> 52) & 0x0F);
			buffer[13] = NybbleToLowercaseHexCharacter((x >> 48) & 0x0F);
			buffer[14] = NybbleToLowercaseHexCharacter(x >> 60);
			buffer[15] = NybbleToLowercaseHexCharacter((x >> 56) & 0x0F);
		}
		else if (typeof(T) == typeof(float))
		{
			WriteReverseHexString(BitConverter.SingleToUInt32Bits(Unsafe.As<T, float>(ref value)), buffer);
		}
		else if (typeof(T) == typeof(double))
		{
			WriteReverseHexString(BitConverter.DoubleToUInt64Bits(Unsafe.As<T, double>(ref value)), buffer);
		}
		else
		{
			Debug.Fail($"Unsupported type {typeof(T).FullName} for reverse hex string conversion.");
		}
	}

	private static char NybbleToLowercaseHexCharacter(int x)
	{
		const int Zero = (int)'0';
		const int Offset = (int)'a' - Zero - 0x0A;
		return unchecked((char)(x + Zero + ((9 - x) >> 31 & Offset)));
	}
	private static char NybbleToLowercaseHexCharacter(long x) => NybbleToLowercaseHexCharacter(unchecked((int)x));
}

```

`Source/AssetRipper.Yaml/Extensions/YamlArrayExtensions.cs`:

```cs
namespace AssetRipper.Yaml.Extensions;

public static class YamlArrayExtensions
{
	public static void AddTypelessData(this YamlMappingNode mappingNode, string name, IReadOnlyList<byte> data)
	{
		mappingNode.Add(name, data.Count);
		mappingNode.Add(TypelessdataName, YamlScalarNode.CreateHex(data));
	}

	public const string TypelessdataName = "_typelessdata";
}

```

`Source/AssetRipper.Yaml/Extensions/YamlSerializedVersionExtensions.cs`:

```cs
namespace AssetRipper.Yaml.Extensions;

public static class YamlSerializedVersionExtensions
{
	public static void AddSerializedVersion(this YamlMappingNode _this, int version)
	{
		if (version > 1)
		{
			_this.Add(SerializedVersionName, version);
		}
	}

	public static void ForceAddSerializedVersion(this YamlMappingNode _this, int version)
	{
		if (version > 0)
		{
			_this.Add(SerializedVersionName, version);
		}
	}

	public static void InsertSerializedVersion(this YamlMappingNode _this, int version)
	{
		if (version > 1)
		{
			_this.InsertBegin(SerializedVersionName, version);
		}
	}

	public const string SerializedVersionName = "serializedVersion";
}

```

`Source/AssetRipper.Yaml/MappingStyle.cs`:

```cs
namespace AssetRipper.Yaml;

/// <summary>
/// Specifies the style of a mapping.
/// </summary>
public enum MappingStyle
{
	/// <summary>
	/// The block mapping style.
	/// </summary>
	Block,

	/// <summary>
	/// The flow mapping style.
	/// </summary>
	Flow
}

```

`Source/AssetRipper.Yaml/MetaType.cs`:

```cs
namespace AssetRipper.Yaml;

internal enum MetaType
{
	Yaml,
	Tag,
}

internal static class MetaTypeExtensions
{
	public static string ToStringRepresentation(this MetaType metaType)
	{
		return metaType switch
		{
			MetaType.Yaml => "YAML",
			MetaType.Tag => "TAG",
			_ => throw new ArgumentOutOfRangeException(nameof(metaType), $"Value: {metaType}"),
		};
	}
}

```

`Source/AssetRipper.Yaml/ScalarStyle.cs`:

```cs
namespace AssetRipper.Yaml;

/// <summary>
/// Specifies the style of a Yaml scalar.
/// </summary>
public enum ScalarStyle
{
	/// <summary>
	/// The plain scalar style.
	/// </summary>
	Plain,

	/// <summary>
	/// The single-quoted scalar style.
	/// </summary>
	SingleQuoted,

	/// <summary>
	/// The double-quoted scalar style.
	/// </summary>
	DoubleQuoted,
}

```

`Source/AssetRipper.Yaml/ScalarType.cs`:

```cs
namespace AssetRipper.Yaml;

internal enum ScalarType
{
	Boolean,
	Byte,
	SByte,
	UInt16,
	Int16,
	UInt32,
	Int32,
	UInt64,
	Int64,
	Single,
	Double,
	String,
}

```

`Source/AssetRipper.Yaml/SequenceStyle.cs`:

```cs
namespace AssetRipper.Yaml;

/// <summary>
/// Specifies the style of a sequence.
/// </summary>
public enum SequenceStyle
{
	/// <summary>
	/// The block sequence style
	/// </summary>
	Block,

	/// <summary>
	/// The block sequence style but with curly braces
	/// </summary>
	BlockCurve,

	/// <summary>
	/// The flow sequence style
	/// </summary>
	Flow,
}

public static class SequenceStyleExtensions
{
	public static bool IsAnyBlock(this SequenceStyle _this)
	{
		return _this is SequenceStyle.Block or SequenceStyle.BlockCurve;
	}
}

```

`Source/AssetRipper.Yaml/YAMLDocument.cs`:

```cs
namespace AssetRipper.Yaml;

public sealed class YamlDocument
{
	public YamlDocument() { }

	public YamlSequenceNode CreateSequenceRoot()
	{
		YamlSequenceNode root = new();
		Root = root;
		return root;
	}

	public YamlMappingNode CreateMappingRoot()
	{
		YamlMappingNode root = new();
		Root = root;
		return root;
	}

	internal void Emit(Emitter emitter, bool isSeparator)
	{
		if (isSeparator)
		{
			emitter.Write("---").WriteWhitespace();
		}

		ThrowIfNullRoot();
		Root.Emit(emitter);
	}

	[MemberNotNull(nameof(Root))]
	private void ThrowIfNullRoot()
	{
		if (Root is null)
		{
			throw new NullReferenceException("Root cannot be null here");
		}
	}

	public YamlNode? Root { get; private set; }
}

```

`Source/AssetRipper.Yaml/YAMLMappingNode.cs`:

```cs
using System.Collections;

namespace AssetRipper.Yaml;

public sealed class YamlMappingNode : YamlNode, IEnumerable<KeyValuePair<YamlNode, YamlNode>>
{
	public YamlMappingNode() { }

	public YamlMappingNode(MappingStyle style)
	{
		Style = style;
	}

	public void Add(int key, long value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(int key, string value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(int key, YamlNode value)
	{
		YamlScalarNode keyNode = YamlScalarNode.Create(key);
		InsertEnd(keyNode, value);
	}

	public void Add(uint key, string value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(uint key, YamlNode value)
	{
		YamlScalarNode keyNode = YamlScalarNode.Create(key);
		InsertEnd(keyNode, value);
	}

	public void Add(long key, string value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(long key, YamlNode value)
	{
		YamlScalarNode keyNode = YamlScalarNode.Create(key);
		InsertEnd(keyNode, value);
	}

	public void Add(string key, bool value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(string key, byte value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(string key, short value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(string key, ushort value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(string key, int value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(string key, uint value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(string key, long value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(string key, ulong value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(string key, float value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(string key, double value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(string key, string value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(string key, YamlNode value)
	{
		YamlScalarNode keyNode = YamlScalarNode.CreatePlain(key);
		InsertEnd(keyNode, value);
	}

	public void Add(YamlNode key, bool value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(YamlNode key, byte value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(YamlNode key, short value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(YamlNode key, ushort value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(YamlNode key, int value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(YamlNode key, uint value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(YamlNode key, long value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(YamlNode key, ulong value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(YamlNode key, float value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(YamlNode key, string value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		Add(key, valueNode);
	}

	public void Add(YamlNode key, YamlNode value)
	{
		if (key.NodeType != YamlNodeType.Scalar)
		{
			throw new Exception($"Only {YamlNodeType.Scalar} node as a key supported");
		}

		InsertEnd(key, value);
	}

	public void Append(YamlMappingNode map)
	{
		foreach (KeyValuePair<YamlNode, YamlNode> child in map.Children)
		{
			Add(child.Key, child.Value);
		}
	}

	public void InsertBegin(string key, int value)
	{
		YamlScalarNode valueNode = YamlScalarNode.Create(value);
		InsertBegin(key, valueNode);
	}

	public void InsertBegin(string key, YamlNode value)
	{
		YamlScalarNode keyNode = YamlScalarNode.CreatePlain(key);
		InsertBegin(keyNode, value);
	}

	public void InsertBegin(YamlNode key, YamlNode value)
	{
		ArgumentNullException.ThrowIfNull(value);

		KeyValuePair<YamlNode, YamlNode> pair = new(key, value);
		Children.Insert(0, pair);
	}

	internal override void Emit(Emitter emitter)
	{
		base.Emit(emitter);

		StartChildren(emitter);
		foreach (KeyValuePair<YamlNode, YamlNode> kvp in Children)
		{
			YamlNode key = kvp.Key;
			YamlNode value = kvp.Value;

			bool iskey = emitter.IsKey;
			emitter.IsKey = true;
			key.Emit(emitter);
			emitter.IsKey = false;
			StartTransition(emitter, value);
			value.Emit(emitter);
			EndTransition(emitter, value);
			emitter.IsKey = iskey;
		}
		EndChildren(emitter);
	}

	private void StartChildren(Emitter emitter)
	{
		if (Style == MappingStyle.Block)
		{
			if (Children.Count == 0)
			{
				emitter.Write('{');
			}
		}
		else if (Style == MappingStyle.Flow)
		{
			emitter.Write('{');
		}
	}

	private void EndChildren(Emitter emitter)
	{
		if (Style == MappingStyle.Block)
		{
			if (Children.Count == 0)
			{
				emitter.Write('}');
			}

			emitter.WriteLine();
		}
		else if (Style == MappingStyle.Flow)
		{
			emitter.WriteClose('}');
		}
	}

	private void StartTransition(Emitter emitter, YamlNode next)
	{
		emitter.Write(':').WriteWhitespace();
		if (Style == MappingStyle.Block)
		{
			if (next.IsMultiline)
			{
				emitter.WriteLine();
			}
		}

		if (next.IsIndent)
		{
			emitter.IncreaseIndent();
		}
	}

	private void EndTransition(Emitter emitter, YamlNode next)
	{
		if (Style == MappingStyle.Block)
		{
			emitter.WriteLine();
		}
		else if (Style == MappingStyle.Flow)
		{
			emitter.WriteSeparator().WriteWhitespace();
		}

		if (next.IsIndent)
		{
			emitter.DecreaseIndent();
		}
	}

	private void InsertEnd(YamlNode key, YamlNode value)
	{
		ArgumentNullException.ThrowIfNull(value);

		KeyValuePair<YamlNode, YamlNode> pair = new(key, value);
		Children.Add(pair);
	}

	IEnumerator<KeyValuePair<YamlNode, YamlNode>> IEnumerable<KeyValuePair<YamlNode, YamlNode>>.GetEnumerator() => Children.GetEnumerator();

	IEnumerator IEnumerable.GetEnumerator() => Children.GetEnumerator();

	public static YamlMappingNode Empty { get; } = new YamlMappingNode(MappingStyle.Flow);

	public override YamlNodeType NodeType => YamlNodeType.Mapping;
	public override bool IsMultiline => Style == MappingStyle.Block && Children.Count > 0;
	public override bool IsIndent => Style == MappingStyle.Block;

	public MappingStyle Style { get; set; }

	public List<KeyValuePair<YamlNode, YamlNode>> Children { get; } = new();

	public override string ToString()
	{
		return $"Count = {Children.Count}";
	}
}

```

`Source/AssetRipper.Yaml/YAMLNode.cs`:

```cs
namespace AssetRipper.Yaml;

public abstract class YamlNode
{
	internal virtual void Emit(Emitter emitter)
	{
		bool isWrote = false;
		if (!CustomTag.IsEmpty)
		{
			emitter.Write(CustomTag.ToString()).WriteWhitespace();
			isWrote = true;
		}
		if (Anchor.Length > 0)
		{
			emitter.Write("&").Write(Anchor).WriteWhitespace();
			isWrote = true;
		}
		if (Stripped)
		{
			emitter.Write("stripped").WriteWhitespace();
			isWrote = true;
		}

		if (isWrote)
		{
			if (IsMultiline)
			{
				emitter.WriteLine();
			}
		}
	}

	public string EmitToString(bool formatKeys = false)
	{
		using StringWriter writer = new();
		Emitter emitter = new(writer, formatKeys);
		Emit(emitter);
		return writer.ToString();
	}

	public abstract YamlNodeType NodeType { get; }
	public abstract bool IsMultiline { get; }
	public abstract bool IsIndent { get; }

	public string Tag
	{
		get => CustomTag.Content;
		set => CustomTag = new YamlTag(YamlWriter.DefaultTagHandle, value);
	}
	public YamlTag CustomTag { get; set; }
	public string Anchor { get; set; } = string.Empty;
	public bool Stripped { get; set; }
}

```

`Source/AssetRipper.Yaml/YAMLNodeType.cs`:

```cs
namespace AssetRipper.Yaml;

public enum YamlNodeType
{
	/// <summary>
	/// The node is a <see cref="YamlMappingNode"/>.
	/// </summary>
	Mapping,

	/// <summary>
	/// The node is a <see cref="YamlScalarNode"/>.
	/// </summary>
	Scalar,

	/// <summary>
	/// The node is a <see cref="YamlSequenceNode"/>.
	/// </summary>
	Sequence
}

```

`Source/AssetRipper.Yaml/YAMLSequenceNode.cs`:

```cs
namespace AssetRipper.Yaml;

public sealed class YamlSequenceNode : YamlNode
{
	public YamlSequenceNode() { }

	public YamlSequenceNode(SequenceStyle style)
	{
		Style = style;
	}

	public void Add(bool value)
	{
		YamlScalarNode node = YamlScalarNode.Create(value);
		Add(node);
	}

	public void Add(byte value)
	{
		YamlScalarNode node = YamlScalarNode.Create(value);
		Add(node);
	}

	public void Add(short value)
	{
		YamlScalarNode node = YamlScalarNode.Create(value);
		Add(node);
	}

	public void Add(ushort value)
	{
		YamlScalarNode node = YamlScalarNode.Create(value);
		Add(node);
	}

	public void Add(int value)
	{
		YamlScalarNode node = YamlScalarNode.Create(value);
		Add(node);
	}

	public void Add(uint value)
	{
		YamlScalarNode node = YamlScalarNode.Create(value);
		Add(node);
	}

	public void Add(long value)
	{
		YamlScalarNode node = YamlScalarNode.Create(value);
		Add(node);
	}

	public void Add(ulong value)
	{
		YamlScalarNode node = YamlScalarNode.Create(value);
		Add(node);
	}

	public void Add(float value)
	{
		YamlScalarNode node = YamlScalarNode.Create(value);
		Add(node);
	}

	public void Add(double value)
	{
		YamlScalarNode node = YamlScalarNode.Create(value);
		Add(node);
	}

	public void Add(string value)
	{
		YamlScalarNode node = YamlScalarNode.Create(value);
		Add(node);
	}

	public void Add(YamlNode child)
	{
		Children.Add(child);
	}

	internal override void Emit(Emitter emitter)
	{
		base.Emit(emitter);

		StartChildren(emitter);
		for (int i = 0; i < Children.Count; i++)
		{
			YamlNode child = Children[i];
			StartChild(emitter, child);
			child.Emit(emitter);
			EndChild(emitter, child);
		}
		EndChildren(emitter);
	}

	private void StartChildren(Emitter emitter)
	{
		switch (Style)
		{
			case SequenceStyle.Block:
				if (Children.Count == 0)
				{
					emitter.Write('[');
				}

				break;

			case SequenceStyle.BlockCurve:
				if (Children.Count == 0)
				{
					emitter.Write('{');
				}

				break;

			case SequenceStyle.Flow:
				emitter.Write('[');
				break;
		}
	}

	private void EndChildren(Emitter emitter)
	{
		switch (Style)
		{
			case SequenceStyle.Block:
				if (Children.Count == 0)
				{
					emitter.Write(']');
				}

				emitter.WriteLine();
				break;

			case SequenceStyle.BlockCurve:
				if (Children.Count == 0)
				{
					emitter.WriteClose('}');
				}

				emitter.WriteLine();
				break;

			case SequenceStyle.Flow:
				emitter.WriteClose(']');
				break;
		}
	}

	private void StartChild(Emitter emitter, YamlNode next)
	{
		if (Style.IsAnyBlock())
		{
			emitter.Write('-').Write(' ');

			if (next.NodeType == NodeType)
			{
				emitter.IncreaseIndent();
			}
		}
		if (next.IsIndent)
		{
			emitter.IncreaseIndent();
		}
	}

	private void EndChild(Emitter emitter, YamlNode next)
	{
		if (Style.IsAnyBlock())
		{
			emitter.WriteLine();
			if (next.NodeType == NodeType)
			{
				emitter.DecreaseIndent();
			}
		}
		else if (Style == SequenceStyle.Flow)
		{
			emitter.WriteSeparator().WriteWhitespace();
		}

		if (next.IsIndent)
		{
			emitter.DecreaseIndent();
		}
	}

	public override YamlNodeType NodeType => YamlNodeType.Sequence;
	public override bool IsMultiline => Style.IsAnyBlock() && Children.Count > 0;
	public override bool IsIndent => false;

	public SequenceStyle Style { get; }

	public List<YamlNode> Children { get; } = new();

	public override string ToString()
	{
		return $"Count = {Children.Count}";
	}
}

```

`Source/AssetRipper.Yaml/YAMLTag.cs`:

```cs
namespace AssetRipper.Yaml;

public readonly struct YamlTag
{
	public YamlTag(string handle, string content)
	{
		Handle = handle;
		Content = content;
	}

	public override string ToString()
	{
		return IsEmpty ? string.Empty : $"{Handle}{Content}";
	}

	public string ToHeaderString()
	{
		return IsEmpty ? string.Empty : $"{Handle} {Content}";
	}

	public bool IsEmpty => string.IsNullOrEmpty(Handle);

	public string Handle { get; }
	public string Content { get; }
}

```

`Source/AssetRipper.Yaml/YAMLWriter.cs`:

```cs
namespace AssetRipper.Yaml;

public class YamlWriter
{
	public void AddDocument(YamlDocument document)
	{
#if DEBUG
		ArgumentNullException.ThrowIfNull(document);
		if (m_documents.Contains(document))
		{
			throw new ArgumentException($"Document {document} is added already", nameof(document));
		}
#endif
		m_documents.Add(document);
	}

	public void AddTag(string handle, string content)
	{
		if (m_tags.Any(t => t.Handle == handle))
		{
			throw new Exception($"Writer already contains tag {handle}");
		}

		YamlTag tag = new YamlTag(handle, content);
		m_tags.Add(tag);
	}

	public void Write(TextWriter output)
	{
		WriteHead(output);
		foreach (YamlDocument doc in m_documents)
		{
			WriteDocument(doc);
		}

		WriteTail(output);
	}

	public void WriteHead(TextWriter output)
	{
		m_emitter = new Emitter(output, IsFormatKeys);
		m_isWriteSeparator = false;

		if (IsWriteVersion)
		{
			m_emitter.WriteMeta(MetaType.Yaml, Version.ToString());
			m_isWriteSeparator = true;
		}

		if (IsWriteDefaultTag)
		{
			m_emitter.WriteMeta(MetaType.Tag, DefaultTag.ToHeaderString());
			m_isWriteSeparator = true;
		}
		foreach (YamlTag tag in m_tags)
		{
			m_emitter.WriteMeta(MetaType.Tag, tag.ToHeaderString());
			m_isWriteSeparator = true;
		}
	}

	public void WriteDocument(YamlDocument doc)
	{
		ThrowIfNullEmitter();
		doc.Emit(m_emitter, m_isWriteSeparator);
		m_isWriteSeparator = true;
	}

	public void WriteTail(TextWriter output)
	{
		output.Write('\n');
	}

	[MemberNotNull(nameof(m_emitter))]
	private void ThrowIfNullEmitter()
	{
		if (m_emitter is null)
		{
			throw new NullReferenceException("Emitter cannot be null");
		}
	}

	public static Version Version { get; } = new Version(1, 1);

	public const string DefaultTagHandle = "!u!";
	public const string DefaultTagContent = "tag:unity3d.com,2011:";

	public readonly YamlTag DefaultTag = new YamlTag(DefaultTagHandle, DefaultTagContent);

	public bool IsWriteVersion { get; set; } = true;
	public bool IsWriteDefaultTag { get; set; } = true;
	public bool IsFormatKeys { get; set; }

	private readonly HashSet<YamlDocument> m_documents = [];
	private readonly List<YamlTag> m_tags = [];

	private Emitter? m_emitter;
	private bool m_isWriteSeparator;
}

```

`Source/AssetRipper.Yaml/YamlEscaping.cs`:

```cs
using System.Numerics;
using System.Text;

namespace AssetRipper.Yaml;

internal static class YamlEscaping
{
	//https://yaml.org/spec/1.1/current.html#escaping%20in%20double-quoted%20style/

	[return: NotNullIfNotNull(nameof(value))]
	public static string? Escape(string? value)
	{
		if (value is null)
		{
			return null;
		}

		if (value.Length == 0)
		{
			return "";
		}

		int index = IndexOfFirstCharacterToEscape(value);
		if (index < 0)
		{
			return value;
		}

		ReadOnlySpan<char> span = value;

		StringBuilder sb = new((int)BitOperations.RoundUpToPowerOf2((uint)value.Length));
		sb.Append(span[..index]);
		foreach (char c in span[index..])
		{
			WriteCharacter(sb, c);
		}
		return sb.ToString();
	}

	public static bool TryEscape(char c, [NotNullWhen(true)] out string? escapeSequence)
	{
		if (NeedsEscaped(c))
		{
			escapeSequence = c switch
			{
				'\\' => "\\\\",
				'"' => "\\\"",
				'\n' => "\\n",
				'\r' => "\\r",
				'\t' => "\\t",
				_ => EscapeAsHex(c),
			};
			return true;
		}
		else
		{
			escapeSequence = null;
			return false;
		}
	}

	private static void WriteCharacter(StringBuilder sb, char c)
	{
		if (NeedsEscaped(c))
		{
			switch (c)
			{
				case '\\':
					sb.Append('\\').Append('\\');
					break;
				case '"':
					sb.Append('\\').Append('"');
					break;
				case '\n':
					sb.Append('\\').Append('n');
					break;
				case '\r':
					sb.Append('\\').Append('r');
					break;
				case '\t':
					sb.Append('\\').Append('t');
					break;
				default:
					WriteEscapedAsHex(sb, c);
					break;
			}
		}
		else
		{
			sb.Append(c);
		}
	}

	public static int IndexOfFirstCharacterToEscape(ReadOnlySpan<char> span)
	{
		for (int i = 0; i < span.Length; i++)
		{
			if (NeedsEscaped(span[i]))
			{
				return i;
			}
		}
		return -1;
	}

	private static bool NeedsEscaped(char c)
	{
		//A large portion of Unicode does not need escaping, but it's simpler to escape all non-ascii characters.
		//https://en.wikipedia.org/wiki/ASCII
		return c is not (>= (char)0x20 and <= (char)0x7E) or '"' or '\\';
	}

	private static string EscapeAsHex(char c)
	{
		const string HexCharacters = "0123456789ABCDEF";
		ushort value = c;

		if (value > byte.MaxValue)
		{
			//Format as \uXXXX
			return $"\\u{HexCharacters[(value & 0xF000) >> 12]}{HexCharacters[(value & 0xF00) >> 8]}{HexCharacters[(value & 0xF0) >> 4]}{HexCharacters[value & 0xF]}";
		}
		else
		{
			//Format as \xXX
			return $"\\x{HexCharacters[(value & 0xF0) >> 4]}{HexCharacters[value & 0xF]}";
		}
	}

	private static void WriteEscapedAsHex(StringBuilder sb, char c)
	{
		const string HexCharacters = "0123456789ABCDEF";
		ushort value = c;

		if (value > byte.MaxValue)
		{
			//Format as \uXXXX
			ReadOnlySpan<char> span =
				[
					'\\',
					'u',
					HexCharacters[(value & 0xF000) >> 12],
					HexCharacters[(value & 0xF00) >> 8],
					HexCharacters[(value & 0xF0) >> 4],
					HexCharacters[value & 0xF],
				];
			sb.Append(span);
		}
		else
		{
			//Format as \xXX
			ReadOnlySpan<char> span =
				[
					'\\',
					'x',
					HexCharacters[(value & 0xF0) >> 4],
					HexCharacters[value & 0xF],
				];
			sb.Append(span);
		}
	}
}

```

`Source/AssetRipper.Yaml/YamlScalarNode.Base.cs`:

```cs
namespace AssetRipper.Yaml;

public abstract partial class YamlScalarNode : YamlNode
{
	public sealed override bool IsMultiline => false;
	public sealed override bool IsIndent => false;
	public sealed override YamlNodeType NodeType => YamlNodeType.Scalar;
	public virtual ScalarStyle Style => ScalarStyle.Plain;
	public abstract string Value { get; }

	private YamlScalarNode()
	{
	}

	private protected abstract void EmitCore(Emitter emitter);

	internal sealed override void Emit(Emitter emitter)
	{
		base.Emit(emitter);

		switch (Style)
		{
			case ScalarStyle.Plain:
				EmitCore(emitter);
				break;

			case ScalarStyle.SingleQuoted:
				emitter.Write('\'');
				EmitCore(emitter);
				emitter.Write('\'');
				break;

			case ScalarStyle.DoubleQuoted:
				emitter.Write('"');
				EmitCore(emitter);
				emitter.Write('"');
				break;

			default:
				throw new Exception($"Unsupported scalar style {Style}");
		}
	}


	public sealed override string ToString() => Value;
}

```

`Source/AssetRipper.Yaml/YamlScalarNode.BoolListNode.cs`:

```cs
using AssetRipper.Yaml.Extensions;

namespace AssetRipper.Yaml;

public abstract partial class YamlScalarNode
{
	private sealed class BoolListNode(IReadOnlyList<bool> list) : YamlScalarNode
	{
		private protected override void EmitCore(Emitter emitter)
		{
			Span<char> buffer = stackalloc char[ReverseHexString.GetHexStringLength<byte>()];
			for (int i = 0; i < list.Count; i++)
			{
				byte b = list[i] ? (byte)1 : (byte)0;
				ReverseHexString.WriteReverseHexString(b, buffer);
				emitter.Write(buffer);
			}
		}

		public override string Value => list.ToString() ?? "";
	}
}

```

`Source/AssetRipper.Yaml/YamlScalarNode.BooleanNode.cs`:

```cs
namespace AssetRipper.Yaml;

public abstract partial class YamlScalarNode
{
	private sealed class BooleanNode(bool value) : YamlScalarNode
	{
		private protected override void EmitCore(Emitter emitter)
		{
			emitter.Write(value ? 1 : 0);
		}

		public override string Value => value ? "true" : "false";
	}
}

```

`Source/AssetRipper.Yaml/YamlScalarNode.CharListNode.cs`:

```cs
using AssetRipper.Yaml.Extensions;

namespace AssetRipper.Yaml;

public abstract partial class YamlScalarNode
{
	private sealed class CharListNode(IReadOnlyList<char> list) : YamlScalarNode
	{
		private protected override void EmitCore(Emitter emitter)
		{
			Span<char> buffer = stackalloc char[ReverseHexString.GetHexStringLength<ushort>()];
			for (int i = 0; i < list.Count; i++)
			{
				ReverseHexString.WriteReverseHexString((ushort)list[i], buffer);
				emitter.Write(buffer);
			}
		}

		public override string Value => list.ToString() ?? "";
	}
}

```

`Source/AssetRipper.Yaml/YamlScalarNode.Creation.cs`:

```cs
using AssetRipper.Primitives;
using System.Numerics;

namespace AssetRipper.Yaml;

public abstract partial class YamlScalarNode
{
	public static YamlScalarNode Create<T>(T value) where T : unmanaged, INumber<T>, IConvertible
	{
		return new NumericNode<T>(value);
	}

	public static YamlScalarNode CreateHex<T>(IReadOnlyList<T> list) where T : unmanaged, INumber<T>
	{
		return new NumericListNode<T>(list);
	}

	public static YamlScalarNode CreateHex(IReadOnlyList<bool> list) => new BoolListNode(list);

	public static YamlScalarNode CreateHex(IReadOnlyList<char> list) => new CharListNode(list);

	public static YamlScalarNode CreateHex<T>(T value) where T : IBinaryFloatingPointIeee754<T>
	{
		return new FloatingPointHexNode<T>(value);
	}

	public static YamlScalarNode Create(bool value) => new BooleanNode(value);

	public static YamlScalarNode Create(string value) => new StringNode(value);

	public static YamlScalarNode Create(Utf8String value) => new StringNode(value.String);

	internal static YamlScalarNode CreatePlain(string value) => new StringNode(value, ScalarStyle.Plain);
}

```

`Source/AssetRipper.Yaml/YamlScalarNode.FloatingPointHexNode.cs`:

```cs
using System.Globalization;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace AssetRipper.Yaml;

public abstract partial class YamlScalarNode
{
	/// <summary>
	/// Hexidecimal representation of a floating point number. <see href="https://docs.unity3d.com/2022.3/Documentation/Manual/FormatDescription.html"/>
	/// </summary>
	/// <remarks>
	/// This is the only lossless way to represent a floating point number in YAML.
	/// However, the output is less readable than the default representation.
	/// </remarks>
	/// <typeparam name="T">The floating point type.</typeparam>
	/// <param name="value"></param>
	private sealed class FloatingPointHexNode<T>(T value) : YamlScalarNode where T : IBinaryFloatingPointIeee754<T>
	{
		private protected override void EmitCore(Emitter emitter)
		{
			emitter.Write(Value);
		}

		public override string Value
		{
			get
			{
				if (typeof(T) == typeof(float))
				{
					float single = Unsafe.As<T, float>(ref value);
					uint hex = BitConverter.SingleToUInt32Bits(single);
					return $"0x{hex:x8}({single.ToString(CultureInfo.InvariantCulture)})";
				}
				else if (typeof(T) == typeof(double))
				{
					double single = Unsafe.As<T, double>(ref value);
					ulong hex = BitConverter.DoubleToUInt64Bits(single);
					return $"0x{hex:x16}({single.ToString(CultureInfo.InvariantCulture)})";
				}
				else
				{
					// This can't happen
					return value.ToString() ?? "";
				}
			}
		}
	}
}

```

`Source/AssetRipper.Yaml/YamlScalarNode.NumericListNode.cs`:

```cs
using AssetRipper.Yaml.Extensions;
using System.Numerics;

namespace AssetRipper.Yaml;

public abstract partial class YamlScalarNode
{
	private sealed class NumericListNode<T>(IReadOnlyList<T> list) : YamlScalarNode where T : unmanaged, INumber<T>
	{
		private protected override void EmitCore(Emitter emitter)
		{
			Span<char> buffer = stackalloc char[ReverseHexString.GetHexStringLength<T>()];
			for (int i = 0; i < list.Count; i++)
			{
				ReverseHexString.WriteReverseHexString(list[i], buffer);
				emitter.Write(buffer);
			}
		}

		public override string Value
		{
			get
			{
				StringWriter sb = new();
				Span<char> buffer = stackalloc char[ReverseHexString.GetHexStringLength<T>()];
				for (int i = 0; i < list.Count; i++)
				{
					ReverseHexString.WriteReverseHexString(list[i], buffer);
					sb.Write(buffer);
				}
				return sb.ToString();
			}
		}
	}
}

```

`Source/AssetRipper.Yaml/YamlScalarNode.NumericNode.cs`:

```cs
using System.Globalization;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace AssetRipper.Yaml;

public abstract partial class YamlScalarNode
{
	private sealed class NumericNode<T>(T value) : YamlScalarNode where T : struct, INumber<T>, IConvertible
	{
		private protected override void EmitCore(Emitter emitter)
		{
			if (typeof(T) == typeof(float))
			{
				emitter.Write(Unsafe.As<T, float>(ref value));
			}
			else if (typeof(T) == typeof(double))
			{
				emitter.Write(Unsafe.As<T, double>(ref value));
			}
			else if (IsSigned)
			{
				emitter.Write(value.ToInt64(CultureInfo.InvariantCulture));
			}
			else
			{
				emitter.Write(value.ToUInt64(CultureInfo.InvariantCulture));
			}
		}

		public override string Value => value.ToString() ?? "";

		private static bool IsSigned => typeof(T) == typeof(sbyte) || typeof(T) == typeof(short) || typeof(T) == typeof(int) || typeof(T) == typeof(long);
	}
}

```

`Source/AssetRipper.Yaml/YamlScalarNode.StringNode.cs`:

```cs
using System.Text.RegularExpressions;

namespace AssetRipper.Yaml;

public abstract partial class YamlScalarNode
{
	private sealed partial class StringNode : YamlScalarNode
	{
		public StringNode(string value)
		{
			Value = value;
			Style = GetStringStyle(value);
		}

		public StringNode(string value, ScalarStyle style)
		{
			Value = value;
			Style = style;
		}

		private protected override void EmitCore(Emitter emitter)
		{
			WriteString(emitter);
		}

		public override string Value { get; }
		public override ScalarStyle Style { get; }

		private void WriteString(Emitter emitter)
		{
			switch (Style)
			{
				case ScalarStyle.Plain:
					if (emitter.IsFormatKeys && emitter.IsKey)
					{
						emitter.WriteFormat(Value);
					}
					else
					{
						emitter.Write(Value);
					}
					break;
				case ScalarStyle.SingleQuoted:
					{
						emitter.WriteDelayed();
						for (int i = 0; i < Value.Length; i++)
						{
							char c = Value[i];
							emitter.WriteRaw(c);
							switch (c)
							{
								case '\'':
									emitter.WriteRaw(c);
									break;
								case '\n':
									emitter.WriteRaw("\n	");
									break;
							}
						}

						break;
					}

				case ScalarStyle.DoubleQuoted:
					{
						emitter.WriteDelayed();
						for (int i = 0; i < Value.Length; i++)
						{
							char c = Value[i];
							switch (c)
							{
								case '\\':
									emitter.WriteRaw('\\').WriteRaw('\\');
									break;
								case '\n':
									emitter.WriteRaw('\\').WriteRaw('n');
									break;
								case '\r':
									emitter.WriteRaw('\\').WriteRaw('r');
									break;
								case '\t':
									emitter.WriteRaw('\\').WriteRaw('t');
									break;
								case '"':
									emitter.WriteRaw('\\').WriteRaw('"');
									break;

								default:
									if (char.IsControl(c))
									{
										emitter.WriteRawUnicode(c);
									}
									else
									{
										emitter.WriteRaw(c);
									}
									break;
							}
						}

						break;
					}

				default:
					throw new NotSupportedException(Style.ToString());
			}
		}

		private static ScalarStyle GetStringStyle(string value)
		{
			if (string.IsNullOrEmpty(value))
			{
				return ScalarStyle.Plain;
			}
			else if (ContainsControlCharacter(value))
			{
				return ScalarStyle.DoubleQuoted;
			}
			else if (IllegalStringsRegex().IsMatch(value))
			{
				return value.Contains("\n ") ? ScalarStyle.DoubleQuoted : ScalarStyle.SingleQuoted;
			}

			return ScalarStyle.Plain;
		}

		private static bool ContainsControlCharacter(ReadOnlySpan<char> span)
		{
			foreach (char c in span)
			{
				if (char.IsControl(c))
				{
					return true;
				}
			}
			return false;
		}

		[GeneratedRegex("""(^\s)|(^-\s)|(^-$)|(^[\:\[\]'"*&!@#%{}?<>,\`])|([:@]\s)|([\n\r])|([:\s]$)""", RegexOptions.Compiled)]
		private static partial Regex IllegalStringsRegex();
	}
}

```

`Source/Directory.Build.props`:

```props
<Project>
	<PropertyGroup>
		<TargetFramework>net10.0</TargetFramework>
		<Nullable>enable</Nullable>
		<LangVersion>preview</LangVersion>
		<IsAotCompatible>true</IsAotCompatible>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>

		<VersionPrefix>1.3.10</VersionPrefix>
		<Copyright>Copyright © ds5678</Copyright>
		<Authors>ds5678</Authors>
	</PropertyGroup>

	<ItemGroup>
		<Using Include="System" />
		<Using Include="System.Collections.Generic" />
		<Using Include="System.Diagnostics.CodeAnalysis" />
		<Using Include="System.IO" />
		<Using Include="System.Linq" />
		<Using Include="System.Threading" />
		<Using Include="System.Threading.Tasks" />
	</ItemGroup>
</Project>

```

`Source/Licenses/AsmResolver.md`:

```md
The MIT License (MIT)
=====================

Copyright © `2016-2021 Washi`

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the “Software”), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
```

`Source/Licenses/AssetStudio.md`:

```md
MIT License

Copyright (c) 2016 Radu
Copyright (c) 2016-2020 Perfare

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Source/Licenses/Cpp2IL.md`:

```md
MIT License

Copyright (c) 2020 Sam Byass

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Source/Licenses/Crunch.md`:

```md
Original crunch/crnlib source code
crunch/crnlib uses the ZLIB license:
http://opensource.org/licenses/Zlib

Copyright (c) 2010-2016 Richard Geldreich, Jr. and Binomial LLC

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.

Further crunch/crnlib modifications
MIT License

Copyright (c) 2019 Perfare

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Source/Licenses/Fmod5Sharp.md`:

```md
MIT License

Copyright (c) 2021 Sam Byass

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Source/Licenses/ILSpy.md`:

```md
MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Source/Licenses/Lz4.md`:

```md
MIT License

Copyright (c) 2017 Milosz Krajewski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Source/Licenses/Moq.md`:

```md
BSD-3-Clause

Copyright (c) 2007, Clarius Consulting, Manas Technology Solutions, InSTEDD,
and Contributors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

    * Neither the names of the copyright holders nor the names of its
    contributors may be used to endorse or promote products derived from this
    software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`Source/Licenses/NAudio.md`:

```md
Copyright 2020 Mark Heath

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


```

`Source/Licenses/NAudioVorbis.md`:

```md
MIT License

Copyright (c) 2021 Andrew Ward

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Source/Licenses/NUnit.md`:

```md
Copyright (c) 2024 Charlie Poole, Rob Prouse

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


```

`Source/Licenses/NVorbis.md`:

```md
MIT License

Copyright (c) 2020 Andrew Ward

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Source/Licenses/SharpCompress.md`:

```md
The MIT License (MIT)

Copyright (c) 2014  Adam Hathcock

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
```

`Source/Licenses/SharpGLTF.md`:

```md
MIT License

Copyright (c) 2019 Vicente Penades

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Source/Licenses/Smolv.md`:

```md
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2016-2018 Aras Pranckevicius
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
```

`Source/Licenses/SourceGenerator.Foundations.md`:

```md
MIT License

Copyright (c) 2024 Byron Mayne

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Source/Licenses/SpirV.md`:

```md
BSD 2-Clause License

Copyright (c) 2017, Matthäus G. Chajdas
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`Source/Licenses/Texture2DDecoder.md`:

```md
MIT License

Copyright (c) 2016 Radu
Copyright (c) 2016-2020 Perfare
Copyright (c) 2022 Kiruya Momochi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Source/Licenses/darkfx.md`:

```md
MIT License

Copyright (c) 2021 Steffen Wilke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Source/Licenses/oqo0.SwaggerThemes.md`:

```md
MIT License

Copyright (c) [year] [fullname]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Source/Licenses/uTinyRipper.md`:

```md
MIT License

Copyright (c) 2020 mafaca

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Source/Licenses/uTinyRipperExporter.md`:

```md
MIT License

Copyright (c) 2018 spacehamster

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Source/Smolv/OpData.cs`:

```cs
namespace Smolv;

/// <summary>
/// Data for each <see cref="SpvOp"/> instruction.
/// </summary>
/// <param name="HasResult">Does it have result ID?</param>
/// <param name="HasType">Does it have type ID?</param>
/// <param name="DeltaFromResult">How many words after (optional) type+result to write out as deltas from result?</param>
/// <param name="VarRest">Should the rest of words be written in varint encoding?</param>
public readonly record struct OpData(byte HasResult, byte HasType, sbyte DeltaFromResult, byte VarRest)
{
	public static OpData Get(SpvOp op)
	{
		return SpirvOpData[(int)op];
	}

	private static readonly OpData[] SpirvOpData =
	[
		new OpData(0, 0, 0, 0), // Nop
		new OpData(1, 1, 0, 0), // Undef
		new OpData(0, 0, 0, 0), // SourceContinued
		new OpData(0, 0, 0, 1), // Source
		new OpData(0, 0, 0, 0), // SourceExtension
		new OpData(0, 0, 0, 0), // Name
		new OpData(0, 0, 0, 0), // MemberName
		new OpData(0, 0, 0, 0), // String
		new OpData(0, 0, 0, 1), // Line
		new OpData(1, 1, 0, 0), // #9
		new OpData(0, 0, 0, 0), // Extension
		new OpData(1, 0, 0, 0), // ExtInstImport
		new OpData(1, 1, 0, 1), // ExtInst
		new OpData(1, 1, 2, 1), // VectorShuffleCompact - new in SMOLV
		new OpData(0, 0, 0, 1), // MemoryModel
		new OpData(0, 0, 0, 1), // EntryPoint
		new OpData(0, 0, 0, 1), // ExecutionMode
		new OpData(0, 0, 0, 1), // Capability
		new OpData(1, 1, 0, 0), // #18
		new OpData(1, 0, 0, 1), // TypeVoid
		new OpData(1, 0, 0, 1), // TypeBool
		new OpData(1, 0, 0, 1), // TypeInt
		new OpData(1, 0, 0, 1), // TypeFloat
		new OpData(1, 0, 0, 1), // TypeVector
		new OpData(1, 0, 0, 1), // TypeMatrix
		new OpData(1, 0, 0, 1), // TypeImage
		new OpData(1, 0, 0, 1), // TypeSampler
		new OpData(1, 0, 0, 1), // TypeSampledImage
		new OpData(1, 0, 0, 1), // TypeArray
		new OpData(1, 0, 0, 1), // TypeRuntimeArray
		new OpData(1, 0, 0, 1), // TypeStruct
		new OpData(1, 0, 0, 1), // TypeOpaque
		new OpData(1, 0, 0, 1), // TypePointer
		new OpData(1, 0, 0, 1), // TypeFunction
		new OpData(1, 0, 0, 1), // TypeEvent
		new OpData(1, 0, 0, 1), // TypeDeviceEvent
		new OpData(1, 0, 0, 1), // TypeReserveId
		new OpData(1, 0, 0, 1), // TypeQueue
		new OpData(1, 0, 0, 1), // TypePipe
		new OpData(0, 0, 0, 1), // TypeForwardPointer
		new OpData(1, 1, 0, 0), // #40
		new OpData(1, 1, 0, 0), // ConstantTrue
		new OpData(1, 1, 0, 0), // ConstantFalse
		new OpData(1, 1, 0, 0), // Constant
		new OpData(1, 1, 9, 0), // ConstantComposite
		new OpData(1, 1, 0, 1), // ConstantSampler
		new OpData(1, 1, 0, 0), // ConstantNull
		new OpData(1, 1, 0, 0), // #47
		new OpData(1, 1, 0, 0), // SpecConstantTrue
		new OpData(1, 1, 0, 0), // SpecConstantFalse
		new OpData(1, 1, 0, 0), // SpecConstant
		new OpData(1, 1, 9, 0), // SpecConstantComposite
		new OpData(1, 1, 0, 0), // SpecConstantOp
		new OpData(1, 1, 0, 0), // #53
		new OpData(1, 1, 0, 1), // Function
		new OpData(1, 1, 0, 0), // FunctionParameter
		new OpData(0, 0, 0, 0), // FunctionEnd
		new OpData(1, 1, 9, 0), // FunctionCall
		new OpData(1, 1, 0, 0), // #58
		new OpData(1, 1, 0, 1), // Variable
		new OpData(1, 1, 0, 0), // ImageTexelPointer
		new OpData(1, 1, 1, 1), // Load
		new OpData(0, 0, 2, 1), // Store
		new OpData(0, 0, 0, 0), // CopyMemory
		new OpData(0, 0, 0, 0), // CopyMemorySized
		new OpData(1, 1, 0, 1), // AccessChain
		new OpData(1, 1, 0, 0), // InBoundsAccessChain
		new OpData(1, 1, 0, 0), // PtrAccessChain
		new OpData(1, 1, 0, 0), // ArrayLength
		new OpData(1, 1, 0, 0), // GenericPtrMemSemantics
		new OpData(1, 1, 0, 0), // InBoundsPtrAccessChain
		new OpData(0, 0, 0, 1), // Decorate
		new OpData(0, 0, 0, 1), // MemberDecorate
		new OpData(1, 0, 0, 0), // DecorationGroup
		new OpData(0, 0, 0, 0), // GroupDecorate
		new OpData(0, 0, 0, 0), // GroupMemberDecorate
		new OpData(1, 1, 0, 0), // #76
		new OpData(1, 1, 1, 1), // VectorExtractDynamic
		new OpData(1, 1, 2, 1), // VectorInsertDynamic
		new OpData(1, 1, 2, 1), // VectorShuffle
		new OpData(1, 1, 9, 0), // CompositeConstruct
		new OpData(1, 1, 1, 1), // CompositeExtract
		new OpData(1, 1, 2, 1), // CompositeInsert
		new OpData(1, 1, 1, 0), // CopyObject
		new OpData(1, 1, 0, 0), // Transpose
		new OpData(1, 1, 0, 0), // #85
		new OpData(1, 1, 0, 0), // SampledImage
		new OpData(1, 1, 2, 1), // ImageSampleImplicitLod
		new OpData(1, 1, 2, 1), // ImageSampleExplicitLod
		new OpData(1, 1, 3, 1), // ImageSampleDrefImplicitLod
		new OpData(1, 1, 3, 1), // ImageSampleDrefExplicitLod
		new OpData(1, 1, 2, 1), // ImageSampleProjImplicitLod
		new OpData(1, 1, 2, 1), // ImageSampleProjExplicitLod
		new OpData(1, 1, 3, 1), // ImageSampleProjDrefImplicitLod
		new OpData(1, 1, 3, 1), // ImageSampleProjDrefExplicitLod
		new OpData(1, 1, 2, 1), // ImageFetch
		new OpData(1, 1, 3, 1), // ImageGather
		new OpData(1, 1, 3, 1), // ImageDrefGather
		new OpData(1, 1, 2, 1), // ImageRead
		new OpData(0, 0, 3, 1), // ImageWrite
		new OpData(1, 1, 1, 0), // Image
		new OpData(1, 1, 1, 0), // ImageQueryFormat
		new OpData(1, 1, 1, 0), // ImageQueryOrder
		new OpData(1, 1, 2, 0), // ImageQuerySizeLod
		new OpData(1, 1, 1, 0), // ImageQuerySize
		new OpData(1, 1, 2, 0), // ImageQueryLod
		new OpData(1, 1, 1, 0), // ImageQueryLevels
		new OpData(1, 1, 1, 0), // ImageQuerySamples
		new OpData(1, 1, 0, 0), // #108
		new OpData(1, 1, 1, 0), // ConvertFToU
		new OpData(1, 1, 1, 0), // ConvertFToS
		new OpData(1, 1, 1, 0), // ConvertSToF
		new OpData(1, 1, 1, 0), // ConvertUToF
		new OpData(1, 1, 1, 0), // UConvert
		new OpData(1, 1, 1, 0), // SConvert
		new OpData(1, 1, 1, 0), // FConvert
		new OpData(1, 1, 1, 0), // QuantizeToF16
		new OpData(1, 1, 1, 0), // ConvertPtrToU
		new OpData(1, 1, 1, 0), // SatConvertSToU
		new OpData(1, 1, 1, 0), // SatConvertUToS
		new OpData(1, 1, 1, 0), // ConvertUToPtr
		new OpData(1, 1, 1, 0), // PtrCastToGeneric
		new OpData(1, 1, 1, 0), // GenericCastToPtr
		new OpData(1, 1, 1, 1), // GenericCastToPtrExplicit
		new OpData(1, 1, 1, 0), // Bitcast
		new OpData(1, 1, 0, 0), // #125
		new OpData(1, 1, 1, 0), // SNegate
		new OpData(1, 1, 1, 0), // FNegate
		new OpData(1, 1, 2, 0), // IAdd
		new OpData(1, 1, 2, 0), // FAdd
		new OpData(1, 1, 2, 0), // ISub
		new OpData(1, 1, 2, 0), // FSub
		new OpData(1, 1, 2, 0), // IMul
		new OpData(1, 1, 2, 0), // FMul
		new OpData(1, 1, 2, 0), // UDiv
		new OpData(1, 1, 2, 0), // SDiv
		new OpData(1, 1, 2, 0), // FDiv
		new OpData(1, 1, 2, 0), // UMod
		new OpData(1, 1, 2, 0), // SRem
		new OpData(1, 1, 2, 0), // SMod
		new OpData(1, 1, 2, 0), // FRem
		new OpData(1, 1, 2, 0), // FMod
		new OpData(1, 1, 2, 0), // VectorTimesScalar
		new OpData(1, 1, 2, 0), // MatrixTimesScalar
		new OpData(1, 1, 2, 0), // VectorTimesMatrix
		new OpData(1, 1, 2, 0), // MatrixTimesVector
		new OpData(1, 1, 2, 0), // MatrixTimesMatrix
		new OpData(1, 1, 2, 0), // OuterProduct
		new OpData(1, 1, 2, 0), // Dot
		new OpData(1, 1, 2, 0), // IAddCarry
		new OpData(1, 1, 2, 0), // ISubBorrow
		new OpData(1, 1, 2, 0), // UMulExtended
		new OpData(1, 1, 2, 0), // SMulExtended
		new OpData(1, 1, 0, 0), // #153
		new OpData(1, 1, 1, 0), // Any
		new OpData(1, 1, 1, 0), // All
		new OpData(1, 1, 1, 0), // IsNan
		new OpData(1, 1, 1, 0), // IsInf
		new OpData(1, 1, 1, 0), // IsFinite
		new OpData(1, 1, 1, 0), // IsNormal
		new OpData(1, 1, 1, 0), // SignBitSet
		new OpData(1, 1, 2, 0), // LessOrGreater
		new OpData(1, 1, 2, 0), // Ordered
		new OpData(1, 1, 2, 0), // Unordered
		new OpData(1, 1, 2, 0), // LogicalEqual
		new OpData(1, 1, 2, 0), // LogicalNotEqual
		new OpData(1, 1, 2, 0), // LogicalOr
		new OpData(1, 1, 2, 0), // LogicalAnd
		new OpData(1, 1, 1, 0), // LogicalNot
		new OpData(1, 1, 3, 0), // Select
		new OpData(1, 1, 2, 0), // IEqual
		new OpData(1, 1, 2, 0), // INotEqual
		new OpData(1, 1, 2, 0), // UGreaterThan
		new OpData(1, 1, 2, 0), // SGreaterThan
		new OpData(1, 1, 2, 0), // UGreaterThanEqual
		new OpData(1, 1, 2, 0), // SGreaterThanEqual
		new OpData(1, 1, 2, 0), // ULessThan
		new OpData(1, 1, 2, 0), // SLessThan
		new OpData(1, 1, 2, 0), // ULessThanEqual
		new OpData(1, 1, 2, 0), // SLessThanEqual
		new OpData(1, 1, 2, 0), // FOrdEqual
		new OpData(1, 1, 2, 0), // FUnordEqual
		new OpData(1, 1, 2, 0), // FOrdNotEqual
		new OpData(1, 1, 2, 0), // FUnordNotEqual
		new OpData(1, 1, 2, 0), // FOrdLessThan
		new OpData(1, 1, 2, 0), // FUnordLessThan
		new OpData(1, 1, 2, 0), // FOrdGreaterThan
		new OpData(1, 1, 2, 0), // FUnordGreaterThan
		new OpData(1, 1, 2, 0), // FOrdLessThanEqual
		new OpData(1, 1, 2, 0), // FUnordLessThanEqual
		new OpData(1, 1, 2, 0), // FOrdGreaterThanEqual
		new OpData(1, 1, 2, 0), // FUnordGreaterThanEqual
		new OpData(1, 1, 0, 0), // #192
		new OpData(1, 1, 0, 0), // #193
		new OpData(1, 1, 2, 0), // ShiftRightLogical
		new OpData(1, 1, 2, 0), // ShiftRightArithmetic
		new OpData(1, 1, 2, 0), // ShiftLeftLogical
		new OpData(1, 1, 2, 0), // BitwiseOr
		new OpData(1, 1, 2, 0), // BitwiseXor
		new OpData(1, 1, 2, 0), // BitwiseAnd
		new OpData(1, 1, 1, 0), // Not
		new OpData(1, 1, 4, 0), // BitFieldInsert
		new OpData(1, 1, 3, 0), // BitFieldSExtract
		new OpData(1, 1, 3, 0), // BitFieldUExtract
		new OpData(1, 1, 1, 0), // BitReverse
		new OpData(1, 1, 1, 0), // BitCount
		new OpData(1, 1, 0, 0), // #206
		new OpData(1, 1, 0, 0), // DPdx
		new OpData(1, 1, 0, 0), // DPdy
		new OpData(1, 1, 0, 0), // Fwidth
		new OpData(1, 1, 0, 0), // DPdxFine
		new OpData(1, 1, 0, 0), // DPdyFine
		new OpData(1, 1, 0, 0), // FwidthFine
		new OpData(1, 1, 0, 0), // DPdxCoarse
		new OpData(1, 1, 0, 0), // DPdyCoarse
		new OpData(1, 1, 0, 0), // FwidthCoarse
		new OpData(1, 1, 0, 0), // #216
		new OpData(1, 1, 0, 0), // #217
		new OpData(0, 0, 0, 0), // EmitVertex
		new OpData(0, 0, 0, 0), // EndPrimitive
		new OpData(0, 0, 0, 0), // EmitStreamVertex
		new OpData(0, 0, 0, 0), // EndStreamPrimitive
		new OpData(1, 1, 0, 0), // #222
		new OpData(1, 1, 0, 0), // #223
		new OpData(0, 0, -3, 0), // ControlBarrier
		new OpData(0, 0, -2, 0), // MemoryBarrier
		new OpData(1, 1, 0, 0), // #226
		new OpData(1, 1, 0, 0), // AtomicLoad
		new OpData(0, 0, 0, 0), // AtomicStore
		new OpData(1, 1, 0, 0), // AtomicExchange
		new OpData(1, 1, 0, 0), // AtomicCompareExchange
		new OpData(1, 1, 0, 0), // AtomicCompareExchangeWeak
		new OpData(1, 1, 0, 0), // AtomicIIncrement
		new OpData(1, 1, 0, 0), // AtomicIDecrement
		new OpData(1, 1, 0, 0), // AtomicIAdd
		new OpData(1, 1, 0, 0), // AtomicISub
		new OpData(1, 1, 0, 0), // AtomicSMin
		new OpData(1, 1, 0, 0), // AtomicUMin
		new OpData(1, 1, 0, 0), // AtomicSMax
		new OpData(1, 1, 0, 0), // AtomicUMax
		new OpData(1, 1, 0, 0), // AtomicAnd
		new OpData(1, 1, 0, 0), // AtomicOr
		new OpData(1, 1, 0, 0), // AtomicXor
		new OpData(1, 1, 0, 0), // #243
		new OpData(1, 1, 0, 0), // #244
		new OpData(1, 1, 0, 0), // Phi
		new OpData(0, 0, -2, 1), // LoopMerge
		new OpData(0, 0, -1, 1), // SelectionMerge
		new OpData(1, 0, 0, 0), // Label
		new OpData(0, 0, -1, 0), // Branch
		new OpData(0, 0, -3, 1), // BranchConditional
		new OpData(0, 0, 0, 0), // Switch
		new OpData(0, 0, 0, 0), // Kill
		new OpData(0, 0, 0, 0), // Return
		new OpData(0, 0, 0, 0), // ReturnValue
		new OpData(0, 0, 0, 0), // Unreachable
		new OpData(0, 0, 0, 0), // LifetimeStart
		new OpData(0, 0, 0, 0), // LifetimeStop
		new OpData(1, 1, 0, 0), // #258
		new OpData(1, 1, 0, 0), // GroupAsyncCopy
		new OpData(0, 0, 0, 0), // GroupWaitEvents
		new OpData(1, 1, 0, 0), // GroupAll
		new OpData(1, 1, 0, 0), // GroupAny
		new OpData(1, 1, 0, 0), // GroupBroadcast
		new OpData(1, 1, 0, 0), // GroupIAdd
		new OpData(1, 1, 0, 0), // GroupFAdd
		new OpData(1, 1, 0, 0), // GroupFMin
		new OpData(1, 1, 0, 0), // GroupUMin
		new OpData(1, 1, 0, 0), // GroupSMin
		new OpData(1, 1, 0, 0), // GroupFMax
		new OpData(1, 1, 0, 0), // GroupUMax
		new OpData(1, 1, 0, 0), // GroupSMax
		new OpData(1, 1, 0, 0), // #272
		new OpData(1, 1, 0, 0), // #273
		new OpData(1, 1, 0, 0), // ReadPipe
		new OpData(1, 1, 0, 0), // WritePipe
		new OpData(1, 1, 0, 0), // ReservedReadPipe
		new OpData(1, 1, 0, 0), // ReservedWritePipe
		new OpData(1, 1, 0, 0), // ReserveReadPipePackets
		new OpData(1, 1, 0, 0), // ReserveWritePipePackets
		new OpData(0, 0, 0, 0), // CommitReadPipe
		new OpData(0, 0, 0, 0), // CommitWritePipe
		new OpData(1, 1, 0, 0), // IsValidReserveId
		new OpData(1, 1, 0, 0), // GetNumPipePackets
		new OpData(1, 1, 0, 0), // GetMaxPipePackets
		new OpData(1, 1, 0, 0), // GroupReserveReadPipePackets
		new OpData(1, 1, 0, 0), // GroupReserveWritePipePackets
		new OpData(0, 0, 0, 0), // GroupCommitReadPipe
		new OpData(0, 0, 0, 0), // GroupCommitWritePipe
		new OpData(1, 1, 0, 0), // #289
		new OpData(1, 1, 0, 0), // #290
		new OpData(1, 1, 0, 0), // EnqueueMarker
		new OpData(1, 1, 0, 0), // EnqueueKernel
		new OpData(1, 1, 0, 0), // GetKernelNDrangeSubGroupCount
		new OpData(1, 1, 0, 0), // GetKernelNDrangeMaxSubGroupSize
		new OpData(1, 1, 0, 0), // GetKernelWorkGroupSize
		new OpData(1, 1, 0, 0), // GetKernelPreferredWorkGroupSizeMultiple
		new OpData(0, 0, 0, 0), // RetainEvent
		new OpData(0, 0, 0, 0), // ReleaseEvent
		new OpData(1, 1, 0, 0), // CreateUserEvent
		new OpData(1, 1, 0, 0), // IsValidEvent
		new OpData(0, 0, 0, 0), // SetUserEventStatus
		new OpData(0, 0, 0, 0), // CaptureEventProfilingInfo
		new OpData(1, 1, 0, 0), // GetDefaultQueue
		new OpData(1, 1, 0, 0), // BuildNDRange
		new OpData(1, 1, 2, 1), // ImageSparseSampleImplicitLod
		new OpData(1, 1, 2, 1), // ImageSparseSampleExplicitLod
		new OpData(1, 1, 3, 1), // ImageSparseSampleDrefImplicitLod
		new OpData(1, 1, 3, 1), // ImageSparseSampleDrefExplicitLod
		new OpData(1, 1, 2, 1), // ImageSparseSampleProjImplicitLod
		new OpData(1, 1, 2, 1), // ImageSparseSampleProjExplicitLod
		new OpData(1, 1, 3, 1), // ImageSparseSampleProjDrefImplicitLod
		new OpData(1, 1, 3, 1), // ImageSparseSampleProjDrefExplicitLod
		new OpData(1, 1, 2, 1), // ImageSparseFetch
		new OpData(1, 1, 3, 1), // ImageSparseGather
		new OpData(1, 1, 3, 1), // ImageSparseDrefGather
		new OpData(1, 1, 1, 0), // ImageSparseTexelsResident
		new OpData(0, 0, 0, 0), // NoLine
		new OpData(1, 1, 0, 0), // AtomicFlagTestAndSet
		new OpData(0, 0, 0, 0), // AtomicFlagClear
		new OpData(1, 1, 0, 0), // ImageSparseRead
		new OpData(1, 1, 0, 0), // SizeOf
		new OpData(1, 1, 0, 0), // TypePipeStorage
		new OpData(1, 1, 0, 0), // ConstantPipeStorage
		new OpData(1, 1, 0, 0), // CreatePipeFromPipeStorage
		new OpData(1, 1, 0, 0), // GetKernelLocalSizeForSubgroupCount
		new OpData(1, 1, 0, 0), // GetKernelMaxNumSubgroups
		new OpData(1, 1, 0, 0), // TypeNamedBarrier
		new OpData(1, 1, 0, 1), // NamedBarrierInitialize
		new OpData(0, 0, -2, 1), // MemoryNamedBarrier
		new OpData(1, 1, 0, 0), // ModuleProcessed
		new OpData(0, 0, 0, 1), // ExecutionModeId
		new OpData(0, 0, 0, 1), // DecorateId
		new OpData(1, 1, 1, 1), // GroupNonUniformElect
		new OpData(1, 1, 1, 1), // GroupNonUniformAll
		new OpData(1, 1, 1, 1), // GroupNonUniformAny
		new OpData(1, 1, 1, 1), // GroupNonUniformAllEqual
		new OpData(1, 1, 1, 1), // GroupNonUniformBroadcast
		new OpData(1, 1, 1, 1), // GroupNonUniformBroadcastFirst
		new OpData(1, 1, 1, 1), // GroupNonUniformBallot
		new OpData(1, 1, 1, 1), // GroupNonUniformInverseBallot
		new OpData(1, 1, 1, 1), // GroupNonUniformBallotBitExtract
		new OpData(1, 1, 1, 1), // GroupNonUniformBallotBitCount
		new OpData(1, 1, 1, 1), // GroupNonUniformBallotFindLSB
		new OpData(1, 1, 1, 1), // GroupNonUniformBallotFindMSB
		new OpData(1, 1, 1, 1), // GroupNonUniformShuffle
		new OpData(1, 1, 1, 1), // GroupNonUniformShuffleXor
		new OpData(1, 1, 1, 1), // GroupNonUniformShuffleUp
		new OpData(1, 1, 1, 1), // GroupNonUniformShuffleDown
		new OpData(1, 1, 1, 1), // GroupNonUniformIAdd
		new OpData(1, 1, 1, 1), // GroupNonUniformFAdd
		new OpData(1, 1, 1, 1), // GroupNonUniformIMul
		new OpData(1, 1, 1, 1), // GroupNonUniformFMul
		new OpData(1, 1, 1, 1), // GroupNonUniformSMin
		new OpData(1, 1, 1, 1), // GroupNonUniformUMin
		new OpData(1, 1, 1, 1), // GroupNonUniformFMin
		new OpData(1, 1, 1, 1), // GroupNonUniformSMax
		new OpData(1, 1, 1, 1), // GroupNonUniformUMax
		new OpData(1, 1, 1, 1), // GroupNonUniformFMax
		new OpData(1, 1, 1, 1), // GroupNonUniformBitwiseAnd
		new OpData(1, 1, 1, 1), // GroupNonUniformBitwiseOr
		new OpData(1, 1, 1, 1), // GroupNonUniformBitwiseXor
		new OpData(1, 1, 1, 1), // GroupNonUniformLogicalAnd
		new OpData(1, 1, 1, 1), // GroupNonUniformLogicalOr
		new OpData(1, 1, 1, 1), // GroupNonUniformLogicalXor
		new OpData(1, 1, 1, 1), // GroupNonUniformQuadBroadcast
		new OpData(1, 1, 1, 1), // GroupNonUniformQuadSwap
	];
};

```

`Source/Smolv/Original-Cpp-Notes.md`:

```md
smol-v - public domain - https://github.com/aras-p/smol-v
authored 2016-2020 by Aras Pranckevicius
no warranty implied; use at your own risk
See end of file for license information.


### OVERVIEW:

SMOL-V encodes Vulkan/Khronos SPIR-V format programs into a form that is smaller, and is more
compressible. Normally no changes to the programs are done; they decode
into exactly same program as what was encoded. Optionally, debug information
can be removed too.

SPIR-V is a very verbose format, several times larger than same programs expressed in other
shader formats (e.g. DX11 bytecode, GLSL, DX9 bytecode etc.). The SSA-form with ever increasing
IDs is not very appreciated by regular data compressors either. SMOL-V does several things
to improve this:
- Many words, especially ones that most often have small values, are encoded using
  "varint" scheme (1-5 bytes per word, with just one byte for values in 0..127 range).
  See https://developers.google.com/protocol-buffers/docs/encoding
- Some IDs used in the program are delta-encoded, relative to previously seen IDs (e.g. Result
  IDs). Often instructions reference things that were computed just before, so this results in
  small deltas. These values are also encoded using "varint" scheme.
- Reordering instruction opcodes so that the most common ones are the smallest values, for smaller
 varint encoding.
- Encoding several instructions in a more compact form, e.g. the "typical <=4 component swizzle"
 shape of a VectorShuffle instruction, or sequences of MemberDecorate instructions.

A somewhat similar utility is spirv-remap from glslang, see
https://github.com/KhronosGroup/glslang/blob/master/README-spirv-remap.txt


### USAGE:

Add source/smolv.h and source/smolv.cpp to your C++ project build.
Currently it might require C++11 or somesuch; I only tested with Visual Studio 2017/2019, Mac Xcode 11 and Gcc 5.4.

smolv::Encode and smolv::Decode is the basic functionality.

Other functions are for development/statistics purposes, to figure out frequencies and
distributions of the instructions.

There's a test + compression benchmarking suite in testing/testmain.cpp; using that needs adding
other files under testing/external to the build too (3rd party code: glslang remapper, Zstd, LZ4).


### LIMITATIONS / TODO:

- SPIR-V where the words got stored in big-endian layout is not supported yet.
- The whole thing might not work on Big-Endian CPUs. It might, but I'm not 100% sure.
- Not much prevention is done against malformed/corrupted inputs, TODO.
- Out of memory cases are not handled. The code will either throw exception
  or crash, depending on your compilation flags.
```

`Source/Smolv/README.md`:

```md
# Smolv

## License

[Smolv](https://github.com/aras-p/smol-v) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/Smolv.md).
```

`Source/Smolv/Smolv.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\Smolv\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\Smolv\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

</Project>

```

`Source/Smolv/SmolvDecoder.cs`:

```cs
using System.Buffers.Binary;
using System.Text;

namespace Smolv;

public static class SmolvDecoder
{
	public static int GetDecodedBufferSize(ReadOnlySpan<byte> data)
	{
		if (!CheckSmolHeader(data))
		{
			return 0;
		}

		int size = BinaryPrimitives.ReadInt32LittleEndian(data[(5 * sizeof(uint))..]);
		return size;
	}

	public static int GetDecodedBufferSize([NotNull] Stream stream)
	{
		ArgumentNullException.ThrowIfNull(stream);
		if (!stream.CanSeek)
		{
			throw new ArgumentException(null, nameof(stream));
		}
		if (stream.Position + HeaderSize > stream.Length)
		{
			return 0;
		}

		long initPosition = stream.Position;
		stream.Position += HeaderSize - sizeof(uint);
		int size = stream.ReadByte() | (stream.ReadByte() << 8) | (stream.ReadByte() << 16) | (stream.ReadByte() << 24);
		stream.Position = initPosition;
		return size;
	}

	public static byte[]? Decode(byte[] data)
	{
		int bufferSize = GetDecodedBufferSize(data);
		if (bufferSize == 0)
		{
			// invalid SMOL-V
			return null;
		}

		byte[] output = new byte[bufferSize];
		if (Decode(data, output))
		{
			return output;
		}

		return null;
	}

	public static bool Decode(byte[] data, [NotNull] byte[] output)
	{
		ArgumentNullException.ThrowIfNull(output);

		int bufferSize = GetDecodedBufferSize(data);
		if (bufferSize > output.Length)
		{
			return false;
		}

		using MemoryStream outputStream = new MemoryStream(output);
		return Decode(data, outputStream);
	}

	public static bool Decode([NotNull] byte[] data, Stream outputStream)
	{
		ArgumentNullException.ThrowIfNull(data);
		using MemoryStream inputStream = new MemoryStream(data);
		return Decode(inputStream, data.Length, outputStream);
	}

	public static bool Decode([NotNull] Stream inputStream, int inputSize, [NotNull] Stream outputStream)
	{
		ArgumentNullException.ThrowIfNull(inputStream);
		ArgumentNullException.ThrowIfNull(outputStream);
		if (inputStream.Length < HeaderSize)
		{
			return false;
		}

		using BinaryReader input = new BinaryReader(inputStream, Encoding.UTF8, true);
		using BinaryWriter output = new BinaryWriter(outputStream, Encoding.UTF8, true);
		long inputEndPosition = input.BaseStream.Position + inputSize;
		long outputStartPosition = output.BaseStream.Position;

		// Header
		output.Write(SpirVHeaderMagic);
		input.BaseStream.Position += sizeof(uint);
		uint version = input.ReadUInt32();
		output.Write(version & 0x00FFFFFF);
		uint generator = input.ReadUInt32();
		output.Write(generator);
		int bound = input.ReadInt32();
		output.Write(bound);
		uint schema = input.ReadUInt32();
		output.Write(schema);
		int decodedSize = input.ReadInt32();

		// Body
		int prevResult = 0;
		int prevDecorate = 0;
		while (input.BaseStream.Position < inputEndPosition)
		{
			// read length + opcode
			if (!ReadLengthOp(input, out uint instrLen, out SpvOp op))
			{
				return false;
			}

			bool wasSwizzle = op == SpvOp.VectorShuffleCompact;
			if (wasSwizzle)
			{
				op = SpvOp.VectorShuffle;
			}
			output.Write((instrLen << 16) | (uint)op);

			uint ioffs = 1;
			// read type as varint, if we have it
			if (op.OpHasType())
			{
				if (!ReadVarint(input, out uint value))
				{
					return false;
				}

				output.Write(value);
				ioffs++;
			}

			// read result as delta+varint, if we have it
			if (op.OpHasResult())
			{
				if (!ReadVarint(input, out uint value))
				{
					return false;
				}

				int zds = prevResult + ZigDecode(value);
				output.Write(zds);
				prevResult = zds;
				ioffs++;
			}

			// Decorate: IDs relative to previous decorate
			if (op == SpvOp.Decorate || op == SpvOp.MemberDecorate)
			{
				if (!ReadVarint(input, out uint value))
				{
					return false;
				}

				int zds = prevDecorate + unchecked((int)value);
				output.Write(zds);
				prevDecorate = zds;
				ioffs++;
			}

			bool isNewSmolV = false;
			if (op == SpvOp.MemberDecorate && isNewSmolV)
			{
				if (input.BaseStream.Position >= inputEndPosition)
				{
					return false; //Broken input
				}

				long count = input.BaseStream.Position + 1;
				uint prevIndex = 0;
				uint prevOffset = 0;
				for (int m = 0; m < count; m++)
				{
					//read member index
					if (!ReadVarint(input, out uint memberIndex))
					{
						return false;
					}

					memberIndex += prevIndex;
					prevIndex = memberIndex;

					//decoration (and length if not common/known)
					if (!ReadVarint(input, out uint memberDec))
					{
						return false;
					}

					int knownExtraOps = DecorationExtraOps((int)memberDec);
					uint memberLen;
					if (knownExtraOps == -1)
					{
						if (!ReadVarint(input, out memberLen))
						{
							return false;
						}

						memberLen += 4;
					}
					else
					{
						memberLen = (uint)(4 + knownExtraOps);
					}

					// write SPIR-V op+length (unless it's first member decoration, in which case it was written before)
					if (m != 0)
					{
						output.Write((memberLen << 16) | (uint)op);
						output.Write(prevDecorate);
					}
					output.Write(memberIndex);
					output.Write(memberDec);

					if (memberDec == 35) // Offset
					{
						if (memberLen != 5)
						{
							return false;
						}

						if (!ReadVarint(input, out uint val))
						{
							return false;
						}

						val += prevOffset;
						output.Write(val);
						prevOffset = val;
					}
					else
					{
						for (uint i = 4; i < memberLen; ++i)
						{
							if (!ReadVarint(input, out uint val))
							{
								return false;
							}

							output.Write(val);
						}
					}
				}
				continue;
			}

			// Read this many IDs, that are relative to result ID
			int relativeCount = op.OpDeltaFromResult();
			bool inverted = false;
			if (relativeCount < 0)
			{
				inverted = true;
				relativeCount = -relativeCount;
			}
			for (int i = 0; i < relativeCount && ioffs < instrLen; ++i, ++ioffs)
			{
				if (!ReadVarint(input, out uint value))
				{
					return false;
				}

				int zd = inverted ? ZigDecode(value) : unchecked((int)value);
				output.Write(prevResult - zd);
			}

			if (wasSwizzle && instrLen <= 9)
			{
				uint swizzle = input.ReadByte();
				if (instrLen > 5)
				{
					output.Write(swizzle >> 6);
				}

				if (instrLen > 6)
				{
					output.Write((swizzle >> 4) & 3);
				}

				if (instrLen > 7)
				{
					output.Write((swizzle >> 2) & 3);
				}

				if (instrLen > 8)
				{
					output.Write(swizzle & 3);
				}
			}
			else if (op.OpVarRest())
			{
				// read rest of words with variable encoding
				for (; ioffs < instrLen; ++ioffs)
				{
					if (!ReadVarint(input, out uint value))
					{
						return false;
					}
					output.Write(value);
				}
			}
			else
			{
				// read rest of words without any encoding
				for (; ioffs < instrLen; ++ioffs)
				{
					if (input.BaseStream.Position + 4 > input.BaseStream.Length)
					{
						return false;
					}
					uint val = input.ReadUInt32();
					output.Write(val);
				}
			}
		}

		if (output.BaseStream.Position != outputStartPosition + decodedSize)
		{
			// something went wrong during decoding? we should have decoded to exact output size
			return false;
		}

		return true;
	}

	private static bool CheckSmolHeader(ReadOnlySpan<byte> data)
	{
		return CheckGenericHeader(data, SmolHeaderMagic);
	}

	private static bool CheckGenericHeader(ReadOnlySpan<byte> data, uint expectedMagic)
	{
		if (data.Length < HeaderSize)
		{
			return false;
		}

		uint headerMagic = BinaryPrimitives.ReadUInt32LittleEndian(data);
		if (headerMagic != expectedMagic)
		{
			return false;
		}

		uint headerVersion = BinaryPrimitives.ReadUInt32LittleEndian(data[sizeof(uint)..]);
		if (headerVersion < 0x00010000 || headerVersion > 0x00010300)
		{
			// only support 1.0 through 1.3
			return false;
		}

		return true;
	}

	private static bool ReadVarint(BinaryReader input, out uint value)
	{
		uint v = 0;
		int shift = 0;
		while (input.BaseStream.Position < input.BaseStream.Length)
		{
			byte b = input.ReadByte();
			v |= unchecked((uint)(b & 127) << shift);
			shift += 7;
			if ((b & 128) == 0)
			{
				break;
			}
		}

		value = v;
		// @TODO: report failures
		return true;
	}

	private static bool ReadLengthOp(BinaryReader input, out uint len, out SpvOp op)
	{
		len = default;
		op = default;
		if (!ReadVarint(input, out uint value))
		{
			return false;
		}
		len = ((value >> 20) << 4) | ((value >> 4) & 0xF);
		op = (SpvOp)(((value >> 4) & 0xFFF0) | (value & 0xF));

		op = RemapOp(op);
		len = DecodeLen(op, len);
		return true;
	}

	/// <summary>
	/// Remap most common Op codes (Load, Store, Decorate, VectorShuffle etc.) to be in &lt; 16 range, for 
	/// more compact varint encoding. This basically swaps rarely used op values that are &lt; 16 with the
	/// ones that are common.
	/// </summary>
	private static SpvOp RemapOp(SpvOp op)
	{
		return op switch
		{
			// 0: 24%
			SpvOp.Decorate => SpvOp.Nop,
			SpvOp.Nop => SpvOp.Decorate,

			// 1: 17%
			SpvOp.Load => SpvOp.Undef,
			SpvOp.Undef => SpvOp.Load,

			// 2: 9%
			SpvOp.Store => SpvOp.SourceContinued,
			SpvOp.SourceContinued => SpvOp.Store,

			// 3: 7.2%
			SpvOp.AccessChain => SpvOp.Source,
			SpvOp.Source => SpvOp.AccessChain,

			// 4: 5.0%
			// Name - already small enum value - 5: 4.4%
			// MemberName - already small enum value - 6: 2.9% 
			SpvOp.VectorShuffle => SpvOp.SourceExtension,
			SpvOp.SourceExtension => SpvOp.VectorShuffle,

			// 7: 4.0%
			SpvOp.MemberDecorate => SpvOp.String,
			SpvOp.String => SpvOp.MemberDecorate,

			// 8: 0.9%
			SpvOp.Label => SpvOp.Line,
			SpvOp.Line => SpvOp.Label,

			// 9: 3.9%
			SpvOp.Variable => (SpvOp)9,
			(SpvOp)9 => SpvOp.Variable,

			// 10: 3.9%
			SpvOp.FMul => SpvOp.Extension,
			SpvOp.Extension => SpvOp.FMul,

			// 11: 2.5%
			// ExtInst - already small enum value - 12: 1.2%
			// VectorShuffleCompact - already small enum value - used for compact shuffle encoding
			SpvOp.FAdd => SpvOp.ExtInstImport,
			SpvOp.ExtInstImport => SpvOp.FAdd,

			// 14: 2.2%
			SpvOp.TypePointer => SpvOp.MemoryModel,
			SpvOp.MemoryModel => SpvOp.TypePointer,

			// 15: 1.1%
			SpvOp.FNegate => SpvOp.EntryPoint,
			SpvOp.EntryPoint => SpvOp.FNegate,

			_ => op,
		};
	}

	private static uint DecodeLen(SpvOp op, uint len)
	{
		return len + op switch
		{
			SpvOp.VectorShuffle => 4 + 1,
			SpvOp.VectorShuffleCompact => 4 + 1,
			SpvOp.Decorate => 2 + 1,
			SpvOp.Load => 3 + 1,
			SpvOp.AccessChain => 3 + 1,
			_ => (uint)1,
		};
	}

	private static int DecorationExtraOps(int dec)
	{
		// RelaxedPrecision, Block..ColMajor
		if (dec == 0 || (dec >= 2 && dec <= 5))
		{
			return 0;
		}
		// Stream..XfbStride
		if (dec >= 29 && dec <= 37)
		{
			return 1;
		}

		// unknown, encode length
		return -1;
	}

	private static int ZigDecode(uint u)
	{
		return (u & 1) != 0 ? unchecked((int)~(u >> 1)) : unchecked((int)(u >> 1));
	}

	public const uint SpirVHeaderMagic = 0x07230203;
	/// <summary>
	/// 'SMOL' ascii
	/// </summary>
	public const uint SmolHeaderMagic = 0x534D4F4C;

	private const int HeaderSize = 6 * sizeof(uint);
}

```

`Source/Smolv/SpvOp.cs`:

```cs
namespace Smolv;

public enum SpvOp
{
	Nop = 0,
	Undef = 1,
	SourceContinued = 2,
	Source = 3,
	SourceExtension = 4,
	Name = 5,
	MemberName = 6,
	String = 7,
	Line = 8,
	Extension = 10,
	ExtInstImport = 11,
	ExtInst = 12,
	/// <summary>
	/// Not in SPIR-V, added for SMOL-V!
	/// </summary>
	VectorShuffleCompact = 13,
	MemoryModel = 14,
	EntryPoint = 15,
	ExecutionMode = 16,
	Capability = 17,
	TypeVoid = 19,
	TypeBool = 20,
	TypeInt = 21,
	TypeFloat = 22,
	TypeVector = 23,
	TypeMatrix = 24,
	TypeImage = 25,
	TypeSampler = 26,
	TypeSampledImage = 27,
	TypeArray = 28,
	TypeRuntimeArray = 29,
	TypeStruct = 30,
	TypeOpaque = 31,
	TypePointer = 32,
	TypeFunction = 33,
	TypeEvent = 34,
	TypeDeviceEvent = 35,
	TypeReserveId = 36,
	TypeQueue = 37,
	TypePipe = 38,
	TypeForwardPointer = 39,
	ConstantTrue = 41,
	ConstantFalse = 42,
	Constant = 43,
	ConstantComposite = 44,
	ConstantSampler = 45,
	ConstantNull = 46,
	SpecConstantTrue = 48,
	SpecConstantFalse = 49,
	SpecConstant = 50,
	SpecConstantComposite = 51,
	SpecConstantOp = 52,
	Function = 54,
	FunctionParameter = 55,
	FunctionEnd = 56,
	FunctionCall = 57,
	Variable = 59,
	ImageTexelPointer = 60,
	Load = 61,
	Store = 62,
	CopyMemory = 63,
	CopyMemorySized = 64,
	AccessChain = 65,
	InBoundsAccessChain = 66,
	PtrAccessChain = 67,
	ArrayLength = 68,
	GenericPtrMemSemantics = 69,
	InBoundsPtrAccessChain = 70,
	Decorate = 71,
	MemberDecorate = 72,
	DecorationGroup = 73,
	GroupDecorate = 74,
	GroupMemberDecorate = 75,
	VectorExtractDynamic = 77,
	VectorInsertDynamic = 78,
	VectorShuffle = 79,
	CompositeConstruct = 80,
	CompositeExtract = 81,
	CompositeInsert = 82,
	CopyObject = 83,
	Transpose = 84,
	SampledImage = 86,
	ImageSampleImplicitLod = 87,
	ImageSampleExplicitLod = 88,
	ImageSampleDrefImplicitLod = 89,
	ImageSampleDrefExplicitLod = 90,
	ImageSampleProjImplicitLod = 91,
	ImageSampleProjExplicitLod = 92,
	ImageSampleProjDrefImplicitLod = 93,
	ImageSampleProjDrefExplicitLod = 94,
	ImageFetch = 95,
	ImageGather = 96,
	ImageDrefGather = 97,
	ImageRead = 98,
	ImageWrite = 99,
	Image = 100,
	ImageQueryFormat = 101,
	ImageQueryOrder = 102,
	ImageQuerySizeLod = 103,
	ImageQuerySize = 104,
	ImageQueryLod = 105,
	ImageQueryLevels = 106,
	ImageQuerySamples = 107,
	ConvertFToU = 109,
	ConvertFToS = 110,
	ConvertSToF = 111,
	ConvertUToF = 112,
	UConvert = 113,
	SConvert = 114,
	FConvert = 115,
	QuantizeToF16 = 116,
	ConvertPtrToU = 117,
	SatConvertSToU = 118,
	SatConvertUToS = 119,
	ConvertUToPtr = 120,
	PtrCastToGeneric = 121,
	GenericCastToPtr = 122,
	GenericCastToPtrExplicit = 123,
	Bitcast = 124,
	SNegate = 126,
	FNegate = 127,
	IAdd = 128,
	FAdd = 129,
	ISub = 130,
	FSub = 131,
	IMul = 132,
	FMul = 133,
	UDiv = 134,
	SDiv = 135,
	FDiv = 136,
	UMod = 137,
	SRem = 138,
	SMod = 139,
	FRem = 140,
	FMod = 141,
	VectorTimesScalar = 142,
	MatrixTimesScalar = 143,
	VectorTimesMatrix = 144,
	MatrixTimesVector = 145,
	MatrixTimesMatrix = 146,
	OuterProduct = 147,
	Dot = 148,
	IAddCarry = 149,
	ISubBorrow = 150,
	UMulExtended = 151,
	SMulExtended = 152,
	Any = 154,
	All = 155,
	IsNan = 156,
	IsInf = 157,
	IsFinite = 158,
	IsNormal = 159,
	SignBitSet = 160,
	LessOrGreater = 161,
	Ordered = 162,
	Unordered = 163,
	LogicalEqual = 164,
	LogicalNotEqual = 165,
	LogicalOr = 166,
	LogicalAnd = 167,
	LogicalNot = 168,
	Select = 169,
	IEqual = 170,
	INotEqual = 171,
	UGreaterThan = 172,
	SGreaterThan = 173,
	UGreaterThanEqual = 174,
	SGreaterThanEqual = 175,
	ULessThan = 176,
	SLessThan = 177,
	ULessThanEqual = 178,
	SLessThanEqual = 179,
	FOrdEqual = 180,
	FUnordEqual = 181,
	FOrdNotEqual = 182,
	FUnordNotEqual = 183,
	FOrdLessThan = 184,
	FUnordLessThan = 185,
	FOrdGreaterThan = 186,
	FUnordGreaterThan = 187,
	FOrdLessThanEqual = 188,
	FUnordLessThanEqual = 189,
	FOrdGreaterThanEqual = 190,
	FUnordGreaterThanEqual = 191,
	ShiftRightLogical = 194,
	ShiftRightArithmetic = 195,
	ShiftLeftLogical = 196,
	BitwiseOr = 197,
	BitwiseXor = 198,
	BitwiseAnd = 199,
	Not = 200,
	BitFieldInsert = 201,
	BitFieldSExtract = 202,
	BitFieldUExtract = 203,
	BitReverse = 204,
	BitCount = 205,
	DPdx = 207,
	DPdy = 208,
	Fwidth = 209,
	DPdxFine = 210,
	DPdyFine = 211,
	FwidthFine = 212,
	DPdxCoarse = 213,
	DPdyCoarse = 214,
	FwidthCoarse = 215,
	EmitVertex = 218,
	EndPrimitive = 219,
	EmitStreamVertex = 220,
	EndStreamPrimitive = 221,
	ControlBarrier = 224,
	MemoryBarrier = 225,
	AtomicLoad = 227,
	AtomicStore = 228,
	AtomicExchange = 229,
	AtomicCompareExchange = 230,
	AtomicCompareExchangeWeak = 231,
	AtomicIIncrement = 232,
	AtomicIDecrement = 233,
	AtomicIAdd = 234,
	AtomicISub = 235,
	AtomicSMin = 236,
	AtomicUMin = 237,
	AtomicSMax = 238,
	AtomicUMax = 239,
	AtomicAnd = 240,
	AtomicOr = 241,
	AtomicXor = 242,
	Phi = 245,
	LoopMerge = 246,
	SelectionMerge = 247,
	Label = 248,
	Branch = 249,
	BranchConditional = 250,
	Switch = 251,
	Kill = 252,
	Return = 253,
	ReturnValue = 254,
	Unreachable = 255,
	LifetimeStart = 256,
	LifetimeStop = 257,
	GroupAsyncCopy = 259,
	GroupWaitEvents = 260,
	GroupAll = 261,
	GroupAny = 262,
	GroupBroadcast = 263,
	GroupIAdd = 264,
	GroupFAdd = 265,
	GroupFMin = 266,
	GroupUMin = 267,
	GroupSMin = 268,
	GroupFMax = 269,
	GroupUMax = 270,
	GroupSMax = 271,
	ReadPipe = 274,
	WritePipe = 275,
	ReservedReadPipe = 276,
	ReservedWritePipe = 277,
	ReserveReadPipePackets = 278,
	ReserveWritePipePackets = 279,
	CommitReadPipe = 280,
	CommitWritePipe = 281,
	IsValidReserveId = 282,
	GetNumPipePackets = 283,
	GetMaxPipePackets = 284,
	GroupReserveReadPipePackets = 285,
	GroupReserveWritePipePackets = 286,
	GroupCommitReadPipe = 287,
	GroupCommitWritePipe = 288,
	EnqueueMarker = 291,
	EnqueueKernel = 292,
	GetKernelNDrangeSubGroupCount = 293,
	GetKernelNDrangeMaxSubGroupSize = 294,
	GetKernelWorkGroupSize = 295,
	GetKernelPreferredWorkGroupSizeMultiple = 296,
	RetainEvent = 297,
	ReleaseEvent = 298,
	CreateUserEvent = 299,
	IsValidEvent = 300,
	SetUserEventStatus = 301,
	CaptureEventProfilingInfo = 302,
	GetDefaultQueue = 303,
	BuildNDRange = 304,
	ImageSparseSampleImplicitLod = 305,
	ImageSparseSampleExplicitLod = 306,
	ImageSparseSampleDrefImplicitLod = 307,
	ImageSparseSampleDrefExplicitLod = 308,
	ImageSparseSampleProjImplicitLod = 309,
	ImageSparseSampleProjExplicitLod = 310,
	ImageSparseSampleProjDrefImplicitLod = 311,
	ImageSparseSampleProjDrefExplicitLod = 312,
	ImageSparseFetch = 313,
	ImageSparseGather = 314,
	ImageSparseDrefGather = 315,
	ImageSparseTexelsResident = 316,
	NoLine = 317,
	AtomicFlagTestAndSet = 318,
	AtomicFlagClear = 319,
	ImageSparseRead = 320,
	SizeOf = 321,
	TypePipeStorage = 322,
	ConstantPipeStorage = 323,
	CreatePipeFromPipeStorage = 324,
	GetKernelLocalSizeForSubgroupCount = 325,
	GetKernelMaxNumSubgroups = 326,
	TypeNamedBarrier = 327,
	NamedBarrierInitialize = 328,
	MemoryNamedBarrier = 329,
	ModuleProcessed = 330,
	ExecutionModeId = 331,
	DecorateId = 332,
	GroupNonUniformElect = 333,
	GroupNonUniformAll = 334,
	GroupNonUniformAny = 335,
	GroupNonUniformAllEqual = 336,
	GroupNonUniformBroadcast = 337,
	GroupNonUniformBroadcastFirst = 338,
	GroupNonUniformBallot = 339,
	GroupNonUniformInverseBallot = 340,
	GroupNonUniformBallotBitExtract = 341,
	GroupNonUniformBallotBitCount = 342,
	GroupNonUniformBallotFindLSB = 343,
	GroupNonUniformBallotFindMSB = 344,
	GroupNonUniformShuffle = 345,
	GroupNonUniformShuffleXor = 346,
	GroupNonUniformShuffleUp = 347,
	GroupNonUniformShuffleDown = 348,
	GroupNonUniformIAdd = 349,
	GroupNonUniformFAdd = 350,
	GroupNonUniformIMul = 351,
	GroupNonUniformFMul = 352,
	GroupNonUniformSMin = 353,
	GroupNonUniformUMin = 354,
	GroupNonUniformFMin = 355,
	GroupNonUniformSMax = 356,
	GroupNonUniformUMax = 357,
	GroupNonUniformFMax = 358,
	GroupNonUniformBitwiseAnd = 359,
	GroupNonUniformBitwiseOr = 360,
	GroupNonUniformBitwiseXor = 361,
	GroupNonUniformLogicalAnd = 362,
	GroupNonUniformLogicalOr = 363,
	GroupNonUniformLogicalXor = 364,
	GroupNonUniformQuadBroadcast = 365,
	GroupNonUniformQuadSwap = 366,
}

public static class SpvOpExtensions
{
	/// <summary>
	/// Instruction encoding depends on the table that describes the various SPIR-V opcodes.<br/>
	/// Whenever we change or expand the table, we need to bump up the SMOL-V version,<br/>
	/// and make sure that we can still decode files encoded by an older version.
	/// </summary>
	static int GetKnownOpsCount(int version)
	{
		if (version == 0)
		{
			return (int)(SpvOp.ModuleProcessed + 1);
		}

		if (version == 1) // 2020 February, version 1 added ExecutionModeId..GroupNonUniformQuadSwap
		{
			return (int)(SpvOp.GroupNonUniformQuadSwap + 1);
		}

		return 0;
	}

	public static bool OpHasResult(this SpvOp _this) => OpHasResult(_this, GetKnownOpsCount(0));
	public static bool OpHasResult(this SpvOp _this, int opsCount)
	{
		if (_this < 0 || (int)_this >= opsCount)
		{
			return false;
		}
		return OpData.Get(_this).HasResult != 0;
	}

	public static bool OpHasType(this SpvOp _this) => OpHasType(_this, GetKnownOpsCount(0));
	public static bool OpHasType(this SpvOp _this, int opsCount)
	{
		if (_this < 0 || (int)_this >= opsCount)
		{
			return false;
		}
		return OpData.Get(_this).HasType != 0;
	}

	public static int OpDeltaFromResult(this SpvOp _this) => OpDeltaFromResult(_this, GetKnownOpsCount(0));
	public static int OpDeltaFromResult(this SpvOp _this, int opsCount)
	{
		if (_this < 0 || (int)_this >= opsCount)
		{
			return 0;
		}
		return OpData.Get(_this).DeltaFromResult;
	}

	public static bool OpVarRest(this SpvOp _this) => OpVarRest(_this, GetKnownOpsCount(0));
	public static bool OpVarRest(this SpvOp _this, int opsCount)
	{
		if (_this < 0 || (int)_this >= opsCount)
		{
			return false;
		}
		return OpData.Get(_this).VarRest != 0;
	}

	public static bool OpDebugInfo(this SpvOp _this) => OpDebugInfo(_this, GetKnownOpsCount(0));
	public static bool OpDebugInfo(this SpvOp _this, int opsCount)
	{
		return _this is
			SpvOp.SourceContinued or
			SpvOp.Source or
			SpvOp.SourceExtension or
			SpvOp.Name or
			SpvOp.MemberName or
			SpvOp.String or
			SpvOp.Line or
			SpvOp.NoLine or
			SpvOp.ModuleProcessed;
	}
}

```

`Source/SpirV/Disassembler.cs`:

```cs
using System.Text;

namespace SpirV;

public struct ModuleHeader
{
	public Version Version { get; set; }
	public string GeneratorVendor { get; set; }
	public string? GeneratorName { get; set; }
	public int GeneratorVersion { get; set; }
	public uint Bound { get; set; }
	public uint Reserved { get; set; }
}

[Flags]
public enum DisassemblyOptions
{
	None,
	ShowTypes,
	ShowNames,
	Default = ShowTypes | ShowNames
}

public class Disassembler
{
	public string Disassemble(Module module)
	{
		return Disassemble(module, DisassemblyOptions.Default);
	}

	public string Disassemble(Module module, DisassemblyOptions options)
	{
		m_sb.AppendLine("; SPIR-V");
		m_sb.Append("; Version: ").Append(module.Header.Version).AppendLine();
		if (module.Header.GeneratorName == null)
		{
			m_sb.Append("; Generator: unknown; ").Append(module.Header.GeneratorVersion).AppendLine();
		}
		else
		{
			m_sb.Append("; Generator: ").Append(module.Header.GeneratorVendor).Append(' ').
				Append(module.Header.GeneratorName).Append("; ").Append(module.Header.GeneratorVersion).AppendLine();
		}
		m_sb.Append("; Bound: ").Append(module.Header.Bound).AppendLine();
		m_sb.Append("; Schema: ").Append(module.Header.Reserved).AppendLine();

		string[] lines = new string[module.Instructions.Count + 1];
		lines[0] = m_sb.ToString();
		m_sb.Clear();

		for (int i = 0; i < module.Instructions.Count; i++)
		{
			ParsedInstruction instruction = module.Instructions[i];
			PrintInstruction(m_sb, instruction, options);
			lines[i + 1] = m_sb.ToString();
			m_sb.Clear();
		}

		int longestPrefix = 0;
		for (int i = 0; i < lines.Length; i++)
		{
			string line = lines[i];
			longestPrefix = Math.Max(longestPrefix, line.IndexOf('='));
			if (longestPrefix > 50)
			{
				longestPrefix = 50;
				break;
			}
		}

		m_sb.Append(lines[0]);
		for (int i = 1; i < lines.Length; i++)
		{
			string line = lines[i];
			int index = line.IndexOf('=');
			if (index == -1)
			{
				m_sb.Append(' ', longestPrefix + 4);
				m_sb.Append(line);
			}
			else
			{
				int pad = Math.Max(0, longestPrefix - index);
				m_sb.Append(' ', pad);
				m_sb.Append(line, 0, index);
				m_sb.Append('=');
				m_sb.Append(line, index + 1, line.Length - index - 1);
			}
			m_sb.AppendLine();
		}

		string result = m_sb.ToString();
		m_sb.Clear();
		return result;
	}

	private static void PrintInstruction(StringBuilder sb, ParsedInstruction instruction, DisassemblyOptions options)
	{
		if (instruction.Operands.Count == 0)
		{
			sb.Append(instruction.Instruction.Name);
			return;
		}

		int currentOperand = 0;
		if (instruction.Instruction.Operands[currentOperand].Type is IdResultType)
		{
			if (options.HasFlag(DisassemblyOptions.ShowTypes))
			{
				Type resultType = instruction.ResultType ?? throw new NullReferenceException();
				resultType.ToString(sb).Append(' ');
			}
			++currentOperand;
		}

		if (currentOperand < instruction.Operands.Count && instruction.Instruction.Operands[currentOperand].Type is IdResult)
		{
			if (!options.HasFlag(DisassemblyOptions.ShowNames) || string.IsNullOrWhiteSpace(instruction.Name))
			{
				PrintOperandValue(sb, instruction.Operands[currentOperand].Value, options);
			}
			else
			{
				sb.Append(instruction.Name);
			}
			sb.Append(" = ");

			++currentOperand;
		}

		sb.Append(instruction.Instruction.Name);
		sb.Append(' ');

		for (; currentOperand < instruction.Operands.Count; ++currentOperand)
		{
			PrintOperandValue(sb, instruction.Operands[currentOperand].Value, options);
			sb.Append(' ');
		}
	}

	private static void PrintOperandValue(StringBuilder sb, object value, DisassemblyOptions options)
	{
		switch (value)
		{
			case System.Type t:
				sb.Append(t.Name);
				break;

			case string s:
				{
					sb.Append('"');
					sb.Append(s);
					sb.Append('"');
				}
				break;

			case ObjectReference or:
				{
					if (options.HasFlag(DisassemblyOptions.ShowNames) && or.Reference != null && !string.IsNullOrWhiteSpace(or.Reference.Name))
					{
						sb.Append(or.Reference.Name);
					}
					else
					{
						or.ToString(sb);
					}
				}
				break;

			case IBitEnumOperandValue beov:
				PrintBitEnumValue(sb, beov, options);
				break;

			case IValueEnumOperandValue veov:
				PrintValueEnumValue(sb, veov, options);
				break;

			case VaryingOperandValue varOpVal:
				varOpVal.ToString(sb);
				break;

			default:
				sb.Append(value);
				break;
		}
	}

	private static void PrintBitEnumValue(StringBuilder sb, IBitEnumOperandValue enumOperandValue, DisassemblyOptions options)
	{
		foreach (uint key in enumOperandValue.Values.Keys)
		{
			sb.Append(enumOperandValue.GetEnumName(key));
			IReadOnlyList<object> value = enumOperandValue.Values[key];
			if (value.Count != 0)
			{
				sb.Append(' ');
				foreach (object v in value)
				{
					PrintOperandValue(sb, v, options);
				}
			}
		}
	}

	private static void PrintValueEnumValue(StringBuilder sb, IValueEnumOperandValue valueOperandValue, DisassemblyOptions options)
	{
		sb.Append(valueOperandValue.Key);
		if (valueOperandValue.Value is IList<object> valueList && valueList.Count > 0)
		{
			sb.Append(' ');
			foreach (object v in valueList)
			{
				PrintOperandValue(sb, v, options);
			}
		}
	}

	private readonly StringBuilder m_sb = new StringBuilder();
}

```

`Source/SpirV/EnumExtensions.cs`:

```cs
using System.Runtime.CompilerServices;

namespace SpirV;

public static class EnumExtensions
{
	public static uint AsUInt32<T>(this T value) where T : unmanaged, Enum
	{
		return As<T, uint>(value);
	}

	public static T AsEnum<T>(this uint value) where T : unmanaged, Enum
	{
		return As<uint, T>(value);
	}

	private static TTo As<TFrom, TTo>(TFrom source) where TFrom : unmanaged where TTo : unmanaged
	{
		if (Unsafe.SizeOf<TFrom>() == Unsafe.SizeOf<TTo>())
		{
			return Unsafe.As<TFrom, TTo>(ref source);
		}
		else
		{
			return ThrowOrReturnDefault<TTo>();
		}
	}

#if DEBUG
	[DoesNotReturn]
#endif
	private static T ThrowOrReturnDefault<T>() where T : struct
	{
#if DEBUG
		throw new InvalidCastException();
#else
		return default;//Exceptions prevent inlining.
#endif
	}
}

```

`Source/SpirV/Instruction.cs`:

```cs
namespace SpirV;

public enum OperandQuantifier
{
	/// <summary>
	/// 1
	/// </summary>
	Default,
	/// <summary>
	/// 0 or 1
	/// </summary>
	Optional,
	/// <summary>
	/// 0+
	/// </summary>
	Varying
}

public class Operand
{
	public Operand(OperandType kind, string? name, OperandQuantifier quantifier)
	{
		Name = name;
		Type = kind;
		Quantifier = quantifier;
	}

	public string? Name { get; }
	public OperandType Type { get; }
	public OperandQuantifier Quantifier { get; }
}

public class Instruction
{
	public Instruction(string? name) : this(name, new List<Operand>())
	{
	}

	public Instruction(string? name, IReadOnlyList<Operand> operands)
	{
		Operands = operands;
		Name = name;
	}

	public string? Name { get; }
	public IReadOnlyList<Operand> Operands { get; }
}

```

`Source/SpirV/Module.cs`:

```cs
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace SpirV;

public class Module
{
	public Module(ModuleHeader header, IReadOnlyList<ParsedInstruction> instructions)
	{
		Header = header;
		Instructions = instructions;

		Read(Instructions, objects_);
	}

	public static bool IsDebugInstruction(ParsedInstruction instruction)
	{
		return debugInstructions_.Contains(instruction.Instruction.Name);
	}

	private static void Read(IReadOnlyList<ParsedInstruction> instructions, Dictionary<uint, ParsedInstruction> objects)
	{
		// Debug instructions can be only processed after everything
		// else has been parsed, as they may reference types which haven't
		// been seen in the file yet
		List<ParsedInstruction> debugInstructions = new List<ParsedInstruction>();
		// Entry points contain forward references
		// Those need to be resolved afterwards
		List<ParsedInstruction> entryPoints = new List<ParsedInstruction>();

		foreach (ParsedInstruction instruction in instructions)
		{
			if (IsDebugInstruction(instruction))
			{
				debugInstructions.Add(instruction);
				continue;
			}
			if (instruction.Instruction is OpEntryPoint)
			{
				entryPoints.Add(instruction);
				continue;
			}

			if (instruction.Instruction.Name?.StartsWith("OpType", StringComparison.Ordinal) ?? false)
			{
				ProcessTypeInstruction(instruction, objects);
			}

			instruction.ResolveResultType(objects);
			if (instruction.HasResult)
			{
				objects[instruction.ResultId] = instruction;
			}

			switch (instruction.Instruction)
			{
				// Constants require that the result type has been resolved
				case OpSpecConstant:
				case OpConstant:

					{
						Type? t = instruction.ResultType;
						Debug.Assert(t != null);
						Debug.Assert(t is ScalarType);

						object? constant = ConvertConstant(t as ScalarType, instruction.Words, 3);
						instruction.Operands[2].Value = constant;
						instruction.Value = constant;
					}
					break;
			}
		}

		foreach (ParsedInstruction instruction in debugInstructions)
		{
			switch (instruction.Instruction)
			{
				case OpMemberName:

					{
						StructType t = (StructType?)objects[instruction.Words[1]].ResultType ?? throw new NullReferenceException();
						t.SetMemberName((uint)instruction.Operands[1].Value, (string)instruction.Operands[2].Value);
					}
					break;

				case OpName:

					{
						// We skip naming objects we don't know about
						ParsedInstruction t = objects[instruction.Words[1]];
						t.Name = (string)instruction.Operands[1].Value;
					}
					break;
			}
		}

		foreach (ParsedInstruction instruction in instructions)
		{
			instruction.ResolveReferences(objects);
		}
	}

	public static Module ReadFrom(Stream stream)
	{
		BinaryReader br = new BinaryReader(stream);
		Reader reader = new Reader(br);

		uint versionNumber = reader.ReadDWord();
		int majorVersion = (int)(versionNumber >> 16);
		int minorVersion = (int)((versionNumber >> 8) & 0xFF);
		Version version = new Version(majorVersion, minorVersion);

		uint generatorMagicNumber = reader.ReadDWord();
		int generatorToolId = (int)(generatorMagicNumber >> 16);
		string generatorVendor = "unknown";
		string? generatorName = null;

		if (Meta.Tools.ContainsKey(generatorToolId))
		{
			Meta.ToolInfo toolInfo = Meta.Tools[generatorToolId];
			generatorVendor = toolInfo.Vendor;
			if (toolInfo.Name != null)
			{
				generatorName = toolInfo.Name;
			}
		}

		// Read header
		ModuleHeader header = new();
		header.Version = version;
		header.GeneratorName = generatorName;
		header.GeneratorVendor = generatorVendor;
		header.GeneratorVersion = (int)(generatorMagicNumber & 0xFFFF);
		header.Bound = reader.ReadDWord();
		header.Reserved = reader.ReadDWord();

		List<ParsedInstruction> instructions = new();
		while (!reader.EndOfStream)
		{
			uint instructionStart = reader.ReadDWord();
			ushort wordCount = (ushort)(instructionStart >> 16);
			int opCode = (int)(instructionStart & 0xFFFF);

			uint[] words = new uint[wordCount];
			words[0] = instructionStart;
			for (ushort i = 1; i < wordCount; ++i)
			{
				words[i] = reader.ReadDWord();
			}

			ParsedInstruction instruction = new ParsedInstruction(opCode, words);
			instructions.Add(instruction);
		}

		return new Module(header, instructions);
	}

	/// <summary>
	/// Collect types from OpType* instructions
	/// </summary>
	private static void ProcessTypeInstruction(ParsedInstruction i, IReadOnlyDictionary<uint, ParsedInstruction> objects)
	{
		switch (i.Instruction)
		{
			case OpTypeInt:
				{
					i.ResultType = new IntegerType((int)i.Words[2], i.Words[3] == 1u);
				}
				break;

			case OpTypeFloat:
				{
					i.ResultType = new FloatingPointType((int)i.Words[2]);
				}
				break;

			case OpTypeVector:
				{
					i.ResultType = new VectorType((ScalarType)objects[i.Words[2]].ResultType, (int)i.Words[3]);
				}
				break;

			case OpTypeMatrix:
				{
					i.ResultType = new MatrixType((VectorType)objects[i.Words[2]].ResultType, (int)i.Words[3]);
				}
				break;

			case OpTypeArray:
				{
					object? constant = objects[i.Words[3]].Value;
					int size = 0;

					switch (constant)
					{
						case ushort u16:
							size = u16;
							break;

						case uint u32:
							size = (int)u32;
							break;

						case ulong u64:
							size = (int)u64;
							break;

						case short i16:
							size = i16;
							break;

						case int i32:
							size = i32;
							break;

						case long i64:
							size = (int)i64;
							break;
					}

					i.ResultType = new ArrayType(objects[i.Words[2]].ResultType, size);
				}
				break;

			case OpTypeRuntimeArray:
				{
					i.ResultType = new RuntimeArrayType((Type)objects[i.Words[2]].ResultType);
				}
				break;

			case OpTypeBool:
				{
					i.ResultType = new BoolType();
				}
				break;

			case OpTypeOpaque:
				{
					i.ResultType = new OpaqueType();
				}
				break;

			case OpTypeVoid:
				{
					i.ResultType = new VoidType();
				}
				break;

			case OpTypeImage:
				{
					Type sampledType = objects[i.Operands[1].GetId()].ResultType;
					Dim dim = i.Operands[2].GetSingleEnumValue<Dim>();
					uint depth = (uint)i.Operands[3].Value;
					bool isArray = (uint)i.Operands[4].Value != 0;
					bool isMultiSampled = (uint)i.Operands[5].Value != 0;
					uint sampled = (uint)i.Operands[6].Value;
					ImageFormat imageFormat = i.Operands[7].GetSingleEnumValue<ImageFormat>();

					i.ResultType = new ImageType(sampledType,
						dim,
						(int)depth, isArray, isMultiSampled,
						(int)sampled, imageFormat,
						i.Operands.Count > 8 ? i.Operands[8].GetSingleEnumValue<AccessQualifier>() : AccessQualifier.ReadOnly);
				}
				break;

			case OpTypeSampler:
				{
					i.ResultType = new SamplerType();
					break;
				}

			case OpTypeSampledImage:
				{
					i.ResultType = new SampledImageType((ImageType)objects[i.Words[2]].ResultType);
				}
				break;

			case OpTypeFunction:
				{
					List<Type> parameterTypes = new List<Type>();
					for (int j = 3; j < i.Words.Count; ++j)
					{
						parameterTypes.Add(objects[i.Words[j]].ResultType);
					}
					i.ResultType = new FunctionType(objects[i.Words[2]].ResultType, parameterTypes);
				}
				break;

			case OpTypeForwardPointer:
				{
					// We create a normal pointer, but with unspecified type
					// This will get resolved later on
					i.ResultType = new PointerType((StorageClass)i.Words[2]);
				}
				break;

			case OpTypePointer:
				{
					if (objects.ContainsKey(i.Words[1]))
					{
						// If there is something present, it must have been
						// a forward reference. The storage type must
						// match
						PointerType pt = (PointerType)i.ResultType;
						Debug.Assert(pt != null);
						Debug.Assert(pt.StorageClass == (StorageClass)i.Words[2]);
						pt.ResolveForwardReference(objects[i.Words[3]].ResultType);
					}
					else
					{
						i.ResultType = new PointerType((StorageClass)i.Words[2], objects[i.Words[3]].ResultType);
					}
				}
				break;

			case OpTypeStruct:
				{
					List<Type> memberTypes = new List<Type>();
					for (int j = 2; j < i.Words.Count; ++j)
					{
						memberTypes.Add(objects[i.Words[j]].ResultType);
					}
					i.ResultType = new StructType(memberTypes);
				}
				break;
		}
	}

	private static object? ConvertConstant(ScalarType? type, IReadOnlyList<uint> words, int index)
	{
		switch (type)
		{
			case IntegerType i:
				{
					if (i.Signed)
					{
						if (i.Width == 16)
						{
							return unchecked((short)words[index]);
						}
						else if (i.Width == 32)
						{
							return unchecked((int)words[index]);
						}
						else if (i.Width == 64)
						{
							return unchecked((long)(words[index] | ((ulong)words[index + 1] << 32)));
						}
					}
					else
					{
						if (i.Width == 16)
						{
							return unchecked((ushort)words[index]);
						}
						else if (i.Width == 32)
						{
							return words[index];
						}
						else if (i.Width == 64)
						{
							return words[index] | ((ulong)words[index + 1] << 32);
						}
					}

					throw new Exception("Cannot construct integer literal.");
				}

			case FloatingPointType f:
				{
					if (f.Width == 32)
					{
						uint value = words[0];
						return Unsafe.As<uint, float>(ref value);
					}
					else if (f.Width == 64)
					{
						ulong value = words[index] | ((ulong)words[index + 1] << 32);
						return Unsafe.As<ulong, double>(ref value);
					}
					else
					{
						throw new Exception("Cannot construct floating point literal.");
					}
				}
			default:
				return null;
		}
	}

	public ModuleHeader Header { get; }
	public IReadOnlyList<ParsedInstruction> Instructions { get; }

	private static readonly HashSet<string?> debugInstructions_ = new()
	{
		"OpSourceContinued",
		"OpSource",
		"OpSourceExtension",
		"OpName",
		"OpMemberName",
		"OpString",
		"OpLine",
		"OpNoLine",
		"OpModuleProcessed"
	};

	private readonly Dictionary<uint, ParsedInstruction> objects_ = new Dictionary<uint, ParsedInstruction>();
}

```

`Source/SpirV/OperandType.cs`:

```cs
using System.Reflection;
using System.Text;

namespace SpirV;

public class OperandType
{
	public virtual bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		// This returns the dynamic type
		value = GetType();
		wordsUsed = 1;
		return true;
	}
}

public class Literal : OperandType
{
}

public class LiteralNumber : Literal
{
}

// The SPIR-V JSON file uses only literal integers
public class LiteralInteger : LiteralNumber
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		value = words[index];
		wordsUsed = 1;
		return true;
	}
}

public class LiteralString : Literal
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		// This is just a fail-safe -- the loop below must terminate
		wordsUsed = 1;
		int bytesUsed = 0;
		byte[] bytes = new byte[(words.Count - index) * 4];
		for (int i = index; i < words.Count; ++i)
		{
			uint word = words[i];
			byte b0 = (byte)(word & 0xFF);
			if (b0 == 0)
			{
				break;
			}
			else
			{
				bytes[bytesUsed++] = b0;
			}

			byte b1 = (byte)((word >> 8) & 0xFF);
			if (b1 == 0)
			{
				break;
			}
			else
			{
				bytes[bytesUsed++] = b1;
			}

			byte b2 = (byte)((word >> 16) & 0xFF);
			if (b2 == 0)
			{
				break;
			}
			else
			{
				bytes[bytesUsed++] = b2;
			}

			byte b3 = (byte)(word >> 24);
			if (b3 == 0)
			{
				break;
			}
			else
			{
				bytes[bytesUsed++] = b3;
			}
			wordsUsed++;
		}

		value = Encoding.UTF8.GetString(bytes, 0, bytesUsed);
		return true;
	}
}

public class LiteralContextDependentNumber : Literal
{
	// This is handled during parsing by ConvertConstant
}

public class LiteralExtInstInteger : Literal
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		value = words[index];
		wordsUsed = 1;
		return true;
	}
}

public class LiteralSpecConstantOpInteger : Literal
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		List<ObjectReference> result = new List<ObjectReference>();
		for (int i = index; i < words.Count; i++)
		{
			ObjectReference objRef = new ObjectReference(words[i]);
			result.Add(objRef);
		}

		value = result;
		wordsUsed = words.Count - index;
		return true;
	}
}

public abstract class Parameter
{
	public abstract IReadOnlyList<OperandType> OperandTypes { get; }
}

public class ParameterFactory
{
	public virtual Parameter? CreateParameter(object value)
	{
		return null;
	}
}

public class EnumType<T> : EnumType<T, ParameterFactory>
	where T : unmanaged, Enum
{
};

public class EnumType<T, U> : OperandType
	where T : unmanaged, Enum
	where U : ParameterFactory, new()
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		int wordsUsedForParameters = 0;
		if (typeof(T).GetTypeInfo().GetCustomAttributes<FlagsAttribute>().Any())
		{
			Dictionary<uint, IReadOnlyList<object>> result = new Dictionary<uint, IReadOnlyList<object>>();
			foreach (T enumValue in Enum.GetValues<T>())
			{
				uint bit = enumValue.AsUInt32();
				// bit == 0 and words[0] == 0 handles the 0x0 = None cases
				if ((words[index] & bit) != 0 || (bit == 0 && words[index] == 0))
				{
					Parameter? p = parameterFactory_.CreateParameter(bit);
					if (p == null)
					{
						result.Add(bit, Array.Empty<object>());
					}
					else
					{
						object[] resultItems = new object[p.OperandTypes.Count];
						for (int j = 0; j < p.OperandTypes.Count; ++j)
						{
							p.OperandTypes[j].ReadValue(words, 1 + wordsUsedForParameters, out object pValue, out int pWordsUsed);
							wordsUsedForParameters += pWordsUsed;
							resultItems[j] = pValue;
						}
						result.Add(bit, resultItems);
					}
				}
			}
			value = new BitEnumOperandValue<T>(result);
		}
		else
		{
			object[] resultItems;
			Parameter? p = parameterFactory_.CreateParameter(words[index]);
			if (p == null)
			{
				resultItems = Array.Empty<object>();
			}
			else
			{
				resultItems = new object[p.OperandTypes.Count];
				for (int j = 0; j < p.OperandTypes.Count; ++j)
				{
					p.OperandTypes[j].ReadValue(words, 1 + wordsUsedForParameters, out object pValue, out int pWordsUsed);
					wordsUsedForParameters += pWordsUsed;
					resultItems[j] = pValue;
				}
			}
			value = new ValueEnumOperandValue<T>((T)(object)words[index], resultItems);
		}

		wordsUsed = wordsUsedForParameters + 1;
		return true;
	}

	private readonly U parameterFactory_ = new U();
}

public class IdScope : OperandType
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		value = (Scope)words[index];
		wordsUsed = 1;
		return true;
	}
}

public class IdMemorySemantics : OperandType
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		value = (MemorySemantics)words[index];
		wordsUsed = 1;
		return true;
	}
}

public class IdType : OperandType
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		value = words[index];
		wordsUsed = 1;
		return true;
	}
}

public class IdResult : IdType
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		value = new ObjectReference(words[index]);
		wordsUsed = 1;
		return true;
	}
}

public class IdResultType : IdType
{
}

public class IdRef : IdType
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		value = new ObjectReference(words[index]);
		wordsUsed = 1;
		return true;
	}
}

public class PairIdRefIdRef : OperandType
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		ObjectReference variable = new ObjectReference(words[index]);
		ObjectReference parent = new ObjectReference(words[index + 1]);
		value = new { Variable = variable, Parent = parent };
		wordsUsed = 2;
		return true;
	}
}

public class PairIdRefLiteralInteger : OperandType
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		ObjectReference type = new ObjectReference(words[index]);
		uint word = words[index + 1];
		value = new { Type = type, Member = word };
		wordsUsed = 2;
		return true;
	}
}

public class PairLiteralIntegerIdRef : OperandType
{
	public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
	{
		uint selector = words[index];
		ObjectReference label = new ObjectReference(words[index + 1]);
		value = new { Selector = selector, Label = label };
		wordsUsed = 2;
		return true;
	}
}

```

`Source/SpirV/ParsedInstruction.cs`:

```cs
using System.Text;

namespace SpirV;

public class ParsedOperand
{
	public ParsedOperand(IReadOnlyList<uint> words, int index, int count, object value, Operand operand)
	{
		uint[] array = new uint[count];
		for (int i = 0; i < count; i++)
		{
			array[i] = words[index + i];
		}

		Words = array;
		Value = value;
		Operand = operand;
	}

	public T GetSingleEnumValue<T>() where T : Enum
	{
		IValueEnumOperandValue v = (IValueEnumOperandValue)Value;
		if (v.Value.Count == 0)
		{
			// If there's no value at all, the enum is probably something like ImageFormat.
			// In which case we just return the enum value
			return (T)v.Key;
		}
		else
		{
			// This means the enum has a value attached to it, so we return the attached value
			return (T)((IValueEnumOperandValue)Value).Value[0];
		}
	}

	public uint GetId()
	{
		return ((ObjectReference)Value).Id;
	}

	public uint GetBitEnumValue()
	{
		IBitEnumOperandValue v = (IBitEnumOperandValue)Value;

		uint result = 0;
		foreach (uint k in v.Values.Keys)
		{
			result |= k;
		}

		return result;
	}

	public IReadOnlyList<uint> Words { get; }
	public object Value { get; set; }
	public Operand Operand { get; }
}

public class VaryingOperandValue
{
	public VaryingOperandValue(IReadOnlyList<object> values)
	{
		Values = values;
	}

	public override string ToString()
	{
		StringBuilder sb = new();
		ToString(sb);
		return sb.ToString();
	}

	public StringBuilder ToString(StringBuilder sb)
	{
		for (int i = 0; i < Values.Count; ++i)
		{
			if (Values[i] is ObjectReference objRef)
			{
				objRef.ToString(sb);
			}
			else
			{
				sb.Append(Values[i]);
			}
			if (i < (Values.Count - 1))
			{
				sb.Append(' ');
			}
		}
		return sb;
	}

	public IReadOnlyList<object> Values { get; }
}

public interface IEnumOperandValue
{
	string? GetEnumName(uint value);
}

public interface IBitEnumOperandValue : IEnumOperandValue
{
	IReadOnlyDictionary<uint, IReadOnlyList<object>> Values { get; }
}

public interface IValueEnumOperandValue : IEnumOperandValue
{
	object Key { get; }
	IReadOnlyList<object> Value { get; }
}

public abstract class EnumOperandValue<T> : IEnumOperandValue
	where T : unmanaged, Enum
{
	public string? GetEnumName(uint value) => Enum.GetName<T>(value.AsEnum<T>());
}

public class ValueEnumOperandValue<T> : EnumOperandValue<T>, IValueEnumOperandValue
	where T : unmanaged, Enum
{
	public ValueEnumOperandValue(T key, IReadOnlyList<object> value)
	{
		Key = key;
		Value = value;
	}

	public object Key { get; }
	public IReadOnlyList<object> Value { get; }
}

public class BitEnumOperandValue<T> : EnumOperandValue<T>, IBitEnumOperandValue
	where T : unmanaged, Enum
{
	public BitEnumOperandValue(Dictionary<uint, IReadOnlyList<object>> values)
	{
		Values = values;
	}

	public IReadOnlyDictionary<uint, IReadOnlyList<object>> Values { get; }
}

public class ObjectReference
{
	public ObjectReference(uint id)
	{
		Id = id;
	}

	public void Resolve(IReadOnlyDictionary<uint, ParsedInstruction> objects)
	{
		Reference = objects[Id];
	}

	public override string ToString()
	{
		return $"%{Id}";
	}

	public StringBuilder ToString(StringBuilder sb)
	{
		return sb.Append('%').Append(Id);
	}

	public uint Id { get; }
	public ParsedInstruction? Reference { get; private set; }
}

public class ParsedInstruction
{
	public ParsedInstruction(int opCode, IReadOnlyList<uint> words)
	{
		Words = words;
		Instruction = Instructions.OpcodeToInstruction[opCode];
		ParseOperands();
	}

	private void ParseOperands()
	{
		if (Instruction.Operands.Count == 0)
		{
			return;
		}

		// Word 0 describes this instruction so we can ignore it
		int currentWord = 1;
		int currentOperand = 0;
		List<object> varyingOperandValues = new();
		int varyingWordStart = 0;
		Operand? varyingOperand = null;

		while (currentWord < Words.Count)
		{
			Operand operand = Instruction.Operands[currentOperand];
			operand.Type.ReadValue(Words, currentWord, out object value, out int wordsUsed);
			if (operand.Quantifier == OperandQuantifier.Varying)
			{
				varyingOperandValues.Add(value);
				varyingWordStart = currentWord;
				varyingOperand = operand;
			}
			else
			{
				int wordCount = Math.Min(Words.Count - currentWord, wordsUsed);
				ParsedOperand parsedOperand = new ParsedOperand(Words, currentWord, wordCount, value, operand);
				Operands.Add(parsedOperand);
			}

			currentWord += wordsUsed;
			if (operand.Quantifier != OperandQuantifier.Varying)
			{
				++currentOperand;
			}
		}

		if (varyingOperand != null)
		{
			VaryingOperandValue varOperantValue = new VaryingOperandValue(varyingOperandValues);
			ParsedOperand parsedOperand = new ParsedOperand(Words, currentWord, Words.Count - currentWord, varOperantValue, varyingOperand);
			Operands.Add(parsedOperand);
		}
	}

	public void ResolveResultType(IReadOnlyDictionary<uint, ParsedInstruction> objects)
	{
		if (Instruction.Operands.Count > 0 && Instruction.Operands[0].Type is IdResultType)
		{
			ResultType = objects[(uint)Operands[0].Value].ResultType;
		}
	}

	public void ResolveReferences(IReadOnlyDictionary<uint, ParsedInstruction> objects)
	{
		foreach (ParsedOperand operand in Operands)
		{
			if (operand.Value is ObjectReference objectReference)
			{
				objectReference.Resolve(objects);
			}
		}
	}

	public Type ResultType { get; set; }
	public uint ResultId
	{
		get
		{
			for (int i = 0; i < Instruction.Operands.Count; ++i)
			{
				if (Instruction.Operands[i].Type is IdResult)
				{
					return Operands[i].GetId();
				}
			}
			return 0;
		}
	}
	public bool HasResult => ResultId != 0;

	public IReadOnlyList<uint> Words { get; }
	public Instruction Instruction { get; }
	public IList<ParsedOperand> Operands { get; } = new List<ParsedOperand>();
	public string? Name { get; set; }
	public object? Value { get; set; }
}

```

`Source/SpirV/README.md`:

```md
# SpirV

## License

[SpirV](https://github.com/Anteru/csspv) is licensed under the [BSD 2-Clause license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/SpirV.md).
```

`Source/SpirV/Reader.cs`:

```cs
using System.Runtime.CompilerServices;

namespace SpirV;

internal sealed class Reader
{
	public Reader(BinaryReader reader)
	{
		reader_ = reader;
		uint magicNumber = reader_.ReadUInt32();
		if (magicNumber == Meta.MagicNumber)
		{
			littleEndian_ = true;
		}
		else if (Reverse(magicNumber) == Meta.MagicNumber)
		{
			littleEndian_ = false;
		}
		else
		{
			throw new Exception("Invalid magic number");
		}
	}

	public uint ReadDWord()
	{
		if (littleEndian_)
		{
			return reader_.ReadUInt32();
		}
		else
		{
			return Reverse(reader_.ReadUInt32());
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static uint Reverse(uint u)
	{
		return (u << 24) | ((u & 0xFF00U) << 8) | ((u >> 8) & 0xFF00U) | (u >> 24);
	}

	public bool EndOfStream => reader_.BaseStream.Position == reader_.BaseStream.Length;

	private readonly BinaryReader reader_;
	private readonly bool littleEndian_;
}

```

`Source/SpirV/SpirV.Core.Grammar.cs`:

```cs
namespace SpirV;

[Flags]
public enum ImageOperands : uint
{
	None = 0,
	Bias = 1,
	Lod = 2,
	Grad = 4,
	ConstOffset = 8,
	Offset = 16,
	ConstOffsets = 32,
	Sample = 64,
	MinLod = 128,
}
public class ImageOperandsParameterFactory : ParameterFactory
{
	public class BiasParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new IdRef(), };
	}

	public class LodParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new IdRef(), };
	}

	public class GradParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new IdRef(), new IdRef(), };
	}

	public class ConstOffsetParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new IdRef(), };
	}

	public class OffsetParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new IdRef(), };
	}

	public class ConstOffsetsParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new IdRef(), };
	}

	public class SampleParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new IdRef(), };
	}

	public class MinLodParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new IdRef(), };
	}

	public override Parameter? CreateParameter(object value)
	{
		return (ImageOperands)value switch
		{
			ImageOperands.Bias => new BiasParameter(),
			ImageOperands.Lod => new LodParameter(),
			ImageOperands.Grad => new GradParameter(),
			ImageOperands.ConstOffset => new ConstOffsetParameter(),
			ImageOperands.Offset => new OffsetParameter(),
			ImageOperands.ConstOffsets => new ConstOffsetsParameter(),
			ImageOperands.Sample => new SampleParameter(),
			ImageOperands.MinLod => new MinLodParameter(),
			_ => null,
		};
	}
}
[Flags]
public enum FPFastMathMode : uint
{
	None = 0,
	NotNaN = 1,
	NotInf = 2,
	NSZ = 4,
	AllowRecip = 8,
	Fast = 16,
}
public class FPFastMathModeParameterFactory : ParameterFactory
{
}
[Flags]
public enum SelectionControl : uint
{
	None = 0,
	Flatten = 1,
	DontFlatten = 2,
}
public class SelectionControlParameterFactory : ParameterFactory
{
}
[Flags]
public enum LoopControl : uint
{
	None = 0,
	Unroll = 1,
	DontUnroll = 2,
	DependencyInfinite = 4,
	DependencyLength = 8,
}
public class LoopControlParameterFactory : ParameterFactory
{
	public class DependencyLengthParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public override Parameter? CreateParameter(object value)
	{
		return (LoopControl)value switch
		{
			LoopControl.DependencyLength => new DependencyLengthParameter(),
			_ => null,
		};
	}
}
[Flags]
public enum FunctionControl : uint
{
	None = 0,
	Inline = 1,
	DontInline = 2,
	Pure = 4,
	Const = 8,
}
public class FunctionControlParameterFactory : ParameterFactory
{
}
[Flags]
public enum MemorySemantics : uint
{
	Relaxed = 0,
	None = 0,
	Acquire = 2,
	Release = 4,
	AcquireRelease = 8,
	SequentiallyConsistent = 16,
	UniformMemory = 64,
	SubgroupMemory = 128,
	WorkgroupMemory = 256,
	CrossWorkgroupMemory = 512,
	AtomicCounterMemory = 1024,
	ImageMemory = 2048,
}
public class MemorySemanticsParameterFactory : ParameterFactory
{
}
[Flags]
public enum MemoryAccess : uint
{
	None = 0,
	Volatile = 1,
	Aligned = 2,
	Nontemporal = 4,
}
public class MemoryAccessParameterFactory : ParameterFactory
{
	public class AlignedParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public override Parameter? CreateParameter(object value)
	{
		return (MemoryAccess)value switch
		{
			MemoryAccess.Aligned => new AlignedParameter(),
			_ => null,
		};
	}
}
[Flags]
public enum KernelProfilingInfo : uint
{
	None = 0,
	CmdExecTime = 1,
}
public class KernelProfilingInfoParameterFactory : ParameterFactory
{
}
public enum SourceLanguage : uint
{
	Unknown = 0,
	ESSL = 1,
	GLSL = 2,
	OpenCL_C = 3,
	OpenCL_CPP = 4,
	HLSL = 5,
}
public class SourceLanguageParameterFactory : ParameterFactory
{
}
public enum ExecutionModel : uint
{
	Vertex = 0,
	TessellationControl = 1,
	TessellationEvaluation = 2,
	Geometry = 3,
	Fragment = 4,
	GLCompute = 5,
	Kernel = 6,
}
public class ExecutionModelParameterFactory : ParameterFactory
{
}
public enum AddressingModel : uint
{
	Logical = 0,
	Physical32 = 1,
	Physical64 = 2,
}
public class AddressingModelParameterFactory : ParameterFactory
{
}
public enum MemoryModel : uint
{
	Simple = 0,
	GLSL450 = 1,
	OpenCL = 2,
}
public class MemoryModelParameterFactory : ParameterFactory
{
}
public enum ExecutionMode : uint
{
	Invocations = 0,
	SpacingEqual = 1,
	SpacingFractionalEven = 2,
	SpacingFractionalOdd = 3,
	VertexOrderCw = 4,
	VertexOrderCcw = 5,
	PixelCenterInteger = 6,
	OriginUpperLeft = 7,
	OriginLowerLeft = 8,
	EarlyFragmentTests = 9,
	PointMode = 10,
	Xfb = 11,
	DepthReplacing = 12,
	DepthGreater = 14,
	DepthLess = 15,
	DepthUnchanged = 16,
	LocalSize = 17,
	LocalSizeHint = 18,
	InputPoints = 19,
	InputLines = 20,
	InputLinesAdjacency = 21,
	Triangles = 22,
	InputTrianglesAdjacency = 23,
	Quads = 24,
	Isolines = 25,
	OutputVertices = 26,
	OutputPoints = 27,
	OutputLineStrip = 28,
	OutputTriangleStrip = 29,
	VecTypeHint = 30,
	ContractionOff = 31,
	Initializer = 33,
	Finalizer = 34,
	SubgroupSize = 35,
	SubgroupsPerWorkgroup = 36,
	SubgroupsPerWorkgroupId = 37,
	LocalSizeId = 38,
	LocalSizeHintId = 39,
	PostDepthCoverage = 4446,
	StencilRefReplacingEXT = 5027,
}
public class ExecutionModeParameterFactory : ParameterFactory
{
	public class InvocationsParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class LocalSizeParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), new LiteralInteger(), new LiteralInteger(), };
	}

	public class LocalSizeHintParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), new LiteralInteger(), new LiteralInteger(), };
	}

	public class OutputVerticesParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class VecTypeHintParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class SubgroupSizeParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class SubgroupsPerWorkgroupParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
		{
			new LiteralInteger(),
		};
	}

	public class SubgroupsPerWorkgroupIdParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
		{
			new IdRef(),
		};
	}

	public class LocalSizeIdParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
		{
			new IdRef(),
			new IdRef(),
			new IdRef(),
		};
	}

	public class LocalSizeHintIdParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new IdRef(), };
	}

	public override Parameter? CreateParameter(object value)
	{
		return (ExecutionMode)value switch
		{
			ExecutionMode.Invocations => new InvocationsParameter(),
			ExecutionMode.LocalSize => new LocalSizeParameter(),
			ExecutionMode.LocalSizeHint => new LocalSizeHintParameter(),
			ExecutionMode.OutputVertices => new OutputVerticesParameter(),
			ExecutionMode.VecTypeHint => new VecTypeHintParameter(),
			ExecutionMode.SubgroupSize => new SubgroupSizeParameter(),
			ExecutionMode.SubgroupsPerWorkgroup => new SubgroupsPerWorkgroupParameter(),
			ExecutionMode.SubgroupsPerWorkgroupId => new SubgroupsPerWorkgroupIdParameter(),
			ExecutionMode.LocalSizeId => new LocalSizeIdParameter(),
			ExecutionMode.LocalSizeHintId => new LocalSizeHintIdParameter(),
			_ => null,
		};
	}
}
public enum StorageClass : uint
{
	UniformConstant = 0,
	Input = 1,
	Uniform = 2,
	Output = 3,
	Workgroup = 4,
	CrossWorkgroup = 5,
	Private = 6,
	Function = 7,
	Generic = 8,
	PushConstant = 9,
	AtomicCounter = 10,
	Image = 11,
	StorageBuffer = 12,
}
public class StorageClassParameterFactory : ParameterFactory
{
}
public enum Dim : uint
{
	Dim1D = 0,
	Dim2D = 1,
	Dim3D = 2,
	Cube = 3,
	Rect = 4,
	Buffer = 5,
	SubpassData = 6,
}
public class DimParameterFactory : ParameterFactory
{
}
public enum SamplerAddressingMode : uint
{
	None = 0,
	ClampToEdge = 1,
	Clamp = 2,
	Repeat = 3,
	RepeatMirrored = 4,
}
public class SamplerAddressingModeParameterFactory : ParameterFactory
{
}
public enum SamplerFilterMode : uint
{
	Nearest = 0,
	Linear = 1,
}
public class SamplerFilterModeParameterFactory : ParameterFactory
{
}
public enum ImageFormat : uint
{
	Unknown = 0,
	Rgba32f = 1,
	Rgba16f = 2,
	R32f = 3,
	Rgba8 = 4,
	Rgba8Snorm = 5,
	Rg32f = 6,
	Rg16f = 7,
	R11fG11fB10f = 8,
	R16f = 9,
	Rgba16 = 10,
	Rgb10A2 = 11,
	Rg16 = 12,
	Rg8 = 13,
	R16 = 14,
	R8 = 15,
	Rgba16Snorm = 16,
	Rg16Snorm = 17,
	Rg8Snorm = 18,
	R16Snorm = 19,
	R8Snorm = 20,
	Rgba32i = 21,
	Rgba16i = 22,
	Rgba8i = 23,
	R32i = 24,
	Rg32i = 25,
	Rg16i = 26,
	Rg8i = 27,
	R16i = 28,
	R8i = 29,
	Rgba32ui = 30,
	Rgba16ui = 31,
	Rgba8ui = 32,
	R32ui = 33,
	Rgb10a2ui = 34,
	Rg32ui = 35,
	Rg16ui = 36,
	Rg8ui = 37,
	R16ui = 38,
	R8ui = 39,
}
public class ImageFormatParameterFactory : ParameterFactory
{
}
public enum ImageChannelOrder : uint
{
	R = 0,
	A = 1,
	RG = 2,
	RA = 3,
	RGB = 4,
	RGBA = 5,
	BGRA = 6,
	ARGB = 7,
	Intensity = 8,
	Luminance = 9,
	Rx = 10,
	RGx = 11,
	RGBx = 12,
	Depth = 13,
	DepthStencil = 14,
	sRGB = 15,
	sRGBx = 16,
	sRGBA = 17,
	sBGRA = 18,
	ABGR = 19,
}
public class ImageChannelOrderParameterFactory : ParameterFactory
{
}
public enum ImageChannelDataType : uint
{
	SnormInt8 = 0,
	SnormInt16 = 1,
	UnormInt8 = 2,
	UnormInt16 = 3,
	UnormShort565 = 4,
	UnormShort555 = 5,
	UnormInt101010 = 6,
	SignedInt8 = 7,
	SignedInt16 = 8,
	SignedInt32 = 9,
	UnsignedInt8 = 10,
	UnsignedInt16 = 11,
	UnsignedInt32 = 12,
	HalfFloat = 13,
	Float = 14,
	UnormInt24 = 15,
	UnormInt101010_2 = 16,
}
public class ImageChannelDataTypeParameterFactory : ParameterFactory
{
}
public enum FPRoundingMode : uint
{
	RTE = 0,
	RTZ = 1,
	RTP = 2,
	RTN = 3,
}
public class FPRoundingModeParameterFactory : ParameterFactory
{
}
public enum LinkageType : uint
{
	Export = 0,
	Import = 1,
}
public class LinkageTypeParameterFactory : ParameterFactory
{
}
public enum AccessQualifier : uint
{
	ReadOnly = 0,
	WriteOnly = 1,
	ReadWrite = 2,
}
public class AccessQualifierParameterFactory : ParameterFactory
{
}
public enum FunctionParameterAttribute : uint
{
	Zext = 0,
	Sext = 1,
	ByVal = 2,
	Sret = 3,
	NoAlias = 4,
	NoCapture = 5,
	NoWrite = 6,
	NoReadWrite = 7,
}
public class FunctionParameterAttributeParameterFactory : ParameterFactory
{
}
public enum Decoration : uint
{
	RelaxedPrecision = 0,
	SpecId = 1,
	Block = 2,
	BufferBlock = 3,
	RowMajor = 4,
	ColMajor = 5,
	ArrayStride = 6,
	MatrixStride = 7,
	GLSLShared = 8,
	GLSLPacked = 9,
	CPacked = 10,
	BuiltIn = 11,
	NoPerspective = 13,
	Flat = 14,
	Patch = 15,
	Centroid = 16,
	Sample = 17,
	Invariant = 18,
	Restrict = 19,
	Aliased = 20,
	Volatile = 21,
	Constant = 22,
	Coherent = 23,
	NonWritable = 24,
	NonReadable = 25,
	Uniform = 26,
	SaturatedConversion = 28,
	Stream = 29,
	Location = 30,
	Component = 31,
	Index = 32,
	Binding = 33,
	DescriptorSet = 34,
	Offset = 35,
	XfbBuffer = 36,
	XfbStride = 37,
	FuncParamAttr = 38,
	FPRoundingMode = 39,
	FPFastMathMode = 40,
	LinkageAttributes = 41,
	NoContraction = 42,
	InputAttachmentIndex = 43,
	Alignment = 44,
	MaxByteOffset = 45,
	AlignmentId = 46,
	MaxByteOffsetId = 47,
	ExplicitInterpAMD = 4999,
	OverrideCoverageNV = 5248,
	PassthroughNV = 5250,
	ViewportRelativeNV = 5252,
	SecondaryViewportRelativeNV = 5256,
}
public class DecorationParameterFactory : ParameterFactory
{
	public class SpecIdParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class ArrayStrideParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class MatrixStrideParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class BuiltInParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new EnumType<BuiltIn>(), };
	}

	public class StreamParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class LocationParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class ComponentParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class IndexParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class BindingParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class DescriptorSetParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class OffsetParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class XfbBufferParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class XfbStrideParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class FuncParamAttrParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new EnumType<FunctionParameterAttribute>(), };
	}

	public class FPRoundingModeParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new EnumType<FPRoundingMode>(), };
	}

	public class FPFastMathModeParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new EnumType<FPFastMathMode>(), };
	}

	public class LinkageAttributesParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralString(), new EnumType<LinkageType>(), };
	}

	public class InputAttachmentIndexParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class AlignmentParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class MaxByteOffsetParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public class AlignmentIdParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new IdRef(), };
	}

	public class MaxByteOffsetIdParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new IdRef(), };
	}

	public class SecondaryViewportRelativeNVParameter : Parameter
	{
		public override IReadOnlyList<OperandType> OperandTypes
		{
			get => operandTypes_;
		}

		private static readonly List<OperandType> operandTypes_ = new()
	{new LiteralInteger(), };
	}

	public override Parameter? CreateParameter(object value)
	{
		return (Decoration)value switch
		{
			Decoration.SpecId => new SpecIdParameter(),
			Decoration.ArrayStride => new ArrayStrideParameter(),
			Decoration.MatrixStride => new MatrixStrideParameter(),
			Decoration.BuiltIn => new BuiltInParameter(),
			Decoration.Stream => new StreamParameter(),
			Decoration.Location => new LocationParameter(),
			Decoration.Component => new ComponentParameter(),
			Decoration.Index => new IndexParameter(),
			Decoration.Binding => new BindingParameter(),
			Decoration.DescriptorSet => new DescriptorSetParameter(),
			Decoration.Offset => new OffsetParameter(),
			Decoration.XfbBuffer => new XfbBufferParameter(),
			Decoration.XfbStride => new XfbStrideParameter(),
			Decoration.FuncParamAttr => new FuncParamAttrParameter(),
			Decoration.FPRoundingMode => new FPRoundingModeParameter(),
			Decoration.FPFastMathMode => new FPFastMathModeParameter(),
			Decoration.LinkageAttributes => new LinkageAttributesParameter(),
			Decoration.InputAttachmentIndex => new InputAttachmentIndexParameter(),
			Decoration.Alignment => new AlignmentParameter(),
			Decoration.MaxByteOffset => new MaxByteOffsetParameter(),
			Decoration.AlignmentId => new AlignmentIdParameter(),
			Decoration.MaxByteOffsetId => new MaxByteOffsetIdParameter(),
			Decoration.SecondaryViewportRelativeNV => new SecondaryViewportRelativeNVParameter(),
			_ => null,
		};
	}
}
public enum BuiltIn : uint
{
	Position = 0,
	PointSize = 1,
	ClipDistance = 3,
	CullDistance = 4,
	VertexId = 5,
	InstanceId = 6,
	PrimitiveId = 7,
	InvocationId = 8,
	Layer = 9,
	ViewportIndex = 10,
	TessLevelOuter = 11,
	TessLevelInner = 12,
	TessCoord = 13,
	PatchVertices = 14,
	FragCoord = 15,
	PointCoord = 16,
	FrontFacing = 17,
	SampleId = 18,
	SamplePosition = 19,
	SampleMask = 20,
	FragDepth = 22,
	HelperInvocation = 23,
	NumWorkgroups = 24,
	WorkgroupSize = 25,
	WorkgroupId = 26,
	LocalInvocationId = 27,
	GlobalInvocationId = 28,
	LocalInvocationIndex = 29,
	WorkDim = 30,
	GlobalSize = 31,
	EnqueuedWorkgroupSize = 32,
	GlobalOffset = 33,
	GlobalLinearId = 34,
	SubgroupSize = 36,
	SubgroupMaxSize = 37,
	NumSubgroups = 38,
	NumEnqueuedSubgroups = 39,
	SubgroupId = 40,
	SubgroupLocalInvocationId = 41,
	VertexIndex = 42,
	InstanceIndex = 43,
	SubgroupEqMaskKHR = 4416,
	SubgroupGeMaskKHR = 4417,
	SubgroupGtMaskKHR = 4418,
	SubgroupLeMaskKHR = 4419,
	SubgroupLtMaskKHR = 4420,
	BaseVertex = 4424,
	BaseInstance = 4425,
	DrawIndex = 4426,
	DeviceIndex = 4438,
	ViewIndex = 4440,
	BaryCoordNoPerspAMD = 4992,
	BaryCoordNoPerspCentroidAMD = 4993,
	BaryCoordNoPerspSampleAMD = 4994,
	BaryCoordSmoothAMD = 4995,
	BaryCoordSmoothCentroidAMD = 4996,
	BaryCoordSmoothSampleAMD = 4997,
	BaryCoordPullModelAMD = 4998,
	FragStencilRefEXT = 5014,
	ViewportMaskNV = 5253,
	SecondaryPositionNV = 5257,
	SecondaryViewportMaskNV = 5258,
	PositionPerViewNV = 5261,
	ViewportMaskPerViewNV = 5262,
}
public class BuiltInParameterFactory : ParameterFactory
{
}
public enum Scope : uint
{
	CrossDevice = 0,
	Device = 1,
	Workgroup = 2,
	Subgroup = 3,
	Invocation = 4,
}
public class ScopeParameterFactory : ParameterFactory
{
}
public enum GroupOperation : uint
{
	Reduce = 0,
	InclusiveScan = 1,
	ExclusiveScan = 2,
}
public class GroupOperationParameterFactory : ParameterFactory
{
}
public enum KernelEnqueueFlags : uint
{
	NoWait = 0,
	WaitKernel = 1,
	WaitWorkGroup = 2,
}
public class KernelEnqueueFlagsParameterFactory : ParameterFactory
{
}
public enum Capability : uint
{
	Matrix = 0,
	Shader = 1,
	Geometry = 2,
	Tessellation = 3,
	Addresses = 4,
	Linkage = 5,
	Kernel = 6,
	Vector16 = 7,
	Float16Buffer = 8,
	Float16 = 9,
	Float64 = 10,
	Int64 = 11,
	Int64Atomics = 12,
	ImageBasic = 13,
	ImageReadWrite = 14,
	ImageMipmap = 15,
	Pipes = 17,
	Groups = 18,
	DeviceEnqueue = 19,
	LiteralSampler = 20,
	AtomicStorage = 21,
	Int16 = 22,
	TessellationPointSize = 23,
	GeometryPointSize = 24,
	ImageGatherExtended = 25,
	StorageImageMultisample = 27,
	UniformBufferArrayDynamicIndexing = 28,
	SampledImageArrayDynamicIndexing = 29,
	StorageBufferArrayDynamicIndexing = 30,
	StorageImageArrayDynamicIndexing = 31,
	ClipDistance = 32,
	CullDistance = 33,
	ImageCubeArray = 34,
	SampleRateShading = 35,
	ImageRect = 36,
	SampledRect = 37,
	GenericPointer = 38,
	Int8 = 39,
	InputAttachment = 40,
	SparseResidency = 41,
	MinLod = 42,
	Sampled1D = 43,
	Image1D = 44,
	SampledCubeArray = 45,
	SampledBuffer = 46,
	ImageBuffer = 47,
	ImageMSArray = 48,
	StorageImageExtendedFormats = 49,
	ImageQuery = 50,
	DerivativeControl = 51,
	InterpolationFunction = 52,
	TransformFeedback = 53,
	GeometryStreams = 54,
	StorageImageReadWithoutFormat = 55,
	StorageImageWriteWithoutFormat = 56,
	MultiViewport = 57,
	SubgroupDispatch = 58,
	NamedBarrier = 59,
	PipeStorage = 60,
	SubgroupBallotKHR = 4423,
	DrawParameters = 4427,
	SubgroupVoteKHR = 4431,
	StorageBuffer16BitAccess = 4433,
	StorageUniformBufferBlock16 = 4433,
	UniformAndStorageBuffer16BitAccess = 4434,
	StorageUniform16 = 4434,
	StoragePushConstant16 = 4435,
	StorageInputOutput16 = 4436,
	DeviceGroup = 4437,
	MultiView = 4439,
	VariablePointersStorageBuffer = 4441,
	VariablePointers = 4442,
	AtomicStorageOps = 4445,
	SampleMaskPostDepthCoverage = 4447,
	ImageGatherBiasLodAMD = 5009,
	FragmentMaskAMD = 5010,
	StencilExportEXT = 5013,
	ImageReadWriteLodAMD = 5015,
	SampleMaskOverrideCoverageNV = 5249,
	GeometryShaderPassthroughNV = 5251,
	ShaderViewportIndexLayerEXT = 5254,
	ShaderViewportIndexLayerNV = 5254,
	ShaderViewportMaskNV = 5255,
	ShaderStereoViewNV = 5259,
	PerViewAttributesNV = 5260,
	SubgroupShuffleINTEL = 5568,
	SubgroupBufferBlockIOINTEL = 5569,
	SubgroupImageBlockIOINTEL = 5570,
}
public class CapabilityParameterFactory : ParameterFactory
{
}
public class OpNop : Instruction
{
	public OpNop() : base("OpNop")
	{
	}
}
public class OpUndef : Instruction
{
	public OpUndef() : base("OpUndef", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpSourceContinued : Instruction
{
	public OpSourceContinued() : base("OpSourceContinued", new List<Operand>()
{new Operand(new LiteralString(), "Continued Source", OperandQuantifier.Default), })
	{
	}
}
public class OpSource : Instruction
{
	public OpSource() : base("OpSource", new List<Operand>()
{new Operand(new EnumType<SourceLanguage, SourceLanguageParameterFactory>(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Version", OperandQuantifier.Default), new Operand(new IdRef(), "File", OperandQuantifier.Optional), new Operand(new LiteralString(), "Source", OperandQuantifier.Optional), })
	{
	}
}
public class OpSourceExtension : Instruction
{
	public OpSourceExtension() : base("OpSourceExtension", new List<Operand>()
{new Operand(new LiteralString(), "Extension", OperandQuantifier.Default), })
	{
	}
}
public class OpName : Instruction
{
	public OpName() : base("OpName", new List<Operand>()
{new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new LiteralString(), "Name", OperandQuantifier.Default), })
	{
	}
}
public class OpMemberName : Instruction
{
	public OpMemberName() : base("OpMemberName", new List<Operand>()
{new Operand(new IdRef(), "Type", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Member", OperandQuantifier.Default), new Operand(new LiteralString(), "Name", OperandQuantifier.Default), })
	{
	}
}
public class OpString : Instruction
{
	public OpString() : base("OpString", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralString(), "String", OperandQuantifier.Default), })
	{
	}
}
public class OpLine : Instruction
{
	public OpLine() : base("OpLine", new List<Operand>()
{new Operand(new IdRef(), "File", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Line", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Column", OperandQuantifier.Default), })
	{
	}
}
public class OpExtension : Instruction
{
	public OpExtension() : base("OpExtension", new List<Operand>()
{new Operand(new LiteralString(), "Name", OperandQuantifier.Default), })
	{
	}
}
public class OpExtInstImport : Instruction
{
	public OpExtInstImport() : base("OpExtInstImport", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralString(), "Name", OperandQuantifier.Default), })
	{
	}
}
public class OpExtInst : Instruction
{
	public OpExtInst() : base("OpExtInst", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Set", OperandQuantifier.Default), new Operand(new LiteralExtInstInteger(), "Instruction", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1, +Operand 2, +...", OperandQuantifier.Varying), })
	{
	}
}
public class OpMemoryModel : Instruction
{
	public OpMemoryModel() : base("OpMemoryModel", new List<Operand>()
{new Operand(new EnumType<AddressingModel, AddressingModelParameterFactory>(), null, OperandQuantifier.Default), new Operand(new EnumType<MemoryModel, MemoryModelParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpEntryPoint : Instruction
{
	public OpEntryPoint() : base("OpEntryPoint", new List<Operand>()
{new Operand(new EnumType<ExecutionModel, ExecutionModelParameterFactory>(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Entry Point", OperandQuantifier.Default), new Operand(new LiteralString(), "Name", OperandQuantifier.Default), new Operand(new IdRef(), "Interface", OperandQuantifier.Varying), })
	{
	}
}
public class OpExecutionMode : Instruction
{
	public OpExecutionMode() : base("OpExecutionMode", new List<Operand>()
{new Operand(new IdRef(), "Entry Point", OperandQuantifier.Default), new Operand(new EnumType<ExecutionMode, ExecutionModeParameterFactory>(), "Mode", OperandQuantifier.Default), })
	{
	}
}
public class OpCapability : Instruction
{
	public OpCapability() : base("OpCapability", new List<Operand>()
{new Operand(new EnumType<Capability, CapabilityParameterFactory>(), "Capability", OperandQuantifier.Default), })
	{
	}
}
public class OpTypeVoid : Instruction
{
	public OpTypeVoid() : base("OpTypeVoid", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpTypeBool : Instruction
{
	public OpTypeBool() : base("OpTypeBool", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpTypeInt : Instruction
{
	public OpTypeInt() : base("OpTypeInt", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Width", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Signedness", OperandQuantifier.Default), })
	{
	}
}
public class OpTypeFloat : Instruction
{
	public OpTypeFloat() : base("OpTypeFloat", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Width", OperandQuantifier.Default), })
	{
	}
}
public class OpTypeVector : Instruction
{
	public OpTypeVector() : base("OpTypeVector", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Component Type", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Component Count", OperandQuantifier.Default), })
	{
	}
}
public class OpTypeMatrix : Instruction
{
	public OpTypeMatrix() : base("OpTypeMatrix", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Column Type", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Column Count", OperandQuantifier.Default), })
	{
	}
}
public class OpTypeImage : Instruction
{
	public OpTypeImage() : base("OpTypeImage", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Type", OperandQuantifier.Default), new Operand(new EnumType<Dim, DimParameterFactory>(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Depth", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Arrayed", OperandQuantifier.Default), new Operand(new LiteralInteger(), "MS", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Sampled", OperandQuantifier.Default), new Operand(new EnumType<ImageFormat, ImageFormatParameterFactory>(), null, OperandQuantifier.Default), new Operand(new EnumType<AccessQualifier, AccessQualifierParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpTypeSampler : Instruction
{
	public OpTypeSampler() : base("OpTypeSampler", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpTypeSampledImage : Instruction
{
	public OpTypeSampledImage() : base("OpTypeSampledImage", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image Type", OperandQuantifier.Default), })
	{
	}
}
public class OpTypeArray : Instruction
{
	public OpTypeArray() : base("OpTypeArray", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Element Type", OperandQuantifier.Default), new Operand(new IdRef(), "Length", OperandQuantifier.Default), })
	{
	}
}
public class OpTypeRuntimeArray : Instruction
{
	public OpTypeRuntimeArray() : base("OpTypeRuntimeArray", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Element Type", OperandQuantifier.Default), })
	{
	}
}
public class OpTypeStruct : Instruction
{
	public OpTypeStruct() : base("OpTypeStruct", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Member 0 type, +member 1 type, +...", OperandQuantifier.Varying), })
	{
	}
}
public class OpTypeOpaque : Instruction
{
	public OpTypeOpaque() : base("OpTypeOpaque", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralString(), "The name of the opaque type.", OperandQuantifier.Default), })
	{
	}
}
public class OpTypePointer : Instruction
{
	public OpTypePointer() : base("OpTypePointer", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<StorageClass, StorageClassParameterFactory>(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Type", OperandQuantifier.Default), })
	{
	}
}
public class OpTypeFunction : Instruction
{
	public OpTypeFunction() : base("OpTypeFunction", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Return Type", OperandQuantifier.Default), new Operand(new IdRef(), "Parameter 0 Type, +Parameter 1 Type, +...", OperandQuantifier.Varying), })
	{
	}
}
public class OpTypeEvent : Instruction
{
	public OpTypeEvent() : base("OpTypeEvent", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpTypeDeviceEvent : Instruction
{
	public OpTypeDeviceEvent() : base("OpTypeDeviceEvent", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpTypeReserveId : Instruction
{
	public OpTypeReserveId() : base("OpTypeReserveId", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpTypeQueue : Instruction
{
	public OpTypeQueue() : base("OpTypeQueue", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpTypePipe : Instruction
{
	public OpTypePipe() : base("OpTypePipe", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<AccessQualifier, AccessQualifierParameterFactory>(), "Qualifier", OperandQuantifier.Default), })
	{
	}
}
public class OpTypeForwardPointer : Instruction
{
	public OpTypeForwardPointer() : base("OpTypeForwardPointer", new List<Operand>()
{new Operand(new IdRef(), "Pointer Type", OperandQuantifier.Default), new Operand(new EnumType<StorageClass, StorageClassParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpConstantTrue : Instruction
{
	public OpConstantTrue() : base("OpConstantTrue", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpConstantFalse : Instruction
{
	public OpConstantFalse() : base("OpConstantFalse", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpConstant : Instruction
{
	public OpConstant() : base("OpConstant", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralContextDependentNumber(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpConstantComposite : Instruction
{
	public OpConstantComposite() : base("OpConstantComposite", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Constituents", OperandQuantifier.Varying), })
	{
	}
}
public class OpConstantSampler : Instruction
{
	public OpConstantSampler() : base("OpConstantSampler", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<SamplerAddressingMode, SamplerAddressingModeParameterFactory>(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Param", OperandQuantifier.Default), new Operand(new EnumType<SamplerFilterMode, SamplerFilterModeParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpConstantNull : Instruction
{
	public OpConstantNull() : base("OpConstantNull", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpSpecConstantTrue : Instruction
{
	public OpSpecConstantTrue() : base("OpSpecConstantTrue", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpSpecConstantFalse : Instruction
{
	public OpSpecConstantFalse() : base("OpSpecConstantFalse", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpSpecConstant : Instruction
{
	public OpSpecConstant() : base("OpSpecConstant", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralContextDependentNumber(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpSpecConstantComposite : Instruction
{
	public OpSpecConstantComposite() : base("OpSpecConstantComposite", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Constituents", OperandQuantifier.Varying), })
	{
	}
}
public class OpSpecConstantOp : Instruction
{
	public OpSpecConstantOp() : base("OpSpecConstantOp", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralSpecConstantOpInteger(), "Opcode", OperandQuantifier.Default), })
	{
	}
}
public class OpFunction : Instruction
{
	public OpFunction() : base("OpFunction", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<FunctionControl, FunctionControlParameterFactory>(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Function Type", OperandQuantifier.Default), })
	{
	}
}
public class OpFunctionParameter : Instruction
{
	public OpFunctionParameter() : base("OpFunctionParameter", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpFunctionEnd : Instruction
{
	public OpFunctionEnd() : base("OpFunctionEnd")
	{
	}
}
public class OpFunctionCall : Instruction
{
	public OpFunctionCall() : base("OpFunctionCall", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Function", OperandQuantifier.Default), new Operand(new IdRef(), "Argument 0, +Argument 1, +...", OperandQuantifier.Varying), })
	{
	}
}
public class OpVariable : Instruction
{
	public OpVariable() : base("OpVariable", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<StorageClass, StorageClassParameterFactory>(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Initializer", OperandQuantifier.Optional), })
	{
	}
}
public class OpImageTexelPointer : Instruction
{
	public OpImageTexelPointer() : base("OpImageTexelPointer", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Sample", OperandQuantifier.Default), })
	{
	}
}
public class OpLoad : Instruction
{
	public OpLoad() : base("OpLoad", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new EnumType<MemoryAccess, MemoryAccessParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpStore : Instruction
{
	public OpStore() : base("OpStore", new List<Operand>()
{new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Object", OperandQuantifier.Default), new Operand(new EnumType<MemoryAccess, MemoryAccessParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpCopyMemory : Instruction
{
	public OpCopyMemory() : base("OpCopyMemory", new List<Operand>()
{new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new IdRef(), "Source", OperandQuantifier.Default), new Operand(new EnumType<MemoryAccess, MemoryAccessParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpCopyMemorySized : Instruction
{
	public OpCopyMemorySized() : base("OpCopyMemorySized", new List<Operand>()
{new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new IdRef(), "Source", OperandQuantifier.Default), new Operand(new IdRef(), "Size", OperandQuantifier.Default), new Operand(new EnumType<MemoryAccess, MemoryAccessParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpAccessChain : Instruction
{
	public OpAccessChain() : base("OpAccessChain", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Indexes", OperandQuantifier.Varying), })
	{
	}
}
public class OpInBoundsAccessChain : Instruction
{
	public OpInBoundsAccessChain() : base("OpInBoundsAccessChain", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Indexes", OperandQuantifier.Varying), })
	{
	}
}
public class OpPtrAccessChain : Instruction
{
	public OpPtrAccessChain() : base("OpPtrAccessChain", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Element", OperandQuantifier.Default), new Operand(new IdRef(), "Indexes", OperandQuantifier.Varying), })
	{
	}
}
public class OpArrayLength : Instruction
{
	public OpArrayLength() : base("OpArrayLength", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Structure", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Array member", OperandQuantifier.Default), })
	{
	}
}
public class OpGenericPtrMemSemantics : Instruction
{
	public OpGenericPtrMemSemantics() : base("OpGenericPtrMemSemantics", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
	{
	}
}
public class OpInBoundsPtrAccessChain : Instruction
{
	public OpInBoundsPtrAccessChain() : base("OpInBoundsPtrAccessChain", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Element", OperandQuantifier.Default), new Operand(new IdRef(), "Indexes", OperandQuantifier.Varying), })
	{
	}
}
public class OpDecorate : Instruction
{
	public OpDecorate() : base("OpDecorate", new List<Operand>()
{new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new EnumType<Decoration, DecorationParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpMemberDecorate : Instruction
{
	public OpMemberDecorate() : base("OpMemberDecorate", new List<Operand>()
{new Operand(new IdRef(), "Structure Type", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Member", OperandQuantifier.Default), new Operand(new EnumType<Decoration, DecorationParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpDecorationGroup : Instruction
{
	public OpDecorationGroup() : base("OpDecorationGroup", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpGroupDecorate : Instruction
{
	public OpGroupDecorate() : base("OpGroupDecorate", new List<Operand>()
{new Operand(new IdRef(), "Decoration Group", OperandQuantifier.Default), new Operand(new IdRef(), "Targets", OperandQuantifier.Varying), })
	{
	}
}
public class OpGroupMemberDecorate : Instruction
{
	public OpGroupMemberDecorate() : base("OpGroupMemberDecorate", new List<Operand>()
{new Operand(new IdRef(), "Decoration Group", OperandQuantifier.Default), new Operand(new PairIdRefLiteralInteger(), "Targets", OperandQuantifier.Varying), })
	{
	}
}
public class OpVectorExtractDynamic : Instruction
{
	public OpVectorExtractDynamic() : base("OpVectorExtractDynamic", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), })
	{
	}
}
public class OpVectorInsertDynamic : Instruction
{
	public OpVectorInsertDynamic() : base("OpVectorInsertDynamic", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), new Operand(new IdRef(), "Component", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), })
	{
	}
}
public class OpVectorShuffle : Instruction
{
	public OpVectorShuffle() : base("OpVectorShuffle", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector 1", OperandQuantifier.Default), new Operand(new IdRef(), "Vector 2", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Components", OperandQuantifier.Varying), })
	{
	}
}
public class OpCompositeConstruct : Instruction
{
	public OpCompositeConstruct() : base("OpCompositeConstruct", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Constituents", OperandQuantifier.Varying), })
	{
	}
}
public class OpCompositeExtract : Instruction
{
	public OpCompositeExtract() : base("OpCompositeExtract", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Composite", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Indexes", OperandQuantifier.Varying), })
	{
	}
}
public class OpCompositeInsert : Instruction
{
	public OpCompositeInsert() : base("OpCompositeInsert", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Object", OperandQuantifier.Default), new Operand(new IdRef(), "Composite", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Indexes", OperandQuantifier.Varying), })
	{
	}
}
public class OpCopyObject : Instruction
{
	public OpCopyObject() : base("OpCopyObject", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
	{
	}
}
public class OpTranspose : Instruction
{
	public OpTranspose() : base("OpTranspose", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Matrix", OperandQuantifier.Default), })
	{
	}
}
public class OpSampledImage : Instruction
{
	public OpSampledImage() : base("OpSampledImage", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Sampler", OperandQuantifier.Default), })
	{
	}
}
public class OpImageSampleImplicitLod : Instruction
{
	public OpImageSampleImplicitLod() : base("OpImageSampleImplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageSampleExplicitLod : Instruction
{
	public OpImageSampleExplicitLod() : base("OpImageSampleExplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpImageSampleDrefImplicitLod : Instruction
{
	public OpImageSampleDrefImplicitLod() : base("OpImageSampleDrefImplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageSampleDrefExplicitLod : Instruction
{
	public OpImageSampleDrefExplicitLod() : base("OpImageSampleDrefExplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpImageSampleProjImplicitLod : Instruction
{
	public OpImageSampleProjImplicitLod() : base("OpImageSampleProjImplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageSampleProjExplicitLod : Instruction
{
	public OpImageSampleProjExplicitLod() : base("OpImageSampleProjExplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpImageSampleProjDrefImplicitLod : Instruction
{
	public OpImageSampleProjDrefImplicitLod() : base("OpImageSampleProjDrefImplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageSampleProjDrefExplicitLod : Instruction
{
	public OpImageSampleProjDrefExplicitLod() : base("OpImageSampleProjDrefExplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpImageFetch : Instruction
{
	public OpImageFetch() : base("OpImageFetch", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageGather : Instruction
{
	public OpImageGather() : base("OpImageGather", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Component", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageDrefGather : Instruction
{
	public OpImageDrefGather() : base("OpImageDrefGather", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageRead : Instruction
{
	public OpImageRead() : base("OpImageRead", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageWrite : Instruction
{
	public OpImageWrite() : base("OpImageWrite", new List<Operand>()
{new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Texel", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImage : Instruction
{
	public OpImage() : base("OpImage", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), })
	{
	}
}
public class OpImageQueryFormat : Instruction
{
	public OpImageQueryFormat() : base("OpImageQueryFormat", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
	{
	}
}
public class OpImageQueryOrder : Instruction
{
	public OpImageQueryOrder() : base("OpImageQueryOrder", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
	{
	}
}
public class OpImageQuerySizeLod : Instruction
{
	public OpImageQuerySizeLod() : base("OpImageQuerySizeLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Level of Detail", OperandQuantifier.Default), })
	{
	}
}
public class OpImageQuerySize : Instruction
{
	public OpImageQuerySize() : base("OpImageQuerySize", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
	{
	}
}
public class OpImageQueryLod : Instruction
{
	public OpImageQueryLod() : base("OpImageQueryLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), })
	{
	}
}
public class OpImageQueryLevels : Instruction
{
	public OpImageQueryLevels() : base("OpImageQueryLevels", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
	{
	}
}
public class OpImageQuerySamples : Instruction
{
	public OpImageQuerySamples() : base("OpImageQuerySamples", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
	{
	}
}
public class OpConvertFToU : Instruction
{
	public OpConvertFToU() : base("OpConvertFToU", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Float Value", OperandQuantifier.Default), })
	{
	}
}
public class OpConvertFToS : Instruction
{
	public OpConvertFToS() : base("OpConvertFToS", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Float Value", OperandQuantifier.Default), })
	{
	}
}
public class OpConvertSToF : Instruction
{
	public OpConvertSToF() : base("OpConvertSToF", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Signed Value", OperandQuantifier.Default), })
	{
	}
}
public class OpConvertUToF : Instruction
{
	public OpConvertUToF() : base("OpConvertUToF", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Unsigned Value", OperandQuantifier.Default), })
	{
	}
}
public class OpUConvert : Instruction
{
	public OpUConvert() : base("OpUConvert", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Unsigned Value", OperandQuantifier.Default), })
	{
	}
}
public class OpSConvert : Instruction
{
	public OpSConvert() : base("OpSConvert", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Signed Value", OperandQuantifier.Default), })
	{
	}
}
public class OpFConvert : Instruction
{
	public OpFConvert() : base("OpFConvert", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Float Value", OperandQuantifier.Default), })
	{
	}
}
public class OpQuantizeToF16 : Instruction
{
	public OpQuantizeToF16() : base("OpQuantizeToF16", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpConvertPtrToU : Instruction
{
	public OpConvertPtrToU() : base("OpConvertPtrToU", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
	{
	}
}
public class OpSatConvertSToU : Instruction
{
	public OpSatConvertSToU() : base("OpSatConvertSToU", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Signed Value", OperandQuantifier.Default), })
	{
	}
}
public class OpSatConvertUToS : Instruction
{
	public OpSatConvertUToS() : base("OpSatConvertUToS", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Unsigned Value", OperandQuantifier.Default), })
	{
	}
}
public class OpConvertUToPtr : Instruction
{
	public OpConvertUToPtr() : base("OpConvertUToPtr", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Integer Value", OperandQuantifier.Default), })
	{
	}
}
public class OpPtrCastToGeneric : Instruction
{
	public OpPtrCastToGeneric() : base("OpPtrCastToGeneric", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
	{
	}
}
public class OpGenericCastToPtr : Instruction
{
	public OpGenericCastToPtr() : base("OpGenericCastToPtr", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
	{
	}
}
public class OpGenericCastToPtrExplicit : Instruction
{
	public OpGenericCastToPtrExplicit() : base("OpGenericCastToPtrExplicit", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new EnumType<StorageClass, StorageClassParameterFactory>(), "Storage", OperandQuantifier.Default), })
	{
	}
}
public class OpBitcast : Instruction
{
	public OpBitcast() : base("OpBitcast", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
	{
	}
}
public class OpSNegate : Instruction
{
	public OpSNegate() : base("OpSNegate", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
	{
	}
}
public class OpFNegate : Instruction
{
	public OpFNegate() : base("OpFNegate", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
	{
	}
}
public class OpIAdd : Instruction
{
	public OpIAdd() : base("OpIAdd", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFAdd : Instruction
{
	public OpFAdd() : base("OpFAdd", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpISub : Instruction
{
	public OpISub() : base("OpISub", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFSub : Instruction
{
	public OpFSub() : base("OpFSub", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpIMul : Instruction
{
	public OpIMul() : base("OpIMul", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFMul : Instruction
{
	public OpFMul() : base("OpFMul", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpUDiv : Instruction
{
	public OpUDiv() : base("OpUDiv", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpSDiv : Instruction
{
	public OpSDiv() : base("OpSDiv", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFDiv : Instruction
{
	public OpFDiv() : base("OpFDiv", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpUMod : Instruction
{
	public OpUMod() : base("OpUMod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpSRem : Instruction
{
	public OpSRem() : base("OpSRem", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpSMod : Instruction
{
	public OpSMod() : base("OpSMod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFRem : Instruction
{
	public OpFRem() : base("OpFRem", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFMod : Instruction
{
	public OpFMod() : base("OpFMod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpVectorTimesScalar : Instruction
{
	public OpVectorTimesScalar() : base("OpVectorTimesScalar", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), new Operand(new IdRef(), "Scalar", OperandQuantifier.Default), })
	{
	}
}
public class OpMatrixTimesScalar : Instruction
{
	public OpMatrixTimesScalar() : base("OpMatrixTimesScalar", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Matrix", OperandQuantifier.Default), new Operand(new IdRef(), "Scalar", OperandQuantifier.Default), })
	{
	}
}
public class OpVectorTimesMatrix : Instruction
{
	public OpVectorTimesMatrix() : base("OpVectorTimesMatrix", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), new Operand(new IdRef(), "Matrix", OperandQuantifier.Default), })
	{
	}
}
public class OpMatrixTimesVector : Instruction
{
	public OpMatrixTimesVector() : base("OpMatrixTimesVector", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Matrix", OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), })
	{
	}
}
public class OpMatrixTimesMatrix : Instruction
{
	public OpMatrixTimesMatrix() : base("OpMatrixTimesMatrix", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "LeftMatrix", OperandQuantifier.Default), new Operand(new IdRef(), "RightMatrix", OperandQuantifier.Default), })
	{
	}
}
public class OpOuterProduct : Instruction
{
	public OpOuterProduct() : base("OpOuterProduct", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector 1", OperandQuantifier.Default), new Operand(new IdRef(), "Vector 2", OperandQuantifier.Default), })
	{
	}
}
public class OpDot : Instruction
{
	public OpDot() : base("OpDot", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector 1", OperandQuantifier.Default), new Operand(new IdRef(), "Vector 2", OperandQuantifier.Default), })
	{
	}
}
public class OpIAddCarry : Instruction
{
	public OpIAddCarry() : base("OpIAddCarry", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpISubBorrow : Instruction
{
	public OpISubBorrow() : base("OpISubBorrow", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpUMulExtended : Instruction
{
	public OpUMulExtended() : base("OpUMulExtended", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpSMulExtended : Instruction
{
	public OpSMulExtended() : base("OpSMulExtended", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpAny : Instruction
{
	public OpAny() : base("OpAny", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), })
	{
	}
}
public class OpAll : Instruction
{
	public OpAll() : base("OpAll", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), })
	{
	}
}
public class OpIsNan : Instruction
{
	public OpIsNan() : base("OpIsNan", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
	{
	}
}
public class OpIsInf : Instruction
{
	public OpIsInf() : base("OpIsInf", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
	{
	}
}
public class OpIsFinite : Instruction
{
	public OpIsFinite() : base("OpIsFinite", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
	{
	}
}
public class OpIsNormal : Instruction
{
	public OpIsNormal() : base("OpIsNormal", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
	{
	}
}
public class OpSignBitSet : Instruction
{
	public OpSignBitSet() : base("OpSignBitSet", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
	{
	}
}
public class OpLessOrGreater : Instruction
{
	public OpLessOrGreater() : base("OpLessOrGreater", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), new Operand(new IdRef(), "y", OperandQuantifier.Default), })
	{
	}
}
public class OpOrdered : Instruction
{
	public OpOrdered() : base("OpOrdered", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), new Operand(new IdRef(), "y", OperandQuantifier.Default), })
	{
	}
}
public class OpUnordered : Instruction
{
	public OpUnordered() : base("OpUnordered", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), new Operand(new IdRef(), "y", OperandQuantifier.Default), })
	{
	}
}
public class OpLogicalEqual : Instruction
{
	public OpLogicalEqual() : base("OpLogicalEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpLogicalNotEqual : Instruction
{
	public OpLogicalNotEqual() : base("OpLogicalNotEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpLogicalOr : Instruction
{
	public OpLogicalOr() : base("OpLogicalOr", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpLogicalAnd : Instruction
{
	public OpLogicalAnd() : base("OpLogicalAnd", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpLogicalNot : Instruction
{
	public OpLogicalNot() : base("OpLogicalNot", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
	{
	}
}
public class OpSelect : Instruction
{
	public OpSelect() : base("OpSelect", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Condition", OperandQuantifier.Default), new Operand(new IdRef(), "Object 1", OperandQuantifier.Default), new Operand(new IdRef(), "Object 2", OperandQuantifier.Default), })
	{
	}
}
public class OpIEqual : Instruction
{
	public OpIEqual() : base("OpIEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpINotEqual : Instruction
{
	public OpINotEqual() : base("OpINotEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpUGreaterThan : Instruction
{
	public OpUGreaterThan() : base("OpUGreaterThan", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpSGreaterThan : Instruction
{
	public OpSGreaterThan() : base("OpSGreaterThan", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpUGreaterThanEqual : Instruction
{
	public OpUGreaterThanEqual() : base("OpUGreaterThanEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpSGreaterThanEqual : Instruction
{
	public OpSGreaterThanEqual() : base("OpSGreaterThanEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpULessThan : Instruction
{
	public OpULessThan() : base("OpULessThan", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpSLessThan : Instruction
{
	public OpSLessThan() : base("OpSLessThan", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpULessThanEqual : Instruction
{
	public OpULessThanEqual() : base("OpULessThanEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpSLessThanEqual : Instruction
{
	public OpSLessThanEqual() : base("OpSLessThanEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFOrdEqual : Instruction
{
	public OpFOrdEqual() : base("OpFOrdEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFUnordEqual : Instruction
{
	public OpFUnordEqual() : base("OpFUnordEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFOrdNotEqual : Instruction
{
	public OpFOrdNotEqual() : base("OpFOrdNotEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFUnordNotEqual : Instruction
{
	public OpFUnordNotEqual() : base("OpFUnordNotEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFOrdLessThan : Instruction
{
	public OpFOrdLessThan() : base("OpFOrdLessThan", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFUnordLessThan : Instruction
{
	public OpFUnordLessThan() : base("OpFUnordLessThan", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFOrdGreaterThan : Instruction
{
	public OpFOrdGreaterThan() : base("OpFOrdGreaterThan", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFUnordGreaterThan : Instruction
{
	public OpFUnordGreaterThan() : base("OpFUnordGreaterThan", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFOrdLessThanEqual : Instruction
{
	public OpFOrdLessThanEqual() : base("OpFOrdLessThanEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFUnordLessThanEqual : Instruction
{
	public OpFUnordLessThanEqual() : base("OpFUnordLessThanEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFOrdGreaterThanEqual : Instruction
{
	public OpFOrdGreaterThanEqual() : base("OpFOrdGreaterThanEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpFUnordGreaterThanEqual : Instruction
{
	public OpFUnordGreaterThanEqual() : base("OpFUnordGreaterThanEqual", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpShiftRightLogical : Instruction
{
	public OpShiftRightLogical() : base("OpShiftRightLogical", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Shift", OperandQuantifier.Default), })
	{
	}
}
public class OpShiftRightArithmetic : Instruction
{
	public OpShiftRightArithmetic() : base("OpShiftRightArithmetic", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Shift", OperandQuantifier.Default), })
	{
	}
}
public class OpShiftLeftLogical : Instruction
{
	public OpShiftLeftLogical() : base("OpShiftLeftLogical", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Shift", OperandQuantifier.Default), })
	{
	}
}
public class OpBitwiseOr : Instruction
{
	public OpBitwiseOr() : base("OpBitwiseOr", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpBitwiseXor : Instruction
{
	public OpBitwiseXor() : base("OpBitwiseXor", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpBitwiseAnd : Instruction
{
	public OpBitwiseAnd() : base("OpBitwiseAnd", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
	{
	}
}
public class OpNot : Instruction
{
	public OpNot() : base("OpNot", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
	{
	}
}
public class OpBitFieldInsert : Instruction
{
	public OpBitFieldInsert() : base("OpBitFieldInsert", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Insert", OperandQuantifier.Default), new Operand(new IdRef(), "Offset", OperandQuantifier.Default), new Operand(new IdRef(), "Count", OperandQuantifier.Default), })
	{
	}
}
public class OpBitFieldSExtract : Instruction
{
	public OpBitFieldSExtract() : base("OpBitFieldSExtract", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Offset", OperandQuantifier.Default), new Operand(new IdRef(), "Count", OperandQuantifier.Default), })
	{
	}
}
public class OpBitFieldUExtract : Instruction
{
	public OpBitFieldUExtract() : base("OpBitFieldUExtract", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Offset", OperandQuantifier.Default), new Operand(new IdRef(), "Count", OperandQuantifier.Default), })
	{
	}
}
public class OpBitReverse : Instruction
{
	public OpBitReverse() : base("OpBitReverse", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), })
	{
	}
}
public class OpBitCount : Instruction
{
	public OpBitCount() : base("OpBitCount", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), })
	{
	}
}
public class OpDPdx : Instruction
{
	public OpDPdx() : base("OpDPdx", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
	{
	}
}
public class OpDPdy : Instruction
{
	public OpDPdy() : base("OpDPdy", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
	{
	}
}
public class OpFwidth : Instruction
{
	public OpFwidth() : base("OpFwidth", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
	{
	}
}
public class OpDPdxFine : Instruction
{
	public OpDPdxFine() : base("OpDPdxFine", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
	{
	}
}
public class OpDPdyFine : Instruction
{
	public OpDPdyFine() : base("OpDPdyFine", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
	{
	}
}
public class OpFwidthFine : Instruction
{
	public OpFwidthFine() : base("OpFwidthFine", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
	{
	}
}
public class OpDPdxCoarse : Instruction
{
	public OpDPdxCoarse() : base("OpDPdxCoarse", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
	{
	}
}
public class OpDPdyCoarse : Instruction
{
	public OpDPdyCoarse() : base("OpDPdyCoarse", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
	{
	}
}
public class OpFwidthCoarse : Instruction
{
	public OpFwidthCoarse() : base("OpFwidthCoarse", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
	{
	}
}
public class OpEmitVertex : Instruction
{
	public OpEmitVertex() : base("OpEmitVertex")
	{
	}
}
public class OpEndPrimitive : Instruction
{
	public OpEndPrimitive() : base("OpEndPrimitive")
	{
	}
}
public class OpEmitStreamVertex : Instruction
{
	public OpEmitStreamVertex() : base("OpEmitStreamVertex", new List<Operand>()
{new Operand(new IdRef(), "Stream", OperandQuantifier.Default), })
	{
	}
}
public class OpEndStreamPrimitive : Instruction
{
	public OpEndStreamPrimitive() : base("OpEndStreamPrimitive", new List<Operand>()
{new Operand(new IdRef(), "Stream", OperandQuantifier.Default), })
	{
	}
}
public class OpControlBarrier : Instruction
{
	public OpControlBarrier() : base("OpControlBarrier", new List<Operand>()
{new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdScope(), "Memory", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
	{
	}
}
public class OpMemoryBarrier : Instruction
{
	public OpMemoryBarrier() : base("OpMemoryBarrier", new List<Operand>()
{new Operand(new IdScope(), "Memory", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicLoad : Instruction
{
	public OpAtomicLoad() : base("OpAtomicLoad", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicStore : Instruction
{
	public OpAtomicStore() : base("OpAtomicStore", new List<Operand>()
{new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicExchange : Instruction
{
	public OpAtomicExchange() : base("OpAtomicExchange", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicCompareExchange : Instruction
{
	public OpAtomicCompareExchange() : base("OpAtomicCompareExchange", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Equal", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Unequal", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), new Operand(new IdRef(), "Comparator", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicCompareExchangeWeak : Instruction
{
	public OpAtomicCompareExchangeWeak() : base("OpAtomicCompareExchangeWeak", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Equal", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Unequal", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), new Operand(new IdRef(), "Comparator", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicIIncrement : Instruction
{
	public OpAtomicIIncrement() : base("OpAtomicIIncrement", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicIDecrement : Instruction
{
	public OpAtomicIDecrement() : base("OpAtomicIDecrement", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicIAdd : Instruction
{
	public OpAtomicIAdd() : base("OpAtomicIAdd", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicISub : Instruction
{
	public OpAtomicISub() : base("OpAtomicISub", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicSMin : Instruction
{
	public OpAtomicSMin() : base("OpAtomicSMin", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicUMin : Instruction
{
	public OpAtomicUMin() : base("OpAtomicUMin", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicSMax : Instruction
{
	public OpAtomicSMax() : base("OpAtomicSMax", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicUMax : Instruction
{
	public OpAtomicUMax() : base("OpAtomicUMax", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicAnd : Instruction
{
	public OpAtomicAnd() : base("OpAtomicAnd", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicOr : Instruction
{
	public OpAtomicOr() : base("OpAtomicOr", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicXor : Instruction
{
	public OpAtomicXor() : base("OpAtomicXor", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpPhi : Instruction
{
	public OpPhi() : base("OpPhi", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new PairIdRefIdRef(), "Variable, Parent, ...", OperandQuantifier.Varying), })
	{
	}
}
public class OpLoopMerge : Instruction
{
	public OpLoopMerge() : base("OpLoopMerge", new List<Operand>()
{new Operand(new IdRef(), "Merge Block", OperandQuantifier.Default), new Operand(new IdRef(), "Continue Target", OperandQuantifier.Default), new Operand(new EnumType<LoopControl, LoopControlParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpSelectionMerge : Instruction
{
	public OpSelectionMerge() : base("OpSelectionMerge", new List<Operand>()
{new Operand(new IdRef(), "Merge Block", OperandQuantifier.Default), new Operand(new EnumType<SelectionControl, SelectionControlParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpLabel : Instruction
{
	public OpLabel() : base("OpLabel", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpBranch : Instruction
{
	public OpBranch() : base("OpBranch", new List<Operand>()
{new Operand(new IdRef(), "Target Label", OperandQuantifier.Default), })
	{
	}
}
public class OpBranchConditional : Instruction
{
	public OpBranchConditional() : base("OpBranchConditional", new List<Operand>()
{new Operand(new IdRef(), "Condition", OperandQuantifier.Default), new Operand(new IdRef(), "True Label", OperandQuantifier.Default), new Operand(new IdRef(), "False Label", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Branch weights", OperandQuantifier.Varying), })
	{
	}
}
public class OpSwitch : Instruction
{
	public OpSwitch() : base("OpSwitch", new List<Operand>()
{new Operand(new IdRef(), "Selector", OperandQuantifier.Default), new Operand(new IdRef(), "Default", OperandQuantifier.Default), new Operand(new PairLiteralIntegerIdRef(), "Target", OperandQuantifier.Varying), })
	{
	}
}
public class OpKill : Instruction
{
	public OpKill() : base("OpKill")
	{
	}
}
public class OpReturn : Instruction
{
	public OpReturn() : base("OpReturn")
	{
	}
}
public class OpReturnValue : Instruction
{
	public OpReturnValue() : base("OpReturnValue", new List<Operand>()
{new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpUnreachable : Instruction
{
	public OpUnreachable() : base("OpUnreachable")
	{
	}
}
public class OpLifetimeStart : Instruction
{
	public OpLifetimeStart() : base("OpLifetimeStart", new List<Operand>()
{new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Size", OperandQuantifier.Default), })
	{
	}
}
public class OpLifetimeStop : Instruction
{
	public OpLifetimeStop() : base("OpLifetimeStop", new List<Operand>()
{new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Size", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupAsyncCopy : Instruction
{
	public OpGroupAsyncCopy() : base("OpGroupAsyncCopy", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Destination", OperandQuantifier.Default), new Operand(new IdRef(), "Source", OperandQuantifier.Default), new Operand(new IdRef(), "Num Elements", OperandQuantifier.Default), new Operand(new IdRef(), "Stride", OperandQuantifier.Default), new Operand(new IdRef(), "Event", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupWaitEvents : Instruction
{
	public OpGroupWaitEvents() : base("OpGroupWaitEvents", new List<Operand>()
{new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Num Events", OperandQuantifier.Default), new Operand(new IdRef(), "Events List", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupAll : Instruction
{
	public OpGroupAll() : base("OpGroupAll", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupAny : Instruction
{
	public OpGroupAny() : base("OpGroupAny", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupBroadcast : Instruction
{
	public OpGroupBroadcast() : base("OpGroupBroadcast", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), new Operand(new IdRef(), "LocalId", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupIAdd : Instruction
{
	public OpGroupIAdd() : base("OpGroupIAdd", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupFAdd : Instruction
{
	public OpGroupFAdd() : base("OpGroupFAdd", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupFMin : Instruction
{
	public OpGroupFMin() : base("OpGroupFMin", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupUMin : Instruction
{
	public OpGroupUMin() : base("OpGroupUMin", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupSMin : Instruction
{
	public OpGroupSMin() : base("OpGroupSMin", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupFMax : Instruction
{
	public OpGroupFMax() : base("OpGroupFMax", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupUMax : Instruction
{
	public OpGroupUMax() : base("OpGroupUMax", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupSMax : Instruction
{
	public OpGroupSMax() : base("OpGroupSMax", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpReadPipe : Instruction
{
	public OpReadPipe() : base("OpReadPipe", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpWritePipe : Instruction
{
	public OpWritePipe() : base("OpWritePipe", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpReservedReadPipe : Instruction
{
	public OpReservedReadPipe() : base("OpReservedReadPipe", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpReservedWritePipe : Instruction
{
	public OpReservedWritePipe() : base("OpReservedWritePipe", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpReserveReadPipePackets : Instruction
{
	public OpReserveReadPipePackets() : base("OpReserveReadPipePackets", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Num Packets", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpReserveWritePipePackets : Instruction
{
	public OpReserveWritePipePackets() : base("OpReserveWritePipePackets", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Num Packets", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpCommitReadPipe : Instruction
{
	public OpCommitReadPipe() : base("OpCommitReadPipe", new List<Operand>()
{new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpCommitWritePipe : Instruction
{
	public OpCommitWritePipe() : base("OpCommitWritePipe", new List<Operand>()
{new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpIsValidReserveId : Instruction
{
	public OpIsValidReserveId() : base("OpIsValidReserveId", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), })
	{
	}
}
public class OpGetNumPipePackets : Instruction
{
	public OpGetNumPipePackets() : base("OpGetNumPipePackets", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpGetMaxPipePackets : Instruction
{
	public OpGetMaxPipePackets() : base("OpGetMaxPipePackets", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupReserveReadPipePackets : Instruction
{
	public OpGroupReserveReadPipePackets() : base("OpGroupReserveReadPipePackets", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Num Packets", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupReserveWritePipePackets : Instruction
{
	public OpGroupReserveWritePipePackets() : base("OpGroupReserveWritePipePackets", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Num Packets", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupCommitReadPipe : Instruction
{
	public OpGroupCommitReadPipe() : base("OpGroupCommitReadPipe", new List<Operand>()
{new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupCommitWritePipe : Instruction
{
	public OpGroupCommitWritePipe() : base("OpGroupCommitWritePipe", new List<Operand>()
{new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
	{
	}
}
public class OpEnqueueMarker : Instruction
{
	public OpEnqueueMarker() : base("OpEnqueueMarker", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Queue", OperandQuantifier.Default), new Operand(new IdRef(), "Num Events", OperandQuantifier.Default), new Operand(new IdRef(), "Wait Events", OperandQuantifier.Default), new Operand(new IdRef(), "Ret Event", OperandQuantifier.Default), })
	{
	}
}
public class OpEnqueueKernel : Instruction
{
	public OpEnqueueKernel() : base("OpEnqueueKernel", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Queue", OperandQuantifier.Default), new Operand(new IdRef(), "Flags", OperandQuantifier.Default), new Operand(new IdRef(), "ND Range", OperandQuantifier.Default), new Operand(new IdRef(), "Num Events", OperandQuantifier.Default), new Operand(new IdRef(), "Wait Events", OperandQuantifier.Default), new Operand(new IdRef(), "Ret Event", OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), new Operand(new IdRef(), "Local Size", OperandQuantifier.Varying), })
	{
	}
}
public class OpGetKernelNDrangeSubGroupCount : Instruction
{
	public OpGetKernelNDrangeSubGroupCount() : base("OpGetKernelNDrangeSubGroupCount", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "ND Range", OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
	{
	}
}
public class OpGetKernelNDrangeMaxSubGroupSize : Instruction
{
	public OpGetKernelNDrangeMaxSubGroupSize() : base("OpGetKernelNDrangeMaxSubGroupSize", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "ND Range", OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
	{
	}
}
public class OpGetKernelWorkGroupSize : Instruction
{
	public OpGetKernelWorkGroupSize() : base("OpGetKernelWorkGroupSize", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
	{
	}
}
public class OpGetKernelPreferredWorkGroupSizeMultiple : Instruction
{
	public OpGetKernelPreferredWorkGroupSizeMultiple() : base("OpGetKernelPreferredWorkGroupSizeMultiple", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
	{
	}
}
public class OpRetainEvent : Instruction
{
	public OpRetainEvent() : base("OpRetainEvent", new List<Operand>()
{new Operand(new IdRef(), "Event", OperandQuantifier.Default), })
	{
	}
}
public class OpReleaseEvent : Instruction
{
	public OpReleaseEvent() : base("OpReleaseEvent", new List<Operand>()
{new Operand(new IdRef(), "Event", OperandQuantifier.Default), })
	{
	}
}
public class OpCreateUserEvent : Instruction
{
	public OpCreateUserEvent() : base("OpCreateUserEvent", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpIsValidEvent : Instruction
{
	public OpIsValidEvent() : base("OpIsValidEvent", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Event", OperandQuantifier.Default), })
	{
	}
}
public class OpSetUserEventStatus : Instruction
{
	public OpSetUserEventStatus() : base("OpSetUserEventStatus", new List<Operand>()
{new Operand(new IdRef(), "Event", OperandQuantifier.Default), new Operand(new IdRef(), "Status", OperandQuantifier.Default), })
	{
	}
}
public class OpCaptureEventProfilingInfo : Instruction
{
	public OpCaptureEventProfilingInfo() : base("OpCaptureEventProfilingInfo", new List<Operand>()
{new Operand(new IdRef(), "Event", OperandQuantifier.Default), new Operand(new IdRef(), "Profiling Info", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpGetDefaultQueue : Instruction
{
	public OpGetDefaultQueue() : base("OpGetDefaultQueue", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpBuildNDRange : Instruction
{
	public OpBuildNDRange() : base("OpBuildNDRange", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "GlobalWorkSize", OperandQuantifier.Default), new Operand(new IdRef(), "LocalWorkSize", OperandQuantifier.Default), new Operand(new IdRef(), "GlobalWorkOffset", OperandQuantifier.Default), })
	{
	}
}
public class OpImageSparseSampleImplicitLod : Instruction
{
	public OpImageSparseSampleImplicitLod() : base("OpImageSparseSampleImplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageSparseSampleExplicitLod : Instruction
{
	public OpImageSparseSampleExplicitLod() : base("OpImageSparseSampleExplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpImageSparseSampleDrefImplicitLod : Instruction
{
	public OpImageSparseSampleDrefImplicitLod() : base("OpImageSparseSampleDrefImplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageSparseSampleDrefExplicitLod : Instruction
{
	public OpImageSparseSampleDrefExplicitLod() : base("OpImageSparseSampleDrefExplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpImageSparseSampleProjImplicitLod : Instruction
{
	public OpImageSparseSampleProjImplicitLod() : base("OpImageSparseSampleProjImplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageSparseSampleProjExplicitLod : Instruction
{
	public OpImageSparseSampleProjExplicitLod() : base("OpImageSparseSampleProjExplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpImageSparseSampleProjDrefImplicitLod : Instruction
{
	public OpImageSparseSampleProjDrefImplicitLod() : base("OpImageSparseSampleProjDrefImplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageSparseSampleProjDrefExplicitLod : Instruction
{
	public OpImageSparseSampleProjDrefExplicitLod() : base("OpImageSparseSampleProjDrefExplicitLod", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpImageSparseFetch : Instruction
{
	public OpImageSparseFetch() : base("OpImageSparseFetch", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageSparseGather : Instruction
{
	public OpImageSparseGather() : base("OpImageSparseGather", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Component", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageSparseDrefGather : Instruction
{
	public OpImageSparseDrefGather() : base("OpImageSparseDrefGather", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpImageSparseTexelsResident : Instruction
{
	public OpImageSparseTexelsResident() : base("OpImageSparseTexelsResident", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Resident Code", OperandQuantifier.Default), })
	{
	}
}
public class OpNoLine : Instruction
{
	public OpNoLine() : base("OpNoLine")
	{
	}
}
public class OpAtomicFlagTestAndSet : Instruction
{
	public OpAtomicFlagTestAndSet() : base("OpAtomicFlagTestAndSet", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
	{
	}
}
public class OpAtomicFlagClear : Instruction
{
	public OpAtomicFlagClear() : base("OpAtomicFlagClear", new List<Operand>()
{new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
	{
	}
}
public class OpImageSparseRead : Instruction
{
	public OpImageSparseRead() : base("OpImageSparseRead", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
	{
	}
}
public class OpSizeOf : Instruction
{
	public OpSizeOf() : base("OpSizeOf", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
	{
	}
}
public class OpTypePipeStorage : Instruction
{
	public OpTypePipeStorage() : base("OpTypePipeStorage", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpConstantPipeStorage : Instruction
{
	public OpConstantPipeStorage() : base("OpConstantPipeStorage", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Packet Size", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Packet Alignment", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Capacity", OperandQuantifier.Default), })
	{
	}
}
public class OpCreatePipeFromPipeStorage : Instruction
{
	public OpCreatePipeFromPipeStorage() : base("OpCreatePipeFromPipeStorage", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe Storage", OperandQuantifier.Default), })
	{
	}
}
public class OpGetKernelLocalSizeForSubgroupCount : Instruction
{
	public OpGetKernelLocalSizeForSubgroupCount() : base("OpGetKernelLocalSizeForSubgroupCount", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Subgroup Count", OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
	{
	}
}
public class OpGetKernelMaxNumSubgroups : Instruction
{
	public OpGetKernelMaxNumSubgroups() : base("OpGetKernelMaxNumSubgroups", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
	{
	}
}
public class OpTypeNamedBarrier : Instruction
{
	public OpTypeNamedBarrier() : base("OpTypeNamedBarrier", new List<Operand>()
{new Operand(new IdResult(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpNamedBarrierInitialize : Instruction
{
	public OpNamedBarrierInitialize() : base("OpNamedBarrierInitialize", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Subgroup Count", OperandQuantifier.Default), })
	{
	}
}
public class OpMemoryNamedBarrier : Instruction
{
	public OpMemoryNamedBarrier() : base("OpMemoryNamedBarrier", new List<Operand>()
{new Operand(new IdRef(), "Named Barrier", OperandQuantifier.Default), new Operand(new IdScope(), "Memory", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
	{
	}
}
public class OpModuleProcessed : Instruction
{
	public OpModuleProcessed() : base("OpModuleProcessed", new List<Operand>()
{new Operand(new LiteralString(), "Process", OperandQuantifier.Default), })
	{
	}
}
public class OpExecutionModeId : Instruction
{
	public OpExecutionModeId() : base("OpExecutionModeId", new List<Operand>()
{new Operand(new IdRef(), "Entry Point", OperandQuantifier.Default), new Operand(new EnumType<ExecutionMode, ExecutionModeParameterFactory>(), "Mode", OperandQuantifier.Default), })
	{
	}
}
public class OpDecorateId : Instruction
{
	public OpDecorateId() : base("OpDecorateId", new List<Operand>()
{new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new EnumType<Decoration, DecorationParameterFactory>(), null, OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupBallotKHR : Instruction
{
	public OpSubgroupBallotKHR() : base("OpSubgroupBallotKHR", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupFirstInvocationKHR : Instruction
{
	public OpSubgroupFirstInvocationKHR() : base("OpSubgroupFirstInvocationKHR", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupAllKHR : Instruction
{
	public OpSubgroupAllKHR() : base("OpSubgroupAllKHR", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupAnyKHR : Instruction
{
	public OpSubgroupAnyKHR() : base("OpSubgroupAnyKHR", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupAllEqualKHR : Instruction
{
	public OpSubgroupAllEqualKHR() : base("OpSubgroupAllEqualKHR", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupReadInvocationKHR : Instruction
{
	public OpSubgroupReadInvocationKHR() : base("OpSubgroupReadInvocationKHR", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupIAddNonUniformAMD : Instruction
{
	public OpGroupIAddNonUniformAMD() : base("OpGroupIAddNonUniformAMD", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupFAddNonUniformAMD : Instruction
{
	public OpGroupFAddNonUniformAMD() : base("OpGroupFAddNonUniformAMD", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupFMinNonUniformAMD : Instruction
{
	public OpGroupFMinNonUniformAMD() : base("OpGroupFMinNonUniformAMD", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupUMinNonUniformAMD : Instruction
{
	public OpGroupUMinNonUniformAMD() : base("OpGroupUMinNonUniformAMD", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupSMinNonUniformAMD : Instruction
{
	public OpGroupSMinNonUniformAMD() : base("OpGroupSMinNonUniformAMD", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupFMaxNonUniformAMD : Instruction
{
	public OpGroupFMaxNonUniformAMD() : base("OpGroupFMaxNonUniformAMD", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupUMaxNonUniformAMD : Instruction
{
	public OpGroupUMaxNonUniformAMD() : base("OpGroupUMaxNonUniformAMD", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpGroupSMaxNonUniformAMD : Instruction
{
	public OpGroupSMaxNonUniformAMD() : base("OpGroupSMaxNonUniformAMD", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
	{
	}
}
public class OpFragmentMaskFetchAMD : Instruction
{
	public OpFragmentMaskFetchAMD() : base("OpFragmentMaskFetchAMD", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), })
	{
	}
}
public class OpFragmentFetchAMD : Instruction
{
	public OpFragmentFetchAMD() : base("OpFragmentFetchAMD", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Fragment Index", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupShuffleINTEL : Instruction
{
	public OpSubgroupShuffleINTEL() : base("OpSubgroupShuffleINTEL", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Data", OperandQuantifier.Default), new Operand(new IdRef(), "InvocationId", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupShuffleDownINTEL : Instruction
{
	public OpSubgroupShuffleDownINTEL() : base("OpSubgroupShuffleDownINTEL", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Current", OperandQuantifier.Default), new Operand(new IdRef(), "Next", OperandQuantifier.Default), new Operand(new IdRef(), "Delta", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupShuffleUpINTEL : Instruction
{
	public OpSubgroupShuffleUpINTEL() : base("OpSubgroupShuffleUpINTEL", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Previous", OperandQuantifier.Default), new Operand(new IdRef(), "Current", OperandQuantifier.Default), new Operand(new IdRef(), "Delta", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupShuffleXorINTEL : Instruction
{
	public OpSubgroupShuffleXorINTEL() : base("OpSubgroupShuffleXorINTEL", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Data", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupBlockReadINTEL : Instruction
{
	public OpSubgroupBlockReadINTEL() : base("OpSubgroupBlockReadINTEL", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Ptr", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupBlockWriteINTEL : Instruction
{
	public OpSubgroupBlockWriteINTEL() : base("OpSubgroupBlockWriteINTEL", new List<Operand>()
{new Operand(new IdRef(), "Ptr", OperandQuantifier.Default), new Operand(new IdRef(), "Data", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupImageBlockReadINTEL : Instruction
{
	public OpSubgroupImageBlockReadINTEL() : base("OpSubgroupImageBlockReadINTEL", new List<Operand>()
{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), })
	{
	}
}
public class OpSubgroupImageBlockWriteINTEL : Instruction
{
	public OpSubgroupImageBlockWriteINTEL() : base("OpSubgroupImageBlockWriteINTEL", new List<Operand>()
{new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Data", OperandQuantifier.Default), })
	{
	}
}
public static class Instructions
{
	private static readonly Dictionary<int, Instruction> instructions_ = new() { { 0, new OpNop() }, { 1, new OpUndef() }, { 2, new OpSourceContinued() }, { 3, new OpSource() }, { 4, new OpSourceExtension() }, { 5, new OpName() }, { 6, new OpMemberName() }, { 7, new OpString() }, { 8, new OpLine() }, { 10, new OpExtension() }, { 11, new OpExtInstImport() }, { 12, new OpExtInst() }, { 14, new OpMemoryModel() }, { 15, new OpEntryPoint() }, { 16, new OpExecutionMode() }, { 17, new OpCapability() }, { 19, new OpTypeVoid() }, { 20, new OpTypeBool() }, { 21, new OpTypeInt() }, { 22, new OpTypeFloat() }, { 23, new OpTypeVector() }, { 24, new OpTypeMatrix() }, { 25, new OpTypeImage() }, { 26, new OpTypeSampler() }, { 27, new OpTypeSampledImage() }, { 28, new OpTypeArray() }, { 29, new OpTypeRuntimeArray() }, { 30, new OpTypeStruct() }, { 31, new OpTypeOpaque() }, { 32, new OpTypePointer() }, { 33, new OpTypeFunction() }, { 34, new OpTypeEvent() }, { 35, new OpTypeDeviceEvent() }, { 36, new OpTypeReserveId() }, { 37, new OpTypeQueue() }, { 38, new OpTypePipe() }, { 39, new OpTypeForwardPointer() }, { 41, new OpConstantTrue() }, { 42, new OpConstantFalse() }, { 43, new OpConstant() }, { 44, new OpConstantComposite() }, { 45, new OpConstantSampler() }, { 46, new OpConstantNull() }, { 48, new OpSpecConstantTrue() }, { 49, new OpSpecConstantFalse() }, { 50, new OpSpecConstant() }, { 51, new OpSpecConstantComposite() }, { 52, new OpSpecConstantOp() }, { 54, new OpFunction() }, { 55, new OpFunctionParameter() }, { 56, new OpFunctionEnd() }, { 57, new OpFunctionCall() }, { 59, new OpVariable() }, { 60, new OpImageTexelPointer() }, { 61, new OpLoad() }, { 62, new OpStore() }, { 63, new OpCopyMemory() }, { 64, new OpCopyMemorySized() }, { 65, new OpAccessChain() }, { 66, new OpInBoundsAccessChain() }, { 67, new OpPtrAccessChain() }, { 68, new OpArrayLength() }, { 69, new OpGenericPtrMemSemantics() }, { 70, new OpInBoundsPtrAccessChain() }, { 71, new OpDecorate() }, { 72, new OpMemberDecorate() }, { 73, new OpDecorationGroup() }, { 74, new OpGroupDecorate() }, { 75, new OpGroupMemberDecorate() }, { 77, new OpVectorExtractDynamic() }, { 78, new OpVectorInsertDynamic() }, { 79, new OpVectorShuffle() }, { 80, new OpCompositeConstruct() }, { 81, new OpCompositeExtract() }, { 82, new OpCompositeInsert() }, { 83, new OpCopyObject() }, { 84, new OpTranspose() }, { 86, new OpSampledImage() }, { 87, new OpImageSampleImplicitLod() }, { 88, new OpImageSampleExplicitLod() }, { 89, new OpImageSampleDrefImplicitLod() }, { 90, new OpImageSampleDrefExplicitLod() }, { 91, new OpImageSampleProjImplicitLod() }, { 92, new OpImageSampleProjExplicitLod() }, { 93, new OpImageSampleProjDrefImplicitLod() }, { 94, new OpImageSampleProjDrefExplicitLod() }, { 95, new OpImageFetch() }, { 96, new OpImageGather() }, { 97, new OpImageDrefGather() }, { 98, new OpImageRead() }, { 99, new OpImageWrite() }, { 100, new OpImage() }, { 101, new OpImageQueryFormat() }, { 102, new OpImageQueryOrder() }, { 103, new OpImageQuerySizeLod() }, { 104, new OpImageQuerySize() }, { 105, new OpImageQueryLod() }, { 106, new OpImageQueryLevels() }, { 107, new OpImageQuerySamples() }, { 109, new OpConvertFToU() }, { 110, new OpConvertFToS() }, { 111, new OpConvertSToF() }, { 112, new OpConvertUToF() }, { 113, new OpUConvert() }, { 114, new OpSConvert() }, { 115, new OpFConvert() }, { 116, new OpQuantizeToF16() }, { 117, new OpConvertPtrToU() }, { 118, new OpSatConvertSToU() }, { 119, new OpSatConvertUToS() }, { 120, new OpConvertUToPtr() }, { 121, new OpPtrCastToGeneric() }, { 122, new OpGenericCastToPtr() }, { 123, new OpGenericCastToPtrExplicit() }, { 124, new OpBitcast() }, { 126, new OpSNegate() }, { 127, new OpFNegate() }, { 128, new OpIAdd() }, { 129, new OpFAdd() }, { 130, new OpISub() }, { 131, new OpFSub() }, { 132, new OpIMul() }, { 133, new OpFMul() }, { 134, new OpUDiv() }, { 135, new OpSDiv() }, { 136, new OpFDiv() }, { 137, new OpUMod() }, { 138, new OpSRem() }, { 139, new OpSMod() }, { 140, new OpFRem() }, { 141, new OpFMod() }, { 142, new OpVectorTimesScalar() }, { 143, new OpMatrixTimesScalar() }, { 144, new OpVectorTimesMatrix() }, { 145, new OpMatrixTimesVector() }, { 146, new OpMatrixTimesMatrix() }, { 147, new OpOuterProduct() }, { 148, new OpDot() }, { 149, new OpIAddCarry() }, { 150, new OpISubBorrow() }, { 151, new OpUMulExtended() }, { 152, new OpSMulExtended() }, { 154, new OpAny() }, { 155, new OpAll() }, { 156, new OpIsNan() }, { 157, new OpIsInf() }, { 158, new OpIsFinite() }, { 159, new OpIsNormal() }, { 160, new OpSignBitSet() }, { 161, new OpLessOrGreater() }, { 162, new OpOrdered() }, { 163, new OpUnordered() }, { 164, new OpLogicalEqual() }, { 165, new OpLogicalNotEqual() }, { 166, new OpLogicalOr() }, { 167, new OpLogicalAnd() }, { 168, new OpLogicalNot() }, { 169, new OpSelect() }, { 170, new OpIEqual() }, { 171, new OpINotEqual() }, { 172, new OpUGreaterThan() }, { 173, new OpSGreaterThan() }, { 174, new OpUGreaterThanEqual() }, { 175, new OpSGreaterThanEqual() }, { 176, new OpULessThan() }, { 177, new OpSLessThan() }, { 178, new OpULessThanEqual() }, { 179, new OpSLessThanEqual() }, { 180, new OpFOrdEqual() }, { 181, new OpFUnordEqual() }, { 182, new OpFOrdNotEqual() }, { 183, new OpFUnordNotEqual() }, { 184, new OpFOrdLessThan() }, { 185, new OpFUnordLessThan() }, { 186, new OpFOrdGreaterThan() }, { 187, new OpFUnordGreaterThan() }, { 188, new OpFOrdLessThanEqual() }, { 189, new OpFUnordLessThanEqual() }, { 190, new OpFOrdGreaterThanEqual() }, { 191, new OpFUnordGreaterThanEqual() }, { 194, new OpShiftRightLogical() }, { 195, new OpShiftRightArithmetic() }, { 196, new OpShiftLeftLogical() }, { 197, new OpBitwiseOr() }, { 198, new OpBitwiseXor() }, { 199, new OpBitwiseAnd() }, { 200, new OpNot() }, { 201, new OpBitFieldInsert() }, { 202, new OpBitFieldSExtract() }, { 203, new OpBitFieldUExtract() }, { 204, new OpBitReverse() }, { 205, new OpBitCount() }, { 207, new OpDPdx() }, { 208, new OpDPdy() }, { 209, new OpFwidth() }, { 210, new OpDPdxFine() }, { 211, new OpDPdyFine() }, { 212, new OpFwidthFine() }, { 213, new OpDPdxCoarse() }, { 214, new OpDPdyCoarse() }, { 215, new OpFwidthCoarse() }, { 218, new OpEmitVertex() }, { 219, new OpEndPrimitive() }, { 220, new OpEmitStreamVertex() }, { 221, new OpEndStreamPrimitive() }, { 224, new OpControlBarrier() }, { 225, new OpMemoryBarrier() }, { 227, new OpAtomicLoad() }, { 228, new OpAtomicStore() }, { 229, new OpAtomicExchange() }, { 230, new OpAtomicCompareExchange() }, { 231, new OpAtomicCompareExchangeWeak() }, { 232, new OpAtomicIIncrement() }, { 233, new OpAtomicIDecrement() }, { 234, new OpAtomicIAdd() }, { 235, new OpAtomicISub() }, { 236, new OpAtomicSMin() }, { 237, new OpAtomicUMin() }, { 238, new OpAtomicSMax() }, { 239, new OpAtomicUMax() }, { 240, new OpAtomicAnd() }, { 241, new OpAtomicOr() }, { 242, new OpAtomicXor() }, { 245, new OpPhi() }, { 246, new OpLoopMerge() }, { 247, new OpSelectionMerge() }, { 248, new OpLabel() }, { 249, new OpBranch() }, { 250, new OpBranchConditional() }, { 251, new OpSwitch() }, { 252, new OpKill() }, { 253, new OpReturn() }, { 254, new OpReturnValue() }, { 255, new OpUnreachable() }, { 256, new OpLifetimeStart() }, { 257, new OpLifetimeStop() }, { 259, new OpGroupAsyncCopy() }, { 260, new OpGroupWaitEvents() }, { 261, new OpGroupAll() }, { 262, new OpGroupAny() }, { 263, new OpGroupBroadcast() }, { 264, new OpGroupIAdd() }, { 265, new OpGroupFAdd() }, { 266, new OpGroupFMin() }, { 267, new OpGroupUMin() }, { 268, new OpGroupSMin() }, { 269, new OpGroupFMax() }, { 270, new OpGroupUMax() }, { 271, new OpGroupSMax() }, { 274, new OpReadPipe() }, { 275, new OpWritePipe() }, { 276, new OpReservedReadPipe() }, { 277, new OpReservedWritePipe() }, { 278, new OpReserveReadPipePackets() }, { 279, new OpReserveWritePipePackets() }, { 280, new OpCommitReadPipe() }, { 281, new OpCommitWritePipe() }, { 282, new OpIsValidReserveId() }, { 283, new OpGetNumPipePackets() }, { 284, new OpGetMaxPipePackets() }, { 285, new OpGroupReserveReadPipePackets() }, { 286, new OpGroupReserveWritePipePackets() }, { 287, new OpGroupCommitReadPipe() }, { 288, new OpGroupCommitWritePipe() }, { 291, new OpEnqueueMarker() }, { 292, new OpEnqueueKernel() }, { 293, new OpGetKernelNDrangeSubGroupCount() }, { 294, new OpGetKernelNDrangeMaxSubGroupSize() }, { 295, new OpGetKernelWorkGroupSize() }, { 296, new OpGetKernelPreferredWorkGroupSizeMultiple() }, { 297, new OpRetainEvent() }, { 298, new OpReleaseEvent() }, { 299, new OpCreateUserEvent() }, { 300, new OpIsValidEvent() }, { 301, new OpSetUserEventStatus() }, { 302, new OpCaptureEventProfilingInfo() }, { 303, new OpGetDefaultQueue() }, { 304, new OpBuildNDRange() }, { 305, new OpImageSparseSampleImplicitLod() }, { 306, new OpImageSparseSampleExplicitLod() }, { 307, new OpImageSparseSampleDrefImplicitLod() }, { 308, new OpImageSparseSampleDrefExplicitLod() }, { 309, new OpImageSparseSampleProjImplicitLod() }, { 310, new OpImageSparseSampleProjExplicitLod() }, { 311, new OpImageSparseSampleProjDrefImplicitLod() }, { 312, new OpImageSparseSampleProjDrefExplicitLod() }, { 313, new OpImageSparseFetch() }, { 314, new OpImageSparseGather() }, { 315, new OpImageSparseDrefGather() }, { 316, new OpImageSparseTexelsResident() }, { 317, new OpNoLine() }, { 318, new OpAtomicFlagTestAndSet() }, { 319, new OpAtomicFlagClear() }, { 320, new OpImageSparseRead() }, { 321, new OpSizeOf() }, { 322, new OpTypePipeStorage() }, { 323, new OpConstantPipeStorage() }, { 324, new OpCreatePipeFromPipeStorage() }, { 325, new OpGetKernelLocalSizeForSubgroupCount() }, { 326, new OpGetKernelMaxNumSubgroups() }, { 327, new OpTypeNamedBarrier() }, { 328, new OpNamedBarrierInitialize() }, { 329, new OpMemoryNamedBarrier() }, { 330, new OpModuleProcessed() }, { 331, new OpExecutionModeId() }, { 332, new OpDecorateId() }, { 4421, new OpSubgroupBallotKHR() }, { 4422, new OpSubgroupFirstInvocationKHR() }, { 4428, new OpSubgroupAllKHR() }, { 4429, new OpSubgroupAnyKHR() }, { 4430, new OpSubgroupAllEqualKHR() }, { 4432, new OpSubgroupReadInvocationKHR() }, { 5000, new OpGroupIAddNonUniformAMD() }, { 5001, new OpGroupFAddNonUniformAMD() }, { 5002, new OpGroupFMinNonUniformAMD() }, { 5003, new OpGroupUMinNonUniformAMD() }, { 5004, new OpGroupSMinNonUniformAMD() }, { 5005, new OpGroupFMaxNonUniformAMD() }, { 5006, new OpGroupUMaxNonUniformAMD() }, { 5007, new OpGroupSMaxNonUniformAMD() }, { 5011, new OpFragmentMaskFetchAMD() }, { 5012, new OpFragmentFetchAMD() }, { 5571, new OpSubgroupShuffleINTEL() }, { 5572, new OpSubgroupShuffleDownINTEL() }, { 5573, new OpSubgroupShuffleUpINTEL() }, { 5574, new OpSubgroupShuffleXorINTEL() }, { 5575, new OpSubgroupBlockReadINTEL() }, { 5576, new OpSubgroupBlockWriteINTEL() }, { 5577, new OpSubgroupImageBlockReadINTEL() }, { 5578, new OpSubgroupImageBlockWriteINTEL() }, };
	public static IReadOnlyDictionary<int, Instruction> OpcodeToInstruction
	{
		get => instructions_;
	}
}

```

`Source/SpirV/SpirV.Meta.cs`:

```cs
namespace SpirV;

internal class Meta
{
	public class ToolInfo
	{
		public ToolInfo(string vendor)
		{
			Vendor = vendor;
		}

		public ToolInfo(string vendor, string name)
		{
			Vendor = vendor;
			Name = name;
		}

		public string? Name { get; }
		public string Vendor { get; }
	}

	public static uint MagicNumber => 119734787U;
	public static uint Version => 66048U;
	public static uint Revision => 2U;
	public static uint OpCodeMask => 65535U;
	public static uint WordCountShift => 16U;

	public static IReadOnlyDictionary<int, ToolInfo> Tools => toolInfos_;

	private readonly static Dictionary<int, ToolInfo> toolInfos_ = new Dictionary<int, ToolInfo>
	{
		{ 0, new ToolInfo("Khronos") },
		{ 1, new ToolInfo("LunarG") },
		{ 2, new ToolInfo("Valve") },
		{ 3, new ToolInfo("Codeplay") },
		{ 4, new ToolInfo("NVIDIA") },
		{ 5, new ToolInfo("ARM") },
		{ 6, new ToolInfo("Khronos", "LLVM/SPIR-V Translator") },
		{ 7, new ToolInfo("Khronos", "SPIR-V Tools Assembler") },
		{ 8, new ToolInfo("Khronos", "Glslang Reference Front End") },
		{ 9, new ToolInfo("Qualcomm") },
		{ 10, new ToolInfo("AMD") },
		{ 11, new ToolInfo("Intel") },
		{ 12, new ToolInfo("Imagination") },
		{ 13, new ToolInfo("Google", "Shaderc over Glslang") },
		{ 14, new ToolInfo("Google", "spiregg") },
		{ 15, new ToolInfo("Google", "rspirv") },
		{ 16, new ToolInfo("X-LEGEND", "Mesa-IR/SPIR-V Translator") },
		{ 17, new ToolInfo("Khronos", "SPIR-V Tools Linker") },
	};
}

```

`Source/SpirV/SpirV.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputPath>..\0Bins\Other\SpirV\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\SpriV\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

</Project>

```

`Source/SpirV/Types.cs`:

```cs
using System.Text;

namespace SpirV;

public class Type
{
	public virtual StringBuilder ToString(StringBuilder sb)
	{
		return sb;
	}
}

public class VoidType : Type
{
	public override string ToString()
	{
		return "void";
	}

	public override StringBuilder ToString(StringBuilder sb)
	{
		return sb.Append("void");
	}
}

public class ScalarType : Type
{
}

public class BoolType : ScalarType
{
	public override string ToString()
	{
		return "bool";
	}

	public override StringBuilder ToString(StringBuilder sb)
	{
		return sb.Append("bool");
	}
}

public class IntegerType : ScalarType
{
	public IntegerType(int width, bool signed)
	{
		Width = width;
		Signed = signed;
	}

	public override string ToString()
	{
		if (Signed)
		{
			return $"i{Width}";
		}
		else
		{
			return $"u{Width}";
		}
	}

	public override StringBuilder ToString(StringBuilder sb)
	{
		if (Signed)
		{
			sb.Append('i').Append(Width);
		}
		else
		{
			sb.Append('u').Append(Width);
		}
		return sb;
	}

	public int Width { get; }
	public bool Signed { get; }
}

public class FloatingPointType : ScalarType
{
	public FloatingPointType(int width)
	{
		Width = width;
	}

	public override string ToString()
	{
		return $"f{Width}";
	}

	public override StringBuilder ToString(StringBuilder sb)
	{
		return sb.Append('f').Append(Width);
	}

	public int Width { get; }
}

public class VectorType : Type
{
	public VectorType(ScalarType scalarType, int componentCount)
	{
		ComponentType = scalarType;
		ComponentCount = componentCount;
	}

	public override string ToString()
	{
		return $"{ComponentType}_{ComponentCount}";
	}

	public override StringBuilder ToString(StringBuilder sb)
	{
		return ComponentType.ToString(sb).Append('_').Append(ComponentCount);
	}

	public ScalarType ComponentType { get; }
	public int ComponentCount { get; }
}

public class MatrixType : Type
{
	public MatrixType(VectorType vectorType, int columnCount)
	{
		ColumnType = vectorType;
		ColumnCount = columnCount;
	}

	public override string ToString()
	{
		return $"{ColumnType}x{ColumnCount}";
	}

	public override StringBuilder ToString(StringBuilder sb)
	{
		return sb.Append(ColumnType).Append('x').Append(ColumnCount);
	}

	public VectorType ColumnType { get; }
	public int ColumnCount { get; }
	public int RowCount => ColumnType.ComponentCount;
}

public class ImageType : Type
{
	public ImageType(Type sampledType, Dim dim, int depth, bool isArray, bool isMultisampled, int sampleCount,
		ImageFormat imageFormat, AccessQualifier accessQualifier)
	{
		SampledType = sampledType;
		Dim = dim;
		Depth = depth;
		IsArray = isArray;
		IsMultisampled = isMultisampled;
		SampleCount = sampleCount;
		Format = imageFormat;
		AccessQualifier = accessQualifier;
	}

	public override string ToString()
	{
		StringBuilder sb = new StringBuilder();
		ToString(sb);
		return sb.ToString();
	}

	public override StringBuilder ToString(StringBuilder sb)
	{
		switch (AccessQualifier)
		{
			case AccessQualifier.ReadWrite:
				sb.Append("read_write ");
				break;
			case AccessQualifier.WriteOnly:
				sb.Append("write_only ");
				break;
			case AccessQualifier.ReadOnly:
				sb.Append("read_only ");
				break;
		}

		sb.Append("Texture");
		switch (Dim)
		{
			case Dim.Dim1D:
				sb.Append("1D");
				break;
			case Dim.Dim2D:
				sb.Append("2D");
				break;
			case Dim.Dim3D:
				sb.Append("3D");
				break;
			case Dim.Cube:
				sb.Append("Cube");
				break;
		}

		if (IsMultisampled)
		{
			sb.Append("MS");
		}
		if (IsArray)
		{
			sb.Append("Array");
		}
		return sb;
	}

	public Type SampledType { get; }
	public Dim Dim { get; }
	public int Depth { get; }
	public bool IsArray { get; }
	public bool IsMultisampled { get; }
	public int SampleCount { get; }
	public ImageFormat Format { get; }
	public AccessQualifier AccessQualifier { get; }
}

public class SamplerType : Type
{
	public override string ToString()
	{
		return "sampler";
	}

	public override StringBuilder ToString(StringBuilder sb)
	{
		return sb.Append("sampler");
	}
}

public class SampledImageType : Type
{
	public SampledImageType(ImageType imageType)
	{
		ImageType = imageType;
	}

	public override string ToString()
	{
		return $"{ImageType}Sampled";
	}

	public override StringBuilder ToString(StringBuilder sb)
	{
		return ImageType.ToString(sb).Append("Sampled");
	}

	public ImageType ImageType { get; }
}

public class ArrayType : Type
{
	public ArrayType(Type elementType, int elementCount)
	{
		ElementType = elementType;
		ElementCount = elementCount;
	}

	public override string ToString()
	{
		return $"{ElementType}[{ElementCount}]";
	}

	public override StringBuilder ToString(StringBuilder sb)
	{
		return ElementType.ToString(sb).Append('[').Append(ElementCount).Append(']');
	}

	public int ElementCount { get; }
	public Type ElementType { get; }
}

public class RuntimeArrayType : Type
{
	public RuntimeArrayType(Type elementType)
	{
		ElementType = elementType;
	}

	public Type ElementType { get; }
}

public class StructType : Type
{
	public StructType(IReadOnlyList<Type> memberTypes)
	{
		MemberTypes = memberTypes;
		memberNames_ = new List<string>();

		for (int i = 0; i < memberTypes.Count; ++i)
		{
			memberNames_.Add(string.Empty);
		}
	}

	public void SetMemberName(uint member, string name)
	{
		memberNames_[(int)member] = name;
	}

	public override string ToString()
	{
		StringBuilder sb = new StringBuilder();
		ToString(sb);
		return sb.ToString();
	}

	public override StringBuilder ToString(StringBuilder sb)
	{
		sb.Append("struct {");
		for (int i = 0; i < MemberTypes.Count; ++i)
		{
			Type memberType = MemberTypes[i];
			memberType.ToString(sb);
			if (!string.IsNullOrEmpty(memberNames_[i]))
			{
				sb.Append(' ');
				sb.Append(MemberNames[i]);
			}

			sb.Append(';');
			if (i < (MemberTypes.Count - 1))
			{
				sb.Append(' ');
			}
		}
		sb.Append('}');
		return sb;
	}

	public IReadOnlyList<Type> MemberTypes { get; }
	public IReadOnlyList<string> MemberNames => memberNames_;

	private List<string> memberNames_;
}

public class OpaqueType : Type
{
}

public class PointerType : Type
{
	public PointerType(StorageClass storageClass, Type type)
	{
		StorageClass = storageClass;
		Type = type;
	}

	public PointerType(StorageClass storageClass)
	{
		StorageClass = storageClass;
	}

	public void ResolveForwardReference(Type t)
	{
		Type = t;
	}

	public override string ToString()
	{
		if (Type == null)
		{
			return $"{StorageClass} *";
		}
		else
		{
			return $"{StorageClass} {Type}*";
		}
	}

	public override StringBuilder ToString(StringBuilder sb)
	{
		sb.Append(StorageClass.ToString()).Append(' ');
		Type?.ToString(sb);
		sb.Append('*');
		return sb;
	}

	public StorageClass StorageClass { get; }
	public Type? Type { get; private set; }
}

public class FunctionType : Type
{
	public FunctionType(Type returnType, IReadOnlyList<Type> parameterTypes)
	{
		ReturnType = returnType;
		ParameterTypes = parameterTypes;
	}

	public Type ReturnType { get; }
	public IReadOnlyList<Type> ParameterTypes { get; }
}

public class EventType : Type
{
}

public class DeviceEventType : Type
{
}

public class ReserveIdType : Type
{
}

public class QueueType : Type
{
}

public class PipeType : Type
{
}

public class PipeStorage : Type
{
}

public class NamedBarrier : Type
{
}

```

`Source/UnityEngine/Behaviour.cs`:

```cs
namespace UnityEngine;

public class Behaviour : Component
{
}

```

`Source/UnityEngine/Bounds.cs`:

```cs
namespace UnityEngine;

public struct Bounds
{
	public Vector3 center;
	public Vector3 extents;
}

```

`Source/UnityEngine/BoundsInt.cs`:

```cs
namespace UnityEngine;

public struct BoundsInt
{
	public Vector3Int position;
	public Vector3Int size;
}

```

`Source/UnityEngine/Color.cs`:

```cs
namespace UnityEngine;

public struct Color
{
	public float r;
	public float g;
	public float b;
	public float a;
}

```

`Source/UnityEngine/Color32.cs`:

```cs
namespace UnityEngine;

public struct Color32
{
	public int rgba;
}

```

`Source/UnityEngine/Component.cs`:

```cs
namespace UnityEngine;

public class Component : Object
{
}

```

`Source/UnityEngine/GameObject.cs`:

```cs
namespace UnityEngine;

public class GameObject : Object
{
}

```

`Source/UnityEngine/LayerMask.cs`:

```cs
namespace UnityEngine;

public struct LayerMask
{
	public uint m_Bits;
}

```

`Source/UnityEngine/Matrix4x4.cs`:

```cs
namespace UnityEngine;

public struct Matrix4x4
{
	public float m00; public float m01; public float m02; public float m03;
	public float m10; public float m11; public float m12; public float m13;
	public float m20; public float m21; public float m22; public float m23;
	public float m30; public float m31; public float m32; public float m33;
}

```

`Source/UnityEngine/MonoBehaviour.cs`:

```cs
namespace UnityEngine;

public class MonoBehaviour : Behaviour
{
}

```

`Source/UnityEngine/Object.cs`:

```cs
namespace UnityEngine;

public class Object
{
}

```

`Source/UnityEngine/Quaternion.cs`:

```cs
namespace UnityEngine;

public struct Quaternion
{
	public float x;
	public float y;
	public float z;
	public float w;
}

```

`Source/UnityEngine/README.md`:

```md
Ignore this. It's just for unit testing.

```

`Source/UnityEngine/Rect.cs`:

```cs
namespace UnityEngine;

public struct Rect
{
	public float x;
	public float y;
	public float width;
	public float height;
}

```

`Source/UnityEngine/RectInt.cs`:

```cs
namespace UnityEngine;

public struct RectInt
{
	public int x;
	public int y;
	public int width;
	public int height;
}

```

`Source/UnityEngine/Rendering/SphericalHarmonicsL2.cs`:

```cs
namespace UnityEngine.Rendering;

public struct SphericalHarmonicsL2
{
	private float shr0;

	private float shr1;

	private float shr2;

	private float shr3;

	private float shr4;

	private float shr5;

	private float shr6;

	private float shr7;

	private float shr8;

	private float shg0;

	private float shg1;

	private float shg2;

	private float shg3;

	private float shg4;

	private float shg5;

	private float shg6;

	private float shg7;

	private float shg8;

	private float shb0;

	private float shb1;

	private float shb2;

	private float shb3;

	private float shb4;

	private float shb5;

	private float shb6;

	private float shb7;

	private float shb8;
}

```

`Source/UnityEngine/SerializeField.cs`:

```cs
namespace UnityEngine;

/// <summary>
/// Instruct Unity to serialize a non-public field.
/// </summary>
/// <remarks>
/// Unity does not follow the convention that attribute type names end with the "Attribute" suffix.
/// </remarks>
[AttributeUsage(AttributeTargets.Field)]
public sealed class SerializeField : Attribute
{
}

```

`Source/UnityEngine/SerializeReference.cs`:

```cs
namespace UnityEngine;

/// <summary>
/// Instruct Unity to serialize the field as a reference.
/// </summary>
/// <remarks>
/// Unity does not follow the convention that attribute type names end with the "Attribute" suffix.
/// </remarks>
[AttributeUsage(AttributeTargets.Field)]
public sealed class SerializeReference : Attribute
{
}

```

`Source/UnityEngine/UnityEngine.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<IsPackable>false</IsPackable>
		<OutputPath>..\0Bins\Other\UnityEngine\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\0Bins\obj\UnityEngine\$(Configuration)\</IntermediateOutputPath>
	</PropertyGroup>

</Project>

```

`Source/UnityEngine/Vector2.cs`:

```cs
namespace UnityEngine;

public struct Vector2
{
	public float x;
	public float y;
}

```

`Source/UnityEngine/Vector2Int.cs`:

```cs
namespace UnityEngine;

public struct Vector2Int
{
	public int m_X;
	public int m_Y;
}

```

`Source/UnityEngine/Vector3.cs`:

```cs
namespace UnityEngine;

public struct Vector3
{
	public float x;
	public float y;
	public float z;
}

```

`Source/UnityEngine/Vector3Int.cs`:

```cs
namespace UnityEngine;

public struct Vector3Int
{
	public int m_X;
	public int m_Y;
	public int m_Z;
}

```

`Source/UnityEngine/Vector4.cs`:

```cs
namespace UnityEngine;

public struct Vector4
{
	public float x;
	public float y;
	public float z;
	public float w;
}

```

`Source/generate.bat`:

```bat
:: Build Solution

dotnet build -c Debug ../


:: Generate Dll

cd ./0Bins/AssetRipper.AssemblyDumper/Debug/

AssetRipper.AssemblyDumper.exe

cd ../../../


:: Decompile Dll

cd ./0Bins/AssetRipper.AssemblyDumper.Recompiler/Debug/

AssetRipper.AssemblyDumper.Recompiler.exe ../../AssetRipper.AssemblyDumper/Debug/AssetRipper.SourceGenerated.dll ./Output/ %1

cd ../../../


:: Recompile into a NuGet package

cd ./0Bins/AssetRipper.AssemblyDumper.Recompiler/Debug/Output/

dotnet build -c Release

cd ../../../../


:: Remove the dependency references

cd ./0Bins/AssetRipper.AssemblyDumper.NuGetFixer/Debug/

AssetRipper.AssemblyDumper.NuGetFixer.exe ../../AssetRipper.AssemblyDumper.Recompiler/Debug/Output/bin/Release/ %1
```

`docs/api/index.md`:

```md
# API Documentation
This section contains all the generated documentation for the project.

```

`docs/articles/CommonIssues.md`:

```md
# Common Issues

## Why doesn't AssetRipper export Mono Scripts from my bundle?

Except in extremely rare and special cases, there are no mono scripts stored in asset bundles.

Mono scripts are stored in C# assemblies, ie `.dll` files. The contents of these assemblies can be viewed in [ILSpy](https://github.com/icsharpcode/ILSpy).

> Note: C++ assemblies also use the `.dll` extension. If C# code can't be viewed after opening a `.dll` file in ILSpy, then it's not a C# assembly.

In order to export mono scripts with asset bundle assets, the relevant assemblies must be included in the import. You can do this by:

1. Place all the assemblies in a folder.
2. Select that folder and the assetbundle(s) being ripped.
3. Drag those into AssetRipper at the same time.

If it worked, you'll get this line in the log:

```text
Import : Files use the 'Mono' scripting backend.
```

If it didn't work, there will be this line:

```text
Import : Files use the 'Unknown' scripting backend.
```

For IL2Cpp games, use [Cpp2IL](https://github.com/SamboyCoding/Cpp2IL) to generate assemblies. [Il2CppInterop assemblies](https://github.com/BepInEx/Il2CppInterop) used in modding will not work.

## Duplicate Assemblies

This has a signature error in the log file.

```text
Could not add pe assembly to name dictionary!
```

It is almost always caused by having two assemblies with the same name in the Managed folder or any subfolders. Note that the "name" in this case is the assembly name shown in a decompiler not the file name.

## Modified Assemblies

> This can include publicized assemblies and/or Il2CppInterop assemblies.

Modified assemblies almost always cause read errors when used in AssetRipper. Here are some common changes that are known to cause lots of problems:

* Publicizing an assembly changes field deserialization on Monobehaviours.
* Attribute removal can also change field deserialization.
* Modified method bodies can cause decompiler errors.

## Too many open files

```text
System.IO.IOException (00000018): Too many open files
```

This can happen on Linux when the limit is set too low. Try running `ulimit -n 1048576` before running AssetRipper in the same terminal. The number 1048576 is arbitrary.

The above command is a soft relaxation of the limit. For permanent changes, modify `/etc/security/limits.conf`.

See [issue 2061](https://github.com/AssetRipper/AssetRipper/issues/2061) for more information.

```

`docs/articles/Credits.md`:

```md
# Credits

## Licensed Works

A complete list of licensed works used in AssetRipper can be found in the application.

## Project Heritage

AssetRipper builds upon the work of several open-source projects:

1. **[uTinyRipper](https://github.com/mafaca/UtinyRipper)** by [mafaca](https://github.com/mafaca)
    - AssetRipper began as a fork of this project
    - Licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Source/Licenses/uTinyRipper.md)

2. **[AssetStudio](https://github.com/Perfare/AssetStudio)** by [Perfare](https://github.com/Perfare)
    - Contributed code to AssetRipper
    - Licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Source/Licenses/AssetStudio.md)

3. **[uTinyRipperExporter](https://github.com/spacehamster/UtinyRipperExporter)** by [spacehamster](https://github.com/spacehamster)
    - Contributed code to AssetRipper
    - Licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Source/Licenses/uTinyRipperExporter.md)
```

`docs/articles/Downloads.md`:

```md
# Downloads

## Stable Releases [![Latest Release](https://img.shields.io/github/v/release/AssetRipper/AssetRipper?label=Latest%20Release&style=flat-square)](https://github.com/AssetRipper/AssetRipper/releases/latest)

Get the latest stable version of AssetRipper for your platform:

| Platform      | Download Link                                                                                             |
|---------------|-----------------------------------------------------------------------------------------------------------|
| Windows x64   | [Download](https://github.com/AssetRipper/AssetRipper/releases/latest/download/AssetRipper_win_x64.zip)   |
| Windows Arm64 | [Download](https://github.com/AssetRipper/AssetRipper/releases/latest/download/AssetRipper_win_arm64.zip) |
| Mac x64       | [Download](https://github.com/AssetRipper/AssetRipper/releases/latest/download/AssetRipper_mac_x64.zip)   |
| Mac Arm64     | [Download](https://github.com/AssetRipper/AssetRipper/releases/latest/download/AssetRipper_mac_arm64.zip) |
| Linux x64     | [Download](https://github.com/AssetRipper/AssetRipper/releases/latest/download/AssetRipper_linux_x64.zip) |
| Linux Arm64     | [Download](https://github.com/AssetRipper/AssetRipper/releases/latest/download/AssetRipper_linux_arm64.zip) |

📝 [Release Notes](https://github.com/AssetRipper/AssetRipper/releases/latest)

## Pre-Releases [![Pre-Release](https://img.shields.io/github/v/release/AssetRipper/AssetRipper?include_prereleases&label=Pre-Release&style=flat-square)](https://github.com/AssetRipper/AssetRipper/releases)

Pre-releases showcase experimental features and are available in the [releases section](https://github.com/AssetRipper/AssetRipper/releases).

⚠️ These versions may be unstable and are recommended for testing purposes only.

## Nightly Builds [![Build Status](https://img.shields.io/github/workflow/status/AssetRipper/AssetRipper/Publish/master?label=Build%20Status&style=flat-square)](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master)

For advanced users, every commit triggers an automatic nightly build via Github Actions:

| Platform      | Download Link                                                                                               |
|---------------|-------------------------------------------------------------------------------------------------------------|
| Windows x64   | [Download](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master/AssetRipper_win_x64.zip)   |
| Windows Arm64 | [Download](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master/AssetRipper_win_arm64.zip) |
| Mac x64       | [Download](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master/AssetRipper_mac_x64.zip)   |
| Mac Arm64     | [Download](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master/AssetRipper_mac_arm64.zip) |
| Linux x64     | [Download](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master/AssetRipper_linux_x64.zip) |
| Linux Arm64     | [Download](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master/AssetRipper_linux_arm64.zip) |

⚠️ Alpha builds are highly experimental and may contain bugs or unfinished features.

---

If you encounter any issues, please report them on our [Issue Tracker](https://github.com/AssetRipper/AssetRipper/issues).
```

`docs/articles/PremiumFeatures.md`:

```md
# Premium Features

## Traditional Il2Cpp Recovery

This is an experimental feature for recovering code compiled with Il2Cpp. It takes a traditional decompilation approach. It can be enabled by selecting Script Content Level 3 in the settings.

For performance, mscorlib and any assemblies whose names start with System or Unity have been excluded from analysis. The source code for those assemblies should be publicly available, in one form or another.

From a quick glance, the success rate seems to be currently between 10 and 20 percent of methods on x86 games. Other platforms have lower rates of recovery. Improvements are ongoing.

## Shader Decompilation

This is an experimental shader decompiler that strives to support all variants and preserve perfect semantics. However, it's not yet polished, so expect it to throw errors while ripping some shaders and for there to be compilation errors in Unity Editor. Please report any issues on [GitHub](https://github.com/AssetRipper/AssetRipper/issues).

**Platform Support:**

* Vulkan shaders can be decompiled on any platform.
* DirectX shaders can only be decompiled on Windows computers.

## Static Mesh Separation

Objects marked as static in a scene get merged when the game is compiled. This is an optimization Unity uses to reduce draw calls. Unfortunately, it also makes game recovery more difficult. This feature reverses that process to the best of its ability.

* If a mesh is used statically multiple times in the game, even across different scenes, AssetRipper intelligently identifies these duplicates and generates a single mesh for all the instances.
* If the original mesh exists in the game files, it's used instead of generating a new mesh.
* Mesh names are lost during static batching, so the GameObject name is used instead. Some sensible name cleaning is applied.

This feature has a setting for enabling it, which defaults to true.

## Prefab Outlining

When a game is compiled, all prefabs in a scene are inlined (instantiated), so any information about the original prefab is lost. This feature attempts to reverse that process by analyzing all GameObject hierarchies in the game and identifying repetitions that can be replaced with new (or existing) prefabs.

This feature has a setting for enabling it, which defaults to false.

## Asset Deduplication

When building multiple asset bundles, it's very common for Unity to duplicate assets shared between bundles. This allows each bundle to stay self-contained. Asset deduplication is an experimental feature for reversing that process.

Some assets are easier to deduplicate than others. Currently, this is limited to:

* Mono Scripts
* Shaders
* Compute Shaders
* Audio Clips
* Text Assets
* Meshes
* Textures without sprites

This feature has a setting for enabling it, which defaults to false.

## User Defined Package Export

One of the most frustrating things for users is package export. Previously, exported projects referenced only the default set of Unity core modules. Whenever a user would reference a package that the game had used, the new package would conflict with assemblies and scripts within the exported project. Deleting the conflicting exported files would break any asset references to those files.

There are third-party tools available to help fix broken script references, but they mostly rely on guessing the scripts from the MonoBehaviour fields. In addition, they do nothing to fix broken references for other asset types. That is the purpose of this feature: export asset and package references, so that the user doesn't have to fix broken references later.

Unfortunately, it is not feasible to datamine all possible packages, not even restricted to the official offerings from Unity. As such, users and communities be responsible for mining the packages specific to their game. However, there are some resources to help programmers do the required datamining. https://github.com/AssetRipper/MarrowMiningDemo

This experimental feature can be enabled by going to the Configuration Files page, which can be accessed with "View/Configuration Files" in the file menu. To enable the feature, the user must upload package data json files appropriate for the game being ripped. Example json files are available in the Marrow Mining Demo I linked above.

## Asset Path Overrides

This feature allows users to change the export destination of an asset. It can be enabled by going to the Configuration Files page, which can be accessed with "View/Configuration Files" in the file menu. To enable the feature, the user must upload a json file appropriate for the game being ripped.

### Path Override File Structure

Path overrides can be supplied as a json file.

```json
{
	"Files": {
		"cab-bcaf22789432bda1e5d0eea9d2521ddd": {
			"4476349470337976665": "Assets/AssetRenamed.txt"
		},
		"level1.assets":
		{
			"1": "Assets/Prefabs/Prefab1.prefab",
			"2": "Assets/Prefabs/Prefab2.prefab",
			"3": "Assets/Prefabs/Subfolder/SpecialPrefab.prefab",
			"12": "Assets/Images/MyTexture.png"
		}
	}
}
```

`Files` is a dictionary with string keys representing asset collection names. The values are also dictionaries. They use the asset path id as the key and the new output path as the value. Paths are relative to the project root.

```

`docs/articles/Requirements.md`:

```md
# Development and Usage Requirements

## Building the Solution

To build AssetRipper from source, you'll need:

### Essential Software
- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)

### Compatible IDEs/Editors (with C# 14 support)
Choose one of the following:
- [Visual Studio 2026](https://visualstudio.microsoft.com/downloads/) (Community edition is free for open-source development)
- [Visual Studio Code](https://code.visualstudio.com/Download) with C# extension
- [JetBrains Rider](https://www.jetbrains.com/rider/) (commercial software, free for students and open-source developers)

## Running AssetRipper

if you want to run binary files, you need to install:

### Unity Editor
- [Download Unity](https://unity.com/releases/editor/archive)
- ⚠️ Important: Your Unity editor version should be:
  - At least as recent as the game version you're working with
  - Ideally, use the exact same version as the target game for best compatibility

```

`docs/articles/RoadMap.md`:

```md
# Development Roadmap

## 1. Planned But Unscheduled

### 1.1 Import
- **Script Import**
  - Use type trees for assembly reconstruction

### 1.2 Export
- **Script Export**
  - Assembly renaming
- **Miscellaneous Export**
  - Copy plugins folder into output
- **Binary Export**
  - SerializeFile writing as an alternative to yaml export

### 1.3 UI
- **Improved Asset Previews**
  - Scene preview
  - Material preview

### 1.4 Remove Native Dependencies
- Replace crunch with managed code

---

## 2. Concept Ideas

> **Note:** This is a collection of ideas that might not be desirable or feasible. Many of them may never be implemented. Do not interpret their inclusion as any form of commitment.

### 2.1 Import/Export Enhancements
- **Asset Loading**
  - Extract assets and save to disk for lower RAM usage
- **Audio Export**
  - WWise audio extraction
- **Shader Export**
  - Replace all shaders on materials with a built-in shader (e.g., Standard shader)
- **Selective Export**
  - Export selected object to folder or compressed zip file
- **Filtered Export**
  - Resources (png, wav, avi, obj, ...)
  - Prefabs
  - Scripts

### 2.2 UI and User Experience
- **GUI Quality of Life Features**
  - Preferences Window (Font setting, Configurable keybindings)
- **Console**
  - Enterable commands
- **Search Functionality**
  - Dedicated search window
  - Tree View Search (Filters, Name filter, Rows limit, Result count, Group resources option)
- **Tabs**
  - Inspector Tab (Tag, Layer, ID, File name, Asset Specific Properties)
  - Moveable Tabs
  - Error Tab

### 2.3 Asset Management
- **Asset Editing**
- **Asset Bundle Construction**
  - Editing and Repacking of games and asset bundles
  - Asset Header Editor
  - Asset Duplication and Creation
  - Asset Editing and Replacement
  - Copy and paste assets
  - Prefab Creation
- **Asset Exporting**
  - Export as Prefab
  - Export as Unitypackage
  - Node Dump

### 2.4 Asset Previews
- **Meshes**
  - Colored semi-transparency
  - Triangle count
  - FPS meter
  - Orientation aids (Corner cube, XYZ axis)
  - Toggle face cull
  - Wireframe option
- **Textures**
  - Background options (e.g., checkers, white, black, default)
  - Color channel display options
- **Other Asset Types**
  - Video Display
  - Animations
  - Scripts (view as text, notify if script missing)

### 2.5 Performance and Settings
- **Import Settings**
  - Ignore scenes option
  - Import bundle as level
  - Assembly de-obfuscation
- **Performance Improvements**
  - Asynchronous import/export

### 2.6 Miscellaneous
- Find all references
```

`docs/articles/RunningOnMac.md`:

```md
# Running AssetRipper on macOS

> ⚠️ Disclaimer: The project developer does not have access to a Mac. This guide is community-contributed and might be outdated.

This guide will help you run AssetRipper on macOS. Before proceeding, ensure you have all the necessary [requirements](https://assetripper.github.io/AssetRipper/articles/Requirements.html).

## Running the GUI Version

### Step 1: Download AssetRipper

1. Download the GUI release from the [AssetRipper downloads page](https://assetripper.github.io/AssetRipper/articles/Downloads.html).
2. Choose `AssetRipper_mac_x64.zip` or `AssetRipper_mac_arm64.zip`, depending on your computer architecture. M2 processors are arm64.

   ![Download AssetRipper](images/RunningOnMac/001.png)

### Step 2: Extract the Archive

1. Right-click the downloaded file and select "Open" to extract its contents.

   ![Extract AssetRipper](images/RunningOnMac/002.png)

2. You should now see a folder named `AssetRipper_mac_x64`.

   ![AssetRipper folder](images/RunningOnMac/003.png)

3. Inside this folder, you'll find various files, including the AssetRipper executable.

   ![AssetRipper contents](images/RunningOnMac/004.png)
   ![AssetRipper executable](images/RunningOnMac/005.png)

### Step 3: Open Terminal in the AssetRipper Folder

1. Select the `AssetRipper_mac_x64` folder.
2. Go to `Finder` > `Services` > `New Terminal at Folder`.

   ![Open Terminal](images/RunningOnMac/006.png)

### Step 4: Run AssetRipper

1. In the Terminal, enter the following command:
```
./AssetRipper.GUI.Free
```
2. You may encounter a "Permission denied" error.

![Permission denied](images/RunningOnMac/008.png)

3. To fix this, enter the following command:
```
chmod +x AssetRipper.GUI.Free
```
4. Now, try running AssetRipper again:
```
./AssetRipper.GUI.Free
```

### Step 5: Handle Security Prompts

1. You may see a security prompt. Click "Cancel" for now.

![Security prompt](images/RunningOnMac/010.png)

2. Open System Preferences (⌘ + Space, search for "System Preferences").
3. Go to "Security & Privacy" > "General" tab.
4. At the bottom, click "Allow Anyway" for AssetRipper.

![Allow AssetRipper](images/RunningOnMac/013.png)

5. Run the `./AssetRipper.GUI.Free` command again in Terminal.
6. Click "Open" when prompted.

![Open AssetRipper](images/RunningOnMac/014.png)

7. You may see additional security prompts. Click "OK" and allow them as needed.

![Additional prompts](images/RunningOnMac/015.png)
![More prompts](images/RunningOnMac/016.png)

### Step 6: AssetRipper GUI

After completing these steps, the AssetRipper GUI should open:

![AssetRipper GUI](images/RunningOnMac/017.png)

## Reopening AssetRipper

Once you've gone through the initial setup, you can easily reopen AssetRipper:

1. Navigate to the `AssetRipper_mac_x64` folder.
2. Double-click the `AssetRipper.GUI.Free` file to launch the application.

![Reopen AssetRipper](images/RunningOnMac/018.png)

Congratulations! You've successfully set up and run AssetRipper on macOS.

![AssetRipper running](images/RunningOnMac/019.png)
```

`docs/articles/intro.md`:

```md
# Introduction

Welcome to the articles section. Here you can find information about the project and its future.
```

`docs/articles/toc.yml`:

```yml
- name: Getting Started
  items:
    - name: Introduction
      href: intro.md
    - name: Requirements
      href: Requirements.md
    - name: Downloads
      href: Downloads.md

- name: Usage Guide
  items:
    - name: Common Issues
      href: CommonIssues.md
    - name: Running on Mac
      href: RunningOnMac.md
    - name: Premium Features
      href: PremiumFeatures.md


- name: Project Information
  items:
    - name: Road Map
      href: RoadMap.md
    - name: Credits
      href: Credits.md

```

`docs/docfx.json`:

```json
{
  "metadata": [
    {
      "src": [
        {
          "src": "../",
          "files": [
            "**.csproj",
            "**.sln"
          ]
        }
      ],
      "dest": "api",
      "disableGitFeatures": false,
      "disableDefaultFilter": false
    }
  ],
  "build": {
    "content": [
      {
        "files": [
          "api/**.yml",
          "api/index.md"
        ]
      },
      {
        "files": [
          "articles/**.md",
          "articles/**/toc.yml",
          "toc.yml",
          "*.md"
        ]
      }
    ],
    "resource": [
      {
        "files": [
          "images/**",
          "articles/images/**"
        ]
      }
    ],
    "overwrite": [
      {
        "files": [
          "apidoc/**.md"
        ],
        "exclude": [
          "obj/**",
          "_site/**"
        ]
      }
    ],
    "dest": "_site",
    "globalMetadataFiles": [],
    "fileMetadataFiles": [],
    "template": [
      "default",
      "templates/darkfx"
    ],
    "postProcessors": [],
    "markdownEngineName": "markdig",
    "noLangKeyword": false,
    "keepFileLink": false,
    "cleanupCacheHistory": false,
    "disableGitFeatures": false
  }
}
```

`docs/index.md`:

```md
<h1 align="center">AssetRipper</h1>

<p align="center">
  <img src="https://github.com/AssetRipper/AssetRipper/raw/master/Media/Images/2D_Logo/AssetRipperLogoBackground.png" alt="AssetRipper Logo" width="50%">
</p>

<p align="center">
  <a href="https://github.com/AssetRipper/AssetRipper/releases"><img src="https://img.shields.io/github/downloads/AssetRipper/AssetRipper/total.svg?label=Downloads&logo=github" alt="Total Downloads"></a>
  <a href="https://github.com/AssetRipper/AssetRipper/releases/latest"><img src="https://img.shields.io/github/v/release/AssetRipper/AssetRipper?label=Release&logo=github" alt="Latest Release"></a>
  <a href="https://github.com/AssetRipper/AssetRipper/blob/master/LICENSE.md"><img src="https://img.shields.io/github/license/AssetRipper/AssetRipper?label=License&logo=gnu" alt="License"></a>
  <a href="https://discord.gg/XqXa53W2Yh"><img src="https://img.shields.io/discord/867514400701153281?label=Discord&logo=discord&color=5865F2" alt="Discord"></a>
</p>

<p align="center">
  <a href="#Features">Features</a> •
  <a href="#getting-started">Getting Started</a> •
  <a href="#premium-edition">Premium Edition</a> •
  <a href="#Donations">Donations</a> •
  <a href="#contributing">Contributing</a>
</p>

AssetRipper is a powerful tool for loading and converting Unity engine assets. It can process:
- Serialized files (`*CAB-*`, `*.assets`, `*.sharedAssets`, etc.)
- Asset bundles (`*.unity3d`, `*.bundle`, etc.)

The loaded assets are converted into:
- The native Unity engine format for easy use in Unity Editor.
- Standard formats that traditional software, like Blender, can read.

AssetRipper supports Unity versions from `3.5.0` to `6000.5.X`. However, support quality may vary slightly for different Unity versions.

# Getting Started

1. Download the latest release from the [Downloads page](https://assetripper.github.io/AssetRipper/articles/Downloads.html).
2. Extract the downloaded archive.
3. Run AssetRipper executable.
4. Change the settings to your preference.
5. Open your Unity game folder or asset files.
6. Wait for the extraction and conversion process to complete.
7. Access your extracted assets in the output folder.

There is also a [community guide for Mac users](https://assetripper.github.io/AssetRipper/articles/RunningOnMac.html).

# Premium Edition

[Patreon](https://www.patreon.com/ds5678) supporters at the `Premium` tier or higher receive access to the premium edition of AssetRipper. This edition includes additional [features and improvements](https://assetripper.github.io/AssetRipper/articles/PremiumFeatures.html).

# Donations

Your support helps maintain and improve AssetRipper. If you find this tool useful, please consider donating:

- [GitHub Sponsors](https://github.com/sponsors/ds5678)
- [Patreon](https://www.patreon.com/ds5678)
- [PayPal](https://paypal.me/ds5678)

Patreon donors receive special roles on our [Discord server](https://discord.gg/XqXa53W2Yh).

# Contributing

We welcome contributions from the community! Whether it's bug reports, feature requests, or code contributions, please feel free to get involved.

<a href="https://github.com/AssetRipper/AssetRipper/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=AssetRipper/AssetRipper"/>
</a>

# Legal Disclaimers

- AssetRipper is licensed under the [GNU General Public License v3.0](https://github.com/AssetRipper/AssetRipper/blob/master/LICENSE.md).
- Using or distributing output from this software may be subject to copyright laws in your jurisdiction.
- AssetRipper is not sponsored by or affiliated with Unity Technologies or its affiliates.
- "Unity" is a trademark or registered trademark of Unity Technologies or its affiliates in the U.S. and elsewhere.

For a full list of attributions, please see our [Credits](articles/Credits.md) page.
```

`docs/templates/darkfx/partials/affix.tmpl.partial`:

```partial
{{!Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See LICENSE file in the project root for full license information.}}

<div class="hidden-sm col-md-2" role="complementary">
  <div class="sideaffix">
    {{^_disableContribution}}
    <div class="contribution">
      <ul class="nav">
        {{#docurl}}
        <li>
          <a href="{{docurl}}" class="contribution-link">{{__global.improveThisDoc}}</a>
        </li>
        {{/docurl}}
        {{#sourceurl}}
        <li>
          <a href="{{sourceurl}}" class="contribution-link">{{__global.viewSource}}</a>
        </li>
        {{/sourceurl}}
      </ul>
    </div>
    {{/_disableContribution}}
    <div class="toggle-mode">
      <div class="icon">
        <i aria-hidden="true">☀</i>
      </div>
      <label class="switch">
        <input type="checkbox" id="switch-style">
        <span class="slider round"></span>
      </label>
      <div class="icon">
        <i aria-hidden="true">☾</i>
      </div>
    </div>

    <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
    <h5>{{__global.inThisArticle}}</h5>
    <div></div>
    <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
    </nav>
  </div>
</div>

```

`docs/templates/darkfx/partials/footer.tmpl.partial`:

```partial
{{!Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See LICENSE file in the project root for full license information.}}

<footer>
  <div class="grad-bottom"></div>
  <div class="footer">
    <div class="container">
      <span class="pull-right">
        <a href="#top">Back to top</a>
      </span>
      <div class="pull-left">
        {{{_appFooter}}}
        {{^_appFooter}}<span>Generated by <strong>DocFX</strong></span>{{/_appFooter}}
      </div>
      <div class="toggle-mode pull-right visible-sm visible-xs">
        <div class="icon">
          <i aria-hidden="true">☀</i>
        </div>
        <label class="switch">
          <input type="checkbox" id="switch-style-m">
          <span class="slider round"></span>
        </label>
        <div class="icon">
          <i aria-hidden="true">☾</i>
        </div>
      </div>
    </div>
  </div>
  <script type="text/javascript" src="{{_rel}}styles/toggle-theme.js"></script>
</footer>
```

`docs/templates/darkfx/partials/head.tmpl.partial`:

```partial
{{!Copyright (c) Oscar Vasquez. All rights reserved. Licensed under the MIT license. See LICENSE file in the project root for full license information.}}

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>{{#title}}{{title}}{{/title}}{{^title}}{{>partials/title}}{{/title}} {{#_appTitle}}| {{_appTitle}} {{/_appTitle}}</title>
  <meta name="viewport" content="width=device-width">
  <meta name="title" content="{{#title}}{{title}}{{/title}}{{^title}}{{>partials/title}}{{/title}} {{#_appTitle}}| {{_appTitle}} {{/_appTitle}}">
  <meta name="generator" content="docfx {{_docfxVersion}}">
  {{#_description}}<meta name="description" content="{{_description}}">{{/_description}}
  <link rel="shortcut icon" href="{{_rel}}{{{_appFaviconPath}}}{{^_appFaviconPath}}favicon.ico{{/_appFaviconPath}}">
  <link rel="stylesheet" href="{{_rel}}styles/docfx.vendor.css">
  <link rel="stylesheet" href="{{_rel}}styles/docfx.css">
  <link rel="stylesheet" href="{{_rel}}styles/main.css">
  <meta property="docfx:navrel" content="{{_navRel}}">
  <meta property="docfx:tocrel" content="{{_tocRel}}">
  {{#_noindex}}<meta name="searchOption" content="noindex">{{/_noindex}}
  {{#_enableSearch}}<meta property="docfx:rel" content="{{_rel}}">{{/_enableSearch}}
  {{#_enableNewTab}}<meta property="docfx:newtab" content="true">{{/_enableNewTab}}
</head>
```

`docs/templates/darkfx/styles/main.css`:

```css
:root, body.dark-theme {
  --color-foreground: #ccd5dc;
  --color-navbar: #66666d;
  --color-breadcrumb: #999;
  --color-underline: #ddd;
  --color-toc-hover: #fff;
  --color-background: #2d2d30;
  --color-background-subnav: #333337;
  --color-background-dark: #1e1e1e;
  --color-background-table-alt: #212123;
  --color-background-quote: #69696e;
}

body.light-theme {
  --color-foreground: #171717;
  --color-breadcrumb: #4a4a4a;
  --color-toc-hover: #4c4c4c;
  --color-background: #ffffff;
  --color-background-subnav: #f5f5f5;
  --color-background-dark: #ddd;
  --color-background-table-alt: #f9f9f9;
}

body {
  color: var(--color-foreground);
  line-height: 1.5;
  font-size: 14px;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  word-wrap: break-word;
  background-color: var(--color-background);
}

.btn.focus, .btn:focus, .btn:hover {
  color: var(--color-foreground);
}

h1 {
  font-weight: 600;
  font-size: 32px;
}

h2 {
  font-weight: 600;
  font-size: 24px;
  line-height: 1.8;
}

h3 {
  font-weight: 600;
  font-size: 20px;
  line-height: 1.8;
}

h5 {
  font-size: 14px;
  padding: 10px 0px;
}

article h1, article h2, article h3, article h4 {
  margin-top: 35px;
  margin-bottom: 15px;
}

article h4 {
  padding-bottom: 8px;
  border-bottom: 2px solid var(--color-underline);
}

.navbar-brand>img {
  color: var(--color-background);
}

.navbar {
  border: none;
}

.subnav {
  border-top: 1px solid var(--color-underline);
  background-color: var(--color-background-subnav);
}

.sidenav, .fixed_header, .toc {
  background-color: var(--color-background);
}

.navbar-inverse {
  background-color: var(--color-background-dark);
  z-index: 100;
}

.navbar-inverse .navbar-nav>li>a, .navbar-inverse .navbar-text {
  color: var(--color-navbar);
  background-color: var(--color-background-dark);
  border-bottom: 3px solid transparent;
  padding-bottom: 12px;
}

.navbar-inverse .navbar-nav>li>a:focus, .navbar-inverse .navbar-nav>li>a:hover {
  color: var(--color-foreground);
  background-color: var(--color-background-dark);
  border-bottom: 3px solid var(--color-background-subnav);
  transition: all ease 0.25s;
}

.navbar-inverse .navbar-nav>.active>a, .navbar-inverse .navbar-nav>.active>a:focus, .navbar-inverse .navbar-nav>.active>a:hover {
  color: var(--color-foreground);
  background-color: var(--color-background-dark);
  border-bottom: 3px solid var(--color-foreground);
  transition: all ease 0.25s;
}

.navbar-form .form-control {
  border: none;
  border-radius: 0;
}

.light-theme .navbar-brand svg {
  filter: brightness(20%);
}

.toc .level1>li {
  font-weight: 400;
}

.toc .nav>li>a {
  color: var(--color-foreground);
}

.sidefilter {
  background-color: var(--color-background);
  border-left: none;
  border-right: none;
}

.sidefilter {
  background-color: var(--color-background);
  border-left: none;
  border-right: none;
}

.toc-filter {
  padding: 10px;
  margin: 0;
  background-color: var(--color-background);
}

.toc-filter>input {
  border: none;
  border-radius: unset;
  background-color: var(--color-background-subnav);
  padding: 5px 0 5px 20px;
  font-size: 90%
}

.toc-filter>.clear-icon {
  position: absolute;
  top: 17px;
  right: 15px;
}

.toc-filter>input:focus {
  color: var(--color-foreground);
  transition: all ease 0.25s;
}

.toc-filter>.filter-icon {
  display: none;
}

.sidetoc>.toc {
  background-color: var(--color-background);
  overflow-x: hidden;
}

.sidetoc {
  background-color: var(--color-background);
  border: none;
}

.alert {
  background-color: inherit;
  border: none;
  padding: 10px 0;
  border-radius: 0;
}

.alert>p {
  margin-bottom: 0;
  padding: 5px 10px;
  border-bottom: 1px solid;
  background-color: var(--color-background-dark);
}

.alert>h5 {
  padding: 10px 15px;
  margin-top: 0;
  margin-bottom: 0;
  text-transform: uppercase;
  font-weight: bold;
  border-top: 2px solid;
  background-color: var(--color-background-dark);
  border-radius: none;
}

.alert>ul {
  margin-bottom: 0;
  padding: 5px 40px;
}

.alert-info {
  color: #1976d2;
}

.alert-warning {
  color: #f57f17;
}

.alert-danger {
  color: #d32f2f;
}

pre {
  padding: 9.5px;
  margin: 0 0 10px;
  font-size: 13px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: var(--color-background-dark);
  border-radius: 0;
  border: none;
}

code {
  background: var(--color-background-dark) !important;
  border-radius: 2px;
}

.hljs {
  color: var(--color-foreground);
}

.toc .nav>li.active>.expand-stub::before, .toc .nav>li.in>.expand-stub::before, .toc .nav>li.in.active>.expand-stub::before, .toc .nav>li.filtered>.expand-stub::before {
  content: "▾";
}

.toc .nav>li>.expand-stub::before, .toc .nav>li.active>.expand-stub::before {
  content: "▸";
}

.affix ul ul>li>a:before {
  content: "|";
}

.breadcrumb {
  background-color: var(--color-background-subnav);
}

.breadcrumb .label.label-primary {
  background: #444;
  border-radius: 0;
  font-weight: normal;
  font-size: 100%;
}

#breadcrumb .breadcrumb>li a {
  border-radius: 0;
  font-weight: normal;
  font-size: 85%;
  display: inline;
  padding: 0 .6em 0;
  line-height: 1;
  text-align: center;
  white-space: nowrap;
  vertical-align: baseline;
  color: var(--color-breadcrumb);
}

#breadcrumb .breadcrumb>li a:hover {
  color: var(--color-foreground);
  transition: all ease 0.25s;
}

.breadcrumb>li+li:before {
  content: "⯈";
  font-size: 75%;
  color: var(--color-background-dark);
  padding: 0;
}

.light-theme .breadcrumb>li+li:before {
  color: var(--color-foreground)
 }

.toc .level1>li {
  font-weight: 600;
  font-size: 130%;
  padding-left: 5px;
}

.footer {
  border-top: none;
  background-color: var(--color-background-dark);
  padding: 15px 0;
  font-size: 90%;
}

.toc .nav>li>a:hover, .toc .nav>li>a:focus {
  color: var(--color-toc-hover);
  transition: all ease 0.1s;
}

.form-control {
  background-color: var(--color-background-subnav);
  border: none;
  border-radius: 0;
  -webkit-box-shadow: none;
  box-shadow: none;
}

.form-control:focus {
  border-color: #66afe9;
  outline: 0;
  -webkit-box-shadow: none;
  box-shadow: none;
}

input#search-query:focus {
  color: var(--color-foreground);
}

.table-bordered, .table-bordered>tbody>tr>td, .table-bordered>tbody>tr>th, .table-bordered>tfoot>tr>td, .table-bordered>tfoot>tr>th, .table-bordered>thead>tr>td, .table-bordered>thead>tr>th {
  border: 1px solid var(--color-background-dark);
}

.table-striped>tbody>tr:nth-of-type(odd) {
  background-color: var(--color-background-table-alt);
}

blockquote {
  padding: 10px 20px;
  margin: 0 0 10px;
  font-size: 110%;
  border-left: 5px solid var(--color-background-quote);
  color: var(--color-background-quote);
}

.pagination>.disabled>a, .pagination>.disabled>a:focus, .pagination>.disabled>a:hover, .pagination>.disabled>span, .pagination>.disabled>span:focus, .pagination>.disabled>span:hover {
  background-color: var(--color-background-subnav);
  border-color: var(--color-background-subnav);
}

.breadcrumb>li, .pagination {
  display: inline;
}

.tabGroup a[role="tab"] {
  border-bottom: 2px solid var(--color-background-dark);
}

.tabGroup a[role="tab"][aria-selected="true"] {
  color: var(--color-foreground);
}

.tabGroup section[role="tabpanel"] {
  border: 1px solid var(--color-background-dark);
}

.sideaffix > div.contribution > ul > li > a.contribution-link:hover {
  background-color: var(--color-background);
}

.switch {
  position: relative;
  display: inline-block;
  width: 40px;
  height: 20px;
}

.switch input { 
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 14px;
  width: 14px;
  left: 4px;
  bottom: 3px;
  background-color: white;
  -webkit-transition: .4s;
  transition: .4s;
}

input:checked + .slider {
  background-color: #337ab7;
}

input:focus + .slider {
  box-shadow: 0 0 1px #337ab7;
}

input:checked + .slider:before {
  -webkit-transform: translateX(19px);
  -ms-transform: translateX(19px);
  transform: translateX(19px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 20px;
}

.slider.round:before {
  border-radius: 50%;
}
.toggle-mode .icon {
  display: inline-block;
}

.toggle-mode .icon i {
  font-style: normal;
  font-size: 17px;
  display: inline-block;
  padding-right: 7px;
  padding-left: 7px;
  vertical-align: middle;
}

@media (min-width: 1600px) {
  .container {
    width: 100%;
  }
  .sidefilter {
    width: 18%;
  }
  .sidetoc {
    width: 18%;
  }
  .article.grid-right {
    margin-left: 19%;
  }
  .sideaffix {
    width: 11.5%;
  }
  .affix ul>li.active>a {
    white-space: initial;
  }
  .affix ul>li>a {
    width: 99%;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
}
```

`docs/templates/darkfx/styles/toggle-theme.js`:

```js
const sw = document.getElementById("switch-style"), sw_mobile = document.getElementById("switch-style-m"), b = document.body;
if (b) {
  function toggleTheme(target, dark) {
    target.classList.toggle("dark-theme", dark)
    target.classList.toggle("light-theme", !dark)
  }

  function switchEventListener() {
    toggleTheme(b, this.checked);
    if (window.localStorage) {
      this.checked ? localStorage.setItem("theme", "dark-theme") : localStorage.setItem("theme", "light-theme")
    }
  }

  var isDarkTheme = !window.localStorage || !window.localStorage.getItem("theme") || window.localStorage && localStorage.getItem("theme") === "dark-theme";

  if(sw && sw_mobile){
    sw.checked = isDarkTheme;
    sw_mobile.checked = isDarkTheme;

    sw.addEventListener("change", switchEventListener);
    sw_mobile.addEventListener("change", switchEventListener);
    
    // sync state between switches
    sw.addEventListener("change", function() {
      sw_mobile.checked = this.checked;
    });

    sw_mobile.addEventListener("change", function() {
      sw.checked = this.checked;
    });
  }

  toggleTheme(b, isDarkTheme);
}
```

`docs/toc.yml`:

```yml
- name: Articles
  href: articles/
- name: Api Documentation
  href: api/
  homepage: api/index.md

```

`nuget.config`:

```config
<configuration>
	<packageSources>
		<add key="SamboyDev" value="https://nuget.samboy.dev/v3/index.json" />
	</packageSources>
</configuration>

```