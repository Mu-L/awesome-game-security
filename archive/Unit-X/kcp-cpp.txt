Project Path: arc_Unit-X_kcp-cpp_2c9lnumw

Source Tree:

```txt
arc_Unit-X_kcp-cpp_2c9lnumw
├── CMakeLists.txt
├── KCPLogger.h
├── KCPNet.cpp
├── KCPNet.h
├── LICENSE
├── README.md
├── kcp.svg
├── kcp_cpp_logo.png
├── kcp_logo.png
├── kissnet
│   ├── LICENSE
│   └── kissnet.hpp
└── main.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(kcp_cpp)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
find_package (Threads REQUIRED)

#If no build type is set then force Release
IF( NOT CMAKE_BUILD_TYPE )
    set(CMAKE_BUILD_TYPE "Release" CACHE STRING
            "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel."
            FORCE)
ENDIF()

set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -DDEBUG")
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

#Include KCP
include(ExternalProject)
ExternalProject_Add(project_kcp
        GIT_REPOSITORY https://github.com/skywind3000/kcp.git
        GIT_SUBMODULES ""
        GIT_TAG 58139efbbaa6fc82a451b780b05d37fb41f21d15
        UPDATE_COMMAND ""
        SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/kcp
        BINARY_DIR ${CMAKE_CURRENT_SOURCE_DIR}/kcp
        GIT_PROGRESS 1
        BUILD_COMMAND cmake --build ${CMAKE_CURRENT_SOURCE_DIR}/kcp --config ${CMAKE_BUILD_TYPE} --target kcp
        CMAKE_ARGS -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE} -DCMAKE_POSITION_INDEPENDENT_CODE=ON
        STEP_TARGETS build
        EXCLUDE_FROM_ALL TRUE
        INSTALL_COMMAND ""
        )
add_library(kcp STATIC IMPORTED)

IF (WIN32)
    set_property(TARGET kcp PROPERTY IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/kcp/${CMAKE_BUILD_TYPE}/kcp.lib)
ELSE()
    set_property(TARGET kcp PROPERTY IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/kcp/libkcp.a)
ENDIF()

add_dependencies(kcp project_kcp)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/kcp/)

add_library(kcpnet STATIC KCPNet.cpp)
target_link_libraries(kcpnet kcp Threads::Threads)

add_executable(kcp_cpp main.cpp)
target_link_libraries(kcp_cpp kcpnet Threads::Threads)

```

`KCPLogger.h`:

```h
//
// UnitX Edgeware AB 2020
//

#ifndef KCP_CPP_LOGGER_H
#define KCP_CPP_LOGGER_H

#include <iostream>
#include <sstream>

#define LOGG_NOTIFY (unsigned)1
#define LOGG_WARN (unsigned)2
#define LOGG_ERROR (unsigned)4
#define LOGG_FATAL (unsigned)8
#define LOGG_MASK  LOGG_NOTIFY | LOGG_WARN | LOGG_ERROR | LOGG_FATAL //What to logg?

//#define DEBUG

#ifdef DEBUG
#define KCP_LOGGER(l,g,f) \
{ \
std::ostringstream a; \
if (g == (LOGG_NOTIFY & (LOGG_MASK))) {a << "Notification: ";} \
else if (g == (LOGG_WARN & (LOGG_MASK))) {a << "Warning: ";} \
else if (g == (LOGG_ERROR & (LOGG_MASK))) {a << "Error: ";} \
else if (g == (LOGG_FATAL & (LOGG_MASK))) {a << "Fatal: ";} \
if (a.str().length()) { \
if (l) {a << __FILE__ << " " << __LINE__ << " ";} \
a << f << std::endl; \
std::cout << a.str(); \
} \
}
#else
#define KCP_LOGGER(l,g,f)
#endif

#endif //KCP_CPP_LOGGER_H

```

`KCPNet.cpp`:

```cpp
//
// Created by Anders Cedronius on 2020-09-30.
//

//TODO documentation, unit tests.

#include "KCPNet.h"
#include "KCPLogger.h"
#include <stdexcept>
#include <algorithm>
#include <vector>

#define KCP_MAX_BYTES 4096

//------------------------------------------------------------------------------------------
//
// KCP Client
//
//------------------------------------------------------------------------------------------

int udp_output_client(const char *pBuf, int lSize, ikcpcb *pKCP, void *pCTX) {
    auto *lWeakSelf = (KCPNetClient *) pCTX;
    if (lWeakSelf) {
        lWeakSelf->udpOutputClient(pBuf, lSize);
    } else {
        KCP_LOGGER(true, LOGG_FATAL, "udp_output_client failed getting 'this'")
        return -1; // Throw
    }
    return 0;
}

void KCPNetClient::udpOutputClient(const char *pBuf, int lSize) {
    auto[lSentBytes, lStatus] = mKissnetSocket.send((const std::byte *) pBuf, lSize);
    if (lSentBytes != lSize || lStatus != kissnet::socket_status::valid) {
        KCP_LOGGER(false, LOGG_NOTIFY, "Client failed sending data")
        return;
    }
#ifdef _WIN32
    mHasSentData = true;
#endif

}

KCPNetClient::KCPNetClient() {

}

KCPNetClient::~KCPNetClient() {
    uint32_t lDeadLock;
    // Signal close netWorker and nudge thread
    mKissnetSocket.shutdown(); // End net thread
    mKissnetSocket.close(); // End net thread
    mNudgeThreadActive = false; // End nudge thread

    // Join network thread
    if (mNetworkThreadRunning) {
        lDeadLock = 10;
        while (mNetworkThreadRunning) {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            if (!--lDeadLock) {
                KCP_LOGGER(true, LOGG_FATAL, "Client network is not ending will terminate anyway")
                break;
            }
        }
    }

    // Join nudge thread
    lDeadLock = 10;
    while (mNudgeThreadRunning) {
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        if (!--lDeadLock) {
            KCP_LOGGER(true, LOGG_FATAL, "Client nudge thread not ending will terminate anyway")
            break;
        }
    }
    std::lock_guard<std::mutex> lock(mKCPNetMtx);
    if (mKCP) ikcp_release(mKCP);
    KCP_LOGGER(false, LOGG_NOTIFY, "KCPNetClient Destruct")
}

// Fix in KCP later
int KCPNetClient::sendData(const char *pData, size_t lSize) {
    std::lock_guard<std::mutex> lock(mKCPNetMtx);
    return ikcp_send(mKCP, pData, lSize);
}

int KCPNetClient::configureKCP(KCPSettings &rSettings,
                               const std::function<void(const char *, size_t, KCPContext *)> &rGotData,
                               const std::function<void(KCPContext *)> &rDisconnect,
                               const std::string &lIP, uint16_t lPort,
                               uint32_t lID, std::shared_ptr<KCPContext> pCTX) {
    mCTX = std::move(pCTX);

    if (lIP.empty()) {
        KCP_LOGGER(true, LOGG_FATAL, "IP / HOST must be provided")
        return 1;
    }

    if (!lPort) {
        KCP_LOGGER(true, LOGG_FATAL, "Port must be provided")
        return 1;
    }

    if (!lID) {
        KCP_LOGGER(true, LOGG_FATAL, "KCP ID can't be 0")
        return 1;
    }

    kissnet::udp_socket lCreateSocket(kissnet::endpoint(lIP, lPort));
    mKissnetSocket = std::move(lCreateSocket); // Move ownership to this/me

    mKCP = ikcp_create(lID, this);
    if (!mKCP) {
        KCP_LOGGER(true, LOGG_FATAL, "Failed to create KCP")
        return 1;
    }
    mKCP->output = udp_output_client;
    std::thread([=]() { netWorkerClient(rGotData); }).detach();
    std::thread([=]() { kcpNudgeWorkerClient(rDisconnect); }).detach();
    KCP_LOGGER(false, LOGG_NOTIFY, "KCPNetClient Constructed");


    std::lock_guard<std::mutex> lock(mKCPNetMtx);
    int lResult;
    lResult = ikcp_nodelay(mKCP, rSettings.mNoDelay, rSettings.mInterval, rSettings.mResend, !rSettings.mFlow);
    if (lResult) {
        KCP_LOGGER(false, LOGG_ERROR, "ikcp_nodelay client failed.")
        return lResult;
    }
    lResult = ikcp_setmtu(mKCP, rSettings.mMtu);
    if (lResult) {
        KCP_LOGGER(false, LOGG_ERROR, "ikcp_setmtu client failed.")
        return lResult;
    }
    lResult = ikcp_wndsize(mKCP, rSettings.mSndWnd, rSettings.mRcvWnd);
    if (lResult) {
        KCP_LOGGER(false, LOGG_ERROR, "ikcp_wndsize client failed.")
    }
    return lResult;
}

// TODO Create a drift into corrected time
int64_t KCPNetClient::getNetworkTimeus(){
    if (!mGotCorrection) return 0;
    int64_t lLocalTime = std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count();
    int64_t lRecalculatedTime = lLocalTime - mCurrentCorrection;

    if (!mFirstTimeDelivery) {
        if (mLastDeliveredTime < lRecalculatedTime) {
            mLastDeliveredTime = lRecalculatedTime;
            return lRecalculatedTime;
        } else {
            return mLastDeliveredTime;
        }
    }

    mLastDeliveredTime = lRecalculatedTime;
    mFirstTimeDelivery = false;
    return lRecalculatedTime;
}

void KCPNetClient::kcpNudgeWorkerClient(const std::function<void(KCPContext *)> &rDisconnect) {
    mNudgeThreadRunning = true;
    mNudgeThreadActive = true;
    uint32_t lTimeSleepms = 10;
    uint64_t lTimeBaseus = std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count();

    uint64_t lTimeLast = 0;

    while (mNudgeThreadActive) {
        std::this_thread::sleep_for(std::chrono::milliseconds(lTimeSleepms));
        uint64_t lTimeNowus = std::chrono::duration_cast<std::chrono::microseconds>(
                std::chrono::steady_clock::now().time_since_epoch()).count() - lTimeBaseus;

        if (mGotCorrection) {
            if (!lTimeLast) {
                lTimeLast = lTimeNowus;
            } else {
                uint64_t lDiffTime = lTimeNowus - lTimeLast;
                lTimeLast = lTimeNowus;
                if (mCurrentCorrectionTarget != mCurrentCorrection) {
                    double lMulFac = lDiffTime / 1000000.0;
                    double lMaxComp =   lMulFac * MAX_TIME_DRIFT_PPM;
                    if (mCurrentCorrectionTarget > mCurrentCorrection) {
                        //KCP_LOGGER(false, LOGG_NOTIFY, "+curr " << mCurrentCorrection << " target " << mCurrentCorrectionTarget << " compensation " << lMaxComp)
                        mCurrentCorrection += lMaxComp;
                        if (mCurrentCorrection > mCurrentCorrectionTarget) {
                            int64_t lTmp = mCurrentCorrectionTarget;
                            mCurrentCorrection = lTmp;
                        }
                    } else {
                        //KCP_LOGGER(false, LOGG_NOTIFY, "-curr " << mCurrentCorrection << " target " << mCurrentCorrectionTarget << " compensation " << lMaxComp)
                        mCurrentCorrection -= lMaxComp;
                        if (mCurrentCorrection < mCurrentCorrectionTarget) {
                            int64_t lTmp = mCurrentCorrectionTarget;
                            mCurrentCorrection = lTmp;
                        }
                    }
                }
            }
        }

        uint64_t lTimeNowms = lTimeNowus / 1000;
        if (lTimeNowms > mHeartBeatIntervalTrigger) {
            mHeartBeatIntervalTrigger += HEART_BEAT_DISTANCE;
            KCP_LOGGER(false, LOGG_NOTIFY, "Heart beat client")
            if (!mConnectionTimeOut && rDisconnect) {
                rDisconnect(mCTX.get());
                mConnectionTimeOut = HEART_BEAT_TIME_OUT;
            }
            mConnectionTimeOut--;
        }
        mKCPNetMtx.lock();
        ikcp_update(mKCP, lTimeNowms);
        lTimeSleepms = ikcp_check(mKCP, lTimeNowms) - lTimeNowms;
        mKCPNetMtx.unlock();
        //KCP_LOGGER(false, LOGG_NOTIFY,"dead client? " << mKCP->dead_link)
        //KCP_LOGGER(false, LOGG_NOTIFY,"k " << lTimeSleep << " " << lTimeNow)
    }
    KCP_LOGGER(false, LOGG_NOTIFY, "kcpNudgeWorkerClient quitting");
    if (rDisconnect) {
        rDisconnect(mCTX.get());
    }
    mNudgeThreadRunning = false;
}

void KCPNetClient::netWorkerClient(const std::function<void(const char *, size_t, KCPContext *)> &rGotData) {
    mNetworkThreadRunning = true;
    kissnet::buffer<KCP_MAX_BYTES> receiveBuffer;
    char lBuffer[KCP_MAX_BYTES];
#ifdef _WIN32
    do {
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    } while (!mHasSentData && mNetworkThreadRunning);
#endif
    while (true) {
        auto[received_bytes, status] = mKissnetSocket.recv(receiveBuffer);
        if (!received_bytes || status != kissnet::socket_status::valid) {
            KCP_LOGGER(false, LOGG_NOTIFY, "netWorkerClient quitting")
            break;
        }

        if (*(uint64_t *) receiveBuffer.data() == TIME_PREAMBLE_V1) {
            auto lTimeData = (KCPTimePacket *) receiveBuffer.data();
            if (lTimeData->correctionActive == 1) {
                lTimeData->correctionActive = 2;
                if (!mGotCorrection) {
                    mCurrentCorrection = lTimeData->correction;
                }
                mCurrentCorrectionTarget = lTimeData->correction;
                mGotCorrection = true;
            }
            mKCPNetMtx.lock();
            int64_t lTimeNow = std::chrono::duration_cast<std::chrono::microseconds>(
                    std::chrono::steady_clock::now().time_since_epoch()).count();
            lTimeData->t2 = lTimeNow;
            lTimeData->t3 = lTimeNow;
            auto[lSentBytes, lStatus] = mKissnetSocket.send(receiveBuffer, sizeof(KCPTimePacket));
            if (lSentBytes != sizeof(KCPTimePacket) || lStatus != kissnet::socket_status::valid) {
                KCP_LOGGER(false, LOGG_NOTIFY, "Client failed sending data")
            }
            mConnectionTimeOut = HEART_BEAT_TIME_OUT;
            mKCPNetMtx.unlock();
            continue;
        }

        mKCPNetMtx.lock();
        mConnectionTimeOut = HEART_BEAT_TIME_OUT;
        ikcp_input(mKCP, (const char *) receiveBuffer.data(), received_bytes);
        int lRcv = ikcp_recv(mKCP, &lBuffer[0], KCP_MAX_BYTES);
        mKCPNetMtx.unlock();
        if (lRcv > 0 && rGotData) {
            rGotData(&lBuffer[0], lRcv, mCTX.get());
        } // Else deal with code?

    }
    mNetworkThreadRunning = false;
}


//------------------------------------------------------------------------------------------
//
// KCP Server
//
//------------------------------------------------------------------------------------------

int udp_output_server(const char *pBuf, int lSize, ikcpcb *pKCP, void *pCTX) {
    auto *lWeakSelf = (KCPNetServer::KCPServerData *) pCTX;
    if (lWeakSelf) {
        if (lWeakSelf->mWeakKCPNetServer) {
            lWeakSelf->mWeakKCPNetServer->udpOutputServer(pBuf, lSize, lWeakSelf);
        } else {
            KCP_LOGGER(true, LOGG_FATAL, "udp_output_server failed getting 'this'")
        }
    } else {
        KCP_LOGGER(true, LOGG_FATAL, "udp_output_server failed getting KCPServerData")
        return -1; // Throw
    }
    return 0;
}

void KCPNetServer::udpOutputServer(const char *pBuf, int lSize, KCPServerData *lCTX) {
    if (mDropAll) return;
    auto[lSentBytes, lStatus] = mKissnetSocket.send((const std::byte *) pBuf, lSize, &lCTX->mDestination);
    if (lSentBytes != lSize || lStatus != kissnet::socket_status::valid) {
        KCP_LOGGER(false, LOGG_NOTIFY, "Server failed sending data")
    }
}

KCPNetServer::KCPNetServer() {

}

KCPNetServer::~KCPNetServer() {
    uint32_t lDeadLock;
    // Signal close netWorker and nudge thread
    mKissnetSocket.shutdown(); // End net thread
    mKissnetSocket.close(); // End net thread
    mNudgeThreadActive = false; // End nudge thread

    // Join network thread
    if (mNetworkThreadRunning) {
        lDeadLock = 10;
        while (mNetworkThreadRunning) {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            if (!--lDeadLock) {
                KCP_LOGGER(true, LOGG_FATAL, "Server net thread is not ending will terminate anyway")
                break;
            }
        }
    }

    //Join nudge thread
    lDeadLock = 10;
    while (mNudgeThreadRunning) {
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        if (!--lDeadLock) {
            KCP_LOGGER(true, LOGG_FATAL, "Nudge thread not ending will terminate anyway")
            break;
        }
    }

    std::lock_guard<std::mutex> lock(mKCPMapMtx);
    mKCPMap.clear();
    KCP_LOGGER(false, LOGG_NOTIFY, "KCPNetServer Destruct")
}

int KCPNetServer::sendData(const char *pData, size_t lSize, KCPContext *pCTX) {
    std::lock_guard<std::mutex> lock(mKCPMapMtx);
    int lStatus = -1;
    if (mKCPMap.count(pCTX->mKCPSocket)) {
        lStatus = ikcp_send(mKCPMap[pCTX->mKCPSocket]->mKCPServer, pData, lSize);
    } else {
        KCP_LOGGER(false, LOGG_NOTIFY, "KCP Connection is unknown")
    }
    return lStatus;
}

int KCPNetServer::configureKCP(const std::function<void(const char *, size_t, KCPContext *)> &rGotData,
                               const std::function<void(KCPContext *)> &rDisconnect,
                               const std::function<std::shared_ptr<KCPContext>(std::string, uint16_t,
                                                                               std::shared_ptr<KCPContext> &)> &rValidate,
                               const std::string &lIP,
                               uint16_t lPort,
                               std::shared_ptr<KCPContext> pCTX) {
    mCTX = std::move(pCTX);
    if (lIP.empty()) {
        KCP_LOGGER(true, LOGG_FATAL, "IP / HOST must be provided");
        return 1;
    }
    if (!lPort) {
        KCP_LOGGER(true, LOGG_FATAL, "Port must be provided")
        return 1;
    }

    kissnet::udp_socket lCreateSocket(kissnet::endpoint(lIP, lPort));
    mKissnetSocket = std::move(lCreateSocket); //Move ownership to this/me
    mKissnetSocket.bind();

    std::thread([=]() { netWorkerServer(rGotData, rValidate); }).detach();
    std::thread([=]() { kcpNudgeWorkerServer(rDisconnect); }).detach();
    KCP_LOGGER(false, LOGG_NOTIFY, "KCPNetServer Constructed");
    return 0;
}

int KCPNetServer::configureInternal(KCPSettings &rSettings, KCPContext *pCTX) {
    std::lock_guard<std::mutex> lock(mKCPMapMtx);
    int lResult = 0;
    if (mKCPMap.count(pCTX->mKCPSocket)) {
        lResult = ikcp_nodelay(mKCPMap[pCTX->mKCPSocket]->mKCPServer, rSettings.mNoDelay, rSettings.mInterval,
                               rSettings.mResend, !rSettings.mFlow);
        if (lResult) {
            KCP_LOGGER(false, LOGG_ERROR, "ikcp_nodelay server failed.")
            return lResult;
        }
        lResult = ikcp_setmtu(mKCPMap[pCTX->mKCPSocket]->mKCPServer, rSettings.mMtu);
        if (lResult) {
            KCP_LOGGER(false, LOGG_ERROR, "ikcp_setmtu server failed.")
            return lResult;
        }
        lResult = ikcp_wndsize(mKCPMap[pCTX->mKCPSocket]->mKCPServer, rSettings.mSndWnd, rSettings.mRcvWnd);
        if (lResult) {
            KCP_LOGGER(false, LOGG_ERROR, "ikcp_wndsize server failed.")
            return lResult;
        }
    } else {
        KCP_LOGGER(false, LOGG_NOTIFY, "KCP Connection is unknown")
    }
    return lResult;
}

// Im in lock here no need to lock again
void KCPNetServer::sendTimePacket(KCPServerData &rServerData) {

    KCPTimePacket lTimePacket;
    lTimePacket.t1 = std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count();
    if (rServerData.mGotStableTime) {
        lTimePacket.correctionActive = 1;
        lTimePacket.correction = rServerData.mCurrentCorrection;
    }
    auto[lSentBytes, lStatus] = mKissnetSocket.send((const std::byte *) &lTimePacket, sizeof(lTimePacket), &rServerData.mDestination);
    if (lSentBytes != sizeof(lTimePacket) || lStatus != kissnet::socket_status::valid) {
        KCP_LOGGER(false, LOGG_NOTIFY, "Server failed sending timing data")
    }
}

// For now the server is updating all connections every 10ms
void KCPNetServer::kcpNudgeWorkerServer(const std::function<void(KCPContext *)> &rDisconnect) {
    mNudgeThreadRunning = true;
    mNudgeThreadActive = true;
    uint32_t lTimeSleep = 10;
    uint64_t lTimeBase = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count();
    while (mNudgeThreadActive) {
        std::this_thread::sleep_for(std::chrono::milliseconds(lTimeSleep));
        uint64_t lTimeNow = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::steady_clock::now().time_since_epoch()).count() - lTimeBase;

        bool ltimeOutFlag = false;
        if (lTimeNow > mHeartBeatIntervalTrigger) {
            ltimeOutFlag = true;
            mHeartBeatIntervalTrigger += HEART_BEAT_DISTANCE;
            KCP_LOGGER(false, LOGG_NOTIFY, "Heart beat ")
        }

        bool lSendTimeLowFreq = false;
        if (lTimeNow > mSendTimeIntervalTriggerLow) {
            lSendTimeLowFreq = true;
            mSendTimeIntervalTriggerLow += TIME_PACKETS_NORMAL_DISTANCE_MS;
            //KCP_LOGGER(false, LOGG_NOTIFY,"Send time low")
        }

        bool lSendTimeHiFreq = false;
        if (lTimeNow > mSendTimeIntervalTriggerHi) {
            lSendTimeHiFreq = true;
            mSendTimeIntervalTriggerHi += TIME_PACKETS_BURST_DISTANCE_MS;
            //KCP_LOGGER(false, LOGG_NOTIFY,"Send time hi")
        }

        uint32_t lTimeSleepLowest = UINT32_MAX;
        mKCPMapMtx.lock();
        if (!mKCPMap.empty()) {
            std::vector<uint64_t> lRemoveList;
            //for (const auto &rKCP: mKCPMap) {
            for (auto pKCP = mKCPMap.cbegin(); pKCP != mKCPMap.cend() /* not hoisted */; /* no increment */) {
                // KCP_LOGGER(false, LOGG_NOTIFY,"dead server? " << pKCP->second->mKCPServer->dead_link)
                bool lDeleteThis = false;
                if (ltimeOutFlag) {
                    if (!pKCP->second->mConnectionTimeOut && rDisconnect) {
                        mKCPMapMtx.unlock();
                        rDisconnect(pKCP->second->mKCPContext.get());
                        mKCPMapMtx.lock();
                        lDeleteThis = true;
                    }
                    pKCP->second->mConnectionTimeOut--;
                }

                if (lDeleteThis) {
                    KCP_LOGGER(false, LOGG_NOTIFY, "Removed stale client")
                    mKCPMap.erase(pKCP++);
                } else {
                    ikcp_update(pKCP->second->mKCPServer, lTimeNow);
                    uint32_t lTimeSleepCandidate = ikcp_check(pKCP->second->mKCPServer, lTimeNow) - lTimeNow;
                    if (lTimeSleepCandidate < lTimeSleepLowest) {
                        lTimeSleepLowest = lTimeSleepCandidate;
                    }

                    // Time transfer section

                    if (!pKCP->second->mClientGotCorrection && lSendTimeHiFreq) {
                        // We have not corrected any time. send time packet
                        sendTimePacket(*pKCP->second);
                    } else if (pKCP->second->mClientGotCorrection && lSendTimeLowFreq) {
                        // We have synced send a normal packet
                        sendTimePacket(*pKCP->second);
                    }

                    // ---------------------

                    ++pKCP;
                }
            }
        }
        mKCPMapMtx.unlock();
        if (lTimeSleepLowest != UINT32_MAX) {
            lTimeSleep = lTimeSleepLowest;
        } else {
            lTimeSleep = 10;
        }

    }
    KCP_LOGGER(false, LOGG_NOTIFY, "kcpNudgeWorker quitting");
    for (auto pKCP = mKCPMap.cbegin(); pKCP != mKCPMap.cend(); ++pKCP) {
        if (rDisconnect) {
            rDisconnect(pKCP->second->mKCPContext.get());
        }
    }
    mNudgeThreadRunning = false;
}

void KCPNetServer::netWorkerServer(const std::function<void(const char *, size_t, KCPContext *)>& rGotData,
                                   const std::function<std::shared_ptr<KCPContext>(std::string,
                                                                                   uint16_t,
                                                                                   std::shared_ptr<KCPContext> &)> & rValidate) {
    mNetworkThreadRunning = true;
    kissnet::buffer<KCP_MAX_BYTES> receiveBuffer;
    kissnet::addr_collection receiveConnection;
    char lBuffer[KCP_MAX_BYTES];
    while (true) {
        auto[received_bytes, status] = mKissnetSocket.recv(receiveBuffer,0, &receiveConnection);
        if (!received_bytes || status != kissnet::socket_status::valid) {
            KCP_LOGGER(false, LOGG_NOTIFY, "serverWorker quitting");
            break;
        }

        if (mDropAll) continue;

        kissnet::endpoint lFromWho = mKissnetSocket.get_recv_endpoint();
        std::string lKey =  lFromWho.address + ":" + std::to_string(lFromWho.port);

        mKCPMapMtx.lock();
        if (!mKCPMap.count(lKey)) {
            KCP_LOGGER(false, LOGG_NOTIFY, "New server connection")
            std::shared_ptr<KCPContext> lx = std::make_shared<KCPContext>(lKey);
            if (mCTX) {
                lx->mUnsafePointer = mCTX->mUnsafePointer;
                lx->mValue = mCTX->mValue;
                lx->mObject = mCTX->mObject;
            }

            if (rValidate) {
                mKCPMapMtx.unlock();
                auto lCTX = rValidate(lFromWho.address, lFromWho.port, lx);
                if (lCTX == nullptr) {
                    KCP_LOGGER(false, LOGG_NOTIFY, "Connection rejected")
                    continue;
                }
                mKCPMapMtx.lock();
            }

            // Create the connection and hand RCP the data
            auto lConnection = std::make_unique<KCPServerData>();
            lConnection->mKCPContext = lx;
            lConnection->mWeakKCPNetServer = this;
            lConnection->mKCPServer = ikcp_create(lx->mID, lConnection.get());
            if (!lConnection->mKCPServer) {
                throw std::runtime_error("Failed creating KCP");
            }
            lConnection->mKCPServer->output = udp_output_server;
            lConnection->mDestination = receiveConnection;

            mKCPMap[lKey] = std::move(lConnection);
            mKCPMapMtx.unlock();
            configureInternal(lx->mSettings, lx.get());
            if (*(uint64_t *) receiveBuffer.data() == TIME_PREAMBLE_V1) {
                KCP_LOGGER(false, LOGG_NOTIFY, "server got time do nothing")
                continue;
            }
            mKCPMapMtx.lock();
            ikcp_input(mKCPMap[lKey]->mKCPServer, (const char *) receiveBuffer.data(), received_bytes);
            int lRcv = ikcp_recv(mKCPMap[lKey]->mKCPServer, &lBuffer[0], KCP_MAX_BYTES);
            mKCPMapMtx.unlock();
            if (lRcv > 0 && rGotData) {
                rGotData(&lBuffer[0], lRcv, lx.get());
            }
            // The connection is known pass the data to RCP
        } else {
            if (*(uint64_t *) receiveBuffer.data() == TIME_PREAMBLE_V1) {
                auto lTimeData = (KCPTimePacket *) receiveBuffer.data();
                int64_t lTimeNow = std::chrono::duration_cast<std::chrono::microseconds>(
                        std::chrono::steady_clock::now().time_since_epoch()).count();
                lTimeData->t4 = lTimeNow;
                int64_t lDelay = lTimeData->t4 - lTimeData->t1;
                int64_t lCompensation = ((lTimeData->t2 - lTimeData->t1) + (lTimeData->t3 - lTimeData->t4)) / 2;

                // Check T2 - T1 compared to T4 - T3 ?
                // The lowest delay has the lowest diff anyway so let's do that later if needed.

                mKCPMap[lKey]->mListOfDelayAndCompensation.emplace_back(std::make_pair(lDelay, lCompensation));
                if (mKCPMap[lKey]->mListOfDelayAndCompensation.size() > MAX_SAVED_TIME_POINTS) {
                    mKCPMap[lKey]->mListOfDelayAndCompensation.erase(
                            mKCPMap[lKey]->mListOfDelayAndCompensation.begin());
                }

                if (mKCPMap[lKey]->mListOfDelayAndCompensation.size() >= MIN_COLLECTED_TIME_POINTS) {
                    std::vector<std::pair<int64_t, int64_t>> lTimePoints(MIN_COLLECTED_TIME_POINTS);
                    std::partial_sort_copy(mKCPMap[lKey]->mListOfDelayAndCompensation.begin(),
                                           mKCPMap[lKey]->mListOfDelayAndCompensation.end(),
                                           lTimePoints.begin(),
                                           lTimePoints.end());
                    auto[lMinDelay, lMinCompensation] = lTimePoints[0];
                    auto[lMaxDelay, lMaxCompensation] = lTimePoints[MIN_COLLECTED_TIME_POINTS - 1];

                    if (((lMaxDelay - lMinDelay) / 1000) < MAX_DELAY_DIFF_MS && !mKCPMap[lKey]->mGotStableTime) {
                        mKCPMap[lKey]->mGotStableTime = true;
                    }

                    if (mKCPMap[lKey]->mGotStableTime) {
                        mKCPMap[lKey]->mCurrentCorrection = lMinCompensation;
                    }

                    if (!mKCPMap[lKey]->mClientGotCorrection && lTimeData->correctionActive == 2) {
                        mKCPMap[lKey]->mClientGotCorrection = true;
                    }
                }

                KCP_LOGGER(false, LOGG_NOTIFY, "server got time. Delay -> " << lDelay
                                                                            << " lCompensation -> " << lCompensation
                                                                            << " StableTime -> "
                                                                            << mKCPMap[lKey]->mGotStableTime
                                                                            << " Compensation -> "
                                                                            << mKCPMap[lKey]->mCurrentCorrection
                )
                mKCPMapMtx.unlock();
                continue;
            }
            mKCPMap[lKey]->mConnectionTimeOut = HEART_BEAT_TIME_OUT;
            ikcp_input(mKCPMap[lKey]->mKCPServer, (const char *) receiveBuffer.data(), received_bytes);
            int lRcv = ikcp_recv(mKCPMap[lKey]->mKCPServer, &lBuffer[0], KCP_MAX_BYTES);
            mKCPMapMtx.unlock();
            if (lRcv > 0 && rGotData) {
                rGotData(&lBuffer[0], lRcv, mKCPMap[lKey]->mKCPContext.get());
            }
        }
    }
    mNetworkThreadRunning = false;
}

```

`KCPNet.h`:

```h
//
//  _   _______ ______ _   _      _
// | | / /  __ \| ___ \ \ | |    | |
// | |/ /| /  \/| |_/ /  \| | ___| |_
// |    \| |    |  __/| . ` |/ _ \ __|
// | |\  \ \__/\| |   | |\  |  __/ |_
// \_| \_/\____/\_|   \_| \_/\___|\__|
//
//
// Created by Unit-X @ Edgeware AB on 2020-09-30.
//

// C++ wrapper around KCP

// All payload data is little endian.

#ifndef KCP_CPP_KCPNET_H
#define KCP_CPP_KCPNET_H

#include "ikcp.h"
#include "kissnet/kissnet.hpp"
#include <any>
#include <thread>
#include <unordered_map>
#include <functional>
#include <mutex>
#include <vector>
#include <atomic>

// Time preamble
#define TIME_PREAMBLE_V1 0x000100010ff00ff0

// Time constants server
#define MAX_DELAY_DIFF_MS 20
#define MIN_COLLECTED_TIME_POINTS 5
#define MAX_SAVED_TIME_POINTS 100
#define TIME_PACKETS_BURST_DISTANCE_MS 100
#define TIME_PACKETS_NORMAL_DISTANCE_MS 1000

// Time constants client
// The maximum adjustment + and - in microseconds per second allowed
#define MAX_TIME_DRIFT_PPM 500

// Count the HEART_BEAT every x ms.
#define HEART_BEAT_DISTANCE 500
// Time out after HEART_BEAT_DISTANCE ms * HEART_BEAT_TIME_OUT milliseconds
#define HEART_BEAT_TIME_OUT 10

struct KCPTimePacket{
    uint64_t timePreamble = TIME_PREAMBLE_V1; //Version 1 preamble
    int64_t t1 = 0;
    int64_t t2 = 0;
    int64_t t3 = 0;
    int64_t t4 = 0;
    int64_t correction = 0;
    int64_t correctionActive = 0;
};
static_assert(sizeof(KCPTimePacket) == 56, "KCPTimePacket is not the expected size");

class KCPSettings {
public:
    bool mNoDelay = false;  // No delay mode. False: Off / True: On.
    int  mInterval = 10;   // KCP update interval in ms
    int  mResend = 0;       // Retransmit when missed mResend number ACK (Default value is 0)
    bool mFlow = true;      // Flow control, False: Off / True: On.
    int  mMtu = 1472;       // Maximum payload in a single UDP datagram
    int  mSndWnd = 32;      // Send window size
    int  mRcvWnd = 32;      // Receive window size //The doc says 32 the code says 128
};

// Optional context passed to the callbacks
class KCPContext {
public:
    explicit KCPContext (std::string lKey): mKCPSocket(lKey) {

    }
    std::any mObject = nullptr;         // For safe object lifecycles
    void* mUnsafePointer = nullptr;     // Lightweight alternative for unsafe pointers
    uint64_t mValue = 0;                // Generic 64-bit variable
    uint64_t mID = 10;                  //KCP ID to be used
    KCPSettings mSettings;
    std::string mKCPSocket;
};

//------------------------------------------------------------------------------------------
//
// KCP Client
//
//------------------------------------------------------------------------------------------

class KCPNetClient {
public:
    explicit KCPNetClient();
    virtual ~KCPNetClient();

    int sendData(const char* pData, size_t lSize);

    int configureKCP(KCPSettings &rSettings,
                     const std::function<void(const char*, size_t, KCPContext*)> &rGotData,
                     const std::function<void(KCPContext*)> &rDisconnect,
                     const std::string& lIP = "",
                     uint16_t lPort = 0,
                     uint32_t lID = 0,
                     std::shared_ptr<KCPContext> pCTX = nullptr);

    int64_t getNetworkTimeus(); //Network time in us

    void udpOutputClient(const char *pBuf, int lSize); //Method used by the bridge function

    // delete copy and move constructors and assign operators
    KCPNetClient(KCPNetClient const &) = delete;             // Copy construct
    KCPNetClient(KCPNetClient &&) = delete;                  // Move construct
    KCPNetClient &operator=(KCPNetClient const &) = delete;  // Copy assign
    KCPNetClient &operator=(KCPNetClient &&) = delete;      // Move assign

protected:
    std::shared_ptr<KCPContext> mCTX = nullptr;

private:
    void netWorkerClient(const std::function<void(const char*, size_t, KCPContext*)> &rDisconnect);
    void kcpNudgeWorkerClient(const std::function<void(KCPContext*)> &rGotData);

#ifdef _WIN32
    bool mHasSentData = false;
#endif
    std::mutex mKCPNetMtx;
    ikcpcb *mKCP = nullptr; // The KCP handle for client mode
    kissnet::udp_socket mKissnetSocket;
    bool mNetworkThreadRunning = false;
    bool mNudgeThreadRunning = false;
    bool mNudgeThreadActive = false;
    uint64_t mConnectionTimeOut = HEART_BEAT_TIME_OUT;
    uint64_t mHeartBeatIntervalTrigger = 0;
    bool mFirstTimeDelivery = true;
    int64_t mLastDeliveredTime;
    std::atomic<int64_t> mCurrentCorrectionTarget = 0;
    std::atomic<int64_t> mCurrentCorrection = 0;
    std::atomic<bool> mGotCorrection = false;
};

//------------------------------------------------------------------------------------------
//
// KCP Server
//
//------------------------------------------------------------------------------------------

class KCPNetServer {
public:
    class KCPServerData {
    public:
        virtual ~KCPServerData() {
            if (mKCPServer) ikcp_release(mKCPServer);
        }
        KCPNetServer* mWeakKCPNetServer = nullptr;
        ikcpcb* mKCPServer = nullptr;
        std::shared_ptr<KCPContext> mKCPContext = nullptr;
        kissnet::addr_collection mDestination;

        uint64_t mConnectionTimeOut = HEART_BEAT_TIME_OUT;
        bool mGotStableTime = false;
        bool mClientGotCorrection = false;
        std::vector<std::pair<int64_t, int64_t>> mListOfDelayAndCompensation;
        int64_t mCurrentCorrection = 0;
    };

    explicit KCPNetServer();

    virtual ~KCPNetServer();

    int sendData(const char* pData, size_t lSize, KCPContext* pCTX);

    int configureKCP(const std::function<void(const char*, size_t, KCPContext*)> &rGotData,
                     const std::function<void(KCPContext*)> &rDisconnect,
                     const std::function<std::shared_ptr<KCPContext>(std::string, uint16_t, std::shared_ptr<KCPContext>&)> &rValidate,
                     const std::string& lIP = "",
                     uint16_t lport = 0,
                     std::shared_ptr<KCPContext> pCTX = nullptr);

    // Method used by the bridge function
    void udpOutputServer(const char *pBuf, int lSize, KCPServerData* lCTX);

    // delete copy and move constructors and assign operators
    KCPNetServer(KCPNetServer const &) = delete;             // Copy construct
    KCPNetServer(KCPNetServer &&) = delete;                  // Move construct
    KCPNetServer &operator=(KCPNetServer const &) = delete;  // Copy assign
    KCPNetServer &operator=(KCPNetServer &&) = delete;      // Move assign

    bool mDropAll = false;

protected:
    std::shared_ptr<KCPContext> mCTX = nullptr;

private:
    int configureInternal(KCPSettings &rSettings, KCPContext *pCtx);
    void netWorkerServer(const std::function<void(const char*, size_t, KCPContext*)> &rGotData,
                         const std::function<std::shared_ptr<KCPContext>(std::string, uint16_t, std::shared_ptr<KCPContext>&)> &rValidate);
    void kcpNudgeWorkerServer(const std::function<void(KCPContext*)> &rDisconnect);
    void sendTimePacket(KCPServerData &rServerData);

    std::mutex mKCPMapMtx;
    std::unordered_map<std::string, std::unique_ptr<KCPServerData>> mKCPMap;
    kissnet::udp_socket mKissnetSocket;
    bool mNetworkThreadRunning = false;
    bool mNudgeThreadRunning = false;
    bool mNudgeThreadActive = false;
    uint64_t mHeartBeatIntervalTrigger = 0;
    uint64_t mSendTimeIntervalTriggerLow = 0;
    uint64_t mSendTimeIntervalTriggerHi = 0;
};

#endif //KCP_CPP_KCPNET_H

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Edgeware AB

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# KCP - CPP

![alt text](kcp_cpp_logo.png)

**Simple C++ wrapper of the [KCP](https://github.com/skywind3000/kcp) protocol.**

[![alt text](kcp.svg)](https://github.com/skywind3000/kcp)

## Build

Requires cmake version >= **3.10** and **C++17**

**Release:**

```sh
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
cmake --build . --config Release
```

***Debug:***

```sh
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Debug ..
cmake --build . --config Debug
```


*Output:*

**(platform specific)kcpnet.(platform specific)**

(Linux/MacOS -> libkcpnet.a)

(Windows -> kcpnet.lib)


## Current build status

[![kcpcpp_ubuntu](https://github.com/Unit-X/kcp-cpp/workflows/kcpcpp_ubuntu/badge.svg)](https://github.com/Unit-X/kcp-cpp/actions?query=workflow%3Akcpcpp_ubuntu)

[![kcpcpp_macos](https://github.com/Unit-X/kcp-cpp/workflows/kcpcpp_macos/badge.svg)](https://github.com/Unit-X/kcp-cpp/actions?query=workflow%3Akcpcpp_macos)

[![kcpcpp_win](https://github.com/Unit-X/kcp-cpp/workflows/kcpcpp_win/badge.svg)](https://github.com/Unit-X/kcp-cpp/actions?query=workflow%3Akcpcpp_win)


## Usage

```cpp

//----------
//Server ---
//----------

//Create the server 
//1. Data from server callback
//2. Client disconnect callback
//3. Validate new client callback
//4. Listening interface
//5. Listening port
//6. Optional context
KCPNetServer lKcpServer;
lKcpServer.configureKCP(gotDataServer,
                         noConnectionServer,
                         validateConnection,
                         "127.0.0.1",
                         8000,
                         nullptr);


//Send data to the client
//1. Pointer to the data
//2. The size of the data
//3. The pointer to the KCPContext you got when accepting the client
lKcpServer.sendData((const char*)lData.data(), 4000, gRetainThis.get());



//----------
//Client ---
//----------

//Create the client
//1. The settings struct
//2. Got data from server
//3. Lost connection to server
//4. Connect to interface
//5. Connect to port
//6. Connection ID (Must be set identical on the server see -> validateConnection)
//7. Optional context
KCPNetClient lKcpClient;

KCPSettings lSettingsClient;
configureKCP(lSettingsClient,
            gotDataClient,
            noConnectionClient,
            "127.0.0.1",
            8000,
            10,
            nullptr);

//Send data to the server
//1. Pointer to the data
//2. The size of the data
lKcpClient.sendData((const char*)lData.data(), 4000);


//Please see KCP documentation for details.
class KCPSettings {
public:
    bool mNodelay = false;  //No delay mode. False: Off / True: On.
    int  mInterval = 100;   //KCP update interval in ms
    int  mResend = 0;       //Retransmit when missed mResend number ACK (Default value is 0)
    bool mFlow = false;     //Flow control, False: Off / True: On.
    int  mMtu = 1472;       //Maximum payload in a single UDP datagram
    int  mSndWnd = 32;      //Send window size
    int  mRcvWnd = 32;      //Receive window size //The doc says 32 the code says 128
};


```

## Using KCP - CPP in your CMake project

* **Step1** 

Add this in your CMake file.

```
#Include kcpnet
include(ExternalProject)
ExternalProject_Add(project_kcpnet
        GIT_REPOSITORY https://github.com/Unit-X/kcp-cpp
        GIT_SUBMODULES ""
        UPDATE_COMMAND ""
        SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/kcpnet
        BINARY_DIR ${CMAKE_CURRENT_SOURCE_DIR}/kcpnet
        GIT_PROGRESS 1
        BUILD_COMMAND cmake --build ${CMAKE_CURRENT_SOURCE_DIR}/kcpnet --config ${CMAKE_BUILD_TYPE} --target kcpnet
        STEP_TARGETS build
        EXCLUDE_FROM_ALL TRUE
        INSTALL_COMMAND ""
        )
add_library(kcpnet STATIC IMPORTED)
add_library(kcp STATIC IMPORTED)
IF (WIN32)
    set_property(TARGET kcpnet PROPERTY IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/kcpnet/${CMAKE_BUILD_TYPE}/kcpnet.lib)
    set_property(TARGET kcpnet PROPERTY IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/kcpnet/kcp/${CMAKE_BUILD_TYPE}/kcp.lib)
ELSE()
    set_property(TARGET kcpnet PROPERTY IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/kcpnet/libkcpnet.a)
    set_property(TARGET kcp PROPERTY IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/kcpnet/kcp/libkcp.a)
ENDIF()

add_dependencies(kcpnet project_kcpnet)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/kcpnet/)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/kcpnet/kcp/)
```

* **Step2**

Link your library or executable.

```
target_link_libraries((your target) kcpnet kcp (the rest you want to link)) 
```

* **Step3** 

Add header file to your project.

```
#include "KCPNet.h"
```


## Credits

Anders Cedronius for creating the C++ wrapper

anders.cedronius(at)edgeware.tv


## License

*MIT*

Read *LICENCE* for details

```

`kcp.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" width="88" height="20"><linearGradient id="b" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><mask id="a"><rect width="88" height="20" rx="3" fill="#fff"/></mask><g mask="url(#a)"><path fill="#555" d="M0 0h31v20H0z"/><path fill="#007ec6" d="M31 0h57v20H31z"/><path fill="url(#b)" d="M0 0h88v20H0z"/></g><g fill="#fff" text-anchor="middle" font-family="DejaVu Sans,Verdana,Geneva,sans-serif" font-size="11"><text x="15.5" y="15" fill="#010101" fill-opacity=".3">KCP</text><text x="15.5" y="14">KCP</text><text x="58.5" y="15" fill="#010101" fill-opacity=".3">Powered</text><text x="58.5" y="14">Powered</text></g></svg>
```

`kissnet/LICENSE`:

```
MIT License

Copyright (c) 2018-2020 Arthur Brainville (Ybalrid)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`kissnet/kissnet.hpp`:

```hpp
/*
 * MIT License
 *
 * Copyright (c) 2018-2020 Arthur Brainville (Ybalrid) and with the help of
 * Comunity Contributors!
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * INTRODUCTION
 * ============
 *
 * Kissnet is a simple C++17 layer around the raw OS provided socket API to be
 * used on IP networks with the TCP and UDP protocols.
 *
 * Kissnet is not a networking framework, and it will not process your data or
 * assist you in any way. Kissnet's only goal is to provide a simple API to send
 * and receive bytes,
 * without having to play around with a bunch of structure, file descriptors,
 * handles and pointers given to a C-style API. The other goal of kissnet is to
 * provide an API that will works in a cross platform setting.
 *
 * Kissnet will automatically manage the eventual startup/shutdown of the
 * library needed to perform socket operations on a particular platform. (e.g.
 * the Windows Socket API on MS-Windows.
 *
 * Kissnet leverages (and expect you to do so), multiple features from C++17,
 * including: std::byte, if constexpr, structured bindings, if-initializer and
 * template parameter type deduction.
 *
 * The library is structured across 4 exposed data types:
 *
 *  - buffer<size_t> : a static array of std::byte implemented via std::array.
 *  This is what you should use to hold raw data you are getting from a socket,
 *  before extracting what you need from the bytes
 *  - port_t : a 16 bit unsigned number. Represent a network port number
 *  - endpoint : a structure that represent a location where you need to connect
 *  to. Contains a hostname (as std::string) and a port number (as port_t)
 *  - socket<protocol> : a templated class that represents an ipv4 or ipv6 socket.
 *  Protocol is either TCP or UDP
 *
 * Kissnet does error handling in 2 ways:
 *
 *  1:
 *  When an operation can generate an error that the user should handle by hand
 *  anyway, a tuple containing the expected type returned, and an object that
 *  represent the status of what happens is returned.
 *
 *  For example, socket send/receive operation can discover that the connection
 *  was closed, or was shut down properly. It could also be the fact that a
 *  socket was configured "non blocking" and would have blocked in this
 *  situation. On both occasion, these methods will return the fact that 0 bytes
 *  came across as the transaction size, and the status will indicate either an
 *  error (socket no longer valid), or an actual status message (connection
 *  closed, socket would have blocked)
 *
 *  These status objects will behave like a const bool that equals "false" when
 *  an error occurred, and "true" when it's just a status notification
 *
 *  2:
 *  Fatal errors are by default handled by throwing a runtime_error exception.
 *  But, for many reasons, you may want to
 *  not use exceptions entirely.
 *
 *  kissnet give you some facilities to get fatal errors information back, and
 *  to choose how to handle it. Kissnet give you a few levers you can use:
 *
 *  - You can deactivate the exception support by #defining KISSNET_NO_EXCEP
 *  before #including kissnet.hpp. Instead, kissnet will use a function based
 *  error handler
 *  - By default, the error handler prints to stderr the error message, and
 *  abort the program
 *  - kissnet::error::callback is a function pointer that gets a string, and a
 *  context pointer. The string is the error message, and the context pointer
 * what ever you gave kissnet for the occasion. This is a global pointer that
 * you can set as you want. This will override the "print to stderr" behavior
 * at fatal error time.
 *  - kissnet::error::ctx is a void*, this will be passed to your error handler
 *  as a "context" pointer. If you need your handler to write to a log,
 *  or to turn on the HTCPCP enabled teapot on John's desk, you can.
 *  - kissnet::abortOnFatalError is a boolean that will control the call to
 *  abort(). This is independent to the fact that you did set or not an error
 *  callback. please note that any object involved with the operation that
 * triggered the fatal error is probably in an invalid state, and probably
 * deserve to be thrown away.
 */

#ifndef KISS_NET
#define KISS_NET

///Define this to not use exceptions
#ifndef KISSNET_NO_EXCEP
#define kissnet_fatal_error(STR) throw std::runtime_error(STR)
#else
#define kissnet_fatal_error(STR) kissnet::error::handle(STR);
#endif

#include <array>
#include <memory>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <cassert>
#include <stdexcept>
#include <string>
#include <utility>

#ifdef _WIN32

#define _WINSOCK_DEPRECATED_NO_WARNINGS
#define WIN32_LEAN_AND_MEAN

#ifndef NOMINMAX
#define NOMINMAX
#endif //endif nominmax

#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>

using ioctl_setting = u_long;
using buffsize_t	= int;

#define AI_ADDRCONFIG 0x00000400

#ifndef SHUT_RDWR
#define SHUT_RDWR SD_BOTH
#endif

// taken from: https://github.com/rxi/dyad/blob/915ae4939529b9aaaf6ebfd2f65c6cff45fc0eac/src/dyad.c#L58
inline const char* inet_ntop(int af, const void* src, char* dst, socklen_t size)
{
	union
	{
		struct sockaddr sa;
		struct sockaddr_in sai;
		struct sockaddr_in6 sai6;
	} addr;
	int res;
	memset(&addr, 0, sizeof(addr));
	addr.sa.sa_family = af;
	if (af == AF_INET6)
	{
		memcpy(&addr.sai6.sin6_addr, src, sizeof(addr.sai6.sin6_addr));
	}
	else
	{
		memcpy(&addr.sai.sin_addr, src, sizeof(addr.sai.sin_addr));
	}
	res = WSAAddressToStringA(&addr.sa, sizeof(addr), 0, dst, reinterpret_cast<LPDWORD>(&size));
	if (res != 0) return NULL;
	return dst;
}

//Handle WinSock2/Windows Socket API initialization and cleanup
#pragma comment(lib, "Ws2_32.lib")
namespace kissnet
{

	namespace win32_specific
	{
		///Forward declare the object that will permit to manage the WSAStartup/Cleanup automatically
		struct WSA;

		///Enclose the global pointer in this namespace. Only use this inside a shared_ptr
		namespace internal_state
		{
			static WSA* global_WSA = nullptr;
		}

		///WSA object. Only to be constructed with std::make_shared()
		struct WSA : std::enable_shared_from_this<WSA>
		{
			//For safety, only initialize Windows Socket API once, and delete it once
			///Prevent copy construct
			WSA(const WSA&) = delete;
			///Prevent copy assignment
			WSA& operator=(const WSA&) = delete;
			///Prevent moving
			WSA(WSA&&) = delete;
			///Prevent move assignment
			WSA& operator=(WSA&&) = delete;

			///data storage
			WSADATA wsa_data;

			///Startup
			WSA() :
			 wsa_data {}
			{
				if (const auto status = WSAStartup(MAKEWORD(2, 2), &wsa_data); status != 0)
				{
					std::string error_message;
					switch (status) // https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup#return-value
					{
						default:
							error_message = "Unknown error happened.";
							break;
						case WSASYSNOTREADY:
							error_message = "The underlying network subsystem is not ready for network communication.";
							break;
						case WSAVERNOTSUPPORTED: //unlikely, we specify 2.2!
							error_message = " The version of Windows Sockets support requested "
											"(2.2)" //we know here the version was 2.2, add that to the error message copied from MSDN
											" is not provided by this particular Windows Sockets implementation. ";
							break;
						case WSAEINPROGRESS:
							error_message = "A blocking Windows Sockets 1.1 operation is in progress.";
							break;
						case WSAEPROCLIM:
							error_message = "A limit on the number of tasks supported by the Windows Sockets implementation has been reached.";
							break;
						case WSAEFAULT: //unlikely, if this ctor is running, wsa_data is part of this object's "stack" data
							error_message = "The lpWSAData parameter is not a valid pointer.";
							break;
					}
					kissnet_fatal_error(error_message);
				}
#ifdef KISSNET_WSA_DEBUG
				std::cerr << "Initialized Windows Socket API\n";
#endif
			}

			///Cleanup
			~WSA()
			{
				WSACleanup();
				internal_state::global_WSA = nullptr;
#ifdef KISSNET_WSA_DEBUG
				std::cerr << "Cleanup Windows Socket API\n";
#endif
			}

			///get the shared pointer
			std::shared_ptr<WSA> getPtr()
			{
				return shared_from_this();
			}
		};

		///Get-or-create the global pointer
		inline std::shared_ptr<WSA> getWSA()
		{
			//If it has been created already:
			if (internal_state::global_WSA)
				return internal_state::global_WSA->getPtr(); //fetch the smart pointer from the naked pointer

			//Create in wsa
			auto wsa = std::make_shared<WSA>();

			//Save the raw address in the global state
			internal_state::global_WSA = wsa.get();

			//Return the smart pointer
			return wsa;
		}
	}

#define KISSNET_OS_SPECIFIC_PAYLOAD_NAME wsa_ptr
#define KISSNET_OS_SPECIFIC std::shared_ptr<kissnet::win32_specific::WSA> KISSNET_OS_SPECIFIC_PAYLOAD_NAME
#define KISSNET_OS_INIT KISSNET_OS_SPECIFIC_PAYLOAD_NAME = kissnet::win32_specific::getWSA()

	///Return the last error code
	inline int get_error_code()
	{
		const auto error = WSAGetLastError();

		//We need to posixify the values that we are actually using inside this header.
		switch (error)
		{
			case WSAEWOULDBLOCK:
				return EWOULDBLOCK;
			case WSAEBADF:
				return EBADF;
			case WSAEINTR:
				return EINTR;
			default:
				return error;
		}
	}
}
#else //UNIX platform

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netdb.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>

using ioctl_setting = int;
using buffsize_t	= size_t;

//To get consistent socket API between Windows and Linux:
static const int INVALID_SOCKET = -1;
static const int SOCKET_ERROR	= -1;
using SOCKET					= int;
using SOCKADDR_IN				= sockaddr_in;
using SOCKADDR					= sockaddr;
using IN_ADDR					= in_addr;

//Wrap them in their WIN32 names
inline int closesocket(SOCKET in)
{
    return close(in);
}

template <typename... Params>
inline int ioctlsocket(int fd, int request, Params&&... params)
{
    return ioctl(fd, request, params...);
}

#define KISSNET_OS_SPECIFIC_PAYLOAD_NAME dummy
#define KISSNET_OS_SPECIFIC char dummy
#define KISSNET_OS_INIT dummy = 42;

namespace unix_specific
{
}

inline int get_error_code()
{
    return errno;
}

#endif //ifdef WIN32

#ifdef KISSNET_USE_OPENSSL

#include <openssl/ssl.h>
#include <openssl/err.h>

#include <vector>
#include <mutex>

#endif //Kissnet use OpenSSL

#ifndef SOL_TCP
#define SOL_TCP IPPROTO_TCP
#endif

///Main namespace of kissnet
namespace kissnet
{

    ///Exception-less error handling infrastructure
    namespace error
    {
        static void (*callback)(const std::string&, void* ctx) = nullptr;
        static void* ctx									   = nullptr;
        static bool abortOnFatalError						   = true;

        inline void handle(const std::string& str)
        {
            //if the error::callback function has been provided, call that
            if (callback)
            {
                callback(str, ctx);
            }
                //Print error into the standard error output
            else
            {
                fputs(str.c_str(), stderr);
            }

            //If the error abort hasn't been deactivated
            if (abortOnFatalError)
            {
                abort();
            }
        }
    }

    ///low level protocol used, between TCP\TCP_SSL and UDP
    enum class protocol {
        tcp,
        tcp_ssl,
        udp
    };

    ///Address information structs
    struct addr_collection {
        sockaddr_storage adrinf = {0};
        socklen_t sock_size = 0;
    };

    ///File descriptor set types
    static constexpr int fds_read	= 0x1;
    static constexpr int fds_write	= 0x2;
    static constexpr int fds_except = 0x4;

    ///buffer is an array of std::byte
    template <size_t buff_size>
    using buffer = std::array<std::byte, buff_size>;

    ///port_t is the port
    using port_t = uint16_t;

    ///An endpoint is where the network will connect to (address and port)
    struct endpoint
    {
        ///The address to connect to
        std::string address {};

        ///The port to connect to
        port_t port {};

        ///Default constructor, the endpoint is not valid at that point, but you can set the address/port manually
        endpoint() = default;

        ///Basically create the endpoint with what you give it
        endpoint(std::string addr, port_t prt) :
                address { std::move(addr) }, port { prt }
        { }

        static bool is_valid_port_number(unsigned long n)
        {
            return n < 1 << 16;
        }

        ///Construct the endpoint from "address:port"
        endpoint(std::string addr)
        {
            const auto separator = addr.find_last_of(':');

            //Check if input wasn't missformed
            if (separator == std::string::npos)
                kissnet_fatal_error("string is not of address:port form");
            if (separator == addr.size() - 1)
                kissnet_fatal_error("string has ':' as last character. Expected port number here");

            //Isolate address
            address = addr.substr(0, separator);

            //Read from string as unsigned
            const auto parsed_port = strtoul(addr.substr(separator + 1).c_str(), nullptr, 10);

            //In all other cases, port was always given as a port_t type, strongly preventing it to be a number outside of the [0; 65535] range. Here it's not the case.
            //To detect errors early, check it here :
            if (!is_valid_port_number(parsed_port))
                kissnet_fatal_error("Invalid port number " + std::to_string(parsed_port));

            //Store it
            port = static_cast<port_t>(parsed_port);
        }

        ///Construct an endpoint from a SOCKADDR
        endpoint(SOCKADDR* addr)
        {

            switch (addr->sa_family)
            {
                case AF_INET: {
                    auto ip_addr = (SOCKADDR_IN*)(addr);
                    address		 = inet_ntoa(ip_addr->sin_addr);
                    port		 = ntohs(ip_addr->sin_port);
                }
                    break;

                case AF_INET6: {
                    auto ip_addr = (sockaddr_in6*)(addr);
                    char buffer[INET6_ADDRSTRLEN];
                    address = inet_ntop(AF_INET6, &(ip_addr->sin6_addr), buffer, INET6_ADDRSTRLEN);
                    port	= ntohs(ip_addr->sin6_port);
                }
                    break;

                default: {
                    kissnet_fatal_error("Trying to construct an endpoint for a protocol familly that is neither AF_INET or AF_INET6");
                }
            }

            if (address.empty())
                kissnet_fatal_error("Couldn't construct endpoint from sockaddr(_storage) struct");
        }
    };

    //Wrap "system calls" here to avoid conflicts with the names used in the socket class

    ///socket()
    inline auto syscall_socket = [](int af, int type, int protocol) {
        return ::socket(af, type, protocol);
    };

    ///select()
    inline auto syscall_select = [](int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout) {
        return ::select(nfds, readfds, writefds, exceptfds, timeout);
    };

    ///recv()
    inline auto syscall_recv = [](SOCKET s, char* buff, buffsize_t len, int flags) {
        return ::recv(s, buff, len, flags);
    };

    ///send()
    inline auto syscall_send = [](SOCKET s, const char* buff, buffsize_t len, int flags) {
        return ::send(s, buff, len, flags);
    };

    ///bind()
    inline auto syscall_bind = [](SOCKET s, const struct sockaddr* name, socklen_t namelen) {
        return ::bind(s, name, namelen);
    };

    ///connect()
    inline auto syscall_connect = [](SOCKET s, const struct sockaddr* name, socklen_t namelen) {
        return ::connect(s, name, namelen);
    };

    ///listen()
    inline auto syscall_listen = [](SOCKET s, int backlog) {
        return ::listen(s, backlog);
    };

    ///accept()
    inline auto syscall_accept = [](SOCKET s, struct sockaddr* addr, socklen_t* addrlen) {
        return ::accept(s, addr, addrlen);
    };

    ///shutdown()
    inline auto syscall_shutdown = [](SOCKET s) {
        return ::shutdown(s, SHUT_RDWR);
    };

    ///Represent the status of a socket as returned by a socket operation (send, received). Implicitly convertible to bool
    struct socket_status
    {
        ///Enumeration of socket status, with a 1 byte footprint
        enum values : int8_t {
            errored							= 0x0,
            valid							= 0x1,
            cleanly_disconnected			= 0x2,
            non_blocking_would_have_blocked = 0x3,
            timed_out						= 0x4

            /* ... any other info on a "still valid socket" goes here ... */

        };

        ///Actual value of the socket_status.
        const values value;

        ///Use the default constructor
        socket_status() :
                value { errored } { }

        ///Construct a "errored/valid" status for a true/false
        explicit socket_status(bool state) :
                value(values(state ? valid : errored)) { }

        socket_status(values v) :
                value(v) { }

        ///Copy socket status by default
        socket_status(const socket_status&) = default;

        ///Move socket status by default
        socket_status(socket_status&&) = default;

        ///implicitly convert this object to const bool (as the status should not change)
        operator bool() const
        {
            //See the above enum: every value <= 0 correspond to an error, and will return false. Every value > 0 returns true
            return value > 0;
        }

        int8_t get_value()
        {
            return value;
        }

        bool operator==(values v)
        {
            return v == value;
        }
    };

#ifdef KISSNET_USE_OPENSSL
    #if OPENSSL_VERSION_NUMBER < 0x10100000L
	static std::shared_ptr<std::vector<std::mutex>> SSL_lock_cs;

	class ThreadSafe_SSL
	{
	public:
		ThreadSafe_SSL()
		{
			SSL_lock_cs = std::make_shared<std::vector<std::mutex>>(CRYPTO_num_locks());

			CRYPTO_set_locking_callback((void (*)(int, int, const char*, int))
											win32_locking_callback);
		}

		~ThreadSafe_SSL() { CRYPTO_set_locking_callback(nullptr); }

	private:
		static void win32_locking_callback(int mode, int type, const char* file, int line)
		{
			auto& locks = *SSL_lock_cs;

			if (mode & CRYPTO_LOCK)
			{
				locks[type].lock();
			}
			else
			{
				locks[type].unlock();
			}
		}
	};

#endif

	class Initialize_SSL
	{
	public:
		Initialize_SSL()
		{
#if OPENSSL_VERSION_NUMBER < 0x1010001fL
			SSL_load_error_strings();
			SSL_library_init();
#else
			OPENSSL_init_ssl(
				OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);

			OPENSSL_init_crypto(
				OPENSSL_INIT_LOAD_CONFIG | OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS,
				nullptr);
#endif
		}

		~Initialize_SSL()
		{
#if OPENSSL_VERSION_NUMBER < 0x1010001fL
			ERR_free_strings();
#endif
		}

#if OPENSSL_VERSION_NUMBER < 0x10100000L
	private:
		ThreadSafe_SSL thread_setup;
#endif
	};

	static Initialize_SSL InitializeSSL;
#endif

    ///Class that represent a socket
    template <protocol sock_proto>
    class socket
    {
        ///Represent a number of bytes with a status information. Some of the methods of this class returns this.
        using bytes_with_status = std::tuple<size_t, socket_status>;

        ///OS specific stuff. payload we have to hold onto for RAII management of the Operating System's socket library (e.g. Windows Socket API WinSock2)
        KISSNET_OS_SPECIFIC;

        ///operatic-system type for a socket object
        SOCKET sock = INVALID_SOCKET;

#ifdef KISSNET_USE_OPENSSL
        SSL* pSSL		  = nullptr;
		SSL_CTX* pContext = nullptr;
#endif

        ///Location where this socket is bound
        endpoint bind_loc = {};

        ///Address information structures
        addrinfo getaddrinfo_hints	  = {};
        addrinfo* getaddrinfo_results = nullptr;
        addrinfo* socket_addrinfo	  = nullptr;

        void initialize_addrinfo()
        {
            int type {};
            int iprotocol {};
            if constexpr (sock_proto == protocol::tcp || sock_proto == protocol::tcp_ssl)
            {
                type	  = SOCK_STREAM;
                iprotocol = IPPROTO_TCP;
            }

            else if constexpr (sock_proto == protocol::udp)
            {
                type	  = SOCK_DGRAM;
                iprotocol = IPPROTO_UDP;
            }

            getaddrinfo_hints			  = {};
            getaddrinfo_hints.ai_family	  = AF_UNSPEC;
            getaddrinfo_hints.ai_socktype = type;
            getaddrinfo_hints.ai_protocol = iprotocol;
            getaddrinfo_hints.ai_flags	  = AI_ADDRCONFIG;
        }

        ///Create and connect to socket
        socket_status connect(addrinfo* addr, int64_t timeout, bool createsocket)
        {
            if constexpr (sock_proto == protocol::tcp || sock_proto == protocol::tcp_ssl) //only TCP is a connected protocol
            {
                if (createsocket)
                {
                    close();
                    socket_addrinfo = nullptr;
                    sock			= syscall_socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
                }

                if (sock == INVALID_SOCKET)
                    return socket_status::errored;

                socket_addrinfo = addr;

                if (timeout > 0)
                    set_non_blocking(true);

                int error = syscall_connect(sock, addr->ai_addr, socklen_t(addr->ai_addrlen));
                if (error == SOCKET_ERROR)
                {
                    error = get_error_code();
                    if (error == EWOULDBLOCK || error == EAGAIN || error == EINPROGRESS)
                    {
                        struct timeval tv;
                        tv.tv_sec  = static_cast<long>(timeout / 1000);
                        tv.tv_usec = 1000 * static_cast<long>(timeout % 1000);

                        fd_set fd_write, fd_except;
                        ;
                        FD_ZERO(&fd_write);
                        FD_SET(sock, &fd_write);
                        FD_ZERO(&fd_except);
                        FD_SET(sock, &fd_except);

                        int ret = syscall_select(static_cast<int>(sock) + 1, NULL, &fd_write, &fd_except, &tv);
                        if (ret == -1)
                            error = get_error_code();
                        else if (ret == 0)
                            error = ETIMEDOUT;
                        else
                        {
                            socklen_t errlen = sizeof(error);
                            if (getsockopt(sock, SOL_SOCKET, SO_ERROR, reinterpret_cast<char*>(&error), &errlen) != 0)
                                kissnet_fatal_error("getting socket error returned an error");
                        }
                    }
                }

                if (timeout > 0)
                    set_non_blocking(false);

                if (error == 0)
                {
                    return socket_status::valid;
                }
                else
                {
                    close();
                    socket_addrinfo = nullptr;
                    return socket_status::errored;
                }
            }

            kissnet_fatal_error("connect called for non-tcp socket");
        }

        ///sockaddr struct
        sockaddr_storage socket_input  = {};
        socklen_t socket_input_socklen = 0;

    public:

        ///Construct an invalid socket
        socket() = default;

        ///socket<> isn't copyable
        socket(const socket&) = delete;

        ///socket<> isn't copyable
        socket& operator=(const socket&) = delete;

        ///Move constructor. socket<> isn't copyable
        socket(socket&& other) noexcept
        {
            KISSNET_OS_SPECIFIC_PAYLOAD_NAME = std::move(other.KISSNET_OS_SPECIFIC_PAYLOAD_NAME);
            bind_loc						 = std::move(other.bind_loc);
            sock							 = std::move(other.sock);
            socket_input					 = std::move(other.socket_input);
            socket_input_socklen			 = std::move(other.socket_input_socklen);
            getaddrinfo_results				 = std::move(other.getaddrinfo_results);
            socket_addrinfo					 = std::move(other.socket_addrinfo);

#ifdef KISSNET_USE_OPENSSL
            pSSL		   = other.pSSL;
			pContext	   = other.pContext;
			other.pSSL	   = nullptr;
			other.pContext = nullptr;
#endif

            other.sock				  = INVALID_SOCKET;
            other.getaddrinfo_results = nullptr;
            other.socket_addrinfo	  = nullptr;
        }

        ///Move assign operation
        socket& operator=(socket&& other) noexcept
        {
            if (this != &other)
            {
                if (!(sock < 0) || sock != INVALID_SOCKET)
                    closesocket(sock);

                KISSNET_OS_SPECIFIC_PAYLOAD_NAME = std::move(other.KISSNET_OS_SPECIFIC_PAYLOAD_NAME);
                bind_loc						 = std::move(other.bind_loc);
                sock							 = std::move(other.sock);
                socket_input					 = std::move(other.socket_input);
                socket_input_socklen			 = std::move(other.socket_input_socklen);
                getaddrinfo_results				 = std::move(other.getaddrinfo_results);
                socket_addrinfo					 = std::move(other.socket_addrinfo);

#ifdef KISSNET_USE_OPENSSL
                pSSL		   = other.pSSL;
				pContext	   = other.pContext;
				other.pSSL	   = nullptr;
				other.pContext = nullptr;
#endif

                other.sock				  = INVALID_SOCKET;
                other.getaddrinfo_results = nullptr;
                other.socket_addrinfo	  = nullptr;
            }
            return *this;
        }

        ///Return true if the underlying OS provided socket representation (file descriptor, handle...). Both socket are pointing to the same thing in this case
        bool operator==(const socket& other) const
        {
            return sock == other.sock;
        }

        ///Return true if socket is valid. If this is false, you probably shouldn't attempt to send/receive anything, it will probably explode in your face!
        bool is_valid() const
        {
            return sock != INVALID_SOCKET;
        }

        inline operator bool() const
        {
            return is_valid();
        }

        ///Construct socket and (if applicable) connect to the endpoint
        socket(endpoint bind_to) :
                bind_loc { std::move(bind_to) }
        {
            //operating system related housekeeping
            KISSNET_OS_INIT;

            //Do we use streams or datagrams
            initialize_addrinfo();

            if (getaddrinfo(bind_loc.address.c_str(), std::to_string(bind_loc.port).c_str(), &getaddrinfo_hints, &getaddrinfo_results) != 0)
            {
                kissnet_fatal_error("getaddrinfo failed!");
            }

            for (auto* addr = getaddrinfo_results; addr; addr = addr->ai_next)
            {
                sock = syscall_socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
                if (sock != INVALID_SOCKET)
                {
                    socket_addrinfo = addr;
                    break;
                }
            }

            if (sock == INVALID_SOCKET)
            {
                kissnet_fatal_error("unable to create socket!");
            }
        }

        ///Construct a socket from an operating system socket, an additional endpoint to remember from where we are
        socket(SOCKET native_sock, endpoint bind_to) :
                sock { native_sock }, bind_loc(std::move(bind_to))
        {
            KISSNET_OS_INIT;

            initialize_addrinfo();
        }

        ///Set the socket in non blocking mode
        /// \param state By default "true". If put to false, it will set the socket back into blocking, normal mode
        void set_non_blocking(bool state = true) const
        {
#ifdef _WIN32
            ioctl_setting set = state ? 1 : 0;
			if (ioctlsocket(sock, FIONBIO, &set) < 0)
#else
            const auto flags	= fcntl(sock, F_GETFL, 0);
            const auto newflags = state ? flags | O_NONBLOCK : flags ^ O_NONBLOCK;
            if (fcntl(sock, F_SETFL, newflags) < 0)
#endif
                kissnet_fatal_error("setting socket to nonblock returned an error");
        }

        ///Set the socket option for broadcasts
        /// \param state By default "true". If put to false, it will disable broadcasts
        void set_broadcast(bool state = true) const
        {
            const int broadcast = state ? 1 : 0;
            if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, reinterpret_cast<const char*>(&broadcast), sizeof(broadcast)) != 0)
                kissnet_fatal_error("setting socket broadcast mode returned an error");
        }

        /// Set the socket option for TCPNoDelay
        /// \param state By default "true". If put to false, it will disable TCPNoDelay
        void set_tcp_no_delay(bool state = true) const
        {
            if constexpr (sock_proto == protocol::tcp)
            {
                const int tcpnodelay = state ? 1 : 0;
                if (setsockopt(sock, SOL_TCP, TCP_NODELAY, reinterpret_cast<const char*>(&tcpnodelay), sizeof(tcpnodelay)) != 0)
                    kissnet_fatal_error("setting socket tcpnodelay mode returned an error");
            }
        }

        /// Get socket status
        socket_status get_status() const
        {
            int sockerror	 = 0;
            socklen_t errlen = sizeof(sockerror);
            if (getsockopt(sock, SOL_SOCKET, SO_ERROR, reinterpret_cast<char*>(&sockerror), &errlen) != 0)
                kissnet_fatal_error("getting socket error returned an error");

            return sockerror == SOCKET_ERROR ? socket_status::errored : socket_status::valid;
        }

        ///Bind socket locally using the address and port of the endpoint
        void bind()
        {
            if (syscall_bind(sock, static_cast<SOCKADDR*>(socket_addrinfo->ai_addr), socklen_t(socket_addrinfo->ai_addrlen)) == SOCKET_ERROR)
            {
                kissnet_fatal_error("bind() failed\n");
            }
        }

        ///Join a multicast group
        void join(const endpoint& multi_cast_endpoint, const std::string& interface = "")
        {
            if (sock_proto != protocol::udp)
            {
                kissnet_fatal_error("joining a multicast is only possible in UDP mode\n");
            }

            addrinfo *multicast_addr;
            addrinfo *local_addr;
            addrinfo  hints = {0};
            hints.ai_family = PF_UNSPEC;
            hints.ai_flags  = AI_NUMERICHOST;
            if (getaddrinfo(multi_cast_endpoint.address.c_str(), nullptr, &hints, &multicast_addr) != 0)
            {
                kissnet_fatal_error("getaddrinfo() failed\n");
            }

            hints.ai_family   = multicast_addr->ai_family;
            hints.ai_socktype = SOCK_DGRAM;
            hints.ai_flags    = AI_PASSIVE;
            if (getaddrinfo(nullptr, std::to_string(multi_cast_endpoint.port).c_str(), &hints, &local_addr) != 0)
            {
                kissnet_fatal_error("getaddrinfo() failed\n");
            }

            sock = syscall_socket(local_addr->ai_family, local_addr->ai_socktype, local_addr->ai_protocol);
            if (sock != INVALID_SOCKET)
            {
                socket_addrinfo = local_addr;
            } else {
                kissnet_fatal_error("syscall_socket() failed\n");
            }

            bind();

            //IPv4
            if (multicast_addr->ai_family  == PF_INET && multicast_addr->ai_addrlen == sizeof(struct sockaddr_in))
            {
                struct ip_mreq multicastRequest = {0};
                memcpy(&multicastRequest.imr_multiaddr,
                       &((struct sockaddr_in*)(multicast_addr->ai_addr))->sin_addr,
                       sizeof(multicastRequest.imr_multiaddr));

                if (interface.length()) {
                    multicastRequest.imr_interface.s_addr = inet_addr(interface.c_str());;
                } else {
                    multicastRequest.imr_interface.s_addr = htonl(INADDR_ANY);
                }

                if (setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*) &multicastRequest, sizeof(multicastRequest)) != 0)
                {
                    kissnet_fatal_error("setsockopt() failed\n");
                }
            }

                //IPv6
            else if (multicast_addr->ai_family  == PF_INET6 && multicast_addr->ai_addrlen == sizeof(struct sockaddr_in6))
            {
                struct ipv6_mreq multicastRequest = {0};
                memcpy(&multicastRequest.ipv6mr_multiaddr,
                       &((struct sockaddr_in6*)(multicast_addr->ai_addr))->sin6_addr,
                       sizeof(multicastRequest.ipv6mr_multiaddr));

                if (interface.length()) {
                    struct addrinfo *reslocal;
                    if (getaddrinfo(interface.c_str(), nullptr, nullptr, &reslocal)){
                        kissnet_fatal_error("getaddrinfo() failed\n");
                    }
                    multicastRequest.ipv6mr_interface = ((sockaddr_in6 *)reslocal->ai_addr)->sin6_scope_id;
                    freeaddrinfo(reslocal);
                } else {
                    multicastRequest.ipv6mr_interface = 0;
                }


                if (setsockopt(sock, IPPROTO_IPV6, IPV6_JOIN_GROUP, (char*) &multicastRequest, sizeof(multicastRequest)) != 0)
                {
                    kissnet_fatal_error("setsockopt() failed\n");
                }
            }
            else
            {
                kissnet_fatal_error("unknown AI family.\n");
            }

            freeaddrinfo(multicast_addr);
        }

        ///(For TCP) connect to the endpoint as client
        socket_status connect(int64_t timeout = 0)
        {
            if constexpr (sock_proto == protocol::tcp) //only TCP is a connected protocol
            {
                // try to connect to existing native socket, if any.
                auto curr_addr = socket_addrinfo;
                if (connect(curr_addr, timeout, false) != socket_status::valid)
                {
                    // try to create/connect native socket for one of the other addrinfo, if any
                    for (auto* addr = getaddrinfo_results; addr; addr = addr->ai_next)
                    {
                        if (addr == curr_addr)
                            continue; // already checked

                        if (connect(addr, timeout, true) == socket_status::valid)
                            break; // success
                    }
                }

                if (sock == INVALID_SOCKET)
                    kissnet_fatal_error("unable to create connectable socket!");

                return socket_status::valid;
            }
#ifdef KISSNET_USE_OPENSSL
            else if constexpr (sock_proto == protocol::tcp_ssl) //only TCP is a connected protocol
			{
				// try to connect to existing native socket, if any.
				auto curr_addr = socket_addrinfo;
				if (connect(curr_addr, timeout, false) != socket_status::valid)
				{
					// try to create/connect native socket for one of the other addrinfo, if any
					for (auto* addr = getaddrinfo_results; addr; addr = addr->ai_next)
					{
						if (addr == curr_addr)
							continue; // already checked

						if (connect(addr, timeout, true) == socket_status::valid)
							break; // success
					}
				}

				if (sock == INVALID_SOCKET)
					kissnet_fatal_error("unable to create connectable socket!");

				auto* pMethod =
#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
					TLSv1_2_client_method();
#else
					TLS_client_method();
#endif

				pContext = SSL_CTX_new(pMethod);
				pSSL	 = SSL_new(pContext);
				if (!pSSL)
					return socket_status::errored;

				if (!(static_cast<bool>(SSL_set_fd(pSSL, sock))))
					return socket_status::errored;

				if (SSL_connect(pSSL) != 1)
					return socket_status::errored;

				return socket_status::valid;
			}
#endif
        }

        ///(for TCP= setup socket to listen to connection. Need to be called on binded socket, before being able to accept()
        void listen()
        {
            if constexpr (sock_proto == protocol::tcp)
            {
                if (syscall_listen(sock, SOMAXCONN) == SOCKET_ERROR)
                {
                    kissnet_fatal_error("listen failed\n");
                }
            }
        }

        ///(for TCP) Wait for incoming connection, return socket connect to the client. Blocking.
        socket accept()
        {
            if constexpr (sock_proto != protocol::tcp)
            {
                return { INVALID_SOCKET, {} };
            }

            sockaddr_storage socket_address;
            SOCKET s;
            socklen_t size = sizeof socket_address;

            if ((s = syscall_accept(sock, reinterpret_cast<SOCKADDR*>(&socket_address), &size)) == INVALID_SOCKET)
            {
                const auto error = get_error_code();
                switch (error)
                {
                    case EWOULDBLOCK: //if socket "would have blocked" from the call, ignore
                    case EINTR:		  //if blocking call got interrupted, ignore;
                        return {};
                }

                kissnet_fatal_error("accept() returned an invalid socket\n");
            }

            return { s, endpoint(reinterpret_cast<SOCKADDR*>(&socket_address)) };
        }

        void close()
        {
            if (sock != INVALID_SOCKET)
            {
#ifdef KISSNET_USE_OPENSSL
                if constexpr (sock_proto == protocol::tcp_ssl)
				{
					if (pSSL)
					{
						SSL_set_shutdown(pSSL, SSL_RECEIVED_SHUTDOWN | SSL_SENT_SHUTDOWN);
						SSL_shutdown(pSSL);
						SSL_free(pSSL);
						if (pContext)
							SSL_CTX_free(pContext);
					}
				}
#endif

                closesocket(sock);
            }

            sock = INVALID_SOCKET;
        }

        void shutdown()
        {
            if (sock != INVALID_SOCKET)
            {
                syscall_shutdown(sock);
            }
        }

        ///Close socket on destruction
        ~socket()
        {
            close();

            if (getaddrinfo_results)
                freeaddrinfo(getaddrinfo_results);
        }

        ///Select socket with timeout
        socket_status select(int fds, int64_t timeout)
        {
            fd_set fd_read, fd_write, fd_except;
            ;
            struct timeval tv;

            tv.tv_sec  = static_cast<long>(timeout / 1000);
            tv.tv_usec = 1000 * static_cast<long>(timeout % 1000);

            if (fds & fds_read)
            {
                FD_ZERO(&fd_read);
                FD_SET(sock, &fd_read);
            }
            if (fds & fds_write)
            {
                FD_ZERO(&fd_write);
                FD_SET(sock, &fd_write);
            }
            if (fds & fds_except)
            {
                FD_ZERO(&fd_except);
                FD_SET(sock, &fd_except);
            }

            int ret = syscall_select(static_cast<int>(sock) + 1,
                                     fds & fds_read ? &fd_read : NULL,
                                     fds & fds_write ? &fd_write : NULL,
                                     fds & fds_except ? &fd_except : NULL,
                                     &tv);
            if (ret == -1)
                return socket_status::errored;
            else if (ret == 0)
                return socket_status::timed_out;
            return socket_status::valid;
        }

        template <size_t buff_size>
        bytes_with_status send(const buffer<buff_size>& buff, const size_t length = buff_size, addr_collection* addr = nullptr)
        {
            assert(buff_size >= length);
            return send(buff.data(), length, addr);
        }

        ///Send some bytes through the pipe
        bytes_with_status send(const std::byte* read_buff, size_t length, addr_collection* addr = nullptr)
        {
            auto received_bytes { 0 };
            if constexpr (sock_proto == protocol::tcp)
            {
                received_bytes = syscall_send(sock, reinterpret_cast<const char*>(read_buff), static_cast<buffsize_t>(length), 0);
            }
#ifdef KISSNET_USE_OPENSSL
                else if constexpr (sock_proto == protocol::tcp_ssl)
			{
				received_bytes = SSL_write(pSSL, reinterpret_cast<const char*>(read_buff), static_cast<buffsize_t>(length));
			}
#endif
            else if constexpr (sock_proto == protocol::udp)
            {
                if (addr) {
                    received_bytes = sendto(sock, reinterpret_cast<const char*>(read_buff), static_cast<buffsize_t>(length), 0, reinterpret_cast<sockaddr*>(&addr->adrinf) , addr->sock_size);
                } else {
                    received_bytes = sendto(sock, reinterpret_cast<const char*>(read_buff), static_cast<buffsize_t>(length), 0, static_cast<SOCKADDR*>(socket_addrinfo->ai_addr), socklen_t(socket_addrinfo->ai_addrlen));
                }
            }

            if (received_bytes < 0)
            {
                if (get_error_code() == EWOULDBLOCK)
                {
                    return { 0, socket_status::non_blocking_would_have_blocked };
                }

                return { 0, socket_status::errored };
            }

            return { received_bytes, socket_status::valid };
        }

        ///receive bytes inside the buffer, return the number of bytes you got. You can choose to write inside the buffer at a specific start offset (in number of bytes)
        template <size_t buff_size>
        bytes_with_status recv(buffer<buff_size>& write_buff, size_t start_offset = 0, addr_collection* addr_info = nullptr)
        {
            auto received_bytes = 0;
            if constexpr (sock_proto == protocol::tcp)
            {
                received_bytes = syscall_recv(sock, reinterpret_cast<char*>(write_buff.data()) + start_offset, static_cast<buffsize_t>(buff_size - start_offset), 0);
            }
#ifdef KISSNET_USE_OPENSSL
                else if constexpr (sock_proto == protocol::tcp_ssl)
			{
				received_bytes = SSL_read(pSSL, reinterpret_cast<char*>(write_buff.data()) + start_offset, static_cast<buffsize_t>(buff_size - start_offset));
			}
#endif
            else if constexpr (sock_proto == protocol::udp)
            {
                socket_input_socklen = sizeof socket_input;

                received_bytes = ::recvfrom(sock, reinterpret_cast<char*>(write_buff.data()) + start_offset, static_cast<buffsize_t>(buff_size - start_offset), 0, reinterpret_cast<sockaddr*>(&socket_input), &socket_input_socklen);
                if (addr_info) {
                    addr_info->adrinf = socket_input;
                    addr_info->sock_size = socket_input_socklen;
                }
            }

            if (received_bytes < 0)
            {
                const auto error = get_error_code();
                if (error == EWOULDBLOCK)
                    return { 0, socket_status::non_blocking_would_have_blocked };
                if (error == EAGAIN)
                    return { 0, socket_status::non_blocking_would_have_blocked };
                return { 0, socket_status::errored };
            }

            if (received_bytes == 0)
            {
                return { received_bytes, socket_status::cleanly_disconnected };
            }

            return { size_t(received_bytes), socket_status::valid };
        }

        ///receive up-to len bytes inside the memory location pointed by buffer
        bytes_with_status recv(std::byte* buffer, size_t len, bool wait = true, addr_collection* addr_info = nullptr)
        {
            auto received_bytes = 0;
            if constexpr (sock_proto == protocol::tcp)
            {
                int flags;
                if (wait)
                    flags = MSG_WAITALL;
                else
                {
#ifdef _WIN32
                    flags = 0; // MSG_DONTWAIT not avail on windows, need to make socket nonblockingto emulate
					set_non_blocking(true);
#else
                    flags = MSG_DONTWAIT;
#endif
                }
                received_bytes = syscall_recv(sock, reinterpret_cast<char*>(buffer), static_cast<buffsize_t>(len), flags);
#ifdef _WIN32
                set_non_blocking(false);
#endif
            }

#ifdef KISSNET_USE_OPENSSL
                else if constexpr (sock_proto == protocol::tcp_ssl)
			{
				received_bytes = SSL_read(pSSL, reinterpret_cast<char*>(buffer), static_cast<buffsize_t>(len));
			}
#endif

            else if constexpr (sock_proto == protocol::udp)
            {
                socket_input_socklen = sizeof socket_input;

                received_bytes = ::recvfrom(sock, reinterpret_cast<char*>(buffer), static_cast<buffsize_t>(len), 0, reinterpret_cast<sockaddr*>(&socket_input), &socket_input_socklen);
                if (addr_info) {
                    addr_info->adrinf = socket_input;
                    addr_info->sock_size = socket_input_socklen;
                }
            }

            if (received_bytes < 0)
            {
                const auto error = get_error_code();
                if (error == EWOULDBLOCK)
                    return { 0, socket_status::non_blocking_would_have_blocked };
                if (error == EAGAIN)
                    return { 0, socket_status::non_blocking_would_have_blocked };
                return { 0, socket_status::errored };
            }

            if (received_bytes == 0)
            {
                return { received_bytes, socket_status::cleanly_disconnected };
            }

            return { size_t(received_bytes), socket_status::valid };
        }

        ///Return the endpoint where this socket is talking to
        endpoint get_bind_loc() const
        {
            return bind_loc;
        }

        ///Return an endpoint that originated the data in the last recv
        endpoint get_recv_endpoint() const
        {
            if constexpr (sock_proto == protocol::tcp)
            {
                return get_bind_loc();
            }
            if constexpr (sock_proto == protocol::udp)
            {
                return { (sockaddr*)&socket_input };
            }
        }

        ///Return the number of bytes available inside the socket
        size_t bytes_available() const
        {
            static ioctl_setting size = 0;
            const auto status		  = ioctlsocket(sock, FIONREAD, &size);

            if (status < 0)
            {
                kissnet_fatal_error("ioctlsocket status is negative when getting FIONREAD\n");
            }

            return size > 0 ? size : 0;
        }

        ///Return the protocol used by this socket
        static protocol get_protocol()
        {
            return sock_proto;
        }
    };

    ///Alias for socket<protocol::tcp>
    using tcp_socket = socket<protocol::tcp>;
#ifdef KISSNET_USE_OPENSSL
    ///Alias for socket<protocol::tcp_ssl>
	using tcp_ssl_socket = socket<protocol::tcp_ssl>;
#endif //KISSNET_USE_OPENSSL
    ///Alias for socket<protocol::udp>
    using udp_socket = socket<protocol::udp>;
}

//cleanup preprocessor macros
#undef KISSNET_OS_SPECIFIC_PAYLOAD_NAME
#undef KISSNET_OS_SPECIFIC
#undef KISSNET_OS_INIT
#undef kissnet_fatal_error

#endif //KISS_NET
```

`main.cpp`:

```cpp
#include <iostream>

#include "KCPNet.h"
#include <vector>
#include <algorithm>

std::shared_ptr<KCPContext> gRetainThis;

int gPacketNum = 0;

// Validate this connection
// Return a nullptr if you want to reject the new connection
// If you want to retain this connection context this is the place to do that. All other calls use the raw pointer to the object.
// You can also skip retaining this and just pass a smart_pointer to std::any within the KCPContext
std::shared_ptr<KCPContext> validateConnection(std::string lIP, uint16_t lPort, std::shared_ptr<KCPContext> &rpCtx) {
    std::cout << "Connecting IP:port > " << lIP << ":" << unsigned(lPort) << std::endl;
    rpCtx->mValue = 50;
    gRetainThis = rpCtx;

    // You can optionally configure the KCP connection here also.
    //rpCtx->mSettings.mMtu = 1000;

    // And set the wanted ID.
    //rpCtx->mID = 10; (10 is default)

    return rpCtx;
}

void gotDataServer(const char* pData, size_t lSize, KCPContext* pCTX) {
    std::cout << "The server got -> " << unsigned(lSize) << " bytes of data. pk num -> " << gPacketNum++ << std::endl;
}

void gotDataClient(const char* pData, size_t lSize, KCPContext* pCTX) {
    std::cout << "The client got -> " << unsigned(lSize) << " bytes of data" << std::endl;
}

void noConnectionServer(KCPContext* pCTX) {
    std::cout << "The server timed out a client." << std::endl;
}

void noConnectionClient(KCPContext* pCTX) {
    std::cout << "The server is not active." << std::endl;
}

class TestClass {
    int mTestValue = 100;
};

int main() {
    std::cout << "KCP-cpp test" << std::endl;

    std::vector<uint8_t> lData(4000);
    std::generate(lData.begin(), lData.end(), [n = 0]() mutable { return n++; });

    // Create the server and register the receive data callback and the validate connection callback
    std::shared_ptr<KCPContext> lx = std::make_shared<KCPContext>("");
    lx->mObject = std::make_shared<TestClass>();
    KCPNetServer lKcpServer;
    if (lKcpServer.configureKCP(gotDataServer,
                            noConnectionServer,
                            validateConnection,
                            "::1",
                            8000,
                            lx)) {
        std::cout << "Failed to configure the KCP Server" << std::endl;
    }

    KCPNetClient lKcpClient;

    KCPSettings lSettingsClient;
    if(lKcpClient.configureKCP(lSettingsClient,
                               gotDataClient,
                               noConnectionClient,
                               "::1",
                               8000,
                               10,
                               nullptr)) {
        std::cout << "Failed to configure the KCP Client" << std::endl;
    }

/*
    for ( uint64_t i=0 ; i<10000 ; i++ ) {
        *(uint64_t*)lData.data() = i;
        lKcpClient.sendData((const char*)lData.data(), 1000);
        std::cout << "Pushed -> " << unsigned(i) << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds (1));
    }
    std::cout << "STOP SENDING" << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds (2));
*/

    lKcpClient.sendData((const char*)lData.data(), 4000);

    std::this_thread::sleep_for(std::chrono::seconds (1));
    lKcpServer.sendData((const char*)lData.data(), 4000, gRetainThis.get());
    std::this_thread::sleep_for(std::chrono::seconds (1));

    lKcpServer.mDropAll = true;

    std::this_thread::sleep_for(std::chrono::seconds (1));
    lKcpClient.sendData((const char*)lData.data(), 4000);
    lKcpServer.sendData((const char*)lData.data(), 4000, gRetainThis.get());
    std::this_thread::sleep_for(std::chrono::seconds (1));
    lKcpClient.sendData((const char*)lData.data(), 4000);
    lKcpServer.sendData((const char*)lData.data(), 4000, gRetainThis.get());
    std::this_thread::sleep_for(std::chrono::seconds (20));
    lKcpClient.sendData((const char*)lData.data(), 4000);
    lKcpServer.sendData((const char*)lData.data(), 4000, gRetainThis.get());

    return 0;
}

```