Project Path: arc_cryonumb_elfloader_yqxnv795

Source Tree:

```txt
arc_cryonumb_elfloader_yqxnv795
├── README.md
├── pom.xml
└── src
    └── main
        ├── java
        │   └── org
        │       └── ps5jb
        │           └── client
        │               └── payloads
        │                   ├── ElfLoader.java
        │                   ├── ElfRunner.java
        │                   ├── constants
        │                   │   ├── ELF.java
        │                   │   └── MEM.java
        │                   ├── lib
        │                   │   └── LibKernelExtended.java
        │                   └── parser
        │                       ├── ElfHeader.java
        │                       ├── ElfParser.java
        │                       ├── ElfProgramHeader.java
        │                       ├── ElfRelocation.java
        │                       └── ElfSectionHeader.java
        └── resources
            └── elfldr.elf

```

`README.md`:

```md
# ELF Loader for BD-J [ps5-jar-loader](https://github.com/hammer-83/ps5-jar-loader)

## Usage

- Download and burn the iso release of [ps5-jar-loader](https://github.com/hammer-83/ps5-jar-loader/releases/latest) onto a BluRay Disc.
- Run the UMTX payload from the disc or send via remote option.
- Use the remote jar loader option to send the elfloader.jar payload to your PS5.
- There are multiple options available for sending:

### Netcat
`nc -n <ps5-ip-address> < elfloader.jar`

### Socat
`socat TCP:<ps5-ip-address>:9025 FILE:elfloader.jar`

### GUI options for Windows
- NetCat GUI by Modded Warfare
- Payload Sender by AlAzif (also available for Android)

## Thanks and credits to...
[hammer-83](https://github.com/hammer-83) - For his steady support with his knowledge and tools and of course his jar loader project including his BDJ/PS5 sdk.

[iakdev](https://github.com/iakdev) - For his ideas and motivational support.

[sb/John](https://github.com/ps5-payload-dev) - For his excellent PS5 payload sdk and his elfldr.elf used in this project.

[shahrilnet](https://github.com/shahrilnet) and [Specter](https://github.com/Cryptogenic) - For their LUA and JavaScript versions of an ELF loader used as inspiration.

```

`pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.ps5jb</groupId>
        <artifactId>xploit</artifactId>
        <version>1.0-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <groupId>org.ps5jb.xploit</groupId>
    <artifactId>elfloader</artifactId>
    <description>
        Loader for ELF Payloads
    </description>

    <properties>
        <bdjstack.dir>${project.basedir}/../../lib</bdjstack.dir>

        <xploit.payload>ElfLoader</xploit.payload>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.ps5jb.xploit</groupId>
            <artifactId>jar</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    </dependencies>

    <build>
        <resources>
            <resource>
                <directory>${project.basedir}/src/main/resources</directory>
                <filtering>false</filtering>
            </resource>
        </resources>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

`src/main/java/org/ps5jb/client/payloads/ElfLoader.java`:

```java
package org.ps5jb.client.payloads;

import org.ps5jb.client.payloads.constants.ELF;
import org.ps5jb.client.payloads.constants.MEM;
import org.ps5jb.client.payloads.lib.LibKernelExtended;
import org.ps5jb.client.payloads.parser.ElfParser;
import org.ps5jb.client.payloads.parser.ElfProgramHeader;
import org.ps5jb.client.payloads.parser.ElfRelocation;
import org.ps5jb.client.payloads.parser.ElfSectionHeader;
import org.ps5jb.client.utils.init.KernelReadWriteUnavailableException;
import org.ps5jb.client.utils.init.SdkInit;
import org.ps5jb.client.utils.process.ProcessUtils;
import org.ps5jb.loader.KernelAccessor;
import org.ps5jb.loader.KernelReadWrite;
import org.ps5jb.loader.Status;
import org.ps5jb.sdk.core.Pointer;
import org.ps5jb.sdk.core.SdkSoftwareVersionUnsupportedException;
import org.ps5jb.sdk.core.kernel.KernelAccessorIPv6;
import org.ps5jb.sdk.core.kernel.KernelOffsets;
import org.ps5jb.sdk.core.kernel.KernelPointer;
import org.ps5jb.sdk.include.sys.proc.Process;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;

public class ElfLoader implements Runnable {

    private final LibKernelExtended libKernel = new LibKernelExtended();
    private ProcessUtils procUtils;
    private SdkInit sdk;

    String elfName = "elfldr.elf";

    private boolean init() {
        try {
            sdk = SdkInit.init(true, false);
            procUtils = new ProcessUtils(libKernel);
        } catch (KernelReadWriteUnavailableException e) {
            println("Kernel R/W is not available, aborting");
            libKernel.closeLibrary();
            return false;
        } catch (SdkSoftwareVersionUnsupportedException e) {
            Status.printStackTrace("Unsupported firmware version: ", e);
            libKernel.closeLibrary();
            return false;
        }

        return true;
    }

    @Override
    public void run() {
        if (!init()) {
            return;
        }

        byte[] elfBytes;
        try {
            // Read the ELF file from Jar
            InputStream inputStream = this.getClass().getResourceAsStream("/" + elfName);
            if (inputStream != null) {
                elfBytes = new byte[inputStream.available()];
                DataInputStream dataInputStream = new DataInputStream(inputStream);
                dataInputStream.readFully(elfBytes);

                for (int i = 0; i < 4; i++) {
                    if (elfBytes[i] != ELF.elfMagic[i]) {
                        println("[!] " + elfName + " not a valid ELF file. Aborting.");
                        return;
                    }
                }
            } else {
                println("[!] " + elfName + " not found in JAR");
                return;
            }
        } catch (IOException e) {
            Status.printStackTrace("Error while reading " + elfName, e);
            libKernel.closeLibrary();
            return;
        }

        // Apply patch to bdj process
        Process curProc = new Process(KernelPointer.valueOf(sdk.curProcAddress));
        patchProcess(curProc);
        println("[+] Patch applied to " + curProc.getName());

        // Enable debug settings
        if (enableDebug()) {
            println("[+] Debug settings enabled");
        } else {
            println("[-] Debug settings already enabled");
        }

        //
        // ELF loading
        //

        // Allocate memory for ELF
        int elfStoreSize = elfBytes.length;
        Pointer elfStore = Pointer.malloc(elfStoreSize);

        // Store ELF into memory
        for (int i = 0; i < elfStoreSize; i++) {
            elfStore.write1(i, elfBytes[i]);
        }

        println("[+] Stored " + elfName + " (" + elfBytes.length + " bytes)");
        println("Prepare ELF execution...");

        // Parse ELF file
        ElfParser elf = new ElfParser(elfBytes);

        //
        // Memory mapping
        //

        short flags = MEM.MAP_PRIVATE | MEM.MAP_ANONYMOUS;
        byte prot = MEM.PROT_READ | MEM.PROT_WRITE;
        long baseAddr;
        if (elf.getElfType() == ELF.ET_DYN) {
            baseAddr = 0;
        } else if (elf.getElfType() == ELF.ET_EXEC) {
            baseAddr = elf.getMinVaddr();
            flags |= MEM.MAP_FIXED;
        } else {
            println("  [!] ELF type not supported");
            return;
        }

        // Map memory for ELF segments
        Pointer mmapMemoryLocation = libKernel.mmap(Pointer.valueOf(baseAddr), elf.getElfSize(), prot, flags, -1, 0);

        if (mmapMemoryLocation.addr() == -1) {
            println("  [!] Could not map anonymous memory");
            return;
        } else {
            println("  [+] Mapped memory for ELF segments");
        }

        // Copy loadable segments
        Pointer elfDestination = mmapMemoryLocation;
        ElfProgramHeader[] pHeaders = elf.getProgramHeadersByType(ELF.PT_LOAD);
        for (ElfProgramHeader ph : pHeaders) {
            Pointer dest = elfDestination.inc(ph.getVaddr());
            copySegment(elfStore, dest, ph.getMemsz(), ph.getFilesz(), ph.getOffset());

            println("  [+] ELF segment copied into memory");
        }

        //
        // Relocations
        //

        int countRel = 0;

        // Apply relocations
        ElfSectionHeader[] sHeaders = elf.getSectionHeadersByType(ELF.SHT_RELA);
        for (ElfSectionHeader sh : sHeaders) {
            for (ElfRelocation r : sh.getRelocations()) {
                if (r.getType() == ELF.R_X86_64_RELATIVE) {
                    Pointer relocAddr = elfDestination.inc(r.getOffset());
                    long relocVal = elfDestination.addr() + r.getAddend();
                    relocAddr.write8(relocVal);
                    countRel++;
                }
            }
        }

        println("  [+] Applied relocations: " + countRel);

        //
        // Memory protection
        //

        // Set protection of segments
        for (ElfProgramHeader ph : pHeaders) {
            if (ph.getMemsz() > 0) {
                Pointer segmentAddr = elfDestination.inc(ph.getVaddr());
                long segmentSize = MEM.roundPage(ph.getMemsz());
                if ((ph.getFlags() & ELF.PF_X) == ELF.PF_X) {
                    byte memProt = MEM.translateProtection(ph.getFlags());
                    libKernel.kMprotect(curProc, segmentAddr, memProt);
                } else {
                    byte memProt = MEM.translateProtection(ph.getFlags());
                    libKernel.mprotect(segmentAddr, segmentSize, memProt);
                }
            }
        }

        println("  [+] Set memory protection flags");

        //
        // ELF arguments
        //

        Pointer rwSocketPair = Pointer.malloc(8);
        Pointer payloadOut = Pointer.malloc(8);
        Pointer args = Pointer.malloc(48); // 8 * 6

        // Get IPv6 Accessor for pipe and socket
        KernelAccessorIPv6 ipv6;
        KernelAccessor ka = KernelReadWrite.getAccessor(getClass().getClassLoader());
        if (ka instanceof KernelAccessorIPv6) {
            ipv6 = (KernelAccessorIPv6) ka;
        } else {
            sdk.restoreNonAgcKernelReadWrite();
            ipv6 = (KernelAccessorIPv6) KernelReadWrite.getAccessor(getClass().getClassLoader());
        }

        // Pipe
        Pointer rwPipe = Pointer.malloc(8);
        rwPipe.write4(ipv6.getPipeReadFd());
        rwPipe.write4(4, ipv6.getPipeWriteFd());

        // Pass master/victim pair to payload so it can do read/write
        rwSocketPair.write4(ipv6.getMasterSock());
        rwSocketPair.write4(4, ipv6.getVictimSock());

        // We need getpid, sceKernelDlsym does not work on higher FWs
        Pointer dlsym = libKernel.addrOf("getpid");
//        Pointer dlsym = libKernel.addrOf("sceKernelDlsym");
        long kdataAddress = sdk.kernelDataAddress;

        args.inc(0x00).write8(dlsym.addr());                 // arg1 = dlsym_t* dlsym
        args.inc(0x08).write8(rwPipe.addr());                // arg2 = int *rwpipe[2]
        args.inc(0x10).write8(rwSocketPair.addr());          // arg3 = int *rwpair[2]
        args.inc(0x18).write8(ipv6.getPipeAddress().addr()); // arg4 = uint64_t kpipe_addr
        args.inc(0x20).write8(kdataAddress);                 // arg5 = uint64_t kdata_base_addr
        args.inc(0x28).write8(payloadOut.addr());            // arg6 = int *payloadout

        println("  [+] Prepared ELF arguments");

        //
        // ELF execution
        //

        Pointer elfEntryPoint = Pointer.valueOf(elfDestination.addr() + elf.getElfEntry());

        println("Execution...");
        println("  [+] Starting " + elfName);

        // Run in Java thread
        ElfRunner runner = new ElfRunner(elfEntryPoint, args);
        Thread t = new Thread(runner);
        t.start();
        try {
            t.join();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        int retVal = runner.getReturnValue();

        println("  [+] Finished");
        println("Done.");

        // Cleanup
        payloadOut.free();
        rwPipe.free();
        rwSocketPair.free();
        args.free();
        elfStore.free();
        libKernel.munmap(elfDestination, elf.getElfSize());
    }

    private void patchProcess(Process process) {
        // Patch ucred
        procUtils.setUserGroup(process, new int[]{
                0, // cr_uid
                0, // cr_ruid
                0, // cr_svuid
                1, // cr_ngroups
                0  // cr_rgid
        });

        final long SYSTEM_AUTHID   = 0x4800000000010003l;
        final long COREDUMP_AUTHID = 0x4800000000000006l;
        final long DEVICE_AUTHID   = 0x4801000000000013l;
        final long currentAuthId   = procUtils.getPrivs(process)[0];

        // Escalate sony privs
        procUtils.setPrivs(process, new long[]{
                DEVICE_AUTHID,       // cr_sceAuthId
                0xFFFFFFFFFFFFFFFFL, // cr_sceCaps[0]
                0xFFFFFFFFFFFFFFFFL, // cr_sceCaps[1]
                0x80                 // cr_sceAttr[0]
        });

        // Remove dynlib restriction
        KernelPointer dynlibAddr = process.getDynLib();
        dynlibAddr.write4(0x118, 0);
        dynlibAddr.write8(0x18, 1);

        // Bypass libkernel address range check (credit @cheburek3000)
        dynlibAddr.write8(0xf0, 0);
        dynlibAddr.write8(0xf8, -1);
    }

    private boolean enableDebug() {
        boolean appliedPatch = false;
        KernelOffsets offsets = sdk.kernelOffsets;
        KernelPointer kdata = KernelPointer.valueOf(sdk.kernelDataAddress, false);

        // enable direct memory access
        sdk.switchToAgcKernelReadWrite(true);

        // Security flags
        KernelPointer secFlagsPtr = kdata.inc(offsets.OFFSET_KERNEL_DATA_BASE_SECURITY_FLAGS);
        int secFlagsVal = secFlagsPtr.read4();
        if ((secFlagsVal & 0x14) != 0x14) {
            secFlagsPtr.write4(secFlagsVal | 0x14);
            appliedPatch = true;
        }

        // target ID
        KernelPointer targetIdPtr = kdata.inc(offsets.OFFSET_KERNEL_DATA_BASE_TARGET_ID);
        byte targetId = targetIdPtr.read1();
        if (targetId != (byte) 0x82) {
            targetIdPtr.write1((byte) 0x82);
            appliedPatch = true;
        }

        // QA flags
        KernelPointer qaFlagsPtr = kdata.inc(offsets.OFFSET_KERNEL_DATA_BASE_QA_FLAGS);
        long qaFlagsVal = qaFlagsPtr.read8();
        final long QA_MASK = 0x0000000000010300L;
        if ((qaFlagsVal & QA_MASK) != QA_MASK) {
            qaFlagsPtr.write8(qaFlagsVal | QA_MASK);
            appliedPatch = true;
        }

        // Utoken flag
        KernelPointer uTokenFlagsPtr = kdata.inc(offsets.OFFSET_KERNEL_DATA_BASE_UTOKEN_FLAGS);
        byte uTokenFlagsVal = uTokenFlagsPtr.read1();
        if ((uTokenFlagsVal & 0x1) != 0x1) {
            uTokenFlagsPtr.write1((byte) (uTokenFlagsVal | 0x1));
            appliedPatch = true;
        }

        // Notification: debug settings enabled
        if (appliedPatch) {
            libKernel.sceKernelSendNotificationRequest("Debug Settings enabled");
        }

        // disable DMA
        sdk.restoreNonAgcKernelReadWrite();

        return appliedPatch;
    }

    private void println(String message) {
        Status.println(message);
    }

    private void copySegment(Pointer src, Pointer dest, long memSize, long fileSize, long offset) {
        for (long i = 0; i < memSize; i += 8) {
            long qword = (i >= fileSize) ? 0 : src.read8(offset + i);
            dest.write8(i, qword);
        }
    }
}
```

`src/main/java/org/ps5jb/client/payloads/ElfRunner.java`:

```java
package org.ps5jb.client.payloads;

import org.ps5jb.sdk.core.Library;
import org.ps5jb.sdk.core.Pointer;

public class ElfRunner extends Library implements Runnable {
    private int retVal;
    private final Pointer entryPoint;
    private final Pointer args;

    public ElfRunner(Pointer entryPoint, Pointer args) {
        super(0x2001);
        this.entryPoint = entryPoint;
        this.args = args;
    }

    @Override
    public void run() {
        retVal = (int) call(entryPoint, args.addr());
    }

    public int getReturnValue() {
        return retVal;
    }
}

```

`src/main/java/org/ps5jb/client/payloads/constants/ELF.java`:

```java
package org.ps5jb.client.payloads.constants;

public class ELF {
    /** Elf header starts with 0x7F + 'E' + 'L' + 'F' */
    public static byte[] elfMagic = {0x7F, 0x45, 0x4C, 0x46};

    // ELF types
    /** No file type (Unknown/Unspecified) */
    public static final short ET_NONE = 0;
    /** Relocatable file (.o object files) */
    public static final short ET_REL = 1;
    /** Executable file (compiled binary) */
    public static final short ET_EXEC = 2;
    /** Shared object file (.so libraries) */
    public static final short ET_DYN = 3;

    // ELF program types
    /** Loadable segment type */
    public static final short PT_LOAD = 1;
    /** Segment for dynamic linking */
    public static final short PT_DYNAMIC = 2;

    // ELF section header types
    /** Section header type: Relocation with Addend */
    public static final short SHT_RELA = 4;
    /** Section header type: Relocation without Addend */
    public static final short SHT_REL = 9;

    // Relocation types
    /** No relocation required. */
    public static final int R_X86_64_NONE = 0;
    /** 64-bit absolute relocation. */
    public static final int R_X86_64_64 = 1;
    /** 32-bit relative relocation (PC-relative). */
    public static final int R_X86_64_PC32 = 2;
    /** 32-bit GOT entry relocation. */
    public static final int R_X86_64_GOT32 = 3;
    /** 32-bit PLT entry relocation. */
    public static final int R_X86_64_PLT32 = 4;
    /** Copy data relocation. */
    public static final int R_X86_64_COPY = 5;
    /** Global data relocation (for functions/variables). */
    public static final int R_X86_64_GLOB_DAT = 6;
    /** PLT entry relocation for shared library linking. */
    public static final int R_X86_64_JUMP_SLOT = 7;
    /** Position-independent code (PIC) relative relocation. */
    public static final int R_X86_64_RELATIVE = 8;
    /** Thread-local storage module relocation (DTP). */
    public static final int R_X86_64_TLS_DTPMOD64 = 9;
    /** Thread-local storage data offset relocation. */
    public static final int R_X86_64_TLS_DTPOFF64 = 10;
    /** Thread-local storage thread pointer offset relocation. */
    public static final int R_X86_64_TLS_TPOFF64 = 11;

    // ELF p_flags
    /** p_flags: All access denied */
    public static final short PF_NONE = 0;
    /** p_flags: Execute only. May have Read memory permission too */
    public static final short PF_X    = 1;
    /** p_flags: Write only. May have Read, Execute memory permission too */
    public static final short PF_W    = 2;
    /** p_flags: Write, Execute. May have Read memory permission too */
    public static final short PF_WX   = 3;
    /** p_flags: Read only. May have Execute memory permission too */
    public static final short PF_R    = 4;
    /** p_flags: Read, Execute */
    public static final short PF_RX   = 5;
    /** p_flags: Read, Write. May have Execute memory permission too */
    public static final short PF_RW   = 6;
    /** p_flags: Read, Write, Execute */
    public static final short PF_RWX  = 7;
}

```

`src/main/java/org/ps5jb/client/payloads/constants/MEM.java`:

```java
package org.ps5jb.client.payloads.constants;

public class MEM {

    /** The size of a memory page, defined as 0x4000 (16,384 bytes or 16 KB). */
    public static final short PAGE_SIZE = 0x4000;

    // Memory protection
    /** Memory protection: All access denied */
    public static final byte PROT_NONE  = 0;
    /** Memory protection: Read only */
    public static final byte PROT_READ  = 1;
    /** Memory protection: Write only */
    public static final byte PROT_WRITE = 2;
    /** Memory protection: Read, Write */
    public static final byte PROT_RW    = 3;
    /** Memory protection: Execute only */
    public static final byte PROT_EXEC  = 4;
    /** Memory protection: Read, Execute */
    public static final byte PROT_RX    = 5;
    // FreeBSD doesn't allow PROT_WRITE and PROT_EXEC simultaneously
    /** Memory protection: Write, Execute. Not supported! */
    public static final byte PROT_WX    = 6;
    /** Memory protection: Read, Write, Execute. Not supported! */
    public static final byte PROT_RWX   = 7;

    // mmap
    /** mmap_flag: Share changes */
    public static final short MAP_SHARED    = 0x1;
    /** mmap_flag: Changes are private (copy-on-write) */
    public static final short MAP_PRIVATE   = 0x2;
    /** mmap_flag: Interpret addr exactly */
    public static final short MAP_FIXED     = 0x10;
    /** mmap_flag: Assign a region with rename semantics (OBSOLETE) */
    public static final short MAP_RENAME    = 0x20;
    /** mmap_flag: Do not reserve swap space */
    public static final short MAP_NORESERVE = 0x40;
    /** mmap_flag: Region is retained after exec */
    public static final short MAP_INHERIT   = 0x80;
    /** mmap_flag: Region grows downward, suitable for stack */
    public static final short MAP_STACK     = 0x100;
    /** mmap_flag: Do not flush modifications to file */
    public static final short MAP_NOSYNC    = 0x800;
    /** mmap_flag: Anonymous memory (not backed by a file) */
    public static final short MAP_ANONYMOUS = 0x1000;
    /** mmap_flag: Reserved mapping (no memory allocated) */
    public static final short MAP_GUARD     = 0x2000;
    /** mmap_flag: Fail if the address is already mapped */
    public static final short MAP_EXCL      = 0x4000;
    /** mmap_flag: Exclude from core dump */
    public static final int MAP_NOCORE      = 0x8000;

    /**
     * Truncates the given address to the start of its containing memory page.
     *
     * @param addr The memory address to truncate.
     * @return The starting address of the page containing {@code addr}.
     */
    public static long truncatePage(long addr) {
        return addr & -PAGE_SIZE;
    }

    /**
     * Rounds the given address up to the start of the next memory page if it is not already page-aligned.
     *
     * @param addr The memory address to round up.
     * @return The starting address of the next page if {@code addr} is not already aligned,
     *         otherwise returns {@code addr} unchanged.
     */
    public static long roundPage(long addr) {
        return (addr + (PAGE_SIZE - 1)) & -PAGE_SIZE;
    }

    /**
     * Translates ELF segment protection flags into memory protection flags.
     *
     * @param flags The ELF protection flags, typically a combination of {@code ELF.PF_X},
     *              {@code ELF.PF_R}, and {@code ELF.PF_W}.
     * @return A byte representing the corresponding memory protection flags, combining
     *         {@code PROT_EXEC}, {@code PROT_READ}, and {@code PROT_WRITE} as needed.
     */
    public static byte translateProtection(int flags) {
        byte memFlags = 0;
        if ((flags & ELF.PF_X) == ELF.PF_X) {
            memFlags |= PROT_EXEC;
        }
        if ((flags & ELF.PF_R) == ELF.PF_R) {
            memFlags |= PROT_READ;
        }
        if ((flags & ELF.PF_W) == ELF.PF_W) {
            memFlags |= PROT_WRITE;
        }
        return memFlags;
    }
}

```

`src/main/java/org/ps5jb/client/payloads/lib/LibKernelExtended.java`:

```java
package org.ps5jb.client.payloads.lib;

import org.ps5jb.loader.Status;
import org.ps5jb.sdk.core.Pointer;
import org.ps5jb.sdk.core.kernel.KernelPointer;
import org.ps5jb.sdk.include.sys.mman.ProtectionFlag;
import org.ps5jb.sdk.include.sys.proc.Process;
import org.ps5jb.sdk.lib.LibKernel;

import java.util.Arrays;

public class LibKernelExtended extends LibKernel {
    /** Offset to the vm_map structure inside vmspace of a process */
    private final short OFFSET_VMROOT;

    public LibKernelExtended() {
        OFFSET_VMROOT = getOffsetVmRoot();
    }

    // Offsets from PS5 payload sdk (credits @sb)
    private short getOffsetVmRoot() {
        short offset;
        switch (getSystemSoftwareVersion()) {
            case 0x0100:
            case 0x0101:
            case 0x0102:
            case 0x0105:
            case 0x0110:
            case 0x0111:
            case 0x0112:
            case 0x0113:
            case 0x0114: {
                Status.println("[+] FW 1.xx detected");
                offset = 0x1C0;
                break;
            }
            case 0x0220:
            case 0x0225:
            case 0x0226:
            case 0x0230:
            case 0x0250:
            case 0x0270: {
                Status.println("[+] FW 2.xx detected");
                offset = 0x1C8;
                break;
            }
            case 0x0300:
            case 0x0310:
            case 0x0320:
            case 0x0321: {
                Status.println("[+] FW 3.xx detected");
                offset = 0x1C8;
                break;
            }
            case 0x0400:
            case 0x0402:
            case 0x0403:
            case 0x0450:
            case 0x0451: {
                Status.println("[+] FW 4.xx detected");
                offset = 0x1C8;
                break;
            }
            case 0x0500:
            case 0x0502:
            case 0x0510:
            case 0x0550: {
                Status.println("[+] FW 5.xx detected");
                offset = 0x1C8;
                break;
            }
            case 0x0600:
            case 0x0602:
            case 0x0650: {
                Status.println("[+] FW 6.xx detected");
                offset = 0x1D0;
                break;
            }
            case 0x0700:
            case 0x0701:
            case 0x0720:
            case 0x0740:
            case 0x0760:
            case 0x0761: {
                Status.println("[+] FW 7.xx detected");
                offset = 0x1D0;
                break;
            }
            default: {
                Status.println("[!] FW not supported");
                offset = 0;
            }
        }
        return offset;
    }

    /**
     * Modifies the memory protection attributes of a specified address in a process's virtual memory map.
     *
     * <p>This method traverses the process's VM map entries, searching for the region that contains
     * the specified address. If found, it updates the protection attributes.</p>
     *
     * @param proc The process whose memory protections are being modified.
     * @param addr The memory address whose protection needs to be changed.
     * @param prot The new protection flags to apply (e.g., read, write, execute permissions).
     */
    public void kMprotect(Process proc, Pointer addr, byte prot) {
        KernelPointer vmMapEntry = proc.getVmSpace().getPointer().pptr(OFFSET_VMROOT);
        while (!KernelPointer.NULL.equals(vmMapEntry)) {
            long start = vmMapEntry.read8(0x20);
            long end = vmMapEntry.read8(0x28);
            if (addr.addr() < start) {
                // go left in tree
                vmMapEntry = vmMapEntry.pptr(0x10);
            } else if (addr.addr() >= end) {
                // go right in tree
                vmMapEntry = vmMapEntry.pptr(0x18);
            } else {
                // protection
                vmMapEntry.write1(0x64, prot);
                // max protection
                vmMapEntry.write1(0x65, prot);
                return;
            }
        }
    }
}

```

`src/main/java/org/ps5jb/client/payloads/parser/ElfHeader.java`:

```java
package org.ps5jb.client.payloads.parser;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class ElfHeader {
    public static final int EI_NIDENT = 16;

    private final byte[] e_ident = new byte[EI_NIDENT];
    private final short e_type;
    private final short e_machine;
    private final int e_version;
    private final long e_entry;
    private final long e_phoff;
    private final long e_shoff;
    private final int e_flags;
    private final short e_ehsize;
    private final short e_phentsize;
    private final short e_phnum;
    private final short e_shentsize;
    private final short e_shnum;
    private final short e_shstrndx;

    public ElfHeader(byte[] data) {
        ByteBuffer buffer = ByteBuffer.wrap(data);
        buffer.order(ByteOrder.LITTLE_ENDIAN);

        buffer.get(e_ident);
        e_type = buffer.getShort();
        e_machine = buffer.getShort();
        e_version = buffer.getInt();
        e_entry = buffer.getLong();
        e_phoff = buffer.getLong();
        e_shoff = buffer.getLong();
        e_flags = buffer.getInt();
        e_ehsize = buffer.getShort();
        e_phentsize = buffer.getShort();
        e_phnum = buffer.getShort();
        e_shentsize = buffer.getShort();
        e_shnum = buffer.getShort();
        e_shstrndx = buffer.getShort();
    }

    public byte[] getIdent() {
        return e_ident;
    }

    public short getType() {
        return e_type;
    }

    public short getMachine() {
        return e_machine;
    }

    public int getVersion() {
        return e_version;
    }

    public long getEntry() {
        return e_entry;
    }

    public long getPhOffset() {
        return e_phoff;
    }

    public long getShOffset() {
        return e_shoff;
    }

    public int getFlags() {
        return e_flags;
    }

    public short getEhSize() {
        return e_ehsize;
    }

    public short getPhEntitySize() {
        return e_phentsize;
    }

    public short getPhNumber() {
        return e_phnum;
    }

    public short getShEntitySize() {
        return e_shentsize;
    }

    public short getShNumber() {
        return e_shnum;
    }

    public short getShStringIndex() {
        return e_shstrndx;
    }
}

```

`src/main/java/org/ps5jb/client/payloads/parser/ElfParser.java`:

```java
package org.ps5jb.client.payloads.parser;

import org.ps5jb.client.payloads.constants.ELF;
import org.ps5jb.client.payloads.constants.MEM;
import org.ps5jb.loader.Status;

public class ElfParser {
    private final byte[] data;
    private final ElfHeader header;
    private final ElfProgramHeader[] programHeaders;
    private final ElfSectionHeader[] sectionHeaders;
    private final long minVaddr;
    private final long maxVaddr;
    private final long elfSize;

    public ElfParser(byte[] data) {
        this.data = data;
        header = new ElfHeader(data);
        programHeaders = parseProgramHeaders();
        sectionHeaders = parseSectionHeaders();
        minVaddr = minVaddr();
        maxVaddr = maxVaddr();
        elfSize = maxVaddr - minVaddr;
    }

    private ElfProgramHeader[] parseProgramHeaders() {
        ElfProgramHeader[] headers = new ElfProgramHeader[header.getPhNumber()];
        for (short i = 0; i < header.getPhNumber(); i++) {
            long offset = header.getPhOffset() + i * header.getPhEntitySize();
            headers[i] = new ElfProgramHeader(data, offset);
        }
        return headers;
    }

    private ElfSectionHeader[] parseSectionHeaders() {
        ElfSectionHeader[] headers = new ElfSectionHeader[header.getShNumber()];
        for (short i = 0; i < header.getShNumber(); i++) {
            long offset = header.getShOffset() + i * header.getShEntitySize();
            headers[i] = new ElfSectionHeader(data, offset);
        }
        // resolve names
        short indexOfStrTable = header.getShStringIndex();
        long strTableOffset = headers[indexOfStrTable].getOffset();
        for (ElfSectionHeader h : headers) {
            String name = getNullTerminatedString(data, (int) strTableOffset + h.getNameOffset());
            h.setName(name);
        }
        return headers;
    }

    public String getNullTerminatedString(byte[] data, int offset) {
        int end = offset;
        while (end < data.length && data[end] != 0) {
            end++;
        }
        return new String(data, offset, end - offset);
    }

    private long minVaddr() {
        long minVaddr = -1;
        for (ElfProgramHeader header : programHeaders) {
            if (header.getVaddr() < minVaddr) {
                minVaddr = header.getVaddr();
            }
        }
        return MEM.truncatePage(minVaddr);
    }

    private long maxVaddr() {
        long maxVaddr = 0;
        for (ElfProgramHeader header : programHeaders) {
            if (maxVaddr < header.getVaddr() + header.getMemsz()) {
                maxVaddr = header.getVaddr() + header.getMemsz();
            }
        }
        return MEM.roundPage(maxVaddr);
    }

    public long getElfType() {
        return header.getType();
    }

    public long getElfSize() {
        return elfSize;
    }

    public long getElfEntry() {
        return header.getEntry();
    }

    public long getMinVaddr() {
        return minVaddr;
    }

    public ElfProgramHeader[] getProgramHeadersByType(short programHeaderType) {
        short arraySize = 0;
        for (ElfProgramHeader header : programHeaders) {
            if (header.getType() == programHeaderType) {
                arraySize++;
            }
        }
        ElfProgramHeader[] headers = new ElfProgramHeader[arraySize];
        short i = 0;
        for (ElfProgramHeader header : programHeaders) {
            if (header.getType() == programHeaderType) {
                headers[i] = header;
                i++;
            }
        }
        return headers;
    }

    public ElfSectionHeader[] getSectionHeadersByType(short sectionHeaderType) {
        short arraySize = 0;
        for (ElfSectionHeader header : sectionHeaders) {
            if (header.getType() == sectionHeaderType) {
                arraySize++;
            }
        }
        ElfSectionHeader[] headers = new ElfSectionHeader[arraySize];
        short i = 0;
        for (ElfSectionHeader header : sectionHeaders) {
            if (header.getType() == sectionHeaderType) {
                headers[i] = header;
                i++;
            }
        }
        return headers;
    }
}

```

`src/main/java/org/ps5jb/client/payloads/parser/ElfProgramHeader.java`:

```java
package org.ps5jb.client.payloads.parser;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class ElfProgramHeader {
    private final int p_type;
    private final int p_flags;
    private final long p_offset;
    private final long p_vaddr;
    private final long p_paddr;
    private final long p_filesz;
    private final long p_memsz;
    private final long p_align;

    public ElfProgramHeader(byte[] data, long offset) {
        ByteBuffer buffer = ByteBuffer.wrap(data, (int) offset, data.length - (int) offset);
        buffer.order(ByteOrder.LITTLE_ENDIAN);

        p_type = buffer.getInt();
        p_flags = buffer.getInt();
        p_offset = buffer.getLong();
        p_vaddr = buffer.getLong();
        p_paddr = buffer.getLong();
        p_filesz = buffer.getLong();
        p_memsz = buffer.getLong();
        p_align = buffer.getLong();
    }

    public int getType() {
        return p_type;
    }

    public int getFlags() {
        return p_flags;
    }

    public long getOffset() {
        return p_offset;
    }

    public long getVaddr() {
        return p_vaddr;
    }

    public long getPaddr() {
        return p_paddr;
    }

    public long getFilesz() {
        return p_filesz;
    }

    public long getMemsz() {
        return p_memsz;
    }

    public long getAlign() {
        return p_align;
    }
}


```

`src/main/java/org/ps5jb/client/payloads/parser/ElfRelocation.java`:

```java
package org.ps5jb.client.payloads.parser;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class ElfRelocation {
    private final long r_offset;  // Address of relocation
    private final long r_info;    // Encoded relocation type and symbol index
    private final long r_addend;

    public ElfRelocation(long r_offset, long r_info, long r_addend) {
        this.r_offset = r_offset;
        this.r_info = r_info;
        this.r_addend = r_addend;
    }

    public long getOffset() {
        return r_offset;
    }

    public long getAddend() {
        return r_addend;
    }

    // Extracts symbol index from r_info (upper 32 bits)
    public int getSymbolIndex() {
        return (int) (r_info >> 32);
    }

    // Extracts relocation type from r_info (lower 32 bits)
    public int getType() {
        return (int) (r_info & 0xFFFFFFFFL);
    }

    // Static method to parse an Elf64_Rela entry from a byte array
    public static ElfRelocation fromByteBuffer(ByteBuffer buffer) {
        buffer.order(ByteOrder.LITTLE_ENDIAN);

        long offset = buffer.getLong();  // Read 8-byte r_offset
        long info = buffer.getLong();    // Read 8-byte r_info
        long addend = buffer.getLong();  // Read 8-byte r_addend

        return new ElfRelocation(offset, info, addend);
    }
}


```

`src/main/java/org/ps5jb/client/payloads/parser/ElfSectionHeader.java`:

```java
package org.ps5jb.client.payloads.parser;

import org.ps5jb.client.payloads.constants.ELF;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class ElfSectionHeader {
    private String name = "";
    private final int sh_name;       // Section name (index into string table)
    private final int sh_type;       // Section type
    private final long sh_flags;     // Section flags
    private final long sh_addr;      // Virtual address in memory
    private final long sh_offset;    // Offset in file
    private final long sh_size;      // Size of section
    private final int sh_link;       // Link to another section
    private final int sh_info;       // Additional section information
    private final long sh_addralign; // Address alignment
    private final long sh_entsize;   // Size of entries if section has a table
    private ElfRelocation[] relocations;

    public ElfSectionHeader(byte[] data, long offset) {
        ByteBuffer buffer = ByteBuffer.wrap(data, (int) offset, data.length - (int) offset);
        buffer.order(ByteOrder.LITTLE_ENDIAN);

        sh_name = buffer.getInt();
        sh_type = buffer.getInt();
        sh_flags = buffer.getLong();
        sh_addr = buffer.getLong();
        sh_offset = buffer.getLong();
        sh_size = buffer.getLong();
        sh_link = buffer.getInt();
        sh_info = buffer.getInt();
        sh_addralign = buffer.getLong();
        sh_entsize = buffer.getLong();

        if (sh_type == ELF.SHT_RELA) {
            buffer.position( (int) sh_offset );
            int entries = (int) (sh_size / sh_entsize);
            relocations = new ElfRelocation[entries];
            int i = 0;
            while (buffer.position() < sh_offset + sh_size) {
                relocations[i] = ElfRelocation.fromByteBuffer(buffer);
                i++;
            }
        }
    }

    public String getName() {
        return name;
    }

    public int getNameOffset() {
        return sh_name;
    }

    public int getType() {
        return sh_type;
    }

    public long getFlags() {
        return sh_flags;
    }

    public long getAddr() {
        return sh_addr;
    }

    public long getOffset() {
        return sh_offset;
    }

    public long getSize() {
        return sh_size;
    }

    public int getLink() {
        return sh_link;
    }

    public int getInfo() {
        return sh_info;
    }

    public long getAddrAlign() {
        return sh_addralign;
    }

    public long getEntSize() {
        return sh_entsize;
    }

    public ElfRelocation[] getRelocations() {
        return relocations;
    }

    public void setName(String name) {
        this.name = name;
    }
}

```