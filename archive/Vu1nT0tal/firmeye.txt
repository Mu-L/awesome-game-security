Project Path: arc_Vu1nT0tal_firmeye_vc25dfcs

Source Tree:

```txt
arc_Vu1nT0tal_firmeye_vc25dfcs
├── LICENSE
├── README.md
├── _config.yml
├── firmeye
│   ├── __init__.py
│   ├── analysis
│   │   ├── __init__.py
│   │   ├── dynamic.py
│   │   └── static.py
│   ├── cli
│   │   ├── firmeye_cli.py
│   │   ├── idahunt.py
│   │   └── names.py
│   ├── config.py
│   ├── constants.py
│   ├── helper.py
│   ├── hexraystool.py
│   ├── idaxml.py
│   ├── logger.py
│   ├── re_assistant.py
│   ├── regs.py
│   ├── test.py
│   ├── tools
│   │   ├── __init__.py
│   │   ├── checksec.py
│   │   ├── hexrayshelper.py
│   │   └── idapyhelper.py
│   ├── utility.py
│   ├── view
│   │   ├── __init__.py
│   │   ├── chooser.py
│   │   ├── colors.py
│   │   └── custviewer.py
│   └── vulnscan
│       ├── __init__.py
│       └── cve_2019_3568.py
├── firmeye.pdf
├── firmeye.py
└── requirements.txt

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# firmeye - IoT固件漏洞挖掘工具

firmeye 是一个 IDA 插件，基于敏感函数参数回溯来辅助漏洞挖掘。我们知道，在固件漏洞挖掘中，从敏感/危险函数出发，寻找其参数来源，是一种很有效的漏洞挖掘方法，但程序中调用敏感函数的地方非常多，人工分析耗时费力，通过该插件，可以帮助排除大部分的安全调用，从而提高效率。

- 漏洞类型支持：缓冲区溢出、命令执行、格式化字符串
- 架构支持：ARM

分享：[slides](./firmeye.pdf)

## 安装

该插件运行环境要求 IDA Pro 7.5，Python3。

1. 下载本项目：`https://github.com/firmianay/firmeye.git`。
2. 安装依赖：`pip install -r requirements.txt`。
3. 将 `firmeye` 和 `firmeye.py` 复制到 IDA Pro 插件目录下，例如 `C:\Program Files\IDA Pro 7.5\plugins`。
4. 打开 IDA Pro 并加载待分析固件程序。
5. `Ctrl+F1` 查看插件使用帮助。热键：
    - `Ctrl+Shift+s`：主菜单
    - `Ctrl+Shift+d`：启动/禁用调试钩子
    - `Ctrl+Shift+c`：扫描代码模式（TODO）
    - `Ctrl+Shift+x`：逆向辅助工具
    - `Ctrl+Shift+q`：功能测试

## 使用方法

### 静态分析功能

敏感函数被分为 5 类：printf、strcpy、memcpy、scanf、system。分别对应各自的漏洞类型和检测规则。

### 动态调试功能

对静态分析得到的可疑地址下断点，并在调试时动态处理断点事件，获得参数、返回值等上下文信息。

## 命令行工具

利用 [idahunt](idahttps://github.com/nccgroup/idahunt) 可以让插件自动化批量运行，使用方法如下：

```sh
$ python3 idahunt.py --inputdir C:\xxxx --analyse --filter "names.py -a 32 -v"                      # 生成IDB
$ python3 idahunt.py --inputdir C:\xxxx --cleanup                                                   # 清理临时文件
$ python3 idahunt.py --inputdir C:\xxxx --filter "names.py -a 32 -v" --scripts "firmeye_cli.py"     # 运行脚本
```

## 改进方向

该插件目前还非常不完善，下面是一些改进方向，欢迎讨论和 PR。

- 完善参数回溯逻辑，支持更复杂的指令语义识别
- 支持函数间分析
- 完善漏洞判断逻辑，降低误报率
- 加入动态污点分析作为辅助
- 支持更多体系架构，如 x86、MIPS 等

## 关注我们

[VulnTotal安全](https://github.com/VulnTotal-Team)致力于分享高质量原创文章和开源工具，包括物联网/汽车安全、移动安全、网络攻防等。

GNU General Public License v3.0

[![Stargazers over time](https://starchart.cc/VulnTotal-Team/firmeye.svg)](https://starchart.cc/VulnTotal-Team/firmeye)

```

`_config.yml`:

```yml
theme: jekyll-theme-cayman
```

`firmeye.py`:

```py
# -*- coding: utf-8 -*-

import ida_idaapi
import ida_kernwin

from firmeye.utility import FEStrMgr
from firmeye.constants import *
from firmeye.logger import FELogger
from firmeye.analysis.static import FEStaticAnalyzer
from firmeye.analysis.dynamic import FEDynamicAnalyzer
from firmeye.hexraystool import FECodePattern 
from firmeye.re_assistant import FEReAssist
from firmeye.test import FEFuncTest

MENU_PATH = "Edit/Plugins/"


class Firmeye(ida_idaapi.plugin_t):
    help = PLUGIN_HELP
    flags = ida_idaapi.PLUGIN_KEEP
    wanted_name = PLUGIN_NAME
    wanted_hotkey = PLUGIN_HOTKEY
    comment = PLUGIN_COMMENT

    def __init__(self):
        ida_idaapi.plugin_t.__init__(self)
        FEStrMgr(minl=1)

    act_static = 'firmeye:static_main'
    act_dbg_hook = 'firmeye:dynamic_change_debug_hook_mode'
    act_pattern = 'firmeye:code_pattern'
    act_assist = 'firmeye:reverse_assistant'
    act_test = 'firmeye:functional_test'

    def _init_actions(self):
        action = ida_kernwin.action_desc_t(
            self.act_static,
            'static analyzer: main menu',
            FEStaticAnalyzer(),
            'Ctrl+Shift+s',
            '静态分析器主菜单', 0)
        ida_kernwin.register_action(action)
        ida_kernwin.attach_action_to_menu(MENU_PATH, self.act_static, ida_kernwin.SETMENU_APP)

        action = ida_kernwin.action_desc_t(
            self.act_dbg_hook,
            'dynamic analyzer: enable/disable debug hook',
            FEDynamicAnalyzer(),
            'Ctrl+Shift+d',
            '启用/解除DEBUG Hook', 0)
        ida_kernwin.register_action(action)
        ida_kernwin.attach_action_to_menu(MENU_PATH, self.act_dbg_hook, ida_kernwin.SETMENU_APP)

        action = ida_kernwin.action_desc_t(
            self.act_pattern,
            'code pattern: find code pattern',
            FECodePattern(),
            'Ctrl+Shift+c',
            '代码模式扫描', 0)
        ida_kernwin.register_action(action)
        ida_kernwin.attach_action_to_menu(MENU_PATH, self.act_pattern, ida_kernwin.SETMENU_APP)

        action = ida_kernwin.action_desc_t(
            self.act_test,
            'reverse assist tools',
            FEReAssist(),
            'Ctrl+Shift+x',
            '逆向辅助工具', 0)
        ida_kernwin.register_action(action)
        ida_kernwin.attach_action_to_menu(MENU_PATH, self.act_assist, ida_kernwin.SETMENU_APP)

        action = ida_kernwin.action_desc_t(
            self.act_test,
            'functional test',
            FEFuncTest(),
            'Ctrl+Shift+q',
            '功能性测试', 0)
        ida_kernwin.register_action(action)
        ida_kernwin.attach_action_to_menu(MENU_PATH, self.act_test, ida_kernwin.SETMENU_APP)

    def _detach_menu_action(self):
        ida_kernwin.detach_action_from_menu(MENU_PATH, self.act_static)
        ida_kernwin.detach_action_from_menu(MENU_PATH, self.act_dbg_hook)
        ida_kernwin.detach_action_from_menu(MENU_PATH, self.act_pattern)
        ida_kernwin.detach_action_from_menu(MENU_PATH, self.act_assist)
        ida_kernwin.detach_action_from_menu(MENU_PATH, self.act_test)

    def init(self):
        try:
            self._init_actions()
        except Exception as e:
            FELogger.erro(e.__str__())
        return ida_idaapi.PLUGIN_KEEP

    def term(self):
        self._detach_menu_action()

    def banner(self):
        FELogger.console(PLUGIN_HELP)
        FELogger.console(BANNER_MSG)

    def run(self,arg):
        self.banner()

def PLUGIN_ENTRY():
    try:
        return Firmeye()
    except Exception as e:
        FELogger.erro(e.__str__())

```

`firmeye/__init__.py`:

```py
# -*- coding: utf-8 -*-

```

`firmeye/analysis/__init__.py`:

```py
# -*- coding: utf-8 -*-

```

`firmeye/analysis/dynamic.py`:

```py
# -*- coding: utf-8 -*-

import time

import idc
import ida_dbg
import ida_idd
import ida_kernwin
import ida_bytes
import ida_funcs
import idautils

from firmeye.regs import arm_regset
from firmeye.utility import FEStrMgr, SINK_FUNC
from firmeye.helper import hexstr, is_func_call
from firmeye.logger import FELogger
from firmeye.analysis.static import get_custom_func


class FEDbgHook(ida_dbg.DBG_Hooks):
    """
    调试器Hook类
    """

    def __init__(self):
        ida_dbg.DBG_Hooks.__init__(self)

        self.bp_hit_count = {}          # 断点触发次数
        self.bf_hit_count = {}          # 断点所在函数触发次数

        self.reg_val = {}               # 保存寄存器的值
        for reg in arm_regset.args + (arm_regset.stack, ):
            self.reg_val[reg] = ida_idd.regval_t()

        self.step_dbg = False

    def inc_break_func_hit_count(self, func_name):
        if not func_name in self.bf_hit_count:
            self.bf_hit_count[func_name] = 0

        self.bf_hit_count[func_name] += 1

        return self.bf_hit_count[func_name]

    def inc_break_point_hit_count(self, addr):
        if not addr in self.bp_hit_count:
            self.bp_hit_count[addr] = 0

        self.bp_hit_count[addr] += 1

        return self.bp_hit_count[addr]

    def get_xdbg_reg_var(self):
        """
        获取寄存器的值
        """
        for reg_t in self.reg_val:
            ida_dbg.get_reg_val(reg_t, self.reg_val[reg_t])

        return self.reg_val

    def get_args_rule(self, func_name, ea):
        CUSTOM_FUNC = get_custom_func()
        if func_name in SINK_FUNC:
            args_rule = SINK_FUNC[func_name]['args_rule']
        elif func_name in CUSTOM_FUNC:
            args_rule = CUSTOM_FUNC[func_name]['args_rule']
        elif hexstr(ea) in CUSTOM_FUNC:
            args_rule = CUSTOM_FUNC[hexstr(ea)]['args_rule']
        else:
            args_rule = False
        return args_rule

    def var_len_args_run_info(self, args_rule, args):
        """
        获取变长参数函数的寄存器信息
        """

        run_info = {}
        fmt_t = ''

        for idx in range(len(args_rule) - 1):
            str_reg = 'R%s' % idx
            arg_t = args_rule[idx]
            if arg_t == 'none':      # 跳过无关参数
                continue
            elif arg_t == 'int':
                run_info[str_reg] = [hexstr(args[str_reg].ival), None]
                FELogger.console('%s: %s' % (str_reg, hexstr(args[str_reg].ival)))
            elif arg_t == 'str':
                arg_v = args[str_reg].ival
                if arg_v != 0:
                    str_t = FEStrMgr.get_string_from_mem(arg_v)
                else:
                    str_t = ''
                run_info[str_reg] = [hexstr(arg_v), repr(str_t)]
                FELogger.console('%s: %s => %s' % (str_reg, hexstr(arg_v), repr(str_t)))
            elif arg_t == 'fmt':
                arg_v = args[str_reg].ival
                fmt_t = FEStrMgr.get_string_from_mem(arg_v)
                run_info[str_reg] = [hexstr(arg_v), repr(fmt_t)]
                FELogger.console('%s: %s => %s' % (str_reg, hexstr(arg_v), repr(fmt_t)))
            else:
                run_info[str_reg] = [hexstr(args[str_reg].ival), None]
                FELogger.console('%s: %s' % (str_reg, hexstr(args[str_reg].ival)))

        # 判断是否包含格式字符串
        if fmt_t != '':
            fmt_list = FEStrMgr.parse_format_string(str_t)
            args_num = len(fmt_list) + idx + 1
            # 判断变长参数总个数
            if idx+1 == args_num:
                pass
            # n<=4 寄存器
            elif idx+1 < args_num and args_num <= 4:
                for jdx in range(len(fmt_list)):
                    str_reg = 'R%s' % (idx+jdx+1)
                    if 's' in fmt_list[jdx]:
                        arg_v = args[str_reg].ival
                        str_t = FEStrMgr.get_string_from_mem(arg_v)
                        run_info[str_reg] = [hexstr(arg_v), repr(str_t)]
                        FELogger.console('%s: %s => %s' % (str_reg, hexstr(arg_v), repr(str_t)))
                    else:
                        run_info[str_reg] = [hexstr(args[str_reg].ival), None]
                        FELogger.console('%s: %s' % (str_reg, hexstr(args[str_reg].ival)))
            # n>4 寄存器+栈
            else:
                stack_num = args_num - 4
                sp_addr = args[arm_regset.stack].ival
                for jdx in range(4 - idx - 1):
                    str_reg = 'R%s' % (idx+jdx+1)
                    if 's' in fmt_list[jdx]:
                        arg_v = args[str_reg].ival
                        str_t = FEStrMgr.get_string_from_mem(arg_v)
                        run_info[str_reg] = [hexstr(arg_v), repr(str_t)]
                        FELogger.console('%s: %s => %s' % (str_reg, hexstr(arg_v), repr(str_t)))
                    else:
                        run_info[str_reg] = [hexstr(args[str_reg].ival), None]
                        FELogger.console('%s: %s' % (str_reg, hexstr(args[str_reg].ival)))

                run_info[arm_regset.stack] = []
                for kdx in range(stack_num):
                    stack_v = ida_bytes.get_wide_dword(sp_addr)
                    if 's' in fmt_list[jdx+kdx+1]:
                        if stack_v == 0:
                            str_t = ''
                        else:
                            str_t = FEStrMgr.get_string_from_mem(stack_v)
                        run_info[arm_regset.stack].append([hexstr(sp_addr), hexstr(stack_v), repr(str_t)])
                        FELogger.console('stack: %s - %s => %s' % (hexstr(sp_addr), hexstr(stack_v), repr(str_t)))
                    else:
                        run_info[arm_regset.stack].append([hexstr(sp_addr), hexstr(stack_v), None])
                        FELogger.console('stack: %s - %s' % (hexstr(sp_addr), hexstr(stack_v)))
                    sp_addr += 4
        else:
            pass

        return run_info

    def fix_len_args_run_info(self, args_rule, args):
        """
        获取定长参数函数的寄存器信息
        """

        run_info = {}

        for idx in range(len(args_rule)):
            str_reg = 'R%s' % idx
            arg_t = args_rule[idx]
            if arg_t == 'none':     # 跳过无关的参数
                continue
            elif arg_t == 'int':
                run_info[str_reg] = [hexstr(args[str_reg].ival), None]
                FELogger.console('%s: %s' % (str_reg, hexstr(args[str_reg].ival)))
            elif arg_t == 'str':
                arg_v = args[str_reg].ival
                if arg_v != 0:
                    str_t = FEStrMgr.get_string_from_mem(arg_v)
                else:
                    str_t = ''
                run_info[str_reg] = [hexstr(arg_v), repr(str_t)]
                FELogger.console('%s: %s => %s' % (str_reg, hexstr(arg_v), repr(str_t)))
            else:
                run_info[str_reg] = [hexstr(args[str_reg].ival), None]
                FELogger.console('%s: %s' % (str_reg, hexstr(args[str_reg].ival)))

        return run_info

    def get_before_run_info(self, args_rule):
        """
        获取某函数执行前的寄存器信息
        """

        runtime_info = {}
        args = self.get_xdbg_reg_var()

        rv = ida_idd.regval_t()
        ida_dbg.get_reg_val('PC', rv)
        FELogger.console('PC: %s' % hexstr(rv.ival))

        # 判断是否包含变长参数
        if args_rule[-1] == '...':
            runtime_info = self.var_len_args_run_info(args_rule, args)
        elif args_rule[-1] == 'va_list':
            # TODO 支持va_list参数解析，暂时同“...”
            runtime_info = self.var_len_args_run_info(args_rule, args)
        else:
            runtime_info = self.fix_len_args_run_info(args_rule, args)

        return runtime_info

    def get_after_run_info(self, args_rule):
        """
        获取某函数执行后的返回值
        # TODO 添加参数的变化
        """

        runtime_info = {}
        args = self.get_xdbg_reg_var()

        rv = ida_idd.regval_t()
        ida_dbg.get_reg_val('PC', rv)
        FELogger.console('PC: %s' % hexstr(rv.ival))

        arg_v = args[arm_regset.ret].ival
        #str_t = FEStrMgr.get_string_from_mem(arg_v)
        #runtime_info[arm_regset.ret] = [hexstr(arg_v), repr(str_t)]
        #FELogger.console('ret: %s => %s' % (hexstr(arg_v), repr(str_t)))
        FELogger.console('%s: %s' % (arm_regset.ret, hexstr(arg_v)))
        return runtime_info

    def dbg_bpt(self, tid, ea):
        """
        触发断点时的处理函数
        """

        func_name_t = idc.print_operand(ea, 0)
        point_hit_count = self.inc_break_point_hit_count(ea)

        if is_func_call(ea):
            # 如果当前地址是函数调用（即调用前）

            args_rule = self.get_args_rule(func_name_t, ea)
            if args_rule == False:
                FELogger.console('临时断点%s' % hexstr(ea))
            else:
                up_func_name = ida_funcs.get_func_name(ea)
                func_hit_count = self.inc_break_func_hit_count(up_func_name)

                FELogger.console(func_name_t + ' - ' + up_func_name + '-'*60)
                FELogger.console('tid - %d - %d, pointHit: %d, funcHit: %d' %
                                        (tid, time.time(), point_hit_count, func_hit_count))
                FELogger.console(('%s - before' + '-'*30) % func_name_t)

                ida_dbg.refresh_debugger_memory()
                before_info = self.get_before_run_info(args_rule)

        elif is_func_call(ida_bytes.prev_head(ea, 0)):
            # 如果当前地址的上一条地址是函数调用（即调用后）

            func_ea = ida_bytes.prev_head(ea, 0)
            func_name = idc.print_operand(func_ea, 0)
            args_rule = self.get_args_rule(func_name, func_ea)

            FELogger.console(('%s - after ' + '-'*30) % func_name)

            # ida_dbg.refresh_debugger_memory()
            after_info = self.get_after_run_info(args_rule)

        else:
            FELogger.console('临时断点%s' % hexstr(ea))

        # 是否单步调试
        if self.step_dbg == False:
            ida_dbg.continue_process()

        return 0


class FEDynamicAnalyzer(ida_kernwin.action_handler_t):
    """
    动态分析器
    """

    hook_status = False

    def __init__(self):
        ida_kernwin.action_handler_t.__init__(self)
        self.dbg_hook = FEDbgHook()

    def get_xdbg_hook_status(self):
        return self.hook_status

    def set_xdbg_hook_status(self):
        self.hook_status = not self.hook_status

    @FELogger.reload
    def activate(self, ctx):
        if self.get_xdbg_hook_status():
            FELogger.info('关闭调试事件记录')
            self.dbg_hook.unhook()
        else:
            FELogger.info('启用调试事件记录')

            if ida_kernwin.ask_yn(0, '是否单步调试？') == 1:
                self.dbg_hook.step_dbg = True
            else:
                self.dbg_hook.step_dbg = False
            self.dbg_hook.hook()

        self.set_xdbg_hook_status()

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS

```

`firmeye/analysis/static.py`:

```py
# -*- coding: utf-8 -*-

import os
import csv
import random
from functools import reduce

import idc
import idautils
import ida_kernwin
import ida_nalt
import ida_dbg
import ida_ua
import ida_funcs
import ida_bytes
import ida_idaapi

from firmeye.config import SINK_FUNC, FUNC_TAG
from firmeye.utility import FEArgsTracer, FEStrMgr, FESinkFuncMgr
from firmeye.helper import hexstr
from firmeye.view.chooser import AnalysisChooser, AnalysisChooseData
from firmeye.logger import FELogger

CUSTOM_FUNC = {}   # 全局变量，保存用户临时定义的sink函数

def get_custom_func():
    """返回临时函数集合"""
    return CUSTOM_FUNC

def printf_func_analysis(func_name, xref_list):
    """
    printf系列函数漏洞分析
    """

    def check_fmt_reg(xref_addr_t, fmt_reg, vuln_regs, siz_addr_t=0, parse=False):
        vuln_flag = 0
        addr1 = 0
        str1 = ''

        if siz_addr_t == 0:
            str_siz_addr = ''
        else:
            str_siz_addr = hexstr(siz_addr_t)

        FELogger.info("从%s回溯格式字符串%s" % (hexstr(xref_addr_t), fmt_reg))
        tracer = FEArgsTracer(xref_addr_t, fmt_reg)
        source_addr = tracer.run()
        print('source_addr: ', source_addr)
        # 判断是否找到字符串来源地址
        if source_addr == []:
            FELogger.info("未找到目标地址%s" % hexstr(xref_addr_t))
            vuln_flag = 1
        else:
            for fmt_addr in source_addr:
                addr1 = fmt_addr
                fmt_str = FEStrMgr.get_mem_string(fmt_addr)
                # 判断是否找到字符串
                if fmt_str == []:
                    FELogger.info('格式字符串未找到%s' % hexstr(xref_addr_t))
                    vuln_flag = 1
                    str1 = ''
                else:
                    FELogger.info('找到格式字符串%s' % hexstr(xref_addr_t))
                    str1 = fmt_str[0]
                    if parse == False:
                        vuln_flag = 0
                    else:
                        fmt_list = FEStrMgr.parse_format_string(str1)
                        # 判断字符串中的格式字符
                        if fmt_list != [] and 's' in ''.join(fmt_list):
                            if vuln_regs[-1] == '...':
                                args_num = len(fmt_list) + len(vuln_regs) - 1
                                if args_num > 4:
                                    fmt_list = fmt_list[:(4 - (len(vuln_regs) - 1))]

                                for idx in range(len(fmt_list)):
                                    if 's' in fmt_list[idx]:
                                        str_reg = 'R%s' % (len(vuln_regs)-1 + idx)
                                        FELogger.info("从%s回溯字符串%s" % (hexstr(xref_addr_t), str_reg))
                                        str_tracer = FEArgsTracer(xref_addr_t, str_reg, max_node=256)
                                        str_source_addr = str_tracer.run()
                                        print('str_source_addr: ', str_source_addr)
                                        if str_source_addr == []:
                                            FELogger.info("未找到%s字符串地址" % str_reg)
                                            vuln_flag = 1
                                            break
                                        else:
                                            for str_addr in str_source_addr:
                                                if idc.get_operand_type(str_addr, 1) == ida_ua.o_mem:
                                                    vuln_flag = 0
                                                else:
                                                    vuln_flag = 1
                                                    break
                                    else:
                                        continue
                            else:
                                vuln_flag = 1
                        else:
                            FELogger.info("格式字符串不包含s转换符号")
                            vuln_flag = 0

        data = AnalysisChooseData(vuln=vuln_flag, name=func_name_t, ea=xref_addr_t, addr1=addr1, str1=str1, other1=str_siz_addr)
        items.append(data)

    func_name_t = func_name
    xref_list_t = xref_list
    items = []
    vuln_rule = SINK_FUNC[func_name_t]['vuln_rule']
    args_rule = SINK_FUNC[func_name_t]['args_rule']
    for xref_addr_t in xref_list_t:
        for rule in vuln_rule:
            FELogger.info('检测%s漏洞' % rule['vuln_type'])

            if rule['vuln_type'] == 'format_string':
                fmt_reg = rule['vuln_regs'][0]
                check_fmt_reg(xref_addr_t, fmt_reg, args_rule, parse=False)
            else:
                vuln_regs = rule['vuln_regs']
                if vuln_regs[-1] == '...':
                    fmt_reg = vuln_regs[-2]
                    if len(vuln_regs) == 3:
                        siz_reg = vuln_regs[0]
                    else:
                        siz_reg = None
                else:
                    fmt_reg = vuln_regs[-1]
                    if len(vuln_regs) == 2:
                        siz_reg = vuln_regs[0]
                    else:
                        siz_reg = None

                # 判断是否有size参数
                if siz_reg != None:
                    FELogger.info("从%s回溯字符串长度%s" % (hexstr(xref_addr_t), siz_reg))
                    siz_tracer = FEArgsTracer(xref_addr_t, siz_reg, max_node=256)
                    siz_source_addr = siz_tracer.run()
                    print('siz_source_addr: ', siz_source_addr)
                    # 判断是否找到size的地址
                    if siz_source_addr == []:
                        FELogger.info("未找到size地址%s" % hexstr(xref_addr_t))
                        check_fmt_reg(xref_addr_t, fmt_reg, args_rule, parse=True)
                    else:
                        for siz_addr_t in siz_source_addr:
                            # 判断size是否为立即数
                            if idc.get_operand_type(siz_addr_t, 1) != ida_ua.o_imm:
                                check_fmt_reg(xref_addr_t, fmt_reg, args_rule, siz_addr_t, parse=True)
                            else:
                                num = idc.print_operand(siz_addr_t, 1)
                                data = AnalysisChooseData(vuln=0, name=func_name_t, ea=xref_addr_t, addr1=siz_addr_t, str1='', other1=num)
                                items.append(data)
                else:
                    check_fmt_reg(xref_addr_t, fmt_reg, args_rule, parse=True)
    return items

def scanf_func_analysis(func_name, xref_list):
    """
    scanf系列函数漏洞分析
    """

    func_name_t = func_name
    xref_list_t = xref_list

    items = printf_func_analysis(func_name_t, xref_list_t)
    return items

def str_func_analysis(func_name, xref_list):
    """
    str操作类函数漏洞分析
    """

    def check_src_reg(xref_addr_t, src_reg, siz_addr_t=0):
        vuln_flag = 0
        addr1 = 0
        str1 = ''

        if siz_addr_t == 0:
            str_siz_addr = ''
        else:
            str_siz_addr = hexstr(siz_addr_t)

        FELogger.info("从%s回溯来源地址%s" % (hexstr(xref_addr_t), src_reg))
        src_tracer = FEArgsTracer(xref_addr_t, src_reg)
        src_source_addr = src_tracer.run()
        print('src_source_addr: ', src_source_addr)
        # 判断是否找到字符串来源地址
        if src_source_addr == []:
            FELogger.info("未找到目标地址%s" % hexstr(xref_addr_t))
            vuln_flag = 1
        else:
            for src_addr in src_source_addr:
                addr1 = src_addr
                src_str = FEStrMgr.get_mem_string(src_addr)
                # 判断是否找到字符串
                if src_str == []:
                    FELogger.info('来源字符串未找到%s' % hexstr(xref_addr_t))
                    vuln_flag = 1
                else:
                    # 判断来源地址是否为内存
                    str1 = src_str[0]
                    if idc.get_operand_type(src_addr, 1) != ida_ua.o_mem:
                        vuln_flag = 1
                    else:
                        vuln_flag = 0

        data = AnalysisChooseData(vuln=vuln_flag, name=func_name_t, ea=xref_addr_t, addr1=addr1, str1=str1, other1=str_siz_addr)
        items.append(data)

    func_name_t = func_name
    xref_list_t = xref_list
    items = []
    vuln_rule = SINK_FUNC[func_name_t]['vuln_rule']
    vuln_regs = vuln_rule[0]['vuln_regs']
    src_reg = vuln_regs[0]
    siz_reg = None
    if len(vuln_regs) == 2:
        siz_reg = vuln_regs[1]

    FELogger.info('检测%s漏洞' % vuln_rule[0]['vuln_type'])
    for xref_addr_t in xref_list_t:
        # 判断是否有size参数
        if siz_reg != None:
            FELogger.info("从%s回溯字符串长度%s" % (hexstr(xref_addr_t), siz_reg))
            siz_tracer = FEArgsTracer(xref_addr_t, siz_reg, max_node=256)
            siz_source_addr = siz_tracer.run()
            print('siz_source_addr: ', siz_source_addr)
            # 判断是否找到size的地址
            if siz_source_addr == []:
                FELogger.info("未找到size地址%s" % hexstr(xref_addr_t))
                data = AnalysisChooseData(vuln=1, name=func_name_t, ea=xref_addr_t)
                items.append(data)
            else:
                for siz_addr_t in siz_source_addr:
                    # 判断size是否为立即数
                    if idc.get_operand_type(siz_addr_t, 1) != ida_ua.o_imm:
                        check_src_reg(xref_addr_t, src_reg, siz_addr_t)
                    else:
                        num = idc.print_operand(siz_addr_t, 1)
                        data = AnalysisChooseData(vuln=0, name=func_name_t, ea=xref_addr_t, addr1=siz_addr_t, str1='', other1=num)
                        items.append(data)
        else:
            check_src_reg(xref_addr_t, src_reg)
    return items

def mem_func_analysis(func_name, xref_list):
    """
    mem系列函数漏洞分析
    """

    func_name_t = func_name
    xref_list_t = xref_list

    items = str_func_analysis(func_name_t, xref_list_t)
    return items

def system_func_analysis(func_name, xref_list):
    """
    system系列函数漏洞分析    
    """

    vuln_flag = 0
    addr1 = 0
    str1 = ''

    func_name_t = func_name
    xref_list_t = xref_list
    items = []
    vuln_rule = SINK_FUNC[func_name_t]['vuln_rule']
    vuln_reg = vuln_rule[0]['vuln_regs'][0]

    FELogger.info('检测%s漏洞' % vuln_rule[0]['vuln_type'])
    for xref_addr_t in xref_list_t:
        FELogger.info("从%s回溯来源地址%s" % (hexstr(xref_addr_t), vuln_reg))
        tracer = FEArgsTracer(xref_addr_t, vuln_reg)
        source_addr = tracer.run()
        print('source_addr: ', source_addr)
        # 判断是否找到目标地址
        if source_addr == []:
            FELogger.info("目标地址未找到%s" % hexstr(xref_addr_t))
            vuln_flag = 1
        else:
            for cmd_addr in source_addr:
                addr1 = cmd_addr
                # 判断字符串是否来自内存
                if idc.get_operand_type(cmd_addr, 1) == ida_ua.o_mem:
                    cmd_str = FEStrMgr.get_mem_string(cmd_addr)
                    # 判断是否找到字符串
                    if cmd_str == []:
                        FELogger.info("硬编码命令未找到%s" % hexstr(xref_addr_t))
                        vuln_flag = 1
                    else:
                        vuln_flag = 0
                        str1 = cmd_str[0]
                else:
                    FELogger.info("命令来自外部%s" % hexstr(xref_addr_t))
                    vuln_flag = 1

        data = AnalysisChooseData(vuln=vuln_flag, name=func_name_t, ea=xref_addr_t, addr1=addr1, str1=str1)
        items.append(data)
    return items


class FEStaticForm(ida_kernwin.Form):
    """
    静态分析窗口
    """

    sink_func_xref_dict = {}
    vuln_func_fast_dict = {}    # 缓存，避免重复分析
    vuln_func_dict = {}
    tmp_func_dict = {}

    def __init__(self):
        ida_kernwin.Form.__init__(self, """STARTITEM 0
Firmeye Static Analyzer
危险函数地址:
<##查看:{btn_get_sink_func_addr}>
对指定函数调用地址下断点:
<##添加断点:{btn_add_tmp_func_bpt}><##删除断点:{btn_del_tmp_func_bpt}><##仅添加函数:{btn_add_tmp_func_info}>
危险函数调用地址（全部）:
<##查看:{btn_get_all_sink_func_xref}><##添加断点:{btn_add_all_xref_bpt}><##删除断点:{btn_del_all_xref_bpt}>
危险函数调用地址（指定）:
<##查看:{btn_get_one_sink_func_xref}><##添加断点:{btn_add_one_xref_bpt}><##删除断点:{btn_del_one_xref_bpt}>
危险函数漏洞分析（全部）:
<##查看:{btn_get_all_vuln_func}><##添加断点:{btn_add_all_vuln_bpt}><##删除断点:{btn_del_all_vuln_bpt}>
危险函数漏洞分析（指定）:
<##查看:{btn_get_one_vuln_func}><##添加断点:{btn_add_one_vuln_bpt}><##删除断点:{btn_del_one_vuln_bpt}>
给所有断点的下一条指令下断点:
<##添加断点:{btn_add_next_inst_bpt}><##添加并删除当前断点:{btn_add_next_and_del_inst_bpt}>
导出/导入离线断点:
<##导出:{btn_export_all_bpt_addr}><##导入:{btn_import_all_bpt_addr}>
""", {
    'btn_get_sink_func_addr': ida_kernwin.Form.ButtonInput(self.btn_get_sink_func_addr),

    'btn_get_all_sink_func_xref': ida_kernwin.Form.ButtonInput(self.btn_get_all_sink_func_xref),
    'btn_get_one_sink_func_xref': ida_kernwin.Form.ButtonInput(self.btn_get_one_sink_func_xref),
    'btn_get_all_vuln_func': ida_kernwin.Form.ButtonInput(self.btn_get_all_vuln_func),
    'btn_get_one_vuln_func': ida_kernwin.Form.ButtonInput(self.btn_get_one_vuln_func),

    'btn_add_all_xref_bpt': ida_kernwin.Form.ButtonInput(self.btn_add_all_xref_bpt),
    'btn_del_all_xref_bpt': ida_kernwin.Form.ButtonInput(self.btn_del_all_xref_bpt),
    'btn_add_one_xref_bpt': ida_kernwin.Form.ButtonInput(self.btn_add_one_xref_bpt),
    'btn_del_one_xref_bpt': ida_kernwin.Form.ButtonInput(self.btn_del_one_xref_bpt),
    'btn_add_all_vuln_bpt': ida_kernwin.Form.ButtonInput(self.btn_add_all_vuln_bpt),
    'btn_del_all_vuln_bpt': ida_kernwin.Form.ButtonInput(self.btn_del_all_vuln_bpt),
    'btn_add_one_vuln_bpt': ida_kernwin.Form.ButtonInput(self.btn_add_one_vuln_bpt),
    'btn_del_one_vuln_bpt': ida_kernwin.Form.ButtonInput(self.btn_del_one_vuln_bpt),
    'btn_add_tmp_func_bpt': ida_kernwin.Form.ButtonInput(self.btn_add_tmp_func_bpt),
    'btn_del_tmp_func_bpt': ida_kernwin.Form.ButtonInput(self.btn_del_tmp_func_bpt),
    'btn_add_tmp_func_info': ida_kernwin.Form.ButtonInput(self.btn_add_tmp_func_info),
    'btn_add_next_inst_bpt': ida_kernwin.Form.ButtonInput(self.btn_add_next_inst_bpt),
    'btn_add_next_and_del_inst_bpt': ida_kernwin.Form.ButtonInput(self.btn_add_next_and_del_inst_bpt),
    'btn_export_all_bpt_addr': ida_kernwin.Form.ButtonInput(self.btn_export_all_bpt_addr),
    'btn_import_all_bpt_addr': ida_kernwin.Form.ButtonInput(self.btn_import_all_bpt_addr),
})

    def add_or_del_all_xref_bpt(self, is_add):
        if is_add == True:
            action = idc.add_bpt
            act_info = '添加'
        else:
            action = idc.del_bpt
            act_info = '删除'

        if self.sink_func_xref_dict == {}:
            mgr_t = FESinkFuncMgr()
            for func_name, xref_list in mgr_t.gen_sink_func_xref():
                tmp_list = []
                for xref_addr_t in xref_list:
                    tmp_list.append(xref_addr_t)
                    action(xref_addr_t)
                self.sink_func_xref_dict[func_name] = tmp_list
        else:
            for xref_addr_t in reduce(lambda x, y: x+y, self.sink_func_xref_dict.values()):
                action(xref_addr_t)
        FELogger.info('已%s断点：危险函数调用地址（全部）' % act_info)

    def btn_add_all_xref_bpt(self, code=0):
        """添加断点 所有危险函数调用地址"""
        self.add_or_del_all_xref_bpt(is_add=True)

    def btn_del_all_xref_bpt(self, code=0):
        """删除断点 所有危险函数调用地址"""
        self.add_or_del_all_xref_bpt(is_add=False)

    def add_or_del_one_xref_bpt(self, is_add):
        if is_add == True:
            action = idc.add_bpt
            act_info = '添加'
        else:
            action = idc.del_bpt
            act_info = '删除'

        tgt_t = ida_kernwin.ask_str('', 0, '请输入危险函数名')
        if tgt_t in SINK_FUNC:
            if not tgt_t in self.sink_func_xref_dict:
                mgr_t = FESinkFuncMgr()
                xref_list = mgr_t.get_one_func_xref(tgt_t)

                if not xref_list:
                    FELogger.warn("未找到函数%s" % tgt_t)
                    return

                tmp_list = []
                for xref_addr in xref_list:
                    tmp_list.append(xref_addr)
                    action(xref_addr)
                self.sink_func_xref_dict[tgt_t] = tmp_list
            else:
                for xref_addr_t in self.sink_func_xref_dict[tgt_t]:
                    action(xref_addr_t)
            FELogger.info("已%s断点：危险函数调用地址（%s）" % (act_info, tgt_t))
        else:
            FELogger.warn("未支持函数")

    def btn_add_one_xref_bpt(self, code=0):
        """添加断点 某个危险函数调用地址"""
        self.add_or_del_one_xref_bpt(is_add=True)

    def btn_del_one_xref_bpt(self, code=0):
        """删除断点 某个危险函数调用地址"""
        self.add_or_del_one_xref_bpt(is_add=False)

    def btn_add_all_vuln_bpt(self, code=0):
        """添加断点 所有危险函数漏洞地址"""
        self.add_fast_dict_from_all_vuln_func()

        for xref_addr_t in reduce(lambda x, y: x + y, self.vuln_func_fast_dict.values()):
            ida_dbg.add_bpt(xref_addr_t, 0, idc.BPT_DEFAULT)

        FELogger.info('已添加断点：危险函数漏洞分析（全部）')

    def btn_del_all_vuln_bpt(self, code=0):
        """删除断点 所有危险函数漏洞地址"""
        for xref_addr_t in reduce(lambda x, y: x + y, self.vuln_func_fast_dict.values()):
            ida_dbg.del_bpt(xref_addr_t)

        FELogger.info('已删除断点：危险函数漏洞分析（全部）')

    def btn_add_one_vuln_bpt(self, code=0):
        """添加断点 某个危险函数漏洞地址"""
        tgt_t = ida_kernwin.ask_str('', 0, '请输入危险函数名')
        if tgt_t in SINK_FUNC:
            if not tgt_t in self.vuln_func_fast_dict:
                mgr_t = FESinkFuncMgr()
                xref_list = mgr_t.get_one_func_xref(tgt_t)
                tag = SINK_FUNC[tgt_t]['tag']

                if not xref_list:
                    FELogger.warn("未找到函数%s" % tgt_t)
                    return

                if tag == FUNC_TAG['PRINTF']:
                    items = printf_func_analysis(tgt_t, xref_list)
                    self.add_fast_dict_from_items(items)
                elif tag == FUNC_TAG['STRING']:
                    items = str_func_analysis(tgt_t, xref_list)
                    self.add_fast_dict_from_items(items)
                elif tag == FUNC_TAG['SCANF']:
                    items = scanf_func_analysis(tgt_t, xref_list)
                    self.add_fast_dict_from_items(items)
                elif tag == FUNC_TAG['SYSTEM']:
                    items = system_func_analysis(tgt_t, xref_list)
                    self.add_fast_dict_from_items(items)
                elif tag == FUNC_TAG['MEMORY']:
                    items = mem_func_analysis(tgt_t, xref_list)
                    self.add_fast_dict_from_items(items)
                else:
                    FELogger.info("未支持函数%s" % tgt_t)

            if tgt_t in self.vuln_func_fast_dict:
                for xref_addr_t in self.vuln_func_fast_dict[tgt_t]:
                    ida_dbg.add_bpt(xref_addr_t, 0, idc.BPT_DEFAULT)

            FELogger.info('已添加断点：危险函数漏洞分析（%s）' % tgt_t)
        else:
            FELogger.warn("未支持函数")

    def btn_del_one_vuln_bpt(self, code=0):
        """删除断点 某个危险函数漏洞地址"""
        tgt_t = ida_kernwin.ask_str('', 0, '请输入危险函数名')
        if tgt_t in SINK_FUNC:
            if tgt_t in self.vuln_func_fast_dict:
                for xref_addr_t in self.vuln_func_fast_dict[tgt_t]:
                    ida_dbg.del_bpt(xref_addr_t)
            FELogger.info("已删除断点：危险函数漏洞分析（%s）" % tgt_t)
        else:
            FELogger.warn("未支持函数")

    def add_tmp_func(self, info_only=False):
        """
        添加临时sink函数
        info_only: 在添加函数信息的同时是否添加断点
        """

        input_str = ida_kernwin.ask_text(0, '', "请输入任意函数名/函数地址，及各参数类型（none, int, str），可输入多行\n例如：\nstrcmp str str")
        try:
            rules = [x.strip() for x in input_str.strip().split('\n')]
            for rule in rules:
                tgt_t = rule.split(' ')[0].strip()
                args_rule = [x.strip() for x in rule.split(' ')[1:]]

                if not tgt_t in self.tmp_func_dict:
                    if tgt_t.startswith('0x'):
                        addr_t = int(tgt_t, 16)
                        addr_hexstr = hexstr(addr_t)
                        CUSTOM_FUNC[addr_hexstr] = {'args_rule': args_rule}
                        self.tmp_func_dict[addr_hexstr] = [addr_t]
                        if info_only == False:
                            ida_dbg.add_bpt(addr_t, 0, idc.BPT_DEFAULT)
                    else:
                        for func_addr_t in idautils.Functions():
                            func_name_t = ida_funcs.get_func_name(func_addr_t)
                            if func_name_t == tgt_t:
                                CUSTOM_FUNC[func_name_t] = {'args_rule': args_rule}
                                self.tmp_func_dict[func_name_t] = []
                                for xref_addr_t in idautils.CodeRefsTo(func_addr_t, 0):
                                    self.tmp_func_dict[func_name_t].append(xref_addr_t)
                                    if info_only == False:
                                        ida_dbg.add_bpt(xref_addr_t, 0, idc.BPT_DEFAULT)
                                    else:
                                        continue
                                break
                            else:
                                continue
                else:
                    CUSTOM_FUNC[tgt_t] = {'args_rule': args_rule}
                    for xref_addr_t in self.tmp_func_dict[tgt_t]:
                        if info_only == False:
                            ida_dbg.add_bpt(xref_addr_t, 0, idc.BPT_DEFAULT)
                        else:
                            continue
                FELogger.info("已添加断点：%s" % rule)
        except Exception as e:
            FELogger.info("输入信息有误：%s" % e)

    def btn_add_tmp_func_bpt(self, code=0):
        """添加临时函数并下断点"""
        self.add_tmp_func(info_only=False)

    def btn_del_tmp_func_bpt(self, code=0):
        """删除临时函数断点"""
        tgt_t = ida_kernwin.ask_str('', 0, '请输入任意函数名')
        try:
            if tgt_t in self.tmp_func_dict:
                for xref_addr_t in self.tmp_func_dict[tgt_t]:
                    ida_dbg.del_bpt(xref_addr_t)
                CUSTOM_FUNC.pop(tgt_t)
            FELogger.info("已删除断点：指定函数调用地址 %s" % tgt_t)
        except Exception:
            FELogger.warn("请输入函数名")

    def btn_add_tmp_func_info(self, code=0):
        """添加临时函数"""
        self.add_tmp_func(info_only=True)

    def get_all_bpt_list(self):
        """
        获取所有断点的地址列表
        """
        bpt_list = []
        bpt_num = ida_dbg.get_bpt_qty()
        bpt_t = ida_dbg.bpt_t()
        for i in range(bpt_num):
            if ida_dbg.getn_bpt(i, bpt_t) == True:
                bpt_list.append(bpt_t.ea)
            else:
                FELogger.info("获取断点失败 %d" % i)
        return bpt_list

    def btn_add_next_inst_bpt(self, code=0):
        """
        给所有断点的下一条指令下断点
        """
        bpt_list = self.get_all_bpt_list()
        for bpt in bpt_list:
            ida_dbg.add_bpt(ida_bytes.next_head(bpt, ida_idaapi.BADADDR), 0, idc.BPT_DEFAULT)

    def btn_add_next_and_del_inst_bpt(self, code=0):
        """
        给所有断点的下一条指令下断点并删除当前断点
        """
        bpt_list = self.get_all_bpt_list()
        for bpt in bpt_list:
            ida_dbg.add_bpt(ida_bytes.next_head(bpt, ida_idaapi.BADADDR), 0, idc.BPT_DEFAULT)
            ida_dbg.del_bpt(bpt)

    def btn_export_all_bpt_addr(self, code=0):
        """
        导出离线断点
        """
        cur_workpath = os.getcwd()
        csv_filepath = os.path.join(cur_workpath, '%s_bpt.csv' % ida_nalt.get_root_filename())

        bpt_list = self.get_all_bpt_list()
        bpt_list = [[format(bpt, '#010x')[2:]] for bpt in bpt_list]

        header = ['breakpoints']
        with open(csv_filepath, 'w', newline='') as f:
            ff = csv.writer(f)
            ff.writerow(header)
            ff.writerows(bpt_list)

        FELogger.info("导出断点完成：%s" % csv_filepath)

    def btn_import_all_bpt_addr(self, code=0):
        """
        导入离线断点
        """
        cur_workpath = os.getcwd()
        csv_filepath = os.path.join(cur_workpath, '%s_bpt.csv' % ida_nalt.get_root_filename())

        if os.path.exists(csv_filepath):
            with open(csv_filepath, 'r') as f:
                next(f)
                reader = csv.reader(f)
                for row in reader:
                    ida_dbg.add_bpt(int(row[0], 16), 0, idc.BPT_DEFAULT)
            FELogger.info("导入断点完成：%s" % csv_filepath)
        else:
            FELogger.warn("文件不存在：%s" % csv_filepath)

    def btn_get_sink_func_addr(self, code=0):
        """
        查看危险函数地址列表
        """
        cols = [['', 0 | ida_kernwin.Choose.CHCOL_DEC],
                ['函数名', 10 | ida_kernwin.Choose.CHCOL_PLAIN],
                ['函数地址', 10 | ida_kernwin.Choose.CHCOL_HEX]]
        items = []

        mgr_t = FESinkFuncMgr()
        for func_name, func_addr in mgr_t.gen_sink_func_addr():
            data = AnalysisChooseData(vuln=0, name=func_name, ea=func_addr)
            items.append(data)

        chooser = AnalysisChooser(title='危险函数地址', cols=cols, item=items)
        chooser.Show()

    def btn_get_all_sink_func_xref(self, code=0):
        """
        查看所有危险函数调用地址
        """

        cols = [['', 0 | ida_kernwin.Choose.CHCOL_DEC],
                ['函数名', 10 | ida_kernwin.Choose.CHCOL_PLAIN],
                ['函数地址', 10 | ida_kernwin.Choose.CHCOL_HEX]]
        items = []

        mgr_t = FESinkFuncMgr()
        for func_name, xref_list in mgr_t.gen_sink_func_xref():
            tmp_list = []
            for xref_addr in xref_list:
                data = AnalysisChooseData(vuln=0, name=func_name, ea=xref_addr)
                items.append(data)
                tmp_list.append(xref_addr)
            self.sink_func_xref_dict[func_name] = tmp_list

        chooser = AnalysisChooser(title='危险函数调用地址', cols=cols, item=items)
        chooser.Show()

    def btn_get_one_sink_func_xref(self, code=0):
        """
        查看某个危险函数调用地址
        """

        tgt_t = ida_kernwin.ask_str('', 0, '请输入要查看的危险函数名')
        if tgt_t in SINK_FUNC:
            cols = [['', 0 | ida_kernwin.Choose.CHCOL_DEC],
                ['函数名', 10 | ida_kernwin.Choose.CHCOL_PLAIN],
                ['函数地址', 10 | ida_kernwin.Choose.CHCOL_HEX]]
            items = []

            mgr_t = FESinkFuncMgr()
            xref_list = mgr_t.get_one_func_xref(tgt_t)

            if not xref_list:
                FELogger.warn("未找到函数%s" % tgt_t)
                return

            tmp_list = []
            for xref_addr in xref_list:
                data = AnalysisChooseData(vuln=0, name=tgt_t, ea=xref_addr)
                items.append(data)
                tmp_list.append(xref_addr)
            self.sink_func_xref_dict[tgt_t] = tmp_list

            chooser = AnalysisChooser(title='危险函数调用地址', cols=cols, item=items)
            chooser.Show()
        else:
            FELogger.warn("未支持函数")

    def get_vuln_addr_from_items(self, items):
        vuln_list = set()
        for item in items:
            if item.vuln == 1:
                vuln_list.add(item.ea)
            else:
                continue
        return list(vuln_list)

    def add_fast_dict_from_items(self, items):
        if items != []:
            func_name = items[0].name
            vuln_list = self.get_vuln_addr_from_items(items)
            self.vuln_func_fast_dict[func_name] = vuln_list

    def add_fast_dict_from_all_vuln_func(self):
        mgr_t = FESinkFuncMgr()
        for func_name, xref_list in mgr_t.gen_sink_func_xref():
            if not func_name in self.vuln_func_fast_dict:
                tag = SINK_FUNC[func_name]['tag']
                print('func_name: ', func_name)
                print('xref_list: ', len(xref_list))
                if tag == FUNC_TAG['PRINTF']:
                    items = printf_func_analysis(func_name, xref_list)
                    self.add_fast_dict_from_items(items)
                elif tag == FUNC_TAG['STRING']:
                    items = str_func_analysis(func_name, xref_list)
                    self.add_fast_dict_from_items(items)
                elif tag == FUNC_TAG['SCANF']:
                    items = scanf_func_analysis(func_name, xref_list)
                    self.add_fast_dict_from_items(items)
                elif tag == FUNC_TAG['SYSTEM']:
                    items = system_func_analysis(func_name, xref_list)
                    self.add_fast_dict_from_items(items)
                elif tag == FUNC_TAG['MEMORY']:
                    items = mem_func_analysis(func_name, xref_list)
                    self.add_fast_dict_from_items(items)
                else:
                    FELogger.info("未支持函数%s" % func_name)
            else:
                continue

    def btn_get_all_vuln_func(self, code=0):
        """查看所有危险函数漏洞地址"""
        self.add_fast_dict_from_all_vuln_func()

    def btn_get_one_vuln_func(self, code=0):
        """查看某个危险函数漏洞地址"""
        tgt_t = ida_kernwin.ask_str('', 0, '请输入要查看的危险函数名')
        if tgt_t in SINK_FUNC:
            mgr_t = FESinkFuncMgr()
            xref_list = mgr_t.get_one_func_xref(tgt_t)
            tag = SINK_FUNC[tgt_t]['tag']

            if not xref_list:
                FELogger.warn("未找到函数%s" % tgt_t)
                return

            # printf系列函数
            if tag == FUNC_TAG['PRINTF']:
                items = printf_func_analysis(tgt_t, xref_list)
                self.add_fast_dict_from_items(items)
                cols = [['可疑', 3 | ida_kernwin.Choose.CHCOL_DEC],
                        ['函数名', 10 | ida_kernwin.Choose.CHCOL_PLAIN],
                        ['函数地址', 10 | ida_kernwin.Choose.CHCOL_HEX],
                        ['格式字符串地址', 10 | ida_kernwin.Choose.CHCOL_HEX],
                        ['格式字符串', 15 | ida_kernwin.Choose.CHCOL_PLAIN],
                        ['长度', 10 | ida_kernwin.Choose.CHCOL_HEX]]
                chooser = AnalysisChooser(title='危险函数漏洞分析', cols=cols, item=items)
                chooser.Show()

            # str系列函数
            elif tag == FUNC_TAG['STRING']:
                items = str_func_analysis(tgt_t, xref_list)
                self.add_fast_dict_from_items(items)
                cols = [['可疑', 3 | ida_kernwin.Choose.CHCOL_DEC],
                        ['函数名', 10 | ida_kernwin.Choose.CHCOL_PLAIN],
                        ['函数地址', 10 | ida_kernwin.Choose.CHCOL_HEX],
                        ['来源地址', 10 | ida_kernwin.Choose.CHCOL_HEX],
                        ['字符串', 15 | ida_kernwin.Choose.CHCOL_PLAIN],
                        ['字符串长度', 10 | ida_kernwin.Choose.CHCOL_HEX]]
                chooser = AnalysisChooser(title='危险函数漏洞分析', cols=cols, item=items)
                chooser.Show()

            # scanf系列函数
            elif tag == FUNC_TAG['SCANF']:
                items = scanf_func_analysis(tgt_t, xref_list)
                self.add_fast_dict_from_items(items)
                cols = [['可疑', 3 | ida_kernwin.Choose.CHCOL_DEC],
                        ['函数名', 10 | ida_kernwin.Choose.CHCOL_PLAIN],
                        ['函数地址', 10 | ida_kernwin.Choose.CHCOL_HEX],
                        ['格式字符串地址', 10 | ida_kernwin.Choose.CHCOL_HEX],
                        ['格式字符串', 15 | ida_kernwin.Choose.CHCOL_PLAIN],
                        ['长度', 10 | ida_kernwin.Choose.CHCOL_HEX]]
                chooser = AnalysisChooser(title='危险函数漏洞分析', cols=cols, item=items)
                chooser.Show()

            # system函数
            elif tag == FUNC_TAG['SYSTEM']:
                items = system_func_analysis(tgt_t, xref_list)
                self.add_fast_dict_from_items(items)
                cols = [['可疑', 3 | ida_kernwin.Choose.CHCOL_DEC],
                        ['函数名', 10 | ida_kernwin.Choose.CHCOL_PLAIN],
                        ['函数地址', 10 | ida_kernwin.Choose.CHCOL_HEX],
                        ['来源地址', 10 | ida_kernwin.Choose.CHCOL_HEX],
                        ['命令语句', 15 | ida_kernwin.Choose.CHCOL_PLAIN]]
                chooser = AnalysisChooser(title='危险函数漏洞分析', cols=cols, item=items)
                chooser.Show()

            # mem系列函数
            elif tag == FUNC_TAG['MEMORY']:
                items = mem_func_analysis(tgt_t, xref_list)
                self.add_fast_dict_from_items(items)
                cols = [['可疑', 3 | ida_kernwin.Choose.CHCOL_DEC],
                        ['函数名', 10 | ida_kernwin.Choose.CHCOL_PLAIN],
                        ['函数地址', 10 | ida_kernwin.Choose.CHCOL_HEX],
                        ['来源地址', 10 | ida_kernwin.Choose.CHCOL_HEX],
                        ['', 0 | ida_kernwin.Choose.CHCOL_PLAIN],
                        ['字符串长度', 10 | ida_kernwin.Choose.CHCOL_HEX]]
                chooser = AnalysisChooser(title='危险函数漏洞分析', cols=cols, item=items)
                chooser.Show()
            else:
                FELogger.info("未支持函数%s" % tgt_t)
        else:
            FELogger.warn("未支持函数")


class FEStaticAnalyzer(ida_kernwin.action_handler_t):
    """
    静态分析器
    """

    def __init__(self):
        ida_kernwin.action_handler_t.__init__(self)

    def show_menu(self):
        main = FEStaticForm()
        main.Compile()
        main.Execute()

    @FELogger.reload
    def activate(self, ctx):
        self.show_menu()

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS

```

`firmeye/cli/firmeye_cli.py`:

```py
# -*- coding: utf-8 -*-

import os

import ida_pro

from firmeye.utility import SINK_FUNC, FUNC_TAG, MEMORY
from firmeye.helper import hexstr
from firmeye.analysis.static import FESinkFuncMgr, printf_func_analysis, str_func_analysis, scanf_func_analysis, system_func_analysis, mem_func_analysis

def analysis():
    f = open('analyze_result.txt', 'w+')
    result = []
    mgr_t = FESinkFuncMgr()

    for func_name, xref_list in mgr_t.gen_sink_func_xref():
        tag = SINK_FUNC[func_name]['tag']
        if tag == FUNC_TAG['PRINTF']:
            items = printf_func_analysis(func_name, xref_list)
            result += build_result(items)
        elif tag == FUNC_TAG['STRING']:
            items = str_func_analysis(func_name, xref_list)
            result += build_result(items)
        elif tag == FUNC_TAG['SCANF']:
            items = scanf_func_analysis(func_name, xref_list)
            result += build_result(items)
        elif tag == FUNC_TAG['SYSTEM']:
            items = system_func_analysis(func_name, xref_list)
            result += build_result(items)
        elif tag == FUNC_TAG['MEMORY']:
            items = mem_func_analysis(func_name, xref_list)
            result += build_result(items)
        else:
            continue

    f.writelines(result)
    f.close

def build_result(items):
    lines = []
    for item in items:
        data = [str(item.vuln), item.name, hexstr(item.ea)]
        for x in [item.addr1, item.addr2]:
            if x != None:
                data.append(hexstr(x))
            else:
                continue
        for x in [item.str1, item.str2, item.other1]:
            if x != None:
                data.append(repr(x))
            else:
                continue
        data.append('\n')
        lines.append('\t'.join(data))
    return lines

if __name__ == "__main__":
    analysis()
    if "DO_EXIT" in os.environ:
        ida_pro.qexit(1)

```

`firmeye/cli/idahunt.py`:

```py
# -*- coding: utf-8 -*-

import argparse
import os
import re
import sys
import subprocess
import time
import glob
import struct

def logmsg(s, end=None, debug=True):
    if not debug:
        return
    if type(s) == str:
        if end != None:
            print("[idahunt] " + s, end=end)
        else:
            print("[idahunt] " + s)
    else:
        print(s)

def iglob_hidden(*args, **kwargs):
    """
    A glob.iglob that include dot files and hidden files
    https://gist.github.com/polyvertex/b6d337fec7011a0f9292
    """
    old_ishidden = glob._ishidden
    glob._ishidden = lambda x: False
    try:
        yield from glob.iglob(*args, **kwargs)
    finally:
        glob._ishidden = old_ishidden

def path_to_module_string(p):
    return p.replace("/", ".").replace("\\", ".")

def detect_arch_pe_files(filename):
    """
    自动检测 PE 文件的体系结构
    """

    IMAGE_FILE_MACHINE_I386 = 0x014c
    IMAGE_FILE_MACHINE_IA64 = 0x0200
    IMAGE_FILE_MACHINE_AMD64 = 0x8664
    IMAGE_FILE_MACHINE_ARMTHUMB_MIXED = 0x01c2
    IMAGE_FILE_MACHINE_ARM64 = 0xAA64

    arch = None
    f = open(filename, "rb")
    f.seek(60)
    s = f.read(4)
    header_offset = struct.unpack("<L", s)[0]
    f.seek(header_offset+4)
    s = f.read(2)
    machine = struct.unpack("<H", s)[0]
    if machine == IMAGE_FILE_MACHINE_I386 or machine == IMAGE_FILE_MACHINE_ARMTHUMB_MIXED:
        arch = 32
    elif machine == IMAGE_FILE_MACHINE_IA64 or machine == IMAGE_FILE_MACHINE_AMD64 or machine == IMAGE_FILE_MACHINE_ARM64:
        arch = 64
    else:
        logmsg("Unknown architecture detected for %s. Ignoring" % filename)
    f.close()

    return arch

def detect_arch_elf_files(filename):
    """
    自动检测 ELF 文件的体系结构
    """

    arch = None
    f = open(filename, "rb")
    f.seek(4)
    s = f.read(1)
    if s == b"\x01":
        arch = 32
    elif s == b"\x02":
        arch = 64
    else:
        logmsg("Unknown architecture detected for %s. Ignoring" % filename)
    f.close()

    return arch

def detect_arch(filename):
    """
    自动检测体系结构
    """
    arch = None
    f = open(filename, "rb")
    pe = f.read(2)
    f.seek(0)
    elf = f.read(4)
    f.close()
    if pe == b"MZ":
        arch = detect_arch_pe_files(filename)
    elif elf == b"\x7fELF":
        arch = detect_arch_elf_files(filename)
    else:
        logmsg("Not an EXE or ELF file. Ignoring automatic architecture detection")

    return arch

def analyse_file(ida_executable, infile, logfile, idbfile, verbose, ida_args=None, script=None, list_only=False):
    """
    Does the initial auto-analysis when we first open a file in IDA
    Returns False if does not do anything, the subprocess if it was created
    of True if it was listing only.
    """

    if os.path.isfile(idbfile):
        logmsg("Skipping existing IDB %s. Analysis has already been made" % idbfile, debug=verbose)
        return False
    if os.path.isfile(infile + ".id0"):
        logmsg("Skipping existing id0 %s. Close IDB first." % (infile + ".id0"), debug=verbose)
        return False
    logmsg("Analysing %s" % infile)
    # 使用 -o 处理符号链接
    if ida_args:
        cmd = [ida_executable, "-B", "-o%s" % idbfile, "-L%s"% logfile] + ida_args + [infile]
    else:
        cmd = [ida_executable, "-B", "-o%s" % idbfile, "-L%s"% logfile, infile]
    if verbose:
        logmsg("%s" % " ".join(cmd))
    shell=True
    if os.name == "posix":
        shell=False

    if not list_only:
        return subprocess.Popen(cmd, shell)
    else:
        return True

def open_file(ida_executable, infile, logfile, idbfile, verbose, ida_args=None, script=None, list_only=False):
    """
    重新打开已存在的 IDB
    Returns False if does not do anything, the subprocess if it was created
    of True if it was listing only.
    """

    if not os.path.isfile(idbfile):
        logmsg("Skipping no existing IDB %s. Execute --analyse first." % idbfile, debug=verbose)
        return False
    if os.path.isfile(infile + ".id0"):
        logmsg("Skipping existing id0 %s. Close IDB first." % (infile + ".id0"), debug=verbose)
        return False
    logmsg("Opening %s" % infile)
    if ida_args:
        cmd = [ida_executable] + ida_args + [idbfile]
    else:
        cmd = [ida_executable, idbfile]
    if verbose:
        logmsg("%s" % " ".join(cmd))
    shell=True
    if os.name == "posix":
        shell=False
    if not list_only:
        subprocess.Popen(cmd, shell)
    # We don't want to wait that it gets closed since it will be a manual
    # operation from the user anyway
    return True

def exec_ida_python_script(ida_executable, infile, logfile, idbfile, verbose, ida_args=None, script=None, list_only=False):
    """
    Re-open an existing IDB and execute an IDA Python script before leaving
    Returns False if does not do anything, the subprocess if it was created
    of True if it was listing only.
    """

    if not script:
        logmsg("Skipping because no script provided. Need a script to execute it in IDA", debug=verbose)
        return False
    if not os.path.isfile(idbfile):
        logmsg("Skipping no existing IDB %s. Execute --analyse first." % idbfile, debug=verbose)
        return False
    if os.path.isfile(infile + ".id0"):
        logmsg("Skipping existing id0 %s. Close IDB first." % (infile + ".id0"), debug=verbose)
        return False
    # If we pass a relative script path from the command line, we try to guess the right path
    # by either looking at the relative path from where idahunt.py is called or by looking at
    # a relative path to the file we analyse is, i.e. where the .idb is
    if not os.path.isabs(script):
        logmsg("WARN: Trying to guess script relative path...")
        abs_script = os.path.abspath(script)
        if not os.path.exists(abs_script):
            logmsg("WARN: Script %s does not exist" % abs_script)
            abs_script = os.path.join(os.path.dirname(infile), script)
            if not os.path.exists(abs_script):
                logmsg("ERROR: Script %s does not exist" % abs_script)
                return False
    else:
        abs_script = script
    logmsg("Executing script %s for %s" % (abs_script, infile))
    # open IDA but at least does not display message boxes to the user.
    if ida_args:
        cmd = [ida_executable, "-A", "-S%s" % abs_script, "-L%s" % logfile] + ida_args + [idbfile]
    else:
        cmd = [ida_executable, "-A", "-S%s" % abs_script, "-L%s" % logfile, idbfile]
    if verbose:
        logmsg("%s" % " ".join(cmd))
    shell=True
    if os.name == "posix":
        shell=False
    # We pass 1 to the script so it can detect (if it wants) to Exit() the IDA
    # session upon completion. 1 is arbitrary. Just needs to be non-zero args
    d = dict(os.environ)
    d["DO_EXIT"] = "1"
    if not list_only:
        return subprocess.Popen(cmd, shell, env=d)
    else:
        return True

def delete_temporary_files(inputdir, list_only=False):
    """
    清理 IDB 的临时文件
    """

    for f in iglob_hidden("%s/**" % inputdir, recursive=True):
        if f.endswith(".id0") or f.endswith(".id1") or f.endswith(".id2") or \
           f.endswith(".nam") or f.endswith(".til") or f.endswith(".dmp"):
            logmsg("Deleting %s" % f)
            if not list_only:
                os.remove(f)

def delete_asm_files(inputdir, list_only=False):
    """
    清理 .asm 文件
    """

    for f in iglob_hidden("%s/**" % inputdir, recursive=True):
        if f.endswith(".asm"):
            logmsg("Deleting %s" % f)
            if not list_only:
                os.remove(f)

def do_dir(inputdir, filter, verbose, max_ida, do_file, ida_args=None, script=None, list_only=False):
    """
    处理输入目录的主函数

    do_file: analyse_file/open_file/exec_ida_python_script 中的一个
    """

    pids = []
    call_count = 0
    exec_count = 0
    for f in iglob_hidden("%s/**" % inputdir, recursive=True):
        if os.path.isdir(f):
            continue
        if f.endswith(".idb") or f.endswith(".i64") or \
           f.endswith(".log") or f.endswith(".asm") or \
           f.endswith(".til") or f.endswith(".id0") or \
           f.endswith(".id1") or f.endswith(".id2") or \
           f.endswith(".nam"):
            continue
        f_noext = os.path.splitext(f)[0]
        if filter:
            module_name = filter.split()[0]
            if module_name.endswith(".py"):
                module_name = module_name[:-3]
            module_name = path_to_module_string(module_name)
            m = __import__(module_name, fromlist=[''])
            res = m.main(f, filter)
            if res == None:
                continue
            infile, arch = res

            if arch == "auto":
                arch = detect_arch(f)
                if arch == None:
                    continue
            if arch == 32:
                ida_executable = IDA32
                idbfile = f_noext + ".idb"
            elif arch == 64:
                ida_executable = IDA64
                idbfile = f_noext + ".i64"
            else:
                logmsg("Invalid architecture returned by filter")
                sys.exit()
        else:
                logmsg("Must specify filter")
                sys.exit()

        logfile = f_noext + ".log"
        pid = do_file(ida_executable, f, logfile, idbfile, verbose, ida_args=ida_args, script=script, list_only=list_only)
        # we check if pid is a real PID or if it returned True (list only)
        if pid != False:
            call_count += 1
        if type(pid) != bool:
            exec_count += 1
            pids.append((pid, f))
        if type(pid) == bool:
            continue
        if max_ida == None or len(pids) < max_ida:
            continue

        # 等待所有的 IDA 实例运行完成
        while (len(pids) != 0):
            for p in pids:
                if p[0].poll() != None:
                    pids.remove(p)
                    if os.path.isfile(p[1] + ".id0"):
                        logmsg("ERROR running %s on %s" % (script, p[1]), debug=True)

            logmsg("Waiting on %d IDA instances" % len(pids), end='\r')
            sys.stdout.flush()
            time.sleep(2)
        logmsg("\nContinuing")

    # 等待所有剩余的 IDA 实例运行完成
    while (len(pids) != 0):
        for p in pids:
            if p[0].poll() != None:
                pids.remove(p)
                if os.path.isfile(p[1] + ".id0"):
                    logmsg("ERROR running %s on %s" % (script, p[1]), debug=True)

        logmsg("Waiting on remaining %d IDA instances" % len(pids), end='\r')
        sys.stdout.flush()
        time.sleep(5)
    if call_count == 0:
        logmsg("WARN: Didn't find any files to run script on")
    else:
        logmsg("Executed IDA %d/%d times" % (exec_count, call_count))

def hms_string(sec_elapsed):
    h = int(sec_elapsed / (60 * 60))
    m = int((sec_elapsed % (60 * 60)) / 60)
    s = sec_elapsed % 60.
    return "{}:{:>02}:{:>05.2f}".format(h, m, s)

if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument('--inputdir', dest='inputdir', default=None,
                        help='Input folder to search for files')
    parser.add_argument('--analyse', '--analyze', dest='analyse', default=False,
                        action='store_true', help='analyse all files \
                        i.e. create .idb for all of them')
    parser.add_argument('--open', dest='open', default=False, action='store_true',
                        help='open all files into IDA (debug only)')
    parser.add_argument('--ida-args', dest='ida_args', default=None,
                        help='Additional arguments to pass to IDA (e.g. -p<processor> -i<entry_point> -b<load_addr>)')
    parser.add_argument('--scripts', dest='scripts', nargs="+", default=None,
                        help='List of IDA Python scripts to execute in this order')
    parser.add_argument('--filter', dest='filter', default="filters/default.py",
                        help='External python script with optional arguments defining a filter \
                        for the names of the files to analyse. See filters/names.py for example')
    parser.add_argument('--cleanup', dest='cleanup', default=False,
                        action='store_true', help='Cleanup i.e. remove .asm files that we don\'t need')
    parser.add_argument('--temp-cleanup', dest='cleanup_temporary',
                        default=False, action='store_true', help='Cleanup \
                        temporary database files i.e. remove .id0, .id1, .id2, \
                        .nam, .dmp files if IDA Pro crashed and did not delete them')
    parser.add_argument('--verbose', dest='verbose', default=False, action='store_true',
                        help='be more verbose to debug script')
    parser.add_argument('--max-ida', dest='max_ida', default=10, type=int,
                        help='Maximum number of instances of IDA to run at a time (default: 10)')
    parser.add_argument('--list-only', dest='list_only', default=False, action="store_true",
                        help='List only what files would be handled without executing IDA')
    parser.add_argument('--version', dest='ida_version', default="7.5",
                        help='Override IDA version (e.g. "7.5"). This is used to find the path of IDA on Windows.')
    args = parser.parse_args()

    if not args.analyse and not args.cleanup_temporary and \
        not args.cleanup and args.scripts == None and args.open == None:
        logmsg("ERROR: You didn't specify an action. Don't know what to do")
        logmsg("ERROR: Try --analyse or --cleanup or --temp-cleanup or --scripts or --open")
        sys.exit(1)

    if args.list_only:
        logmsg("Simulating only...")

    ida_version = args.ida_version
    ida32_found = False
    try:
        IDA32 = os.environ["IDA32"]
        ida32_found = True
    except:
        if os.name == "posix":
            try:
                IDA32 = subprocess.check_output("which idaq", shell=True).rstrip(b'\n').decode('utf-8')
                ida32_found = True
            except subprocess.CalledProcessError:
                pass
            if not ida32_found:
                try:
                    IDA32 = subprocess.check_output("which ida", shell=True).rstrip(b'\n').decode('utf-8')
                    ida32_found = True
                except subprocess.CalledProcessError:
                    pass
        else:
            IDA32="C:\\Program Files\\IDA Pro " + ida_version + "\\ida.exe"
            ida32_found = True

    ida64_found = False
    try:
        IDA64 = os.environ["IDA64"]
        ida64_found = True
    except:
        if os.name == "posix":
            try:
                IDA64 = subprocess.check_output("which idaq64", shell=True).rstrip(b'\n').decode('utf-8')
                ida64_found = True
            except subprocess.CalledProcessError:
                pass
            if not ida64_found:
                try:
                    IDA64 = subprocess.check_output("which ida64", shell=True).rstrip(b'\n').decode('utf-8')
                    ida64_found = True
                except subprocess.CalledProcessError:
                    pass
        else:
            IDA64="C:\\Program Files\\IDA Pro " + ida_version + "\\ida64.exe"
            ida64_found = True

    if not ida32_found or not ida64_found:
        logmsg("You don't seem to have 32-bit and 64-bit ida installed? We can't find them.")
        sys.exit(1)

    if args.verbose:
        logmsg("IDA32 = %s" % IDA32)
        logmsg("IDA64 = %s" % IDA64)

    if not args.inputdir:
        logmsg("ERROR: You need to provide an input directory with --inputdir")
        sys.exit()

    if not os.path.exists(args.inputdir):
        logmsg("ERROR: The path you provided doesn't exist: %s" % args.inputdir)
        sys.exit()

    # NOTE: The order here is important. We do it this way so that you could do
    # clean the dir, create idbs, rename all the idbs, and then update a database all in one run

    if args.list_only and (not args.analyse and not args.scripts and not args.cleanup and not args.cleanup_temporary and args.open == None):
        logmsg("ERROR: You must use --cleanup, --analyse or --scripts with --list-only")
        sys.exit()

    start_time = time.time()

    ida_args = None
    if args.ida_args:
        # lstrip() to allow having a space as first character (to avoid Python to parse our IDA arguments)
        ida_args = args.ida_args.lstrip().split()

    if args.cleanup_temporary:
        logmsg("CLEANUP TEMP FILES")
        delete_temporary_files(args.inputdir, list_only=args.list_only)
    if args.cleanup:
        logmsg("CLEANUP ASM FILES")
        delete_asm_files(args.inputdir, list_only=args.list_only)

    if args.analyse:
        logmsg("ANALYSING FILES")
        do_dir(args.inputdir, args.filter, args.verbose, max_ida=args.max_ida,
               do_file=analyse_file, list_only=args.list_only, ida_args=ida_args)

    if args.scripts:
        logmsg("EXECUTE SCRIPTS")
        scripts = []
        for s in args.scripts:
            if not os.path.isabs(s):
                # Note: we will try to guess its relative path later in exec_ida_python_script()
                logmsg("WARN: %s to be executed in IDA Pro, is not an absolute path" % s)
            scripts.append(s)

        for script in scripts:
            do_dir(args.inputdir, args.filter, args.verbose, max_ida=args.max_ida,
                   do_file=exec_ida_python_script, script=script, list_only=args.list_only,
                   ida_args=ida_args)

    if args.open:
        logmsg("OPENING FILES")
        do_dir(args.inputdir, args.filter, args.verbose, max_ida=args.max_ida,
               do_file=open_file, list_only=args.list_only, ida_args=ida_args)
        sys.exit()

    end_time = time.time()
    logmsg("Took {} to execute this".format(hms_string(end_time - start_time)))

```

`firmeye/cli/names.py`:

```py
# -*- coding: utf-8 -*-
#
# Filter for arbitrary names to be used by idahunt.py command line:
# e.g. idahunt.py --filter "filters/names.py -n Download -e exe -a 32"
#      idahunt.py --filter "filters/names.py -l 64"

import argparse
import os
import re
import sys
import subprocess
import time

def logmsg(s, end=None, debug=True):
    if not debug:
        return
    if type(s) == str:
        if end != None:
            print("[names] " + s),
        else:
            print("[names] " + s)
    else:
        print(s)

def filter(f, name, extension, arch, length, verbose=True):
    if name and not name in os.path.basename(f):
        logmsg("Skipping non-matching name %s in %s" % (name, os.path.basename(f)))
        return None
    _, file_extension = os.path.splitext(f)
    if extension and not extension.startswith("."):
        extension = "." + extension
    if extension and file_extension != extension:
        logmsg("Skipping non-matching extension %s in %s" % (extension, os.path.basename(f)))
        return None
    if name and not name in os.path.basename(f):
        logmsg("Skipping non-matching name %s in %s" % (name, os.path.basename(f)))
        return None
    if length and len(os.path.basename(f)) != length:
        logmsg("Skipping non-matching name: len(%s) != %d" % (os.path.basename(f), length))
        return None

    if arch == "64":
        arch_ = 64
    elif arch == "32":
        arch_ = 32
    elif arch == "auto":
        arch_ = "auto"
    else:
        logmsg("Unknown architecture: %s. You need to specify it with -a" % arch)
        return None

    return f, arch_

def main(f, cmdline):
    sys.argv = cmdline.split()

    parser = argparse.ArgumentParser(prog=cmdline)
    parser.add_argument('-n', dest='name', default=None, help='pattern to include in the name')
    parser.add_argument('-e', dest='extension', default=None, help='Exact extension to match')
    parser.add_argument('-a', dest='arch', default=None, help='Assume architecture known by user')
    parser.add_argument('-l', dest='length', default=None, type=int, help='Name length \
                         to include (e.g. 64 for a SHA256 since it is 32 bytes stored in hex digits)')
    parser.add_argument('-v', dest='verbose', default=False, action='store_true'
                        , help='be more verbose to debug script')
    args = parser.parse_args()

    return filter(f, args.name, args.extension, args.arch, args.length, args.verbose)

```

`firmeye/config.py`:

```py
# -*- coding: utf-8 -*-

import os


THEME = "default"   # 配置主题 default/dark

DEBUG = True        # 配置 debug 模式

GHIDRA_PATH = 'E:\\ghidra_9.0.4'
GHIDRA_HEADLESS_PATH = os.path.join(GHIDRA_PATH, "support", "analyzeHeadless.bat")

FUNC_TAG = {
    'PRINTF': 0,
    'STRING': 1,
    'MEMORY': 2,
    'SCANF' : 3,
    'SYSTEM': 4,
}

SINK_FUNC = {
    'printf': {     # int printf(const char *format, ...);
        'tag': FUNC_TAG['PRINTF'],
        'args_rule': ['fmt', '...'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R0'],
            }
        ]
    },
    'sprintf': {     # int sprintf(char *str, const char *format, ...);
        'tag': FUNC_TAG['PRINTF'],
        'args_rule': ['str', 'fmt', '...'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R1'],
            },
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1', '...'],
            }
        ]
    },
    'snprintf': {     # int snprintf(char *str, size_t size, const char *format, ...);
        'tag': FUNC_TAG['PRINTF'],
        'args_rule': ['str', 'int', 'fmt', '...'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R2'],
            },
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1', 'R2', '...'],
            }
        ]
    },
    'fprintf': {     # int fprintf(FILE *stream, const char *format, ...);
        'tag': FUNC_TAG['PRINTF'],
        'args_rule': ['dword', 'fmt', '...'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R1'],
            }
        ]
    },
    'dprintf': {     # int dprintf(int fd, const char *format, ...);
        'tag': FUNC_TAG['PRINTF'],
        'args_rule': ['int', 'fmt', '...'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R1'],
            }
        ]
    },
    'vprintf': {     # int vprintf(const char *format, va_list ap);
        'tag': FUNC_TAG['PRINTF'],
        'args_rule': ['fmt', 'va_list'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R0'],
            }
        ]
    },
    'vfprintf': {     # int vfprintf(FILE *stream, const char *format, va_list ap);
        'tag': FUNC_TAG['PRINTF'],
        'args_rule': ['dword', 'fmt', 'va_list'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R1'],
            }
        ]
    },
    'vdprintf': {     # int vdprintf(int fd, const char *format, va_list ap);
        'tag': FUNC_TAG['PRINTF'],
        'args_rule': ['int', 'fmt', 'va_list'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R1'],
            }
        ]
    },
    'vsprintf': {     # int vsprintf(char *str, const char *format, va_list ap);
        'tag': FUNC_TAG['PRINTF'],
        'args_rule': ['str', 'fmt', 'va_list'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R1'],
            },
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1'],
            }
        ]
    },
    'vsnprintf': {     # int vsnprintf(char *str, size_t size, const char *format, va_list ap);
        'tag': FUNC_TAG['PRINTF'],
        'args_rule': ['str', 'int', 'fmt', 'va_list'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R2'],
            },
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1', 'R2'],
            }
        ]
    },

    'scanf': {     # int scanf(const char *format, ...);
        'tag': FUNC_TAG['SCANF'],
        'args_rule': ['fmt', '...'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R0'],
            }
        ]
    },
    'sscanf': {     # int sscanf(const char *str, const char *format, ...);
        'tag': FUNC_TAG['SCANF'],
        'args_rule': ['str', 'fmt', '...'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R1'],
            },
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1', '...'],
            }
        ]
    },
    'vscanf': {     # int vscanf(const char *format, va_list ap);
        'tag': FUNC_TAG['SCANF'],
        'args_rule': ['fmt', 'va_list'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R0'],
            }
        ]
    },
    'vsscanf': {     # int vsscanf(const char *str, const char *format, va_list ap);
        'tag': FUNC_TAG['SCANF'],
        'args_rule': ['str', 'fmt', 'va_list'],
        'vuln_rule': [
            {
                'vuln_type': 'format_string',
                'vuln_regs': ['R1'],
            },
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1'],
            }
        ]
    },

    'realpath': {     # char *realpath(const char *path, char *resolved_path);
        'tag': '',
        'args_rule': ['str', 'str'],
        'vuln_rule': [
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R0'],
            }
        ]
    },

    'strtrns': {    # char *strtrns (const char *str, const char *old, const char *new, char *result);
        'tag': FUNC_TAG['STRING'],
        'args_rule': ['str', 'str', 'str', 'str'],
        'vuln_rule': [
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R0'],
            }
        ]
    },
    'strecpy': {    # char *strecpy(char *output, const char *input, const char *exceptions);
        'tag': FUNC_TAG['STRING'],
        'args_rule': ['str', 'str', 'str'],
        'vuln_rule': [
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1'],
            }
        ]
    },
    'streadd': {    # char *streadd(char *output, const char *input, const char *exceptions);
        'tag': FUNC_TAG['STRING'],
        'args_rule': ['str', 'str', 'str'],
        'vuln_rule': [
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1'],
            }
        ]
    },
    'strncat': {    # char *strncat(char *dest, const char *src, size_t n);
        'tag': FUNC_TAG['STRING'],
        'args_rule': ['str', 'str', 'int'],
        'vuln_rule': [
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1', 'R2'],
            }
        ]
    },
    'strcat': {    # char *strcat(char *dest, const char *src);
        'tag': FUNC_TAG['STRING'],
        'args_rule': ['str', 'str'],
        'vuln_rule': [
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1'],
            }
        ]
    },
    'strncpy': {    # char *strncpy(char *dest, const char *src, size_t n);
        'tag': FUNC_TAG['STRING'],
        'args_rule': ['str', 'str', 'int'],
        'vuln_rule': [
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1', 'R2'],
            }
        ]
    },
    'strcpy': {    # char *strcpy(char *dest, const char *src);
        'tag': FUNC_TAG['STRING'],
        'args_rule': ['str', 'str'],
        'vuln_rule': [
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1'],
            }
        ]
    },

    'memcpy': {    # void *memcpy(void *dest, const void *src, size_t n);
        'tag': FUNC_TAG['MEMORY'],
        'args_rule': ['str', 'str', 'int'],
        'vuln_rule': [
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1', 'R2'],
            }
        ]
    },

    '__aeabi_memcpy': {    # void *__aeabi_memcpy(void *dest, const void *src, size_t n);
        'tag': FUNC_TAG['MEMORY'],
        'args_rule': ['str', 'str', 'int'],
        'vuln_rule': [
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R1', 'R2'],
            }
        ]
    },

    'popen': {    # FILE *popen(const char *command, const char *type);
        'tag': '',
        'args_rule': ['str', 'str'],
        'vuln_rule': [
            {
                'vuln_type': 'command_injection',
                'vuln_regs': ['R0'],
            }
        ]
    },

    'system': {    # int system(const char *command);
        'tag': FUNC_TAG['SYSTEM'],
        'args_rule': ['str'],
        'vuln_rule': [
            {
                'vuln_type': 'command_injection',
                'vuln_regs': ['R0'],
            }
        ]
    },

    'doSystemCmd': {    # int system(const char *command);
        'tag': FUNC_TAG['SYSTEM'],
        'args_rule': ['str'],
        'vuln_rule': [
            {
                'vuln_type': 'command_injection',
                'vuln_regs': ['R0'],
            }
        ]
    },

    'gets': {    # char *gets(char *s);
        'tag': '',
        'args_rule': ['str'],
        'vuln_rule': [
            {
                'vuln_type': 'stack_buffer_overflow',
                'vuln_regs': ['R0'],
            }
        ]
    },
}

# 当回溯过程中遇到其他函数对寄存器有影响，则按规则切换回溯对象。
SOURCE_FUNC = {
    'gets': {       # char *gets(char *s);
        'dest': 'R0',
        'src': 'None',
    },

    'scanf': {      # int scanf(const char *format, ...);
        'dest': 'R1',
        'src': 'None',
    },

    'strcat': {     # char *strcat(char *dest, const char *src)
        'dest': 'R0',
        'src': 'R1',
    },

    'strcpy': {     # char *strcpy(char *dest, const char *src);
        'dest': 'R0',
        'src': 'R1',
    },

    'memcpy': {     # void *memcpy(void *dest, const void *src, size_t n);
        'dest': 'R0',
        'src': 'R1',
    },

    '__aeabi_memcpy': { # void *__aeabi_memcpy(void *dest, const void *src, size_t n);
        'dest': 'R0',
        'src': 'R1',
    },
}

INST_LIST = {
    'load': [       # 加载存储指令
        'LDR', 'LDRB', 'LDRD',
        'LDRH', 'LDRHI', 'LDRHIB',
        'LDREQ', 'LDREQB', 'LDREQSB',
        'LDRNE', 'LDRNEB',
        'LDRLT', 'LDRLS', 'LDRLE',
        'LDRGT', 'LDRGE',
        'LDRSB', 'LDRSH',
        'LDRCC', 'LDRCS',
        'VLDR'
    ],
    'move': [       # 数据传送指令
        'MOV', 'MOVS', 'MOVCS', 'MOVCC', 'MOVEQ', 'MOVNE', 'MOVLT', 'MOVLS', 'MOVLE', 'MOVGT', 'MOVGE', 'MOVHI', 'MOVT', 'MOVW', 'MOVTGT', 'MOVTLE',
        'VMOV',
        'MVN',
        'VCVT.F64.F32',
        'REV',
        'CLZ'
    ],
    'arithmetic': [ # 运算指令
        'ADD', 'ADDS', 'ADDCS', 'ADDCC', 'ADDEQ', 'ADDNE', 'ADDLT', 'ADDLS', 'ADDLE', 'ADDGT', 'ADDGE', 'ADDHI', 'ADDW',
        'ADC',
        'SUB', 'SUBS', 'SUBGT', 'SUBCC', 'SUBCS', 'SUBLE', 'SUBLT', 'SUBLS', 'SUBEQ', 'SUBNE',
        'MUL', 'MULS',
        'MLA', 'MLAEQ', 'MLANE'
        'MLS',
        'SDIV',
        'UDIV',
        'RSB', 'RSBNE', 'RSBHI', 'RSBGT', 'RSBCS', 'RSBCC',
        'LSL', 'LSLS',
        'LSRS',
        'ASR', 'ASRS',
        'AND', 'ANDS',
        'ORR', 'ORRS', 'ORRLE',
        'EOR',
        'BIC',
        'UBFX',
        'UXTH', 'UXTB',
        'SXTB', 'SXTH'
    ],
    'load_multi': [ # 块数据传送指令
        'LDMFD', 'LDMEQFD', 'LDMEQIB', 'LDMDB', 'LDMIA', 'LDMIB', 'LDMLEFD'
    ],
    'other': [      # 其他指令
        'STR', 'STRB', 'STREQ', 'STREQB', 'STRNE', 'STRNEB', 'STRLE', 'STRLS', 'STRGT', 'STRH', 'STRHI', 'STRGE', 'STRGEH', 'STRLT',
        'CMP', 'CMPNE', 'CMPGT', 'CMPEQ', 'CMPLS', 'CMPCS',
        'CMN',
        'CBZ', 'CBNZ',
        'STMEA', 'STMFD',
        'PUSH', 'BLX', 'TST'
    ]
}

```

`firmeye/constants.py`:

```py
# -*- coding: utf-8 -*-

PLUGIN_NAME = "Firmeye"
PLUGIN_HOTKEY = "Ctrl+F1"
PLUGIN_COMMENT = "Firmeye: an auxiliary tool for iot vulnerability hunter."
PLUGIN_HELP = '''
#############################  FIRMEYE TOOLKITS ##############################
#                                                                            #
#               an auxiliary tool for iot vulnerability hunter               #
#                                                                            #
# ------------------------------- HOT KEAY --------------------------------- #
#                                                                            #
#    Ctrl+F1             show this help                                      #
#                                                                            #
# --------------------------- STATIC  ANALYZER ----------------------------- #
#                                                                            #
#    Ctrl+Shift+s        main menu                                           #
#                                                                            #
# --------------------------- DYNAMIC ANALYZER ----------------------------- #
#                                                                            #
#    Ctrl+Shift+d        enable/disable debug hook                           #
#                                                                            #
# --------------------------- CODE PATTERN --------------------------------- #
#                                                                            #
#    Ctrl+Shift+c        find code pattern                                   #
#                                                                            #
# --------------------------- REVERSE ASSISTANT ---------------------------- #
#                                                                            #
#    Ctrl+Shift+x        reverse assist tools                                #
#                                                                            #
# --------------------------- FUNCTIONAL TEST ------------------------------ #
#                                                                            #
#    Ctrl+Shift+q        functional test                                     #
#                                                                            #
##############################################################################
'''

AUTHOR = "Chao Yang"
XDBG_VERSION = "v0.1.1"
XDBG_IDA_DEP_VERSION = "IDA PRO 7.5, Python3"
BANNER_MSG = "Firmeye %s - %s" % (XDBG_VERSION, XDBG_IDA_DEP_VERSION)

```

`firmeye/helper.py`:

```py
# -*- coding: utf-8 -*-

import ida_name
import ida_segment
import ida_funcs
import ida_gdl
import ida_idaapi
import ida_ua
import ida_bytes
import idautils
import idc


def hexstr(num):
    """
    IDA内可双击跳转的地址形式
    """
    return format(num, '#010x')

def get_mnem(ea):
    """
    获取操作符并去除末尾的 ".W"
    """
    mnem = ida_ua.print_insn_mnem(ea).split('.')[0]
    return mnem

def is_func_call(ea):
    """
    判读是否是一个函数调用指令
    """

    op1 = idc.print_operand(ea, 0)
    for func_addr in idautils.Functions():
        func_name = ida_funcs.get_func_name(func_addr)
        if op1 == func_name:
            return True
        else:
            continue
    return False

def rename_func(ea, funcname):
    """
    函数名重命名（如有重名在末尾加数字区分）
    """

    currname = funcname
    count = 1
    if ea == None:
        print("Error: can't rename Nonetype to %s" % funcname)
        return False
    while not ida_name.set_name(ea, currname, ida_name.SN_CHECK):
        currname = "%s_%d" % (funcname, count)
        count += 1
        if count > 100:
            print("Error: rename_func looped too much for 0x%d -> %s" % (ea, funcname))
            return False
    return True

def unname_func(ea):
    """
    取消函数命名，退回sub_xxxx
    """

    if not ida_name.set_name(ea, "", ida_name.SN_CHECK):
        print("Error: unname_func: could not remove name for element")
        return False
    return True

def get_segments():
    """
    返回所有segment的名字列表（但其实是section）
    """

    seg_names = []
    for ea in idautils.Segments():
        seg = ida_segment.getseg(ea)
        seg_names.append(ida_segment.get_segm_name(seg))
    return seg_names

def name_to_addr(s):
    """
    返回任意名称的地址：function, label, global...
    """

    addr = ida_name.get_name_ea(ida_idaapi.BADADDR, s)
    if addr == ida_idaapi.BADADDR:
        print("[Error] name_to_addr: Failed to find '%s' symbol" % s)
        return None
    return addr

def addr_to_name(ea):
    """
    返回任意地址的名称
    """
    name = ida_name.get_name(ea, ida_name.GN_VISIBLE)
    if name == "":
        print("[Error] addr_to_name: Failed to find '0x%x' address" % ea)
        return ""
    return name

def get_call_args_arm(ea, count_max=10):
    """
    获得函数调用参数（当前仅支持4个参数）
    """

    args = {}

    mnem = ida_ua.ua_mnem(ea)
    if mnem != "BL" and mnem != "SVC" and mnem != "BLNE" and mnem != "BLHI" and mnem != "BLEQ":
        print("Error: not a BL or SVC or BLNE or BLHI or BLEQ instruction at 0x%x" % ea)
        return None

    arg_inst_arm_mov = ["MOV     R0,",
                        "MOV     R1,",
                        "MOV     R2,",
                        "MOV     R3,"]
    arg_inst_arm_adr = ["ADR     R0,",
                        "ADR     R1,",
                        "ADR     R2,",
                        "ADR     R3,"]
    arg_inst_arm_ldr = ["LDR     R0,",
                        "LDR     R1,",
                        "LDR     R2,",
                        "LDR     R3,"]
    arg_inst_arm_adr2 = ["ADREQ   R0,",
                         "ADREQ   R1,",
                         "ADDEQ   R2,",
                         "ADREQ   R3,"]
    arg_inst_arm_mov2 = ["MOVEQ   R0,",
                         "MOVEQ   R1,",
                         "MOVEQ   R2,",
                         "MOVEQ   R3,"]
    arg_inst_arm_adr3 = ["ADRNE   R0,",
                         "ADRNE   R1,",
                         "ADDNE   R2,",
                         "ADRNE   R3,"]

    ea = ida_bytes.prev_head(ea, 0)
    count = 0
    while count <= count_max:
        disasm_line = idc.generate_disasm_line(ea, 0)
        for i in range(len(arg_inst_arm_mov)):
            #print("'%s'" % arg_inst_arm_mov[i])
            # 假设最接近调用的指令是赋值指令，忽略其他情况（如碰到另一个MOV reg）
            inst_list = [arg_inst_arm_mov[i],
                         arg_inst_arm_mov2[i],
                         arg_inst_arm_adr[i],
                         arg_inst_arm_adr2[i],
                         arg_inst_arm_adr3[i]]
            if any(inst in disasm_line for inst in inst_list):
                if i not in args.keys():
                    args[i] = idc.get_operand_value(ea, 1)
                    print("Found argument %d: 0x%x" % (i, args[i]))
            elif arg_inst_arm_ldr[i] in disasm_line:
                if i not in args.keys():
                    addr = idc.get_operand_value(ea, 1)
                    args[i] = ida_bytes.get_wide_dword(addr)
                    print("Found argument %d: 0x%x" % (i, args[i]))
        ea = ida_bytes.prev_head(ea, 0)
        count += 1
    return args

def find_ret_block(ea):
    """
    寻找函数返回块，不支持多返回函数
    """

    func = ida_funcs.get_func(ea)
    f = ida_gdl.FlowChart(func)
    for block in f:
        if ida_gdl.is_ret_block(block.type):
            return block
    return None

def function_count_instructions(ea):
    """
    返回函数的指令数量
    """
    E = list(idautils.FuncItems(ea))
    return len(E)

```

`firmeye/hexraystool.py`:

```py
# -*- coding: utf-8 -*-
# https://github.com/patois/HexraysToolbox
# commit: 1ca5e93ed65d8dfa91cc25b8a42452113a1f0eb4

import ida_hexrays as hx
import ida_bytes
import idautils
import ida_kernwin
import ida_lines
import ida_funcs
import idc
import ida_idaapi

from firmeye.logger import FELogger

SCRIPT_NAME = "[toolbox]"

class query_result_t():
    def __init__(self, cfunc=None, i=None):
        if isinstance(cfunc, hx.cfuncptr_t):
            self.entry = cfunc.entry_ea
        elif isinstance(cfunc, int):
            self.entry = cfunc
        else:
            self.entry = BADADDR
        if isinstance(i, (hx.cexpr_t, hx.cinsn_t)):
            self.ea = i.ea if not isinstance(cfunc, hx.cfuncptr_t) else self.find_closest_address(cfunc, i)
            self.v = ida_lines.tag_remove(i.print1(None))
        elif isinstance(i, tuple):
            self.ea, self.v = i
        else:
            self.ea = ida_idaapi.BADADDR
            self.v = "<undefined>"

    def find_closest_address(self, cfunc, i):
        parent = i
        while parent:
            if parent and parent.ea != BADADDR:
                return parent.ea
            parent = cfunc.body.find_parent_of(parent)
        return BADADDR

    def __str__(self):
        return "[%x] %x: \"%s\"" % (self.entry, self.ea, self.v)


def find_item(ea, q, parents=False, flags=0):
    """在函数伪代码的 AST 中搜索 item

    ea: 函数内任意地址
    q: lambda/function: f(cfunc_t, citem_t) 返回布尔值
    parents: False -> 丢弃 cexpr_t 父节点
             True  -> 维护 citem_t 父节点

    return: query_result_t 对象列表
    """

    f = ida_funcs.get_func(ea)
    if f:
        cfunc = None
        hf = hx.hexrays_failure_t()
        try:
            cfunc = hx.decompile(f, hf, flags)
        except Exception as e:
            print("%s %x: unable to decompile: '%s'" % (SCRIPT_NAME, ea, hf))
            print("\t (%s)" % e)
            return list()

        if cfunc:
            return find_child_item(cfunc, cfunc.body, q, parents)
    return list()

def find_child_item(cfunc, i, q, parents=False):
    """find child item in cfunc_t starting at citem_t i

    cfunc: cfunc_t
    i: citem_t
    q: lambda/function: f(cfunc_t, citem_t) 返回布尔值

    return: query_result_t 对象列表
    """

    class citem_finder_t(hx.ctree_visitor_t):
        def __init__(self, cfunc, q, parents):
            hx.ctree_visitor_t.__init__(self,
                hx.CV_PARENTS if parents else hx.CV_FAST)

            self.cfunc = cfunc
            self.query = q
            self.found = list()
            return

        def process(self, i):
            if self.query(self.cfunc, i):
                self.found.append(query_result_t(self.cfunc, i))
            return 0

        def visit_insn(self, i):
            return self.process(i)

        def visit_expr(self, e):
            return self.process(e)

    if cfunc:
        itfinder = citem_finder_t(cfunc, q, parents)
        itfinder.apply_to(i, None)
        return itfinder.found
    return list()

def find_expr(ea, q, parents=False, flags=0):
    """在函数伪代码的 AST 中搜索表达式

    ea: 函数内任意地址
    q: lambda/function: f(cfunc_t, citem_t) 返回布尔值
    parents: False -> 丢弃 cexpr_t 父节点
             True  -> 维护 citem_t 父节点

    return: query_result_t 对象列表
    """

    f = ida_funcs.get_func(ea)
    if f:
        cfunc = None
        hf = hx.hexrays_failure_t()
        try:
            cfunc = hx.decompile(f, hf, flags)
        except Exception as e:
            print("%s %x: unable to decompile: '%s'" % (SCRIPT_NAME, ea, hf))
            print("\t (%s)" % e)
            return list()

        if cfunc:
            return find_child_expr(cfunc, cfunc.body, q, parents)
    return list()

def find_child_expr(cfunc, e, q, parents=False):
    """find child expression in cfunc_t starting at cexpr_t e

    cfunc: cfunc_t
    e: cexpr_t
    q: lambda/function: f(cfunc_t, citem_t) 返回布尔值

    return: query_result_t 对象列表
    """

    class expr_finder_t(hx.ctree_visitor_t):
        def __init__(self, cfunc, q, parents):
            hx.ctree_visitor_t.__init__(self,
                hx.CV_PARENTS if parents else hx.CV_FAST)

            self.cfunc = cfunc
            self.query = q
            self.found = list()
            return

        def visit_expr(self, e):
            if self.query(self.cfunc, e):
                self.found.append(query_result_t(self.cfunc, e))
            return 0

    if cfunc:
        expfinder = expr_finder_t(cfunc, q, parents)
        expfinder.apply_to_exprs(e, None)
        return expfinder.found
    return list()

def exec_query(q, ea_list, query_full, parents=False, flags=0):
    """在地址列表上执行 find_item 或 find_item

    q: lambda/function: f(cfunc_t, citem_t) 返回布尔值
    ea_list: 地址列表
    query_full: False -> 仅搜索 cexpr_t
                True  -> 搜索 citem_t（包括 cexpr_t 和 cinsn_t）

    return: query_result_t 对象列表
    """

    find_elem = find_item if query_full else find_expr
    result = list()
    for ea in ea_list:
        result += find_elem(ea, q, parents=parents, flags=flags)
    return result

def query_db(q, query_full=True, do_print=False):
    """在 IDB 上执行 query

    q: lambda/function: f(cfunc_t, citem_t) 返回布尔值
    query_full: False -> 仅搜索 cexpr_t
                True  -> 搜索 citem_t（包括 cexpr_t 和 cinsn_t）

    return: query_result_t 对象列表
    """

    return query(q, ea_list=idautils.Functions(), query_full=query_full, do_print=do_print)

def query(q, ea_list=None, query_full=True, do_print=False):
    """在地址列表上执行 exec_query，可打印结果

    q: lambda/function: f(cfunc_t, citem_t) 返回布尔值
    ea_list: 地址列表
    query_full: False -> 仅搜索 cexpr_t
                True  -> 搜索 citem_t（包括 cexpr_t 和 cinsn_t）

    return: query_result_t 对象列表
    """

    if not ea_list:
        ea_list = [ida_kernwin.get_screen_ea()]
    r = list()
    try:
        r = exec_query(q, ea_list, query_full)
        if do_print:
            print("<query> done! %d unique hits." % len(r))
            for e in r:
                print(e)
    except Exception as exc:
        print("<query> error:", exc)
    return r


class ic_t(ida_kernwin.Choose):
    """citem_t 选择器

    q: lambda/function: f(cfunc_t, citem_t) 返回布尔值或者 query_result_t 对象列表
    ea_list: 地址列表
    query_full: False -> 仅搜索 cexpr_t
                True  -> 搜索 citem_t（包括 cexpr_t 和 cinsn_t）
    """
    window_title = "Hexrays Toolbox"

    def __init__(self,
            q=None,
            ea_list=None,
            query_full=True,
            flags=ida_kernwin.CH_RESTORE | ida_kernwin.CH_QFLT,
            title=None,
            width=None,
            height=None,
            embedded=False,
            modal=False):

        _title = ""
        i = 0
        idx = ""
        pfx = ""
        exists = True
        while exists:
            idx = chr(ord('A')+i%26)
            _title = "%s-%s%s" % (ic_t.window_title, pfx, idx)
            if title:
                _title += ": %s" % title
            exists = (ida_kernwin.find_widget(_title) != None)
            i += 1
            pfx += "" if i % 26 else "A"

        ida_kernwin.Choose.__init__(self,
            _title,
            [ ["函数", 20 | ida_kernwin.CHCOL_FNAME],
              ["地址", 10 | ida_kernwin.CHCOL_EA],
              ["输出", 80 | ida_kernwin.CHCOL_PLAIN]],
            flags = flags,
            width = width,
            height = height,
            embedded = embedded)

        if ea_list is None:
            ea_list =[ida_kernwin.get_screen_ea()]
        if callable(q):
            self.items = exec_query(q, ea_list, query_full)
        elif isinstance(q, list):
            self.items = q
        else:
            self.items = list()
        self.Show()

    def OnClose(self):
        self.items = []

    def OnSelectLine(self, n):
        item_ea = self.items[n].ea
        func_ea = self.items[n].entry
        ea = func_ea if item_ea == BADADDR else item_ea
        ida_kernwin.jumpto(ea)

    def OnGetLine(self, n):
        return self._make_choser_entry(n)

    def OnGetSize(self):
        return len(self.items)

    def append(self, data):
        if not isinstance(data, query_result_t):
            return False
        self.items.append(data)
        self.Refresh()
        return True

    def set_data(self, data):
        self.items = data
        self.Refresh()

    def get_data(self):
        return self.items

    def _make_choser_entry(self, n):
        return ["%s" % idc.get_func_off_str(self.items[n].entry),
                "%016x" % self.items[n].ea if __EA64__ else "%08x" % self.items[n].ea,
                self.items[n].v]


class FECodePatternForm(ida_kernwin.Form):

    def __init__(self):
        ida_kernwin.Form.__init__(self, """STARTITEM 0
Reverse Assistant
TODO：
<##TODO:{btn_todo}>
""", {
    'btn_todo': ida_kernwin.Form.ButtonInput(self.btn_todo),
})

    def btn_todo(self, code=0):
        pass


class FECodePattern(ida_kernwin.action_handler_t):
    """
    在伪代码中做代码模式匹配
    """

    def __init__(self):
        ida_kernwin.action_handler_t.__init__(self)

    def show_menu(self):
        main = FECodePatternForm()
        main.Compile()
        main.Execute()

    @FELogger.reload
    def activate(self, ctx):
        self.show_menu()

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS


"""
def find_memcpy():
    "find calls to memcpy() where the 'n' argument is signed"

    query = lambda cf, e: (e.op is cot_call and
        e.x.op is cot_obj and
        'memcpy' in get_name(e.x.obj_ea) and
        len(e.a) == 3 and
        e.a[2].op is cot_var and
        cf.lvars[e.a[2].v.idx].tif.is_signed())

    return tb.exec_query(query, Functions(), False)

def find_sprintf():
    "find calls to sprintf() where the format string argument contains '%s'"

    func_name = 'sprintf'

    query = lambda cfunc, e: (e.op is cot_call and
        e.x.op is cot_obj and
        func_name in get_name(e.x.obj_ea) and
        len(e.a) >= 2 and
        e.a[1].op is cot_obj and
        is_strlit(get_flags(e.a[1].obj_ea)) and
        b'%s' in get_strlit_contents(e.a[1].obj_ea, -1, 0, STRCONV_ESCAPE))

    ea_malloc = get_name_ea_simple(func_name)
    ea_set = set([f.start_ea for f in [get_func(xref.frm) for xref in XrefsTo(ea_malloc, XREF_FAR)] if f])
    
    return tb.exec_query(query, ea_set, False)

def find_malloc():
    "calls to malloc() with a size argument that is anything but a variable or an immediate number."

    func_name = 'malloc'

    query = lambda cf, e: (e.op is cot_call and 
        e.x.op is cot_obj and
        get_name(e.x.obj_ea) == func_name and
        len(e.a) == 1 and
        e.a[0].op not in [cot_num, cot_var])

    ea_malloc = get_name_ea_simple(func_name)
    ea_set = set([f.start_ea for f in [get_func(xref.frm) for xref in XrefsTo(ea_malloc, XREF_FAR)] if f])
    
    return tb.exec_query(query, ea_set, False)
"""

```

`firmeye/idaxml.py`:

```py
#---------------------------------------------------------------------
# idaxml.py - IDA XML classes
#---------------------------------------------------------------------
"""
"""

import ida_auto
import ida_bytes
import ida_diskio
import ida_enum
import ida_fpro
import ida_frame
import ida_funcs
import ida_ida
import ida_idaapi
import ida_idp
import ida_hexrays
import ida_kernwin
import ida_lines
import ida_loader
import ida_moves
import ida_nalt
import ida_name
import ida_netnode
import ida_pro
import ida_segment
import ida_segregs
import ida_struct
import ida_typeinf
import ida_ua
import ida_xref
import idautils
import idc
import datetime
import os
import sys
import time
from xml.etree import cElementTree

DEBUG = False  # print debug statements

IDAXML_VERSION = "5.0.1"
BASELINE_IDA_VERSION = 700
BASELINE_STR = '7.00'
IDA_SDK_VERSION = ida_pro.IDA_SDK_VERSION
BADADDR = idc.BADADDR
BADNODE = ida_netnode.BADNODE
PLUGIN = True
LOADER = not PLUGIN
AUTO_WAIT = True


def is_ida_version_supported():
    '''
    Determines if IDA version is supported by this idaxml module.
    
    Returns:
        True if IDA version is supported, else False.
    '''
    supported = IDA_SDK_VERSION >= BASELINE_IDA_VERSION
    if not supported:
        idc.msg('\nThe IDA XML plugins and loader are not supported ' +
                'by this version of IDA.\n')
        idc.msg('Please use IDA ' + BASELINE_STR + ' or greater ' +
                'with this version of XML.\n')
    return supported


class Cancelled(Exception):
    pass


class FileError(Exception):
    pass


class MultipleAddressSpacesNotSupported(Exception):
    pass


class IdaXml:
    def __init__(self, arg):
        self.autorun = False if arg == 0 else True
        self.debug = DEBUG
        self.elements = {}
        self.counters = []
        self.tags = []
        self.xmlfile = 0
        self.options = None
    

    def cleanup(self):
        """
        Frees memory and closes message box and XML file at termination.
        """
        if self.options != None:
            self.options.Free()
        ida_kernwin.hide_wait_box()
        self.close_xmlfile()


    def close_xmlfile(self):
        """
        Closes the XML data file for the XML Exporter.
        """
        if self.xmlfile != 0:
            self.xmlfile.close()
            self.xmlfile = 0


    def dbg(self, message):
        """
        Outputs debug message if debug flag is enabled.
        
        Args:
            message: String containing the debug message.
        """
        if (self.debug == True):
            idc.msg(message)
        

    def display_summary(self, what):
        """
        Displays summary in IDA output window.
        """
        summary = ''
        total = 0
        for tag in self.tags:
            count = self.counters[self.elements[tag]]
            summary += "\n%-26s %8d" % (tag, count)
            total += count
        summary  = "\n--------------------------------------" + summary
        summary += "\n--------------------------------------"
        summary += ("\n%-26s %8d" % ("Total XML Elements:",total))
        idc.msg(summary)
        if self.autorun == False: # and self.plugin:
            frmt  = "TITLE XML " + what + " Successful!\n"
            frmt += "ICON INFO\n"
            frmt += "AUTOHIDE NONE\n"
            frmt += "HIDECANCEL\n"
            fileline = '\n\nFile: %s' % self.filename
            details = '\nSee output window for details...'
            ida_kernwin.info("%s" % (frmt + fileline + details))


    def display_version(self, what):
        """
        Displays XML version info in IDA output window.
        
        Args:
            what: String indicating Exporter, Importer, or Loader 
        """
        if os.path.isfile(os.path.join(ida_diskio.get_user_idadir(), 'python', 'idaxml.py')):
            f = os.path.join(ida_diskio.get_user_idadir(), 'python', 'idaxml.py')
        else:
            f = os.path.join(ida_diskio.idadir('python'), 'idaxml.py')
        ftime = time.localtime(os.path.getmtime(f))
        ts = time.strftime('%b %d %Y %H:%M:%S', ftime)
        version = "\nXML " + what + " v" + IDAXML_VERSION
        version += " : SDK " + str(IDA_SDK_VERSION)
        version += " : Python : "+ ts + '\n'
        idc.msg(version)
        
    
    def open_file(self, filename, mode):
        """
        Opens filename to specified mode.
        
        Args:
            filename: String representing absolute filepath.
            mode: String representing mode for open.
            
        Returns
            File handle.
        
        Exceptions:
            Displays a warning and raises FileError exception
            if open fails.
        """
        try:
            f = open(filename, mode)
            return f
        except:
            fmt = "TITLE ERROR!\n"
            fmt += "ICON ERROR\n"
            fmt += "AUTOHIDE NONE\n"
            fmt += "HIDECANCEL\n"
            fmt += "Error opening file" + filename + "!\n"
            idc.warning(fmt)
            raise FileError

    
    def update_counter(self, tag):
        """
        Updates the counter for the element tag.
        
        Args:
            tag: String representing element tag.
        """
        if tag in self.elements:
            self.counters[self.elements[tag]] += 1
        else:
            self.elements[tag] = len(self.elements)
            self.counters.append(1)
            self.tags.append(tag)
    

    def update_status(self, tag):
        """
        Displays the processing status in the IDA window.
        
        Args:
            tag: String representing XML element tag
        """
        status = 'Processing ' + tag
        idc.msg('\n%-35s' % status)
        ida_kernwin.hide_wait_box()
        ida_kernwin.show_wait_box(status)
    

class XmlExporter(IdaXml):
    """
    XML Exporter contains methods to export an IDA database as a
        XML PROGRAM document.
    """
    def __init__(self, arg):
        """
        Initializes the XmlExporter attributes
        Args:
            arg: Integer, non-zero value enables auto-run feature for
                IDA batch (no gui) processing mode. Default is 0.
        """
        IdaXml.__init__(self, arg)
        self.indent_level = 0
        self.seg_addr = False
        self.has_overlays = False
        self.hexrays = False
        
        # initialize class variables from database
        self.inf = ida_idaapi.get_inf_structure()
        self.min_ea = self.inf.min_ea
        self.max_ea = self.inf.max_ea
        self.cbsize = int((ida_idp.ph_get_cnbits()+7)/8)
        self.processor = str.upper(ida_idp.get_idp_name())
        self.batch = ida_kernwin.cvar.batch


    def export_xml(self):
        """
        Exports the IDA database to a XML PROGRAM document file.
        """
        #self.display_version('Exporter')
        self.check_and_load_decompiler()
        
        self.get_options()
    
        if (self.autorun == True):
            (self.filename, ext) = os.path.splitext(idc.get_idb_path())
            self.filename += ".xml"
        else:
            self.filename=ida_kernwin.ask_file(1, "*.xml",
                                         "Enter name of export xml file:")
            
        if self.filename == None or len(self.filename) == 0:
            raise Cancelled
        self.xmlfile = self.open_file(self.filename, "w")
        
        ida_kernwin.show_wait_box("Exporting XML <PROGRAM> document ....")
        idc.msg("\n------------------------------------------------" +
                   "-----------")
        idc.msg("\nExporting XML <PROGRAM> document ....")
        begin = time.process_time() 
        
        self.write_xml_declaration()
        self.export_program()
        
        # export database items based on options
        if (self.options.DataTypes.checked         == True or
            self.options.DataDefinitions.checked   == True or 
            self.options.Functions.checked         == True):
            self.export_datatypes()
        if (self.options.MemorySections.checked    == True or
            self.options.MemoryContent.checked     == True):
            self.export_memory_map()
        if (self.options.RegisterValues.checked    == True):
            self.export_register_values()   
        if (self.options.CodeBlocks.checked        == True):
            self.export_code()  
        if (self.options.DataDefinitions.checked   == True):
            self.export_data()  
        if (self.options.Comments.checked          == True):
            self.export_comments()
            self.export_bookmarks()     
        if (self.options.EntryPoints.checked       == True):
            self.export_program_entry_points()  
        if (self.options.Symbols.checked           == True):
            self.export_symbol_table()  
        if (self.options.Functions.checked         == True):
            self.export_functions() 
        if (self.options.MemoryReferences.checked  == True or 
            self.options.StackReferences.checked   == True or
            self.options.Manual.checked            == True or
            self.options.DataTypes.checked         == True):
            self.export_markup()    
        self.end_element(PROGRAM)
        
        idc.msg('\n%35s' % 'Total ')
        self.display_cpu_time(begin)
        ida_kernwin.hide_wait_box()  
        self.display_summary('Export')
        idc.msg('\nDatabase exported to: ' + self.filename + '\n')
        

    # TODO: Test decompiler comments in batch and gui modes
    def check_and_load_decompiler(self):
        """
        Checks for the presence of a decompiler plugin for the database.
        
        Note: The decompiler must be loaded by the XML Exporter plugin
            if it is running in batch mode. IDA will load the decompiler
            plugin automatically if not in batch mode.
        
        Note: There was no support for decompiler plugins in IDAPython until
            IDA 6.6, so skip if this is an older version.
        
        Note: Currently the 4 decompiler plugins for the  x86, x64,
            ARM32, and ARM64 are supported.
        """
        if self.batch == 0:
            self.hexrays = ida_hexrays.init_hexrays_plugin()
            return
        plugin = ''
        if self.processor == 'PC':
            if self.inf.is_64bit():
                plugin = "hexx64"
            elif self.inf.is_32bit():
                plugin = 'hexrays'
        elif self.processor == 'ARM':
            if self.inf.is_64bit():
                plugin = "hexarm64"
            elif self.inf.is_32bit():
                plugin = "hexarm"
        if len(plugin) > 0:
            try:
                ida_loader.load_plugin(plugin)
                self.hexrays = ida_hexrays.init_hexrays_plugin()
            except:
                return
    

    def check_char(self, ch):
        """
        Replaces a special XML character with an entity string.
        
        Args:
            ch: String containing the character to check.
            
        Returns:
            String containing either the character or the entity
            substition string.
        """
        x = ch
        if not isinstance(ch, int):
            x = ord(ch)
        if ((x < 0x20) and (x != 0x09 and
             x != 0x0A and x != 0x0D)): return ''
        elif ch == '&' :  return '&amp;'
        elif ch == '<' :  return "&lt;"
        elif ch == '>' :  return "&gt;"
        elif ch == '\'' : return "&apos;"
        elif ch == '"' :  return "&quot;"
        elif ch == '\x7F': return ''
        elif x > 0x7F: return '&#x' + format(x,"x") + ";"
        return chr(x)
    

    def check_for_entities(self, text):
        """
        Checks all characters in a string for special XML characters.
        
        Args:
            text: String to check for special XML characters.
            
        Returns:
            String containing original string with substitutions for
                any special XML characters.
        """
        new = ''
        for c in text:
            new += self.check_char(c)
        return new
    

    def check_if_seg_contents(self, seg):
        """
        Determines if any address in a segment contains a value.
        
        Args:
            seg: IDA segment object
            
        Returns:
            True if any address in a segment contains a value.
            False if no address in a segment contains a value.
        """
        for addr in idautils.Heads(seg.start_ea, seg.end_ea):
            if idc.has_value(idc.get_full_flags(addr)) == True:
                return True
        return False


    def check_stack_frame(self, sframe):
        """
        Determines if stack frame contains any parameters or local variables.
        
        Args:
            sframe: IDA stack frame for a function.
            
        Returns:
            True if stack frame has parameters or local variables.
            False if stack frame has no parameters or local variables.
        """
        n = sframe.memqty
        for i in range(n):
            member = sframe.get_member(i)
            if member == None:
                continue
            mname = ida_struct.get_member_name(member.id)
            if mname != None and len(mname) > 0: 
                if mname != " s" and mname != " r":
                    return True
        return False


    def close_binfile(self):
        """
        Closes the binary data file for the XML Exporter.
        """
        if self.binfile != 0:
            self.binfile.close()
            self.binfile = 0


    def close_tag(self, has_contents=False):
        """
        Closes the start tag for an XML element.
        
        Args:
            has_contents: Boolean indicating if the element has
            sub-elements or text.
        """
        if has_contents:
            self.write_to_xmlfile(">")
            self.indent_level += 1
        else:
            self.write_to_xmlfile(" />")

    
    def display_cpu_time(self, start):
        """
        Displays the elapsed CPU time since the start time.
        
        Args:
            start: Floating-point value representing start time in seconds.
        """
        idc.msg('CPU time: %6.4f' % (time.process_time()  - start))
            

    def end_element(self, tag, newline=True):
        """
        Writes the element end tag to the XML file.
        
        Args:
            tag: String containing the element name.
            newline: Boolean indicating if end tag should go on new line.
        """
        self.indent_level -= 1
        if newline:
            start = '\n' + ("    " * self.indent_level)
        else:
            start = ''
        self.write_to_xmlfile(start  + "</" + tag + ">")


    '''
    # BIT_MASK not currently supported for ENUM
    def export_bitmask(self, eid, mask):
        """
        Exports an enum bitmask member as BIT_MASK element.
        
        Args:
            eid: Integer representing the IDA enum id
            mask: Integer representing the IDA enum mask value
        """
        name = idc.get_bmask_name(eid, mask)
        if name == None:
            return
        self.start_element(BIT_MASK)
        self.write_attribute(NAME, name)
        self.write_numeric_attribute(VALUE, mask)
        regcmt = idc.get_bmask_cmt(eid, mask, False)
        rptcmt = idc.get_bmask_cmt(eid, mask, True)
        has_comment =  regcmt != None or rptcmt != None
        self.close_tag(has_comment)
        if regcmt != None and len(regcmt) > 0:
            self.export_regular_cmt(regcmt)
        if rptcmt != None and len(rptcmt) > 0:
            self.export_repeatable_cmt(rptcmt)
        if (has_comment):
            self.end_element(BIT_MASK)
    '''


    def export_bookmarks(self):
        """
        Exports marked location descriptions as BOOKMARK elements.
        """
        found = False
        timer = time.process_time() 
        for slot in range(0,1025):
            address = idc.get_bookmark(slot)
            description = idc.get_bookmark_desc(slot)
            if address == BADADDR:
                continue
            if description == None:
                continue
            if found == False:
                found = True
                self.update_status(BOOKMARKS)
                self.start_element(BOOKMARKS, True)
            self.start_element(BOOKMARK)
            self.write_address_attribute(ADDRESS, address)
            self.write_attribute(DESCRIPTION, description)
            self.close_tag()
        if found:
            self.end_element(BOOKMARKS)
            self.display_cpu_time(timer)


    def export_c_comments(self):
        """
        Exports block and end-of-line comments entered in the decompiler
        interface.
        """
        if self.hexrays == False:
            return
        functions = idautils.Functions()
        if functions == None:
            return
        for addr in functions:
            try:
                if ida_segment.is_spec_ea(addr):
                    continue
                ccmts = ida_hexrays.restore_user_cmts(addr)
                if ccmts == None:
                    continue
                p = ida_hexrays.user_cmts_begin(ccmts)
                while p != ida_hexrays.user_cmts_end(ccmts):
                    cmk = ida_hexrays.user_cmts_first(p)
                    cmv = ida_hexrays.user_cmts_second(p)
                    if cmk.itp < (ida_hexrays.ITP_COLON+1):
                        self.export_comment(cmk.ea, "end-of-line", cmv.c_str())
                    else:
                        self.export_comment(cmk.ea, "pre", cmv.c_str())
                    p=ida_hexrays.user_cmts_next(p)
                ida_hexrays.user_cmts_free(ccmts)
            except:
                continue


    def export_code(self):
        """
        Exports the address ranges of code sequences as CODE_BLOCK(s)
        with START and END address attributes.
        """
        addr = self.min_ea
        if idc.is_code(idc.get_full_flags(addr)) == False:
            addr = ida_bytes.next_that(addr, self.max_ea, idc.is_code)
        if (addr == BADADDR):
            return
        self.update_status(CODE)
        timer = time.process_time() 
        data = ida_bytes.next_that(addr, self.max_ea, idc.is_data)
        unknown = ida_bytes.next_unknown(addr, self.max_ea)
        self.start_element(CODE, True)
        while (addr != BADADDR):
            start = addr
            end = min(data, unknown)
            if (end == BADADDR):
                if (ida_segment.getseg(start).end_ea < self.max_ea):
                    codeend = ida_segment.getseg(start).end_ea - 1
                    addr = ida_segment.getseg(idc.next_addr(codeend)).start_ea
                    if idc.is_code(idc.get_full_flags(addr)) == False:
                        addr = ida_bytes.next_that(addr, self.max_ea,
                                               idc.is_code)
                else:
                    codeend = self.max_ea - 1
                    addr = BADADDR
            else:
                if (ida_segment.getseg(start).end_ea < end):
                    codeend = ida_segment.getseg(start).end_ea - 1
                    addr = ida_segment.getseg(idc.next_addr(codeend)).start_ea
                    if idc.is_code(ida_bytes.get_full_flags(addr)) == False:
                        addr = ida_bytes.next_that(addr, self.max_ea,
                                               idc.is_code)
                else:
                    codeend = idc.get_item_end(ida_bytes.prev_that(end,
                                                start, idc.is_code)) - 1
                    addr = ida_bytes.next_that(end, self.max_ea, idc.is_code)
                if (data < addr):
                    data = ida_bytes.next_that(addr, self.max_ea,
                                           idc.is_data)
                if (unknown < addr):
                    unknown = ida_bytes.next_unknown(addr, self.max_ea)
            self.start_element(CODE_BLOCK)
            self.write_address_attribute(START, start)
            self.write_address_attribute(END, codeend)
            self.close_tag()
        self.end_element(CODE)
        self.display_cpu_time(timer)


    def export_comment(self, addr, cmt_type, cmt):
        """
        Exports a <COMMENT> element with ADDRESS and TYPE attributes.
        The comment is exported as the element text (parsed character data).
        
        Args:
            addr: Integers representing address of comment.
            cmt_type: String indicating the comment type.
            cmt: String containing the comment.
        """
        self.start_element(COMMENT)
        self.write_address_attribute(ADDRESS, addr)
        self.write_attribute(TYPE, cmt_type)
        self.close_tag(True)
        # tag_remove seems to be losing last character
        # work around is to add a space
        cmt_text = ida_lines.tag_remove(cmt + ' ')
        self.write_text(cmt_text)
        self.end_element(COMMENT, False)


    def export_comments(self):
        """
        Exports all comments in the IDA database as <COMMENT> elements.
        """
        addr = self.min_ea
        if ida_bytes.has_cmt(idc.get_full_flags(addr)) == False:
            addr = ida_bytes.next_that(addr, self.max_ea, ida_bytes.has_cmt)
        if (addr == BADADDR):
            return
        self.update_status(COMMENTS)
        timer = time.process_time() 
        self.start_element(COMMENTS, True)
        while (addr != BADADDR):
            cmt = idc.get_cmt(addr, False)
            if (cmt != None):
                self.export_comment(addr, "end-of-line", cmt)
            cmt = idc.get_cmt(addr, True)
            if (cmt != None):
                self.export_comment(addr, "repeatable", cmt)
            addr = ida_bytes.next_that(addr, self.max_ea, ida_bytes.has_cmt)
        addr = self.min_ea
        if ida_bytes.has_extra_cmts(idc.get_full_flags(addr)) == False:
            addr = ida_bytes.next_that(addr, self.max_ea, ida_bytes.has_extra_cmts)
        while (addr != BADADDR):
            extra = idc.get_extra_cmt(addr, idc.E_PREV)
            if (extra != None):
                self.export_extra_comment(addr, "pre", idc.E_PREV)
            extra = idc.get_extra_cmt(addr, idc.E_NEXT)
            if (extra != None):
                self.export_extra_comment(addr, "post", idc.E_NEXT)
            addr = ida_bytes.next_that(addr, self.max_ea, ida_bytes.has_extra_cmts)
        self.export_c_comments()
        self.end_element(COMMENTS)
        self.display_cpu_time(timer)


    def export_data(self):
        """
        Exports the data items in the database as <DEFINED_DATA> elements.
        """
        addr = self.min_ea
        if idc.is_data(idc.get_full_flags(addr)) == False:
            addr = ida_bytes.next_that(addr, self.max_ea, idc.is_data)
        if (addr == BADADDR):
            return
        timer = time.process_time() 
        self.update_status(DATA)
        self.start_element(DATA, True)
        while (addr != BADADDR):
            f = idc.get_full_flags(addr)
            if ida_bytes.is_align(f) == True:
                addr = ida_bytes.next_that(addr, self.max_ea, idc.is_data)
                continue
            dtype = self.get_datatype(addr)
            size = idc.get_item_size(addr)
            ti = ida_nalt.opinfo_t()
            msize = ida_bytes.get_data_elsize(addr, f, ti)
            if ida_bytes.is_struct(f) == True:
                s = idc.get_struc_id(dtype)
                msize = idc.get_struc_size(s)
                if msize == 0:
                    msize = 1
            if idc.is_strlit(f) == False and size != msize:
                dtype = "%s[%d]" % (dtype, int(size/msize))
            self.start_element(DEFINED_DATA)
            self.write_address_attribute(ADDRESS, addr)
            self.write_attribute(DATATYPE, dtype)
            self.write_numeric_attribute(SIZE, size*self.cbsize)
            #TODO consider using GetTrueNameEx and Demangle
            demangled = ida_name.get_demangled_name(addr,
                            DEMANGLED_TYPEINFO, self.inf.demnames, idc.GN_STRICT)
            outbuf = ''
            # TODO: How to handle print_type for data mangled names?
            #outbuf = idaapi.print_type(addr, False)
            if demangled == "'string'":
                demangled == None
            has_typeinfo = ((demangled != None and len(demangled) > 0) or
                            (outbuf != None and len(outbuf) > 0))
            #TODO export_data: add DISPLAY_SETTINGS
            self.close_tag(has_typeinfo)
            if has_typeinfo == True:
                if demangled != None and len(demangled) > 0:
                    self.export_typeinfo_cmt(demangled)
                elif len(outbuf) > 0:
                    self.export_typeinfo_cmt(outbuf)
                self.end_element(DEFINED_DATA)
            addr = ida_bytes.next_that(addr, self.max_ea, idc.is_data)
        self.end_element(DATA)
        self.display_cpu_time(timer)
        

    def export_datatypes(self):
        """
        Exports the structures and enums in IDA database.
        """
        # skip if no structures/unions to export
        if idc.get_struc_qty() == 0: return
        self.update_status(DATATYPES)
        timer = time.process_time() 
        self.start_element(DATATYPES, True)
        self.export_structures()
        self.export_enums()
        self.end_element(DATATYPES)
        self.display_cpu_time(timer)


    def export_enum_member(self, cid, bf, mask, radix, signness):
        """
        Exports a member of an enum.
        Args:
            cid: Integer representing id of enum member
            bf: Boolean indicates if a bitfield
            mask: Integer representing bitmask if bitfield
            radix: Integer representing numeric display format
            signness: Boolean indicating if signed value 
        """
        cname = ida_enum.get_enum_member_name(cid)
        if cname == None or len(cname) == 0:
            return
        regcmt = ida_enum.get_enum_member_cmt(cid, False)
        rptcmt = ida_enum.get_enum_member_cmt(cid, True)
        has_comment =  regcmt != None or rptcmt != None
        self.start_element(ENUM_ENTRY)
        self.write_attribute(NAME, cname)
        value = ida_enum.get_enum_member_value(cid)
        self.write_numeric_attribute(VALUE, value, radix, signness)
        # BIT_MASK attribute not currently supported for ENUM_ENTRY
        #if bf == True:
        #    self.write_numeric_attribute(BIT_MASK, mask)
        self.close_tag(has_comment)
        if regcmt != None and len(regcmt) > 0:
            self.export_regular_cmt(regcmt)
        if rptcmt != None and len(rptcmt) > 0:
            self.export_repeatable_cmt(rptcmt)
        if (has_comment):
            self.end_element(ENUM_ENTRY)


    def export_enum_members(self, eid, bf, eflags):
        """
        Exports the members of an enum.
        This function can only be called by IDA versions newer than 6.3 
        
        Args:
            eid: Integer representing id of enum
            bf: Boolean indicates if a bitfield
            eflags: Integer representing the enum flags
        """
        mask=0xFFFFFFFF
        if bf == True:
            mask = idc.get_first_bmask(eid)
        first = True
        for n in range(idc.get_enum_size(eid)):
            if (first == True):
                value = ida_enum.get_first_enum_member(eid, mask)
                first = False
            else:
                value = ida_enum.get_next_enum_member(eid, value, mask)
            (cid, serial) = ida_enum.get_first_serial_enum_member(eid, value, mask)
            main_cid = cid
            while cid != BADNODE:
                self.export_enum_member(cid, bf, mask,
                                   ida_bytes.get_radix(eflags, 0),
                                   self.is_signed_data(eflags))
                last_value = ida_enum.get_last_enum_member(eid, mask)
                if value == last_value:
                    # ENUM BIT_MASK exporting not currently supported
                    #self.export_bitmask(eid, mask)
                    mask = idc.get_next_bmask(eid, mask)
                    first = True
                (cid, serial) = ida_enum.get_next_serial_enum_member(serial, main_cid)


    def export_enum_reference(self, addr, op):
        """
        Exports the enum reference for an operand at an address.
        
        Args:
            addr: Integer representing the instruction address.
            op: Integer representing the operand index (0-based)
        """
        (eid, serial) = ida_bytes.get_enum_id(addr, op)
        insn = ida_ua.insn_t()
        ida_ua.decode_insn(insn, addr)
        value = insn.ops[op].value
        cid = BADNODE
        last = idc.get_last_bmask(eid)
        if idc.is_bf(eid) == True:
            last = idc.get_last_bmask(eid)
            mask = idc.get_first_bmask(eid)
            while  cid == BADNODE:
                cid = ida_enum.get_enum_member(eid, (value & mask), 0, mask)
                if cid != BADNODE or mask == last:
                    break
                mask = idc.get_next_bmask(eid, mask)
        else:
            cid = ida_enum.get_enum_member(eid, value, 0, last)
        if cid == BADNODE:
            return
        self.start_element(EQUATE_REFERENCE)
        self.write_address_attribute(ADDRESS, addr)
        self.write_numeric_attribute(OPERAND_INDEX, op, 10)
        self.write_numeric_attribute(VALUE, ida_enum.get_enum_member_value(cid))
        cname = ida_enum.get_enum_member_name(cid)
        if cname != None and len(cname) > 0:
            self.write_attribute(NAME, cname)
        if idc.is_bf(eid) == True:
            self.write_numeric_attribute("BIT_MASK", mask);
        self.close_tag()
        

    def export_enum_references(self, addr):
        """
        Finds and exports enum references at an address.
        
        Args:
            addr: Integer representing the instruction address.
        """
        f = idc.get_full_flags(addr)
        for op in range(2):
            if ida_bytes.is_enum(f, op) == True:
                self.export_enum_reference(addr, op)
                

    def export_enums(self):
        """
        Exports enumerations.
        """
        num_enums = idc.get_enum_qty()
        if (num_enums == 0):
            return
        for i in range(num_enums):
            self.start_element(ENUM)
            eid = idc.getn_enum(i)
            ename = idc.get_enum_name(eid)
            if (ename == None or len(ename) == 0):
                continue
            self.write_attribute(NAME, ename)
            ewidth = idc.get_enum_width(eid)
            if ewidth != 0 and ewidth <= 7:
                self.write_numeric_attribute(SIZE, 1 << (ewidth-1), 10)
            eflags = idc.get_enum_flag(eid)
            bf = idc.is_bf(eid)
            # BIT_FIELD attribute not supported for ENUM export
            #if bf == True:
            #    self.write_attribute(BIT_FIELD, "yes")
            regcmt = idc.get_enum_cmt(eid, False)
            rptcmt = idc.get_enum_cmt(eid, True)
            has_children = ((idc.get_enum_size(eid) > 0) or
                            (regcmt != None) or (rptcmt != None) or
                            (ida_bytes.get_radix(eflags, 0) != 16) or
                            (self.is_signed_data(eflags) == True))
            self.close_tag(has_children)
            if (ida_bytes.get_radix(eflags, 0) != 16 or
                self.is_signed_data(eflags) == True):
                self.start_element(DISPLAY_SETTINGS)
                if ida_bytes.get_radix(eflags, 0) != 16:
                    self.write_attribute(FORMAT, self.get_format(eflags))
                if self.is_signed_data(eflags) == True:
                    self.write_attribute(SIGNED, "yes")
                self.close_tag()
            if regcmt != None:
                self.export_regular_cmt(regcmt)
            if rptcmt != None:
                self.export_repeatable_cmt(rptcmt)
            self.export_enum_members(eid, bf, eflags)
            if (has_children):
                self.end_element(ENUM)


    def export_extra_comment(self, addr, cmt_type, extra):
        """
        Exports pre- and post- comments for an address.
        
        Args:
            addr: Integer representing the instruction address.
            cmt_type: String indicating comment type
            extra: Integer representing extra comment index
        """
        cmt = ''
        nextline = idc.get_extra_cmt(addr, extra)
        while (nextline != None):
            # workaround for tag_remove bug is to add space
            cmt += ida_lines.tag_remove(nextline + ' ')
            extra += 1
            nextline = idc.get_extra_cmt(addr, extra)
            if (nextline != None):
                cmt += '\n' 
        self.export_comment(addr, cmt_type, cmt)


    def export_functions(self):
        """
        Exports information about all functions. 
        """
        functions = idautils.Functions()
        if functions == None:
            return
        self.update_status(FUNCTIONS)
        timer = time.process_time() 
        self.start_element(FUNCTIONS, True)
        for addr in functions:
            function = ida_funcs.get_func(addr)
            if ida_segment.is_spec_ea(function.start_ea) == True:
                continue
            self.start_element(FUNCTION)
            self.write_address_attribute(ENTRY_POINT, function.start_ea)
            if ida_bytes.has_user_name(idc.get_full_flags(addr)) == True:
                name = self.get_symbol_name(addr)
                if name != None and len(name) > 0:
                    self.write_attribute(NAME, name)
            if function.flags & idc.FUNC_LIB != 0:
                self.write_attribute(LIBRARY_FUNCTION, "y")
            self.close_tag(True)
            fchunks = idautils.Chunks(addr)
            for (startEA, endEA) in fchunks:
                self.start_element(ADDRESS_RANGE)
                self.write_address_attribute(START, startEA)
                self.write_address_attribute(END, endEA-1)
                self.close_tag()
            regcmt = ida_funcs.get_func_cmt(function, False)
            if regcmt != None:
                self.export_regular_cmt(regcmt)
            rptcmt = ida_funcs.get_func_cmt(function, True)
            if rptcmt != None:
                self.export_repeatable_cmt(rptcmt)
            demangled = ida_name.get_demangled_name(addr,
                                            DEMANGLED_TYPEINFO,
                                            self.inf.demnames, True)
            if demangled != None and demangled == "'string'":
                demangled = None
            outbuf = ''
            # TODO: How to handle print_type for function typeinfo cmts
            #outbuf = idaapi.print_type(addr, False)
            has_typeinfo = (demangled != None or (outbuf != None and
                            len(outbuf) > 0))
            if demangled != None:
                self.export_typeinfo_cmt(demangled)
            elif has_typeinfo == True:
                self.export_typeinfo_cmt(outbuf[:-1])
            self.export_stack_frame(function)
            self.end_element(FUNCTION)
        self.end_element(FUNCTIONS)
        self.display_cpu_time(timer)


    def export_manual_instruction(self, addr):
        """
        Exports user-entered "manual instruction" at an address.
        
        Args:
            addr: Integer representing instruction address.
        """
        text = idc.get_manual_insn(addr)
        if text == None or len(text) == 0:
            return
        self.start_element(MANUAL_INSTRUCTION)
        self.write_address_attribute(ADDRESS, addr)
        self.close_tag(True)
        self.write_text(text)
        self.end_element(MANUAL_INSTRUCTION, False)
        

    def export_manual_operand(self, addr):
        """
        Exports user-entered "manual operands" at an address.
        
        Args:
            addr: Integer representing instruction address.
        """
        for op in range(ida_ida.UA_MAXOP):
            if ida_bytes.is_forced_operand(addr, op) == True:
                text = idc.get_forced_operand(addr, op)
                if text != None and len(text) > 0:
                    self.start_element(MANUAL_OPERAND)
                    self.write_address_attribute(ADDRESS, addr)
                    self.write_numeric_attribute(OPERAND_INDEX, op, 10)
                    self.close_tag(True)
                    self.write_text(text)
                    self.end_element(MANUAL_OPERAND, False)


    def export_markup(self):
        """
        Exports markup for instructions and data items including references
        and manual instructions and operands.
        """
        self.update_status(MARKUP)
        timer = time.process_time()
        self.start_element(MARKUP, True)
        addr = self.min_ea
        while addr != BADADDR:
            f = idc.get_full_flags(addr)
            if self.options.MemoryReferences.checked == True:
                if ida_bytes.has_xref(f) == True:
                    self.export_user_memory_reference(addr)
                if ida_bytes.is_off(f, ida_bytes.OPND_ALL) == True:
                    self.export_memory_references(addr)
            if (self.options.Functions.checked == True and
                    self.options.StackReferences.checked == True and
                    ida_bytes.is_stkvar(f, ida_bytes.OPND_ALL) == True):
                self.export_stack_reference(addr)
            if (self.options.DataTypes.checked == True and
                    ida_bytes.is_enum(f, ida_bytes.OPND_ALL) == True):
                self.export_enum_references(addr)
            if self.options.Manual.checked == True:
                # TODO: Ask about OPND_ALL and retrieving additional manual operands
                #if ida_bytes.is_forced_operand(addr, ida_bytes.OPND_ALL) == True:
                if (ida_bytes.is_forced_operand(addr, 0) == True or
                        ida_bytes.is_forced_operand(addr, 1) == True):
                    self.export_manual_operand(addr)
                if ida_bytes.is_manual_insn(addr) == True:
                    self.export_manual_instruction(addr)
            addr = idc.next_head(addr, self.max_ea)
        self.end_element(MARKUP)
        self.display_cpu_time(timer)


    def export_members(self, s):
        """
        Exports the members of a structure or union.
        
        Args:
            s: IDA structure/union instance
        """
        nmembers = s.memqty
        for n in range(nmembers):
            m = s.get_member(n)
            offset = m.soff
            if s.is_union() == True:
                offset = 0
            self.start_element(MEMBER)
            self.write_numeric_attribute(OFFSET, offset)
            mname = ida_struct.get_member_name(m.id)
            if len(mname) > 0:
                self.write_attribute(NAME, mname)
            dtype = self.get_member_type(m)
            if ida_struct.is_varmember(m) == True:
                msize = 0
                size  = 0
            else:
                mtibuf = ida_nalt.opinfo_t()
                mti = ida_struct.retrieve_member_info(mtibuf, m)
                #if IDA_SDK_VERSION < 640:
                #    msize = idaapi.get_type_size0(None, dtype)
                #    if msize == None or msize == 0:
                #        msize = ida_struct.get_member_size(m)
                #else:
                size = ida_struct.get_member_size(m)
                #msize = idaapi.get_data_type_size(m.flag, mtibuf)
                # TODO: How to handle get_date_type_size for structure members
                msize = size
                if size < msize: size = msize
            if (size != msize):
                arraytype = self.get_member_type(m)
                dtype = "%s[%d]" % (arraytype, int(size/msize))
            self.write_attribute(DATATYPE, dtype)
            self.write_numeric_attribute(SIZE, size*self.cbsize)
            regcmt = ida_struct.get_member_cmt(m.id, False)
            rptcmt = ida_struct.get_member_cmt(m.id, True)
            hascmt = regcmt != None or rptcmt != None
            self.close_tag(hascmt)
            if (hascmt):
                if regcmt != None:
                    self.export_regular_cmt(regcmt)
                if rptcmt != None:
                    self.export_repeatable_cmt(rptcmt)
                self.end_element(MEMBER)


    def export_memory_contents(self, binfilename, binfile, start, end):
        """
        Exports the binary memory contents in the database.
        
        A MEMORY_CONTENTS element is generated for each contiguous address
        range where each address in the range contains a value.
        The binary values are store in a separate file (not the XML file),
        and the MEMORY_CONTENTS element identifies the file and the
        offset in the file where the address range is located.
        Args:
            binfilename: String containing the absolute filepath
            binfile: IDA file instance for binary file
            start: Integer representing the starting address
            end: Integer representing the ending address
        """
        length = 0
        startaddr = start
        for addr in range(start, end):
            # reset start address when length == 0
            if (length == 0):
                startaddr = addr
            has_val = ida_bytes.has_value(idc.get_full_flags(addr))
            if has_val == True:
                length += self.cbsize
            next_address = idc.next_addr(addr)
            if ((has_val == False) or (next_address != addr+1) or
                    (next_address == end)):
                if length > 0:
                    offset = binfile.tell()
                    ida_loader.base2file(binfile.get_fp(), offset, startaddr,
                                     startaddr+length)
                    self.start_element(MEMORY_CONTENTS)
                    self.write_address_attribute(START_ADDR, startaddr)
                    self.write_attribute(FILE_NAME, binfilename)
                    self.write_numeric_attribute(FILE_OFFSET, offset)
                    self.write_numeric_attribute(LENGTH, length)
                    self.close_tag(False)
                    length=0


    def export_memory_map(self):
        """
        Exports information about all memory blocks in the database.
        
        A MEMORY_SECTION is generated for each block (segment). If the
        memory block is initialized (has values), the contents are exported
        using the MEMORY_CONTENTS element.
        """
        nsegs = ida_segment.get_segm_qty()
        if (nsegs == 0):
            return
        self.update_status(MEMORY_MAP)
        timer = time.process_time();
        binfilename = ''
        if (self.options.MemoryContent.checked == True):
            (binfilename, ext) = os.path.splitext(self.filename)
            binfilename += ".bytes"
            self.binfile = ida_fpro.qfile_t()
            self.binfile.open(binfilename,'wb');
        self.start_element(MEMORY_MAP, True)
        for i in range(nsegs):
            self.export_memory_section(ida_segment.getnseg(i), binfilename)
        self.end_element(MEMORY_MAP)
        if (self.options.MemoryContent.checked == True):
            self.close_binfile()
        self.display_cpu_time(timer)


    def export_memory_reference(self, addr, op):
        """
        Exports the memory reference for operand at the address.
        
        Args:
            addr: Integer representing the instruction address.
            op: Integer representing the operand index (0-based)
        """
        f = idc.get_full_flags(addr)
        ri = ida_nalt.refinfo_t()
        if ida_nalt.get_refinfo(ri, addr, op) == 1: 
            if ri.target != BADADDR:
                target = ri.target
            elif idc.is_code(f) == True:
                insn = ida_ua.insn_t()
                ida_ua.decode_insn(insn, addr)
                target = (insn.ops[op].value - ri.tdelta + ri.base) & ((1 << 64) - 1)
            elif idc.is_data(f) == True:
                target = (self.get_data_value(addr) - ri.tdelta + ri.base) & ((1 << 64) - 1)
            else:
                return
        else:
            return
        if ida_bytes.is_mapped(target) == False:
            return
        self.start_element(MEMORY_REFERENCE)
        self.write_address_attribute(ADDRESS, addr)
        self.write_numeric_attribute(OPERAND_INDEX, op, 10)
        self.write_address_attribute(TO_ADDRESS, target)
        self.write_attribute(PRIMARY, "y")
        self.close_tag()
        

    def export_memory_references(self, addr):
        """
        Exports the memory references for any operands at the address.
        
        Args:
            addr: Integer representing the instruction address.
        """
        f = idc.get_full_flags(addr)
        for op in range(ida_ida.UA_MAXOP):
            if ida_bytes.is_off(f, op) == True and (idc.is_data(f) == True or
                    (idc.is_code(f) == True and
                    self.is_imm_op(addr, op) == True)):
                self.export_memory_reference(addr, op)
    

    def export_memory_section(self, seg, binfilename):
        """
        Exports segment information as a MEMORY_SECTIONS element.
        
        Args:
            seg: IDA segment instance
            binfilename: String containing absolute filepath for binary file.
        """
        segname = ida_segment.get_segm_name(seg)
        self.start_element(MEMORY_SECTION)
        self.write_attribute(NAME, segname)
        self.write_address_attribute(START_ADDR, seg.start_ea)
        length = (seg.end_ea - seg.start_ea)*self.cbsize
        self.write_numeric_attribute(LENGTH, length)
        perms = ""
        if (seg.perm != 0):
            if (seg.perm & ida_segment.SEGPERM_READ  != 0):
                perms += 'r'
            if (seg.perm & ida_segment.SEGPERM_WRITE != 0):
                perms += 'w' 
            if (seg.perm & ida_segment.SEGPERM_EXEC  != 0):
                perms += 'x'
            if (len(perms) > 0):
                self.write_attribute(PERMISSIONS, perms)
        has_contents = (self.options.MemoryContent.checked == True and
                       self.check_if_seg_contents(seg) == True)
        self.close_tag(has_contents)
        if (has_contents == True):
            self.export_memory_contents(os.path.basename(binfilename),
                                      self.binfile, seg.start_ea, seg.end_ea)
            self.end_element(MEMORY_SECTION)


    def export_program(self):
        """
        Exports basic information about the program as the PROGRAM,
        INFO_SOURCE, PROCESSOR, and COMPILER elements.
        """
        # output the PROGRAM element
        self.update_status(PROGRAM);
        timer = time.process_time()
        self.start_element(PROGRAM)
        self.write_attribute(NAME, idc.get_root_filename())
        self.write_attribute(EXE_PATH, idc.get_input_file_path())
        etype = ida_loader.get_file_type_name()
        if (len(etype) > 0):
            self.write_attribute(EXE_FORMAT, etype)
        # check for presence of INPUT_MD5 netnode
        md5 = ida_netnode.netnode(INPUT_MD5)
        if md5 == BADNODE:
            input_md5 = idc.retrieve_input_file_md5()
        else:
            input_md5 = md5.supval(ida_nalt.RIDX_MD5)
        if input_md5 != None:
            self.write_attribute(INPUT_MD5,input_md5)
        self.close_tag(True)
    
        # output the INFO_SOURCE element
        self.start_element(INFO_SOURCE)
        tool  = 'IDA-Pro ' + ida_kernwin.get_kernel_version()
        tool += ' XML plugin v' + IDAXML_VERSION + ' (Python) SDK ' + str(IDA_SDK_VERSION)
        self.write_attribute(TOOL, tool)
        user = os.getenv("USERNAME", "UNKNOWN")
        if (user == "UNKNOWN"):
            user = os.getenv("USER", "UNKNOWN")
        self.write_attribute(USER, user)
        self.write_attribute(FILE, idc.get_idb_path())
        ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
        self.write_attribute(TIMESTAMP, ts)
        self.close_tag()
    
        # output the PROCESSOR element
        self.start_element(PROCESSOR)
        self.write_attribute(NAME, self.inf.procname)
        if self.inf.is_be() == True:
            byte_order ="big"
        else:
            byte_order ="little"
        self.write_attribute(ENDIAN, byte_order)
        self.seg_addr = False
        bitness = 1
        model_warning = False
        nsegs = ida_segment.get_segm_qty()
        if (nsegs > 0):
            bitness = ida_segment.getnseg(0).bitness
            for i in range(1,nsegs):
                seg = ida_segment.getnseg(i)
                if (seg.bitness != bitness):
                    model_warning = True
                if (seg.bitness > bitness):
                    bitness = seg.bitness
        addr_model = "32-bit"
        if (bitness == 0):
            addr_model = "16-bit"
        elif (bitness == 2):
            addr_model = "64-bit"
        self.write_attribute(ADDRESS_MODEL, addr_model)
        self.close_tag()
        if (model_warning):
            idc.msg("WARNING: Segments do not have same " +
                       "addressing model!\n")
        if (ida_idp.ph.id == ida_idp.PLFM_386 and bitness == 0):
            self.seg_addr = True
        # find any overlayed memory before processing addressable items
        self.find_overlay_memory()
    
        # output compiler info
        self.start_element(COMPILER)
        self.write_attribute(NAME, ida_typeinf.get_compiler_name(self.inf.cc.id))
        self.close_tag()
        self.display_cpu_time(timer)


    def export_program_entry_points(self):
        """
        Exports entry points for the program.
        """
        nepts = idc.get_entry_qty()
        if (nepts  == 0):
            return
        self.update_status(PROGRAM_ENTRY_POINTS)
        timer = time.process_time()
        self.start_element(PROGRAM_ENTRY_POINTS, True)
        for i in range(nepts):
            self.start_element(PROGRAM_ENTRY_POINT)
            addr = idc.get_entry(idc.get_entry_ordinal(i))
            self.write_address_attribute(ADDRESS, addr)
            self.close_tag()
        self.end_element(PROGRAM_ENTRY_POINTS)
        self.display_cpu_time(timer)


    def export_register_values(self):
        """
        Exports segment register value ranges.
        """
        first = ida_idp.ph_get_reg_first_sreg()
        last  = ida_idp.ph_get_reg_last_sreg() + 1
        has_segregareas = False
        for j in range(first, last):
            nsegregareas = ida_segregs.get_sreg_ranges_qty(j)
            if nsegregareas != 0:
                has_segregareas = True
                break;
        if has_segregareas == False:
            return
        self.update_status(REGISTER_VALUES)
        timer = time.process_time();
        self.start_element(REGISTER_VALUES, True)
        sr = ida_segregs.sreg_range_t()
        for j in range(first, last):
            nsegregareas = ida_segregs.get_sreg_ranges_qty(j)
            if nsegregareas == 0:
                continue
            for i in range(nsegregareas):
                success = ida_segregs.getn_sreg_range(sr, j, i)
                if success == False:
                    continue
                value = sr.val
                if value == idc.BADSEL:
                    continue
                regname = ida_idp.ph.regnames[j]
                if regname == None:
                    continue
                if regname.lower() == "cs":
                    continue
                if (ida_idp.ph.id == ida_idp.PLFM_TMS and
                    regname.lower() == "ds"):
                    continue
                self.start_element(REGISTER_VALUE_RANGE)
                self.write_attribute(REGISTER, ida_idp.ph.regnames[j])
                self.write_numeric_attribute(VALUE, value)
                self.write_address_attribute(START_ADDRESS, sr.start_ea)
                length = (sr.end_ea - sr.start_ea) * self.cbsize
                self.write_numeric_attribute(LENGTH, length)
                self.close_tag()
        self.end_element(REGISTER_VALUES)
        self.display_cpu_time(timer)


    def export_regular_cmt(self, cmt):
        """
        Exports the regular comment for an item.
        
        Args:
            cmt: String containing the regular comment.
        """
        self.write_comment_element(REGULAR_CMT, cmt)
    

    def export_repeatable_cmt(self, cmt):
        """
        Exports the repeatable comment for an item.
        
        Args:
            cmt: String containing the repeatable comment.
        """
        self.write_comment_element(REPEATABLE_CMT, cmt)
    

    def export_stack_frame(self, function):
        """
        Export information about a function stack frame including
        variables allocated on the stack.
        
        Args:
            function: IDA function instance
        """
        sframe = ida_struct.get_struc(function.frame)
        if sframe == None or sframe.memqty <= 0:
            return
        self.start_element(STACK_FRAME)
        self.write_numeric_attribute(LOCAL_VAR_SIZE, function.frsize)
        self.write_numeric_attribute(REGISTER_SAVE_SIZE, function.frregs)
        retsize = ida_frame.get_frame_retsize(function)
        self.write_numeric_attribute(RETURN_ADDR_SIZE, retsize)
        self.write_numeric_attribute(BYTES_PURGED, function.argsize)
        has_stack_vars = self.check_stack_frame(sframe)
        self.close_tag(has_stack_vars)
        if has_stack_vars == True:
            self.export_stack_vars(function, sframe)
            self.end_element(STACK_FRAME)


    def export_stack_reference(self, addr):
        """
        Exports references to stack variables at the address.
        
        Args:
            addr: Integer containing instruction address.
        """
        f = idc.get_full_flags(addr)
        for op in range(ida_ida.UA_MAXOP):
            if idc.is_code(f) == True and ida_bytes.is_stkvar(f, op) == True:
                insn = ida_ua.insn_t()
                ida_ua.decode_insn(insn, addr)
                opnd = insn.ops[op]
                # TODO:How to handle opnd.type for stack references
                optype = opnd.type
                if optype == idc.o_void:
                    continue
                # TODO:How to handle op_t_get_addr for stack references
                SV = ida_frame.get_stkvar(insn, opnd, opnd.value)
                if SV == None:
                    continue
                (sv, actval) = SV
                function = ida_funcs.get_func(addr)
                self.start_element(STACK_REFERENCE)
                self.write_address_attribute(ADDRESS, addr)
                self.write_numeric_attribute(OPERAND_INDEX, op, 10)
                offset = opnd.addr
                spoff = offset - function.frregs
                if offset > 0x7FFFFFFF:
                    offset -= 0x100000000
                if spoff > 0x7FFFFFFF:
                    spoff  -= 0x100000000
                self.write_numeric_attribute(STACK_PTR_OFFSET, spoff,
                                             16, True)
                if (function.flags & idc.FUNC_FRAME) != 0:
                    self.write_numeric_attribute(FRAME_PTR_OFFSET,
                                                offset, 16, True)
                self.close_tag()


    def export_stack_vars(self, function, sframe):
        """
        Exports the stack variables (parameters and locals) in a stack frame.
        
        Args:
            function: IDA function instance.
            sframe: IDA stack frame instance.
        """
        for i in range(sframe.memqty):
            member = sframe.get_member(i)
            if member == None:
                continue
            mname = ida_struct.get_member_name(member.id)
            if mname == None or len(mname) < 0:
                continue
            if mname == " s" or mname == " r":
                continue
            spoff = member.soff - function.frsize - function.frregs
            froff = member.soff - function.frsize
            self.start_element(STACK_VAR)
            self.write_numeric_attribute(STACK_PTR_OFFSET, spoff, 16, True)
            if function.flags & idc.FUNC_FRAME != 0:
                self.write_numeric_attribute(FRAME_PTR_OFFSET, froff, 16, True)
            pre = mname[0:4]
            if pre != "var_" and pre != "arg_":
                self.write_attribute(NAME, mname)
            f = member.flag
            size = ida_struct.get_member_size(member)
            mtype = self.get_member_type(member)
            msize = size
            if idc.is_struct(f) == True:
                msize = idc.get_struc_size(ida_struct.get_struc_id(mtype))
            elif idc.is_strlit(f) == False:
                mtibuf = ida_nalt.opinfo_t()
                mti = ida_struct.retrieve_member_info(mtibuf, member)
                # TODO: How to handle get_data_type_size (for stack vars)
                #msize = idaapi.get_data_type_size(f, mtibuf)
            if size < msize: size = msize
            if (idc.is_strlit(f) == False and ida_bytes.is_align(f) == False
                and size != msize):
                mtype = "%s[%d]" % (mtype, int(size/msize))
            self.write_attribute(DATATYPE, mtype)
            self.write_numeric_attribute(SIZE, size*self.cbsize)
            regcmt = ida_struct.get_member_cmt(member.id, False)
            rptcmt = ida_struct.get_member_cmt(member.id, True)
            if regcmt != None:
                regcmt  = ida_lines.tag_remove(regcmt + " ", 0)
            if rptcmt != None:
                rptrcmt = ida_lines.tag_remove(rptcmt + " ", 0)
            has_regcmt = regcmt != None and len(regcmt) > 0
            has_rptcmt = rptcmt != None and len(rptcmt) > 0
            has_content = has_regcmt or has_rptcmt
            self.close_tag(has_content)
            if has_content == True:
                if has_regcmt == True:
                    self.export_regular_cmt(regcmt)
                if has_rptcmt == True:
                    self.export_repeatable_cmt(rptcmt)
                self.end_element(STACK_VAR)


    def export_structures(self):
        """
        Exports information about all structures and unions.
        """
        structs = idautils.Structs()
        for struct in structs:
            (idx, sid, sname) = struct
            s = ida_struct.get_struc(sid)
            stype = STRUCTURE
            if s.is_union() == True:
                stype = UNION
            self.start_element(stype)
            self.write_attribute(NAME, sname)
            size = idc.get_struc_size(sid)*self.cbsize
            self.write_numeric_attribute(SIZE, size)
            if s.is_varstr() == True:
                self.write_attribute(VARIABLE_LENGTH, "y")
            regcmt = idc.get_struc_cmt(sid, False)
            rptcmt = idc.get_struc_cmt(sid, True)
            has_contents = regcmt != None or rptcmt != None or s.memqty > 0
            self.close_tag(has_contents)
            if (has_contents):
                if regcmt != None:
                    self.export_regular_cmt(regcmt)
                if rptcmt != None:
                    self.export_repeatable_cmt(rptcmt)
                if s.memqty > 0:
                    self.export_members(s)
                self.end_element(stype)
    

    def export_symbol(self, addr, name, stype=""):
        """
        Exports name for an address as a SYMBOL element. If the name is a
        demangled name, add the mangled name as the MANGLED attribute.
        
        Args:
            addr: Integer representing the symbol address.
            name: String containing the symbol name.
            stype: String indicating symbol type (global or local)
        """
        self.start_element(SYMBOL)
        self.write_address_attribute(ADDRESS, addr)
        self.write_attribute(NAME, name)
        self.write_attribute(TYPE, stype)
        mangled = idc.get_name(addr, idc.GN_STRICT)
        if name != None and mangled != name:
            self.write_attribute("MANGLED", mangled)
        self.close_tag()
        

    def export_symbol_table(self):
        """
        Exports user-defined and non-default names as SYMBOL elements.
        """
        addr = self.min_ea
        if ida_bytes.has_any_name(idc.get_full_flags(addr)) == False:
            addr = ida_bytes.next_that(addr, self.max_ea, ida_bytes.has_any_name)
        if addr == BADADDR:
            return
        self.update_status(SYMBOL_TABLE)
        self.start_element(SYMBOL_TABLE, True)
        timer = time.process_time()
        while addr != BADADDR:
            # only export meaningful names (user and auto)
            f = idc.get_full_flags(addr)
            if (ida_bytes.has_user_name(f) == True or
                ida_bytes.has_auto_name(f) == True):
                # check for global name
                name = self.get_symbol_name(addr)
                if name != None and len(name) > 0:
                    self.export_symbol(addr, name)
                # check for local name
                if ida_nalt.has_lname(addr):
                    name = idc.get_name(addr, idc.GN_LOCAL)
                    if name != None and len(name) > 0:
                        self.export_symbol(addr, name, 'local')
            # get next address with any name
            addr = ida_bytes.next_that(addr, self.max_ea,
                                   ida_bytes.has_any_name)
        self.end_element(SYMBOL_TABLE)
        self.display_cpu_time(timer)
        

    def export_typeinfo_cmt(self, cmt):
        """
        Exports comment containing type information for data and functions.
        
        Args:
            cmt: String containing type info.
        """
        # older versions of IDAPython returned a '\n' at end of cmt
        if(len(cmt) > 0):
            while cmt[-1] == '\n':
                cmt = cmt[:-1]
        
        self.write_comment_element(TYPEINFO_CMT, cmt)
        

    def export_user_memory_reference(self, addr):
        """
        Exports a user-specified memory reference at the address.
        
        Args:
            addr: Integer representing the instruction address.
        """
        for xref in idautils.XrefsTo(addr, ida_xref.XREF_FAR):
            if xref.user == 1:
                self.start_element(MEMORY_REFERENCE)
                self.write_address_attribute(ADDRESS, xref.frm)
                self.write_address_attribute(TO_ADDRESS, xref.to)
                self.write_attribute(USER_DEFINED, "y")
                self.close_tag()


    def find_overlay_memory(self):
        """
        Determines if any memory blocks (segments) are overlays.
        
        A segment is an overlay if it translates to the same logical
        address as another segment. This is rare, but may occur, for
        example when a processor has a small logical address space
        (i.e. a 16-bit address is limited to 64K) and multiple physical
        segments are mapped into the same logical segment.
        """
        self.overlay = dict()
        self.has_overlays = False;
        nsegs = ida_segment.get_segm_qty()
        if nsegs == 0:
            return
        s = ida_segment.getnseg(0)
        start = self.translate_address(s.start_ea)
        self.overlay[start] = False
        for i in range(1, nsegs):
            s = ida_segment.getnseg(i)
            space = self.get_space_name(s.start_ea)
            saddr = self.translate_address(s.start_ea)
            eaddr = self.translate_address(s.end_ea-1)
            is_overlay = False
            for j in range(i):
                s2 = ida_segment.getnseg(j)
                space2 = self.get_space_name(s2.start_ea)
                if space == space2:
                    start = self.translate_address(s2.start_ea)
                    end   = self.translate_address(s2.end_ea - 1)
                    if ((saddr >= start and saddr <= end) or 
                        (eaddr >= start and eaddr <= end)):
                        is_overlay = True
                        self.has_overlays = True
                        break
            self.overlay[saddr] = is_overlay


    def get_address_string(self, addr):
        """
        Returns a string representing the address.
        
        The representation is typically a hex string of the address,
        but may include a segment or space name prefixe based on the
        processor or architecture.
        
        Args:
            addr: Integer representing a program address.
        """
        temp = "0x%X" % (addr - ida_segment.get_segm_base(ida_segment.getseg(addr)))
        space = self.get_space_name(addr)
        if space != None:
            temp = "%s:%04X" % (space,
                            addr - ida_segment.get_segm_base(ida_segment.getseg(addr)))
        else:
            if (ida_idp.ph_get_id() == ida_idp.PLFM_386 and
                ida_segment.getseg(addr).bitness == 0):
                base = ida_segment.get_segm_para(ida_segment.getseg(addr))
                temp = "%04X:%04X" % (base, addr - (base << 4))
        if ida_idp.ph_get_id() == ida_idp.PLFM_C166:
            temp = "0x%X" % addr
        if self.has_overlays == True and self.is_overlay(addr) == True:
            oname = ida_segment.get_segm_name(ida_segment.getseg(addr))
            if len(oname) > 0:
                temp = oname + "::" + temp
        return temp


    def get_data_value(self, addr):
        """
        Returns the data item value at an address based on its size.
        
        Args:
            addr: Integer representing a program address.
        """
        size = idc.get_item_size(addr)*self.cbsize
        if size == 1:   return ida_bytes.get_byte(addr)
        if size == 2:   return ida_bytes.get_16bit(addr)
        if size == 4:   return ida_bytes.get_32bit(addr)
        if size == 8:   return ida_bytes.get_64bit(addr)
        return 0
    

    def get_datatype(self, addr):
        """
        Returns the datatype at an address.
        
        The type could be a basic type (byte, word, dword, etc.),
        a structure, an array, a pointer, or a string type.
        
        Args:
            addr: Integer representing a program address.
        """
        f = idc.get_full_flags(addr)
        t = self.get_type(f)
        if ida_bytes.is_struct(f) == True:
            opndbuf = ida_nalt.opinfo_t()
            opnd = ida_bytes.get_opinfo(opndbuf, addr, 0, f)
            return idc.get_struc_name(opnd.tid)
        if idc.is_strlit(f) == True:
            str_type = idc.get_str_type(addr)
            #print ida_bytes.print_strlit_type(str_type)
            if str_type == ida_nalt.STRTYPE_TERMCHR:   return "string"
            if str_type == ida_nalt.STRTYPE_PASCAL:    return "string1"
            if str_type == ida_nalt.STRTYPE_LEN2:      return "string2"
            if str_type == ida_nalt.STRTYPE_LEN4:      return "string4"
            if str_type == ida_nalt.STRTYPE_C_16:   return "unicode"
            if str_type == ida_nalt.STRTYPE_C_16:     return "unicode2"
            if str_type == ida_nalt.STRTYPE_C_32:     return "unicode4"
            return "string"
        if ida_bytes.is_off0(f) == True: return "pointer"
        return t


    def get_format(self, flags):
        """
        Returns the display format of a data item based on its flags.
        
        Args:
            flags: Integer representing IDA item flags
            
        Returns:
            String representing IDA display format.
        """
        if ida_bytes.is_char0(flags): return "char"
        radix = ida_bytes.get_radix(flags, 0)
        if radix == 2:  return "binary"
        if radix == 8:  return "octal"
        if radix == 10: return "decimal"
        return "hex" # default
    

    def get_member_type(self, m):
        """
        Returns the datatype of a structure member.
        
        Args:
            m: IDA member instance.
            
        Returns:
            String representing member datatype.
        """
        f = m.flag
        t = self.get_type(f)
        if ida_bytes.is_off0(f) == True:
            t = "pointer"
        if ida_bytes.is_struct(f) == False:
            return t
        s = ida_struct.get_sptr(m)
        if (s == None):
            return t
        sname = idc.get_struc_name(s.id)
        if (sname == None):
            return t
        return sname


    def get_options(self):
        """
        Displays the options menu and retrieves the option settings. 
        """
        fmt =  "HELP\n"
        fmt += "XML plugin (Python)\n"
        fmt += "IDA SDK: "+ str(IDA_SDK_VERSION) + "\n"
        fmt += "\n"
        fmt += "The XML interface provides a dump of the IDA-Pro database as "
        fmt += "a XML \"PROGRAM\" document. The XML PROGRAM document contains "
        fmt += "information from the idb file in a readable text format, and "
        fmt += "can be viewed with a text editor or web browser.\n\n"
        fmt += "ENDHELP\n"
        fmt += "Export as XML PROGRAM document...."
        fmt += "\n <##Options##Memory Sections:{MemorySections}>"
        fmt += "\n <Memory Content:{MemoryContent}>"
        fmt += "\n <Segment Register Value Ranges:{RegisterValues}>"
        fmt += "\n <Data Types:{DataTypes}>"
        fmt += "\n <Code Blocks:{CodeBlocks}>"
        fmt += "\n <Data Definitions:{DataDefinitions}>"
        fmt += "\n <Comments:{Comments}>"
        fmt += "\n <Entry Points:{EntryPoints}>"
        fmt += "\n <Symbols:{Symbols}>"
        fmt += "\n <Functions:{Functions}>"
        fmt += "\n <Memory References:{MemoryReferences}>"
        fmt += "\n <Stack References:{StackReferences}>"
        fmt += "\n <Manual Instructions/Operands:{Manual}>{cGroup1}>"
        fmt += "\n\n"

        Opts = { 'cGroup1': ida_kernwin.Form.ChkGroupControl ((
                    "MemorySections",
                    "MemoryContent",
                    "RegisterValues",
                    "DataTypes",
                    "CodeBlocks",
                    "DataDefinitions",
                    "Comments",
                    "EntryPoints",
                    "Symbols",
                    "Functions",
                    "MemoryReferences",
                    "StackReferences",
                    "Manual"
                ))}

        self.options = ida_kernwin.Form(fmt, Opts)
        self.options.Compile()
        
        self.options.MemorySections.checked   = True
        self.options.MemoryContent.checked    = True
        self.options.DataTypes.checked        = True
        self.options.RegisterValues.checked   = True
        self.options.CodeBlocks.checked       = True
        self.options.DataDefinitions.checked  = True
        self.options.Symbols.checked          = True
        self.options.EntryPoints.checked      = True
        self.options.Functions.checked        = True
        self.options.Comments.checked         = True
        self.options.MemoryReferences.checked = True
        self.options.StackReferences.checked  = False
        self.options.Manual.checked           = True

        if (self.autorun == False):
            ok = self.options.Execute()
            if (ok == 0):
                raise Cancelled


    def get_space_name(self, addr):
        """
        Returns the memory space name associated with an address.
        
        Args:
            addr: Integer representing a program address.
            
        Returns:
            String containg the memory space name.
            None if single address space architecture.
        Used for Harvard architectures (Intel 8051 and TMS, add others
        as needed). 
        """
        pid = ida_idp.ph_get_id()
        stype = ida_segment.segtype(addr)
        if pid == ida_idp.PLFM_8051:
            if stype == idc.SEG_CODE:
                return "CODE"
            else:
                if stype == idc.SEG_IMEM:
                    iaddr = addr - ida_segment.get_segm_base(ida_segment.getseg(addr))
                    if iaddr < 0x80:
                        return "INTMEM"
                    else:
                        return "SFR"
                else:
                    return "EXTMEM"
        if pid == ida_idp.PLFM_TMS:
            if stype == idc.SEG_CODE:
                return "CODE"
            else:
                return "DATA"
        return None


    def get_symbol_name(self, ea):
        """
        Returns the symbol name for the address.
        
        Args:
            ea: Integer representing the symbol address.
            
        Returns:
            String containing the symbol name.
        
        The demangled name will be returned if it exists, otherwise the
        displayed name is returned. Spaces (' ') will be replaced with '_'.
        """
        name = ida_name.get_demangled_name(ea, DEMANGLED_FORM,
                                         self.inf.demnames, idc.GN_STRICT)
        if name == None or len(name) == 0 or name == "`string'":
            name = idc.get_name(ea)
        if name != None:
            name = name.replace(" ","_")
        return name


    def get_type(self, flags):
        """
        Returns a datatype string based on the item flags.
        
        Args:
            flags: IDA item flags.
            
        Returns:
            String representing item datatype.
        """
        if (self.cbsize == 2):
            if ida_bytes.is_byte(flags)  == True: return "word"
            if ida_bytes.is_word(flags)  == True: return "dword"
        if ida_bytes.is_byte(flags)      == True: return "byte"
        if ida_bytes.is_word(flags)      == True: return "word"
        if ida_bytes.is_dword(flags)     == True: return "dword"
        if ida_bytes.is_qword(flags)     == True: return "qword"
        if ida_bytes.is_oword(flags)     == True: return "oword"
        if ida_bytes.is_tbyte(flags)     == True: return "tbyte"
        if ida_bytes.is_float(flags)     == True: return "float"
        if ida_bytes.is_double(flags)    == True: return "double"
        if ida_bytes.is_pack_real(flags) == True: return "packed"
        if idc.is_strlit(flags)          == True: return "ascii"
        if ida_bytes.is_struct(flags)    == True: return "structure"
        if ida_bytes.is_align(flags)     == True: return "align"
        return "unknown"


    def is_imm_op(self, addr, op):
        """
        Returns true if instruction operand at address is an immediate value.
        
        Args:
            addr: Integer representing instruction address.
            op: Integer representing operand index (0-based).
            
        Returns:
            True if instruction operand at address is an immediate value.
            False otherwise.
        """
        insn = ida_ua.insn_t()
        ida_ua.decode_insn(insn, addr)
        if (insn.ops[op].type == idc.o_imm):
            return True
        return False
        

    def is_overlay(self, addr):
        """
        Checks if memory block (segment) is an overlay.
        
        Args:
            addr: Integer representing a program address.
            
        Returns:
            True if memory block (segment) is an overlay.
        """
        if ida_idp.ph_get_id() == ida_idp.PLFM_C166:
            return False
        s = ida_segment.getseg(addr)
        if s.start_ea in self.overlay:
            return self.overlay[s.start_ea]
        return False

    
    def is_signed_data(self, flags):
        return (flags & ida_bytes.FF_SIGN) != 0


    def start_element(self, tag, close=False):
        """
        Outputs the start of a new element on a new indented line.
        
        Args:
            tag: String representing the element tag
            close: Boolean indicating if tag is should be closed.
        """
        if ida_kernwin.user_cancelled() == True:
            raise Cancelled
        self.write_to_xmlfile("\n" + ("    " * self.indent_level) + "<" + tag)
        if (close):
            self.close_tag(True)
        self.update_counter(tag)
        

    def translate_address(self, addr):
        """
        Returns the translated logical address.
        The logical address is adjusted for the segment base address.
        For 16-bit segmented memory, return the 20-bit address.
        
        Args:
            addr: Integer representing a program address.
            
        Returns:
            Integer representing the logical address.
        """
        if self.seg_addr == False:
            return addr - ida_segment.get_segm_base(ida_segment.getseg(addr))
        base = ida_segment.get_segm_para(ida_segment.getseg(addr))
        return (base << 16) + (addr - (base << 4))
    

    def write_address_attribute(self, name, addr):
        """
        Outputs an address attribute for an element.
        
        Args:
            name: String representing attribute name.
            addr: Integer representing a program address.
        """
        self.write_attribute(name, self.get_address_string(addr))
    

    def write_attribute(self, name, value):
        """
        Outputs an attribute (name and value) for an element.
        
        Args:
            name: String representing attribute name.
            value: String representing attribute value.
        """
        if name == None or value == None:
            return
        if (len(name) == 0) or (len(value) == 0):
            return
        attr = " " + name + '="' + self.check_for_entities(value) + '"'
        self.write_to_xmlfile(attr)
        

    def write_comment_element(self, name, cmt):
        """
        Outputs the tag and text for a comment element.
        Comment elements can be REGULAR_CMT, REPEATABLE_CMT, or TYPEINFO_CMT.
        
        Args:
            name: String representing the comment element name.
            cmt: String containing the comment.
        """
        self.start_element(name, True)
        self.write_text(cmt)
        self.end_element(name, False)
        

    def write_numeric_attribute(self, name, value, base=16, signedhex=False):
        """
        Outputs a numeric value attribute (name and value) for an element.
        
        Args:
            name: String representing the attribute name.
            value: Integer representing the attribute value.
            base: Integer representing numeric base to use for value.
            signedhex: Boolean indicating if hex representation of
                value is signed.
        """
        if base == 10:
            temp = "%d" % value
        else:
            if signedhex == True and value < 0:
                temp = "-0x%X" % abs(value)
            else:
                temp = "0x%X" % value
        self.write_attribute(name, temp)


    def write_text(self, text):
        """
        Outputs the parsed character text for an element.
        The text is checked for special characters.
        
        Args:
            text: String representing the element text.
        """
        self.write_to_xmlfile(self.check_for_entities(text))
    

    def write_to_xmlfile(self, buf):
        """
        Writes the buffer to the XML file.
        
        Args:
            buf: String containg data to write to XML file.
        """
        self.xmlfile.write(buf)
        self.dbg(buf)
    

    def write_xml_declaration(self):
        """
        Writes the XML Declarations at the start of the XML file.
        """
        self.dbg("\n")
        xml_declaration  = "<?xml version=\"1.0\" standalone=\"yes\"?>"
        xml_declaration += "\n<?program_dtd version=\"1\"?>\n"
        self.write_to_xmlfile(xml_declaration)


class XmlImporter(IdaXml):
    """
    XmlImporter class contains methods to import an XML PROGRAM
        document into IDA.
    """
    def __init__(self, as_plugin, arg=0):
        """
        Initializes the XmlImporter attributes
        Args:
            as_plugin:
            debug: 
        """
        IdaXml.__init__(self, arg)
        self.plugin = as_plugin
        self.timers = dict()
        self.addr_mode = 1
        self.create = True
        self.dataseg = None
        self.deferred = []
        self.callbacks = {
            'start' : {
                BOOKMARKS           : self.update_import,
                CODE                : self.update_import,
                COMMENTS            : self.update_import,
                COMPILER            : self.import_compiler,
                DATA                : self.update_import,
                DATATYPES           : self.update_import,
                EQUATES             : self.update_import,
                FUNCTIONS           : self.update_import,
                INFO_SOURCE         : self.import_info_source,
                MARKUP              : self.update_import,
                MEMORY_MAP          : self.import_memory_map,
                PROCESSOR           : self.import_processor,
                PROGRAM             : self.import_program,
                PROGRAM_ENTRY_POINTS: self.update_import,
                REGISTER_VALUES     : self.update_import,
                SYMBOL_TABLE        : self.update_import },
            'end' : {
                BOOKMARK            : self.import_bookmark,
                CODE_BLOCK          : self.import_codeblock,
                COMMENT             : self.import_comment,
                DEFINED_DATA        : self.import_defined_data,
                DESCRIPTION         : self.import_description,
                ENUM                : self.import_enum,
                EQUATE_GROUP        : self.import_equate_group,
                EQUATE_REFERENCE    : self.import_equate_reference,
                FUNCTION            : self.import_function,
                FUNCTION_DEF        : self.import_function_def,
                MANUAL_INSTRUCTION  : self.import_manual_instruction,
                MANUAL_OPERAND      : self.import_manual_operand,
                MEMORY_REFERENCE    : self.import_memory_reference,
                MEMORY_SECTION      : self.import_memory_section,
                PROGRAM_ENTRY_POINT : self.import_program_entry_point,
                REGISTER_VALUE_RANGE: self.import_register_value_range,
                STACK_REFERENCE     : self.import_stack_reference,
                STRUCTURE           : self.import_structure,
                SYMBOL              : self.import_symbol,
                TYPE_DEF            : self.import_typedef,
                UNION               : self.import_union,
                # end element for elapse time
                BOOKMARKS           : self.display_timer,
                CODE                : self.display_timer,
                COMMENTS            : self.display_timer,
                DATA                : self.display_timer,
                DATATYPES           : self.process_deferred,
                EQUATES             : self.display_timer,
                FUNCTIONS           : self.display_timer,
                MARKUP              : self.display_timer,
                MEMORY_MAP          : self.display_timer,
                PROGRAM             : self.display_total_time,
                PROGRAM_ENTRY_POINTS: self.display_timer,
                REGISTER_VALUES     : self.display_timer,
                SYMBOL_TABLE        : self.display_timer }
            }


    def import_xml(self):
        """
        Imports the XML PROGRAM file into the database.
        """
        global event, element
        #self.display_version('Importer' if self.plugin else 'Loader')
        displayMenu = self.autorun == False
        self.get_options(displayMenu)
        if self.plugin:
            self.filename=ida_kernwin.ask_file(0, "*.xml",
                                               "Enter name of xml file:")
        else:
            self.filename = idc.get_input_file_path()
        if self.filename == None or len(self.filename) == 0:
            return
        idc.msg('\nImporting from: ' + self.filename + '\n')
        if self.plugin == False:
            ida_kernwin.hide_wait_box()
        ida_kernwin.show_wait_box("Importing XML PROGRAM document....")
        n = 0
        for event,element in cElementTree.iterparse(self.filename,
                                                events=("start","end")):
            if ida_kernwin.user_cancelled() == True:
                raise Cancelled
            
            if self.debug == True and event == 'start':
                msg = ''
                if element.tag != None:
                    msg += str(element.tag) + ' '
                if element.attrib != None:
                    msg += str(element.attrib) + ' '
                if element.text != None:
                    msg += str(element.text)
                if len(msg) > 0:
                    idc.msg('\n' + msg)
            
            if event in self.callbacks:
                if element.tag in self.callbacks[event]:
                    if event == 'start':
                        self.timers[element.tag] = time.process_time()
                    self.callbacks[event][element.tag](element)
                    if event == 'end':
                        element.clear()
            if event == 'end':
                n += 1
        end = time.process_time()
        ida_kernwin.hide_wait_box()
        self.display_summary('Import' if self.plugin else "Load")
        idc.msg('\nXML Elements parsed: ' + str(n) + '\n\n')
        return 1
    

    def get_options(self, display):
        """
        Displays the options menu and retrieves the option settings. 
        """
        fmt =  "HELP\n"
        fmt += "XML PROGRAM loader/importer plugin (Python)\n"
        fmt += "IDA SDK: "+ str(IDA_SDK_VERSION) + "\n\n"
        fmt +=  "The XML PROGRAM loader loads elements from a "
        fmt +=  "XML <PROGRAM> document to create an idb database.\n\n"
        fmt +=  "ENDHELP\n"
        fmt +=  "Import from XML PROGRAM document...."
        fmt += "\n <##Options##Code Blocks:{CodeBlocks}>"
        fmt += "\n <Entry Points:{EntryPoints}>"
        fmt += "\n <Segment Register Value Ranges:{RegisterValues}>"
        fmt += "\n <Data Types:{DataTypes}>"
        fmt += "\n <Data Definitions:{DataDefinitions}>"
        fmt += "\n <Symbols:{Symbols}>"
        fmt += "\n <Comments:{Comments}>"
        fmt += "\n <Bookmarks:{Bookmarks}>"
        fmt += "\n <Functions:{Functions}>"
        fmt += "\n <Memory References:{MemoryReferences}>"
        fmt += "\n <Equate/Enum References:{EquateReferences}>"
        fmt += "\n <Manual Instructions/Operands:{Manual}>{cGroup1}>"
        fmt += "\n\n"
    
        Opts =  { 'cGroup1': ida_kernwin.Form.ChkGroupControl (( 
                    "CodeBlocks",
                    "EntryPoints",
                    "RegisterValues",
                    "DataTypes",
                    "DataDefinitions",
                    "Symbols",
                    "Comments",
                    "Bookmarks",
                    "Functions",
                    "MemoryReferences",
                    "EquateReferences",
                    "Manual"
                ))}
        
        self.options = ida_kernwin.Form(fmt, Opts)
        self.options.Compile()
    
        self.options.CodeBlocks.checked       = True
        self.options.EntryPoints.checked      = True
        self.options.RegisterValues.checked   = True
        self.options.DataTypes.checked        = True
        self.options.DataDefinitions.checked  = True
        self.options.Symbols.checked          = True
        self.options.Functions.checked        = True
        self.options.Comments.checked         = True
        self.options.Bookmarks.checked        = True
        self.options.MemoryReferences.checked = True
        self.options.EquateReferences.checked = True
        self.options.Manual.checked           = True

        if display == True:
            ok = self.options.Execute()
            if (ok == 0):
                raise Cancelled


    def display_timer(self, element):
        """
        Displays the elapsed processing time for XML elements.
        
        Args:
            element: XML element object value containing the element tag.
        """
        if element.tag == MEMORY_MAP and self.plugin:
            return
        if element.tag in self.timers:
            idc.msg('elapsed time: %.4f' %
                    (time.process_time()-self.timers[element.tag]))
    
    
    def display_total_time(self, element):
        """
        Displays the total processing time.
        
        Args:
            element: XML element object value (not used).
        """
        TOTAL = 'Total '
        idc.msg('\n%35selapsed time: %.4f' %
                (TOTAL,time.process_time()-self.timers[PROGRAM]))
    
    

    def get_address(self, element, attr):
        """
        Returns the address value for an element.
        
        Args:
            element: XML element object.
            attr: String containing the address attribute name.
            
        Returns:
            Numeric value representing the address.
        """
        addrstr = element.get(attr)
        if '::' in addrstr:
            # overlayed addresses not currently handled
            return BADADDR
        elif ':' in addrstr:
            [segstr, offset_str] = string.split(addrstr,':')
            offset = int(offset_str,16)
            if self.is_int(segstr) == True:
                sgmt = int(segstr,16)
                addr = (sgmt << 4) + offset
            else:
                # multiple address spaces not currently implemented
                addr = BADADDR
            return addr
        else:
            return int(element.get(attr), 16)
    

    def get_attribute(self, element, attr):
        """
        Returns the attribute value string.
        
        Args:
            element: XML element object.
            attr: String containing the attribute name.
            
        Returns:
            String representing the attribute value.
        """
        return element.get(attr)
    

    def get_attribute_value(self, element, attr):
        """
        Returns the numeric attribute value.
        
        Args:
            element: XML element object.
            attr: String containing the attribute name.
            
        Returns:
            Numeric value representing the attribute value.
        """
        val = element.get(attr)
        try:
            if val.upper().startswith('0X') or val.upper().startswith('-0X'):
                return int(val, 16)
            return int(val)
        except:
            idc.msg('\nUnable to decode string as value: ' + val)
            return 0
        

    def get_cbsize(self):
        """
        Returns the size of the addressable codebyte for the processor.
        
        Returns:
            Integer representing the number of 8-bit bytes in an
            addressable codebyte.
        """
        return int(ida_idp.ph_get_cnbits()+7/8)
    

    def get_datatype_flags(self, datatype, size):
        """
        Returns the flags bitmask for the datatype.
        
        Args:
            datatype: String representing the datatype.
            size: Integer representing the datatype size.
        Returns:
            Integer representing the bitmask.
        """
        if datatype.lower().startswith("byte"):     return ida_bytes.byte_flag()
        if datatype.lower().startswith("word"):     return ida_bytes.word_flag()
        if datatype.lower().startswith("dword"):    return ida_bytes.dword_flag()
        if datatype.lower().startswith("qword"):    return ida_bytes.qword_flag()
        if datatype.lower().startswith("oword"):    return ida_bytes.oword_flag()
        if datatype.lower().startswith("tbyte"):    return ida_bytes.tbyte_flag()
        if datatype.lower().startswith("float"):    return ida_bytes.float_flag()
        if datatype.lower().startswith("double"):   return ida_bytes.double_flag()
        if datatype.lower().startswith("packed"):   return ida_bytes.packreal_flag()
        if self.is_string_type(datatype):           return ida_bytes.strlit_flag()
        if self.is_enumeration(datatype):           return ida_bytes.enum_flag()
        if self.is_structure(datatype):             return ida_bytes.stru_flag()
        #if size == 4:                               return ida_bytes.dword_flag()
        return 0
    

    def get_string_type(self, datatype):
        if datatype.lower() == 'mbcstring':
            return ida_nalt.STRTYPE_C_16
        if datatype.lower().find('unicode') != -1:
            if datatype.lower().find('pascal') != -1:
                return ida_nalt.STRTYPE_LEN2_16
            return ida_nalt.STRTYPE_C_16
        if datatype.lower().find('pascal') != -1:
            return ida_nalt.STRTYPE_C_16
        return ida_nalt.STRTYPE_TERMCHR
            
    
    def has_attribute(self, element, attr):
        """
        Returns true if the XML element contains the named attribute.
        
        Args:
            element: XML element object
            attr: String containing name of the attribute
        
        Returns:
            True if the element contains the named attribute, otherwise False.
        """
        return attr in element.attrib
    

    def is_enumeration(self, datatype):
        """
        Returns true if datatype is an existing enumeration in the database.
        
        Args:
            datatype: String representing the datatype.
            
        Returns:
            True if the datatype is an enumeration in the database,
            otherwise False.
        """
        if ida_enum.get_enum(datatype) == BADNODE:  return False
        return True
    
    
    def is_int(self, s):
        try:
            int(s, 16)
            return True
        except:
            return False
        

    def is_pointer_type(self, dtype):
        """
        Returns true if the datatype represents a pointer.
        
        Args:
            dtype: String representing the datatype.
            
        Returns:
            True if the datatype represents a pointer, otherwise False.
        """
        if dtype.lower().startswith("pointer") or dtype.endswith('*'):
            return True
        return False
    

    def is_string_type(self, datatype):
        """
        Returns true if the datatype represents a string type.
        
        Args:
            datatype: String representing the datatype.
            
        Returns:
            True if the datatype represents a string, otherwise False.
        """
        if datatype.lower().startswith("unicode"):  return True
        if datatype.lower().startswith("string"):   return True
        return False
    

    def is_structure(self, datatype):
        """
        Returns true if the datatype represents a structure in the database.
        
        Args:
            dtype: String representing the datatype.
            
        Returns:
            True if the datatype represents an existing structure,
            otherwise False.
        """
        if ida_struct.get_struc_id(datatype) == BADNODE:  return False
        return True
    

    def import_address_range(self, address_range):
        """
        Processes ADDRESS_RANGE element.
        
        Args:
            address_range: XML element object containing start and end address
                attributes for the address range.
                
        Returns:
            Tuple containing two integers, the start and end address values.
        """
        start = self.get_address(address_range,START)
        end = self.get_address(address_range, END)
        self.update_counter(ADDRESS_RANGE)
        return (start, end)
    

    def import_bit_mask(self, bitmask, eid):
        """
        Processes a BIT_MASK element as an enum bitmask member.
        
        Args:
            bitmask: XML element object representing the IDA enum bitmask.
            eid: Integer representing the IDA enum id
        """
        name = self.get_attribute(bitmask,NAME)
        value = self.get_attribute_value(bitmask,VALUE)
        ida_enum.set_bmask_name(eid, value, name)
        cid = ida_enum.get_enum_member_by_name(name)
        self.update_counter(BIT_MASK)
        regcmt = bitmask.find(REGULAR_CMT)
        if regcmt != None:
            ida_enum.set_enum_member_cmt(cid, regcmt.text, False);
            self.update_counter(BIT_MASK + ':' + REGULAR_CMT)
        rptcmt = bitmask.find(REPEATABLE_CMT)
        if rptcmt != None:
            ida_enum.set_enum_member_cmt(cid, rptcmt.txt, True);
            self.update_counter(BIT_MASK + ':' + REPEATABLE_CMT)
    

    def import_bookmark(self, bookmark):
        """
        Processes a BOOKMARK element.
        
        Args:
            bookmark: XML element object containing bookmark data.
        """
        if self.options.Bookmarks.checked == False:
            return
        try:
            addr = self.get_address(bookmark, ADDRESS)
            if self.has_attribute(bookmark, TYPE):
                typ = self.get_attribute(bookmark, TYPE)
            category = ''
            if self.has_attribute(bookmark, CATEGORY):
                category = self.get_attribute(bookmark, CATEGORY)
            description = ''
            if self.has_attribute(bookmark, DESCRIPTION):
                description = self.get_attribute(bookmark, DESCRIPTION)
            if idc.is_mapped(addr) == False:
                msg = ("import_bookmark: address %X not enabled in database"
                       % addr)
                print(msg)
                return
            self.update_counter(BOOKMARK)
            for slot in range(ida_moves.MAX_MARK_SLOT):
                ea = idc.get_bookmark(slot)
                if ea == BADADDR:
                    idc.put_bookmark(addr, 0, 0, 0, slot, description)
                    break
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info() 
            msg = "** Exception occurred in import_bookmark **"
            print("\n" + msg + "\n", exc_type, exc_value)
    

    def import_cmts(self, element, sid, typ):
        """
        Processes REGULAR_CMT and REPEATABLE_CMT elements for structures.
        
        Args:
            element: XML element object containing a REGULAR_CMT or
                REPEATABLE_CMT element
            sid: Integer representing the structure id
            typ: String indicating structure type (STRUCTURE or UNION)
        """
        regcmt = element.find(REGULAR_CMT)
        if regcmt != None:
            ida_struct.set_struc_cmt(sid, regcmt.text, False)
            self.update_counter(typ + ':' + REGULAR_CMT)
        rptcmt = element.find(REPEATABLE_CMT)
        if rptcmt != None:
            ida_struct.set_struc_cmt(sid, rptcmt.text, True)
            self.update_counter(typ + ':' + REPEATABLE_CMT)
            
        
    def import_codeblock(self, code_block):
        """
        Processes a CODE_BLOCK element by disassembling the address range.
        
        Args:
            code_block: XML element containing codeblock start and end
                addresses.
        """
        if self.options.CodeBlocks.checked == False:
            return
        start = self.get_address(code_block, START)
        end = self.get_address(code_block, END)
        ida_bytes.del_items(start, 3, end-start+1)
        addr = start
        while (addr <= end):
            length = ida_ua.create_insn(int(addr))
            addr += ida_bytes.get_item_size(int(addr))
        self.update_counter(CODE_BLOCK)
    

    def import_comment(self, comment):
        """
        Processes a COMMENT element by creating the comment at the address.
        
        Args:
            comment: XML element containing the comment address, type,
                and text.
        """
        if self.options.Comments.checked == False:
            return
        addr = self.get_address(comment, ADDRESS)
        ctype = self.get_attribute(comment,TYPE)
        text = comment.text
        if ctype == 'pre':
            ida_lines.add_extra_cmt(addr, True, text)
        elif ctype == 'end-of-line':
            idc.set_cmt(addr, text, False)
        elif ctype == 'repeatable':
            idc.set_cmt(addr, text, True)
        elif ctype == 'post':
            ida_lines.add_extra_cmt(addr, False, text)
        self.update_counter(COMMENT+':' + ctype)
    

    def import_compiler(self, compiler):
        """
        Processes the COMPILER element containing the compiler name.
        
        Args:
            compiler: XML element containing the compiler name.
        """
        name = self.get_attribute(compiler, NAME)
        self.update_counter(COMPILER)
        if self.plugin:
            return        
        comp = idc.COMP_UNK
        if   name == "Visual C++":      comp = ida_typeinf.COMP_MS
        elif name == "Borland C++":     comp = ida_typeinf.COMP_BC
        elif name == "Watcom C++":      comp = ida_typeinf.COMP_WATCOM
        elif name == "GNU C++":         comp = ida_typeinf.COMP_GNU
        elif name == "Visual Age C++":  comp = ida_typeinf.COMP_VISAGE
        elif name == "Delphi":          comp = ida_typeinf.COMP_BP
        ida_typeinf.set_compiler_id(comp)
    

    def import_defined_data(self, defined_data):
        """
        Processes a DEFINED_DATA element by creating a data item at the
            specified address.
        
        Args:
            defined_data: XML element containing the address and
                datatype information for the data item
        """
        if self.options.DataDefinitions.checked == False:
            return
        addr = self.get_address(defined_data, ADDRESS)
        datatype = self.get_attribute(defined_data, DATATYPE)
        size = self.get_attribute_value(defined_data, SIZE)
        self.update_counter(DEFINED_DATA)        
        ti = ida_nalt.opinfo_t()
        if self.is_pointer_type(datatype):
            #idaapi.set_refinfo(ti, 0, 0, 0, REF_OFF32)
            flag = ida_bytes.dword_flag() | idc.FF_0OFF
            #idaapi.set_typeinfo(addr, 0, flag, ti)
        else:
            flag = self.get_datatype_flags(datatype, size)
        if flag == ida_bytes.strlit_flag():
            ida_bytes.create_strlit(addr, size, self.get_string_type(datatype))
        elif flag == ida_bytes.stru_flag():
            idc.create_struct(addr, size, datatype)
        else:
            idc.create_data(addr, flag, size, BADNODE)        
        typecmt = defined_data.find(TYPEINFO_CMT)
        if typecmt != None:
            self.update_counter(DEFINED_DATA + ':' + TYPEINFO_CMT)
            
            
    def import_description(self, description):
        """
        Processes the DESCRIPTION element.
        
        Args:
            description: DESCRIPTION XML element.
        """
        self.update_counter(DESCRIPTION)
        # TODO: import_description: decide what to do with DESCRIPTION
        # print description.text


    def import_enum(self, enum):
        """
        Processes an ENUM element by creating the enumeration.
        
        Args:
            enum: XML element containing the enumeration name and
                member data.
        """
        if self.options.DataTypes.checked == False:
            return
        name = self.get_attribute(enum, NAME)
        if self.has_attribute(enum,NAMESPACE):
            namespace = self.get_attribute(enum, NAMESPACE)
        if self.has_attribute(enum,SIZE):
            size = self.get_attribute_value(enum, SIZE)
        eid = idc.add_enum(BADNODE, name,
                           ida_bytes.hex_flag() | ida_bytes.dword_flag())
        self.update_counter(ENUM)
        regcmt = enum.find(REGULAR_CMT)
        if regcmt != None:
            idc.set_enum_cmt(eid, regcmt.text, False)
            self.update_counter(ENUM + ':' + REGULAR_CMT)
        rptcmt = enum.find(REPEATABLE_CMT)
        if rptcmt != None:
            idc.set_enum_cmt(eid, rptcmt.text, True)
            self.update_counter(ENUM + ':' + REPEATABLE_CMT)
        display_settings = enum.find(DISPLAY_SETTINGS)
        if display_settings != None:
            self.update_counter(ENUM + ':' + DISPLAY_SETTINGS)
        enum_entries = enum.findall(ENUM_ENTRY)
        for enum_entry in enum_entries:
            self.import_enum_entry(enum_entry, eid)
    

    def import_enum_entry(self, enum_entry, eid):
        """
        Processes an ENUM_ENTRY by creating a member in the enumeration.
        
        Args:
            enum_entry: XML element containing the member name and value.
            eid: Integer representing the id of the enumeration.
        """
        name = self.get_attribute(enum_entry, NAME)
        value = self.get_attribute_value(enum_entry, VALUE)
        ida_enum.add_enum_member(eid, name, value)
        cid = idc.get_enum_member_by_name(name)
        self.update_counter(ENUM_ENTRY)
        regcmt = enum_entry.find(REGULAR_CMT)
        if regcmt != None:
            idc.set_enum_member_cmt(cid, regcmt.text, False);
            self.update_counter(ENUM_ENTRY + ':' + REGULAR_CMT)
        rptcmt = enum_entry.find(REPEATABLE_CMT)
        if rptcmt != None:
            idc.set_enum_member_cmt(cid, rptcmt.text, True);
            self.update_counter(ENUM_ENTRY + ':' + REPEATABLE_CMT)
    

    def import_equate(self, equate, eid):
        """
        Processes EQUATE element as member of an enumeration.
        
        Args:
            enum_entry: XML element containing the equate name and value.
            eid: Integer representing the id for the enumeration.
        """
        name = self.get_attribute(equate,NAME)
        value = self.get_attribute_value(equate,VALUE)
        bm = -1
        if self.has_attribute(equate, BIT_MASK):
            bm = self.get_attribute_value(equate, BIT_MASK)
        idc.add_enum_member(eid, name, value, bm)
        cid = idc.get_enum_member_by_name(name)
        self.update_counter(EQUATE)
        regcmt = equate.find(REGULAR_CMT) 
        if regcmt != None:
            idc.set_enum_member_cmt(cid, regcmt.text, False);
            self.update_counter(EQUATE + ':' + REGULAR_CMT)
        rptcmt = equate.find(REPEATABLE_CMT)
        if rptcmt != None:
            idc.set_enum_member_cmt(cid, rptcmt.text, True);
            self.update_counter(EQUATE + ':' + REPEATABLE_CMT)
    

    def import_equate_group(self, equate_group):
        """
        Processes EQUATE_GROUP as IDA enumeration type.
        
        Args:
            equate_group: XML element containing the group name and
                equate definitions.
        """
        if self.options.DataTypes.checked == False:
            return
        msg = EQUATE_GROUP
        name = ''
        if self.has_attribute(equate_group, NAME):
            name = self.get_attribute(equate_group, NAME)
        bf = ''
        if self.has_attribute(equate_group, BIT_FIELD):
            bf = self.get_attribute(equate_group, BIT_FIELD)
        eid = idc.add_enum(BADADDR, name, ida_bytes.hex_flag())
        idc.set_enum_bf(eid, (bf == 'yes'))
        self.update_counter(EQUATE_GROUP)
        regcmt = equate_group.find(REGULAR_CMT)
        if regcmt != None:
            idc.set_enum_cmt(eid, regcmt.text, False)
            self.update_counter(EQUATE_GROUP + ':' + REGULAR_CMT)
        rptcmt = equate_group.find(REPEATABLE_CMT)
        if rptcmt != None:
            idc.set_enum_cmt(eid, rptcmt.text, True)
            self.update_counter(EQUATE_GROUP + ':' + REPEATABLE_CMT)
        equates = equate_group.findall(EQUATE)
        for equate in equates:
            self.import_equate(equate,eid)
        bit_masks = equate_group.findall(BIT_MASK)
        for bit_mask in bit_masks:
            self.import_bit_mask(bit_mask, eid)
    

    def import_equate_reference(self, equate_reference):
        if (self.options.DataTypes.checked == False or
            self.options.EquateReferences.checked == False):
            return
        self.update_counter(EQUATE_REFERENCE)
        addr = self.get_address(equate_reference, ADDRESS)
        name = ''
        if self.has_attribute(equate_reference, NAME):
            name = self.get_attribute(equate_reference, NAME)
        if name == '':
            return
        opnd = 0
        if self.has_attribute(equate_reference, OPERAND_INDEX):
            opnd = self.get_attribute_value(equate_reference, OPERAND_INDEX)
        value = None
        if self.has_attribute(equate_reference, VALUE):
            value = self.get_attribute_value(equate_reference, VALUE)
            cid = idc.get_enum_member_by_name(name)
        if cid == BADNODE:
            return
        eid = idc.get_enum_member_enum(cid)
        if eid == BADNODE:
            return
        idc.op_enum(addr, opnd, eid, 0)
        

    def import_function(self, function):
        """
        Creates a function using the FUNCTION attributes.
        
        Args:
            function: XML element containing the function address and
                attributes.
        """
        if self.options.Functions.checked == False:
            return
        try:
            entry_point = self.get_address(function, ENTRY_POINT)
            name = ''
            if self.has_attribute(function, NAME):
                name = self.get_attribute(function, NAME)
            libfunc = 'n'
            if self.has_attribute(function, LIBRARY_FUNCTION):
                libfunc = self.get_attribute(function, LIBRARY_FUNCTION)
            if idc.is_mapped(entry_point) == False:
                msg = ("import_function: address %X not enabled in database"
                       % entry_point)
                print(msg)
                return
            idc.add_func(entry_point, BADADDR)
            self.update_counter(FUNCTION)
            func = ida_funcs.get_func(entry_point)
            if libfunc == 'y':
                func.flags |= idc.FUNC_LIB
            ranges = function.findall(ADDRESS_RANGE)
            for addr_range in ranges:
                (start, end) = self.import_address_range(addr_range)
                ida_funcs.append_func_tail(func, start, end)
            # TODO: auto_wait is probably not needed...
            if AUTO_WAIT:
                ida_auto.auto_wait()
            regcmt = function.find(REGULAR_CMT)
            if regcmt != None:
                self.update_counter(FUNCTION + ':' + REGULAR_CMT)
                ida_funcs.set_func_cmt(func, regcmt.text, False)
            rptcmt = function.find(REPEATABLE_CMT)
            if rptcmt != None:
                self.update_counter(FUNCTION + ':' + REPEATABLE_CMT)
                ida_funcs.set_func_cmt(func, rptcmt.text, True)
            typecmt = function.find(TYPEINFO_CMT)
            if typecmt != None:
                self.update_counter(FUNCTION + ':' + TYPEINFO_CMT)
                # TODO: TYPECMTs
                #idc.SetType(entry_point, typecmt.text + ';')
            sf = function.find(STACK_FRAME)
            if sf != None:
                self.import_stack_frame(sf, func)
            register_vars = function.findall(REGISTER_VAR)
            for register_var in register_vars:
                self.import_register_var(register_var, func)
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            msg = "** Exception occurred in import_function **"
            print("\n" + msg + "\n", exc_type, exc_value)


    def import_function_def(self, function_def):
        # import_function_def: NOT IMPLEMENTED
        if self.options.DataTypes.checked == False:
            return
        self.update_counter(FUNCTION_DEF)
        

    def import_info_source(self, info_source):
        """
        Processes INFO_SOURCE containing information about the
            source of the XML PROGRAM file.
        
        Args:
            info_source: XML element containing attributes that identify
                the source of the PROGRAM data.
        """
        if self.has_attribute(info_source, TOOL):
            tool = self.get_attribute(info_source, TOOL)
        if self.has_attribute(info_source, USER):
            user = self.get_attribute(info_source, USER)
        if self.has_attribute(info_source, FILE):
            f = self.get_attribute(info_source, FILE)
        if self.has_attribute(info_source, TIMESTAMP):
            ts = self.get_attribute(info_source, TIMESTAMP)
        self.update_counter(INFO_SOURCE)
    

    def import_manual_instruction(self, manual_instruction):
        """
        Creates a manual instruction.
        
        Args:
            manual_instruction: XML element containing MANUAL_INSTRUCTION.
        """
        if self.options.Manual.checked == False:
            return
        addr = self.get_address(manual_instruction, ADDRESS)
        idc.set_manual_insn(addr, manual_instruction.text)
        self.update_counter(MANUAL_INSTRUCTION)
    

    def import_manual_operand(self, manual_operand):
        """
        Creates a manual operand at an address.
        
        Args:
            manual_operand: MANUAL_OPERAND XML element.
        """
        if self.options.Manual.checked == False:
            return
        addr = self.get_address(manual_operand, ADDRESS)
        op = self.get_attribute_value(manual_operand, OPERAND_INDEX)
        if idc.is_mapped(addr):
            ida_bytes.set_forced_operand(addr, op, manual_operand.text)
            self.update_counter(MANUAL_OPERAND)


    def process_deferred(self, element):
        """
        Processes the list of deferred structure members when the
        DATATYPES end element is encountered.
        
        Args:
            element: XML end element for DATATYPES 
        """
        for (member, sptr) in self.deferred:
            self.import_member(member, sptr, False)
        self.display_timer(element)


    def import_member(self, member, sptr, defer=True):
        """
        Creates a member for a structure.
        
        Args:
            member: MEMBER XML element.
            sptr:
            defer:  boolean indicating if processing a member should be
                    deferred when the type is unknown. A member should
                    only be deferred on the first pass, not when processing
                    the deferred list.
        """
        offset = self.get_attribute_value(member, OFFSET)
        datatype = self.get_attribute(member, DATATYPE)
        if self.has_attribute(member, DATATYPE_NAMESPACE):
            dt_namespace = self.get_attribute(member, DATATYPE_NAMESPACE)
        name = ''
        if self.has_attribute(member, NAME):
            name = self.get_attribute(member, NAME)
        size = 0
        if self.has_attribute(member, SIZE):
            size = self.get_attribute_value(member, SIZE)
        ti = ida_nalt.opinfo_t()
        if self.is_pointer_type(datatype):
            flag = ida_bytes.dword_flag() | idc.FF_0OFF
            r = ida_nalt.refinfo_t()
            r.init(ida_nalt.get_reftype_by_size(4) | ida_nalt.REFINFO_NOBASE)
            ti.ri = r
        else:
            flag = self.get_datatype_flags(datatype, size)
        if flag == 0 and defer == True:
            self.deferred.append((member, sptr))
            return
        if flag == ida_bytes.enum_flag():
            t = idc.get_enum(datatype)
            ti.ec.tid = t
            ti.ec.serial = idc.get_enum_idx(t)
        if flag == ida_bytes.stru_flag():
            t = idc.get_struc_id(datatype)
            ti.tid = t
        error = ida_struct.add_struc_member(sptr, name, offset, flag, ti, size)
        mbr = ida_struct.get_member(sptr, offset)
        self.import_member_cmts(member, mbr)
        self.update_counter(MEMBER)
        
        
    def import_member_cmts(self, member, mbr):
        """
        Processes REGULAR_CMT and REPEATABLE_CMT elements for members.
        
        Args:
            element: XML element object containing a REGULAR_CMT or
                REPEATABLE_CMT element
            mbr: Integer representing the member id
        """
        regcmt = member.find(REGULAR_CMT)
        if regcmt != None:
            ida_struct.set_member_cmt(mbr, regcmt.text, False)
            self.update_counter(MEMBER + ':' + REGULAR_CMT)
        rptcmt = member.find(REPEATABLE_CMT)
        if rptcmt != None:
            ida_struct.set_member_cmt(mbr, rptcmt.text, True)
            self.update_counter(MEMBER + ':' + REPEATABLE_CMT)
        

    def import_members(self, element, sptr):
        """
        Add data members to a structure.
        
        Args:
            element: STRUCTURE XML element containing MEMBER sub-elements.
            sptr:
        """
        members = element.findall(MEMBER)
        for member in members:
            self.import_member(member, sptr)
                

    def import_memory_contents(self, memory_contents, start, size):
        """
        Processes MEMORY_CONTENTS to load data for a memory block.
        
        Args:
            memory_contents: MEMORY_CONTENTS XML element.
        """
        if memory_contents.get(START_ADDR) == None:
            saddr = start
        else:
            saddr = self.get_address(memory_contents, START_ADDR)
        fname = self.get_attribute(memory_contents, FILE_NAME)
        offset = self.get_attribute_value(memory_contents, FILE_OFFSET)
        if memory_contents.get(LENGTH) == None:
            length = size
        else:
            length = self.get_attribute_value(memory_contents, LENGTH)
        #(binfilename, ext) = os.path.splitext(self.filename)
        #binfilename += ".bytes"
        (binfilename, fileext) = os.path.split(self.filename)
        binfilename += "/" + fname
        binfile = ida_idaapi.loader_input_t()
        binfile.open(binfilename)
        binfile.file2base(offset,saddr,saddr+length,False)
        binfile.close()
        self.update_counter(MEMORY_CONTENTS)
    

    def import_memory_map(self, memory_map):
        """
        Processes the MEMORY_MAP element.
        
        Args:
            memory_map: MEMORY_MAP XML element.
            
        MEMORY_MAP is only processed by the IDA loader. It is ignored when
            run as an IDA plugin.
        """
        # import memory sections only when run as loader
        if self.plugin:
            return
        self.update_import(memory_map)
    

    def import_memory_reference(self, memory_reference):
        """
        Processes the MEMORY_REFERENCE element.
        Currently nothing is done with MEMORY_REFERENCEs.
        
        Args:
            memory_reference: MEMORY_REFERENCE XML element.
        """
        if self.options.MemoryReferences.checked == False:
            return
        # initialize implied attributes
        user = None
        op = None
        primary = None
        base_addr = None
        addr = self.get_address(memory_reference, ADDRESS)
        if self.has_attribute(memory_reference, OPERAND_INDEX):
            op = self.get_attribute_value(memory_reference, OPERAND_INDEX)
        if self.has_attribute(memory_reference, USER_DEFINED):
            user = self.get_attribute(memory_reference, USER_DEFINED)
        to_addr = self.get_address(memory_reference, TO_ADDRESS)
        if self.has_attribute(memory_reference, BASE_ADDRESS):
            base_addr = self.get_address(memory_reference, BASE_ADDRESS)
        if self.has_attribute(memory_reference, PRIMARY):
            primary = self.get_attribute(memory_reference, PRIMARY)
        self.update_counter(MEMORY_REFERENCE)
        # TODO: import_memory_reference: store refs? maybe only user-defined?
        '''
        if user == 'y':
            #print "%08X %08X" % (addr, to_addr), op, primary
            pass
        '''
 
 
    def import_memory_section(self, memory_section):
        """
        Creates a memory segment in the database.
        
        Args:
            memory_section: MEMORY_SECTION XML element.
            
        MEMORY_SECTION is only processed by the IDA loader. It is ignored
            when run as an IDA plugin.
        """
        # TODO: import_memory_section - handle overlays?
        # import memory sections only when run as loader
        if self.plugin:
            return
        name = self.get_attribute(memory_section, NAME)
        length = self.get_attribute_value(memory_section, LENGTH)

        s = ida_segment.segment_t()
        addrstr = self.get_attribute(memory_section, START_ADDR)
        seg_str = ''
        if '::' in addrstr:
            # overlay - skip for now
            print('  ** Overlayed memory block %s skipped **  ' % name)
            msg  = 'Overlayed memory block %s skipped!' % name
            msg += "\n\nXML Import does not currently support"
            msg += "\noverlayed memory blocks."
            idc.warning(msg)
            return
        elif ':' in addrstr:
            [seg_str, offset_str] = string.split(addrstr,':')
            offset = int(offset_str, 16)
            if self.is_int(seg_str):
                base = int(seg_str, 16)
                sel = ida_segment.setup_selector(base)
                start = self.get_address(memory_section, START_ADDR)
            else:
                raise MultipleAddressSpacesNotSupported
                return
        else:
            sel = ida_segment.allocate_selector(0)
            start = self.get_address(memory_section, START_ADDR)
        
        s.sel = sel
        s.start_ea = start
        s.end_ea = start+length
        s.bitness = self.addr_mode
        
        perms = ''
        if self.has_attribute(memory_section, PERMISSIONS):
            perms = self.get_attribute(memory_section, PERMISSIONS)
        s.perm = 0
        if 'r' in perms: s.perm |= ida_segment.SEGPERM_READ
        if 'w' in perms: s.perm |= ida_segment.SEGPERM_WRITE
        if 'x' in perms: s.perm |= ida_segment.SEGPERM_EXEC
        ok = ida_segment.add_segm_ex(s, name, "",
                                idc.ADDSEG_OR_DIE | idc.ADDSEG_QUIET)
        self.update_counter(MEMORY_SECTION)
        for memory_contents in memory_section.findall(MEMORY_CONTENTS):
            self.import_memory_contents(memory_contents, start, length)
    

    def import_processor(self, processor):
        """
        Processes the PROCESSOR element.
        
        Args:
            processor: PROCESSOR XML element.
        """
        name = self.get_attribute(processor, NAME)
        self.update_counter(PROCESSOR)
        if self.plugin:
            return
        address_model = self.get_attribute(processor, ADDRESS_MODEL)
        if address_model != None:
            if str.lower(address_model) == '16-bit':
                self.addr_mode = 0
                idc.set_flag(idc.INF_LFLAGS, idc.LFLG_PC_FLAT, 0)
                idc.set_flag(idc.INF_LFLAGS, idc.LFLG_64BIT, 0)
            elif str.lower(address_model) == '32-bit':
                self.addr_mode = 1
                idc.set_flag(idc.INF_LFLAGS, idc.LFLG_PC_FLAT, 1)
                idc.set_flag(idc.INF_LFLAGS, idc.LFLG_64BIT, 0)
            elif str.lower(address_model) == '64-bit':
                self.addr_mode = 2
                idc.set_flag(idc.INF_LFLAGS, idc.LFLG_PC_FLAT, 1)
                idc.set_flag(idc.INF_LFLAGS, idc.LFLG_64BIT, 1)
        

    def import_program(self, program):
        """
        Processes the PROGRAM element.
        
        Args:
            program: PROGRAM XML element.
        """
        self.update_status(PROGRAM)
        self.update_counter(PROGRAM)
        if self.plugin:
            return
        name = self.get_attribute(program, NAME)
        if self.has_attribute(program, EXE_PATH):
            epath = self.get_attribute(program, EXE_PATH)
            idc.set_root_filename(epath)
        else:
            idc.set_root_filename(name)
        if self.has_attribute(program, EXE_FORMAT):
            eformat = self.get_attribute(program, EXE_FORMAT)
            RootNode = ida_netnode.netnode('Root Node')
            RootNode.supset(ida_nalt.RIDX_FILE_FORMAT_NAME, eformat)
        if self.has_attribute(program, IMAGE_BASE):
            base = self.get_attribute_value(program, IMAGE_BASE)
            ida_nalt.set_imagebase(base)
        if self.has_attribute(program, INPUT_MD5):
            input_md5 = self.get_attribute(program, INPUT_MD5)
            # store original md5 in a special netnode
            md5 = ida_netnode.netnode(INPUT_MD5, len(INPUT_MD5), True)
            md5.supset(ida_nalt.RIDX_MD5, input_md5)

        
    def import_program_entry_point(self, program_entry_point):
        """
        Defines a program entry point.
        
        Args:
            program_entry_point: PROGRAM_ENTRY_POINT XML element.
                Contains the entry point address.
        """
        if self.options.EntryPoints.checked == False:
            return
        addr = self.get_address(program_entry_point, ADDRESS)
        idc.add_entry(addr, addr, "", True)
        self.update_counter(PROGRAM_ENTRY_POINT)
    

    def import_register_value_range(self, register_value_range):
        """
        Defines the address range for a register value.
        
        Args:
            register_value_range: REGISTER_VALUE_RANGE XML element.
                Contains the register, value, start address and range length.
        """
        if self.options.RegisterValues.checked == False:
            return
        self.update_counter(REGISTER_VALUE_RANGE)
        reg = self.get_attribute(register_value_range, REGISTER)
        if reg == 'cs': return
        value = self.get_attribute_value(register_value_range, VALUE)
        addr = self.get_address(register_value_range, START_ADDRESS)
        length = self.get_attribute_value(register_value_range, LENGTH)
        r = ida_idp.str2reg(reg)
        if r >= ida_idp.ph_get_reg_first_sreg() and r <= ida_idp.ph_get_reg_last_sreg():
            ida_segregs.split_sreg_range(addr, r, value, idc.SR_user, True)
    

    def import_register_var(self, register_var, func):
        """
        Defines a register variable for a function.
        
        Args:
            register_var: REGISTER_VAR XML element.
                Contains register, variable name, and datatype.
            func: IDA function object
        """
        name = self.get_attribute(register_var, NAME)
        reg = self.get_attribute(register_var, REGISTER)
        if self.has_attribute(register_var, DATATYPE):
            datatype = self.get_attribute(register_var, DATATYPE)
        if self.has_attribute(register_var, DATATYPE_NAMESPACE):
            namespace = self.get_attribute(register_var, DATATYPE_NAMESPACE)
        if func:
            idc.define_local_var(func.start_ea, func.end_ea, reg, name)
        self.update_counter(REGISTER_VAR)
    

    def import_stack_frame(self, stack_frame, func):
        """
        Defines a stack frame for a function.
        
        Args:
            stack_frame: STACK_FRAME element with STACK_VAR child elements.
        """
        if self.has_attribute(stack_frame, LOCAL_VAR_SIZE):
            lvsize = self.get_attribute_value(stack_frame, LOCAL_VAR_SIZE)
        if self.has_attribute(stack_frame, PARAM_OFFSET):
            param_offset = self.get_attribute_value(stack_frame, PARAM_OFFSET)
        if self.has_attribute(stack_frame, REGISTER_SAVE_SIZE):
            reg_save_size = self.get_attribute_value(stack_frame,
                                                     REGISTER_SAVE_SIZE)
        if self.has_attribute(stack_frame, RETURN_ADDR_SIZE):
            retaddr_size = self.get_attribute_value(stack_frame,
                                                    RETURN_ADDR_SIZE)
        if self.has_attribute(stack_frame, BYTES_PURGED):
            bytes_purged = self.get_attribute_value(stack_frame, BYTES_PURGED)
        self.update_counter(STACK_FRAME)
        for stack_var in stack_frame.findall(STACK_VAR):
            if func:
                self.import_stack_var(stack_var, func)
    

    def import_stack_reference(self, stack_reference):
        # import_stack_reference: NOT IMPLEMENTED
        self.update_counter(STACK_REFERENCE)
        pass
                    

    def import_stack_var(self, stack_var, func):
        """
        Processes STACK_VAR element.
        
        Args:
            stack_var: STACK_VAR XML element.
            
        Stack variables are created by IDA's function analysis. 
        Only the STACK_VAR NAME attribute is used to set the name for
        a stack variable at the specified stack/frame offset. 
        """
        spoffset = self.get_attribute_value(stack_var, STACK_PTR_OFFSET)
        datatype = self.get_attribute(stack_var, DATATYPE)
        offset = spoffset + func.frsize + func.frregs
        if self.has_attribute(stack_var, FRAME_PTR_OFFSET):
            fpoffset = self.get_attribute_value(stack_var, FRAME_PTR_OFFSET)
            offset = fpoffset + func.frsize
        name = ''
        if self.has_attribute(stack_var, NAME):
            name = self.get_attribute(stack_var, NAME)
        if self.has_attribute(stack_var, DATATYPE_NAMESPACE):
            namespace = self.get_attribute(stack_var, DATATYPE_NAMESPACE)
        if self.has_attribute(stack_var, SIZE):
            size = self.get_attribute_value(stack_var, SIZE)
        self.update_counter(STACK_VAR)
        sf = ida_frame.get_frame(func)
        if name != '':
            ida_struct.set_member_name(sf, offset, name)
    

    def import_structure(self, structure):
        """
        Adds a structure.
        
        Args:
            structure: STRUCTURE XML element.
                Contains the STRUCTURE attributes and child elements.
        """
        if self.options.DataTypes.checked == False:
            return
        name = self.get_attribute(structure, NAME)
        dtyp = idc.get_struc_id(name)
        if dtyp != BADNODE:
            # duplicate name, try adding name space
            if self.has_attribute(structure, NAMESPACE) == False:
                return
            namespace = self.get_attribute(structure, NAMESPACE)
            name = namespace + '__' + name
            name.replace('/','_')
            name.replace('.','_')
            dtyp = idc.get_struc_id(name)
            # skip if still duplicate (could add sequence #)
            if dtyp != BADNODE:
                return
        size = 0
        if self.has_attribute(structure, SIZE):
            size = self.get_attribute_value(structure, SIZE)
        if self.has_attribute(structure, VARIABLE_LENGTH):
            vl = self.get_attribute_value(structure, VARIABLE_LENGTH)
            isVariableLength = vl == 'y'        
        sid = idc.add_struc(-1, name, 0)
        sptr = ida_struct.get_struc(sid)
        self.update_counter(STRUCTURE)
        self.import_cmts(structure, sid, STRUCTURE)
        self.import_members(structure, sptr)
        if idc.get_struc_size(sptr) < size:
            t = ida_nalt.opinfo_t()
            ida_struct.add_struc_member(sptr,"",size-1,ida_bytes.byte_flag(),t,1)
        

    def import_symbol(self, symbol):
        """
        Adds a symbol name at the specified address.
        
        Args:
            symbol: SYMBOL XML element.
                Contains symbol name and address. Optionally includes
                type and mangled symbol.
        """
        if self.options.Symbols.checked == False:
            return
        addr = self.get_address(symbol, ADDRESS)
        name = self.get_attribute(symbol, NAME)
        if self.has_attribute(symbol, MANGLED):
            name = self.get_attribute(symbol, MANGLED)
        flag = idc.SN_NOWARN
        if self.has_attribute(symbol, TYPE):
            typ = self.get_attribute(symbol, TYPE)
            if  typ == 'local': flag |= idc.SN_LOCAL
        idc.set_name(addr, name, flag)
        self.update_counter(SYMBOL)
    

    def import_typedef(self, type_def):
        # import_typedef: NOT IMPLEMENTED
        if self.options.DataTypes.checked == False:
            return
        self.update_counter(TYPE_DEF)
        

    def import_union(self, union):
        """
        Adds a union datatype.
        
        Args:
            union: UNION XML element.
                Contains UNION attributes and child elements.
        """
        if self.options.DataTypes.checked == False:
            return
        name = self.get_attribute(union, NAME)
        dtyp = idc.get_struc_id(name)
        if dtyp != BADNODE:
            # duplicate name, try adding name space
            if self.has_attribute(union, NAMESPACE) == False:
                return
            namespace = self.get_attribute(union, NAMESPACE)
            name = namespace + '__' + name
            name.replace('/','_')
            name.replace('.','_')
            dtyp = idc.get_struc_id(name)
            # skip if still duplicate (could add sequence #)
            if dtyp != BADNODE:
                return
        size = 0
        if self.has_attribute(union, SIZE):
            size = self.get_attribute_value(union, SIZE)
        sid = idc.add_struc(BADADDR, name, True)
        sptr = ida_struct.get_struc(sid)
        self.update_counter(UNION)
        self.import_cmts(union, sid, UNION)
        self.import_members(union, sptr)
        if idc.get_struc_size(sptr) < size:
            t = ida_nalt.opinfo_t()
            ida_struct.add_struc_member(sptr,"", size-1, ida_bytes.byte_flag(), t, 1)
            

    def update_import(self, element):
        """
        Update the element counter and processing status.
        
        Args:
            element: XML element
            
        This function is used to process certain high-level elements
        (such as COMMENTS, CODE_BLOCKS, SYMBOL_TABLE, FUNCTIONS, etc.)
        that are used to group sub-elements.
        """
        self.update_counter(element.tag)
        self.update_status(element.tag)
    

# Global constants
# mangled name inhibit flags are not currently exposed in python api
# inhibit flags for symbol names
# DEMANGLE_FORM (MNG_SHORT_FORM | MNG_NOBASEDT | MNG_NOCALLC | MNG_NOCSVOL)
DEMANGLED_FORM = 0x0ea3ffe7
# inhibit flags for typeinfo cmts
# DEMANGLED_TYPEINFO (MNG_LONG_FORM)
DEMANGLED_TYPEINFO = 0x06400007

        
# Global XML string constants for elements and attributes
ADDRESS = 'ADDRESS'
ADDRESS_MODEL = 'ADDRESS_MODEL'
ADDRESS_RANGE = 'ADDRESS_RANGE'
BASE_ADDRESS = 'BASE_ADDRESS'
BIT_FIELD = 'BIT_FIELD'
BIT_MAPPED = 'BIT_MAPPED'
BIT_MASK = 'BIT_MASK'
BOOKMARK = 'BOOKMARK'
BOOKMARKS = 'BOOKMARKS'
BYTES = 'BYTES'
BYTES_PURGED = 'BYTES_PURGED'
CATEGORY = 'CATEGORY'
CODE = 'CODE'
CODE_BLOCK = 'CODE_BLOCK'
COMMENT = 'COMMENT'
COMMENTS = 'COMMENTS'
COMPILER = 'COMPILER'
DATA = 'DATA'
DATATYPE = 'DATATYPE'
DATATYPES = 'DATATYPES'
DATATYPE_NAMESPACE = 'DATATYPE_NAMESPACE'
DEFINED_DATA = 'DEFINED_DATA'
DESCRIPTION = 'DESCRIPTION'
DISPLAY_SETTINGS = 'DISPLAY_SETTINGS'
END = 'END'
ENDIAN = 'ENDIAN'
ENTRY_POINT = 'ENTRY_POINT'
ENUM = 'ENUM'
ENUM_ENTRY = 'ENUM_ENTRY'
EQUATE = 'EQUATE'
EQUATES = 'EQUATES'
EQUATE_GROUP = 'EQUATE_GROUP'
EQUATE_REFERENCE = 'EQUATE_REFERENCE'
EXE_FORMAT = 'EXE_FORMAT'
EXE_PATH = 'EXE_PATH'
EXT_LIBRARY = 'EXT_LIBRARY'
EXT_LIBRARY_REFERENCE = 'EXT_LIBRARY_REFERENCE'
EXT_LIBRARY_TABLE = 'EXT_LIBRARY_TABLE'
FAMILY = 'FAMILY'
FILE = 'FILE'
FILE_NAME = 'FILE_NAME'
FILE_OFFSET = 'FILE_OFFSET'
FOLDER = 'FOLDER'
FORMAT = 'FORMAT'
FRAGMENT = 'FRAGMENT'
FRAME_PTR_OFFSET = 'FRAME_PTR_OFFSET'
FUNCTION = 'FUNCTION'
FUNCTIONS = 'FUNCTIONS'
FUNCTION_DEF = 'FUNCTION_DEF'
IMAGE_BASE = 'IMAGE_BASE'
INPUT_MD5 = 'INPUT_MD5'
INFO_SOURCE = 'INFO_SOURCE'
LANGUAGE_PROVIDER = 'LANGUAGE_PROVIDER'
LENGTH = 'LENGTH'
LIB_ADDR = 'LIB_ADDR'
LIB_LABEL = 'LIB_LABEL'
LIB_ORDINAL = 'LIB_ORDINAL'
LIB_PROG_NAME = 'LIB_PROG_NAME'
LIBRARY_FUNCTION = 'LIBRARY_FUNCTION'
LOCAL_VAR_SIZE = 'LOCAL_VAR_SIZE'
MANGLED = 'MANGLED'
MANUAL_INSTRUCTION = 'MANUAL_INSTRUCTION'
MANUAL_OPERAND = 'MANUAL_OPERAND'
MARKUP = 'MARKUP'
MEMBER = 'MEMBER'
MEMORY_CONTENTS = 'MEMORY_CONTENTS'
MEMORY_MAP = 'MEMORY_MAP'
MEMORY_REFERENCE = 'MEMORY_REFERENCE'
MEMORY_SECTION = 'MEMORY_SECTION'
NAME = 'NAME'
NAMESPACE = 'NAMESPACE'
OFFSET = 'OFFSET'
OPERAND_INDEX = 'OPERAND_INDEX'
PARAM_OFFSET = 'PARAM_OFFSET'
PATH = 'PATH'
PERMISSIONS = 'PERMISSIONS'
PRIMARY = 'PRIMARY'
PROCESSOR = 'PROCESSOR'
PROGRAM = 'PROGRAM'
PROGRAM_ENTRY_POINT = 'PROGRAM_ENTRY_POINT'
PROGRAM_ENTRY_POINTS = 'PROGRAM_ENTRY_POINTS'
PROGRAM_TREES = 'PROGRAM_TREES'
PROPERTIES = 'PROPERTIES'
PROPERTY = 'PROPERTY'
REGISTER = 'REGISTER'
REGISTER_SAVE_SIZE = 'REGISTER_SAVE_SIZE'
REGISTER_VALUES = 'REGISTER_VALUES'
REGISTER_VALUE_RANGE = 'REGISTER_VALUE_RANGE'
REGISTER_VAR = 'REGISTER_VAR'
REGULAR_CMT = 'REGULAR_CMT'
RELOCATION = 'RELOCATION'
RELOCATION_TABLE = 'RELOCATION_TABLE'
REPEATABLE_CMT = 'REPEATABLE_CMT'
RETURN_ADDR_SIZE = 'RETURN_ADDR_SIZE'
RETURN_TYPE = 'RETURN_TYPE'
SHOW_TERMINATOR = 'SHOW_TERMINATOR'
SIGNED = 'SIGNED'
SIZE = 'SIZE'
SOURCE_ADDRESS = 'SOURCE_ADDRESS'
SOURCE_TYPE = 'SOURCE_TYPE'
STACK_FRAME = 'STACK_FRAME'
STACK_PTR_OFFSET = 'STACK_PTR_OFFSET'
STACK_REFERENCE = 'STACK_REFERENCE'
STACK_VAR = 'STACK_VAR'
START = 'START'
START_ADDR = 'START_ADDR'
START_ADDRESS = 'START_ADDRESS'
STRUCTURE = 'STRUCTURE'
SYMBOL = 'SYMBOL'
SYMBOL_TABLE = 'SYMBOL_TABLE'
TIMESTAMP = 'TIMESTAMP'
TOOL = 'TOOL'
TO_ADDRESS = 'TO_ADDRESS'
TREE = 'TREE'
TYPE = 'TYPE'
TYPEINFO_CMT = 'TYPEINFO_CMT'
TYPE_DEF = 'TYPE_DEF'
UNION = 'UNION'
USER = 'USER'
USER_DEFINED = 'USER_DEFINED'
VALUE = 'VALUE'
VARIABLE_LENGTH = 'VARIABLE_LENGTH'
ZERO_PAD = 'ZERO_PAD'

```

`firmeye/logger.py`:

```py
# -*- coding: utf-8 -*-

import os
import time
from functools import wraps

import ida_nalt
import ida_kernwin

from firmeye.config import DEBUG


class FELogger():
    """
    日志、调试配置管理类
    """

    enable_dbg = DEBUG
    log_path = ''
    log_fd = None
    time_cost = {}

    @classmethod
    def get_dbg_mode(cls):
        return cls.enable_dbg

    @classmethod
    def enable_debug(cls):
        cls.enable_dbg = True

    @classmethod
    def disable_debug(cls):
        cls.enable_dbg = False

    @classmethod
    def reload(cls, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            if cls.get_dbg_mode():
                cur_workpath = os.getcwd()
                log_filename = '%s.xdbg' % ida_nalt.get_root_filename()
                log_filepath = os.path.join(cur_workpath, log_filename)
                cls.log_path = log_filepath
                if cls.log_fd:
                    cls.log_fd.close()
                    cls.log_fd = None
                cls.log_fd = open(cls.log_path, 'a')
            return func(*args, **kwargs)
        return wrapper

    @classmethod
    def log_time(cls, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            s_time = time.perf_counter()
            ret_t = func(*args, **kwargs)
            e_time = time.perf_counter()
            if not func.__name__ in cls.time_cost:
                cls.time_cost[func.__name__] = 0
            cls.time_cost[func.__name__] += e_time - s_time
            return ret_t
        return wrapper

    @classmethod
    def show_time_cost(cls, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            ret_t = func(*args, **kwargs)
            for func_name in cls.time_cost:
                cls.info('%s: %f seconds' % (func_name, cls.time_cost[func_name]))
            return ret_t
        return wrapper

    @classmethod
    def log(cls, level, msg, debug):
        if level == 'console':
            msg_t = '%s\n' % msg
        else:
            msg_t = '[%s] %s\n' % (level, msg)

        if cls.log_fd:
            if cls.enable_dbg or debug:
                cls.log_fd.write(msg_t)
                cls.log_fd.flush()

        ida_kernwin.msg(msg_t)
        if level == 'warn' or level == 'erro':
            ida_kernwin.warning(msg_t)

    @classmethod
    def console(cls, msg, debug=False):
        cls.log(level='console', msg=msg, debug=debug)

    @classmethod
    def info(cls, msg, debug=False):
        cls.log(level='info', msg=msg, debug=debug)

    @classmethod
    def warn(cls, msg, debug=False):
        cls.log(level='warn', msg=msg, debug=debug)

    @classmethod
    def erro(cls, msg, debug=False):
        cls.log(level='erro', msg=msg, debug=debug)

```

`firmeye/re_assistant.py`:

```py
# -*- coding: utf-8 -*-

import os
import csv
from collections import OrderedDict

import idc
import ida_funcs
import ida_kernwin
import ida_auto
import ida_nalt
import ida_hexrays
import idautils

from firmeye.helper import hexstr
from firmeye.logger import FELogger
from firmeye.tools.idapyhelper import PyHelperChooser
from firmeye.tools.hexrayshelper import get_ctree_graph
from firmeye.tools.checksec import Checksec
from firmeye.view.chooser import AnalysisChooser, AnalysisChooseData
from firmeye.idaxml import XmlExporter, Cancelled


class FEReAssistForm(ida_kernwin.Form):

    def __init__(self):
        ida_kernwin.Form.__init__(self, """STARTITEM 0
Reverse Assistant
IDAPython帮助:
<##查看:{btn_idapy_helper}>
HexRays ctree图：
<##查看:{btn_hexrays_helper}>
Checksec：
<##查看:{btn_checksec}>
Ghidra函数列表：
<##导入:{btn_imp_ghidra_funcs}>
函数调用次数统计：
<##开始:{btn_func_xref_count}>
导出XML到Ghidra：
<##导出:{btn_export_ida_to_xml}>
""", {
    'btn_idapy_helper': ida_kernwin.Form.ButtonInput(self.btn_idapy_helper),
    'btn_hexrays_helper': ida_kernwin.Form.ButtonInput(self.btn_hexrays_helper),
    'btn_checksec': ida_kernwin.Form.ButtonInput(self.btn_checksec),
    'btn_imp_ghidra_funcs': ida_kernwin.Form.ButtonInput(self.btn_imp_ghidra_funcs),
    'btn_func_xref_count': ida_kernwin.Form.ButtonInput(self.btn_func_xref_count),
    'btn_export_ida_to_xml': ida_kernwin.Form.ButtonInput(self.btn_export_ida_to_xml)
})

    def btn_idapy_helper(self, code=0):
        """
        IDAPython帮助
        """
        helper = PyHelperChooser("IDAPyHelper")
        helper.Show()

    def btn_hexrays_helper(self, code=0):
        """
        HexRays ctree图
        """
        ea = ida_kernwin.get_screen_ea()
        get_ctree_graph(ea)


    def btn_checksec(self, code=0):
        """
        ELF Checksec
        """
        elfpath = ida_nalt.get_input_file_path()
        if os.path.exists(elfpath):
            result = Checksec(elfpath)
            FELogger.info("-"*10+"Checksec"+"-"*10+elfpath+"-"*10)
            FELogger.info(result.sec)
        else:
            input_path = ida_kernwin.ask_str(elfpath, 0, "请输入原始Binary路径")
            if input_path and input_path != "":
                if os.path.exists(input_path):
                    result = Checksec(input_path)
                    FELogger.info("-"*10+"Checksec"+"-"*10+input_path+"-"*10)
                    FELogger.info(result.sec)
                else:
                    FELogger.info("原始Binary不存在：%s" % input_path)
            else:
                FELogger.info("原始Binary不存在：%s" % elfpath)

    def btn_imp_ghidra_funcs(self, code=0):
        """
        导入Ghidra函数列表
        """
        ghidra_filepath = os.path.join(os.getcwd(), 'ghidra_func_addrs.csv')
        ghidra_path = ida_kernwin.ask_str(ghidra_filepath, 0, '导入的Ghidra导出函数文件路径')

        func_addrs = list(idautils.Functions())
        make_func_addrs = []
        if ghidra_path and ghidra_path != '':
            if os.path.exists(ghidra_path):
                with open(ghidra_path, 'rb') as f:
                    next(f)
                    reader = csv.reader(f)
                    for row in reader:
                        addr = int(row[0].strip('\"'), 16)
                        if ida_funcs.add_func(addr) == True:
                            make_func_addrs.append(addr)
                        else:
                            if addr not in func_addrs:
                                FELogger.info("创建函数%s失败" % hexstr(addr))
                FELogger.info("Ghidra导出函数文件：%s，已导入" % ghidra_path)
            else:
                FELogger.erro("未找到Ghidra导出函数文件：%s" % ghidra_path)
        else:
            FELogger.warn("请输入Ghidra导出函数文件路径")

        FELogger.info("成功创建%d个新函数" % len(make_func_addrs))

    def btn_func_xref_count(self, code=0):
        """
        函数调用次数统计
        """
        xref_count_dict = OrderedDict()
        for func_addr_t in idautils.Functions():
            count = len(list(idautils.CodeRefsTo(func_addr_t, 0)))
            xref_count_dict[ida_funcs.get_func_name(func_addr_t)] = [func_addr_t, count]
        ordered_list = sorted(list(xref_count_dict.items()), key=lambda x: x[1][1], reverse=True)

        cols = [['', 0 | ida_kernwin.Choose.CHCOL_DEC],
                ['函数名', 15 | ida_kernwin.Choose.CHCOL_PLAIN],
                ['地址', 10 | ida_kernwin.Choose.CHCOL_HEX],
                ['次数', 10 | ida_kernwin.Choose.CHCOL_PLAIN]]
        items = []

        for x in ordered_list:
            data = AnalysisChooseData(vuln=0, name=x[0], ea=x[1][0], other1=str(x[1][1]))
            items.append(data)

        chooser = AnalysisChooser(title='函数调用次数统计', cols=cols, item=items)
        chooser.Show()

    def btn_export_ida_to_xml(self, code=0):
        """
        导出XML到Ghidra
        """
        def do_export():
            st = ida_auto.set_ida_state(idc.IDA_STATUS_WORK)
            xml = XmlExporter(1)

            try:
                try:
                    xml.export_xml()
                    FELogger.info("已导出IDA数据到XML")
                except Cancelled:
                    ida_kernwin.hide_wait_box()
                    FELogger.warn("已取消XML导出")
                except Exception as e:
                    ida_kernwin.hide_wait_box()
                    FELogger.warn("导出XML失败 %s" % e)
            finally:
                xml.cleanup()
                ida_auto.set_ida_state(st)

        cur_workpath = os.getcwd()
        xml_filepath = os.path.join(cur_workpath, '%s.xml' % ida_nalt.get_input_file_path())
        bin_filepath = os.path.join(cur_workpath, '%s.bytes' % ida_nalt.get_input_file_path())

        if os.path.isfile(xml_filepath) and os.path.isfile(bin_filepath):
            if ida_kernwin.ask_yn(0, '导出文件已存在，是否覆盖？') == 1:
                do_export()
        else:
            do_export()


class FEReAssist(ida_kernwin.action_handler_t):
    """
    提供一些逆向辅助工具
    """

    def __init__(self):
        ida_kernwin.action_handler_t.__init__(self)

    def show_menu(self):
        main = FEReAssistForm()
        main.Compile()
        main.Execute()

    @FELogger.reload
    def activate(self, ctx):
        self.show_menu()

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS

```

`firmeye/regs.py`:

```py
# -*- coding: utf-8 -*-

class RegisterSet():
    """
    定义通用寄存器结构
    """

    def __init__(self, pc=None, stack=None, frame=None, flags=None,
            flagsr=None, common=tuple(), args=tuple(), ret=None):
        self.pc = pc
        self.common = common
        self.stack = stack
        self.frame = frame
        self.flags = flags
        self.flagsr = flagsr
        self.args = args
        self.all = list(filter(None, common + (pc, stack, frame, flagsr)))
        self.ret = ret

    def __len__(self):
        return len(self.all)

    def __iter__(self):
        for reg in self.all:
            yield reg

x86_flags = ('ID', 'VIP', 'VIF', 'AC', 'VM', 'RF', 'NT', 'IOPL', 'OF',
             'DF', 'IF', 'TF', 'SF', 'ZF', 'AF', 'PF', 'CF')

x86_regset = RegisterSet(
    pc     = 'EIP',
    frame  = 'EBP',
    stack  = 'ESP',
    flags  = x86_flags,
    flagsr = 'EFL',
    common = ('EAX', 'EBX', 'ECX', 'EDX', 'ESI', 'EDI'),
    ret    = 'EAX'
)

x64_regset = RegisterSet(
    pc     = 'RIP',
    frame  = 'RBP',
    stack  = 'RSP',
    flags  = x86_flags,
    flagsr = 'EFL',
    args   = ('RDI', 'RSI', 'RDX', 'RCX', 'R8', 'R9'),
    common = ('RAX', 'RBX', 'RCX', 'RDX', 'RDI', 'RSI',
              'R8', 'R9', 'R10', 'R11', 'R12', 'R13', 'R14', 'R15'),
    ret    = 'RAX'
)

arm_regset = RegisterSet(
    pc     = 'PC',
    stack  = 'SP',
    flags  = ('N', 'Z', 'C', 'V', 'Q', 'IT2', 'J', 'GE', 'IT', 'E',
              'A', 'I', 'F', 'T', 'MODE'),
    flagsr = 'PSR',
    args   = ('R0', 'R1', 'R2', 'R3'),
    common = tuple('R%i' % i for i in range(13)) + ('LR',),
    ret    = 'R0'
)

aarch64_regset = RegisterSet(
    pc     = 'PC',
    stack  = 'SP',
    flagsr = 'PSR',
    common = tuple('X%i' % i for i in range(31)) + ('LR',),
    args   = ('X0', 'X1', 'X2', 'X3'),
    ret    = 'X0'
)

mips_regset = RegisterSet(
    pc     = 'PC',
    frame  = 'FP',
    stack  = 'SP',
    common = ('V0', 'V1', 'A0', 'A1', 'A2', 'A3', 'T0', 'T1', 'T2', 'T3', 'T4', 'T5',
              'T6', 'T7', 'T8', 'T9', 'S0', 'S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7'),
    args   = ('A0', 'A1', 'A2', 'A3'),
    ret    = 'A0'
)

```

`firmeye/test.py`:

```py
# -*- coding: utf-8 -*-

import ida_funcs
import ida_kernwin
import idautils

from firmeye.utility import FEArgsTracer
from firmeye.helper import hexstr
from firmeye.logger import FELogger


class FEFuncTestForm(ida_kernwin.Form):

    def __init__(self):
        ida_kernwin.Form.__init__(self, """STARTITEM 0
Functional Test
DFS测试（从某地址回溯某寄存器）：
<##测试:{btn_dfs_test_1}>
DFS测试（从某函数所有调用地址回溯某寄存器）：
<##测试:{btn_dfs_test_2}>
""", {
    'btn_dfs_test_1': ida_kernwin.Form.ButtonInput(self.btn_dfs_test_1),
    'btn_dfs_test_2': ida_kernwin.Form.ButtonInput(self.btn_dfs_test_2)
})

    def btn_dfs_test_1(self, code=0):
        addr_t = ida_kernwin.ask_str('', 0, '请输入回溯起点地址')
        reg_t = ida_kernwin.ask_str('', 0, '请输入回溯寄存器')
        if (addr_t and addr_t != '') and (reg_t and reg_t != ''):
            try:
                addr_t = int(addr_t, 16)
            except Exception:
                FELogger.warn("无效地址")
                return

            FELogger.info("从地址%s回溯寄存器%s" % (hexstr(addr_t), reg_t))
            tracer = FEArgsTracer(addr_t, reg_t)
            source_addr = tracer.run()
            print('source_addr: ', source_addr)
        else:
            FELogger.warn("请输入起点地址和寄存器")

    def btn_dfs_test_2(self, code=0):
        tgt_t = ida_kernwin.ask_str('', 0, '请输入函数名')
        reg_t = ida_kernwin.ask_str('', 0, '请输入回溯寄存器')
        if (tgt_t and tgt_t != '') and (reg_t and reg_t != ''):
            for func_addr_t in idautils.Functions():
                func_name_t = ida_funcs.get_func_name(func_addr_t)
                if func_name_t == tgt_t:
                    for xref_addr_t in idautils.CodeRefsTo(func_addr_t, 0):
                        if ida_funcs.get_func(xref_addr_t):
                            FELogger.info("从地址%s回溯寄存器%s" % (hexstr(xref_addr_t), reg_t))
                            tracer = FEArgsTracer(xref_addr_t, reg_t, max_node=256)
                            source_addr = tracer.run()
                            print('source_addr: ', source_addr)
                    break
            else:
                FELogger.warn("请输入函数名和寄存器")


class FEFuncTest(ida_kernwin.action_handler_t):
    """功能测试器
    DFS寄存器回溯测试
    """

    def __init__(self):
        ida_kernwin.action_handler_t.__init__(self)

    def show_menu(self):
        main = FEFuncTestForm()
        main.Compile()
        main.Execute()

    @FELogger.reload
    def activate(self, ctx):
        self.show_menu()

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS

```

`firmeye/tools/__init__.py`:

```py
# -*- coding: utf-8 -*-

```

`firmeye/tools/checksec.py`:

```py
# -*- coding: utf-8 -*-

import lief


class Checksec():
    """
    检查 ELF 的保护机制
    """

    def __init__(self, elfpath):
        self.path = elfpath
        self.binary = lief.parse(elfpath)

        self.sec = {
            "RELRO": {
                'Full': "Full RELRO",
                'Partial': "Partial RELRO",
                None: "No RELRO"
            }[self.check_relro],
            "Canary": {
                True: "Canary found",
                False: "No canary found"
            }[self.check_canary],
            "NX": {
                True: "NX enabled",
                False: "NX disabled"
            }[self.check_nx],
            "PIE": {
                True: "PIE enabled",
                False: "No PIE (%#x)" % self.binary.header.entrypoint
            }[self.check_pie],
            "FORTIFY": {
                True: "FORTIRY enabled",
                False: "FORTIRY disabled"
            }[self.check_fortify],
        }

    @property
    def check_relro(self):
        """
        ELF Specification: https://refspecs.linuxbase.org/elf/elf.pdf
        page 81: https://refspecs.linuxbase.org/elf/elf.pdf#page=81
        DT_BIND_NOW: https://refspecs.linuxbase.org/elf/elf.pdf#page=81
        PT_GNU_RELRO: https://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic.html#PROGHEADER
        DF_BIND_NOW: http://refspecs.linuxbase.org/elf/gabi4+/ch5.dynamic.html#df_bind_now
        """
        if not any('GNU_RELRO' in str(s.type) for s in self.binary.segments):
            return None

        dynamic = self.binary.get_section('.dynamic')
        if dynamic:
            for entry in self.binary.dynamic_entries:
                if entry.tag == lief.ELF.DYNAMIC_TAGS.FLAGS \
                            and entry.value == lief.ELF.DYNAMIC_FLAGS.BIND_NOW.__int__():
                    return "Full"

        return "Partial"

    @property
    def check_canary(self):
        if self.binary.has_symbol('__stack_chk_fail'):
            return True
    
        for r in self.binary.pltgot_relocations:
            if r.symbol.name == '__stack_chk_fail':
                return True

        return False

    @property
    def check_pie(self):
        return self.binary.is_pie

    @property
    def check_nx(self):
        """
        https://github.com/torvalds/linux/blob/v4.9/fs/binfmt_elf.c#L784-L789
        https://github.com/torvalds/linux/blob/v4.9/fs/binfmt_elf.c#L849-L850
        """
        #if self.binary.header.file_type != lief.ELF.E_TYPE.EXECUTABLE:
        #    return True
        for s in self.binary.segments:
            if "GNU_STACK" in str(s.type):
                if s.has(lief.ELF.SEGMENT_FLAGS.X):
                    return False

        return True

    @property
    def check_fortify(self):
        for r in self.binary.pltgot_relocations:
            if r.symbol.name.endswith == '_chk':
                return True

        return False

```

`firmeye/tools/hexrayshelper.py`:

```py
# -*- coding: utf-8 -*-
# https://github.com/patois/HRDevHelper

import re
import os

import idaapi
import ida_pro
import ida_hexrays
import ida_kernwin
import ida_lines
import ida_graph
import ida_moves
import ida_lines

"""
from firmeye.config import THEME
if THEME == "default":
    from firmeye.view.colors import graph_default as graph_color
elif THEME == "dark":
    from firmeye.view.colors import graph_dark as graph_color
"""
PLUGIN_NAME = "HexraysHelper"

CONFIG = {
    'options':
        {
            'center': True,     # 当前 node 居中
            'zoom': 1.0,        # 1.0 = 100%
            'dockpos': ida_kernwin.DP_RIGHT
        },
    'frame':
        {
            'default': 0x000000,
            'focus': 0xe1ad32,
            'highlight': 0x1baeff
        },
    'node':
        {
            'loop': 0x333366,
            'call': 0x502020,
            'cit': 0x000000,
            'cot': 0x222222
        },
    'text':
        {
            'default': ida_lines.SCOLOR_DEFAULT,
            'highlight': ida_lines.SCOLOR_EXTRA
        }
}

def get_obj_ids(vdui, lnnum):
    obj_ids = []
    pc = vdui.cfunc.get_pseudocode()
    if lnnum >= len(pc):
        return obj_ids
    line = pc[lnnum].line
    tag = ida_lines.COLOR_ON + chr(ida_lines.COLOR_ADDR)
    pos = line.find(tag)
    while pos != -1 and len(line[pos+len(tag):]) >= ida_lines.COLOR_ADDR_SIZE:
        addr = line[pos+len(tag):pos+len(tag)+ida_lines.COLOR_ADDR_SIZE]
        idx = int(addr, 16)
        a = ida_hexrays.ctree_anchor_t()
        a.value = idx
        if a.is_valid_anchor() and a.is_citem_anchor():
            item = vdui.cfunc.treeitems.at(a.get_index())
            if item:
                obj_ids.append(item.obj_id)
        pos = line.find(tag, pos+len(tag)+ida_lines.COLOR_ADDR_SIZE)
    return obj_ids

def get_selected_lines(vdui):
    vdui.get_current_item(ida_hexrays.USE_KEYBOARD)
    line_numbers = []
    w = vdui.ct
    p0 = ida_kernwin.twinpos_t()
    p1 = ida_kernwin.twinpos_t()
    if ida_kernwin.read_selection(w, p0, p1):
        place0 = p0.place(w)
        place1 = p1.place(w)
        a = place0.as_simpleline_place_t(place0).n
        b = place1.as_simpleline_place_t(place1).n
        line_numbers = [i for i in range(a, b+1)]
    else:
        line_numbers = [vdui.cpos.lnnum]
    return line_numbers


class vd_hooks_t(ida_hexrays.Hexrays_Hooks):
    def __init__(self, cg):
        ida_hexrays.Hexrays_Hooks.__init__(self)
        self.cg = cg

    def create_hint(self, vd):
        if vd.get_current_item(ida_hexrays.USE_MOUSE):
            lnnum = vd.cpos.lnnum
            if lnnum < vd.cfunc.hdrlines:
                return 0

            lines = []
            title = "%s:" % PLUGIN_NAME
            sep = 30*"-"
            indent = 2*" "
            
            item = vd.item.it
            op = item.op
            is_expr = item.is_expr()
            item_type = ida_hexrays.get_ctype_name(op)
            item_ea = item.ea
            lines.append("%s" % title)
            lines.append("%s" % (len(title)*"="))
            if is_expr:
                name = item.cexpr.print1(None)
                #name = ida_lines.tag_remove(name)
                #name = ida_pro.str2user(name)
                lines.append("%sitem:\t%s" % (indent, name))
            lines.append("%stype:\tc%ct_%s" % (
                indent,
                "o" if is_expr else "i",
                item_type))
            lines.append("%sea:\t%x" % (indent, item_ea))
            lines.append("%s" % sep)
            lines.append("")
            
            custom_hints = "\n".join(lines)
            return (2, custom_hints, len(lines))
        return 0

    def refresh_pseudocode(self, vu):
        """
        刷新伪代码
        """
        self.cg.update(cfunc=vu.cfunc, focus=None)
        return 0

    def curpos(self, vu):
        # 游标改变时，修改高亮块
        if self.cg:
            objs = []
            line_numbers = get_selected_lines(vu)
            for n in line_numbers:
                objs += get_obj_ids(vu, n)
            focusitem = vu.item.e if vu.item.is_citem() else None
            self.cg.update(cfunc=None, objs=objs, focus=focusitem.obj_id if focusitem else None)
        return 0


class cfunc_graph_t(ida_graph.GraphViewer):
    def __init__(self, focus, config, close_open=False):
        self.title = PLUGIN_NAME
        ida_graph.GraphViewer.__init__(self, self.title, close_open)

        self.center_node = config["options"]["center"]

        self.COLOR_FRAME_DEFAULT = config["frame"]["default"]
        self.COLOR_FRAME_HIGHLIGHT = config["frame"]["highlight"]
        self.COLOR_FRAME_FOCUS = config["frame"]["focus"]

        self.COLOR_NODE_CIT_LOOP = config["node"]["loop"]
        self.COLOR_NODE_COT_CALL = config["node"]["call"]
        self.COLOR_NODE_CIT = config["node"]["cit"]
        self.COLOR_NODE_COT = config["node"]["cot"]

        self.COLOR_TEXT_DEFAULT = config["text"]["default"]
        self.COLOR_TEXT_HIGHLIGHT = config["text"]["highlight"]

        self.items = [] # list of citem_t
        self._set_focus(focus)

        self.objs = []
        self.succs = [] # list of lists of next nodes
        self.preds = [] # list of lists of previous nodes

        self.vd_hooks = vd_hooks_t(self)
        self.vd_hooks.hook()

    def reinit(self):
        self.items = []
        self.succs = []
        self.preds = []
        self.Clear()

    def add_node(self):
        n = self._size()

        def resize(array, new_size):
            if new_size > len(array):
                while len(array) < new_size:
                    array.append([])
            else:
                array = array[:new_size]
            return array

        self.preds = resize(self.preds, n+1)
        self.succs = resize(self.succs, n+1)
        return n

    def add_edge(self, x, y):
        self.preds[y].append(x)
        self.succs[x].append(y)

    def zoom_and_dock(self, vu_title, zoom, dock_position=None):
        widget = ida_kernwin.find_widget(self.title)
        if widget and dock_position:
            gli = ida_moves.graph_location_info_t()
            if ida_graph.viewer_get_gli(gli, widget):
                gli.zoom = zoom
                ida_graph.viewer_set_gli(widget, gli)
            ida_kernwin.set_dock_pos(self.title, vu_title, dock_position)
            self.Refresh()

    def update(self, cfunc=None, objs=None, focus=None):
        if cfunc:
            gb = graph_builder_t(self)
            gb.apply_to(cfunc.body, None)
        self._set_focus(focus)
        self._set_objs(objs)
        self.Refresh()
        return

    def _set_focus(self, focus):
        self.focus = focus

    def _set_objs(self, objs):
        self.objs = objs

    def _nsucc(self, n):
        return len(self.succs[n]) if self._size() else 0

    def _npred(self, n):
        return len(self.preds[n]) if self._size() else 0

    def _succ(self, n, i):
        return self.succs[n][i]

    def _pred(self, n, i):
        return self.preds[n][i]

    def _size(self):
        return len(self.preds)

    def _get_expr_name(self, expr):
        name = expr.print1(None)
        name = ida_lines.tag_remove(name)
        name = ida_pro.str2user(name)
        return name

    def _get_node_label(self, n, highlight_node=False):
        item = self.items[n]
        op = item.op
        insn = item.cinsn
        expr = item.cexpr
        type_name = ida_hexrays.get_ctype_name(op)
        parts = []
        if op == ida_hexrays.cot_ptr:
            parts.append("%s.%d" % (type_name, expr.ptrsize))
        elif op == ida_hexrays.cot_memptr:
            parts.append("%s.%d (m=%d)" % (type_name, expr.ptrsize, expr.m))
        elif op == ida_hexrays.cot_memref:
            parts.append("%s (m=%d)" % (type_name, expr.m,))
        elif op in [
                ida_hexrays.cot_obj,
                ida_hexrays.cot_var]:
            name = self._get_expr_name(expr)
            parts.append("%s.%d %s" % (type_name, expr.refwidth, name))
        elif op in [
                ida_hexrays.cot_num,
                ida_hexrays.cot_helper,
                ida_hexrays.cot_str]:
            name = self._get_expr_name(expr)
            parts.append("%s %s" % (type_name, name,))
        elif op == ida_hexrays.cit_goto:
            parts.append("%s LABEL_%d" % (type_name, insn.cgoto.label_num))
        elif op == ida_hexrays.cit_asm:
            parts.append("%s <asm statements; unsupported ATM>" % type_name)
        else:
            parts.append("%s" % type_name)

        parts.append("ea: %08x" % item.ea)
        if item.is_expr() and not expr.type.empty():
            tstr = expr.type._print()
            parts.append(tstr if tstr else "?")
        scolor = self.COLOR_TEXT_HIGHLIGHT if highlight_node else self.COLOR_TEXT_DEFAULT
        parts = [ida_lines.COLSTR("%s" % part, scolor) for part in parts]
        return "\n".join(parts)

    def _get_node_info(self, n):
        item = self.items[n]
        color = 0
        focus_node = False
        highlight_node = False

        # 判断该 node 是否属于当前伪代码行
        if self.objs is not None and item.obj_id in self.objs:
            highlight_node = True

        if self.focus is not None and item.obj_id == self.focus:
            focus_node = True

        # 处理 COT_
        if item.is_expr():
            # 处理 call 调用
            if item.op == ida_hexrays.cot_call:
                color = self.COLOR_NODE_COT_CALL
            else:
                color = self.COLOR_NODE_COT
        # 处理 CIT_
        elif ida_hexrays.is_loop(item.op):
            color = self.COLOR_NODE_CIT_LOOP
        else:
            color = self.COLOR_NODE_CIT

        return (focus_node, highlight_node, color)

    def OnViewKeydown(self, key, state):
        c = chr(key & 0xFF)

        if c == 'C':
            self.center_node = not self.center_node
            ida_kernwin.msg("%s: centering graph %sabled\n" % (PLUGIN_NAME, "en" if self.center_node else "dis"))
        return True

    def OnClose(self):
        if self.vd_hooks:
            self.vd_hooks.unhook()

    def OnRefresh(self):
        """
        @return: 返回 True 告诉 graph viewer 使用新的 items
        """

        self.nodes = {}
        self.Clear()

        # nodes
        for n in range(len(self.items)):
            item = self.items[n]
            focus_node, highlight_node, color = self._get_node_info(n)
            node_label = self._get_node_label(n, highlight_node=highlight_node)
            nid = self.AddNode((node_label, color))

            framecol = self.COLOR_FRAME_DEFAULT
            if highlight_node:
                framecol = self.COLOR_FRAME_HIGHLIGHT
            if focus_node:
                framecol = self.COLOR_FRAME_FOCUS

            p = idaapi.node_info_t()            
            p.frame_color = framecol
            self.SetNodeInfo(nid, p, idaapi.NIF_FRAME_COLOR)
            self.nodes[item.obj_id] = nid

            if self.center_node and focus_node:
                widget = ida_kernwin.find_widget(self._title)
                ida_graph.viewer_center_on(widget, nid)

        # edges
        for n in range(len(self.items)):
            item = self.items[n]

            for i in range(self._nsucc(n)):
                t = self._succ(n, i)
                self.AddEdge(self.nodes[item.obj_id], self.nodes[self.items[t].obj_id])

        return True

    def OnGetText(self, node_id):
        return self[node_id]
    
    def OnDblClick(self, node_id):
        ida_kernwin.jumpto(self.items[node_id].ea)
        return True

    def OnHint(self, node_id):
        return self._get_node_label(node_id)


class graph_builder_t(ida_hexrays.ctree_parentee_t):

    def __init__(self, cg):
        ida_hexrays.ctree_parentee_t.__init__(self)
        self.init(cg)

    def init(self, cg):
        self.cg = cg
        self.cg.reinit()
        self.reverse = {} # citem_t -> node#

    def _add_node(self, i):
        for k_obj_id in self.reverse.keys():
            if i.obj_id == k_obj_id:
                ida_kernwin.warning("bad ctree - duplicate nodes! (i.ea=%x)" % i.ea)
                return -1

        n = self.cg.add_node()
        if n <= len(self.cg.items):
            self.cg.items.append(i)
        self.cg.items[n] = i
        self.reverse[i.obj_id] = n
        return n

    def _process(self, i):
        n = self._add_node(i)
        if n < 0:
            return n
        if len(self.parents) > 1:
            lp = self.parents.back().obj_id
            for k_obj_id, v in self.reverse.items():
                if k_obj_id == lp:
                    p = v
                    break
            self.cg.add_edge(p, n)
        return 0

    def visit_insn(self, i):
        return self._process(i)

    def visit_expr(self, e):
        return self._process(e)

def get_ctree_graph(ea):
    """
    在当前反编译窗口中创建当前函数的 ctree 图
    """

    vu = ida_hexrays.open_pseudocode(ea, 0)
    w = ida_kernwin.get_current_widget()
    vu_title = ida_kernwin.get_widget_title(w)

    vu.get_current_item(ida_hexrays.USE_KEYBOARD)
    focusitem = vu.item.e if vu.item.is_citem() else None

    # 创建 graphviewer
    cg = cfunc_graph_t(focusitem, CONFIG, close_open=True)
    # 为当前函数创建图像
    gb = graph_builder_t(cg)
    gb.apply_to(vu.cfunc.body, None)
    # 显示图像
    cg.Show()
    # 设置窗口位置
    cg.zoom_and_dock(vu_title, CONFIG["options"]["zoom"], CONFIG["options"]["dockpos"])

```

`firmeye/tools/idapyhelper.py`:

```py
# -*- coding: utf-8 -*-
# https://github.com/patois/IDAPyHelper

import os
import inspect

import ida_kernwin
import ida_diskio


class FileViewer(ida_kernwin.Form):
    """
    文件内容显示
    """

    def __init__(self, title, content):
        ida_kernwin.Form.__init__(self,
("BUTTON YES NONE\n"
"BUTTON NO NONE\n"
"BUTTON CANCEL NONE\n"
"%s\n\n"
"<##Docstring##:{cbEditable}>"
) % title,
{'cbEditable': ida_kernwin.Form.MultiLineTextControl(text=content,
    flags=ida_kernwin.textctrl_info_t.TXTF_READONLY |
    ida_kernwin.textctrl_info_t.TXTF_FIXEDFONT)})


class DocstringViewer(ida_kernwin.Form):
    """
    字符串显示
    """

    def __init__(self, title, docstr):
        ida_kernwin.Form.__init__(self,
("BUTTON YES NONE\n"
"BUTTON NO NONE\n"
"BUTTON CANCEL NONE\n"
"%s\n\n"
"<##Docstring##:{cbEditable}>"
) % title,
{'cbEditable': ida_kernwin.Form.MultiLineTextControl(text=docstr,
    flags=ida_kernwin.textctrl_info_t.TXTF_READONLY |
    ida_kernwin.textctrl_info_t.TXTF_FIXEDFONT)})


class ChooserData:
    """
    Chooser数据结构
    """

    icon_ids = {"str": 80, "int": 8, "class": 89, "function": 81, "method": 99}
    def __init__(self, mod_name, sym_name, file_name):
        self.mod_name = mod_name
        self.sym_name = sym_name
        self.file_name = file_name
        self.doc_str = ""
        self.sym_type = ""
        self.sym_value = ""
        self.line_no = ""

    def get_icon(self):
        return self.icon_ids[self.sym_type]


class PyHelperChooser(ida_kernwin.Choose):
    """
    Chooser
    """

    def __init__(self, title, nb=5):
        cols = [["模块", 10 | ida_kernwin.Choose.CHCOL_PLAIN],
                ["符号", 20 | ida_kernwin.Choose.CHCOL_PLAIN],
                ["文档", 10 | ida_kernwin.Choose.CHCOL_PLAIN],
                ["类型", 10 | ida_kernwin.Choose.CHCOL_PLAIN],
                ["取值", 10 | ida_kernwin.Choose.CHCOL_HEX],
                ["行号", 10 | ida_kernwin.Choose.CHCOL_DEC]]

        ida_kernwin.Choose.__init__(self,
            title=title, cols=cols, flags=ida_kernwin.Choose.CH_QFLT | ida_kernwin.Choose.CH_NOIDB
        )

        self.items = []
        self.icon = 0
        self.build_items()

    def build_items(self):
        pydir = ida_diskio.idadir(os.path.join("python", "3"))
        for mod_name in os.listdir(pydir):
            if mod_name.endswith(".py"):
                mod_name, _ = os.path.splitext(mod_name)
                if mod_name in ["init", "idaapi"]:
                    continue
                else:
                    mod = __import__(mod_name)
                    file_name = mod.__file__
                    for sym_name, obj in inspect.getmembers(mod):
                        data = ChooserData(mod_name, sym_name, file_name)
                        if inspect.isfunction(obj):
                            data.sym_type = "function"
                            data.line_no = "%d" % obj.__code__.co_firstlineno
                            data.doc_str = inspect.getdoc(obj)
                        elif inspect.isclass(obj):
                            data.sym_type = "class"
                            data.doc_str = inspect.getdoc(obj)
                        elif inspect.ismethod(obj):
                            data.sym_type = "method"
                            data.line_no = "%d" % obj.im_func.__code__.co_firstlineno
                            data.doc_str = inspect.getdoc(obj)
                        elif type(obj) == int:
                            data.sym_type = "int"
                            data.sym_value = "0x%x" % (obj)
                        elif type(obj) == str:
                            data.sym_type = "str"
                            data.sym_value = str(obj)
                        else:
                            ida_kernwin.msg("未知符号 %s - %s" % (type(obj), sym_name))
                            continue
                        self.items.append(data)
            else:
                continue

    def OnGetLine(self, n):
        d = self.items[n]
        data = [d.mod_name, d.sym_name, "%s"%d.doc_str, d.sym_type, d.sym_value, d.line_no]
        return data

    def OnGetIcon(self, n):
        return self.items[n].get_icon()

    def OnGetSize(self):
        return len(self.items)

    def OnSelectLine(self, n):
        data = self.items[n]
        postfix = " (%s)" % data.mod_name if len(data.mod_name) else ""
        if not data.doc_str:
            ida_kernwin.msg("文档不存在 \"%s\"\n" % data.sym_name)
        else:
            f = DocstringViewer("%s%s" % (data.sym_name, postfix), data.doc_str)
            f.modal = False
            f.openform_flags = ida_kernwin.PluginForm.WOPN_TAB
            f, _ = f.Compile()
            f.Open()
        return (ida_kernwin.Choose.NOTHING_CHANGED, )

    def OnEditLine(self, n):
        fn = self.items[n].file_name
        if fn:
            if fn.endswith(".pyc"):
                fn = fn[:-1]
            with open(fn) as fin:
                f = FileViewer("%s" % (os.path.basename(fn)), fin.read())
                f.modal = False
                f.openform_flags = ida_kernwin.PluginForm.WOPN_TAB
                f, _ = f.Compile()
                f.Open()
        return (ida_kernwin.Choose.NOTHING_CHANGED, )            

```

`firmeye/utility.py`:

```py
# -*- coding: utf-8 -*-

import re
from functools import reduce

import idc
import ida_bytes
import ida_ua
import ida_funcs
import ida_nalt
import ida_gdl
import ida_xref
import ida_segment
import ida_idaapi
import idautils

from firmeye.config import SINK_FUNC, INST_LIST, SOURCE_FUNC
from firmeye.logger import FELogger
from firmeye.helper import hexstr, name_to_addr, get_mnem


class FESinkFuncMgr():
    """sink函数管理器
    提供获取sink函数的调用地址和交叉引用信息的工具函数
    sink_func_info: 默认存储sink函数全局配置信息
    """

    def __init__(self, sink_func_info=SINK_FUNC):
        self.sink_func_info = sink_func_info

    def gen_sink_func_addr(self):
        for func_addr in idautils.Functions():
            func_name = ida_funcs.get_func_name(func_addr)
            if func_name in self.sink_func_info:
                yield (func_name, func_addr)
            else:
                continue

    def gen_func_xref(self, func_addr):
        for xref_addr in idautils.CodeRefsTo(func_addr, 0):
            if ida_funcs.get_func(xref_addr):
                yield xref_addr
            else:
                continue

    def get_func_xref(self, func_addr):
        return [xref_addr for xref_addr in self.gen_func_xref(func_addr)]

    def gen_sink_func_xref(self):
        for func_name, func_addr in self.gen_sink_func_addr():
            yield (func_name, self.get_func_xref(func_addr))

    def get_one_func_xref(self, func_name):
        for func_addr in idautils.Functions():
            func_name_t = ida_funcs.get_func_name(func_addr)
            if func_name == func_name_t:
                return self.get_func_xref(func_addr)
            else:
                continue


class FEArgsTracer():
    """参数回溯器
    基于DFS提供寄存器回溯功能
    addr: 回溯起始地址
    reg: 回溯寄存器
    max_node: 最大回溯节点数
    """

    def __init__(self, addr, reg, max_node=1024):
        self.trace_addr = addr
        self.trace_reg = reg

        self.init_tree()
        self.init_cache()
        self.init_blk_cfg()

        self.max_node = max_node

    def init_blk_cfg(self):
        """
        初始化基本块CFG
        """
        func_t = ida_funcs.get_func(self.trace_addr)
        if func_t:
            self.cfg = ida_gdl.FlowChart(func_t)
        else:
            self.cfg = []

    def get_blk(self, addr):
        """
        获取addr所在的基本块
        """
        for blk in self.cfg:
            if blk.start_ea <= addr and addr < blk.end_ea:
                return blk
        return None

    def create_tree_node(self, addr, prev=None):
        """
        创建树节点
        """
        return {
            'addr': addr,
            'prev': prev,
        }

    def init_tree(self):
        """
        初始化回溯树
        """
        self.tree = self.create_tree_node(self.trace_addr)

    def push_cache_node(self, addr, key):
        """
        将节点地址添加到缓存列表
        """
        if key in self.cache:
            self.cache['all_node'].add(addr)
            if addr not in self.cache[key]:
                self.cache[key].add(addr)
                return True
        return False

    def init_cache(self):
        """
        初始化缓存列表，记录回溯过程中经过的节点地址
        """
        self.cache = {'addr': set(), 'all_node': set()}
        for r in ['R'+str(i) for i in range(16)]:
            self.cache.update({r: set()})

    def parse_operands(self, mnem, tar_addr):
        """
        提取块拷贝指令（LDM/STM）涉及的寄存器
        # TODO 有待改进
        """

        regs = []
        if mnem.startswith('LDM') or mnem.startswith('STM'):
            op2 = idc.print_operand(tar_addr, 1).strip('{}')
            for item in op2.split(','):
                if '-' in item:
                    [a, b] = re.findall(r"\d+\.?\d*", item)
                    a, b = int(a), int(b)
                    for i in range(b - a + 1):
                        regs.append("R" + str(a + i))
                else:
                    regs.append(item)

        if mnem.startswith('LDR') or mnem.startswith('STR') or mnem.startswith('VLDR'):
            op2 = idc.print_operand(tar_addr, 1).strip('[]')
            for item in op2.split(','):
                item = item.strip('[]')
                if 'R' in item or 'SP' in item:
                    regs.append(item)

        return regs

    def get_next_reg(self, addr, reg):
        """
        寻找下一个赋值来源寄存器
        返回寄存器名或None
        """

        reg_t = reg
        addr_t = addr

        mnem = get_mnem(addr_t)
        line = idc.generate_disasm_line(addr_t, 0)
        if mnem.startswith('BLX') and addr_t != self.trace_addr:
            FELogger.info("途径函数\t"+hexstr(addr)+"\t"+line)
            func_name = idc.print_operand(addr_t, 0)
            func_addr = name_to_addr(func_name)
            if func_addr is not None:
                if reg_t == 'R0':
                    does_return = ida_funcs.get_func(func_addr).does_return()
                    if does_return == True:
                        FELogger.info("找到赋值点\t"+hexstr(addr)+"\t"+line)
                        return None
                else:
                    if func_name in SOURCE_FUNC and reg_t == SOURCE_FUNC[func_name]['dest']:
                        reg_t = SOURCE_FUNC[func_name]['src']
                        if reg_t == 'None':
                            FELogger.info("找到赋值点\t"+hexstr(addr)+"\t"+line)
                            return None
                        else:
                            FELogger.info("回溯"+reg_t+"\t"+hexstr(addr)+"\t"+line)

        inst_list_t = INST_LIST
        reg_re = re.compile(reg_t + '\\D|' + reg_t + '\\Z')
        if reg_re.search(line):
            if mnem in reduce(lambda x, y: x + y, [value for value in inst_list_t.values()]):
                op1 = idc.print_operand(addr_t, 0).split("!")[0]
                if mnem in inst_list_t['load_multi']:
                    # 找到      LDM R1, {R0-R3}
                    regs = self.parse_operands(mnem, addr_t)
                    if reg_t not in regs:
                        FELogger.info("回溯"+reg_t+"\t"+hexstr(addr)+"\t"+line)
                    else:
                        FELogger.info("找到赋值点\t"+hexstr(addr)+"\t"+line)
                        return None
                else:
                    if op1 != reg_t or mnem in inst_list_t['other']:
                        FELogger.info("回溯"+reg_t+"\t"+hexstr(addr)+"\t"+line)
                    elif mnem in inst_list_t['arithmetic']:
                        # 停止      ADD R0, SP; ADD R0, SP, #10
                        # 回溯R0    ADD R0, R1; ADD R0, #10
                        # 回溯R1    ADD R0, R1, #10; ADD R0, R1, R2
                        op2_tmp = idc.print_operand(addr_t, 1)
                        if idc.get_operand_type(addr_t, 2) == ida_ua.o_void:
                            if idc.get_operand_type(addr_t, 1) == ida_ua.o_reg:
                                if op2_tmp == 'SP':
                                    FELogger.info("取消回溯SP\t"+hexstr(addr)+"\t"+line)
                                    return None
                                else:
                                    FELogger.info("回溯"+reg_t+"\t"+hexstr(addr)+"\t"+line)
                            else:
                                FELogger.info("回溯"+reg_t+"\t"+hexstr(addr)+"\t"+line)
                        elif idc.get_operand_type(addr_t, 3) == ida_ua.o_void:
                            op3_tmp = idc.print_operand(addr_t, 2)
                            if op2_tmp == 'SP' or op3_tmp == 'SP':
                                FELogger.info("取消回溯SP\t"+hexstr(addr)+"\t"+line)
                                return None
                            elif reg_t == op2_tmp or reg_t == op3_tmp:
                                FELogger.info("复杂运算\t"+hexstr(addr)+"\t"+line)
                                return None
                            else:
                                reg_t = op2_tmp
                                FELogger.info("回溯"+reg_t+"\t"+hexstr(addr)+"\t"+line)
                        else:
                            op3_tmp = idc.print_operand(addr_t, 2)
                            op4_tmp = idc.print_operand(addr_t, 3)
                            if op2_tmp == 'SP' or op3_tmp == 'SP' or op4_tmp == 'SP':
                                FELogger.info("取消回溯SP\t"+hexstr(addr)+"\t"+line)
                                return None
                            elif reg_t == op2_tmp or reg_t == op3_tmp or reg_t == op4_tmp:
                                FELogger.info("复杂运算\t"+hexstr(addr)+"\t"+line)
                                return None
                            else:
                                reg_t = op2_tmp
                                FELogger.info("回溯"+reg_t+"\t"+hexstr(addr)+"\t"+line)
                    elif mnem in inst_list_t['move']:
                        # 停止      MOV R0, SP; MOV R0, SP, #10
                        # 找到      MOV R0, #10
                        # 回溯R1    MOV R0, R1
                        # 回溯D8    VMOV R0, R1, D16
                        if mnem.startswith('VMOV'):
                            op3_tmp = idc.print_operand(addr_t, 2)
                            reg_t = op3_tmp
                            FELogger.info("回溯"+reg_t+"\t"+hexstr(addr)+"\t"+line)
                        else:
                            op2_tmp = idc.print_operand(addr_t, 1)
                            if op2_tmp == 'SP':
                                FELogger.info("取消回溯SP\t"+hexstr(addr)+"\t"+line)
                                return None
                            elif idc.get_operand_type(addr_t, 1) == ida_ua.o_reg:
                                reg_t = op2_tmp
                                FELogger.info("回溯"+reg_t+"\t"+hexstr(addr)+"\t"+line)
                            elif mnem in ['MOVT', 'MOVTGT', 'MOVTLE']:
                                FELogger.info("回溯"+reg_t+"\t"+hexstr(addr)+"\t"+line)
                            else:
                                FELogger.info("找到赋值点\t"+hexstr(addr)+"\t"+line)
                                return None
                    elif mnem in inst_list_t['load']:
                        # 找到      LDR R0, =xxxxxxx
                        # 停止      LDR R0, [SP, #10]
                        # 回溯R1    LDR R0, [R1, #10]
                        # 回溯R0    LDR R0, [R0, R1, #10]
                        if idc.get_operand_type(addr_t, 1) == ida_ua.o_mem:
                            FELogger.info("找到赋值点\t"+hexstr(addr)+"\t"+line)
                            return None
                        else:
                            regs_tmp = self.parse_operands(mnem, addr_t)
                            if 'SP' in regs_tmp:
                                FELogger.info("取消回溯SP\t"+hexstr(addr)+"\t"+line)
                                return None
                            elif reg_t in regs_tmp:
                                FELogger.info("回溯"+reg_t+"\t"+hexstr(addr)+"\t"+line)
                            else:
                                reg_t = regs_tmp[0]
                                FELogger.info("回溯"+reg_t+"\t"+hexstr(addr)+"\t"+line)
                    else:
                        FELogger.info("未知指令\t"+hexstr(addr)+"\t"+line)
            else:
                FELogger.info("未知指令\t"+hexstr(addr)+"\t"+line)
        else:
            pass

        return reg_t

    def get_all_ref(self, addr):
        """
        获取所有引用到addr的地址
        """
        xref_t = []
        addr_t = ida_xref.get_first_cref_to(addr)
        while addr_t != ida_idaapi.BADADDR:
            xref_t.append(addr_t)
            addr_t = ida_xref.get_next_cref_to(addr, addr_t)
        return xref_t

    def get_node_nums(self):
        """
        获取已回溯节点数
        """
        return len(self.cache['all_node'])

    def set_color(self, addr, color_type):
        """
        设置指令背景色
        """
        ida_nalt.set_item_color(addr, color_type)

    def trace_handle(self, addr, reg):
        """
        处理回溯事件
        """
        next_addr = ida_bytes.prev_head(addr, 0)
        next_reg = self.get_next_reg(addr, reg)

        return (next_addr, next_reg)

    def trace_block(self, blk, node, reg):
        """
        在一个基本块内回溯
        """
        reg_t = reg
        cur_t = node['addr']
        while reg_t and cur_t >= blk.start_ea:
            cur_t, reg_t = self.trace_handle(cur_t, reg_t)

        return (ida_bytes.next_head(cur_t, ida_idaapi.BADADDR), reg_t)

    def trace_next(self, blk, node, reg):
        """
        下一轮回溯
        """
        for ref_addr in self.get_all_ref(blk.start_ea):
            block = self.get_blk(ref_addr)
            if block:
                FELogger.info("基本块跳转\t"+hexstr(ref_addr)+"\t"+idc.generate_disasm_line(ref_addr, 0))
                node_t = self.create_tree_node(ref_addr, prev=node)
                self.dfs(node_t, reg, block)

    def dfs(self, node, reg, blk):
        """深度优先搜索
        node: 当前节点
        reg: 回溯寄存器
        blk: 当前基本块
        """
        blk_t = blk
        if self.get_node_nums() < self.max_node:    # 避免路径爆炸
            if self.push_cache_node(node['addr'], reg): # 避免重复，加快速度
                cur_t, reg_t = self.trace_block(blk_t, node, reg)
                if reg_t:
                    # 如果返回一个新的寄存器，开启下一轮回溯
                    self.trace_next(blk_t, node, reg_t)
                else:
                    self.cache['addr'].add(cur_t)
            else:
                FELogger.info("该块已经回溯，取消操作")
        else:
            FELogger.info("超出最大回溯块数量")

    @FELogger.show_time_cost
    @FELogger.log_time
    def run(self):
        """
        启动回溯
        """
        trace_blk = self.get_blk(self.trace_addr)
        self.dfs(self.tree, self.trace_reg, trace_blk)
        return list(self.cache['addr'])


class FEStrMgr():
    """字符串管理器
    提供获取和解析字符串的功能
    minl: 定义字符串的最短长度
    """

    strings = {}    # 管理器初始化时进行缓存

    def __init__(self, minl=1):
        st_obj = idautils.Strings()
        st_obj.setup(minlen=minl)
        for string in st_obj:
            self.strings[string.ea] = str(string)

    @classmethod
    def get_string_from_mem(cls, addr):
        """
        从addr逐字节获取字符
        """

        string = ''
        chr_t = ida_bytes.get_wide_byte(addr)
        i = 0
        while chr_t != 0:
            chr_t = ida_bytes.get_wide_byte(addr+i)
            string += chr(chr_t)
            i += 1
        return string[:-1]

    @classmethod
    def get_mem_string(cls, addr):
        """
        获取内存中的字符串
        """

        addr_t = addr
        dref = idautils.DataRefsFrom(addr_t)
        strs = [cls.strings[x] for x in dref if x in cls.strings]

        # 处理几种特殊情况
        # LDR R1, =sub_xxxx
        # LDR R1, =loc_xxxx
        if idc.print_operand(addr, 1)[:5] in ['=sub_', '=loc_']:
            return []

        # LDR R1, =unk_53B4B6
        # .rodata:0053B4B6 http:
        # .rodata:0053B4BB //%s%s
        if strs != [] and strs[0].find('%') == -1:
            strs = []
            dref = idautils.DataRefsFrom(addr_t)
            for x in dref:
                segname = ida_segment.get_segm_name(ida_segment.getseg(x))
                if segname not in ['.text', '.bss']:
                    strs.append(cls.get_string_from_mem(x))

        # LDR R1, =(aFailedToGetAnI+0x22)
        # LDR R2, =(aSS - 0xCFA4)
        # ADD R2, PC, R2
        if strs == []:
            dref = idautils.DataRefsFrom(addr_t)
            for x in dref:
                segname = ida_segment.get_segm_name(ida_segment.getseg(x))
                if segname not in ['.text', '.bss']:
                    strs.append(cls.get_string_from_mem(x))
                elif len(list(idautils.DataRefsFrom(x))) == 0:
                    reg_t = idc.print_operand(addr_t, 0)
                    num1 = ida_bytes.get_wide_dword(x)
                    while get_mnem(addr_t) != 'ADD' or (idc.print_operand(addr_t, 0) != reg_t and idc.print_operand(addr_t, 1) != 'PC'):
                        addr_t = ida_bytes.next_head(addr_t, ida_idaapi.BADADDR)
                    num2 = addr_t + 8
                    addr_t = num1 + num2
                    strs.append(cls.get_string_from_mem(addr_t))

        # MOVW R1, #0x87B4
        # MOVT.W R1, #0x52
        if strs == [] and get_mnem(addr_t) == 'MOVW':
            reg_t = idc.print_operand(addr_t, 0)
            num1 = int(idc.print_operand(addr_t, 1).split('#')[1], 16)
            while get_mnem(addr_t) not in ['MOVTGT', 'MOVTLE', 'MOVT'] or idc.print_operand(addr_t, 0) != reg_t:
                addr_t = ida_bytes.next_head(addr_t, ida_idaapi.BADADDR)
            num2 = int(idc.print_operand(addr_t, 1).split('#')[1], 16)
            addr_t = (num2<<16) + num1
            strs.append(cls.get_string_from_mem(addr_t))

        return strs

    @classmethod
    def parse_format_string(cls, string):
        """
        解析格式字符串
        %[parameter][flags][field width][.precision][length]type
        """

        _type = ['d', 'i', 'u', 'f', 'F', 'e', 'E', 'g', 'G', 'x', 'X', 'o', 's', 'c', 'p', 'a', 'A', 'n']
        pattern = '.*?[%s]' % ''.join(_type)
        fmt_list = string.split("%")[1:]
        results = []
        for fmt in fmt_list:
            re_obj = re.search(pattern, fmt)
            if re_obj:
                results.append(re_obj.group())
        return results

```

`firmeye/view/__init__.py`:

```py
# -*- coding: utf-8 -*-

```

`firmeye/view/chooser.py`:

```py
# -*- coding: utf-8 -*-

import ida_kernwin

from firmeye.view.custviewer import CustViewer
from firmeye.helper import hexstr


class AnalysisChooseData():
    """
    显示结果数据结构
    """
    def __init__(self, vuln, name, ea, addr1=None, addr2=None, str1=None, str2=None, other1=None):
        self.vuln = vuln
        self.name = name
        self.ea = ea
        self.addr1 = addr1
        self.addr2 = addr2
        self.str1 = str1
        self.str2 = str2
        self.other1 = other1


class AnalysisChooser(ida_kernwin.Choose):
    """
    分析结果窗口选择器
    """
    def __init__(self, title, cols, item):
        ida_kernwin.Choose.__init__(self,
            title=title, cols=cols, flags=(ida_kernwin.Choose.CH_QFLT | ida_kernwin.Choose.CH_NOIDB)
        )
        self.build_items(item)

    def OnGetSize(self):
        return len(self.items)

    def OnGetLine(self, n):
        d = self.items[n]
        data = [str(d.vuln), d.name, hexstr(d.ea)]

        for x in [d.vuln, d.addr2]:
            if x != None:
                data.append(hexstr(x))
            else:
                continue

        for x in [d.str1, d.str2, d.other1]:
            if x != None:
                data.append(x)
            else:
                continue

        return data

    def OnSelectLine(self, n):
        data = self.items[n]
        viewer = CustViewer(data.ea)
        viewer.jump_in_disassembly()
        return (ida_kernwin.Choose.NOTHING_CHANGED, )

    def build_items(self, items):
        self.items = []
        for item in items:
            self.items.append(item)

```

`firmeye/view/colors.py`:

```py
# -*- coding: utf-8 -*-


disassembly_default = {
    'background': {
        'line_default': 0xffffff,
        'line_selected': 0xc0bbaf,
        'highlight': 0xffff00,
        'breakpoint': 0xff0000,
        'disabled_breakpoint': 0x00ff00,
        'unavailable_breakpoint': 0xff8000,
        'current_line_overlay': 0x505050,
        'current_ip_line_overlay': 0xffd060,
        'trace_line_overlay': 0xffff00,
        'second_trace_line_overlay': 0xffbcb4,
        'extra_line_overlay1': 0x50ff50,
        'extra_line_overlay2': 0xeeff88,
    },
    'text': {
        'instruction': 0x000080,
        'assembler_directive': 0x0000ff,
        'macro': 0x800080,
        'register_name': 0x000080,
        'keywords': 0x000080,
        'dummy_data_name': 0x000080,
        'dummy_code_name': 0x000080,
        'dummy_unknown_name': 0x000080,
        'hidden_name': 0x808080,
        'library_function_name': 0x8080ff,
        'local_variable_name': 0x008000,
        'regular_data_name': 0x0000ff,
        'regular_code_name': 0x0000ff,
        'regular_unknown_name': 0x000080,
        'demangled_name': 0x0000ff,
        'segment_name': 0x808000,
        'imported_name': 0xff00ff,
        'void_operand': 0xff8000,
        'char_constant': 0x008000,
        'string_constant': 0x00ff00,
        'numeric_constant': 0x008000,
        'char_in_data_directive': 0x008000,
        'string_in_data_directive': 0x008000,
        'numeric_in_data_directive': 0x008040,
        'code_reference': 0x008000,
        'data_reference': 0x8080ff,
        'code_ref_to_tail_byte': 0xff0000,
        'data_ref_to_tail_byte': 0x808000,
        'automatic_comment': 0x808080,
        'regular_comment': 0x0000ff,
        'repeatable_comment': 0x808080,
        'extra_line': 0x0000ff,
        'collapsed_line': 0x0000ff,
        'prefix_library_func': 0x00ffff,
        'prefix_regular_func': 0x000000,
        'prefix_single_inst': 0x800000,
        'prefix_data_bytes': 0x808080,
        'prefix_unexplored_byte': 0x808000,
        'prefix_external_name_definition_segment': 0xff00ff,
        'prefix_current_item': 0x000000,
        'prefix_current_line': 0x0000ff,
        'prefix_lumina': 0x32cd32,
        'punctuation': 0x000080,
        'opcode_bytes': 0x0000ff,
        'alternative_operand': 0x0000ff,
        'error_problem': 0x010101,
        'default': 0x0000ff,
    }
}

disassembly_dark = {
    'background': {
        'line_default': 0x2d2d2d,
        'line_selected': 0xe1ad32,
        'highlight': 0x600060,
        'breakpoint': 0x760000,
        'disabled_breakpoint': 0x00ff00,
        'unavailable_breakpoint': 0xff8000,
        'current_line_overlay': 0x505050,
        'current_ip_line_overlay': 0xffd060,
        'trace_line_overlay': 0xffff00,
        'second_trace_line_overlay': 0xffbcb4,
        'extra_line_overlay1': 0x50ff50,
        'extra_line_overlay2': 0xeeff88,
    },
    'text': {
        'instruction': 0xffffff,
        'assembler_directive': 0x9dd600,
        'macro': 0xdf077e,
        'register_name': 0x73adad,
        'keywords': 0xababab,
        'dummy_data_name': 0xebebb9,
        'dummy_code_name': 0xffd200,
        'dummy_unknown_name': 0xaaff00,
        'hidden_name': 0xffd200,
        'library_function_name': 0x00ffff,
        'local_variable_name': 0xff8000,
        'regular_data_name': 0xebebb9,
        'regular_code_name': 0xffd200,
        'regular_unknown_name': 0xffaaff,
        'demangled_name': 0xffecbb,
        'segment_name': 0xffff7f,
        'imported_name': 0xff5afd,
        'void_operand': 0xff4646,
        'char_constant': 0x69d200,
        'string_constant': 0x00ff00,
        'numeric_constant': 0xd25032,
        'char_in_data_directive': 0x79f300,
        'string_in_data_directive': 0x69d200,
        'numeric_in_data_directive': 0xd25032,
        'code_reference': 0xffaa7f,
        'data_reference': 0x7c7c61,
        'code_ref_to_tail_byte': 0xd25032,
        'data_ref_to_tail_byte': 0x808000,
        'automatic_comment': 0x666666,
        'regular_comment': 0xffc5f3,
        'repeatable_comment': 0x82607e,
        'extra_line': 0xffc5f3,
        'collapsed_line': 0xffff00,
        'prefix_library_func': 0x00ffff,
        'prefix_regular_func': 0x666666,
        'prefix_single_inst': 0xaa0000,
        'prefix_data_bytes': 0x7c7c61,
        'prefix_unexplored_byte': 0x9d9d00,
        'prefix_external_name_definition_segment': 0xff55ff,
        'prefix_current_item': 0x000000,
        'prefix_current_line': 0xffaa00,
        'prefix_lumina': 0x32cd32,
        'punctuation': 0xc0c0c0,
        'opcode_bytes': 0x595959,
        'alternative_operand': 0xffaaff,
        'error_problem': 0xff3437,
        'default': 0xaaaaaa,
    }
}

graph_default = {
    'background': {
        'top': 0xffffff,
        'bottom': 0xe0f8ff
    },
    'nodes': {
        'normal_title': 0xffffff,
        'selected_title': 0xb1f9f9,
        'current_title': 0xa0cfcf,
        'group_frame': 0xffff00,
        'node_shadow': 0x000000,
        'highlight1': 0xccffff,
        'highlight2': 0xccffcc,
        'foreign_node': 0xff0000
    },
    'edges': {
        'normal_edge': 0x0000ff,
        'yes_edge': 0x008000,
        'no_edge': 0xff0000,
        'highlighted_edge': 0xff00ff,
        'current_edge': 0x00ffff
    }
}

graph_dark = {
    'background': {
        'top': 0xb2b2b2,
        'bottom': 0xb2b2b2
    },
    'nodes': {
        'normal_title': 0xf5f5f5,
        'selected_title': 0xaa9f98,
        'current_title': 0x5e5854,
        'group_frame': 0xffff00,
        'node_shadow': 0x242424,
        'highlight1': 0x003900,
        'highlight2': 0x6d0000,
        'foreign_node': 0xff0000
    },
    'edges': {
        'normal_edge': 0x0043cb,
        'yes_edge': 0x009100,
        'no_edge': 0xbc0000,
        'highlighted_edge': 0xaaaaff,
        'current_edge': 0xc68e00
    }
}

```

`firmeye/view/custviewer.py`:

```py
# -*- coding: utf-8 -*-

import re

import ida_bytes
import ida_kernwin

from firmeye.logger import FELogger


class CustViewer(ida_kernwin.simplecustviewer_t):
    """
    分析结果窗口显示器
    """

    def __init__(self, ea):
        ida_kernwin.simplecustviewer_t.__init__(self)
        self.ea = ea

    def jump_in_disassembly(self):
        ea = self.ea
        if not ea or not ida_bytes.is_loaded(ea):
            FELogger.warn("地址错误")
            return

        widget = self.find_disass_view()
        if not widget:
            FELogger.warn("无法找到反汇编窗口")
            return

        self.jumpto_in_view(widget, ea)

    def jump_in_new_window(self):
        ea = self.ea
        if not ea or not ida_bytes.is_loaded(ea):
            FELogger.warn("地址错误")
            return

        window_name = "D-0x%x" % ea
        widget = ida_kernwin.open_disasm_window(window_name)
        if widget:
            self.jumpto_in_view(widget, ea)
        else:
            FELogger.warn("创建新窗口失败")

    def jump_in_hex(self):
        ea = self.ea
        if not ea or not ida_bytes.is_loaded(ea):
            FELogger.warn("地址错误")
            return

        widget = self.find_hex_view()
        if not widget:
            FELogger.warn("无法找到十六进制窗口")
            return

        self.jumpto_in_view(widget, ea)

    def find_disass_view(self):
        for c in map(chr, range(65, 75)):
            widget = ida_kernwin.find_widget('IDA View-%s' % c)
            if widget:
                return widget
            else:
                continue
        return None

    def find_hex_view(self):
        for i in range(1, 10):
            widget = ida_kernwin.find_widget('Hex View-%d' % i)
            if widget:
                return widget
            else:
                continue
        return None

    def jumpto_in_view(self, view, ea):
        ida_kernwin.activate_widget(view, True)
        return ida_kernwin.jumpto(ea)

```

`firmeye/vulnscan/__init__.py`:

```py
# -*- coding: utf-8 -*-

```

`firmeye/vulnscan/cve_2019_3568.py`:

```py
# -*- coding: utf-8 -*-

from idaapi import *

from helper import name_to_addr
from hexraystool import query

def scan_cve_2019_3568():
    """
    在 libwhatsapp.so 中扫描 CVE-2019-3568
    """
    expr = lambda cf, e: (e.op is cit_if and
            e.cif.expr.op is cot_land and
            e.cif.expr.y.op is cot_eq and
            e.cif.expr.y.y.op is cot_num and
            e.cif.expr.y.y.numval() == 51200)

    locations = set(CodeRefsTo(name_to_addr("__aeabi_memcpy"), False))
    return query(expr, locations, do_print=True)

if __name__ == "__main__":
    print("扫描 CVE-2019-3568...")
    scan_cve_2019_3568()

```

`requirements.txt`:

```txt
lief

```