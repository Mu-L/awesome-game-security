Project Path: arc_alexhude_FRIEND_3c4kfjll

Source Tree:

```txt
arc_alexhude_FRIEND_3c4kfjll
├── CMakeLists.txt
├── Configurations
│   ├── AArch64_armv8arm_k.xml
│   ├── AR_VMSA_armv7arm_C.xml
│   ├── mips.xml
│   └── x86_64.xml
├── FRIEND
│   ├── AArch32Extender.cpp
│   ├── AArch32Extender.hpp
│   ├── AArch64Extender.cpp
│   ├── AArch64Extender.hpp
│   ├── Documentation.cpp
│   ├── Documentation.hpp
│   ├── FRIEND.cpp
│   ├── FunctionSummary.cpp
│   ├── FunctionSummary.hpp
│   ├── IDAAPI.hpp
│   ├── PluginDelegate.hpp
│   ├── ProcExtender.hpp
│   ├── Settings.cpp
│   └── Settings.hpp
├── HintEditor
│   ├── Dependencies
│   │   └── AEXML.framework
│   │       ├── AEXML
│   │       ├── Headers
│   │       ├── Modules
│   │       ├── Resources
│   │       └── Versions
│   │           ├── A
│   │           │   ├── AEXML
│   │           │   ├── Headers
│   │           │   │   ├── AEXML-Swift.h
│   │           │   │   └── AEXML.h
│   │           │   ├── Modules
│   │           │   │   ├── AEXML.swiftmodule
│   │           │   │   │   ├── Project
│   │           │   │   │   │   ├── arm64-apple-macos.swiftsourceinfo
│   │           │   │   │   │   ├── arm64.swiftsourceinfo
│   │           │   │   │   │   ├── x86_64-apple-macos.swiftsourceinfo
│   │           │   │   │   │   └── x86_64.swiftsourceinfo
│   │           │   │   │   ├── arm64-apple-macos.swiftdoc
│   │           │   │   │   ├── arm64-apple-macos.swiftmodule
│   │           │   │   │   ├── arm64.swiftdoc
│   │           │   │   │   ├── arm64.swiftmodule
│   │           │   │   │   ├── x86_64-apple-macos.swiftdoc
│   │           │   │   │   ├── x86_64-apple-macos.swiftmodule
│   │           │   │   │   ├── x86_64.swiftdoc
│   │           │   │   │   └── x86_64.swiftmodule
│   │           │   │   └── module.modulemap
│   │           │   ├── Resources
│   │           │   │   └── Info.plist
│   │           │   └── _CodeSignature
│   │           │       └── CodeResources
│   │           └── Current
│   └── HintEditor
│       ├── AppDelegate.swift
│       ├── CMakeLists.txt
│       ├── HintEditor-Bridging-Header.h
│       ├── Info.plist
│       ├── ViewController.swift
│       └── storyboards
│           └── Main.storyboard
├── Patches
│   ├── aexml.diff
│   └── capstone.diff
├── README.md
├── Resources
│   └── screenshots
│       ├── external_doc.png
│       ├── hint_editor.png
│       ├── proc_ext.png
│       ├── reg_ins_hints.png
│       ├── settings.png
│       └── summary.png
├── bin
│   ├── IDA 6.x
│   │   ├── FRIEND.p64
│   │   ├── FRIEND.plw
│   │   ├── FRIEND.plx
│   │   ├── FRIEND.plx64
│   │   ├── FRIEND.pmc
│   │   └── FRIEND.pmc64
│   ├── IDA 7.0
│   │   ├── FRIEND.dll
│   │   ├── FRIEND.dylib
│   │   ├── FRIEND64.dll
│   │   └── FRIEND64.dylib
│   ├── IDA 7.1
│   │   ├── FRIEND.dylib
│   │   └── FRIEND64.dylib
│   └── IDA 8.0
│       ├── FRIEND.dylib
│       └── FRIEND64.dylib
├── cmake
│   └── FindIdaSdk.cmake
├── hexrays_sdk
└── idasdk

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 2.8.12)

option(USE_HEXRAYS "Build with Hexrays" ON)
option(USE_IDA6_SDK "Build for IDA 6.x" OFF)

project(FRIEND C CXX)
include(ExternalProject)

if(APPLE)
    if(CMAKE_GENERATOR STREQUAL Xcode)
        # for Xcode set latest macOS SDK and 32bit architecture
        set(CMAKE_OSX_SYSROOT "macosx")
        if(USE_IDA6_SDK)
            set(CMAKE_OSX_ARCHITECTURES "$(ARCHS_STANDARD_32_BIT)")
        else()
            set(CMAKE_OSX_ARCHITECTURES "$(ARCHS_STANDARD)")
        endif()
    endif()
endif()

# idasdk
set(IdaSdk_DIR ${PROJECT_SOURCE_DIR}/idasdk)
# hexrays sdk
if(USE_HEXRAYS)
    set(HexraysSdk_DIR ${PROJECT_SOURCE_DIR}/hexrays_sdk)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DUSE_HEXRAYS")
endif()

# capstone
set(CAPSTONE_ROOT    "${CMAKE_BINARY_DIR}/third_party/capstone")
set(CAPSTONE_GIT_URL "https://github.com/aquynh/capstone")
set(CAPSTONE_GIT_TAG "")
set(CAPSTONE_PATCHES "${PROJECT_SOURCE_DIR}/Patches/capstone.diff")

# pugixml
set(PUGIXML_ROOT     "${CMAKE_BINARY_DIR}/third_party/pugixml")
set(PUGIXML_GIT_URL  "https://github.com/zeux/pugixml")
set(PUGIXML_GIT_TAG  "")

list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)

find_package(Git REQUIRED)
find_package(IdaSdk REQUIRED)

if(UNIX)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --std=c++11")
    set(CMAKE_SKIP_BUILD_RPATH TRUE)
    if(USE_IDA6_SDK)
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -m32")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -m32")
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -m32")
    endif()
elseif(WIN32)
    if(MSVC)
        foreach(cur_var CMAKE_C_FLAGS
                        CMAKE_C_FLAGS_DEBUG
        				CMAKE_C_FLAGS_RELEASE
        				CMAKE_C_FLAGS_MINSIZEREL
        				CMAKE_C_FLAGS_RELWITHDEBINFO
        				CMAKE_CXX_FLAGS
                        CMAKE_CXX_FLAGS_DEBUG
                        CMAKE_CXX_FLAGS_RELEASE
                        CMAKE_CXX_FLAGS_MINSIZEREL
                        CMAKE_CXX_FLAGS_RELWITHDEBINFO)
			string(REGEX REPLACE "/(LD|(M(T|D)))d?( +|$)" "/MD " new_var ${${cur_var}})
			string(REGEX REPLACE "(/|-)D *_DEBUG" "" new_var ${new_var})
			set(${cur_var} ${new_var} CACHE STRING "" FORCE)
        endforeach(cur_var)
    endif()
endif()

if(NOT CMAKE_BUILD_TYPE STREQUAL "Debug")
    add_definitions(-DNDEBUG)
endif()

# build capstone
ExternalProject_Add(
    capstone
    PREFIX              "${CAPSTONE_ROOT}"
    INSTALL_DIR         "${CAPSTONE_ROOT}"
    GIT_REPOSITORY      "${CAPSTONE_GIT_URL}"
    GIT_TAG             "${CAPSTONE_GIT_TAG}"
    GIT_SHALLOW         ON
    PATCH_COMMAND       ${GIT_EXECUTABLE} reset --hard && ${GIT_EXECUTABLE} apply --ignore-whitespace --whitespace=nowarn ${CAPSTONE_PATCHES}
    CMAKE_ARGS          -DCMAKE_INSTALL_PREFIX:PATH=<INSTALL_DIR>
                        -DCAPSTONE_BUILD_SHARED=OFF
                        -DCAPSTONE_BUILD_TESTS=OFF
                        -DCAPSTONE_MIPS_SUPPORT=OFF
                        -DCAPSTONE_PPC_SUPPORT=OFF
                        -DCAPSTONE_SPARC_SUPPORT=OFF
                        -DCAPSTONE_SYSZ_SUPPORT=OFF
                        -DCAPSTONE_XCORE_SUPPORT=OFF
                        -DCAPSTONE_X86_SUPPORT=OFF
                        -DCMAKE_OSX_SYSROOT:STRING=${CMAKE_OSX_SYSROOT}
                        -DCMAKE_OSX_ARCHITECTURES:STRING=${CMAKE_OSX_ARCHITECTURES}
                        -DCMAKE_C_FLAGS:STRING=${CMAKE_C_FLAGS}
                        -DCMAKE_C_FLAGS_DEBUG:STRING=${CMAKE_C_FLAGS_DEBUG}
                        -DCMAKE_C_FLAGS_RELEASE:STRING=${CMAKE_C_FLAGS_RELEASE}
                        -DCMAKE_C_FLAGS_MINSIZEREL:STRING=${CMAKE_C_FLAGS_MINSIZEREL}
                        -DCMAKE_C_FLAGS_RELWITHDEBINFO:STRING=${CMAKE_C_FLAGS_RELWITHDEBINFO}
                        -DCMAKE_CXX_FLAGS:STRING=${CMAKE_CXX_FLAGS}
                        -DCMAKE_CXX_FLAGS_DEBUG:STRING=${DCMAKE_CXX_FLAGS_DEBUG}
                        -DCMAKE_CXX_FLAGS_RELEASE:STRING=${DCMAKE_CXX_FLAGS_RELEASE}
                        -DCMAKE_CXX_FLAGS_MINSIZEREL:STRING=${DCMAKE_CXX_FLAGS_MINSIZEREL}
                        -DCMAKE_CXX_FLAGS_RELWITHDEBINFO:STRING=${DCMAKE_CXX_FLAGS_RELWITHDEBINFO}
                        -DCMAKE_POSITION_INDEPENDENT_CODE:BOOL=ON
)

# build pugixml
ExternalProject_Add(
    pugixml
    PREFIX              "${PUGIXML_ROOT}"
    INSTALL_DIR         "${PUGIXML_ROOT}"
    GIT_REPOSITORY      "${PUGIXML_GIT_URL}"
    GIT_TAG             "${PUGIXML_GIT_TAG}"
    GIT_SHALLOW         ON
    CMAKE_ARGS          -DCMAKE_INSTALL_PREFIX:PATH=<INSTALL_DIR>
                        -DCMAKE_OSX_SYSROOT:STRING=${CMAKE_OSX_SYSROOT}
                        -DCMAKE_OSX_ARCHITECTURES:STRING=${CMAKE_OSX_ARCHITECTURES}
                        -DCMAKE_C_FLAGS:STRING=${CMAKE_C_FLAGS}
                        -DCMAKE_C_FLAGS_DEBUG:STRING=${CMAKE_C_FLAGS_DEBUG}
                        -DCMAKE_C_FLAGS_RELEASE:STRING=${CMAKE_C_FLAGS_RELEASE}
                        -DCMAKE_C_FLAGS_MINSIZEREL:STRING=${CMAKE_C_FLAGS_MINSIZEREL}
                        -DCMAKE_C_FLAGS_RELWITHDEBINFO:STRING=${CMAKE_C_FLAGS_RELWITHDEBINFO}
                        -DCMAKE_CXX_FLAGS:STRING=${CMAKE_CXX_FLAGS}
                        -DCMAKE_CXX_FLAGS_DEBUG:STRING=${DCMAKE_CXX_FLAGS_DEBUG}
                        -DCMAKE_CXX_FLAGS_RELEASE:STRING=${DCMAKE_CXX_FLAGS_RELEASE}
                        -DCMAKE_CXX_FLAGS_MINSIZEREL:STRING=${DCMAKE_CXX_FLAGS_MINSIZEREL}
                        -DCMAKE_CXX_FLAGS_RELWITHDEBINFO:STRING=${DCMAKE_CXX_FLAGS_RELWITHDEBINFO}
                        -DCMAKE_POSITION_INDEPENDENT_CODE:BOOL=ON
)

add_library(capstone_static STATIC IMPORTED)
set_target_properties(
    capstone_static PROPERTIES IMPORTED_LOCATION
    ${CAPSTONE_ROOT}/lib/${CMAKE_STATIC_LIBRARY_PREFIX}capstone${CMAKE_STATIC_LIBRARY_SUFFIX}
)
add_dependencies(capstone_static capstone)

add_library(pugixml_static STATIC IMPORTED)
set_target_properties(
    pugixml_static PROPERTIES IMPORTED_LOCATION
    ${PUGIXML_ROOT}/lib/${CMAKE_STATIC_LIBRARY_PREFIX}pugixml${CMAKE_STATIC_LIBRARY_SUFFIX}
)
add_dependencies(pugixml_static pugixml)

include_directories(
    ${PROJECT_SOURCE_DIR}
    ${IdaSdk_INCLUDE_DIRS}
    ${CAPSTONE_ROOT}/include/capstone/
    ${PUGIXML_ROOT}/include/
)

if(USE_HEXRAYS)
    include_directories(
        ${HexraysSdk_DIR}/include/
    )
endif()


# add_subdirectory(tools)

add_ida_plugin(FRIEND EA64
               FRIEND/AArch64Extender.cpp
               FRIEND/AArch64Extender.hpp
               FRIEND/AArch32Extender.cpp
               FRIEND/AArch32Extender.hpp
               FRIEND/Documentation.cpp
               FRIEND/Documentation.hpp
               FRIEND/FRIEND.cpp
               FRIEND/FunctionSummary.cpp
               FRIEND/FunctionSummary.hpp
               FRIEND/IDAAPI.hpp
               FRIEND/PluginDelegate.hpp
               FRIEND/ProcExtender.hpp
               FRIEND/Settings.cpp
               FRIEND/Settings.hpp)

set_target_properties(FRIEND${_plx} FRIEND${_plx64} PROPERTIES POSITION_INDEPENDENT_CODE ON)
target_link_libraries(FRIEND${_plx} pugixml_static capstone_static)
target_link_libraries(FRIEND${_plx64} pugixml_static capstone_static)

```

`Configurations/AArch64_armv8arm_k.xml`:

```xml
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<documentation>
	<document id="armv8arm" name="ARM Architecture Reference Manual" version="A.k">
		<path>/path/to/DDI0487A_k_armv8_arm.pdf</path>
	</document>
	<elements>
		<group type="reg" name="A64 General Purpose Registers">
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X0">Possible purpose:
- return value register
- argument register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X1">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X2">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X3">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X4">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X5">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X6">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X7">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X8">Possible purpose:
- indirect result register (XR)</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X9">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X10">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X11">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X12">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X12">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X14">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X15">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="64-bit General Purpose Regisfter" doc_id="armv8arm" token="X16">Possible purpose:
- intra-procedure-call temporary register (IP0)</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X17">Possible purpose:
- intra-procedure-call temporary register (IP1)</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X18">Possible purpose:
- platform register (PR), reserved for the use of platform ABIs</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X19">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X20">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X21">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X22">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X23">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X24">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X25">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X26">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X27">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X28">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X29">Possible purpose:
- frame pointer register (FP)</hint>
			<hint page="59" header="64-bit General Purpose Register" doc_id="armv8arm" token="X30">Possible purpose:
- link register (LR)</hint>
			<hint page="125" header="64-bit Zero Register" doc_id="armv8arm" token="XZR">The name XZR represents the zero register in a 64-bit context.</hint>
			<hint page="59" header="Program Counter Register" doc_id="armv8arm" token="PC">Possible purpose:
- holding the address of the current instruction</hint>
			<hint page="59" header="64-bit Stack Pointer Register" doc_id="armv8arm" token="SP">Represents the current stack pointer in a 64-bit context.</hint>
			<hint page="59" header="Frame Pointer Register" doc_id="armv8arm" token="FP">Possible purpose:
- holds the address of the current frame</hint>
			<hint page="59" header="Link Register Register" doc_id="armv8arm" token="LR">Possible purpose:
- holds return address</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W0">Possible purpose:
- return value register
- argument register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W1">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W2">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W3">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W4">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W5">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W6">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W7">Possible purpose:
- argument register
- scratch register
- caller-saved register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W8">Possible purpose:
- indirect result register (XR)</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W9">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W10">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W11">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W12">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W12">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W14">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W15">Possible purpose:
- caller-saved temporary register</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W16">Possible purpose:
- intra-procedure-call temporary register (IP0)</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W17">Possible purpose:
- intra-procedure-call temporary register (IP1)</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W18">Possible purpose:
- platform register (PR), reserved for the use of platform ABIs</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W19">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W20">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W21">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W22">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W23">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W24">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W25">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W26">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W27">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W28">Possible purpose:
- callee-saved registers</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W29">Possible purpose:
- frame pointer register (FP)</hint>
			<hint page="59" header="32-bit General Purpose Register" doc_id="armv8arm" token="W30">Possible purpose:
- link register (LR)</hint>
			<hint page="125" header="32-bit Zero Register" doc_id="armv8arm" token="WZR">The name XZR represents the zero register in a 64-bit context.</hint>
			<hint page="123" header="32-bit Stack Pointer Register" doc_id="armv8arm" token="WSP">Represents the current stack pointer in a 32-bit context.</hint>
		</group>
		<group type="reg" name="A64 SIMD and FP Registers">
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V0">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V1">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V2">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V3">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V4">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V5">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V6">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V7">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V8">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V9">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V10">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V11">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V14">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V15">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V16">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V17">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V18">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V19">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V20">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V21">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V22">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V23">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V24">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V25">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V26">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V27">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V28">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V29">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="V30">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q0">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q1">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q2">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q3">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q4">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q5">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q6">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q7">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q8">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q9">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q10">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q11">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q14">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q15">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q16">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q17">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q18">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q19">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q20">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q21">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q22">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q23">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q24">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q25">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q26">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q27">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q28">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q29">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="128-bit SIMD and FP Register" doc_id="armv8arm" token="Q30">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D0">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D1">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D2">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D3">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D4">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D5">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D6">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D7">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D8">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D9">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D10">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D11">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D14">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D15">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D16">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D17">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D18">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D19">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D20">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D21">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D22">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D23">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D24">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D25">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D26">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D27">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D28">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D29">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="64-bit SIMD and FP Register" doc_id="armv8arm" token="D30">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S0">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S1">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S2">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S3">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S4">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S5">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S6">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S7">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S8">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S9">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S10">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S11">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S14">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S15">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S16">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S17">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S18">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S19">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S20">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S21">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S22">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S23">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S24">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S25">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S26">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S27">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S28">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S29">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="32-bit SIMD and FP Register" doc_id="armv8arm" token="S30">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H0">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H1">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H2">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H3">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H4">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H5">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H6">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H7">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H8">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H9">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H10">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H11">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H14">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H15">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H16">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H17">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H18">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H19">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H20">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H21">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H22">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H23">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H24">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H25">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H26">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H27">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H28">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H29">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="16-bit SIMD and FP Register" doc_id="armv8arm" token="H30">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B0">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B1">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B2">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B3">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B4">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B5">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B6">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B7">Possible purpose:
- parameter and result register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B8">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B9">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B10">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B11">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B12">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B14">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B15">Possible purpose:
- callee preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B16">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B17">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B18">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B19">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B20">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B21">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B22">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B23">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B24">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B25">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B26">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B27">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B28">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B29">Possible purpose:
- callee optionally preserved register</hint>
			<hint page="59" header="8-bit SIMD and FP Register" doc_id="armv8arm" token="B30">Possible purpose:
- callee optionally preserved register</hint>
		</group>
		<group type="reg" name="A64 Special-purpose Registers">
			<hint page="294" header="Current Exception Level" doc_id="armv8arm" token="CurrentEL">Holds the current Exception level.
   [31:4] - Reserved, RES0.
EL [ 3:2] - Current Exception level:
            00 EL0
            01 EL1
            10 EL2
            11 EL3
   [ 1:0] - Reserved, RES0.</hint>
			<hint page="296" header="Interrupt Mask Bits" doc_id="armv8arm" token="DAIF">Allows access to the interrupt mask bits.
[31:10] - Reserved, RES0.
D [ 9 ] - Process state D mask:
          0 Watchpoint, Breakpoint, and Software Step at the current EL are not masked.
          1 Watchpoint, Breakpoint, and Software Step at the current EL are masked.
A [ 8 ] - SError interrupt mask bit:
          0 Exception not masked.
          1 Exception masked.
I [ 7 ] - IRQ mask bit:
          0 Exception not masked.
          1 Exception masked.
F [ 6 ] - FIQ mask bit:
          0 Exception not masked.
          1 Exception masked.
[ 5: 0] - Reserved, RES0.</hint>
			<hint page="2177" header="Debug Link Register" doc_id="armv8arm" token="DLR_EL0">In Debug state, holds the address to restart from.</hint>
			<hint page="2180" header="Debug Saved Program Status Register" doc_id="armv8arm" token="DSPSR_EL0">Holds the saved process state when entering from AArch64 and exiting Debug state to AArch64.
N, bit [31]  - Set to the value of the N condition flag.
Z, bit [30]  - Set to the value of the Z condition flag.
C, bit [29]  - Set to the value of the C condition flag.
V, bit [28]  - Set to the value of the V condition flag.
Bits [27:22] - Reserved, RES0.
SS, bit [21] - Software step. Shows the value of PSTATE.SS immediately 
               before Debug state was entered.
IL, bit [20] - Illegal Execution state bit. Shows the value of PSTATE.IL 
               immediately before Debug state was entered.
Bits [19:10] - Reserved, RES0.
D, bit [9]   - Process state D mask.
               0 Watchpoint, Breakpoint, and Software Step exceptions are not masked.
               1 Watchpoint, Breakpoint, and Software Step exceptions are masked.
A, bit [8]   - SError interrupt mask bit.
               0 Exception not masked.
               1 Exception masked.
I, bit [7]   - IRQ mask bit.
               0 Exception not masked.
               1 Exception masked.
F, bit [6]   - FIQ mask bit.
               0 Exception not masked.
               1 Exception masked.
Bit [5]      - Reserved, RES0.
M[4], bit [4] - Execution state that Debug state was entered from.
               0 Exception taken from AArch64.
M[3:0], bits [3:0] - AArch64 mode that Debug state was entered from.
               0b0000 EL0t      
               0b0100 EL1t      M[3:2] holds the Exception Level.
               0b0101 EL1h      M[1] is unused and is RES0 for all non-reserved values. 
               0b1000 EL2t      M[0] is used to select the SP: 
               0b1001 EL2h           0 means the SP is always SP0.
               0b1100 EL3t           1 means the exception SP is determined by the EL.
               0b1101 EL3h</hint>
			<hint page="300" header="Exception Link Register (EL1)" doc_id="armv8arm" token="ELR_EL1">When taking an exception to EL1, holds the address to return to.</hint>
			<hint page="301" header="Exception Link Register (EL2)" doc_id="armv8arm" token="ELR_EL2">When taking an exception to EL2, holds the address to return to.</hint>
			<hint page="303" header="Exception Link Register (EL3)" doc_id="armv8arm" token="ELR_EL3">When taking an exception to EL3, holds the address to return to.</hint>
			<hint page="304" header="Floating-point Control Register" doc_id="armv8arm" token="FPCR">Controls floating-point behavior.
Bits [31:27]  - Reserved, RES0.
AHP, bit [26] - Alternative half-precision control bit:
                0 IEEE half-precision format selected.
                1 Alternative half-precision format selected.
DN, bit [25]  - Default NaN mode control bit:
                0 NaN operands propagate through to the output of a floating-point operation.
                1 Any operation involving one or more NaNs returns the Default NaN.
FZ, bit [24]  - Flush-to-zero mode control bit:
                0 Flush-to-zero mode disabled. Behavior of the floating-point system is 
                  fully compliant with the IEEE 754 standard.
                1 Flush-to-zero mode enabled.
RMode, bits [23:22] - Rounding Mode control field. The encoding of this field is:
                00 Round to Nearest (RN) mode
                01 Round towards Plus Infinity (RP) mode
                10 Round towards Minus Infinity (RM) mode
                11 Round towards Zero (RZ) mode.
Stride, bits [21:20] - This field has no function in AArch64, and non-zero values are 
                ignored during AArch64 execution
Bit [19]      - Reserved, RES0.
Len, bits [18:16] - This field has no function in AArch64, and non-zero values are 
                ignored during AArch64 execution.
IDE, bit [15] - Input Denormal exception trap enable.
                0 Untrapped exception handling selected.
                1 Trapped exception handling selected.
Bits [14:13]  - Reserved, RES0.
IXE, bit [12] - Inexact exception trap enable.
                0 Untrapped exception handling selected.
                1 Trapped exception handling selected. 
UFE, bit [11] - Underflow exception trap enable.
                0 Untrapped exception handling selected.
                1 Trapped exception handling selected.
OFE, bit [10] - Overflow exception trap enable.
                0 Untrapped exception handling selected.
                1 Trapped exception handling selected.
DZE, bit [9]  - Division by Zero exception trap enable.
                0 Untrapped exception handling selected.
                1 Trapped exception handling selected.
IOE, bit [8]  - Invalid Operation exception trap enable.
                0 Untrapped exception handling selected.
                1 Trapped exception handling selected.
Bits [7:0]    - Reserved, RES0.</hint>
			<hint page="308" header="Floating-point Status Register" doc_id="armv8arm" token="FPSR">Provides floating-point system status information.
N, bit [31]  - Negative condition, floating-point comparisons set the PSTATE.N flag
Z, bit [30]  - Zero condition, floating-point comparisons set the PSTATE.Z flag
C, bit [29]  - Carry condition, floating-point comparisons set the PSTATE.C flag
V, bit [28]  - Overflow condition flag, floating-point comparisons set the PSTATE.C flag
QC, bit [27] - Cumulative saturation bit
Bits [26:8]  - Reserved, RES0.
IDC, bit [7] - Input Denormal cumulative exception bit. 
Bits [6:5]   - Reserved, RES0.
IXC, bit [4] - Inexact cumulative exception bit.
UFC, bit [3] - Underflow cumulative exception bit. 
OFC, bit [2] - Overflow cumulative exception bit. 
DZC, bit [1] - Division by Zero cumulative exception bit.
IOC, bit [0] - Invalid Operation cumulative exception bit.</hint>
			<hint page="311" header="Condition Flags" doc_id="armv8arm" token="NZCV">Allows access to the condition flags.
N, bit [31] - Negative condition flag. 
              Set to 1 if the result of the last flag-setting instruction was negative.
Z, bit [30] - Zero condition flag.
              Set to 1 if the result of the last flag-setting instruction was zero, and to 0 otherwise. 
              A result of zero often indicates an equal result from a comparison.
C, bit [29] - Carry condition flag. 
              Set to 1 if the last flag-setting instruction resulted in a carry condition.
V, bit [28] - Overflow condition flag. 
              Set to 1 if the last flag-setting instruction resulted in an overflow condition.
Bits [27:0] - Reserved, RES0.</hint>
			<hint page="313" header="Stack Pointer (EL0)" doc_id="armv8arm" token="SP_EL0">Holds the stack pointer associated with EL0.
At higher Exception levels, this is used as the current stack pointer 
when the value of SPSel.SP is 0.</hint>
			<hint page="314" header="Stack Pointer (EL1)" doc_id="armv8arm" token="SP_EL1">Holds the stack pointer associated with EL1.
When executing at EL1, the value of SPSel.SP determines 
the current stack pointer:
0 SP_EL0
1 SP_EL1</hint>
			<hint page="316" header="Stack Pointer (EL2)" doc_id="armv8arm" token="SP_EL2">Holds the stack pointer associated with EL2. 
When executing at EL2, the value of SPSel.SP determines 
the current stack pointer:
0 SP_EL0
1 SP_EL2</hint>
			<hint page="318" header="SP_EL3, Stack Pointer (EL3)" doc_id="armv8arm" token="SP_EL3">Holds the stack pointer associated with EL3. 
When executing at EL3, the value of SPSel.SP determines 
the current stack pointer:
0 SP_EL0
1 SP_EL3</hint>
			<hint page="319" header="Stack Pointer Select" doc_id="armv8arm" token="SPSEL">Allows the Stack Pointer to be selected between SP_EL0 and SP_ELx.</hint>
			<hint page="323" header="Saved Program Status Register (EL1)" doc_id="armv8arm" token="SPSR_EL1">Holds the saved process state when an exception is taken to EL1.
N, bit [31]  - Set to the value of the N condition flag on exception to EL1.
Z, bit [30]  - Set to the value of the Z condition flag on exception to EL1.
C, bit [29]  - Set to the value of the C condition flag on exception to EL1.
V, bit [28]  - Set to the value of the V condition flag on exception to EL1.
Bits [27:22] - Reserved, RES0.
SS, bit [21] - Software step. Shows the value of PSTATE.SS immediately 
               before exception was taken.
IL, bit [20] - Illegal Execution state bit. Shows the value of PSTATE.IL 
               immediately before exception was taken.
Bits [19:10] - Reserved, RES0.
D, bit [9]   - Process state D mask.
               0 Watchpoint, Breakpoint, and Software Step exceptions are not masked.
               1 Watchpoint, Breakpoint, and Software Step exceptions are masked.
A, bit [8]   - SError interrupt mask bit.
               0 Exception not masked.
               1 Exception masked.
I, bit [7]   - IRQ mask bit.
               0 Exception not masked.
               1 Exception masked.
F, bit [6]   - FIQ mask bit.
               0 Exception not masked.
               1 Exception masked.
Bit [5]      - Reserved, RES0.
M[4], bit [4] - Execution state that the exception was taken from.
               0 Exception taken from AArch64.
M[3:0], bits [3:0] - AArch64 mode that an exception was taken from.
               0b0000 EL0t      M[3:2] holds the Exception Level.
               0b0100 EL1t      M[1] is unused and is RES0 for all non-reserved values. 
               0b0101 EL1h      M[0] is used to select the SP: 
                                     0 means the SP is always SP0.
                                     1 means the exception SP is determined by the EL.</hint>
			<hint page="328" header="Saved Program Status Register (EL2)" doc_id="armv8arm" token="SPSR_EL2">Holds the saved process state when an exception is taken to EL2.
N, bit [31]  - Set to the value of the N condition flag on exception to EL2.
Z, bit [30]  - Set to the value of the Z condition flag on exception to EL2.
C, bit [29]  - Set to the value of the C condition flag on exception to EL2.
V, bit [28]  - Set to the value of the V condition flag on exception to EL2.
Bits [27:22] - Reserved, RES0.
SS, bit [21] - Software step. Shows the value of PSTATE.SS immediately 
               before exception was taken.
IL, bit [20] - Illegal Execution state bit. Shows the value of PSTATE.IL 
               immediately before exception was taken.
Bits [19:10] - Reserved, RES0.
D, bit [9]   - Process state D mask.
               0 Watchpoint, Breakpoint, and Software Step exceptions are not masked.
               1 Watchpoint, Breakpoint, and Software Step exceptions are masked.
A, bit [8]   - SError interrupt mask bit.
               0 Exception not masked.
               1 Exception masked.
I, bit [7]   - IRQ mask bit.
               0 Exception not masked.
               1 Exception masked.
F, bit [6]   - FIQ mask bit.
               0 Exception not masked.
               1 Exception masked.
Bit [5]      - Reserved, RES0.
M[4], bit [4] - Execution state that the exception was taken from.
               0 Exception taken from AArch64.
M[3:0], bits [3:0] - AArch64 mode that an exception was taken from.
               0b0000 EL0t      M[3:2] holds the Exception Level.
               0b0100 EL1t      M[1] is unused and is RES0 for all non-reserved values. 
               0b0101 EL1h      M[0] is used to select the SP: 
               0b1000 EL2t           0 means the SP is always SP0.
               0b1001 EL2h           1 means the exception SP is determined by the EL.</hint>
			<hint page="333" header="Saved Program Status Register (EL3)" doc_id="armv8arm" token="SPSR_EL3">Holds the saved process state when an exception is taken to EL3.
N, bit [31]  - Set to the value of the N condition flag on exception to EL2.
Z, bit [30]  - Set to the value of the Z condition flag on exception to EL2.
C, bit [29]  - Set to the value of the C condition flag on exception to EL2.
V, bit [28]  - Set to the value of the V condition flag on exception to EL2.
Bits [27:22] - Reserved, RES0.
SS, bit [21] - Software step. Shows the value of PSTATE.SS immediately 
               before exception was taken.
IL, bit [20] - Illegal Execution state bit. Shows the value of PSTATE.IL 
               immediately before exception was taken.
Bits [19:10] - Reserved, RES0.
D, bit [9]   - Process state D mask.
               0 Watchpoint, Breakpoint, and Software Step exceptions are not masked.
               1 Watchpoint, Breakpoint, and Software Step exceptions are masked.
A, bit [8]   - SError interrupt mask bit.
               0 Exception not masked.
               1 Exception masked.
I, bit [7]   - IRQ mask bit.
               0 Exception not masked.
               1 Exception masked.
F, bit [6]   - FIQ mask bit.
               0 Exception not masked.
               1 Exception masked.
Bit [5]      - Reserved, RES0.
M[4], bit [4] - Execution state that the exception was taken from.
               0 Exception taken from AArch64.
M[3:0], bits [3:0] - AArch64 mode that an exception was taken from.
               0b0000 EL0t      
               0b0100 EL1t      M[3:2] holds the Exception Level.
               0b0101 EL1h      M[1] is unused and is RES0 for all non-reserved values. 
               0b1000 EL2t      M[0] is used to select the SP: 
               0b1001 EL2h           0 means the SP is always SP0.
               0b1100 EL3t           1 means the exception SP is determined by the EL.
               0b1101 EL3h</hint>
			<hint page="1530" header="Accessing PSTATE.{D, A, I, F} using MSR" doc_id="armv8arm" token="DAIFSET">Directly sets any of the PSTATE.{D,A, I, F} bits to 1</hint>
			<hint page="1530" header="Accessing PSTATE.{D, A, I, F} using MSR" doc_id="armv8arm" token="DAIFCLR">Directly clears any of the PSTATE.{D, A, I, F} bits to 0</hint>
		</group>
		<group type="reg" name="A64 System Registers (cache maintenance)">
			<hint page="348" header="Data or unified Cache line Clean and Invalidate by Set/Way" doc_id="armv8arm" token="CISW">Clean and Invalidate data cache by set/way.

Bits [63:32] - Reserved, RES0.
SetWay, bits [31:4] - Contains fields:
             Way, bits[31:32-A], the number of the way to operate on.
             Set, bits[B-1:L], the number of the set to operate on.
             Bits[L-1:4] are RES0.
Level, bits [3:1] - Cache level to operate on, minus 1
Bit [0]      - Reserved, RES0.

Example: DC CISW, &lt;Xt&gt;</hint>
			<hint page="350" header="Data or unified Cache line Clean and Invalidate by VA to PoC" doc_id="armv8arm" token="CIVAC">Clean and Invalidate data cache by address to Point of Coherency.

Bits [63:0] - Virtual address to use.

Example: DC CIVAC, &lt;Xt&gt;</hint>
			<hint page="352" header="Data or unified Cache line Clean by Set/Way" doc_id="armv8arm" token="CSW">Clean data cache by set/way.

Bits [63:32] - Reserved, RES0.
SetWay, bits [31:4] - Contains fields:
             Way, bits[31:32-A], the number of the way to operate on.
             Set, bits[B-1:L], the number of the set to operate on.
             Bits[L-1:4] are RES0.
Level, bits [3:1] - Cache level to operate on, minus 1
Bit [0]      - Reserved, RES0.

Example: DC CSW, &lt;Xt&gt;</hint>
			<hint page="353" header="Data or unified Cache line Clean by VA to PoC" doc_id="armv8arm" token="CVAC">Clean data cache by address to Point of Coherency.

Bits [63:0] - Virtual address to use.

Example: DC CVAC, &lt;Xt&gt;</hint>
			<hint page="354" header="Data or unified Cache line Clean by VA to PoU" doc_id="armv8arm" token="CVAU">Clean data cache by address to Point of Unification.

Bits [63:0] - Virtual address to use.

Example: DC CVAU, &lt;Xt&gt;</hint>
			<hint page="355" header="Data or unified Cache line Invalidate by Set/Way" doc_id="armv8arm" token="ISW">Invalidate data cache by set/way.

Bits [63:32] - Reserved, RES0.
SetWay, bits [31:4] - Contains fields:
             Way, bits[31:32-A], the number of the way to operate on.
             Set, bits[B-1:L], the number of the set to operate on.
             Bits[L-1:4] are RES0.
Level, bits [3:1] - Cache level to operate on, minus 1
Bit [0]      - Reserved, RES0.

Example: DC ISW, &lt;Xt&gt;</hint>
			<hint page="357" header="Data or unified Cache line Invalidate by VA to PoC" doc_id="armv8arm" token="IVAC">Invalidate data cache by address to Point of Coherency.
Bits [63:0] - Virtual address to use.

Example: DC IVAC, &lt;Xt&gt;</hint>
			<hint page="359" header="Data Cache Zero by VA" doc_id="armv8arm" token="ZVA">Zero data cache by address. 
Zeroes a naturally aligned block of N bytes, where the size of N is identified in DCZID_EL0.

Bits [63:0] - Virtual address to use. There is no alignment restriction on the address 
              within the block of N bytes that is used.

Example: DC ZVA, &lt;Xt&gt;</hint>
			<hint page="361" header="Instruction Cache Invalidate All to PoU" doc_id="armv8arm" token="IALLU">Invalidate all instruction caches to Point of Unification.

Example: IC IALLU</hint>
			<hint page="362" header="Instruction Cache Invalidate All to PoU, Inner Shareable" doc_id="armv8arm" token="IALLUIS">Invalidate all instruction caches in Inner Shareable domain to Point of Unification.

Example: IC IALLUIS</hint>
			<hint page="363" header="Instruction Cache line Invalidate by VA to PoU" doc_id="armv8arm" token="IVAU">Invalidate instruction cache by address to Point of Unification.

Bits [63:0] - Virtual address to use.

Example: IC IVAU, &lt;Xt&gt;</hint>
		</group>
		<group type="reg" name="A64 System Registers (address translation)">
			<hint page="366" header="Address Translate Stages 1 and 2 EL0 Read " doc_id="armv8arm" token="S12E0R">Performs stage 1 and 2 address translations as defined for EL0, 
with permissions as if reading from the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S12E0R, &lt;Xt&gt;</hint>
			<hint page="367" header="Address Translate Stages 1 and 2 EL0 Write" doc_id="armv8arm" token="S12E0W">Performs stage 1 and 2 address translations as defined for EL0, 
with permissions as if writing to the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S12E0W, &lt;Xt&gt;</hint>
			<hint page="368" header="Address Translate Stages 1 and 2 EL1 Read" doc_id="armv8arm" token="S12E1R">Performs stage 1 and 2 address translations as defined for EL1, 
with permissions as if reading from the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S12E1R, &lt;Xt&gt;</hint>
			<hint page="369" header="Address Translate Stages 1 and 2 EL1 Write" doc_id="armv8arm" token="S12E1W">Performs stage 1 and 2 address translations as defined for EL1, 
with permissions as if writing to the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S12E1W, &lt;Xt&gt;</hint>
			<hint page="370" header="Address Translate Stage 1 EL0 Read" doc_id="armv8arm" token="S1E0R">Performs stage 1 address translation as defined for EL0, 
with permissions as if reading from the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E0R, &lt;Xt&gt;</hint>
			<hint page="371" header="Address Translate Stage 1 EL0 Write" doc_id="armv8arm" token="S1E0W">Performs stage 1 address translation as defined for EL0, 
with permissions as if writing to the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E0W, &lt;Xt&gt;</hint>
			<hint page="372" header="Address Translate Stage 1 EL1 Read " doc_id="armv8arm" token="S1E1R">Performs stage 1 address translation as defined for EL1, 
with permissions as if reading from the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E1R, &lt;Xt&gt;</hint>
			<hint page="373" header="Address Translate Stage 1 EL1 Write" doc_id="armv8arm" token="S1E1W">Performs stage 1 address translation as defined for EL1, 
with permissions as if writing to the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E1W, &lt;Xt&gt;</hint>
			<hint page="374" header="Address Translate Stage 1 EL2 Read" doc_id="armv8arm" token="S1E2R">Performs stage 1 address translation as defined for EL2, 
with permissions as if reading from the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E2R, &lt;Xt&gt;</hint>
			<hint page="375" header="Address Translate Stage 1 EL2 Write" doc_id="armv8arm" token="S1E2W">Performs stage 1 address translation as defined for EL2, 
with permissions as if writing to the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E2W, &lt;Xt&gt;</hint>
			<hint page="376" header="Address Translate Stage 1 EL3 Read" doc_id="armv8arm" token="S1E3R">Performs stage 1 address translation as defined for EL3, 
with permissions as if reading from the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

Example: AT S1E3R, &lt;Xt&gt;</hint>
			<hint page="377" header="Address Translate Stage 1 EL3 Write" doc_id="armv8arm" token="S1E3W">Performs stage 1 address translation as defined for EL3, 
with permissions as if writing to the given virtual address.

Bits [63:0] - Input address for translation. The resulting 
              address can be read from the PAR_EL1.

AT S1E3W, &lt;Xt&gt;</hint>
		</group>
		<group type="reg" name="A64 System Registers (TLB maintenance)">
			<hint page="379" header="TLB Invalidate All, EL1" doc_id="armv8arm" token="ALLE1">Invalidate all EL1&amp;0 regime stage 1 and 2 TLB entries.

Example: TLBI ALLE1</hint>
			<hint page="380" header="TLB Invalidate All, EL1, Inner Shareable" doc_id="armv8arm" token="ALLE1IS">Invalidate all EL1&amp;0 regime stage 1 and 2 TLB entries on 
all PEs in the same Inner Shareable domain.

Example: TLBI ALLE1IS</hint>
			<hint page="381" header="TLB Invalidate All, EL2" doc_id="armv8arm" token="ALLE2">Invalidate all EL2 regime stage 1 TLB entries.

Example: TLBI ALLE2</hint>
			<hint page="382" header="TLB Invalidate All, EL2, Inner Shareable" doc_id="armv8arm" token="ALLE2IS">Invalidate all EL2 regime stage 1 TLB entries on all PEs 
in the same Inner Shareable domain.

Example: TLBI ALLE2IS</hint>
			<hint page="383" header="TLB Invalidate All, EL3" doc_id="armv8arm" token="ALLE3">Invalidate all EL3 regime stage 1 TLB entries.

Example: TLBI ALLE3</hint>
			<hint page="384" header="TLB Invalidate All, EL3, Inner Shareable" doc_id="armv8arm" token="ALLE3IS">Invalidate all EL3 regime stage 1 TLB entries on all 
PEs in the same Inner Shareable domain.

Example: TLBI ALLE3IS</hint>
			<hint page="385" header="TLB Invalidate by ASID, EL1" doc_id="armv8arm" token="ASIDE1">Invalidate EL1&amp;0 regime stage 1 TLB entries for 
the given ASID and the current VMID.

ASID, bits [63:48] - ASID value to match. Any appropriate TLB 
                     entries that match the ASID values will 
                     be affected by this operation.
Bits [47:0]        - Reserved, RES0.


Example: TLBI ASIDE1, &lt;Xt&gt;</hint>
			<hint page="387" header="TLB Invalidate by ASID, EL1, Inner Shareable" doc_id="armv8arm" token="ASIDE1IS">Invalidate EL1&amp;0 regime stage 1 TLB entries for the given ASID and 
the current VMID on all PEs in the same Inner Shareable domain.

ASID, bits [63:48] - ASID value to match. Any appropriate TLB entries 
                     that match the ASID values will be affected by 
                     this operation.
Bits [47:0]        - Reserved, RES0.

Example: TLBI ASIDE1IS, &lt;Xt&gt;</hint>
			<hint page="389" header="TLB Invalidate by Intermediate Physical Address, Stage 2, EL1" doc_id="armv8arm" token="IPAS2E1">Invalidate EL1&amp;0 regime stage 2 TLB entries for the given IPA 
and the current VMID.

Bits [63:36]           - Reserved, RES0.
IPA[47:12], bits[35:0] - Bits[47:12] of the intermediate physical 
                         address to match.

Example: TLBI IPAS2E1, &lt;Xt&gt;</hint>
			<hint page="390" header="TLB Invalidate by Intermediate Physical Address, Stage 2, EL1, Inner Shareable" doc_id="armv8arm" token="IPAS2E1IS">Invalidate EL1&amp;0 regime stage 2 TLB entries for the given IPA and the current 
VMID on all PEs in the same Inner Shareable domain.

Bits [63:36]           - Reserved, RES0.
IPA[47:12], bits[35:0] - Bits[47:12] of the intermediate physical 
                         address to match.

Example: TLBI IPAS2E1IS, &lt;Xt&gt;</hint>
			<hint page="392" header="TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, EL1" doc_id="armv8arm" token="IPAS2LE1">Invalidate EL1&amp;0 regime stage 2 TLB entries for the last level of translation, 
the given IPA, and the current VMID.

Bits [63:36]           - Reserved, RES0.
IPA[47:12], bits[35:0] - Bits[47:12] of the intermediate physical 
                         address to match.

Example: TLBI IPAS2LE1, &lt;Xt&gt;</hint>
			<hint page="393" header="TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, EL1, Inner Shareable" doc_id="armv8arm" token="IPAS2LE1IS">Invalidate EL1&amp;0 regime stage 2 TLB entries for the last level of translation, 
the given IPA, and the current VMID, on all PEs in the same 
Inner Shareable domain.

Bits [63:36]           - Reserved, RES0.
IPA[47:12], bits[35:0] - Bits[47:12] of the intermediate physical 
                         address to match.

Example: TLBI IPAS2LE1IS, &lt;Xt&gt;</hint>
			<hint page="395" header="TLB Invalidate by VA, All ASID, EL1" doc_id="armv8arm" token="VAAE1">Invalidate EL1&amp;0 regime stage 1 TLB entries for the 
given VA and the current VMID.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the VA 
                         will be affected by this operation, regardless 
                         of the ASID. 

Example: TLBI VAAE1, &lt;Xt&gt;</hint>
			<hint page="397" header="TLB Invalidate by VA, All ASID, EL1, Inner Shareable" doc_id="armv8arm" token="VAAE1IS">Invalidate EL1&amp;0 regime stage 1 TLB entries for the given VA and the 
current VMID on all PEs in the same Inner Shareable domain.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the VA 
                         will be affected by this operation, regardless 
                         of the ASID. 

Example: TLBI VAAE1IS, &lt;Xt&gt;</hint>
			<hint page="399" header="TLB Invalidate by VA, All ASID, Last level, EL1" doc_id="armv8arm" token="VAALE1">Invalidate EL1&amp;0 regime stage 1 TLB entries for the last level of 
translation table walk, the given VA, and the current VMID.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the VA 
                         will be affected by this operation, regardless 
                         of the ASID. 

Example: TLBI VAALE1, &lt;Xt&gt;</hint>
			<hint page="401" header="TLB Invalidate by VA, All ASID, EL1, Inner Shareable" doc_id="armv8arm" token="VAALE1IS">Invalidate EL1&amp;0 regime stage 1 TLB entries for the last level of 
translation table walk, the given VA, and the current VMID, on all 
PEs in the same Inner Shareable domain.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the VA 
                         will be affected by this operation, regardless 
                         of the ASID. 

Example: TLBI VAALE1IS, &lt;Xt&gt;</hint>
			<hint page="403" header="TLB Invalidate by VA, EL1" doc_id="armv8arm" token="VAE1">Invalidate EL1&amp;0 regime stage 1 TLB entries for the given VA and 
ASID and the current VMID.

ASID, bits [63:48]     - ASID value to match. Any TLB entries that match 
                         the ASID value and VA value will be affected by 
                         this operation.
                         Global TLB entries that match the VA value will 
                         be affected by this operation, regardless of the 
                         value of the ASID field.
Bits [47:44]           - Reserved, RES0
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. Any 
                         appropriate TLB entries that match the ASID value 
                         (if appropriate) and VA will be affected by this 
                         operation.

Example: TLBI VAE1, &lt;Xt&gt;</hint>
			<hint page="405" header="TLB Invalidate by VA, EL1, Inner Shareable" doc_id="armv8arm" token="VAE1IS">Invalidate EL1&amp;0 regime stage 1 TLB entries for the given VA and ASID, and 
the current VMID, on all PEs in the same Inner Shareable domain.

ASID, bits [63:48]     - ASID value to match. Any TLB entries that match 
                         the ASID value and VA value will be affected by 
                         this operation.
                         Global TLB entries that match the VA value will 
                         be affected by this operation, regardless of the 
                         value of the ASID field.
Bits [47:44]           - Reserved, RES0
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. Any 
                         appropriate TLB entries that match the ASID value 
                         (if appropriate) and VA will be affected by this 
                         operation.

Example: TLBI VAE1IS, &lt;Xt&gt;</hint>
			<hint page="407" header="TLB Invalidate by VA, EL2" doc_id="armv8arm" token="VAE2">Invalidate EL2 regime stage 1 TLB entries for the given VA.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation.

Example: TLBI VAE2, &lt;Xt&gt;</hint>
			<hint page="409" header="" doc_id="armv8arm" token="VAE2IS">Invalidate EL2 regime stage 1 TLB entries for the given VA on all PEs 
in the same Inner Shareable domain.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VAE2IS, &lt;Xt&gt;</hint>
			<hint page="411" header="TLB Invalidate by VA, EL3" doc_id="armv8arm" token="VAE3">Invalidate EL3 regime stage 1 TLB entries for the given VA.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VAE3, &lt;Xt</hint>
			<hint page="413" header="TLB Invalidate by VA, EL3, Inner Shareable" doc_id="armv8arm" token="VAE3IS">Invalidate EL3 regime stage 1 TLB entries for the given VA on 
all PEs in the same Inner Shareable domain.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VAE3IS, &lt;Xt&gt;</hint>
			<hint page="415" header="TLB Invalidate by VA, Last level, EL1" doc_id="armv8arm" token="VALE1">Invalidate EL1&amp;0 regime stage 1 TLB entries for the last level of 
translation table walk, the given VA and ASID, and the current VMID.

ASID, bits [63:48]     - ASID value to match. Any TLB entries that match 
                         the ASID value and VA value will be affected by 
                         this operation.
                         Global TLB entries that match the VA value will 
                         be affected by this operation, regardless of the 
                         value of the ASID field.
Bits [47:44]           - Reserved, RES0
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. Any 
                         appropriate TLB entries that match the ASID value 
                         (if appropriate) and VA will be affected by this 
                         operation.

Example: TLBI VALE1, &lt;Xt&gt;</hint>
			<hint page="417" header="TLB Invalidate by VA, Last level, EL1, Inner Shareable" doc_id="armv8arm" token="VALE1IS">Invalidate EL1&amp;0 regime stage 1 TLB entries for the last level of 
translation table walk, the given VA and ASID, and the current VMID, 
on all PEs in the same Inner Shareable domain.

ASID, bits [63:48]     - ASID value to match. Any TLB entries that match 
                         the ASID value and VA value will be affected by 
                         this operation.
                         Global TLB entries that match the VA value will 
                         be affected by this operation, regardless of the 
                         value of the ASID field.
Bits [47:44]           - Reserved, RES0
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. Any 
                         appropriate TLB entries that match the ASID value 
                         (if appropriate) and VA will be affected by this 
                         operation.

Example: TLBI VALE1IS, &lt;Xt&gt;</hint>
			<hint page="419" header="TLB Invalidate by VA, Last level, EL2" doc_id="armv8arm" token="VALE2">Invalidate EL2 regime stage 1 TLB entries for the last level 
of translation table walk and the given VA.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VALE2, &lt;Xt&gt;</hint>
			<hint page="421" header="TLB Invalidate by VA, Last level, EL2, Inner Shareable" doc_id="armv8arm" token="VALE2IS">Invalidate EL2 regime stage 1 TLB entries for the last level of 
translation table walk and the given VA on all PEs in the same 
Inner Shareable domain.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VALE2IS, &lt;Xt&gt;</hint>
			<hint page="423" header="TLB Invalidate by VA, Last level, EL3" doc_id="armv8arm" token="VALE3">Invalidate EL3 regime stage 1 TLB entries for the last level of 
translation table walk and the given VA.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VALE3, &lt;Xt&gt;</hint>
			<hint page="425" header="TLB Invalidate by VA, Last level, EL3, Inner Shareable" doc_id="armv8arm" token="VALE3IS">Invalidate EL3 regime stage 1 TLB entries for the last level of 
translation table walk and the given VA on all PEs in the same 
Inner Shareable domain.

Bits [63:44]           - Reserved, RES0.
VA[55:12], bits [43:0] - Bits[55:12] of the virtual address to match. 
                         Any appropriate TLB entries that match the 
                         ASID value (if appropriate) and VA will be 
                         affected by this operation. 

Example: TLBI VALE3IS, &lt;Xt&gt;</hint>
			<hint page="427" header="TLB Invalidate by VMID, All at stage 1, EL1" doc_id="armv8arm" token="VMALLE1">Invalidate all EL1&amp;0 regime stage 1 TLB entries for the current VMID.

Example: TLBI VMALLE1</hint>
			<hint page="428" header="TLB Invalidate by VMID, All at stage 1, EL1, Inner Shareable" doc_id="armv8arm" token="VMALLE1IS">Invalidate all EL1&amp;0 regime stage 1 TLB entries for the current 
VMID on all PEs in the same Inner Shareable domain.

Example: TLBI VMALLE1IS</hint>
			<hint page="429" header="TLB Invalidate by VMID, All at Stage 1 and 2, EL1" doc_id="armv8arm" token="VMALLS12E1">Invalidate all EL1&amp;0 regime stage 1 and 2 TLB entries 
for the current VMID.

Example: TLBI VMALLS12E1</hint>
			<hint page="430" header="TLB Invalidate by VMID, All at Stage 1 and 2, EL1, Inner Shareable" doc_id="armv8arm" token="VMALLS12E1IS">Invalidate all EL1&amp;0 regime stage 1 and 2 TLB entries for the current 
VMID on all PEs in the same Inner Shareable domain.

Example: TLBI VMALLS12E1IS</hint>
		</group>
		<group type="reg" name="A64 System Registers (Control)">
			<hint page="1896" header="Auxiliary Control Register (EL1)" doc_id="armv8arm" token="ACTLR_EL1">Provides IMPLEMENTATION DEFINED configuration and 
control options for execution at EL1 and EL0.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1897" header="Auxiliary Control Register (EL2)" doc_id="armv8arm" token="ACTLR_EL2">Provides IMPLEMENTATION DEFINED configuration and
control options for EL2.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1898" header="Auxiliary Control Register (EL3)" doc_id="armv8arm" token="ACTLR_EL3">Provides IMPLEMENTATION DEFINED configuration and
control options for EL3.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1899" header="Auxiliary Fault Status Register 0 (EL1)" doc_id="armv8arm" token="AFSR0_EL1">Provides additional IMPLEMENTATION DEFINED fault 
status information for exceptions taken to EL1.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1900" header="Auxiliary Fault Status Register 0 (EL2) " doc_id="armv8arm" token="AFSR0_EL2">Provides additional IMPLEMENTATION DEFINED fault 
status information for exceptions taken to EL2.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1901" header="Auxiliary Fault Status Register 0 (EL3)" doc_id="armv8arm" token="AFSR0_EL3">Provides additional IMPLEMENTATION DEFINED fault 
status information for exceptions taken to EL3.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1902" header="Auxiliary Fault Status Register 1 (EL1)" doc_id="armv8arm" token="AFSR1_EL1">Provides additional IMPLEMENTATION DEFINED fault 
status information for exceptions taken to EL1.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1903" header="AFSR1_EL2, Auxiliary Fault Status Register 1 (EL2)" doc_id="armv8arm" token="AFSR1_EL2">Provides additional IMPLEMENTATION DEFINED fault 
status information for exceptions taken to EL2.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1904" header="Auxiliary Fault Status Register 1 (EL3)" doc_id="armv8arm" token="AFSR1_EL3">Provides additional IMPLEMENTATION DEFINED fault 
status information for exceptions taken to EL3.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1905" header="Auxiliary ID Register" doc_id="armv8arm" token="AIDR_EL1">Provides IMPLEMENTATION DEFINED identification information.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1906" header="Auxiliary Memory Attribute Indirection Register (EL1)" doc_id="armv8arm" token="AMAIR_EL1">Provides IMPLEMENTATION DEFINED memory attributes 
for the memory regions specified by MAIR_EL1.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1908" header="Auxiliary Memory Attribute Indirection Register (EL2)" doc_id="armv8arm" token="AMAIR_EL2">Provides IMPLEMENTATION DEFINED memory attributes 
for the memory regions specified by MAIR_EL2.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1909" header="Auxiliary Memory Attribute Indirection Register (EL3)" doc_id="armv8arm" token="AMAIR_EL3">Provides IMPLEMENTATION DEFINED memory attributes 
for the memory regions specified by MAIR_EL3.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1910" header="Current Cache Size ID Register" doc_id="armv8arm" token="CCSIDR_EL1">Provides information about the architecture 
of the currently selected cache.

              bits [31:28] - Reserved, UNKNOWN.
     NumSets, bits [27:13] - (Number of sets in cache) - 1, therefore 
                             a value of 0 indicates 1 set in the cache. 
                             The number of sets does not have to be a 
                             power of 2.
Associativity, bits [12:3] - (Associativity of cache) - 1, therefore 
                             a value of 0 indicates an associativity 
                             of 1. The associativity does not have 
                             to be a power of 2.
     LineSize, bits [2:0]  - (Log2(Number of bytes in cache line)) - 4.</hint>
			<hint page="1912" header="Cache Level ID Register" doc_id="armv8arm" token="CLIDR_EL1">Identifies the type of cache, or caches, that are implemented at each level 
and can be managed using the architected cache maintenance instructions that 
operate by set/way, up to a maximum of seven levels. Also identifies the 
Level of Coherence (LoC) and Level of Unification (LoU) for the cache hierarchy.

Bits [63:33]       - Reserved, RES0
ICB, bits [32:30]  - Inner cache boundary. This field indicates the boundary for 
                     caching Inner Cacheable memory regions.
                       000 Not disclosed by this mechanism.
                       001 L1 cache is the highest Inner Cacheable level.
                       010 L2 cache is the highest Inner Cacheable level.
                       011 L3 cache is the highest Inner Cacheable level.
                       100 L4 cache is the highest Inner Cacheable level.
                       101 L5 cache is the highest Inner Cacheable level.
                       110 L6 cache is the highest Inner Cacheable level.
                       111 L7 cache is the highest Inner Cacheable level.
LoUU, bits [29:27]  - Level of Unification Uniprocessor for the cache hierarchy.
LoC, bits [26:24]   - Level of Coherence for the cache hierarchy.
LoUIS, bits [23:21] - Level of Unification Inner Shareable for the cache hierarchy.
Ctype&lt;n&gt;, bits [3(n-1)+2:3(n-1)], for n = 1 to 7 - 
                    Cache Type fields. Indicate the type of cache that is implemented 
                    and can be managed using the architected cache maintenance instructions 
                    that operate by set/way at each level, from Level 1 up to a maximum of 
                    seven levels of cache hierarchy.
                      000 No cache.
                      001 Instruction cache only.
                      010 Data cache only.
                      011 Separate instruction and data caches.
                      100 Unified cache.</hint>
			<hint page="1914" header="Context ID Register (EL1)" doc_id="armv8arm" token="CONTEXTIDR_EL1">Identifies the current Process Identifier.
The value of the whole of this register is called the Context ID and is used by:
- The debug logic, for Linked and Unlinked Context ID matching.
- The trace logic, to identify the current process.

PROCID, bits [31:0] - Process Identifier. This field must be programmed with a 
                      unique value that identifies the current process.</hint>
			<hint page="1916" header="Architectural Feature Access Control Register" doc_id="armv8arm" token="CPACR_EL1">Controls access to trace, and to Advanced SIMD and floating-point functionality.

Bits [31:29]       - Reserved, RES0
TTA, bit [28]      - Traps EL0 and EL1 System register accesses to all implemented trace 
                     registers to EL1, from both Execution states.
                       0 EL0 and EL1 System register accesses to all implemented trace 
                         registers are not trapped to EL1.
                       1 EL0 and EL1 System register accesses to all implemented trace 
                         registers are trapped to EL1.
Bits [27:22]       - Reserved, RES0
FPEN, bits [21:20] - Traps EL0 and EL1 accesses to the SIMD and floating-point 
                     registers to EL1, from both Execution states.
                       00 Causes any instructions in EL0 or EL1 that use the registers 
                          associated with floating-point and Advanced SIMD execution to 
                          be trapped.
                       01 Causes any instructions in EL0 that use the registers associated 
                          with floating-point and Advanced SIMD execution to be trapped, 
                          but does not cause any instruction in EL1 to be trapped.
                       10 Causes any instructions in EL0 or EL1 that use the registers 
                          associated with floating-point and Advanced SIMD execution to 
                          be trapped.
                       11 Does not cause any instruction to be trapped.
Bits [19:0]        - Reserved, RES0.</hint>
			<hint page="1918" header="Architectural Feature Trap Register (EL2)" doc_id="armv8arm" token="CPTR_EL2">Controls trapping to EL2 of access to CPACR, CPACR_EL1, trace functionality 
and registers associated with Advanced SIMD and floating-point execution. 
Also controls EL2 access to this functionality.

TCPAC, bit [31] - Traps Non-secure EL1 accesses to the CPACR_EL1 or CPACR to 
                  EL2, from both Execution states. 
                    0 This control has no effect on Non-secure EL1 accesses
                      to the CPACR_EL1 or CPACR. 
                    1 Non-secure EL1 accesses to the CPACR_EL1 or CPACR are 
                      trapped to EL2.
Bits [30:21]    - Reserved, RES0.
TTA, bit [20]   - Traps Non-secure System register accesses to the trace 
                  registers to EL2, from both Execution states.
                    0 Non-secure System register accesses to the trace 
                      registers are not trapped to EL2.
                    1 Any attempt at EL2, or Non-secure EL0 or EL1, to execute
                      a System register access to a trace register is trapped 
                      to EL2, subject to the exception prioritization rules.
Bits [19:14]    - Reserved, RES0.
Bits [13:12]    - Reserved, RES1.
Bit [11]        - Reserved, RES0.
TFP, bit [10]   - Traps Non-secure accesses to SIMD and floating-point 
                  functionality to EL2, from both Execution states.
                    0 Does not cause any instruction to be trapped.
                    1 Any attempt at EL2, or Non-secure EL0 or EL1, to execute
                      an instruction that uses the registers associated with 
                      floating-point and Advanced SIMD execution is trapped to 
                      EL2, subject to the exception prioritization rules.
Bits [9:0]      - Reserved, RES1.</hint>
			<hint page="1920" header="Architectural Feature Trap Register (EL3)" doc_id="armv8arm" token="CPTR_EL3">Controls trapping to EL3 of access to CPACR_EL1, CPACR_EL2, trace functionality 
and registers associated with Advanced SIMD and floating-point execution. 
Also controls EL3 access to this functionality.

TCPAC, bit [31] - Traps Non-secure EL3 accesses to the CPACR_EL2 or CPACR to 
                  EL2, from both Execution states. 
                    0 This control does not cause any accesses to CPACR_EL1, 
                      CPTR_EL2, CPACR, or HCPTR to trap to EL3. 
                    1 EL2 accesses to the CPTR_EL2 or HCPTR, and EL2 and EL1 
                      accesses to the CPACR_EL1 or CPACR, are trapped to EL3 
                      if they are not trapped to EL2 by the CPTR_EL2.TCPAC 
                      control.
Bits [30:21]    - Reserved, RES0.
TTA, bit [20]   - Traps System register accesses to the trace registers, from 
                  all Exception levels, both Security states, and both 
                  Execution states, to EL3.
                    0 Does not cause any instruction to be trapped.

                    1 Any System register access to the trace registers is 
                      trapped to EL3, subject to the exception prioritization 
                      rules.
Bits [19:11]    - Reserved, RES0.
TFP, bit [10]   - Traps all accesses to Advanced SIMD and floating-point 
                  functionality, from all Exception levels, both Security states,
                  and both Execution states, to EL3.
                    0 Does not cause any instruction to be trapped.
                    1 Any attempt at any Exception level to execute an instruction 
                      that uses the registers associated with Advanced SIMD and 
                      floating-point is trapped to EL3, subject to the exception 
                      prioritization rules.
Bits [9:0]      - Reserved, RES1.</hint>
			<hint page="1922" header="Cache Size Selection Register" doc_id="armv8arm" token="CSSELR_EL1">Selects the current Cache Size ID Register, CCSIDR_EL1, 
by specifying the required cache level and the cache 
type (either instruction or data cache).

Bits [31:4]       - Reserved, RES0.
Level, bits [3:1] - Cache level of required cache.
                      000 Level 1 cache
                      001 Level 2 cache
                      010 Level 3 cache
                      011 Level 4 cache
                      100 Level 5 cache
                      101 Level 6 cache
                      110 Level 7 cache
InD, bit [0]      - Instruction not Data bit.
                      0 Data or unified cache.
                      1 Instruction cache.</hint>
			<hint page="1924" header="Cache Type Register " doc_id="armv8arm" token="CTR_EL0">Provides information about the architecture of the caches.

TBD</hint>
			<hint page="1926" header="Domain Access Control Register" doc_id="armv8arm" token="DACR32_EL2">Allows access to the AArch32 DACR register from AArch64 state only. 
Its value has no effect on execution in AArch64 state.

TBD</hint>
			<hint page="1928" header="Data Cache Zero ID register" doc_id="armv8arm" token="DCZID_EL0">Indicates the block size that is written with byte values of 0 
by the DC ZVA (Data Cache Zero by Address) system instruction.

TBD</hint>
			<hint page="1930" header="Exception Syndrome Register (EL1) " doc_id="armv8arm" token="ESR_EL1">Holds syndrome information for an exception taken to EL1.

EC, bits [31:26] - Exception Class. Indicates the reason for the 
                   exception that this register holds information about.
IL, bit [25]     - Instruction Length for synchronous exceptions.
ISS, bits [24:0] - Instruction Specific Syndrome. Architecturally, this 
                   field can be defined independently for each defined 
                   Exception class. However, in practice, some ISS encodings 
                   are used for more than one Exception class.</hint>
			<hint page="1931" header="Exception Syndrome Register (EL2)" doc_id="armv8arm" token="ESR_EL2">Holds syndrome information for an exception taken to EL2.

EC, bits [31:26] - Exception Class. Indicates the reason for the 
                   exception that this register holds information about.
IL, bit [25]     - Instruction Length for synchronous exceptions.
ISS, bits [24:0] - Instruction Specific Syndrome. Architecturally, this 
                   field can be defined independently for each defined 
                   Exception class. However, in practice, some ISS encodings 
                   are used for more than one Exception class.</hint>
			<hint page="1932" header="Exception Syndrome Register (EL3)" doc_id="armv8arm" token="ESR_EL3">Holds syndrome information for an exception taken to EL3.

EC, bits [31:26] - Exception Class. Indicates the reason for the 
                   exception that this register holds information about.
IL, bit [25]     - Instruction Length for synchronous exceptions.
ISS, bits [24:0] - Instruction Specific Syndrome. Architecturally, this 
                   field can be defined independently for each defined 
                   Exception class. However, in practice, some ISS encodings 
                   are used for more than one Exception class.</hint>
			<hint page="1965" header="Fault Address Register (EL1)" doc_id="armv8arm" token="FAR_EL1">Holds the faulting Virtual Address for all synchronous Instruction 
or Data Abort, PC alignment fault and Watchpoint exceptions that 
are taken to EL1.

Bits [63:0] - Faulting Virtual Address for synchronous exceptions 
              taken to EL1.</hint>
			<hint page="1967" header="Fault Address Register (EL2)" doc_id="armv8arm" token="FAR_EL2">Holds the faulting Virtual Address for all synchronous Instruction 
or Data Abort, PC alignment fault and Watchpoint exceptions that 
are taken to EL2.

Bits [63:0] - Faulting Virtual Address for synchronous exceptions 
              taken to EL2.</hint>
			<hint page="1969" header="Fault Address Register (EL3)" doc_id="armv8arm" token="FAR_EL3">Holds the faulting Virtual Address for all synchronous Instruction 
or Data Abort, PC alignment fault and Watchpoint exceptions that 
are taken to EL3.

Bits [63:0] - Faulting Virtual Address for synchronous exceptions 
              taken to EL3.</hint>
			<hint page="1971" header="Floating-Point Exception Control register" doc_id="armv8arm" token="FPEXC32_EL2">Allows access to the AArch32 register FPEXC from AArch64 state only. 
Its value has no effect on execution in AArch64 state.

TBD</hint>
			<hint page="1976" header="Hypervisor Auxiliary Control Register" doc_id="armv8arm" token="HACR_EL2">Controls trapping to EL2 of IMPLEMENTATION DEFINED aspects 
of Non-secure EL1 or EL0 operation.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1977" header="Hypervisor Configuration Register" doc_id="armv8arm" token="HCR_EL2">Provides configuration controls for virtualization, 
including defining whether various Non-secure 
operations are trapped to EL2.

TBD</hint>
			<hint page="1989" header="Hypervisor IPA Fault Address Register" doc_id="armv8arm" token="HPFAR_EL2">Holds the faulting IPA for some aborts on a stage 2 translation taken to EL2.

TBD</hint>
			<hint page="1991" header="Hypervisor System Trap Register" doc_id="armv8arm" token="HSTR_EL2">Controls trapping to Hyp mode of Non-secure accesses, at EL1 or 
lower in AArch32, to the System register in the coproc == 1111 
encoding space, by the CRn value used to access the register 
using MCR or MRC instruction. When the register is accessible 
using an MCRR or MRRC instruction, this is the CRm value used 
to access the register.

TBD</hint>
			<hint page="1993" header="AArch64 Auxiliary Feature Register 0" doc_id="armv8arm" token="ID_AA64AFR0_EL1">Provides information about the IMPLEMENTATION DEFINED 
features of the PE in AArch64.

Bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="1995" header="AArch64 Auxiliary Feature Register 1" doc_id="armv8arm" token="ID_AA64AFR1_EL1">Reserved for future expansion of information about the 
IMPLEMENTATION DEFINED features of the PE in AArch64.

Bits [63:0] - Reserved, RES0.</hint>
			<hint page="1996" header="AArch64 Debug Feature Register 0" doc_id="armv8arm" token="ID_AA64DFR0_EL1">Provides top level information about the debug system in AArch64.

TBD</hint>
			<hint page="1998" header="AArch64 Debug Feature Register 1" doc_id="armv8arm" token="ID_AA64DFR1_EL1">Reserved for future expansion of top level information about the debug system in AArch64.

Bits [63:0] - Reserved, RES0.</hint>
			<hint page="1999" header="AArch64 Instruction Set Attribute Register 0" doc_id="armv8arm" token="ID_AA64ISAR0_EL1">Provides information about the instructions implemented in AArch64 state.

TBD</hint>
			<hint page="2001" header="AArch64 Instruction Set Attribute Register 1" doc_id="armv8arm" token="ID_AA64ISAR1_EL1">Reserved for future expansion of the information about the 
instructions implemented in AArch64 state.

Bits [63:0] - Reserved, RES0.</hint>
			<hint page="2002" header="AArch64 Memory Model Feature Register 0" doc_id="armv8arm" token="ID_AA64MMFR0_EL1">Provides information about the implemented memory 
model and memory management support in AArch64.

TBD</hint>
			<hint page="2005" header="AArch64 Memory Model Feature Register 1" doc_id="armv8arm" token="ID_AA64MMFR1_EL1">Reserved for future expansion of the information about the implemented 
memory model and memory management support in AArch64.

Bits [63:0] - Reserved, RES0.</hint>
			<hint page="2006" header="AArch64 Processor Feature Register 0" doc_id="armv8arm" token="ID_AA64PFR0_EL1">Provides additional information about implemented PE features in AArch64.

TBD</hint>
			<hint page="2008" header="AArch64 Processor Feature Register 1" doc_id="armv8arm" token="ID_AA64PFR1_EL1">Reserved for future expansion of information 
about implemented PE features in AArch64.

Bits [63:0] - Reserved, RES0.</hint>
			<hint page="2051" header="Instruction Fault Status Register (EL2)" doc_id="armv8arm" token="IFSR32_EL2">Allows access to the AArch32 IFSR register from AArch64 state only. 
Its value has no effect on execution in AArch64 state.

TBD</hint>
			<hint page="2055" header="Interrupt Status Register" doc_id="armv8arm" token="ISR_EL1">Shows whether any IRQ, FIQ, or SError interrupt is pending. 
In an implementation that includes EL2, when the register 
is accessed from Non-secure EL1, a pending interrupt or 
external abort might be physical or virtual, and the 
architecture does not provide any mechanism that software 
executing at Non-secure EL1 can use to determine whether a 
pending interrupt or external abort is physical or virtual. 
For all other accesses, any indicated interrupt or external 
abort must be physical.

TBD</hint>
			<hint page="2057" header="Memory Attribute Indirection Register (EL1)" doc_id="armv8arm" token="MAIR_EL1">Provides the memory attribute encodings corresponding to the 
possible AttrIndx values in a Long-descriptor format 
translation table entry for stage 1 translations at EL1.

TBD</hint>
			<hint page="2059" header="Memory Attribute Indirection Register (EL2)" doc_id="armv8arm" token="MAIR_EL2">Provides the memory attribute encodings corresponding to the 
possible AttrIndx values in a Long-descriptor format translation 
table entry for stage 1 translations at EL2.

TBD</hint>
			<hint page="2061" header="Memory Attribute Indirection Register (EL3)" doc_id="armv8arm" token="MAIR_EL3">Provides the memory attribute encodings corresponding to the 
possible AttrIndx values in a Long-descriptor format translation 
table entry for stage 1 translations at EL3.

TBD</hint>
			<hint page="2063" header="Main ID Register" doc_id="armv8arm" token="MIDR_EL1">Provides identification information for the PE, including an 
implementer code for the device and a device ID number.

TBD</hint>
			<hint page="2065" header="Multiprocessor Affinity Register" doc_id="armv8arm" token="MPIDR_EL1">In a multiprocessor system, provides an additional PE 
identification mechanism for scheduling purposes.

TBD</hint>
			<hint page="2067" header="AArch32 Media and VFP Feature Register 0" doc_id="armv8arm" token="MVFR0_EL1">Describes the features provided by the AArch32 
Advanced SIMD and Floating-point implementation.

TBD</hint>
			<hint page="2070" header="AArch32 Media and VFP Feature Register 1 " doc_id="armv8arm" token="MVFR1_EL1">Describes the features provided by the AArch32 
Advanced SIMD and Floating-point implementation.

TBD</hint>
			<hint page="2073" header="AArch32 Media and VFP Feature Register 2" doc_id="armv8arm" token="MVFR2_EL1">Describes the features provided by the AArch32 
Advanced SIMD and Floating-point implementation.

TBD</hint>
			<hint page="2075" header="Physical Address Register" doc_id="armv8arm" token="PAR_EL1">Returns the output address (OA) from an address translation 
instruction that executed successfully, or fault information 
if the instruction did not execute successfully.

TBD</hint>
			<hint page="2079" header="Revision ID Register" doc_id="armv8arm" token="REVIDR_EL1">Provides implementation-specific minor revision information.

bits [31:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="2080" header="Reset Management Register (if EL2 and EL3 not implemented)" doc_id="armv8arm" token="RMR_EL1">When this register is implemented:
- A write to the register can request a Warm reset.
- If EL1 can use AArch32 and AArch64, this register 
  specifies the Execution state that the PE boots 
  into on a Warm reset.

TBD</hint>
			<hint page="2082" header="Reset Management Register (if EL2 implemented and EL3 not implemented)" doc_id="armv8arm" token="RMR_EL2">When this register is implemented:
- A write to the register can request a Warm reset.
- If EL2 can use AArch32 and AArch64, this register 
  specifies the Execution state that the PE boots 
  into on a Warm reset.

TBD</hint>
			<hint page="2084" header="Reset Management Register (if EL3 implemented) " doc_id="armv8arm" token="RMR_EL3">When this register is implemented:
- A write to the register can request a Warm reset.
- If EL3 can use AArch32 and AArch64, the register 
  specifies the Execution state that the PE boots 
  into on a Warm reset.

TBD</hint>
			<hint page="2086" header="Reset Vector Base Address Register (if EL2 and EL3 not implemented)" doc_id="armv8arm" token="RVBAR_EL1">If EL1 is the highest Exception level implemented, contains 
the IMPLEMENTATION DEFINED address that execution starts 
from after reset when executing in AArch64 state.

Bits [63:0] - Reset Address. The IMPLEMENTATION DEFINED address
              that execution starts from after reset when 
              executing in 64-bit state. Bits[1:0] of this 
              register are 00, as this address must be aligned, 
              and the address must be within the physical 
              address size supported by the PE.</hint>
			<hint page="2087" header="Reset Vector Base Address Register (if EL3 not implemented)" doc_id="armv8arm" token="RVBAR_EL2">If EL2 is the highest Exception level implemented, contains 
the IMPLEMENTATION DEFINED address that execution starts 
from after reset when executing in AArch64 state.

Bits [63:0] - Reset Address. The IMPLEMENTATION DEFINED address 
              that execution starts from after reset when 
              executing in 64-bit state. Bits[1:0] of this 
              register are 00, as this address must be aligned, 
              and the address must be within the physical 
              address size supported by the PE.</hint>
			<hint page="2088" header="Reset Vector Base Address Register (if EL3 implemented) " doc_id="armv8arm" token="RVBAR_EL3">If EL3 is the highest Exception level implemented, contains 
the IMPLEMENTATION DEFINED address that execution starts 
from after reset when executing in AArch64 state.

Bits [63:0] - Reset Address. The IMPLEMENTATION DEFINED address 
              that execution starts from after reset when 
              executing in 64-bit state. Bits[1:0] of this 
              register are 00, as this address must be aligned,
              and the address must be within the physical 
              address size supported by the PE.</hint>
			<hint page="2089" header="S3_&lt;op1&gt;_&lt;Cn&gt;_&lt;Cm&gt;_&lt;op2&gt;, IMPLEMENTATION DEFINED registers" doc_id="armv8arm" token="S3_">This area of the instruction set space is reserved 
for IMPLEMENTATION DEFINED registers.

bits [63:0] - IMPLEMENTATION DEFINED</hint>
			<hint page="2090" header="Secure Configuration Register" doc_id="armv8arm" token="SCR_EL3">Defines the configuration of the current Security state. It specifies:
- The Security state of EL0 and EL1, either Secure or Non-secure.
- The Execution state at lower Exception levels.
- Whether IRQ, FIQ, and External Abort interrupts are taken to EL3.

TBD</hint>
			<hint page="2094" header="System Control Register (EL1)" doc_id="armv8arm" token="SCTLR_EL1">Provides top level control of the system, 
including its memory system, at EL1 and EL0.

TBD</hint>
			<hint page="2101" header="System Control Register (EL2)" doc_id="armv8arm" token="SCTLR_EL2">Provides top level control of the system, 
including its memory system, at EL2.

TBD</hint>
			<hint page="2105" header="System Control Register (EL3)" doc_id="armv8arm" token="SCTLR_EL3">Provides top level control of the system, 
including its memory system, at EL3.

TBD</hint>
			<hint page="2109" header="Translation Control Register (EL1)" doc_id="armv8arm" token="TCR_EL1">Determines which of the Translation Table Base Registers 
defines the base address for a translation table walk 
required for the stage 1 translation of a memory access 
from EL0 or EL1. Also controls the translation table 
format and holds cacheability and shareability information.

TBD</hint>
			<hint page="2114" header="Translation Control Register (EL2)" doc_id="armv8arm" token="TCR_EL2">Controls translation table walks required for the stage 1 
translation of memory accesses from EL2, and holds 
cacheability and shareability information for the accesses.

TBD</hint>
			<hint page="2117" header="Translation Control Register (EL3)" doc_id="armv8arm" token="TCR_EL3">Controls translation table walks required for the stage 1 
translation of memory accesses from EL3, and holds 
cacheability and shareability information for the accesses.

TBD</hint>
			<hint page="2120" header="EL0 Read/Write Software Thread ID Register" doc_id="armv8arm" token="TPIDR_EL0">Provides a location where software executing at EL0 can store 
thread identifying information, for OS management purposes.

Bits [63:0] - Thread ID. Thread identifying information stored 
              by software running at this Exception level.</hint>
			<hint page="2121" header="EL1 Software Thread ID Register" doc_id="armv8arm" token="TPIDR_EL1">Provides a location where software executing at EL1 can store 
thread identifying information, for OS management purposes.

Bits [63:0] - Thread ID. Thread identifying information stored 
              by software running at this Exception level.</hint>
			<hint page="2122" header="EL2 Software Thread ID Register" doc_id="armv8arm" token="TPIDR_EL2">Provides a location where software executing at EL2 can store 
thread identifying information, for OS management purposes.

Bits [63:0] - Thread ID. Thread identifying information stored
              by software running at this Exception level.</hint>
			<hint page="2123" header="EL3 Software Thread ID Register" doc_id="armv8arm" token="TPIDR_EL3">Provides a location where software executing at EL3 can store 
thread identifying information, for OS management purposes.

Bits [63:0] - Thread ID. Thread identifying information stored 
              by software running at this Exception level.</hint>
			<hint page="2124" header="EL0 Read-Only Software Thread ID Register" doc_id="armv8arm" token="TPIDRRO_EL0">Provides a location where software executing at EL1 or higher 
can store thread identifying information that is visible to 
software executing at EL0, for OS management purposes.

Bits [63:0] - Thread ID. Thread identifying information stored 
              by software running at this Exception level.</hint>
			<hint page="2125" header="Translation Table Base Register 0 (EL1)" doc_id="armv8arm" token="TTBR0_EL1">Holds the base address of translation table 0, and information 
about the memory it occupies. 
This is one of the translation tables for the stage 1 
translation of memory accesses at EL0 and EL1.

ASID, bits [63:48] - An ASID for the translation table base address. 
                     The TCR_EL1.A1 field selects either TTBR0_EL1.ASID 
                     or TTBR1_EL1.ASID.
BADDR, bits [47:0] - Translation table base address, bits[47:x].</hint>
			<hint page="2127" header="Translation Table Base Register 0 (EL2)" doc_id="armv8arm" token="TTBR0_EL2">Holds the base address of the translation table for the 
stage 1 translation of memory accesses from EL2.

Bits [63:48]       - Reserved, RES0
BADDR, bits [47:0] - Translation table base address, bits[47:x].</hint>
			<hint page="2129" header="Translation Table Base Register 0 (EL3)" doc_id="armv8arm" token="TTBR0_EL3">Holds the base address of the translation table for the 
stage 1 translation of memory accesses from EL3.

Bits [63:48]       - Reserved, RES0
BADDR, bits [47:0] - Translation table base address, bits[47:x].</hint>
			<hint page="2131" header="Translation Table Base Register 1 (EL1)" doc_id="armv8arm" token="TTBR1_EL1">Holds the base address of translation table 1, and information 
about the memory it occupies.
This is one of the translation tables for the stage 1 
translation of memory accesses at EL0 and EL1.

ASID, bits [63:48] - An ASID for the translation table base address. 
                     The TCR_EL1.A1 field selects either TTBR0_EL1.ASID 
                     or TTBR1_EL1.ASID.
BADDR, bits [47:0] - Translation table base address, bits[47:x].</hint>
			<hint page="2133" header="Vector Base Address Register (EL1)" doc_id="armv8arm" token="VBAR_EL1">Holds the vector base address for any exception that is taken to EL1.

Bits [63:11] - Vector Base Address. Base address of the exception 
               vectors for exceptions taken to EL1.
Bits [10:0]  - Reserved, RES0.</hint>
			<hint page="2135" header="Vector Base Address Register (EL2)" doc_id="armv8arm" token="VBAR_EL2">Holds the vector base address for any exception that is taken to EL2.

Bits [63:11] - Vector Base Address. Base address of the exception 
               vectors for exceptions taken to EL2.
Bits [10:0]  - Reserved, RES0.</hint>
			<hint page="2137" header="Vector Base Address Register (EL3)" doc_id="armv8arm" token="VBAR_EL3">Holds the vector base address for any exception that is taken to EL3.

Bits [63:11] - Vector Base Address. Base address of the exception 
               vectors for exceptions taken to EL3.
Bits [10:0]  - Reserved, RES0.</hint>
			<hint page="2138" header="Virtualization Multiprocessor ID Register" doc_id="armv8arm" token="VMPIDR_EL2">Holds the value of the Virtualization Multiprocessor ID. 
This is the value returned by Non-secure EL1 reads of MPIDR_EL1.

TBD</hint>
			<hint page="2140" header="Virtualization Processor ID Register " doc_id="armv8arm" token="VPIDR_EL2">Holds the value of the Virtualization Processor ID. 
This is the value returned by Non-secure EL1 reads of MIDR_EL1.

TBD</hint>
			<hint page="2142" header="Virtualization Translation Control Register" doc_id="armv8arm" token="VTCR_EL2">Controls the translation table walks required for the stage 2 
translation of memory accesses from Non-secure EL0 and EL1, 
and holds cacheability and shareability information for the accesses.

TBD</hint>
			<hint page="2145" header="Virtualization Translation Table Base Register" doc_id="armv8arm" token="VTTBR_EL2">Holds the base address of the translation table for the stage 2 
translation of memory accesses from Non-secure EL0 and EL1.

TBD</hint>
		</group>
		<group type="reg" name="A64 System Registers (Debug)">
			<hint page="2148" header="Debug Authentication Status register" doc_id="armv8arm" token="DBGAUTHSTATUS_EL1">Provides information about the state of the IMPLEMENTATION DEFINED 
authentication interface for debug.</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 0" doc_id="armv8arm" token="DBGBCR0_EL1">Holds control information for a breakpoint. 
Forms breakpoint 0 together with value register DBGBVR0_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 1" doc_id="armv8arm" token="DBGBCR1_EL1">Holds control information for a breakpoint. 
Forms breakpoint 1 together with value register DBGBVR1_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 2" doc_id="armv8arm" token="DBGBCR2_EL1">Holds control information for a breakpoint. 
Forms breakpoint 2 together with value register DBGBVR2_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 3" doc_id="armv8arm" token="DBGBCR3_EL1">Holds control information for a breakpoint. 
Forms breakpoint 3 together with value register DBGBVR3_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 4" doc_id="armv8arm" token="DBGBCR4_EL1">Holds control information for a breakpoint. 
Forms breakpoint 4 together with value register DBGBVR4_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 5" doc_id="armv8arm" token="DBGBCR5_EL1">Holds control information for a breakpoint. 
Forms breakpoint 5 together with value register DBGBVR5_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 6" doc_id="armv8arm" token="DBGBCR6_EL1">Holds control information for a breakpoint. 
Forms breakpoint 6 together with value register DBGBVR6_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 7" doc_id="armv8arm" token="DBGBCR7_EL1">Holds control information for a breakpoint. 
Forms breakpoint 7 together with value register DBGBVR7_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 8" doc_id="armv8arm" token="DBGBCR8_EL1">Holds control information for a breakpoint. 
Forms breakpoint 8 together with value register DBGBVR8_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 9" doc_id="armv8arm" token="DBGBCR9_EL1">Holds control information for a breakpoint. 
Forms breakpoint 9 together with value register DBGBVR9_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 10" doc_id="armv8arm" token="DBGBCR10_EL1">Holds control information for a breakpoint. 
Forms breakpoint 10 together with value register DBGBVR10_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 11" doc_id="armv8arm" token="DBGBCR11_EL1">Holds control information for a breakpoint. 
Forms breakpoint 11 together with value register DBGBVR11_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 12" doc_id="armv8arm" token="DBGBCR12_EL1">Holds control information for a breakpoint. 
Forms breakpoint 12 together with value register DBGBVR12_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 13" doc_id="armv8arm" token="DBGBCR13_EL1">Holds control information for a breakpoint. 
Forms breakpoint 13 together with value register DBGBVR13_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 14" doc_id="armv8arm" token="DBGBCR14_EL1">Holds control information for a breakpoint. 
Forms breakpoint 14 together with value register DBGBVR14_EL1.

TBD</hint>
			<hint page="2150" header="Debug Breakpoint Control Register 15" doc_id="armv8arm" token="DBGBCR15_EL1">Holds control information for a breakpoint. 
Forms breakpoint 15 together with value register DBGBVR15_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 0" doc_id="armv8arm" token="DBGBVR0_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 0 together 
with control register DBGBCR0_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 1" doc_id="armv8arm" token="DBGBVR1_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 1 together 
with control register DBGBCR1_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 2" doc_id="armv8arm" token="DBGBVR2_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 2 together 
with control register DBGBCR2_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 3" doc_id="armv8arm" token="DBGBVR3_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 3 together 
with control register DBGBCR3_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 4" doc_id="armv8arm" token="DBGBVR4_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 4 together 
with control register DBGBCR4_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 5" doc_id="armv8arm" token="DBGBVR5_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 5 together 
with control register DBGBCR5_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 6" doc_id="armv8arm" token="DBGBVR6_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 6 together 
with control register DBGBCR6_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 7" doc_id="armv8arm" token="DBGBVR7_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 7 together 
with control register DBGBCR7_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 8" doc_id="armv8arm" token="DBGBVR8_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 8 together 
with control register DBGBCR8_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 9" doc_id="armv8arm" token="DBGBVR9_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 9 together 
with control register DBGBCR9_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 10" doc_id="armv8arm" token="DBGBVR10_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 10 together 
with control register DBGBCR10_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 11" doc_id="armv8arm" token="DBGBVR11_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 11 together 
with control register DBGBCR11_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 12" doc_id="armv8arm" token="DBGBVR12_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 12 together 
with control register DBGBCR12_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 13" doc_id="armv8arm" token="DBGBVR13_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 13 together 
with control register DBGBCR13_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 14" doc_id="armv8arm" token="DBGBVR14_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 14 together 
with control register DBGBCR14_EL1.

TBD</hint>
			<hint page="2153" header="Debug Breakpoint Value Register 15" doc_id="armv8arm" token="DBGBVR15_EL1">Holds a virtual address, or a VMID and/or a context ID, for 
use in breakpoint matching. Forms breakpoint 15 together 
with control register DBGBCR15_EL1.

TBD</hint>
			<hint page="2156" header="Debug Claim Tag Clear register" doc_id="armv8arm" token="DBGCLAIMCLR_EL1">Used by software to read the values of the CLAIM tag bits, 
and to clear these bits to 0. The architecture does not 
define any functionality for the CLAIM tag bits.


TBD</hint>
			<hint page="2158" header="Debug Claim Tag Set register " doc_id="armv8arm" token="DBGCLAIMSET_EL1">Used by software to set the CLAIM tag bits to 1.
The architecture does not define any functionality 
for the CLAIM tag bits.

TBD</hint>
			<hint page="2160" header="Debug Data Transfer Register, half-duplex" doc_id="armv8arm" token="DBGDTR_EL0">Transfers 64 bits of data between the PE and an external debugger. 
Can transfer both ways using only a single register.

TBD</hint>
			<hint page="2162" header="Debug Data Transfer Register, Receive" doc_id="armv8arm" token="DBGDTRRX_EL0">Transfers data from an external debugger to the PE. 
For example, it is used by a debugger transferring 
commands and data to a debug target. It is a 
component of the Debug Communications Channel.

TBD</hint>
			<hint page="2164" header="Debug Data Transfer Register, Transmit" doc_id="armv8arm" token="DBGDTRTX_EL0">Transfers data from the PE to an external debugger. 
For example, it is used by a debug target to transfer 
data to the debugger. It is a component of the 
Debug Communication Channel.

TBD</hint>
			<hint page="2166" header="Debug Power Control Register" doc_id="armv8arm" token="DBGPRCR_EL1">Controls behavior of the PE on powerdown request.

TBD</hint>
			<hint page="2168" header="Debug Vector Catch Register" doc_id="armv8arm" token="DBGVCR32_EL2">Allows access to the AArch32 register DBGVCR from 
AArch64 state only. Its value has no effect on 
execution in AArch64 state.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 0" doc_id="armv8arm" token="DBGWCR0_EL1">Holds control information for a watchpoint. 
Forms watchpoint 0 together with value register DBGWVR0_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 1" doc_id="armv8arm" token="DBGWCR1_EL1">Holds control information for a watchpoint. 
Forms watchpoint 1 together with value register DBGWVR1_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 2" doc_id="armv8arm" token="DBGWCR2_EL1">Holds control information for a watchpoint. 
Forms watchpoint 2 together with value register DBGWVR2_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 3" doc_id="armv8arm" token="DBGWCR3_EL1">Holds control information for a watchpoint. 
Forms watchpoint 3 together with value register DBGWVR3_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 4" doc_id="armv8arm" token="DBGWCR4_EL1">Holds control information for a watchpoint. 
Forms watchpoint 4 together with value register DBGWVR4_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 5" doc_id="armv8arm" token="DBGWCR5_EL1">Holds control information for a watchpoint. 
Forms watchpoint 5 together with value register DBGWVR5_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 6" doc_id="armv8arm" token="DBGWCR6_EL1">Holds control information for a watchpoint. 
Forms watchpoint 6 together with value register DBGWVR6_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 7" doc_id="armv8arm" token="DBGWCR7_EL1">Holds control information for a watchpoint. 
Forms watchpoint 7 together with value register DBGWVR7_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 8" doc_id="armv8arm" token="DBGWCR8_EL1">Holds control information for a watchpoint. 
Forms watchpoint 8 together with value register DBGWVR8_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 9" doc_id="armv8arm" token="DBGWCR9_EL1">Holds control information for a watchpoint. 
Forms watchpoint 9 together with value register DBGWVR9_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 10" doc_id="armv8arm" token="DBGWCR10_EL1">Holds control information for a watchpoint. 
Forms watchpoint 10 together with value register DBGWVR10_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 11" doc_id="armv8arm" token="DBGWCR11_EL1">Holds control information for a watchpoint. 
Forms watchpoint 11 together with value register DBGWVR11_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 12" doc_id="armv8arm" token="DBGWCR12_EL1">Holds control information for a watchpoint. 
Forms watchpoint 12 together with value register DBGWVR12_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 13" doc_id="armv8arm" token="DBGWCR13_EL1">Holds control information for a watchpoint. 
Forms watchpoint 13 together with value register DBGWVR13_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 14" doc_id="armv8arm" token="DBGWCR14_EL1">Holds control information for a watchpoint. 
Forms watchpoint 14 together with value register DBGWVR14_EL1.

TBD</hint>
			<hint page="2172" header="Debug Watchpoint Control Register 15" doc_id="armv8arm" token="DBGWCR15_EL1">Holds control information for a watchpoint. 
Forms watchpoint 15 together with value register DBGWVR15_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 0" doc_id="armv8arm" token="DBGWVR0_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 0 together with control register DBGWCR0_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 1" doc_id="armv8arm" token="DBGWVR1_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 1 together with control register DBGWCR1_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 2" doc_id="armv8arm" token="DBGWVR2_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 2 together with control register DBGWCR2_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 3" doc_id="armv8arm" token="DBGWVR3_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 3 together with control register DBGWCR3_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 4" doc_id="armv8arm" token="DBGWVR4_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 4 together with control register DBGWCR4_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 5" doc_id="armv8arm" token="DBGWVR5_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 5 together with control register DBGWCR5_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 6" doc_id="armv8arm" token="DBGWVR6_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 6 together with control register DBGWCR6_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 7" doc_id="armv8arm" token="DBGWVR7_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 7 together with control register DBGWCR7_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 8" doc_id="armv8arm" token="DBGWVR8_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 8 together with control register DBGWCR8_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 9" doc_id="armv8arm" token="DBGWVR9_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 9 together with control register DBGWCR9_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 10" doc_id="armv8arm" token="DBGWVR10_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 10 together with control register DBGWCR10_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 11" doc_id="armv8arm" token="DBGWVR11_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 11 together with control register DBGWCR11_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 12" doc_id="armv8arm" token="DBGWVR12_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 12 together with control register DBGWCR12_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 13" doc_id="armv8arm" token="DBGWVR13_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 13 together with control register DBGWCR13_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 14" doc_id="armv8arm" token="DBGWVR14_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 14 together with control register DBGWCR14_EL1.

TBD</hint>
			<hint page="2175" header="Debug Watchpoint Value Register 15" doc_id="armv8arm" token="DBGWVR15_EL1">Holds a data address value for use in watchpoint matching. 
Forms watchpoint 15 together with control register DBGWCR15_EL1.

TBD</hint>
			<hint page="2177" header="Debug Link Register" doc_id="armv8arm" token="DLR_EL0">In Debug state, holds the address to restart from.

Bits [63:0] - Restart address.</hint>
			<hint page="2178" header="Debug Saved Program Status Register" doc_id="armv8arm" token="DSPSR_EL0">Holds the saved process state on entry to Debug state.

TBD</hint>
			<hint page="2183" header="Monitor DCC Interrupt Enable Register" doc_id="armv8arm" token="MDCCINT_EL1">Enables interrupt requests to be signaled based 
on the DCC status flags.

TBD</hint>
			<hint page="2185" header="Monitor DCC Status Register" doc_id="armv8arm" token="MDCCSR_EL0">Main control register for the debug implementation, 
containing flow-control flags for the DCC. This is 
an internal, read-only view.

TBD</hint>
			<hint page="2187" header="Monitor Debug Configuration Register (EL2)" doc_id="armv8arm" token="MDCR_EL2">Provides EL2 configuration options for self-hosted 
debug and the Performance Monitors Extension.

TBD</hint>
			<hint page="2191" header="Monitor Debug Configuration Register (EL3)" doc_id="armv8arm" token="MDCR_EL3">Provides EL3 configuration options for self-hosted 
debug and the Performance Monitors Extension.

TBD</hint>
			<hint page="2195" header="Monitor Debug ROM Address Register" doc_id="armv8arm" token="MDRAR_EL1">Defines the base physical address of a 4KB-aligned 
memory-mapped debug component, usually a ROM table 
that locates and describes the memory-mapped debug 
components in the system. ARMv8 deprecates any use 
of this register.

TBD</hint>
			<hint page="2197" header="Monitor Debug System Control Register" doc_id="armv8arm" token="MDSCR_EL1">Main control register for the debug implementation.

TBD</hint>
			<hint page="2201" header="OS Double Lock Register" doc_id="armv8arm" token="OSDLR_EL1">Used to control the OS Double Lock.

Bits [31:1]  - Reserved, RES0.
DLK, bit [0] - OS Double Lock control bit. Possible values are:
                 0 OS Double Lock unlocked.
                 1 OS Double Lock locked, if DBGPRCR_EL1.CORENPDRQ
                   (Core no powerdown request) bit is set to 0 and 
                   the PE is in Non-debug state.</hint>
			<hint page="2203" header="OS Lock Data Transfer Register, Receive" doc_id="armv8arm" token="OSDTRRX_EL1">Used for save/restore of DBGDTRRX_EL0. 
It is a component of the Debug Communications Channel.

Bits [31:0]  - Update DTRRX without side-effect.
               Writes to this register update the value 
               in DTRRX and do not change RXfull.
               Reads of this register return the last value 
               written to DTRRX and do not change RXfull.</hint>
			<hint page="2205" header="OS Lock Data Transfer Register, Transmit" doc_id="armv8arm" token="OSDTRTX_EL1">Used for save/restore of DBGDTRTX_EL0. 
It is a component of the Debug Communications Channel.

Bits [31:0]  - Return DTRTX without side-effect.

               Reads of this register return the value 
               in DTRTX and do not change TXfull.
               Writes of this register update the value 
               in DTRTX and do not change TXfull.</hint>
			<hint page="2207" header="OS Lock Exception Catch Control Register" doc_id="armv8arm" token="OSECCR_EL1">Provides a mechanism for an operating system to access 
the contents of EDECCR that are otherwise invisible to 
software, so it can save/restore the contents of EDECCR 
over powerdown on behalf of the external debugger.

EDECCR, bits [31:0] - Used for save/restore to EDECCR 
                      over powerdown.</hint>
			<hint page="2209" header="OS Lock Access Register" doc_id="armv8arm" token="OSLAR_EL1">Used to lock or unlock the OS lock.

Bits [31:1]   - Reserved, RES0.
OSLK, bit [0] - On writes to OSLAR_EL1, bit[0] is copied 
                to the OS lock. Use OSLSR_EL1.OSLK to check
                the current status of the lock.</hint>
			<hint page="2211" header="OS Lock Status Register" doc_id="armv8arm" token="OSLSR_EL1">Provides the status of the OS lock.

TBD</hint>
			<hint page="2213" header="AArch32 Secure Debug Enable Register" doc_id="armv8arm" token="SDER32_EL3">Allows access to the AArch32 register SDER from 
AArch64 state only. Its value has no effect on 
execution in AArch64 state.

TBD</hint>
		</group>
		<group type="reg" name="A64 System Registers (Performance Monitors)">
			<hint page="2216" header="Performance Monitors Cycle Count Filter Register" doc_id="armv8arm" token="PMCCFILTR_EL0">Determines the modes in which the Cycle Counter, 
PMCCNTR_EL0, increments.

TBD</hint>
			<hint page="2218" header="Performance Monitors Cycle Count Register" doc_id="armv8arm" token="PMCCNTR_EL0">Holds the value of the processor Cycle Counter, 
CCNT, that counts processor clock cycles.

TBD</hint>
			<hint page="2220" header="Performance Monitors Common Event Identification register 0" doc_id="armv8arm" token="PMCEID0_EL0">Defines which common architectural and common microarchitectural 
feature events in the range 0x000 to 0x01F are implemented. 
If a particular bit is set to 1, then the event for that bit 
is implemented.

ID[31:0], bits [31:0] - PMCEID0_EL0[n] maps to event n.
                        For each bit:
                          0 The common event is not implemented.
                          1 The common event is implemented.</hint>
			<hint page="2222" header="Performance Monitors Common Event Identification register 1" doc_id="armv8arm" token="PMCEID1_EL0">Defines which common architectural and common microarchitectural 
feature events in the range 0x020 to 0x03F are implemented. 
If a particular bit is set to 1, then the event for that 
bit is implemented.

ID[63:32], bits [31:0] - PMCEID1_EL0[n] maps to event (n + 32).
                         For each bit:
                           0 The common event is not implemented.
                           1 The common event is implemented.</hint>
			<hint page="2224" header="Performance Monitors Count Enable Clear register " doc_id="armv8arm" token="PMCNTENCLR_EL0">Disables the Cycle Count Register, PMCCNTR_EL0, 
and any implemented event counters PMEVCNTR&lt;n&gt;. 
Reading this register shows which counters are enabled.

TBD</hint>
			<hint page="2226" header="Performance Monitors Count Enable Set register" doc_id="armv8arm" token="PMCNTENSET_EL0">Enables the Cycle Count Register, PMCCNTR_EL0, 
and any implemented event counters PMEVCNTR&lt;n&gt;. 
Reading this register shows which counters are enabled.

TBD</hint>
			<hint page="2228" header="Performance Monitors Control Register" doc_id="armv8arm" token="PMCR_EL0">Provides details of the Performance Monitors implementation, 
including the number of counters implemented, and configures 
and controls the counters.

TBD</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 0" doc_id="armv8arm" token="PMEVCNTR0_EL0">Holds event counter 0, which counts events.

Bits [31:0] - Event counter 0. Value of event counter 0.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 1" doc_id="armv8arm" token="PMEVCNTR1_EL0">Holds event counter 1, which counts events.

Bits [31:0] - Event counter 1. Value of event counter 1.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 2" doc_id="armv8arm" token="PMEVCNTR2_EL0">Holds event counter 2, which counts events.

Bits [31:0] - Event counter 2. Value of event counter 2.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 3" doc_id="armv8arm" token="PMEVCNTR3_EL0">Holds event counter 3, which counts events.

Bits [31:0] - Event counter 3. Value of event counter 3.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 4" doc_id="armv8arm" token="PMEVCNTR4_EL0">Holds event counter 4, which counts events.

Bits [31:0] - Event counter 4. Value of event counter 4.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 5" doc_id="armv8arm" token="PMEVCNTR5_EL0">Holds event counter 5, which counts events.

Bits [31:0] - Event counter 5. Value of event counter 5.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 6" doc_id="armv8arm" token="PMEVCNTR6_EL0">Holds event counter 6, which counts events.

Bits [31:0] - Event counter 6. Value of event counter 6.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 7" doc_id="armv8arm" token="PMEVCNTR7_EL0">Holds event counter 7, which counts events.

Bits [31:0] - Event counter 7. Value of event counter 7.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 8" doc_id="armv8arm" token="PMEVCNTR8_EL0">Holds event counter 8, which counts events.

Bits [31:0] - Event counter 8. Value of event counter 8.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 9" doc_id="armv8arm" token="PMEVCNTR9_EL0">Holds event counter 9, which counts events.

Bits [31:0] - Event counter 9. Value of event counter 9.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 10" doc_id="armv8arm" token="PMEVCNTR10_EL0">Holds event counter 10, which counts events.

Bits [31:0] - Event counter 10. Value of event counter 10.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 11" doc_id="armv8arm" token="PMEVCNTR11_EL0">Holds event counter 11, which counts events.

Bits [31:0] - Event counter 11. Value of event counter 11.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 12" doc_id="armv8arm" token="PMEVCNTR12_EL0">Holds event counter 12, which counts events.

Bits [31:0] - Event counter 12. Value of event counter 12.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 13" doc_id="armv8arm" token="PMEVCNTR13_EL0">Holds event counter 13, which counts events.

Bits [31:0] - Event counter 13. Value of event counter 13.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 14" doc_id="armv8arm" token="PMEVCNTR14_EL0">Holds event counter 14, which counts events.

Bits [31:0] - Event counter 14. Value of event counter 14.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 15" doc_id="armv8arm" token="PMEVCNTR15_EL0">Holds event counter 15, which counts events.

Bits [31:0] - Event counter 15. Value of event counter 15.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 16" doc_id="armv8arm" token="PMEVCNTR16_EL0">Holds event counter 16, which counts events.

Bits [31:0] - Event counter 16. Value of event counter 16.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 17" doc_id="armv8arm" token="PMEVCNTR17_EL0">Holds event counter 17, which counts events.

Bits [31:0] - Event counter 17. Value of event counter 17.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 18" doc_id="armv8arm" token="PMEVCNTR18_EL0">Holds event counter 18, which counts events.

Bits [31:0] - Event counter 18. Value of event counter 18.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 19" doc_id="armv8arm" token="PMEVCNTR19_EL0">Holds event counter 19, which counts events.

Bits [31:0] - Event counter 19. Value of event counter 19.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 20" doc_id="armv8arm" token="PMEVCNTR20_EL0">Holds event counter 20, which counts events.

Bits [31:0] - Event counter 20. Value of event counter 20.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 21" doc_id="armv8arm" token="PMEVCNTR21_EL0">Holds event counter 21, which counts events.

Bits [31:0] - Event counter 21. Value of event counter 21.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 22" doc_id="armv8arm" token="PMEVCNTR22_EL0">Holds event counter 22, which counts events.

Bits [31:0] - Event counter 22. Value of event counter 22.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 23" doc_id="armv8arm" token="PMEVCNTR23_EL0">Holds event counter 23, which counts events.

Bits [31:0] - Event counter 23. Value of event counter 23.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 24" doc_id="armv8arm" token="PMEVCNTR24_EL0">Holds event counter 24, which counts events.

Bits [31:0] - Event counter 24. Value of event counter 24.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 25" doc_id="armv8arm" token="PMEVCNTR25_EL0">Holds event counter 25, which counts events.

Bits [31:0] - Event counter 25. Value of event counter 25.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 26" doc_id="armv8arm" token="PMEVCNTR26_EL0">Holds event counter 26, which counts events.

Bits [31:0] - Event counter 26. Value of event counter 26.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 27" doc_id="armv8arm" token="PMEVCNTR27_EL0">Holds event counter 27, which counts events.

Bits [31:0] - Event counter 27. Value of event counter 27.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 28" doc_id="armv8arm" token="PMEVCNTR28_EL0">Holds event counter 28, which counts events.

Bits [31:0] - Event counter 28. Value of event counter 28.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 29" doc_id="armv8arm" token="PMEVCNTR29_EL0">Holds event counter 29, which counts events.

Bits [31:0] - Event counter 29. Value of event counter 29.</hint>
			<hint page="2231" header="Performance Monitors Event Count Register 30" doc_id="armv8arm" token="PMEVCNTR30_EL0">Holds event counter 30, which counts events.

Bits [31:0] - Event counter 30. Value of event counter 30.</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 0" doc_id="armv8arm" token="PMEVTYPER0_EL0">Configures event counter 0.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 1" doc_id="armv8arm" token="PMEVTYPER1_EL0">Configures event counter 1.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 2" doc_id="armv8arm" token="PMEVTYPER2_EL0">Configures event counter 2.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 3" doc_id="armv8arm" token="PMEVTYPER3_EL0">Configures event counter 3.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 4" doc_id="armv8arm" token="PMEVTYPER4_EL0">Configures event counter 4.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 5" doc_id="armv8arm" token="PMEVTYPER5_EL0">Configures event counter 5.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 6" doc_id="armv8arm" token="PMEVTYPER6_EL0">Configures event counter 6.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 7" doc_id="armv8arm" token="PMEVTYPER7_EL0">Configures event counter 7.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 8" doc_id="armv8arm" token="PMEVTYPER8_EL0">Configures event counter 8.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 9" doc_id="armv8arm" token="PMEVTYPER9_EL0">Configures event counter 9.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 10" doc_id="armv8arm" token="PMEVTYPER10_EL0">Configures event counter 10.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 11" doc_id="armv8arm" token="PMEVTYPER11_EL0">Configures event counter 11.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 12" doc_id="armv8arm" token="PMEVTYPER12_EL0">Configures event counter 12.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 13" doc_id="armv8arm" token="PMEVTYPER13_EL0">Configures event counter 13.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 14" doc_id="armv8arm" token="PMEVTYPER14_EL0">Configures event counter 14.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 15" doc_id="armv8arm" token="PMEVTYPER15_EL0">Configures event counter 15.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 16" doc_id="armv8arm" token="PMEVTYPER16_EL0">Configures event counter 16.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 17" doc_id="armv8arm" token="PMEVTYPER17_EL0">Configures event counter 17.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 18" doc_id="armv8arm" token="PMEVTYPER18_EL0">Configures event counter 18.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 19" doc_id="armv8arm" token="PMEVTYPER19_EL0">Configures event counter 19.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 20" doc_id="armv8arm" token="PMEVTYPER20_EL0">Configures event counter 20.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 21" doc_id="armv8arm" token="PMEVTYPER21_EL0">Configures event counter 21.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 22" doc_id="armv8arm" token="PMEVTYPER22_EL0">Configures event counter 22.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 23" doc_id="armv8arm" token="PMEVTYPER23_EL0">Configures event counter 23.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 24" doc_id="armv8arm" token="PMEVTYPER24_EL0">Configures event counter 24.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 25" doc_id="armv8arm" token="PMEVTYPER25_EL0">Configures event counter 25.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 26" doc_id="armv8arm" token="PMEVTYPER26_EL0">Configures event counter 26.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 27" doc_id="armv8arm" token="PMEVTYPER27_EL0">Configures event counter 27.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 28" doc_id="armv8arm" token="PMEVTYPER28_EL0">Configures event counter 28.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 29" doc_id="armv8arm" token="PMEVTYPER29_EL0">Configures event counter 29.

TBD</hint>
			<hint page="2233" header="Performance Monitors Event Type Register 30" doc_id="armv8arm" token="PMEVTYPER30_EL0">Configures event counter 30.

TBD</hint>
			<hint page="2237" header="Performance Monitors Interrupt Enable Clear register" doc_id="armv8arm" token="PMINTENCLR_EL1">Disables the generation of interrupt requests on overflows 
from the Cycle Count Register, PMCCNTR_EL0, and the event 
counters PMEVCNTR&lt;n&gt;_EL0. Reading the register shows which 
overflow interrupt requests are enabled.

TBD</hint>
			<hint page="2239" header="Performance Monitors Interrupt Enable Set register" doc_id="armv8arm" token="PMINTENSET_EL1">Enables the generation of interrupt requests on overflows 
from the Cycle Count Register, PMCCNTR_EL0, and the event 
counters PMEVCNTR&lt;n&gt;_EL0. Reading the register shows which 
overflow interrupt requests are enabled.

TBD</hint>
			<hint page="2241" header="Performance Monitors Overflow Flag Status Clear Register" doc_id="armv8arm" token="PMOVSCLR_EL0">Contains the state of the overflow bit for the Cycle Count Register, 
PMCCNTR_EL0, and each of the implemented event counters PMEVCNTR&lt;n&gt;. 
Writing to this register clears these bits.

TBD</hint>
			<hint page="2243" header="Performance Monitors Overflow Flag Status Set register" doc_id="armv8arm" token="PMOVSSET_EL0">Sets the state of the overflow bit for the Cycle Count Register, 
PMCCNTR_EL0, and each of the implemented event counters PMEVCNTR&lt;n&gt;.

TBD</hint>
			<hint page="2245" header="Performance Monitors Event Counter Selection Register" doc_id="armv8arm" token="PMSELR_EL0">Selects the current event counter PMEVCNTR&lt;n&gt; or the cycle counter, CCNT.

TBD</hint>
			<hint page="2247" header="Performance Monitors Software Increment register" doc_id="armv8arm" token="PMSWINC_EL0">Increments a counter that is configured to count the Software 
increment event, event 0x00. For more information, see SW_INCR.

TBD</hint>
			<hint page="2249" header="Performance Monitors User Enable Register" doc_id="armv8arm" token="PMUSERENR_EL0">Enables or disables EL0 access to the Performance Monitors.

TBD</hint>
			<hint page="2251" header="Performance Monitors Selected Event Count Register" doc_id="armv8arm" token="PMXEVCNTR_EL0">Reads or writes the value of the selected event counter, 
PMEVCNTR&lt;n&gt;_EL0. PMSELR_EL0.SEL determines which event 
counter is selected.

PMEVCNTR&lt;n&gt;, bits [31:0] - Value of the selected event counter, 
                           PMEVCNTR&lt;n&gt;_EL0, where n is the value 
                           stored in PMSELR_EL0.SEL.</hint>
			<hint page="2253" header="Performance Monitors Selected Event Type Register" doc_id="armv8arm" token="PMXEVTYPER_EL0">When PMSELR_EL0.SEL selects an event counter, this accesses a 
PMEVTYPER&lt;n&gt;_EL0 register. When PMSELR_EL0.SEL selects the 
cycle counter, this accesses PMCCFILTR_EL0.

Bits [31:0] - Event type register or PMCCFILTR_EL0.</hint>
		</group>
		<group type="reg" name="A64 System Registers (Generic Timer)">
			<hint page="2256" header="Counter-timer Frequency register" doc_id="armv8arm" token="CNTFRQ_EL0">This register is provided so that software can discover the 
frequency of the system counter.

Bits [31:0] - Clock frequency. Indicates the system counter 
              clock frequency, in Hz.</hint>
			<hint page="2258" header="Counter-timer Hypervisor Control register" doc_id="armv8arm" token="CNTHCTL_EL2">Controls the generation of an event stream from the physical counter, 
and access from Non-secure EL1 to the physical counter and the 
Non-secure EL1 physical timer.

TBD</hint>
			<hint page="2260" header="Counter-timer Hypervisor Physical Timer Control register" doc_id="armv8arm" token="CNTHP_CTL_EL2">Control register for the EL2 physical timer.

TBD</hint>
			<hint page="2262" header="Counter-timer Hypervisor Physical Timer CompareValue register" doc_id="armv8arm" token="CNTHP_CVAL_EL2">Holds the compare value for the EL2 physical timer.

Bits [63:0] - EL2 physical timer compare value.</hint>
			<hint page="2263" header="Counter-timer Hypervisor Physical Timer TimerValue register" doc_id="armv8arm" token="CNTHP_TVAL_EL2">Holds the timer value for the EL2 physical timer.

Bits [31:0] - EL2 physical timer value.</hint>
			<hint page="2264" header="Counter-timer Kernel Control register" doc_id="armv8arm" token="CNTKCTL_EL1">Controls the generation of an event stream from the virtual counter, 
and access from EL0 to the physical counter, virtual counter, 
EL1 physical timers, and the virtual timer.

TBD</hint>
			<hint page="2267" header="Counter-timer Physical Timer Control register" doc_id="armv8arm" token="CNTP_CTL_EL0">Control register for the EL1 physical timer.

TBD</hint>
			<hint page="2269" header="Counter-timer Physical Timer CompareValue register" doc_id="armv8arm" token="CNTP_CVAL_EL0">Holds the compare value for the EL1 physical timer.

Bits [63:0] - EL1 physical timer compare value.</hint>
			<hint page="2270" header="Counter-timer Physical Timer TimerValue register" doc_id="armv8arm" token="CNTP_TVAL_EL0">Holds the timer value for the EL1 physical timer.

Bits [31:0] - EL1 physical timer value.</hint>
			<hint page="2272" header="Counter-timer Physical Count register" doc_id="armv8arm" token="CNTPCT_EL0">Holds the 64-bit physical count value.

Bits [63:0] - Physical count value.</hint>
			<hint page="2273" header="Counter-timer Physical Secure Timer Control register" doc_id="armv8arm" token="CNTPS_CTL_EL1">Control register for the secure physical timer, usually accessible 
at EL3 but configurably accessible at EL1 in Secure state.

TBD</hint>
			<hint page="2275" header="Counter-timer Physical Secure Timer CompareValue register" doc_id="armv8arm" token="CNTPS_CVAL_EL1">Holds the compare value for the secure physical timer, 
usually accessible at EL3 but configurably accessible 
at EL1 in Secure state.

Bits [63:0] - Secure physical timer compare value.</hint>
			<hint page="2276" header="Counter-timer Physical Secure Timer TimerValue register" doc_id="armv8arm" token="CNTPS_TVAL_EL1">Holds the timer value for the secure physical timer, 
usually accessible at EL3 but configurably accessible 
at EL1 in Secure state.

Bits [31:0] - Secure physical timer value.</hint>
			<hint page="2277" header="Counter-timer Virtual Timer Control register" doc_id="armv8arm" token="CNTV_CTL_EL0">Control register for the virtual timer.

TBD</hint>
			<hint page="2279" header="Counter-timer Virtual Timer CompareValue register" doc_id="armv8arm" token="CNTV_CVAL_EL0">Holds the compare value for the virtual timer.

Bits [63:0] - Virtual timer compare value.</hint>
			<hint page="2280" header="Counter-timer Virtual Timer TimerValue register" doc_id="armv8arm" token="CNTV_TVAL_EL0">Holds the timer value for the virtual timer.

Bits [31:0] - Virtual timer value.</hint>
			<hint page="2282" header="Counter-timer Virtual Count register" doc_id="armv8arm" token="CNTVCT_EL0">Holds the 64-bit virtual count value. The virtual count value 
is equal to the physical count value visible in CNTPCT_EL0 
minus the virtual offset visible in CNTVOFF_EL2.

Bits [63:0] - Virtual count value.</hint>
			<hint page="2283" header="Counter-timer Virtual Offset register" doc_id="armv8arm" token="CNTVOFF_EL2">Holds the 64-bit virtual offset. This is the offset between the 
physical count value visible in CNTPCT_EL0 and the virtual 
count value visible in CNTVCT_EL0.</hint>
		</group>
		<group type="reg" name="A64 Barrier Symbols">
			<hint page="515" header="Full system, all" doc_id="armv8arm" token="SY">Full system is the required shareability domain, 
reads and writes are the required access types 
in both Group A and Group B.</hint>
			<hint page="515" header="Full system, store" doc_id="armv8arm" token="ST">Full system is the required shareability domain, 
writes are the required access type in both 
Group A and Group B.</hint>
			<hint page="515" header="Full system, all" doc_id="armv8arm" token="LD">Full system is the required shareability domain, 
reads are the required access type in Group A, 
and reads and writes are the required access 
types in Group B.</hint>
			<hint page="515" header="Inner Shareable, all" doc_id="armv8arm" token="ISH">Inner Shareable is the required shareability domain, 
reads and writes are the required access types in 
both Group A and Group B.</hint>
			<hint page="515" header="Inner Shareable, store" doc_id="armv8arm" token="ISHST">Inner Shareable is the required shareability domain, 
writes are the required access type in both 
Group A and Group B.</hint>
			<hint page="515" header="Inner Shareable, load" doc_id="armv8arm" token="ISHLD">Inner Shareable is the required shareability domain, reads 
are the required access type in Group A, and reads and 
writes are the required access types in Group B.</hint>
			<hint page="515" header="Non-shareable, all" doc_id="armv8arm" token="NSH">Non-shareable is the required shareability domain, 
reads and writes are the required access types in 
both Group A and Group B.</hint>
			<hint page="515" header="Non-shareable, store" doc_id="armv8arm" token="NSHST">Non-shareable is the required shareability domain, 
writes are the required access type in both 
Group A and Group B.</hint>
			<hint page="516" header="Non-shareable, load" doc_id="armv8arm" token="NSHLD">Non-shareable is the required shareability domain, reads 
are the required access type in Group A, and reads and 
writes are the required access types in Group B.</hint>
			<hint page="516" header="Outer Shareable, all" doc_id="armv8arm" token="OSH">Outer Shareable is the required shareability domain, 
reads and writes are the required access types in 
both Group A and Group B.</hint>
			<hint page="516" header="Outer Shareable, store" doc_id="armv8arm" token="OSHST">Outer Shareable is the required shareability domain, 
writes are the required access type in both Group A 
and Group B.</hint>
			<hint page="516" header="Outer Shareable, load" doc_id="armv8arm" token="OSHLD">Outer Shareable is the required shareability domain, reads 
are the required access type in Group A, and reads and 
writes are the required access types in Group B.</hint>
		</group>
		<group type="ins" name="A64 Base instructions">
			<hint page="435" header="Add with Carry" doc_id="armv8arm" token="ADC">Adds two register values and the Carry flag value, 
and writes the result to the destination register.

ADC &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="436" header="Add with Carry (setting flags)" doc_id="armv8arm" token="ADCS">Adds two register values and the Carry flag value,
and writes the result to the destination register. 
It updates the condition flags based on the result.

ADCS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="437" header="Addition" doc_id="armv8arm" token="ADD">1. Extended register
Adds a register value and a sign or zero-extended register value, 
followed by an optional left shift amount, and writes the result to the destination register. 

ADD &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

2. Immediate
Adds a register value and an optionally-shifted immediate value, 
and writes the result to the destination register.

ADD &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}

3. Shifted register
Adds a register value and an optionally-shifted register value, 
and writes the result to the destination register.

ADD &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="443" header="Addition (setting flags)" doc_id="armv8arm" token="ADDS">1. Extended register
Adds a register value and a sign or zero-extended register value, 
followed by an optional left shift amount, and writes the result to the destination register. 
It updates the condition flags based on the result.

ADDS &lt;Xd&gt;, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

2. Immediate
Adds a register value and an optionally-shifted immediate value, 
and writes the result to the destination register. 
It updates the condition flags based on the result.

ADDS &lt;Xd&gt;, &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}

3. Shifted register
Adds a register value and an optionally-shifted register value, 
and writes the result to the destination register. 
It updates the condition flags based on the result.

ADDS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="449" header="Load address" doc_id="armv8arm" token="ADR">Form PC-relative address adds an immediate value 
to the PC value to form a PC-relative address, 
and writes the result to the destination register.

ADR &lt;Xd&gt;, &lt;label&gt;</hint>
			<hint page="450" header="Load address" doc_id="armv8arm" token="ADRP">Form PC-relative address to 4KB page adds an immediate value that is shifted left by 12 bits, 
to the PC value to form a PC-relative address, with the bottom 12 bits masked out, 
and writes the result to the destination register.

ADRP &lt;Xd&gt;, &lt;label&gt;</hint>
			<hint page="451" header="Bitwise AND" doc_id="armv8arm" token="AND">1. Immediate
Performs a bitwise AND of a register value and an immediate value, 
and writes the result to the destination register.

AND &lt;Xd|SP&gt;, &lt;Xn&gt;, #&lt;imm&gt;

2. Shifted register
Performs a bitwise AND of a register value and an optionally-shifted register value, 
and writes the result to the destination register.

AND &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="454" header="Bitwise AND (setting flags)" doc_id="armv8arm" token="ANDS">1. Immediate
Performs a bitwise AND of a register value and an immediate value, 
and writes the result to the destination register. 
It updates the condition flags based on the result.

ANDS &lt;Xd&gt;, &lt;Xn&gt;, #&lt;imm&gt;

2. Shifted register
Performs a bitwise AND of a register value and an optionally-shifted register value, 
and writes the result to the destination register. 
It updates the condition flags based on the result.

ANDS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="458" header="Arithmetic Shift Right" doc_id="armv8arm" token="ASR">1. Register
Shifts a register value right by a variable number of bits, 
shifting in copies of its sign bit, and writes the result to the destination register. 
The remainder obtained by dividing the second source register by the data size defines 
the number of bits by which the first source register is right-shifted.

ASR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

  is equivalent to

ASRV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

2. Immediate
Shifts a register value right by an immediate number of bits, 
shifting in copies of the sign bit in the upper bits and zeros in the lower bits, 
and writes the result to the destination register.

ASR &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt;

  is equivalent to

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt;, #63</hint>
			<hint page="460" header="Arithmetic Shift Right Variable" doc_id="armv8arm" token="ASRV">Shifts a register value right by a variable number of bits, 
shifting in copies of its sign bit, 
and writes the result to the destination register. 
The remainder obtained by dividing the second source register 
by the data size defines the number of bits by which the first 
source register is right-shifted.

ASRV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.EQ">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

EQ - Equal (Z==1)

B.EQ &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.NE">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

NE - Not equal (Z==0)

B.NE &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.CS">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

CS - Carry set (C==1)

B.CS &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.HS">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

HS - Carry set (C==1)

B.HS &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.CC">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

CC - Carry clear (C==0)

B.CC &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.LO">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

LO - Carry clear (C==0)

B.LO &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.MI">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

MI - Minus, negative (N==1)

B.MI &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.PL">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

PL - Plus, positive or zero (N==0)

B.PL &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.VS">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

VS - Overflow (V==1)

B.VS &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.VC">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

VC - No overflow (V==0)

B.VC &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.HI">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

HI - Unsigned higher (C ==1 &amp;&amp; Z == 0)

B.HI &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.LS">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

LS - Unsigned lower or same (!(C ==1 &amp;&amp; Z ==0))

B.LS &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.GE">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

GE - Signed greater than or equal (N == V)

B.GE &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.LT">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

LT - Signed less than (N! = V)

B.LT &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.GT">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

GT - Signed greater than (Z == 0 &amp;&amp; N == V)

B.GT &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.LE">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

LE - Signed less than or equal (!(Z == 0 &amp;&amp; N == V))

B.LE &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.AL">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

AL - Always (Any)

B.AL &lt;label&gt;</hint>
			<hint page="462" header="Branch conditionally" doc_id="armv8arm" token="B.NV">Branch conditionally to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

NV - Always (Any)

B.NV &lt;label&gt;</hint>
			<hint page="463" header="Branch unconditionally" doc_id="armv8arm" token="B">Branch causes an unconditional branch to a label at a PC-relative offset, 
with a hint that this is not a subroutine call or return.

B &lt;label&gt;</hint>
			<hint page="464" header="Bitfield Insert" doc_id="armv8arm" token="BFI">Copies any number of low-order bits from a source register into the 
same number of adjacent bits at any position in the destination register, 
leaving other bits unchanged.

BFI &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;
  
  is equivalent to

BFM &lt;Xd&gt;, &lt;Xn&gt;, #(-&lt;lsb&gt; MOD 64), #(&lt;width&gt;-1)</hint>
			<hint page="465" header="Bitfield Move" doc_id="armv8arm" token="BFM">Copies any number of low-order bits from a source register into the
same number of adjacent bits at any position in the destination register, 
leaving other bits unchanged.

BFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</hint>
			<hint page="467" header="Bitfield extract and insert" doc_id="armv8arm" token="BFXIL">At low end copies any number of low-order bits from a source register into the 
same number of adjacent bits at the low end in the destination register, 
leaving other bits unchanged.

BFXIL &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;

  is equivalent to

BFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #(&lt;lsb&gt;+&lt;width&gt;-1)</hint>
			<hint page="468" header="Bitwise Bit Clear" doc_id="armv8arm" token="BIC">Performs a bitwise AND of a register value and the complement of an optionally-shifted 
register value, and writes the result to the destination register.

BIC &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="470" header="Bitwise Bit Clear (setting flags)" doc_id="armv8arm" token="BICS">Performs a bitwise AND of a register value and the complement of an optionally-shifted 
register value, and writes the result to the destination register. 
It updates the condition flags based on the result.

BICS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="472" header="Branch with Link" doc_id="armv8arm" token="BL">Branches to a PC-relative offset, setting the register X30 to PC+4. 
It provides a hint that this is a subroutine call.

BL &lt;label&gt;</hint>
			<hint page="473" header="Branch with Link to Register" doc_id="armv8arm" token="BLR">Calls a subroutine at an address in a register, 
setting register X30 to PC+4.

BLR &lt;Xn&gt;</hint>
			<hint page="474" header="Branch to Register" doc_id="armv8arm" token="BR">Branches unconditionally to an address in a register, 
with a hint that this is not a subroutine return.

BR &lt;Xn&gt;</hint>
			<hint page="476" header="Compare and Branch on Nonzero" doc_id="armv8arm" token="CBNZ">Compares the value in a register with zero, and conditionally branches to a label 
at a PC-relative offset if the comparison is not equal. 
It provides a hint that this is not a subroutine call or return. 
This instruction does not affect the condition flags.

CBNZ &lt;Xt&gt;, &lt;label&gt;</hint>
			<hint page="477" header="Compare and Branch on Zero" doc_id="armv8arm" token="CBZ">Compares the value in a register with zero, and conditionally branches to a label 
at a PC-relative offset if the comparison is equal. I
t provides a hint that this is not a subroutine call or return. 
This instruction does not affect condition flags.

CBZ &lt;Xt&gt;, &lt;label&gt;</hint>
			<hint page="478" header="Conditional Compare Negative" doc_id="armv8arm" token="CCMN">1. Immediate
Sets the value of the condition flags to the result of the comparison of a 
register value and a negated immediate value if the condition is TRUE, 
and an immediate value otherwise.

CCMN &lt;Xn&gt;, #&lt;imm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;

2. Register
Sets the value of the condition flags to the result of the comparison of a 
register value and the inverse of another register value if the condition 
is TRUE, and an immediate value otherwise.

CCMN &lt;Xn&gt;, &lt;Xm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;</hint>
			<hint page="480" header="Conditional Compare" doc_id="armv8arm" token="CCMP">1. Immediate
Sets the value of the condition flags to the result of the comparison of a 
register value and an immediate value if the condition is TRUE, 
and an immediate value otherwise.

CCMP &lt;Xn&gt;, #&lt;imm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;

2. Register
Sets the value of the condition flags to the result of the comparison of two 
registers if the condition is TRUE, and an immediate value otherwise.

CCMP &lt;Xn&gt;, &lt;Xm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;</hint>
			<hint page="482" header="Conditional Increment" doc_id="armv8arm" token="CINC">Returns, in the destination register, the value of the source 
register incremented by 1 if the condition is TRUE, 
and otherwise returns the value of the source register.

CINC &lt;Xd&gt;, &lt;Xn&gt;, &lt;cond&gt;

  is equivalent to

CSINC &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xn&gt;, invert(&lt;cond&gt;)</hint>
			<hint page="483" header="Conditional Invert" doc_id="armv8arm" token="CINV">Returns, in the destination register, the bitwise inversion 
of the value of the source register if the condition is TRUE,
and otherwise returns the value of the source register.

CINV &lt;Xd&gt;, &lt;Xn&gt;, &lt;cond&gt;

  is equivalent to

CSINV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xn&gt;, invert(&lt;cond&gt;)</hint>
			<hint page="485" header="Count leading sign bits" doc_id="armv8arm" token="CLS">Count leading sign bits : Rd = CLS(Rn)

CLS &lt;Xd&gt;, &lt;Xn&gt;</hint>
			<hint page="486" header="Count leading zero bits" doc_id="armv8arm" token="CLZ">Count leading zero bits : Rd = CLZ(Rn)

CLZ &lt;Wd&gt;, &lt;Wn&gt;</hint>
			<hint page="487" header="Compare Negative" doc_id="armv8arm" token="CMN">1. Extended register
Adds a register value and a sign or zero-extended register value, 
followed by an optional left shift amount. 
It updates the condition flags based on the result, and discards the result.

CMN &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

  is equivalent to

ADDS XZR, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

2. Immediate
Adds a register value and an optionally-shifted immediate value. 
It updates the condition flags based on the result, and discards the result.

CMN &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}

  is equivalent to

ADDS XZR, &lt;Xn|SP&gt;, #&lt;imm&gt; {, &lt;shift&gt;}

3. Shifted register
Adds a register value and an optionally-shifted register value. 
It updates the condition flags based on the result, and discards the result.

CMN &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}

  is equivalent to

ADDS XZR, &lt;Xn&gt;, &lt;Xm&gt; {, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="492" header="Compare" doc_id="armv8arm" token="CMP">1. Extended register
Subtracts a sign or zero-extended register value, followed by an optional left shift amount, 
from a register value. 
It updates the condition flags based on the result, and discards the result.

CMP &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

  is equivalent to

SUBS XZR, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

2. Immediate
subtracts an optionally-shifted immediate value from a register value. 
It updates the condition flags based on the result, and discards the result.

CMP &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}

  is equivalent to

SUBS XZR, &lt;Xn|SP&gt;, #&lt;imm&gt; {, &lt;shift&gt;}

3. Shifted register
Subtracts an optionally-shifted register value from a register value. 
It updates the condition flags based on the result, and discards the result.

CMP &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}

  is equivalent to

SUBS XZR, &lt;Xn&gt;, &lt;Xm&gt; {, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="497" header="Conditional Negate" doc_id="armv8arm" token="CNEG">Returns, in the destination register, the negated value of the source 
register if the condition is TRUE, and otherwise returns the value of 
the source register.

CNEG &lt;Xd&gt;, &lt;Xn&gt;, &lt;cond&gt;

  is equivalent to

CSNEG &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xn&gt;, invert(&lt;cond&gt;)</hint>
			<hint page="502" header="Conditional Select" doc_id="armv8arm" token="CSEL">Returns, in the destination register, the value of the first source 
register if the condition is TRUE, and otherwise returns the value 
of the second source register.

CSEL &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, &lt;cond&gt;</hint>
			<hint page="503" header="Conditional Set" doc_id="armv8arm" token="CSET">Sets the destination register to 1 if the condition is TRUE, 
and otherwise sets it to 0.

CSET &lt;Xd&gt;, &lt;cond&gt;

  is equivalent to

CSINC &lt;Xd&gt;, XZR, XZR, invert(&lt;cond&gt;)</hint>
			<hint page="504" header="Conditional Set Mask" doc_id="armv8arm" token="CSETM">Sets all bits of the destination register to 1 if the 
condition is TRUE, and otherwise sets all bits to 0.

CSETM &lt;Xd&gt;, &lt;cond&gt;

  is equivalent to

CSINV &lt;Xd&gt;, XZR, XZR, invert(&lt;cond&gt;)</hint>
			<hint page="505" header="Conditional Select Increment" doc_id="armv8arm" token="CSINC">Returns, in the destination register, the value of the first source 
register if the condition is TRUE, and otherwise returns the value 
of the second source register incremented by 1.

CSINC &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, &lt;cond&gt;</hint>
			<hint page="507" header="Conditional Select Invert" doc_id="armv8arm" token="CSINV">Returns, in the destination register, the value of the first source 
register if the condition is TRUE, and otherwise returns the bitwise 
inversion value of the second source register.

CSINV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, &lt;cond&gt;</hint>
			<hint page="509" header="Conditional Select Negation" doc_id="armv8arm" token="CSNEG">Returns, in the destination register, the value of the first source 
register if the condition is TRUE, and otherwise returns the negated 
value of the second source register.

CSNEG &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, &lt;cond&gt;</hint>
			<hint page="520" header="Bitwise Exclusive OR NOT" doc_id="armv8arm" token="EON">Performs a bitwise Exclusive OR NOT of a register value 
and an optionally-shifted register value, and writes 
the result to the destination register.

EON &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="522" header="Bitwise Exclusive OR" doc_id="armv8arm" token="EOR">1. Immediate
Performs a bitwise Exclusive OR of a register value 
and an immediate value, and writes the result to 
the destination register.

EOR &lt;Xd|SP&gt;, &lt;Xn&gt;, #&lt;imm&gt;

2. Shifted register
Performs a bitwise Exclusive OR of a register value 
and an optionally-shifted register value, and writes 
the result to the destination register.

EOR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="526" header="Extract register" doc_id="armv8arm" token="EXTR">Extracts a register from a pair of registers.

EXTR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, #&lt;lsb&gt;</hint>
			<hint page="533" header="Load-Acquire Register" doc_id="armv8arm" token="LDAR">Derives an address from a base register value, 
loads a 32-bit word or 64-bit doubleword from 
memory, and writes it to a register.

LDAR &lt;Xt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="534" header="Load-Acquire Register Byte" doc_id="armv8arm" token="LDARB">Derives an address from a base register value, 
loads a byte from memory, zero-extends it and 
writes it to a register. 

LDARB &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="535" header="Load-Acquire Register Halfword" doc_id="armv8arm" token="LDARH">Derives an address from a base register value, 
loads a halfword from memory, zero-extends it, 
and writes it to a register. 

LDARH &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="536" header="Load-Acquire Exclusive Pair of Registers" doc_id="armv8arm" token="LDAXP">Derives an address from a base register value, loads two 32-bit words or 
two 64-bit doublewords from memory, and writes them to two registers. 
A 32-bit pair requires the address to be doubleword aligned and is 
single-copy atomic at doubleword granularity. A 64-bit pair requires 
the address to be quadword aligned and is single-copy atomic for each 
doubleword at doubleword granularity. The PE marks the physical address 
being accessed as an exclusive access. This exclusive access mark is 
checked by Store Exclusive instructions.

LDAXP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="538" header="Load-Acquire Exclusive Register" doc_id="armv8arm" token="LDAXR">Derives an address from a base register value, loads a 32-bit word 
or 64-bit doubleword from memory, and writes it to a register. 
The memory access is atomic. The PE marks the physical address 
being accessed as an exclusive access. This exclusive access mark 
is checked by Store Exclusive instructions.

LDAXR &lt;Xt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="540" header="Load-Acquire Exclusive Register Byte" doc_id="armv8arm" token="LDAXRB">Derives an address from a base register value, loads a byte from memory, 
zero-extends it and writes it to a register. The memory access is atomic.
The PE marks the physical address being accessed as an exclusive access. 
This exclusive access mark is checked by Store Exclusive instructions. 

LDAXRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="541" header="Load-Acquire Exclusive Register Halfword" doc_id="armv8arm" token="LDAXRH">Derives an address from a base register value, loads a halfword from memory, 
zero-extends it and writes it to a register. The memory access is atomic.
The PE marks the physical address being accessed as an exclusive access. 
This exclusive access mark is checked by Store Exclusive instructions.

LDAXRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="542" header="Load Pair of Registers w non-temporal hint" doc_id="armv8arm" token="LDNP">Calculates an address from a base register value and an 
immediate offset, loads two 32-bit words or two 64-bit 
doublewords from memory, and writes them to two registers.

LDNP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="544" header="Load Pair of Registers" doc_id="armv8arm" token="LDP">Calculates an address from a base register value and an 
immediate offset, loads two 32-bit words or two 64-bit 
doublewords from memory, and writes them to two registers.

Post-index:    LDP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;
Pre-index:     LDP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!
Signed offset: LDP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="547" header="Load Pair of Registers Signed Word" doc_id="armv8arm" token="LDPSW">Calculates an address from a base register value and an 
immediate offset, loads two 32-bit words from memory, 
sign-extends them, and writes them to two registers.

Post-index:    LDPSW &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;
Pre-index:     LDPSW &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!
Signed offset: LDPSW &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="550" header="Load Register" doc_id="armv8arm" token="LDR">1. Immediate
Loads a word or doubleword from memory and writes it to a register. 
The address that is used for the load is calculated from a base 
register and an immediate offset.

Post-index:      LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Literal
Calculates an address from the PC value and an immediate offset, 
loads a word from memory, and writes it to a register.

LDR &lt;Xt&gt;, &lt;label&gt;

3. Register
Calculates an address from a base register value and an offset register 
value, loads a word from memory, and writes it to a register. The offset 
register value can optionally be shifted and extended.

LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="557" header="Load Register Byte" doc_id="armv8arm" token="LDRB">1. Immediate
Loads a byte from memory, zero-extends it, and writes the result 
to a register. The address that is used for the load is calculated 
from a base register and an immediate offset.

Post-index:      LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset 
register value, loads a byte from memory, zero-extends it, 
and writes it to a register.

Extended register variant:
  LDR &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]

Shifted register variant:
  LDRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, &lt;Xm&gt;{, LSL &lt;amount&gt;}]</hint>
			<hint page="561" header="Load Register Halfword" doc_id="armv8arm" token="LDRH">1. Immediate
Loads a halfword from memory, zero-extends it, and writes the 
result to a register. The address that is used for the load is 
calculated from a base register and an immediate offset.

Post-index:      LDRH &lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;

Pre-index:       LDRH &lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: LDRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset 
register value, loads a halfword from memory, zero-extends it, 
and writes it to a register.

32-bit variant:
  LDRH &lt;Wt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="565" header="Load Register Signed Byte" doc_id="armv8arm" token="LDRSB">1. Immediate
Loads a byte from memory, sign-extends it to either 32 bits or 64 bits, 
and writes the result to a register. The address that is used for the 
load is calculated from a base register and an immediate offset.

Post-index:      LDRSB &lt;Xt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       LDRSB &lt;Xt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: LDRSB &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset register value, 
loads a byte from memory, sign-extends it, and writes it to a register.

64-bit with extended register offset variant
  LDRSB &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;), &lt;extend&gt; {&lt;amount&gt;}]
64-bit with shifted register offset variant
  LDRSB &lt;Xt&gt;, [&lt;Xn|SP&gt;, &lt;Xm&gt;{, LSL &lt;amount&gt;}]</hint>
			<hint page="570" header="Load Register Signed Halfword" doc_id="armv8arm" token="LDRSH">1. Immediate
Loads a halfword from memory, sign-extends it to 32 bits or 64 bits, 
and writes the result to a register. The address that is used for the 
load is calculated from a base register and an immediate offset.

Post-index:      LDRSH &lt;Xt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       LDRSH &lt;Xt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: LDRSH &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset register 
value, loads a halfword from memory, sign-extends it, and writes it to 
a register.

LDRSH &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="578" header="Load Register Signed Word" doc_id="armv8arm" token="LDRSW">1. Immediate
Loads a word from memory, sign-extends it to 64 bits, and writes the 
result to a register. The address that is used for the load is 
calculated from a base register and an immediate offset. 

Post-index:      LDRSW &lt;Xt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       LDRSW &lt;Xt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: LDRSW &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Literal
Calculates an address from the PC value and an immediate offset, 
loads a word from memory, and writes it to a register.

LDRSW &lt;Xt&gt;, &lt;label&gt;

3. Register
Calculates an address from a base register value and an offset register 
value, loads a word from memory, sign-extends it to form a 64-bit value, 
and writes it to a register. The offset register value can be shifted 
left by 0 or 2 bits.

LDRSW &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="580" header="Load Register (unprivileged)" doc_id="armv8arm" token="LDTR">Loads a word or doubleword from memory, and writes it to a register. 
The address that is used for the load is calculated from a base 
register and an immediate offset.

LDTR &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="582" header="Load Register Byte (unprivileged)" doc_id="armv8arm" token="LDTRB">Loads a byte from memory, zero-extends it, and writes the result 
to a register. The address that is used for the load is 
calculated from a base register and an immediate offset.

LDTRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="583" header="Load Register Halfword (unprivileged)" doc_id="armv8arm" token="LDTRH">Loads a halfword from memory, zero-extends it, and writes the 
result to a register. The address that is used for the load is 
calculated from a base register and an immediate offset.

LDTRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="584" header="Load Register Signed Byte (unprivileged)" doc_id="armv8arm" token="LDTRSB">Loads a byte from memory, sign-extends it to 32 bits or 64 bits, 
and writes the result to a register. The address that is used 
for the load is calculated from a base register and an immediate offset.

LDTRSB &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="586" header="Load Register Signed Halfword (unprivileged)" doc_id="armv8arm" token="LDTRSH">Loads a halfword from memory, sign-extends it to 32 bits or 64 bits, 
and writes the result to a register. The address that is used for 
the load is calculated from a base register and an immediate offset.

LDTRSH &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="588" header="Load Register Signed Word (unprivileged)" doc_id="armv8arm" token="LDTRSW">Loads a word from memory, sign-extends it to 64 bits, and writes 
the result to a register. The address that is used for the load 
is calculated from a base register and an immediate offset.

LDTRSW &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="589" header="Load Register (unscaled) " doc_id="armv8arm" token="LDUR">Calculates an address from a base register and an immediate offset, 
loads a 32-bit word or 64-bit doubleword from memory, zero-extends 
it, and writes it to a register.

LDUR &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="591" header="Load Register Byte (unscaled) " doc_id="armv8arm" token="LDURB">Calculates an address from a base register and an immediate offset, 
loads a byte from memory, zero-extends it, and writes it to a register.

LDURB &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="592" header="Load Register Halfword (unscaled) " doc_id="armv8arm" token="LDURH">Calculates an address from a base register and an immediate 
offset, loads a halfword from memory, zero-extends it, and 
writes it to a register.

LDURH &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="593" header="Load Register Signed Byte (unscaled) " doc_id="armv8arm" token="LDURSB">Calculates an address from a base register and an immediate 
offset, loads a signed byte from memory, sign-extends it, 
and writes it to a register.

LDURSB &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="595" header="Load Register Signed Halfword (unscaled) " doc_id="armv8arm" token="LDURSH">Calculates an address from a base register and an immediate 
offset, loads a signed halfword from memory, sign-extends 
it, and writes it to a register.

LDURSH &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="597" header="Load Register Signed Word (unscaled) " doc_id="armv8arm" token="LDURSW">Calculates an address from a base register and an immediate 
offset, loads a signed word from memory, sign-extends it, 
and writes it to a register.

LDURSW &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="598" header="Load Exclusive Pair of Registers" doc_id="armv8arm" token="LDXP">Derives an address from a base register value, loads two 32-bit 
words or two 64-bit doublewords from memory, and writes them to 
two registers. A 32-bit pair requires the address to be doubleword 
aligned and is single-copy atomic at doubleword granularity.
 A 64-bit pair requires the address to be quadword aligned and is 
single-copy atomic for each doubleword at doubleword granularity. 
The PE marks the physical address being accessed as an exclusive 
access. This exclusive access mark is checked by Store Exclusive 
instructions. 

LDXP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="600" header="Load Exclusive Register" doc_id="armv8arm" token="LDXR">Derives an address from a base register value, loads a 32-bit word 
or a 64-bit doubleword from memory, and writes it to a register. 
The memory access is atomic. The PE marks the physical address 
being accessed as an exclusive access. This exclusive access mark 
is checked by Store Exclusive instructions.  

LDXR &lt;Xt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="601" header="Load Exclusive Register Byte" doc_id="armv8arm" token="LDXRB">Derives an address from a base register value, loads a byte from memory, 
zero-extends it and writes it to a register. The memory access is atomic. 
The PE marks the physical address being accessed as an exclusive access. 
This exclusive access mark is checked by Store Exclusive instructions.

LDXRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="602" header="Load Exclusive Register Halfword" doc_id="armv8arm" token="LDXRH">Derives an address from a base register value, loads a halfword from memory, 
zero-extends it and writes it to a register. The memory access is atomic. 
The PE marks the physical address being accessed as an exclusive access. 
This exclusive access mark is checked by Store Exclusive instructions. 

LDXRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="603" header="Logical Shift Left" doc_id="armv8arm" token="LSL">1. Register
Shifts a register value left by a variable number of bits, shifting 
in zeros, and writes the result to the destination register. The 
remainder obtained by dividing the second source register by the 
data size defines the number of bits by which the first source 
register is left-shifted.

LSL &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

  is equivalent to

LSLV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

2. Immediate
Shifts a register value left by an immediate number of bits, shifting 
in zeros, and writes the result to the destination register.

LSL &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt;

  is equivalent to

UBFM &lt;Xd&gt;, &lt;Xn&gt;, #(-&lt;shift&gt; MOD 64), #(63-&lt;shift&gt;)</hint>
			<hint page="605" header="Logical Shift Left Variable" doc_id="armv8arm" token="LSLV">Shifts a register value left by a variable number of bits, shifting 
in zeros, and writes the result to the destination register. The 
remainder obtained by dividing the second source register by the 
data size defines the number of bits by which the first source 
register is left-shifted.

LSLV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="606" header="Logical Shift Right" doc_id="armv8arm" token="LSR">1. Register
Shifts a register value right by a variable number of bits, shifting in 
zeros, and writes the result to the destination register. The remainder 
obtained by dividing the second source register by the data size defines 
the number of bits by which the first source register is right-shifted.

LSR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

  is equivalent to

LSRV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

2. Immediate
Shifts a register value right by an immediate number of bits, shifting 
in zeros, and writes the result to the destination register.

LSR &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt;

  is equivalent to

UBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;shift&gt;, #63</hint>
			<hint page="608" header="Logical Shift Right Variable" doc_id="armv8arm" token="LSRV">Shifts a register value right by a variable number of bits, 
shifting in zeros, and writes the result to the destination 
register. The remainder obtained by dividing the second 
source register by the data size defines the number of bits 
by which the first source register is right-shifted.

LSRV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="609" header="Multiply-Add" doc_id="armv8arm" token="MADD">Multiplies two register values, adds a third register value, 
and writes the result to the destination register.

MADD &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, &lt;Xa&gt;</hint>
			<hint page="611" header="Multiply-Negate" doc_id="armv8arm" token="MNEG">Multiplies two register values, negates the product, and writes 
the result to the destination register.

MNEG &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

  is equivalent to

MSUB &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, XZR</hint>
			<hint page="612" header="Move" doc_id="armv8arm" token="MOV">1. To/from SP - moves between register and stack pointer : Rd = Rn

MOV &lt;Xd|SP&gt;, &lt;Xn|SP&gt;
  is equivalent to
ADD &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, #0

2. Inverted wide immediate - moves an inverted 16-bit immediate 
   value to a register.

MOV &lt;Xd&gt;, #&lt;imm&gt;
  is equivalent to
MOVN &lt;Xd&gt;, #&lt;imm16&gt;, LSL #&lt;shift&gt;

3. Wide immediate - moves a 16-bit immediate value to a register.

MOV &lt;Xd&gt;, #&lt;imm&gt;
  is equivalent to
MOVZ &lt;Xd&gt;, #&lt;imm16&gt;, LSL #&lt;shift&gt;

4. Bitmask immediate - writes a bitmask immediate value to a register.

MOV &lt;Xd|SP&gt;, #&lt;imm&gt;
  is equivalent to
ORR &lt;Xd|SP&gt;, XZR, #&lt;imm&gt;

5. Register - copies the value in a source register to the destination register.

MOV &lt;Xd&gt;, &lt;Xm&gt;
  is equivalent to
ORR &lt;Xd&gt;, XZR, &lt;Xm&gt;</hint>
			<hint page="617" header="Move wide with keep" doc_id="armv8arm" token="MOVK">Moves an optionally-shifted 16-bit immediate value into a register, 
keeping other bits unchanged.

MOVK &lt;Xd&gt;, #&lt;imm&gt;{, LSL #&lt;shift&gt;}</hint>
			<hint page="618" header="Move wide with NOT" doc_id="armv8arm" token="MOVN">Moves the inverse of an optionally-shifted 16-bit immediate 
value to a register.

MOVN &lt;Xd&gt;, #&lt;imm&gt;{, LSL #&lt;shift&gt;}</hint>
			<hint page="620" header="Move wide with zero" doc_id="armv8arm" token="MOVZ">Moves an optionally-shifted 16-bit immediate value to a register.

MOVZ &lt;Xd&gt;, #&lt;imm&gt;{, LSL #&lt;shift&gt;}</hint>
			<hint page="626" header="Multiply-Subtract" doc_id="armv8arm" token="MSUB">Multiplies two register values, subtracts the product from a third 
register value, and writes the result to the destination register.

MSUB &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, &lt;Xa&gt;</hint>
			<hint page="628" header="Multiply" doc_id="armv8arm" token="MUL">Multiply : Rd = Rn * Rm

MUL &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

  is equivalent to

MADD &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;, XZR</hint>
			<hint page="629" header="Bitwise NOT" doc_id="armv8arm" token="MVN">Writes the bitwise inverse of a register value to the destination register.

MVN &lt;Xd&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}

  is equivalent to

ORN &lt;Xd&gt;, XZR, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="631" header="Negate" doc_id="armv8arm" token="NEG">Negates (shifted register) an optionally-shifted register value, 
and writes the result to the destination register.

NEG &lt;Xd&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}

  is equivalent to

SUB &lt;Xd&gt;, XZR, &lt;Xm&gt; {, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="633" header="Negate (setting flags)" doc_id="armv8arm" token="NEGS">Negates an optionally-shifted register value, and writes the 
result to the destination register. It updates the condition 
flags based on the result.

NEGS &lt;Xd&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}

  is equivalent to

SUBS &lt;Xd&gt;, XZR, &lt;Xm&gt; {, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="635" header="Negate with Carry" doc_id="armv8arm" token="NGC">Negates the sum of a register value and the value of NOT (Carry flag), 
and writes the result to the destination register.

NGC &lt;Xd&gt;, &lt;Xm&gt;

  is equivalent to

SBC &lt;Xd&gt;, XZR, &lt;Xm&gt;</hint>
			<hint page="636" header="Negate with Carry (setting flags)" doc_id="armv8arm" token="NGCS">Negates the sum of a register value and the value of NOT (Carry flag), 
and writes the result to the destination register. It updates the 
condition flags based on the result.

NGCS &lt;Xd&gt;, &lt;Xm&gt;

  is equivalent to

SBCS &lt;Xd&gt;, XZR, &lt;Xm&gt;</hint>
			<hint page="638" header="Bitwise OR NOT" doc_id="armv8arm" token="ORN">Performs a bitwise (inclusive) OR of a register value and the 
complement of an optionally-shifted register value, and writes 
the result to the destination register.

ORN &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="640" header="Bitwise OR" doc_id="armv8arm" token="ORR">1. Immediate
Performs a bitwise (inclusive) OR of a register value and an immediate 
register value, and writes the result to the destination register.

ORR &lt;Xd|SP&gt;, &lt;Xn&gt;, #&lt;imm&gt;

2. Shifted register
Performs a bitwise (inclusive) OR of a register value and an 
optionally-shifted register value, and writes the result to the 
destination register.

ORR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="644" header="Prefetch Memory" doc_id="armv8arm" token="PRFM">Signals the memory system that data memory accesses from a specified 
address are likely to occur in the near future. The memory system can 
respond by taking actions that are expected to speed up the memory 
accesses when they do occur, such as preloading the cache line 
containing the specified address into one or more caches.

1. Immediate

PRFM (&lt;prfop&gt;|#&lt;imm5&gt;), [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Literal

PRFM (&lt;prfop&gt;|#&lt;imm5&gt;), &lt;label&gt;

3. Register

PRFM (&lt;prfop&gt;|#&lt;imm5&gt;), [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]

4. Unscaled offset

PRFUM (&lt;prfop&gt;|#&lt;imm5&gt;), [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="652" header="Reverse Bits" doc_id="armv8arm" token="RBIT">Reverses the bit order in a register.

RBIT &lt;Xd&gt;, &lt;Xn&gt;</hint>
			<hint page="653" header="Return" doc_id="armv8arm" token="RET">Return from subroutine branches unconditionally to an address in a 
register, with a hint that this is a subroutine return.

RET {&lt;Xn&gt;}</hint>
			<hint page="654" header="Reverse Bytes" doc_id="armv8arm" token="REV">Reverses the byte order in a register.

REV &lt;Xd&gt;, &lt;Xn&gt;</hint>
			<hint page="656" header="Reverse bytes in 16-bit halfwords" doc_id="armv8arm" token="REV16">Reverses the byte order in each 16-bit halfword of a register.

REV16 &lt;Xd&gt;, &lt;Xn&gt;</hint>
			<hint page="658" header="Reverse bytes in 32-bit words" doc_id="armv8arm" token="REV32">Reverses the byte order in each 32-bit word of a register.

REV32 &lt;Xd&gt;, &lt;Xn&gt;</hint>
			<hint page="659" header="Reverse bytes in 64-bit words" doc_id="armv8arm" token="REV64">Reverse Bytes reverses the byte order in a 64-bit general-purpose register.

REV64 &lt;Xd&gt;, &lt;Xn&gt;

  is equivalent to

REV &lt;Xd&gt;, &lt;Xn&gt;</hint>
			<hint page="660" header="Rotate right" doc_id="armv8arm" token="ROR">1. Immediate
Provides the value of the contents of a register rotated by a variable 
number of bits. The bits that are rotated off the right end are inserted 
into the vacated bit positions on the left.

ROR &lt;Xd&gt;, &lt;Xs&gt;, #&lt;shift&gt;

  is equivalent to

EXTR &lt;Xd&gt;, &lt;Xs&gt;, &lt;Xs&gt;, #&lt;shift&gt;

2. Register
Provides the value of the contents of a register rotated by a variable number 
of bits. The bits that are rotated off the right end are inserted into the 
vacated bit positions on the left. The remainder obtained by dividing the 
second source register by the data size defines the number of bits by which 
the first source register is right-shifted.

ROR &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;

  is equivalent to

RORV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="662" header="Rotate Right Variable" doc_id="armv8arm" token="RORV">Provides the value of the contents of a register rotated by a variable 
number of bits. The bits that are rotated off the right end are inserted 
into the vacated bit positions on the left. The remainder obtained by 
dividing the second source register by the data size defines the number 
of bits by which the first source register is right-shifted.

RORV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="663" header="Subtract with Carry" doc_id="armv8arm" token="SBC">Subtracts a register value and the value of NOT (Carry flag) from a 
register value, and writes the result to the destination register.

SBC &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="665" header="Subtract with Carry (setting flags)" doc_id="armv8arm" token="SBCS">Subtracts a register value and the value of NOT (Carry flag) from a 
register value, and writes the result to the destination register. 
It updates the condition flags based on the result.

SBCS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="667" header="Signed Bitfield Insert in Zero " doc_id="armv8arm" token="SBFIZ">Zeroes the destination register and copies any number of contiguous bits
 from a source register into any position in the destination register, 
sign-extending the most significant bit of the transferred value.

SBFIZ &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;

  is equivalent to

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #(-&lt;lsb&gt; MOD 64), #(&lt;width&gt;-1)</hint>
			<hint page="668" header="Signed Bitfield Move" doc_id="armv8arm" token="SBFM">Copies any number of low-order bits from a source register into the 
same number of adjacent bits at any position in the destination 
register, shifting in copies of the sign bit in the upper bits and 
zeros in the lower bits.

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</hint>
			<hint page="670" header="Signed Bitfield Extract" doc_id="armv8arm" token="SBFX">Extracts any number of adjacent bits at any position from a register, 
sign-extends them to the size of the register, and writes the result 
to the destination register.

SBFX &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;

  is equivalent to

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #(&lt;lsb&gt;+&lt;width&gt;-1)</hint>
			<hint page="671" header="Signed Divide" doc_id="armv8arm" token="SDIV">Divides a signed integer register value by another signed integer 
register value, and writes the result to the destination register. 
The condition flags are not affected.

SDIV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="674" header="Signed Multiply-Add Long" doc_id="armv8arm" token="SMADDL">Multiplies two 32-bit register values, adds a 64-bit register value, 
and writes the result to the 64-bit destination register.

SMADDL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;</hint>
			<hint page="676" header="Signed Multiply-Negate Long" doc_id="armv8arm" token="SMNEGL">Multiplies two 32-bit register values, negates the product, 
and writes the result to the 64-bit destination register.

SMSUBL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, XZR</hint>
			<hint page="677" header="Signed Multiply-Subtract Long" doc_id="armv8arm" token="SMSUBL">Multiplies two 32-bit register values, subtracts the product from a 64-bit 
register value, and writes the result to the 64-bit destination register.

SMSUBL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;</hint>
			<hint page="678" header="Signed Multiply High" doc_id="armv8arm" token="SMULH">Multiplies two 64-bit register values, and writes bits[127:64] 
of the 128-bit result to the 64-bit destination register.

SMULH &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="678" header="Signed Multiply Long" doc_id="armv8arm" token="SMULL">Multiplies two 32-bit register values, and writes the 
result to the 64-bit destination register.

SMADDL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, XZR</hint>
			<hint page="680" header="Store-Release Register" doc_id="armv8arm" token="STLR">Stores a 32-bit word or a 64-bit doubleword to a 
memory location, from a register. 

STLR &lt;Xt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="681" header="Store-Release Register Byte" doc_id="armv8arm" token="STLRB">Stores a byte from a 32-bit register to a memory location.

STLRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="682" header="Store-Release Register Halfword" doc_id="armv8arm" token="STLRH">Stores a halfword from a 32-bit register to a memory location.

STLRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="683" header="Store-Release Exclusive Pair of registers" doc_id="armv8arm" token="STLXP">Stores two 32-bit words or two 64-bit doublewords to a memory location 
if the PE has exclusive access to the memory address, from two registers, 
and returns a status value of 0 if the store was successful, or of 1 if 
no store was performed.

STLXP &lt;Ws&gt;, &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="686" header="Store-Release Exclusive Register" doc_id="armv8arm" token="STLXR">Stores a 32-bit word or a 64-bit doubleword to memory if the PE has exclusive 
access to the memory address, from two registers, and returns a status value 
of 0 if the store was successful, or of 1 if no store was performed. 

STLXR &lt;Ws&gt;, &lt;Xt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="688" header="Store-Release Exclusive Register Byte" doc_id="armv8arm" token="STLXRB">Stores a byte from a 32-bit register to memory if the PE has exclusive 
access to the memory address, and returns a status value of 0 if the 
store was successful, or of 1 if no store was performed.

STLXRB &lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="690" header="Store-Release Exclusive Register Halfword" doc_id="armv8arm" token="STLXRH">Stores a halfword from a 32-bit register to memory if the PE has exclusive access 
to the memory address, and returns a status value of 0 if the store was successful, 
or of 1 if no store was performed.

STLXRH &lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="692" header="Store Pair of Registers, with non-temporal hint" doc_id="armv8arm" token="STNP">Calculates an address from a base register value and an immediate offset, 
and stores two 32-bit words or two 64-bit doublewords to the calculated 
address, from two registers. 

STNP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="694" header="Store Pair of Registers" doc_id="armv8arm" token="STP">Calculates an address from a base register value and an immediate offset, 
and stores two 32-bit words or two 64-bit doublewords to the calculated 
address, from two registers.

STP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;</hint>
			<hint page="697" header="Store Register" doc_id="armv8arm" token="STR">1. Immediate
Stores a word or a doubleword from a register to memory. The address that 
is used for the store is calculated from a base register and an immediate 
offset.

Post-index:      STR &lt;Xt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       STR &lt;Xt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: STR &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset register 
value, and stores a 32-bit word or a 64-bit doubleword to the calculated 
address, from a register.

STR &lt;Xt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="702" header="Store Register Byte" doc_id="armv8arm" token="STRB">1. Immediate
Stores the least significant byte of a 32-bit register to memory. The 
address that is used for the store is calculated from a base register 
and an immediate offset. 

Post-index:      STRB &lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       STRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: STRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset register 
value, and stores a byte from a 32-bit register to the calculated address. 

Extended register variant: 
  STRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;), &lt;extend&gt; {&lt;amount&gt;}]
Shifted register variant:
  STRB &lt;Wt&gt;, [&lt;Xn|SP&gt;, &lt;Xm&gt;{, LSL &lt;amount&gt;}]</hint>
			<hint page="706" header="Store Register Halfword" doc_id="armv8arm" token="STRH">1. Immediate
Stores the least significant halfword of a 32-bit register to memory. The 
address that is used for the store is calculated from a base register and 
an immediate offset.

Post-index:      STRH &lt;Wt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
Pre-index:       STRH &lt;Wt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
Unsigned offset: STRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
Calculates an address from a base register value and an offset register 
value, and stores a halfword from a 32-bit register to the calculated 
address.

32-bit variant:
  STRH &lt;Wt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="710" header="Store Register (unprivileged)" doc_id="armv8arm" token="STTR">Stores a word or doubleword from a register to memory. The address that is 
used for the store is calculated from a base register and an immediate offset.

STTR &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="712" header="Store Register Byte (unprivileged)" doc_id="armv8arm" token="STTRB">Stores a byte from a 32-bit register to memory. The address that is used 
for the store is calculated from a base register and an immediate offset.

STTRB &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="713" header="Store Register Halfword (unprivileged)" doc_id="armv8arm" token="STTRH">Stores a halfword from a 32-bit register to memory. The address that is used 
for the store is calculated from a base register and an immediate offset.

STTRH &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="714" header="Store Register (unscaled)" doc_id="armv8arm" token="STUR">Calculates an address from a base register value and an immediate offset, 
and stores a 32-bit word or a 64-bit doubleword to the calculated address, 
from a register.

STUR &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="715" header="Store Register Byte (unscaled)" doc_id="armv8arm" token="STURB">Calculates an address from a base register value and an immediate offset, 
and stores a byte to the calculated address, from a 32-bit register.

STURB &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="716" header="Store Register Halfword (unscaled)" doc_id="armv8arm" token="STURH">Calculates an address from a base register value and an immediate offset, 
and stores a halfword to the calculated address, from a 32-bit register.

STURH &lt;Wt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="717" header="Store Exclusive Pair of registers" doc_id="armv8arm" token="STXP">Stores two 32-bit words or two 64-bit doublewords from two registers to a 
memory location if the PE has exclusive access to the memory address, and 
returns a status value of 0 if the store was successful, or of 1 if no 
store was performed.

STXP &lt;Ws&gt;, &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="720" header="Store Exclusive Register" doc_id="armv8arm" token="STXR">Stores a 32-bit word or a 64-bit doubleword from a register to memory 
if the PE has exclusive access to the memory address, and returns a 
status value of 0 if the store was successful, or of 1 if no store 
was performed.

STXR &lt;Ws&gt;, &lt;Xt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="722" header="Store Exclusive Register Byte" doc_id="armv8arm" token="STXRB">Stores a byte from a register to memory if the PE has exclusive access 
to the memory address, and returns a status value of 0 if the store was 
successful, or of 1 if no store was performed.

STXRB &lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="724" header="Store Exclusive Register Halfword" doc_id="armv8arm" token="STXRH">Stores a halfword from a register to memory if the PE has exclusive access 
to the memory address, and returns a status value of 0 if the store was 
successful, or of 1 if no store was performed.

STXRH &lt;Ws&gt;, &lt;Wt&gt;, [&lt;Xn|SP&gt;{,#0}]</hint>
			<hint page="726" header="Subtract" doc_id="armv8arm" token="SUB">1. Extended register
Subtracts a sign or zero-extended register value, followed by an 
optional left shift amount, from a register value, and writes the 
result to the destination register. The argument that is extended 
from the &lt;Rm&gt; register can be a byte, halfword, word, or doubleword.

SUB &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

2. Immediate
Subtracts an optionally-shifted immediate value from a register 
value, and writes the result to the destination register.

SUB &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}

3. Shifted register
Subtracts an optionally-shifted register value from a register value, 
and writes the result to the destination register.

SUB &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="732" header="Subtract (setting flags)" doc_id="armv8arm" token="SUBS">1. Extended register
Subtracts a sign or zero-extended register value, followed by an optional 
left shift amount, from a register value, and writes the result to the 
destination register. The argument that is extended from the &lt;Rm&gt; register 
can be a byte, halfword, word, or doubleword. It updates the condition 
flags based on the result.

SUBS &lt;Xd&gt;, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}

2. Immediate
Subtracts an optionally-shifted immediate value from a register value, 
and writes the result to the destination register. It updates the 
condition flags based on the result.

SUBS &lt;Xd&gt;, &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}

3. Shifted register
Subtracts an optionally-shifted register value from a register value, 
and writes the result to the destination register. It updates the 
condition flags based on the result.


SUBS &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="739" header="Signed Extend Byte" doc_id="armv8arm" token="SXTB">Extracts an 8-bit value from a register, sign-extends it to the size 
of the register, and writes the result to the destination register.

SXTB &lt;Xd&gt;, &lt;Wn&gt;

  is equivalent to

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #0, #7</hint>
			<hint page="740" header="Sign Extend Halfword" doc_id="armv8arm" token="SXTH">Extracts a 16-bit value, sign-extends it to the size of the register, 
and writes the result to the destination register.

SXTH &lt;Xd&gt;, &lt;Wn&gt;

  is equivalent to

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #0, #15</hint>
			<hint page="741" header="Sign Extend Word" doc_id="armv8arm" token="SXTW">Sign-extends a word to the size of the register, and 
writes the result to the destination register.

SBFM &lt;Xd&gt;, &lt;Xn&gt;, #0, #31</hint>
			<hint page="744" header="Test bit and Branch if Nonzero" doc_id="armv8arm" token="TBNZ">Compares the value of a bit in a general-purpose register with zero, 
and conditionally branches to a label at a PC-relative offset if the 
comparison is not equal. It provides a hint that this is not a subroutine 
call or return. This instruction does not affect condition flags.

TBNZ &lt;R&gt;&lt;t&gt;, #&lt;imm&gt;, &lt;label&gt;</hint>
			<hint page="745" header="Test bit and Branch if Zero" doc_id="armv8arm" token="TBZ">Compares the value of a test bit with zero, and conditionally branches 
to a label at a PC-relative offset if the comparison is equal. 
It provides a hint that this is not a subroutine call or return. 
This instruction does not affect condition flags.

TBZ &lt;R&gt;&lt;t&gt;, #&lt;imm&gt;, &lt;label&gt;</hint>
			<hint page="748" header="Test bits" doc_id="armv8arm" token="TST">1. Immediate
Setting the condition flags and discarding the result : Rn AND imm

TST &lt;Xn&gt;, #&lt;imm&gt;

  is equivalent to

ANDS XZR, &lt;Xn&gt;, #&lt;imm&gt;

2. Shifted register
Performs a bitwise AND operation on a register value and an 
optionally-shifted register value. It updates the condition 
flags based on the result, and discards the result.

TST &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}

  is equivalent to

ANDS XZR, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}</hint>
			<hint page="751" header="Unsigned Bitfield Insert in Zero" doc_id="armv8arm" token="UBFIZ">Zeroes the destination register and copies any number of 
contiguous bits from a source register into any position
in the destination register.

UBFIZ &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;

  is equivalent to

UBFM &lt;Xd&gt;, &lt;Xn&gt;, #(-&lt;lsb&gt; MOD 64), #(&lt;width&gt;-1)</hint>
			<hint page="752" header="Unsigned Bitfield Move" doc_id="armv8arm" token="UBFM">Copies any number of low-order bits from a source register 
into the same number of adjacent bits at any position in the 
destination register, with zeros in the upper and lower bits.

UBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</hint>
			<hint page="754" header="Unsigned Bitfield Extract" doc_id="armv8arm" token="UBFX">Extracts any number of adjacent bits at any position from a register, 
zero-extends them to the size of the register, and writes the result 
to the destination register.

UBFX &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;

  is equivalent to

UBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #(&lt;lsb&gt;+&lt;width&gt;-1)</hint>
			<hint page="755" header="Unsigned Divide" doc_id="armv8arm" token="UDIV">Divides an unsigned integer register value by another unsigned 
integer register value, and writes the result to the destination 
register. The condition flags are not affected.

UDIV &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="756" header="Unsigned Multiply-Add Long" doc_id="armv8arm" token="UMADDL">Multiplies two 32-bit register values, adds a 64-bit register value, 
and writes the result to the 64-bit destination register.

UMADDL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;</hint>
			<hint page="757" header="Unsigned Multiply-Negate Long" doc_id="armv8arm" token="UMNEGL">Multiplies two 32-bit register values, negates the product, 
and writes the result to the 64-bit destination register.

UMSUBL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, XZR</hint>
			<hint page="758" header="Unsigned Multiply-Subtract Long" doc_id="armv8arm" token="UMSUBL">Multiplies two 32-bit register values, subtracts the product from 
a 64-bit register value, and writes the result to the 64-bit 
destination register.

UMSUBL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;</hint>
			<hint page="759" header="Unsigned Multiply High" doc_id="armv8arm" token="UMULH">Multiplies two 64-bit register values, and writes bits[127:64] 
of the 128-bit result to the 64-bit destination register.

UMULH &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;</hint>
			<hint page="760" header="Unsigned Multiply Long" doc_id="armv8arm" token="UMULL">Multiplies two 32-bit register values, and writes the 
result to the 64-bit destination register.

UMADDL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, XZR</hint>
			<hint page="761" header="Unsigned Extend Byte" doc_id="armv8arm" token="UXTB">Extracts an 8-bit value from a register, zero-extends it to the size 
of the register, and writes the result to the destination register.

32-bit variant: 

UXTB &lt;Wd&gt;, &lt;Wn&gt;

  is equivalent to

UBFM &lt;Wd&gt;, &lt;Wn&gt;, #0, #7</hint>
			<hint page="762" header="Unsigned Extend Halfword" doc_id="armv8arm" token="UXTH">Extracts a 16-bit value from a register, zero-extends it to the size 
of the register, and writes the result to the destination register.

32-bit variant:

UXTH &lt;Wd&gt;, &lt;Wn&gt;

  is equivalent to

UBFM &lt;Wd&gt;, &lt;Wn&gt;, #0, #15</hint>
		</group>
		<group type="ins" name="A64 Exception generation/return instructions">
			<hint page="475" header="Breakpoint Instruction" doc_id="armv8arm" token="BRK">Generates a Breakpoint Instruction exception.

The PE records the exception in ESR_ELx, using the EC value 0x3c, 
and captures the value of the immediate argument in ESR_ELx.ISS.

BRK #&lt;imm&gt;</hint>
			<hint page="529" header="Halt Instruction" doc_id="armv8arm" token="HLT">Halt instruction generates a Halt Instruction debug event.

HLT #&lt;imm&gt;</hint>
			<hint page="530" header="Generate exception targeting EL2" doc_id="armv8arm" token="HVC">Hypervisor Call causes an exception to EL2. 
Non-secure software executing at EL1 can use this instruction 
to call the hypervisor to request a service.

HVC #&lt;imm&gt;</hint>
			<hint page="675" header="Secure Monitor Call" doc_id="armv8arm" token="SMC">Causes an exception to EL3.
SMC is available only for software executing at 
EL1 or higher. It is UNDEFINED in EL0.

SMC #&lt;imm&gt;</hint>
			<hint page="738" header="Supervisor Call" doc_id="armv8arm" token="SVC">Causes an exception to be taken to EL1.
On executing an SVC instruction, the PE records the exception as a 
Supervisor Call exception in ESR_ELx, using the EC value 0x15, and 
the value of the immediate argument.

SVC #&lt;imm&gt;</hint>
			<hint page="525" header="Exception Return" doc_id="armv8arm" token="ERET">Exception Return using the ELR and SPSR for the current Exception level. 
When executed, the PE restores PSTATE from the SPSR, and branches to 
the address held in the ELR.

ERET</hint>
			<hint page="512" header="Debug switch to EL1" doc_id="armv8arm" token="DCPS1">Debug Change PE State to EL1.

DCPS1 {#&lt;imm&gt;}</hint>
			<hint page="513" header="Debug switch to EL2" doc_id="armv8arm" token="DCPS2">Debug Change PE State to EL2.

DCPS2 {#&lt;imm&gt;}</hint>
			<hint page="514" header="Debug switch to EL3" doc_id="armv8arm" token="DCPS3">Debug Change PE State to EL3.

DCPS3 {#&lt;imm&gt;}</hint>
			<hint page="517" header="Debug restore PE state" doc_id="armv8arm" token="DRPS">Debug restore process state.

DRPS</hint>
		</group>
		<group type="ins" name="A64 System instructions">
			<hint page="622" header="Move System Register" doc_id="armv8arm" token="MRS">Allows the PE to read an AArch64 System register into a 
general-purpose register.

MRS &lt;Xt&gt;, (&lt;systemreg&gt;|S&lt;op0&gt;_&lt;op1&gt;_&lt;Cn&gt;_&lt;Cm&gt;_&lt;op2&gt;)</hint>
			<hint page="623" header="Move to Special Register" doc_id="armv8arm" token="MSR">1. Immediate
Move immediate value to Special Register moves an immediate 
value to selected bits of the PSTATE.

MSR &lt;pstatefield&gt;, #&lt;imm&gt;

2. Register
Move general-purpose register to System Register allows 
the PE to write an AArch64 System register from a 
general-purpose register.

MSR (&lt;systemreg&gt;|S&lt;op0&gt;_&lt;op1&gt;_&lt;Cn&gt;_&lt;Cm&gt;_&lt;op2&gt;), &lt;Xt&gt;</hint>
			<hint page="742" header="System instruction" doc_id="armv8arm" token="SYS">This instruction is used by the aliases AT, DC, IC, and TLBI.

SYS #&lt;op1&gt;, &lt;Cn&gt;, &lt;Cm&gt;, #&lt;op2&gt;{, &lt;Xt&gt;}</hint>
			<hint page="743" header="System instruction with result" doc_id="armv8arm" token="SYSL">SYSL &lt;Xt&gt;, #&lt;op1&gt;, &lt;Cn&gt;, &lt;Cm&gt;, #&lt;op2&gt;</hint>
			<hint page="531" header="Instruction cache operation" doc_id="armv8arm" token="IC">This instruction is an alias of the SYS instruction.

IC &lt;ic_op&gt;{, &lt;Xt&gt;}

  is equivalent to

SYS #&lt;op1&gt;, C7, &lt;Cm&gt;, #&lt;op2&gt;{, &lt;Xt&gt;}</hint>
			<hint page="511" header="Data Cache operation" doc_id="armv8arm" token="DC">This instruction is an alias of the SYS instruction.

DC &lt;dc_op&gt;, &lt;Xt&gt;

  is equivalent to

SYS #&lt;op1&gt;, C7, &lt;Cm&gt;, #&lt;op2&gt;, &lt;Xt&gt;</hint>
			<hint page="461" header="Address translation operation" doc_id="armv8arm" token="AT">This instruction is an alias of the SYS instruction.

AT &lt;at_op&gt;, &lt;Xt&gt;

  is equivalent to

SYS #&lt;op1&gt;, C7, &lt;Cm&gt;, #&lt;op2&gt;, &lt;Xt&gt;</hint>
			<hint page="746" header="TLB Invalidate operation" doc_id="armv8arm" token="TLBI">This instruction is an alias of the SYS instruction.

TLBI &lt;tlbi_op&gt;{, &lt;Xt&gt;}

  is equivalent to

SYS #&lt;op1&gt;, C8, &lt;Cm&gt;, #&lt;op2&gt;{, &lt;Xt&gt;}</hint>
		</group>
		<group type="ins" name="A64 Hint instructions">
			<hint page="637" header="No Operation" doc_id="armv8arm" token="NOP">Does nothing, other than advance the value of the program counter by 4. 
This instruction can be used for instruction alignment purposes.

NOP</hint>
			<hint page="765" header="Yield hint" doc_id="armv8arm" token="YIELD">Software with a multithreading capability can use a YIELD instruction to 
indicate to the PE that it is performing a task, for example a spin-lock, 
that could be swapped out to improve overall system performance. The PE 
can use this hint to suspend and resume multiple software threads if it 
supports the capability.

YIELD</hint>
			<hint page="763" header="Wait for event" doc_id="armv8arm" token="WFE">Hint instruction that permits the PE to enter a low-power 
state until one of a number of events occurs, including 
events signaled by executing the SEV instruction on any 
PE in the multiprocessor system.

WFE</hint>
			<hint page="764" header="Wait for interrupt" doc_id="armv8arm" token="WFI">Hint instruction that permits the PE to enter a low-power 
state until one of a number of asynchronous event occurs.

WFI</hint>
			<hint page="672" header="Send Event" doc_id="armv8arm" token="SEV">Hint instruction. It causes an event to be signaled to 
all PEs in the multiprocessor system.

SEV</hint>
			<hint page="673" header="Send Event Local" doc_id="armv8arm" token="SEVL">Hint instruction. It causes an event to be signaled locally without 
the requirement to affect other PEs in the multiprocessor system. 
It can prime a wait-loop which starts with a WFE instruction.

SEVL</hint>
			<hint page="528" header="Unallocated hint" doc_id="armv8arm" token="HINT">Hint instruction is for the instruction set space that 
is reserved for architectural hint instructions.

HINT #&lt;imm&gt;</hint>
		</group>
		<group type="ins" name="A64 Barriers and CLREX instructions">
			<hint page="484" header="Clear Exclusive" doc_id="armv8arm" token="CLREX">Clears the local monitor of the executing PE.

CLREX {#&lt;imm&gt;}</hint>
			<hint page="518" header="Data Synchronization Barrier" doc_id="armv8arm" token="DSB">Data Synchronization Barrier is a memory barrier that 
ensures the completion of memory accesses.

DSB &lt;option&gt;|#&lt;imm&gt;</hint>
			<hint page="515" header="Data Memory Barrier" doc_id="armv8arm" token="DMB">Data Memory Barrier is a memory barrier that ensures 
the ordering of observations of memory accesses.

DMB &lt;option&gt;|#&lt;imm&gt;</hint>
			<hint page="532" header="Instruction Synchronization Barrier" doc_id="armv8arm" token="ISB">Instruction Synchronization Barrier flushes the pipeline in the PE, 
so that all instructions following the ISB are fetched from cache 
or memory, after the instruction has been completed. It ensures that 
the effects of context changing operations executed before the ISB 
instruction are visible to the instructions fetched after the ISB. 
Context changing operations include changing the ASID, TLB 
maintenance instructions, and all changes to the System registers. 
In addition, any branches that appear in program order after the 
ISB instruction are written into the branch prediction logic with 
the context that is visible after the ISB instruction. This is 
needed to ensure correct execution of the instruction stream.

ISB {&lt;option&gt;|#&lt;imm&gt;}</hint>
		</group>
		<group type="ins" name="A64 Floating Point instructions">
			<hint page="828" header="Floating-point Absolute Difference (vector)" doc_id="armv8arm" token="FABD">This instruction subtracts the floating-point values in the elements 
of the second source SIMD&amp;FP register, from the corresponding 
floating-point values in the elements of the first source SIMD&amp;FP 
register, places the absolute value of each result in a vector, 
and writes the vector to the destination SIMD&amp;FP register.

FABD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="830" header="Floating-point Absolute value" doc_id="armv8arm" token="FABS">1. Vector
This instruction calculates the absolute value of each vector element 
in the source SIMD&amp;FP register, writes the result to a vector, and 
writes the vector to the destination SIMD&amp;FP register.

FABS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction calculates the absolute value in the SIMD&amp;FP source 
register and writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FABS &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FABS &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="832" header="Floating-point Absolute Compare Greater than or Equal (vector)" doc_id="armv8arm" token="FACGE">This instruction compares the absolute value of each floating-point 
value in the first source SIMD&amp;FP register with the absolute value 
of the corresponding floating-point value in the second source SIMD&amp;FP 
register and if the first value is greater than or equal to the second 
value sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to one, otherwise sets every bit of the 
corresponding vector element in the destination SIMD&amp;FP register to zero.

FACGE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="834" header="Floating-point Absolute Compare Greater than (vector)" doc_id="armv8arm" token="FACGT">This instruction compares the absolute value of each vector element 
in the first source SIMD&amp;FP register with the absolute value of the 
corresponding vector element in the second source SIMD&amp;FP register 
and if the first value is greater than the second value sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP 
register to one, otherwise sets every bit of the corresponding 
vector element in the destination SIMD&amp;FP register to zero.

FACGT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="836" header="Floating-point Add" doc_id="armv8arm" token="FADD">1. Vector
This instruction adds corresponding vector elements in the two source 
SIMD&amp;FP registers, writes the result into a vector, and writes the vector 
to the destination SIMD&amp;FP register. All the values in this instruction 
are floating-point values.

FADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction adds the floating-point values of the two source SIMD&amp;FP 
registers, and writes the result to the destination SIMD&amp;FP register.

Single-precision variant
  FADD &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FADD &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="840" header="Floating-point Add Pair" doc_id="armv8arm" token="FADDP">1. Vector
This instruction creates a vector by concatenating the vector elements of the 
first source SIMD&amp;FP register after the vector elements of the second source 
SIMD&amp;FP register, reads each pair of adjacent vector elements from the 
concatenated vector, adds each pair of values together, places the result 
into a vector, and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are floating-point values.

FADDP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction adds two floating-point vector elements in the source SIMD&amp;FP 
register and writes the scalar result into the destination SIMD&amp;FP register.

FADDP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="843" header="Floating-point Conditional quiet Compare (scalar)" doc_id="armv8arm" token="FCCMP">This instruction compares the two SIMD&amp;FP source register values and 
writes the result to the PSTATE.{N, Z, C, V} flags. If the condition 
does not pass then the PSTATE.{N, Z, C, V} flags are set to the flag 
bit specifier.

Single-precision variant
  FCCMP &lt;Sn&gt;, &lt;Sm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;
Double-precision variant
  FCCMP &lt;Dn&gt;, &lt;Dm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;</hint>
			<hint page="845" header="Floating-point Conditional signaling Compare (scalar)" doc_id="armv8arm" token="FCCMPE">This instruction compares the two SIMD&amp;FP source register values and 
writes the result to the PSTATE.{N, Z, C, V} flags. If the condition 
does not pass then the PSTATE.{N, Z, C, V} flags are set to the flag 
bit specifier.

Single-precision variant
  FCCMPE &lt;Sn&gt;, &lt;Sm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;
Double-precision variant
  FCCMPE &lt;Dn&gt;, &lt;Dm&gt;, #&lt;nzcv&gt;, &lt;cond&gt;</hint>
			<hint page="847" header="Floating-point Compare Equal (vector)" doc_id="armv8arm" token="FCMEQ">1. Register
This instruction compares each floating-point value from the first source 
SIMD&amp;FP register, with the corresponding floating-point value from the 
second source SIMD&amp;FP register, and if the comparison is equal sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP register 
to one, otherwise sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to zero.

FCMEQ &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. Zero
This instruction reads each floating-point value in the source SIMD&amp;FP 
register and if the value is equal to zero sets every bit of the 
corresponding vector element in the destination SIMD&amp;FP register to one, 
otherwise sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to zero.

FCMEQ &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0.0</hint>
			<hint page="851" header="Floating-point Compare Greater than or Equal (vector)" doc_id="armv8arm" token="FCMGE">1. Register
This instruction reads each floating-point value in the first source 
SIMD&amp;FP register and if the value is greater than or equal to the 
corresponding floating-point value in the second source SIMD&amp;FP 
register sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to one, otherwise sets every bit of the 
corresponding vector element in the destination SIMD&amp;FP register to zero.

FCMGE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. Zero
This instruction reads each floating-point value in the source SIMD&amp;FP 
register and if the value is greater than or equal to zero sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP 
register to one, otherwise sets every bit of the corresponding vector 
element in the destination SIMD&amp;FP register to zero.

FCMGE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0.0</hint>
			<hint page="855" header="Floating-point Compare Greater than (vector)" doc_id="armv8arm" token="FCMGT">1. Register
This instruction reads each floating-point value in the first source 
SIMD&amp;FP register and if the value is greater than the corresponding 
floating-point value in the second source SIMD&amp;FP register sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP 
register to one, otherwise sets every bit of the corresponding vector 
element in the destination SIMD&amp;FP register to zero.

FCMGT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. Zero
This instruction reads each floating-point value in the source SIMD&amp;FP 
register and if the value is greater than zero sets every bit of the 
corresponding vector element in the destination SIMD&amp;FP register to one,
otherwise sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to zero.

FCMGT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0.0</hint>
			<hint page="859" header="Floating-point Compare Less than or Equal to zero (vector)" doc_id="armv8arm" token="FCMLE">This instruction reads each floating-point value in the source 
SIMD&amp;FP register and if the value is less than or equal to zero 
sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to one, otherwise sets every bit 
of the corresponding vector element in the destination SIMD&amp;FP 
register to zero.

FCMLE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0.0</hint>
			<hint page="861" header="Floating-point Compare Less than zero (vector)" doc_id="armv8arm" token="FCMLT">This instruction reads each floating-point value in the source 
SIMD&amp;FP register and if the value is less than zero sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP 
register to one, otherwise sets every bit of the corresponding 
vector element in the destination SIMD&amp;FP register to zero.

FCMLT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0.0</hint>
			<hint page="863" header="Floating-point quiet Compare (scalar)" doc_id="armv8arm" token="FCMP">This instruction compares the two SIMD&amp;FP source register values, 
or the first SIMD&amp;FP source register value and zero. It writes
the result to the PSTATE.{N, Z, C, V} flags.

Single-precision variant
  FCMP &lt;Sn&gt;, &lt;Sm&gt;
Single-precision, zero variant
  FCMP &lt;Sn&gt;, #0.0
Double-precision variant
  FCMP &lt;Dn&gt;, &lt;Dm&gt;
Double-precision, zero variant
  FCMP &lt;Dn&gt;, #0.0</hint>
			<hint page="865" header="Floating-point signaling Compare (scalar)" doc_id="armv8arm" token="FCMPE">This instruction compares the two SIMD&amp;FP source register values, 
or the first SIMD&amp;FP source register value and zero. It writes 
the result to the PSTATE.{N, Z, C, V} flags.

Single-precision variant
  FCMPE &lt;Sn&gt;, &lt;Sm&gt;
Single-precision, zero variant
  FCMPE &lt;Sn&gt;, #0.0
Double-precision variant
  FCMPE &lt;Dn&gt;, &lt;Dm&gt;
Double-precision, zero variant
  FCMPE &lt;Dn&gt;, #0.0</hint>
			<hint page="867" header="Floating-point Conditional Select (scalar)" doc_id="armv8arm" token="FCSEL">This instruction allows the SIMD&amp;FP destination register to take the 
value from either one or the other of two SIMD&amp;FP source registers. 
If the condition passes, the first SIMD&amp;FP source register value is 
taken, otherwise the second SIMD&amp;FP source register value is taken.

Single-precision variant
  FCSEL &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;, &lt;cond&gt;
Double-precision variant
  FCSEL &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;, &lt;cond&gt;</hint>
			<hint page="869" header="Floating-point Convert precision (scalar)" doc_id="armv8arm" token="FCVT">This instruction converts the floating-point value in the SIMD&amp;FP 
source register to the precision for the destination register data 
type using the rounding mode that is determined by the FPCR and 
writes the result to the SIMD&amp;FP destination register.

Half-precision to single-precision variant
  FCVT &lt;Sd&gt;, &lt;Hn&gt;
Half-precision to double-precision variant
  FCVT &lt;Dd&gt;, &lt;Hn&gt;
Single-precision to half-precision variant
  FCVT &lt;Hd&gt;, &lt;Sn&gt;
Single-precision to double-precision variant
  FCVT &lt;Dd&gt;, &lt;Sn&gt;
Double-precision to half-precision variant
  FCVT &lt;Hd&gt;, &lt;Dn&gt;
Double-precision to single-precision variant
  FCVT &lt;Sd&gt;, &lt;Dn&gt;</hint>
			<hint page="871" header="Floating-point Convert to Signed integer, rounding to nearest with ties to Away" doc_id="armv8arm" token="FCVTAS">1. Vector
This instruction converts each element in a vector from a 
floating-point value to a signed integer value using the 
Round to Nearest with Ties to Away rounding mode and writes 
the result to the SIMD&amp;FP destination register.

FCVTAS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the 
SIMD&amp;FP source register to a 32-bit or 64-bit signed integer 
using the Round to Nearest with Ties to Away rounding mode, 
and writes the result to the general-purpose destination 
register.

Single-precision to 32-bit variant
  FCVTAS &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTAS &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTAS &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTAS &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="875" header="Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away" doc_id="armv8arm" token="FCVTAU">1. Vector
This instruction converts each element in a vector from a 
floating-point value to an unsigned integer value using the 
Round to Nearest with Ties to Away rounding mode and writes 
the result to the SIMD&amp;FP destination register.

FCVTAU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the 
SIMD&amp;FP source register to a 32-bit or 64-bit unsigned integer 
using the Round to Nearest with Ties to Away rounding mode, 
and writes the result to the general-purpose destination register.

Single-precision to 32-bit variant
  FCVTAU &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTAU &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTAU &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTAU &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="879" header="Floating-point Convert to higher precision Long (vector)" doc_id="armv8arm" token="FCVTL">This instruction reads each element in a vector in the SIMD&amp;FP 
source register, converts each value to double the precision of 
the source element using the rounding mode that is determined 
by the FPCR, and writes each result to the equivalent element 
of the vector in the SIMD&amp;FP destination register.
Where the operation lengthens a 64-bit vector to a 128-bit vector, 
the FCVTL2 variant operates on the elements in the top 64 bits 
of the source register.

FCVTL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</hint>
			<hint page="879" header="Floating-point Convert to higher precision Long (vector)" doc_id="armv8arm" token="FCVTL2">This instruction reads each element in a vector in the SIMD&amp;FP 
source register, converts each value to double the precision of 
the source element using the rounding mode that is determined 
by the FPCR, and writes each result to the equivalent element 
of the vector in the SIMD&amp;FP destination register.
Where the operation lengthens a 64-bit vector to a 128-bit vector, 
the FCVTL2 variant operates on the elements in the top 64 bits 
of the source register.

FCVTL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</hint>
			<hint page="881" header="Floating-point Convert to Signed integer, rounding toward Minus infinity" doc_id="armv8arm" token="FCVTMS">1. Vector
This instruction converts a scalar or each element in a vector from a 
floating-point value to a signed integer value using the Round towards 
Minus Infinity rounding mode, and writes the result to the SIMD&amp;FP 
destination register.

FCVTMS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the SIMD&amp;FP 
source register to a 32-bit or 64-bit signed integer using the Round 
towards Minus Infinity rounding mode, and writes the result to the 
general-purpose destination register.

Single-precision to 32-bit variant
  FCVTMS &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTMS &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTMS &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTMS &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="885" header="Floating-point Convert to Unsigned integer, rounding toward Minus infinity" doc_id="armv8arm" token="FCVTMU">1. Vector
This instruction converts a scalar or each element in a vector from a 
floating-point value to an unsigned integer value using the Round 
towards Minus Infinity rounding mode, and writes the result to the 
SIMD&amp;FP destination register.

FCVTMU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the SIMD&amp;FP 
source register to a 32-bit or 64-bit unsigned integer using the 
Round towards Minus Infinity rounding mode, and writes the result 
to the general-purpose destination register.

Single-precision to 32-bit variant
  FCVTMU &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTMU &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTMU &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTMU &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="889" header="Floating-point Convert to lower precision Narrow (vector)" doc_id="armv8arm" token="FCVTN">This instruction reads each vector element in the SIMD&amp;FP source register, 
converts each result to half the precision of the source element, writes 
the final result to a vector, and writes the vector to the lower or upper 
half of the destination SIMD&amp;FP register. The destination vector elements 
are half as long as the source vector elements. The rounding mode is 
determined by the FPCR.
The FCVTN instruction writes the vector to the lower half of the destination
register and clears the upper half, while the FCVTN2 instruction writes 
the vector to the upper half of the destination register without affecting 
the other bits of the register.

FCVTN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="889" header="Floating-point Convert to lower precision Narrow (vector)" doc_id="armv8arm" token="FCVTN2">This instruction reads each vector element in the SIMD&amp;FP source register, 
converts each result to half the precision of the source element, writes 
the final result to a vector, and writes the vector to the lower or upper 
half of the destination SIMD&amp;FP register. The destination vector elements 
are half as long as the source vector elements. The rounding mode is 
determined by the FPCR.
The FCVTN instruction writes the vector to the lower half of the destination
register and clears the upper half, while the FCVTN2 instruction writes 
the vector to the upper half of the destination register without affecting 
the other bits of the register.

FCVTN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="891" header="Floating-point Convert to Signed integer, rounding to nearest with ties to even" doc_id="armv8arm" token="FCVTNS">1. Vector
This instruction converts a scalar or each element in a vector from a 
floating-point value to a signed integer value using the Round to 
Nearest rounding mode, and writes the result to the SIMD&amp;FP destination 
register.

FCVTNS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the SIMD&amp;FP source 
register to a 32-bit or 64-bit signed integer using the Round to Nearest 
rounding mode, and writes the result to the general-purpose destination 
register.

Single-precision to 32-bit variant
  FCVTNS &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTNS &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTNS &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTNS &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="895" header="Floating-point Convert to Unsigned integer, rounding to nearest with ties to even" doc_id="armv8arm" token="FCVTNU">1. Vector
This instruction converts a scalar or each element in a vector from a 
floating-point value to an unsigned integer value using the Round to 
Nearest rounding mode, and writes the result to the SIMD&amp;FP destination 
register.

FCVTNU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the SIMD&amp;FP source 
register to a 32-bit or 64-bit unsigned integer using the Round to Nearest 
rounding mode, and writes the result to the general-purpose destination 
register.

Single-precision to 32-bit variant
  FCVTNU &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTNU &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTNU &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTNU &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="899" header="Floating-point Convert to Signed integer, rounding toward Plus infinity" doc_id="armv8arm" token="FCVTPS">1. Vector
This instruction converts a scalar or each element in a vector from a 
floating-point value to a signed integer value using the Round towards 
Plus Infinity rounding mode, and writes the result to the SIMD&amp;FP 
destination register.

FCVTPS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the SIMD&amp;FP source 
register to a 32-bit or 64-bit signed integer using the Round towards 
Plus Infinity rounding mode, and writes the result to the general-purpose 
destination register.

Single-precision to 32-bit variant
  FCVTPS &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTPS &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTPS &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTPS &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="903" header="Floating-point Convert to Unsigned integer, rounding toward Plus infinity" doc_id="armv8arm" token="FCVTPU">1. Vector
This instruction converts a scalar or each element in a vector from a 
floating-point value to an unsigned integer value using the Round 
towards Plus Infinity rounding mode, and writes the result to the 
SIMD&amp;FP destination register.

FCVTPU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

2. Scalar
This instruction converts the floating-point value in the SIMD&amp;FP 
source register to a 32-bit or 64-bit unsigned integer using the Round 
towards Plus Infinity rounding mode, and writes the result to the 
general-purpose destination register.

Single-precision to 32-bit variant
  FCVTPU &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant
  FCVTPU &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant
  FCVTPU &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant
  FCVTPU &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="907" header="Floating-point Convert to lower precision Narrow, rounding to odd (vector)" doc_id="armv8arm" token="FCVTXN">This instruction reads each vector element in the source SIMD&amp;FP register, 
narrows each value to half the precision of the source element using the 
Round to Odd rounding mode, writes the result to a vector, and writes the 
vector to the destination SIMD&amp;FP register.
The FCVTXN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the FCVTXN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Scalar variant
  FCVTXN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;</hint>
			<hint page="907" header="Floating-point Convert to lower precision Narrow, rounding to odd (vector)" doc_id="armv8arm" token="FCVTXN2">This instruction reads each vector element in the source SIMD&amp;FP register, 
narrows each value to half the precision of the source element using the 
Round to Odd rounding mode, writes the result to a vector, and writes the 
vector to the destination SIMD&amp;FP register.
The FCVTXN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the FCVTXN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Vector variant
  FCVTXN2 &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;</hint>
			<hint page="909" header="Floating-point Convert, rounding toward Zero" doc_id="armv8arm" token="FCVTZS">1. Vector. Fixed-point
This instruction converts a scalar or each element in a vector from 
floating-point to fixed-point signed integer using the Round towards 
Zero rounding mode, and writes the result to the SIMD&amp;FP destination 
register.

FCVTZS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;fbits&gt;

2. Vector. Integer
This instruction converts a scalar or each element in a vector from 
a floating-point value to a signed integer value using the Round 
towards Zero rounding mode, and writes the result to the SIMD&amp;FP
destination register.

FCVTZS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

3. Scalar. Fixed-point
This instruction converts the floating-point value in the SIMD&amp;FP 
source register to a 32-bit or 64-bit fixed-point signed integer 
using the Round towards Zero rounding mode, and writes the result 
to the general-purpose destination register.

Single-precision to 32-bit variant: FCVTZS &lt;Wd&gt;, &lt;Sn&gt;, #&lt;fbits&gt;
Single-precision to 64-bit variant: FCVTZS &lt;Xd&gt;, &lt;Sn&gt;, #&lt;fbits&gt;
Double-precision to 32-bit variant: FCVTZS &lt;Wd&gt;, &lt;Dn&gt;, #&lt;fbits&gt;
Double-precision to 64-bit variant: FCVTZS &lt;Xd&gt;, &lt;Dn&gt;, #&lt;fbits&gt;

4. Scalar. Integer
This instruction converts the floating-point value in the SIMD&amp;FP 
source register to a 32-bit or 64-bit signed integer using the Round 
towards Zero rounding mode, and writes the result to the 
general-purpose destination register.

Single-precision to 32-bit variant: FCVTZS &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant: FCVTZS &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant: FCVTZS &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant: FCVTZS &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="918" header="Floating-point Convert, rounding toward Zero" doc_id="armv8arm" token="FCVTZU">1. Vector. Fixed-point
This instruction converts a scalar or each element in a vector from 
floating-point to fixed-point unsigned integer using the Round towards 
Zero rounding mode, and writes the result to the general-purpose 
destination register.

FCVTZU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;fbits&gt;

2. Vector. Integer
This instruction converts a scalar or each element in a vector from a 
floating-point value to an unsigned integer value using the Round towards 
Zero rounding mode, and writes the result to the SIMD&amp;FP destination 
register.

FCVTZU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

3. Scalar. Fixed-point
This instruction converts the floating-point value in the SIMD&amp;FP source 
register to a 32-bit or 64-bit fixed-point unsigned integer using the 
Round towards Zero rounding mode, and writes the result to the 
general-purpose destination register.

Single-precision to 32-bit variant: FCVTZU &lt;Wd&gt;, &lt;Sn&gt;, #&lt;fbits&gt;
Single-precision to 64-bit variant: FCVTZU &lt;Xd&gt;, &lt;Sn&gt;, #&lt;fbits&gt;
Double-precision to 32-bit variant: FCVTZU &lt;Wd&gt;, &lt;Dn&gt;, #&lt;fbits&gt;
Double-precision to 64-bit variant: FCVTZU &lt;Xd&gt;, &lt;Dn&gt;, #&lt;fbits&gt;

4. Scalar. Integer
This instruction converts the floating-point value in the SIMD&amp;FP source 
register to a 32-bit or 64-bit unsigned integer using the Round towards 
Zero rounding mode, and writes the result to the general-purpose destination 
register.

Single-precision to 32-bit variant: FCVTZU &lt;Wd&gt;, &lt;Sn&gt;
Single-precision to 64-bit variant: FCVTZU &lt;Xd&gt;, &lt;Sn&gt;
Double-precision to 32-bit variant: FCVTZU &lt;Wd&gt;, &lt;Dn&gt;
Double-precision to 64-bit variant: FCVTZU &lt;Xd&gt;, &lt;Dn&gt;</hint>
			<hint page="927" header="Floating-point Divide" doc_id="armv8arm" token="FDIV">1. Vector
This instruction divides the floating-point values in the elements in 
the first source SIMD&amp;FP register, by the floating-point values in the 
corresponding elements in the second source SIMD&amp;FP register, places 
the results in a vector, and writes the vector to the destination 
SIMD&amp;FP register.

FDIV &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction divides the floating-point value of the first source 
SIMD&amp;FP register by the floating-point value of the second source 
SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP 
register.

Single-precision variant
  FDIV &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FDIV &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="931" header="Floating-point fused Multiply-Add (scalar)" doc_id="armv8arm" token="FMADD">This instruction multiplies the values of the first two SIMD&amp;FP 
source registers, adds the product to the value of the third 
SIMD&amp;FP source register, and writes the result to the SIMD&amp;FP 
destination register.

Single-precision variant
  FMADD &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;, &lt;Sa&gt;
Double-precision variant
  FMADD &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;, &lt;Da&gt;</hint>
			<hint page="933" header="Floating-point Maximum" doc_id="armv8arm" token="FMAX">1. Vector
This instruction compares corresponding vector elements in the two 
source SIMD&amp;FP registers, places the larger of each of the two 
floating-point values into a vector, and writes the vector to 
the destination SIMD&amp;FP register.

FMAX &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares the two source SIMD&amp;FP registers, and 
writes the larger of the two floating-point values to the 
destination SIMD&amp;FP register.

Single-precision variant
  FMAX &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FMAX &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="937" header="Floating-point Maximum Number" doc_id="armv8arm" token="FMAXNM">1. Vector
This instruction compares corresponding vector elements in the two 
source SIMD&amp;FP registers, writes the larger of the two 
floating-point values into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

FMAXNM &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares the first and second source SIMD&amp;FP 
register values, and writes the larger of the two floating-point 
values to the destination SIMD&amp;FP register.

Single-precision variant
  FMAXNM &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FMAXNM &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="941" header="Floating-point Maximum Number of Pair of elements" doc_id="armv8arm" token="FMAXNMP">1. Vector
This instruction creates a vector by concatenating the vector elements 
of the first source SIMD&amp;FP register after the vector elements of the 
second source SIMD&amp;FP register, reads each pair of adjacent vector 
elements in the two source SIMD&amp;FP registers, writes the largest of 
each pair of values into a vector, and writes the vector to the 
destination SIMD&amp;FP register. All the values in this instruction 
are floating-point values.

FMAXNMP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares two vector elements in the source SIMD&amp;FP 
register and writes the largest of the floating-point values as a 
scalar to the destination SIMD&amp;FP register.

FMAXNMP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="944" header="Floating-point Maximum Number across Vector" doc_id="armv8arm" token="FMAXNMV">This instruction compares all the vector elements in the source 
SIMD&amp;FP register, and writes the largest of the values as a scalar 
to the destination SIMD&amp;FP register. All the values in this 
instruction are floating-point values.

FMAXNMV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="945" header="Floating-point Maximum of Pair of elements" doc_id="armv8arm" token="FMAXP">1. Vector
This instruction creates a vector by concatenating the vector 
elements of the first source SIMD&amp;FP register after the vector 
elements of the second source SIMD&amp;FP register, reads each pair 
of adjacent vector elements from the concatenated vector, writes 
the larger of each pair of values into a vector, and writes the 
vector to the destination SIMD&amp;FP register. All the values in 
this instruction are floating-point values.

FMAXP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares two vector elements in the source 
SIMD&amp;FP register and writes the largest of the floating-point 
values as a scalar to the destination SIMD&amp;FP register.

FMAXP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="948" header="Floating-point Maximum across Vector" doc_id="armv8arm" token="FMAXV">This instruction compares all the vector elements in the source 
SIMD&amp;FP register, and writes the largest of the values as a scalar 
to the destination SIMD&amp;FP register. All the values in this 
instruction are floating-point values.

FMAXV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="949" header="Floating-point minimum" doc_id="armv8arm" token="FMIN">1. Vector
This instruction compares corresponding elements in the vectors 
in the two source SIMD&amp;FP registers, places the smaller of each 
of the two floating-point values into a vector, and writes the 
vector to the destination SIMD&amp;FP register.

FMIN &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares the first and second source SIMD&amp;FP 
register values, and writes the smaller of the two floating-point 
values to the destination SIMD&amp;FP register.

Single-precision variant
  FMIN &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FMIN &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="953" header="Floating-point Minimum Number" doc_id="armv8arm" token="FMINNM">1. Vector
This instruction compares corresponding vector elements in the two source 
SIMD&amp;FP registers, writes the smaller of the two floating-point values into 
a vector, and writes the vector to the destination SIMD&amp;FP register.

FMINNM &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares the first and second source SIMD&amp;FP register values, 
and writes the smaller of the two floating-point values to the destination 
SIMD&amp;FP register.

Single-precision variant
  FMINNM &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FMINNM &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="957" header="Floating-point Minimum Number of Pair of elements" doc_id="armv8arm" token="FMINNMP">1. Vector
This instruction creates a vector by concatenating the vector 
elements of the first source SIMD&amp;FP register after the vector 
elements of the second source SIMD&amp;FP register, reads each pair 
of adjacent vector elements in the two source SIMD&amp;FP registers, 
writes the smallest of each pair of floating-point values into 
a vector, and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are floating-point values.

FMINNMP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares two vector elements in the source 
SIMD&amp;FP register and writes the smallest of the floating-point 
values as a scalar to the destination SIMD&amp;FP register.

FMINNMP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="960" header="Floating-point Minimum Number across Vector" doc_id="armv8arm" token="FMINNMV">This instruction compares all the vector elements in the source 
SIMD&amp;FP register, and writes the smallest of the values as a 
scalar to the destination SIMD&amp;FP register. All the values in 
this instruction are floating-point values.

FMINNMV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="961" header="Floating-point Minimum of Pair of elements" doc_id="armv8arm" token="FMINP">1. Vector
This instruction creates a vector by concatenating the vector 
elements of the first source SIMD&amp;FP register after the vector 
elements of the second source SIMD&amp;FP register, reads each pair 
of adjacent vector elements from the concatenated vector, 
writes the smaller of each pair of values into a vector, 
and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are floating-point values.

FMINP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Scalar
This instruction compares two vector elements in the source 
SIMD&amp;FP register and writes the smallest of the floating-point 
values as a scalar to the destination SIMD&amp;FP register.

FMINP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="964" header="Floating-point Minimum across Vector." doc_id="armv8arm" token="FMINV">This instruction compares all the vector elements in the source 
SIMD&amp;FP register, and writes the smallest of the values as a 
scalar to the destination SIMD&amp;FP register. All the values in 
this instruction are floating-point values.

FMINV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="965" header="Floating-point fused Multiply-Add to accumulator" doc_id="armv8arm" token="FMLA">1. By element
This instruction multiplies the vector elements in the first source 
SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP 
register, and accumulates the results in the vector elements of the 
destination SIMD&amp;FP register. All the values in this instruction are 
floating-point values.

FMLA &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding floating-point values in 
the vectors in the two source SIMD&amp;FP registers, adds the product to 
the corresponding vector element of the destination SIMD&amp;FP register, 
and writes the result to the destination SIMD&amp;FP register.

FMLA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="969" header="Floating-point fused Multiply-Subtract from accumulator" doc_id="armv8arm" token="FMLS">1. By element
This instruction multiplies the vector elements in the first source 
SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP 
register, and subtracts the results from the vector elements of the 
destination SIMD&amp;FP register. All the values in this instruction are 
floating-point values.

FMLS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding floating-point values in 
the vectors in the two source SIMD&amp;FP registers, negates the product, 
adds the result to the corresponding vector element of the destination 
SIMD&amp;FP register, and writes the result to the destination SIMD&amp;FP 
register.

FMLS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="973" header="Floating-point move" doc_id="armv8arm" token="FMOV">1. Vector. Immediate
This instruction copies an immediate floating-point constant 
into every element of the SIMD&amp;FP destination register.

Single-precision variant: FMOV &lt;Vd&gt;.&lt;T&gt;, #&lt;imm&gt;
Double-precision variant: FMOV &lt;Vd&gt;.2D, #&lt;imm&gt;

2. Register
This instruction copies the floating-point value in the 
SIMD&amp;FP source register to the SIMD&amp;FP destination register.

Single-precision variant: FMOV &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant: FMOV &lt;Dd&gt;, &lt;Dn&gt;

3. General
This instruction transfers the contents of a SIMD&amp;FP register 
to a general-purpose register, or the contents of a 
general-purpose register to a SIMD&amp;FP register.

32-bit to single-precision variant:    FMOV &lt;Sd&gt;, &lt;Wn&gt;
Single-precision to 32-bit variant:    FMOV &lt;Wd&gt;, &lt;Sn&gt;
64-bit to double-precision variant:    FMOV &lt;Dd&gt;, &lt;Xn&gt;
64-bit to top half of 128-bit variant: FMOV &lt;Vd&gt;.D[1], &lt;Xn&gt;
Double-precision to 64-bit variant:    FMOV &lt;Xd&gt;, &lt;Dn&gt;
Top half of 128-bit to 64-bit variant: FMOV &lt;Xd&gt;, &lt;Vn&gt;.D[1]

4. Scalar. Immediate
This instruction copies a floating-point immediate constant 
into the SIMD&amp;FP destination register.

Single-precision variant: FMOV &lt;Sd&gt;, #&lt;imm&gt;
Double-precision variant: FMOV &lt;Dd&gt;, #&lt;imm&gt;</hint>
			<hint page="979" header="Floating-point Fused Multiply-Subtract" doc_id="armv8arm" token="FMSUB">This instruction multiplies the values of the first two 
SIMD&amp;FP source registers, negates the product, adds that 
to the value of the third SIMD&amp;FP source register, and 
writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FMSUB &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;, &lt;Sa&gt;
Double-precision variant
  FMSUB &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;, &lt;Da&gt;</hint>
			<hint page="981" header="Floating-point Multiply" doc_id="armv8arm" token="FMUL">1. By element
This instruction multiplies the vector elements in the first source 
SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP 
register, places the results in a vector, and writes the vector to 
the destination SIMD&amp;FP register. All the values in this instruction 
are floating-point values.

FMUL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding floating-point values in 
the vectors in the two source SIMD&amp;FP registers, places the result 
in a vector, and writes the vector to the destination SIMD&amp;FP register.

FMUL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

3. Scalar
This instruction multiplies the floating-point values of the two source 
SIMD&amp;FP registers, and writes the result to the destination SIMD&amp;FP 
register.

Single-precision variant
  FMUL &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FMUL &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="987" header="Floating-point Multiply extended" doc_id="armv8arm" token="FMULX">1. Default
This instruction multiplies corresponding floating-point values in 
the vectors of the two source SIMD&amp;FP registers, places the resulting
floating-point values in a vector, and writes the vector to the 
destination SIMD&amp;FP register.

FMULX &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. By element
This instruction multiplies the floating-point values in the vector 
elements in the first source SIMD&amp;FP register by the specified 
floating-point value in the second source SIMD&amp;FP register, places 
the results in a vector, and writes the vector to the destination 
SIMD&amp;FP register.

FMULX &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</hint>
			<hint page="992" header="Floating-point Negate" doc_id="armv8arm" token="FNEG">1. Vector
This instruction negates the value of each vector element in the 
source SIMD&amp;FP register, writes the result to a vector, and writes 
the vector to the destination SIMD&amp;FP register.

FNEG &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
Floating-point Negate (scalar). This instruction negates the value 
in the SIMD&amp;FP source register and writes the result to the SIMD&amp;FP 
destination register.

Single-precision variant
  FNEG &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FNEG &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="994" header="Floating-point Negated fused Multiply-Add (scalar)" doc_id="armv8arm" token="FNMADD">This instruction multiplies the values of the first two SIMD&amp;FP 
source registers, negates the product, subtracts the value of 
the third SIMD&amp;FP source register, and writes the result to 
the destination SIMD&amp;FP register.

Single-precision variant
  FNMADD &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;, &lt;Sa&gt;
Double-precision variant
  FNMADD &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;, &lt;Da&gt;</hint>
			<hint page="996" header="Floating-point Negated fused Multiply-Subtract (scalar)" doc_id="armv8arm" token="FNMSUB">This instruction multiplies the values of the first two 
SIMD&amp;FP source registers, subtracts the value of the 
third SIMD&amp;FP source register, and writes the result 
to the destination SIMD&amp;FP register.

Single-precision variant
  FNMSUB &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;, &lt;Sa&gt;
Double-precision variant
  FNMSUB &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;, &lt;Da&gt;</hint>
			<hint page="998" header="Floating-point Multiply-Negate (scalar)" doc_id="armv8arm" token="FNMUL">This instruction multiplies the floating-point values of 
the two source SIMD&amp;FP registers, and writes the negation 
of the result to the destination SIMD&amp;FP register.

Single-precision variant
  FNMUL &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FNMUL &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
			<hint page="1000" header="Floating-point Reciprocal Estimate" doc_id="armv8arm" token="FRECPE">This instruction finds an approximate reciprocal estimate 
for each vector element in the source SIMD&amp;FP register, 
places the result in a vector, and writes the vector to 
the destination SIMD&amp;FP register.

Scalar variant
  FRECPE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

Vector variant
  FRECPE &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1002" header="Floating-point Reciprocal Step" doc_id="armv8arm" token="FRECPS">This instruction multiplies the corresponding floating-point 
values in the vectors of the two source SIMD&amp;FP registers, 
subtracts each of the products from 2.0, places the resulting 
floating-point values in a vector, and writes the vector to 
the destination SIMD&amp;FP register.

Scalar variant
  FRECPS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;
Vector variant
  FRECPS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1004" header="Floating-point Reciprocal exponent (scalar)" doc_id="armv8arm" token="FRECPX">This instruction finds an approximate reciprocal exponent for 
each vector element in the source SIMD&amp;FP register, places 
the result in a vector, and writes the vector to the 
destination SIMD&amp;FP register.

FRECPX &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;</hint>
			<hint page="1005" header="Floating-point Round to Integral, to nearest with ties to Away" doc_id="armv8arm" token="FRINTA">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the Round to Nearest with Ties to Away rounding 
mode, and writes the result to the SIMD&amp;FP destination register.

FRINTA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP 
source register to an integral floating-point value of the same 
size using the Round to Nearest with Ties to Away rounding mode, 
and writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTA &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTA &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1009" header="Floating-point Round to Integral, using current rounding mode" doc_id="armv8arm" token="FRINTI">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the rounding mode that is determined by the FPCR, 
and writes the result to the SIMD&amp;FP destination register.

FRINTI &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP 
source register to an integral floating-point value of the same 
size using the rounding mode that is determined by the FPCR, and 
writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTI &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTI &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1013" header="Floating-point Round to Integral, toward Minus infinity" doc_id="armv8arm" token="FRINTM">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the Round towards Minus Infinity rounding mode, 
and writes the result to the SIMD&amp;FP destination register.

FRINTM &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP 
source register to an integral floating-point value of the same 
size using the Round towards Minus Infinity rounding mode, and 
writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTM &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTM &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1017" header="Floating-point Round to Integral, to nearest with ties to even" doc_id="armv8arm" token="FRINTN">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the Round to Nearest rounding mode, and writes 
the result to the SIMD&amp;FP destination register.

FRINTN &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP 
source register to an integral floating-point value of the same 
size using the Round to Nearest rounding mode, and writes the 
result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTN &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTN &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1021" header="Floating-point Round to Integral, toward Plus infinity" doc_id="armv8arm" token="FRINTP">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the Round towards Plus Infinity rounding mode, 
and writes the result to the SIMD&amp;FP destination register.

FRINTP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP 
source register to an integral floating-point value of the same 
size using the Round towards Plus Infinity rounding mode, and 
writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTP &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTP &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1025" header="Floating-point Round to Integral exact, using current rounding mode" doc_id="armv8arm" token="FRINTX">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the rounding mode that is determined by the FPCR, 
and writes the result to the SIMD&amp;FP destination register.

FRINTX &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP 
source register to an integral floating-point value of the same 
size using the rounding mode that is determined by the FPCR, and 
writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTX &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTX &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1029" header="Floating-point Round to Integral exact, using current rounding mode" doc_id="armv8arm" token="FRINTZ">1. Vector
This instruction rounds a vector of floating-point values in the 
SIMD&amp;FP source register to integral floating-point values of the 
same size using the Round towards Zero rounding mode, and writes 
the result to the SIMD&amp;FP destination register.

FRINTZ &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction rounds a floating-point value in the SIMD&amp;FP source 
register to an integral floating-point value of the same size using 
the rounding mode that is determined by the FPCR, and writes the 
result to the SIMD&amp;FP destination register.

Single-precision variant
  FRINTX &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FRINTX &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1033" header="Floating-point Reciprocal Square Root Estimate" doc_id="armv8arm" token="FRSQRTE">This instruction calculates an approximate square root for each 
vector element in the source SIMD&amp;FP register, places the result 
in a vector, and writes the vector to the destination SIMD&amp;FP 
register.

FRSQRTE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;</hint>
			<hint page="1035" header="Floating-point Reciprocal Square Root Step" doc_id="armv8arm" token="FRSQRTS">This instruction multiplies corresponding floating-point values 
in the vectors of the two source SIMD&amp;FP registers, subtracts 
each of the products from 3.0, divides these results by 2.0, 
places the results into a vector, and writes the vector to 
the destination SIMD&amp;FP register.

Scalar variant
  FRSQRTS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;
Vector variant
  FRSQRTS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1038" header="Floating-point Square Root" doc_id="armv8arm" token="FSQRT">1. Vector
This instruction calculates the square root for each vector element in 
the source SIMD&amp;FP register, places the result in a vector, and writes 
the vector to the destination SIMD&amp;FP register.

FSQRT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Scalar
This instruction calculates the square root of the value in the SIMD&amp;FP 
source register and writes the result to the SIMD&amp;FP destination register.

Single-precision variant
  FSQRT &lt;Sd&gt;, &lt;Sn&gt;
Double-precision variant
  FSQRT &lt;Dd&gt;, &lt;Dn&gt;</hint>
			<hint page="1041" header="Floating-point Subtract " doc_id="armv8arm" token="FSUB">1. Vector
This instruction subtracts the elements in the vector in the second 
source SIMD&amp;FP register, from the corresponding elements in the 
vector in the first source SIMD&amp;FP register, places each result into 
elements of a vector, and writes the vector to the destination SIMD&amp;FP 
register.

2. Scalar
This instruction subtracts the floating-point value of the second source 
SIMD&amp;FP register from the floating-point value of the first source SIMD&amp;FP 
register, and writes the result to the destination SIMD&amp;FP register.

Single-precision variant
  FSUB &lt;Sd&gt;, &lt;Sn&gt;, &lt;Sm&gt;
Double-precision variant
  FSUB &lt;Dd&gt;, &lt;Dn&gt;, &lt;Dm&gt;</hint>
		</group>
		<group type="ins" name="A64 SIMD instructions">
			<hint page="771" header="Absolute value (vector)" doc_id="armv8arm" token="ABS">This instruction calculates the absolute value of each vector 
element in the source SIMD&amp;FP register, puts the result into a 
vector, and writes the vector to the destination SIMD&amp;FP register.

ABS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;</hint>
			<hint page="773" header="Add (vector)" doc_id="armv8arm" token="ADD">This instruction adds corresponding elements in the two source 
SIMD&amp;FP registers, places the results into a vector, and writes 
the vector to the destination SIMD&amp;FP register.

ADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="775" header="Add returning High Narrow" doc_id="armv8arm" token="ADDHN">This instruction adds each vector element in the first source SIMD&amp;FP 
register to the corresponding vector element in the second source 
SIMD&amp;FP register, places the most significant half of the result 
into a vector, and writes the vector to the lower or upper half of 
the destination SIMD&amp;FP register.
The results are truncated. For rounded results, see RADDHN, RADDHN2.
The ADDHN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the ADDHN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

ADDHN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="775" header="Add returning High Narrow" doc_id="armv8arm" token="ADDHN2">This instruction adds each vector element in the first source SIMD&amp;FP 
register to the corresponding vector element in the second source 
SIMD&amp;FP register, places the most significant half of the result 
into a vector, and writes the vector to the lower or upper half of 
the destination SIMD&amp;FP register.
The results are truncated. For rounded results, see RADDHN, RADDHN2.
The ADDHN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the ADDHN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

ADDHN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="777" header="Add Pair of elements" doc_id="armv8arm" token="ADDP">1. Scalar
This instruction adds two vector elements in the source 
SIMD&amp;FP register and writes the scalar result into the 
destination SIMD&amp;FP register.

ADDP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;

2. Vector
This instruction creates a vector by concatenating the 
vector elements of the first source SIMD&amp;FP register 
after the vector elements of the second source SIMD&amp;FP 
register, reads each pair of adjacent vector elements 
from the concatenated vector, adds each pair of values 
together, places the result into a vector, and writes 
the vector to the destination SIMD&amp;FP register.

ADDP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="780" header="Add across Vector" doc_id="armv8arm" token="ADDV">This instruction adds every vector element in the source SIMD&amp;FP 
register together, and writes the scalar result to the destination 
SIMD&amp;FP register.

ADDV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="786" header="Bitwise AND (vector)" doc_id="armv8arm" token="AND">This instruction performs a bitwise AND between the two source 
SIMD&amp;FP registers, and writes the result to the destination 
SIMD&amp;FP register.

AND &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="787" header="Bitwise bit Clear" doc_id="armv8arm" token="BIC">1. Vector. Immediate
This instruction reads each vector element from the destination 
SIMD&amp;FP register, performs a bitwise AND between each result and 
the complement of an immediate constant, places the result into 
a vector, and writes the vector to the destination SIMD&amp;FP register.

16-bit variant
  BIC &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}
32-bit variant
  BIC &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}

2. Vector Register
This instruction performs a bitwise AND between the first source 
SIMD&amp;FP register and the complement of the second source SIMD&amp;FP 
register, and writes the result to the destination SIMD&amp;FP register.

BIC &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="790" header="Bitwise Insert if False" doc_id="armv8arm" token="BIF">This instruction inserts each bit from the first source 
SIMD&amp;FP register into the destination SIMD&amp;FP register 
if the corresponding bit of the second source SIMD&amp;FP 
register is 0, otherwise leaves the bit in the 
destination register unchanged.

BIF &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="791" header="Bitwise Insert if True" doc_id="armv8arm" token="BIT">This instruction inserts each bit from the first source 
SIMD&amp;FP register into the SIMD&amp;FP destination register 
if the corresponding bit of the second source SIMD&amp;FP 
register is 1, otherwise leaves the bit in the 
destination register unchanged.

BIT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="792" header="Bitwise Select" doc_id="armv8arm" token="BSL">This instruction sets each bit in the destination 
SIMD&amp;FP register to the corresponding bit from the
first source SIMD&amp;FP register when the original 
destination bit was 1, otherwise from the second 
source SIMD&amp;FP register.

BSL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="793" header="Count Leading Sign bits (vector)" doc_id="armv8arm" token="CLS">This instruction counts the number of consecutive bits following 
the most significant bit that are the same as the most significant 
bit in each vector element in the source SIMD&amp;FP register, places 
the result into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The count does not include the most significant 
bit itself.

CLS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="795" header="Count Leading Zero bits (vector)" doc_id="armv8arm" token="CLZ">This instruction counts the number of consecutive zeros, starting 
from the most significant bit, in each vector element in the source 
SIMD&amp;FP register, places the result into a vector, and writes the 
vector to the destination SIMD&amp;FP register.

CLZ &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="797" header="Compare bitwise Equal" doc_id="armv8arm" token="CMEQ">1. Register
This instruction compares each vector element from the first source 
SIMD&amp;FP register with the corresponding vector element from the 
second source SIMD&amp;FP register, and if the comparison is equal sets 
every bit of the corresponding vector element in the destination 
SIMD&amp;FP register to one, otherwise sets every bit of the corresponding 
vector element in the destination SIMD&amp;FP register to zero.

CMEQ &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. Zero
This instruction reads each vector element in the source SIMD&amp;FP 
register and if the value is equal to zero sets every bit of the 
corresponding vector element in the destination SIMD&amp;FP register 
to one, otherwise sets every bit of the corresponding vector element 
in the destination SIMD&amp;FP register to zero.

CMEQ &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0</hint>
			<hint page="801" header="Compare signed Greater than or Equal" doc_id="armv8arm" token="CMGE">1. Register
This instruction compares each vector element in the first source 
SIMD&amp;FP register with the corresponding vector element in the 
second source SIMD&amp;FP register and if the first signed integer 
value is greater than or equal to the second signed integer value 
sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to one, otherwise sets every 
bit of the corresponding vector element in the destination 
SIMD&amp;FP register to zero.

CMGE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. Zero
This instruction reads each vector element in the source SIMD&amp;FP 
register and if the signed integer value is greater than or equal 
to zero sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to one, otherwise sets every bit of 
the corresponding vector element in the destination SIMD&amp;FP 
register to zero.

CMGE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0</hint>
			<hint page="805" header="Compare signed Greater than" doc_id="armv8arm" token="CMGT">1. Register
This instruction compares each vector element in the first source 
SIMD&amp;FP register with the corresponding vector element in the 
second source SIMD&amp;FP register and if the first signed integer 
value is greater than the second signed integer value sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP 
register to one, otherwise sets every bit of the corresponding 
vector element in the destination SIMD&amp;FP register to zero.

CMGT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

2. Zero
This instruction reads each vector element in the source SIMD&amp;FP 
register and if the signed integer value is greater than zero 
sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to one, otherwise sets every bit 
of the corresponding vector element in the destination SIMD&amp;FP 
register to zero.

CMGT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0</hint>
			<hint page="809" header="Compare unsigned Higher (vector)" doc_id="armv8arm" token="CMHI">This instruction compares each vector element in the first source 
SIMD&amp;FP register with the corresponding vector element in the 
second source SIMD&amp;FP register and if the first unsigned integer 
value is greater than the second unsigned integer value sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP 
register to one, otherwise sets every bit of the corresponding 
vector element in the destination SIMD&amp;FP register to zero.

CMHI &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="811" header="Compare unsigned Higher or Same (vector)" doc_id="armv8arm" token="CMHS">This instruction compares each vector element in the first source SIMD&amp;FP 
register with the corresponding vector element in the second source 
SIMD&amp;FP register and if the first unsigned integer value is greater than 
or equal to the second unsigned integer value sets every bit of the 
corresponding vector element in the destination SIMD&amp;FP register to one, 
otherwise sets every bit of the corresponding vector element in the 
destination SIMD&amp;FP register to zero.

CMHS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="813" header="Compare signed Less than or Equal to zero (vector)" doc_id="armv8arm" token="CMLE">This instruction reads each vector element in the source 
SIMD&amp;FP register and if the signed integer value is less 
than or equal to zero sets every bit of the corresponding 
vector element in the destination SIMD&amp;FP register to one, 
otherwise sets every bit of the corresponding vector 
element in the destination SIMD&amp;FP register to zero.

CMLE &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0</hint>
			<hint page="815" header="Compare signed Less than zero (vector)" doc_id="armv8arm" token="CMLT">This instruction reads each vector element in the source 
SIMD&amp;FP register and if the signed integer value is less 
than zero sets every bit of the corresponding vector 
element in the destination SIMD&amp;FP register to one, 
otherwise sets every bit of the corresponding vector 
element in the destination SIMD&amp;FP register to zero.

CMLT &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #0</hint>
			<hint page="817" header="Compare bitwise Test bits nonzero (vector)" doc_id="armv8arm" token="CMTST">This instruction reads each vector element in the first source 
SIMD&amp;FP register, performs an AND with the corresponding vector 
element in the second source SIMD&amp;FP register, and if the result 
is not zero, sets every bit of the corresponding vector element 
in the destination SIMD&amp;FP register to one, otherwise sets every 
bit of the corresponding vector element in the destination SIMD&amp;FP
register to zero.

CMTST &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="819" header="Population Count per byte" doc_id="armv8arm" token="CNT">This instruction counts the number of bits that have a value 
of one in each vector element in the source SIMD&amp;FP register, 
places the result into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

CNT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="820" header="Duplicate to vector or scalar" doc_id="armv8arm" token="DUP">1. Element
This instruction duplicates the vector element at the specified 
element index in the source SIMD&amp;FP register into a scalar or 
each element in a vector, and writes the result to the 
destination SIMD&amp;FP register.

DUP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;[&lt;index&gt;]

2. General
This instruction duplicates the contents of the source 
general-purpose register into a scalar or each element in a 
vector, and writes the result to the SIMD&amp;FP destination 
register.

DUP &lt;Vd&gt;.&lt;T&gt;, &lt;R&gt;&lt;n&gt;</hint>
			<hint page="825" header="Bitwise Exclusive OR (vector)" doc_id="armv8arm" token="EOR">This instruction performs a bitwise Exclusive OR operation 
between the two source SIMD&amp;FP registers, and places the 
result in the destination SIMD&amp;FP register.

EOR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="826" header="Extract vector from pair of vectors" doc_id="armv8arm" token="EXT">This instruction extracts the lowest vector elements from the 
second source SIMD&amp;FP register and the highest vector elements 
from the first source SIMD&amp;FP register, concatenates the results 
into a vector, and writes the vector to the destination SIMD&amp;FP 
register vector. The index value specifies the lowest vector 
element to extract from the first source register, and consecutive 
elements are extracted from the first, then second, source 
registers until the destination vector is filled.

EXT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;, #&lt;index&gt;</hint>
			<hint page="1043" header="Insert vector element" doc_id="armv8arm" token="INS">1. Element
This instruction copies the vector element of the source 
SIMD&amp;FP register to the specified vector element of the 
destination SIMD&amp;FP register.

INS &lt;Vd&gt;.&lt;Ts&gt;[&lt;index1&gt;], &lt;Vn&gt;.&lt;Ts&gt;[&lt;index2&gt;]

2. General
This instruction copies the contents of the source 
general-purpose register to the specified vector element 
in the destination SIMD&amp;FP register.

INS &lt;Vd&gt;.&lt;Ts&gt;[&lt;index&gt;], &lt;R&gt;&lt;n&gt;</hint>
			<hint page="1047" header="Load single-element structures" doc_id="armv8arm" token="LD1">1. Multiple structures
This instruction loads multiple single-element structures from memory and 
writes the result to one, two, three, or four SIMD&amp;FP registers.

No offset:
  One register variant:    LD1 { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
  Two registers variant:   LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
  Three registers variant: LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
  Four registers variant:  LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  One register, immediate offset variant:    LD1 { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  One register, register offset variant:     LD1 { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;
  Two registers, immediate offset variant:   LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Two registers, register offset variant:    LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;
  Three registers, immediate offset variant: LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Three registers, register offset variant:  LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;
  Four registers, immediate offset variant:  LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Four registers, register offset variant:   LD1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;

2. Single structure
This instruction loads a single-element structure from memory and writes the 
result to the specified lane of the SIMD&amp;FP register without affecting the 
other bits of the register.

No offset:
  8-bit variant:  LD1 { &lt;Vt&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant  LD1 { &lt;Vt&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: LD1 { &lt;Vt&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: LD1 { &lt;Vt&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
8-bit, immediate offset variant:  LD1 { &lt;Vt&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #1
8-bit, register offset variant:   LD1 { &lt;Vt&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
16-bit, immediate offset variant: LD1 { &lt;Vt&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #2
16-bit, register offset variant:  LD1 { &lt;Vt&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
32-bit, immediate offset variant: LD1 { &lt;Vt&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #4
32-bit, register offset variant:  LD1 { &lt;Vt&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
64-bit, immediate offset variant: LD1 { &lt;Vt&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #8
64-bit, register offset variant:  LD1 { &lt;Vt&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1055" header="Load one single-element structure and Replicate to all lanes (of one register)" doc_id="armv8arm" token="LD1R">This instruction loads a single-element structure from memory and 
replicates the structure to all the lanes of the SIMD&amp;FP register.

No offset
  LD1R { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
Post-index
  Immediate offset variant: LD1R { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  LD1R { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1058" header="Load 2-element structures" doc_id="armv8arm" token="LD2">1. Multiple structures
This instruction loads multiple 2-element structures from memory and writes 
the result to the two SIMD&amp;FP registers, with de-interleaving.

No offset:
  LD2 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: LD2 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  LD2 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;

2. Single structure
This instruction loads a 2-element structure from memory and writes the result to 
the corresponding elements of the two SIMD&amp;FP registers without affecting the 
other bits of the registers.

No offset:
  8-bit variant:  LD2 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant: LD2 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: LD2 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: LD2 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]


Post-index:
  8-bit, immediate offset variant:  LD2 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #2
  8-bit, register offset variant:   LD2 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: LD2 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #4
  16-bit, register offset variant:  LD2 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: LD2 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #8
  32-bit, register offset variant:  LD2 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: LD2 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #16
  64-bit, register offset variant:  LD2 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1065" header="Load single 2-element structure and Replicate to all lanes of two registers" doc_id="armv8arm" token="LD2R">This instruction loads a 2-element structure from memory and replicates 
the structure to all the lanes of the two SIMD&amp;FP registers.

No offset:
  LD2R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: LD2R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  LD2R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1068" header="Load 3-element structures to three registers" doc_id="armv8arm" token="LD3">1. Multiple structures
This instruction loads multiple 3-element structures from memory and writes the 
result to the three SIMD&amp;FP registers, with de-interleaving.

No offset:
  LD3 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: LD3 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  LD3 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;

2. Single structure
This instruction loads a 3-element structure from memory and writes the result to the 
corresponding elements of the three SIMD&amp;FP registers without affecting the other 
bits of the registers.

No offset:
  8-bit variant:  LD3 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant: LD3 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: LD3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: LD3 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
  8-bit, immediate offset variant:  LD3 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #3
  8-bit, register offset variant:   LD3 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: LD3 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #6
  16-bit, register offset variant:  LD3 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: LD3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #12
  32-bit, register offset variant:  LD3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: LD3 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #24
  64-bit, register offset variant:  LD3 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1075" header="Load single 3-element structure and Replicate to all lanes of three registers." doc_id="armv8arm" token="LD3R">This instruction loads a 3-element structure from memory and replicates 
the structure to all the lanes of the three SIMD&amp;FP registers.

No offset:
  LD3R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
Post-index:
  Immediate offset variant: LD3R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  LD3R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1078" header="Load 4-element structures to four registers" doc_id="armv8arm" token="LD4">1. Multiple structures
This instruction loads multiple 4-element structures from memory and writes the result 
to the four SIMD&amp;FP registers, with de-interleaving.

No offset:
  LD4 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: LD4 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  LD4 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;

2. Single structure
This instruction loads a 4-element structure from memory and writes the result to the 
corresponding elements of the four SIMD&amp;FP registers without affecting the other bits 
of the registers.

No offset:
  8-bit variant:  LD4 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B, &lt;Vt4&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant: LD4 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H, &lt;Vt4&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: LD4 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S, &lt;Vt4&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: LD4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
  8-bit, immediate offset variant:  LD4 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B, &lt;Vt4&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #4
  8-bit, register offset variant:   LD4 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B, &lt;Vt4&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: LD4 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H, &lt;Vt4&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #8
  16-bit, register offset variant:  LD4 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H, &lt;Vt4&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: LD4 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S, &lt;Vt4&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #16
  32-bit, register offset variant:  LD4 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S, &lt;Vt4&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: LD4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #32

  64-bit, register offset variant:  LD4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1085" header="Load single 4-element structure and Replicate to all lanes of four registers" doc_id="armv8arm" token="LD4R">This instruction loads a 4-element structure from memory and replicates 
the structure to all the lanes of the four SIMD&amp;FP registers.

No offset:
  LD4R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: 
    LD4R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant
    LD4R { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1088" header="Load Pair of SIMD&amp;FP registers, with Non-temporal hint" doc_id="armv8arm" token="LDNP">This instruction loads a pair of SIMD&amp;FP registers from memory, 
issuing a hint to the memory system that the access is non-temporal. 
The address that is used for the load is calculated from a base 
register value and an optional immediate offset.

32-bit variant
  LDNP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
64-bit variant
  LDNP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
128-bit variant
  LDNP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="1090" header="Load Pair of SIMD&amp;FP registers" doc_id="armv8arm" token="LDP">This instruction loads a pair of SIMD&amp;FP registers from memory. 
The address that is used for the load is calculated from a base 
register value and an optional immediate offset.

Post-index:
  32-bit variant:  LDP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;
  64-bit variant:  LDP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;
  128-bit variant: LDP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;

Pre-index:
  32-bit variant:  LDP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!
  64-bit variant:  LDP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!
  128-bit variant: LDP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!

Signed offset:
  32-bit variant:  LDP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
  64-bit variant:  LDP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
  128-bit variant: LDP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="1093" header="Load SIMD&amp;FP Register" doc_id="armv8arm" token="LDR">1. Immediate
This instruction loads an element from memory, and writes the result 
as a scalar to the SIMD&amp;FP register. The address that is used for 
the load is calculated from a base register value, a signed 
immediate offset, and an optional offset that is a multiple of the 
element size.

Post-index:
  8-bit variant:   LDR &lt;Bt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  16-bit variant:  LDR &lt;Ht&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  32-bit variant:  LDR &lt;St&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  64-bit variant:  LDR &lt;Dt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  128-bit variant: LDR &lt;Qt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;

Pre-index:
  8-bit variant:   LDR &lt;Bt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  16-bit variant:  LDR &lt;Ht&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  32-bit variant:  LDR &lt;St&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  64-bit variant:  LDR &lt;Dt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  128-bit variant: LDR &lt;Qt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!

Unsigned offset:
  8-bit variant:   LDR &lt;Bt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  16-bit variant:  LDR &lt;Ht&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  32-bit variant:  LDR &lt;St&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  64-bit variant:  LDR &lt;Dt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  128-bit variant: LDR &lt;Qt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Literal
This instruction loads a SIMD&amp;FP register from memory. The address that is 
used for the load is calculated from the PC value and an immediate offset.

32-bit variant:  LDR &lt;St&gt;, &lt;label&gt;
64-bit variant:  LDR &lt;Dt&gt;, &lt;label&gt;
128-bit variant: LDR &lt;Qt&gt;, &lt;label&gt;

3. Register
This instruction loads a SIMD&amp;FP register from memory. The address that is used 
for the load is calculated from a base register value and an offset register 
value. The offset can be optionally shifted and extended.

8-bit variant:   LDR &lt;Bt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;), &lt;extend&gt; {&lt;amount&gt;}]
8-bit variant:   LDR &lt;Bt&gt;, [&lt;Xn|SP&gt;, &lt;Xm&gt;{, LSL &lt;amount&gt;}]
16-bit variant:  LDR &lt;Ht&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]
32-bit variant:  LDR &lt;St&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]
64-bit variant:  LDR &lt;Dt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]
128-bit variant: LDR &lt;Qt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="1102" header="Load SIMD&amp;FP Register (unscaled offset)" doc_id="armv8arm" token="LDUR">This instruction loads a SIMD&amp;FP register from memory. The address 
that is used for the load is calculated from a base register value 
and an optional immediate offset.

8-bit variant:   LDUR &lt;Bt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
16-bit variant:  LDUR &lt;Ht&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
32-bit variant:  LDUR &lt;St&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
64-bit variant:  LDUR &lt;Dt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
128-bit variant: LDUR &lt;Qt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="1104" header="Multiply-Add to accumulator" doc_id="armv8arm" token="MLA">1. By element
This instruction multiplies the vector elements in the first source 
SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP 
register, and accumulates the results with the vector elements of the 
destination SIMD&amp;FP register. All the values in this instruction are 
unsigned integer values.

MLA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding elements in the vectors of 
the two source SIMD&amp;FP registers, and accumulates the results with the 
vector elements of the destination SIMD&amp;FP register.

MLA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1108" header="Multiply-Subtract from accumulator" doc_id="armv8arm" token="MLS">1. By element
This instruction multiplies the vector elements in the first source 
SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP 
register, and subtracts the results from the vector elements of the 
destination SIMD&amp;FP register. All the values in this instruction are 
unsigned integer values.

MLS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding elements in the vectors of 
the two source SIMD&amp;FP registers, and subtracts the results from the 
vector elements of the destination SIMD&amp;FP register.

MLS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1112" header="Move vector element" doc_id="armv8arm" token="MOV">1. Scalar
This instruction duplicates the specified vector element in the SIMD&amp;FP 
source register into a scalar, and writes the result to the SIMD&amp;FP 
destination register.

MOV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;[&lt;index&gt;]
  is equivalent to
DUP &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;[&lt;index&gt;]

2. Element
This instruction copies the vector element of the source SIMD&amp;FP register 
to the specified vector element of the destination SIMD&amp;FP register.
This instruction can insert data into individual elements within a SIMD&amp;FP 
register without clearing the remaining bits to zero.

MOV &lt;Vd&gt;.&lt;Ts&gt;[&lt;index1&gt;], &lt;Vn&gt;.&lt;Ts&gt;[&lt;index2&gt;]
  is equivalent to
INS &lt;Vd&gt;.&lt;Ts&gt;[&lt;index1&gt;], &lt;Vn&gt;.&lt;Ts&gt;[&lt;index2&gt;]

3. From general
This instruction copies the contents of the source general-purpose register 
to the specified vector element in the destination SIMD&amp;FP register.
This instruction can insert data into individual elements within a SIMD&amp;FP 
register without clearing the remaining bits to zero.

MOV &lt;Vd&gt;.&lt;Ts&gt;[&lt;index&gt;], &lt;R&gt;&lt;n&gt;
  is equivalent to
INS &lt;Vd&gt;.&lt;Ts&gt;[&lt;index&gt;], &lt;R&gt;&lt;n&gt;

4. Vector
This instruction copies the vector in the source SIMD&amp;FP register into the 
destination SIMD&amp;FP register.

MOV &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;
  is equivalent to
ORR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

5. To general
This instruction reads the unsigned integer from the source SIMD&amp;FP register, 
zero-extends it to form a 32-bit or 64-bit value, and writes the result to the 
destination general-purpose register.

32-bit variant:
  MOV &lt;Wd&gt;, &lt;Vn&gt;.S[&lt;index&gt;] is equivalent to UMOV &lt;Wd&gt;, &lt;Vn&gt;.S[&lt;index&gt;]
64-bit variant:
  MOV &lt;Xd&gt;, &lt;Vn&gt;.D[&lt;index&gt;] is equivalent to UMOV &lt;Xd&gt;, &lt;Vn&gt;.D[&lt;index&gt;]</hint>
			<hint page="1120" header="Move Immediate (vector)" doc_id="armv8arm" token="MOVI">This instruction places an immediate constant into every vector 
element of the destination SIMD&amp;FP register.

8-bit variant:
  MOVI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #0}
16-bit shifted immediate variant
  MOVI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}
32-bit shifted immediate variant
  MOVI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}
32-bit shifting ones variant
  MOVI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;, MSL #&lt;amount&gt;
64-bit scalar variant
  MOVI &lt;Dd&gt;, #&lt;imm&gt;
64-bit vector variant
  MOVI &lt;Vd&gt;.2D, #&lt;imm&gt;</hint>
			<hint page="1123" header="Multiply" doc_id="armv8arm" token="MUL">1. By element
This instruction multiplies the vector elements in the first source 
SIMD&amp;FP register by the specified value in the second source SIMD&amp;FP 
register, places the results in a vector, and writes the vector to the 
destination SIMD&amp;FP register. All the values in this instruction are 
unsigned integer values.

MUL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding elements in the vectors of 
the two source SIMD&amp;FP registers, places the results in a vector, and 
writes the vector to the destination SIMD&amp;FP register.

MUL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1127" header="Bitwise NOT (vector)" doc_id="armv8arm" token="MVN">This instruction reads each vector element from the source SIMD&amp;FP register, 
places the inverse of each value into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

MVN &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

  is equivalent to

NOT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1128" header="Move inverted Immediate (vector)" doc_id="armv8arm" token="MVNI">This instruction places the inverse of an immediate constant into 
every vector element of the destination SIMD&amp;FP register.

16-bit shifted immediate variant
  MVNI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}
32-bit shifted immediate variant
  MVNI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}
32-bit shifting ones variant
  MVNI &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;, MSL #&lt;amount&gt;</hint>
			<hint page="1130" header="Negate (vector)" doc_id="armv8arm" token="NEG">This instruction reads each vector element from the source SIMD&amp;FP 
register, negates each value, puts the result into a vector, and 
writes the vector to the destination SIMD&amp;FP register.

NEG &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;</hint>
			<hint page="1132" header="Bitwise NOT (vector)" doc_id="armv8arm" token="NOT">This instruction reads each vector element from the source SIMD&amp;FP 
register, places the inverse of each value into a vector, and 
writes the vector to the destination SIMD&amp;FP register.

NOT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1133" header="Bitwise inclusive OR NOT" doc_id="armv8arm" token="ORN">1. Vector
This instruction performs a bitwise OR NOT between the two source SIMD&amp;FP 
registers, and writes the result to the destination SIMD&amp;FP register.

ORN &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;

2. Immediate
This instruction reads each vector element from the destination SIMD&amp;FP 
register, performs a bitwise OR between each result and an immediate 
constant, places the result into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

16-bit variant
  ORR &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}
32-bit variant
  ORR &lt;Vd&gt;.&lt;T&gt;, #&lt;imm8&gt;{, LSL #&lt;amount&gt;}

3. Register
This instruction performs a bitwise OR between the two source SIMD&amp;FP 
registers, and writes the result to the destination SIMD&amp;FP register.

ORR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1137" header="Polynomial Multiply" doc_id="armv8arm" token="PMUL">This instruction multiplies corresponding elements in the vectors 
of the two source SIMD&amp;FP registers, places the results in a vector, 
and writes the vector to the destination SIMD&amp;FP register.

PMUL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1139" header="Polynomial Multiply Long" doc_id="armv8arm" token="PMULL">This instruction multiplies corresponding elements in the lower or 
upper half of the vectors of the two source SIMD&amp;FP registers, 
places the results in a vector, and writes the vector to the 
destination SIMD&amp;FP register. The destination vector elements are 
twice as long as the elements that are multiplied.

The PMULL instruction extracts each source vector from the lower 
half of each source register, while the PMULL2
instruction extracts each source vector from the upper half of 
each source register.

PMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1139" header="Polynomial Multiply Long" doc_id="armv8arm" token="PMULL2">This instruction multiplies corresponding elements in the lower or 
upper half of the vectors of the two source SIMD&amp;FP registers, 
places the results in a vector, and writes the vector to the 
destination SIMD&amp;FP register. The destination vector elements are 
twice as long as the elements that are multiplied.

The PMULL instruction extracts each source vector from the lower 
half of each source register, while the PMULL2
instruction extracts each source vector from the upper half of 
each source register.

PMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1141" header="Rounding Add returning High Narrow" doc_id="armv8arm" token="RADDHN">This instruction adds each vector element in the first source SIMD&amp;FP 
register to the corresponding vector element in the second source SIMD&amp;FP 
register, places the most significant half of the result into a vector, 
and writes the vector to the lower or upper half of the destination SIMD&amp;FP 
register.

The RADDHN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the RADDHN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

RADDHN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1141" header="Rounding Add returning High Narrow" doc_id="armv8arm" token="RADDHN2">This instruction adds each vector element in the first source SIMD&amp;FP 
register to the corresponding vector element in the second source SIMD&amp;FP 
register, places the most significant half of the result into a vector, 
and writes the vector to the lower or upper half of the destination SIMD&amp;FP 
register.

The RADDHN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the RADDHN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

RADDHN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1143" header="Reverse Bit order (vector)" doc_id="armv8arm" token="RBIT">This instruction reads each vector element from the source SIMD&amp;FP register, 
reverses the bits of the element, places the results into a vector, and 
writes the vector to the destination SIMD&amp;FP register.

RBIT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1144" header="Reverse elements in 16-bit halfwords (vector)" doc_id="armv8arm" token="REV16">This instruction reverses the order of 8-bit elements in each halfword 
of the vector in the source SIMD&amp;FP register, places the results into 
a vector, and writes the vector to the destination SIMD&amp;FP register.

REV16 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1146" header="Reverse elements in 32-bit words (vector)" doc_id="armv8arm" token="REV32">This instruction reverses the order of 8-bit or 16-bit elements in each 
word of the vector in the source SIMD&amp;FP register, places the results 
into a vector, and writes the vector to the destination SIMD&amp;FP register.

REV32 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1148" header="Reverse elements in 64-bit doublewords (vector)" doc_id="armv8arm" token="REV64">This instruction reverses the order of 8-bit, 16-bit, or 32-bit elements in 
each doubleword of the vector in the source SIMD&amp;FP register, places the 
results into a vector, and writes the vector to the destination SIMD&amp;FP register.

REV64 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1150" header="Rounding Shift Right Narrow (immediate)" doc_id="armv8arm" token="RSHRN">This instruction reads each unsigned integer value from the vector in the 
source SIMD&amp;FP register, right shifts each result by an immediate value, 
writes the final result to a vector, and writes the vector to the lower or 
upper half of the destination SIMD&amp;FP register. The destination vector 
elements are half as long as the source vector elements. The results are 
rounded. For truncated results, see SHRN, SHRN2.

The RSHRN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the RSHRN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

RSHRN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1150" header="Rounding Shift Right Narrow (immediate)" doc_id="armv8arm" token="RSHRN2">This instruction reads each unsigned integer value from the vector in the 
source SIMD&amp;FP register, right shifts each result by an immediate value, 
writes the final result to a vector, and writes the vector to the lower or 
upper half of the destination SIMD&amp;FP register. The destination vector 
elements are half as long as the source vector elements. The results are 
rounded. For truncated results, see SHRN, SHRN2.

The RSHRN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the RSHRN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

RSHRN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1152" header="Rounding Subtract returning High Narrow" doc_id="armv8arm" token="RSUBHN">This instruction subtracts each vector element of the second source SIMD&amp;FP 
register from the corresponding vector element of the first source SIMD&amp;FP 
register, places the most significant half of the result into a vector, and 
writes the vector to the lower or upper half of the destination SIMD&amp;FP register.

The results are rounded. For truncated results, see SUBHN, SUBHN2.

The RSUBHN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the RSUBHN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

RSUBHN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1152" header="Rounding Subtract returning High Narrow" doc_id="armv8arm" token="RSUBHN2">This instruction subtracts each vector element of the second source SIMD&amp;FP 
register from the corresponding vector element of the first source SIMD&amp;FP 
register, places the most significant half of the result into a vector, and 
writes the vector to the lower or upper half of the destination SIMD&amp;FP register.

The results are rounded. For truncated results, see SUBHN, SUBHN2.

The RSUBHN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the RSUBHN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

RSUBHN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1154" header="Signed Absolute difference and Accumulate" doc_id="armv8arm" token="SABA">This instruction subtracts the elements of the vector of the second 
source SIMD&amp;FP register from the corresponding elements of the first 
source SIMD&amp;FP register, and accumulates the absolute values of the 
results into the elements of the vector of the destination SIMD&amp;FP 
register.

SABA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1156" header="Signed Absolute difference and Accumulate Long" doc_id="armv8arm" token="SABAL">This instruction subtracts the vector elements in the lower or upper 
half of the second source SIMD&amp;FP register from the corresponding 
vector elements of the first source SIMD&amp;FP register, and accumulates 
the absolute values of the results into the vector elements of the 
destination SIMD&amp;FP register. The destination vector elements are 
twice as long as the source vector elements.

The SABAL instruction extracts each source vector from the lower half 
of each source register, while the SABAL2 instruction extracts each 
source vector from the upper half of each source register.

SABAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1156" header="Signed Absolute difference and Accumulate Long" doc_id="armv8arm" token="SABAL2">This instruction subtracts the vector elements in the lower or upper 
half of the second source SIMD&amp;FP register from the corresponding 
vector elements of the first source SIMD&amp;FP register, and accumulates 
the absolute values of the results into the vector elements of the 
destination SIMD&amp;FP register. The destination vector elements are 
twice as long as the source vector elements.

The SABAL instruction extracts each source vector from the lower half 
of each source register, while the SABAL2 instruction extracts each 
source vector from the upper half of each source register.

SABAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1158" header="Signed Absolute Difference" doc_id="armv8arm" token="SABD">This instruction subtracts the elements of the vector of the second 
source SIMD&amp;FP register from the corresponding elements of the first 
source SIMD&amp;FP register, places the absolute values of the results 
into a vector, and writes the vector to the destination SIMD&amp;FP register.

SABD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1160" header="Signed Absolute Difference Long" doc_id="armv8arm" token="SABDL">This instruction subtracts the vector elements of the second source SIMD&amp;FP 
register from the corresponding vector elements of the first source SIMD&amp;FP 
register, places the absolute value of the results into a vector, and writes 
the vector to the lower or upper half of the destination SIMD&amp;FP register. 

The destination vector elements are twice as long as the source vector elements.

The SABDL instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the SABDL2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

SABDL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1160" header="Signed Absolute Difference Long" doc_id="armv8arm" token="SABDL2">This instruction subtracts the vector elements of the second source SIMD&amp;FP 
register from the corresponding vector elements of the first source SIMD&amp;FP 
register, places the absolute value of the results into a vector, and writes 
the vector to the lower or upper half of the destination SIMD&amp;FP register. 

The destination vector elements are twice as long as the source vector elements.

The SABDL instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the SABDL2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

SABDL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1162" header="Signed Add and Accumulate Long Pairwise" doc_id="armv8arm" token="SADALP">This instruction adds pairs of adjacent signed integer values from the 
vector in the source SIMD&amp;FP register and accumulates the results into 
the vector elements of the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the source vector elements.

SADALP &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</hint>
			<hint page="1164" header="Signed Add Long (vector)" doc_id="armv8arm" token="SADDL">This instruction adds each vector element in the lower or upper half 
of the first source SIMD&amp;FP register to the corresponding vector 
element of the second source SIMD&amp;FP register, places the results 
into a vector, and writes the vector to the destination SIMD&amp;FP 
register. The destination vector elements are twice as long as the 
source vector elements. All the values in this instruction are 
signed integer values.

The SADDL instruction extracts each source vector from the lower 
half of each source register, while the SADDL2 instruction extracts 
each source vector from the upper half of each source register.

SADDL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1164" header="Signed Add Long (vector)" doc_id="armv8arm" token="SADDL2">This instruction adds each vector element in the lower or upper half 
of the first source SIMD&amp;FP register to the corresponding vector 
element of the second source SIMD&amp;FP register, places the results 
into a vector, and writes the vector to the destination SIMD&amp;FP 
register. The destination vector elements are twice as long as the 
source vector elements. All the values in this instruction are 
signed integer values.

The SADDL instruction extracts each source vector from the lower 
half of each source register, while the SADDL2 instruction extracts 
each source vector from the upper half of each source register.

SADDL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1166" header="Signed Add Long Pairwise" doc_id="armv8arm" token="SADDLP">This instruction adds pairs of adjacent signed integer values from 
the vector in the source SIMD&amp;FP register, places the result into 
a vector, and writes the vector to the destination SIMD&amp;FP register. 
The destination vector elements are twice as long as the source vector 
elements.

SADDLP &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</hint>
			<hint page="1168" header="Signed Add Long across Vector" doc_id="armv8arm" token="SADDLV">This instruction adds every vector element in the source SIMD&amp;FP 
register together, and writes the scalar result to the destination 
SIMD&amp;FP register. The destination scalar is twice as long as the 
source vector elements. All the values in this instruction are 
signed integer values.

SADDLV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1170" header="Signed Add Wide" doc_id="armv8arm" token="SADDW">This instruction adds vector elements of the first source SIMD&amp;FP 
register to the corresponding vector elements in the lower or upper 
half of the second source SIMD&amp;FP register, places the results in a 
vector, and writes the vector to the SIMD&amp;FP destination register.

The SADDW instruction extracts the second source vector from the lower 
half of the second source register, while the SADDW2 instruction extracts 
the second source vector from the upper half of the second source register.

SADDW &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1170" header="Signed Add Wide" doc_id="armv8arm" token="SADDW2">This instruction adds vector elements of the first source SIMD&amp;FP 
register to the corresponding vector elements in the lower or upper 
half of the second source SIMD&amp;FP register, places the results in a 
vector, and writes the vector to the SIMD&amp;FP destination register.

The SADDW instruction extracts the second source vector from the lower 
half of the second source register, while the SADDW2 instruction extracts 
the second source vector from the upper half of the second source register.

SADDW2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1172" header="Signed fixed-point Convert" doc_id="armv8arm" token="SCVTF">1. Fixed-point (vector)
This instruction converts each element in a vector from fixed-point to 
floating-point using the rounding mode that is specified by the FPCR, 
and writes the result to the SIMD&amp;FP destination register.

Scalar variant: SCVTF &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;fbits&gt;

Vector variant: SCVTF &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;fbits&gt;

2. Integer (vector)
This instruction converts each element in a vector from signed integer 
to floating-point using the rounding mode that is specified by the FPCR, 
and writes the result to the SIMD&amp;FP destination register.

Scalar variant: SCVTF &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;
Vector variant: SCVTF &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;

3. Fixed-point (scalar)
This instruction converts the signed value in the 32-bit or 64-bit 
general-purpose source register to a floating-point value using the 
rounding mode that is specified by the FPCR, and writes the result to 
the SIMD&amp;FP destination register.

32-bit to single-precision variant: SCVTF &lt;Sd&gt;, &lt;Wn&gt;, #&lt;fbits&gt;
32-bit to double-precision variant: SCVTF &lt;Dd&gt;, &lt;Wn&gt;, #&lt;fbits&gt;
64-bit to single-precision variant: SCVTF &lt;Sd&gt;, &lt;Xn&gt;, #&lt;fbits&gt;
64-bit to double-precision variant:SCVTF &lt;Dd&gt;, &lt;Xn&gt;, #&lt;fbits&gt;

4. Integer (scalar)
This instruction converts the signed integer value in the general-purpose 
source register to a floating-point value using the rounding mode that is 
specified by the FPCR, and writes the result to the SIMD&amp;FP destination register.

32-bit to single-precision variant: SCVTF &lt;Sd&gt;, &lt;Wn&gt;
32-bit to double-precision variant: SCVTF &lt;Dd&gt;, &lt;Wn&gt;
64-bit to single-precision variant: SCVTF &lt;Sd&gt;, &lt;Xn&gt;
64-bit to double-precision variant: SCVTF &lt;Dd&gt;, &lt;Xn&gt;</hint>
			<hint page="1191" header="Signed Halving Add" doc_id="armv8arm" token="SHADD">This instruction adds corresponding signed integer values from the 
two source SIMD&amp;FP registers, shifts each result right one bit, 
places the results into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

SHADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1193" header="Shift Left (immediate)" doc_id="armv8arm" token="SHL">This instruction reads each value from a vector, right shifts each 
result by an immediate value, writes the final result to a vector, 
and writes the vector to the destination SIMD&amp;FP register.

Scalar variant
  SHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;
Vector variant
  SHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1195" header="Shift Left Long (by element size)" doc_id="armv8arm" token="SHLL">This instruction reads each vector element in the lower or upper 
half of the source SIMD&amp;FP register, left shifts each result by 
the element size, writes the final result to a vector, and writes 
the vector to the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the source vector elements.

The SHLL instruction extracts vector elements from the lower half 
of the source register, while the SHLL2 instruction extracts vector 
elements from the upper half of the source register.

SHLL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</hint>
			<hint page="1195" header="Shift Left Long (by element size)" doc_id="armv8arm" token="SHLL2">This instruction reads each vector element in the lower or upper 
half of the source SIMD&amp;FP register, left shifts each result by 
the element size, writes the final result to a vector, and writes 
the vector to the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the source vector elements.

The SHLL instruction extracts vector elements from the lower half 
of the source register, while the SHLL2 instruction extracts vector 
elements from the upper half of the source register.

SHLL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</hint>
			<hint page="1197" header="Shift Right Narrow (immediate)" doc_id="armv8arm" token="SHRN">Shift Right Narrow (immediate). This instruction reads each unsigned integer 
value from the source SIMD&amp;FP register, right shifts each result by an 
immediate value, puts the final result into a vector, and writes the vector 
to the lower or upper half of the destination SIMD&amp;FP register. The destination 
vector elements are half as long as the source vector elements. The results 
are truncated. For rounded results, see RSHRN, RSHRN2.

The RSHRN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the RSHRN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

SHRN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1197" header="Shift Right Narrow (immediate)" doc_id="armv8arm" token="SHRN2">Shift Right Narrow (immediate). This instruction reads each unsigned integer 
value from the source SIMD&amp;FP register, right shifts each result by an 
immediate value, puts the final result into a vector, and writes the vector 
to the lower or upper half of the destination SIMD&amp;FP register. The destination 
vector elements are half as long as the source vector elements. The results 
are truncated. For rounded results, see RSHRN, RSHRN2.

The RSHRN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the RSHRN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

SHRN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1199" header="Signed Halving Subtract" doc_id="armv8arm" token="SHSUB">This instruction subtracts the elements in the vector in the second 
source SIMD&amp;FP register from the corresponding elements in the vector 
in the first source SIMD&amp;FP register, shifts each result right one bit, 
places each result into elements of a vector, and writes the vector 
to the destination SIMD&amp;FP register.

SHSUB &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1201" header="Shift Left and Insert (immediate)" doc_id="armv8arm" token="SLI">This instruction reads each vector element in the source SIMD&amp;FP 
register, left shifts each vector element by an immediate value, 
and inserts the result into the corresponding vector element in 
the destination SIMD&amp;FP register such that the new zero bits 
created by the shift are not inserted but retain their existing 
value. Bits shifted out of the left of each vector element in 
the source register are lost.

Scalar variant
  SLI &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SLI &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1204" header="Signed Maximum (vector)" doc_id="armv8arm" token="SMAX">This instruction compares corresponding elements in the vectors in 
the two source SIMD&amp;FP registers, places the larger of each pair of 
signed integer values into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

SMAX &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1206" header="Signed Maximum Pairwise" doc_id="armv8arm" token="SMAXP">This instruction creates a vector by concatenating the vector elements 
of the first source SIMD&amp;FP register after the vector elements of the 
second source SIMD&amp;FP register, reads each pair of adjacent vector 
elements in the two source SIMD&amp;FP registers, writes the largest of 
each pair of signed integer values into a vector, and writes the 
vector to the destination SIMD&amp;FP register.

SMAXP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1208" header="Signed Maximum across Vector" doc_id="armv8arm" token="SMAXV">This instruction compares all the vector elements in the source 
SIMD&amp;FP register, and writes the largest of the values as a scalar 
to the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values.

SMAXV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1210" header="Signed Minimum (vector)." doc_id="armv8arm" token="SMIN">This instruction compares corresponding elements in the vectors in 
the two source SIMD&amp;FP registers, places the smaller of each of the 
two signed integer values into a vector, and writes the vector to 
the destination SIMD&amp;FP register.

SMIN &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1211" header="Signed Minimum Pairwise" doc_id="armv8arm" token="SMINP">This instruction creates a vector by concatenating the vector elements 
of the first source SIMD&amp;FP register after the vector elements of the 
second source SIMD&amp;FP register, reads each pair of adjacent vector 
elements in the two source SIMD&amp;FP registers, writes the smallest of 
each pair of signed integer values into a vector, and writes the 
vector to the destination SIMD&amp;FP register.

SMINP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1214" header="Signed Minimum across Vector" doc_id="armv8arm" token="SMINV">This instruction compares all the vector elements in the source 
SIMD&amp;FP register, and writes the smallest of the values as a 
scalar to the destination SIMD&amp;FP register. All the values in 
this instruction are signed integer values.

SMINV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1216" header="Signed Multiply-Add Long" doc_id="armv8arm" token="SMLAL">1. By element
This instruction multiplies each vector element in the lower or upper half 
of the first source SIMD&amp;FP register by the specified vector element in 
the second source SIMD&amp;FP register, and accumulates the results with the 
vector elements of the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the elements that are multiplied. All 
the values in this instruction are signed integer values.

The SMLAL instruction extracts vector elements from the lower half of the 
first source register, while the SMLAL2 instruction extracts vector elements 
from the upper half of the first source register.

SMLAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower 
or upper half of the vectors of the two source SIMD&amp;FP registers, and accumulates 
the results with the vector elements of the destination SIMD&amp;FP register. The 
destination vector elements are twice as long as the elements that are multiplied.

The SMLAL instruction extracts each source vector from the lower half of each 
source register, while the SMLAL2 instruction extracts each source vector from 
the upper half of each source register.

SMLAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1216" header="Signed Multiply-Add Long" doc_id="armv8arm" token="SMLAL2">1. By element
This instruction multiplies each vector element in the lower or upper half 
of the first source SIMD&amp;FP register by the specified vector element in 
the second source SIMD&amp;FP register, and accumulates the results with the 
vector elements of the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the elements that are multiplied. All 
the values in this instruction are signed integer values.

The SMLAL instruction extracts vector elements from the lower half of the 
first source register, while the SMLAL2 instruction extracts vector elements 
from the upper half of the first source register.

SMLAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower 
or upper half of the vectors of the two source SIMD&amp;FP registers, and accumulates 
the results with the vector elements of the destination SIMD&amp;FP register. The 
destination vector elements are twice as long as the elements that are multiplied.

The SMLAL instruction extracts each source vector from the lower half of each 
source register, while the SMLAL2 instruction extracts each source vector from 
the upper half of each source register.

SMLAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1221" header="Signed Multiply-Subtract Long" doc_id="armv8arm" token="SMLSL">1. By element
This instruction multiplies each vector element in the lower or upper half of 
the first source SIMD&amp;FP register by the specified vector element of the second 
source SIMD&amp;FP register and subtracts the results from the vector elements of 
the destination SIMD&amp;FP register. The destination vector elements are twice as 
long as the elements that are multiplied.

The SMLSL instruction extracts vector elements from the lower half of the first
source register, while the SMLSL2 instruction extracts vector elements from 
the upper half of the first source register.

SMLSL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower or 
upper half of the vectors of the two source SIMD&amp;FP registers, and subtracts 
the results from the vector elements of the destination SIMD&amp;FP register. The 
destination vector elements are twice as long as the elements that are multiplied.

The SMLSL instruction extracts each source vector from the lower half of each 
source register, while the SMLSL2 instruction extracts each source vector from 
the upper half of each source register.

SMLSL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1221" header="Signed Multiply-Subtract Long" doc_id="armv8arm" token="SMLSL2">1. By element
This instruction multiplies each vector element in the lower or upper half of 
the first source SIMD&amp;FP register by the specified vector element of the second 
source SIMD&amp;FP register and subtracts the results from the vector elements of 
the destination SIMD&amp;FP register. The destination vector elements are twice as 
long as the elements that are multiplied.

The SMLSL instruction extracts vector elements from the lower half of the first
source register, while the SMLSL2 instruction extracts vector elements from 
the upper half of the first source register.

SMLSL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower or 
upper half of the vectors of the two source SIMD&amp;FP registers, and subtracts 
the results from the vector elements of the destination SIMD&amp;FP register. The 
destination vector elements are twice as long as the elements that are multiplied.

The SMLSL instruction extracts each source vector from the lower half of each 
source register, while the SMLSL2 instruction extracts each source vector from 
the upper half of each source register.

SMLSL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1226" header="Signed Move vector element to general-purpose register" doc_id="armv8arm" token="SMOV">This instruction reads the signed integer from the source SIMD&amp;FP register, 
sign-extends it to form a 32-bit or 64-bit value, and writes the result to 
destination general-purpose register.

32-bit variant
  SMOV &lt;Wd&gt;, &lt;Vn&gt;.&lt;Ts&gt;[&lt;index&gt;]
64-bit variant
  SMOV &lt;Xd&gt;, &lt;Vn&gt;.&lt;Ts&gt;[&lt;index&gt;]</hint>
			<hint page="1228" header="Signed Multiply Long" doc_id="armv8arm" token="SMULL">1. By element
This instruction multiplies each vector element in the lower or upper half 
of the first source SIMD&amp;FP register by the specified vector element of 
the second source SIMD&amp;FP register, places the result in a vector, and 
writes the vector to the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the elements that are multiplied.

The SMULL instruction extracts vector elements from the lower half of the 
first source register, while the SMULL2 instruction extracts vector elements 
from the upper half of the first source register.

SMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower 
or upper half of the vectors of the two source SIMD&amp;FP registers, places the 
results in a vector, and writes the vector to the destination SIMD&amp;FP register.

The destination vector elements are twice as long as the elements that are 
multiplied.

The SMULL instruction extracts each source vector from the lower half of each 
source register, while the SMULL2 instruction extracts each source vector from 
the upper half of each source register.

SMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1228" header="Signed Multiply Long" doc_id="armv8arm" token="SMULL2">1. By element
This instruction multiplies each vector element in the lower or upper half 
of the first source SIMD&amp;FP register by the specified vector element of 
the second source SIMD&amp;FP register, places the result in a vector, and 
writes the vector to the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the elements that are multiplied.

The SMULL instruction extracts vector elements from the lower half of the 
first source register, while the SMULL2 instruction extracts vector elements 
from the upper half of the first source register.

SMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower 
or upper half of the vectors of the two source SIMD&amp;FP registers, places the 
results in a vector, and writes the vector to the destination SIMD&amp;FP register.

The destination vector elements are twice as long as the elements that are 
multiplied.

The SMULL instruction extracts each source vector from the lower half of each 
source register, while the SMULL2 instruction extracts each source vector from 
the upper half of each source register.

SMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1232" header="Signed saturating Absolute value" doc_id="armv8arm" token="SQABS">This instruction reads each vector element from the source SIMD&amp;FP 
register, puts the absolute value of the result into a vector, and 
writes the vector to the destination SIMD&amp;FP register. All the 
values in this instruction are signed integer values.

Scalar variant
  SQABS &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

Vector variant
  SQABS &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1234" header="Signed saturating Add" doc_id="armv8arm" token="SQADD">This instruction adds the values of corresponding elements of the two 
source SIMD&amp;FP registers, places the results into a vector, and writes 
the vector to the destination SIMD&amp;FP register.

Scalar variant
  SQADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SQADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1236" header="Signed saturating Doubling Multiply-Add Long" doc_id="armv8arm" token="SQDMLAL">1. By element
This instruction multiplies each vector element in the lower or upper half 
of the first source SIMD&amp;FP register by the specified vector element of the 
second source SIMD&amp;FP register, doubles the results, and accumulates the 
final results with the vector elements of the destination SIMD&amp;FP register. 
The destination vector elements are twice as long as the elements that are 
multiplied.

If overflow occurs with any of the results, those results are saturated. 
If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLAL instruction extracts vector elements from the lower half of the 
first source register, while the SQDMLAL2 instruction extracts vector elements 
from the upper half of the first source register.

Scalar variant
  SQDMLAL &lt;Va&gt;&lt;d&gt;, &lt;Vb&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

Vector variant
  SQDMLAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower 
or upper half of the vectors of the two source SIMD&amp;FP registers, doubles the 
results, and accumulates the final results with the vector elements of the 
destination SIMD&amp;FP register. The destination vector elements are twice as 
long as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLAL instruction extracts each source vector from the lower half of 
each source register, while the SQDMLAL2 instruction extracts each source 
vector from the upper half of each source register.

Scalar variant
  SQDMLAL &lt;Va&gt;&lt;d&gt;, &lt;Vb&gt;&lt;n&gt;, &lt;Vb&gt;&lt;m&gt;

Vector variant
  SQDMLAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1236" header="Signed saturating Doubling Multiply-Add Long" doc_id="armv8arm" token="SQDMLAL2">1. By element
This instruction multiplies each vector element in the lower or upper half 
of the first source SIMD&amp;FP register by the specified vector element of the 
second source SIMD&amp;FP register, doubles the results, and accumulates the 
final results with the vector elements of the destination SIMD&amp;FP register. 
The destination vector elements are twice as long as the elements that are 
multiplied.

If overflow occurs with any of the results, those results are saturated. 
If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLAL instruction extracts vector elements from the lower half of the 
first source register, while the SQDMLAL2 instruction extracts vector elements 
from the upper half of the first source register.

Vector variant
  SQDMLAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower 
or upper half of the vectors of the two source SIMD&amp;FP registers, doubles the 
results, and accumulates the final results with the vector elements of the 
destination SIMD&amp;FP register. The destination vector elements are twice as 
long as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLAL instruction extracts each source vector from the lower half of 
each source register, while the SQDMLAL2 instruction extracts each source 
vector from the upper half of each source register.

Vector variant
  SQDMLAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1243" header="Signed saturating Doubling Multiply-Subtract Long" doc_id="armv8arm" token="SQDMLSL">1. By element
This instruction multiplies each vector element in the lower or upper half of 
the first source SIMD&amp;FP register by the specified vector element of the second 
source SIMD&amp;FP register, doubles the results, and subtracts the final results 
from the vector elements of the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the elements that are multiplied. All the 
values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLSL instruction extracts vector elements from the lower half of the 
first source register, while the SQDMLSL2 instruction extracts vector elements 
from the upper half of the first source register.

Scalar variant
  SQDMLSL &lt;Va&gt;&lt;d&gt;, &lt;Vb&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

Vector variant
  SQDMLSL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower or 
upper half of the vectors of the two source SIMD&amp;FP registers, doubles the 
results, and subtracts the final results from the vector elements of the 
destination SIMD&amp;FP register. The destination vector elements are twice as long 
as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLSL instruction extracts each source vector from the lower half of each 
source register, while the SQDMLSL2 instruction extracts each source vector from 
the upper half of each source register.

Scalar variant
  SQDMLSL &lt;Va&gt;&lt;d&gt;, &lt;Vb&gt;&lt;n&gt;, &lt;Vb&gt;&lt;m&gt;

Vector variant
  SQDMLSL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1243" header="Signed saturating Doubling Multiply-Subtract Long" doc_id="armv8arm" token="SQDMLSL2">1. By element
This instruction multiplies each vector element in the lower or upper half of 
the first source SIMD&amp;FP register by the specified vector element of the second 
source SIMD&amp;FP register, doubles the results, and subtracts the final results 
from the vector elements of the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the elements that are multiplied. All the 
values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLSL instruction extracts vector elements from the lower half of the 
first source register, while the SQDMLSL2 instruction extracts vector elements 
from the upper half of the first source register.

Vector variant
  SQDMLSL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding signed integer values in the lower or 
upper half of the vectors of the two source SIMD&amp;FP registers, doubles the 
results, and subtracts the final results from the vector elements of the 
destination SIMD&amp;FP register. The destination vector elements are twice as long 
as the elements that are multiplied.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMLSL instruction extracts each source vector from the lower half of each 
source register, while the SQDMLSL2 instruction extracts each source vector from 
the upper half of each source register.

Vector variant
  SQDMLSL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1250" header="Signed saturating Doubling Multiply returning High half" doc_id="armv8arm" token="SQDMULH">1. By element
This instruction multiplies each vector element in the first source SIMD&amp;FP 
register by the specified vector element of the second source SIMD&amp;FP 
register, doubles the results, places the most significant half of the 
final results into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The results are truncated.

SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies the values of corresponding elements of the two 
source SIMD&amp;FP registers, doubles the results, places the most significant 
half of the final results into a vector, and writes the vector to the 
destination SIMD&amp;FP register. The results are truncated.

SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="1255" header="Signed saturating Doubling Multiply Long" doc_id="armv8arm" token="SQDMULL">1. By element
This instruction multiplies each vector element in the lower or upper half of 
the first source SIMD&amp;FP register by the specified vector element of the 
second source SIMD&amp;FP register, doubles the results, places the final results 
in a vector, and writes the vector to the destination SIMD&amp;FP register. All 
the values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMULL instruction extracts the first source vector from the lower half 
of the first source register, while the SQDMULL2 instruction extracts the 
first source vector from the upper half of the first source register.

Scalar variant
  SQDMULL &lt;Va&gt;&lt;d&gt;, &lt;Vb&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

Vector variant
  SQDMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

1. Vector
This instruction multiplies corresponding vector elements in the lower or upper 
half of the two source SIMD&amp;FP registers, doubles the results, places the final 
results in a vector, and writes the vector to the destination SIMD&amp;FP register.
If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMULL instruction extracts each source vector from the lower half of each 
source register, while the SQDMULL2 instruction extracts each source vector from 
the upper half of each source register.

Scalar variant
  SQDMULL &lt;Va&gt;&lt;d&gt;, &lt;Vb&gt;&lt;n&gt;, &lt;Vb&gt;&lt;m&gt;

Vector variant
  SQDMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1255" header="Signed saturating Doubling Multiply Long" doc_id="armv8arm" token="SQDMULL2">1. By element
This instruction multiplies each vector element in the lower or upper half of 
the first source SIMD&amp;FP register by the specified vector element of the 
second source SIMD&amp;FP register, doubles the results, places the final results 
in a vector, and writes the vector to the destination SIMD&amp;FP register. All 
the values in this instruction are signed integer values.

If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMULL instruction extracts the first source vector from the lower half 
of the first source register, while the SQDMULL2 instruction extracts the 
first source vector from the upper half of the first source register.

Vector variant
  SQDMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

1. Vector
This instruction multiplies corresponding vector elements in the lower or upper 
half of the two source SIMD&amp;FP registers, doubles the results, places the final 
results in a vector, and writes the vector to the destination SIMD&amp;FP register.
If overflow occurs with any of the results, those results are saturated. If 
saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQDMULL instruction extracts each source vector from the lower half of each 
source register, while the SQDMULL2 instruction extracts each source vector from 
the upper half of each source register.

Vector variant
  SQDMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1261" header="Signed saturating Negate" doc_id="armv8arm" token="SQNEG">This instruction reads each vector element from the source SIMD&amp;FP register, 
negates each value, places the result into a vector, and writes the vector 
to the destination SIMD&amp;FP register. All the values in this instruction are 
signed integer values.

Scalar variant
  SQNEG &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

Vector variant
  SQNEG &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1263" header="Signed saturating Rounding Doubling Multiply returning High half" doc_id="armv8arm" token="SQRDMULH">1. By element
This instruction multiplies each vector element in the first source SIMD&amp;FP 
register by the specified vector element of the second source SIMD&amp;FP register, 
doubles the results, places the most significant half of the final results 
into a vector, and writes the vector to the destination SIMD&amp;FP register.
The results are rounded.

Scalar variant
  SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

Vector variant
  SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies the values of corresponding elements of the two 
source SIMD&amp;FP registers, doubles the results, places the most significant 
half of the final results into a vector, and writes the vector to the 
destination SIMD&amp;FP register.
The results are rounded.

Scalar variant
  SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1268" header="Signed saturating Rounding Shift Left" doc_id="armv8arm" token="SQRSHL">This instruction takes each vector element in the first source SIMD&amp;FP register, 
shifts it by a value from the least significant byte of the corresponding vector 
element of the second source SIMD&amp;FP register, places the results into a vector, 
and writes the vector to the destination SIMD&amp;FP register.
If the shift value is positive, the operation is a left shift. Otherwise, it is a 
right shift. The results are rounded. For truncated results, see SQSHL (register).

Scalar variant
  SQRSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SQRSHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1270" header="Signed saturating Rounded Shift Right Narrow" doc_id="armv8arm" token="SQRSHRN">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, saturates each shifted 
result to a value that is half the original width, puts the final result 
into a vector, and writes the vector to the lower or upper half of the 
destination SIMD&amp;FP register. All the values in this instruction are signed 
integer values. The destination vector elements are half as long as the 
source vector elements. The results are rounded. For truncated results, 
see SQSHRN, SQSHRN2.

The SQRSHRN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQRSHRN2 
instruction writes the vector to the upper half of the destination register 
without affecting the other bits of the register.

Scalar variant
  SQRSHRN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SQRSHRN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1270" header="Signed saturating Rounded Shift Right Narrow" doc_id="armv8arm" token="SQRSHRN2">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, saturates each shifted 
result to a value that is half the original width, puts the final result 
into a vector, and writes the vector to the lower or upper half of the 
destination SIMD&amp;FP register. All the values in this instruction are signed 
integer values. The destination vector elements are half as long as the 
source vector elements. The results are rounded. For truncated results, 
see SQSHRN, SQSHRN2.

The SQRSHRN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQRSHRN2 
instruction writes the vector to the upper half of the destination register 
without affecting the other bits of the register.

Vector variant
  SQRSHRN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1273" header="Signed saturating Rounded Shift Right Unsigned Narrow" doc_id="armv8arm" token="SQRSHRUN">This instruction reads each signed integer value in the vector of the 
source SIMD&amp;FP register, right shifts each value by an immediate value, 
saturates the result to an unsigned integer value that is half the 
original width, places the final result into a vector, and writes the 
vector to the destination SIMD&amp;FP register. The results are rounded. 
For truncated results, see SQSHRUN, SQSHRUN2.

The SQRSHRUN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQRSHRUN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

Scalar variant
  SQRSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SQRSHRUN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1273" header="Signed saturating Rounded Shift Right Unsigned Narrow" doc_id="armv8arm" token="SQRSHRUN2">This instruction reads each signed integer value in the vector of the 
source SIMD&amp;FP register, right shifts each value by an immediate value, 
saturates the result to an unsigned integer value that is half the 
original width, places the final result into a vector, and writes the 
vector to the destination SIMD&amp;FP register. The results are rounded. 
For truncated results, see SQSHRUN, SQSHRUN2.

The SQRSHRUN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQRSHRUN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

Vector variant
  SQRSHRUN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1276" header="Signed saturating Shift Left" doc_id="armv8arm" token="SQSHL">1. Immediate
This instruction reads each vector element in the source SIMD&amp;FP register, 
shifts each result by an immediate value, places the final result in a 
vector, and writes the vector to the destination SIMD&amp;FP register. 
The results are truncated. 

Scalar variant
  SQSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SQSHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;

2. Register
This instruction takes each element in the vector of the first source 
SIMD&amp;FP register, shifts each element by a value from the least significant 
byte of the corresponding element of the second source SIMD&amp;FP register, 
places the results in a vector, and writes the vector to the destination 
SIMD&amp;FP register.

If the shift value is positive, the operation is a left shift. Otherwise, 
it is a right shift. The results are truncated.

Scalar variant
  SQSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SQSHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1281" header="Signed saturating Shift Left Unsigned" doc_id="armv8arm" token="SQSHLU">This instruction reads each signed integer value in the vector of 
the source SIMD&amp;FP register, shifts each value by an immediate 
value, saturates the shifted result to an unsigned integer value, 
places the result in a vector, and writes the vector to the 
destination SIMD&amp;FP register. The results are truncated.

Scalar variant
  SQSHLU &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SQSHLU &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1284" header="Signed saturating Shift Right Narrow" doc_id="armv8arm" token="SQSHRN">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts and truncates each result by an immediate value, saturates 
each shifted result to a value that is half the original width, puts the 
final result into a vector, and writes the vector to the lower or upper 
half of the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values. The destination vector elements 
are half as long as the source vector elements.

The SQSHRN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQSHRN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

Scalar variant
SQSHRN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
SQSHRN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1284" header="Signed saturating Shift Right Narrow" doc_id="armv8arm" token="SQSHRN2">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts and truncates each result by an immediate value, saturates 
each shifted result to a value that is half the original width, puts the 
final result into a vector, and writes the vector to the lower or upper 
half of the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values. The destination vector elements 
are half as long as the source vector elements.

The SQSHRN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQSHRN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

Vector variant
SQSHRN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1287" header="Signed saturating Shift Right Unsigned Narrow" doc_id="armv8arm" token="SQSHRUN">This instruction reads each signed integer value in the vector of the 
source SIMD&amp;FP register, right shifts each value by an immediate value, 
saturates the result to an unsigned integer value that is half the 
original width, places the final result into a vector, and writes the 
vector to the destination SIMD&amp;FP register. The results are truncated. 

The SQSHRUN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQSHRUN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

Scalar variant
  SQSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SQSHRUN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1287" header="Signed saturating Shift Right Unsigned Narrow" doc_id="armv8arm" token="SQSHRUN2">This instruction reads each signed integer value in the vector of the 
source SIMD&amp;FP register, right shifts each value by an immediate value, 
saturates the result to an unsigned integer value that is half the 
original width, places the final result into a vector, and writes the 
vector to the destination SIMD&amp;FP register. The results are truncated. 

The SQSHRUN instruction writes the vector to the lower half of the 
destination register and clears the upper half, while the SQSHRUN2 
instruction writes the vector to the upper half of the destination 
register without affecting the other bits of the register.

Vector variant
  SQSHRUN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1290" header="Signed saturating Subtract" doc_id="armv8arm" token="SQSUB">This instruction subtracts the element values of the second source SIMD&amp;FP 
register from the corresponding element values of the first source SIMD&amp;FP 
register, places the results into a vector, and writes the vector to the
destination SIMD&amp;FP register.

Scalar variant
  SQSUB &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SQSUB &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1292" header="Signed saturating extract Narrow" doc_id="armv8arm" token="SQXTN">This instruction reads each vector element from the source SIMD&amp;FP register, 
saturates the value to half the original width, places the result into a 
vector, and writes the vector to the lower or upper half of the destination 
SIMD&amp;FP register. The destination vector elements are half as long as the 
source vector elements. All the values in this instruction are signed 
integer values.

If overflow occurs with any of the results, those results are saturated. 
If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQXTN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the SQXTN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Scalar variant
SQXTN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;

Vector variant
SQXTN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1292" header="Signed saturating extract Narrow" doc_id="armv8arm" token="SQXTN2">This instruction reads each vector element from the source SIMD&amp;FP register, 
saturates the value to half the original width, places the result into a 
vector, and writes the vector to the lower or upper half of the destination 
SIMD&amp;FP register. The destination vector elements are half as long as the 
source vector elements. All the values in this instruction are signed 
integer values.

If overflow occurs with any of the results, those results are saturated. 
If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQXTN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the SQXTN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Vector variant
SQXTN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1295" header="Signed saturating extract Unsigned Narrow" doc_id="armv8arm" token="SQXTUN">This instruction reads each signed integer value in the vector of the source 
SIMD&amp;FP register, saturates the value to an unsigned integer value that is 
half the original width, places the result into a vector, and writes the 
vector to the lower or upper half of the destination SIMD&amp;FP register. The 
destination vector elements are half as long as the source vector elements.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQXTUN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the SQXTUN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Scalar variant
  SQXTUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;

Vector variant
  SQXTUN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1295" header="Signed saturating extract Unsigned Narrow" doc_id="armv8arm" token="SQXTUN2">This instruction reads each signed integer value in the vector of the source 
SIMD&amp;FP register, saturates the value to an unsigned integer value that is 
half the original width, places the result into a vector, and writes the 
vector to the lower or upper half of the destination SIMD&amp;FP register. The 
destination vector elements are half as long as the source vector elements.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The SQXTUN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the SQXTUN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Vector variant
  SQXTUN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1298" header="Signed Rounding Halving Add" doc_id="armv8arm" token="SRHADD">This instruction adds corresponding signed integer values from the two 
source SIMD&amp;FP registers, shifts each result right one bit, places the 
results into a vector, and writes the vector to the destination SIMD&amp;FP 
register. The results are rounded.

SRHADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1300" header="Shift Right and Insert" doc_id="armv8arm" token="SRI">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each vector element by an immediate value, and inserts the 
result into the corresponding vector element in the destination SIMD&amp;FP 
register such that the new zero bits created by the shift are not inserted 
but retain their existing value. Bits shifted out of the right of each 
vector element of the source register are lost.

SRI &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</hint>
			<hint page="1303" header="Signed Rounding Shift Left" doc_id="armv8arm" token="SRSHL">This instruction takes each signed integer value in the vector of the first 
source SIMD&amp;FP register, shifts it by a value from the least significant byte 
of the corresponding element of the second source SIMD&amp;FP register, places 
the results in a vector, and writes the vector to the destination SIMD&amp;FP 
register.

If the shift value is positive, the operation is a left shift. If the shift 
value is negative, it is a rounding right shift.

SRSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="1305" header="Signed Rounding Shift Right" doc_id="armv8arm" token="SRSHR">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, places the final result 
into a vector, and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are signed integer values. 
The results are rounded.

SRSHR &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</hint>
			<hint page="1307" header="Signed Rounding Shift Right and Accumulate" doc_id="armv8arm" token="SRSRA">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, and accumulates the final 
results with the vector elements of the destination SIMD&amp;FP register. All 
the values in this instruction are signed integer values. 
The results are rounded.

SRSRA &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</hint>
			<hint page="1309" header="Signed Shift Left" doc_id="armv8arm" token="SSHL">This instruction takes each signed integer value in the vector of the first 
source SIMD&amp;FP register, shifts each value by a value from the least 
significant byte of the corresponding element of the second source SIMD&amp;FP 
register, places the results in a vector, and writes the vector to the 
destination SIMD&amp;FP register.

If the shift value is positive, the operation is a left shift. If the shift 
value is negative, it is a truncating right shift.

Scalar variant
  SSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SSHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1312" header="Signed Shift Left Long" doc_id="armv8arm" token="SSHLL">This instruction reads each vector element from the source SIMD&amp;FP register, 
left shifts each vector element by the specified shift amount, places the 
result into a vector, and writes the vector to the destination SIMD&amp;FP register. 
The destination vector elements are twice as long as the source vector elements. 
All the values in this instruction are signed integer values.

The SSHLL instruction extracts vector elements from the lower half of the source 
register, while the SSHLL2 instruction extracts vector elements from the upper 
half of the source register.

SSHLL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</hint>
			<hint page="1312" header="Signed Shift Left Long" doc_id="armv8arm" token="SSHLL2">This instruction reads each vector element from the source SIMD&amp;FP register, 
left shifts each vector element by the specified shift amount, places the 
result into a vector, and writes the vector to the destination SIMD&amp;FP register. 
The destination vector elements are twice as long as the source vector elements. 
All the values in this instruction are signed integer values.

The SSHLL instruction extracts vector elements from the lower half of the source 
register, while the SSHLL2 instruction extracts vector elements from the upper 
half of the source register.

SSHLL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</hint>
			<hint page="1313" header="Signed Shift Right" doc_id="armv8arm" token="SSHR">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, places the final result 
into a vector, and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are signed integer values. 
The results are truncated. 

Scalar variant
  SSHR &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SSHR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1315" header="Signed Shift Right and Accumulate" doc_id="armv8arm" token="SSRA">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, and accumulates the final 
results with the vector elements of the destination SIMD&amp;FP register. All 
the values in this instruction are signed integer values. 
The results are truncated.

Scalar variant
  SSRA &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  SSRA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1317" header="Signed Subtract Long" doc_id="armv8arm" token="SSUBL">This instruction subtracts each vector element in the lower or upper half of 
the second source SIMD&amp;FP register from the corresponding vector element of 
the first source SIMD&amp;FP register, places the results into a vector, and writes 
the vector to the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values. The destination vector elements are 
twice as long as the source vector elements.

The SSUBL instruction extracts each source vector from the lower half of each 
source register, while the SSUBL2 instruction extracts each source vector from 
the upper half of each source register.

SSUBL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1317" header="Signed Subtract Long" doc_id="armv8arm" token="SSUBL2">This instruction subtracts each vector element in the lower or upper half of 
the second source SIMD&amp;FP register from the corresponding vector element of 
the first source SIMD&amp;FP register, places the results into a vector, and writes 
the vector to the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values. The destination vector elements are 
twice as long as the source vector elements.

The SSUBL instruction extracts each source vector from the lower half of each 
source register, while the SSUBL2 instruction extracts each source vector from 
the upper half of each source register.

SSUBL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1319" header="Signed Subtract Wide" doc_id="armv8arm" token="SSUBW">This instruction subtracts each vector element in the lower or upper half of 
the second source SIMD&amp;FP register from the corresponding vector element in 
the first source SIMD&amp;FP register, places the result in a vector, and writes 
the vector to the SIMD&amp;FP destination register. All the values in this 
instruction are signed integer values.

The SSUBW instruction extracts the second source vector from the lower half 
of the second source register, while the SSUBW2 instruction extracts the 
second source vector from the upper half of the second source register.

SSUBW &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1319" header="Signed Subtract Wide" doc_id="armv8arm" token="SSUBW2">This instruction subtracts each vector element in the lower or upper half of 
the second source SIMD&amp;FP register from the corresponding vector element in 
the first source SIMD&amp;FP register, places the result in a vector, and writes 
the vector to the SIMD&amp;FP destination register. All the values in this 
instruction are signed integer values.

The SSUBW instruction extracts the second source vector from the lower half 
of the second source register, while the SSUBW2 instruction extracts the 
second source vector from the upper half of the second source register.

SSUBW2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1321" header="Store single-element structures from one, two, three, or four registers" doc_id="armv8arm" token="ST1">1. Multiple structures
This instruction stores elements to memory from one, two, three, or four SIMD&amp;FP 
registers, without interleaving. Every element of each register is stored.

No offset:
  One register variant:    ST1 { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
  Two registers variant:   ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
  Three registers variant: ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]
  Four registers variant:  ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  One register, immediate offset variant:    ST1 { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  One register, register offset variant:     ST1 { &lt;Vt&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;
  Two registers, immediate offset variant:   ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Two registers, register offset variant:    ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;
  Three registers, immediate offset variant: ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Three registers, register offset variant:  ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;
  Four registers, immediate offset variant:  ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Four registers, register offset variant:   ST1 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;

2. Single structure
This instruction stores the specified element of a SIMD&amp;FP register to memory.

No offset:
  8-bit variant:  ST1 { &lt;Vt&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant: ST1 { &lt;Vt&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: ST1 { &lt;Vt&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: ST1 { &lt;Vt&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
  8-bit, immediate offset variant:  ST1 { &lt;Vt&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #1
  8-bit, register offset variant:   ST1 { &lt;Vt&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: ST1 { &lt;Vt&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #2
  16-bit, register offset variant:  ST1 { &lt;Vt&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: ST1 { &lt;Vt&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #4
  32-bit, register offset variant:  ST1 { &lt;Vt&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: ST1 { &lt;Vt&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #8
  64-bit, register offset variant:  ST1 { &lt;Vt&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1329" header="Store 2-element structures from two registers" doc_id="armv8arm" token="ST2">1. Multiple structures
This instruction stores multiple 2-element structures from two SIMD&amp;FP registers 
to memory, with interleaving. Every element of each register is stored.

No offset:
  ST2 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: ST2 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  ST2 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;


2. Single structure
This instruction stores a 2-element structure to memory from corresponding elements 
of two SIMD&amp;FP registers.

No offset:
  8-bit variant:  ST2 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant: ST2 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: ST2 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: ST2 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
  8-bit, immediate offset variant:  ST2 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #2
  8-bit, register offset variant:   ST2 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: ST2 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #4
  16-bit, register offset variant:  ST2 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: ST2 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #8
  32-bit, register offset variant:  ST2 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: ST2 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #16
  64-bit, register offset variant:  ST2 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1336" header="Store 3-element structures from three registers" doc_id="armv8arm" token="ST3">1. Multiple structures
This instruction stores multiple 3-element structures to memory from three SIMD&amp;FP registers, 
with interleaving. Every element of each register is stored.

No offset:
  ST3 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: ST3 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant:  ST3 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;


2. Single structure
This instruction stores a 3-element structure to memory from corresponding elements of three 
SIMD&amp;FP registers.

No offset:
  8-bit variant:  ST3 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  16-bit variant: ST3 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  32-bit variant: ST3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: ST3 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
  8-bit, immediate offset variant:  ST3 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #3
  8-bit, register offset variant:   ST3 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: ST3 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #6
  16-bit, register offset variant:  ST3 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: ST3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #12
  32-bit, register offset variant:  ST3 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: ST3 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #24
  64-bit, register offset variant:  ST3 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1343" header="Store 4-element structures from four registers" doc_id="armv8arm" token="ST4">1. Multiple structures
This instruction stores multiple 4-element structures to memory from four SIMD&amp;FP registers, 
with interleaving. Every element of each register is stored.

No offset:
  ST4 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;]

Post-index:
  Immediate offset variant: ST4 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;imm&gt;
  Register offset variant: ST4 { &lt;Vt&gt;.&lt;T&gt;, &lt;Vt2&gt;.&lt;T&gt;, &lt;Vt3&gt;.&lt;T&gt;, &lt;Vt4&gt;.&lt;T&gt; }, [&lt;Xn|SP&gt;], &lt;Xm&gt;

2. Single structure
This instruction stores a 4-element structure to memory from corresponding elements of four 
SIMD&amp;FP registers.

No offset:
  8-bit variant:  ST4 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B, &lt;Vt4&gt;.B }[&lt;index&gt;],
  16-bit variant: ST4 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H, &lt;Vt4&gt;.H }[&lt;index&gt;],
  32-bit variant: ST4 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S, &lt;Vt4&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;]
  64-bit variant: ST4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;]

Post-index:
  8-bit, immediate offset variant:  ST4 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B, &lt;Vt4&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], #4
  8-bit, register offset variant:   ST4 { &lt;Vt&gt;.B, &lt;Vt2&gt;.B, &lt;Vt3&gt;.B, &lt;Vt4&gt;.B }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  16-bit, immediate offset variant: ST4 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H, &lt;Vt4&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], #8
  16-bit, register offset variant:  ST4 { &lt;Vt&gt;.H, &lt;Vt2&gt;.H, &lt;Vt3&gt;.H, &lt;Vt4&gt;.H }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  32-bit, immediate offset variant: ST4 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S, &lt;Vt4&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], #16
  32-bit, register offset variant:  ST4 { &lt;Vt&gt;.S, &lt;Vt2&gt;.S, &lt;Vt3&gt;.S, &lt;Vt4&gt;.S }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;
  64-bit, immediate offset variant: ST4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], #32
  64-bit, register offset variant:  ST4 { &lt;Vt&gt;.D, &lt;Vt2&gt;.D, &lt;Vt3&gt;.D, &lt;Vt4&gt;.D }[&lt;index&gt;], [&lt;Xn|SP&gt;], &lt;Xm&gt;</hint>
			<hint page="1350" header="Store Pair of SIMD&amp;FP registers, with Non-temporal hint" doc_id="armv8arm" token="STNP">This instruction stores a pair of SIMD&amp;FP registers to memory, issuing a hint 
to the memory system that the access is non-temporal. The address used for the 
store is calculated from an address from a base register value and an immediate 
offset.

32-bit variant
  STNP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
64-bit variant
  STNP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
128-bit variant
  STNP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="1352" header="Store Pair of SIMD&amp;FP registers" doc_id="armv8arm" token="STP">This instruction stores a pair of SIMD&amp;FP registers to memory. The address used 
for the store is calculated from a base register value and an immediate offset.

Post-index:
  32-bit variant:  STP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;
  64-bit variant:  STP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;
  128-bit variant: STP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;

Pre-index:
  32-bit variant:  STP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!
  64-bit variant:  STP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!
  128-bit variant: STP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!

Signed offset:
  32-bit variant:  STP &lt;St1&gt;, &lt;St2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
  64-bit variant:  STP &lt;Dt1&gt;, &lt;Dt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
  128-bit variant: STP &lt;Qt1&gt;, &lt;Qt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</hint>
			<hint page="1355" header="Store SIMD&amp;FP register" doc_id="armv8arm" token="STR">1. Immediate
This instruction stores a single SIMD&amp;FP register to memory. The address 
that is used for the store is calculated from a base register value and 
an immediate offset.

Post-index:
  8-bit variant:   STR &lt;Bt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  16-bit variant:  STR &lt;Ht&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  32-bit variant:  STR &lt;St&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  64-bit variant:  STR &lt;Dt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;
  128-bit variant: STR &lt;Qt&gt;, [&lt;Xn|SP&gt;], #&lt;simm&gt;

Pre-index:
  8-bit variant:   STR &lt;Bt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  16-bit variant:  STR &lt;Ht&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  32-bit variant:  STR &lt;St&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  64-bit variant:  STR &lt;Dt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!
  128-bit variant: STR &lt;Qt&gt;, [&lt;Xn|SP&gt;, #&lt;simm&gt;]!

Unsigned offset:
  8-bit variant:   STR &lt;Bt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  16-bit variant:  STR &lt;Ht&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  32-bit variant:  STR &lt;St&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  64-bit variant:  STR &lt;Dt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]
  128-bit variant: STR &lt;Qt&gt;, [&lt;Xn|SP&gt;{, #&lt;pimm&gt;}]

2. Register
This instruction stores a single SIMD&amp;FP register to memory. The address that is used 
for the store is calculated from a base register value and an offset register value. 
The offset can be optionally shifted and extended.

8-bit variant:   STR &lt;Bt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;), &lt;extend&gt; {&lt;amount&gt;}]
8-bit variant:   STR &lt;Bt&gt;, [&lt;Xn|SP&gt;, &lt;Xm&gt;{, LSL &lt;amount&gt;}]
16-bit variant:  STR &lt;Ht&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]
32-bit variant:  STR &lt;St&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]
64-bit variant:  STR &lt;Dt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]
128-bit variant: STR &lt;Qt&gt;, [&lt;Xn|SP&gt;, (&lt;Wm&gt;|&lt;Xm&gt;){, &lt;extend&gt; {&lt;amount&gt;}}]</hint>
			<hint page="1362" header="Store SIMD&amp;FP register (unscaled offset)" doc_id="armv8arm" token="STUR">This instruction stores a single SIMD&amp;FP register to memory. The address that 
is used for the store is calculated from a base register value and an optional 
immediate offset.

8-bit variant: 
  STUR &lt;Bt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
16-bit variant
  STUR &lt;Ht&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
32-bit variant
  STUR &lt;St&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
64-bit variant
  STUR &lt;Dt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]
128-bit variant
  STUR &lt;Qt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</hint>
			<hint page="1364" header="Subtract (vector)" doc_id="armv8arm" token="SUB">This instruction subtracts each vector element in the second source SIMD&amp;FP register 
from the corresponding vector element in the first source SIMD&amp;FP register, places 
the result into a vector, and writes the vector to the destination SIMD&amp;FP register.

Scalar variant
  SUB &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  SUB &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1366" header="Subtract returning High Narrow" doc_id="armv8arm" token="SUBHN">This instruction subtracts each vector element in the second source SIMD&amp;FP register 
from the corresponding vector element in the first source SIMD&amp;FP register, places 
the most significant half of the result into a vector, and writes the vector to the 
lower or upper half of the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values. The results are truncated.

The SUBHN instruction writes the vector to the lower half of the destination register 
and clears the upper half, while the SUBHN2 instruction writes the vector to the upper 
half of the destination register without affecting the other bits of the register.

Three registers, not all the same type variant
SUBHN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1366" header="Subtract returning High Narrow" doc_id="armv8arm" token="SUBHN2">This instruction subtracts each vector element in the second source SIMD&amp;FP register 
from the corresponding vector element in the first source SIMD&amp;FP register, places 
the most significant half of the result into a vector, and writes the vector to the 
lower or upper half of the destination SIMD&amp;FP register. All the values in this 
instruction are signed integer values. The results are truncated.

The SUBHN instruction writes the vector to the lower half of the destination register 
and clears the upper half, while the SUBHN2 instruction writes the vector to the upper 
half of the destination register without affecting the other bits of the register.

Three registers, not all the same type variant
SUBHN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1368" header="Signed saturating Accumulate of Unsigned value" doc_id="armv8arm" token="SUQADD">This instruction adds the unsigned integer values of the vector elements in the 
source SIMD&amp;FP register to corresponding signed integer values of the vector 
elements in the destination SIMD&amp;FP register, and writes the resulting signed 
integer values to the destination SIMD&amp;FP register.

Scalar variant
  SUQADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

Vector variant
  SUQADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1370" header="Signed extend Long" doc_id="armv8arm" token="SXTL">This instruction duplicates each vector element in the lower or upper half of the 
source SIMD&amp;FP register into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the source 
vector elements. All the values in this instruction are signed integer values.

The SXTL instruction extracts the source vector from the lower half of the source 
register, while the SXTL2 instruction extracts the source vector from the upper 
half of the source register.

SXTL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;

  is equivalent to

SSHLL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</hint>
			<hint page="1370" header="Signed extend Long" doc_id="armv8arm" token="SXTL2">This instruction duplicates each vector element in the lower or upper half of the 
source SIMD&amp;FP register into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the source 
vector elements. All the values in this instruction are signed integer values.

The SXTL instruction extracts the source vector from the lower half of the source 
register, while the SXTL2 instruction extracts the source vector from the upper 
half of the source register.

SXTL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;

  is equivalent to

SSHLL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</hint>
			<hint page="1372" header="Table vector Lookup" doc_id="armv8arm" token="TBL">This instruction reads each value from the vector elements in the index 
source SIMD&amp;FP register, uses each result as an index to perform a lookup 
in a table of bytes that is described by one to four source table SIMD&amp;FP 
registers, places the lookup result in a vector, and writes the vector to 
the destination SIMD&amp;FP register. If an index is out of range for the table, 
the result for that lookup is 0. If more than one source register is used 
to describe the table, the first source register describes the lowest bytes 
of the table.

Two register table variant
  TBL &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B, &lt;Vn+1&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;

Three register table variant
  TBL &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B, &lt;Vn+1&gt;.16B, &lt;Vn+2&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;

Four register table variant
  TBL &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B, &lt;Vn+1&gt;.16B, &lt;Vn+2&gt;.16B, &lt;Vn+3&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;

Single register table variant
  TBL &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1374" header="Table vector lookup extension" doc_id="armv8arm" token="TBX">This instruction reads each value from the vector elements in the index 
source SIMD&amp;FP register, uses each result as an index to perform a lookup 
in a table of bytes that is described by one to four source table SIMD&amp;FP 
registers, places the lookup result in a vector, and writes the vector to 
the destination SIMD&amp;FP register. If an index is out of range for the table, 
the existing value in the vector element of the destination register is 
left unchanged. If more than one source register is used to describe the 
table, the first source register describes the lowest bytes of the table.

Two register table variant
  TBX &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B, &lt;Vn+1&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;

Three register table variant
  TBX &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B, &lt;Vn+1&gt;.16B, &lt;Vn+2&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;

Four register table variant
  TBX &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B, &lt;Vn+1&gt;.16B, &lt;Vn+2&gt;.16B, &lt;Vn+3&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;

Single register table variant
  TBX &lt;Vd&gt;.&lt;Ta&gt;, { &lt;Vn&gt;.16B }, &lt;Vm&gt;.&lt;Ta&gt;</hint>
			<hint page="1376" header="Transpose vectors (primary)" doc_id="armv8arm" token="TRN1">This instruction reads corresponding even-numbered vector elements from the two 
source SIMD&amp;FP registers, starting at zero, places each result into consecutive 
elements of a vector, and writes the vector to the destination SIMD&amp;FP register. 
Vector elements from the first source register are placed into even-numbered 
elements of the destination vector, starting at zero, while vector elements from 
the second source register are placed into odd-numbered elements of the 
destination vector.

TRN1 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1378" header="Transpose vectors (secondary)" doc_id="armv8arm" token="TRN2">This instruction reads corresponding odd-numbered vector elements from the two 
source SIMD&amp;FP registers, places each result into consecutive elements of a 
vector, and writes the vector to the destination SIMD&amp;FP register. Vector 
elements from the first source register are placed into even-numbered elements 
of the destination vector, starting at zero, while vector elements from the 
second source register are placed into odd-numbered elements of the destination 
vector.

TRN2 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1380" header="Unsigned Absolute difference and Accumulate" doc_id="armv8arm" token="UABA">This instruction subtracts the elements of the vector of the second 
source SIMD&amp;FP register from the corresponding elements of the first 
source SIMD&amp;FP register, and accumulates the absolute values of the 
results into the elements of the vector of the destination SIMD&amp;FP 
register.

UABA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1382" header="Unsigned Absolute difference and Accumulate Long" doc_id="armv8arm" token="UABAL">This instruction subtracts the vector elements in the lower or upper half of the 
second source SIMD&amp;FP register from the corresponding vector elements of the first 
source SIMD&amp;FP register, and accumulates the absolute values of the results into 
the vector elements of the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the source vector elements. All the values in this 
instruction are unsigned integer values.

The UABAL instruction extracts each source vector from the lower half of each 
source register, while the UABAL2 instruction extracts each source vector from 
the upper half of each source register.

UABAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1382" header="Unsigned Absolute difference and Accumulate Long" doc_id="armv8arm" token="UABAL2">This instruction subtracts the vector elements in the lower or upper half of the 
second source SIMD&amp;FP register from the corresponding vector elements of the first 
source SIMD&amp;FP register, and accumulates the absolute values of the results into 
the vector elements of the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the source vector elements. All the values in this 
instruction are unsigned integer values.

The UABAL instruction extracts each source vector from the lower half of each 
source register, while the UABAL2 instruction extracts each source vector from 
the upper half of each source register.

UABAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1384" header="Unsigned Absolute Difference (vector)" doc_id="armv8arm" token="UABD">This instruction subtracts the elements of the vector of the second 
source SIMD&amp;FP register from the corresponding elements of the first 
source SIMD&amp;FP register, places the absolute values of the results 
into a vector, and writes the vector to the destination SIMD&amp;FP 
register.

UABD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1386" header="Unsigned Absolute Difference Long" doc_id="armv8arm" token="UABDL">This instruction subtracts the vector elements in the lower or upper half of the 
second source SIMD&amp;FP register from the corresponding vector elements of the first 
source SIMD&amp;FP register, places the absolute value of the result into a vector, 
and writes the vector to the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the source vector elements. All the values in this 
instruction are unsigned integer values.

The UABDL instruction extracts each source vector from the lower half of each 
source register, while the UABDL2 instruction extracts each source vector from 
the upper half of each source register.

UABDL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1386" header="Unsigned Absolute Difference Long" doc_id="armv8arm" token="UABDL2">This instruction subtracts the vector elements in the lower or upper half of the 
second source SIMD&amp;FP register from the corresponding vector elements of the first 
source SIMD&amp;FP register, places the absolute value of the result into a vector, 
and writes the vector to the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the source vector elements. All the values in this 
instruction are unsigned integer values.

The UABDL instruction extracts each source vector from the lower half of each 
source register, while the UABDL2 instruction extracts each source vector from 
the upper half of each source register.

UABDL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1388" header="Unsigned Add and Accumulate Long Pairwise" doc_id="armv8arm" token="UADALP">This instruction adds pairs of adjacent unsigned integer values from the vector 
in the source SIMD&amp;FP register and accumulates the results with the vector 
elements of the destination SIMD&amp;FP register. The destination vector elements 
are twice as long as the source vector elements.

UADALP &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</hint>
			<hint page="1390" header="Unsigned Add Long (vector)" doc_id="armv8arm" token="UADDL">This instruction adds each vector element in the lower or upper half of the first 
source SIMD&amp;FP register to the corresponding vector element of the second source 
SIMD&amp;FP register, places the result into a vector, and writes the vector to the 
destination SIMD&amp;FP register. The destination vector elements are twice as long 
as the source vector elements. All the values in this instruction are unsigned 
integer values.

The UADDL instruction extracts each source vector from the lower half of each 
source register, while the UADDL2 instruction extracts each source vector from 
the upper half of each source register.

UADDL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1390" header="Unsigned Add Long (vector)" doc_id="armv8arm" token="UADDL2">This instruction adds each vector element in the lower or upper half of the first 
source SIMD&amp;FP register to the corresponding vector element of the second source 
SIMD&amp;FP register, places the result into a vector, and writes the vector to the 
destination SIMD&amp;FP register. The destination vector elements are twice as long 
as the source vector elements. All the values in this instruction are unsigned 
integer values.

The UADDL instruction extracts each source vector from the lower half of each 
source register, while the UADDL2 instruction extracts each source vector from 
the upper half of each source register.

UADDL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1392" header="Unsigned Add Long Pairwise" doc_id="armv8arm" token="UADDLP">This instruction adds pairs of adjacent unsigned integer values from the 
vector in the source SIMD&amp;FP register, places the result into a vector, 
and writes the vector to the destination SIMD&amp;FP register. The destination 
vector elements are twice as long as the source vector elements.

UADDLP &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</hint>
			<hint page="1394" header="Unsigned sum Long across Vector" doc_id="armv8arm" token="UADDLV">This instruction adds every vector element in the source SIMD&amp;FP register together, 
and writes the scalar result to the destination SIMD&amp;FP register. The destination 
scalar is twice as long as the source vector elements. All the values in this 
instruction are unsigned integer values.

UADDLV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1396" header="Unsigned Add Wide" doc_id="armv8arm" token="UADDW, UADDW2">This instruction adds the vector elements of the first source SIMD&amp;FP register 
to the corresponding vector elements in the lower or upper half of the second 
source SIMD&amp;FP register, places the result in a vector, and writes the vector 
to the SIMD&amp;FP destination register. The vector elements of the destination 
register and the first source register are twice as long as the vector elements 
of the second source register. All the values in this instruction are unsigned 
integer values.

The UADDW instruction extracts vector elements from the lower half of the second 
source register, while the UADDW2 instruction extracts vector elements from the 
upper half of the second source register.

UADDW &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1396" header="Unsigned Add Wide" doc_id="armv8arm" token="UADDW2">This instruction adds the vector elements of the first source SIMD&amp;FP register 
to the corresponding vector elements in the lower or upper half of the second 
source SIMD&amp;FP register, places the result in a vector, and writes the vector 
to the SIMD&amp;FP destination register. The vector elements of the destination 
register and the first source register are twice as long as the vector elements 
of the second source register. All the values in this instruction are unsigned 
integer values.

The UADDW instruction extracts vector elements from the lower half of the second 
source register, while the UADDW2 instruction extracts vector elements from the 
upper half of the second source register.

UADDW2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1398" header="Unsigned Convert to Floating-point" doc_id="armv8arm" token="UCVTF">1. Fixed-point (vector)
This instruction converts each element in a vector from fixed-point to floating-point 
using the rounding mode that is specified by the FPCR, and writes the result to the 
SIMD&amp;FP destination register.

Scalar variant
  UCVTF &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;fbits&gt;
Vector variant
  UCVTF &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;fbits&gt;

2. Integer (vector)
This instruction converts each element in a vector from an unsigned integer value to a 
floating-point value using the rounding mode that is specified by the FPCR, and writes 
the result to the SIMD&amp;FP destination register.

Scalar variant
  UCVTF &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;
Vector variant
  UCVTF &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;


3. Fixed-paint (scalar)
This instruction converts the unsigned value in the 32-bit or 64-bit general-purpose 
source register to a floating-point value using the rounding mode that is specified 
by the FPCR, and writes the result to the SIMD&amp;FP destination register.

32-bit to single-precision variant: UCVTF &lt;Sd&gt;, &lt;Wn&gt;, #&lt;fbits&gt;
32-bit to double-precision variant: UCVTF &lt;Dd&gt;, &lt;Wn&gt;, #&lt;fbits&gt;
64-bit to single-precision variant: UCVTF &lt;Sd&gt;, &lt;Xn&gt;, #&lt;fbits&gt;
64-bit to double-precision variant: UCVTF &lt;Dd&gt;, &lt;Xn&gt;, #&lt;fbits&gt;


4. Integer (scalar)
This instruction converts the unsigned integer value in the general-purpose source 
register to a floating-point value using the rounding mode that is specified by the 
FPCR, and writes the result to the SIMD&amp;FP destination register.

32-bit to single-precision variant: UCVTF &lt;Sd&gt;, &lt;Wn&gt;
32-bit to double-precision variant: UCVTF &lt;Dd&gt;, &lt;Wn&gt;
64-bit to single-precision variant: UCVTF &lt;Sd&gt;, &lt;Xn&gt;
64-bit to double-precision variant: UCVTF &lt;Dd&gt;, &lt;Xn&gt;</hint>
			<hint page="1407" header="Unsigned Halving Add" doc_id="armv8arm" token="UHADD">This instruction adds corresponding unsigned integer values from the two 
source SIMD&amp;FP registers, shifts each result right one bit, places the 
results into a vector, and writes the vector to the destination SIMD&amp;FP 
register.

UHADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1409" header="Unsigned Halving Subtract" doc_id="armv8arm" token="UHSUB">This instruction subtracts the vector elements in the second source SIMD&amp;FP 
register from the corresponding vector elements in the first source SIMD&amp;FP 
register, shifts each result right one bit, places each result into a vector, 
and writes the vector to the destination SIMD&amp;FP register.

UHSUB &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1411" header="Unsigned Maximum (vector)." doc_id="armv8arm" token="UMAX">This instruction compares corresponding elements in the vectors 
in the two source SIMD&amp;FP registers, places the larger of each 
pair of unsigned integer values into a vector, and writes the 
vector to the destination SIMD&amp;FP register.

UMAX &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1413" header="Unsigned Maximum Pairwise" doc_id="armv8arm" token="UMAXP">This instruction creates a vector by concatenating the vector elements of the first 
source SIMD&amp;FP register after the vector elements of the second source SIMD&amp;FP 
register, reads each pair of adjacent vector elements in the two source SIMD&amp;FP 
registers, writes the largest of each pair of unsigned integer values into a vector, 
and writes the vector to the destination SIMD&amp;FP register.

UMAXP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1415" header="Unsigned Maximum across Vector" doc_id="armv8arm" token="UMAXV">This instruction compares all the vector elements in the source SIMD&amp;FP register, 
and writes the largest of the values as a scalar to the destination SIMD&amp;FP 
register. All the values in this instruction are unsigned integer values.

UMAXV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1417" header="Unsigned Minimum (vector)" doc_id="armv8arm" token="UMIN">This instruction compares corresponding vector elements in the two source SIMD&amp;FP 
registers, places the smaller of each of the two unsigned integer values into a 
vector, and writes the vector to the destination SIMD&amp;FP register.

UMIN &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1419" header="Unsigned Minimum Pairwise" doc_id="armv8arm" token="UMINP">This instruction creates a vector by concatenating the vector elements of the 
first source SIMD&amp;FP register after the vector elements of the second source 
SIMD&amp;FP register, reads each pair of adjacent vector elements in the two source 
SIMD&amp;FP registers, writes the smallest of each pair of unsigned integer values 
into a vector, and writes the vector to the destination SIMD&amp;FP register.

UMINP &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1421" header="Unsigned Minimum across Vector" doc_id="armv8arm" token="UMINV">This instruction compares all the vector elements in the source SIMD&amp;FP register, 
and writes the smallest of the values as a scalar to the destination SIMD&amp;FP 
register. All the values in this instruction are unsigned integer values.

UMINV &lt;V&gt;&lt;d&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1423" header="Unsigned Multiply-Add Long" doc_id="armv8arm" token="UMLAL">1. By element
This instruction multiplies each vector element in the lower or upper half of the first 
source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP 
register and accumulates the results with the vector elements of the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the elements 
that are multiplied.

UMLAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies the vector elements in the lower or upper half of the first 
source SIMD&amp;FP register by the corresponding vector elements of the second source SIMD&amp;FP 
register, and accumulates the results with the vector elements of the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the elements 
that are multiplied.

UMLAL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1423" header="Unsigned Multiply-Add Long" doc_id="armv8arm" token="UMLAL2">1. By element
This instruction multiplies each vector element in the lower or upper half of the first 
source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP 
register and accumulates the results with the vector elements of the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the elements 
that are multiplied.

UMLAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies the vector elements in the lower or upper half of the first 
source SIMD&amp;FP register by the corresponding vector elements of the second source SIMD&amp;FP 
register, and accumulates the results with the vector elements of the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the elements 
that are multiplied.

UMLAL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1428" header="Unsigned Multiply-Subtract Long" doc_id="armv8arm" token="UMLSL">1. By element
This instruction multiplies each vector element in the lower or upper half of the first 
source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP 
register and subtracts the results from the vector elements of the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the elements 
that are multiplied.

UMLSL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding vector elements in the lower or upper half 
of the two source SIMD&amp;FP registers, and subtracts the results from the vector 
elements of the destination SIMD&amp;FP register. The destination vector elements are 
twice as long as the elements that are multiplied. All the values in this instruction 
are unsigned integer values.

UMLSL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1428" header="Unsigned Multiply-Subtract Long" doc_id="armv8arm" token="UMLSL2">1. By element
This instruction multiplies each vector element in the lower or upper half of the first 
source SIMD&amp;FP register by the specified vector element of the second source SIMD&amp;FP 
register and subtracts the results from the vector elements of the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the elements 
that are multiplied.

UMLSL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]

2. Vector
This instruction multiplies corresponding vector elements in the lower or upper half 
of the two source SIMD&amp;FP registers, and subtracts the results from the vector 
elements of the destination SIMD&amp;FP register. The destination vector elements are 
twice as long as the elements that are multiplied. All the values in this instruction 
are unsigned integer values.

UMLSL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1433" header="Unsigned Move vector element to general-purpose register" doc_id="armv8arm" token="UMOV">This instruction reads the unsigned integer from the source SIMD&amp;FP register, 
zero-extends it to form a 32-bit or 64-bit value, and writes the result to 
the destination general-purpose register.

32-bit variant
  UMOV &lt;Wd&gt;, &lt;Vn&gt;.&lt;Ts&gt;[&lt;index&gt;]

64-bit variant
  UMOV &lt;Xd&gt;, &lt;Vn&gt;.&lt;Ts&gt;[&lt;index&gt;]</hint>
			<hint page="1435" header="Unsigned Multiply Long" doc_id="armv8arm" token="UMULL">1. By element
This instruction multiplies each vector element in the lower or upper half of the 
first source SIMD&amp;FP register by the specified vector element of the second source 
SIMD&amp;FP register, places the results in a vector, and writes the vector to the 
destination SIMD&amp;FP register. The destination vector elements are twice as long 
as the elements that are multiplied.

UMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]


2. Vector
This instruction multiplies corresponding vector elements in the lower or upper 
half of the two source SIMD&amp;FP registers, places the result in a vector, and 
writes the vector to the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the elements that are multiplied. All the values 
in this instruction are unsigned integer values.

UMULL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1435" header="Unsigned Multiply Long" doc_id="armv8arm" token="UMULL2">1. By element
This instruction multiplies each vector element in the lower or upper half of the 
first source SIMD&amp;FP register by the specified vector element of the second source 
SIMD&amp;FP register, places the results in a vector, and writes the vector to the 
destination SIMD&amp;FP register. The destination vector elements are twice as long 
as the elements that are multiplied.

UMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]


2. Vector
This instruction multiplies corresponding vector elements in the lower or upper 
half of the two source SIMD&amp;FP registers, places the result in a vector, and 
writes the vector to the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the elements that are multiplied. All the values 
in this instruction are unsigned integer values.

UMULL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1439" header="Unsigned saturating Add" doc_id="armv8arm" token="UQADD">This instruction adds the values of corresponding elements of the two source 
SIMD&amp;FP registers, places the results into a vector, and writes the vector to 
the destination SIMD&amp;FP register.

UQADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="1441" header="Unsigned saturating Rounding Shift Left" doc_id="armv8arm" token="UQRSHL">This instruction takes each vector element of the first source SIMD&amp;FP register, 
shifts the vector element by a value from the least significant byte of the 
corresponding vector element of the second source SIMD&amp;FP register, places the 
results into a vector, and writes the vector to the destination SIMD&amp;FP register.

UQRSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="1443" header="Unsigned saturating Rounded Shift Right Narrow" doc_id="armv8arm" token="UQRSHRN">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, puts the final result into 
a vector, and writes the vector to the lower or upper half of the destination 
SIMD&amp;FP register. All the values in this instruction are unsigned integer 
values. The results are rounded.

Scalar variant
  UQRSHRN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  UQRSHRN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1443" header="Unsigned saturating Rounded Shift Right Narrow" doc_id="armv8arm" token="UQRSHRN2">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, puts the final result into 
a vector, and writes the vector to the lower or upper half of the destination 
SIMD&amp;FP register. All the values in this instruction are unsigned integer 
values. The results are rounded.

Vector variant
  UQRSHRN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1446" header="Unsigned saturating Shift Left" doc_id="armv8arm" token="UQSHL">1. Immediate
This instruction takes each vector element in the source SIMD&amp;FP register, 
shifts it by an immediate value, places the results in a vector, and writes 
the vector to the destination SIMD&amp;FP register. The results are truncated.

Scalar variant
  UQSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  UQSHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;

2. Register
This instruction takes each element in the vector of the first source SIMD&amp;FP 
register, shifts the element by a value from the least significant byte of 
the corresponding element of the second source SIMD&amp;FP register, places the 
results in a vector, and writes the vector to the destination SIMD&amp;FP register.

Scalar variant
  UQSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  UQSHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1451" header="Unsigned saturating Shift Right Narrow" doc_id="armv8arm" token="UQSHRN">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, saturates each shifted result 
to a value that is half the original width, puts the final result into a vector, 
and writes the vector to the lower or upper half of the destination SIMD&amp;FP 
register. All the values in this instruction are unsigned integer values. 
The results are truncated.

Scalar variant
  UQSHRN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  UQSHRN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1451" header="Unsigned saturating Shift Right Narrow" doc_id="armv8arm" token="UQSHRN2">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, saturates each shifted result 
to a value that is half the original width, puts the final result into a vector, 
and writes the vector to the lower or upper half of the destination SIMD&amp;FP 
register. All the values in this instruction are unsigned integer values. 
The results are truncated.

Vector variant
  UQSHRN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</hint>
			<hint page="1454" header="Unsigned saturating Subtract." doc_id="armv8arm" token="UQSUB">This instruction subtracts the element values of the second source SIMD&amp;FP 
register from the corresponding element values of the first source SIMD&amp;FP 
register, places the results into a vector, and writes the vector to the 
destination SIMD&amp;FP register.

UQSUB &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="1456" header="Unsigned saturating extract Narrow" doc_id="armv8arm" token="UQXTN">This instruction reads each vector element from the source SIMD&amp;FP register, 
saturates each value to half the original width, places the result into a 
vector, and writes the vector to the destination SIMD&amp;FP register. All the 
values in this instruction are unsigned integer values.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The UQXTN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the UQXTN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Scalar variant
  UQXTN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;

Vector variant
  UQXTN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1456" header="Unsigned saturating extract Narrow" doc_id="armv8arm" token="UQXTN2">This instruction reads each vector element from the source SIMD&amp;FP register, 
saturates each value to half the original width, places the result into a 
vector, and writes the vector to the destination SIMD&amp;FP register. All the 
values in this instruction are unsigned integer values.

If saturation occurs, the cumulative saturation bit FPSR.QC is set.

The UQXTN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the UQXTN2 instruction writes the 
vector to the upper half of the destination register without affecting the 
other bits of the register.

Vector variant
  UQXTN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1459" header="Unsigned Reciprocal Estimate" doc_id="armv8arm" token="URECPE">This instruction reads each vector element from the source SIMD&amp;FP register, 
calculates an approximate inverse for the unsigned integer value, places the 
result into a vector, and writes the vector to the destination SIMD&amp;FP register.

URECPE &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1460" header="Unsigned Rounding Halving Add" doc_id="armv8arm" token="URHADD">This instruction adds corresponding unsigned integer values from the two 
source SIMD&amp;FP registers, shifts each result right one bit, places the 
results into a vector, and writes the vector to the destination SIMD&amp;FP 
register.

URHADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1462" header="Unsigned Rounding Shift Left" doc_id="armv8arm" token="URSHL">This instruction takes each element in the vector of the first source 
SIMD&amp;FP register, shifts the vector element by a value from the least 
significant byte of the corresponding element of the second source 
SIMD&amp;FP register, places the results in a vector, and writes 
the vector to the destination SIMD&amp;FP register.

URSHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</hint>
			<hint page="1464" header="Unsigned Rounding Shift Right" doc_id="armv8arm" token="URSHR">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, writes the final result to 
a vector, and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are unsigned integer values. 
The results are rounded.

Scalar variant
  URSHR &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  URSHR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1466" header="Unsigned Reciprocal Square Root Estimate" doc_id="armv8arm" token="URSQRTE">This instruction reads each vector element from the source 
SIMD&amp;FP register, calculates an approximate inverse square 
root for each value, places the result into a vector, and 
writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are unsigned integer 
values.

URSQRTE &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1467" header="Unsigned Rounding Shift Right and Accumulate" doc_id="armv8arm" token="URSRA">This instruction reads each vector element in the source 
SIMD&amp;FP register, right shifts each result by an immediate 
value, and accumulates the final results with the vector 
elements of the destination SIMD&amp;FP register. All the values 
in this instruction are unsigned integer values. 
The results are rounded.

Scalar variant
  URSRA &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  URSRA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1469" header="Unsigned Shift Left" doc_id="armv8arm" token="USHL">This instruction takes each element in the vector of the first source 
SIMD&amp;FP register, shifts each element by a value from the least 
significant byte of the corresponding element of the second source 
SIMD&amp;FP register, places the results in a vector, and writes the 
vector to the destination SIMD&amp;FP register.

Scalar variant
  USHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;

Vector variant
  USHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1471" header="Unsigned Shift Left Long" doc_id="armv8arm" token="USHLL">This instruction reads each vector element in the lower or upper half of 
the source SIMD&amp;FP register, shifts the unsigned integer value left by 
the specified number of bits, places the result into a vector, and writes 
the vector to the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the source vector elements.

The USHLL instruction extracts vector elements from the lower half of the 
source register, while the USHLL2 instruction extracts vector elements 
from the upper half of the source register.

USHLL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</hint>
			<hint page="1471" header="Unsigned Shift Left Long" doc_id="armv8arm" token="USHLL2">This instruction reads each vector element in the lower or upper half of 
the source SIMD&amp;FP register, shifts the unsigned integer value left by 
the specified number of bits, places the result into a vector, and writes 
the vector to the destination SIMD&amp;FP register. The destination vector 
elements are twice as long as the source vector elements.

The USHLL instruction extracts vector elements from the lower half of the 
source register, while the USHLL2 instruction extracts vector elements 
from the upper half of the source register.

USHLL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</hint>
			<hint page="1473" header="Unsigned Shift Right" doc_id="armv8arm" token="USHR">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, writes the final result 
to a vector, and writes the vector to the destination SIMD&amp;FP register. 
All the values in this instruction are unsigned integer values. 
The results are truncated.

Scalar variant
  USHR &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  USHR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1475" header="Unsigned saturating Accumulate of Signed value" doc_id="armv8arm" token="USQADD">This instruction adds the signed integer values of the vector elements 
in the source SIMD&amp;FP register to corresponding unsigned integer values 
of the vector elements in the destination SIMD&amp;FP register, and 
accumulates the resulting unsigned integer values with the vector 
elements of the destination SIMD&amp;FP register.

Scalar variant
  USQADD &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;

Vector variant
  USQADD &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;</hint>
			<hint page="1477" header="Unsigned Shift Right and Accumulate" doc_id="armv8arm" token="USRA">This instruction reads each vector element in the source SIMD&amp;FP register, 
right shifts each result by an immediate value, and accumulates the final 
results with the vector elements of the destination SIMD&amp;FP register. 
All the values in this instruction are unsigned integer values. 
The results are truncated. 

Scalar variant
  USRA &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;

Vector variant
  USRA &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</hint>
			<hint page="1479" header="Unsigned Subtract Long" doc_id="armv8arm" token="USUBL">This instruction subtracts each vector element in the lower or upper half of the 
second source SIMD&amp;FP register from the corresponding vector element of the first 
source SIMD&amp;FP register, places the result into a vector, and writes the vector 
to the destination SIMD&amp;FP register. All the values in this instruction are 
unsigned integer values. The destination vector elements are twice as long as 
the source vector elements.

The USUBL instruction extracts each source vector from the lower half of each 
source register, while the USUBL2 instruction extracts each source vector 
from the upper half of each source register.

USUBL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1479" header="Unsigned Subtract Long" doc_id="armv8arm" token="USUBL2">This instruction subtracts each vector element in the lower or upper half of the 
second source SIMD&amp;FP register from the corresponding vector element of the first 
source SIMD&amp;FP register, places the result into a vector, and writes the vector 
to the destination SIMD&amp;FP register. All the values in this instruction are 
unsigned integer values. The destination vector elements are twice as long as 
the source vector elements.

The USUBL instruction extracts each source vector from the lower half of each 
source register, while the USUBL2 instruction extracts each source vector 
from the upper half of each source register.

USUBL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1481" header="Unsigned Subtract Wide" doc_id="armv8arm" token="USUBW">This instruction subtracts each vector element of the second 
source SIMD&amp;FP register from the corresponding vector element 
in the lower or upper half of the first source SIMD&amp;FP register, 
places the result in a vector, and writes the vector to the 
SIMD&amp;FP destination register. All the values in this instruction 
are signed integer values.

The vector elements of the destination register and the first 
source register are twice as long as the vector elements of 
the second source register.

USUBW &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1481" header="Unsigned Subtract Wide" doc_id="armv8arm" token="USUBW2">This instruction subtracts each vector element of the second 
source SIMD&amp;FP register from the corresponding vector element 
in the lower or upper half of the first source SIMD&amp;FP register, 
places the result in a vector, and writes the vector to the 
SIMD&amp;FP destination register. All the values in this instruction 
are signed integer values.

The vector elements of the destination register and the first 
source register are twice as long as the vector elements of 
the second source register.

USUBW2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Ta&gt;, &lt;Vm&gt;.&lt;Tb&gt;</hint>
			<hint page="1483" header="Unsigned extend Long" doc_id="armv8arm" token="UXTL">This instruction copies each vector element from the lower or upper half of the 
source SIMD&amp;FP register into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the 
source vector elements.

The UXTL instruction extracts vector elements from the lower half of the source 
register, while the UXTL2 instruction extracts vector elements from the upper 
half of the source register.

UXTL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;

  is equivalent to

USHLL &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</hint>
			<hint page="1483" header="Unsigned extend Long" doc_id="armv8arm" token="UXTL2">This instruction copies each vector element from the lower or upper half of the 
source SIMD&amp;FP register into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The destination vector elements are twice as long as the 
source vector elements.

The UXTL instruction extracts vector elements from the lower half of the source 
register, while the UXTL2 instruction extracts vector elements from the upper 
half of the source register.

UXTL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;

  is equivalent to

USHLL2 &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</hint>
			<hint page="1485" header="Unzip vectors (primary)" doc_id="armv8arm" token="UZP1">This instruction reads corresponding even-numbered vector elements from the 
two source SIMD&amp;FP registers, starting at zero, places the result from the 
first source register into consecutive elements in the lower half of a vector, 
and the result from the second source register into consecutive elements in 
the upper half of a vector, and writes the vector to the destination SIMD&amp;FP 
register.

UZP1 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1487" header="Unzip vectors (secondary)" doc_id="armv8arm" token="UZP2">This instruction reads corresponding odd-numbered vector elements 
from the two source SIMD&amp;FP registers, places the result from the 
first source register into consecutive elements in the lower half 
of a vector, and the result from the second source register into 
consecutive elements in the upper half of a vector, and writes 
the vector to the destination SIMD&amp;FP register.

UZP2 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1489" header="Extract Narrow" doc_id="armv8arm" token="XTN">This instruction reads each vector element from the source SIMD&amp;FP register, 
narrows each value to half the original width, places the result into a 
vector, and writes the vector to the lower or upper half of the destination 
SIMD&amp;FP register. The destination vector elements are half as long as the 
source vector elements.

The XTN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the XTN2 instruction writes the 
vector to the upper half of the destination register without affecting 
the other bits of the register.

XTN &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1489" header="Extract Narrow" doc_id="armv8arm" token="XTN2">This instruction reads each vector element from the source SIMD&amp;FP register, 
narrows each value to half the original width, places the result into a 
vector, and writes the vector to the lower or upper half of the destination 
SIMD&amp;FP register. The destination vector elements are half as long as the 
source vector elements.

The XTN instruction writes the vector to the lower half of the destination 
register and clears the upper half, while the XTN2 instruction writes the 
vector to the upper half of the destination register without affecting 
the other bits of the register.

XTN2 &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;</hint>
			<hint page="1491" header="Zip vectors (primary)" doc_id="armv8arm" token="ZIP1">This instruction reads adjacent vector elements from the upper half of two 
source SIMD&amp;FP registers as pairs, interleaves the pairs and places them 
into a vector, and writes the vector to the destination SIMD&amp;FP register. 
The first pair from the first source register is placed into the two 
lowest vector elements, with subsequent pairs taken alternately from 
each source register.

ZIP1 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
			<hint page="1493" header="Zip vectors (secondary)" doc_id="armv8arm" token="ZIP2">This instruction reads adjacent vector elements from the lower half 
of two source SIMD&amp;FP registers as pairs, interleaves the pairs and 
places them into a vector, and writes the vector to the destination 
SIMD&amp;FP register. The first pair from the first source register is 
placed into the two lowest vector elements, with subsequent pairs 
taken alternately from each source register.

ZIP2 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</hint>
		</group>
		<group type="ins" name="A64 Cryptographic Extension instructions">
			<hint page="782" header="AES single round decryption" doc_id="armv8arm" token="AESD">AESD &lt;Vd&gt;.16B, &lt;Vn&gt;.16B</hint>
			<hint page="783" header="AES single round encryption" doc_id="armv8arm" token="AESE">AESE &lt;Vd&gt;.16B, &lt;Vn&gt;.16B</hint>
			<hint page="784" header="AES inverse mix columns" doc_id="armv8arm" token="AESIMC">AESIMC &lt;Vd&gt;.16B, &lt;Vn&gt;.16B</hint>
			<hint page="785" header="AES mix columns" doc_id="armv8arm" token="AESMC">AESMC &lt;Vd&gt;.16B, &lt;Vn&gt;.16B</hint>
			<hint page="498" header="CRC32 checksum" doc_id="armv8arm" token="CRC32B">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values
is reversed as part of the operation, and the polynomial 0x04C11DB7 is 
used for the CRC calculation.

CRC32B &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</hint>
			<hint page="498" header="CRC32 checksum" doc_id="armv8arm" token="CRC32H">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values
is reversed as part of the operation, and the polynomial 0x04C11DB7 is 
used for the CRC calculation.

CRC32H &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</hint>
			<hint page="498" header="CRC32 checksum" doc_id="armv8arm" token="CRC32W">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values
is reversed as part of the operation, and the polynomial 0x04C11DB7 is 
used for the CRC calculation.

CRC32W &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</hint>
			<hint page="498" header="CRC32 checksum" doc_id="armv8arm" token="CRC32X">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values
is reversed as part of the operation, and the polynomial 0x04C11DB7 is 
used for the CRC calculation.

CRC32X &lt;Wd&gt;, &lt;Wn&gt;, &lt;Xm&gt;</hint>
			<hint page="500" header="CRC32 checksum" doc_id="armv8arm" token="CRC32CB">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values 
is reversed as part of the operation, and the polynomial 0x1EDC6F41 is 
used for the CRC calculation.

CRC32CB &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</hint>
			<hint page="500" header="CRC32 checksum" doc_id="armv8arm" token="CRC32CH">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values 
is reversed as part of the operation, and the polynomial 0x1EDC6F41 is 
used for the CRC calculation.

CRC32CH &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</hint>
			<hint page="500" header="CRC32 checksum" doc_id="armv8arm" token="CRC32CW">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values 
is reversed as part of the operation, and the polynomial 0x1EDC6F41 is 
used for the CRC calculation.

CRC32CW &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;</hint>
			<hint page="500" header="CRC32 checksum" doc_id="armv8arm" token="CRC32CX">Performs a cyclic redundancy check (CRC) calculation on a value held in a 
general-purpose register. It takes an input CRC value in the first source 
operand, performs a CRC on the input value in the second source operand, 
and returns the output CRC value. The second source operand can be 8, 16, 
32, or 64 bits. To align with common usage, the bit order of the values 
is reversed as part of the operation, and the polynomial 0x1EDC6F41 is 
used for the CRC calculation.

CRC32CX &lt;Wd&gt;, &lt;Wn&gt;, &lt;Xm&gt;</hint>
			<hint page="1181" header="SHA1 hash update (choose)" doc_id="armv8arm" token="SHA1C">SHA1C &lt;Qd&gt;, &lt;Sn&gt;, &lt;Vm&gt;.4S</hint>
			<hint page="1182" header="SHA1 fixed rotate " doc_id="armv8arm" token="SHA1H">SHA1H &lt;Sd&gt;, &lt;Sn&gt;</hint>
			<hint page="1183" header="SHA1 hash update (majority)" doc_id="armv8arm" token="SHA1M">SHA1M &lt;Qd&gt;, &lt;Sn&gt;, &lt;Vm&gt;.4S</hint>
			<hint page="1184" header="SHA1 hash update (parity)" doc_id="armv8arm" token="SHA1P">SHA1P &lt;Qd&gt;, &lt;Sn&gt;, &lt;Vm&gt;.4S</hint>
			<hint page="1185" header="SHA1 schedule update 0" doc_id="armv8arm" token="SHA1SU0">SHA1SU0 &lt;Vd&gt;.4S, &lt;Vn&gt;.4S, &lt;Vm&gt;.4S</hint>
			<hint page="1186" header="SHA1 schedule update 1" doc_id="armv8arm" token="SHA1SU1">SHA1SU1 &lt;Vd&gt;.4S, &lt;Vn&gt;.4S</hint>
			<hint page="1187" header="SHA256 hash update (part 2)" doc_id="armv8arm" token="SHA256H2">SHA256H2 &lt;Qd&gt;, &lt;Qn&gt;, &lt;Vm&gt;.4S</hint>
			<hint page="1188" header="SHA256 hash update (part 1)" doc_id="armv8arm" token="SHA256H">SHA256H &lt;Qd&gt;, &lt;Qn&gt;, &lt;Vm&gt;.4S</hint>
			<hint page="1189" header="SHA256 schedule update 0" doc_id="armv8arm" token="SHA256SU0">SHA256SU0 &lt;Vd&gt;.4S, &lt;Vn&gt;.4S</hint>
			<hint page="1190" header="SHA256 schedule update 1" doc_id="armv8arm" token="SHA256SU1">SHA256SU1 &lt;Vd&gt;.4S, &lt;Vn&gt;.4S, &lt;Vm&gt;.4S</hint>
		</group>
	</elements>
</documentation>
```

`Configurations/AR_VMSA_armv7arm_C.xml`:

```xml
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<documentation>
	<document id="armv7arm" name="ARM Architecture Reference Manual" version="C.c">
		<path>/path/to/DDI0406C_C_armv7ar_arm.pdf</path>
	</document>
	<elements>
		<group type="reg" name="System Control Identification Registers">
			<hint page="1649" header="Main ID Register" doc_id="armv7arm" token="MIDR">The MIDR provides identification information for the processor, 
including an implementer code for the device and a device ID number.</hint>
			<hint page="1556" header="Cache Type Register" doc_id="armv7arm" token="CTR">The CTR provides information about the architecture of the caches.</hint>
			<hint page="1716" header="TCM Type Register" doc_id="armv7arm" token="TCMTR">The TCMTR provides information about the implementation of the TCM.</hint>
			<hint page="1721" header="TLB Type Register" doc_id="armv7arm" token="TLBTR">The TLBTR provides information about the TLB implementation. 
The register must define whether the implementation provides 
separate instruction and data TLBs, or a unified TLB.</hint>
			<hint page="1651" header="Multiprocessor Affinity Register" doc_id="armv7arm" token="MPIDR">In a multiprocessor system, the MPIDR provides an additional processor 
identification mechanism for scheduling purposes, and indicates whether 
the implementation includes the Multiprocessing Extensions.</hint>
			<hint page="1703" header="Revision ID Register" doc_id="armv7arm" token="REVIDR">The REVIDR provides implementation-specific minor revision information 
that can only be interpreted in conjunction with the MIDR.</hint>
			<hint page="1633" header="Processor Feature Register 0" doc_id="armv7arm" token="ID_PFR0">ID_PFR0 gives information about the programmers’ model and top-level 
information about the instruction sets supported by the processor.</hint>
			<hint page="1635" header="Processor Feature Register 1" doc_id="armv7arm" token="ID_PFR1">ID_PFR1 gives information about the programmers’ model 
and Security Extensions support.</hint>
			<hint page="1605" header="Debug Feature Register 0" doc_id="armv7arm" token="ID_DFR0">ID_DFR0 provides top level information about the debug system.</hint>
			<hint page="1604" header="Auxiliary Feature Register 0" doc_id="armv7arm" token="ID_AFR0">ID_AFR0 provides information about the IMPLEMENTATION DEFINED 
features of the processor.</hint>
			<hint page="1621" header="Memory Model Feature Register 0" doc_id="armv7arm" token="ID_MMFR0">ID_MMFR0 provides information about the implemented memory 
model and memory management support.</hint>
			<hint page="1623" header="Memory Model Feature Register 1" doc_id="armv7arm" token="ID_MMFR1">ID_MMFR1 provides information about the implemented memory 
model and memory management support.</hint>
			<hint page="1627" header="Memory Model Feature Register 2" doc_id="armv7arm" token="ID_MMFR2">ID_MMFR2 provides information about the implemented memory 
model and memory management support.</hint>
			<hint page="1630" header="Memory Model Feature Register 3" doc_id="armv7arm" token="ID_MMFR3">ID_MMFR3 provides information about the implemented memory 
model and memory management support.</hint>
			<hint page="1608" header="Instruction Set Attribute Register 0" doc_id="armv7arm" token="ID_ISAR0">ID_ISAR0 provides information about the instruction sets 
implemented by the processor.</hint>
			<hint page="1610" header="Instruction Set Attribute Register 1" doc_id="armv7arm" token="ID_ISAR1">ID_ISAR1 provides information about the instruction sets 
implemented by the processor.</hint>
			<hint page="1613" header="Instruction Set Attribute Register 2" doc_id="armv7arm" token="ID_ISAR2">ID_ISAR2 provides information about the instruction sets 
implemented by the processor.</hint>
			<hint page="1615" header="Instruction Set Attribute Register 3" doc_id="armv7arm" token="ID_ISAR3">ID_ISAR3 provides information about the instruction sets 
implemented by the processor.</hint>
			<hint page="1618" header="Instruction Set Attribute Register 4" doc_id="armv7arm" token="ID_ISAR4">ID_ISAR4 provides information about the instruction sets 
implemented by the processor.</hint>
			<hint page="1620" header="Instruction Set Attribute Register 5" doc_id="armv7arm" token="ID_ISAR5">ID_ISAR5 is reserved for future expansion of the information 
about the instruction sets implemented by the processor.</hint>
			<hint page="1528" header="Cache Size ID Registers" doc_id="armv7arm" token="CCSIDR">The CCSIDR provides information about the architecture of the caches.</hint>
			<hint page="1530" header="Cache Level ID Register" doc_id="armv7arm" token="CLIDR">The CLIDR identifies:
- the type of cache, or caches, implemented at each level, 
  up to a maximum of seven levels
- the Level of Coherence (LoC) and Level of Unification (LoU) 
  for the cache hierarchy.</hint>
			<hint page="1811" header=" Auxiliary ID Register" doc_id="armv7arm" token="AIDR">Provides IMPLEMENTATION DEFINED ID information.</hint>
			<hint page="1834" header="Cache Size Selection Register" doc_id="armv7arm" token="CSSELR">The CSSELR selects the current CCSIDR, by specifying:
- The required cache level.
- The cache type, either:
  — Instruction cache, if the memory system implements 
    separate instruction and data caches.
  — Data cache. The data cache argument must be used for 
    a unified cache.</hint>
		</group>
		<group type="reg" name="System Control Virtualization Extensions Registers">
			<hint page="1737" header="Virtualization Processor ID Register" doc_id="armv7arm" token="VPIDR">The VPIDR holds the value of the Virtualization Processor ID. 
A Non-secure read of the MIDR from PL1 returns the value of this register.</hint>
			<hint page="1736" header="Virtualization Multiprocessor ID Register" doc_id="armv7arm" token="VMPIDR">The VMPIDR holds the value of the Virtualization Multiprocessor ID. 
A Non-secure read of the MPIDR from PL1 returns the value of this register.</hint>
			<hint page="1591" header="Hyp System Control Register" doc_id="armv7arm" token="HSCTLR">The HSCTLR provides top level control of the system operation in Hyp mode. 
This register provides Hyp mode control of features controlled by the 
Banked SCTLR bits, and shows the values of the non-Banked SCTLR bits.</hint>
			<hint page="1575" header="Hyp Auxiliary Control Register" doc_id="armv7arm" token="HACTLR">The HACTLR controls IMPLEMENTATION DEFINED features of Hyp mode operation.</hint>
			<hint page="1581" header="Hyp Configuration Register" doc_id="armv7arm" token="HCR">The HCR provides configuration controls for virtualization, 
including defining whether various Non-secure operations are 
trapped to Hyp mode.</hint>
			<hint page="1584" header="Hyp Debug Configuration Register" doc_id="armv7arm" token="HDCR">The HDCR controls the trapping to Hyp mode of Non-secure accesses, 
at PL1 or lower, to functions provided by the debug and trace 
architectures.</hint>
			<hint page="1578" header="Hyp Coprocessor Trap Register" doc_id="armv7arm" token="HCPTR">The HCPTR controls the trapping to Hyp mode of Non-secure accesses, 
at PL1 or lower, to coprocessors other than CP14 and CP15, and to 
floating-point and Advanced SIMD functionality. It also controls 
the access to coprocessors other than CP14 and CP15, and to 
floating-point and Advanced SIMD functionality, from Hyp mode.</hint>
			<hint page="1595" header="Hyp System Trap Register" doc_id="armv7arm" token="HSTR">The HSTR controls the trapping to Hyp mode of Non-secure accesses, 
at PL1 or lower, of:
- use of Jazelle or ThumbEE
- access to each of the CP15 primary coprocessor registers, 
  {c0-c3, c5-c13, c15}.</hint>
			<hint page="1575" header="Hyp Auxiliary Configuration Register" doc_id="armv7arm" token="HACR">The HACR controls the trapping to Hyp mode of IMPLEMENTATION DEFINED 
aspects of Non-secure PL1 or PL0 operation.</hint>
			<hint page="1597" header="Hyp Translation Control Register" doc_id="armv7arm" token="HTCR">The HTCR controls the translation table walks required for the 
stage 1 translation of memory accesses from Hyp mode, and holds 
cacheability and shareability information for the accesses.</hint>
			<hint page="1738" header="Virtualization Translation Control Register" doc_id="armv7arm" token="VTCR">The VTCR controls the translation table walks required for the 
stage 2 translation of memory accesses from Non-secure modes 
other than Hyp mode, and holds cacheability and shareability 
information for the accesses.</hint>
			<hint page="1576" header="Hyp Auxiliary Fault Syndrome Register" doc_id="armv7arm" token="HADFSR">The HAxFSR contain additional IMPLEMENTATION DEFINED 
syndrome information ford ata Abort exceptions taken 
to Hyp mode, for the HADFSR</hint>
			<hint page="1576" header="Hyp Auxiliary Fault Syndrome Register" doc_id="armv7arm" token="HAIFSR">The HAxFSR contain additional IMPLEMENTATION DEFINED 
syndrome information ford prefetch Abort exceptions 
taken to Hyp mode, for the HAIFSR</hint>
			<hint page="1594" header="Hyp Syndrome Register" doc_id="armv7arm" token="HSR">The HSR holds syndrome information for an exception taken to Hyp mode.</hint>
			<hint page="1587" header="Hyp Data Fault Address Register" doc_id="armv7arm" token="HDFAR">The HDFAR holds the VA of the faulting address that caused a 
synchronous Data Abort exception that is taken to Hyp mode.</hint>
			<hint page="1588" header="Hyp Instruction Fault Address Register" doc_id="armv7arm" token="HIFAR">The HIFAR holds the VA of the faulting address that 
caused a synchronous Prefetch Abort exception that 
is taken to Hyp mode.</hint>
			<hint page="1590" header="Hyp IPA Fault Address Registe" doc_id="armv7arm" token="HPFAR">For some aborts on a stage 2 translation, taken to Hyp mode, 
HPFAR holds the faulting IPA.</hint>
			<hint page="1589" header="Hyp Memory Attribute Indirection Registers 0" doc_id="armv7arm" token="HMAIR0">The HMAIR0 register provide the memory attribute encodings 
corresponding to the possible AttrIndx values in a translation 
table entry for stage 1 translations for memory accesses 
from Hyp mode. For more information about the AttrIndx field.</hint>
			<hint page="1589" header="Hyp Memory Attribute Indirection Registers 1" doc_id="armv7arm" token="HMAIR1">The HMAIR1 register provide the memory attribute encodings 
corresponding to the possible AttrIndx values in a translation 
table entry for stage 1 translations for memory accesses 
from Hyp mode. For more information about the AttrIndx field.</hint>
			<hint page="1577" header="Hyp Auxiliary Memory Attribute Indirection Registers 0" doc_id="armv7arm" token="HAMAIR0">The HAMAIR0 register provide IMPLEMENTATION DEFINED memory 
attributes for the memory attribute encodings defined by 
the HMAIR0 register.

These IMPLEMENTATION DEFINED attributes can only provide 
additional qualifiers for the memory attribute encodings, 
and cannot change the memory attributes defined in the 
HMAIR0 registers.</hint>
			<hint page="1577" header="Hyp Auxiliary Memory Attribute Indirection Registers 1" doc_id="armv7arm" token="HAMAIR1">The HAMAIR1 register provide IMPLEMENTATION DEFINED memory 
attributes for the memory attribute encodings defined by 
the HMAIR1 register.

These IMPLEMENTATION DEFINED attributes can only provide 
additional qualifiers for the memory attribute encodings, 
and cannot change the memory attributes defined in the 
HMAIR0 registers.</hint>
		</group>
		<group type="reg" name="System Control Virtual Memory Registers">
			<hint page="1707" header="System Control Register" doc_id="armv7arm" token="SCTLR">The SCTLR provides the top level control of the system, 
including its memory system.</hint>
			<hint page="1729" header="Translation Table Base Register 0" doc_id="armv7arm" token="TTBR0">TTBR0 holds the base address of translation table 0, and 
information about the memory it occupies. This is one of 
the translation tables for the stage 1 translation of 
memory accesses from modes other than Hyp mode.</hint>
			<hint page="1733" header="Translation Table Base Register 1" doc_id="armv7arm" token="TTBR1">TTBR1 holds the base address of translation table 1, and 
information about the memory it occupies. This is one of 
the translation tables for the stage 1 translation of 
memory accesses from modes other than Hyp mode.</hint>
			<hint page="1724" header="Translation Table Base Control Register" doc_id="armv7arm" token="TTBCR">TTBCR determines which of the Translation Table Base Registers, 
TTBR0 or TTBR1, defines the base address for a translation table 
walk required for the stage 1 translation of a memory access 
from any mode other than Hyp mode.

If the implementation includes the Large Physical Address Extension, 
the TTBCR also:
- Controls the translation table format.
- When using the Long-descriptor translation table format, holds 
  cacheability and shareability information for the accesses.</hint>
			<hint page="1646" header="Memory Attribute Indirection Registers 0" doc_id="armv7arm" token="MAIR0">MAIR0 provides the memory attribute encodings corresponding to 
the possible AttrIndx values in a Long-descriptor format 
translation table entry for stage 1 translations.</hint>
			<hint page="1646" header="Memory Attribute Indirection Registers 1" doc_id="armv7arm" token="MAIR1">MAIR1 provides the memory attribute encodings corresponding to 
the possible AttrIndx values in a Long-descriptor format 
translation table entry for stage 1 translations.</hint>
			<hint page="1525" header="Auxiliary Memory Attribute Indirection Registers 0" doc_id="armv7arm" token="AMAIR0">When using the Long-descriptor format translation tables 
for stage 1 translations, AMAIR0 provides IMPLEMENTATION 
DEFINED memory attributes for the memory regions specified 
by the MAIRn registers.</hint>
			<hint page="1525" header="Auxiliary Memory Attribute Indirection Registers 1" doc_id="armv7arm" token="AMAIR1">When using the Long-descriptor format translation tables 
for stage 1 translations, AMAIR1 provides IMPLEMENTATION 
DEFINED memory attributes for the memory regions specified 
by the MAIRn registers.</hint>
			<hint page="1548" header="Context ID Register" doc_id="armv7arm" token="CONTEXTIDR">CONTEXTIDR identifies the current Process Identifier (PROCID) 
and, when using the Short-descriptor translation table format, 
the Address Space Identifier (ASID).</hint>
		</group>
		<group type="reg" name="System Control Security Extensions Registers">
			<hint page="1704" header="Secure Configuration Register" doc_id="armv7arm" token="SCR">The SCR defines the configuration of the current security state. 
It specifies:
- the security state of the processor, Secure or Non-secure
- what mode the processor branches to if an IRQ, FIQ or 
  external abort occurs
- whether the CPSR.{F, A} bits can be modified when SCR.NS == 1.</hint>
			<hint page="1715" header="Secure Debug Enable Register" doc_id="armv7arm" token="SDER">The SDER controls invasive and non-invasive debug in the Secure PL0 mode.</hint>
			<hint page="1662" header="Non-Secure Access Control Register" doc_id="armv7arm" token="NSACR">The NSACR:
- Defines the Non-secure access permissions to coprocessors CP0 to CP13.
- Can include additional IMPLEMENTATION DEFINED bits that define Non-secure 
  access permissions for IMPLEMENTATION DEFINED functionality.
- In an implementation that includes the Virtualization Extensions, controls
  Hyp mode access to:
  — coprocessors CP0 to CP13
  — floating-point and Advanced SIMD functionality.</hint>
			<hint page="1558" header="Domain Access Control Register" doc_id="armv7arm" token="DACR">DACR defines the access permission for each of the sixteen memory domains.</hint>
			<hint page="1735" header="Vector Base Address Register" doc_id="armv7arm" token="VBAR">When high exception vectors are not selected, the VBAR 
holds the exception base address for exceptions that 
are not taken to Monitor mode or to Hyp mode.</hint>
			<hint page="1654" header="Monitor Vector Base Address Register" doc_id="armv7arm" token="MVBAR">The MVBAR holds the exception base address for all exceptions 
that are taken to Monitor mode.</hint>
			<hint page="1640" header="Interrupt Status Register" doc_id="armv7arm" token="ISR">The ISR shows whether an IRQ, FIQ, or external abort is pending. 
In an implementation that includes the Virtualization Extensions,
an indicated pending abort might be a physical abort or a virtual
abort.</hint>
			<hint page="1602" header="Hyp Vector Base Address Register" doc_id="armv7arm" token="HVBAR">The HVBAR holds the exception base address for any exception 
that is taken to Hyp mode</hint>
		</group>
		<group type="reg" name="System Control Other Registers">
			<hint page="1522" header="Auxiliary Control Register" doc_id="armv7arm" token="ACTLR">The ACTLR provides IMPLEMENTATION DEFINED configuration and control options.</hint>
			<hint page="1551" header="Auxiliary Control Register" doc_id="armv7arm" token="CPACR">The CPACR:
- Controls access to coprocessors CP0 to CP13 from PL0 and PL1.
- Is used to determine which, if any, of coprocessors CP0 to 
  CP13 are implemented.</hint>
			<hint page="1561" header="Data Fault Status Register" doc_id="armv7arm" token="DFSR">The DFSR holds status information about the last data fault.</hint>
			<hint page="1566" header="FCSE Process ID Register" doc_id="armv7arm" token="FCSEIDR">The FCSEIDR identifies the current Process ID (PID) for 
the Fast Context Switch Extension (FCSE).</hint>
		</group>
		<group type="reg" name="System Control Fault Handling Registers">
			<hint page="1561" header="Data Fault Status Register" doc_id="armv7arm" token="DFSR">The DFSR holds status information about the last data fault.</hint>
			<hint page="1638" header="Instruction Fault Status Register" doc_id="armv7arm" token="IFSR">The IFSR holds status information about the last instruction fault.</hint>
			<hint page="1523" header="Auxiliary Data Fault Status Register" doc_id="armv7arm" token="ADFSR">The ADFSRs can provide additional IMPLEMENTATION DEFINED 
fault status information.</hint>
			<hint page="1523" header="Auxiliary Instruction Fault Status Register" doc_id="armv7arm" token="AIFSR">The AIFSRs can provide additional IMPLEMENTATION DEFINED 
fault status information.</hint>
			<hint page="1560" header="Data Fault Address Register" doc_id="armv7arm" token="DFAR">The DFAR holds the VA of the faulting address that 
caused a synchronous Data Abort exception.</hint>
			<hint page="1637" header="Instruction Fault Address Register" doc_id="armv7arm" token="IFAR">The IFAR holds the VA of the faulting access that 
caused a synchronous Prefetch Abort exception.</hint>
		</group>
		<group type="reg" name="System Control Cache Maintenance Registers">
			<hint page="1744" header="Instruction Cache Invalidate All to PoU, Inner Shareable" doc_id="armv7arm" token="ICIALLUIS">Invalidate all instruction caches Inner Shareable to PoU. 
If branch predictors are architecturally-visible, also 
flushes branch predictors.</hint>
			<hint page="1744" header="Branch Predictor Invalidate All, Inner Shareable" doc_id="armv7arm" token="BPIALLIS">Invalidate all entries from branch predictors Inner Shareable.</hint>
			<hint page="1665" header="Instruction Cache Invalidate All to PoU" doc_id="armv7arm" token="ICIALLU">Invalidate all instruction caches to PoU. If branch 
predictors are architecturally-visible, also flushes 
branch predictors.</hint>
			<hint page="1665" header="Instruction Cache Invalidate by MVA to PoU" doc_id="armv7arm" token="ICIMVAU">Invalidate instruction cache line by MVA to PoU.</hint>
			<hint page="1752" header="CP15 Instruction Synchronization Barrier" doc_id="armv7arm" token="CP15ISB">In ARMv7, the ISB instruction performs an Instruction 
Synchronization Barrier operation</hint>
			<hint page="1744" header="Branch Predictor Invalidate All" doc_id="armv7arm" token="BPIALL">Invalidate all entries from branch predictors.</hint>
			<hint page="1744" header="Branch Predictor Invalidate by MVA" doc_id="armv7arm" token="BPIMVA">Invalidate MVA from branch predictors.</hint>
			<hint page="1944" header="Data Cache Invalidate by MVA to PoC" doc_id="armv7arm" token="DCIMVAC">Invalidate data or unified cache line by address to PoC.</hint>
			<hint page="1944" header="Data Cache Invalidate by Set/Way" doc_id="armv7arm" token="DCISW">Invalidate data or unified cache line by set/way.</hint>
			<hint page="1944" header="Data Cache Clean by MVA to PoC" doc_id="armv7arm" token="DCCMVAC">Clean data or unified cache line by address to PoC.</hint>
			<hint page="1944" header="Data Cache Clean by Set/Way" doc_id="armv7arm" token="DCCSW">Clean data or unified cache line by set/way.</hint>
			<hint page="1752" header="CP15 Instruction Synchronization Barrier" doc_id="armv7arm" token="CP15DSB">In ARMv7, the ISB instruction performs an Instruction 
Synchronization Barrier operation</hint>
			<hint page="1752" header="CP15 Instruction Synchronization Barrier" doc_id="armv7arm" token="CP15DMB">In ARMv7, the ISB instruction performs an Instruction 
Synchronization Barrier operation</hint>
			<hint page="1944" header="Data Cache Clean by MVA to PoU" doc_id="armv7arm" token="DCCMVAU">Clean data or unified cache line by address to PoU.</hint>
			<hint page="1944" header="Data Cache Invalidate by MVA to PoC" doc_id="armv7arm" token="DCCIMVAC">Clean and invalidate data or unified cache line by address to PoC.</hint>
			<hint page="1944" header="Data Cache Invalidate by Set/Way" doc_id="armv7arm" token="DCCISW">Clean and invalidate data or unified cache line by set/way.</hint>
		</group>
		<group type="reg" name="System Control Address Translation Registers">
			<hint page="1665" header="Physical Address Register" doc_id="armv7arm" token="PAR">Receives the PA from any address translation operation.</hint>
			<hint page="1750" header="Address Translate Stage 1 Current state PL1 Read" doc_id="armv7arm" token="ATS1CPR">Stage 1 current state PL1 read.

In an implementation that includes the Virtualization Extensions, 
in Non-secure state, this operation returns the result of a VA 
to IPA translation. Otherwise, they return the result of a VA to 
PA translation.</hint>
			<hint page="1750" header="Address Translate Stage 1 Current state PL1 Write" doc_id="armv7arm" token="ATS1CPW">Stage 1 current state PL1 write.

In an implementation that includes the Virtualization Extensions, 
in Non-secure state, this operation returns the result of a VA 
to IPA translation. Otherwise, they return the result of a VA to 
PA translation.</hint>
			<hint page="1750" header="Address Translate Stage 1 Current state Unprivileged Read" doc_id="armv7arm" token="ATS1CUR">Stage 1 current state unprivileged (PL0) read.

In an implementation that includes the Virtualization Extensions, 
in Non-secure state, this operation returns the result of a VA 
to IPA translation. Otherwise, they return the result of a VA to 
PA translation.</hint>
			<hint page="1750" header="Address Translate Stage 1 Current state Unprivileged Write" doc_id="armv7arm" token="ATS1CUW">Stage 1 current state unprivileged (PL0) write.

In an implementation that includes the Virtualization Extensions, 
in Non-secure state, this operation returns the result of a VA 
to IPA translation. Otherwise, they return the result of a VA to 
PA translation.</hint>
			<hint page="1750" header="Address Translate Stages 1 and 2 Non-secure PL1 Read" doc_id="armv7arm" token="ATS12NSOPR">Stages 1 and 2 Non-secure PL1 read.

This operation always returns the result of a VA to PA translation.</hint>
			<hint page="1750" header="Address Translate Stages 1 and 2 Non-secure PL1 Write" doc_id="armv7arm" token="ATS12NSOPW">Stages 1 and 2 Non-secure PL1 write.

This operation always returns the result of a VA to PA translation.</hint>
			<hint page="1750" header="Address Translate Stages 1 and 2 Non-secure Unprivileged Read" doc_id="armv7arm" token="ATS12NSOUR">Stages 1 and 2 Non-secure unprivileged (PL0) read.

This operation always returns the result of a VA to PA translation.</hint>
			<hint page="1750" header="Address Translate Stages 1 and 2 Non-secure Unprivileged Write" doc_id="armv7arm" token="ATS12NSOUW">Stages 1 and 2 Non-secure unprivileged (PL0) write.

This operation always returns the result of a VA to PA translation.</hint>
			<hint page="1750" header="Address Translate Stage 1 Hyp mode Read" doc_id="armv7arm" token="ATS1HR">Stage 1 Hyp mode read.

This operation always returns the result of a VA to PA translation.</hint>
			<hint page="1750" header="Address Translate Stage 1 Hyp mode Write" doc_id="armv7arm" token="ATS1HW">Stage 1 Hyp mode write.

This operation always returns the result of a VA to PA translation.</hint>
			<hint page="1750" header="TLB Invalidate All, Inner Shareable" doc_id="armv7arm" token="TLBIALLIS">Stage 1 Hyp mode write.

This operation always returns the result of a VA to PA translation.</hint>
		</group>
		<group type="reg" name="System Control TLB Maintenance Registers">
			<hint page="1746" header="TLB Invalidate All, Inner Shareable" doc_id="armv7arm" token="TLBIALLIS">Invalidate entire unified TLB Inner Shareable.</hint>
			<hint page="1746" header="TLB Invalidate by MVA, Inner Shareable" doc_id="armv7arm" token="TLBIMVAIS">Invalidate unified TLB entry by MVA and ASID, Inner Shareable.</hint>
			<hint page="1746" header="TLB Invalidate by ASID, Inner Shareable" doc_id="armv7arm" token="TLBIASIDIS">Invalidate unified TLB by ASID match Inner Shareable.</hint>
			<hint page="1746" header="TLB Invalidate by MVA, all ASIDs, Inner Shareable" doc_id="armv7arm" token="TLBIMVAAIS">Invalidate unified TLB entry by MVA all ASID Inner Shareable.</hint>
			<hint page="1746" header="Instruction TLB Invalidate All" doc_id="armv7arm" token="ITLBIALL">Invalidate entire instruction TLB.</hint>
			<hint page="1746" header="Instruction TLB Invalidate by MVA" doc_id="armv7arm" token="ITLBIMVA">Invalidate instruction TLB entry by MVA and ASID.</hint>
			<hint page="1746" header="Instruction TLB Invalidate by ASID" doc_id="armv7arm" token="ITLBIASID">Invalidate instruction TLB by ASID match.</hint>
			<hint page="1746" header="Data TLB Invalidate All" doc_id="armv7arm" token="DTLBIALL">Invalidate entire data TLB.</hint>
			<hint page="1746" header="Data TLB Invalidate by MVA" doc_id="armv7arm" token="DTLBIMVA">Invalidate data TLB entry by MVA and ASID.</hint>
			<hint page="1746" header="Data TLB Invalidate by ASID" doc_id="armv7arm" token="DTLBIASID">Invalidate data TLB by ASID match.</hint>
			<hint page="1746" header="TLB Invalidate All" doc_id="armv7arm" token="TLBIALL">Invalidate entire unified TLB.</hint>
			<hint page="1746" header="TLB Invalidate by MVA" doc_id="armv7arm" token="TLBIMVA">Invalidate unified TLB entry by MVA and ASID.</hint>
			<hint page="1747" header="TLB Invalidate by ASID" doc_id="armv7arm" token="TLBIASID">Invalidate unified TLB by ASID match.</hint>
			<hint page="1747" header="TLB Invalidate by MVA, all ASIDs" doc_id="armv7arm" token="TLBIMVAA">Invalidate unified TLB entries by MVA all ASID.</hint>
			<hint page="1749" header="TLB Invalidate All, Hyp mode, Inner Shareable" doc_id="armv7arm" token="TLBIALLHIS">Invalidate entire Hyp unified TLB Inner Shareable.</hint>
			<hint page="1749" header="TLB Invalidate by MVA, Hyp mode, Inner Shareable" doc_id="armv7arm" token="TLBIMVAHIS">Invalidate Hyp unified TLB entry by MVA Inner Shareable.</hint>
			<hint page="1749" header="TLB Invalidate all Non-secure Non-Hyp IS" doc_id="armv7arm" token="TLBIALLNSNHIS">Invalidate entire Non-secure Non-Hyp unified TLB Inner Shareable.</hint>
			<hint page="1749" header="TLB Invalidate All, Hyp mode" doc_id="armv7arm" token="TLBIALLH">Invalidate entire Hyp unified TLB.</hint>
			<hint page="1749" header="TLB Invalidate by MVA, Hyp mode" doc_id="armv7arm" token="TLBIMVAH">Invalidate Hyp unified TLB entry by MVA.</hint>
			<hint page="1749" header="TLB Invalidate all Non-secure Non-Hyp" doc_id="armv7arm" token="TLBIALLNSNH">Invalidate entire Non-secure Non-Hyp unified TLB.</hint>
		</group>
		<group type="reg" name="System Control Performance Monitors Registers">
			<hint page="1678" header="Performance Monitors Control Register" doc_id="armv7arm" token="PMCR">The PMCR provides details of the Performance Monitors implementation, 
including the number of counters implemented, and configures and 
controls the counters.</hint>
			<hint page="1676" header="Performance Monitors Count Enable Set Register" doc_id="armv7arm" token="PMCNTENSET">The PMCNTENSET register enables the Cycle Count Register, 
PMCCNTR, and any implemented event counters, PMNx. Reading 
this register shows which counters are enabled.</hint>
			<hint page="1674" header="Performance Monitors Count Enable Clear Register" doc_id="armv7arm" token="PMCNTENCLR">The PMCNTENCLR register disables the Cycle Count Register, 
PMCCNTR, and any implemented event counters, PMNx. Reading 
this register shows which counters are enabled.</hint>
			<hint page="1685" header="Performance Monitors Overflow Flag Status Register" doc_id="armv7arm" token="PMOVSR">The PMOVSR holds the state of the overflow bit for:
- the Cycle Count Register, PMCCNTR
- each of the implemented event counters, PMNx.

Software must write to this register to clear these bits.</hint>
			<hint page="1691" header="Performance Monitors Software Increment" doc_id="armv7arm" token="PMSWINC">The PMSWINC register increments a counter that is configured
to count the Software increment event, event 0x00.</hint>
			<hint page="1689" header="Performance Monitors Event Counter Selection Register" doc_id="armv7arm" token="PMSELR">- In PMUv1, PMSELR selects an event counter, PMNx.
- In PMUv2, PMSELR selects an event counter, PMNx, 
  or the cycle counter, CCNT.

The PMSELR.SEL value of 31 selects the cycle counter.</hint>
			<hint page="1672" header="Performance Monitors Common Event ID Register" doc_id="armv7arm" token="PMCEID0">The PMCEID0 registers define which common architectural and 
common microarchitectural feature events are implemented.</hint>
			<hint page="1672" header="Performance Monitors Common Event ID Register" doc_id="armv7arm" token="PMCEID1">The PMCEID1 registers define which common architectural and 
common microarchitectural feature events are implemented.</hint>
			<hint page="1671" header="Performance Monitors Cycle Count Register" doc_id="armv7arm" token="PMCCNTR">The PMCCNTR holds the value of the processor Cycle Counter, 
CCNT, that counts processor clock cycles.</hint>
			<hint page="1696" header="Performance Monitors Event Type Select Register" doc_id="armv7arm" token="PMXEVTYPER">When PMSELR.SEL selects an event counter, PMNx, PMXEVTYPER 
configures which event increments that event counter.
In PMUv2 PMXEVTYPER also determines the modes in which PMNx 
or PMCCNTR increments.

PMSELR.SEL determines which event counter is selected, or 
if PMCCNTR is selected.</hint>
			<hint page="1694" header="Performance Monitors Event Count Register" doc_id="armv7arm" token="PMXEVCNTR">The PMXEVCNTR reads or writes the value of the selected 
event counter, PMNx. PMSELR.SEL determines which event 
counter is selected.</hint>
			<hint page="1693" header="Performance Monitors User Enable Register" doc_id="armv7arm" token="PMUSERENR">The PMUSERENR enables or disables User mode access 
to the Performance Monitors.</hint>
			<hint page="1683" header="Performance Monitors Interrupt Enable Set Register" doc_id="armv7arm" token="PMINTENSET">The PMINTENSET register enables the generation of interrupt 
requests on overflows from:
- the Cycle Count Register, PMCCNTR
- each implemented event counter, PMNx.

Reading the register shows which overflow interrupt requests 
are enabled.</hint>
			<hint page="1681" header="Performance Monitors Interrupt Enable Clear Register" doc_id="armv7arm" token="PMINTENCLR">The PMINTENCLR register disables the generation of interrupt 
requests on overflows from:
- the Cycle Count Register, PMCCNTR
- each implemented event counter, PMNx.

Reading the register shows which overflow interrupt requests 
are enabled.</hint>
			<hint page="1687" header="Performance Monitors Overflow Flag Status Set Register" doc_id="armv7arm" token="PMOVSSET">The PMOVSSET register sets the state of the overflow bit for:
- the Cycle Count Register, PMCCNTR
- each of the implemented event counters, PMNx.</hint>
		</group>
		<group type="reg" name="System Control Miscellaneous Operation Registers">
			<hint page="1723" header="User Read/Write Thread ID Register" doc_id="armv7arm" token="TPIDRURW">The TPIDRURW provides a location where software executing 
at PL0 can store thread identifying information, for OS 
management purposes.</hint>
			<hint page="1722" header="User Read-Only Thread ID Register" doc_id="armv7arm" token="TPIDRURO">The TPIDRURO provides a location where software executing at PL1 
or higher can store thread identifying information that is visible 
to software executing at PL0, for OS management purposes.</hint>
			<hint page="1722" header="PL1 only Thread ID Register" doc_id="armv7arm" token="TPIDRPRW">The TPIDRPRW provides a location where software executing at PL1 
or higher can store thread identifying information that is not 
visible to software executing at PL0, for OS management purposes.</hint>
			<hint page="1599" header="Hyp Software Thread ID Register" doc_id="armv7arm" token="HTPIDR">The HTPIDR provides a location where software running in Hyp 
mode can store thread identifying information that is not 
visible to Non-secure software executing at PL0 or PL1, for 
hypervisor management purposes.</hint>
			<hint page="1818" header="Counter Frequency Register" doc_id="armv7arm" token="CNTFRQ">The CNTFRQ register indicates the clock frequency of the system counter.</hint>
		</group>
		<group type="reg" name="System Control Generic Timer Registers">
			<hint page="1818" header="Counter Frequency Register" doc_id="armv7arm" token="CNTFRQ">The CNTFRQ register indicates the clock frequency of the system counter.</hint>
			<hint page="1537" header="Timer PL1 Control Register" doc_id="armv7arm" token="CNTKCTL">Controls:
- access to the following from PL0 modes:
  — the physical counter
  — the virtual counter
  — the PL1 physical timers
  — the virtual timer.
- the generation of an event stream from the virtual counter.</hint>
			<hint page="1542" header="PL1 Physical TimerValue Register" doc_id="armv7arm" token="CNTP_TVAL">Holds the timer value for the PL1 physical timer. 
This provides a 32-bit downcounter.</hint>
			<hint page="1539" header="PL1 Physical Timer Control Register" doc_id="armv7arm" token="CNTP_CTL">The control register for the physical timer.</hint>
			<hint page="1545" header="Virtual TimerValue Register" doc_id="armv7arm" token="CNTV_TVAL">Holds the timer value for the virtual timer. 
This provides a 32-bit downcounter.</hint>
			<hint page="1544" header="Virtual Timer Control Register" doc_id="armv7arm" token="CNTV_CTL">The control register for the virtual timer.</hint>
			<hint page="1533" header="Timer PL2 Control Register" doc_id="armv7arm" token="CNTHCTL">Controls:
- access to the following from Non-secure PL1 modes:
  — the physical counter
  — the Non-secure PL1 physical timer.
- the generation of an event stream from the physical counter.</hint>
			<hint page="1536" header="PL2 Physical TimerValue Register" doc_id="armv7arm" token="CNTHP_TVAL">Holds the timer value for the Hyp mode physical timer. 
This provides a 32-bit downcounter.</hint>
		</group>
		<group type="reg" name="System Control Jazelle Registers">
			<hint page="1642" header="Jazelle ID Register" doc_id="armv7arm" token="JIDR">Identifies the Jazelle architecture and subarchitecture versions.</hint>
			<hint page="1644" header="Jazelle OS Control Register" doc_id="armv7arm" token="JOSCR">Provides operating system control of the use of the Jazelle 
extension by processes and threads.</hint>
			<hint page="1643" header="Jazelle OS Control Register" doc_id="armv7arm" token="JMCR">Provides control of the Jazelle extension.</hint>
			<hint page="2231" header="Debug ID Register" doc_id="armv7arm" token="DBGDIDR">Specifies:
- which version of the Debug architecture is implemented
- some features of the debug implementation.</hint>
		</group>
		<group type="reg" name="Debug Registers">
			<hint page="2231" header="Debug ID Register" doc_id="armv7arm" token="DBGDIDR">Specifies:
- which version of the Debug architecture is implemented
- some features of the debug implementation.</hint>
			<hint page="2298" header="Watchpoint Fault Address Register" doc_id="armv7arm" token="DBGWFAR">Returns information about the address of the instruction 
that accessed a watchpointed address.</hint>
			<hint page="2288" header="Vector Catch Register" doc_id="armv7arm" token="DBGVCR">Controls Vector catch debug events.</hint>
			<hint page="2263" header="Event Catch Register" doc_id="armv7arm" token="DBGECR">Configures the debug logic to generate the OS Unlock catch 
debug event when the OS Lock is cleared.</hint>
			<hint page="2241" header="Debug State Cache Control Register" doc_id="armv7arm" token="DBGDSCCR">Controls cache behavior when the processor is in Debug state.</hint>
			<hint page="2259" header="Debug State MMU Control Register" doc_id="armv7arm" token="DBGDSMCR">Controls TLB behavior when the processor is in Debug state.</hint>
			<hint page="2261" header="Host to Target Data Transfer Register" doc_id="armv7arm" token="DBGDTRRXext">Transfers data from an external host to the ARM processor. 
For example it is used by a debugger transferring commands 
and data to a debug target. It is a component of the Debug 
Communication Channel (DCC).</hint>
			<hint page="2243" header="Debug Status and Control Register" doc_id="armv7arm" token="DBGDSCRext">The main control register for the debug implementation.</hint>
			<hint page="2262" header="Target to Host Data Transfer register" doc_id="armv7arm" token="DBGDTRTXext">Transfers data from the ARM processor to an external host. 
For example it is used by a debug target to transfer data 
to the debugger. It is a component of the Debug Communication 
Channel (DCC).</hint>
			<hint page="2236" header="Debug Run Control Register" doc_id="armv7arm" token="DBGDRCR">Software uses this register to:
- request the processor to enter or exit Debug state
- clear to 0 the sticky exception bits in the DBGDSCR
- cancel bus requests
- clear to 0 DBGDSCR.PipeAdv, the Sticky Pipeline Advance bit.</hint>
			<hint page="2218" header="Breakpoint Value Register 0" doc_id="armv7arm" token="DBGBVR0">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR0 is associated with DBGBCR0 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR1" doc_id="armv7arm" header="Breakpoint Value Register 1">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR1 is associated with DBGBCR1 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR2" doc_id="armv7arm" header="Breakpoint Value Register 2">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR2 is associated with DBGBCR2 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR3" doc_id="armv7arm" header="Breakpoint Value Register 3">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR3 is associated with DBGBCR3 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR4" doc_id="armv7arm" header="Breakpoint Value Register 4">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR4 is associated with DBGBCR4 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR5" doc_id="armv7arm" header="Breakpoint Value Register 5">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR5 is associated with DBGBCR5 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR6" doc_id="armv7arm" header="Breakpoint Value Register 6">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR6 is associated with DBGBCR6 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR7" doc_id="armv7arm" header="Breakpoint Value Register 7">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR7 is associated with DBGBCR7 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR8" doc_id="armv7arm" header="Breakpoint Value Register 8">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR8 is associated with DBGBCR8 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR9" doc_id="armv7arm" header="Breakpoint Value Register 9">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR9 is associated with DBGBCR9 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR10" doc_id="armv7arm" header="Breakpoint Value Register 10">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR10 is associated with DBGBCR10 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR11" doc_id="armv7arm" header="Breakpoint Value Register 11">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR11 is associated with DBGBCR11 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR12" doc_id="armv7arm" header="Breakpoint Value Register 12">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR12 is associated with DBGBCR12 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR13" doc_id="armv7arm" header="Breakpoint Value Register 13">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR13 is associated with DBGBCR13 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR14" doc_id="armv7arm" header="Breakpoint Value Register 14">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR14 is associated with DBGBCR14 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2218" token="DBGBVR15" doc_id="armv7arm" header="Breakpoint Value Register 15">Holds a value for use in breakpoint matching, either the 
virtual address of an instruction, or a Context ID.

Used in conjunction with a Breakpoint Control Register, 
DBGBCR. DBGBVR15 is associated with DBGBCR15 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for Context matching.</hint>
			<hint page="2213" token="DBGBCR0" doc_id="armv7arm" header="Breakpoint Control Register 0">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR0 is associated with DBGBCR0 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR1" doc_id="armv7arm" header="Breakpoint Control Register 1">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR1 is associated with DBGBCR1 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR2" doc_id="armv7arm" header="Breakpoint Control Register 2">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR2 is associated with DBGBCR2 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR3" doc_id="armv7arm" header="Breakpoint Control Register 3">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR3 is associated with DBGBCR3 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR4" doc_id="armv7arm" header="Breakpoint Control Register 4">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR4 is associated with DBGBCR4 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR5" doc_id="armv7arm" header="Breakpoint Control Register 5">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR5 is associated with DBGBCR5 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR6" doc_id="armv7arm" header="Breakpoint Control Register 6">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR6 is associated with DBGBCR6 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR7" doc_id="armv7arm" header="Breakpoint Control Register 7">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR7 is associated with DBGBCR7 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR8" doc_id="armv7arm" header="Breakpoint Control Register 8">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR8 is associated with DBGBCR8 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR9" doc_id="armv7arm" header="Breakpoint Control Register 9">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR9 is associated with DBGBCR9 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR10" doc_id="armv7arm" header="Breakpoint Control Register 10">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR10 is associated with DBGBCR10 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR11" doc_id="armv7arm" header="Breakpoint Control Register 11">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR11 is associated with DBGBCR11 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR12" doc_id="armv7arm" header="Breakpoint Control Register 12">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR12 is associated with DBGBCR12 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR13" doc_id="armv7arm" header="Breakpoint Control Register 13">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR13 is associated with DBGBCR13 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR14" doc_id="armv7arm" header="Breakpoint Control Register 14">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR14 is associated with DBGBCR14 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2213" token="DBGBCR15" doc_id="armv7arm" header="Breakpoint Control Register 15">Holds control information for a breakpoint.

Used in conjunction with a Breakpoint Value Register, DBGBVR. 
DBGBVR15 is associated with DBGBCR15 to form this breakpoint.

If the implementation includes the Virtualization Extensions, 
and this breakpoint supports Context matching, DBGBVR can be 
associated with a Breakpoint Extended Value Register, DBGBXVR, 
for VMID matching.</hint>
			<hint page="2299" token="DBGWVR0" doc_id="armv7arm" header="Watchpoint Value Register 0">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR0 is associated with DBGWCR0 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR1" doc_id="armv7arm" header="Watchpoint Value Register 1">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR1 is associated with DBGWCR1 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR2" doc_id="armv7arm" header="Watchpoint Value Register 2">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR2 is associated with DBGWCR2 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR3" doc_id="armv7arm" header="Watchpoint Value Register 3">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR3 is associated with DBGWCR3 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR4" doc_id="armv7arm" header="Watchpoint Value Register 4">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR4 is associated with DBGWCR4 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR5" doc_id="armv7arm" header="Watchpoint Value Register 5">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR5 is associated with DBGWCR5 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR6" doc_id="armv7arm" header="Watchpoint Value Register 6">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR6 is associated with DBGWCR6 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR7" doc_id="armv7arm" header="Watchpoint Value Register 7">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR7 is associated with DBGWCR7 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR8" doc_id="armv7arm" header="Watchpoint Value Register 8">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR8 is associated with DBGWCR8 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR9" doc_id="armv7arm" header="Watchpoint Value Register 9">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR9 is associated with DBGWCR9 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR10" doc_id="armv7arm" header="Watchpoint Value Register 10">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR10 is associated with DBGWCR10 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR11" doc_id="armv7arm" header="Watchpoint Value Register 11">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR11 is associated with DBGWCR11 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR12" doc_id="armv7arm" header="Watchpoint Value Register 12">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR12 is associated with DBGWCR12 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR13" doc_id="armv7arm" header="Watchpoint Value Register 13">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR13 is associated with DBGWCR13 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR14" doc_id="armv7arm" header="Watchpoint Value Register 14">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR14 is associated with DBGWCR14 to form this watchpoint.</hint>
			<hint page="2299" token="DBGWVR15" doc_id="armv7arm" header="Watchpoint Value Register 15">Holds a data address value for use in watchpoint matching. 
The address used must be the virtual address of the data.

Used with a Watchpoint Control Register, DBGWCR. 
DBGWVR15 is associated with DBGWCR15 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR0" doc_id="armv7arm" header="Watchpoint Control Register 0">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR0 is associated with DBGWCR0 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR1" doc_id="armv7arm" header="Watchpoint Control Register 1">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR1 is associated with DBGWCR1 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR2" doc_id="armv7arm" header="Watchpoint Control Register 2">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR2 is associated with DBGWCR2 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR3" doc_id="armv7arm" header="Watchpoint Control Register 3">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR3 is associated with DBGWCR3 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR4" doc_id="armv7arm" header="Watchpoint Control Register 4">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR4 is associated with DBGWCR4 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR5" doc_id="armv7arm" header="Watchpoint Control Register 5">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR5 is associated with DBGWCR5 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR6" doc_id="armv7arm" header="Watchpoint Control Register 6">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR6 is associated with DBGWCR6 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR7" doc_id="armv7arm" header="Watchpoint Control Register 7">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR7 is associated with DBGWCR7 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR8" doc_id="armv7arm" header="Watchpoint Control Register 8">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR8 is associated with DBGWCR8 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR9" doc_id="armv7arm" header="Watchpoint Control Register 9">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR9 is associated with DBGWCR9 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR10" doc_id="armv7arm" header="Watchpoint Control Register 10">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR10 is associated with DBGWCR10 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR11" doc_id="armv7arm" header="Watchpoint Control Register 11">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR11 is associated with DBGWCR11 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR12" doc_id="armv7arm" header="Watchpoint Control Register 12">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR12 is associated with DBGWCR12 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR13" doc_id="armv7arm" header="Watchpoint Control Register 13">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR13 is associated with DBGWCR13 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR14" doc_id="armv7arm" header="Watchpoint Control Register 14">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR14 is associated with DBGWCR14 to form this watchpoint.</hint>
			<hint page="2293" token="DBGWCR15" doc_id="armv7arm" header="Watchpoint Control Register 15">Holds control information for a watchpoint.

Used in conjunction with a Watchpoint Value Register, DBGWVR. 
DBGWVR15 is associated with DBGWCR15 to form this watchpoint.</hint>
			<hint page="2219" token="DBGBXVR0" doc_id="armv7arm" header="Breakpoint Extended Value Register 0">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR1" doc_id="armv7arm" header="Breakpoint Extended Value Register 1">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR2" doc_id="armv7arm" header="Breakpoint Extended Value Register 2">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR3" doc_id="armv7arm" header="Breakpoint Extended Value Register 3">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR4" doc_id="armv7arm" header="Breakpoint Extended Value Register 4">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR5" doc_id="armv7arm" header="Breakpoint Extended Value Register 5">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR6" doc_id="armv7arm" header="Breakpoint Extended Value Register 6">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR7" doc_id="armv7arm" header="Breakpoint Extended Value Register 7">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR8" doc_id="armv7arm" header="Breakpoint Extended Value Register 8">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR9" doc_id="armv7arm" header="Breakpoint Extended Value Register 9">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR10" doc_id="armv7arm" header="Breakpoint Extended Value Register 10">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR11" doc_id="armv7arm" header="Breakpoint Extended Value Register 11">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR12" doc_id="armv7arm" header="Breakpoint Extended Value Register 12">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR13" doc_id="armv7arm" header="Breakpoint Extended Value Register 13">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR14" doc_id="armv7arm" header="Breakpoint Extended Value Register 14">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2219" token="DBGBXVR15" doc_id="armv7arm" header="Breakpoint Extended Value Register 15">Holds a value for use in breakpoint matching, to support VMID matching.

Used in conjunction with a Breakpoint Control Register DBGBCR, and a 
Breakpoint Value Register DBGBVR.</hint>
			<hint page="2269" token="DBGOSLAR" doc_id="armv7arm" header="OS Lock Access Register">Provides a lock for the debug registers.

Writing the key value to the DBGOSLAR also resets the 
internal counter for the OS Save or OS Restore operation.

The OS Lock may also disable Software debug events. Use 
DBGOSLSR to check the current status of the lock.</hint>
			<hint page="2270" token="DBGOSLSR" doc_id="armv7arm" header="OS Lock Status Register">Provides status information for the OS Lock.

In any implementation, software can read this register to detect 
whether the OS Save and Restore mechanism is implemented. If it 
is not implemented the read of DBGOSLSR.OSLM returns zero.</hint>
			<hint page="2272" token="DBGOSSRR" doc_id="armv7arm" header="OS Save and Restore Register">Software can save or restore the debug logic state of the 
processor by performing a series of reads or writes of the 
DBGOSSRR.

This register works in conjunction with an internal sequence 
counter to perform the OS Save or OS Restore operation. Writing 
the lock value to the DBGOSLAR resets this counter.
</hint>
			<hint page="2280" token="DBGPRCR" doc_id="armv7arm" header="Device Powerdown and Reset Control Register">Controls processor functionality related to reset and powerdown.
</hint>
			<hint page="2284" token="DBGPRSR" doc_id="armv7arm" header="Device Powerdown and Reset Status Register">Holds information about the reset and powerdown state of the processor.</hint>
			<hint page="2264" token="DBGITCTRL" doc_id="armv7arm" header="Integration Mode Control register">Switches the processor from its default functional mode into 
integration mode, where test software can control directly the 
inputs and outputs of the processor, for integration testing 
or topology detection. When the processor is in integration mode, 
the test software uses the IMPLEMENTATION DEFINED integration 
registers to drive output values and to read inputs.
</hint>
			<hint page="2211" token="DBGAUTHSTATUS" doc_id="armv7arm" header="Authentication Status register">Indicates the implemented debug authentication features and 
provides the current values of the configuration inputs that 
determine the debug permissions.</hint>
			<hint page="2226" token="DBGDEVID" doc_id="armv7arm" header="Debug Device ID register ">Adds to the information given by the DBGDIDR by describing 
other features of the debug implementation.</hint>
			<hint page="2229" token="DBGDEVID1" doc_id="armv7arm" header="Debug Device ID register 1">Adds to the information given by the DBGDIDR by describing 
other features of the debug implementation.
</hint>
			<hint page="2229" token="DBGDEVID2" doc_id="armv7arm" header="Debug Device ID register 2">Adds to the information given by the DBGDIDR by describing 
other features of the debug implementation.
</hint>
			<hint page="2225" token="DBGCLAIMSET" doc_id="armv7arm" header="Claim Tag Set Register">Used by software to set CLAIM bits to 1.
Used in conjunction with the DBGCLAIMCLR Register.</hint>
			<hint page="2224" token="DBGCLAIMCLR" doc_id="armv7arm" header="Claim Tag Clear Register">Used by software to read the values of the CLAIM bits, 
and to clear these bits to zero. Used in conjunction 
with the DBGCLAIMSET register.
</hint>
			<hint page="2243" token="DBGDSCRint" doc_id="armv7arm" header="Debug Status and Control Register">The main control register for the debug implementation.</hint>
			<hint page="2261" token="DBGDTRRXint" doc_id="armv7arm" header="Host to Target Data Transfer register">Transfers data from an external host to the ARM processor. 
For example it is used by a debugger transferring commands 
and data to a debug target. It is a component of the Debug 
Communication Channel (DCC).</hint>
			<hint page="2234" token="DBGDRAR" doc_id="armv7arm" header="Debug ROM Address Register">Defines the base physical address of a memory-mapped debug component, 
usually a ROM Table that locates and describes the memory-mapped 
debug components in the system. However, if this processor is the 
only memory-mapped debug component in the system, or the only 
memory-mapped debug component visible to this processor, then DBGDRAR 
defines the base physical address of this processor&apos;s debug registers.</hint>
			<hint page="2268" token="DBGOSDLR" doc_id="armv7arm" header="OS Double Lock Register ">Locks out an external debugger entirely.</hint>
			<hint page="2239" token="DBGDSAR" doc_id="armv7arm" header="Debug Self Address Offset Register">Defines the offset from the base address defined by DBGDRAR 
of the physical base address of the debug registers for the 
processor.
</hint>
		</group>
	</elements>
</documentation>
```

`Configurations/mips.xml`:

```xml
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<documentation>
	<document id="mips32" name="MIPS Architecture Reference Manual" version="1.0">
		<path>http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html</path>
	</document>
	<elements>
		<group type="ins" name="MIPS instructions">
<hint page="436" header="Add (with overflow)" doc_id="mips32" token="add">Adds two registers and stores the result in a
register

Syntax: add $d, $s, $t </hint>
<hint page="437" header="Add immediate (with overflow)" doc_id="mips32" token="addi">Adds a register and a sign-extended immediate
value and  stores the result in a register

Syntax: addi $t, $s, imm </hint>
<hint page="438" header="Add immediate unsigned (no overflow)" doc_id="mips32" token="addiu">Adds a register and a sign-extended immediate
value  and stores the result in a register

Syntax: addiu $t, $s, imm </hint>
<hint page="439" header="Add unsigned (no overflow)" doc_id="mips32" token="addu">Adds two registers and stores the result in a
register

Syntax: addu $d, $s, $t </hint>
<hint page="440" header="Bitwise and" doc_id="mips32" token="and">Bitwise ands two registers and stores the result
in  a register

Syntax: and $d, $s, $t </hint>
<hint page="441" header="Bitwise and immediate" doc_id="mips32" token="andi">Bitwise ands a register and an immediate value and
stores the result in a register

Syntax: andi $t, $s, imm </hint>
<hint page="442" header="Branch on equal" doc_id="mips32" token="beq">Branches if the two registers are equal

Syntax: beq $s, $t, offset </hint>
<hint page="443" header="Branch on greater than or equal to zero" doc_id="mips32" token="bgez">Branches if the register is greater than or equal
to  zero

Syntax: bgez $s, offset </hint>
<hint page="444" header="Branch on greater than or equal to zero and link" doc_id="mips32" token="bgezal">Branches if the register is greater than or equal
to  zero and saves the return address in $31

Syntax: bgezal $s, offset </hint>
<hint page="445" header="Branch on greater than zero" doc_id="mips32" token="bgtz">Branches if the register is greater than zero

Syntax: bgtz $s, offset </hint>
<hint page="446" header="Branch on less than or equal to zero" doc_id="mips32" token="blez">Branches if the register is less than or equal to
zero

Syntax: blez $s, offset </hint>
<hint page="447" header="Branch on less than zero" doc_id="mips32" token="bltz">Branches if the register is less than zero

Syntax: bltz $s, offset </hint>
<hint page="448" header="Branch on less than zero and link" doc_id="mips32" token="bltzal">Branches if the register is less than zero and
saves  the return address in $31

Syntax: bltzal $s, offset </hint>
<hint page="449" header="Branch on not equal" doc_id="mips32" token="bne">Branches if the two registers are not equal

Syntax: bne $s, $t, offset </hint>
<hint page="450" header="Divide" doc_id="mips32" token="div">Divides $s by $t and stores the quotient in $LO
and  the remainder in $HI

Syntax: div $s, $t </hint>
<hint page="451" header="Divide unsigned" doc_id="mips32" token="divu">Divides $s by $t and stores the quotient in $LO
and  the remainder in $HI

Syntax: divu $s, $t </hint>
<hint page="452" header="Jump" doc_id="mips32" token="j">Jumps to the calculated address

Syntax: j target </hint>
<hint page="453" header="Jump and link" doc_id="mips32" token="jal">Jumps to the calculated address and stores the
return address in $31

Syntax: jal target </hint>
<hint page="454" header="Jump register" doc_id="mips32" token="jr">Jump to the address contained in register $s

Syntax: jr $s </hint>
<hint page="455" header="Load byte" doc_id="mips32" token="lb">A byte is loaded into a register from the
specified  address.

Syntax: lb $t, offset($s) </hint>
<hint page="456" header="Load upper immediate" doc_id="mips32" token="lui">The immediate value is shifted left 16 bits and
stored in the register. The lower 16 bits are
zeroes.

Syntax: lui $t, imm</hint>
<hint page="457" header="Load word" doc_id="mips32" token="lw">A word is loaded into a register from the
specified  address.

Syntax: lw $t, offset($s) </hint>
<hint page="458" header="Move from HI" doc_id="mips32" token="mfhi">The contents of register HI are moved to the
specified register.

Syntax: mfhi $d </hint>
<hint page="459" header="Move from LO" doc_id="mips32" token="mflo">The contents of register LO are moved to the
specified register.

Syntax: mflo $d </hint>
<hint page="460" header="Multiply" doc_id="mips32" token="mult">Multiplies $s by $t and stores the result in $LO.

Syntax: mult $s, $t </hint>
<hint page="461" header="Multiply unsigned" doc_id="mips32" token="multu">Multiplies $s by $t and stores the result in $LO.

Syntax: multu $s, $t </hint>
<hint page="462" header="no operation" doc_id="mips32" token="noop">Performs no operation.

Syntax: noop </hint>
<hint page="463" header="Bitwise or" doc_id="mips32" token="or">Bitwise logical ors two registers and stores the
result in a register

Syntax: or $d, $s, $t </hint>
<hint page="464" header="Bitwise or immediate" doc_id="mips32" token="ori">Bitwise ors a register and an immediate value and
stores  the result in a register

Syntax: ori $t, $s, imm</hint>
<hint page="465" header="Store byte" doc_id="mips32" token="sb">The least significant byte of $t is stored at the
specified address.

Syntax: sb $t, offset($s) </hint>
<hint page="466" header="Shift left logical" doc_id="mips32" token="sll">Shifts a register value left by the shift amount
listed in the instruction and places the result in
a third register. Zeroes  are shifted in.

Syntax: sll $d, $t, h </hint>
<hint page="467" header="Shift left logical variable" doc_id="mips32" token="sllv">Shifts a register value left by the value in a
second register and places the result in a third
register. Zeroes are shifted  in.

Syntax: sllv $d, $t, $s </hint>
<hint page="468" header="Set on less than (signed)" doc_id="mips32" token="slt">If $s is less than $t, $d is set to one. It gets
zero otherwise.

Syntax: slt $d, $s, $t </hint>
<hint page="469" header="Set on less than immediate (signed)" doc_id="mips32" token="slti">If $s is less than immediate, $t is set to one. It
gets zero otherwise.

Syntax: slti $t, $s, imm </hint>
<hint page="470" header="Set on less than immediate unsigned" doc_id="mips32" token="sltiu">If $s is less than the unsigned immediate, $t is
set  to one. It gets zero otherwise.

Syntax: sltiu $t, $s, imm </hint>
<hint page="471" header="Set on less than unsigned" doc_id="mips32" token="sltu">If $s is less than $t, $d is set to one. It gets
zero otherwise.

Syntax: sltu $d, $s, $t </hint>
<hint page="472" header="Shift right arithmetic" doc_id="mips32" token="sra">Shifts a register value right by the shift amount
(shamt) and places the value in the destination
register.  The sign bit is shifted in.

Syntax: sra $d, $t, h </hint>
<hint page="473" header="Shift right logical" doc_id="mips32" token="srl">Shifts a register value right by the shift amount
(shamt) and places the value in the destination
register.  Zeroes are shifted in.

Syntax: srl $d, $t, h </hint>
<hint page="474" header="Shift right logical variable" doc_id="mips32" token="srlv">Shifts a register value right by the amount
specified in $s and places the value in the
destination register. Zeroes are  shifted in.

Syntax: srlv $d, $t, $s </hint>
<hint page="475" header="Subtract" doc_id="mips32" token="sub">Subtracts two registers and stores the result in a
register

Syntax: sub $d, $s, $t </hint>
<hint page="476" header="Subtract unsigned" doc_id="mips32" token="subu">Subtracts two registers and stores the result in a
register

Syntax: subu $d, $s, $t </hint>
<hint page="477" header="Store word" doc_id="mips32" token="sw">The contents of $t is stored at the specified
address.

Syntax: sw $t, offset($s) </hint>
<hint page="478" header="System call" doc_id="mips32" token="syscall">Generates a software interrupt.

Syntax: syscall </hint>
<hint page="479" header="Bitwise exclusive or" doc_id="mips32" token="xor">Exclusive ors two registers and stores the result
in  a register

Syntax: xor $d, $s, $t </hint>
<hint page="480" header="Bitwise exclusive or immediate" doc_id="mips32" token="xori">Bitwise exclusive ors a register and an immediate
value and stores the result in a register

Syntax: xori $t, $s, imm </hint>


		</group>
	</elements>
</documentation>

```

`Configurations/x86_64.xml`:

```xml
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<documentation>
	<document id="x86_64" name="Intel 64 and IA-32 Architectures Software Developer's Manual" version="1.0">
		<path>https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf</path>
	</document>
	<elements>
		<group type="ins" name="x86_64 instructions">
<hint page="0" header="ASCII Adjust After Addition" doc_id="x86_64" token="aaa">Adjusts the sum of two unpacked BCD values to create an unpacked BCD result. The AL register is the implied
source and destination operand for this instruction. The AAA instruction is only useful when it follows an ADD
instruction that adds (binary addition) two unpacked BCD values and stores a byte result in the AL register. The
AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.
If the addition produces a decimal carry, the AH register increments by 1, and the CF and AF flags are set. If there
was no decimal carry, the CF and AF flags are cleared and the AH register is unchanged. In either case, bits 4
through 7 of the AL register are set to 0.
This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</hint>
<hint page="0" header="ASCII Adjust AX Before Division" doc_id="x86_64" token="aad">Adjusts two unpacked BCD digits (the least-significant digit in the AL register and the most-significant digit in the
AH register) so that a division operation performed on the result will yield a correct unpacked BCD value. The AAD
instruction is only useful when it precedes a DIV instruction that divides (binary division) the adjusted value in the
AX register by an unpacked BCD value.
The AAD instruction sets the value in the AL register to (AL + (10 * AH)), and then clears the AH register to 00H.
The value in the AX register is then equal to the binary equivalent of the original unpacked two-digit (base 10)
number in registers AH and AL.
The generalized version of this instruction allows adjustment of two unpacked digits of any number base (see the
"Operation" section below), by setting the imm8 byte to the selected number base (for example, 08H for octal, 0AH
for decimal, or 0CH for base 12 numbers). The AAD mnemonic is interpreted by all assemblers to mean adjust
ASCII (base 10) values. To adjust values in another number base, the instruction must be hand coded in machine
code (D5 imm8).
This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</hint>
<hint page="0" header="ASCII Adjust AX After Multiply" doc_id="x86_64" token="aam">Adjusts the result of the multiplication of two unpacked BCD values to create a pair of unpacked (base 10) BCD
values. The AX register is the implied source and destination operand for this instruction. The AAM instruction is
only useful when it follows an MUL instruction that multiplies (binary multiplication) two unpacked BCD values and
stores a word result in the AX register. The AAM instruction then adjusts the contents of the AX register to contain
the correct 2-digit unpacked (base 10) BCD result.
The generalized version of this instruction allows adjustment of the contents of the AX to create two unpacked
digits of any number base (see the "Operation" section below). Here, the imm8 byte is set to the selected number
base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAM mnemonic is interpreted
by all assemblers to mean adjust to ASCII (base 10) values. To adjust to values in another number base, the
instruction must be hand coded in machine code (D4 imm8).
This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</hint>
<hint page="0" header="ASCII Adjust AL After Subtraction" doc_id="x86_64" token="aas">Adjusts the result of the subtraction of two unpacked BCD values to create a unpacked BCD result. The AL register
is the implied source and destination operand for this instruction. The AAS instruction is only useful when it follows
a SUB instruction that subtracts (binary subtraction) one unpacked BCD value from another and stores a byte
result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-
digit unpacked BCD result.
If the subtraction produced a decimal carry, the AH register decrements by 1, and the CF and AF flags are set. If no
decimal carry occurred, the CF and AF flags are cleared, and the AH register is unchanged. In either case, the AL
register is left with its top four bits set to 0.
This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</hint>
<hint page="0" header="Add with Carry" doc_id="x86_64" token="adc">Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and
stores the result in the destination operand. The destination operand can be a register or a memory location; the
source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be
used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate
value is used as an operand, it is sign-extended to the length of the destination operand format.</hint>
<hint page="0" header="Unsigned Integer Addition of Two Operands with Carry Flag" doc_id="x86_64" token="adcx">Performs an unsigned addition of the destination operand (first operand), the source operand (second operand)
and the carry-flag (CF) and stores the result in the destination operand. The destination operand is a general-
purpose register, whereas the source operand can be a general-purpose register or memory location. The state of
CF can represent a carry from a previous addition. The instruction sets the CF flag with the carry generated by the
unsigned addition of the operands.
The ADCX instruction is executed in the context of multi-precision addition, where we add a series of operands with
a carry-chain. At the beginning of a chain of additions, we need to make sure the CF is in a desired initial state.
Often, this initial state needs to be 0, which can be achieved with an instruction to zero the CF (e.g. XOR).
This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-
bit mode.
In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to addi-
tional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64 bits.
ADCX executes normally either inside or outside a transaction region.
Note: ADCX defines the OF flag differently than the ADD/ADC instructions as defined in Intel 64 and IA-32 Archi-
tectures Software Developer's Manual, Volume 2A.</hint>
<hint page="0" header="Add" doc_id="x86_64" token="add">Adds the destination operand (first operand) and the source operand (second operand) and then stores the result
in the destination operand. The destination operand can be a register or a memory location; the source operand
can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one
instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination
operand format.
The ADD instruction performs integer addition. It evaluates the result for both signed and unsigned integer oper-
ands and sets the CF and OF flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The
SF flag indicates the sign of the signed result.</hint>
<hint page="0" header="Add Packed Double-Precision Floating-Point Values" doc_id="x86_64" token="addpd">Add two, four or eight packed double-precision floating-point values from the first source operand to the second
source operand, and stores the packed double-precision floating-point results in the destination operand.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be
a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a
64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with
writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256)
of the corresponding ZMM register destination are zeroed.
VEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper Bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified.</hint>
<hint page="0" header="Add Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="addps">Add four, eight or sixteen packed single-precision floating-point values from the first source operand with the
second source operand, and stores the packed single-precision floating-point results in the destination operand.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be
a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a
32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with
writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256)
of the corresponding ZMM register destination are zeroed.
VEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper Bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified.</hint>
<hint page="0" header="Add Scalar Double-Precision Floating-Point Values" doc_id="x86_64" token="addsd">Adds the low double-precision floating-point values from the second source operand and the first source operand
and stores the double-precision floating-point result in the destination operand.
The second source operand can be an XMM register or a 64-bit memory location. The first source and destination
operands are XMM registers.
128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAX_VL-1:64) of the
corresponding destination register remain unchanged.
EVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:64) of
the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAX_VL-1:128)
of the destination register are zeroed.
EVEX version: The low quadword element of the destination is updated according to the writemask.
Software should ensure VADDSD is encoded with VEX.L=0. Encoding VADDSD with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Add Scalar Single-Precision Floating-Point Values" doc_id="x86_64" token="addss">Adds the low single-precision floating-point values from the second source operand and the first source operand,
and stores the double-precision floating-point result in the destination operand.
The second source operand can be an XMM register or a 64-bit memory location. The first source and destination
operands are XMM registers.
128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAX_VL-1:32) of the
corresponding the destination register remain unchanged.
EVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:32) of
the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAX_VL-1:128)
of the destination register are zeroed.
EVEX version: The low doubleword element of the destination is updated according to the writemask.
Software should ensure VADDSS is encoded with VEX.L=0. Encoding VADDSS with VEX.L=1 may encounter unpre-
dictable behavior across different processor generations.</hint>
<hint page="0" header="Packed Double-FP Add/Subtract" doc_id="x86_64" token="addsubpd">Adds odd-numbered double-precision floating-point values of the first source operand (second operand) with the
corresponding double-precision floating-point values from the second source operand (third operand); stores the
result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered
double-precision floating-point values from the second source operand from the corresponding double-precision
floating values in the first source operand; stores the result into the even-numbered values of the destination
operand.
In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
(XMM8-XMM15).
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
YMM register destination are unmodified. See Figure 3-3.
VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register.</hint>
<hint page="0" header="Packed Single-FP Add/Subtract" doc_id="x86_64" token="addsubps">Adds odd-numbered single-precision floating-point values of the first source operand (second operand) with the
corresponding single-precision floating-point values from the second source operand (third operand); stores the
result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered
single-precision floating-point values from the second source operand from the corresponding single-precision
floating values in the first source operand; stores the result into the even-numbered values of the destination
operand.
In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
(XMM8-XMM15).
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
YMM register destination are unmodified. See Figure 3-4.
VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register.</hint>
<hint page="0" header="Unsigned Integer Addition of Two Operands with Overflow Flag" doc_id="x86_64" token="adox">Performs an unsigned addition of the destination operand (first operand), the source operand (second operand)
and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a general-
purpose register, whereas the source operand can be a general-purpose register or memory location. The state of
OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the
unsigned addition of the operands.
The ADOX instruction is executed in the context of multi-precision addition, where we add a series of operands with
a carry-chain. At the beginning of a chain of additions, we execute an instruction to zero the OF (e.g. XOR).
This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit
mode.
In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to addi-
tional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64-bits.
ADOX executes normally either inside or outside a transaction region.
Note: ADOX defines the CF and OF flags differently than the ADD/ADC instructions as defined in Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 2A.</hint>
<hint page="0" header="Perform One Round of an AES Decryption Flow" doc_id="x86_64" token="aesdec">This instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, with the
round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and
store the result in the destination operand.
Use the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDE-
CLAST instruction.
128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an
XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-
1:128) of the corresponding YMM destination register remain unchanged.
VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM
register are zeroed.</hint>
<hint page="0" header="Perform Last Round of an AES Decryption Flow" doc_id="x86_64" token="aesdeclast">This instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, with the
round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and
store the result in the destination operand.
128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an
XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-
1:128) of the corresponding YMM destination register remain unchanged.
VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM
register are zeroed.</hint>
<hint page="0" header="Perform One Round of an AES Encryption Flow" doc_id="x86_64" token="aesenc">This instruction performs a single round of an AES encryption flow using a round key from the second source
operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination
operand.
Use the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENC-
CLAST instruction.
128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an
XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-
1:128) of the corresponding YMM destination register remain unchanged.
VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM
register are zeroed.</hint>
<hint page="0" header="Perform Last Round of an AES Encryption Flow" doc_id="x86_64" token="aesenclast">This instruction performs the last round of an AES encryption flow using a round key from the second source
operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination
operand.
128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an
XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-
1:128) of the corresponding YMM destination register remain unchanged.
VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
source operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM
register are zeroed.</hint>
<hint page="0" header="Perform the AES InvMixColumn Transformation" doc_id="x86_64" token="aesimc">Perform the InvMixColumns transformation on the source operand and store the result in the destination operand.
The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory loca-
tion.
Note: the AESIMC instruction should be applied to the expanded AES round keys (except for the first and last round
key) in order to prepare them for decryption using the "Equivalent Inverse Cipher" (defined in FIPS 197).
128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain
unchanged.
VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="AES Round Key Generation Assist" doc_id="x86_64" token="aeskeygenassist">Assist in expanding the AES cipher key, by computing steps towards generating a round key for encryption, using
128-bit data specified in the source operand and an 8-bit round constant specified as an immediate, store the
result in the destination operand.
The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory loca-
tion.
128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain
unchanged.
VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Logical AND" doc_id="x86_64" token="and">Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in
the destination operand location. The source operand can be an immediate, a register, or a memory location; the
destination operand can be a register or a memory location. (However, two memory operands cannot be used in
one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1;
otherwise, it is set to 0.
This instruction can be used with a LOCK prefix to allow the it to be executed atomically.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Logical AND NOT" doc_id="x86_64" token="andn">Performs a bitwise logical AND of inverted second operand (the first source operand) with the third operand (the
second source operand). The result is stored in the first operand (destination operand).
This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</hint>
<hint page="0" header="Bitwise Logical AND of Packed Double Precision Floating-Point Values" doc_id="x86_64" token="andpd">Performs a bitwise logical AND of the two, four or eight packed double-precision floating-point values from the first
source operand and the second source operand, and stores the result in the destination operand.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be
a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a
64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with
writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256) of the
corresponding ZMM register destination are zeroed.
VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
register destination are unmodified.</hint>
<hint page="0" header="Bitwise Logical AND of Packed Single Precision Floating-Point Values" doc_id="x86_64" token="andps">Performs a bitwise logical AND of the four, eight or sixteen packed single-precision floating-point values from the
first source operand and the second source operand, and stores the result in the destination operand.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be
a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a
32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with
writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256) of the
corresponding ZMM register destination are zeroed.
VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified.</hint>
<hint page="0" header="Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values" doc_id="x86_64" token="andnpd">Performs a bitwise logical AND NOT of the two, four or eight packed double-precision floating-point values from the
first source operand and the second source operand, and stores the result in the destination operand.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be
a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a
64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with
writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256) of the
corresponding ZMM register destination are zeroed.
VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
register destination are unmodified.</hint>
<hint page="0" header="Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values" doc_id="x86_64" token="andnps">Performs a bitwise logical AND NOT of the four, eight or sixteen packed single-precision floating-point values from
the first source operand and the second source operand, and stores the result in the destination operand.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be
a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a
32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with
writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256) of the
corresponding ZMM register destination are zeroed.
VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified.</hint>
<hint page="0" header="Adjust RPL Field of Segment Selector" doc_id="x86_64" token="arpl">Compares the RPL fields of two segment selectors. The first operand (the destination operand) contains one
segment selector and the second operand (source operand) contains the other. (The RPL field is located in bits 0
and 1 of each operand.) If the RPL field of the destination operand is less than the RPL field of the source operand,
the ZF flag is set and the RPL field of the destination operand is increased to match that of the source operand.
Otherwise, the ZF flag is cleared and no change is made to the destination operand. (The destination operand can
be a word register or a memory location; the source operand must be a word register.)
The ARPL instruction is provided for use by operating-system procedures (however, it can also be used by applica-
tions). It is generally used to adjust the RPL of a segment selector that has been passed to the operating system
by an application program to match the privilege level of the application program. Here the segment selector
passed to the operating system is placed in the destination operand and segment selector for the application
program's code segment is placed in the source operand. (The RPL field in the source operand represents the priv-
ilege level of the application program.) Execution of the ARPL instruction then ensures that the RPL of the segment
selector received by the operating system is no lower (does not have a higher privilege) than the privilege level of
the application program (the segment selector for the application program's code segment can be read from the
stack following a procedure call).
This instruction executes as described in compatibility mode and legacy mode. It is not encodable in 64-bit mode.
See "Checking Caller Access Privileges" in Chapter 3, "Protected-Mode Memory Management," of the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 3A, for more information about the use of this instruc-
tion.</hint>
<hint page="0" header="Blend Packed Double Precision Floating-Point Values" doc_id="x86_64" token="blendpd">Double-precision floating-point values from the second source operand (third operand) are conditionally merged
with values from the first source operand (second operand) and written to the destination operand (first operand).
The immediate bits [3:0] determine whether the corresponding double-precision floating-point value in the desti-
nation is copied from the second source or first source. If a bit in the mask, corresponding to a word, is "1", then
the double-precision floating-point value in the second source operand is copied, else the value in the first source
operand is copied.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
YMM register destination are unmodified.
VEX.128 encoded version: the first source operand is an XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of
the corresponding YMM register destination are zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register.</hint>
<hint page="0" header="Bit Field Extract" doc_id="x86_64" token="bextr">Extracts contiguous bits from the first source operand (the second operand) using an index value and length value
specified in the second source operand (the third operand). Bit 7:0 of the second source operand specifies the
starting bit position of bit extraction. A START value exceeding the operand size will not extract any bits from the
second source operand. Bit 15:8 of the second source operand specifies the maximum number of bits (LENGTH)
beginning at the START position to extract. Only bit positions up to (OperandSize -1) of the first source operand are
extracted. The extracted bits are written to the destination register, starting from the least significant bit. All higher
order bits in the destination operand (starting at bit position LENGTH) are zeroed. The destination register is
cleared if no bits are extracted.
This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</hint>
<hint page="0" header="Blend Packed Single Precision Floating-Point Values" doc_id="x86_64" token="blendps">Packed single-precision floating-point values from the second source operand (third operand) are conditionally
merged with values from the first source operand (second operand) and written to the destination operand (first
operand). The immediate bits [7:0] determine whether the corresponding single precision floating-point value in
the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is
"1", then the single-precision floating-point value in the second source operand is copied, else the value in the first
source operand is copied.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
YMM register destination are unmodified.
VEX.128 encoded version: The first source operand an XMM register. The second source operand is an XMM register
or 128-bit memory location. The destination operand is an XMM register. The upper bits (VLMAX-1:128) of the
corresponding YMM register destination are zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register.</hint>
<hint page="0" header="Variable Blend Packed Double Precision Floating-Point Values" doc_id="x86_64" token="blendvpd">Conditionally copy each quadword data element of double-precision floating-point value from the second source
operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits
are the most significant bit in each quadword element of the mask register.
Each quadword element of the destination operand is copied from:
.    the corresponding quadword element in the second source operand, if a mask bit is "1"; or
.    the corresponding quadword element in the first source operand, if a mask bit is "0"
The register assignment of the implicit mask operand for BLENDVPD is defined to be the architectural register
XMM0.
128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (VLMAX-1:128)
of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined
to be the architectural register XMM0. An attempt to execute BLENDVPD with a VEX prefix will cause #UD.
VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and
encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
ignored. The upper bits (VLMAX-1:128) of the corresponding YMM register (destination register) are zeroed.
VEX.W must be 0, otherwise, the instruction will #UD.
VEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source
operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and
encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
ignored. VEX.W must be 0, otherwise, the instruction will #UD.
VBLENDVPD permits the mask to be any XMM or YMM register. In contrast, BLENDVPD treats XMM0 implicitly as the
mask and do not support non-destructive destination operation.</hint>
<hint page="0" header="Variable Blend Packed Single Precision Floating-Point Values" doc_id="x86_64" token="blendvps">Conditionally copy each dword data element of single-precision floating-point value from the second source
operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits
are the most significant bit in each dword element of the mask register.
Each quadword element of the destination operand is copied from:
.    the corresponding dword element in the second source operand, if a mask bit is "1"; or
.    the corresponding dword element in the first source operand, if a mask bit is "0"
The register assignment of the implicit mask operand for BLENDVPS is defined to be the architectural register
XMM0.
128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (VLMAX-1:128)
of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined
to be the architectural register XMM0. An attempt to execute BLENDVPS with a VEX prefix will cause #UD.
VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and
encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
ignored. The upper bits (VLMAX-1:128) of the corresponding YMM register (destination register) are zeroed.
VEX.W must be 0, otherwise, the instruction will #UD.
VEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source
operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and
encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
ignored. VEX.W must be 0, otherwise, the instruction will #UD.
VBLENDVPS permits the mask to be any XMM or YMM register. In contrast, BLENDVPS treats XMM0 implicitly as the
mask and do not support non-destructive destination operation.</hint>
<hint page="0" header="Extract Lowest Set Isolated Bit" doc_id="x86_64" token="blsi">Extracts the lowest set bit from the source operand and set the corresponding bit in the destination register. All
other bits in the destination operand are zeroed. If no bits are set in the source operand, BLSI sets all the bits in
the destination to 0 and sets ZF and CF.
This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</hint>
<hint page="0" header="Get Mask Up to Lowest Set Bit" doc_id="x86_64" token="blsmsk">Sets all the lower bits of the destination operand to "1" up to and including lowest set bit (=1) in the source
operand. If source operand is zero, BLSMSK sets all bits of the destination operand to 1 and also sets CF to 1.
This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</hint>
<hint page="0" header="Reset Lowest Set Bit" doc_id="x86_64" token="blsr">Copies all bits from the source operand to the destination operand and resets (=0) the bit position in the destina-
tion operand that corresponds to the lowest set bit of the source operand. If the source operand is zero BLSR sets
CF.
This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</hint>
<hint page="0" header="Check Lower Bound" doc_id="x86_64" token="bndcl">Compare the address in the second operand with the lower bound in bnd. The second operand can be either a
register or memory operand. If the address is lower than the lower bound in bnd.LB, it will set BNDSTATUS to 01H
and signal a #BR exception.
This instruction does not cause any memory access, and does not read or write any flags.</hint>
<hint page="0" header="Check Upper Bound" doc_id="x86_64" token="bndcu">Compare the address in the second operand with the upper bound in bnd. The second operand can be either a
register or a memory operand. If the address is higher than the upper bound in bnd.UB, it will set BNDSTATUS to
01H and signal a #BR exception.
BNDCU perform 1's complement operation on the upper bound of bnd first before proceeding with address compar-
ison. BNDCN perform address comparison directly using the upper bound in bnd that is already reverted out of 1's
complement form.
This instruction does not cause any memory access, and does not read or write any flags.
Effective address computation of m32/64 has identical behavior to LEA</hint>
<hint page="0" header="Check Upper Bound" doc_id="x86_64" token="bndcn">Compare the address in the second operand with the upper bound in bnd. The second operand can be either a
register or a memory operand. If the address is higher than the upper bound in bnd.UB, it will set BNDSTATUS to
01H and signal a #BR exception.
BNDCU perform 1's complement operation on the upper bound of bnd first before proceeding with address compar-
ison. BNDCN perform address comparison directly using the upper bound in bnd that is already reverted out of 1's
complement form.
This instruction does not cause any memory access, and does not read or write any flags.
Effective address computation of m32/64 has identical behavior to LEA</hint>
<hint page="0" header="Load Extended Bounds Using Address Translation" doc_id="x86_64" token="bndldx">BNDLDX uses the linear address constructed from the base register and displacement of the SIB-addressing form
of the memory operand (mib) to perform address translation to access a bound table entry and conditionally load
the bounds in the BTE to the destination. The destination register is updated with the bounds in the BTE, if the
content of the index register of mib matches the pointer value stored in the BTE.
If the pointer value comparison fails, the destination is updated with INIT bounds (lb = 0x0, ub = 0x0) (note: as
articulated earlier, the upper bound is represented using 1's complement, therefore, the 0x0 value of upper bound
allows for access to full memory).
This instruction does not cause memory access to the linear address of mib nor the effective address referenced by
the base, and does not read or write any flags.
Segment overrides apply to the linear address computation with the base of mib, and are used during address
translation to generate the address of the bound table entry. By default, the address of the BTE is assumed to be
linear address. There are no segmentation checks performed on the base of mib.
The base of mib will not be checked for canonical address violation as it does not access memory.
Any encoding of this instruction that does not specify base or index register will treat those registers as zero
(constant). The reg-reg form of this instruction will remain a NOP.
The scale field of the SIB byte has no effect on these instructions and is ignored.
The bound register may be partially updated on memory faults. The order in which memory operands are loaded is
implementation specific.</hint>
<hint page="0" header="Make Bounds" doc_id="x86_64" token="bndmk">Makes bounds from the second operand and stores the lower and upper bounds in the bound register bnd. The
second operand must be a memory operand. The content of the base register from the memory operand is stored
in the lower bound bnd.LB. The 1's complement of the effective address of m32/m64 is stored in the upper bound
b.UB. Computation of m32/m64 has identical behavior to LEA.
This instruction does not cause any memory access, and does not read or write any flags.
If the instruction did not specify base register, the lower bound will be zero. The reg-reg form of this instruction
retains legacy behavior (NOP).
RIP relative instruction in 64-bit will #UD.</hint>
<hint page="0" header="Move Bounds" doc_id="x86_64" token="bndmov">BNDMOV moves a pair of lower and upper bound values from the source operand (the second operand) to the
destination (the first operand). Each operation is 128-bit move. The exceptions are same as the MOV instruction.
The memory format for loading/store bounds in 64-bit mode is shown in Figure 3-5.</hint>
<hint page="0" header="Store Extended Bounds Using Address Translation" doc_id="x86_64" token="bndstx">BNDSTX uses the linear address constructed from the displacement and base register of the SIB-addressing form
of the memory operand (mib) to perform address translation to store to a bound table entry. The bounds in the
source operand bnd are written to the lower and upper bounds in the BTE. The content of the index register of mib
is written to the pointer value field in the BTE.
This instruction does not cause memory access to the linear address of mib nor the effective address referenced by
the base, and does not read or write any flags.
Segment overrides apply to the linear address computation with the base of mib, and are used during address
translation to generate the address of the bound table entry. By default, the address of the BTE is assumed to be
linear address. There are no segmentation checks performed on the base of mib.
The base of mib will not be checked for canonical address violation as it does not access memory.
Any encoding of this instruction that does not specify base or index register will treat those registers as zero
(constant). The reg-reg form of this instruction will remain a NOP.
The scale field of the SIB byte has no effect on these instructions and is ignored.
The bound register may be partially updated on memory faults. The order in which memory operands are loaded is
implementation specific.</hint>
<hint page="0" header="Check Array Index Against Bounds" doc_id="x86_64" token="bound">BOUND determines if the first operand (array index) is within the bounds of an array specified the second operand
(bounds operand). The array index is a signed integer located in a register. The bounds operand is a memory loca-
tion that contains a pair of signed doubleword-integers (when the operand-size attribute is 32) or a pair of signed
word-integers (when the operand-size attribute is 16). The first doubleword (or word) is the lower bound of the
array and the second doubleword (or word) is the upper bound of the array. The array index must be greater than
or equal to the lower bound and less than or equal to the upper bound plus the operand size in bytes. If the index
is not within bounds, a BOUND range exceeded exception (#BR) is signaled. When this exception is generated, the
saved return instruction pointer points to the BOUND instruction.
The bounds limit data structure (two words or doublewords containing the lower and upper limits of the array) is
usually placed just before the array itself, making the limits addressable via a constant offset from the beginning of
the array. Because the address of the array already will be present in a register, this practice avoids extra bus cycles
to obtain the effective address of the array bounds.
This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</hint>
<hint page="0" header="Bit Scan Forward" doc_id="x86_64" token="bsf">Searches the source operand (second operand) for the least significant set bit (1 bit). If a least significant 1 bit is
found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a
memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source
operand. If the content of the source operand is 0, the content of the destination operand is undefined.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Bit Scan Reverse" doc_id="x86_64" token="bsr">Searches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is
found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a
memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source
operand. If the content source operand is 0, the content of the destination operand is undefined.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Byte Swap" doc_id="x86_64" token="bswap">Reverses the byte order of a 32-bit or 64-bit (destination) register. This instruction is provided for converting little-
endian values to big-endian format and vice versa. To swap bytes in a word value (16-bit register), use the XCHG
instruction. When the BSWAP instruction references a 16-bit register, the result is undefined.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Bit Test" doc_id="x86_64" token="bt">Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by
the bit offset (specified by the second operand) and stores the value of the bit in the CF flag. The bit base operand
can be a register or a memory location; the bit offset operand can be a register or an immediate value:
.    If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset
     operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit
     mode).
.    If the bit base operand specifies a memory location, the operand represents the address of the byte in memory
     that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be
     referenced by the offset operand depends on the operand size.
See also: Bit(BitBase, BitOffset) on page 3-11.
Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-
tion with the displacement field of the memory operand. In this case, the low-order 3 or 5 bits (3 for 16-bit oper-
ands, 5 for 32-bit operands) of the immediate bit offset are stored in the immediate bit offset field, and the high-
order bits are shifted and combined with the byte displacement in the addressing mode by the assembler. The
processor will ignore the high order bits if they are not zero.
When accessing a bit in memory, the processor may access 4 bytes starting from the memory address for a 32-bit
operand size, using by the following relationship:</hint>
<hint page="0" header="Bit Test and Complement" doc_id="x86_64" token="btc">Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by
the bit offset operand (second operand), stores the value of the bit in the CF flag, and complements the selected
bit in the bit string. The bit base operand can be a register or a memory location; the bit offset operand can be a
register or an immediate value:
.    If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset
     operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit
     mode). This allows any bit position to be selected.
.    If the bit base operand specifies a memory location, the operand represents the address of the byte in memory
     that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be
     referenced by the offset operand depends on the operand size.
See also: Bit(BitBase, BitOffset) on page 3-11.
Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-
tion with the displacement field of the memory operand. See "BT-Bit Test" in this chapter for more information on
this addressing mechanism.
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Bit Test and Reset" doc_id="x86_64" token="btr">Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by
the bit offset operand (second operand), stores the value of the bit in the CF flag, and clears the selected bit in the
bit string to 0. The bit base operand can be a register or a memory location; the bit offset operand can be a register
or an immediate value:
.    If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset
     operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit
     mode). This allows any bit position to be selected.
.    If the bit base operand specifies a memory location, the operand represents the address of the byte in memory
     that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be
     referenced by the offset operand depends on the operand size.
See also: Bit(BitBase, BitOffset) on page 3-11.
Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-
tion with the displacement field of the memory operand. See "BT-Bit Test" in this chapter for more information on
this addressing mechanism.
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Bit Test and Set" doc_id="x86_64" token="bts">Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by
the bit offset operand (second operand), stores the value of the bit in the CF flag, and sets the selected bit in the
bit string to 1. The bit base operand can be a register or a memory location; the bit offset operand can be a register
or an immediate value:
.    If the bit base operand specifies a register, the instruction takes the modulo 16, 32, or 64 of the bit offset
     operand (modulo size depends on the mode and register size; 64-bit operands are available only in 64-bit
     mode). This allows any bit position to be selected.
.    If the bit base operand specifies a memory location, the operand represents the address of the byte in memory
     that contains the bit base (bit 0 of the specified byte) of the bit string. The range of the bit position that can be
     referenced by the offset operand depends on the operand size.
See also: Bit(BitBase, BitOffset) on page 3-11.
Some assemblers support immediate bit offsets larger than 31 by using the immediate bit offset field in combina-
tion with the displacement field of the memory operand. See "BT-Bit Test" in this chapter for more information on
this addressing mechanism.
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Zero High Bits Starting with Specified Bit Position" doc_id="x86_64" token="bzhi">BZHI copies the bits of the first source operand (the second operand) into the destination operand (the first
operand) and clears the higher bits in the destination according to the INDEX value specified by the second source
operand (the third operand). The INDEX is specified by bits 7:0 of the second source operand. The INDEX value is
saturated at the value of OperandSize -1. CF is set, if the number contained in the 8 low bits of the third operand
is greater than OperandSize -1.
This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</hint>
<hint page="0" header="Call Procedure" doc_id="x86_64" token="call">Saves procedure linking information on the stack and branches to the called procedure specified using the target
operand. The target operand specifies the address of the first instruction in the called procedure. The operand can
be an immediate value, a general-purpose register, or a memory location.
This instruction can be used to execute four types of calls:
.     Near Call - A call to a procedure in the current code segment (the segment currently pointed to by the CS
      register), sometimes referred to as an intra-segment call.
.     Far Call - A call to a procedure located in a different segment than the current code segment, sometimes
      referred to as an inter-segment call.
.     Inter-privilege-level far call - A far call to a procedure in a segment at a different privilege level than that
      of the currently executing program or procedure.
.     Task switch - A call to a procedure located in a different task.
The latter two call types (inter-privilege-level call and task switch) can only be executed in protected mode. See
"Calling Procedures Using Call and RET" in Chapter 6 of the Intel 64 and IA-32 Architectures Software Devel-
oper's Manual, Volume 1, for additional information on near, far, and inter-privilege-level calls. See Chapter 7,
"Task Management," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, for infor-
mation on performing task switches with the CALL instruction.</hint>
<hint page="0" header="Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword" doc_id="x86_64" token="cbw">Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction
copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-
word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.
CBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attri-
bute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the
operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the
operand-size attribute to determine the size of values to be converted.
In 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes
this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit
31) of the doubleword in the EAX register into the high 32 bits of RAX.</hint>
<hint page="0" header="Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword" doc_id="x86_64" token="cwde">Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction
copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-
word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.
CBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attri-
bute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the
operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the
operand-size attribute to determine the size of values to be converted.
In 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes
this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit
31) of the doubleword in the EAX register into the high 32 bits of RAX.</hint>
<hint page="0" header="Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword" doc_id="x86_64" token="cdqe">Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction
copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-
word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.
CBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attri-
bute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the
operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the
operand-size attribute to determine the size of values to be converted.
In 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes
this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit
31) of the doubleword in the EAX register into the high 32 bits of RAX.</hint>
<hint page="0" header="Clear AC Flag in EFLAGS Register" doc_id="x86_64" token="clac">Clears the AC flag bit in EFLAGS register. This disables any alignment checking of user-mode data accesses. If the
SMAP bit is set in the CR4 register, this disallows explicit supervisor-mode data accesses to user-mode pages.
This instruction's operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute CLAC when
CPL &gt; 0 cause #UD.</hint>
<hint page="0" header="Clear Carry Flag" doc_id="x86_64" token="clc">Clears the CF flag in the EFLAGS register. Operation is the same in all modes.</hint>
<hint page="0" header="Clear Direction Flag" doc_id="x86_64" token="cld">Clears the DF flag in the EFLAGS register. When the DF flag is set to 0, string operations increment the index regis-
ters (ESI and/or EDI). Operation is the same in all modes.</hint>
<hint page="0" header="Flush Cache Line" doc_id="x86_64" token="clflush">Invalidates from every level of the cache hierarchy in the cache coherence domain the cache line that contains the
linear address specified with the memory operand. If that cache line contains modified data at any level of the
cache hierarchy, that data is written back to memory. The source operand is a byte memory location.
The availability of CLFLUSH is indicated by the presence of the CPUID feature flag CLFSH
(CPUID.01H:EDX[bit 19]). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8
through 15 of the EBX register when the initial value in the EAX register is 1).
The memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It
should be noted that processors are free to speculatively fetch and cache data from system memory regions
assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh
instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative
fetching can occur at any time and is not tied to instruction execution, the CLFLUSH instruction is not ordered with
respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be specula-
tively loaded into a cache line just before, during, or after the execution of a CLFLUSH instruction that references
the cache line).
Executions of the CLFLUSH instruction are ordered with respect to each other and with respect to writes, locked
read-modify-write instructions, fence instructions, and executions of CLFLUSHOPT to the same cache line.1 They
are not ordered with respect to executions of CLFLUSHOPT to different cache lines.
The CLFLUSH instruction can be used at all privilege levels and is subject to all permission checking and faults asso-
ciated with a byte load (and in addition, a CLFLUSH instruction is allowed to flush a linear address in an execute-
only segment). Like a load, the CLFLUSH instruction sets the A bit but not the D bit in the page tables.
In some implementations, the CLFLUSH instruction may always cause transactional abort with Transactional
Synchronization Extensions (TSX). The CLFLUSH instruction is not expected to be commonly used inside typical
transactional regions. However, programmers must not rely on CLFLUSH instruction to force a transactional abort,
since whether they cause transactional abort is implementation dependent.
The CLFLUSH instruction was introduced with the SSE2 extensions; however, because it has its own CPUID feature
flag, it can be implemented in IA-32 processors that do not include the SSE2 extensions. Also, detecting the pres-
ence of the SSE2 extensions with the CPUID instruction does not guarantee that the CLFLUSH instruction is imple-
mented in the processor.
CLFLUSH operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Flush Cache Line Optimized" doc_id="x86_64" token="clflushopt">Invalidates from every level of the cache hierarchy in the cache coherence domain the cache line that contains the
linear address specified with the memory operand. If that cache line contains modified data at any level of the
cache hierarchy, that data is written back to memory. The source operand is a byte memory location.
The availability of CLFLUSHOPT is indicated by the presence of the CPUID feature flag CLFLUSHOPT
(CPUID.(EAX=7,ECX=0):EBX[bit 23]). The aligned cache line size affected is also indicated with the CPUID instruc-
tion (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).
The memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It
should be noted that processors are free to speculatively fetch and cache data from system memory regions
assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh
instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative
fetching can occur at any time and is not tied to instruction execution, the CLFLUSH instruction is not ordered with
respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be specula-
tively loaded into a cache line just before, during, or after the execution of a CLFLUSH instruction that references
the cache line).
Executions of the CLFLUSHOPT instruction are ordered with respect to fence instructions and to locked read-
modify-write instructions; they are also ordered with respect to the following accesses to the cache line being
invalidated: writes, executions of CLFLUSH, and executions of CLFLUSHOPT. They are not ordered with respect to
writes, executions of CLFLUSH, or executions of CLFLUSHOPT that access other cache lines; to enforce ordering
with such an operation, software can insert an SFENCE instruction between CFLUSHOPT and that operation.
The CLFLUSHOPT instruction can be used at all privilege levels and is subject to all permission checking and faults
associated with a byte load (and in addition, a CLFLUSHOPT instruction is allowed to flush a linear address in an
execute-only segment). Like a load, the CLFLUSHOPT instruction sets the A bit but not the D bit in the page tables.
In some implementations, the CLFLUSHOPT instruction may always cause transactional abort with Transactional
Synchronization Extensions (TSX). The CLFLUSHOPT instruction is not expected to be commonly used inside
typical transactional regions. However, programmers must not rely on CLFLUSHOPT instruction to force a transac-
tional abort, since whether they cause transactional abort is implementation dependent.
CLFLUSHOPT operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Clear Interrupt Flag" doc_id="x86_64" token="cli">If protected-mode virtual interrupts are not enabled, CLI clears the IF flag in the EFLAGS register. No other flags
are affected. Clearing the IF flag causes the processor to ignore maskable external interrupts. The IF flag and the
CLI and STI instruction have no affect on the generation of exceptions and NMI interrupts.
When protected-mode virtual interrupts are enabled, CPL is 3, and IOPL is less than 3; CLI clears the VIF flag in the
EFLAGS register, leaving IF unaffected. Table 3-7 indicates the action of the CLI instruction depending on the
processor operating mode and the CPL/IOPL of the running program or procedure.
Operation is the same in all modes.</hint>
<hint page="0" header="Clear Task-Switched Flag in CR0" doc_id="x86_64" token="clts">Clears the task-switched (TS) flag in the CR0 register. This instruction is intended for use in operating-system
procedures. It is a privileged instruction that can only be executed at a CPL of 0. It is allowed to be executed in real-
address mode to allow initialization for protected mode.
The processor sets the TS flag every time a task switch occurs. The flag is used to synchronize the saving of FPU
context in multitasking applications. See the description of the TS flag in the section titled "Control Registers" in
Chapter 2 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, for more information
about this flag.
CLTS operation is the same in non-64-bit modes and 64-bit mode.
See Chapter 25, "VMX Non-Root Operation," of the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.</hint>
<hint page="0" header="Cache Line Write Back" doc_id="x86_64" token="clwb">Writes back to memory the cache line (if modified) that contains the linear address specified with the memory
operand from any level of the cache hierarchy in the cache coherence domain. The line may be retained in the
cache hierarchy in non-modified state. Retaining the line in the cache hierarchy is a performance optimization
(treated as a hint by hardware) to reduce the possibility of cache miss on a subsequent access. Hardware may
choose to retain the line at any of the levels in the cache hierarchy, and in some cases, may invalidate the line from
the cache hierarchy. The source operand is a byte memory location.
The availability of CLWB instruction is indicated by the presence of the CPUID feature flag CLWB (bit 24 of the EBX
register, see "CPUID - CPU Identification" in this chapter). The aligned cache line size affected is also indicated
with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).
The memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It
should be noted that processors are free to speculatively fetch and cache data from system memory regions that
are assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types).
PREFETCHh instructions can be used to provide the processor with hints for this speculative behavior. Because this
speculative fetching can occur at any time and is not tied to instruction execution, the CLWB instruction is not
ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can
be speculatively loaded into a cache line just before, during, or after the execution of a CLWB instruction that refer-
ences the cache line).
CLWB instruction is ordered only by store-fencing operations. For example, software can use an SFENCE, MFENCE,
XCHG, or LOCK-prefixed instructions to ensure that previous stores are included in the write-back. CLWB instruc-
tion need not be ordered by another CLWB or CLFLUSHOPT instruction. CLWB is implicitly ordered with older stores
executed by the logical processor to the same address.
For usages that require only writing back modified data from cache lines to memory (do not require the line to be
invalidated), and expect to subsequently access the data, software is recommended to use CLWB (with appropriate
fencing) instead of CLFLUSH or CLFLUSHOPT for improved performance.
The CLWB instruction can be used at all privilege levels and is subject to all permission checking and faults associ-
ated with a byte load. Like a load, the CLWB instruction sets the accessed flag but not the dirty flag in the page
tables.
In some implementations, the CLWB instruction may always cause transactional abort with Transactional Synchro-
nization Extensions (TSX). CLWB instruction is not expected to be commonly used inside typical transactional
regions. However, programmers must not rely on CLWB instruction to force a transactional abort, since whether
they cause transactional abort is implementation dependent.</hint>
<hint page="0" header="Complement Carry Flag" doc_id="x86_64" token="cmc">Complements the CF flag in the EFLAGS register. CMC operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Conditional Move (Above or Equal)" doc_id="x86_64" token="cmovae">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Greater Than or Equal)" doc_id="x86_64" token="cmovge">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Not Less Than or Equal)" doc_id="x86_64" token="cmovnle">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Not Below or Equal)" doc_id="x86_64" token="cmovnbe">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Not Great Than or Equal)" doc_id="x86_64" token="cmovnge">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Less Than or Equal)" doc_id="x86_64" token="cmovle">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Not Less Than)" doc_id="x86_64" token="cmovnl">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (No Overflow)" doc_id="x86_64" token="cmovno">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Not Above)" doc_id="x86_64" token="cmovna">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Not Below)" doc_id="x86_64" token="cmovnb">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (No Carry)" doc_id="x86_64" token="cmovnc">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Not Equal)" doc_id="x86_64" token="cmovne">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Not Greater Than)" doc_id="x86_64" token="cmovng">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Not Zero)" doc_id="x86_64" token="cmovnz">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Parity Even)" doc_id="x86_64" token="cmovpe">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (No Parity)" doc_id="x86_64" token="cmovnp">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (No Sign)" doc_id="x86_64" token="cmovns">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Parity Odd)" doc_id="x86_64" token="cmovpo">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Below or Equal)" doc_id="x86_64" token="cmovbe">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Above)" doc_id="x86_64" token="cmova">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Carry)" doc_id="x86_64" token="cmovc">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Below)" doc_id="x86_64" token="cmovb">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Equal)" doc_id="x86_64" token="cmove">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Greater Than)" doc_id="x86_64" token="cmovg">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Not Above or Equal)" doc_id="x86_64" token="cmovnae">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Less than)" doc_id="x86_64" token="cmovl">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Overflow)" doc_id="x86_64" token="cmovo">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Parity)" doc_id="x86_64" token="cmovp">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Sign)" doc_id="x86_64" token="cmovs">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Conditional Move (Zero)" doc_id="x86_64" token="cmovz">The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF,
and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is
associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move
is not performed and execution continues with the instruction following the CMOVcc instruction.
These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one
general-purpose register to another. Conditional moves of 8-bit register operands are not supported.
The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms "less"
and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used for
unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE
(conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.
The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be
supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking
the processor's feature information with the CPUID instruction (see "CPUID-CPU Identification" in this chapter).
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Compare Two Operands" doc_id="x86_64" token="cmp">Compares the first source operand with the second source operand and sets the status flags in the EFLAGS register
according to the results. The comparison is performed by subtracting the second operand from the first operand
and then setting the status flags in the same manner as the SUB instruction. When an immediate value is used as
an operand, it is sign-extended to the length of the first operand.
The condition codes used by the Jcc, CMOVcc, and SETcc instructions are based on the results of a CMP instruction.
Appendix B, "EFLAGS Condition Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual,
Volume 1, shows the relationship of the status flags and the condition codes.</hint>
<hint page="0" header="Compare Packed Double-Precision Floating-Point Values" doc_id="x86_64" token="cmppd">Performs a SIMD compare of the packed double-precision floating-point values in the second source operand and
the first source operand and returns the results of the comparison to the destination operand. The comparison
predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in
the two source operands.
EVEX encoded versions: The first source operand (second operand) is a ZMM/YMM/XMM register. The second
source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 64-bit memory location. The destination operand (first operand) is an opmask register.
Comparison results are written to the destination operand under the writemask k2. Each comparison result is a
single mask bit of 1 (comparison true) or 0 (comparison false).
VEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source
operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first
operand) is a YMM register. Four comparisons are performed with results written to the destination operand. The
result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false).
128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The
second source operand (second operand) can be an XMM register or 128-bit memory location. Bits (MAX_VL-
1:128) of the corresponding ZMM destination register remain unchanged. Two comparisons are performed with
results written to bits 127:0 of the destination operand. The result of each comparison is a quadword mask of all
1s (comparison true) or all 0s (comparison false).</hint>
<hint page="0" header="Compare Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="cmpps">Performs a SIMD compare of the packed single-precision floating-point values in the second source operand and
the first source operand and returns the results of the comparison to the destination operand. The comparison
predicate operand (immediate byte) specifies the type of comparison performed on each of the pairs of packed
values.
EVEX encoded versions: The first source operand (second operand) is a ZMM/YMM/XMM register. The second
source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 32-bit memory location. The destination operand (first operand) is an opmask register.
Comparison results are written to the destination operand under the writemask k2. Each comparison result is a
single mask bit of 1 (comparison true) or 0 (comparison false).
VEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand
(third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a
YMM register. Eight comparisons are performed with results written to the destination operand. The result of each
comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).
128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The
second source operand (second operand) can be an XMM register or 128-bit memory location. Bits (MAX_VL-
1:128) of the corresponding ZMM destination register remain unchanged. Four comparisons are performed with
results written to bits 127:0 of the destination operand. The result of each comparison is a doubleword mask of all
1s (comparison true) or all 0s (comparison false).</hint>
<hint page="0" header="Compare String Operands" doc_id="x86_64" token="cmps">Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word,
doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register
according to the results.
Both source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI
or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the
second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the
instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES
segment cannot be overridden.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands
to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the
source values. This explicit-operand form is provided to allow documentation. However, note that the documenta-
tion provided by this form can be misleading. That is, the source operand symbols must specify the correct type
(size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-</hint>
<hint page="0" header="Compare String Operands" doc_id="x86_64" token="cmpsb">Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word,
doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register
according to the results.
Both source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI
or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the
second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the
instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES
segment cannot be overridden.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands
to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the
source values. This explicit-operand form is provided to allow documentation. However, note that the documenta-
tion provided by this form can be misleading. That is, the source operand symbols must specify the correct type
(size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-</hint>
<hint page="0" header="Compare String Operands" doc_id="x86_64" token="cmpsw">Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word,
doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register
according to the results.
Both source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI
or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the
second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the
instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES
segment cannot be overridden.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands
to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the
source values. This explicit-operand form is provided to allow documentation. However, note that the documenta-
tion provided by this form can be misleading. That is, the source operand symbols must specify the correct type
(size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-</hint>
<hint page="0" header="Compare String Operands" doc_id="x86_64" token="cmpsd">Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word,
doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register
according to the results.
Both source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI
or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the
second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the
instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES
segment cannot be overridden.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands
to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the
source values. This explicit-operand form is provided to allow documentation. However, note that the documenta-
tion provided by this form can be misleading. That is, the source operand symbols must specify the correct type
(size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-</hint>
<hint page="0" header="Compare String Operands" doc_id="x86_64" token="cmpsq">Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word,
doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register
according to the results.
Both source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI
or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the
second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the
instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES
segment cannot be overridden.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands
to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the
source values. This explicit-operand form is provided to allow documentation. However, note that the documenta-
tion provided by this form can be misleading. That is, the source operand symbols must specify the correct type
(size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-</hint>
<hint page="0" header="Compare Scalar Double-Precision Floating-Point Value" doc_id="x86_64" token="cmpsd">Compares the low double-precision floating-point values in the second source operand and the first source operand
and returns the results in of the comparison to the destination operand. The comparison predicate operand (imme-
diate operand) specifies the type of comparison performed.
128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The
second source operand (second operand) can be an XMM register or 64-bit memory location. Bits (MAX_VL-1:64)
of the corresponding YMM destination register remain unchanged. The comparison result is a quadword mask of all
1s (comparison true) or all 0s (comparison false).
VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source
operand (third operand) can be an XMM register or a 64-bit memory location. The result is stored in the low quad-
word of the destination operand; the high quadword is filled with the contents of the high quadword of the first
source operand. Bits (MAX_VL-1:128) of the destination ZMM register are zeroed. The comparison result is a quad-
word mask of all 1s (comparison true) or all 0s (comparison false).
EVEX encoded version: The first source operand (second operand) is an XMM register. The second source operand
can be a XMM register or a 64-bit memory location. The destination operand (first operand) is an opmask register.
The comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false), written to the destination
starting from the LSB according to the writemask k2. Bits (MAX_KL-1:128) of the destination register are cleared.
The comparison predicate operand is an 8-bit immediate:
.     For instructions encoded using the VEX prefix, bits 4:0 define the type of comparison to be performed (see
      Table 3-1). Bits 5 through 7 of the immediate are reserved.
.     For instruction encodings that do not use VEX prefix, bits 2:0 define the type of comparison to be made (see
      the first 8 rows of Table 3-1). Bits 3 through 7 of the immediate are reserved.
The unordered relationship is true when at least one of the two source operands being compared is a NaN; the
ordered relationship is true when neither source operand is a NaN.
A subsequent computational instruction that uses the mask result in the destination operand as an input operand
will not generate an exception, because a mask of all 0s corresponds to a floating-point value of +0.0 and a mask
of all 1s corresponds to a QNaN.
Note that processors with "CPUID.1H:ECX.AVX =0" do not implement the "greater-than", "greater-than-or-equal",
"not-greater than", and "not-greater-than-or-equal relations" predicates. These comparisons can be made either
by using the inverse relationship (that is, use the "not-less-than-or-equal" to make a "greater-than" comparison)</hint>
<hint page="0" header="Compare Scalar Single-Precision Floating-Point Value" doc_id="x86_64" token="cmpss">Compares the low single-precision floating-point values in the second source operand and the first source operand
and returns the results of the comparison to the destination operand. The comparison predicate operand (imme-
diate operand) specifies the type of comparison performed.
128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The
second source operand (second operand) can be an XMM register or 32-bit memory location. Bits (MAX_VL-1:32)
of the corresponding YMM destination register remain unchanged. The comparison result is a doubleword mask of
all 1s (comparison true) or all 0s (comparison false).
VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source
operand (third operand) can be an XMM register or a 32-bit memory location. The result is stored in the low 32 bits
of the destination operand; bits 128:32 of the destination operand are copied from the first source operand. Bits
(MAX_VL-1:128) of the destination ZMM register are zeroed. The comparison result is a doubleword mask of all 1s
(comparison true) or all 0s (comparison false).
EVEX encoded version: The first source operand (second operand) is an XMM register. The second source operand
can be a XMM register or a 32-bit memory location. The destination operand (first operand) is an opmask register.
The comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false), written to the destination
starting from the LSB according to the writemask k2. Bits (MAX_KL-1:128) of the destination register are cleared.
The comparison predicate operand is an 8-bit immediate:
.     For instructions encoded using the VEX prefix, bits 4:0 define the type of comparison to be performed (see
      Table 3-1). Bits 5 through 7 of the immediate are reserved.
.     For instruction encodings that do not use VEX prefix, bits 2:0 define the type of comparison to be made (see
      the first 8 rows of Table 3-1). Bits 3 through 7 of the immediate are reserved.</hint>
<hint page="0" header="Compare and Exchange" doc_id="x86_64" token="cmpxchg">Compares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two
values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the
destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode.
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the
interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the
comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is
written into the destination. (The processor never produces a locked read without also producing a locked write.)
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Compare and Exchange Bytes" doc_id="x86_64" token="cmpxchg8b">Compares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand
(destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored
in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX).
The destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For
the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the
low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-
order 64 bits and RAX and RBX contain the low-order 64bits of a 128-bit value.
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the
interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the
comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is
written into the destination. (The processor never produces a locked read without also producing a locked write.)
In 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. Note that
CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned. See the summary chart at the
beginning of this section for encoding data and limits. For information on the CPUID flag that indicates
CMPXCHG16B, see page 3-206.</hint>
<hint page="0" header="Compare and Exchange Bytes" doc_id="x86_64" token="cmpxchg16b">Compares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand
(destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored
in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX).
The destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For
the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the
low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-
order 64 bits and RAX and RBX contain the low-order 64bits of a 128-bit value.
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the
interface to the processor's bus, the destination operand receives a write cycle without regard to the result of the
comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is
written into the destination. (The processor never produces a locked read without also producing a locked write.)
In 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. Note that
CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned. See the summary chart at the
beginning of this section for encoding data and limits. For information on the CPUID flag that indicates
CMPXCHG16B, see page 3-206.</hint>
<hint page="0" header="Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS" doc_id="x86_64" token="comisd">Compares the double-precision floating-point values in the low quadwords of operand 1 (first operand) and
operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unor-
dered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unor-
dered result is returned if either source operand is a NaN (QNaN or SNaN).
Operand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory
location. The COMISD instruction differs from the UCOMISD instruction in that it signals a SIMD floating-point
invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISD instruction signals
an invalid numeric exception only if a source operand is an SNaN.
The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.
Software should ensure VCOMISD is encoded with VEX.L=0. Encoding VCOMISD with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" doc_id="x86_64" token="comiss">Compares the single-precision floating-point values in the low quadwords of operand 1 (first operand) and operand
2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered,
greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result
is returned if either source operand is a NaN (QNaN or SNaN).
Operand 1 is an XMM register; operand 2 can be an XMM register or a 32 bit memory location.
The COMISS instruction differs from the UCOMISS instruction in that it signals a SIMD floating-point invalid opera-
tion exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISS instruction signals an invalid
numeric exception only if a source operand is an SNaN.
The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.
Software should ensure VCOMISS is encoded with VEX.L=0. Encoding VCOMISS with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="CPU Identification" doc_id="x86_64" token="cpuid">The ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can
set and clear this flag, the processor executing the procedure supports the CPUID instruction. This instruction oper-
ates the same in non-64-bit modes and 64-bit mode.
CPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers.1 The
instruction's output is dependent on the contents of the EAX register upon execution (in some cases, ECX as well).
For example, the following pseudocode loads EAX with 00H and causes CPUID to return a Maximum Return Value
and the Vendor Identification String in the appropriate registers:</hint>
<hint page="0" header="Accumulate CRC32 Value" doc_id="x86_64" token="crc32">Starting with an initial value in the first operand (destination operand), accumulates a CRC32 (polynomial
11EDC6F41H) value for the second operand (source operand) and stores the result in the destination operand. The
source operand can be a register or a memory location. The destination operand must be an r32 or r64 register. If
the destination is an r64 register, then the 32-bit result is stored in the least significant double word and
00000000H is stored in the most significant double word of the r64 register.
The initial value supplied in the destination operand is a double word integer stored in the r32 register or the least
significant double word of the r64 register. To incrementally accumulate a CRC32 value, software retains the result
of the previous CRC32 operation in the destination operand, then executes the CRC32 instruction again with new
input data in the source operand. Data contained in the source operand is processed in reflected bit order. This
means that the most significant bit of the source operand is treated as the least significant bit of the quotient, and
so on, for all the bits of the source operand. Likewise, the result of the CRC operation is stored in the destination
operand in reflected bit order. This means that the most significant bit of the resulting CRC (bit 31) is stored in the
least significant bit of the destination operand (bit 0), and so on, for all the bits of the CRC.</hint>
<hint page="0" header="Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point" doc_id="x86_64" token="cvtdq2pd">Converts two, four or eight packed signed doubleword integers in the source operand (the second operand) to two,
four or eight packed double-precision floating-point values in the destination operand (the first operand).
EVEX encoded versions: The source operand can be a YMM/XMM/XMM (low 64 bits) register, a 256/128/64-bit
memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand
is a ZMM/YMM/XMM register conditionally updated with writemask k1. Attempt to encode this instruction with EVEX
embedded rounding is ignored.
VEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
operand is a YMM register.
VEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination
operand is a XMM register. The upper Bits (MAX_VL-1:128) of the corresponding ZMM register destination are
zeroed.
128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination
operand is an XMM register. The upper Bits (MAX_VL-1:128) of the corresponding ZMM register destination are
unmodified.
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point" doc_id="x86_64" token="cvtdq2ps">Converts four, eight or sixteen packed signed doubleword integers in the source operand to four, eight or sixteen
packed single-precision floating-point values in the destination operand.
EVEX encoded versions: The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a
ZMM/YMM/XMM register conditionally updated with writemask k1.
VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
operand is a YMM register. Bits (MAX_VL-1:256) of the corresponding register destination are zeroed.
VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
operand is a XMM register. The upper bits (MAX_VL-1:128) of the corresponding register destination are zeroed.
128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
operand is an XMM register. The upper Bits (MAX_VL-1:128) of the corresponding register destination are unmod-
ified.
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Double-Precision Floating-Point Values to Packed Doubleword" doc_id="x86_64" token="cvtpd2dq">Converts packed double-precision floating-point values in the source operand (second operand) to packed signed
doubleword integers in the destination operand (first operand).
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register or the embedded rounding control bits. If a converted result cannot be represented in the destination
format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value
(2w-1, where w represents the number of bits in the destination format) is returned.
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512-bit memory location, or a 512-bit
vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register condi-
tionally updated with writemask k1. The upper bits (MAX_VL-1:256/128/64) of the corresponding destination are
zeroed.
VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
operand is an XMM register. The upper bits (MAX_VL-1:128) of the corresponding ZMM register destination are
zeroed.
VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
operand is a XMM register. The upper bits (MAX_VL-1:64) of the corresponding ZMM register destination are
zeroed.
128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
operand is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper bits
(MAX_VL-1:128) of the corresponding ZMM register destination are unmodified.
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Double-Precision FP Values to Packed Dword Integers" doc_id="x86_64" token="cvtpd2pi">Converts two packed double-precision floating-point values in the source operand (second operand) to two packed
signed doubleword integers in the destination operand (first operand).
The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX tech-
nology register.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid
exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.
This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
floating-point exception is pending, the exception is handled before the CVTPD2PI instruction is executed.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision" doc_id="x86_64" token="cvtpd2ps">Converts two, four or eight packed double-precision floating-point values in the source operand (second operand)
to two, four or eight packed single-precision floating-point values in the destination operand (first operand).
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register or the embedded rounding control bits.
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or
a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a
YMM/XMM/XMM (low 64-bits) register conditionally updated with writemask k1. The upper bits (MAX_VL-
1:256/128/64) of the corresponding destination are zeroed.
VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
operand is an XMM register. The upper bits (MAX_VL-1:128) of the corresponding ZMM register destination are
zeroed.
VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
operand is a XMM register. The upper bits (MAX_VL-1:64) of the corresponding ZMM register destination are
zeroed.
128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
operand is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper Bits
(MAX_VL-1:128) of the corresponding ZMM register destination are unmodified.
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Dword Integers to Packed Double-Precision FP Values" doc_id="x86_64" token="cvtpi2pd">Converts two packed signed doubleword integers in the source operand (second operand) to two packed double-
precision floating-point values in the destination operand (first operand).
The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an
XMM register. In addition, depending on the operand configuration:
.    For operands xmm, mm: the instruction causes a transition from x87 FPU to MMX technology operation (that
     is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this
     instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before
     the CVTPI2PD instruction is executed.
.    For operands xmm, m64: the instruction does not cause a transition to MMX technology and does not take
     x87 FPU exceptions.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Convert Packed Dword Integers to Packed Single-Precision FP Values" doc_id="x86_64" token="cvtpi2ps">Converts two packed signed doubleword integers in the source operand (second operand) to two packed single-
precision floating-point values in the destination operand (first operand).
The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an
XMM register. The results are stored in the low quadword of the destination operand, and the high quadword
remains unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control
bits in the MXCSR register.
This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
floating-point exception is pending, the exception is handled before the CVTPI2PS instruction is executed.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Convert Packed Single-Precision Floating-Point Values to Packed Signed" doc_id="x86_64" token="cvtps2dq">Converts four, eight or sixteen packed single-precision floating-point values in the source operand to four, eight or
sixteen signed doubleword integers in the destination operand.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register or the embedded rounding control bits. If a converted result cannot be represented in the destination
format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value
(2w-1, where w represents the number of bits in the destination format) is returned.
EVEX encoded versions: The source operand is a ZMM register, a 512-bit memory location or a 512-bit vector
broadcasted from a 32-bit memory location. The destination operand is a ZMM register conditionally updated with
writemask k1.
VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
operand is a YMM register. The upper bits (MAX_VL-1:256) of the corresponding ZMM register destination are
zeroed.
VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
operand is a XMM register. The upper bits (MAX_VL-1:128) of the corresponding ZMM register destination are
zeroed.
128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
operand is an XMM register. The upper bits (MAX_VL-1:128) of the corresponding ZMM register destination are
unmodified.
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision" doc_id="x86_64" token="cvtps2pd">Converts two, four or eight packed single-precision floating-point values in the source operand (second operand)
to two, four or eight packed double-precision floating-point values in the destination operand (first operand).
EVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64-bits) register, a 256/128/64-bit memory
location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a
ZMM/YMM/XMM register conditionally updated with writemask k1.
VEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
operand is a YMM register. Bits (MAX_VL-1:256) of the corresponding destination ZMM register are zeroed.
VEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination
operand is a XMM register. The upper Bits (MAX_VL-1:128) of the corresponding ZMM register destination are
zeroed.
128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination
operand is an XMM register. The upper Bits (MAX_VL-1:128) of the corresponding ZMM register destination are
unmodified.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Single-Precision FP Values to Packed Dword Integers" doc_id="x86_64" token="cvtps2pi">Converts two packed single-precision floating-point values in the source operand (second operand) to two packed
signed doubleword integers in the destination operand (first operand).
The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX tech-
nology register. When the source operand is an XMM register, the two single-precision floating-point values are
contained in the low quadword of the register. When a conversion is inexact, the value returned is rounded
according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum
signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indef-
inite integer value (80000000H) is returned.
CVTPS2PI causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer
is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-
point exception is pending, the exception is handled before the CVTPS2PI instruction is executed.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer" doc_id="x86_64" token="cvtsd2si">Converts a double-precision floating-point value in the source operand (the second operand) to a signed double-
word integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit
memory location. The destination operand is a general-purpose register. When the source operand is an XMM
register, the double-precision floating-point value is contained in the low quadword of the register.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register.
If a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode
with REX.W/VEX.W/EVEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the
indefinite integer value (80000000H) is returned.
If a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and
REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the
indefinite integer value (80000000_00000000H) is returned.
Legacy SSE instruction: Use of the REX.W prefix promotes the instruction to produce 64-bit data in 64-bit mode.
See the summary chart at the beginning of this section for encoding data and limits.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.
Software should ensure VCVTSD2SI is encoded with VEX.L=0. Encoding VCVTSD2SI with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision" doc_id="x86_64" token="cvtsd2ss">Converts a double-precision floating-point value in the "convert-from" source operand (the second operand in
SSE2 version, otherwise the third operand) to a single-precision floating-point value in the destination operand.
When the "convert-from" operand is an XMM register, the double-precision floating-point value is contained in the
low quadword of the register. The result is stored in the low doubleword of the destination operand. When the
conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.
128-bit Legacy SSE version: The "convert-from" source operand (the second operand) is an XMM register or
memory location. Bits (MAX_VL-1:32) of the corresponding destination register remain unchanged. The destina-
tion operand is an XMM register.
VEX.128 and EVEX encoded versions: The "convert-from" source operand (the third operand) can be an XMM
register or a 64-bit memory location. The first source and destination operands are XMM registers. Bits (127:32) of
the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAX_VL-
1:128) of the destination register are zeroed.
EVEX encoded version: the converted result in written to the low doubleword element of the destination under the
writemask.
Software should ensure VCVTSD2SS is encoded with VEX.L=0. Encoding VCVTSD2SS with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value" doc_id="x86_64" token="cvtsi2sd">Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the "convert-from"
source operand to a double-precision floating-point value in the destination operand. The result is stored in the low
quadword of the destination operand, and the high quadword left unchanged. When conversion is inexact, the
value returned is rounded according to the rounding control bits in the MXCSR register.
The second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and
destination operands are XMM registers.
128-bit Legacy SSE version: Use of the REX.W prefix promotes the instruction to 64-bit operands. The "convert-
from" source operand (the second operand) is a general-purpose register or memory location. The destination is
an XMM register Bits (MAX_VL-1:64) of the corresponding destination register remain unchanged.
VEX.128 and EVEX encoded versions: The "convert-from" source operand (the third operand) can be a general-
purpose register or a memory location. The first source and destination operands are XMM registers. Bits (127:64)
of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAX_VL-
1:128) of the destination register are zeroed.
EVEX.W0 version: attempt to encode this instruction with EVEX embedded rounding is ignored.
VEX.W1 and EVEX.W1 versions: promotes the instruction to use 64-bit input value in 64-bit mode.
Software should ensure VCVTSI2SD is encoded with VEX.L=0. Encoding VCVTSI2SD with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value" doc_id="x86_64" token="cvtsi2ss">Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the "convert-from"
source operand to a single-precision floating-point value in the destination operand (first operand). The "convert-
from" source operand can be a general-purpose register or a memory location. The destination operand is an XMM
register. The result is stored in the low doubleword of the destination operand, and the upper three doublewords
are left unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control
bits in the MXCSR register or the embedded rounding control bits.
128-bit Legacy SSE version: In 64-bit mode, Use of the REX.W prefix promotes the instruction to use 64-bit input
value. The "convert-from" source operand (the second operand) is a general-purpose register or memory location.
Bits (MAX_VL-1:32) of the corresponding destination register remain unchanged.
VEX.128 and EVEX encoded versions: The "convert-from" source operand (the third operand) can be a general-
purpose register or a memory location. The first source and destination operands are XMM registers. Bits (127:32)
of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAX_VL-
1:128) of the destination register are zeroed.
EVEX encoded version: the converted result in written to the low doubleword element of the destination under the
writemask.
Software should ensure VCVTSI2SS is encoded with VEX.L=0. Encoding VCVTSI2SS with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision" doc_id="x86_64" token="cvtss2sd">Converts a single-precision floating-point value in the "convert-from" source operand to a double-precision
floating-point value in the destination operand. When the "convert-from" source operand is an XMM register, the
single-precision floating-point value is contained in the low doubleword of the register. The result is stored in the
low quadword of the destination operand.
128-bit Legacy SSE version: The "convert-from" source operand (the second operand) is an XMM register or
memory location. Bits (MAX_VL-1:64) of the corresponding destination register remain unchanged. The destina-
tion operand is an XMM register.
VEX.128 and EVEX encoded versions: The "convert-from" source operand (the third operand) can be an XMM
register or a 32-bit memory location. The first source and destination operands are XMM registers. Bits (127:64) of
the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAX_VL-
1:128) of the destination register are zeroed.
Software should ensure VCVTSS2SD is encoded with VEX.L=0. Encoding VCVTSS2SD with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer" doc_id="x86_64" token="cvtss2si">Converts a single-precision floating-point value in the source operand (the second operand) to a signed double-
word integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand).
The source operand can be an XMM register or a memory location. The destination operand is a general-purpose
register. When the source operand is an XMM register, the single-precision floating-point value is contained in the
low doubleword of the register.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register or the embedded rounding control bits. If a converted result cannot be represented in the destination
format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value
(2w-1, where w represents the number of bits in the destination format) is returned.
Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to produce 64-bit data.
See the summary chart at the beginning of this section for encoding data and limits.
VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.
Software should ensure VCVTSS2SI is encoded with VEX.L=0. Encoding VCVTSS2SI with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Convert with Truncation Packed Double-Precision Floating-Point Values to" doc_id="x86_64" token="cvttpd2dq">Converts two, four or eight packed double-precision floating-point values in the source operand (second operand)
to two, four or eight packed signed doubleword integers in the destination operand (first operand).
When a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than
the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is
masked, the indefinite integer value (80000000H) is returned.
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or
a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a
YMM/XMM/XMM (low 64 bits) register conditionally updated with writemask k1. The upper bits (MAX_VL-1:256) of
the corresponding destination are zeroed.
VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
operand is an XMM register. The upper bits (MAX_VL-1:128) of the corresponding ZMM register destination are
zeroed.
VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
operand is a XMM register. The upper bits (MAX_VL-1:64) of the corresponding ZMM register destination are
zeroed.
128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
operand is an XMM register. The upper bits (MAX_VL-1:128) of the corresponding ZMM register destination are
unmodified.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert with Truncation Packed Double-Precision FP Values to Packed Dword" doc_id="x86_64" token="cvttpd2pi">Converts two packed double-precision floating-point values in the source operand (second operand) to two packed
signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register
or a 128-bit memory location. The destination operand is an MMX technology register.
When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger
than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is
masked, the indefinite integer value (80000000H) is returned.
This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
floating-point exception is pending, the exception is handled before the CVTTPD2PI instruction is executed.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Convert with Truncation Packed Single-Precision Floating-Point Values to Packed" doc_id="x86_64" token="cvttps2dq">Converts four, eight or sixteen packed single-precision floating-point values in the source operand to four, eight or
sixteen signed doubleword integers in the destination operand.
When a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than
the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is
masked, the indefinite integer value (80000000H) is returned.
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or
a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a
ZMM/YMM/XMM register conditionally updated with writemask k1.
VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination
operand is a YMM register. The upper bits (MAX_VL-1:256) of the corresponding ZMM register destination are
zeroed.
VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination
operand is a XMM register. The upper bits (MAX_VL-1:128) of the corresponding ZMM register destination are
zeroed.
128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination
operand is an XMM register. The upper bits (MAX_VL-1:128) of the corresponding ZMM register destination are
unmodified.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert with Truncation Packed Single-Precision FP Values to Packed Dword" doc_id="x86_64" token="cvttps2pi">Converts two packed single-precision floating-point values in the source operand (second operand) to two packed
signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register
or a 64-bit memory location. The destination operand is an MMX technology register. When the source operand is
an XMM register, the two single-precision floating-point values are contained in the low quadword of the register.
When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger
than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is
masked, the indefinite integer value (80000000H) is returned.
This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
floating-point exception is pending, the exception is handled before the CVTTPS2PI instruction is executed.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed" doc_id="x86_64" token="cvttsd2si">Converts a double-precision floating-point value in the source operand (the second operand) to a signed double-
word integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand).
The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general
purpose register. When the source operand is an XMM register, the double-precision floating-point value is
contained in the low quadword of the register.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register.
If a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode
with REX.W/VEX.W/EVEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the
indefinite integer value (80000000H) is returned.
If a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and
REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the
indefinite integer value (80000000_00000000H) is returned.
Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See
the summary chart at the beginning of this section for encoding data and limits.
VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert with Truncation Scalar Single-Precision Floating-Point Value to Integer" doc_id="x86_64" token="cvttss2si">Converts a single-precision floating-point value in the source operand (the second operand) to a signed doubleword
integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand). The
source operand can be an XMM register or a 32-bit memory location. The destination operand is a general purpose
register. When the source operand is an XMM register, the single-precision floating-point value is contained in the
low doubleword of the register.
When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than
the maximum signed doubleword integer, the floating-point invalid exception is raised. If this exception is masked,
the indefinite integer value (80000000H or 80000000_00000000H if operand size is 64 bits) is returned.
Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See
the summary chart at the beginning of this section for encoding data and limits.
VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.
Software should ensure VCVTTSS2SI is encoded with VEX.L=0. Encoding VCVTTSS2SI with VEX.L=1 may
encounter unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Convert Word to Doubleword/Convert Doubleword to Quadword" doc_id="x86_64" token="cwd">Doubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign
extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction
copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction
copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruc-
tion (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position
in the RDX register.
The CWD instruction can be used to produce a doubleword dividend from a word before word division. The CDQ
instruction can be used to produce a quadword dividend from a doubleword before doubleword division. The CQO
instruction can be used to produce a double quadword dividend from a quadword before a quadword division.
The CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the
operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers
may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these
mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the
size of values to be converted, regardless of the mnemonic used.
In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same
opcode as CWD/CDQ. See the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Convert Word to Doubleword/Convert Doubleword to Quadword" doc_id="x86_64" token="cdq">Doubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign
extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction
copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction
copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruc-
tion (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position
in the RDX register.
The CWD instruction can be used to produce a doubleword dividend from a word before word division. The CDQ
instruction can be used to produce a quadword dividend from a doubleword before doubleword division. The CQO
instruction can be used to produce a double quadword dividend from a quadword before a quadword division.
The CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the
operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers
may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these
mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the
size of values to be converted, regardless of the mnemonic used.
In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same
opcode as CWD/CDQ. See the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Convert Word to Doubleword/Convert Doubleword to Quadword" doc_id="x86_64" token="cqo">Doubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign
extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction
copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction
copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruc-
tion (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position
in the RDX register.
The CWD instruction can be used to produce a doubleword dividend from a word before word division. The CDQ
instruction can be used to produce a quadword dividend from a doubleword before doubleword division. The CQO
instruction can be used to produce a double quadword dividend from a quadword before a quadword division.
The CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the
operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers
may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these
mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the
size of values to be converted, regardless of the mnemonic used.
In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same
opcode as CWD/CDQ. See the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Decimal Adjust AL after Addition" doc_id="x86_64" token="daa">Adjusts the sum of two packed BCD values to create a packed BCD result. The AL register is the implied source and
destination operand. The DAA instruction is only useful when it follows an ADD instruction that adds (binary addi-
tion) two 2-digit, packed BCD values and stores a byte result in the AL register. The DAA instruction then adjusts
the contents of the AL register to contain the correct 2-digit, packed BCD result. If a decimal carry is detected, the
CF and AF flags are set accordingly.
This instruction executes as described above in compatibility mode and legacy mode. It is not valid in 64-bit mode.</hint>
<hint page="0" header="Decimal Adjust AL after Subtraction" doc_id="x86_64" token="das">Adjusts the result of the subtraction of two packed BCD values to create a packed BCD result. The AL register is the
implied source and destination operand. The DAS instruction is only useful when it follows a SUB instruction that
subtracts (binary subtraction) one 2-digit, packed BCD value from another and stores a byte result in the AL
register. The DAS instruction then adjusts the contents of the AL register to contain the correct 2-digit, packed BCD
result. If a decimal borrow is detected, the CF and AF flags are set accordingly.
This instruction executes as described above in compatibility mode and legacy mode. It is not valid in 64-bit mode.</hint>
<hint page="0" header="Decrement by 1" doc_id="x86_64" token="dec">Subtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be
a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag.
(To perform a decrement operation that updates the CF flag, use a SUB instruction with an immediate operand of
1.)
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
In 64-bit mode, DEC r16 and DEC r32 are not encodable (because opcodes 48H through 4FH are REX prefixes).
Otherwise, the instruction's 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to
additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.
See the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Unsigned Divide" doc_id="x86_64" token="div">Divides unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers (dividend) by the source operand
(divisor) and stores the result in the AX (AH:AL), DX:AX, EDX:EAX, or RDX:RAX registers. The source operand can
be a general-purpose register or a memory location. The action of this instruction depends on the operand size
(dividend/divisor). Division using 64-bit operand is available only in 64-bit mode.
Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magni-
tude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is
applied, the instruction divides the unsigned value in RDX:RAX by the source operand and stores the quotient in
RAX, the remainder in RDX.
See the summary chart at the beginning of this section for encoding data and limits. See Table 3-15.
                                                    Table 3-15. DIV Action
                                                                                                                  Maximum
 Operand Size                          Dividend         Divisor         Quotient            Remainder             Quotient
 Word/byte                             AX               r/m8            AL                  AH                    255
 Doubleword/word                       DX:AX            r/m16           AX                  DX                    65,535
 Quadword/doubleword                   EDX:EAX          r/m32           EAX                 EDX                   232 - 1
 Doublequadword/                       RDX:RAX          r/m64           RAX                 RDX                   264 - 1
 quadword</hint>
<hint page="0" header="Divide Packed Double-Precision Floating-Point Values" doc_id="x86_64" token="divpd">Performs a SIMD divide of the double-precision floating-point values in the first source operand by the floating-
point values in the second source operand (the third operand). Results are written to the destination operand (the
first operand).
EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second
source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally
updated with writemask k1.
VEX.256 encoded version: The first source operand (the second operand) is a YMM register. The second source
operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper
bits (MAX_VL-1:256) of the corresponding destination are zeroed.
VEX.128 encoded version: The first source operand (the second operand) is a XMM register. The second source
operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper
bits (MAX_VL-1:128) of the corresponding destination are zeroed.
128-bit Legacy SSE version: The second source operand (the second operand) can be an XMM register or an 128-
bit memory location. The destination is the same as the first source operand. The upper bits (MAX_VL-1:128) of the
corresponding destination are unmodified.</hint>
<hint page="0" header="Divide Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="divps">Performs a SIMD divide of the four, eight or sixteen packed single-precision floating-point values in the first source
operand (the second operand) by the four, eight or sixteen packed single-precision floating-point values in the
second source operand (the third operand). Results are written to the destination operand (the first operand).
EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second
source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally
updated with writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified.</hint>
<hint page="0" header="Divide Scalar Double-Precision Floating-Point Value" doc_id="x86_64" token="divsd">Divides the low double-precision floating-point value in the first source operand by the low double-precision
floating-point value in the second source operand, and stores the double-precision floating-point result in the desti-
nation operand. The second source operand can be an XMM register or a 64-bit memory location. The first source
and destination are XMM registers.
128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAX_VL-
1:64) of the corresponding ZMM destination register remain unchanged.
VEX.128 encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The quadword at bits
127:64 of the destination operand is copied from the corresponding quadword of the first source operand. Bits
(MAX_VL-1:128) of the destination register are zeroed.
EVEX.128 encoded version: The first source operand is an xmm register encoded by EVEX.vvvv. The quadword
element of the destination operand at bits 127:64 are copied from the first source operand. Bits (MAX_VL-1:128)
of the destination register are zeroed.
EVEX version: The low quadword element of the destination is updated according to the writemask.
Software should ensure VDIVSD is encoded with VEX.L=0. Encoding VDIVSD with VEX.L=1 may encounter unpre-
dictable behavior across different processor generations.</hint>
<hint page="0" header="Divide Scalar Single-Precision Floating-Point Values" doc_id="x86_64" token="divss">Divides the low single-precision floating-point value in the first source operand by the low single-precision floating-
point value in the second source operand, and stores the single-precision floating-point result in the destination
operand. The second source operand can be an XMM register or a 32-bit memory location.
128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAX_VL-
1:32) of the corresponding YMM destination register remain unchanged.
VEX.128 encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The three high-order
doublewords of the destination operand are copied from the first source operand. Bits (MAX_VL-1:128) of the
destination register are zeroed.
EVEX.128 encoded version: The first source operand is an xmm register encoded by EVEX.vvvv. The doubleword
elements of the destination operand at bits 127:32 are copied from the first source operand. Bits (MAX_VL-1:128)
of the destination register are zeroed.
EVEX version: The low doubleword element of the destination is updated according to the writemask.
Software should ensure VDIVSS is encoded with VEX.L=0. Encoding VDIVSS with VEX.L=1 may encounter unpre-
dictable behavior across different processor generations.</hint>
<hint page="0" header="Dot Product of Packed Double Precision Floating-Point Values" doc_id="x86_64" token="dppd">Conditionally multiplies the packed double-precision floating-point values in the destination operand (first operand)
with the packed double-precision floating-point values in the source (second operand) depending on a mask
extracted from bits [5:4] of the immediate operand (third operand). If a condition mask bit is zero, the corre-
sponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 1.
The two resulting double-precision values are summed into an intermediate result. The intermediate result is
conditionally broadcasted to the destination using a broadcast mask specified by bits [1:0] of the immediate byte.
If a broadcast mask bit is "1", the intermediate result is copied to the corresponding qword element in the destina-
tion operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.
DPPD follows the NaN forwarding rules stated in the Software Developer's Manual, vol. 1, table 4.7. These rules do
not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of
those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally gener-
ated NaNs will have at least one NaN propagated to the destination.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
YMM register destination are unmodified.
VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
zeroed.
If VDPPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an
#UD exception.</hint>
<hint page="0" header="Dot Product of Packed Single Precision Floating-Point Values" doc_id="x86_64" token="dpps">Conditionally multiplies the packed single precision floating-point values in the destination operand (first operand)
with the packed single-precision floats in the source (second operand) depending on a mask extracted from the
high 4 bits of the immediate byte (third operand). If a condition mask bit in Imm8[7:4] is zero, the corresponding
multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel 64 and IA-32 Archi-
tectures Software Developer's Manual, Volume 1.
The four resulting single-precision values are summed into an intermediate result. The intermediate result is condi-
tionally broadcasted to the destination using a broadcast mask specified by bits [3:0] of the immediate byte.
If a broadcast mask bit is "1", the intermediate result is copied to the corresponding dword element in the destina-
tion operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.
DPPS follows the NaN forwarding rules stated in the Software Developer's Manual, vol. 1, table 4.7. These rules do
not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of
those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally gener-
ated NaNs will have at least one NaN propagated to the destination.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding
YMM register destination are unmodified.
VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination
operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register.</hint>
<hint page="0" header="Empty MMX Technology State" doc_id="x86_64" token="emms">Sets the values of all the tags in the x87 FPU tag word to empty (all 1s). This operation marks the x87 FPU data
registers (which are aliased to the MMX technology registers) as available for use by x87 FPU floating-point instruc-
tions. (See Figure 8-7 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for the
format of the x87 FPU tag word.) All other MMX instructions (other than the EMMS instruction) set all the tags in
x87 FPU tag word to valid (all 0s).
The EMMS instruction must be used to clear the MMX technology state at the end of all MMX technology procedures
or subroutines and before calling other procedures or subroutines that may execute x87 floating-point instructions.
If a floating-point instruction loads one of the registers in the x87 FPU data register stack before the x87 FPU tag
word has been reset by the EMMS instruction, an x87 floating-point register stack overflow can occur that will
result in an x87 floating-point exception or incorrect result.
EMMS operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Make Stack Frame for Procedure Parameters" doc_id="x86_64" token="enter">Creates a stack frame (comprising of space for dynamic storage and 1-32 frame pointer storage) for a procedure.
The first operand (imm16) specifies the size of the dynamic storage in the stack frame (that is, the number of bytes
of dynamically allocated on the stack for the procedure). The second operand (imm8) gives the lexical nesting level
(0 to 31) of the procedure. The nesting level (imm8 mod 32) and the OperandSize attribute determine the size in
bytes of the storage space for frame pointers.
The nesting level determines the number of frame pointers that are copied into the "display area" of the new stack
frame from the preceding frame. The default size of the frame pointer is the StackAddrSize attribute, but can be
overridden using the 66H prefix. Thus, the OperandSize attribute determines the size of each frame pointer that
will be copied into the stack frame and the data being transferred from SP/ESP/RSP register into the BP/EBP/RBP
register.
The ENTER and companion LEAVE instructions are provided to support block structured languages. The ENTER
instruction (when used) is typically the first instruction in a procedure and is used to set up a new stack frame for
a procedure. The LEAVE instruction is then used at the end of the procedure (just before the RET instruction) to
release the stack frame.
If the nesting level is 0, the processor pushes the frame pointer from the BP/EBP/RBP register onto the stack,
copies the current stack pointer from the SP/ESP/RSP register into the BP/EBP/RBP register, and loads the
SP/ESP/RSP register with the current stack-pointer value minus the value in the size operand. For nesting levels of
1 or greater, the processor pushes additional frame pointers on the stack before adjusting the stack pointer. These
additional frame pointers provide the called procedure with access points to other nested frames on the stack. See
"Procedure Calls for Block-Structured Languages" in Chapter 6 of the Intel 64 and IA-32 Architectures Software
Developer's Manual, Volume 1, for more information about the actions of the ENTER instruction.
The ENTER instruction causes a page fault whenever a write using the final value of the stack pointer (within the
current stack segment) would do so.
In 64-bit mode, default operation size is 64 bits; 32-bit operation size cannot be encoded. Use of 66H prefix
changes frame pointer operand size to 16 bits.
When the 66H prefix is used and causing the OperandSize attribute to be less than the StackAddrSize, software is
responsible for the following:
.   The companion LEAVE instruction must also use the 66H prefix,
.   The value in the RBP/EBP register prior to executing "66H ENTER" must be within the same 16KByte region of
    the current stack pointer (RSP/ESP), such that the value of RBP/EBP after "66H ENTER" remains a valid address
    in the stack. This ensures "66H LEAVE" can restore 16-bits of data from the stack.</hint>
<hint page="0" header="Extract Packed Floating-Point Values" doc_id="x86_64" token="extractps">Extracts a single-precision floating-point value from the source operand (second operand) at the 32-bit offset spec-
ified from imm8. Immediate bits higher than the most significant offset for the vector length are ignored.
The extracted single-precision floating-point value is stored in the low 32-bits of the destination operand
In 64-bit mode, destination register operand has default operand size of 64 bits. The upper 32-bits of the register
are filled with zero. REX.W is ignored.
VEX.128 and EVEX encoded version: When VEX.W1 or EVEX.W1 form is used in 64-bit mode with a general
purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits.
VEX.vvvv/EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
128-bit Legacy SSE version: When a REX.W prefix is used in 64-bit mode with a general purpose register (GPR) as
a destination operand, the packed single quantity is zero extended to 64 bits.
The source register is an XMM register. Imm8[1:0] determine the starting DWORD offset from which to extract the
32-bit floating-point value.
If VEXTRACTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause
an #UD exception.</hint>
<hint page="0" header="Compute 2x-1" doc_id="x86_64" token="f2xm1">Computes the exponential value of 2 to the power of the source operand minus 1. The source operand is located in
register ST(0) and the result is also stored in ST(0). The value of the source operand must lie in the range -1.0 to
+1.0. If the source value is outside this range, the result is undefined.
The following table shows the results obtained when computing the exponential value of various classes of
numbers, assuming that neither overflow nor underflow occurs.
                                         Table 3-16. Results Obtained from F2XM1
                           ST(0) SRC                                                   ST(0) DEST
                           - 1.0 to -0                                                 - 0.5 to - 0
                               -0                                                           -0
                               +0                                                           +0
                           + 0 to +1.0                                                  + 0 to 1.0</hint>
<hint page="0" header="Absolute Value" doc_id="x86_64" token="fabs">Clears the sign bit of ST(0) to create the absolute value of the operand. The following table shows the results
obtained when creating the absolute value of various classes of numbers.</hint>
<hint page="0" header="Add" doc_id="x86_64" token="fadd">Adds the destination and source operands and stores the sum in the destination location. The destination operand
is always an FPU register; the source operand can be a register or a memory location. Source operands in memory
can be in single-precision or double-precision floating-point format or in word or doubleword integer format.
The no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-
operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents
of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice
versa. The value in ST(0) can be doubled by coding:</hint>
<hint page="0" header="Add" doc_id="x86_64" token="faddp">Adds the destination and source operands and stores the sum in the destination location. The destination operand
is always an FPU register; the source operand can be a register or a memory location. Source operands in memory
can be in single-precision or double-precision floating-point format or in word or doubleword integer format.
The no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-
operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents
of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice
versa. The value in ST(0) can be doubled by coding:</hint>
<hint page="0" header="Add" doc_id="x86_64" token="fiadd">Adds the destination and source operands and stores the sum in the destination location. The destination operand
is always an FPU register; the source operand can be a register or a memory location. Source operands in memory
can be in single-precision or double-precision floating-point format or in word or doubleword integer format.
The no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-
operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents
of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice
versa. The value in ST(0) can be doubled by coding:</hint>
<hint page="0" header="Load Binary Coded Decimal" doc_id="x86_64" token="fbld">Converts the BCD source operand into double extended-precision floating-point format and pushes the value onto
the FPU stack. The source operand is loaded without rounding errors. The sign of the source operand is preserved,
including that of -0.
The packed BCD digits are assumed to be in the range 0 through 9; the instruction does not check for invalid digits
(AH through FH). Attempting to load an invalid encoding produces an undefined result.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Store BCD Integer and Pop" doc_id="x86_64" token="fbstp">Converts the value in the ST(0) register to an 18-digit packed BCD integer, stores the result in the destination
operand, and pops the register stack. If the source value is a non-integral value, it is rounded to an integer value,
according to rounding mode specified by the RC field of the FPU control word. To pop the register stack, the
processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
The destination operand specifies the address where the first byte destination value is to be stored. The BCD value
(including its sign bit) requires 10 bytes of space in memory.
The following table shows the results obtained when storing various classes of numbers in packed BCD format.
                                                     Table 3-19. FBSTP Results
                              ST(0)                                                           DEST
            - inf or Value Too Large for DEST Format                                              *
                              F&lt;=-1                                                             -D
                            -1 &lt; F &lt; -0                                                         **
                                  -0                                                           -0
                                  +0                                                           +0
                           + 0 &lt; F &lt; +1                                                         **
                              F &gt;= +1                                                           +D
            + inf or Value Too Large for DEST Format                                              *
                               NaN                                                              *
 NOTES:
 F Means finite floating-point value.
 D Means packed-BCD number.
 * Indicates floating-point invalid-operation (#IA) exception.
 ** +-0 or +-1, depending on the rounding mode.</hint>
<hint page="0" header="Change Sign" doc_id="x86_64" token="fchs">Complements the sign bit of ST(0). This operation changes a positive value into a negative value of equal magni-
tude or vice versa. The following table shows the results obtained when changing the sign of various classes of
numbers.
                                                Table 3-20. FCHS Results
                            ST(0) SRC                                              ST(0) DEST
 -inf                                                        +inf
 -F                                                        +F
 -0                                                        +0
 +0                                                        -0
 +F                                                        -F
 +inf                                                        -inf
 NaN                                                       NaN
 NOTES:
 * F means finite floating-point value.</hint>
<hint page="0" header="Clear Exceptions" doc_id="x86_64" token="fclex">Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception summary status flag (ES), the
stack fault flag (SF), and the busy flag (B) in the FPU status word. The FCLEX instruction checks for and handles
any pending unmasked floating-point exceptions before clearing the exception flags; the FNCLEX instruction does
not.
The assembler issues two instructions for the FCLEX instruction (an FWAIT instruction followed by an FNCLEX
instruction), and the processor executes each of these instructions separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.</hint>
<hint page="0" header="Clear Exceptions" doc_id="x86_64" token="fnclex">Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception summary status flag (ES), the
stack fault flag (SF), and the busy flag (B) in the FPU status word. The FCLEX instruction checks for and handles
any pending unmasked floating-point exceptions before clearing the exception flags; the FNCLEX instruction does
not.
The assembler issues two instructions for the FCLEX instruction (an FWAIT instruction followed by an FNCLEX
instruction), and the processor executes each of these instructions separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.</hint>
<hint page="0" header="Floating-Point Conditional Move (Above or Equal)" doc_id="x86_64" token="fcmovae">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Greater Than or Equal)" doc_id="x86_64" token="fcmovge">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Not Less Than or Equal)" doc_id="x86_64" token="fcmovnle">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Not Below or Equal)" doc_id="x86_64" token="fcmovnbe">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Not Great Than or Equal)" doc_id="x86_64" token="fcmovnge">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Less Than or Equal)" doc_id="x86_64" token="fcmovle">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Not Less Than)" doc_id="x86_64" token="fcmovnl">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (No Overflow)" doc_id="x86_64" token="fcmovno">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Not Above)" doc_id="x86_64" token="fcmovna">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Not Below)" doc_id="x86_64" token="fcmovnb">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (No Carry)" doc_id="x86_64" token="fcmovnc">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Not Equal)" doc_id="x86_64" token="fcmovne">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Not Greater Than)" doc_id="x86_64" token="fcmovng">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Not Zero)" doc_id="x86_64" token="fcmovnz">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Parity Even)" doc_id="x86_64" token="fcmovpe">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (No Parity)" doc_id="x86_64" token="fcmovnp">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (No Sign)" doc_id="x86_64" token="fcmovns">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Parity Odd)" doc_id="x86_64" token="fcmovpo">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Below or Equal)" doc_id="x86_64" token="fcmovbe">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Above)" doc_id="x86_64" token="fcmova">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Carry)" doc_id="x86_64" token="fcmovc">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Below)" doc_id="x86_64" token="fcmovb">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Equal)" doc_id="x86_64" token="fcmove">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Greater Than)" doc_id="x86_64" token="fcmovg">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Not Above or Equal)" doc_id="x86_64" token="fcmovnae">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Less than)" doc_id="x86_64" token="fcmovl">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Overflow)" doc_id="x86_64" token="fcmovo">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Parity)" doc_id="x86_64" token="fcmovp">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Sign)" doc_id="x86_64" token="fcmovs">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Floating-Point Conditional Move (Zero)" doc_id="x86_64" token="fcmovz">Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination
operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Descrip-
tion column above and in Chapter 8 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1. The source operand is always in the ST(i) register and the destination operand is always ST(0).
The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching
overhead for IF operations and the possibility of branch mispredictions by the processor.
A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are
supported by checking the processor's feature information with the CPUID instruction (see "COMISS-Compare
Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS" in this chapter). If both the CMOV and FPU
feature bits are set, the FCMOVcc instructions are supported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Compare Floating Point Values" doc_id="x86_64" token="fcom">Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU
status word according to the results (see the table below). The source operand can be a data register or a memory
location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is
ignored, so that -0.0 is equal to +0.0.
                                          Table 3-21. FCOM/FCOMP/FCOMPP Results
                  Condition                               C3                            C2                          C0
                 ST(0) &gt; SRC                               0                            0                            0
                 ST(0) &lt; SRC                               0                            0                            1
                 ST(0) = SRC                               1                            0                            0
                 Unordered*                                1                            1                            1
 NOTES:
 * Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</hint>
<hint page="0" header="Compare Floating Point Values" doc_id="x86_64" token="fcomp">Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU
status word according to the results (see the table below). The source operand can be a data register or a memory
location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is
ignored, so that -0.0 is equal to +0.0.
                                          Table 3-21. FCOM/FCOMP/FCOMPP Results
                  Condition                               C3                            C2                          C0
                 ST(0) &gt; SRC                               0                            0                            0
                 ST(0) &lt; SRC                               0                            0                            1
                 ST(0) = SRC                               1                            0                            0
                 Unordered*                                1                            1                            1
 NOTES:
 * Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</hint>
<hint page="0" header="Compare Floating Point Values" doc_id="x86_64" token="fcompp">Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU
status word according to the results (see the table below). The source operand can be a data register or a memory
location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is
ignored, so that -0.0 is equal to +0.0.
                                          Table 3-21. FCOM/FCOMP/FCOMPP Results
                  Condition                               C3                            C2                          C0
                 ST(0) &gt; SRC                               0                            0                            0
                 ST(0) &lt; SRC                               0                            0                            1
                 ST(0) = SRC                               1                            0                            0
                 Unordered*                                1                            1                            1
 NOTES:
 * Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</hint>
<hint page="0" header="Compare Floating Point Values and Set EFLAGS" doc_id="x86_64" token="fcomi">Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and
CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for compari-
sons, so that -0.0 is equal to +0.0.
                                   Table 3-22. FCOMI/FCOMIP/ FUCOMI/FUCOMIP Results
                     Comparison Results*                                    ZF                      PF                     CF
                           ST0 &gt; ST(i)                                       0                       0                      0
                           ST0 &lt; ST(i)                                       0                       0                      1
                           ST0 = ST(i)                                       1                       0                      0
                          Unordered**                                        1                       1                      1
 NOTES:
 * See the IA-32 Architecture Compatibility section below.
 ** Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</hint>
<hint page="0" header="Compare Floating Point Values and Set EFLAGS" doc_id="x86_64" token="fcomip">Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and
CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for compari-
sons, so that -0.0 is equal to +0.0.
                                   Table 3-22. FCOMI/FCOMIP/ FUCOMI/FUCOMIP Results
                     Comparison Results*                                    ZF                      PF                     CF
                           ST0 &gt; ST(i)                                       0                       0                      0
                           ST0 &lt; ST(i)                                       0                       0                      1
                           ST0 = ST(i)                                       1                       0                      0
                          Unordered**                                        1                       1                      1
 NOTES:
 * See the IA-32 Architecture Compatibility section below.
 ** Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</hint>
<hint page="0" header="Compare Floating Point Values and Set EFLAGS" doc_id="x86_64" token="fucomi">Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and
CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for compari-
sons, so that -0.0 is equal to +0.0.
                                   Table 3-22. FCOMI/FCOMIP/ FUCOMI/FUCOMIP Results
                     Comparison Results*                                    ZF                      PF                     CF
                           ST0 &gt; ST(i)                                       0                       0                      0
                           ST0 &lt; ST(i)                                       0                       0                      1
                           ST0 = ST(i)                                       1                       0                      0
                          Unordered**                                        1                       1                      1
 NOTES:
 * See the IA-32 Architecture Compatibility section below.
 ** Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</hint>
<hint page="0" header="Compare Floating Point Values and Set EFLAGS" doc_id="x86_64" token="fucomip">Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and
CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for compari-
sons, so that -0.0 is equal to +0.0.
                                   Table 3-22. FCOMI/FCOMIP/ FUCOMI/FUCOMIP Results
                     Comparison Results*                                    ZF                      PF                     CF
                           ST0 &gt; ST(i)                                       0                       0                      0
                           ST0 &lt; ST(i)                                       0                       0                      1
                           ST0 = ST(i)                                       1                       0                      0
                          Unordered**                                        1                       1                      1
 NOTES:
 * See the IA-32 Architecture Compatibility section below.
 ** Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</hint>
<hint page="0" header="Cosine" doc_id="x86_64" token="fcos">Computes the approximate cosine of the source operand in register ST(0) and stores the result in ST(0). The
source operand must be given in radians and must be within the range -263 to +263. The following table shows the
results obtained when taking the cosine of various classes of numbers.
                                                       Table 3-23. FCOS Results
                            ST(0) SRC                                                     ST(0) DEST
                               -inf                                                              *
                               -F                                                          -1 to +1
                               -0                                                             +1
                               +0                                                             +1
                               +F                                                          - 1 to + 1
                               +inf                                                              *
                               NaN                                                            NaN
 NOTES:
 F Means finite floating-point value.
 * Indicates floating-point invalid-arithmetic-operand (#IA) exception.</hint>
<hint page="0" header="Decrement Stack-Top Pointer" doc_id="x86_64" token="fdecstp">Subtracts one from the TOP field of the FPU status word (decrements the top-of-stack pointer). If the TOP field
contains a 0, it is set to 7. The effect of this instruction is to rotate the stack by one position. The contents of the
FPU data registers and tag register are not affected.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Divide" doc_id="x86_64" token="fdiv">Divides the destination operand by the source operand and stores the result in the destination location. The desti-
nation operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory
location. Source operands in memory can be in single-precision or double-precision floating-point format, word or
doubleword integer format.
The no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0)
register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location
(either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by
the contents of the ST(i) register or vice versa.
The FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result.
To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
by 1. The no-operand version of the floating-point divide instructions always results in the register stack being
popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.
The FIDIV instructions convert an integer source operand to double extended-precision floating-point format
before performing the division. When the source operand is an integer 0, it is treated as a +0.
If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an inf of
the appropriate sign is stored in the destination operand.
The following table shows the results obtained when dividing various classes of numbers, assuming that neither
overflow nor underflow occurs.</hint>
<hint page="0" header="Divide" doc_id="x86_64" token="fdivp">Divides the destination operand by the source operand and stores the result in the destination location. The desti-
nation operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory
location. Source operands in memory can be in single-precision or double-precision floating-point format, word or
doubleword integer format.
The no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0)
register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location
(either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by
the contents of the ST(i) register or vice versa.
The FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result.
To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
by 1. The no-operand version of the floating-point divide instructions always results in the register stack being
popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.
The FIDIV instructions convert an integer source operand to double extended-precision floating-point format
before performing the division. When the source operand is an integer 0, it is treated as a +0.
If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an inf of
the appropriate sign is stored in the destination operand.
The following table shows the results obtained when dividing various classes of numbers, assuming that neither
overflow nor underflow occurs.</hint>
<hint page="0" header="Divide" doc_id="x86_64" token="fidiv">Divides the destination operand by the source operand and stores the result in the destination location. The desti-
nation operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory
location. Source operands in memory can be in single-precision or double-precision floating-point format, word or
doubleword integer format.
The no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0)
register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location
(either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by
the contents of the ST(i) register or vice versa.
The FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result.
To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
by 1. The no-operand version of the floating-point divide instructions always results in the register stack being
popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.
The FIDIV instructions convert an integer source operand to double extended-precision floating-point format
before performing the division. When the source operand is an integer 0, it is treated as a +0.
If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an inf of
the appropriate sign is stored in the destination operand.
The following table shows the results obtained when dividing various classes of numbers, assuming that neither
overflow nor underflow occurs.</hint>
<hint page="0" header="Reverse Divide" doc_id="x86_64" token="fdivr">Divides the source operand by the destination operand and stores the result in the destination location. The desti-
nation operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory
location. Source operands in memory can be in single-precision or double-precision floating-point format, word or
doubleword integer format.
These instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to
support more efficient coding.
The no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1)
register. The one-operand version divides the contents of a memory location (either a floating-point or an integer
value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by
the contents of the ST(0) register or vice versa.
The FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result.
To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
by 1. The no-operand version of the floating-point divide instructions always results in the register stack being
popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.
The FIDIVR instructions convert an integer source operand to double extended-precision floating-point format
before performing the division.
If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an inf of
the appropriate sign is stored in the destination operand.
The following table shows the results obtained when dividing various classes of numbers, assuming that neither
overflow nor underflow occurs.</hint>
<hint page="0" header="Reverse Divide" doc_id="x86_64" token="fdivrp">Divides the source operand by the destination operand and stores the result in the destination location. The desti-
nation operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory
location. Source operands in memory can be in single-precision or double-precision floating-point format, word or
doubleword integer format.
These instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to
support more efficient coding.
The no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1)
register. The one-operand version divides the contents of a memory location (either a floating-point or an integer
value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by
the contents of the ST(0) register or vice versa.
The FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result.
To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
by 1. The no-operand version of the floating-point divide instructions always results in the register stack being
popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.
The FIDIVR instructions convert an integer source operand to double extended-precision floating-point format
before performing the division.
If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an inf of
the appropriate sign is stored in the destination operand.
The following table shows the results obtained when dividing various classes of numbers, assuming that neither
overflow nor underflow occurs.</hint>
<hint page="0" header="Reverse Divide" doc_id="x86_64" token="fidivr">Divides the source operand by the destination operand and stores the result in the destination location. The desti-
nation operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory
location. Source operands in memory can be in single-precision or double-precision floating-point format, word or
doubleword integer format.
These instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to
support more efficient coding.
The no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1)
register. The one-operand version divides the contents of a memory location (either a floating-point or an integer
value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by
the contents of the ST(0) register or vice versa.
The FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result.
To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
by 1. The no-operand version of the floating-point divide instructions always results in the register stack being
popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.
The FIDIVR instructions convert an integer source operand to double extended-precision floating-point format
before performing the division.
If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an inf of
the appropriate sign is stored in the destination operand.
The following table shows the results obtained when dividing various classes of numbers, assuming that neither
overflow nor underflow occurs.</hint>
<hint page="0" header="Free Floating-Point Register" doc_id="x86_64" token="ffree">Sets the tag in the FPU tag register associated with register ST(i) to empty (11B). The contents of ST(i) and the FPU
stack-top pointer (TOP) are not affected.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Compare Integer" doc_id="x86_64" token="ficom">Compares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in
the FPU status word according to the results (see table below). The integer value is converted to double extended-
precision floating-point format before the comparison is made.
                                          Table 3-26. FICOM/FICOMP Results
                      Condition                          C3                       C2                      C0
                      ST(0) &gt; SRC                         0                       0                        0
                     ST(0) &lt; SRC                          0                       0                        1
                     ST(0) = SRC                          1                       0                        0
                      Unordered                           1                       1                        1</hint>
<hint page="0" header="Compare Integer" doc_id="x86_64" token="ficomp">Compares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in
the FPU status word according to the results (see table below). The integer value is converted to double extended-
precision floating-point format before the comparison is made.
                                          Table 3-26. FICOM/FICOMP Results
                      Condition                          C3                       C2                      C0
                      ST(0) &gt; SRC                         0                       0                        0
                     ST(0) &lt; SRC                          0                       0                        1
                     ST(0) = SRC                          1                       0                        0
                      Unordered                           1                       1                        1</hint>
<hint page="0" header="Load Integer" doc_id="x86_64" token="fild">Converts the signed-integer source operand into double extended-precision floating-point format and pushes the
value onto the FPU register stack. The source operand can be a word, doubleword, or quadword integer. It is loaded
without rounding errors. The sign of the source operand is preserved.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Increment Stack-Top Pointer" doc_id="x86_64" token="fincstp">Adds one to the TOP field of the FPU status word (increments the top-of-stack pointer). If the TOP field contains a
7, it is set to 0. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data
registers and tag register are not affected. This operation is not equivalent to popping the stack, because the tag
for the previous top-of-stack register is not marked empty.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Initialize Floating-Point Unit" doc_id="x86_64" token="finit">Sets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU
control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared
(no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all
tagged as empty (11B). Both the instruction and data pointers are cleared.
The FINIT instruction checks for and handles any pending unmasked floating-point exceptions before performing
the initialization; the FNINIT instruction does not.
The assembler issues two instructions for the FINIT instruction (an FWAIT instruction followed by an FNINIT
instruction), and the processor executes each of these instructions in separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Initialize Floating-Point Unit" doc_id="x86_64" token="fninit">Sets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU
control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared
(no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all
tagged as empty (11B). Both the instruction and data pointers are cleared.
The FINIT instruction checks for and handles any pending unmasked floating-point exceptions before performing
the initialization; the FNINIT instruction does not.
The assembler issues two instructions for the FINIT instruction (an FWAIT instruction followed by an FNINIT
instruction), and the processor executes each of these instructions in separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Store Integer" doc_id="x86_64" token="fist">The FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the desti-
nation operand. Values can be stored in word or doubleword integer format. The destination operand specifies the
address where the first byte of the destination value is to be stored.
The FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop
the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
The FISTP instruction also stores values in quadword integer format.
The following table shows the results obtained when storing various classes of numbers in integer format.
                                                 Table 3-27. FIST/FISTP Results
                             ST(0)                                                          DEST
           - inf or Value Too Large for DEST Format                                            *
                             F &lt;= -1                                                          -I
                          -1 &lt; F &lt; -0                                                        **
                              -0                                                             0
                              +0                                                             0
                         +0&lt;F&lt;+1                                                             **
                            F&gt;=+1                                                             +I
           + inf or Value Too Large for DEST Format                                            *
                              NaN                                                            *
NOTES:
F Means finite floating-point value.
I Means integer.
* Indicates floating-point invalid-operation (#IA) exception.
** 0 or +-1, depending on the rounding mode.</hint>
<hint page="0" header="Store Integer" doc_id="x86_64" token="fistp">The FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the desti-
nation operand. Values can be stored in word or doubleword integer format. The destination operand specifies the
address where the first byte of the destination value is to be stored.
The FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop
the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
The FISTP instruction also stores values in quadword integer format.
The following table shows the results obtained when storing various classes of numbers in integer format.
                                                 Table 3-27. FIST/FISTP Results
                             ST(0)                                                          DEST
           - inf or Value Too Large for DEST Format                                            *
                             F &lt;= -1                                                          -I
                          -1 &lt; F &lt; -0                                                        **
                              -0                                                             0
                              +0                                                             0
                         +0&lt;F&lt;+1                                                             **
                            F&gt;=+1                                                             +I
           + inf or Value Too Large for DEST Format                                            *
                              NaN                                                            *
NOTES:
F Means finite floating-point value.
I Means integer.
* Indicates floating-point invalid-operation (#IA) exception.
** 0 or +-1, depending on the rounding mode.</hint>
<hint page="0" header="Store Integer with Truncation" doc_id="x86_64" token="fisttp">FISTTP converts the value in ST into a signed integer using truncation (chop) as rounding mode, transfers the
result to the destination, and pop ST. FISTTP accepts word, short integer, and long integer destinations.
The following table shows the results obtained when storing various classes of numbers in integer format.
                                                    Table 3-28. FISTTP Results
                               ST(0)                                                           DEST
- inf or Value Too Large for DEST Format                                                          *
F&lt;= -1                                                                                           -I
-1&lt;F&lt;+1                                                                                         0
FS+1                                                                                            +I
+ inf or Value Too Large for DEST Format                                                          *
NaN                                                                                             *
NOTES:
F Means finite floating-point value.
I Means integer.
* Indicates floating-point invalid-operation (#IA) exception.</hint>
<hint page="0" header="Load Floating Point Value" doc_id="x86_64" token="fld">Pushes the source operand onto the FPU register stack. The source operand can be in single-precision, double-
precision, or double extended-precision floating-point format. If the source operand is in single-precision or
double-precision floating-point format, it is automatically converted to the double extended-precision floating-
point format before being pushed on the stack.
The FLD instruction can also push the value in a selected FPU register [ST(i)] onto the stack. Here, pushing register
ST(0) duplicates the stack top.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Load Constant" doc_id="x86_64" token="fld1">Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU
register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, pi, log102,
and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control
word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a
result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.
See the section titled "Approximation of Pi" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Devel-
oper's Manual, Volume 1, for a description of the pi constant.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Load Constant" doc_id="x86_64" token="fldl2t">Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU
register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, pi, log102,
and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control
word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a
result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.
See the section titled "Approximation of Pi" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Devel-
oper's Manual, Volume 1, for a description of the pi constant.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Load Constant" doc_id="x86_64" token="fldl2e">Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU
register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, pi, log102,
and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control
word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a
result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.
See the section titled "Approximation of Pi" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Devel-
oper's Manual, Volume 1, for a description of the pi constant.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Load Constant" doc_id="x86_64" token="fldpi">Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU
register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, pi, log102,
and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control
word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a
result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.
See the section titled "Approximation of Pi" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Devel-
oper's Manual, Volume 1, for a description of the pi constant.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Load Constant" doc_id="x86_64" token="fldlg2">Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU
register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, pi, log102,
and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control
word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a
result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.
See the section titled "Approximation of Pi" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Devel-
oper's Manual, Volume 1, for a description of the pi constant.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Load Constant" doc_id="x86_64" token="fldln2">Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU
register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, pi, log102,
and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control
word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a
result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.
See the section titled "Approximation of Pi" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Devel-
oper's Manual, Volume 1, for a description of the pi constant.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Load Constant" doc_id="x86_64" token="fldz">Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU
register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, pi, log102,
and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control
word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a
result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.
See the section titled "Approximation of Pi" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Devel-
oper's Manual, Volume 1, for a description of the pi constant.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Load x87 FPU Control Word" doc_id="x86_64" token="fldcw">Loads the 16-bit source operand into the FPU control word. The source operand is a memory location. This instruc-
tion is typically used to establish or change the FPU's mode of operation.
If one or more exception flags are set in the FPU status word prior to loading a new FPU control word and the new
control word unmasks one or more of those exceptions, a floating-point exception will be generated upon execution
of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled "Soft-
ware Exception Handling" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Developer's Manual,
Volume 1). To avoid raising exceptions when changing FPU operating modes, clear any pending exceptions (using
the FCLEX or FNCLEX instruction) before loading the new control word.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Load x87 FPU Environment" doc_id="x86_64" token="fldenv">Loads the complete x87 FPU operating environment from memory into the FPU registers. The source operand spec-
ifies the first byte of the operating-environment data in memory. This data is typically written to the specified
memory location by a FSTENV or FNSTENV instruction.
The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data
pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 1, show the layout in memory of the loaded environment, depending on the operating mode of the
processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the
real mode layouts are used.
The FLDENV instruction should be executed in the same operating mode as the corresponding FSTENV/FNSTENV
instruction.
If one or more unmasked exception flags are set in the new FPU status word, a floating-point exception will be
generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions,
see the section titled "Software Exception Handling" in Chapter 8 of the Intel 64 and IA-32 Architectures Soft-
ware Developer's Manual, Volume 1). To avoid generating exceptions when loading a new environment, clear all
the exception flags in the FPU status word that is being loaded.
If a page or limit fault occurs during the execution of this instruction, the state of the x87 FPU registers as seen by
the fault handler may be different than the state being loaded from memory. In such situations, the fault handler
should ignore the status of the x87 FPU registers, handle the fault, and return. The FLDENV instruction will then
complete the loading of the x87 FPU registers with no resulting context inconsistency.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Multiply" doc_id="x86_64" token="fmul">Multiplies the destination and source operands and stores the product in the destination location. The destination
operand is always an FPU data register; the source operand can be an FPU data register or a memory location.
Source operands in memory can be in single-precision or double-precision floating-point format or in word or
doubleword integer format.
The no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0)
register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0)
register by the contents of a memory location (either a floating point or an integer value) and stores the product in
the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the
ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the desti-
nation operand).
The FMULP instructions perform the additional operation of popping the FPU register stack after storing the
product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack
pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register
stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP.
The FIMUL instructions convert an integer source operand to double extended-
precision floating-point format before performing the multiplication.
The sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multi-
plied is 0 or inf. When the source operand is an integer 0, it is treated as a +0.
The following table shows the results obtained when multiplying various classes of numbers, assuming that neither
overflow nor underflow occurs.</hint>
<hint page="0" header="Multiply" doc_id="x86_64" token="fmulp">Multiplies the destination and source operands and stores the product in the destination location. The destination
operand is always an FPU data register; the source operand can be an FPU data register or a memory location.
Source operands in memory can be in single-precision or double-precision floating-point format or in word or
doubleword integer format.
The no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0)
register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0)
register by the contents of a memory location (either a floating point or an integer value) and stores the product in
the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the
ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the desti-
nation operand).
The FMULP instructions perform the additional operation of popping the FPU register stack after storing the
product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack
pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register
stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP.
The FIMUL instructions convert an integer source operand to double extended-
precision floating-point format before performing the multiplication.
The sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multi-
plied is 0 or inf. When the source operand is an integer 0, it is treated as a +0.
The following table shows the results obtained when multiplying various classes of numbers, assuming that neither
overflow nor underflow occurs.</hint>
<hint page="0" header="Multiply" doc_id="x86_64" token="fimul">Multiplies the destination and source operands and stores the product in the destination location. The destination
operand is always an FPU data register; the source operand can be an FPU data register or a memory location.
Source operands in memory can be in single-precision or double-precision floating-point format or in word or
doubleword integer format.
The no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0)
register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0)
register by the contents of a memory location (either a floating point or an integer value) and stores the product in
the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the
ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the desti-
nation operand).
The FMULP instructions perform the additional operation of popping the FPU register stack after storing the
product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack
pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register
stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP.
The FIMUL instructions convert an integer source operand to double extended-
precision floating-point format before performing the multiplication.
The sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multi-
plied is 0 or inf. When the source operand is an integer 0, it is treated as a +0.
The following table shows the results obtained when multiplying various classes of numbers, assuming that neither
overflow nor underflow occurs.</hint>
<hint page="0" header="No Operation" doc_id="x86_64" token="fnop">Performs no FPU operation. This instruction takes up space in the instruction stream but does not affect the FPU or
machine context, except the EIP register and the FPU Instruction Pointer.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Partial Arctangent" doc_id="x86_64" token="fpatan">Computes the arctangent of the source operand in register ST(1) divided by the source operand in register ST(0),
stores the result in ST(1), and pops the FPU register stack. The result in register ST(0) has the same sign as the
source operand ST(1) and a magnitude less than +pi.
The FPATAN instruction returns the angle between the X axis and the line from the origin to the point (X,Y), where
Y (the ordinate) is ST(1) and X (the abscissa) is ST(0). The angle depends on the sign of X and Y independently,
not just on the sign of the ratio Y/X. This is because a point (-X,Y) is in the second quadrant, resulting in an angle
between pi/2 and pi, while a point (X,-Y) is in the fourth quadrant, resulting in an angle between 0 and -pi/2. A point
(-X,-Y) is in the third quadrant, giving an angle between -pi/2 and -pi.
The following table shows the results obtained when computing the arctangent of various classes of numbers,
assuming that underflow does not occur.
                                                    Table 3-30. FPATAN Results
                                                                              ST(0)
                             -inf            -F                     -0              +0            +F              +inf                 NaN
              -inf             - 3pi/4*       - pi/2                  - pi/2           - pi/2         - pi/2           - pi/4*             NaN
   ST(1)      -F             -p            -pi to -pi/2             -pi/2            -pi/2          -pi/2 to -0      -0                 NaN
              -0             -p            -p                     -p*             - 0*          -0              -0                 NaN
              +0             +p            +p                     + pi*            + 0*          +0              +0                 NaN
              +F             +p            +pi to +pi/2             + pi/2           +pi/2          +pi/2 to +0      +0                 NaN
              +inf             +3pi/4*        +pi/2                   +pi/2            +pi/2          + pi/2           + pi/4*             NaN
                   NaN             NaN              NaN                 NaN            NaN           NaN             NaN           NaN
 NOTES:
 F Means finite floating-point value.
 * Table 8-10 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, specifies that the ratios 0/0 and inf/inf
   generate the floating-point invalid arithmetic-operation exception and, if this exception is masked, the floating-point QNaN indefi-
   nite value is returned. With the FPATAN instruction, the 0/0 or inf/inf value is actually not calculated using division. Instead, the arc-
   tangent of the two variables is derived from a standard mathematical formulation that is generalized to allow complex numbers as
   arguments. In this complex variable formulation, arctangent(0,0) etc. has well defined values. These values are needed to develop
   a library to compute transcendental functions with complex arguments, based on the FPU functions that only allow floating-point
   values as arguments.</hint>
<hint page="0" header="Partial Remainder" doc_id="x86_64" token="fprem">Computes the remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the
ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following
value:
Remainder &lt;- ST(0) - (Q * ST(1))
Here, Q is an integer value that is obtained by truncating the floating-point number quotient of [ST(0) / ST(1)]
toward zero. The sign of the remainder is the same as the sign of the dividend. The magnitude of the remainder is
less than that of the modulus, unless a partial remainder was computed (as described below).
This instruction produces an exact result; the inexact-result exception does not occur and the rounding control has
no effect. The following table shows the results obtained when computing the remainder of various classes of
numbers, assuming that underflow does not occur.
                                                      Table 3-31. FPREM Results
                                                                          ST(1)
                                       -inf          -F              -0             +0            +F             +inf            NaN
                   -inf                   *             *             *              *             *              *            NaN
 ST(0)              -F             ST(0)        -F or -0           **             **          -F or -0       ST(0)           NaN
                    -0                 -0          -0               *              *            -0             -0            NaN
                   +0                  +0         +0                *              *            +0             +0            NaN
                   +F              ST(0)       +F or +0            **             **         +F or +0        ST(0)           NaN
                   +inf                   *             *             *              *             *              *            NaN
                  NaN                  NaN        NaN              NaN            NaN          NaN            NaN            NaN
 NOTES:
 F Means finite floating-point value.
 * Indicates floating-point invalid-arithmetic-operand (#IA) exception.
 ** Indicates floating-point zero-divide (#Z) exception.</hint>
<hint page="0" header="Partial Remainder" doc_id="x86_64" token="fprem1">Computes the IEEE remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in
the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following
value:
Remainder &lt;- ST(0) - (Q * ST(1))
Here, Q is an integer value that is obtained by rounding the floating-point number quotient of [ST(0) / ST(1)]
toward the nearest integer value. The magnitude of the remainder is less than or equal to half the magnitude of the
modulus, unless a partial remainder was computed (as described below).
This instruction produces an exact result; the precision (inexact) exception does not occur and the rounding control
has no effect. The following table shows the results obtained when computing the remainder of various classes of
numbers, assuming that underflow does not occur.
                                                   Table 3-32. FPREM1 Results
                                                                          ST(1)
                                   -inf             -F                -0            +0             +F            +inf            NaN
                   -inf               *              *                 *             *              *              *           NaN
 ST(0)             -F            ST(0)         +-F or -0             **            **         +- F or - 0       ST(0)          NaN
                   -0              -0             -0                 *             *             -0             -0           NaN
                   +0              +0             +0                 *             *             +0             +0           NaN
                   +F            ST(0)         +- F or + 0           **            **         +- F or + 0       ST(0)          NaN
                   +inf               *              *                 *             *              *              *           NaN
                  NaN              NaN           NaN                NaN           NaN           NaN            NaN           NaN
 NOTES:
 F Means finite floating-point value.
 * Indicates floating-point invalid-arithmetic-operand (#IA) exception.
 ** Indicates floating-point zero-divide (#Z) exception.</hint>
<hint page="0" header="Partial Tangent" doc_id="x86_64" token="fptan">Computes the approximate tangent of the source operand in register ST(0), stores the result in ST(0), and pushes
a 1.0 onto the FPU register stack. The source operand must be given in radians and must be less than +-263. The
following table shows the unmasked results obtained when computing the partial tangent of various classes of
numbers, assuming that underflow does not occur.
                                                   Table 3-33. FPTAN Results
                           ST(0) SRC                                                      ST(0) DEST
                              -inf                                                               *
                              -F                                                           - F to + F
                              -0                                                              -0
                              +0                                                              +0
                              +F                                                           - F to + F
                              +inf                                                               *
                              NaN                                                            NaN
NOTES:
F Means finite floating-point value.
* Indicates floating-point invalid-arithmetic-operand (#IA) exception.</hint>
<hint page="0" header="Round to Integer" doc_id="x86_64" token="frndint">Rounds the source value in the ST(0) register to the nearest integral value, depending on the current rounding
mode (setting of the RC field of the FPU control word), and stores the result in ST(0).
If the source value is inf, the value is not changed. If the source value is not an integral value, the floating-point
inexact-result exception (#P) is generated.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Restore x87 FPU State" doc_id="x86_64" token="frstor">Loads the FPU state (operating environment and register stack) from the memory area specified with the source
operand. This state data is typically written to the specified memory location by a previous FSAVE/FNSAVE instruc-
tion.
The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data
pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the
processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the
real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately following
the operating environment image.
The FRSTOR instruction should be executed in the same operating mode as the corresponding FSAVE/FNSAVE
instruction.
If one or more unmasked exception bits are set in the new FPU status word, a floating-point exception will be
generated. To avoid raising exceptions when loading a new operating environment, clear all the exception flags in
the FPU status word that is being loaded.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Store x87 FPU State" doc_id="x86_64" token="fsave">Stores the current FPU state (operating environment and register stack) at the specified destination in memory,
and then re-initializes the FPU. The FSAVE instruction checks for and handles pending unmasked floating-point
exceptions before storing the FPU state; the FNSAVE instruction does not.
The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data
pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the
processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the
real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately follow
the operating environment image.
The saved image reflects the state of the FPU after all floating-point instructions preceding the FSAVE/FNSAVE
instruction in the instruction stream have been executed.
After the FPU state has been saved, the FPU is reset to the same default values it is set to with the FINIT/FNINIT
instructions (see "FINIT/FNINIT-Initialize Floating-Point Unit" in this chapter).
The FSAVE/FNSAVE instructions are typically used when the operating system needs to perform a context switch,
an exception handler needs to use the FPU, or an application program needs to pass a "clean" FPU to a procedure.
The assembler issues two instructions for the FSAVE instruction (an FWAIT instruction followed by an FNSAVE
instruction), and the processor executes each of these instructions separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Store x87 FPU State" doc_id="x86_64" token="fnsave">Stores the current FPU state (operating environment and register stack) at the specified destination in memory,
and then re-initializes the FPU. The FSAVE instruction checks for and handles pending unmasked floating-point
exceptions before storing the FPU state; the FNSAVE instruction does not.
The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data
pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the
processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the
real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately follow
the operating environment image.
The saved image reflects the state of the FPU after all floating-point instructions preceding the FSAVE/FNSAVE
instruction in the instruction stream have been executed.
After the FPU state has been saved, the FPU is reset to the same default values it is set to with the FINIT/FNINIT
instructions (see "FINIT/FNINIT-Initialize Floating-Point Unit" in this chapter).
The FSAVE/FNSAVE instructions are typically used when the operating system needs to perform a context switch,
an exception handler needs to use the FPU, or an application program needs to pass a "clean" FPU to a procedure.
The assembler issues two instructions for the FSAVE instruction (an FWAIT instruction followed by an FNSAVE
instruction), and the processor executes each of these instructions separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Scale" doc_id="x86_64" token="fscale">Truncates the value in the source operand (toward 0) to an integral value and adds that value to the exponent of
the destination operand. The destination and source operands are floating-point values located in registers ST(0)
and ST(1), respectively. This instruction provides rapid multiplication or division by integral powers of 2. The
following table shows the results obtained when scaling various classes of numbers, assuming that neither over-
flow nor underflow occurs.</hint>
<hint page="0" header="Sine" doc_id="x86_64" token="fsin">Computes an approximation of the sine of the source operand in register ST(0) and stores the result in ST(0). The
source operand must be given in radians and must be within the range -263 to +263. The following table shows the
results obtained when taking the sine of various classes of numbers, assuming that underflow does not occur.
                                                     Table 3-35. FSIN Results
                           SRC (ST(0))                                                          DEST (ST(0))
                                -inf                                                                    *
                                -F                                                               - 1 to + 1
                                -0                                                                   -0
                                +0                                                                  +0
                                +F                                                                - 1 to +1
                                +inf                                                                    *
                                NaN                                                                 NaN
 NOTES:
 F Means finite floating-point value.
 * Indicates floating-point invalid-arithmetic-operand (#IA) exception.</hint>
<hint page="0" header="Sine and Cosine" doc_id="x86_64" token="fsincos">Computes both the approximate sine and the cosine of the source operand in register ST(0), stores the sine in
ST(0), and pushes the cosine onto the top of the FPU register stack. (This instruction is faster than executing the
FSIN and FCOS instructions in succession.)
The source operand must be given in radians and must be within the range -263 to +263. The following table shows
the results obtained when taking the sine and cosine of various classes of numbers, assuming that underflow does
not occur.
                                                   Table 3-36. FSINCOS Results
                    SRC                                                                  DEST
                   ST(0)                                    ST(1) Cosine                                    ST(0) Sine
                    -inf                                              *                                            *
                    -F                                        - 1 to + 1                                     - 1 to + 1
                    -0                                             +1                                           -0
                    +0                                             +1                                           +0
                    +F                                        - 1 to + 1                                     - 1 to + 1
                    +inf                                              *                                            *
                   NaN                                             NaN                                         NaN
 NOTES:
 F Means finite floating-point value.
 * Indicates floating-point invalid-arithmetic-operand (#IA) exception.</hint>
<hint page="0" header="Square Root" doc_id="x86_64" token="fsqrt">Computes the square root of the source value in the ST(0) register and stores the result in ST(0).
The following table shows the results obtained when taking the square root of various classes of numbers,
assuming that neither overflow nor underflow occurs.
                                                    Table 3-37. FSQRT Results
                           SRC (ST(0))                                                         DEST (ST(0))
                                -inf                                                                   *
                                -F                                                                   *
                                -0                                                                  -0
                                +0                                                                  +0
                                +F                                                                  +F
                                +inf                                                                  +inf
                              NaN                                                                   NaN
 NOTES:
 F Means finite floating-point value.
 * Indicates floating-point invalid-arithmetic-operand (#IA) exception.</hint>
<hint page="0" header="Store Floating Point Value" doc_id="x86_64" token="fst">The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory loca-
tion or another register in the FPU register stack. When storing the value in memory, the value is converted to
single-precision or double-precision floating-point format.
The FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop
the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
The FSTP instruction can also store values in memory in double extended-precision floating-point format.
If the destination operand is a memory location, the operand specifies the address where the first byte of the desti-
nation value is to be stored. If the destination operand is a register, the operand specifies a register in the register
stack relative to the top of the stack.
If the destination size is single-precision or double-precision, the significand of the value being stored is rounded
to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word),
and the exponent is converted to the width and bias of the destination format. If the value being stored is too large
for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no
value is stored in the destination operand. If the value being stored is a denormal value, the denormal exception
(#D) is not generated. This condition is simply signaled as a numeric underflow exception (#U) condition.
If the value being stored is +-0, +-inf, or a NaN, the least-significant bits of the significand and the exponent are trun-
cated to fit the destination format. This operation preserves the value's identity as a 0, inf, or NaN.
If the destination operand is a non-empty register, the invalid-operation exception is not generated.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Store Floating Point Value" doc_id="x86_64" token="fstp">The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory loca-
tion or another register in the FPU register stack. When storing the value in memory, the value is converted to
single-precision or double-precision floating-point format.
The FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop
the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
The FSTP instruction can also store values in memory in double extended-precision floating-point format.
If the destination operand is a memory location, the operand specifies the address where the first byte of the desti-
nation value is to be stored. If the destination operand is a register, the operand specifies a register in the register
stack relative to the top of the stack.
If the destination size is single-precision or double-precision, the significand of the value being stored is rounded
to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word),
and the exponent is converted to the width and bias of the destination format. If the value being stored is too large
for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no
value is stored in the destination operand. If the value being stored is a denormal value, the denormal exception
(#D) is not generated. This condition is simply signaled as a numeric underflow exception (#U) condition.
If the value being stored is +-0, +-inf, or a NaN, the least-significant bits of the significand and the exponent are trun-
cated to fit the destination format. This operation preserves the value's identity as a 0, inf, or NaN.
If the destination operand is a non-empty register, the invalid-operation exception is not generated.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Store x87 FPU Control Word" doc_id="x86_64" token="fstcw">Stores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction
checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW
instruction does not.
The assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW
instruction), and the processor executes each of these instructions in separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Store x87 FPU Control Word" doc_id="x86_64" token="fnstcw">Stores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction
checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW
instruction does not.
The assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW
instruction), and the processor executes each of these instructions in separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Store x87 FPU Environment" doc_id="x86_64" token="fstenv">Saves the current FPU operating environment at the memory location specified with the destination operand, and
then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status
word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 1, show the layout in memory of the stored environ-
ment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute
(16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.
The FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing
the FPU environment; the FNSTENV instruction does not. The saved image reflects the state of the FPU after all
floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been
executed.
These instructions are often used by exception handlers because they provide access to the FPU instruction and
data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment
prevents floating-point exceptions from interrupting the exception handler.
The assembler issues two instructions for the FSTENV instruction (an FWAIT instruction followed by an FNSTENV
instruction), and the processor executes each of these instructions separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Store x87 FPU Environment" doc_id="x86_64" token="fnstenv">Saves the current FPU operating environment at the memory location specified with the destination operand, and
then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status
word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 1, show the layout in memory of the stored environ-
ment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute
(16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.
The FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing
the FPU environment; the FNSTENV instruction does not. The saved image reflects the state of the FPU after all
floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been
executed.
These instructions are often used by exception handlers because they provide access to the FPU instruction and
data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment
prevents floating-point exceptions from interrupting the exception handler.
The assembler issues two instructions for the FSTENV instruction (an FWAIT instruction followed by an FNSTENV
instruction), and the processor executes each of these instructions separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Store x87 FPU Status Word" doc_id="x86_64" token="fstsw">Stores the current value of the x87 FPU status word in the destination location. The destination operand can be
either a two-byte memory location or the AX register. The FSTSW instruction checks for and handles pending
unmasked floating-point exceptions before storing the status word; the FNSTSW instruction does not.
The FNSTSW AX form of the instruction is used primarily in conditional branching (for instance, after an FPU
comparison instruction or an FPREM, FPREM1, or FXAM instruction), where the direction of the branch depends on
the state of the FPU condition code flags. (See the section titled "Branching and Conditional Moves on FPU Condi-
tion Codes" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1.) This
instruction can also be used to invoke exception handlers (by examining the exception flags) in environments that
do not use interrupts. When the FNSTSW AX instruction is executed, the AX register is updated before the
processor executes any further instructions. The status stored in the AX register is thus guaranteed to be from the
completion of the prior FPU instruction.
The assembler issues two instructions for the FSTSW instruction (an FWAIT instruction followed by an FNSTSW
instruction), and the processor executes each of these instructions separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Store x87 FPU Status Word" doc_id="x86_64" token="fnstsw">Stores the current value of the x87 FPU status word in the destination location. The destination operand can be
either a two-byte memory location or the AX register. The FSTSW instruction checks for and handles pending
unmasked floating-point exceptions before storing the status word; the FNSTSW instruction does not.
The FNSTSW AX form of the instruction is used primarily in conditional branching (for instance, after an FPU
comparison instruction or an FPREM, FPREM1, or FXAM instruction), where the direction of the branch depends on
the state of the FPU condition code flags. (See the section titled "Branching and Conditional Moves on FPU Condi-
tion Codes" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1.) This
instruction can also be used to invoke exception handlers (by examining the exception flags) in environments that
do not use interrupts. When the FNSTSW AX instruction is executed, the AX register is updated before the
processor executes any further instructions. The status stored in the AX register is thus guaranteed to be from the
completion of the prior FPU instruction.
The assembler issues two instructions for the FSTSW instruction (an FWAIT instruction followed by an FNSTSW
instruction), and the processor executes each of these instructions separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Subtract" doc_id="x86_64" token="fsub">Subtracts the source operand from the destination operand and stores the difference in the destination location.
The destination operand is always an FPU data register; the source operand can be a register or a memory location.
Source operands in memory can be in single-precision or double-precision floating-point format or in word or
doubleword integer format.
The no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and
stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-
point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand
version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.
The FSUBP instructions perform the additional operation of popping the FPU register stack following the subtrac-
tion. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer
(TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack
being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.
The FISUB instructions convert an integer source operand to double extended-precision floating-point format
before performing the subtraction.
Table 3-38 shows the results obtained when subtracting various classes of numbers from one another, assuming
that neither overflow nor underflow occurs. Here, the SRC value is subtracted from the DEST value (DEST - SRC =
result).
When the difference between two operands of like sign is 0, the result is +0, except for the round toward -inf mode,
in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the
source operand is an integer 0, it is treated as a +0.
When one operand is inf, the result is inf of the expected sign. If both operands are inf of the same sign, an invalid-
operation exception is generated.</hint>
<hint page="0" header="Subtract" doc_id="x86_64" token="fsubp">Subtracts the source operand from the destination operand and stores the difference in the destination location.
The destination operand is always an FPU data register; the source operand can be a register or a memory location.
Source operands in memory can be in single-precision or double-precision floating-point format or in word or
doubleword integer format.
The no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and
stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-
point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand
version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.
The FSUBP instructions perform the additional operation of popping the FPU register stack following the subtrac-
tion. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer
(TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack
being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.
The FISUB instructions convert an integer source operand to double extended-precision floating-point format
before performing the subtraction.
Table 3-38 shows the results obtained when subtracting various classes of numbers from one another, assuming
that neither overflow nor underflow occurs. Here, the SRC value is subtracted from the DEST value (DEST - SRC =
result).
When the difference between two operands of like sign is 0, the result is +0, except for the round toward -inf mode,
in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the
source operand is an integer 0, it is treated as a +0.
When one operand is inf, the result is inf of the expected sign. If both operands are inf of the same sign, an invalid-
operation exception is generated.</hint>
<hint page="0" header="Subtract" doc_id="x86_64" token="fisub">Subtracts the source operand from the destination operand and stores the difference in the destination location.
The destination operand is always an FPU data register; the source operand can be a register or a memory location.
Source operands in memory can be in single-precision or double-precision floating-point format or in word or
doubleword integer format.
The no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and
stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-
point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand
version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.
The FSUBP instructions perform the additional operation of popping the FPU register stack following the subtrac-
tion. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer
(TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack
being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.
The FISUB instructions convert an integer source operand to double extended-precision floating-point format
before performing the subtraction.
Table 3-38 shows the results obtained when subtracting various classes of numbers from one another, assuming
that neither overflow nor underflow occurs. Here, the SRC value is subtracted from the DEST value (DEST - SRC =
result).
When the difference between two operands of like sign is 0, the result is +0, except for the round toward -inf mode,
in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the
source operand is an integer 0, it is treated as a +0.
When one operand is inf, the result is inf of the expected sign. If both operands are inf of the same sign, an invalid-
operation exception is generated.</hint>
<hint page="0" header="Reverse Subtract" doc_id="x86_64" token="fsubr">Subtracts the destination operand from the source operand and stores the difference in the destination location.
The destination operand is always an FPU register; the source operand can be a register or a memory location.
Source operands in memory can be in single-precision or double-precision floating-point format or in word or
doubleword integer format.
These instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided
to support more efficient coding.
The no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and
stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents
of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand
version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.
The FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtrac-
tion. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer
(TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register
stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.
The FISUBR instructions convert an integer source operand to double extended-precision floating-point format
before performing the subtraction.
The following table shows the results obtained when subtracting various classes of numbers from one another,
assuming that neither overflow nor underflow occurs. Here, the DEST value is subtracted from the SRC value (SRC
- DEST = result).
When the difference between two operands of like sign is 0, the result is +0, except for the round toward -inf mode,
in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the
source operand is an integer 0, it is treated as a +0.
When one operand is inf, the result is inf of the expected sign. If both operands are inf of the same sign, an invalid-
operation exception is generated.</hint>
<hint page="0" header="Reverse Subtract" doc_id="x86_64" token="fsubrp">Subtracts the destination operand from the source operand and stores the difference in the destination location.
The destination operand is always an FPU register; the source operand can be a register or a memory location.
Source operands in memory can be in single-precision or double-precision floating-point format or in word or
doubleword integer format.
These instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided
to support more efficient coding.
The no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and
stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents
of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand
version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.
The FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtrac-
tion. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer
(TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register
stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.
The FISUBR instructions convert an integer source operand to double extended-precision floating-point format
before performing the subtraction.
The following table shows the results obtained when subtracting various classes of numbers from one another,
assuming that neither overflow nor underflow occurs. Here, the DEST value is subtracted from the SRC value (SRC
- DEST = result).
When the difference between two operands of like sign is 0, the result is +0, except for the round toward -inf mode,
in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the
source operand is an integer 0, it is treated as a +0.
When one operand is inf, the result is inf of the expected sign. If both operands are inf of the same sign, an invalid-
operation exception is generated.</hint>
<hint page="0" header="Reverse Subtract" doc_id="x86_64" token="fisubr">Subtracts the destination operand from the source operand and stores the difference in the destination location.
The destination operand is always an FPU register; the source operand can be a register or a memory location.
Source operands in memory can be in single-precision or double-precision floating-point format or in word or
doubleword integer format.
These instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided
to support more efficient coding.
The no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and
stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents
of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand
version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.
The FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtrac-
tion. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer
(TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register
stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.
The FISUBR instructions convert an integer source operand to double extended-precision floating-point format
before performing the subtraction.
The following table shows the results obtained when subtracting various classes of numbers from one another,
assuming that neither overflow nor underflow occurs. Here, the DEST value is subtracted from the SRC value (SRC
- DEST = result).
When the difference between two operands of like sign is 0, the result is +0, except for the round toward -inf mode,
in which case the result is -0. This instruction also guarantees that +0 - (-0) = +0, and that -0 - (+0) = -0. When the
source operand is an integer 0, it is treated as a +0.
When one operand is inf, the result is inf of the expected sign. If both operands are inf of the same sign, an invalid-
operation exception is generated.</hint>
<hint page="0" header="TEST" doc_id="x86_64" token="ftst">Compares the value in the ST(0) register with 0.0 and sets the condition code flags C0, C2, and C3 in the FPU
status word according to the results (see table below).
                                               Table 3-40. FTST Results
                      Condition                              C3                    C2                      C0
                     ST(0) &gt; 0.0                             0                     0                       0
                     ST(0) &lt; 0.0                             0                     0                       1
                     ST(0) = 0.0                             1                     0                       0
                     Unordered                               1                     1                       1</hint>
<hint page="0" header="Unordered Compare Floating Point Values" doc_id="x86_64" token="fucom">Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2,
and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the
contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that -0.0 is equal to +0.0.
                                        Table 3-41. FUCOM/FUCOMP/FUCOMPP Results
                     Comparison Results*                                   C3                     C2                    C0
                          ST0 &gt; ST(i)                                       0                      0                     0
                          ST0 &lt; ST(i)                                       0                      0                     1
                          ST0 = ST(i)                                       1                      0                     0
                           Unordered                                        1                      1                     1
 NOTES:
 * Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</hint>
<hint page="0" header="Unordered Compare Floating Point Values" doc_id="x86_64" token="fucomp">Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2,
and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the
contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that -0.0 is equal to +0.0.
                                        Table 3-41. FUCOM/FUCOMP/FUCOMPP Results
                     Comparison Results*                                   C3                     C2                    C0
                          ST0 &gt; ST(i)                                       0                      0                     0
                          ST0 &lt; ST(i)                                       0                      0                     1
                          ST0 = ST(i)                                       1                      0                     0
                           Unordered                                        1                      1                     1
 NOTES:
 * Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</hint>
<hint page="0" header="Unordered Compare Floating Point Values" doc_id="x86_64" token="fucompp">Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2,
and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the
contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that -0.0 is equal to +0.0.
                                        Table 3-41. FUCOM/FUCOMP/FUCOMPP Results
                     Comparison Results*                                   C3                     C2                    C0
                          ST0 &gt; ST(i)                                       0                      0                     0
                          ST0 &lt; ST(i)                                       0                      0                     1
                          ST0 = ST(i)                                       1                      0                     0
                           Unordered                                        1                      1                     1
 NOTES:
 * Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.</hint>
<hint page="0" header="Examine Floating-Point" doc_id="x86_64" token="fxam">Examines the contents of the ST(0) register and sets the condition code flags C0, C2, and C3 in the FPU status word
to indicate the class of value or number in the register (see the table below).
                                                       Table 3-42. FXAM Results
.</hint>
<hint page="0" header="Exchange Register Contents" doc_id="x86_64" token="fxch">Exchanges the contents of registers ST(0) and ST(i). If no source operand is specified, the contents of ST(0) and
ST(1) are exchanged.
This instruction provides a simple means of moving values in the FPU register stack to the top of the stack [ST(0)],
so that they can be operated on by those floating-point instructions that can only operate on values in ST(0). For
example, the following instruction sequence takes the square root of the third register from the top of the register
stack:
     FXCH ST(3);
     FSQRT;
     FXCH ST(3);
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Restore x87 FPU, MMX, XMM, and MXCSR State" doc_id="x86_64" token="fxrstor">Reloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in
the source operand. This data should have been written to memory previously using the FXSAVE instruction, and
in the same format as required by the operating modes. The first byte of the data should be located on a 16-byte
boundary. There are three distinct layouts of the FXSAVE state map: one for legacy and compatibility mode, a
second format for 64-bit mode FXSAVE/FXRSTOR with REX.W=0, and the third format is for 64-bit mode with
FXSAVE64/FXRSTOR64. Table 3-43 shows the layout of the legacy/compatibility mode state information in memory
and describes the fields in the memory image for the FXRSTOR and FXSAVE instructions. Table 3-46 shows the
layout of the 64-bit mode state information when REX.W is set (FXSAVE64/FXRSTOR64). Table 3-47 shows the
layout of the 64-bit mode state information when REX.W is clear (FXSAVE/FXRSTOR).
The state image referenced with an FXRSTOR instruction must have been saved using an FXSAVE instruction or be
in the same format as required by Table 3-43, Table 3-46, or Table 3-47. Referencing a state image saved with an
FSAVE, FNSAVE instruction or incompatible field layout will result in an incorrect state restoration.
The FXRSTOR instruction does not flush pending x87 FPU exceptions. To check and raise exceptions when loading
x87 FPU state information with the FXRSTOR instruction, use an FWAIT instruction after the FXRSTOR instruction.
If the OSFXSR bit in control register CR4 is not set, the FXRSTOR instruction may not restore the states of the XMM
and MXCSR registers. This behavior is implementation dependent.
If the MXCSR state contains an unmasked exception with a corresponding status flag also set, loading the register
with the FXRSTOR instruction will not result in a SIMD floating-point error condition being generated. Only the next
occurrence of this unmasked exception will result in the exception being generated.
Bits 16 through 32 of the MXCSR register are defined as reserved and should be set to 0. Attempting to write a 1 in
any of these bits from the saved state image will result in a general protection exception (#GP) being generated.
Bytes 464:511 of an FXSAVE image are available for software use. FXRSTOR ignores the content of bytes 464:511
in an FXSAVE state image.</hint>
<hint page="0" header="Save x87 FPU, MMX Technology, and SSE State" doc_id="x86_64" token="fxsave">Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory loca-
tion specified in the destination operand. The content layout of the 512 byte region depends on whether the
processor is operating in non-64-bit operating modes or 64-bit sub-mode of IA-32e mode.
Bytes 464:511 are available to software use. The processor does not write to bytes 464:511 of an FXSAVE area.
The operation of FXSAVE in non-64-bit modes is described first.</hint>
<hint page="0" header="Extract Exponent and Significand" doc_id="x86_64" token="fxtract">Separates the source value in the ST(0) register into its exponent and significand, stores the exponent in ST(0),
and pushes the significand onto the register stack. Following this operation, the new top-of-stack register ST(0)
contains the value of the original significand expressed as a floating-point value. The sign and significand of this
value are the same as those found in the source operand, and the exponent is 3FFFH (biased value for a true expo-
nent of zero). The ST(1) register contains the value of the original operand's true (unbiased) exponent expressed
as a floating-point value. (The operation performed by this instruction is a superset of the IEEE-recommended
logb(x) function.)
This instruction and the F2XM1 instruction are useful for performing power and range scaling operations. The
FXTRACT instruction is also useful for converting numbers in double extended-precision floating-point format to
decimal representations (e.g., for printing or displaying).
If the floating-point zero-divide exception (#Z) is masked and the source operand is zero, an exponent value of -
inf is stored in register ST(1) and 0 with the sign of the source operand is stored in register ST(0).
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Compute y * log2x" doc_id="x86_64" token="fyl2x">Computes (ST(1) * log2 (ST(0))), stores the result in resister ST(1), and pops the FPU register stack. The source
operand in ST(0) must be a non-zero positive number.
The following table shows the results obtained when taking the log of various classes of numbers, assuming that
neither overflow nor underflow occurs.
                                                    Table 3-48. FYL2X Results
                                                                            ST(0)
                                 -inf         -F            +-0              +0&lt;+F&lt;+1            +1        +F&gt;+1           +inf           NaN</hint>
<hint page="0" header="Compute y * log2(x +1)" doc_id="x86_64" token="fyl2xp1">Computes (ST(1) * log2(ST(0) + 1.0)), stores the result in register ST(1), and pops the FPU register stack. The
source operand in ST(0) must be in the range:
     - ( 1 - 2 / 2 ) )to ( 1 - 2 / 2 )
The source operand in ST(1) can range from -inf to +inf. If the ST(0) operand is outside of its acceptable range, the
result is undefined and software should not rely on an exception being generated. Under some circumstances
exceptions may be generated when ST(0) is out of range, but this behavior is implementation specific and not
guaranteed.
The following table shows the results obtained when taking the log epsilon of various classes of numbers, assuming
that underflow does not occur.
                                                     Table 3-49. FYL2XP1 Results
                                                                             ST(0)
                                     -(1 - ( 2 / 2 )) to -0          -0              +0             +0 to +(1 - ( 2 / 2 ))          NaN
                     -inf                       +inf                         *            *                     -inf                      NaN
     ST(1)           -F                       +F                     +0               -0                     -F                     NaN
                     -0                       +0                     +0               -0                     -0                     NaN
                     +0                       -0                    -0               +0                      +0                     NaN
                     +F                       -F                    -0               +0                      +F                     NaN
                     +inf                       -inf                         *            *                     +inf                      NaN
                    NaN                      NaN                    NaN              NaN                    NaN                     NaN
 NOTES:
 F Means finite floating-point value.
 * Indicates floating-point invalid-operation (#IA) exception.</hint>
<hint page="0" header="Packed Double-FP Horizontal Add" doc_id="x86_64" token="haddpd">Adds the double-precision floating-point values in the high and low quadwords of the destination operand and
stores the result in the low quadword of the destination operand.
Adds the double-precision floating-point values in the high and low quadwords of the source operand and stores the
result in the high quadword of the destination operand.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
See Figure 3-16 for HADDPD; see Figure 3-17 for VHADDPD.</hint>
<hint page="0" header="Packed Single-FP Horizontal Add" doc_id="x86_64" token="haddps">Adds the single-precision floating-point values in the first and second dwords of the destination operand and stores
the result in the first dword of the destination operand.
Adds single-precision floating-point values in the third and fourth dword of the destination operand and stores the
result in the second dword of the destination operand.
Adds single-precision floating-point values in the first and second dword of the source operand and stores the
result in the third dword of the destination operand.
Adds single-precision floating-point values in the third and fourth dword of the source operand and stores the result
in the fourth dword of the destination operand.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Halt" doc_id="x86_64" token="hlt">Stops instruction execution and places the processor in a HALT state. An enabled interrupt (including NMI and
SMI), a debug exception, the BINIT# signal, the INIT# signal, or the RESET# signal will resume execution. If an
interrupt (including NMI) is used to resume execution after a HLT instruction, the saved instruction pointer
(CS:EIP) points to the instruction following the HLT instruction.
When a HLT instruction is executed on an Intel 64 or IA-32 processor supporting Intel Hyper-Threading Technology,
only the logical processor that executes the instruction is halted. The other logical processors in the physical
processor remain active, unless they are each individually halted by executing a HLT instruction.
The HLT instruction is a privileged instruction. When the processor is running in protected or virtual-8086 mode,
the privilege level of a program or procedure must be 0 to execute the HLT instruction.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Packed Double-FP Horizontal Subtract" doc_id="x86_64" token="hsubpd">The HSUBPD instruction subtracts horizontally the packed DP FP numbers of both operands.
Subtracts the double-precision floating-point value in the high quadword of the destination operand from the low
quadword of the destination operand and stores the result in the low quadword of the destination operand.
Subtracts the double-precision floating-point value in the high quadword of the source operand from the low quad-
word of the source operand and stores the result in the high quadword of the destination operand.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Packed Single-FP Horizontal Subtract" doc_id="x86_64" token="hsubps">Subtracts the single-precision floating-point value in the second dword of the destination operand from the first
dword of the destination operand and stores the result in the first dword of the destination operand.
Subtracts the single-precision floating-point value in the fourth dword of the destination operand from the third
dword of the destination operand and stores the result in the second dword of the destination operand.
Subtracts the single-precision floating-point value in the second dword of the source operand from the first dword
of the source operand and stores the result in the third dword of the destination operand.
Subtracts the single-precision floating-point value in the fourth dword of the source operand from the third dword
of the source operand and stores the result in the fourth dword of the destination operand.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
See Figure 3-22 for HSUBPS; see Figure 3-23 for VHSUBPS.</hint>
<hint page="0" header="Signed Divide" doc_id="x86_64" token="idiv">Divides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by the source operand (divisor) and stores the
result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a
memory location. The action of this instruction depends on the operand size (dividend/divisor).
Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magni-
tude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is
applied, the instruction divides the signed value in RDX:RAX by the source operand. RAX contains a 64-bit
quotient; RDX contains a 64-bit remainder.
See the summary chart at the beginning of this section for encoding data and limits. See Table 3-50.
                                                     Table 3-50. IDIV Results
           Operand Size                 Dividend        Divisor             Quotient        Remainder              Quotient Range
 Word/byte                          AX               r/m8              AL                 AH                 -128 to +127
 Doubleword/word                    DX:AX            r/m16             AX                 DX                 -32,768 to +32,767
 Quadword/doubleword                EDX:EAX          r/m32             EAX                EDX                -231 to 231 - 1
 Doublequadword/ quadword           RDX:RAX          r/m64             RAX                RDX                -263 to 263 - 1</hint>
<hint page="0" header="Signed Multiply" doc_id="x86_64" token="imul">Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of
operands.
.   One-operand form - This form is identical to that used by the MUL instruction. Here, the source operand (in
    a general-purpose register or memory location) is multiplied by the value in the AL, AX, EAX, or RAX register
    (depending on the operand size) and the product (twice the size of the input operand) is stored in the AX,
    DX:AX, EDX:EAX, or RDX:RAX registers, respectively.
.   Two-operand form - With this form the destination operand (the first operand) is multiplied by the source
    operand (second operand). The destination operand is a general-purpose register and the source operand is an
    immediate value, a general-purpose register, or a memory location. The intermediate product (twice the size of
    the input operand) is truncated and stored in the destination operand location.
.   Three-operand form - This form requires a destination operand (the first operand) and two source operands
    (the second and the third operands). Here, the first source operand (which can be a general-purpose register
    or a memory location) is multiplied by the second source operand (an immediate value). The intermediate
    product (twice the size of the first source operand) is truncated and stored in the destination operand (a
    general-purpose register).</hint>
<hint page="0" header="Input from Port" doc_id="x86_64" token="in">Copies the value from the I/O port specified with the second operand (source operand) to the destination operand
(first operand). The source operand can be a byte-immediate or the DX register; the destination operand can be
register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively). Using the
DX register as a source operand allows I/O port addresses from 0 to 65,535 to be accessed; using a byte imme-
diate allows I/O port addresses 0 to 255 to be accessed.
When accessing an 8-bit I/O port, the opcode determines the port size; when accessing a 16- and 32-bit I/O port,
the operand-size attribute determines the port size. At the machine code level, I/O instructions are shorter when
accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.
This instruction is only useful for accessing I/O ports located in the processor's I/O address space. See Chapter 18,
"Input/Output," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for more infor-
mation on accessing I/O ports in the I/O address space.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Increment by 1" doc_id="x86_64" token="inc">Adds 1 to the destination operand, while preserving the state of the CF flag. The destination operand can be a
register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag.
(Use a ADD instruction with an immediate operand of 1 to perform an increment operation that does updates the
CF flag.)
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
In 64-bit mode, INC r16 and INC r32 are not encodable (because opcodes 40H through 47H are REX prefixes).
Otherwise, the instruction's 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to
additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.</hint>
<hint page="0" header="Input from Port to String" doc_id="x86_64" token="ins">Copies the data from the I/O port specified with the source operand (second operand) to the destination operand
(first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The
destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI
registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment
cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of
the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attri-
bute of the instruction for a 16- or 32-bit I/O port.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source operand must be "DX," and the destination operand should be
a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided
to allow documentation; however, note that the documentation provided by this form can be misleading. That is,
the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword),
but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers,
which must be loaded correctly before the INS instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the INS instructions.
Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination
operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD
(doubleword).
After the byte, word, or doubleword is transfer from the I/O port to the memory location, the DI/EDI/RDI register
is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the
DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI
register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword
operations.</hint>
<hint page="0" header="Input from Port to String" doc_id="x86_64" token="insb">Copies the data from the I/O port specified with the source operand (second operand) to the destination operand
(first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The
destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI
registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment
cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of
the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attri-
bute of the instruction for a 16- or 32-bit I/O port.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source operand must be "DX," and the destination operand should be
a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided
to allow documentation; however, note that the documentation provided by this form can be misleading. That is,
the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword),
but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers,
which must be loaded correctly before the INS instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the INS instructions.
Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination
operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD
(doubleword).
After the byte, word, or doubleword is transfer from the I/O port to the memory location, the DI/EDI/RDI register
is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the
DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI
register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword
operations.</hint>
<hint page="0" header="Input from Port to String" doc_id="x86_64" token="insw">Copies the data from the I/O port specified with the source operand (second operand) to the destination operand
(first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The
destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI
registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment
cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of
the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attri-
bute of the instruction for a 16- or 32-bit I/O port.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source operand must be "DX," and the destination operand should be
a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided
to allow documentation; however, note that the documentation provided by this form can be misleading. That is,
the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword),
but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers,
which must be loaded correctly before the INS instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the INS instructions.
Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination
operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD
(doubleword).
After the byte, word, or doubleword is transfer from the I/O port to the memory location, the DI/EDI/RDI register
is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the
DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI
register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword
operations.</hint>
<hint page="0" header="Input from Port to String" doc_id="x86_64" token="insd">Copies the data from the I/O port specified with the source operand (second operand) to the destination operand
(first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The
destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI
registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment
cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of
the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attri-
bute of the instruction for a 16- or 32-bit I/O port.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source operand must be "DX," and the destination operand should be
a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided
to allow documentation; however, note that the documentation provided by this form can be misleading. That is,
the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword),
but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers,
which must be loaded correctly before the INS instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the INS instructions.
Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination
operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD
(doubleword).
After the byte, word, or doubleword is transfer from the I/O port to the memory location, the DI/EDI/RDI register
is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the
DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI
register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword
operations.</hint>
<hint page="0" header="Insert Scalar Single-Precision Floating-Point Value" doc_id="x86_64" token="insertps">(register source form)
Select a single-precision floating-point element from second source as indicated by Count_S bits of the immediate
operand and destination operand it into the first source at the location indicated by the Count_D bits of the imme-
diate operand. Store in the destination and zero out destination elements based on the ZMask bits of the immediate
operand.
(memory source form)
Load a floating-point element from a 32-bit memory location and destination operand it into the first source at the
location indicated by the Count_D bits of the immediate operand. Store in the destination and zero out destination
elements based on the ZMask bits of the immediate operand.
128-bit Legacy SSE version: The first source register is an XMM register. The second source operand is either an
XMM register or a 32-bit memory location. The destination is not distinct from the first source XMM register and the
upper bits (MAX_VL-1:128) of the corresponding register destination are unmodified.
VEX.128 and EVEX encoded version: The destination and first source register is an XMM register. The second
source operand is either an XMM register or a 32-bit memory location. The upper bits (MAX_VL-1:128) of the corre-
sponding register destination are zeroed.
If VINSERTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause
an #UD exception.</hint>
<hint page="0" header="Call to Interrupt Procedure" doc_id="x86_64" token="int n">The INT n instruction generates a call to the interrupt or exception handler specified with the destination operand
(see the section titled "Interrupts and Exceptions" in Chapter 6 of the Intel 64 and IA-32 Architectures Software
Developer's Manual, Volume 1). The destination operand specifies a vector from 0 to 255, encoded as an 8-bit
unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vectors are
reserved by Intel for system use. Some of these vectors are used for internally generated exceptions.
The INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The
INTO instruction is a special mnemonic for calling overflow exception (#OF), exception 4. The overflow interrupt
checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The
INTO instruction cannot be used in 64-bit mode.)
The INT 3 instruction generates a special one byte opcode (CC) that is intended for calling the debug exception
handler. (This one byte form is valuable because it can be used to replace the first byte of any instruction with a
breakpoint, including other one byte instructions, without over-writing other code). To further support its function
as a debug breakpoint, the interrupt generated with the CC opcode also differs from the regular software interrupts
as follows:
.     Interrupt redirection does not happen when in VME mode; the interrupt is handled by a protected-mode
      handler.
.     The virtual-8086 mode IOPL checks do not occur. The interrupt is taken without faulting at any IOPL level.
Note that the "normal" 2-byte opcode for INT 3 (CD03) does not have these special features. Intel and Microsoft
assemblers will not generate the CD03 opcode from any mnemonic, but this opcode can be created by direct
numeric code definition or by self-modifying code.
The action of the INT n instruction (including the INTO and INT 3 instructions) is similar to that of a far call made
with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed
onto the stack before the return address. (The return address is a far address consisting of the current values of
the CS and EIP registers.) Returns from interrupt procedures are handled with the IRET instruction, which pops the
EFLAGS information and return address from the stack.
The vector specifies an interrupt descriptor in the interrupt descriptor table (IDT); that is, it provides index into the
IDT. The selected interrupt descriptor in turn contains a pointer to an interrupt or exception handler procedure.
In protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate,
or task gate. In real-address mode, the IDT is an array of 4-byte far pointers (2-byte code segment selector and
a 2-byte instruction pointer), each of which point directly to a procedure in the selected segment. (Note that in
real-address mode, the IDT is called the interrupt vector table, and its pointers are called interrupt vectors.)
The following decision table indicates which action in the lower portion of the table is taken given the conditions in
the upper portion of the table. Each Y in the lower section of the decision table represents a procedure defined in
the "Operation" section for this instruction (except #GP).</hint>
<hint page="0" header="Call to Interrupt Procedure" doc_id="x86_64" token="into">The INT n instruction generates a call to the interrupt or exception handler specified with the destination operand
(see the section titled "Interrupts and Exceptions" in Chapter 6 of the Intel 64 and IA-32 Architectures Software
Developer's Manual, Volume 1). The destination operand specifies a vector from 0 to 255, encoded as an 8-bit
unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vectors are
reserved by Intel for system use. Some of these vectors are used for internally generated exceptions.
The INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The
INTO instruction is a special mnemonic for calling overflow exception (#OF), exception 4. The overflow interrupt
checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The
INTO instruction cannot be used in 64-bit mode.)
The INT 3 instruction generates a special one byte opcode (CC) that is intended for calling the debug exception
handler. (This one byte form is valuable because it can be used to replace the first byte of any instruction with a
breakpoint, including other one byte instructions, without over-writing other code). To further support its function
as a debug breakpoint, the interrupt generated with the CC opcode also differs from the regular software interrupts
as follows:
.     Interrupt redirection does not happen when in VME mode; the interrupt is handled by a protected-mode
      handler.
.     The virtual-8086 mode IOPL checks do not occur. The interrupt is taken without faulting at any IOPL level.
Note that the "normal" 2-byte opcode for INT 3 (CD03) does not have these special features. Intel and Microsoft
assemblers will not generate the CD03 opcode from any mnemonic, but this opcode can be created by direct
numeric code definition or by self-modifying code.
The action of the INT n instruction (including the INTO and INT 3 instructions) is similar to that of a far call made
with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed
onto the stack before the return address. (The return address is a far address consisting of the current values of
the CS and EIP registers.) Returns from interrupt procedures are handled with the IRET instruction, which pops the
EFLAGS information and return address from the stack.
The vector specifies an interrupt descriptor in the interrupt descriptor table (IDT); that is, it provides index into the
IDT. The selected interrupt descriptor in turn contains a pointer to an interrupt or exception handler procedure.
In protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate,
or task gate. In real-address mode, the IDT is an array of 4-byte far pointers (2-byte code segment selector and
a 2-byte instruction pointer), each of which point directly to a procedure in the selected segment. (Note that in
real-address mode, the IDT is called the interrupt vector table, and its pointers are called interrupt vectors.)
The following decision table indicates which action in the lower portion of the table is taken given the conditions in
the upper portion of the table. Each Y in the lower section of the decision table represents a procedure defined in
the "Operation" section for this instruction (except #GP).</hint>
<hint page="0" header="Call to Interrupt Procedure" doc_id="x86_64" token="int 3">The INT n instruction generates a call to the interrupt or exception handler specified with the destination operand
(see the section titled "Interrupts and Exceptions" in Chapter 6 of the Intel 64 and IA-32 Architectures Software
Developer's Manual, Volume 1). The destination operand specifies a vector from 0 to 255, encoded as an 8-bit
unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vectors are
reserved by Intel for system use. Some of these vectors are used for internally generated exceptions.
The INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The
INTO instruction is a special mnemonic for calling overflow exception (#OF), exception 4. The overflow interrupt
checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The
INTO instruction cannot be used in 64-bit mode.)
The INT 3 instruction generates a special one byte opcode (CC) that is intended for calling the debug exception
handler. (This one byte form is valuable because it can be used to replace the first byte of any instruction with a
breakpoint, including other one byte instructions, without over-writing other code). To further support its function
as a debug breakpoint, the interrupt generated with the CC opcode also differs from the regular software interrupts
as follows:
.     Interrupt redirection does not happen when in VME mode; the interrupt is handled by a protected-mode
      handler.
.     The virtual-8086 mode IOPL checks do not occur. The interrupt is taken without faulting at any IOPL level.
Note that the "normal" 2-byte opcode for INT 3 (CD03) does not have these special features. Intel and Microsoft
assemblers will not generate the CD03 opcode from any mnemonic, but this opcode can be created by direct
numeric code definition or by self-modifying code.
The action of the INT n instruction (including the INTO and INT 3 instructions) is similar to that of a far call made
with the CALL instruction. The primary difference is that with the INT n instruction, the EFLAGS register is pushed
onto the stack before the return address. (The return address is a far address consisting of the current values of
the CS and EIP registers.) Returns from interrupt procedures are handled with the IRET instruction, which pops the
EFLAGS information and return address from the stack.
The vector specifies an interrupt descriptor in the interrupt descriptor table (IDT); that is, it provides index into the
IDT. The selected interrupt descriptor in turn contains a pointer to an interrupt or exception handler procedure.
In protected mode, the IDT contains an array of 8-byte descriptors, each of which is an interrupt gate, trap gate,
or task gate. In real-address mode, the IDT is an array of 4-byte far pointers (2-byte code segment selector and
a 2-byte instruction pointer), each of which point directly to a procedure in the selected segment. (Note that in
real-address mode, the IDT is called the interrupt vector table, and its pointers are called interrupt vectors.)
The following decision table indicates which action in the lower portion of the table is taken given the conditions in
the upper portion of the table. Each Y in the lower section of the decision table represents a procedure defined in
the "Operation" section for this instruction (except #GP).</hint>
<hint page="0" header="Invalidate Internal Caches" doc_id="x86_64" token="invd">Invalidates (flushes) the processor's internal caches and issues a special-function bus cycle that directs external
caches to also flush themselves. Data held in internal caches is not written back to main memory.
After executing this instruction, the processor does not wait for the external caches to complete their flushing oper-
ation before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache flush
signal.
The INVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a
program or procedure must be 0 to execute this instruction.
The INVD instruction may be used when the cache is used as temporary memory and the cache contents need to
be invalidated rather than written back to memory. When the cache is used as temporary memory, no external
device should be actively writing data to main memory.
Use this instruction with care. Data cached internally and not written back to main memory will be lost. Note that
any data from an external device to main memory (for example, via a PCIWrite) can be temporarily stored in the
caches; these data can be lost when an INVD instruction is executed. Unless there is a specific requirement or
benefit to flushing caches without writing back modified cache lines (for example, temporary memory, testing, or
fault recovery where cache coherency with main memory is not a concern), software should instead use the
WBINVD instruction.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Invalidate TLB Entries" doc_id="x86_64" token="invlpg">Invalidates any translation lookaside buffer (TLB) entries specified with the source operand. The source operand is
a memory address. The processor determines the page that contains that address and flushes all TLB entries for
that page.1
The INVLPG instruction is a privileged instruction. When the processor is running in protected mode, the CPL must
be 0 to execute this instruction.
The INVLPG instruction normally flushes TLB entries only for the specified page; however, in some cases, it may
flush more entries, even the entire TLB. The instruction is guaranteed to invalidates only TLB entries associated
with the current PCID. (If PCIDs are disabled - CR4.PCIDE = 0 - the current PCID is 000H.) The instruction also
invalidates any global TLB entries for the specified page, regardless of PCID.
For more details on operations that flush the TLB, see "MOV-Move to/from Control Registers" in the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 2B and Section 4.10.4.1, "Operations that Invalidate
TLBs and Paging-Structure Caches," in the Intel 64 and IA-32 Architectures Software Developer's Manual,
Volume 3A.
This instruction's operation is the same in all non-64-bit modes. It also operates the same in 64-bit mode, except
if the memory address is in non-canonical form. In this case, INVLPG is the same as a NOP.</hint>
<hint page="0" header="Invalidate Process-Context Identifier" doc_id="x86_64" token="invpcid">Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on process-
context identifier (PCID). (See Section 4.10, "Caching Translation Information," in Intel 64 and IA-32 Architecture
Software Developer's Manual, Volume 3A.) Invalidation is based on the INVPCID type specified in the register
operand and the INVPCID descriptor specified in the memory operand.
Outside 64-bit mode, the register operand is always 32 bits, regardless of the value of CS.D. In 64-bit mode the
register operand has 64 bits.
There are four INVPCID types currently defined:
.    Individual-address invalidation: If the INVPCID type is 0, the logical processor invalidates mappings-except
     global translations-for the linear address and PCID specified in the INVPCID descriptor.1 In some cases, the
     instruction may invalidate global translations or mappings for other linear addresses (or other PCIDs) as well.
.    Single-context invalidation: If the INVPCID type is 1, the logical processor invalidates all mappings-except
     global translations-associated with the PCID specified in the INVPCID descriptor. In some cases, the
     instruction may invalidate global translations or mappings for other PCIDs as well.
.    All-context invalidation, including global translations: If the INVPCID type is 2, the logical processor invalidates
     all mappings-including global translations-associated with any PCID.
.    All-context invalidation: If the INVPCID type is 3, the logical processor invalidates all mappings-except global
     translations-associated with any PCID. In some case, the instruction may invalidate global translations as
     well.
The INVPCID descriptor comprises 128 bits and consists of a PCID and a linear address as shown in Figure 3-24.
For INVPCID type 0, the processor uses the full 64 bits of the linear address even outside 64-bit mode; the linear
address is not used for other INVPCID types.</hint>
<hint page="0" header="Interrupt Return" doc_id="x86_64" token="iret">Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by
an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform
a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or
when an interrupt or exception causes a task switch to an interrupt or exception handler.) See the section titled
"Task Linking" in Chapter 7 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A.
IRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended
for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the
IRET mnemonic interchangeably for both operand sizes.
In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During
this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image
from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted
program or procedure.
In Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags
in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting
of these flags, the processor performs the following types of interrupt returns:
.    Return from virtual-8086 mode.
.    Return to virtual-8086 mode.
.    Intra-privilege level return.
.    Inter-privilege level return.
.    Return from nested task (task switch).
If the NT flag (EFLAGS register) is cleared, the IRET instruction performs a far return from the interrupt procedure,
without a task switch. The code segment being returned to must be equally or less privileged than the interrupt
handler routine (as indicated by the RPL field of the code segment selector popped from the stack).
As with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code
segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then
resumes execution of the interrupted program or procedure. If the return is to another privilege level, the IRET
instruction also pops the stack pointer and SS from the stack, before resuming program execution. If the return is
to virtual-8086 mode, the processor also pops the data segment registers from the stack.
If the NT flag is set, the IRET instruction performs a task switch (return) from a nested task (a task called with a
CALL instruction, an interrupt, or an exception) back to the calling or interrupted task. The updated state of the
task executing the IRET instruction is saved in its TSS. If the task is re-entered later, the code that follows the IRET
instruction is executed.
If the NT flag is set and the processor is in IA-32e mode, the IRET instruction causes a general protection excep-
tion.
If nonmaskable interrupts (NMIs) are blocked (see Section 6.7.1, "Handling Multiple NMIs" in the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 3A), execution of the IRET instruction unblocks NMIs.</hint>
<hint page="0" header="Interrupt Return" doc_id="x86_64" token="iretd">Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by
an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform
a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or
when an interrupt or exception causes a task switch to an interrupt or exception handler.) See the section titled
"Task Linking" in Chapter 7 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A.
IRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended
for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the
IRET mnemonic interchangeably for both operand sizes.
In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During
this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image
from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted
program or procedure.
In Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags
in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting
of these flags, the processor performs the following types of interrupt returns:
.    Return from virtual-8086 mode.
.    Return to virtual-8086 mode.
.    Intra-privilege level return.
.    Inter-privilege level return.
.    Return from nested task (task switch).
If the NT flag (EFLAGS register) is cleared, the IRET instruction performs a far return from the interrupt procedure,
without a task switch. The code segment being returned to must be equally or less privileged than the interrupt
handler routine (as indicated by the RPL field of the code segment selector popped from the stack).
As with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code
segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then
resumes execution of the interrupted program or procedure. If the return is to another privilege level, the IRET
instruction also pops the stack pointer and SS from the stack, before resuming program execution. If the return is
to virtual-8086 mode, the processor also pops the data segment registers from the stack.
If the NT flag is set, the IRET instruction performs a task switch (return) from a nested task (a task called with a
CALL instruction, an interrupt, or an exception) back to the calling or interrupted task. The updated state of the
task executing the IRET instruction is saved in its TSS. If the task is re-entered later, the code that follows the IRET
instruction is executed.
If the NT flag is set and the processor is in IA-32e mode, the IRET instruction causes a general protection excep-
tion.
If nonmaskable interrupts (NMIs) are blocked (see Section 6.7.1, "Handling Multiple NMIs" in the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 3A), execution of the IRET instruction unblocks NMIs.</hint>
<hint page="0" header="Jump if Condition Is Met (Above or Equal)" doc_id="x86_64" token="jae">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Greater Than or Equal)" doc_id="x86_64" token="jge">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Not Less Than or Equal)" doc_id="x86_64" token="jnle">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Not Below or Equal)" doc_id="x86_64" token="jnbe">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Not Great Than or Equal)" doc_id="x86_64" token="jnge">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Less Than or Equal)" doc_id="x86_64" token="jle">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Not Less Than)" doc_id="x86_64" token="jnl">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (No Overflow)" doc_id="x86_64" token="jno">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Not Above)" doc_id="x86_64" token="jna">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Not Below)" doc_id="x86_64" token="jnb">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (No Carry)" doc_id="x86_64" token="jnc">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Not Equal)" doc_id="x86_64" token="jne">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Not Greater Than)" doc_id="x86_64" token="jng">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Not Zero)" doc_id="x86_64" token="jnz">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Parity Even)" doc_id="x86_64" token="jpe">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (No Parity)" doc_id="x86_64" token="jnp">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (No Sign)" doc_id="x86_64" token="jns">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Parity Odd)" doc_id="x86_64" token="jpo">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Below or Equal)" doc_id="x86_64" token="jbe">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Above)" doc_id="x86_64" token="ja">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Carry)" doc_id="x86_64" token="jc">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Below)" doc_id="x86_64" token="jb">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Equal)" doc_id="x86_64" token="je">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Greater Than)" doc_id="x86_64" token="jg">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Not Above or Equal)" doc_id="x86_64" token="jnae">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Less than)" doc_id="x86_64" token="jl">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Overflow)" doc_id="x86_64" token="jo">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Parity)" doc_id="x86_64" token="jp">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Sign)" doc_id="x86_64" token="js">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump if Condition Is Met (Zero)" doc_id="x86_64" token="jz">Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags
are in the specified state (condition), performs a jump to the target instruction specified by the destination
operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the
condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc
instruction.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly
code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to
the instruction pointer. Instruction coding is most efficient for offsets of -128 to +127. If the operand-size attribute
is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.
The conditions for each Jcc mnemonic are given in the "Description" column of the table on the preceding page. The
terms "less" and "greater" are used for comparisons of signed integers and the terms "above" and "below" are used
for unsigned integers.
Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are
defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or
equal) instruction are alternate mnemonics for the opcode 77H.
The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional
jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction,
and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the
following conditional far jump is illegal:
   JZ FARLABEL;
To accomplish this far jump, use the following two instructions:
   JNZ BEYOND;
   JMP FARLABEL;
   BEYOND:
The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags.
Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These
instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction
(such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX
is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).
All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-
ability.
In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP
Near is RIP = RIP + 32-bit offset sign extended to 64-bits.</hint>
<hint page="0" header="Jump" doc_id="x86_64" token="jmp">Transfers program control to a different point in the instruction stream without recording return information. The
destination (target) operand specifies the address of the instruction being jumped to. This operand can be an
immediate value, a general-purpose register, or a memory location.
This instruction can be used to execute four different types of jumps:
.    Near jump-A jump to an instruction within the current code segment (the segment currently pointed to by the
     CS register), sometimes referred to as an intrasegment jump.
.    Short jump-A near jump where the jump range is limited to -128 to +127 from the current EIP value.
.    Far jump-A jump to an instruction located in a different segment than the current code segment but at the
     same privilege level, sometimes referred to as an intersegment jump.
.    Task switch-A jump to an instruction located in a different task.
A task switch can only be executed in protected mode (see Chapter 7, in the Intel 64 and IA-32 Architectures
Software Developer's Manual, Volume 3A, for information on performing task switches with the JMP instruction).
Near and Short Jumps. When executing a near jump, the processor jumps to the address (within the current code
segment) that is specified with the target operand. The target operand specifies either an absolute offset (that is
an offset from the base of the code segment) or a relative offset (a signed displacement relative to the current</hint>
<hint page="0" header="ADD Two Masks" doc_id="x86_64" token="kaddw">Adds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.</hint>
<hint page="0" header="ADD Two Masks" doc_id="x86_64" token="kaddb">Adds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.</hint>
<hint page="0" header="ADD Two Masks" doc_id="x86_64" token="kaddq">Adds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.</hint>
<hint page="0" header="ADD Two Masks" doc_id="x86_64" token="kaddd">Adds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.</hint>
<hint page="0" header="Bitwise Logical AND Masks" doc_id="x86_64" token="kandw">Performs a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask
k1.</hint>
<hint page="0" header="Bitwise Logical AND Masks" doc_id="x86_64" token="kandb">Performs a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask
k1.</hint>
<hint page="0" header="Bitwise Logical AND Masks" doc_id="x86_64" token="kandq">Performs a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask
k1.</hint>
<hint page="0" header="Bitwise Logical AND Masks" doc_id="x86_64" token="kandd">Performs a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask
k1.</hint>
<hint page="0" header="Bitwise Logical AND NOT Masks" doc_id="x86_64" token="kandnw">Performs a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector
mask k1.</hint>
<hint page="0" header="Bitwise Logical AND NOT Masks" doc_id="x86_64" token="kandnb">Performs a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector
mask k1.</hint>
<hint page="0" header="Bitwise Logical AND NOT Masks" doc_id="x86_64" token="kandnq">Performs a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector
mask k1.</hint>
<hint page="0" header="Bitwise Logical AND NOT Masks" doc_id="x86_64" token="kandnd">Performs a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector
mask k1.</hint>
<hint page="0" header="Move from and to Mask Registers" doc_id="x86_64" token="kmovw">Copies values from the source operand (second operand) to the destination operand (first operand). The source
and destination operands can be mask registers, memory location or general purpose. The instruction cannot be
used to transfer data between general purpose registers and or memory locations.
When moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving
to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the
default GPR destination's size is 32 bits. In 64-bit mode, the default GPR destination's size is 64 bits. Note that
REX.W cannot be used to modify the size of the general-purpose destination.</hint>
<hint page="0" header="Move from and to Mask Registers" doc_id="x86_64" token="kmovb">Copies values from the source operand (second operand) to the destination operand (first operand). The source
and destination operands can be mask registers, memory location or general purpose. The instruction cannot be
used to transfer data between general purpose registers and or memory locations.
When moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving
to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the
default GPR destination's size is 32 bits. In 64-bit mode, the default GPR destination's size is 64 bits. Note that
REX.W cannot be used to modify the size of the general-purpose destination.</hint>
<hint page="0" header="Move from and to Mask Registers" doc_id="x86_64" token="kmovq">Copies values from the source operand (second operand) to the destination operand (first operand). The source
and destination operands can be mask registers, memory location or general purpose. The instruction cannot be
used to transfer data between general purpose registers and or memory locations.
When moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving
to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the
default GPR destination's size is 32 bits. In 64-bit mode, the default GPR destination's size is 64 bits. Note that
REX.W cannot be used to modify the size of the general-purpose destination.</hint>
<hint page="0" header="Move from and to Mask Registers" doc_id="x86_64" token="kmovd">Copies values from the source operand (second operand) to the destination operand (first operand). The source
and destination operands can be mask registers, memory location or general purpose. The instruction cannot be
used to transfer data between general purpose registers and or memory locations.
When moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving
to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the
default GPR destination's size is 32 bits. In 64-bit mode, the default GPR destination's size is 64 bits. Note that
REX.W cannot be used to modify the size of the general-purpose destination.</hint>
<hint page="0" header="NOT Mask Register" doc_id="x86_64" token="knotw">Performs a bitwise NOT of vector mask k2 and writes the result into vector mask k1.</hint>
<hint page="0" header="NOT Mask Register" doc_id="x86_64" token="knotb">Performs a bitwise NOT of vector mask k2 and writes the result into vector mask k1.</hint>
<hint page="0" header="NOT Mask Register" doc_id="x86_64" token="knotq">Performs a bitwise NOT of vector mask k2 and writes the result into vector mask k1.</hint>
<hint page="0" header="NOT Mask Register" doc_id="x86_64" token="knotd">Performs a bitwise NOT of vector mask k2 and writes the result into vector mask k1.</hint>
<hint page="0" header="Bitwise Logical OR Masks" doc_id="x86_64" token="korw">Performs a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask
k1 (three-operand form).</hint>
<hint page="0" header="Bitwise Logical OR Masks" doc_id="x86_64" token="korb">Performs a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask
k1 (three-operand form).</hint>
<hint page="0" header="Bitwise Logical OR Masks" doc_id="x86_64" token="korq">Performs a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask
k1 (three-operand form).</hint>
<hint page="0" header="Bitwise Logical OR Masks" doc_id="x86_64" token="kord">Performs a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask
k1 (three-operand form).</hint>
<hint page="0" header="OR Masks And Set Flags" doc_id="x86_64" token="kortestw">Performs a bitwise OR between the vector mask register k2, and the vector mask register k1, and sets CF and ZF
based on the operation result.
ZF flag is set if both sources are 0x0. CF is set if, after the OR operation is done, the operation result is all 1's.</hint>
<hint page="0" header="OR Masks And Set Flags" doc_id="x86_64" token="kortestb">Performs a bitwise OR between the vector mask register k2, and the vector mask register k1, and sets CF and ZF
based on the operation result.
ZF flag is set if both sources are 0x0. CF is set if, after the OR operation is done, the operation result is all 1's.</hint>
<hint page="0" header="OR Masks And Set Flags" doc_id="x86_64" token="kortestq">Performs a bitwise OR between the vector mask register k2, and the vector mask register k1, and sets CF and ZF
based on the operation result.
ZF flag is set if both sources are 0x0. CF is set if, after the OR operation is done, the operation result is all 1's.</hint>
<hint page="0" header="OR Masks And Set Flags" doc_id="x86_64" token="kortestd">Performs a bitwise OR between the vector mask register k2, and the vector mask register k1, and sets CF and ZF
based on the operation result.
ZF flag is set if both sources are 0x0. CF is set if, after the OR operation is done, the operation result is all 1's.</hint>
<hint page="0" header="Shift Left Mask Registers" doc_id="x86_64" token="kshiftlw">Shifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and
place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destina-
tion are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for
word shift), 31 (for doubleword shift) or 63 (for quadword shift).</hint>
<hint page="0" header="Shift Left Mask Registers" doc_id="x86_64" token="kshiftlb">Shifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and
place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destina-
tion are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for
word shift), 31 (for doubleword shift) or 63 (for quadword shift).</hint>
<hint page="0" header="Shift Left Mask Registers" doc_id="x86_64" token="kshiftlq">Shifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and
place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destina-
tion are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for
word shift), 31 (for doubleword shift) or 63 (for quadword shift).</hint>
<hint page="0" header="Shift Left Mask Registers" doc_id="x86_64" token="kshiftld">Shifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and
place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destina-
tion are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for
word shift), 31 (for doubleword shift) or 63 (for quadword shift).</hint>
<hint page="0" header="Shift Right Mask Registers" doc_id="x86_64" token="kshiftrw">Shifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place
the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are
zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift),
31 (for doubleword shift) or 63 (for quadword shift).</hint>
<hint page="0" header="Shift Right Mask Registers" doc_id="x86_64" token="kshiftrb">Shifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place
the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are
zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift),
31 (for doubleword shift) or 63 (for quadword shift).</hint>
<hint page="0" header="Shift Right Mask Registers" doc_id="x86_64" token="kshiftrq">Shifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place
the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are
zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift),
31 (for doubleword shift) or 63 (for quadword shift).</hint>
<hint page="0" header="Shift Right Mask Registers" doc_id="x86_64" token="kshiftrd">Shifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place
the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are
zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift),
31 (for doubleword shift) or 63 (for quadword shift).</hint>
<hint page="0" header="Packed Bit Test Masks and Set Flags" doc_id="x86_64" token="ktestw">Performs a bitwise comparison of the bits of the first source operand and corresponding bits in the second source
operand. If the AND operation produces all zeros, the ZF is set else the ZF is clear. If the bitwise AND operation of
the inverted first source operand with the second source operand produces all zeros the CF is set else the CF is
clear. Only the EFLAGS register is updated.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Packed Bit Test Masks and Set Flags" doc_id="x86_64" token="ktestb">Performs a bitwise comparison of the bits of the first source operand and corresponding bits in the second source
operand. If the AND operation produces all zeros, the ZF is set else the ZF is clear. If the bitwise AND operation of
the inverted first source operand with the second source operand produces all zeros the CF is set else the CF is
clear. Only the EFLAGS register is updated.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Packed Bit Test Masks and Set Flags" doc_id="x86_64" token="ktestq">Performs a bitwise comparison of the bits of the first source operand and corresponding bits in the second source
operand. If the AND operation produces all zeros, the ZF is set else the ZF is clear. If the bitwise AND operation of
the inverted first source operand with the second source operand produces all zeros the CF is set else the CF is
clear. Only the EFLAGS register is updated.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Packed Bit Test Masks and Set Flags" doc_id="x86_64" token="ktestd">Performs a bitwise comparison of the bits of the first source operand and corresponding bits in the second source
operand. If the AND operation produces all zeros, the ZF is set else the ZF is clear. If the bitwise AND operation of
the inverted first source operand with the second source operand produces all zeros the CF is set else the CF is
clear. Only the EFLAGS register is updated.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Unpack for Mask Registers" doc_id="x86_64" token="kunpckbw">Unpacks the lower 8/16/32 bits of the second and third operands (source operands) into the low part of the first
operand (destination operand), starting from the low bytes. The result is zero-extended in the destination.</hint>
<hint page="0" header="Unpack for Mask Registers" doc_id="x86_64" token="kunpckwd">Unpacks the lower 8/16/32 bits of the second and third operands (source operands) into the low part of the first
operand (destination operand), starting from the low bytes. The result is zero-extended in the destination.</hint>
<hint page="0" header="Unpack for Mask Registers" doc_id="x86_64" token="kunpckdq">Unpacks the lower 8/16/32 bits of the second and third operands (source operands) into the low part of the first
operand (destination operand), starting from the low bytes. The result is zero-extended in the destination.</hint>
<hint page="0" header="Bitwise Logical XNOR Masks" doc_id="x86_64" token="kxnorw">Performs a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector
mask k1 (three-operand form).</hint>
<hint page="0" header="Bitwise Logical XNOR Masks" doc_id="x86_64" token="kxnorb">Performs a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector
mask k1 (three-operand form).</hint>
<hint page="0" header="Bitwise Logical XNOR Masks" doc_id="x86_64" token="kxnorq">Performs a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector
mask k1 (three-operand form).</hint>
<hint page="0" header="Bitwise Logical XNOR Masks" doc_id="x86_64" token="kxnord">Performs a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector
mask k1 (three-operand form).</hint>
<hint page="0" header="Bitwise Logical XOR Masks" doc_id="x86_64" token="kxorw">Performs a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask
k1 (three-operand form).</hint>
<hint page="0" header="Bitwise Logical XOR Masks" doc_id="x86_64" token="kxorb">Performs a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask
k1 (three-operand form).</hint>
<hint page="0" header="Bitwise Logical XOR Masks" doc_id="x86_64" token="kxorq">Performs a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask
k1 (three-operand form).</hint>
<hint page="0" header="Bitwise Logical XOR Masks" doc_id="x86_64" token="kxord">Performs a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask
k1 (three-operand form).</hint>
<hint page="0" header="Load Status Flags into AH Register" doc_id="x86_64" token="lahf">This instruction executes as described above in compatibility mode and legacy mode. It is valid in 64-bit mode only
if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1.</hint>
<hint page="0" header="Load Access Rights Byte" doc_id="x86_64" token="lar">Loads the access rights from the segment descriptor specified by the second operand (source operand) into the
first operand (destination operand) and sets the ZF flag in the flag register. The source operand (which can be a
register or a memory location) contains the segment selector for the segment descriptor being accessed. If the
source operand is a memory address, only 16 bits of data are accessed. The destination operand is a general-
purpose register.
The processor performs access checks as part of the loading process. Once loaded in the destination register, soft-
ware can perform additional checks on the access rights information.
The access rights for a segment descriptor include fields located in the second doubleword (bytes 4-7) of the
segment descriptor. The following fields are loaded by the LAR instruction:
.   Bits 7:0 are returned as 0
.   Bits 11:8 return the segment type.
.   Bit 12 returns the S flag.
.   Bits 14:13 return the DPL.
.   Bit 15 returns the P flag.
.   The following fields are returned only if the operand size is greater than 16 bits:
    - Bits 19:16 are undefined.
    - Bit 20 returns the software-available bit in the descriptor.
    - Bit 21 returns the L flag.
    - Bit 22 returns the D/B flag.
    - Bit 23 returns the G flag.
    - Bits 31:24 are returned as 0.
This instruction performs the following checks before it loads the access rights in the destination register:
.   Checks that the segment selector is not NULL.
.   Checks that the segment selector points to a descriptor that is within the limits of the GDT or LDT being
    accessed
.   Checks that the descriptor type is valid for this instruction. All code and data segment descriptors are valid for
    (can be accessed with) the LAR instruction. The valid system segment and gate descriptor types are given in
    Table 3-52.
.   If the segment is not a conforming code segment, it checks that the specified segment descriptor is visible at
    the CPL (that is, if the CPL and the RPL of the segment selector are less than or equal to the DPL of the segment
    selector).
If the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no
access rights are loaded in the destination operand.</hint>
<hint page="0" header="Load Unaligned Integer 128 Bits" doc_id="x86_64" token="lddqu">The instruction is functionally similar to (V)MOVDQU ymm/xmm, m256/m128 for loading from memory. That is:
32/16 bytes of data starting at an address specified by the source memory operand (second operand) are fetched
from memory and placed in a destination register (first operand). The source operand need not be aligned on a
32/16-byte boundary. Up to 64/32 bytes may be loaded from memory; this is implementation dependent.
This instruction may improve performance relative to (V)MOVDQU if the source operand crosses a cache line
boundary. In situations that require the data loaded by (V)LDDQU be modified and stored to the same location, use
(V)MOVDQU or (V)MOVDQA instead of (V)LDDQU. To move a double quadword to or from memory locations that
are known to be aligned on 16-byte boundaries, use the (V)MOVDQA instruction.</hint>
<hint page="0" header="Load MXCSR Register" doc_id="x86_64" token="ldmxcsr">Loads the source operand into the MXCSR control/status register. The source operand is a 32-bit memory location.
See "MXCSR Control and Status Register" in Chapter 10, of the Intel 64 and IA-32 Architectures Software Devel-
oper's Manual, Volume 1, for a description of the MXCSR register and its contents.
The LDMXCSR instruction is typically used in conjunction with the (V)STMXCSR instruction, which stores the
contents of the MXCSR register in memory.
The default MXCSR value at reset is 1F80H.
If a (V)LDMXCSR instruction clears a SIMD floating-point exception mask bit and sets the corresponding exception
flag bit, a SIMD floating-point exception will not be immediately generated. The exception will be generated only
upon the execution of the next instruction that meets both conditions below:
.   the instruction must operate on an XMM or YMM register operand,
.   the instruction causes that particular SIMD floating-point exception to be reported.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.
If VLDMXCSR is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an
#UD exception.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Load Far Pointer" doc_id="x86_64" token="lds">Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment
register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in
memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The
instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-
bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS,
SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.
If one of these instructions is executed in protected mode, additional information from the segment descriptor
pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment
register.
Also in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers
without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment
register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to
the segment occurs.)
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes
operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory.
Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). See the summary chart at
the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Load Far Pointer" doc_id="x86_64" token="les">Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment
register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in
memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The
instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-
bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS,
SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.
If one of these instructions is executed in protected mode, additional information from the segment descriptor
pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment
register.
Also in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers
without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment
register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to
the segment occurs.)
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes
operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory.
Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). See the summary chart at
the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Load Far Pointer" doc_id="x86_64" token="lfs">Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment
register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in
memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The
instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-
bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS,
SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.
If one of these instructions is executed in protected mode, additional information from the segment descriptor
pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment
register.
Also in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers
without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment
register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to
the segment occurs.)
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes
operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory.
Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). See the summary chart at
the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Load Far Pointer" doc_id="x86_64" token="lgs">Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment
register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in
memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The
instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-
bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS,
SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.
If one of these instructions is executed in protected mode, additional information from the segment descriptor
pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment
register.
Also in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers
without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment
register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to
the segment occurs.)
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes
operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory.
Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). See the summary chart at
the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Load Far Pointer" doc_id="x86_64" token="lss">Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment
register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in
memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The
instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-
bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS,
SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.
If one of these instructions is executed in protected mode, additional information from the segment descriptor
pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment
register.
Also in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers
without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment
register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to
the segment occurs.)
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes
operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory.
Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). See the summary chart at
the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Load Effective Address" doc_id="x86_64" token="lea">Computes the effective address of the second operand (the source operand) and stores it in the first operand
(destination operand). The source operand is a memory address (offset part) specified with one of the processors
addressing modes; the destination operand is a general-purpose register. The address-size and operand-size attri-
butes affect the action performed by this instruction, as shown in the following table. The operand-size attribute of
the instruction is determined by the chosen register; the address-size attribute is determined by the attribute of
the code segment.
                 Table 3-53. Non-64-bit Mode LEA Operation with Address and Operand Size Attributes
  Operand Size       Address Size                                                 Action Performed
        16                   16            16-bit effective address is calculated and stored in requested 16-bit register destination.
        16                   32            32-bit effective address is calculated. The lower 16 bits of the address are stored in the
                                           requested 16-bit register destination.
        32                   16            16-bit effective address is calculated. The 16-bit address is zero-extended and stored in the
                                           requested 32-bit register destination.
        32                   32            32-bit effective address is calculated and stored in the requested 32-bit register destination.</hint>
<hint page="0" header="High Level Procedure Exit" doc_id="x86_64" token="leave">Releases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction copies the frame pointer (in
the EBP register) into the stack pointer register (ESP), which releases the stack space allocated to the stack frame.
The old frame pointer (the frame pointer for the calling procedure that was saved by the ENTER instruction) is then
popped from the stack into the EBP register, restoring the calling procedure's stack frame.
A RET instruction is commonly executed following a LEAVE instruction to return program control to the calling
procedure.
See "Procedure Calls for Block-Structured Languages" in Chapter 7 of the Intel 64 and IA-32 Architectures Soft-
ware Developer's Manual, Volume 1, for detailed information on the use of the ENTER and LEAVE instructions.
In 64-bit mode, the instruction's default operation size is 64 bits; 32-bit operation cannot be encoded. See the
summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Load Fence" doc_id="x86_64" token="lfence">Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruc-
tion. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruc-
tion begins execution until LFENCE completes. In particular, an instruction that loads from memory and that
precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an
instruction that stores to memory might complete before the data being stored have become globally visible.)
Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute until
the LFENCE completes.
Weakly ordered memory types can be used to achieve higher processor performance through such techniques as
out-of-order issue and speculative reads. The degree to which a consumer of data recognizes or knows that the
data is weakly ordered varies among applications and may be unknown to the producer of this data. The LFENCE
instruction provides a performance-efficient way of ensuring load ordering between routines that produce weakly-
ordered results and routines that consume that data.
Processors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC,
and WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution.
Thus, it is not ordered with respect to executions of the LFENCE instruction; data can be brought into the caches
speculatively just before, during, or after the execution of an LFENCE instruction.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.
Specification of the instruction's opcode above indicates a ModR/M byte of E8. For this instruction, the processor
ignores the r/m field of the ModR/M byte. Thus, LFENCE is encoded by any opcode of the form 0F AE Ex, where x is
in the range 8-F.</hint>
<hint page="0" header="Load Global/Interrupt Descriptor Table Register" doc_id="x86_64" token="lgdt">Loads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor
table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a
linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor
table (IDT). If operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-
bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute
is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here,
the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is
filled with zeros.
The LGDT and LIDT instructions are used only in operating-system software; they are not used in application
programs. They are the only instructions that directly load a linear address (that is, not a segment-relative
address) and a limit in protected mode. They are commonly executed in real-address mode to allow processor
initialization prior to switching to protected mode.
In 64-bit mode, the instruction's operand size is fixed at 8+2 bytes (an 8-byte base and a 2-byte limit). See the
summary chart at the beginning of this section for encoding data and limits.
See "SGDT-Store Global Descriptor Table Register" in Chapter 4, Intel 64 and IA-32 Architectures Software
Developer's Manual, Volume 2B, for information on storing the contents of the GDTR and IDTR.</hint>
<hint page="0" header="Load Global/Interrupt Descriptor Table Register" doc_id="x86_64" token="lidt">Loads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor
table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a
linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor
table (IDT). If operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-
bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute
is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here,
the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is
filled with zeros.
The LGDT and LIDT instructions are used only in operating-system software; they are not used in application
programs. They are the only instructions that directly load a linear address (that is, not a segment-relative
address) and a limit in protected mode. They are commonly executed in real-address mode to allow processor
initialization prior to switching to protected mode.
In 64-bit mode, the instruction's operand size is fixed at 8+2 bytes (an 8-byte base and a 2-byte limit). See the
summary chart at the beginning of this section for encoding data and limits.
See "SGDT-Store Global Descriptor Table Register" in Chapter 4, Intel 64 and IA-32 Architectures Software
Developer's Manual, Volume 2B, for information on storing the contents of the GDTR and IDTR.</hint>
<hint page="0" header="Load Local Descriptor Table Register" doc_id="x86_64" token="lldt">Loads the source operand into the segment selector field of the local descriptor table register (LDTR). The source
operand (a general-purpose register or a memory location) contains a segment selector that points to a local
descriptor table (LDT). After the segment selector is loaded in the LDTR, the processor uses the segment selector
to locate the segment descriptor for the LDT in the global descriptor table (GDT). It then loads the segment limit
and base address for the LDT from the segment descriptor into the LDTR. The segment registers DS, ES, SS, FS,
GS, and CS are not affected by this instruction, nor is the LDTR field in the task state segment (TSS) for the current
task.
If bits 2-15 of the source operand are 0, LDTR is marked invalid and the LLDT instruction completes silently.
However, all subsequent references to descriptors in the LDT (except by the LAR, VERR, VERW or LSL instructions)
cause a general protection exception (#GP).
The operand-size attribute has no effect on this instruction.
The LLDT instruction is provided for use in operating-system software; it should not be used in application
programs. This instruction can only be executed in protected mode or 64-bit mode.
In 64-bit mode, the operand size is fixed at 16 bits.</hint>
<hint page="0" header="Load Machine Status Word" doc_id="x86_64" token="lmsw">Loads the source operand into the machine status word, bits 0 through 15 of register CR0. The source operand can
be a 16-bit general-purpose register or a memory location. Only the low-order 4 bits of the source operand (which
contains the PE, MP, EM, and TS flags) are loaded into CR0. The PG, CD, NW, AM, WP, NE, and ET flags of CR0 are
not affected. The operand-size attribute has no effect on this instruction.
If the PE flag of the source operand (bit 0) is set to 1, the instruction causes the processor to switch to protected
mode. While in protected mode, the LMSW instruction cannot be used to clear the PE flag and force a switch back
to real-address mode.
The LMSW instruction is provided for use in operating-system software; it should not be used in application
programs. In protected or virtual-8086 mode, it can only be executed at CPL 0.
This instruction is provided for compatibility with the Intel 286 processor; programs and procedures intended to
run on IA-32 and Intel 64 processors beginning with Intel386 processors should use the MOV (control registers)
instruction to load the whole CR0 register. The MOV CR0 instruction can be used to set and clear the PE flag in CR0,
allowing a procedure or program to switch between protected and real-address modes.
This instruction is a serializing instruction.
This instruction's operation is the same in non-64-bit modes and 64-bit mode. Note that the operand size is fixed
at 16 bits.
See "Changes to Instruction Behavior in VMX Non-Root Operation" in Chapter 25 of the Intel 64 and IA-32 Archi-
tectures Software Developer's Manual, Volume 3C, for more information about the behavior of this instruction in
VMX non-root operation.</hint>
<hint page="0" header="Assert LOCK# Signal Prefix" doc_id="x86_64" token="lock">Causes the processor's LOCK# signal to be asserted during execution of the accompanying instruction (turns the
instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal ensures that the
processor has exclusive use of any shared memory while the signal is asserted.
In most IA-32 and all Intel 64 processors, locking may occur without the LOCK# signal being asserted. See the "IA-
32 Architecture Compatibility" section below for more details.
The LOCK prefix can be prepended only to the following instructions and only to those forms of the instructions
where the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B,
CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. If the LOCK prefix is used with one of
these instructions and the source operand is a memory operand, an undefined opcode exception (#UD) may be
generated. An undefined opcode exception will also be generated if the LOCK prefix is used with any instruction not
in the above list. The XCHG instruction always asserts the LOCK# signal regardless of the presence or absence of
the LOCK prefix.
The LOCK prefix is typically used with the BTS instruction to perform a read-modify-write operation on a memory
location in shared memory environment.
The integrity of the LOCK prefix is not affected by the alignment of the memory field. Memory locking is observed
for arbitrarily misaligned fields.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Load String" doc_id="x86_64" token="lods">Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The
source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers
(depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be over-
ridden with a segment override prefix.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be
specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source
value. The destination operand is then automatically selected to match the size of the source operand (the AL
register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form
is provided to allow documentation; however, note that the documentation provided by this form can be
misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or
doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI
registers, which must be loaded correctly before the load string instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the LODS instructions.
Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the desti-
nation operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte
loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).
After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the
(E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS
register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.)
The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for
doubleword operations.</hint>
<hint page="0" header="Load String" doc_id="x86_64" token="lodsb">Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The
source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers
(depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be over-
ridden with a segment override prefix.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be
specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source
value. The destination operand is then automatically selected to match the size of the source operand (the AL
register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form
is provided to allow documentation; however, note that the documentation provided by this form can be
misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or
doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI
registers, which must be loaded correctly before the load string instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the LODS instructions.
Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the desti-
nation operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte
loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).
After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the
(E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS
register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.)
The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for
doubleword operations.</hint>
<hint page="0" header="Load String" doc_id="x86_64" token="lodsw">Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The
source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers
(depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be over-
ridden with a segment override prefix.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be
specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source
value. The destination operand is then automatically selected to match the size of the source operand (the AL
register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form
is provided to allow documentation; however, note that the documentation provided by this form can be
misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or
doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI
registers, which must be loaded correctly before the load string instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the LODS instructions.
Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the desti-
nation operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte
loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).
After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the
(E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS
register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.)
The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for
doubleword operations.</hint>
<hint page="0" header="Load String" doc_id="x86_64" token="lodsd">Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The
source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers
(depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be over-
ridden with a segment override prefix.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be
specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source
value. The destination operand is then automatically selected to match the size of the source operand (the AL
register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form
is provided to allow documentation; however, note that the documentation provided by this form can be
misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or
doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI
registers, which must be loaded correctly before the load string instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the LODS instructions.
Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the desti-
nation operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte
loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).
After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the
(E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS
register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.)
The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for
doubleword operations.</hint>
<hint page="0" header="Load String" doc_id="x86_64" token="lodsq">Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The
source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers
(depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be over-
ridden with a segment override prefix.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be
specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source
value. The destination operand is then automatically selected to match the size of the source operand (the AL
register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form
is provided to allow documentation; however, note that the documentation provided by this form can be
misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or
doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI
registers, which must be loaded correctly before the load string instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the LODS instructions.
Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the desti-
nation operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte
loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).
After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the
(E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS
register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.)
The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for
doubleword operations.</hint>
<hint page="0" header="Loop According to ECX Counter" doc_id="x86_64" token="loop">Performs a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64
bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden
using a 67H prefix.
Each time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is
0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If
the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the
instruction at the beginning of the loop.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the IP/EIP/RIP register). This offset is generally specified as a label in assembly code, but at the
machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer.
Offsets of -128 to +127 are allowed with this instruction.
Some forms of the loop instruction (LOOPcc) also accept the ZF flag as a condition for terminating the loop before
the count reaches zero. With these forms of the instruction, a condition code (cc) is associated with each instruction
to indicate the condition being tested for. Here, the LOOPcc instruction itself does not affect the state of the ZF flag;
the ZF flag is changed by other instructions in the loop.</hint>
<hint page="0" header="Loop According to ECX Counter" doc_id="x86_64" token="loopcc">Performs a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64
bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden
using a 67H prefix.
Each time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is
0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If
the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the
instruction at the beginning of the loop.
The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruc-
tion pointer in the IP/EIP/RIP register). This offset is generally specified as a label in assembly code, but at the
machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer.
Offsets of -128 to +127 are allowed with this instruction.
Some forms of the loop instruction (LOOPcc) also accept the ZF flag as a condition for terminating the loop before
the count reaches zero. With these forms of the instruction, a condition code (cc) is associated with each instruction
to indicate the condition being tested for. Here, the LOOPcc instruction itself does not affect the state of the ZF flag;
the ZF flag is changed by other instructions in the loop.</hint>
<hint page="0" header="Load Segment Limit" doc_id="x86_64" token="lsl">Loads the unscrambled segment limit from the segment descriptor specified with the second operand (source
operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source
operand (which can be a register or a memory location) contains the segment selector for the segment descriptor
being accessed. The destination operand is a general-purpose register.
The processor performs access checks as part of the loading process. Once loaded in the destination register, soft-
ware can compare the segment limit with the offset of a pointer.
The segment limit is a 20-bit value contained in bytes 0 and 1 and in the first 4 bits of byte 6 of the segment
descriptor. If the descriptor has a byte granular segment limit (the granularity flag is set to 0), the destination
operand is loaded with a byte granular value (byte limit). If the descriptor has a page granular segment limit (the
granularity flag is set to 1), the LSL instruction will translate the page granular limit (page limit) into a byte limit
before loading it into the destination operand. The translation is performed by shifting the 20-bit "raw" limit left 12
bits and filling the low-order 12 bits with 1s.
When the operand size is 32 bits, the 32-bit byte limit is stored in the destination operand. When the operand size
is 16 bits, a valid 32-bit limit is computed; however, the upper 16 bits are truncated and only the low-order 16 bits
are loaded into the destination operand.
This instruction performs the following checks before it loads the segment limit into the destination register:
.    Checks that the segment selector is not NULL.
.    Checks that the segment selector points to a descriptor that is within the limits of the GDT or LDT being
     accessed
.    Checks that the descriptor type is valid for this instruction. All code and data segment descriptors are valid for
     (can be accessed with) the LSL instruction. The valid special segment and gate descriptor types are given in the
     following table.
.    If the segment is not a conforming code segment, the instruction checks that the specified segment descriptor
     is visible at the CPL (that is, if the CPL and the RPL of the segment selector are less than or equal to the DPL of
     the segment selector).
If the segment descriptor cannot be accessed or is an invalid type for the instruction, the ZF flag is cleared and no
value is loaded in the destination operand.</hint>
<hint page="0" header="Load Task Register" doc_id="x86_64" token="ltr">Loads the source operand into the segment selector field of the task register. The source operand (a general-
purpose register or a memory location) contains a segment selector that points to a task state segment (TSS).
After the segment selector is loaded in the task register, the processor uses the segment selector to locate the
segment descriptor for the TSS in the global descriptor table (GDT). It then loads the segment limit and base
address for the TSS from the segment descriptor into the task register. The task pointed to by the task register is
marked busy, but a switch to the task does not occur.
The LTR instruction is provided for use in operating-system software; it should not be used in application programs.
It can only be executed in protected mode when the CPL is 0. It is commonly used in initialization code to establish
the first task to be executed.
The operand-size attribute has no effect on this instruction.
In 64-bit mode, the operand size is still fixed at 16 bits. The instruction references a 16-byte descriptor to load the
64-bit base.</hint>
<hint page="0" header="Count the Number of Leading Zero Bits" doc_id="x86_64" token="lzcnt">Counts the number of leading most significant zero bits in a source operand (second operand) returning the result
into a destination (first operand).
LZCNT differs from BSR. For example, LZCNT will produce the operand size when the input operand is zero. It
should be noted that on processors that do not support LZCNT, the instruction byte encoding is executed as BSR.
In 64-bit mode 64-bit operand size requires REX.W=1.</hint>
<hint page="0" header="Store Selected Bytes of Double Quadword" doc_id="x86_64" token="maskmovdqu">Stores selected bytes from the source operand (first operand) into an 128-bit memory location. The mask operand
(second operand) selects which bytes from the source operand are written to memory. The source and mask oper-
ands are XMM registers. The memory location specified by the effective address in the DI/EDI/RDI register (the
default segment register is DS, but this may be overridden with a segment-override prefix). The memory location
does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size
attribute.)
The most significant bit in each byte of the mask operand determines whether the corresponding byte in the source
operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.
The MASKMOVDQU instruction generates a non-temporal hint to the processor to minimize cache pollution. The
non-temporal hint is implemented by using a write combining (WC) memory type protocol (see "Caching of
Temporal vs. Non-Temporal Data" in Chapter 10, of the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 1). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing opera-
tion implemented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVDQU
instructions if multiple processors might use different memory types to read/write the destination memory loca-
tions.
Behavior with a mask of all 0s is as follows:
.    No data will be written to memory.
.    Signaling of breakpoints (code or data) is not guaranteed; different processor implementations may signal or
     not signal these breakpoints.
.    Exceptions associated with addressing memory and page faults may still be signaled (implementation
     dependent).
.    If the destination memory region is mapped as UC or WP, enforcement of associated semantics for these
     memory types is not guaranteed (that is, is reserved) and is implementation-specific.
The MASKMOVDQU instruction can be used to improve performance of algorithms that need to merge data on a
byte-by-byte basis. MASKMOVDQU should not cause a read for ownership; doing so generates unnecessary band-
width since data is to be written directly using the byte-mask without allocating old data prior to the store.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
If VMASKMOVDQU is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will
cause an #UD exception.</hint>
<hint page="0" header="Store Selected Bytes of Quadword" doc_id="x86_64" token="maskmovq">Stores selected bytes from the source operand (first operand) into a 64-bit memory location. The mask operand
(second operand) selects which bytes from the source operand are written to memory. The source and mask oper-
ands are MMX technology registers. The memory location specified by the effective address in the DI/EDI/RDI
register (the default segment register is DS, but this may be overridden with a segment-override prefix). The
memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the
address-size attribute.)
The most significant bit in each byte of the mask operand determines whether the corresponding byte in the source
operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.
The MASKMOVQ instruction generates a non-temporal hint to the processor to minimize cache pollution. The non-
temporal hint is implemented by using a write combining (WC) memory type protocol (see "Caching of Temporal
vs. Non-Temporal Data" in Chapter 10, of the Intel 64 and IA-32 Architectures Software Developer's Manual,
Volume 1). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation imple-
mented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVQ instructions if
multiple processors might use different memory types to read/write the destination memory locations.
This instruction causes a transition from x87 FPU to MMX technology state (that is, the x87 FPU top-of-stack pointer
is set to 0 and the x87 FPU tag word is set to all 0s [valid]).
The behavior of the MASKMOVQ instruction with a mask of all 0s is as follows:
.    No data will be written to memory.
.    Transition from x87 FPU to MMX technology state will occur.
.    Exceptions associated with addressing memory and page faults may still be signaled (implementation
     dependent).
.    Signaling of breakpoints (code or data) is not guaranteed (implementation dependent).
.    If the destination memory region is mapped as UC or WP, enforcement of associated semantics for these
     memory types is not guaranteed (that is, is reserved) and is implementation-specific.
The MASKMOVQ instruction can be used to improve performance for algorithms that need to merge data on a byte-
by-byte basis. It should not cause a read for ownership; doing so generates unnecessary bandwidth since data is
to be written directly using the byte-mask without allocating old data prior to the store.
In 64-bit mode, the memory address is specified by DS:RDI.</hint>
<hint page="0" header="Maximum of Packed Double-Precision Floating-Point Values" doc_id="x86_64" token="maxpd">Performs a SIMD compare of the packed double-precision floating-point values in the first source operand and the
second source operand and returns the maximum value for each pair of values to the destination operand.
If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is
returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that
is, a QNaN version of the SNaN is not returned).
If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN
or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source
operand (from either the first or second operand) be returned, the action of MAXPD can be emulated using a
sequence of instructions, such as a comparison followed by AND, ANDN and OR.
EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second
source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally
updated with writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256)
of the corresponding ZMM register destination are zeroed.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.</hint>
<hint page="0" header="Maximum of Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="maxps">Performs a SIMD compare of the packed single-precision floating-point values in the first source operand and the
second source operand and returns the maximum value for each pair of values to the destination operand.
If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is
returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that
is, a QNaN version of the SNaN is not returned).
If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN
or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source
operand (from either the first or second operand) be returned, the action of MAXPS can be emulated using a
sequence of instructions, such as, a comparison followed by AND, ANDN and OR.
EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second
source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally
updated with writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256)
of the corresponding ZMM register destination are zeroed.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified.</hint>
<hint page="0" header="Return Maximum Scalar Double-Precision Floating-Point Value" doc_id="x86_64" token="maxsd">Compares the low double-precision floating-point values in the first source operand and the second source
operand, and returns the maximum value to the low quadword of the destination operand. The second source
operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM
registers. When the second source operand is a memory operand, only 64 bits are accessed.
If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If
a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a
QNaN version of the SNaN is not returned).
If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid
floating-point value, is written to the result. If instead of this behavior, it is required that the NaN of either source
operand be returned, the action of MAXSD can be emulated using a sequence of instructions, such as, a comparison
followed by AND, ANDN and OR.
128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAX_VL-1:64) of the
corresponding destination register remain unchanged.
VEX.128 and EVEX encoded version: Bits (127:64) of the XMM register destination are copied from corresponding
bits in the first source operand. Bits (MAX_VL-1:128) of the destination register are zeroed.
EVEX encoded version: The low quadword element of the destination operand is updated according to the
writemask.
Software should ensure VMAXSD is encoded with VEX.L=0. Encoding VMAXSD with VEX.L=1 may encounter unpre-
dictable behavior across different processor generations.</hint>
<hint page="0" header="Return Maximum Scalar Single-Precision Floating-Point Value" doc_id="x86_64" token="maxss">Compares the low single-precision floating-point values in the first source operand and the second source operand,
and returns the maximum value to the low doubleword of the destination operand.
If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If
a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a
QNaN version of the SNaN is not returned).
If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid
floating-point value, is written to the result. If instead of this behavior, it is required that the NaN from either source
operand be returned, the action of MAXSS can be emulated using a sequence of instructions, such as, a comparison
followed by AND, ANDN and OR.
The second source operand can be an XMM register or a 32-bit memory location. The first source and destination
operands are XMM registers.
128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAX_VL:32) of the corre-
sponding destination register remain unchanged.
VEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by VEX.vvvv. Bits
(127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits
(MAX_VL:128) of the destination register are zeroed.
EVEX encoded version: The low doubleword element of the destination operand is updated according to the
writemask.
Software should ensure VMAXSS is encoded with VEX.L=0. Encoding VMAXSS with VEX.L=1 may encounter unpre-
dictable behavior across different processor generations.</hint>
<hint page="0" header="Memory Fence" doc_id="x86_64" token="mfence">Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior
the MFENCE instruction. This serializing operation guarantees that every load and store instruction that precedes
the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows
the MFENCE instruction.1 The MFENCE instruction is ordered with respect to all load and store instructions, other
MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID
instruction). MFENCE does not serialize the instruction stream.
Weakly ordered memory types can be used to achieve higher processor performance through such techniques as
out-of-order issue, speculative reads, write-combining, and write-collapsing. The degree to which a consumer of
data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the
producer of this data. The MFENCE instruction provides a performance-efficient way of ensuring load and store
ordering between routines that produce weakly-ordered results and routines that consume that data.
Processors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and
WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution. Thus, it
is not ordered with respect to executions of the MFENCE instruction; data can be brought into the caches specula-
tively just before, during, or after the execution of an MFENCE instruction.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.
Specification of the instruction's opcode above indicates a ModR/M byte of F0. For this instruction, the processor
ignores the r/m field of the ModR/M byte. Thus, MFENCE is encoded by any opcode of the form 0F AE Fx, where x
is in the range 0-7.</hint>
<hint page="0" header="Minimum of Packed Double-Precision Floating-Point Values" doc_id="x86_64" token="minpd">Performs a SIMD compare of the packed double-precision floating-point values in the first source operand and the
second source operand and returns the minimum value for each pair of values to the destination operand.
If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is
returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that
is, a QNaN version of the SNaN is not returned).
If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN
or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source
operand (from either the first or second operand) be returned, the action of MINPD can be emulated using a
sequence of instructions, such as, a comparison followed by AND, ANDN and OR.
EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second
source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally
updated with writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256)
of the corresponding ZMM register destination are zeroed.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified.</hint>
<hint page="0" header="Minimum of Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="minps">Performs a SIMD compare of the packed single-precision floating-point values in the first source operand and the
second source operand and returns the minimum value for each pair of values to the destination operand.
If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is
returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that
is, a QNaN version of the SNaN is not returned).
If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN
or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source
operand (from either the first or second operand) be returned, the action of MINPS can be emulated using a
sequence of instructions, such as, a comparison followed by AND, ANDN and OR.
EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second
source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally
updated with writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256)
of the corresponding ZMM register destination are zeroed.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified.</hint>
<hint page="0" header="Return Minimum Scalar Double-Precision Floating-Point Value" doc_id="x86_64" token="minsd">Compares the low double-precision floating-point values in the first source operand and the second source
operand, and returns the minimum value to the low quadword of the destination operand. When the source
operand is a memory operand, only the 64 bits are accessed.
If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If
a value in the second source operand is an SNaN, then SNaN is returned unchanged to the destination (that is, a
QNaN version of the SNaN is not returned).
If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid
floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand
(from either the first or second source) be returned, the action of MINSD can be emulated using a sequence of
instructions, such as, a comparison followed by AND, ANDN and OR.
The second source operand can be an XMM register or a 64-bit memory location. The first source and destination
operands are XMM registers.
128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAX_VL-1:64) of the
corresponding destination register remain unchanged.
VEX.128 and EVEX encoded version: Bits (127:64) of the XMM register destination are copied from corresponding
bits in the first source operand. Bits (MAX_VL-1:128) of the destination register are zeroed.
EVEX encoded version: The low quadword element of the destination operand is updated according to the
writemask.
Software should ensure VMINSD is encoded with VEX.L=0. Encoding VMINSD with VEX.L=1 may encounter unpre-
dictable behavior across different processor generations.</hint>
<hint page="0" header="Return Minimum Scalar Single-Precision Floating-Point Value" doc_id="x86_64" token="minss">Compares the low single-precision floating-point values in the first source operand and the second source operand
and returns the minimum value to the low doubleword of the destination operand.
If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If
a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN
version of the SNaN is not returned).
If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid
floating-point value, is written to the result. If instead of this behavior, it is required that the NaN in either source
operand be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison
followed by AND, ANDN and OR.
The second source operand can be an XMM register or a 32-bit memory location. The first source and destination
operands are XMM registers.
128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAX_VL:32) of the corre-
sponding destination register remain unchanged.
VEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by (E)VEX.vvvv. Bits
(127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits
(MAX_VL-1:128) of the destination register are zeroed.
EVEX encoded version: The low doubleword element of the destination operand is updated according to the
writemask.
Software should ensure VMINSS is encoded with VEX.L=0. Encoding VMINSS with VEX.L=1 may encounter unpre-
dictable behavior across different processor generations.</hint>
<hint page="0" header="Set Up Monitor Address" doc_id="x86_64" token="monitor">The MONITOR instruction arms address monitoring hardware using an address specified in EAX (the address range
that the monitoring hardware checks for store operations can be determined by using CPUID). A store to an
address within the specified address range triggers the monitoring hardware. The state of monitor hardware is
used by MWAIT.
The content of EAX is an effective address (in 64-bit mode, RAX is used). By default, the DS segment is used to
create a linear address that is monitored. Segment overrides can be used.
ECX and EDX are also used. They communicate other information to MONITOR. ECX specifies optional extensions.
EDX specifies optional hints; it does not change the architectural behavior of the instruction. For the Pentium 4
processor (family 15, model 3), no extensions or hints are defined. Undefined hints in EDX are ignored by the
processor; undefined extensions in ECX raises a general protection fault.
The address range must use memory of the write-back type. Only write-back memory will correctly trigger the
monitoring hardware. Additional information on determining what address range to use in order to prevent false
wake-ups is described in Chapter 8, "Multiple-Processor Management" of the Intel 64 and IA-32 Architectures
Software Developer's Manual, Volume 3A.
The MONITOR instruction is ordered as a load operation with respect to other memory transactions. The instruction
is subject to the permission checking and faults associated with a byte load. Like a load, MONITOR sets the A-bit
but not the D-bit in page tables.
CPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT in the processor. When set,
MONITOR may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode
exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE
MSR; disabling MONITOR clears the CPUID feature flag and causes execution to generate an invalid-opcode excep-
tion.
The instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Move" doc_id="x86_64" token="mov">Copies the second operand (source operand) to the first operand (destination operand). The source operand can be
an immediate value, general-purpose register, segment register, or memory location; the destination register can
be a general-purpose register, segment register, or memory location. Both operands must be the same size, which
can be a byte, a word, a doubleword, or a quadword.
The MOV instruction cannot be used to load the CS register. Attempting to do so results in an invalid opcode excep-
tion (#UD). To load the CS register, use the far JMP, CALL, or RET instruction.
If the destination operand is a segment register (DS, ES, FS, GS, or SS), the source operand must be a valid
segment selector. In protected mode, moving a segment selector into a segment register automatically causes the
segment descriptor information associated with that segment selector to be loaded into the hidden (shadow) part
of the segment register. While loading this information, the segment selector and segment descriptor information
is validated (see the "Operation" algorithm below). The segment descriptor data is obtained from the GDT or LDT
entry for the specified segment selector.
A NULL segment selector (values 0000-0003) can be loaded into the DS, ES, FS, and GS registers without causing
a protection exception. However, any subsequent attempt to reference a segment whose corresponding segment
register is loaded with a NULL value causes a general protection exception (#GP) and no memory reference occurs.
Loading the SS register with a MOV instruction inhibits all interrupts until after the execution of the next instruc-
tion. This operation allows a stack pointer to be loaded into the ESP register with the next instruction (MOV ESP,
stack-pointer value) before an interrupt occurs1. Be aware that the LSS instruction offers a more efficient
method of loading the SS and ESP registers.
When executing MOV Reg, Sreg, the processor copies the content of Sreg to the 16 least significant bits of the
general-purpose register. The upper bits of the destination register are zero for most IA-32 processors (Pentium</hint>
<hint page="0" header="Move to/from Control Registers" doc_id="x86_64" token="mov">Moves the contents of a control register (CR0, CR2, CR3, CR4, or CR8) to a general-purpose register or the
contents of a general purpose register to a control register. The operand size for these instructions is always 32 bits
in non-64-bit modes, regardless of the operand-size attribute. (See "Control Registers" in Chapter 2 of the Intel
64 and IA-32 Architectures Software Developer's Manual, Volume 3A, for a detailed description of the flags and
fields in the control registers.) This instruction can be executed only when the current privilege level is 0.
At the opcode level, the reg field within the ModR/M byte specifies which of the control registers is loaded or read.
The 2 bits in the mod field are ignored. The r/m field specifies the general-purpose register loaded or read.
Attempts to reference CR1, CR5, CR6, CR7, and CR9-CR15 result in undefined opcode (#UD) exceptions.
When loading control registers, programs should not attempt to change the reserved bits; that is, always set
reserved bits to the value previously read. An attempt to change CR4's reserved bits will cause a general protection
fault. Reserved bits in CR0 and CR3 remain clear after any load of those registers; attempts to set them have no
impact. On Pentium 4, Intel Xeon and P6 family processors, CR0.ET remains set after any load of CR0; attempts to
clear this bit have no impact.
In certain cases, these instructions have the side effect of invalidating entries in the TLBs and the paging-structure
caches. See Section 4.10.4.1, "Operations that Invalidate TLBs and Paging-Structure Caches," in the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 3A for details.
The following side effects are implementation-specific for the Pentium 4, Intel Xeon, and P6 processor family: when
modifying PE or PG in register CR0, or PSE or PAE in register CR4, all TLB entries are flushed, including global
entries. Software should not depend on this functionality in all Intel 64 or IA-32 processors.
In 64-bit mode, the instruction's default operation size is 64 bits. The REX.R prefix must be used to access CR8. Use
of REX.B permits access to additional registers (R8-R15). Use of the REX.W prefix or 66H prefix is ignored. Use of</hint>
<hint page="0" header="Move to/from Debug Registers" doc_id="x86_64" token="mov">Moves the contents of a debug register (DR0, DR1, DR2, DR3, DR4, DR5, DR6, or DR7) to a general-purpose
register or vice versa. The operand size for these instructions is always 32 bits in non-64-bit modes, regardless of
the operand-size attribute. (See Section 17.2, "Debug Registers", of the Intel 64 and IA-32 Architectures Soft-
ware Developer's Manual, Volume 3A, for a detailed description of the flags and fields in the debug registers.)
The instructions must be executed at privilege level 0 or in real-address mode.
When the debug extension (DE) flag in register CR4 is clear, these instructions operate on debug registers in a
manner that is compatible with Intel386 and Intel486 processors. In this mode, references to DR4 and DR5 refer
to DR6 and DR7, respectively. When the DE flag in CR4 is set, attempts to reference DR4 and DR5 result in an
undefined opcode (#UD) exception. (The CR4 register was added to the IA-32 Architecture beginning with the
Pentium processor.)
At the opcode level, the reg field within the ModR/M byte specifies which of the debug registers is loaded or read.
The two bits in the mod field are ignored. The r/m field specifies the general-purpose register loaded or read.
In 64-bit mode, the instruction's default operation size is 64 bits. Use of the REX.B prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W or 66H prefix is ignored. Use of the REX.R prefix causes an invalid-
opcode exception. See the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Move Aligned Packed Double-Precision Floating-Point Values" doc_id="x86_64" token="movapd"></hint>
<hint page="0" header="Move Aligned Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="movaps">Moves 4, 8 or 16 single-precision floating-point values from the source operand (second operand) to the destina-
tion operand (first operand). This instruction can be used to load an XMM, YMM or ZMM register from an 128-bit,
256-bit or 512-bit memory location, to store the contents of an XMM, YMM or ZMM register into a 128-bit, 256-bit
or 512-bit memory location, or to move data between two XMM, two YMM or two ZMM registers.
When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit
version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary or a general-
protection exception (#GP) will be generated. For EVEX.512 encoded versions, the operand must be aligned to the
size of the memory operand. To move single-precision floating-point values to and from unaligned memory loca-
tions, use the VMOVUPS instruction.</hint>
<hint page="0" header="Move Data After Swapping Bytes" doc_id="x86_64" token="movbe">Performs a byte swap operation on the data copied from the second operand (source operand) and store the result
in the first operand (destination operand). The source operand can be a general-purpose register, or memory loca-
tion; the destination register can be a general-purpose register, or a memory location; however, both operands can
not be registers, and only one operand can be a memory location. Both operands must be the same size, which can
be a word, a doubleword or quadword.
The MOVBE instruction is provided for swapping the bytes on a read from memory or on a write to memory; thus
providing support for converting little-endian values to big-endian format and vice versa.
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Move Doubleword/Move Quadword" doc_id="x86_64" token="movd">Copies a doubleword from the source operand (second operand) to the destination operand (first operand). The
source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or
32-bit memory locations. This instruction can be used to move a doubleword to and from the low doubleword of an
MMX technology register and a general-purpose register or a 32-bit memory location, or to and from the low
doubleword of an XMM register and a general-purpose register or a 32-bit memory location. The instruction cannot
be used to transfer data between MMX technology registers, between XMM registers, between general-purpose
registers, or between memory locations.
When the destination operand is an MMX technology register, the source operand is written to the low doubleword
of the register, and the register is zero-extended to 64 bits. When the destination operand is an XMM register, the
source operand is written to the low doubleword of the register, and the register is zero-extended to 128 bits.
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.
MOVD/Q with XMM destination:
Moves a dword/qword integer from the source operand and stores it in the low 32/64-bits of the destination XMM
register. The upper bits of the destination are zeroed. The source operand can be a 32/64-bit register or 32/64-bit
memory location.
128-bit Legacy SSE version: Bits (MAX_VL-1:128) of the corresponding YMM destination register remain
unchanged. Qword operation requires the use of REX.W=1.
VEX.128 encoded version: Bits (MAX_VL-1:128) of the destination register are zeroed. Qword operation requires
the use of VEX.W=1.
EVEX.128 encoded version: Bits (MAX_VL-1:128) of the destination register are zeroed. Qword operation requires
the use of EVEX.W=1.</hint>
<hint page="0" header="Move Doubleword/Move Quadword" doc_id="x86_64" token="movq">Copies a doubleword from the source operand (second operand) to the destination operand (first operand). The
source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or
32-bit memory locations. This instruction can be used to move a doubleword to and from the low doubleword of an
MMX technology register and a general-purpose register or a 32-bit memory location, or to and from the low
doubleword of an XMM register and a general-purpose register or a 32-bit memory location. The instruction cannot
be used to transfer data between MMX technology registers, between XMM registers, between general-purpose
registers, or between memory locations.
When the destination operand is an MMX technology register, the source operand is written to the low doubleword
of the register, and the register is zero-extended to 64 bits. When the destination operand is an XMM register, the
source operand is written to the low doubleword of the register, and the register is zero-extended to 128 bits.
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.
MOVD/Q with XMM destination:
Moves a dword/qword integer from the source operand and stores it in the low 32/64-bits of the destination XMM
register. The upper bits of the destination are zeroed. The source operand can be a 32/64-bit register or 32/64-bit
memory location.
128-bit Legacy SSE version: Bits (MAX_VL-1:128) of the corresponding YMM destination register remain
unchanged. Qword operation requires the use of REX.W=1.
VEX.128 encoded version: Bits (MAX_VL-1:128) of the destination register are zeroed. Qword operation requires
the use of VEX.W=1.
EVEX.128 encoded version: Bits (MAX_VL-1:128) of the destination register are zeroed. Qword operation requires
the use of EVEX.W=1.</hint>
<hint page="0" header="Replicate Double FP Values" doc_id="x86_64" token="movddup">For 256-bit or higher versions: Duplicates even-indexed double-precision floating-point values from the source
operand (the second operand) and into adjacent pair and store to the destination operand (the first operand).
For 128-bit versions: Duplicates the low double-precision floating-point value from the source operand (the second
operand) and store to the destination operand (the first operand).
128-bit Legacy SSE version: Bits (MAX_VL-1:128) of the corresponding destination register are unchanged. The
source operand is XMM register or a 64-bit memory location.
VEX.128 and EVEX.128 encoded version: Bits (MAX_VL-1:128) of the destination register are zeroed. The source
operand is XMM register or a 64-bit memory location. The destination is updated conditionally under the writemask
for EVEX version.
VEX.256 and EVEX.256 encoded version: Bits (MAX_VL-1:256) of the destination register are zeroed. The source
operand is YMM register or a 256-bit memory location. The destination is updated conditionally under the
writemask for EVEX version.
EVEX.512 encoded version: The destination is updated according to the writemask. The source operand is ZMM
register or a 512-bit memory location.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Move Aligned Packed Integer Values" doc_id="x86_64" token="movdqa">Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
EVEX encoded versions:
Moves 128, 256 or 512 bits of packed doubleword/quadword integer values from the source operand (the second
operand) to the destination operand (the first operand). This instruction can be used to load a vector register from
an int32/int64 memory location, to store the contents of a vector register into an int32/int64 memory location, or
to move data between two ZMM registers. When the source or destination operand is a memory operand, the
operand must be aligned on a 16 (EVEX.128)/32(EVEX.256)/64(EVEX.512)-byte boundary or a general-protection
exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the
VMOVDQU instruction.
The destination operand is updated at 32-bit (VMOVDQA32) or 64-bit (VMOVDQA64) granularity according to the
writemask.
VEX.256 encoded version:
Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand
(first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the
contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.
When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary
or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory
locations, use the VMOVDQU instruction. Bits (MAX_VL-1:256) of the destination register are zeroed.
128-bit versions:
Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand
(first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the
contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.
When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary
or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory
locations, use the VMOVDQU instruction.
128-bit Legacy SSE version: Bits (MAX_VL-1:128) of the corresponding ZMM destination register remain
unchanged.
VEX.128 encoded version: Bits (MAX_VL-1:128) of the destination register are zeroed.</hint>
<hint page="0" header="Move Aligned Packed Integer Values" doc_id="x86_64" token="vmovdqa">Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
EVEX encoded versions:
Moves 128, 256 or 512 bits of packed doubleword/quadword integer values from the source operand (the second
operand) to the destination operand (the first operand). This instruction can be used to load a vector register from
an int32/int64 memory location, to store the contents of a vector register into an int32/int64 memory location, or
to move data between two ZMM registers. When the source or destination operand is a memory operand, the
operand must be aligned on a 16 (EVEX.128)/32(EVEX.256)/64(EVEX.512)-byte boundary or a general-protection
exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the
VMOVDQU instruction.
The destination operand is updated at 32-bit (VMOVDQA32) or 64-bit (VMOVDQA64) granularity according to the
writemask.
VEX.256 encoded version:
Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand
(first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the
contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.
When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary
or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory
locations, use the VMOVDQU instruction. Bits (MAX_VL-1:256) of the destination register are zeroed.
128-bit versions:
Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand
(first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the
contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.
When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary
or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory
locations, use the VMOVDQU instruction.
128-bit Legacy SSE version: Bits (MAX_VL-1:128) of the corresponding ZMM destination register remain
unchanged.
VEX.128 encoded version: Bits (MAX_VL-1:128) of the destination register are zeroed.</hint>
<hint page="0" header="Move Aligned Packed Integer Values" doc_id="x86_64" token="vmovdqa32">Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
EVEX encoded versions:
Moves 128, 256 or 512 bits of packed doubleword/quadword integer values from the source operand (the second
operand) to the destination operand (the first operand). This instruction can be used to load a vector register from
an int32/int64 memory location, to store the contents of a vector register into an int32/int64 memory location, or
to move data between two ZMM registers. When the source or destination operand is a memory operand, the
operand must be aligned on a 16 (EVEX.128)/32(EVEX.256)/64(EVEX.512)-byte boundary or a general-protection
exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the
VMOVDQU instruction.
The destination operand is updated at 32-bit (VMOVDQA32) or 64-bit (VMOVDQA64) granularity according to the
writemask.
VEX.256 encoded version:
Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand
(first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the
contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.
When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary
or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory
locations, use the VMOVDQU instruction. Bits (MAX_VL-1:256) of the destination register are zeroed.
128-bit versions:
Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand
(first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the
contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.
When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary
or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory
locations, use the VMOVDQU instruction.
128-bit Legacy SSE version: Bits (MAX_VL-1:128) of the corresponding ZMM destination register remain
unchanged.
VEX.128 encoded version: Bits (MAX_VL-1:128) of the destination register are zeroed.</hint>
<hint page="0" header="Move Aligned Packed Integer Values" doc_id="x86_64" token="vmovdqa64">Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
EVEX encoded versions:
Moves 128, 256 or 512 bits of packed doubleword/quadword integer values from the source operand (the second
operand) to the destination operand (the first operand). This instruction can be used to load a vector register from
an int32/int64 memory location, to store the contents of a vector register into an int32/int64 memory location, or
to move data between two ZMM registers. When the source or destination operand is a memory operand, the
operand must be aligned on a 16 (EVEX.128)/32(EVEX.256)/64(EVEX.512)-byte boundary or a general-protection
exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the
VMOVDQU instruction.
The destination operand is updated at 32-bit (VMOVDQA32) or 64-bit (VMOVDQA64) granularity according to the
writemask.
VEX.256 encoded version:
Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand
(first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the
contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.
When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary
or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory
locations, use the VMOVDQU instruction. Bits (MAX_VL-1:256) of the destination register are zeroed.
128-bit versions:
Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand
(first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the
contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.
When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary
or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory
locations, use the VMOVDQU instruction.
128-bit Legacy SSE version: Bits (MAX_VL-1:128) of the corresponding ZMM destination register remain
unchanged.
VEX.128 encoded version: Bits (MAX_VL-1:128) of the destination register are zeroed.</hint>
<hint page="0" header="Move Unaligned Packed Integer Values" doc_id="x86_64" token="movdqu">Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
EVEX encoded versions:
Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand
(the second operand) to the destination operand (first operand). This instruction can be used to load a vector
register from a memory location, to store the contents of a vector register into a memory location, or to move data
between two vector registers.</hint>
<hint page="0" header="Move Unaligned Packed Integer Values" doc_id="x86_64" token="vmovdqu">Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
EVEX encoded versions:
Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand
(the second operand) to the destination operand (first operand). This instruction can be used to load a vector
register from a memory location, to store the contents of a vector register into a memory location, or to move data
between two vector registers.</hint>
<hint page="0" header="Move Unaligned Packed Integer Values" doc_id="x86_64" token="vmovdqu8">Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
EVEX encoded versions:
Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand
(the second operand) to the destination operand (first operand). This instruction can be used to load a vector
register from a memory location, to store the contents of a vector register into a memory location, or to move data
between two vector registers.</hint>
<hint page="0" header="Move Unaligned Packed Integer Values" doc_id="x86_64" token="vmovdqu16">Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
EVEX encoded versions:
Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand
(the second operand) to the destination operand (first operand). This instruction can be used to load a vector
register from a memory location, to store the contents of a vector register into a memory location, or to move data
between two vector registers.</hint>
<hint page="0" header="Move Unaligned Packed Integer Values" doc_id="x86_64" token="vmovdqu32">Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
EVEX encoded versions:
Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand
(the second operand) to the destination operand (first operand). This instruction can be used to load a vector
register from a memory location, to store the contents of a vector register into a memory location, or to move data
between two vector registers.</hint>
<hint page="0" header="Move Unaligned Packed Integer Values" doc_id="x86_64" token="vmovdqu64">Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
EVEX encoded versions:
Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand
(the second operand) to the destination operand (first operand). This instruction can be used to load a vector
register from a memory location, to store the contents of a vector register into a memory location, or to move data
between two vector registers.</hint>
<hint page="0" header="Move Quadword from XMM to MMX Technology Register" doc_id="x86_64" token="movdq2q">Moves the low quadword from the source operand (second operand) to the destination operand (first operand).
The source operand is an XMM register and the destination operand is an MMX technology register.
This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
floating-point exception is pending, the exception is handled before the MOVDQ2Q instruction is executed.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Move Packed Single-Precision Floating-Point Values High to Low" doc_id="x86_64" token="movhlps">This instruction cannot be used for memory to register moves.
128-bit two-argument form:
Moves two packed single-precision floating-point values from the high quadword of the second XMM argument
(second operand) to the low quadword of the first XMM register (first argument). The quadword at bits 127:64 of
the destination operand is left unchanged. Bits (MAX_VL-1:128) of the corresponding destination register remain
unchanged.
128-bit and EVEX three-argument form
Moves two packed single-precision floating-point values from the high quadword of the third XMM argument (third
operand) to the low quadword of the destination (first operand). Copies the high quadword from the second XMM
argument (second operand) to the high quadword of the destination (first operand). Bits (MAX_VL-1:128) of the
corresponding destination register are zeroed.
If VMOVHLPS is encoded with VEX.L or EVEX.L'L= 1, an attempt to execute the instruction encoded with VEX.L or
EVEX.L'L= 1 will cause an #UD exception.</hint>
<hint page="0" header="Move High Packed Double-Precision Floating-Point Value" doc_id="x86_64" token="movhpd">This instruction cannot be used for register to register or memory to memory moves.
128-bit Legacy SSE load:
Moves a double-precision floating-point value from the source 64-bit memory operand and stores it in the high 64-
bits of the destination XMM register. The lower 64bits of the XMM register are preserved. Bits (MAX_VL-1:128) of
the corresponding destination register are preserved.
VEX.128 &amp; EVEX encoded load:
Loads a double-precision floating-point value from the source 64-bit memory operand (the third operand) and
stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from the first source
operand (second operand) are copied to the low 64-bits of the destination. Bits (MAX_VL-1:128) of the corre-
sponding destination register are zeroed.
128-bit store:
Stores a double-precision floating-point value from the high 64-bits of the XMM register source (second operand)
to the 64-bit memory location (first operand).
Note: VMOVHPD (store) (VEX.128.66.0F 17 /r) is legal and has the same behavior as the existing 66 0F 17 store.
For VMOVHPD (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.
If VMOVHPD is encoded with VEX.L or EVEX.L'L= 1, an attempt to execute the instruction encoded with VEX.L or
EVEX.L'L= 1 will cause an #UD exception.</hint>
<hint page="0" header="Move High Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="movhps">This instruction cannot be used for register to register or memory to memory moves.
128-bit Legacy SSE load:
Moves two packed single-precision floating-point values from the source 64-bit memory operand and stores them
in the high 64-bits of the destination XMM register. The lower 64bits of the XMM register are preserved. Bits
(MAX_VL-1:128) of the corresponding destination register are preserved.
VEX.128 &amp; EVEX encoded load:
Loads two single-precision floating-point values from the source 64-bit memory operand (the third operand) and
stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from the first source
operand (the second operand) are copied to the lower 64-bits of the destination. Bits (MAX_VL-1:128) of the corre-
sponding destination register are zeroed.
128-bit store:
Stores two packed single-precision floating-point values from the high 64-bits of the XMM register source (second
operand) to the 64-bit memory location (first operand).
Note: VMOVHPS (store) (VEX.NDS.128.0F 17 /r) is legal and has the same behavior as the existing 0F 17 store.
For VMOVHPS (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.
If VMOVHPS is encoded with VEX.L or EVEX.L'L= 1, an attempt to execute the instruction encoded with VEX.L or
EVEX.L'L= 1 will cause an #UD exception.</hint>
<hint page="0" header="Move Packed Single-Precision Floating-Point Values Low to High" doc_id="x86_64" token="movlhps">This instruction cannot be used for memory to register moves.
128-bit two-argument form:
Moves two packed single-precision floating-point values from the low quadword of the second XMM argument
(second operand) to the high quadword of the first XMM register (first argument). The low quadword of the desti-
nation operand is left unchanged. Bits (MAX_VL-1:128) of the corresponding destination register are unmodified.
128-bit three-argument forms:
Moves two packed single-precision floating-point values from the low quadword of the third XMM argument (third
operand) to the high quadword of the destination (first operand). Copies the low quadword from the second XMM
argument (second operand) to the low quadword of the destination (first operand). Bits (MAX_VL-1:128) of the
corresponding destination register are zeroed.
If VMOVLHPS is encoded with VEX.L or EVEX.L'L= 1, an attempt to execute the instruction encoded with VEX.L or
EVEX.L'L= 1 will cause an #UD exception.</hint>
<hint page="0" header="Move Low Packed Double-Precision Floating-Point Value" doc_id="x86_64" token="movlpd">This instruction cannot be used for register to register or memory to memory moves.
128-bit Legacy SSE load:
Moves a double-precision floating-point value from the source 64-bit memory operand and stores it in the low 64-
bits of the destination XMM register. The upper 64bits of the XMM register are preserved. Bits (MAX_VL-1:128) of
the corresponding destination register are preserved.
VEX.128 &amp; EVEX encoded load:
Loads a double-precision floating-point value from the source 64-bit memory operand (third operand), merges it
with the upper 64-bits of the first source XMM register (second operand), and stores it in the low 128-bits of the
destination XMM register (first operand). Bits (MAX_VL-1:128) of the corresponding destination register are
zeroed.
128-bit store:
Stores a double-precision floating-point value from the low 64-bits of the XMM register source (second operand) to
the 64-bit memory location (first operand).
Note: VMOVLPD (store) (VEX.128.66.0F 13 /r) is legal and has the same behavior as the existing 66 0F 13 store.
For VMOVLPD (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.
If VMOVLPD is encoded with VEX.L or EVEX.L'L= 1, an attempt to execute the instruction encoded with VEX.L or
EVEX.L'L= 1 will cause an #UD exception.</hint>
<hint page="0" header="Move Low Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="movlps">This instruction cannot be used for register to register or memory to memory moves.
128-bit Legacy SSE load:
Moves two packed single-precision floating-point values from the source 64-bit memory operand and stores them
in the low 64-bits of the destination XMM register. The upper 64bits of the XMM register are preserved. Bits
(MAX_VL-1:128) of the corresponding destination register are preserved.
VEX.128 &amp; EVEX encoded load:
Loads two packed single-precision floating-point values from the source 64-bit memory operand (the third
operand), merges them with the upper 64-bits of the first source operand (the second operand), and stores them
in the low 128-bits of the destination register (the first operand). Bits (MAX_VL-1:128) of the corresponding desti-
nation register are zeroed.
128-bit store:
Loads two packed single-precision floating-point values from the low 64-bits of the XMM register source (second
operand) to the 64-bit memory location (first operand).
Note: VMOVLPS (store) (VEX.128.0F 13 /r) is legal and has the same behavior as the existing 0F 13 store. For
VMOVLPS (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.</hint>
<hint page="0" header="Extract Packed Double-Precision Floating-Point Sign Mask" doc_id="x86_64" token="movmskpd">Extracts the sign bits from the packed double-precision floating-point values in the source operand (second
operand), formats them into a 2-bit mask, and stores the mask in the destination operand (first operand). The
source operand is an XMM register, and the destination operand is a general-purpose register. The mask is stored
in the 2 low-order bits of the destination operand. Zero-extend the upper bits of the destination.
In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R
prefix. The default operand size is 64-bit in 64-bit mode.
128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.
VEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose
register.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Extract Packed Single-Precision Floating-Point Sign Mask" doc_id="x86_64" token="movmskps">Extracts the sign bits from the packed single-precision floating-point values in the source operand (second
operand), formats them into a 4- or 8-bit mask, and stores the mask in the destination operand (first operand).
The source operand is an XMM or YMM register, and the destination operand is a general-purpose register. The
mask is stored in the 4 or 8 low-order bits of the destination operand. The upper bits of the destination operand
beyond the mask are filled with zeros.
In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R
prefix. The default operand size is 64-bit in 64-bit mode.
128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.
VEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose
register.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Load Double Quadword Non-Temporal Aligned Hint" doc_id="x86_64" token="movntdqa">MOVNTDQA loads a double quadword from the source operand (second operand) to the destination operand (first
operand) using a non-temporal hint if the memory source is WC (write combining) memory type. For WC memory
type, the nontemporal hint may be implemented by loading a temporary internal buffer with the equivalent of an
aligned cache line without filling this data to the cache. Any memory-type aliased lines in the cache will be snooped
and flushed. Subsequent MOVNTDQA reads to unread portions of the WC cache line will receive data from the
temporary internal buffer if data is available. The temporary internal buffer may be flushed by the processor at any
time for any reason, for example:
. A load operation other than a MOVNTDQA which references memory already resident in a temporary internal
buffer.
. A non-WC reference to memory already resident in a temporary internal buffer.
. Interleaving of reads and writes to a single temporary internal buffer.
. Repeated (V)MOVNTDQA loads of a particular 16-byte item in a streaming line.
. Certain micro-architectural conditions including resource shortages, detection of
a mis-speculation condition, and various fault conditions
The non-temporal hint is implemented by using a write combining (WC) memory type protocol when reading the
data from memory. Using this protocol, the processor
does not read the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into
the cache hierarchy. The memory type of the region being read can override the non-temporal hint, if the memory
address specified for the non-temporal read is not a WC memory region. Information on non-temporal reads and
writes can be found in "Caching of Temporal vs. Non-Temporal Data" in Chapter 10 in the Intel 64 and IA-32
Architecture Software Developer's Manual, Volume 3A.
Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with
a MFENCE instruction should be used in conjunction with MOVNTDQA instructions if multiple processors might use
different memory types for the referenced memory locations or to synchronize reads of a processor with writes by
other agents in the system. A processor's implementation of the streaming load hint does not override the effective
memory type, but the implementation of the hint is processor dependent. For example, a processor implementa-</hint>
<hint page="0" header="Store Packed Integers Using Non-Temporal Hint" doc_id="x86_64" token="movntdq">Moves the packed integers in the source operand (second operand) to the destination operand (first operand) using
a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM
register, YMM register or ZMM register, which is assumed to contain integer data (packed bytes, words, double-
words, or quadwords). The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory
operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (512-bit
version) boundary otherwise a general-protection exception (#GP) will be generated.
The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the
data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it
fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being
written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an
uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see
"Caching of Temporal vs. Non-Temporal Data" in Chapter 10 in the IA-32 Intel Architecture Software Developer's
Manual, Volume 1.
Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with
the SFENCE or MFENCE instruction should be used in conjunction with VMOVNTDQ instructions if multiple proces-
sors might use different memory types to read/write the destination memory locations.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, VEX.L must be 0; otherwise instructions will
#UD.</hint>
<hint page="0" header="Store Doubleword Using Non-Temporal Hint" doc_id="x86_64" token="movnti">Moves the doubleword integer in the source operand (second operand) to the destination operand (first operand)
using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is a
general-purpose register. The destination operand is a 32-bit memory location.
The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the
data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it
fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being
written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an
uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see
"Caching of Temporal vs. Non-Temporal Data" in Chapter 10 in the Intel 64 and IA-32 Architectures Software
Developer's Manual, Volume 1.
Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with
the SFENCE or MFENCE instruction should be used in conjunction with MOVNTI instructions if multiple processors
might use different memory types to read/write the destination memory locations.
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint" doc_id="x86_64" token="movntpd">Moves the packed double-precision floating-point values in the source operand (second operand) to the destination
operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The
source operand is an XMM register, YMM register or ZMM register, which is assumed to contain packed double-
precision, floating-pointing data. The destination operand is a 128-bit, 256-bit or 512-bit memory location. The
memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte
(EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.
The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the
data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it
fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being
written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an
uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see
"Caching of Temporal vs. Non-Temporal Data" in Chapter 10 in the IA-32 Intel Architecture Software Developer's
Manual, Volume 1.
Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with
the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPD instructions if multiple processors
might use different memory types to read/write the destination memory locations.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, VEX.L must be 0; otherwise instructions will
#UD.</hint>
<hint page="0" header="Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint" doc_id="x86_64" token="movntps">Moves the packed single-precision floating-point values in the source operand (second operand) to the destination
operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The
source operand is an XMM register, YMM register or ZMM register, which is assumed to contain packed single-preci-
sion, floating-pointing. The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory
operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512
encoded version) boundary otherwise a general-protection exception (#GP) will be generated.
The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the
data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it
fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being
written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an
uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see
"Caching of Temporal vs. Non-Temporal Data" in Chapter 10 in the IA-32 Intel Architecture Software Developer's
Manual, Volume 1.
Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with
the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPS instructions if multiple processors
might use different memory types to read/write the destination memory locations.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Store of Quadword Using Non-Temporal Hint" doc_id="x86_64" token="movntq">Moves the quadword in the source operand (second operand) to the destination operand (first operand) using a
non-temporal hint to minimize cache pollution during the write to memory. The source operand is an MMX tech-
nology register, which is assumed to contain packed integer data (packed bytes, words, or doublewords). The
destination operand is a 64-bit memory location.
The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the
data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it
fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being
written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an
uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see
"Caching of Temporal vs. Non-Temporal Data" in Chapter 10 in the Intel 64 and IA-32 Architectures Software
Developer's Manual, Volume 1.
Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with
the SFENCE or MFENCE instruction should be used in conjunction with MOVNTQ instructions if multiple processors
might use different memory types to read/write the destination memory locations.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Move Quadword" doc_id="x86_64" token="movq">Copies a quadword from the source operand (second operand) to the destination operand (first operand). The
source and destination operands can be MMX technology registers, XMM registers, or 64-bit memory locations.
This instruction can be used to move a quadword between two MMX technology registers or between an MMX tech-
nology register and a 64-bit memory location, or to move data between two XMM registers or between an XMM
register and a 64-bit memory location. The instruction cannot be used to transfer data between memory locations.
When the source operand is an XMM register, the low quadword is moved; when the destination operand is an XMM
register, the quadword is stored to the low quadword of the register, and the high quadword is cleared to all 0s.
In 64-bit mode and if not encoded using VEX/EVEX, use of the REX prefix in the form of REX.R permits this instruc-
tion to access additional registers (XMM8-XMM15).
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.
If VMOVQ is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an
#UD exception.</hint>
<hint page="0" header="Move Quadword from MMX Technology to XMM Register" doc_id="x86_64" token="movq2dq">Moves the quadword from the source operand (second operand) to the low quadword of the destination operand
(first operand). The source operand is an MMX technology register and the destination operand is an XMM register.
This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack
pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU
floating-point exception is pending, the exception is handled before the MOVQ2DQ instruction is executed.
In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Move Data from String to String" doc_id="x86_64" token="movs">Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified
with the first operand (destination operand). Both the source and destination operands are located in memory. The
address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attri-
bute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or
the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be
overridden with a segment override prefix, but the ES segment cannot be overridden.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the
size and location of the source value and the destination, respectively. This explicit-operands form is provided to
allow documentation; however, note that the documentation provided by this form can be misleading. That is, the
source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or
doublewords), but they do not have to specify the correct location. The locations of the source and destination
operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the
move string instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the MOVS instruc-
tions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The
size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word
move), or MOVSD (doubleword move).
After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according
to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incre-</hint>
<hint page="0" header="Move Data from String to String" doc_id="x86_64" token="movsb">Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified
with the first operand (destination operand). Both the source and destination operands are located in memory. The
address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attri-
bute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or
the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be
overridden with a segment override prefix, but the ES segment cannot be overridden.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the
size and location of the source value and the destination, respectively. This explicit-operands form is provided to
allow documentation; however, note that the documentation provided by this form can be misleading. That is, the
source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or
doublewords), but they do not have to specify the correct location. The locations of the source and destination
operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the
move string instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the MOVS instruc-
tions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The
size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word
move), or MOVSD (doubleword move).
After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according
to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incre-</hint>
<hint page="0" header="Move Data from String to String" doc_id="x86_64" token="movsw">Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified
with the first operand (destination operand). Both the source and destination operands are located in memory. The
address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attri-
bute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or
the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be
overridden with a segment override prefix, but the ES segment cannot be overridden.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the
size and location of the source value and the destination, respectively. This explicit-operands form is provided to
allow documentation; however, note that the documentation provided by this form can be misleading. That is, the
source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or
doublewords), but they do not have to specify the correct location. The locations of the source and destination
operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the
move string instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the MOVS instruc-
tions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The
size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word
move), or MOVSD (doubleword move).
After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according
to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incre-</hint>
<hint page="0" header="Move Data from String to String" doc_id="x86_64" token="movsd">Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified
with the first operand (destination operand). Both the source and destination operands are located in memory. The
address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attri-
bute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or
the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be
overridden with a segment override prefix, but the ES segment cannot be overridden.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the
size and location of the source value and the destination, respectively. This explicit-operands form is provided to
allow documentation; however, note that the documentation provided by this form can be misleading. That is, the
source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or
doublewords), but they do not have to specify the correct location. The locations of the source and destination
operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the
move string instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the MOVS instruc-
tions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The
size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word
move), or MOVSD (doubleword move).
After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according
to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incre-</hint>
<hint page="0" header="Move Data from String to String" doc_id="x86_64" token="movsq">Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified
with the first operand (destination operand). Both the source and destination operands are located in memory. The
address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attri-
bute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or
the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be
overridden with a segment override prefix, but the ES segment cannot be overridden.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the
size and location of the source value and the destination, respectively. This explicit-operands form is provided to
allow documentation; however, note that the documentation provided by this form can be misleading. That is, the
source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or
doublewords), but they do not have to specify the correct location. The locations of the source and destination
operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the
move string instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the MOVS instruc-
tions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The
size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word
move), or MOVSD (doubleword move).
After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according
to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incre-</hint>
<hint page="0" header="Move or Merge Scalar Double-Precision Floating-Point Value" doc_id="x86_64" token="movsd"></hint>
<hint page="0" header="Replicate Single FP Values" doc_id="x86_64" token="movshdup">Duplicates odd-indexed single-precision floating-point values from the source operand (the second operand) to
adjacent element pair in the destination operand (the first operand). See Figure 4-3. The source operand is an
XMM, YMM or ZMM register or 128, 256 or 512-bit memory location and the destination operand is an XMM, YMM
or ZMM register.
128-bit Legacy SSE version: Bits (MAX_VL-1:128) of the corresponding destination register remain unchanged.
VEX.128 encoded version: Bits (MAX_VL-1:128) of the destination register are zeroed.
VEX.256 encoded version: Bits (MAX_VL-1:256) of the destination register are zeroed.
EVEX encoded version: The destination operand is updated at 32-bit granularity according to the writemask.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Replicate Single FP Values" doc_id="x86_64" token="movsldup">Duplicates even-indexed single-precision floating-point values from the source operand (the second operand). See
Figure 4-4. The source operand is an XMM, YMM or ZMM register or 128, 256 or 512-bit memory location and the
destination operand is an XMM, YMM or ZMM register.
128-bit Legacy SSE version: Bits (MAX_VL-1:128) of the corresponding destination register remain unchanged.
VEX.128 encoded version: Bits (MAX_VL-1:128) of the destination register are zeroed.
VEX.256 encoded version: Bits (MAX_VL-1:256) of the destination register are zeroed.
EVEX encoded version: The destination operand is updated at 32-bit granularity according to the writemask.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Move or Merge Scalar Single-Precision Floating-Point Value" doc_id="x86_64" token="movss"></hint>
<hint page="0" header="Move with Sign-Extension" doc_id="x86_64" token="movsx">Copies the contents of the source operand (register or memory location) to the destination operand (register) and
sign extends the value to 16 or 32 bits (see Figure 7-6 in the Intel 64 and IA-32 Architectures Software Devel-
oper's Manual, Volume 1). The size of the converted value depends on the operand-size attribute.
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Move with Sign-Extension" doc_id="x86_64" token="movsxd">Copies the contents of the source operand (register or memory location) to the destination operand (register) and
sign extends the value to 16 or 32 bits (see Figure 7-6 in the Intel 64 and IA-32 Architectures Software Devel-
oper's Manual, Volume 1). The size of the converted value depends on the operand-size attribute.
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the
beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Move Unaligned Packed Double-Precision Floating-Point Values" doc_id="x86_64" token="movupd">Note: VEX.vvvv and EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
EVEX.512 encoded version:
Moves 512 bits of packed double-precision floating-point values from the source operand (second operand) to the
destination operand (first operand). This instruction can be used to load a ZMM register from a float64 memory
location, to store the contents of a ZMM register into a memory. The destination operand is updated according to
the writemask.</hint>
<hint page="0" header="Move Unaligned Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="movups">Note: VEX.vvvv and EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
EVEX.512 encoded version:
Moves 512 bits of packed single-precision floating-point values from the source operand (second operand) to the
destination operand (first operand). This instruction can be used to load a ZMM register from a 512-bit float32
memory location, to store the contents of a ZMM register into memory. The destination operand is updated
according to the writemask.</hint>
<hint page="0" header="Move with Zero-Extend" doc_id="x86_64" token="movzx">Copies the contents of the source operand (register or memory location) to the destination operand (register) and
zero extends the value. The size of the converted value depends on the operand-size attribute.
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bit operands. See the summary chart
at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Compute Multiple Packed Sums of Absolute Difference" doc_id="x86_64" token="mpsadbw">(V)MPSADBW calculates packed word results of sum-absolute-difference (SAD) of unsigned bytes from two blocks
of 32-bit dword elements, using two select fields in the immediate byte to select the offsets of the two blocks within
the first source operand and the second operand. Packed SAD word results are calculated within each 128-bit lane.
Each SAD word result is calculated between a stationary block_2 (whose offset within the second source operand
is selected by a two bit select control, multiplied by 32 bits) and a sliding block_1 at consecutive byte-granular
position within the first source operand. The offset of the first 32-bit block of block_1 is selectable using a one bit
select control, multiplied by 32 bits.
128-bit Legacy SSE version: Imm8[1:0]*32 specifies the bit offset of block_2 within the second source operand.
Imm[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source operand
and destination operand are the same. The first source and destination operands are XMM registers. The second
source operand is either an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding
YMM destination register remain unchanged. Bits 7:3 of the immediate byte are ignored.
VEX.128 encoded version: Imm8[1:0]*32 specifies the bit offset of block_2 within the second source operand.
Imm[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source and desti-
nation operands are XMM registers. The second source operand is either an XMM register or a 128-bit memory
location. Bits (127:128) of the corresponding YMM register are zeroed. Bits 7:3 of the immediate byte are ignored.
VEX.256 encoded version: The sum-absolute-difference (SAD) operation is repeated 8 times for MPSADW between
the same block_2 (fixed offset within the second source operand) and a variable block_1 (offset is shifted by 8 bits
for each SAD operation) in the first source operand. Each 16-bit result of eight SAD operations between block_2
and block_1 is written to the respective word in the lower 128 bits of the destination operand.
Additionally, VMPSADBW performs another eight SAD operations on block_4 of the second source operand and
block_3 of the first source operand. (Imm8[4:3]*32 + 128) specifies the bit offset of block_4 within the second
source operand. (Imm[5]*32+128) specifies the initial bit offset of the block_3 within the first source operand.
Each 16-bit result of eight SAD operations between block_4 and block_3 is written to the respective word in the
upper 128 bits of the destination operand.</hint>
<hint page="0" header="Unsigned Multiply" doc_id="x86_64" token="mul">Performs an unsigned multiplication of the first operand (destination operand) and the second operand (source
operand) and stores the result in the destination operand. The destination operand is an implied operand located in
register AL, AX or EAX (depending on the size of the operand); the source operand is located in a general-purpose
register or a memory location. The action of this instruction and the location of the result depends on the opcode
and the operand size as shown in Table 4-9.
The result is stored in register AX, register pair DX:AX, or register pair EDX:EAX (depending on the operand size),
with the high-order bits of the product contained in register AH, DX, or EDX, respectively. If the high-order bits of
the product are 0, the CF and OF flags are cleared; otherwise, the flags are set.
In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to addi-
tional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.
See the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Multiply Packed Double-Precision Floating-Point Values" doc_id="x86_64" token="mulpd">Multiply packed double-precision floating-point values from the first source operand with corresponding values in
the second source operand, and stores the packed double-precision floating-point results in the destination
operand.
EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second
source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally
updated with writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register. Bits (MAX_VL-1:256) of the
corresponding destination ZMM register are zeroed.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the destination YMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified.</hint>
<hint page="0" header="Multiply Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="mulps">Multiply the packed single-precision floating-point values from the first source operand with the corresponding
values in the second source operand, and stores the packed double-precision floating-point results in the destina-
tion operand.
EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second
source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally
updated with writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register. Bits (MAX_VL-1:256) of the
corresponding destination ZMM register are zeroed.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the destination YMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified.</hint>
<hint page="0" header="Multiply Scalar Double-Precision Floating-Point Value" doc_id="x86_64" token="mulsd">Multiplies the low double-precision floating-point value in the second source operand by the low double-precision
floating-point value in the first source operand, and stores the double-precision floating-point result in the destina-
tion operand. The second source operand can be an XMM register or a 64-bit memory location. The first source
operand and the destination operands are XMM registers.
128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAX_VL-
1:64) of the corresponding destination register remain unchanged.
VEX.128 and EVEX encoded version: The quadword at bits 127:64 of the destination operand is copied from the
same bits of the first source operand. Bits (MAX_VL-1:128) of the destination register are zeroed.
EVEX encoded version: The low quadword element of the destination operand is updated according to the
writemask.
Software should ensure VMULSD is encoded with VEX.L=0. Encoding VMULSD with VEX.L=1 may encounter unpre-
dictable behavior across different processor generations.</hint>
<hint page="0" header="Multiply Scalar Single-Precision Floating-Point Values" doc_id="x86_64" token="mulss">Multiplies the low single-precision floating-point value from the second source operand by the low single-precision
floating-point value in the first source operand, and stores the single-precision floating-point result in the destina-
tion operand. The second source operand can be an XMM register or a 32-bit memory location. The first source
operand and the destination operands are XMM registers.
128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAX_VL-
1:32) of the corresponding YMM destination register remain unchanged.
VEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The three
high-order doublewords of the destination operand are copied from the first source operand. Bits (MAX_VL-1:128)
of the destination register are zeroed.
EVEX encoded version: The low doubleword element of the destination operand is updated according to the
writemask.
Software should ensure VMULSS is encoded with VEX.L=0. Encoding VMULSS with VEX.L=1 may encounter unpre-
dictable behavior across different processor generations.</hint>
<hint page="0" header="Unsigned Multiply Without Affecting Flags" doc_id="x86_64" token="mulx">Performs an unsigned multiplication of the implicit source operand (EDX/RDX) and the specified source operand
(the third operand) and stores the low half of the result in the second destination (second operand), the high half
of the result in the first destination operand (first operand), without reading or writing the arithmetic flags. This
enables efficient programming where the software can interleave add with carry operations and multiplications.
If the first and second operand are identical, it will contain the high half of the multiplication result.
This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</hint>
<hint page="0" header="Monitor Wait" doc_id="x86_64" token="mwait">MWAIT instruction provides hints to allow the processor to enter an implementation-dependent optimized state.
There are two principal targeted usages: address-range monitor and advanced power management. Both usages
of MWAIT require the use of the MONITOR instruction.
CPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT in the processor. When set,
MWAIT may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode
exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE
MSR; disabling MWAIT clears the CPUID feature flag and causes execution to generate an invalid-opcode excep-
tion.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.
ECX specifies optional extensions for the MWAIT instruction. EAX may contain hints such as the preferred optimized
state the processor should enter. The first processors to implement MWAIT supported only the zero value for EAX
and ECX. Later processors allowed setting ECX[0] to enable masked interrupts as break events for MWAIT (see
below). Software can use the CPUID instruction to determine the extensions and hints supported by the processor.</hint>
<hint page="0" header="Two's Complement Negation" doc_id="x86_64" token="neg">Replaces the value of operand (the destination operand) with its two's complement. (This operation is equivalent
to subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory
location.
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="No Operation" doc_id="x86_64" token="nop">This instruction performs no operation. It is a one-byte or multi-byte NOP that takes up space in the instruction
stream but does not impact machine context, except for the EIP register.
The multi-byte form of NOP is available on processors with model encoding:
.     CPUID.01H.EAX[Bytes 11:8] = 0110B or 1111B
The multi-byte NOP instruction does not alter the content of a register and will not issue a memory operation. The
instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="One's Complement Negation" doc_id="x86_64" token="not">Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is set to 1) on the destination operand and stores
the result in the destination operand location. The destination operand can be a register or a memory location.
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Logical Inclusive OR" doc_id="x86_64" token="or">Performs a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores
the result in the destination operand location. The source operand can be an immediate, a register, or a memory
location; the destination operand can be a register or a memory location. (However, two memory operands cannot
be used in one instruction.) Each bit of the result of the OR instruction is set to 0 if both corresponding bits of the
first and second operands are 0; otherwise, each bit is set to 1.
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</hint>
<hint page="0" header="Bitwise Logical OR of Packed Double Precision Floating-Point Values" doc_id="x86_64" token="orpd">Performs a bitwise logical OR of the two, four or eight packed double-precision floating-point values from the first
source operand and the second source operand, and stores the result in the destination operand.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be
a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a
32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with
writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256) of the
corresponding ZMM register destination are zeroed.
VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
register destination are unmodified.</hint>
<hint page="0" header="Bitwise Logical OR of Packed Single Precision Floating-Point Values" doc_id="x86_64" token="orps">Performs a bitwise logical OR of the four, eight or sixteen packed single-precision floating-point values from the
first source operand and the second source operand, and stores the result in the destination operand
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be
a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a
32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with
writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256) of the
corresponding ZMM register destination are zeroed.
VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
register destination are unmodified.</hint>
<hint page="0" header="Output to Port" doc_id="x86_64" token="out">Copies the value from the second operand (source operand) to the I/O port specified with the destination operand
(first operand). The source operand can be register AL, AX, or EAX, depending on the size of the port being
accessed (8, 16, or 32 bits, respectively); the destination operand can be a byte-immediate or the DX register.
Using a byte immediate allows I/O port addresses 0 to 255 to be accessed; using the DX register as a source
operand allows I/O ports from 0 to 65,535 to be accessed.
The size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size
attribute of the instruction for a 16- or 32-bit I/O port.
At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits
of the port address will be 0.
This instruction is only useful for accessing I/O ports located in the processor's I/O address space. See Chapter 18,
"Input/Output," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for more infor-
mation on accessing I/O ports in the I/O address space.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Output String to Port" doc_id="x86_64" token="outs">Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first
operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or
the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The DS
segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from
0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source
and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the
instruction for a 16- or 32-bit I/O port.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O
port and the source address, and the destination operand must be DX. This explicit-operands form is provided to
allow documentation; however, note that the documentation provided by this form can be misleading. That is, the
source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does
not have to specify the correct location. The location is always specified by the DS:(E)SI or RSI registers, which
must be loaded correctly before the OUTS instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the OUTS instructions.
Here also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size
of the I/O port is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or OUTSD (doubleword).
After the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI
register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.
(If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the SI/ESI/RSI register is decremented.)
The SI/ESI/RSI register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by
4 for doubleword operations.</hint>
<hint page="0" header="Output String to Port" doc_id="x86_64" token="outsb">Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first
operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or
the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The DS
segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from
0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source
and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the
instruction for a 16- or 32-bit I/O port.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O
port and the source address, and the destination operand must be DX. This explicit-operands form is provided to
allow documentation; however, note that the documentation provided by this form can be misleading. That is, the
source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does
not have to specify the correct location. The location is always specified by the DS:(E)SI or RSI registers, which
must be loaded correctly before the OUTS instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the OUTS instructions.
Here also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size
of the I/O port is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or OUTSD (doubleword).
After the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI
register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.
(If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the SI/ESI/RSI register is decremented.)
The SI/ESI/RSI register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by
4 for doubleword operations.</hint>
<hint page="0" header="Output String to Port" doc_id="x86_64" token="outsw">Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first
operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or
the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The DS
segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from
0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source
and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the
instruction for a 16- or 32-bit I/O port.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O
port and the source address, and the destination operand must be DX. This explicit-operands form is provided to
allow documentation; however, note that the documentation provided by this form can be misleading. That is, the
source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does
not have to specify the correct location. The location is always specified by the DS:(E)SI or RSI registers, which
must be loaded correctly before the OUTS instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the OUTS instructions.
Here also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size
of the I/O port is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or OUTSD (doubleword).
After the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI
register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.
(If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the SI/ESI/RSI register is decremented.)
The SI/ESI/RSI register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by
4 for doubleword operations.</hint>
<hint page="0" header="Output String to Port" doc_id="x86_64" token="outsd">Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first
operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or
the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The DS
segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from
0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source
and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the
instruction for a 16- or 32-bit I/O port.
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination
operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O
port and the source address, and the destination operand must be DX. This explicit-operands form is provided to
allow documentation; however, note that the documentation provided by this form can be misleading. That is, the
source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does
not have to specify the correct location. The location is always specified by the DS:(E)SI or RSI registers, which
must be loaded correctly before the OUTS instruction is executed.
The no-operands form provides "short forms" of the byte, word, and doubleword versions of the OUTS instructions.
Here also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size
of the I/O port is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or OUTSD (doubleword).
After the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI
register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.
(If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the SI/ESI/RSI register is decremented.)
The SI/ESI/RSI register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by
4 for doubleword operations.</hint>
<hint page="0" header="Packed Absolute Value" doc_id="x86_64" token="pabsb">PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and
stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes,
PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.
EVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location,
or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a
ZMM/YMM/XMM register updated according to the writemask.
EVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory loca-
tion. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.
VEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination
operand is a YMM register. The upper bits (MAX_VL-1:256) of the corresponding register destination are zeroed.
VEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination
operand is an XMM register. The upper bits (MAX_VL-1:128) of the corresponding register destination are zeroed.</hint>
<hint page="0" header="Packed Absolute Value" doc_id="x86_64" token="pabsw">PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and
stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes,
PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.
EVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location,
or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a
ZMM/YMM/XMM register updated according to the writemask.
EVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory loca-
tion. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.
VEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination
operand is a YMM register. The upper bits (MAX_VL-1:256) of the corresponding register destination are zeroed.
VEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination
operand is an XMM register. The upper bits (MAX_VL-1:128) of the corresponding register destination are zeroed.</hint>
<hint page="0" header="Packed Absolute Value" doc_id="x86_64" token="pabsd">PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and
stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes,
PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.
EVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location,
or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a
ZMM/YMM/XMM register updated according to the writemask.
EVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory loca-
tion. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.
VEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination
operand is a YMM register. The upper bits (MAX_VL-1:256) of the corresponding register destination are zeroed.
VEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination
operand is an XMM register. The upper bits (MAX_VL-1:128) of the corresponding register destination are zeroed.</hint>
<hint page="0" header="Packed Absolute Value" doc_id="x86_64" token="pabsq">PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and
stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes,
PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.
EVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location,
or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a
ZMM/YMM/XMM register updated according to the writemask.
EVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory loca-
tion. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.
VEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination
operand is a YMM register. The upper bits (MAX_VL-1:256) of the corresponding register destination are zeroed.
VEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination
operand is an XMM register. The upper bits (MAX_VL-1:128) of the corresponding register destination are zeroed.</hint>
<hint page="0" header="Pack with Signed Saturation" doc_id="x86_64" token="packsswb">Converts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed
doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow condi-
tions. See Figure 4-6 for an example of the packing operation.</hint>
<hint page="0" header="Pack with Signed Saturation" doc_id="x86_64" token="packssdw">Converts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed
doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow condi-
tions. See Figure 4-6 for an example of the packing operation.</hint>
<hint page="0" header="Pack with Unsigned Saturation" doc_id="x86_64" token="packusdw">Converts packed signed doubleword integers in the first and second source operands into packed unsigned word
integers using unsigned saturation to handle overflow conditions. If the signed doubleword value is beyond the
range of an unsigned word (that is, greater than FFFFH or less than 0000H), the saturated unsigned word integer
value of FFFFH or 0000H, respectively, is stored in the destination.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a
ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-
bit memory location. The destination operand is a ZMM register, updated conditionally under the writemask k1.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAX_VL-1:256) of the
corresponding ZMM register destination are zeroed.
VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the
upper bits (MAX_VL-1:128) of the corresponding destination register destination are unmodified.</hint>
<hint page="0" header="Pack with Unsigned Saturation" doc_id="x86_64" token="packuswb">Converts 4, 8, 16 or 32 signed word integers from the destination operand (first operand) and 4, 8, 16 or 32 signed
word integers from the source operand (second operand) into 8, 16, 32 or 64 unsigned byte integers and stores the
result in the destination operand. (See Figure 4-6 for an example of the packing operation.) If a signed word
integer value is beyond the range of an unsigned byte integer (that is, greater than FFH or less than 00H), the satu-
rated unsigned byte integer value of FFH or 00H, respectively, is stored in the destination.
EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM
register or a 512-bit memory location. The destination operand is a ZMM register.</hint>
<hint page="0" header="Add Packed Integers" doc_id="x86_64" token="paddb">Performs a SIMD add of the packed integers from the source operand (second operand) and the destination
operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the
Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of a SIMD operation.
Overflow is handled with wraparound, as described in the following paragraphs.
The PADDB and VPADDB instructions add packed byte integers from the first source operand and second source
operand and store the packed integer results in the destination operand. When an individual result is too large to
be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination
operand (that is, the carry is ignored).
The PADDW and VPADDW instructions add packed word integers from the first source operand and second source
operand and store the packed integer results in the destination operand. When an individual result is too large to
be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination
operand (that is, the carry is ignored).
The PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second
source operand and store the packed integer results in the destination operand. When an individual result is too
large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the
destination operand (that is, the carry is ignored).
The PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second
source operand and store the packed integer results in the destination operand. When a quadword result is too
large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the
destination operand (that is, the carry is ignored).</hint>
<hint page="0" header="Add Packed Integers" doc_id="x86_64" token="paddw">Performs a SIMD add of the packed integers from the source operand (second operand) and the destination
operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the
Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of a SIMD operation.
Overflow is handled with wraparound, as described in the following paragraphs.
The PADDB and VPADDB instructions add packed byte integers from the first source operand and second source
operand and store the packed integer results in the destination operand. When an individual result is too large to
be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination
operand (that is, the carry is ignored).
The PADDW and VPADDW instructions add packed word integers from the first source operand and second source
operand and store the packed integer results in the destination operand. When an individual result is too large to
be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination
operand (that is, the carry is ignored).
The PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second
source operand and store the packed integer results in the destination operand. When an individual result is too
large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the
destination operand (that is, the carry is ignored).
The PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second
source operand and store the packed integer results in the destination operand. When a quadword result is too
large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the
destination operand (that is, the carry is ignored).</hint>
<hint page="0" header="Add Packed Integers" doc_id="x86_64" token="paddd">Performs a SIMD add of the packed integers from the source operand (second operand) and the destination
operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the
Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of a SIMD operation.
Overflow is handled with wraparound, as described in the following paragraphs.
The PADDB and VPADDB instructions add packed byte integers from the first source operand and second source
operand and store the packed integer results in the destination operand. When an individual result is too large to
be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination
operand (that is, the carry is ignored).
The PADDW and VPADDW instructions add packed word integers from the first source operand and second source
operand and store the packed integer results in the destination operand. When an individual result is too large to
be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination
operand (that is, the carry is ignored).
The PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second
source operand and store the packed integer results in the destination operand. When an individual result is too
large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the
destination operand (that is, the carry is ignored).
The PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second
source operand and store the packed integer results in the destination operand. When a quadword result is too
large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the
destination operand (that is, the carry is ignored).</hint>
<hint page="0" header="Add Packed Integers" doc_id="x86_64" token="paddq">Performs a SIMD add of the packed integers from the source operand (second operand) and the destination
operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the
Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of a SIMD operation.
Overflow is handled with wraparound, as described in the following paragraphs.
The PADDB and VPADDB instructions add packed byte integers from the first source operand and second source
operand and store the packed integer results in the destination operand. When an individual result is too large to
be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination
operand (that is, the carry is ignored).
The PADDW and VPADDW instructions add packed word integers from the first source operand and second source
operand and store the packed integer results in the destination operand. When an individual result is too large to
be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination
operand (that is, the carry is ignored).
The PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second
source operand and store the packed integer results in the destination operand. When an individual result is too
large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the
destination operand (that is, the carry is ignored).
The PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second
source operand and store the packed integer results in the destination operand. When a quadword result is too
large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the
destination operand (that is, the carry is ignored).</hint>
<hint page="0" header="Add Packed Signed Integers with Signed Saturation" doc_id="x86_64" token="paddsb">Performs a SIMD add of the packed signed integers from the source operand (second operand) and the destination
operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the
Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of a SIMD operation.
Overflow is handled with signed saturation, as described in the following paragraphs.
(V)PADDSB performs a SIMD add of the packed signed integers with saturation from the first source operand and
second source operand and stores the packed integer results in the destination operand. When an individual byte
result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value
of 7FH or 80H, respectively, is written to the destination operand.
(V)PADDSW performs a SIMD add of the packed signed word integers with saturation from the first source operand
and second source operand and stores the packed integer results in the destination operand. When an individual
word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the satu-
rated value of 7FFFH or 8000H, respectively, is written to the destination operand.
EVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an
ZMM/YMM/XMM register or a memory location. The destination operand is an ZMM/YMM/XMM register.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register.
VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128) of
the corresponding register destination are zeroed.
128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the
upper bits (MAX_VL-1:128) of the corresponding register destination are unmodified.</hint>
<hint page="0" header="Add Packed Signed Integers with Signed Saturation" doc_id="x86_64" token="paddsw">Performs a SIMD add of the packed signed integers from the source operand (second operand) and the destination
operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the
Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of a SIMD operation.
Overflow is handled with signed saturation, as described in the following paragraphs.
(V)PADDSB performs a SIMD add of the packed signed integers with saturation from the first source operand and
second source operand and stores the packed integer results in the destination operand. When an individual byte
result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value
of 7FH or 80H, respectively, is written to the destination operand.
(V)PADDSW performs a SIMD add of the packed signed word integers with saturation from the first source operand
and second source operand and stores the packed integer results in the destination operand. When an individual
word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the satu-
rated value of 7FFFH or 8000H, respectively, is written to the destination operand.
EVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an
ZMM/YMM/XMM register or a memory location. The destination operand is an ZMM/YMM/XMM register.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register.
VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128) of
the corresponding register destination are zeroed.
128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the
upper bits (MAX_VL-1:128) of the corresponding register destination are unmodified.</hint>
<hint page="0" header="Add Packed Unsigned Integers with Unsigned Saturation" doc_id="x86_64" token="paddusb">Performs a SIMD add of the packed unsigned integers from the source operand (second operand) and the destina-
tion operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the
Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of a SIMD operation.
Overflow is handled with unsigned saturation, as described in the following paragraphs.
(V)PADDUSB performs a SIMD add of the packed unsigned integers with saturation from the first source operand
and second source operand and stores the packed integer results in the destination operand. When an individual
byte result is beyond the range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH
is written to the destination operand.
(V)PADDUSW performs a SIMD add of the packed unsigned word integers with saturation from the first source
operand and second source operand and stores the packed integer results in the destination operand. When an
individual word result is beyond the range of an unsigned word integer (that is, greater than FFFFH), the saturated
value of FFFFH is written to the destination operand.
EVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an
ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination is an ZMM/YMM/XMM register.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register.
VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128)
of the corresponding destination register destination are zeroed.
128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the
upper bits (MAX_VL-1:128) of the corresponding register destination are unmodified.</hint>
<hint page="0" header="Add Packed Unsigned Integers with Unsigned Saturation" doc_id="x86_64" token="paddusw">Performs a SIMD add of the packed unsigned integers from the source operand (second operand) and the destina-
tion operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the
Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of a SIMD operation.
Overflow is handled with unsigned saturation, as described in the following paragraphs.
(V)PADDUSB performs a SIMD add of the packed unsigned integers with saturation from the first source operand
and second source operand and stores the packed integer results in the destination operand. When an individual
byte result is beyond the range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH
is written to the destination operand.
(V)PADDUSW performs a SIMD add of the packed unsigned word integers with saturation from the first source
operand and second source operand and stores the packed integer results in the destination operand. When an
individual word result is beyond the range of an unsigned word integer (that is, greater than FFFFH), the saturated
value of FFFFH is written to the destination operand.
EVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an
ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination is an ZMM/YMM/XMM register.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register.
VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM
register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAX_VL-1:128)
of the corresponding destination register destination are zeroed.
128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the
upper bits (MAX_VL-1:128) of the corresponding register destination are unmodified.</hint>
<hint page="0" header="Packed Align Right" doc_id="x86_64" token="palignr">(V)PALIGNR concatenates the destination operand (the first operand) and the source operand (the second
operand) into an intermediate composite, shifts the composite at byte granularity to the right by a constant imme-
diate, and extracts the right-aligned result into the destination. The first and the second operands can be an MMX,</hint>
<hint page="0" header="Logical AND" doc_id="x86_64" token="pand">Performs a bitwise logical AND operation on the first source operand and second source operand and stores the
result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second
operands are 1, otherwise it is set to 0.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Logical AND NOT" doc_id="x86_64" token="pandn">Performs a bitwise logical NOT operation on the first source operand, then performs bitwise AND with second
source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corre-
sponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Spin Loop Hint" doc_id="x86_64" token="pause">Improves the performance of spin-wait loops. When executing a "spin-wait loop," processors will suffer a severe
performance penalty when exiting the loop because it detects a possible memory order violation. The PAUSE
instruction provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint
to avoid the memory order violation in most situations, which greatly improves processor performance. For this
reason, it is recommended that a PAUSE instruction be placed in all spin-wait loops.
An additional function of the PAUSE instruction is to reduce the power consumed by a processor while executing a
spin loop. A processor can execute a spin-wait loop extremely quickly, causing the processor to consume a lot of
power while it waits for the resource it is spinning on to become available. Inserting a pause instruction in a spin-
wait loop greatly reduces the processor's power consumption.
This instruction was introduced in the Pentium 4 processors, but is backward compatible with all IA-32 processors.
In earlier IA-32 processors, the PAUSE instruction operates like a NOP instruction. The Pentium 4 and Intel Xeon
processors implement the PAUSE instruction as a delay. The delay is finite and can be zero for some processors.
This instruction does not change the architectural state of the processor (that is, it performs essentially a delaying
no-op operation).
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Average Packed Integers" doc_id="x86_64" token="pavgb">Performs a SIMD average of the packed unsigned integers from the source operand (second operand) and the
destination operand (first operand), and stores the results in the destination operand. For each corresponding pair
of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary
sum, and that result is shifted right one bit position.
The (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed
unsigned words.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
destination operand can be an MMX technology register.
128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the
upper bits (MAX_VL-1:128) of the corresponding register destination are unmodified.
EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM
register or a 512-bit memory location. The destination operand is a ZMM register.
VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand
is a YMM register or a 256-bit memory location. The destination operand is a YMM register.
VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand
is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits
(MAX_VL-1:128) of the corresponding register destination are zeroed.</hint>
<hint page="0" header="Average Packed Integers" doc_id="x86_64" token="pavgw">Performs a SIMD average of the packed unsigned integers from the source operand (second operand) and the
destination operand (first operand), and stores the results in the destination operand. For each corresponding pair
of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary
sum, and that result is shifted right one bit position.
The (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed
unsigned words.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
destination operand can be an MMX technology register.
128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM
register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the
upper bits (MAX_VL-1:128) of the corresponding register destination are unmodified.
EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM
register or a 512-bit memory location. The destination operand is a ZMM register.
VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand
is a YMM register or a 256-bit memory location. The destination operand is a YMM register.
VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand
is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits
(MAX_VL-1:128) of the corresponding register destination are zeroed.</hint>
<hint page="0" header="Variable Blend Packed Bytes" doc_id="x86_64" token="pblendvb">Conditionally copies byte elements from the source operand (second operand) to the destination operand (first
operand) depending on mask bits defined in the implicit third register argument, XMM0. The mask bits are the most
significant bit in each byte element of the XMM0 register.
If a mask bit is "1", then the corresponding byte element in the source operand is copied to the destination, else
the byte element in the destination operand is left unchanged.
The register assignment of the implicit third operand is defined to be the architectural register XMM0.
128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (VLMAX-1:128)
of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined
to be the architectural register XMM0. An attempt to execute PBLENDVB with a VEX prefix will cause #UD.
VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second
source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and
encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
ignored. The upper bits (VLMAX-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.L
must be 0, otherwise the instruction will #UD. VEX.W must be 0, otherwise, the instruction will #UD.
VEX.256 encoded version: The first source operand and the destination operand are YMM registers. The second
source operand is an YMM register or 256-bit memory location. The third source register is an YMM register and
encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is
ignored.
VPBLENDVB permits the mask to be any XMM or YMM register. In contrast, PBLENDVB treats XMM0 implicitly as the
mask and do not support non-destructive destination operation. An attempt to execute PBLENDVB encoded with a
VEX prefix will cause a #UD exception.</hint>
<hint page="0" header="Blend Packed Words" doc_id="x86_64" token="pblendw">Words from the source operand (second operand) are conditionally written to the destination operand (first
operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask
that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask,
corresponding to a word, is "1", then the word is copied, else the word element in the destination operand is
unchanged.
128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination
register remain unchanged.
VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register
are zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register.</hint>
<hint page="0" header="Carry-Less Multiplication Quadword" doc_id="x86_64" token="pclmulqdq">Performs a carry-less multiplication of two quadwords, selected from the first source and second source operand
according to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to
use according to Table 4-13, other bits of the immediate byte are ignored.</hint>
<hint page="0" header="Compare Packed Data for Equal" doc_id="x86_64" token="pcmpeqb">Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first
operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data
element in the destination operand is set to all 1s; otherwise, it is set to all 0s.
The (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the
(V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the
(V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
destination operand can be an MMX technology register.
128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination
register remain unchanged.
VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register
are zeroed.</hint>
<hint page="0" header="Compare Packed Data for Equal" doc_id="x86_64" token="pcmpeqw">Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first
operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data
element in the destination operand is set to all 1s; otherwise, it is set to all 0s.
The (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the
(V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the
(V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
destination operand can be an MMX technology register.
128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination
register remain unchanged.
VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register
are zeroed.</hint>
<hint page="0" header="Compare Packed Data for Equal" doc_id="x86_64" token="pcmpeqd">Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first
operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data
element in the destination operand is set to all 1s; otherwise, it is set to all 0s.
The (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the
(V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the
(V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
destination operand can be an MMX technology register.
128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination
register remain unchanged.
VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register
are zeroed.</hint>
<hint page="0" header="Compare Packed Qword Data for Equal" doc_id="x86_64" token="pcmpeqq">Performs an SIMD compare for equality of the packed quadwords in the destination operand (first operand) and the
source operand (second operand). If a pair of data elements is equal, the corresponding data element in the desti-
nation is set to all 1s; otherwise, it is set to 0s.
128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM destination
register remain unchanged.
VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register
are zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register.
EVEX encoded VPCMPEQQ: The first source operand (second operand) is a ZMM/YMM/XMM register. The second
source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register updated
according to the writemask k2.</hint>
<hint page="0" header="Packed Compare Explicit Length Strings, Return Index" doc_id="x86_64" token="pcmpestri">The instruction compares and processes data from two string fragments based on the encoded value in the Imm8
Control Byte (see Section 4.1, "Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMP-
ISTRM"), and generates an index stored to the count register (ECX).
Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second
operand) which contains the data elements of the string (byte or word data). The second value is stored in an input
length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length repre-
sents the number of bytes/words which are valid for the respective xmm/m128 data.
The length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-
value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value
in the length register is greater than 16 (8) or less than -16 (-8).
The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see
Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 (see Section 4.1.4) is returned
in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).
Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant informa-
tion:</hint>
<hint page="0" header="Packed Compare Explicit Length Strings, Return Mask" doc_id="x86_64" token="pcmpestrm">The instruction compares data from two string fragments based on the encoded value in the imm8 contol byte (see
Section 4.1, "Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM"), and gener-
ates a mask stored to XMM0.
Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second
operand) which contains the data elements of the string (byte or word data). The second value is stored in an input
length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length repre-
sents the number of bytes/words which are valid for the respective xmm/m128 data.
The length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-
value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value
in the length register is greater than 16 (8) or less than -16 (-8).
The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see
Section 4.1). As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero
extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.
Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant informa-
tion:</hint>
<hint page="0" header="Compare Packed Signed Integers for Greater Than" doc_id="x86_64" token="pcmpgtb">Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the
destination operand (first operand) and the source operand (second operand). If a data element in the destination
operand is greater than the corresponding date element in the source operand, the corresponding data element in
the destination operand is set to all 1s; otherwise, it is set to all 0s.
The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source oper-
ands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source
operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destina-
tion and source operands.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
destination operand can be an MMX technology register.
128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
destination register remain unchanged.
VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
register are zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register.</hint>
<hint page="0" header="Compare Packed Signed Integers for Greater Than" doc_id="x86_64" token="pcmpgtw">Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the
destination operand (first operand) and the source operand (second operand). If a data element in the destination
operand is greater than the corresponding date element in the source operand, the corresponding data element in
the destination operand is set to all 1s; otherwise, it is set to all 0s.
The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source oper-
ands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source
operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destina-
tion and source operands.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
destination operand can be an MMX technology register.
128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
destination register remain unchanged.
VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
register are zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register.</hint>
<hint page="0" header="Compare Packed Signed Integers for Greater Than" doc_id="x86_64" token="pcmpgtd">Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the
destination operand (first operand) and the source operand (second operand). If a data element in the destination
operand is greater than the corresponding date element in the source operand, the corresponding data element in
the destination operand is set to all 1s; otherwise, it is set to all 0s.
The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source oper-
ands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source
operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destina-
tion and source operands.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The
destination operand can be an MMX technology register.
128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
destination register remain unchanged.
VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
register are zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register.</hint>
<hint page="0" header="Compare Packed Data for Greater Than" doc_id="x86_64" token="pcmpgtq">Performs an SIMD signed compare for the packed quadwords in the destination operand (first operand) and the
source operand (second operand). If the data element in the first (destination) operand is greater than the
corresponding element in the second (source) operand, the corresponding data element in the destination is set
to all 1s; otherwise, it is set to 0s.
128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The
first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
destination register remain unchanged.
VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
first source operand and destination operand are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM
register are zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register.
EVEX encoded VPCMPGTD/Q: The first source operand (second operand) is a ZMM/YMM/XMM register. The second
source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register updated
according to the writemask k2.</hint>
<hint page="0" header="Packed Compare Implicit Length Strings, Return Index" doc_id="x86_64" token="pcmpistri">The instruction compares data from two strings based on the encoded value in the Imm8 Control Byte (see Section
4.1, "Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM"), and generates an
index stored to ECX.
Each string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which
contains the data elements of the string (byte or word data). Each input byte/word is augmented with a
valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null
byte/word. (The least significant null byte/word is also considered invalid.)
The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see
Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 is returned in ECX. If no bits
are set in IntRes2, ECX is set to 16 (8).
Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant informa-
tion:</hint>
<hint page="0" header="Packed Compare Implicit Length Strings, Return Mask" doc_id="x86_64" token="pcmpistrm">The instruction compares data from two strings based on the encoded value in the imm8 byte (see Section 4.1,
"Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM") generating a mask
stored to XMM0.
Each string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which
contains the data elements of the string (byte or word data). Each input byte/word is augmented with a
valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null
byte/word. (The least significant null byte/word is also considered invalid.)
The comparison and aggregation operation are performed according to the encoded value of Imm8 bit fields (see
Section 4.1). As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero
extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.
Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant informa-
tion:</hint>
<hint page="0" header="Parallel Bits Deposit" doc_id="x86_64" token="pdep">PDEP uses a mask in the second source operand (the third operand) to transfer/scatter contiguous low order bits
in the first source operand (the second operand) into the destination (the first operand). PDEP takes the low bits
from the first source operand and deposit them in the destination operand at the corresponding bit locations that
are set in the second source operand (mask). All other bits (bits not set in mask) in destination are set to zero.</hint>
<hint page="0" header="Parallel Bits Extract" doc_id="x86_64" token="pext">PEXT uses a mask in the second source operand (the third operand) to transfer either contiguous or non-contig-
uous bits in the first source operand (the second operand) to contiguous low order bit positions in the destination
(the first operand). For each bit set in the MASK, PEXT extracts the corresponding bits from the first source operand
and writes them into contiguous lower bits of destination operand. The remaining upper bits of destination are
zeroed.</hint>
<hint page="0" header="Extract Byte/Dword/Qword" doc_id="x86_64" token="pextrb">Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined
from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a
register, the upper bits of the register are zero extended.
In legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit
mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros.
PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.</hint>
<hint page="0" header="Extract Byte/Dword/Qword" doc_id="x86_64" token="pextrd">Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined
from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a
register, the upper bits of the register are zero extended.
In legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit
mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros.
PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.</hint>
<hint page="0" header="Extract Byte/Dword/Qword" doc_id="x86_64" token="pextrq">Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined
from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a
register, the upper bits of the register are zero extended.
In legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit
mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros.
PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.</hint>
<hint page="0" header="Extract Word" doc_id="x86_64" token="pextrw">Copies the word in the source operand (second operand) specified by the count operand (third operand) to the
destination operand (first operand). The source operand can be an MMX technology register or an XMM register.
The destination operand can be the low word of a general-purpose register or a 16-bit memory address. The count
operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-signifi-
cant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the loca-
tion. The content of the destination register above bit 16 is cleared (set to all 0s).
In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
(XMM8-XMM15, R8-15). If the destination operand is a general-purpose register, the default operand size is 64-bits
in 64-bit mode.</hint>
<hint page="0" header="Packed Horizontal Add" doc_id="x86_64" token="phaddw">(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and
packs the 16-bit signed results to the destination operand (first operand). (V)PHADDD adds two adjacent 32-bit
signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the
destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be
aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.
Note that these instructions can operate on either unsigned or signed (two's complement notation) integers;
however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected over-
flow conditions, software must control the ranges of the values operated on.
Legacy SSE instructions: Both operands can be MMX registers. The second source operand can be an MMX register
or a 64-bit memory location.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
destination register remain unchanged.
In 64-bit mode, use the REX prefix to access additional registers.</hint>
<hint page="0" header="Packed Horizontal Add" doc_id="x86_64" token="phaddd">(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and
packs the 16-bit signed results to the destination operand (first operand). (V)PHADDD adds two adjacent 32-bit
signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the
destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be
aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.
Note that these instructions can operate on either unsigned or signed (two's complement notation) integers;
however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected over-
flow conditions, software must control the ranges of the values operated on.
Legacy SSE instructions: Both operands can be MMX registers. The second source operand can be an MMX register
or a 64-bit memory location.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand can be an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM
destination register remain unchanged.
In 64-bit mode, use the REX prefix to access additional registers.</hint>
<hint page="0" header="Packed Horizontal Add and Saturate" doc_id="x86_64" token="phaddsw">(V)PHADDSW adds two adjacent signed 16-bit integers horizontally from the source and destination operands and
saturates the signed results; packs the signed, saturated 16-bit results to the destination operand (first operand)
When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a
general-protection exception (#GP) will be generated.
Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a
64-bit memory location.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
tion register remain unchanged.
In 64-bit mode, use the REX prefix to access additional registers.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
zeroed.
VEX.256 encoded version: The first source and destination operands are YMM registers. The second source
operand can be an YMM register or a 256-bit memory location.
Note: VEX.L must be 0, otherwise the instruction will #UD.</hint>
<hint page="0" header="Packed Horizontal Word Minimum" doc_id="x86_64" token="phminposuw">Determine the minimum unsigned word value in the source operand (second operand) and place the unsigned
word in the low word (bits 0-15) of the destination operand (first operand). The word index of the minimum value
is stored in bits 16-18 of the destination operand. The remaining upper bits of the destination are set to zero.
128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain
unchanged.
VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.vvvv is reserved
and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.</hint>
<hint page="0" header="Packed Horizontal Subtract" doc_id="x86_64" token="phsubw">(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the
most significant word from the least significant word of each pair in the source and destination operands, and packs
the signed 16-bit results to the destination operand (first operand). (V)PHSUBD performs horizontal subtraction on
each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least signifi-
cant doubleword of each pair, and packs the signed 32-bit result to the destination operand. When the source
operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection
exception (#GP) will be generated.
Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a
64-bit memory location.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
tion register remain unchanged.
In 64-bit mode, use the REX prefix to access additional registers.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
zeroed.</hint>
<hint page="0" header="Packed Horizontal Subtract" doc_id="x86_64" token="phsubd">(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the
most significant word from the least significant word of each pair in the source and destination operands, and packs
the signed 16-bit results to the destination operand (first operand). (V)PHSUBD performs horizontal subtraction on
each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least signifi-
cant doubleword of each pair, and packs the signed 32-bit result to the destination operand. When the source
operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection
exception (#GP) will be generated.
Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a
64-bit memory location.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
tion register remain unchanged.
In 64-bit mode, use the REX prefix to access additional registers.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
zeroed.</hint>
<hint page="0" header="Packed Horizontal Subtract and Saturate" doc_id="x86_64" token="phsubsw">(V)PHSUBSW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the
most significant word from the least significant word of each pair in the source and destination operands. The
signed, saturated 16-bit results are packed to the destination operand (first operand). When the source operand is
a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception
(#GP) will be generated.
Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or
a 64-bit memory location.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
tion register remain unchanged.
In 64-bit mode, use the REX prefix to access additional registers.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
zeroed.
VEX.256 encoded version: The first source and destination operands are YMM registers. The second source
operand can be an YMM register or a 256-bit memory location.
Note: VEX.L must be 0, otherwise the instruction will #UD.</hint>
<hint page="0" header="Insert Byte/Dword/Qword" doc_id="x86_64" token="pinsrb">Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand
(first operand) at the location specified with the count operand (third operand). (The other elements in the desti-
nation register are left untouched.) The source operand can be a general-purpose register or a memory location.
(When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destina-
tion operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte]
location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose regis-
ters.</hint>
<hint page="0" header="Insert Byte/Dword/Qword" doc_id="x86_64" token="pinsrd">Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand
(first operand) at the location specified with the count operand (third operand). (The other elements in the desti-
nation register are left untouched.) The source operand can be a general-purpose register or a memory location.
(When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destina-
tion operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte]
location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose regis-
ters.</hint>
<hint page="0" header="Insert Byte/Dword/Qword" doc_id="x86_64" token="pinsrq">Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand
(first operand) at the location specified with the count operand (third operand). (The other elements in the desti-
nation register are left untouched.) The source operand can be a general-purpose register or a memory location.
(When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destina-
tion operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte]
location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose regis-
ters.</hint>
<hint page="0" header="Insert Word" doc_id="x86_64" token="pinsrw">Copies a word from the source operand (second operand) and inserts it in the destination operand (first operand)
at the location specified with the count operand (third operand). (The other words in the destination register are
left untouched.) The source operand can be a general-purpose register or a 16-bit memory location. (When the
source operand is a general-purpose register, the low word of the register is copied.) The destination operand can
be an MMX technology register or an XMM register. The count operand is an 8-bit immediate. When specifying a
word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location;
for an XMM register, the 3 least-significant bits specify the location.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15, R8-15).
128-bit Legacy SSE version: Bits (VLMAX-1:128) of the corresponding YMM destination register remain
unchanged.
VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.L must be 0, other-
wise the instruction will #UD.
EVEX.128 encoded version: Bits (VLMAX-1:128) of the destination register are zeroed. EVEX.L'L must be 0, other-
wise the instruction will #UD.</hint>
<hint page="0" header="Multiply and Add Packed Signed and Unsigned Bytes" doc_id="x86_64" token="pmaddubsw">(V)PMADDUBSW multiplies vertically each unsigned byte of the destination operand (first operand) with the corre-
sponding signed byte of the source operand (second operand), producing intermediate signed 16-bit integers. Each
adjacent pair of signed words is added and the saturated result is packed to the destination operand. For example,
the lowest-order bytes (bits 7-0) in the source and destination operands are multiplied and the intermediate signed
word result is added with the corresponding intermediate result from the 2nd lowest-order bytes (bits 15-8) of the
operands; the sign-saturated result is stored in the lowest word of the destination register (15-0). The same oper-
ation is performed on the other pairs of adjacent bytes. Both operands can be MMX register or XMM registers. When
the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a
general-protection exception (#GP) will be generated.
In 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15.</hint>
<hint page="0" header="Multiply and Add Packed Integers" doc_id="x86_64" token="pmaddwd">Multiplies the individual signed words of the destination operand (first operand) by the corresponding signed words
of the source operand (second operand), producing temporary signed, doubleword results. The adjacent double-
word results are then summed and stored in the destination operand. For example, the corresponding low-order
words (15-0) and (31-16) in the source and destination operands are multiplied by one another and the double-
word results are added together and stored in the low doubleword of the destination register (31-0). The same
operation is performed on the other pairs of adjacent words. (Figure 4-11 shows this operation when using 64-bit
operands).</hint>
<hint page="0" header="Maximum of Packed Signed Integers" doc_id="x86_64" token="pmaxsb">Performs a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand
and the first source operand and returns the maximum value for each pair of integers to the destination operand.
Legacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location.
The destination operand can be an MMX technology register.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding YMM destina-
tion register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register are zeroed.
VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
first source and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corresponding destination
register are zeroed.
EVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is
a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a
32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.
EVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is
a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated
based on writemask k1.</hint>
<hint page="0" header="Maximum of Packed Signed Integers" doc_id="x86_64" token="pmaxsw">Performs a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand
and the first source operand and returns the maximum value for each pair of integers to the destination operand.
Legacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location.
The destination operand can be an MMX technology register.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding YMM destina-
tion register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register are zeroed.
VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
first source and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corresponding destination
register are zeroed.
EVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is
a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a
32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.
EVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is
a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated
based on writemask k1.</hint>
<hint page="0" header="Maximum of Packed Signed Integers" doc_id="x86_64" token="pmaxsd">Performs a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand
and the first source operand and returns the maximum value for each pair of integers to the destination operand.
Legacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location.
The destination operand can be an MMX technology register.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding YMM destina-
tion register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register are zeroed.
VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
first source and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corresponding destination
register are zeroed.
EVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is
a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a
32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.
EVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is
a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated
based on writemask k1.</hint>
<hint page="0" header="Maximum of Packed Signed Integers" doc_id="x86_64" token="pmaxsq">Performs a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand
and the first source operand and returns the maximum value for each pair of integers to the destination operand.
Legacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location.
The destination operand can be an MMX technology register.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding YMM destina-
tion register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register are zeroed.
VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
first source and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corresponding destination
register are zeroed.
EVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is
a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a
32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.
EVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is
a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated
based on writemask k1.</hint>
<hint page="0" header="Maximum of Packed Unsigned Integers" doc_id="x86_64" token="pmaxub"></hint>
<hint page="0" header="Maximum of Packed Unsigned Integers" doc_id="x86_64" token="pmaxuw"></hint>
<hint page="0" header="Maximum of Packed Unsigned Integers" doc_id="x86_64" token="pmaxud">Performs a SIMD compare of the packed unsigned dword or qword integers in the second source operand and the
first source operand and returns the maximum value for each pair of integers to the destination operand.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register are zeroed.
VEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register
or 256-bit memory location. Bits (MAX_VL-1:256) of the corresponding destination register are zeroed.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a
ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a
32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.</hint>
<hint page="0" header="Maximum of Packed Unsigned Integers" doc_id="x86_64" token="pmaxuq">Performs a SIMD compare of the packed unsigned dword or qword integers in the second source operand and the
first source operand and returns the maximum value for each pair of integers to the destination operand.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register are zeroed.
VEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register
or 256-bit memory location. Bits (MAX_VL-1:256) of the corresponding destination register are zeroed.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a
ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a
32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.</hint>
<hint page="0" header="Minimum of Packed Signed Integers" doc_id="x86_64" token="pminsb"></hint>
<hint page="0" header="Minimum of Packed Signed Integers" doc_id="x86_64" token="pminsw"></hint>
<hint page="0" header="Minimum of Packed Signed Integers" doc_id="x86_64" token="pminsd">Performs a SIMD compare of the packed signed dword or qword integers in the second source operand and the first
source operand and returns the minimum value for each pair of integers to the destination operand.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register are zeroed.
VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
first source and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corresponding destination
register are zeroed.</hint>
<hint page="0" header="Minimum of Packed Signed Integers" doc_id="x86_64" token="pminsq">Performs a SIMD compare of the packed signed dword or qword integers in the second source operand and the first
source operand and returns the minimum value for each pair of integers to the destination operand.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register are zeroed.
VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
first source and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corresponding destination
register are zeroed.</hint>
<hint page="0" header="Minimum of Packed Unsigned Integers" doc_id="x86_64" token="pminub"></hint>
<hint page="0" header="Minimum of Packed Unsigned Integers" doc_id="x86_64" token="pminuw"></hint>
<hint page="0" header="Minimum of Packed Unsigned Integers" doc_id="x86_64" token="pminud">Performs a SIMD compare of the packed unsigned dword/qword integers in the second source operand and the first
source operand and returns the minimum value for each pair of integers to the destination operand.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register are zeroed.
VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
first source and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corresponding destination
register are zeroed.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a
ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a
32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.</hint>
<hint page="0" header="Minimum of Packed Unsigned Integers" doc_id="x86_64" token="pminuq">Performs a SIMD compare of the packed unsigned dword/qword integers in the second source operand and the first
source operand and returns the minimum value for each pair of integers to the destination operand.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination
register are zeroed.
VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The
first source and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corresponding destination
register are zeroed.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a
ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a
32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.</hint>
<hint page="0" header="Move Byte Mask" doc_id="x86_64" token="pmovmskb">Creates a mask made up of the most significant bit of each byte of the source operand (second operand) and stores
the result in the low byte or word of the destination operand (first operand).
The byte mask is 8 bits for 64-bit source operand, 16 bits for 128-bit source operand and 32 bits for 256-bit source
operand. The destination operand is a general-purpose register.
In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R
prefix. The default operand size is 64-bit in 64-bit mode.
Legacy SSE version: The source operand is an MMX technology register.
128-bit Legacy SSE version: The source operand is an XMM register.
VEX.128 encoded version: The source operand is an XMM register.
VEX.256 encoded version: The source operand is a YMM register.
Note: VEX.vvvv is reserved and must be 1111b.</hint>
<hint page="0" header="Packed Move with Sign Extend" doc_id="x86_64" token="pmovsx">Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand
(second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the
destination operand.
128-bit Legacy SSE version: Bits (MAX_VL-1:128) of the corresponding destination register remain unchanged.
VEX.128 and EVEX.128 encoded versions: Bits (MAX_VL-1:128) of the corresponding destination register are
zeroed.
VEX.256 and EVEX.256 encoded versions: Bits (MAX_VL-1:256) of the corresponding destination register are
zeroed.
EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand
(second operand) are sign extended to word, dword or quadword integers and stored to the destination operand
under the writemask. The destination register is XMM, YMM or ZMM Register.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Packed Move with Zero Extend" doc_id="x86_64" token="pmovzx">Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the
source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed
signed bytes the destination operand.
128-bit Legacy SSE version: Bits (MAX_VL-1:128) of the corresponding destination register remain unchanged.
VEX.128 encoded version: Bits (MAX_VL-1:128) of the corresponding destination register are zeroed.
VEX.256 encoded version: Bits (MAX_VL-1:256) of the corresponding destination register are zeroed.
EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second
operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The
destination register is XMM, YMM or ZMM Register.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Multiply Packed Doubleword Integers" doc_id="x86_64" token="pmuldq">Multiplies packed signed doubleword integers in the even-numbered (zero-based reference) elements of the first
source operand with the packed signed doubleword integers in the corresponding elements of the second source
operand and stores packed signed quadword results in the destination operand.
128-bit Legacy SSE version: The input signed doubleword integers are taken from the even-numbered elements of
the source operands, i.e. the first (low) and third doubleword element. For 128-bit memory operands, 128 bits are
fetched from memory, but only the first and third doublewords are used in the computation. The first source
operand and the destination XMM operand is the same. The second source operand can be an XMM register or 128-
bit memory location. Bits (MAX_VL-1:128) of the corresponding destination register remain unchanged.
VEX.128 encoded version: The input signed doubleword integers are taken from the even-numbered elements of
the source operands, i.e., the first (low) and third doubleword element. For 128-bit memory operands, 128 bits are
fetched from memory, but only the first and third doublewords are used in the computation.The first source
operand and the destination operand are XMM registers. The second source operand can be an XMM register or
128-bit memory location. Bits (MAX_VL-1:128) of the corresponding destination register are zeroed.
VEX.256 encoded version: The input signed doubleword integers are taken from the even-numbered elements of
the source operands, i.e. the first, 3rd, 5th, 7th doubleword element. For 256-bit memory operands, 256 bits are
fetched from memory, but only the four even-numbered doublewords are used in the computation. The first source
operand and the destination operand are YMM registers. The second source operand can be a YMM register or 256-
bit memory location. Bits (MAX_VL-1:256) of the corresponding destination ZMM register are zeroed.</hint>
<hint page="0" header="Packed Multiply High with Round and Scale" doc_id="x86_64" token="pmulhrsw">PMULHRSW multiplies vertically each signed 16-bit integer from the destination operand (first operand) with the
corresponding signed 16-bit integer of the source operand (second operand), producing intermediate, signed 32-
bit integers. Each intermediate 32-bit integer is truncated to the 18 most significant bits. Rounding is always
performed by adding 1 to the least significant bit of the 18-bit intermediate result. The final result is obtained by
selecting the 16 bits immediately to the right of the most significant bit of each 18-bit intermediate result and
packed to the destination operand.
When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a
general-protection exception (#GP) will be generated.
In 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15 registers.
Legacy SSE version 64-bit operand: Both operands can be MMX registers. The second source operand is an MMX
register or a 64-bit memory location.</hint>
<hint page="0" header="Multiply Packed Unsigned Integers and Store High Result" doc_id="x86_64" token="pmulhuw">Performs a SIMD unsigned multiply of the packed unsigned word integers in the destination operand (first operand)
and the source operand (second operand), and stores the high 16 bits of each 32-bit intermediate results in the
destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory
location. The destination operand is an MMX technology register.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
tion register remain unchanged.</hint>
<hint page="0" header="Multiply Packed Signed Integers and Store High Result" doc_id="x86_64" token="pmulhw">Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and
the source operand (second operand), and stores the high 16 bits of each intermediate 32-bit result in the destina-
tion operand. (Figure 4-12 shows this operation when using 64-bit operands.)
n 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory
location. The destination operand is an MMX technology register.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
tion register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
zeroed. VEX.L must be 0, otherwise the instruction will #UD.</hint>
<hint page="0" header="Multiply Packed Integers and Store Low Result" doc_id="x86_64" token="pmulld">Performs a SIMD signed multiply of the packed signed dword/qword integers from each element of the first source
operand with the corresponding element in the second source operand. The low 32/64 bits of each 64/128-bit
intermediate results are stored to the destination operand.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding ZMM destina-
tion register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding ZMM register
are zeroed.
VEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register
or 256-bit memory location. Bits (MAX_VL-1:256) of the corresponding destination ZMM register are zeroed.</hint>
<hint page="0" header="Multiply Packed Integers and Store Low Result" doc_id="x86_64" token="pmullq">Performs a SIMD signed multiply of the packed signed dword/qword integers from each element of the first source
operand with the corresponding element in the second source operand. The low 32/64 bits of each 64/128-bit
intermediate results are stored to the destination operand.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding ZMM destina-
tion register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (MAX_VL-1:128) of the corresponding ZMM register
are zeroed.
VEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register
or 256-bit memory location. Bits (MAX_VL-1:256) of the corresponding destination ZMM register are zeroed.</hint>
<hint page="0" header="Multiply Packed Signed Integers and Store Low Result" doc_id="x86_64" token="pmullw">Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and
the source operand (second operand), and stores the low 16 bits of each intermediate 32-bit result in the destina-
tion operand. (Figure 4-12 shows this operation when using 64-bit operands.)
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory
location. The destination operand is an MMX technology register.
128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destina-
tion register remain unchanged.
VEX.128 encoded version: The first source and destination operands are XMM registers. The second source
operand is an XMM register or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are
zeroed. VEX.L must be 0, otherwise the instruction will #UD.</hint>
<hint page="0" header="Multiply Packed Unsigned Doubleword Integers" doc_id="x86_64" token="pmuludq">Multiplies the first operand (destination operand) by the second operand (source operand) and stores the result in
the destination operand.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE version 64-bit operand: The source operand can be an unsigned doubleword integer stored in the low
doubleword of an MMX technology register or a 64-bit memory location. The destination operand can be an
unsigned doubleword integer stored in the low doubleword an MMX technology register. The result is an unsigned</hint>
<hint page="0" header="Pop a Value from the Stack" doc_id="x86_64" token="pop">Loads the value from the top of the stack to the location specified with the destination operand (or explicit opcode)
and then increments the stack pointer. The destination operand can be a general-purpose register, memory loca-
tion, or segment register.
Address and operand sizes are determined and used as follows:
.     Address size. The D flag in the current code-segment descriptor determines the default address size; it may be
      overridden by an instruction prefix (67H).</hint>
<hint page="0" header="Pop All General-Purpose Registers" doc_id="x86_64" token="popa">Pops doublewords (POPAD) or words (POPA) from the stack into the general-purpose registers. The registers are
loaded in the following order: EDI, ESI, EBP, EBX, EDX, ECX, and EAX (if the operand-size attribute is 32) and DI,
SI, BP, BX, DX, CX, and AX (if the operand-size attribute is 16). (These instructions reverse the operation of the
PUSHA/PUSHAD instructions.) The value on the stack for the ESP or SP register is ignored. Instead, the ESP or SP
register is incremented after each register is loaded.
The POPA (pop all) and POPAD (pop all double) mnemonics reference the same opcode. The POPA instruction is
intended for use when the operand-size attribute is 16 and the POPAD instruction for when the operand-size attri-
bute is 32. Some assemblers may force the operand size to 16 when POPA is used and to 32 when POPAD is used
(using the operand-size override prefix [66H] if necessary). Others may treat these mnemonics as synonyms
(POPA/POPAD) and use the current setting of the operand-size attribute to determine the size of values to be
popped from the stack, regardless of the mnemonic used. (The D flag in the current code segment's segment
descriptor determines the operand-size attribute.)
This instruction executes as described in non-64-bit modes. It is not valid in 64-bit mode.</hint>
<hint page="0" header="Pop All General-Purpose Registers" doc_id="x86_64" token="popad">Pops doublewords (POPAD) or words (POPA) from the stack into the general-purpose registers. The registers are
loaded in the following order: EDI, ESI, EBP, EBX, EDX, ECX, and EAX (if the operand-size attribute is 32) and DI,
SI, BP, BX, DX, CX, and AX (if the operand-size attribute is 16). (These instructions reverse the operation of the
PUSHA/PUSHAD instructions.) The value on the stack for the ESP or SP register is ignored. Instead, the ESP or SP
register is incremented after each register is loaded.
The POPA (pop all) and POPAD (pop all double) mnemonics reference the same opcode. The POPA instruction is
intended for use when the operand-size attribute is 16 and the POPAD instruction for when the operand-size attri-
bute is 32. Some assemblers may force the operand size to 16 when POPA is used and to 32 when POPAD is used
(using the operand-size override prefix [66H] if necessary). Others may treat these mnemonics as synonyms
(POPA/POPAD) and use the current setting of the operand-size attribute to determine the size of values to be
popped from the stack, regardless of the mnemonic used. (The D flag in the current code segment's segment
descriptor determines the operand-size attribute.)
This instruction executes as described in non-64-bit modes. It is not valid in 64-bit mode.</hint>
<hint page="0" header="Return the Count of Number of Bits Set to 1" doc_id="x86_64" token="popcnt">This instruction calculates the number of bits set to 1 in the second operand (source) and returns the count in the
first operand (a destination register).</hint>
<hint page="0" header="Pop Stack into EFLAGS Register" doc_id="x86_64" token="popf">Pops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the
value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and
stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the
operation of the PUSHF/PUSHFD instructions.
The POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction
is intended for use when the operand-size attribute is 16; the POPFD instruction is intended for use when the
operand-size attribute is 32. Some assemblers may force the operand size to 16 for POPF and to 32 for POPFD.
Others may treat the mnemonics as synonyms (POPF/POPFD) and use the setting of the operand-size attribute to
determine the size of values to pop from the stack.
The effect of POPF/POPFD on the EFLAGS register changes, depending on the mode of operation. See the Table
4-15 and key below for details.
When operating in protected, compatibility, or 64-bit mode at privilege level 0 (or in real-address mode, the equiv-
alent to privilege level 0), all non-reserved flags in the EFLAGS register except RF1, VIP, VIF, and VM may be modi-
fied. VIP, VIF and VM remain unaffected.
When operating in protected, compatibility, or 64-bit mode with a privilege level greater than 0, but less than or
equal to IOPL, all flags can be modified except the IOPL field and RF1, IF, VIP, VIF, and VM; these remain unaffected.
The AC and ID flags can only be modified if the operand-size attribute is 32. The interrupt flag (IF) is altered only
when executing at a level at least as privileged as the IOPL. If a POPF/POPFD instruction is executed with insuffi-
cient privilege, an exception does not occur but privileged bits do not change.
When operating in virtual-8086 mode (EFLAGS.VM = 1) without the virtual-8086 mode extensions (CR4.VME = 0),
the POPF/POPFD instructions can be used only if IOPL = 3; otherwise, a general-protection exception (#GP) occurs.
If the virtual-8086 mode extensions are enabled (CR4.VME = 1), POPF (but not POPFD) can be executed in virtual-
8086 mode with IOPL &lt; 3.
In 64-bit mode, the mnemonic assigned is POPFQ (note that the 32-bit operand is not encodable). POPFQ pops 64
bits from the stack. Reserved bits of RFLAGS (including the upper 32 bits of RFLAGS) are not affected.
See Chapter 3 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for more informa-
tion about the EFLAGS registers.</hint>
<hint page="0" header="Pop Stack into EFLAGS Register" doc_id="x86_64" token="popfd">Pops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the
value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and
stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the
operation of the PUSHF/PUSHFD instructions.
The POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction
is intended for use when the operand-size attribute is 16; the POPFD instruction is intended for use when the
operand-size attribute is 32. Some assemblers may force the operand size to 16 for POPF and to 32 for POPFD.
Others may treat the mnemonics as synonyms (POPF/POPFD) and use the setting of the operand-size attribute to
determine the size of values to pop from the stack.
The effect of POPF/POPFD on the EFLAGS register changes, depending on the mode of operation. See the Table
4-15 and key below for details.
When operating in protected, compatibility, or 64-bit mode at privilege level 0 (or in real-address mode, the equiv-
alent to privilege level 0), all non-reserved flags in the EFLAGS register except RF1, VIP, VIF, and VM may be modi-
fied. VIP, VIF and VM remain unaffected.
When operating in protected, compatibility, or 64-bit mode with a privilege level greater than 0, but less than or
equal to IOPL, all flags can be modified except the IOPL field and RF1, IF, VIP, VIF, and VM; these remain unaffected.
The AC and ID flags can only be modified if the operand-size attribute is 32. The interrupt flag (IF) is altered only
when executing at a level at least as privileged as the IOPL. If a POPF/POPFD instruction is executed with insuffi-
cient privilege, an exception does not occur but privileged bits do not change.
When operating in virtual-8086 mode (EFLAGS.VM = 1) without the virtual-8086 mode extensions (CR4.VME = 0),
the POPF/POPFD instructions can be used only if IOPL = 3; otherwise, a general-protection exception (#GP) occurs.
If the virtual-8086 mode extensions are enabled (CR4.VME = 1), POPF (but not POPFD) can be executed in virtual-
8086 mode with IOPL &lt; 3.
In 64-bit mode, the mnemonic assigned is POPFQ (note that the 32-bit operand is not encodable). POPFQ pops 64
bits from the stack. Reserved bits of RFLAGS (including the upper 32 bits of RFLAGS) are not affected.
See Chapter 3 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for more informa-
tion about the EFLAGS registers.</hint>
<hint page="0" header="Pop Stack into EFLAGS Register" doc_id="x86_64" token="popfq">Pops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the
value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and
stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the
operation of the PUSHF/PUSHFD instructions.
The POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction
is intended for use when the operand-size attribute is 16; the POPFD instruction is intended for use when the
operand-size attribute is 32. Some assemblers may force the operand size to 16 for POPF and to 32 for POPFD.
Others may treat the mnemonics as synonyms (POPF/POPFD) and use the setting of the operand-size attribute to
determine the size of values to pop from the stack.
The effect of POPF/POPFD on the EFLAGS register changes, depending on the mode of operation. See the Table
4-15 and key below for details.
When operating in protected, compatibility, or 64-bit mode at privilege level 0 (or in real-address mode, the equiv-
alent to privilege level 0), all non-reserved flags in the EFLAGS register except RF1, VIP, VIF, and VM may be modi-
fied. VIP, VIF and VM remain unaffected.
When operating in protected, compatibility, or 64-bit mode with a privilege level greater than 0, but less than or
equal to IOPL, all flags can be modified except the IOPL field and RF1, IF, VIP, VIF, and VM; these remain unaffected.
The AC and ID flags can only be modified if the operand-size attribute is 32. The interrupt flag (IF) is altered only
when executing at a level at least as privileged as the IOPL. If a POPF/POPFD instruction is executed with insuffi-
cient privilege, an exception does not occur but privileged bits do not change.
When operating in virtual-8086 mode (EFLAGS.VM = 1) without the virtual-8086 mode extensions (CR4.VME = 0),
the POPF/POPFD instructions can be used only if IOPL = 3; otherwise, a general-protection exception (#GP) occurs.
If the virtual-8086 mode extensions are enabled (CR4.VME = 1), POPF (but not POPFD) can be executed in virtual-
8086 mode with IOPL &lt; 3.
In 64-bit mode, the mnemonic assigned is POPFQ (note that the 32-bit operand is not encodable). POPFQ pops 64
bits from the stack. Reserved bits of RFLAGS (including the upper 32 bits of RFLAGS) are not affected.
See Chapter 3 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for more informa-
tion about the EFLAGS registers.</hint>
<hint page="0" header="Bitwise Logical OR" doc_id="x86_64" token="por">Performs a bitwise logical OR operation on the source operand (second operand) and the destination operand (first
operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the
corresponding bits of the first and second operands are 1; otherwise, it is set to 0.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).</hint>
<hint page="0" header="Prefetch Data Into Caches" doc_id="x86_64" token="prefetchh">Fetches the line of data from memory that contains the byte specified with the source operand to a location in the
cache hierarchy specified by a locality hint:
.   T0 (temporal data)-prefetch data into all levels of the cache hierarchy.
.   T1 (temporal data with respect to first level cache misses)-prefetch data into level 2 cache and higher.
.   T2 (temporal data with respect to second level cache misses)-prefetch data into level 3 cache and higher, or
    an implementation-specific choice.
.   NTA (non-temporal data with respect to all cache levels)-prefetch data into non-temporal cache structure and
    into a location close to the processor, minimizing cache pollution.
The source operand is a byte memory location. (The locality hints are encoded into the machine level instruction
using bits 3 through 5 of the ModR/M byte.)
If the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement
occurs. Prefetches from uncacheable or WC memory are ignored.
The PREFETCHh instruction is merely a hint and does not affect program behavior. If executed, this instruction
moves data closer to the processor in anticipation of future use.
The implementation of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a
processor implementation. The amount of data prefetched is also processor implementation-dependent. It will,
however, be a minimum of 32 bytes. Additional details of the implementation-dependent locality hints are
described in Section 7.4 of Intel 64 and IA-32 Architectures Optimization Reference Manual.
It should be noted that processors are free to speculatively fetch and cache data from system memory regions that
are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). A
PREFETCHh instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur
at any time and is not tied to instruction execution, a PREFETCHh instruction is not ordered with respect to the
fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHh instruction is also
unordered with respect to CLFLUSH and CLFLUSHOPT instructions, other PREFETCHh instructions, or any other
general instruction. It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Prefetch Data into Caches in Anticipation of a Write" doc_id="x86_64" token="prefetchw">Fetches the cache line of data from memory that contains the byte specified with the source operand to a location
in the 1st or 2nd level cache and invalidates other cached instances of the line.
The source operand is a byte memory location. If the line selected is already present in the lowest level cache and
is already in an exclusively owned state, no data movement occurs. Prefetches from non-writeback memory are
ignored.
The PREFETCHW instruction is merely a hint and does not affect program behavior. If executed, this instruction
moves data closer to the processor and invalidates other cached copies in anticipation of the line being written to
in the future.
The characteristic of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a
processor implementation. The amount of data prefetched is also processor implementation-dependent. It will,
however, be a minimum of 32 bytes. Additional details of the implementation-dependent locality hints are
described in Section 7.4 of Intel 64 and IA-32 Architectures Optimization Reference Manual.
It should be noted that processors are free to speculatively fetch and cache data with exclusive ownership from
system memory regions that permit such accesses (that is, the WB memory type). A PREFETCHW instruction is
considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not
tied to instruction execution, a PREFETCHW instruction is not ordered with respect to the fence instructions
(MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHW instruction is also unordered with
respect to CLFLUSH and CLFLUSHOPT instructions, other PREFETCHW instructions, or any other general instruction
It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Prefetch Vector Data Into Caches with Intent to Write and T1 Hint" doc_id="x86_64" token="prefetchwt1">Fetches the line of data from memory that contains the byte specified with the source operand to a location in the
cache hierarchy specified by an intent to write hint (so that data is brought into 'Exclusive' state via a request for
ownership) and a locality hint:
. T1 (temporal data with respect to first level cache)-prefetch data into the second level cache.
The source operand is a byte memory location. (The locality hints are encoded into the machine level instruction
using bits 3 through 5 of the ModR/M byte. Use of any ModR/M value other than the specified ones will lead to
unpredictable behavior.)
If the line selected is already present in the cache hierarchy at a level closer to the processor, no data movement
occurs. Prefetches from uncacheable or WC memory are ignored.
The PREFETCHh instruction is merely a hint and does not affect program behavior. If executed, this instruction
moves data closer to the processor in anticipation of future use.
The implementation of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a
processor implementation. The amount of data prefetched is also processor implementation-dependent. It will,
however, be a minimum of 32 bytes.
It should be noted that processors are free to speculatively fetch and cache data from system memory regions that
are assigned a memory-type that permits speculative reads (that is, the WB, WC, and WT memory types). A
PREFETCHh instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur
at any time and is not tied to instruction execution, a PREFETCHh instruction is not ordered with respect to the
fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHh instruction is also
unordered with respect to CLFLUSH and CLFLUSHOPT instructions, other PREFETCHh instructions, or any other
general instruction. It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Compute Sum of Absolute Differences" doc_id="x86_64" token="psadbw">Computes the absolute value of the difference of 8 unsigned byte integers from the source operand (second</hint>
<hint page="0" header="Packed Shuffle Bytes" doc_id="x86_64" token="pshufb">PSHUFB performs in-place shuffles of bytes in the destination operand (the first operand) according to the shuffle
control mask in the source operand (the second operand). The instruction permutes the data in the destination
operand, leaving the shuffle mask unaffected. If the most significant bit (bit[7]) of each byte of the shuffle control
mask is set, then constant zero is written in the result byte. Each byte in the shuffle control mask forms an index
to permute the corresponding byte in the destination operand. The value of each index is the least significant 4 bits
(128-bit operation) or 3 bits (64-bit operation) of the shuffle control byte. When the source operand is a 128-bit
memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will
be generated.
In 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15 registers.
Legacy SSE version 64-bit operand: Both operands can be MMX registers.
128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
1:128) of the corresponding YMM destination register remain unchanged.
VEX.128 encoded version: The destination operand is the first operand, the first source operand is the second
operand, the second source operand is the third operand. Bits (VLMAX-1:128) of the destination YMM register are
zeroed.
VEX.256 encoded version: Bits (255:128) of the destination YMM register stores the 16-byte shuffle result of the
upper 16 bytes of the first source operand, using the upper 16-bytes of the second source operand as control mask.</hint>
<hint page="0" header="Shuffle Packed Doublewords" doc_id="x86_64" token="pshufd">Copies doublewords from source operand (second operand) and inserts them in the destination operand (first
operand) at the locations selected with the order operand (third operand). Figure 4-16 shows the operation of the
256-bit VPSHUFD instruction and the encoding of the order operand. Each 2-bit field in the order operand selects
the contents of one doubleword location within a 128-bit lane and copy to the target element in the destination
operand. For example, bits 0 and 1 of the order operand targets the first doubleword element in the low and high
128-bit lane of the destination operand for 256-bit VPSHUFD. The encoded value of bits 1:0 of the order operand
(see the field encoding in Figure 4-16) determines which doubleword element (from the respective 128-bit lane) of
the source operand will be copied to doubleword 0 of the destination operand.
For 128-bit operation, only the low 128-bit lane are operative. The source operand can be an XMM register or a
128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate.
Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword
location in the destination operand.</hint>
<hint page="0" header="Shuffle Packed High Words" doc_id="x86_64" token="pshufhw">Copies words from the high quadword of a 128-bit lane of the source operand and inserts them in the high quad-
word of the destination operand at word locations (of the respective lane) selected with the immediate operand.
This 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illus-
trated in Figure 4-16. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate
operand selects the contents of one word location in the high quadword of the destination operand. The binary
encodings of the immediate operand fields select words (0, 1, 2 or 3, 4) from the high quadword of the source
operand to be copied to the destination operand. The low quadword of the source operand is copied to the low
quadword of the destination operand, for each 128-bit lane.
Note that this instruction permits a word in the high quadword of the source operand to be copied to more than one
word location in the high quadword of the destination operand.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM
register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain
unchanged.
VEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register
or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed. VEX.vvvv is
reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.
VEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register
or a 256-bit memory location.</hint>
<hint page="0" header="Shuffle Packed Low Words" doc_id="x86_64" token="pshuflw">Copies words from the low quadword of a 128-bit lane of the source operand and inserts them in the low quadword
of the destination operand at word locations (of the respective lane) selected with the immediate operand. The
256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illustrated
in Figure 4-16. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate
operand selects the contents of one word location in the low quadword of the destination operand. The binary
encodings of the immediate operand fields select words (0, 1, 2 or 3) from the low quadword of the source operand
to be copied to the destination operand. The high quadword of the source operand is copied to the high quadword
of the destination operand, for each 128-bit lane.
Note that this instruction permits a word in the low quadword of the source operand to be copied to more than one
word location in the low quadword of the destination operand.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM
register or a 128-bit memory location. Bits (VLMAX-1:128) of the corresponding YMM destination register remain
unchanged.
VEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register
or a 128-bit memory location. Bits (VLMAX-1:128) of the destination YMM register are zeroed.
VEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register
or a 256-bit memory location.
EVEX encoded version: The destination operand is a ZMM/YMM/XMM registers. The source operand can be a
ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the
writemask.</hint>
<hint page="0" header="Shuffle Packed Words" doc_id="x86_64" token="pshufw">Copies words from the source operand (second operand) and inserts them in the destination operand (first
operand) at word locations selected with the order operand (third operand). This operation is similar to the opera-
tion used by the PSHUFD instruction, which is illustrated in Figure 4-16. For the PSHUFW instruction, each 2-bit
field in the order operand selects the contents of one word location in the destination operand. The encodings of the
order operand fields select words from the source operand to be copied to the destination operand.
The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an
MMX technology register. The order operand is an 8-bit immediate. Note that this instruction permits a word in the
source operand to be copied to more than one word location in the destination operand.
In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers
(XMM8-XMM15).</hint>
<hint page="0" header="Packed SIGN" doc_id="x86_64" token="psignb"></hint>
<hint page="0" header="Packed SIGN" doc_id="x86_64" token="psignw"></hint>
<hint page="0" header="Packed SIGN" doc_id="x86_64" token="psignd"></hint>
<hint page="0" header="Shift Double Quadword Left Logical" doc_id="x86_64" token="pslldq">Shifts the destination operand (first operand) to the left by the number of bytes specified in the count operand
(second operand). The empty low-order bytes are cleared (set to all 0s). If the value specified by the count
operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.
128-bit Legacy SSE version: The source and destination operands are the same. Bits (VLMAX-1:128) of the corre-
sponding YMM destination register remain unchanged.
VEX.128 encoded version: The source and destination operands are XMM registers. Bits (VLMAX-1:128) of the
destination YMM register are zeroed.
VEX.256 encoded version: The source operand is YMM register. The destination operand is an YMM register. Bits
(MAX_VL-1:256) of the corresponding ZMM register are zeroed. The count operand applies to both the low and
high 128-bit lanes.
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location.
The destination operand is a ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes.</hint>
<hint page="0" header="Shift Packed Data Left Logical" doc_id="x86_64" token="psllw">Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first
operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data
elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count
operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand
is set to all 0s. Figure 4-17 gives an example of shifting words in a 64-bit operand.</hint>
<hint page="0" header="Shift Packed Data Left Logical" doc_id="x86_64" token="pslld">Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first
operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data
elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count
operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand
is set to all 0s. Figure 4-17 gives an example of shifting words in a 64-bit operand.</hint>
<hint page="0" header="Shift Packed Data Left Logical" doc_id="x86_64" token="psllq">Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first
operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data
elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count
operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand
is set to all 0s. Figure 4-17 gives an example of shifting words in a 64-bit operand.</hint>
<hint page="0" header="Shift Packed Data Right Arithmetic" doc_id="x86_64" token="psraw">Shifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand (first
operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data
elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data
element. If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for
quadwords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-18
gives an example of shifting words in a 64-bit operand.)</hint>
<hint page="0" header="Shift Packed Data Right Arithmetic" doc_id="x86_64" token="psrad">Shifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand (first
operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data
elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data
element. If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for
quadwords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-18
gives an example of shifting words in a 64-bit operand.)</hint>
<hint page="0" header="Shift Packed Data Right Arithmetic" doc_id="x86_64" token="psraq">Shifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand (first
operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data
elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data
element. If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for
quadwords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-18
gives an example of shifting words in a 64-bit operand.)</hint>
<hint page="0" header="Shift Double Quadword Right Logical" doc_id="x86_64" token="psrldq">Shifts the destination operand (first operand) to the right by the number of bytes specified in the count operand
(second operand). The empty high-order bytes are cleared (set to all 0s). If the value specified by the count
operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
128-bit Legacy SSE version: The source and destination operands are the same. Bits (VLMAX-1:128) of the corre-
sponding YMM destination register remain unchanged.
VEX.128 encoded version: The source and destination operands are XMM registers. Bits (VLMAX-1:128) of the
destination YMM register are zeroed.
VEX.256 encoded version: The source operand is a YMM register. The destination operand is a YMM register. The
count operand applies to both the low and high 128-bit lanes.
VEX.256 encoded version: The source operand is YMM register. The destination operand is an YMM register. Bits
(MAX_VL-1:256) of the corresponding ZMM register are zeroed. The count operand applies to both the low and
high 128-bit lanes.
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location.
The destination operand is a ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes.
Note: VEX.vvvv/EVEX.vvvv encodes the destination register.</hint>
<hint page="0" header="Shift Packed Data Right Logical" doc_id="x86_64" token="psrlw">Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first
operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data
elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count
operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand
is set to all 0s. Figure 4-19 gives an example of shifting words in a 64-bit operand.
Note that only the low 64-bits of a 128-bit count operand are checked to compute the count.</hint>
<hint page="0" header="Shift Packed Data Right Logical" doc_id="x86_64" token="psrld">Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first
operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data
elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count
operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand
is set to all 0s. Figure 4-19 gives an example of shifting words in a 64-bit operand.
Note that only the low 64-bits of a 128-bit count operand are checked to compute the count.</hint>
<hint page="0" header="Shift Packed Data Right Logical" doc_id="x86_64" token="psrlq">Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first
operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data
elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count
operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand
is set to all 0s. Figure 4-19 gives an example of shifting words in a 64-bit operand.
Note that only the low 64-bits of a 128-bit count operand are checked to compute the count.</hint>
<hint page="0" header="Subtract Packed Integers" doc_id="x86_64" token="psubb">Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers
of the destination operand (first operand), and stores the packed integer results in the destination operand. See
Figure 9-4 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of
a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.
The (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be
represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.
The (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be
represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.
The (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small
to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination
element.
Note that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's
complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow
and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which
it operates.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source
operand can be either an MMX technology register or a 64-bit memory location.
128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-
nation register remain unchanged.
VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register
are zeroed.</hint>
<hint page="0" header="Subtract Packed Integers" doc_id="x86_64" token="psubw">Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers
of the destination operand (first operand), and stores the packed integer results in the destination operand. See
Figure 9-4 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of
a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.
The (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be
represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.
The (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be
represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.
The (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small
to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination
element.
Note that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's
complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow
and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which
it operates.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source
operand can be either an MMX technology register or a 64-bit memory location.
128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-
nation register remain unchanged.
VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register
are zeroed.</hint>
<hint page="0" header="Subtract Packed Integers" doc_id="x86_64" token="psubd">Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers
of the destination operand (first operand), and stores the packed integer results in the destination operand. See
Figure 9-4 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of
a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.
The (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be
represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.
The (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be
represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.
The (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small
to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination
element.
Note that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's
complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow
and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which
it operates.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source
operand can be either an MMX technology register or a 64-bit memory location.
128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-
nation register remain unchanged.
VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register
are zeroed.</hint>
<hint page="0" header="Subtract Packed Quadword Integers" doc_id="x86_64" token="psubq">Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result
in the destination operand. When packed quadword operands are used, a SIMD subtract is performed. When a
quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64
bits are written to the destination element (that is, the carry is ignored).
Note that the (V)PSUBQ instruction can operate on either unsigned or signed (two's complement notation) inte-
gers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected
overflow conditions, software must control the ranges of the values upon which it operates.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE version 64-bit operand: The source operand can be a quadword integer stored in an MMX technology
register or a 64-bit memory location.
128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-
nation register remain unchanged.</hint>
<hint page="0" header="Subtract Packed Signed Integers with Signed Saturation" doc_id="x86_64" token="psubsb">Performs a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed
signed integers of the destination operand (first operand), and stores the packed integer results in the destination
operand. See Figure 9-4 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an
illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following para-
graphs.
The (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the
range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H,
respectively, is written to the destination operand.
The (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the
range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or
8000H, respectively, is written to the destination operand.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source
operand can be either an MMX technology register or a 64-bit memory location.
128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-
nation register remain unchanged.
VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register
are zeroed.
VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first
source operand and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corresponding ZMM
register are zeroed.
EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory
location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is condi-
tionally updated with writemask k1.</hint>
<hint page="0" header="Subtract Packed Signed Integers with Signed Saturation" doc_id="x86_64" token="psubsw">Performs a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed
signed integers of the destination operand (first operand), and stores the packed integer results in the destination
operand. See Figure 9-4 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, for an
illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following para-
graphs.
The (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the
range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H,
respectively, is written to the destination operand.
The (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the
range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or
8000H, respectively, is written to the destination operand.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source
operand can be either an MMX technology register or a 64-bit memory location.
128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-
nation register remain unchanged.
VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register
are zeroed.
VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first
source operand and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corresponding ZMM
register are zeroed.
EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory
location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is condi-
tionally updated with writemask k1.</hint>
<hint page="0" header="Subtract Packed Unsigned Integers with Unsigned Saturation" doc_id="x86_64" token="psubusb">Performs a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the
packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer
results in the destination operand. See Figure 9-4 in the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as
described in the following paragraphs.
These instructions can operate on either 64-bit or 128-bit operands.
The (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than
zero, the saturated value of 00H is written to the destination operand.
The (V)PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than
zero, the saturated value of 0000H is written to the destination operand.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source
operand can be either an MMX technology register or a 64-bit memory location.
128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-
nation register remain unchanged.
VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register
are zeroed.
VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first
source operand and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corresponding ZMM
register are zeroed.
EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory
location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is condi-
tionally updated with writemask k1.</hint>
<hint page="0" header="Subtract Packed Unsigned Integers with Unsigned Saturation" doc_id="x86_64" token="psubusw">Performs a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the
packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer
results in the destination operand. See Figure 9-4 in the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as
described in the following paragraphs.
These instructions can operate on either 64-bit or 128-bit operands.
The (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than
zero, the saturated value of 00H is written to the destination operand.
The (V)PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than
zero, the saturated value of 0000H is written to the destination operand.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source
operand can be either an MMX technology register or a 64-bit memory location.
128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM desti-
nation register remain unchanged.
VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first
source operand and destination operands are XMM registers. Bits (VLMAX-1:128) of the destination YMM register
are zeroed.
VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first
source operand and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corresponding ZMM
register are zeroed.
EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory
location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is condi-
tionally updated with writemask k1.</hint>
<hint page="0" header="Logical Compare" doc_id="x86_64" token="ptest">PTEST and VPTEST set the ZF flag if all bits in the result are 0 of the bitwise AND of the first source operand (first
operand) and the second source operand (second operand). VPTEST sets the CF flag if all bits in the result are 0 of
the bitwise AND of the second source operand (second operand) and the logical NOT of the destination operand.
The first source register is specified by the ModR/M reg field.
128-bit versions: The first source register is an XMM register. The second source register can be an XMM register
or a 128-bit memory location. The destination register is not modified.
VEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM
register or a 256-bit memory location. The destination register is not modified.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Write Data to a Processor Trace Packet" doc_id="x86_64" token="ptwrite">This instruction reads data in the source operand and sends it to the Intel Processor Trace hardware to be encoded
in a PTW packet if TriggerEn, ContextEn, FilterEn, and PTWEn are all set to 1. For more details on these values, see
Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3C, Section 36.2.3, "Power Event
Tracing". The size of data is 64-bit if using REX.W in 64-bit mode, otherwise 32-bits of data are copied from the
source operand.
Note: The instruction will #UD if prefix 66H is used.</hint>
<hint page="0" header="Unpack High Data" doc_id="x86_64" token="punpckhbw">Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destina-
tion operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows
the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.</hint>
<hint page="0" header="Unpack High Data" doc_id="x86_64" token="punpckhwd">Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destina-
tion operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows
the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.</hint>
<hint page="0" header="Unpack High Data" doc_id="x86_64" token="punpckhdq">Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destina-
tion operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows
the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.</hint>
<hint page="0" header="Unpack High Data" doc_id="x86_64" token="punpckhqdq">Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destina-
tion operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows
the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.</hint>
<hint page="0" header="Unpack Low Data" doc_id="x86_64" token="punpcklbw">Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destina-
tion operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22
shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.</hint>
<hint page="0" header="Unpack Low Data" doc_id="x86_64" token="punpcklwd">Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destina-
tion operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22
shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.</hint>
<hint page="0" header="Unpack Low Data" doc_id="x86_64" token="punpckldq">Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destina-
tion operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22
shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.</hint>
<hint page="0" header="Unpack Low Data" doc_id="x86_64" token="punpcklqdq">Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destina-
tion operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22
shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.</hint>
<hint page="0" header="Push Word, Doubleword or Quadword Onto the Stack" doc_id="x86_64" token="push">Decrements the stack pointer and then stores the source operand on the top of the stack. Address and operand
sizes are determined and used as follows:
.     Address size. The D flag in the current code-segment descriptor determines the default address size; it may be
      overridden by an instruction prefix (67H).
      The address size is used only when referencing a source operand in memory.
.     Operand size. The D flag in the current code-segment descriptor determines the default operand size; it may
      be overridden by instruction prefixes (66H or REX.W).
      The operand size (16, 32, or 64 bits) determines the amount by which the stack pointer is decremented (2, 4
      or 8).
      If the source operand is an immediate of size less than the operand size, a sign-extended value is pushed on
      the stack. If the source operand is a segment register (16 bits) and the operand size is 64-bits, a zero-
      extended value is pushed on the stack; if the operand size is 32-bits, either a zero-extended value is pushed
      on the stack or the segment selector is written on the stack using a 16-bit move. For the last case, all recent
      Core and Atom processors perform a 16-bit move, leaving the upper portion of the stack location unmodified.
.     Stack-address size. Outside of 64-bit mode, the B flag in the current stack-segment descriptor determines the
      size of the stack pointer (16 or 32 bits); in 64-bit mode, the size of the stack pointer is always 64 bits.</hint>
<hint page="0" header="Push All General-Purpose Registers" doc_id="x86_64" token="pusha">Pushes the contents of the general-purpose registers onto the stack. The registers are stored on the stack in the
following order: EAX, ECX, EDX, EBX, ESP (original value), EBP, ESI, and EDI (if the current operand-size attribute
is 32) and AX, CX, DX, BX, SP (original value), BP, SI, and DI (if the operand-size attribute is 16). These instruc-
tions perform the reverse operation of the POPA/POPAD instructions. The value pushed for the ESP or SP register
is its value before prior to pushing the first register (see the "Operation" section below).
The PUSHA (push all) and PUSHAD (push all double) mnemonics reference the same opcode. The PUSHA instruc-
tion is intended for use when the operand-size attribute is 16 and the PUSHAD instruction for when the operand-
size attribute is 32. Some assemblers may force the operand size to 16 when PUSHA is used and to 32 when
PUSHAD is used. Others may treat these mnemonics as synonyms (PUSHA/PUSHAD) and use the current setting
of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the
mnemonic used.
In the real-address mode, if the ESP or SP register is 1, 3, or 5 when PUSHA/PUSHAD executes: an #SS exception
is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates a
#DF exception and enters a shutdown state as described in the #DF discussion in Chapter 6 of the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 3A.
This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</hint>
<hint page="0" header="Push All General-Purpose Registers" doc_id="x86_64" token="pushad">Pushes the contents of the general-purpose registers onto the stack. The registers are stored on the stack in the
following order: EAX, ECX, EDX, EBX, ESP (original value), EBP, ESI, and EDI (if the current operand-size attribute
is 32) and AX, CX, DX, BX, SP (original value), BP, SI, and DI (if the operand-size attribute is 16). These instruc-
tions perform the reverse operation of the POPA/POPAD instructions. The value pushed for the ESP or SP register
is its value before prior to pushing the first register (see the "Operation" section below).
The PUSHA (push all) and PUSHAD (push all double) mnemonics reference the same opcode. The PUSHA instruc-
tion is intended for use when the operand-size attribute is 16 and the PUSHAD instruction for when the operand-
size attribute is 32. Some assemblers may force the operand size to 16 when PUSHA is used and to 32 when
PUSHAD is used. Others may treat these mnemonics as synonyms (PUSHA/PUSHAD) and use the current setting
of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the
mnemonic used.
In the real-address mode, if the ESP or SP register is 1, 3, or 5 when PUSHA/PUSHAD executes: an #SS exception
is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates a
#DF exception and enters a shutdown state as described in the #DF discussion in Chapter 6 of the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 3A.
This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</hint>
<hint page="0" header="Push EFLAGS Register onto the Stack" doc_id="x86_64" token="pushf">Decrements the stack pointer by 4 (if the current operand-size attribute is 32) and pushes the entire contents of
the EFLAGS register onto the stack, or decrements the stack pointer by 2 (if the operand-size attribute is 16) and
pushes the lower 16 bits of the EFLAGS register (that is, the FLAGS register) onto the stack. These instructions
reverse the operation of the POPF/POPFD instructions.
When copying the entire EFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead,
the values for these flags are cleared in the EFLAGS image stored on the stack. See Chapter 3 of the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 1, for more information about the EFLAGS register.
The PUSHF (push flags) and PUSHFD (push flags double) mnemonics reference the same opcode. The PUSHF
instruction is intended for use when the operand-size attribute is 16 and the PUSHFD instruction for when the
operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHF is used and to 32
when PUSHFD is used. Others may treat these mnemonics as synonyms (PUSHF/PUSHFD) and use the current
setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the
mnemonic used.
In 64-bit mode, the instruction's default operation is to decrement the stack pointer (RSP) by 8 and pushes RFLAGS
on the stack. 16-bit operation is supported using the operand size override prefix 66H. 32-bit operand size cannot
be encoded in this mode. When copying RFLAGS to the stack, the VM and RF flags (bits 16 and 17) are not copied;
instead, values for these flags are cleared in the RFLAGS image stored on the stack.
When in virtual-8086 mode and the I/O privilege level (IOPL) is less than 3, the PUSHF/PUSHFD instruction causes
a general protection exception (#GP).
In the real-address mode, if the ESP or SP register is 1 when PUSHF/PUSHFD instruction executes: an #SS excep-
tion is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates
a #DF exception and enters a shutdown state as described in the #DF discussion in Chapter 6 of the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 3A.</hint>
<hint page="0" header="Push EFLAGS Register onto the Stack" doc_id="x86_64" token="pushfd">Decrements the stack pointer by 4 (if the current operand-size attribute is 32) and pushes the entire contents of
the EFLAGS register onto the stack, or decrements the stack pointer by 2 (if the operand-size attribute is 16) and
pushes the lower 16 bits of the EFLAGS register (that is, the FLAGS register) onto the stack. These instructions
reverse the operation of the POPF/POPFD instructions.
When copying the entire EFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead,
the values for these flags are cleared in the EFLAGS image stored on the stack. See Chapter 3 of the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 1, for more information about the EFLAGS register.
The PUSHF (push flags) and PUSHFD (push flags double) mnemonics reference the same opcode. The PUSHF
instruction is intended for use when the operand-size attribute is 16 and the PUSHFD instruction for when the
operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHF is used and to 32
when PUSHFD is used. Others may treat these mnemonics as synonyms (PUSHF/PUSHFD) and use the current
setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the
mnemonic used.
In 64-bit mode, the instruction's default operation is to decrement the stack pointer (RSP) by 8 and pushes RFLAGS
on the stack. 16-bit operation is supported using the operand size override prefix 66H. 32-bit operand size cannot
be encoded in this mode. When copying RFLAGS to the stack, the VM and RF flags (bits 16 and 17) are not copied;
instead, values for these flags are cleared in the RFLAGS image stored on the stack.
When in virtual-8086 mode and the I/O privilege level (IOPL) is less than 3, the PUSHF/PUSHFD instruction causes
a general protection exception (#GP).
In the real-address mode, if the ESP or SP register is 1 when PUSHF/PUSHFD instruction executes: an #SS excep-
tion is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates
a #DF exception and enters a shutdown state as described in the #DF discussion in Chapter 6 of the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 3A.</hint>
<hint page="0" header="Logical Exclusive OR" doc_id="x86_64" token="pxor">Performs a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destina-
tion operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corre-
sponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.
In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to
access additional registers (XMM8-XMM15).
Legacy SSE instructions 64-bit operand: The source operand can be an MMX technology register or a 64-bit
memory location. The destination operand is an MMX technology register.</hint>
<hint page="0" header="Rotate" doc_id="x86_64" token="rcl"></hint>
<hint page="0" header="Rotate" doc_id="x86_64" token="rcr"></hint>
<hint page="0" header="Rotate" doc_id="x86_64" token="rol"></hint>
<hint page="0" header="Rotate" doc_id="x86_64" token="ror"></hint>
<hint page="0" header="Compute Reciprocals of Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="rcpps">Performs a SIMD computation of the approximate reciprocals of the four packed single-precision floating-point
values in the source operand (second operand) stores the packed single-precision floating-point results in the
destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination
operand is an XMM register. See Figure 10-5 in the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 1, for an illustration of a SIMD single-precision floating-point operation.
The relative error for this approximation is:</hint>
<hint page="0" header="Compute Reciprocal of Scalar Single-Precision Floating-Point Values" doc_id="x86_64" token="rcpss">Computes of an approximate reciprocal of the low single-precision floating-point value in the source operand
(second operand) and stores the single-precision floating-point result in the destination operand. The source
operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The
three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of a scalar single-precision floating-
point operation.
The relative error for this approximation is:</hint>
<hint page="0" header="Read FS/GS Segment Base" doc_id="x86_64" token="rdfsbase">Loads the general-purpose register indicated by the modR/M:r/m field with the FS or GS segment base address.
The destination operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the
operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source base
address (for FS or GS) are ignored and upper 32 bits of the destination register are cleared.
This instruction is supported only in 64-bit mode.</hint>
<hint page="0" header="Read FS/GS Segment Base" doc_id="x86_64" token="rdgsbase">Loads the general-purpose register indicated by the modR/M:r/m field with the FS or GS segment base address.
The destination operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the
operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source base
address (for FS or GS) are ignored and upper 32 bits of the destination register are cleared.
This instruction is supported only in 64-bit mode.</hint>
<hint page="0" header="Read from Model Specific Register" doc_id="x86_64" token="rdmsr">Reads the contents of a 64-bit model specific register (MSR) specified in the ECX register into registers EDX:EAX.
(On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register
is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On
processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If
fewer than 64 bits are implemented in the MSR being read, the values returned to EDX:EAX in unimplemented bit
locations are undefined.
This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection
exception #GP(0) will be generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a
general protection exception.
The MSRs control functions for testability, execution tracing, performance-monitoring, and machine check errors.
Chapter 35, "Model-Specific Registers (MSRs)," in the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 3C, lists all the MSRs that can be read with this instruction and their addresses. Note that each
processor family has its own set of MSRs.
The CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before
using this instruction.</hint>
<hint page="0" header="Read Processor ID" doc_id="x86_64" token="rdpid">Reads the value of the IA32_TSC_AUX MSR (address C0000103H) into the destination register. The value of CS.D
and operand-size prefixes (66H and REX.W) do not affect the behavior of the RDPID instruction.</hint>
<hint page="0" header="Read Protection Key Rights for User Pages" doc_id="x86_64" token="rdpkru">Reads the value of PKRU into EAX and clears EDX. ECX must be 0 when RDPKRU is executed; otherwise, a general-
protection exception (#GP) occurs.
RDPKRU can be executed only if CR4.PKE = 1; otherwise, an invalid-opcode exception (#UD) occurs. Software can
discover the value of CR4.PKE by examining CPUID.(EAX=07H,ECX=0H):ECX.OSPKE [bit 4].
On processors that support the Intel 64 Architecture, the high-order 32-bits of RCX are ignored and the high-order
32-bits of RDX and RAX are cleared.</hint>
<hint page="0" header="Read Performance-Monitoring Counters" doc_id="x86_64" token="rdpmc">The EAX register is loaded with the low-order 32 bits. The EDX register is loaded with the supported high-order bits
of the counter. The number of high-order bits loaded into EDX is implementation specific on processors that do no
support architectural performance monitoring. The width of fixed-function and general-purpose performance coun-
ters on processors supporting architectural performance monitoring are reported by CPUID 0AH leaf. See below for
the treatment of the EDX register for "fast" reads.
The ECX register specifies the counter type (if the processor supports architectural performance monitoring) and
counter index. Counter type is specified in ECX[30] to select one of two type of performance counters. If the
processor does not support architectural performance monitoring, ECX[30:0] specifies the counter index; other-
wise ECX[29:0] specifies the index relative to the base of each counter type. ECX[31] selects "fast" read mode if
supported. The two counter types are:
.     General-purpose or special-purpose performance counters are specified with ECX[30] = 0: The number of
      general-purpose performance counters on processor supporting architectural performance monitoring are
      reported by CPUID 0AH leaf. The number of general-purpose counters is model specific if the processor does
      not support architectural performance monitoring, see Chapter 18, "Performance Monitoring" of Intel 64 and
      IA-32 Architectures Software Developer's Manual, Volume 3B. Special-purpose counters are available only in
      selected processor members, see Table 4-16.
.     Fixed-function performance counter are specified with ECX[30] = 1. The number fixed-function performance
      counters is enumerated by CPUID 0AH leaf. See Chapter 30 of Intel 64 and IA-32 Architectures Software
      Developer's Manual, Volume 3B. This counter type is selected if ECX[30] is set.
The width of fixed-function performance counters and general-purpose performance counters on processor
supporting architectural performance monitoring are reported by CPUID 0AH leaf. The width of general-purpose
performance counters are 40-bits for processors that do not support architectural performance monitoring coun-
ters. The width of special-purpose performance counters are implementation specific.
Table 4-16 lists valid indices of the general-purpose and special-purpose performance counters according to the
DisplayFamily_DisplayModel values of CPUID encoding for each processor family (see CPUID instruction in Chapter
3, "Instruction Set Reference, A-L" in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
2A).</hint>
<hint page="0" header="Read Random Number" doc_id="x86_64" token="rdrand">Loads a hardware generated random value and store it in the destination register. The size of the random value is
determined by the destination register size and operating mode. The Carry Flag indicates whether a random value
is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. Other-
wise CF=0 and the data in the destination operand will be returned as zeros for the specified width. All other flags
are forced to 0 in either situation. Software must check the state of CF=1 for determining if a valid random value
has been returned, otherwise it is expected to loop and retry execution of RDRAND (see Intel 64 and IA-32 Archi-
tectures Software Developer's Manual, Volume 1, Section 7.3.17, "Random Number Generator Instructions").
This instruction is available at all privilege levels.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.B permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit oper-
ands. See the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Read Random SEED" doc_id="x86_64" token="rdseed">Loads a hardware generated random value and store it in the destination register. The random value is generated
from an Enhanced NRBG (Non Deterministic Random Bit Generator) that is compliant to NIST SP800-90B and NIST
SP800-90C in the XOR construction mode. The size of the random value is determined by the destination register
size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction
is executed. CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination
operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. Software
must check the state of CF=1 for determining if a valid random seed value has been returned, otherwise it is
expected to loop and retry execution of RDSEED (see Section 1.2).
The RDSEED instruction is available at all privilege levels. The RDSEED instruction executes normally either inside
or outside a transaction region.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.B permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit oper-
ands. See the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Read Time-Stamp Counter" doc_id="x86_64" token="rdtsc">Reads the current value of the processor's time-stamp counter (a 64-bit MSR) into the EDX:EAX registers. The EDX
register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits.
(On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.)
The processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever
the processor is reset. See "Time Stamp Counter" in Chapter 17 of the Intel 64 and IA-32 Architectures Software
Developer's Manual, Volume 3B, for specific details of the time stamp counter behavior.
The time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSC instruction as follows. When the
flag is clear, the RDTSC instruction can be executed at any privilege level; when the flag is set, the instruction can
only be executed at privilege level 0.
The time-stamp counter can also be read with the RDMSR instruction, when executing at privilege level 0.
The RDTSC instruction is not a serializing instruction. It does not necessarily wait until all previous instructions
have been executed before reading the counter. Similarly, subsequent instructions may begin execution before the
read operation is performed. If software requires RDTSC to be executed only after all previous instructions have
completed locally, it can either use RDTSCP (if the processor supports that instruction) or execute the sequence
LFENCE;RDTSC.
This instruction was introduced by the Pentium processor.
See "Changes to Instruction Behavior in VMX Non-Root Operation" in Chapter 25 of the Intel 64 and IA-32 Archi-
tectures Software Developer's Manual, Volume 3C, for more information about the behavior of this instruction in
VMX non-root operation.</hint>
<hint page="0" header="Read Time-Stamp Counter and Processor ID" doc_id="x86_64" token="rdtscp">Reads the current value of the processor's time-stamp counter (a 64-bit MSR) into the EDX:EAX registers and also
reads the value of the IA32_TSC_AUX MSR (address C0000103H) into the ECX register. The EDX register is loaded
with the high-order 32 bits of the IA32_TSC MSR; the EAX register is loaded with the low-order 32 bits of the
IA32_TSC MSR; and the ECX register is loaded with the low-order 32-bits of IA32_TSC_AUX MSR. On processors
that support the Intel 64 architecture, the high-order 32 bits of each of RAX, RDX, and RCX are cleared.
The processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever
the processor is reset. See "Time Stamp Counter" in Chapter 17 of the Intel 64 and IA-32 Architectures Software
Developer's Manual, Volume 3B, for specific details of the time stamp counter behavior.
The time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSCP instruction as follows. When the
flag is clear, the RDTSCP instruction can be executed at any privilege level; when the flag is set, the instruction can
only be executed at privilege level 0.
The RDTSCP instruction waits until all previous instructions have been executed before reading the counter.
However, subsequent instructions may begin execution before the read operation is performed.
See "Changes to Instruction Behavior in VMX Non-Root Operation" in Chapter 25 of the Intel 64 and IA-32 Archi-
tectures Software Developer's Manual, Volume 3C, for more information about the behavior of this instruction in
VMX non-root operation.</hint>
<hint page="0" header="Repeat String Operation Prefix" doc_id="x86_64" token="rep">Repeats a string instruction the number of times specified in the count register or until the indicated condition of
the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ
(repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the
string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the
REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ
prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the
following instructions and undefined for the rest:
          .     F3H as REP/REPE/REPZ for string and input/output instruction.
          .     F3H is a mandatory prefix for POPCNT, LZCNT, and ADOX.
The REP prefixes apply only to one string instruction at a time. To repeat a block of instructions, use the LOOP
instruction or another looping construct. All of these repeat prefixes cause the associated instruction to be repeated
until the count in register is decremented to 0. See Table 4-17.</hint>
<hint page="0" header="Repeat String Operation Prefix" doc_id="x86_64" token="repe">Repeats a string instruction the number of times specified in the count register or until the indicated condition of
the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ
(repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the
string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the
REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ
prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the
following instructions and undefined for the rest:
          .     F3H as REP/REPE/REPZ for string and input/output instruction.
          .     F3H is a mandatory prefix for POPCNT, LZCNT, and ADOX.
The REP prefixes apply only to one string instruction at a time. To repeat a block of instructions, use the LOOP
instruction or another looping construct. All of these repeat prefixes cause the associated instruction to be repeated
until the count in register is decremented to 0. See Table 4-17.</hint>
<hint page="0" header="Repeat String Operation Prefix" doc_id="x86_64" token="repz">Repeats a string instruction the number of times specified in the count register or until the indicated condition of
the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ
(repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the
string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the
REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ
prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the
following instructions and undefined for the rest:
          .     F3H as REP/REPE/REPZ for string and input/output instruction.
          .     F3H is a mandatory prefix for POPCNT, LZCNT, and ADOX.
The REP prefixes apply only to one string instruction at a time. To repeat a block of instructions, use the LOOP
instruction or another looping construct. All of these repeat prefixes cause the associated instruction to be repeated
until the count in register is decremented to 0. See Table 4-17.</hint>
<hint page="0" header="Repeat String Operation Prefix" doc_id="x86_64" token="repne">Repeats a string instruction the number of times specified in the count register or until the indicated condition of
the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ
(repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the
string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the
REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ
prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the
following instructions and undefined for the rest:
          .     F3H as REP/REPE/REPZ for string and input/output instruction.
          .     F3H is a mandatory prefix for POPCNT, LZCNT, and ADOX.
The REP prefixes apply only to one string instruction at a time. To repeat a block of instructions, use the LOOP
instruction or another looping construct. All of these repeat prefixes cause the associated instruction to be repeated
until the count in register is decremented to 0. See Table 4-17.</hint>
<hint page="0" header="Repeat String Operation Prefix" doc_id="x86_64" token="repnz">Repeats a string instruction the number of times specified in the count register or until the indicated condition of
the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ
(repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the
string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the
REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ
prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the
following instructions and undefined for the rest:
          .     F3H as REP/REPE/REPZ for string and input/output instruction.
          .     F3H is a mandatory prefix for POPCNT, LZCNT, and ADOX.
The REP prefixes apply only to one string instruction at a time. To repeat a block of instructions, use the LOOP
instruction or another looping construct. All of these repeat prefixes cause the associated instruction to be repeated
until the count in register is decremented to 0. See Table 4-17.</hint>
<hint page="0" header="Return from Procedure" doc_id="x86_64" token="ret">Transfers program control to a return address located on the top of the stack. The address is usually placed on the
stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.
The optional source operand specifies the number of stack bytes to be released after the return address is popped;
the default is none. This operand can be used to release parameters from the stack that were passed to the called
procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure
uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET
instruction must specify the same number of bytes as is specified in the word count field of the call gate.
The RET instruction can be used to execute three different types of returns:
.     Near return - A return to a calling procedure within the current code segment (the segment currently pointed
      to by the CS register), sometimes referred to as an intrasegment return.
.     Far return - A return to a calling procedure located in a different segment than the current code segment,
      sometimes referred to as an intersegment return.
.     Inter-privilege-level far return - A far return to a different privilege level than that of the currently
      executing program or procedure.
The inter-privilege-level return type can only be executed in protected mode. See the section titled "Calling Proce-
dures Using Call and RET" in Chapter 6 of the Intel 64 and IA-32 Architectures Software Developer's Manual,
Volume 1, for detailed information on near, far, and inter-privilege-level returns.
When executing a near return, the processor pops the return instruction pointer (offset) from the top of the stack
into the EIP register and begins program execution at the new instruction pointer. The CS register is unchanged.
When executing a far return, the processor pops the return instruction pointer from the top of the stack into the EIP
register, then pops the segment selector from the top of the stack into the CS register. The processor then begins
program execution in the new code segment at the new instruction pointer.
The mechanics of an inter-privilege-level far return are similar to an intersegment return, except that the
processor examines the privilege levels and access rights of the code and stack segments being returned to deter-
mine if the control transfer is allowed to be made. The DS, ES, FS, and GS segment registers are cleared by the RET
instruction during an inter-privilege-level return if they refer to segments that are not allowed to be accessed at the
new privilege level. Since a stack switch also occurs on an inter-privilege level return, the ESP and SS registers are
loaded from the stack.
If parameters are passed to the called procedure during an inter-privilege level call, the optional source operand
must be used with the RET instruction to release the parameters on the return. Here, the parameters are released
both from the called procedure's stack and the calling procedure's stack (that is, the stack being returned to).
In 64-bit mode, the default operation size of this instruction is the stack-address size, i.e. 64 bits. This applies to
near returns, not far returns; the default operation size of far returns is 32 bits.</hint>
<hint page="0" header="Return from Procedure" doc_id="x86_64" token="retn">Transfers program control to a return address located on the top of the stack. The address is usually placed on the
stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.
The optional source operand specifies the number of stack bytes to be released after the return address is popped;
the default is none. This operand can be used to release parameters from the stack that were passed to the called
procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure
uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET
instruction must specify the same number of bytes as is specified in the word count field of the call gate.
The RET instruction can be used to execute three different types of returns:
.     Near return - A return to a calling procedure within the current code segment (the segment currently pointed
      to by the CS register), sometimes referred to as an intrasegment return.
.     Far return - A return to a calling procedure located in a different segment than the current code segment,
      sometimes referred to as an intersegment return.
.     Inter-privilege-level far return - A far return to a different privilege level than that of the currently
      executing program or procedure.
The inter-privilege-level return type can only be executed in protected mode. See the section titled "Calling Proce-
dures Using Call and RET" in Chapter 6 of the Intel 64 and IA-32 Architectures Software Developer's Manual,
Volume 1, for detailed information on near, far, and inter-privilege-level returns.
When executing a near return, the processor pops the return instruction pointer (offset) from the top of the stack
into the EIP register and begins program execution at the new instruction pointer. The CS register is unchanged.
When executing a far return, the processor pops the return instruction pointer from the top of the stack into the EIP
register, then pops the segment selector from the top of the stack into the CS register. The processor then begins
program execution in the new code segment at the new instruction pointer.
The mechanics of an inter-privilege-level far return are similar to an intersegment return, except that the
processor examines the privilege levels and access rights of the code and stack segments being returned to deter-
mine if the control transfer is allowed to be made. The DS, ES, FS, and GS segment registers are cleared by the RET
instruction during an inter-privilege-level return if they refer to segments that are not allowed to be accessed at the
new privilege level. Since a stack switch also occurs on an inter-privilege level return, the ESP and SS registers are
loaded from the stack.
If parameters are passed to the called procedure during an inter-privilege level call, the optional source operand
must be used with the RET instruction to release the parameters on the return. Here, the parameters are released
both from the called procedure's stack and the calling procedure's stack (that is, the stack being returned to).
In 64-bit mode, the default operation size of this instruction is the stack-address size, i.e. 64 bits. This applies to
near returns, not far returns; the default operation size of far returns is 32 bits.</hint>
<hint page="0" header="Return from Procedure" doc_id="x86_64" token="retf">Transfers program control to a return address located on the top of the stack. The address is usually placed on the
stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.
The optional source operand specifies the number of stack bytes to be released after the return address is popped;
the default is none. This operand can be used to release parameters from the stack that were passed to the called
procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure
uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET
instruction must specify the same number of bytes as is specified in the word count field of the call gate.
The RET instruction can be used to execute three different types of returns:
.     Near return - A return to a calling procedure within the current code segment (the segment currently pointed
      to by the CS register), sometimes referred to as an intrasegment return.
.     Far return - A return to a calling procedure located in a different segment than the current code segment,
      sometimes referred to as an intersegment return.
.     Inter-privilege-level far return - A far return to a different privilege level than that of the currently
      executing program or procedure.
The inter-privilege-level return type can only be executed in protected mode. See the section titled "Calling Proce-
dures Using Call and RET" in Chapter 6 of the Intel 64 and IA-32 Architectures Software Developer's Manual,
Volume 1, for detailed information on near, far, and inter-privilege-level returns.
When executing a near return, the processor pops the return instruction pointer (offset) from the top of the stack
into the EIP register and begins program execution at the new instruction pointer. The CS register is unchanged.
When executing a far return, the processor pops the return instruction pointer from the top of the stack into the EIP
register, then pops the segment selector from the top of the stack into the CS register. The processor then begins
program execution in the new code segment at the new instruction pointer.
The mechanics of an inter-privilege-level far return are similar to an intersegment return, except that the
processor examines the privilege levels and access rights of the code and stack segments being returned to deter-
mine if the control transfer is allowed to be made. The DS, ES, FS, and GS segment registers are cleared by the RET
instruction during an inter-privilege-level return if they refer to segments that are not allowed to be accessed at the
new privilege level. Since a stack switch also occurs on an inter-privilege level return, the ESP and SS registers are
loaded from the stack.
If parameters are passed to the called procedure during an inter-privilege level call, the optional source operand
must be used with the RET instruction to release the parameters on the return. Here, the parameters are released
both from the called procedure's stack and the calling procedure's stack (that is, the stack being returned to).
In 64-bit mode, the default operation size of this instruction is the stack-address size, i.e. 64 bits. This applies to
near returns, not far returns; the default operation size of far returns is 32 bits.</hint>
<hint page="0" header="Rotate Right Logical Without Affecting Flags" doc_id="x86_64" token="rorx">Rotates the bits of second operand right by the count value specified in imm8 without affecting arithmetic flags.
The RORX instruction does not read or write the arithmetic flags.
This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</hint>
<hint page="0" header="Round Packed Double Precision Floating-Point Values" doc_id="x86_64" token="roundpd">Round the 2 double-precision floating-point values in the source operand (second operand) using the rounding
mode specified in the immediate operand (third operand) and place the results in the destination operand (first
operand). The rounding process rounds each input floating-point value to an integer value and returns the integer
result as a double-precision floating-point value.
The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in
Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the
source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-18 lists the encoded
values for rounding-mode field).
The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an
SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before
rounding.
128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destina-
tion is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM
register destination are unmodified.
VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destina-
tion operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
zeroed.
VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination
operand is a YMM register.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Round Packed Single Precision Floating-Point Values" doc_id="x86_64" token="roundps">Round the 4 single-precision floating-point values in the source operand (second operand) using the rounding
mode specified in the immediate operand (third operand) and place the results in the destination operand (first
operand). The rounding process rounds each input floating-point value to an integer value and returns the integer
result as a single-precision floating-point value.
The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in
Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the
source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-18 lists the encoded
values for rounding-mode field).
The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an
SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before
rounding.
128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destina-
tion is not distinct from the first source XMM register and the upper bits (VLMAX-1:128) of the corresponding YMM
register destination are unmodified.
VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destina-
tion operand is an XMM register. The upper bits (VLMAX-1:128) of the corresponding YMM register destination are
zeroed.
VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination
operand is a YMM register.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Round Scalar Double Precision Floating-Point Values" doc_id="x86_64" token="roundsd">Round the DP FP value in the lower qword of the source operand (second operand) using the rounding mode spec-
ified in the immediate operand (third operand) and place the result in the destination operand (first operand). The
rounding process rounds a double-precision floating-point input to an integer value and returns the integer result
as a double precision floating-point value in the lowest position. The upper double precision floating-point value in
the destination is retained.
The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in
Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the
source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-18 lists the encoded
values for rounding-mode field).
The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an
SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before
rounding.
128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
1:64) of the corresponding YMM destination register remain unchanged.
VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</hint>
<hint page="0" header="Round Scalar Single Precision Floating-Point Values" doc_id="x86_64" token="roundss">Round the single-precision floating-point value in the lowest dword of the source operand (second operand) using
the rounding mode specified in the immediate operand (third operand) and place the result in the destination
operand (first operand). The rounding process rounds a single-precision floating-point input to an integer value and
returns the result as a single-precision floating-point value in the lowest position. The upper three single-precision
floating-point values in the destination are retained.
The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in
Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the
source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-18 lists the encoded
values for rounding-mode field).
The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an
SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before
rounding.
128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (VLMAX-
1:32) of the corresponding YMM destination register remain unchanged.
VEX.128 encoded version: Bits (VLMAX-1:128) of the destination YMM register are zeroed.</hint>
<hint page="0" header="Resume from System Management Mode" doc_id="x86_64" token="rsm">Returns program control from system management mode (SMM) to the application program or operating-system
procedure that was interrupted when the processor received an SMM interrupt. The processor's state is restored
from the dump created upon entering SMM. If the processor detects invalid state information during state restora-
tion, it enters the shutdown state. The following invalid information can cause a shutdown:
.      Any reserved bit of CR4 is set to 1.
.      Any illegal combination of bits in CR0, such as (PG=1 and PE=0) or (NW=1 and CD=0).
.      (Intel Pentium and Intel486 processors only.) The value stored in the state dump base field is not a 32-KByte
       aligned address.
The contents of the model-specific registers are not affected by a return from SMM.
The SMM state map used by RSM supports resuming processor context for non-64-bit modes and 64-bit mode.
See Chapter 34, "System Management Mode," in the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 3C, for more information about SMM and the behavior of the RSM instruction.</hint>
<hint page="0" header="Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point" doc_id="x86_64" token="rsqrtps">Performs a SIMD computation of the approximate reciprocals of the square roots of the four packed single-preci-
sion floating-point values in the source operand (second operand) and stores the packed single-precision floating-
point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location.
The destination operand is an XMM register. See Figure 10-5 in the Intel 64 and IA-32 Architectures Software
Developer's Manual, Volume 1, for an illustration of a SIMD single-precision floating-point operation.
The relative error for this approximation is:</hint>
<hint page="0" header="Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value" doc_id="x86_64" token="rsqrtss">Computes an approximate reciprocal of the square root of the low single-precision floating-point value in the
source operand (second operand) stores the single-precision floating-point result in the destination operand. The
source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register.
The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the Intel 64
and IA-32 Architectures Software Developer's Manual, Volume 1, for an illustration of a scalar single-precision
floating-point operation.
The relative error for this approximation is:</hint>
<hint page="0" header="Store AH into Flags" doc_id="x86_64" token="sahf">Loads the SF, ZF, AF, PF, and CF flags of the EFLAGS register with values from the corresponding bits in the AH
register (bits 7, 6, 4, 2, and 0, respectively). Bits 1, 3, and 5 of register AH are ignored; the corresponding reserved
bits (1, 3, and 5) in the EFLAGS register remain as shown in the "Operation" section below.
This instruction executes as described above in compatibility mode and legacy mode. It is valid in 64-bit mode only
if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1.</hint>
<hint page="0" header="Shift" doc_id="x86_64" token="sal">Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the
second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF
flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination
operand.
The destination operand can be a register or a memory location. The count operand can be an immediate value or
the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is
limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used). A special opcode encoding is provided for a count of 1.
The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the
bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most
significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared (see
Figure 7-7 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1).</hint>
<hint page="0" header="Shift" doc_id="x86_64" token="sar">Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the
second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF
flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination
operand.
The destination operand can be a register or a memory location. The count operand can be an immediate value or
the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is
limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used). A special opcode encoding is provided for a count of 1.
The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the
bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most
significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared (see
Figure 7-7 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1).</hint>
<hint page="0" header="Shift" doc_id="x86_64" token="shl">Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the
second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF
flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination
operand.
The destination operand can be a register or a memory location. The count operand can be an immediate value or
the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is
limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used). A special opcode encoding is provided for a count of 1.
The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the
bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most
significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared (see
Figure 7-7 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1).</hint>
<hint page="0" header="Shift" doc_id="x86_64" token="shr">Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the
second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF
flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination
operand.
The destination operand can be a register or a memory location. The count operand can be an immediate value or
the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is
limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used). A special opcode encoding is provided for a count of 1.
The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the
bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most
significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared (see
Figure 7-7 in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1).</hint>
<hint page="0" header="Shift Without Affecting Flags" doc_id="x86_64" token="sarx">Shifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in
the second source operand (the third operand). The result is written to the destination operand (the first operand).
The shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand
to the right (toward less significant bit locations), SARX keeps and propagates the most significant bit (sign bit)
while shifting.
The logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit loca-
tions).
This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.
If the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.
SARX,SHRX, and SHLX instructions do not update flags.</hint>
<hint page="0" header="Shift Without Affecting Flags" doc_id="x86_64" token="shlx">Shifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in
the second source operand (the third operand). The result is written to the destination operand (the first operand).
The shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand
to the right (toward less significant bit locations), SARX keeps and propagates the most significant bit (sign bit)
while shifting.
The logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit loca-
tions).
This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.
If the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.
SARX,SHRX, and SHLX instructions do not update flags.</hint>
<hint page="0" header="Shift Without Affecting Flags" doc_id="x86_64" token="shrx">Shifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in
the second source operand (the third operand). The result is written to the destination operand (the first operand).
The shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand
to the right (toward less significant bit locations), SARX keeps and propagates the most significant bit (sign bit)
while shifting.
The logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit loca-
tions).
This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in
64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An
attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.
If the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.
SARX,SHRX, and SHLX instructions do not update flags.</hint>
<hint page="0" header="Integer Subtraction with Borrow" doc_id="x86_64" token="sbb"></hint>
<hint page="0" header="Scan String" doc_id="x86_64" token="scas">In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword
specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording
the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute
of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override
prefix.
At the assembly-code level, two forms of this instruction are allowed. The explicit-operand form and the no-oper-
ands form. The explicit-operand form (specified using the SCAS mnemonic) allows a memory operand to be speci-
fied explicitly. The memory operand must be a symbol that indicates the size and location of the operand value. The
register operand is then automatically selected to match the size of the memory operand (AL register for byte
comparisons, AX for word comparisons, EAX for doubleword comparisons). The explicit-operand form is provided
to allow documentation. Note that the documentation provided by this form can be misleading. That is, the
memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword) but it
does not have to specify the correct location. The location is always specified by ES:(E)DI.
The no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI is assumed to be the memory
operand and AL, AX, or EAX is assumed to be the register operand. The size of operands is selected by the
mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).
After the comparison, the (E)DI register is incremented or decremented automatically according to the setting of
the DF flag in the EFLAGS register. If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI
register is decremented. The register is incremented or decremented by 1 for byte operations, by 2 for word oper-
ations, and by 4 for doubleword operations.
SCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the REP prefix for block comparisons of ECX bytes,
words, doublewords, or quadwords. Often, however, these instructions will be used in a LOOP construct that takes</hint>
<hint page="0" header="Scan String" doc_id="x86_64" token="scasb">In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword
specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording
the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute
of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override
prefix.
At the assembly-code level, two forms of this instruction are allowed. The explicit-operand form and the no-oper-
ands form. The explicit-operand form (specified using the SCAS mnemonic) allows a memory operand to be speci-
fied explicitly. The memory operand must be a symbol that indicates the size and location of the operand value. The
register operand is then automatically selected to match the size of the memory operand (AL register for byte
comparisons, AX for word comparisons, EAX for doubleword comparisons). The explicit-operand form is provided
to allow documentation. Note that the documentation provided by this form can be misleading. That is, the
memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword) but it
does not have to specify the correct location. The location is always specified by ES:(E)DI.
The no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI is assumed to be the memory
operand and AL, AX, or EAX is assumed to be the register operand. The size of operands is selected by the
mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).
After the comparison, the (E)DI register is incremented or decremented automatically according to the setting of
the DF flag in the EFLAGS register. If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI
register is decremented. The register is incremented or decremented by 1 for byte operations, by 2 for word oper-
ations, and by 4 for doubleword operations.
SCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the REP prefix for block comparisons of ECX bytes,
words, doublewords, or quadwords. Often, however, these instructions will be used in a LOOP construct that takes</hint>
<hint page="0" header="Scan String" doc_id="x86_64" token="scasw">In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword
specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording
the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute
of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override
prefix.
At the assembly-code level, two forms of this instruction are allowed. The explicit-operand form and the no-oper-
ands form. The explicit-operand form (specified using the SCAS mnemonic) allows a memory operand to be speci-
fied explicitly. The memory operand must be a symbol that indicates the size and location of the operand value. The
register operand is then automatically selected to match the size of the memory operand (AL register for byte
comparisons, AX for word comparisons, EAX for doubleword comparisons). The explicit-operand form is provided
to allow documentation. Note that the documentation provided by this form can be misleading. That is, the
memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword) but it
does not have to specify the correct location. The location is always specified by ES:(E)DI.
The no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI is assumed to be the memory
operand and AL, AX, or EAX is assumed to be the register operand. The size of operands is selected by the
mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).
After the comparison, the (E)DI register is incremented or decremented automatically according to the setting of
the DF flag in the EFLAGS register. If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI
register is decremented. The register is incremented or decremented by 1 for byte operations, by 2 for word oper-
ations, and by 4 for doubleword operations.
SCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the REP prefix for block comparisons of ECX bytes,
words, doublewords, or quadwords. Often, however, these instructions will be used in a LOOP construct that takes</hint>
<hint page="0" header="Scan String" doc_id="x86_64" token="scasd">In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword
specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording
the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute
of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override
prefix.
At the assembly-code level, two forms of this instruction are allowed. The explicit-operand form and the no-oper-
ands form. The explicit-operand form (specified using the SCAS mnemonic) allows a memory operand to be speci-
fied explicitly. The memory operand must be a symbol that indicates the size and location of the operand value. The
register operand is then automatically selected to match the size of the memory operand (AL register for byte
comparisons, AX for word comparisons, EAX for doubleword comparisons). The explicit-operand form is provided
to allow documentation. Note that the documentation provided by this form can be misleading. That is, the
memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword) but it
does not have to specify the correct location. The location is always specified by ES:(E)DI.
The no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI is assumed to be the memory
operand and AL, AX, or EAX is assumed to be the register operand. The size of operands is selected by the
mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).
After the comparison, the (E)DI register is incremented or decremented automatically according to the setting of
the DF flag in the EFLAGS register. If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI
register is decremented. The register is incremented or decremented by 1 for byte operations, by 2 for word oper-
ations, and by 4 for doubleword operations.
SCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the REP prefix for block comparisons of ECX bytes,
words, doublewords, or quadwords. Often, however, these instructions will be used in a LOOP construct that takes</hint>
<hint page="0" header="Set Byte on Condition (Above or Equal)" doc_id="x86_64" token="setae">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Greater Than or Equal)" doc_id="x86_64" token="setge">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Not Less Than or Equal)" doc_id="x86_64" token="setnle">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Not Below or Equal)" doc_id="x86_64" token="setnbe">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Not Great Than or Equal)" doc_id="x86_64" token="setnge">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Less Than or Equal)" doc_id="x86_64" token="setle">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Not Less Than)" doc_id="x86_64" token="setnl">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (No Overflow)" doc_id="x86_64" token="setno">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Not Above)" doc_id="x86_64" token="setna">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Not Below)" doc_id="x86_64" token="setnb">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (No Carry)" doc_id="x86_64" token="setnc">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Not Equal)" doc_id="x86_64" token="setne">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Not Greater Than)" doc_id="x86_64" token="setng">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Not Zero)" doc_id="x86_64" token="setnz">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Parity Even)" doc_id="x86_64" token="setpe">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (No Parity)" doc_id="x86_64" token="setnp">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (No Sign)" doc_id="x86_64" token="setns">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Parity Odd)" doc_id="x86_64" token="setpo">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Below or Equal)" doc_id="x86_64" token="setbe">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Above)" doc_id="x86_64" token="seta">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Carry)" doc_id="x86_64" token="setc">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Below)" doc_id="x86_64" token="setb">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Equal)" doc_id="x86_64" token="sete">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Greater Than)" doc_id="x86_64" token="setg">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Not Above or Equal)" doc_id="x86_64" token="setnae">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Less than)" doc_id="x86_64" token="setl">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Overflow)" doc_id="x86_64" token="seto">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Parity)" doc_id="x86_64" token="setp">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Sign)" doc_id="x86_64" token="sets">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Set Byte on Condition (Zero)" doc_id="x86_64" token="setz">Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the
EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix
(cc) indicates the condition being tested for.
The terms "above" and "below" are associated with the CF flag and refer to the relationship between two unsigned
integer values. The terms "greater" and "less" are associated with the SF and OF flags and refer to the relationship
between two signed integer values.
Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and
SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals
OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, "EFLAGS Condition
Codes," in the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1, shows the alternate
mnemonics for various test conditions.
Some languages represent a logical one as an integer with all bits set. This representation can be obtained by
choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to
test for overflow, use the SETNO instruction, then decrement the result.</hint>
<hint page="0" header="Store Fence" doc_id="x86_64" token="sfence">Performs a serializing operation on all store-to-memory instructions that were issued prior the SFENCE instruction.
This serializing operation guarantees that every store instruction that precedes the SFENCE instruction in program
order becomes globally visible before any store instruction that follows the SFENCE instruction. The SFENCE
instruction is ordered with respect to store instructions, other SFENCE instructions, any LFENCE and MFENCE
instructions, and any serializing instructions (such as the CPUID instruction). It is not ordered with respect to load
instructions.
Weakly ordered memory types can be used to achieve higher processor performance through such techniques as
out-of-order issue, write-combining, and write-collapsing. The degree to which a consumer of data recognizes or
knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data.
The SFENCE instruction provides a performance-efficient way of ensuring store ordering between routines that
produce weakly-ordered results and routines that consume this data.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.
Specification of the instruction's opcode above indicates a ModR/M byte of F8. For this instruction, the processor
ignores the r/m field of the ModR/M byte. Thus, SFENCE is encoded by any opcode of the form 0F AE Fx, where x
is in the range 8-F.</hint>
<hint page="0" header="Store Global Descriptor Table Register" doc_id="x86_64" token="sgdt">Stores the content of the global descriptor table register (GDTR) in the destination operand. The destination
operand specifies a memory location.
In legacy or compatibility mode, the destination operand is a 6-byte memory location. If the operand-size attribute
is 16 bits, the limit is stored in the low 2 bytes and the 24-bit base address is stored in bytes 3-5, and byte 6 is zero-
filled. If the operand-size attribute is 32 bits, the 16-bit limit field of the register is stored in the low 2 bytes of the
memory location and the 32-bit base address is stored in the high 4 bytes.
In IA-32e mode, the operand size is fixed at 8+2 bytes. The instruction stores an 8-byte base and a 2-byte limit.
SGDT is useful only by operating-system software. However, it can be used in application programs without causing
an exception to be generated if CR4.UMIP = 0. See "LGDT/LIDT-Load Global/Interrupt Descriptor Table Register"
in Chapter 3, Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 2A, for information on
loading the GDTR and IDTR.</hint>
<hint page="0" header="Perform Four Rounds of SHA1 Operation" doc_id="x86_64" token="sha1rnds4">The SHA1RNDS4 instruction performs four rounds of SHA1 operation using an initial SHA1 state (A,B,C,D) from the
first operand (which is a source operand and the destination operand) and some pre-computed sum of the next 4
round message dwords, and state variable E from the second operand (a source operand). The updated SHA1 state
(A,B,C,D) after four rounds of processing is stored in the destination operand.</hint>
<hint page="0" header="Calculate SHA1 State Variable E after Four Rounds" doc_id="x86_64" token="sha1nexte">The SHA1NEXTE calculates the SHA1 state variable E after four rounds of operation from the current SHA1 state
variable A in the destination operand. The calculated value of the SHA1 state variable E is added to the source
operand, which contains the scheduled dwords.</hint>
<hint page="0" header="Perform an Intermediate Calculation for the Next Four SHA1 Message Dwords" doc_id="x86_64" token="sha1msg1">The SHA1MSG1 instruction is one of two SHA1 message scheduling instructions. The instruction performs an inter-
mediate calculation for the next four SHA1 message dwords.</hint>
<hint page="0" header="Perform a Final Calculation for the Next Four SHA1 Message Dwords" doc_id="x86_64" token="sha1msg2">The SHA1MSG2 instruction is one of two SHA1 message scheduling instructions. The instruction performs the final
calculation to derive the next four SHA1 message dwords.</hint>
<hint page="0" header="Perform Two Rounds of SHA256 Operation" doc_id="x86_64" token="sha256rnds2">The SHA256RNDS2 instruction performs 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H)
from the first operand, an initial SHA256 state (A,B,E,F) from the second operand, and a pre-computed sum of the
next 2 round message dwords and the corresponding round constants from the implicit operand xmm0. Note that
only the two lower dwords of XMM0 are used by the instruction.
The updated SHA256 state (A,B,E,F) is written to the first operand, and the second operand can be used as the
updated state (C,D,G,H) in later rounds.</hint>
<hint page="0" header="Perform an Intermediate Calculation for the Next Four SHA256 Message" doc_id="x86_64" token="sha256msg1">The SHA256MSG1 instruction is one of two SHA256 message scheduling instructions. The instruction performs an
intermediate calculation for the next four SHA256 message dwords.</hint>
<hint page="0" header="Perform a Final Calculation for the Next Four SHA256 Message Dwords" doc_id="x86_64" token="sha256msg2">The SHA256MSG2 instruction is one of two SHA2 message scheduling instructions. The instruction performs the
final calculation for the next four SHA256 message dwords.</hint>
<hint page="0" header="Double Precision Shift Left" doc_id="x86_64" token="shld">The SHLD instruction is used for multi-precision shifts of 64 bits or more.
The instruction shifts the first operand (destination operand) to the left the number of bits specified by the third
operand (count operand). The second operand (source operand) provides bits to shift in from the right (starting
with bit 0 of the destination operand).
The destination operand can be a register or a memory location; the source operand is a register. The count
operand is an unsigned integer that can be stored in an immediate byte or in the CL register. If the count operand
is CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode; only
bits 0 through 4 of the count are used. This masks the count to a value between 0 and 31. If a count is greater than
the operand size, the result is undefined.
If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit
shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not
affected.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits
(upgrading the count mask to 6 bits). See the summary chart at the beginning of this section for encoding data and
limits.</hint>
<hint page="0" header="Double Precision Shift Right" doc_id="x86_64" token="shrd">The SHRD instruction is useful for multi-precision shifts of 64 bits or more.
The instruction shifts the first operand (destination operand) to the right the number of bits specified by the third
operand (count operand). The second operand (source operand) provides bits to shift in from the left (starting with
the most significant bit of the destination operand).
The destination operand can be a register or a memory location; the source operand is a register. The count
operand is an unsigned integer that can be stored in an immediate byte or the CL register. If the count operand is
CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode, the
width of the count mask is 5 bits. Only bits 0 through 4 of the count register are used (masking the count to a value
between 0 and 31). If the count is greater than the operand size, the result is undefined.
If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit
shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not
affected.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits
(upgrading the count mask to 6 bits). See the summary chart at the beginning of this section for encoding data and
limits.</hint>
<hint page="0" header="Packed Interleave Shuffle of Pairs of Double-Precision Floating-Point Values" doc_id="x86_64" token="shufpd">Selects a double-precision floating-point value of an input pair using a bit control and move to a designated
element of the destination operand. The low-to-high order of double-precision element of the destination operand
is interleaved between the first source operand and the second source operand at the granularity of input pair of
128 bits. Each bit in the imm8 byte, starting from bit 0, is the select control of the corresponding element of the
destination to received the shuffled result of an input pair.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be
a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a
64-bit memory location The destination operand is a ZMM/YMM/XMM register updated according to the writemask.
The select controls are the lower 8/4/2 bits of the imm8 byte.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register. The select controls are the bit 3:0
of the imm8 byte, imm8[7:4) are ignored.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed. The select controls are the bit 1:0 of the imm8 byte,
imm8[7:2) are ignored.</hint>
<hint page="0" header="Packed Interleave Shuffle of Quadruplets of Single-Precision Floating-Point Values" doc_id="x86_64" token="shufps">Selects a single-precision floating-point value of an input quadruplet using a two-bit control and move to a desig-
nated element of the destination operand. Each 64-bit element-pair of a 128-bit lane of the destination operand is
interleaved between the corresponding lane of the first source operand and the second source operand at the gran-
ularity 128 bits. Each two bits in the imm8 byte, starting from bit 0, is the select control of the corresponding
element of a 128-bit lane of the destination to received the shuffled result of an input quadruplet. The two lower
elements of a 128-bit lane in the destination receives shuffle results from the quadruple of the first source operand.
The next two elements of the destination receives shuffle results from the quadruple of the second source operand.
EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be
a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a
32-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.
Imm8[7:0] provides 4 select controls for each applicable 128-bit lane of the destination.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register. Imm8[7:0] provides 4 select
controls for the high and low 128-bit of the destination.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed. Imm8[7:0] provides 4 select controls for each element
of the destination.</hint>
<hint page="0" header="Store Interrupt Descriptor Table Register" doc_id="x86_64" token="sidt">Stores the content the interrupt descriptor table register (IDTR) in the destination operand. The destination
operand specifies a 6-byte memory location.
In non-64-bit modes, if the operand-size attribute is 32 bits, the 16-bit limit field of the register is stored in the low
2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes. If the operand-size attri-
bute is 16 bits, the limit is stored in the low 2 bytes and the 24-bit base address is stored in the third, fourth, and
fifth byte, with the sixth byte filled with 0s.
In 64-bit mode, the operand size fixed at 8+2 bytes. The instruction stores 8-byte base and 2-byte limit values.
SIDT is only useful in operating-system software; however, it can be used in application programs without causing
an exception to be generated if CR4.UMIP = 0. See "LGDT/LIDT-Load Global/Interrupt Descriptor Table Register"
in Chapter 3, Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 2A, for information on
loading the GDTR and IDTR.</hint>
<hint page="0" header="Store Local Descriptor Table Register" doc_id="x86_64" token="sldt">Stores the segment selector from the local descriptor table register (LDTR) in the destination operand. The desti-
nation operand can be a general-purpose register or a memory location. The segment selector stored with this
instruction points to the segment descriptor (located in the GDT) for the current LDT. This instruction can only be
executed in protected mode.
Outside IA-32e mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into
the low-order 16 bits of the register. The high-order 16 bits of the register are cleared for the Pentium 4, Intel Xeon,
and P6 family processors. They are undefined for Pentium, Intel486, and Intel386 processors. When the destina-
tion operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of
the operand size.
In compatibility mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into
the low-order 16 bits of the register. The high-order 16 bits of the register are cleared. When the destination
operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the
operand size.
In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). The
behavior of SLDT with a 64-bit register is to zero-extend the 16-bit selector and store it in the register. If the desti-
nation is memory and operand size is 64, SLDT will write the 16-bit selector to memory as a 16-bit quantity,
regardless of the operand size.</hint>
<hint page="0" header="Store Machine Status Word" doc_id="x86_64" token="smsw">Stores the machine status word (bits 0 through 15 of control register CR0) into the destination operand. The desti-
nation operand can be a general-purpose register or a memory location.
In non-64-bit modes, when the destination operand is a 32-bit register, the low-order 16 bits of register CR0 are
copied into the low-order 16 bits of the register and the high-order 16 bits are undefined. When the destination
operand is a memory location, the low-order 16 bits of register CR0 are written to memory as a 16-bit quantity,
regardless of the operand size.
In 64-bit mode, the behavior of the SMSW instruction is defined by the following examples:
.    SMSW r16 operand size 16, store CR0[15:0] in r16
.    SMSW r32 operand size 32, zero-extend CR0[31:0], and store in r32
.    SMSW r64 operand size 64, zero-extend CR0[63:0], and store in r64
.    SMSW m16 operand size 16, store CR0[15:0] in m16
.    SMSW m16 operand size 32, store CR0[15:0] in m16 (not m32)
.    SMSW m16 operands size 64, store CR0[15:0] in m16 (not m64)
SMSW is only useful in operating-system software. However, it is not a privileged instruction and can be used in
application programs if CR4.UMIP = 0. It is provided for compatibility with the Intel 286 processor. Programs and
procedures intended to run on IA-32 and Intel 64 processors beginning with the Intel386 processors should use the
MOV CR instruction to load the machine status word.
See "Changes to Instruction Behavior in VMX Non-Root Operation" in Chapter 25 of the Intel 64 and IA-32 Archi-
tectures Software Developer's Manual, Volume 3C, for more information about the behavior of this instruction in
VMX non-root operation.</hint>
<hint page="0" header="Square Root of Double-Precision Floating-Point Values" doc_id="x86_64" token="sqrtpd">Performs a SIMD computation of the square roots of the two, four or eight packed double-precision floating-point
values in the source operand (the second operand) stores the packed double-precision floating-point results in the
destination operand (the first operand).
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or
a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a
ZMM/YMM/XMM register updated according to the writemask.
VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination
operand is a YMM register. The upper bits (MAX_VL-1:256) of the corresponding ZMM register destination are
zeroed.
VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destina-
tion operand is an XMM register. The upper bits (MAX_VL-1:128) of the corresponding ZMM register destination are
zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destina-
tion is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding ZMM
register destination are unmodified.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Square Root of Single-Precision Floating-Point Values" doc_id="x86_64" token="sqrtps">Performs a SIMD computation of the square roots of the four, eight or sixteen packed single-precision floating-point
values in the source operand (second operand) stores the packed single-precision floating-point results in the
destination operand.
EVEX.512 encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location
or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a
ZMM/YMM/XMM register updated according to the writemask.
VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination
operand is a YMM register. The upper bits (MAX_VL-1:256) of the corresponding ZMM register destination are
zeroed.
VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destina-
tion operand is an XMM register. The upper bits (MAX_VL-1:128) of the corresponding ZMM register destination are
zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destina-
tion is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding ZMM
register destination are unmodified.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Compute Square Root of Scalar Double-Precision Floating-Point Value" doc_id="x86_64" token="sqrtsd">Computes the square root of the low double-precision floating-point value in the second source operand and stores
the double-precision floating-point result in the destination operand. The second source operand can be an XMM
register or a 64-bit memory location. The first source and destination operands are XMM registers.
128-bit Legacy SSE version: The first source operand and the destination operand are the same. The quadword at
bits 127:64 of the destination operand remains unchanged. Bits (MAX_VL-1:64) of the corresponding destination
register remain unchanged.
VEX.128 and EVEX encoded versions: Bits 127:64 of the destination operand are copied from the corresponding
bits of the first source operand. Bits (MAX_VL-1:128) of the destination register are zeroed.
EVEX encoded version: The low quadword element of the destination operand is updated according to the
writemask.
Software should ensure VSQRTSD is encoded with VEX.L=0. Encoding VSQRTSD with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Compute Square Root of Scalar Single-Precision Value" doc_id="x86_64" token="sqrtss">Computes the square root of the low single-precision floating-point value in the second source operand and stores
the single-precision floating-point result in the destination operand. The second source operand can be an XMM
register or a 32-bit memory location. The first source and destination operands is an XMM register.
128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAX_VL-
1:32) of the corresponding YMM destination register remain unchanged.
VEX.128 and EVEX encoded versions: Bits 127:32 of the destination operand are copied from the corresponding
bits of the first source operand. Bits (MAX_VL-1:128) of the destination ZMM register are zeroed.
EVEX encoded version: The low doubleword element of the destination operand is updated according to the
writemask.
Software should ensure VSQRTSS is encoded with VEX.L=0. Encoding VSQRTSS with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Set AC Flag in EFLAGS Register" doc_id="x86_64" token="stac">Sets the AC flag bit in EFLAGS register. This may enable alignment checking of user-mode data accesses. This
allows explicit supervisor-mode data accesses to user-mode pages even if the SMAP bit is set in the CR4 register.
This instruction's operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute STAC when
CPL &gt; 0 cause #UD.</hint>
<hint page="0" header="Set Carry Flag" doc_id="x86_64" token="stc">Sets the CF flag in the EFLAGS register. Operation is the same in all modes.</hint>
<hint page="0" header="Set Direction Flag" doc_id="x86_64" token="std">Sets the DF flag in the EFLAGS register. When the DF flag is set to 1, string operations decrement the index regis-
ters (ESI and/or EDI). Operation is the same in all modes.</hint>
<hint page="0" header="Set Interrupt Flag" doc_id="x86_64" token="sti">If protected-mode virtual interrupts are not enabled, STI sets the interrupt flag (IF) in the EFLAGS register. After
the IF flag is set, the processor begins responding to external, maskable interrupts after the next instruction is
executed. The delayed effect of this instruction is provided to allow interrupts to be enabled just before returning
from a procedure (or subroutine). For instance, if an STI instruction is followed by an RET instruction, the RET
instruction is allowed to execute before external interrupts are recognized1. If the STI instruction is followed by a
CLI instruction (which clears the IF flag), the effect of the STI instruction is negated.
The IF flag and the STI and CLI instructions do not prohibit the generation of exceptions and NMI interrupts. NMI
interrupts (and SMIs) may be blocked for one macroinstruction following an STI.
When protected-mode virtual interrupts are enabled, CPL is 3, and IOPL is less than 3; STI sets the VIF flag in the
EFLAGS register, leaving IF unaffected.
Table 4-19 indicates the action of the STI instruction depending on the processor's mode of operation and the
CPL/IOPL settings of the running program or procedure.
Operation is the same in all modes.</hint>
<hint page="0" header="Store MXCSR Register State" doc_id="x86_64" token="stmxcsr">Stores the contents of the MXCSR control and status register to the destination operand. The destination operand
is a 32-bit memory location. The reserved bits in the MXCSR register are stored as 0s.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.
VEX.L must be 0, otherwise instructions will #UD.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Store String" doc_id="x86_64" token="stos">In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register
(respectively) into the destination operand. The destination operand is a memory location, the address of which is
read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the
mode of operation). The ES segment cannot be overridden with a segment override prefix.
At the assembly-code level, two forms of the instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to
be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the
destination value. The source operand is then automatically selected to match the size of the destination operand
(the AL register for byte operands, AX for word operands, EAX for doubleword operands). The explicit-operands
form is provided to allow documentation; however, note that the documentation provided by this form can be
misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte,
word, or doubleword), but it does not have to specify the correct location. The location is always specified by the
ES:(E)DI register. These must be loaded correctly before the store string instruction is executed.
The no-operands form provides "short forms" of the byte, word, doubleword, and quadword versions of the STOS
instructions. Here also ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is assumed to be the
source operand. The size of the destination and source operands is selected by the mnemonic: STOSB (byte read
from register AL), STOSW (word from AX), STOSD (doubleword from EAX).
After the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is
incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the
register is incremented; if the DF flag is 1, the register is decremented (the register is incremented or decremented
by 1 for byte operations, by 2 for word operations, by 4 for doubleword operations).</hint>
<hint page="0" header="Store String" doc_id="x86_64" token="stosb">In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register
(respectively) into the destination operand. The destination operand is a memory location, the address of which is
read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the
mode of operation). The ES segment cannot be overridden with a segment override prefix.
At the assembly-code level, two forms of the instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to
be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the
destination value. The source operand is then automatically selected to match the size of the destination operand
(the AL register for byte operands, AX for word operands, EAX for doubleword operands). The explicit-operands
form is provided to allow documentation; however, note that the documentation provided by this form can be
misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte,
word, or doubleword), but it does not have to specify the correct location. The location is always specified by the
ES:(E)DI register. These must be loaded correctly before the store string instruction is executed.
The no-operands form provides "short forms" of the byte, word, doubleword, and quadword versions of the STOS
instructions. Here also ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is assumed to be the
source operand. The size of the destination and source operands is selected by the mnemonic: STOSB (byte read
from register AL), STOSW (word from AX), STOSD (doubleword from EAX).
After the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is
incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the
register is incremented; if the DF flag is 1, the register is decremented (the register is incremented or decremented
by 1 for byte operations, by 2 for word operations, by 4 for doubleword operations).</hint>
<hint page="0" header="Store String" doc_id="x86_64" token="stosw">In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register
(respectively) into the destination operand. The destination operand is a memory location, the address of which is
read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the
mode of operation). The ES segment cannot be overridden with a segment override prefix.
At the assembly-code level, two forms of the instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to
be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the
destination value. The source operand is then automatically selected to match the size of the destination operand
(the AL register for byte operands, AX for word operands, EAX for doubleword operands). The explicit-operands
form is provided to allow documentation; however, note that the documentation provided by this form can be
misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte,
word, or doubleword), but it does not have to specify the correct location. The location is always specified by the
ES:(E)DI register. These must be loaded correctly before the store string instruction is executed.
The no-operands form provides "short forms" of the byte, word, doubleword, and quadword versions of the STOS
instructions. Here also ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is assumed to be the
source operand. The size of the destination and source operands is selected by the mnemonic: STOSB (byte read
from register AL), STOSW (word from AX), STOSD (doubleword from EAX).
After the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is
incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the
register is incremented; if the DF flag is 1, the register is decremented (the register is incremented or decremented
by 1 for byte operations, by 2 for word operations, by 4 for doubleword operations).</hint>
<hint page="0" header="Store String" doc_id="x86_64" token="stosd">In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register
(respectively) into the destination operand. The destination operand is a memory location, the address of which is
read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the
mode of operation). The ES segment cannot be overridden with a segment override prefix.
At the assembly-code level, two forms of the instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to
be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the
destination value. The source operand is then automatically selected to match the size of the destination operand
(the AL register for byte operands, AX for word operands, EAX for doubleword operands). The explicit-operands
form is provided to allow documentation; however, note that the documentation provided by this form can be
misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte,
word, or doubleword), but it does not have to specify the correct location. The location is always specified by the
ES:(E)DI register. These must be loaded correctly before the store string instruction is executed.
The no-operands form provides "short forms" of the byte, word, doubleword, and quadword versions of the STOS
instructions. Here also ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is assumed to be the
source operand. The size of the destination and source operands is selected by the mnemonic: STOSB (byte read
from register AL), STOSW (word from AX), STOSD (doubleword from EAX).
After the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is
incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the
register is incremented; if the DF flag is 1, the register is decremented (the register is incremented or decremented
by 1 for byte operations, by 2 for word operations, by 4 for doubleword operations).</hint>
<hint page="0" header="Store String" doc_id="x86_64" token="stosq">In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register
(respectively) into the destination operand. The destination operand is a memory location, the address of which is
read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the
mode of operation). The ES segment cannot be overridden with a segment override prefix.
At the assembly-code level, two forms of the instruction are allowed: the "explicit-operands" form and the "no-
operands" form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to
be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the
destination value. The source operand is then automatically selected to match the size of the destination operand
(the AL register for byte operands, AX for word operands, EAX for doubleword operands). The explicit-operands
form is provided to allow documentation; however, note that the documentation provided by this form can be
misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte,
word, or doubleword), but it does not have to specify the correct location. The location is always specified by the
ES:(E)DI register. These must be loaded correctly before the store string instruction is executed.
The no-operands form provides "short forms" of the byte, word, doubleword, and quadword versions of the STOS
instructions. Here also ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is assumed to be the
source operand. The size of the destination and source operands is selected by the mnemonic: STOSB (byte read
from register AL), STOSW (word from AX), STOSD (doubleword from EAX).
After the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is
incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the
register is incremented; if the DF flag is 1, the register is decremented (the register is incremented or decremented
by 1 for byte operations, by 2 for word operations, by 4 for doubleword operations).</hint>
<hint page="0" header="Store Task Register" doc_id="x86_64" token="str">Stores the segment selector from the task register (TR) in the destination operand. The destination operand can be
a general-purpose register or a memory location. The segment selector stored with this instruction points to the
task state segment (TSS) for the currently running task.
When the destination operand is a 32-bit register, the 16-bit segment selector is copied into the lower 16 bits of the
register and the upper 16 bits of the register are cleared. When the destination operand is a memory location, the
segment selector is written to memory as a 16-bit quantity, regardless of operand size.
In 64-bit mode, operation is the same. The size of the memory operand is fixed at 16 bits. In register stores, the 2-
byte TR is zero extended if stored to a 64-bit register.
The STR instruction is useful only in operating-system software. It can only be executed in protected mode.</hint>
<hint page="0" header="Subtract" doc_id="x86_64" token="sub">Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result
in the destination operand. The destination operand can be a register or a memory location; the source operand
can be an immediate, register, or memory location. (However, two memory operands cannot be used in one
instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination
operand format.</hint>
<hint page="0" header="Subtract Packed Double-Precision Floating-Point Values" doc_id="x86_64" token="subpd">Performs a SIMD subtract of the two, four or eight packed double-precision floating-point values of the second
Source operand from the first Source operand, and stores the packed double-precision floating-point results in the
destination operand.
VEX.128 and EVEX.128 encoded versions: The second source operand is an XMM register or an 128-bit memory
location. The first source operand and destination operands are XMM registers. Bits (MAX_VL-1:128) of the corre-
sponding destination register are zeroed.
VEX.256 and EVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory
location. The first source operand and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corre-
sponding destination register are zeroed.
EVEX.512 encoded version: The second source operand is a ZMM register, a 512-bit memory location or a 512-bit
vector broadcasted from a 64-bit memory location. The first source operand and destination operands are ZMM
registers. The destination operand is conditionally updated according to the writemask.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper Bits (MAX_VL-1:128) of the corresponding
register destination are unmodified.</hint>
<hint page="0" header="Subtract Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="subps">Performs a SIMD subtract of the packed single-precision floating-point values in the second Source operand from
the First Source operand, and stores the packed single-precision floating-point results in the destination operand.
VEX.128 and EVEX.128 encoded versions: The second source operand is an XMM register or an 128-bit memory
location. The first source operand and destination operands are XMM registers. Bits (MAX_VL-1:128) of the corre-
sponding destination register are zeroed.
VEX.256 and EVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory
location. The first source operand and destination operands are YMM registers. Bits (MAX_VL-1:256) of the corre-
sponding destination register are zeroed.
EVEX.512 encoded version: The second source operand is a ZMM register, a 512-bit memory location or a 512-bit
vector broadcasted from a 32-bit memory location. The first source operand and destination operands are ZMM
registers. The destination operand is conditionally updated according to the writemask.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper Bits (MAX_VL-1:128) of the corresponding
register destination are unmodified.</hint>
<hint page="0" header="Subtract Scalar Double-Precision Floating-Point Value" doc_id="x86_64" token="subsd">Subtract the low double-precision floating-point value in the second source operand from the first source operand
and stores the double-precision floating-point result in the low quadword of the destination operand.
The second source operand can be an XMM register or a 64-bit memory location. The first source and destination
operands are XMM registers.
128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAX_VL-1:64) of the
corresponding destination register remain unchanged.
VEX.128 and EVEX encoded versions: Bits (127:64) of the XMM register destination are copied from corresponding
bits in the first source operand. Bits (MAX_VL-1:128) of the destination register are zeroed.
EVEX encoded version: The low quadword element of the destination operand is updated according to the
writemask.
Software should ensure VSUBSD is encoded with VEX.L=0. Encoding VSUBSD with VEX.L=1 may encounter unpre-
dictable behavior across different processor generations.</hint>
<hint page="0" header="Subtract Scalar Single-Precision Floating-Point Value" doc_id="x86_64" token="subss">Subtract the low single-precision floating-point value from the second source operand and the first source operand
and store the double-precision floating-point result in the low doubleword of the destination operand.
The second source operand can be an XMM register or a 32-bit memory location. The first source and destination
operands are XMM registers.
128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAX_VL-1:32) of the
corresponding destination register remain unchanged.
VEX.128 and EVEX encoded versions: Bits (127:32) of the XMM register destination are copied from corresponding
bits in the first source operand. Bits (MAX_VL-1:128) of the destination register are zeroed.
EVEX encoded version: The low doubleword element of the destination operand is updated according to the
writemask.
Software should ensure VSUBSS is encoded with VEX.L=0. Encoding VSUBSD with VEX.L=1 may encounter unpre-
dictable behavior across different processor generations.</hint>
<hint page="0" header="Swap GS Base Register" doc_id="x86_64" token="swapgs">SWAPGS exchanges the current GS base register value with the value contained in MSR address C0000102H
(IA32_KERNEL_GS_BASE). The SWAPGS instruction is a privileged instruction intended for use by system soft-
ware.
When using SYSCALL to implement system calls, there is no kernel stack at the OS entry point. Neither is there a
straightforward method to obtain a pointer to kernel structures from which the kernel stack pointer could be read.
Thus, the kernel cannot save general purpose registers or reference memory.
By design, SWAPGS does not require any general purpose registers or memory operands. No registers need to be
saved before using the instruction. SWAPGS exchanges the CPL 0 data pointer from the IA32_KERNEL_GS_BASE
MSR with the GS base register. The kernel can then use the GS prefix on normal memory references to access
kernel data structures. Similarly, when the OS kernel is entered using an interrupt or exception (where the kernel
stack is already set up), SWAPGS can be used to quickly get a pointer to the kernel data structures.
The IA32_KERNEL_GS_BASE MSR itself is only accessible using RDMSR/WRMSR instructions. Those instructions
are only accessible at privilege level 0. The WRMSR instruction ensures that the IA32_KERNEL_GS_BASE MSR
contains a canonical address.</hint>
<hint page="0" header="Fast System Call" doc_id="x86_64" token="syscall">SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the IA32_LSTAR
MSR (after saving the address of the instruction following SYSCALL into RCX). (The WRMSR instruction ensures
that the IA32_LSTAR MSR always contain a canonical address.)
SYSCALL also saves RFLAGS into R11 and then masks RFLAGS using the IA32_FMASK MSR (MSR address
C0000084H); specifically, the processor clears in RFLAGS every bit corresponding to a bit that is set in the
IA32_FMASK MSR.
SYSCALL loads the CS and SS selectors with values derived from bits 47:32 of the IA32_STAR MSR. However, the
CS and SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors.
Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the respon-
sibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values corre-
spond to the fixed values loaded into the descriptor caches; the SYSCALL instruction does not ensure this
correspondence.
The SYSCALL instruction does not save the stack pointer (RSP). If the OS system-call handler will change the stack
pointer, it is the responsibility of software to save the previous value of the stack pointer. This might be done prior
to executing SYSCALL, with software restoring the stack pointer with the instruction following SYSCALL (which will
be executed after SYSRET). Alternatively, the OS system-call handler may save the stack pointer and restore it
before executing SYSRET.</hint>
<hint page="0" header="Fast System Call" doc_id="x86_64" token="sysenter">Executes a fast call to a level 0 system procedure or routine. SYSENTER is a companion instruction to SYSEXIT. The
instruction is optimized to provide the maximum performance for system calls from user code running at privilege
level 3 to operating system or executive procedures running at privilege level 0.
When executed in IA-32e mode, the SYSENTER instruction transitions the logical processor to 64-bit mode; other-
wise, the logical processor remains in protected mode.
Prior to executing the SYSENTER instruction, software must specify the privilege level 0 code segment and code
entry point, and the privilege level 0 stack segment and stack pointer by writing values to the following MSRs:
.    IA32_SYSENTER_CS (MSR address 174H) - The lower 16 bits of this MSR are the segment selector for the
     privilege level 0 code segment. This value is also used to determine the segment selector of the privilege level
     0 stack segment (see the Operation section). This value cannot indicate a null selector.
.    IA32_SYSENTER_EIP (MSR address 176H) - The value of this MSR is loaded into RIP (thus, this value
     references the first instruction of the selected operating procedure or routine). In protected mode, only
     bits 31:0 are loaded.
.    IA32_SYSENTER_ESP (MSR address 175H) - The value of this MSR is loaded into RSP (thus, this value
     contains the stack pointer for the privilege level 0 stack). This value cannot represent a non-canonical address.
     In protected mode, only bits 31:0 are loaded.
These MSRs can be read from and written to using RDMSR/WRMSR. The WRMSR instruction ensures that the
IA32_SYSENTER_EIP and IA32_SYSENTER_ESP MSRs always contain canonical addresses.
While SYSENTER loads the CS and SS selectors with values derived from the IA32_SYSENTER_CS MSR, the CS and
SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead,
the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of
OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the
fixed values loaded into the descriptor caches; the SYSENTER instruction does not ensure this correspondence.
The SYSENTER instruction can be invoked from all operating modes except real-address mode.
The SYSENTER and SYSEXIT instructions are companion instructions, but they do not constitute a call/return pair.
When executing a SYSENTER instruction, the processor does not save state information for the user code (e.g., the
instruction pointer), and neither the SYSENTER nor the SYSEXIT instruction supports passing parameters on the
stack.
To use the SYSENTER and SYSEXIT instructions as companion instructions for transitions between privilege level 3
code and privilege level 0 operating system procedures, the following conventions must be followed:
.    The segment descriptors for the privilege level 0 code and stack segments and for the privilege level 3 code and
     stack segments must be contiguous in a descriptor table. This convention allows the processor to compute the
     segment selectors from the value entered in the SYSENTER_CS_MSR MSR.
.    The fast system call "stub" routines executed by user code (typically in shared libraries or DLLs) must save the
     required return IP and processor state information if a return to the calling procedure is required. Likewise, the
     operating system or executive procedures called with SYSENTER instructions must have access to and use this
     saved return and state information when returning to the user code.</hint>
<hint page="0" header="Fast Return from Fast System Call" doc_id="x86_64" token="sysexit">Executes a fast return to privilege level 3 user code. SYSEXIT is a companion instruction to the SYSENTER instruc-
tion. The instruction is optimized to provide the maximum performance for returns from system procedures
executing at protections levels 0 to user procedures executing at protection level 3. It must be executed from code
executing at privilege level 0.
With a 64-bit operand size, SYSEXIT remains in 64-bit mode; otherwise, it either enters compatibility mode (if the
logical processor is in IA-32e mode) or remains in protected mode (if it is not).
Prior to executing SYSEXIT, software must specify the privilege level 3 code segment and code entry point, and the
privilege level 3 stack segment and stack pointer by writing values into the following MSR and general-purpose
registers:
.    IA32_SYSENTER_CS (MSR address 174H) - Contains a 32-bit value that is used to determine the segment
     selectors for the privilege level 3 code and stack segments (see the Operation section)
.    RDX - The canonical address in this register is loaded into RIP (thus, this value references the first instruction
     to be executed in the user code). If the return is not to 64-bit mode, only bits 31:0 are loaded.
.    ECX - The canonical address in this register is loaded into RSP (thus, this value contains the stack pointer for
     the privilege level 3 stack). If the return is not to 64-bit mode, only bits 31:0 are loaded.
The IA32_SYSENTER_CS MSR can be read from and written to using RDMSR and WRMSR.
While SYSEXIT loads the CS and SS selectors with values derived from the IA32_SYSENTER_CS MSR, the CS and
SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead,
the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of
OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the
fixed values loaded into the descriptor caches; the SYSEXIT instruction does not ensure this correspondence.
The SYSEXIT instruction can be invoked from all operating modes except real-address mode and virtual-8086
mode.
The SYSENTER and SYSEXIT instructions were introduced into the IA-32 architecture in the Pentium II processor.
The availability of these instructions on a processor is indicated with the SYSENTER/SYSEXIT present (SEP) feature
flag returned to the EDX register by the CPUID instruction. An operating system that qualifies the SEP flag must
also qualify the processor family and model to ensure that the SYSENTER/SYSEXIT instructions are actually
present. For example:</hint>
<hint page="0" header="Return From Fast System Call" doc_id="x86_64" token="sysret">SYSRET is a companion instruction to the SYSCALL instruction. It returns from an OS system-call handler to user
code at privilege level 3. It does so by loading RIP from RCX and loading RFLAGS from R11.1 With a 64-bit operand
size, SYSRET remains in 64-bit mode; otherwise, it enters compatibility mode and only the low 32 bits of the regis-
ters are loaded.
SYSRET loads the CS and SS selectors with values derived from bits 63:48 of the IA32_STAR MSR. However, the
CS and SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors.
Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the respon-
sibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values corre-
spond to the fixed values loaded into the descriptor caches; the SYSRET instruction does not ensure this
correspondence.
The SYSRET instruction does not modify the stack pointer (ESP or RSP). For that reason, it is necessary for software
to switch to the user stack. The OS may load the user stack pointer (if it was saved after SYSCALL) before executing
SYSRET; alternatively, user code may load the stack pointer (if it was saved before SYSCALL) after receiving control
from SYSRET.
If the OS loads the stack pointer before executing SYSRET, it must ensure that the handler of any interrupt or
exception delivered between restoring the stack pointer and successful execution of SYSRET is not invoked with the
user stack. It can do so using approaches such as the following:
.    External interrupts. The OS can prevent an external interrupt from being delivered by clearing EFLAGS.IF
     before loading the user stack pointer.
.    Nonmaskable interrupts (NMIs). The OS can ensure that the NMI handler is invoked with the correct stack by
     using the interrupt stack table (IST) mechanism for gate 2 (NMI) in the IDT (see Section 6.14.5, "Interrupt
     Stack Table," in Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A).
.    General-protection exceptions (#GP). The SYSRET instruction generates #GP(0) if the value of RCX is not
     canonical. The OS can address this possibility using one or more of the following approaches:
     - Confirming that the value of RCX is canonical before executing SYSRET.
     - Using paging to ensure that the SYSCALL instruction will never save a non-canonical value into RCX.
     - Using the IST mechanism for gate 13 (#GP) in the IDT.</hint>
<hint page="0" header="Logical Compare" doc_id="x86_64" token="test">Computes the bit-wise logical AND of first operand (source 1 operand) and the second operand (source 2 operand)
and sets the SF, ZF, and PF status flags according to the result. The result is then discarded.
In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a
REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this
section for encoding data and limits.</hint>
<hint page="0" header="Count the Number of Trailing Zero Bits" doc_id="x86_64" token="tzcnt">TZCNT counts the number of trailing least significant zero bits in source operand (second operand) and returns the
result in destination operand (first operand). TZCNT is an extension of the BSF instruction. The key difference
between TZCNT and BSF instruction is that TZCNT provides operand size as output when source operand is zero
while in the case of BSF instruction, if source operand is zero, the content of destination operand are undefined. On
processors that do not support TZCNT, the instruction byte encoding is executed as BSF.</hint>
<hint page="0" header="Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS" doc_id="x86_64" token="ucomisd">Performs an unordered compare of the double-precision floating-point values in the low quadwords of operand 1
(first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according
to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set
to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).
Operand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory
location.
The UCOMISD instruction differs from the COMISD instruction in that it signals a SIMD floating-point invalid oper-
ation exception (#I) only when a source operand is an SNaN. The COMISD instruction signals an invalid numeric
exception only if a source operand is either an SNaN or a QNaN.
The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.
Software should ensure VCOMISD is encoded with VEX.L=0. Encoding VCOMISD with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS" doc_id="x86_64" token="ucomiss">Compares the single-precision floating-point values in the low doublewords of operand 1 (first operand) and
operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unor-
dered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unor-
dered result is returned if either source operand is a NaN (QNaN or SNaN).
Operand 1 is an XMM register; operand 2 can be an XMM register or a 32 bit memory location.
The UCOMISS instruction differs from the COMISS instruction in that it signals a SIMD floating-point invalid opera-
tion exception (#I) only if a source operand is an SNaN. The COMISS instruction signals an invalid numeric excep-
tion when a source operand is either a QNaN or SNaN.
The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.
Software should ensure VCOMISS is encoded with VEX.L=0. Encoding VCOMISS with VEX.L=1 may encounter
unpredictable behavior across different processor generations.</hint>
<hint page="0" header="Undefined Instruction" doc_id="x86_64" token="ud2">Generates an invalid opcode exception. This instruction is provided for software testing to explicitly generate an
invalid opcode exception. The opcode for this instruction is reserved for this purpose.
Other than raising the invalid opcode exception, this instruction has no effect on processor state or memory.
Even though it is the execution of the UD2 instruction that causes the invalid opcode exception, the instruction
pointer saved by delivery of the exception references the UD2 instruction (and not the following instruction).
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Unpack and Interleave High Packed Double-Precision Floating-Point Values" doc_id="x86_64" token="unpckhpd">Performs an interleaved unpack of the high double-precision floating-point values from the first source operand and
the second source operand. See Figure 4-15 in the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 2B.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch
only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be
enforced.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register.
EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM
register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destina-
tion operand is a ZMM register, conditionally updated using writemask k1.
EVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM
register, a 256-bit memory location, or a 256-bit vector broadcasted from a 64-bit memory location. The destina-
tion operand is a YMM register, conditionally updated using writemask k1.
EVEX.128 encoded version: The first source operand is a XMM register. The second source operand is a XMM
register, a 128-bit memory location, or a 128-bit vector broadcasted from a 64-bit memory location. The destina-
tion operand is a XMM register, conditionally updated using writemask k1.</hint>
<hint page="0" header="Unpack and Interleave High Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="unpckhps">Performs an interleaved unpack of the high single-precision floating-point values from the first source operand and
the second source operand.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch
only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be
enforced.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
VEX.256 encoded version: The second source operand is an YMM register or an 256-bit memory location. The first
source operand and destination operands are YMM registers.</hint>
<hint page="0" header="Unpack and Interleave Low Packed Double-Precision Floating-Point Values" doc_id="x86_64" token="unpcklpd">Performs an interleaved unpack of the low double-precision floating-point values from the first source operand and
the second source operand.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch
only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be
enforced.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register.
EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM
register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destina-
tion operand is a ZMM register, conditionally updated using writemask k1.
EVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM
register, a 256-bit memory location, or a 256-bit vector broadcasted from a 64-bit memory location. The destina-
tion operand is a YMM register, conditionally updated using writemask k1.
EVEX.128 encoded version: The first source operand is an XMM register. The second source operand is a XMM
register, a 128-bit memory location, or a 128-bit vector broadcasted from a 64-bit memory location. The destina-
tion operand is a XMM register, conditionally updated using writemask k1.</hint>
<hint page="0" header="Unpack and Interleave Low Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="unpcklps">Performs an interleaved unpack of the low single-precision floating-point values from the first source operand and
the second source operand.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch
only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be
enforced.
VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM
register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAX_VL-1:128)
of the corresponding ZMM register destination are zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM
register or a 256-bit memory location. The destination operand is a YMM register.</hint>
<hint page="0" header="Align Doubleword/Quadword Vectors" doc_id="x86_64" token="valignd">Concatenates and shifts right doubleword/quadword elements of the first source operand (the second operand)
and the second source operand (the third operand) into a 1024/512/256-bit intermediate vector. The low
512/256/128-bit of the intermediate vector is written to the destination operand (the first operand) using the
writemask k1. The destination and first source operands are ZMM/YMM/XMM registers. The second source operand
can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted
from a 32/64-bit memory location.
This instruction is writemasked, so only those elements with the corresponding bit set in vector mask register k1
are computed and stored into zmm1. Elements in zmm1 with the corresponding bit clear in k1 retain their previous
values (merging-masking) or are set to 0 (zeroing-masking).</hint>
<hint page="0" header="Align Doubleword/Quadword Vectors" doc_id="x86_64" token="valignq">Concatenates and shifts right doubleword/quadword elements of the first source operand (the second operand)
and the second source operand (the third operand) into a 1024/512/256-bit intermediate vector. The low
512/256/128-bit of the intermediate vector is written to the destination operand (the first operand) using the
writemask k1. The destination and first source operands are ZMM/YMM/XMM registers. The second source operand
can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted
from a 32/64-bit memory location.
This instruction is writemasked, so only those elements with the corresponding bit set in vector mask register k1
are computed and stored into zmm1. Elements in zmm1 with the corresponding bit clear in k1 retain their previous
values (merging-masking) or are set to 0 (zeroing-masking).</hint>
<hint page="0" header="Blend Float64/Float32 Vectors Using an OpMask Control" doc_id="x86_64" token="vblendmpd">Performs an element-by-element blending between float64/float32 elements in the first source operand (the
second operand) with the elements in the second source operand (the third operand) using an opmask register as
select control. The blended result is written to the destination register.
The destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a
ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-
bit memory location.
The opmask register is not used as a writemask for this instruction. Instead, the mask is used as an element
selector: every element of the destination is conditionally selected between first source or second source using the
value of the related mask bit (0 for first source operand, 1 for second source operand).
If EVEX.z is set, the elements with corresponding mask bit value of 0 in the destination operand are zeroed.</hint>
<hint page="0" header="Blend Float64/Float32 Vectors Using an OpMask Control" doc_id="x86_64" token="vblendmps">Performs an element-by-element blending between float64/float32 elements in the first source operand (the
second operand) with the elements in the second source operand (the third operand) using an opmask register as
select control. The blended result is written to the destination register.
The destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a
ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-
bit memory location.
The opmask register is not used as a writemask for this instruction. Instead, the mask is used as an element
selector: every element of the destination is conditionally selected between first source or second source using the
value of the related mask bit (0 for first source operand, 1 for second source operand).
If EVEX.z is set, the elements with corresponding mask bit value of 0 in the destination operand are zeroed.</hint>
<hint page="0" header="Load with Broadcast Floating-Point Data" doc_id="x86_64" token="vbroadcast">VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source
operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).
    VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit,
    64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAX_VL-
    1:256) of the destination register are zeroed.
    EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the
    writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low
    doubleword/quadword element of an XMM register.
VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load
floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast
to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register
updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory
location.
VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide
versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are
only supported as 512-bit wide versions.
VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and
VBROADCASTF64X4 have 64-bit granularity.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded
with VEX.L= 0 will cause an #UD exception.</hint>
<hint page="0" header="Broadcast Mask to Vector Register" doc_id="x86_64" token="vpbroadcastm">Broadcasts the zero-extended 64/32 bit value of the low byte/word of the source operand (the second operand) to
each 64/32 bit element of the destination operand (the first operand). The source operand is an opmask register.
The destination operand is a ZMM register (EVEX.512), YMM register (EVEX.256), or XMM register (EVEX.128).
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Store Sparse Packed Double-Precision Floating-Point Values into Dense" doc_id="x86_64" token="vcompresspd">Compress (store) up to 8 double-precision floating-point values from the source operand (the second operand) as
a contiguous vector to the destination operand (the first operand) The source operand is a ZMM/YMM/XMM register,
the destination operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.
The opmask register k1 selects the active elements (partial vector or possibly non-contiguous if less than 8 active
elements) from the source operand to compress into a contiguous vector. The contiguous vector is written to the
destination starting from the low element of the destination operand.
Memory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z
must be zero.
Register destination version: If the vector length of the contiguous vector is less than that of the input vector in the
source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper
bits are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element
instead of the size of the full vector.</hint>
<hint page="0" header="Store Sparse Packed Single-Precision Floating-Point Values into Dense Memory" doc_id="x86_64" token="vcompressps">Compress (stores) up to 16 single-precision floating-point values from the source operand (the second operand) to
the destination operand (the first operand). The source operand is a ZMM/YMM/XMM register, the destination
operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.
The opmask register k1 selects the active elements (a partial vector or possibly non-contiguous if less than 16
active elements) from the source operand to compress into a contiguous vector. The contiguous vector is written to
the destination starting from the low element of the destination operand.
Memory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z
must be zero.
Register destination version: If the vector length of the contiguous vector is less than that of the input vector in the
source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper
bits are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element
instead of the size of the full vector.</hint>
<hint page="0" header="Convert Packed Double-Precision Floating-Point Values to Packed Quadword" doc_id="x86_64" token="vcvtpd2qq">Converts packed double-precision floating-point values in the source operand (second operand) to packed quad-
word integers in the destination operand (first operand).
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location.
The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register or the embedded rounding control bits. If a converted result cannot be represented in the destination
format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value
(2w-1, where w represents the number of bits in the destination format) is returned.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Double-Precision Floating-Point Values to Packed Unsigned" doc_id="x86_64" token="vcvtpd2udq">Converts packed double-precision floating-point values in the source operand (the second operand) to packed
unsigned doubleword integers in the destination operand (the first operand).
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register or the embedded rounding control bits. If a converted result cannot be represented in the destination
format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w - 1 is
returned, where w represents the number of bits in the destination format.
The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector
broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally
updated with writemask k1. The upper bits (MAX_VL-1:256) of the corresponding destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Double-Precision Floating-Point Values to Packed Unsigned" doc_id="x86_64" token="vcvtpd2uqq">Converts packed double-precision floating-point values in the source operand (second operand) to packed
unsigned quadword integers in the destination operand (first operand).
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register or the embedded rounding control bits. If a converted result cannot be represented in the destination
format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w - 1 is
returned, where w represents the number of bits in the destination format.
The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation
is a ZMM/YMM/XMM register conditionally updated with writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert 16-bit FP values to Single-Precision FP values" doc_id="x86_64" token="vcvtph2ps">Converts packed half precision (16-bits) floating-point values in the low-order bits of the source operand (the
second operand) to packed single-precision floating-point values and writes the converted values into the destina-
tion operand (the first operand).
If case of a denormal operand, the correct normal result is returned. MXCSR.DAZ is ignored and is treated as if it
0. No denormal exception is reported on MXCSR.
VEX.128 version: The source operand is a XMM register or 64-bit memory location. The destination operand is a
XMM register. The upper bits (MAX_VL-1:128) of the corresponding destination register are zeroed.
VEX.256 version: The source operand is a XMM register or 128-bit memory location. The destination operand is a
YMM register. Bits (MAX_VL-1:256) of the corresponding destination register are zeroed.
EVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64-bits) register or a 256/128/64-bit
memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.
The diagram below illustrates how data is converted from four packed half precision (in 64 bits) to four single preci-
sion (in 128 bits) FP values.
Note: VEX.vvvv and EVEX.vvvv are reserved (must be 1111b).</hint>
<hint page="0" header="Convert Single-Precision FP value to 16-bit FP value" doc_id="x86_64" token="vcvtps2ph">Convert packed single-precision floating values in the source operand to half-precision (16-bit) floating-point
values and store to the destination operand. The rounding mode is specified using the immediate field (imm8).
Underflow results (i.e., tiny results) are converted to denormals. MXCSR.FTZ is ignored. If a source element is
denormal relative to the input format with DM masked and at least one of PM or UM unmasked; a SIMD exception
will be raised with DE, UE and PE set.</hint>
<hint page="0" header="Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values" doc_id="x86_64" token="vcvtps2udq">Converts sixteen packed single-precision floating-point values in the source operand to sixteen unsigned double-
word integers in the destination operand.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register or the embedded rounding control bits. If a converted result cannot be represented in the destination
format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w - 1 is
returned, where w represents the number of bits in the destination format.
The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector
broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally
updated with writemask k1.
Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Single Precision Floating-Point Values to Packed Singed" doc_id="x86_64" token="vcvtps2qq">Converts eight packed single-precision floating-point values in the source operand to eight signed quadword inte-
gers in the destination operand.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register or the embedded rounding control bits. If a converted result cannot be represented in the destination
format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value
(2w-1, where w represents the number of bits in the destination format) is returned.
The source operand is a YMM/XMM/XMM (low 64- bits) register or a 256/128/64-bit memory location. The destina-
tion operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.
Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Single Precision Floating-Point Values to Packed Unsigned" doc_id="x86_64" token="vcvtps2uqq">Converts up to eight packed single-precision floating-point values in the source operand to unsigned quadword
integers in the destination operand.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register or the embedded rounding control bits. If a converted result cannot be represented in the destination
format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w - 1 is
returned, where w represents the number of bits in the destination format.
The source operand is a YMM/XMM/XMM (low 64- bits) register or a 256/128/64-bit memory location. The destina-
tion operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Quadword Integers to Packed Double-Precision Floating-Point" doc_id="x86_64" token="vcvtqq2pd">Converts packed quadword integers in the source operand (second operand) to packed double-precision floating-
point values in the destination operand (first operand).
The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation
is a ZMM/YMM/XMM register conditionally updated with writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Quadword Integers to Packed Single-Precision Floating-Point" doc_id="x86_64" token="vcvtqq2ps">Converts packed quadword integers in the source operand (second operand) to packed single-precision floating-
point values in the destination operand (first operand).
The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation
is a YMM/XMM/XMM (lower 64 bits) register conditionally updated with writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword" doc_id="x86_64" token="vcvtsd2usi">Converts a double-precision floating-point value in the source operand (the second operand) to an unsigned
doubleword integer in the destination operand (the first operand). The source operand can be an XMM register or
a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an
XMM register, the double-precision floating-point value is contained in the low quadword of the register.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register or the embedded rounding control bits. If a converted result cannot be represented in the destination
format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w - 1 is
returned, where w represents the number of bits in the destination format.</hint>
<hint page="0" header="Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword" doc_id="x86_64" token="vcvtss2usi">Converts a single-precision floating-point value in the source operand (the second operand) to an unsigned double-
word integer (or unsigned quadword integer if operand size is 64 bits) in the destination operand (the first
operand). The source operand can be an XMM register or a memory location. The destination operand is a general-
purpose register. When the source operand is an XMM register, the single-precision floating-point value is
contained in the low doubleword of the register.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register or the embedded rounding control bits. If a converted result cannot be represented in the destination
format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w - 1 is
returned, where w represents the number of bits in the destination format.
VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.
Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert with Truncation Packed Double-Precision Floating-Point Values to" doc_id="x86_64" token="vcvttpd2qq">Converts with truncation packed double-precision floating-point values in the source operand (second operand) to
packed quadword integers in the destination operand (first operand).
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location.
The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register. If a converted result cannot be represented in the destination format, the floating-point invalid exception
is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits
in the destination format) is returned.
Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert with Truncation Packed Double-Precision Floating-Point Values to" doc_id="x86_64" token="vcvttpd2udq">Converts with truncation packed double-precision floating-point values in the source operand (the second operand)
to packed unsigned doubleword integers in the destination operand (the first operand).
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register. If a converted result cannot be represented in the destination format, the floating-point invalid exception
is raised, and if this exception is masked, the integer value 2w - 1 is returned, where w represents the number of
bits in the destination format.
The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector
broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64 bits) register
conditionally updated with writemask k1. The upper bits (MAX_VL-1:256) of the corresponding destination are
zeroed.
Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert with Truncation Packed Double-Precision Floating-Point Values to" doc_id="x86_64" token="vcvttpd2uqq">Converts with truncation packed double-precision floating-point values in the source operand (second operand) to
packed unsigned quadword integers in the destination operand (first operand).
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register. If a converted result cannot be represented in the destination format, the floating-point invalid exception
is raised, and if this exception is masked, the integer value 2w - 1 is returned, where w represents the number of
bits in the destination format.
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location.
The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.
Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert with Truncation Packed Single-Precision Floating-Point Values to" doc_id="x86_64" token="vcvttps2udq">Converts with truncation packed single-precision floating-point values in the source operand to sixteen unsigned
doubleword integers in the destination operand.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR.
If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised,
and if this exception is masked, the integer value 2w - 1 is returned, where w represents the number of bits in the
destination format.
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or
a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a
ZMM/YMM/XMM register conditionally updated with writemask k1.
Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert with Truncation Packed Single Precision Floating-Point Values to" doc_id="x86_64" token="vcvttps2qq">Converts with truncation packed single-precision floating-point values in the source operand to eight signed quad-
word integers in the destination operand.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register. If a converted result cannot be represented in the destination format, the floating-point invalid exception
is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits
in the destination format) is returned.
EVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64 bits) register or a 256/128/64-bit
memory location. The destination operation is a vector register conditionally updated with writemask k1.
Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert with Truncation Packed Single Precision Floating-Point Values to" doc_id="x86_64" token="vcvttps2uqq">Converts with truncation up to eight packed single-precision floating-point values in the source operand to
unsigned quadword integers in the destination operand.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register. If a converted result cannot be represented in the destination format, the floating-point invalid exception
is raised, and if this exception is masked, the integer value 2w - 1 is returned, where w represents the number of
bits in the destination format.
EVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64 bits) register or a 256/128/64-bit
memory location. The destination operation is a vector register conditionally updated with writemask k1.
Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert with Truncation Scalar Double-Precision Floating-Point Value to" doc_id="x86_64" token="vcvttsd2usi">Converts with truncation a double-precision floating-point value in the source operand (the second operand) to an
unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the destination operand
(the first operand). The source operand can be an XMM register or a 64-bit memory location. The destination
operand is a general-purpose register. When the source operand is an XMM register, the double-precision floating-
point value is contained in the low quadword of the register.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register. If a converted result cannot be represented in the destination format, the floating-point invalid exception
is raised, and if this exception is masked, the integer value 2w - 1 is returned, where w represents the number of
bits in the destination format.
EVEX.W1 version: promotes the instruction to produce 64-bit data in 64-bit mode.</hint>
<hint page="0" header="Convert with Truncation Scalar Single-Precision Floating-Point Value to" doc_id="x86_64" token="vcvttss2usi">Converts with truncation a single-precision floating-point value in the source operand (the second operand) to an
unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the destination operand
(the first operand). The source operand can be an XMM register or a memory location. The destination operand is
a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value
is contained in the low doubleword of the register.
When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR
register. If a converted result cannot be represented in the destination format, the floating-point invalid exception
is raised, and if this exception is masked, the integer value 2w - 1 is returned, where w represents the number of
bits in the destination format.
EVEX.W1 version: promotes the instruction to produce 64-bit data in 64-bit mode.
Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Unsigned Doubleword Integers to Packed Double-Precision" doc_id="x86_64" token="vcvtudq2pd">Converts packed unsigned doubleword integers in the source operand (second operand) to packed double-preci-
sion floating-point values in the destination operand (first operand).
The source operand is a YMM/XMM/XMM (low 64 bits) register, a 256/128/64-bit memory location or a
256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM
register conditionally updated with writemask k1.
Attempt to encode this instruction with EVEX embedded rounding is ignored.
Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Unsigned Doubleword Integers to Packed Single-Precision" doc_id="x86_64" token="vcvtudq2ps">Converts packed unsigned doubleword integers in the source operand (second operand) to single-precision
floating-point values in the destination operand (first operand).
The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally
updated with writemask k1.
Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Unsigned Quadword Integers to Packed Double-Precision" doc_id="x86_64" token="vcvtuqq2pd">Converts packed unsigned quadword integers in the source operand (second operand) to packed double-precision
floating-point values in the destination operand (first operand).
The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector
broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally
updated with writemask k1.
Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Packed Unsigned Quadword Integers to Packed Single-Precision" doc_id="x86_64" token="vcvtuqq2ps">Converts packed unsigned quadword integers in the source operand (second operand) to single-precision floating-
point values in the destination operand (first operand).
EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location.
The destination operand is a YMM/XMM/XMM (low 64 bits) register conditionally updated with writemask k1.
Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Convert Unsigned Integer to Scalar Double-Precision Floating-Point Value" doc_id="x86_64" token="vcvtusi2sd">Converts an unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the second
source operand to a double-precision floating-point value in the destination operand. The result is stored in the low
quadword of the destination operand. When conversion is inexact, the value returned is rounded according to the
rounding control bits in the MXCSR register.
The second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and
destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from corre-
sponding bits in the first source operand. Bits (MAX_VL-1:128) of the destination register are zeroed.
EVEX.W1 version: promotes the instruction to use 64-bit input value in 64-bit mode.
EVEX.W0 version: attempt to encode this instruction with EVEX embedded rounding is ignored.</hint>
<hint page="0" header="Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value" doc_id="x86_64" token="vcvtusi2ss">Converts a unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the source
operand (second operand) to a single-precision floating-point value in the destination operand (first operand). The
source operand can be a general-purpose register or a memory location. The destination operand is an XMM
register. The result is stored in the low doubleword of the destination operand. When a conversion is inexact, the
value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding
control bits.
The second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and
destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from corre-
sponding bits in the first source operand. Bits (MAX_VL-1:128) of the destination register are zeroed.
EVEX.W1 version: promotes the instruction to use 64-bit input value in 64-bit mode.</hint>
<hint page="0" header="Double Block Packed Sum-Absolute-Differences (SAD) on Unsigned Bytes" doc_id="x86_64" token="vdbpsadbw">Compute packed SAD (sum of absolute differences) word results of unsigned bytes from two 32-bit dword
elements. Packed SAD word results are calculated in multiples of qword superblocks, producing 4 SAD word results
in each 64-bit superblock of the destination register.
Within each super block of packed word results, the SAD results from two 32-bit dword elements are calculated as
follows:
.     The lower two word results are calculated each from the SAD operation between a sliding dword element within
      a qword superblock from an intermediate vector with a stationary dword element in the corresponding qword
      superblock of the first source operand. The intermediate vector, see "Tmp1" in Figure 5-8, is constructed from
      the second source operand the imm8 byte as shuffle control to select dword elements within a 128-bit lane of
      the second source operand. The two sliding dword elements in a qword superblock of Tmp1 are located at byte
      offset 0 and 1 within the superblock, respectively. The stationary dword element in the qword superblock from
      the first source operand is located at byte offset 0.
.     The next two word results are calculated each from the SAD operation between a sliding dword element within
      a qword superblock from the intermediate vector Tmp1 with a second stationary dword element in the corre-
      sponding qword superblock of the first source operand. The two sliding dword elements in a qword superblock
      of Tmp1 are located at byte offset 2and 3 within the superblock, respectively. The stationary dword element in
      the qword superblock from the first source operand is located at byte offset 4.
.     The intermediate vector is constructed in 128-bits lanes. Within each 128-bit lane, each dword element of the
      intermediate vector is selected by a two-bit field within the imm8 byte on the corresponding 128-bits of the
      second source operand. The imm8 byte serves as dword shuffle control within each 128-bit lanes of the inter-
      mediate vector and the second source operand, similarly to PSHUFD.
The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, or
a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1 at
16-bit word granularity.</hint>
<hint page="0" header="Load Sparse Packed Double-Precision Floating-Point Values from Dense Memory" doc_id="x86_64" token="vexpandpd">Expand (load) up to 8/4/2, contiguous, double-precision floating-point values of the input vector in the source
operand (the second operand) to sparse elements in the destination operand (the first operand) selected by the
writemask k1.
The destination operand is a ZMM/YMM/XMM register, the source operand can be a ZMM/YMM/XMM register or a
512/256/128-bit memory location.
The input vector starts from the lowest element in the source operand. The writemask register k1 selects the desti-
nation elements (a partial vector or sparse elements if less than 8 elements) to be replaced by the ascending
elements in the input vector. Destination elements not selected by the writemask k1 are either unmodified or
zeroed, depending on EVEX.z.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element
instead of the size of the full vector.</hint>
<hint page="0" header="Load Sparse Packed Single-Precision Floating-Point Values from Dense Memory" doc_id="x86_64" token="vexpandps">Expand (load) up to 16/8/4, contiguous, single-precision floating-point values of the input vector in the source
operand (the second operand) to sparse elements of the destination operand (the first operand) selected by the
writemask k1.
The destination operand is a ZMM/YMM/XMM register, the source operand can be a ZMM/YMM/XMM register or a
512/256/128-bit memory location.
The input vector starts from the lowest element in the source operand. The writemask k1 selects the destination
elements (a partial vector or sparse elements if less than 16 elements) to be replaced by the ascending elements
in the input vector. Destination elements not selected by the writemask k1 are either unmodified or zeroed,
depending on EVEX.z.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element
instead of the size of the full vector.</hint>
<hint page="0" header="Verify a Segment for Reading or Writing" doc_id="x86_64" token="verr">Verifies whether the code or data segment specified with the source operand is readable (VERR) or writable
(VERW) from the current privilege level (CPL). The source operand is a 16-bit register or a memory location that
contains the segment selector for the segment to be verified. If the segment is accessible and readable (VERR) or
writable (VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code segments are never verified as writable.
This check cannot be performed on system segments.
To set the ZF flag, the following conditions must be met:
.    The segment selector is not NULL.
.    The selector must denote a descriptor within the bounds of the descriptor table (GDT or LDT).
.    The selector must denote the descriptor of a code or data segment (not that of a system segment or gate).
.    For the VERR instruction, the segment must be readable.
.    For the VERW instruction, the segment must be a writable data segment.
.    If the segment is not a conforming code segment, the segment's DPL must be greater than or equal to (have
     less or the same privilege as) both the CPL and the segment selector's RPL.
The validation performed is the same as is performed when a segment selector is loaded into the DS, ES, FS, or GS
register, and the indicated access (read or write) is performed. The segment selector's value cannot result in a
protection exception, enabling the software to anticipate possible segment access problems.
This instruction's operation is the same in non-64-bit modes and 64-bit mode. The operand size is fixed at 16 bits.</hint>
<hint page="0" header="Verify a Segment for Reading or Writing" doc_id="x86_64" token="verw">Verifies whether the code or data segment specified with the source operand is readable (VERR) or writable
(VERW) from the current privilege level (CPL). The source operand is a 16-bit register or a memory location that
contains the segment selector for the segment to be verified. If the segment is accessible and readable (VERR) or
writable (VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code segments are never verified as writable.
This check cannot be performed on system segments.
To set the ZF flag, the following conditions must be met:
.    The segment selector is not NULL.
.    The selector must denote a descriptor within the bounds of the descriptor table (GDT or LDT).
.    The selector must denote the descriptor of a code or data segment (not that of a system segment or gate).
.    For the VERR instruction, the segment must be readable.
.    For the VERW instruction, the segment must be a writable data segment.
.    If the segment is not a conforming code segment, the segment's DPL must be greater than or equal to (have
     less or the same privilege as) both the CPL and the segment selector's RPL.
The validation performed is the same as is performed when a segment selector is loaded into the DS, ES, FS, or GS
register, and the indicated access (read or write) is performed. The segment selector's value cannot result in a
protection exception, enabling the software to anticipate possible segment access problems.
This instruction's operation is the same in non-64-bit modes and 64-bit mode. The operand size is fixed at 16 bits.</hint>
<hint page="0" header="Approximation to the Exponential 2^x of Packed Double-Precision Floating-Point" doc_id="x86_64" token="vexp2pd">Computes the approximate base-2 exponential evaluation of the double-precision floating-point values in the
source operand (the second operand) and stores the results to the destination operand (the first operand) using
the writemask k1. The approximate base-2 exponential is evaluated with less than 2^-23 of relative error.
Denormal input values are treated as zeros and do not signal #DE, irrespective of MXCSR.DAZ. Denormal results
are flushed to zeros and do not signal #UE, irrespective of MXCSR.FZ.
The source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit
memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
A numerically exact implementation of VEXP2xx can be found at https://software.intel.com/en-us/articles/refer-
ence-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Approximation to the Exponential 2^x of Packed Single-Precision Floating-Point" doc_id="x86_64" token="vexp2ps">Computes the approximate base-2 exponential evaluation of the single-precision floating-point values in the
source operand (the second operand) and store the results in the destination operand (the first operand) using the
writemask k1. The approximate base-2 exponential is evaluated with less than 2^-23 of relative error.
Denormal input values are treated as zeros and do not signal #DE, irrespective of MXCSR.DAZ. Denormal results
are flushed to zeros and do not signal #UE, irrespective of MXCSR.FZ.
The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit
memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
A numerically exact implementation of VEXP2xx can be found at https://software.intel.com/en-us/articles/refer-
ence-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Extr" doc_id="x86_64" token="vextractf128">VEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of single-precision floating-point values
from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first
operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or
imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.
VEXTRACTF32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the
writemask.
VEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of double-precision floating-point values from the source
operand (second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit
data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply
factor The destination may be either a vector register or a 256-bit memory location.
VEXTRACTF64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the
writemask.
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
The high 6 bits of the immediate are ignored.
If VEXTRACTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will
cause an #UD exception.</hint>
<hint page="0" header="Extr" doc_id="x86_64" token="vextractf32x4">VEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of single-precision floating-point values
from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first
operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or
imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.
VEXTRACTF32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the
writemask.
VEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of double-precision floating-point values from the source
operand (second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit
data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply
factor The destination may be either a vector register or a 256-bit memory location.
VEXTRACTF64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the
writemask.
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
The high 6 bits of the immediate are ignored.
If VEXTRACTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will
cause an #UD exception.</hint>
<hint page="0" header="Extr" doc_id="x86_64" token="vextractf64x2">VEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of single-precision floating-point values
from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first
operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or
imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.
VEXTRACTF32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the
writemask.
VEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of double-precision floating-point values from the source
operand (second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit
data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply
factor The destination may be either a vector register or a 256-bit memory location.
VEXTRACTF64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the
writemask.
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
The high 6 bits of the immediate are ignored.
If VEXTRACTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will
cause an #UD exception.</hint>
<hint page="0" header="Extr" doc_id="x86_64" token="vextractf32x8">VEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of single-precision floating-point values
from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first
operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or
imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.
VEXTRACTF32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the
writemask.
VEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of double-precision floating-point values from the source
operand (second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit
data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply
factor The destination may be either a vector register or a 256-bit memory location.
VEXTRACTF64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the
writemask.
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
The high 6 bits of the immediate are ignored.
If VEXTRACTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will
cause an #UD exception.</hint>
<hint page="0" header="Extr" doc_id="x86_64" token="vextractf64x4">VEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of single-precision floating-point values
from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first
operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or
imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.
VEXTRACTF32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the
writemask.
VEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of double-precision floating-point values from the source
operand (second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit
data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply
factor The destination may be either a vector register or a 256-bit memory location.
VEXTRACTF64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the
writemask.
VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
The high 6 bits of the immediate are ignored.
If VEXTRACTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will
cause an #UD exception.</hint>
<hint page="0" header="Extract" doc_id="x86_64" token="vextracti128">VEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of doubleword integer values from the
source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand).
The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as
the multiply factor. The destination may be either a vector register or an 128-bit memory location.
VEXTRACTI32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the
writemask.
VEXTRACTI64x2: The low 128-bit of the destination operand is updated at 64-bit granularity according to the
writemask.
VEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of quadword integer values from the source operand (the
second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data
extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor
The destination may be either a vector register or a 256-bit memory location.
VEXTRACTI32x8: The low 256-bit of the destination operand is updated at 32-bit granularity according to the
writemask.</hint>
<hint page="0" header="Extract" doc_id="x86_64" token="vextracti32x4">VEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of doubleword integer values from the
source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand).
The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as
the multiply factor. The destination may be either a vector register or an 128-bit memory location.
VEXTRACTI32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the
writemask.
VEXTRACTI64x2: The low 128-bit of the destination operand is updated at 64-bit granularity according to the
writemask.
VEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of quadword integer values from the source operand (the
second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data
extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor
The destination may be either a vector register or a 256-bit memory location.
VEXTRACTI32x8: The low 256-bit of the destination operand is updated at 32-bit granularity according to the
writemask.</hint>
<hint page="0" header="Extract" doc_id="x86_64" token="vextracti64x2">VEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of doubleword integer values from the
source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand).
The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as
the multiply factor. The destination may be either a vector register or an 128-bit memory location.
VEXTRACTI32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the
writemask.
VEXTRACTI64x2: The low 128-bit of the destination operand is updated at 64-bit granularity according to the
writemask.
VEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of quadword integer values from the source operand (the
second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data
extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor
The destination may be either a vector register or a 256-bit memory location.
VEXTRACTI32x8: The low 256-bit of the destination operand is updated at 32-bit granularity according to the
writemask.</hint>
<hint page="0" header="Extract" doc_id="x86_64" token="vextracti32x8">VEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of doubleword integer values from the
source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand).
The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as
the multiply factor. The destination may be either a vector register or an 128-bit memory location.
VEXTRACTI32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the
writemask.
VEXTRACTI64x2: The low 128-bit of the destination operand is updated at 64-bit granularity according to the
writemask.
VEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of quadword integer values from the source operand (the
second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data
extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor
The destination may be either a vector register or a 256-bit memory location.
VEXTRACTI32x8: The low 256-bit of the destination operand is updated at 32-bit granularity according to the
writemask.</hint>
<hint page="0" header="Extract" doc_id="x86_64" token="vextracti64x4">VEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of doubleword integer values from the
source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand).
The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as
the multiply factor. The destination may be either a vector register or an 128-bit memory location.
VEXTRACTI32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the
writemask.
VEXTRACTI64x2: The low 128-bit of the destination operand is updated at 64-bit granularity according to the
writemask.
VEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of quadword integer values from the source operand (the
second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data
extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor
The destination may be either a vector register or a 256-bit memory location.
VEXTRACTI32x8: The low 256-bit of the destination operand is updated at 32-bit granularity according to the
writemask.</hint>
<hint page="0" header="Fix Up Special Packed Float64 Values" doc_id="x86_64" token="vfixupimmpd">Perform fix-up of quad-word elements encoded in double-precision floating-point format in the first source operand
(the second operand) using a 32-bit, two-level look-up table specified in the corresponding quadword element of
the second source operand (the third operand) with exception reporting specifier imm8. The elements that are
fixed-up are selected by mask bits of 1 specified in the opmask k1. Mask bits of 0 in the opmask k1 or table
response action of 0000b preserves the corresponding element of the first operand. The fixed-up elements from
the first source operand and the preserved element in the first operand are combined as the final results in the
destination operand (the first operand).
The destination and the first source operands are ZMM/YMM/XMM registers. The second source operand can be a
ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-
bit memory location.
The two-level look-up table perform a fix-up of each DP FP input data in the first source operand by decoding the
input data encoding into 8 token types. A response table is defined for each token type that converts the input
encoding in the first source operand with one of 16 response actions.
This instruction is specifically intended for use in fixing up the results of arithmetic calculations involving one source
so that they match the spec, although it is generally useful for fixing up the results of multiple-instruction
sequences to reflect special-number inputs. For example, consider rcp(0). Input 0 to rcp, and you should get INF
according to the DX10 spec. However, evaluating rcp via Newton-Raphson, where x=approx(1/0), yields an incor-
rect result. To deal with this, VFIXUPIMMPD can be used after the N-R reciprocal sequence to set the result to the
correct value (i.e. INF when the input is 0).
If MXCSR.DAZ is not set, denormal input elements in the first source operand are considered as normal inputs and
do not trigger any fixup nor fault reporting.
Imm8 is used to set the required flags reporting. It supports #ZE and #IE fault reporting (see details below).
MXCSR mask bits are ignored and are treated as if all mask bits are set to masked response). If any of the imm8
bits is set and the condition met for fault reporting, MXCSR.IE or MXCSR.ZE might be updated.
This instruction is writemasked, so only those elements with the corresponding bit set in vector mask register k1
are computed and stored into zmm1. Elements in the destination with the corresponding bit clear in k1 retain their
previous values or are set to 0.</hint>
<hint page="0" header="Fix Up Special Packed Float32 Values" doc_id="x86_64" token="vfixupimmps">Perform fix-up of doubleword elements encoded in single-precision floating-point format in the first source operand
(the second operand) using a 32-bit, two-level look-up table specified in the corresponding doubleword element of
the second source operand (the third operand) with exception reporting specifier imm8. The elements that are
fixed-up are selected by mask bits of 1 specified in the opmask k1. Mask bits of 0 in the opmask k1 or table
response action of 0000b preserves the corresponding element of the first operand. The fixed-up elements from
the first source operand and the preserved element in the first operand are combined as the final results in the
destination operand (the first operand).
The destination and the first source operands are ZMM/YMM/XMM registers. The second source operand can be a
ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-
bit memory location.
The two-level look-up table perform a fix-up of each SP FP input data in the first source operand by decoding the
input data encoding into 8 token types. A response table is defined for each token type that converts the input
encoding in the first source operand with one of 16 response actions.
This instruction is specifically intended for use in fixing up the results of arithmetic calculations involving one source
so that they match the spec, although it is generally useful for fixing up the results of multiple-instruction
sequences to reflect special-number inputs. For example, consider rcp(0). Input 0 to rcp, and you should get INF
according to the DX10 spec. However, evaluating rcp via Newton-Raphson, where x=approx(1/0), yields an incor-
rect result. To deal with this, VFIXUPIMMPS can be used after the N-R reciprocal sequence to set the result to the
correct value (i.e. INF when the input is 0).
If MXCSR.DAZ is not set, denormal input elements in the first source operand are considered as normal inputs and
do not trigger any fixup nor fault reporting.
Imm8 is used to set the required flags reporting. It supports #ZE and #IE fault reporting (see details below).
MXCSR.DAZ is used and refer to zmm2 only (i.e. zmm1 is not considered as zero in case MXCSR.DAZ is set).
MXCSR mask bits are ignored and are treated as if all mask bits are set to masked response). If any of the imm8
bits is set and the condition met for fault reporting, MXCSR.IE or MXCSR.ZE might be updated.</hint>
<hint page="0" header="Fix Up Special Scalar Float64 Value" doc_id="x86_64" token="vfixupimmsd">Perform a fix-up of the low quadword element encoded in double-precision floating-point format in the first source
operand (the second operand) using a 32-bit, two-level look-up table specified in the low quadword element of the
second source operand (the third operand) with exception reporting specifier imm8. The element that is fixed-up is
selected by mask bit of 1 specified in the opmask k1. Mask bit of 0 in the opmask k1 or table response action of
0000b preserves the corresponding element of the first operand. The fixed-up element from the first source
operand or the preserved element in the first operand becomes the low quadword element of the destination
operand (the first operand). Bits 127:64 of the destination operand is copied from the corresponding bits of the first
source operand. The destination and first source operands are XMM registers. The second source operand can be a
XMM register or a 64- bit memory location.
The two-level look-up table perform a fix-up of each DP FP input data in the first source operand by decoding the
input data encoding into 8 token types. A response table is defined for each token type that converts the input
encoding in the first source operand with one of 16 response actions.
This instruction is specifically intended for use in fixing up the results of arithmetic calculations involving one source
so that they match the spec, although it is generally useful for fixing up the results of multiple-instruction
sequences to reflect special-number inputs. For example, consider rcp(0). Input 0 to rcp, and you should get INF
according to the DX10 spec. However, evaluating rcp via Newton-Raphson, where x=approx(1/0), yields an incor-
rect result. To deal with this, VFIXUPIMMPD can be used after the N-R reciprocal sequence to set the result to the
correct value (i.e. INF when the input is 0).
If MXCSR.DAZ is not set, denormal input elements in the first source operand are considered as normal inputs and
do not trigger any fixup nor fault reporting.
Imm8 is used to set the required flags reporting. It supports #ZE and #IE fault reporting (see details below).
MXCSR.DAZ is used and refer to zmm2 only (i.e. zmm1 is not considered as zero in case MXCSR.DAZ is set).
MXCSR mask bits are ignored and are treated as if all mask bits are set to masked response). If any of the imm8
bits is set and the condition met for fault reporting, MXCSR.IE or MXCSR.ZE might be updated.</hint>
<hint page="0" header="Fix Up Special Scalar Float32 Value" doc_id="x86_64" token="vfixupimmss">Perform a fix-up of the low doubleword element encoded in single-precision floating-point format in the first source
operand (the second operand) using a 32-bit, two-level look-up table specified in the low doubleword element of
the second source operand (the third operand) with exception reporting specifier imm8. The element that is fixed-
up is selected by mask bit of 1 specified in the opmask k1. Mask bit of 0 in the opmask k1 or table response action
of 0000b preserves the corresponding element of the first operand. The fixed-up element from the first source
operand or the preserved element in the first operand becomes the low doubleword element of the destination
operand (the first operand) Bits 127:32 of the destination operand is copied from the corresponding bits of the first
source operand. The destination and first source operands are XMM registers. The second source operand can be a
XMM register or a 32-bit memory location.
The two-level look-up table perform a fix-up of each SP FP input data in the first source operand by decoding the
input data encoding into 8 token types. A response table is defined for each token type that converts the input
encoding in the first source operand with one of 16 response actions.
This instruction is specifically intended for use in fixing up the results of arithmetic calculations involving one
source so that they match the spec, although it is generally useful for fixing up the results of multiple-instruction
sequences to reflect special-number inputs. For example, consider rcp(0). Input 0 to rcp, and you should get INF
according to the DX10 spec. However, evaluating rcp via Newton-Raphson, where x=approx(1/0), yields an incor-
rect result. To deal with this, VFIXUPIMMPD can be used after the N-R reciprocal sequence to set the result to the
correct value (i.e. INF when the input is 0).
If MXCSR.DAZ is not set, denormal input elements in the first source operand are considered as normal inputs and
do not trigger any fixup nor fault reporting.
Imm8 is used to set the required flags reporting. It supports #ZE and #IE fault reporting (see details below).
MXCSR.DAZ is used and refer to zmm2 only (i.e. zmm1 is not considered as zero in case MXCSR.DAZ is set).
MXCSR mask bits are ignored and are treated as if all mask bits are set to masked response). If any of the imm8
bits is set and the condition met for fault reporting, MXCSR.IE or MXCSR.ZE might be updated.</hint>
<hint page="0" header="Fused Multiply-Add of Packed Double-" doc_id="x86_64" token="vfmadd132pd">Performs a set of SIMD multiply-add computation on packed double-precision floating-point values using three
source operands and writes the multiply-add results in the destination operand. The destination operand is also the
first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD
register or a memory location.
VFMADD132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source
operand to the two, four or eight packed double-precision floating-point values in the third source operand, adds
the infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in
the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision
floating-point values to the destination operand (first source operand).
VFMADD213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source operand to the two, four or eight packed double-precision floating-point values in the first source operand,
adds the infinite precision intermediate result to the two, four or eight packed double-precision floating-point
values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-
precision floating-point values to the destination operand (first source operand).
VFMADD231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source to the two, four or eight packed double-precision floating-point values in the third source operand, adds the
infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the
first source operand, performs rounding and stores the resulting two, four or eight packed double-precision
floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) is a ZMM register and encoded in
reg_field. The second source operand is a ZMM register and encoded in EVEX.vvvv. The third source operand is a
ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The
destination operand is conditionally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Add of Packed Double-" doc_id="x86_64" token="vfmadd213pd">Performs a set of SIMD multiply-add computation on packed double-precision floating-point values using three
source operands and writes the multiply-add results in the destination operand. The destination operand is also the
first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD
register or a memory location.
VFMADD132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source
operand to the two, four or eight packed double-precision floating-point values in the third source operand, adds
the infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in
the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision
floating-point values to the destination operand (first source operand).
VFMADD213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source operand to the two, four or eight packed double-precision floating-point values in the first source operand,
adds the infinite precision intermediate result to the two, four or eight packed double-precision floating-point
values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-
precision floating-point values to the destination operand (first source operand).
VFMADD231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source to the two, four or eight packed double-precision floating-point values in the third source operand, adds the
infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the
first source operand, performs rounding and stores the resulting two, four or eight packed double-precision
floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) is a ZMM register and encoded in
reg_field. The second source operand is a ZMM register and encoded in EVEX.vvvv. The third source operand is a
ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The
destination operand is conditionally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Add of Packed Double-" doc_id="x86_64" token="vfmadd231pd">Performs a set of SIMD multiply-add computation on packed double-precision floating-point values using three
source operands and writes the multiply-add results in the destination operand. The destination operand is also the
first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD
register or a memory location.
VFMADD132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source
operand to the two, four or eight packed double-precision floating-point values in the third source operand, adds
the infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in
the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision
floating-point values to the destination operand (first source operand).
VFMADD213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source operand to the two, four or eight packed double-precision floating-point values in the first source operand,
adds the infinite precision intermediate result to the two, four or eight packed double-precision floating-point
values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-
precision floating-point values to the destination operand (first source operand).
VFMADD231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source to the two, four or eight packed double-precision floating-point values in the third source operand, adds the
infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the
first source operand, performs rounding and stores the resulting two, four or eight packed double-precision
floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) is a ZMM register and encoded in
reg_field. The second source operand is a ZMM register and encoded in EVEX.vvvv. The third source operand is a
ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The
destination operand is conditionally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Add of Packed Single-" doc_id="x86_64" token="vfmadd132ps">Performs a set of SIMD multiply-add computation on packed single-precision floating-point values using three
source operands and writes the multiply-add results in the destination operand. The destination operand is also the
first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD
register or a memory location.
VFMADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision
floating-point values in the second source operand, performs rounding and stores the resulting four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFMADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the first source
operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision
floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFMADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision
floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen
packed single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) is a ZMM register and encoded in
reg_field. The second source operand is a ZMM register and encoded in EVEX.vvvv. The third source operand is a
ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The
destination operand is conditionally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Add of Packed Single-" doc_id="x86_64" token="vfmadd213ps">Performs a set of SIMD multiply-add computation on packed single-precision floating-point values using three
source operands and writes the multiply-add results in the destination operand. The destination operand is also the
first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD
register or a memory location.
VFMADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision
floating-point values in the second source operand, performs rounding and stores the resulting four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFMADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the first source
operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision
floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFMADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision
floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen
packed single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) is a ZMM register and encoded in
reg_field. The second source operand is a ZMM register and encoded in EVEX.vvvv. The third source operand is a
ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The
destination operand is conditionally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Add of Packed Single-" doc_id="x86_64" token="vfmadd231ps">Performs a set of SIMD multiply-add computation on packed single-precision floating-point values using three
source operands and writes the multiply-add results in the destination operand. The destination operand is also the
first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD
register or a memory location.
VFMADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision
floating-point values in the second source operand, performs rounding and stores the resulting four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFMADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the first source
operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision
floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFMADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision
floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen
packed single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) is a ZMM register and encoded in
reg_field. The second source operand is a ZMM register and encoded in EVEX.vvvv. The third source operand is a
ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The
destination operand is conditionally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Add of Scalar Double-" doc_id="x86_64" token="vfmadd132sd">Performs a SIMD multiply-add computation on the low double-precision floating-point values using three source
operands and writes the multiply-add result in the destination operand. The destination operand is also the first
source operand. The first and second operand are XMM registers. The third source operand can be an XMM register
or a 64-bit memory location.
VFMADD132SD: Multiplies the low double-precision floating-point value from the first source operand to the low
double-precision floating-point value in the third source operand, adds the infinite precision intermediate result to
the low double-precision floating-point values in the second source operand, performs rounding and stores the
resulting double-precision floating-point value to the destination operand (first source operand).
VFMADD213SD: Multiplies the low double-precision floating-point value from the second source operand to the low
double-precision floating-point value in the first source operand, adds the infinite precision intermediate result to
the low double-precision floating-point value in the third source operand, performs rounding and stores the
resulting double-precision floating-point value to the destination operand (first source operand).
VFMADD231SD: Multiplies the low double-precision floating-point value from the second source to the low double-
precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low
double-precision floating-point value in the first source operand, performs rounding and stores the resulting
double-precision floating-point value to the destination operand (first source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.
EVEX encoded version: The low quadword element of the destination is updated according to the writemask.</hint>
<hint page="0" header="Fused Multiply-Add of Scalar Double-" doc_id="x86_64" token="vfmadd213sd">Performs a SIMD multiply-add computation on the low double-precision floating-point values using three source
operands and writes the multiply-add result in the destination operand. The destination operand is also the first
source operand. The first and second operand are XMM registers. The third source operand can be an XMM register
or a 64-bit memory location.
VFMADD132SD: Multiplies the low double-precision floating-point value from the first source operand to the low
double-precision floating-point value in the third source operand, adds the infinite precision intermediate result to
the low double-precision floating-point values in the second source operand, performs rounding and stores the
resulting double-precision floating-point value to the destination operand (first source operand).
VFMADD213SD: Multiplies the low double-precision floating-point value from the second source operand to the low
double-precision floating-point value in the first source operand, adds the infinite precision intermediate result to
the low double-precision floating-point value in the third source operand, performs rounding and stores the
resulting double-precision floating-point value to the destination operand (first source operand).
VFMADD231SD: Multiplies the low double-precision floating-point value from the second source to the low double-
precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low
double-precision floating-point value in the first source operand, performs rounding and stores the resulting
double-precision floating-point value to the destination operand (first source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.
EVEX encoded version: The low quadword element of the destination is updated according to the writemask.</hint>
<hint page="0" header="Fused Multiply-Add of Scalar Double-" doc_id="x86_64" token="vfmadd231sd">Performs a SIMD multiply-add computation on the low double-precision floating-point values using three source
operands and writes the multiply-add result in the destination operand. The destination operand is also the first
source operand. The first and second operand are XMM registers. The third source operand can be an XMM register
or a 64-bit memory location.
VFMADD132SD: Multiplies the low double-precision floating-point value from the first source operand to the low
double-precision floating-point value in the third source operand, adds the infinite precision intermediate result to
the low double-precision floating-point values in the second source operand, performs rounding and stores the
resulting double-precision floating-point value to the destination operand (first source operand).
VFMADD213SD: Multiplies the low double-precision floating-point value from the second source operand to the low
double-precision floating-point value in the first source operand, adds the infinite precision intermediate result to
the low double-precision floating-point value in the third source operand, performs rounding and stores the
resulting double-precision floating-point value to the destination operand (first source operand).
VFMADD231SD: Multiplies the low double-precision floating-point value from the second source to the low double-
precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low
double-precision floating-point value in the first source operand, performs rounding and stores the resulting
double-precision floating-point value to the destination operand (first source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.
EVEX encoded version: The low quadword element of the destination is updated according to the writemask.</hint>
<hint page="0" header="Fused Multiply-Add of Scalar Single-Precision" doc_id="x86_64" token="vfmadd132ss">Performs a SIMD multiply-add computation on single-precision floating-point values using three source operands
and writes the multiply-add results in the destination operand. The destination operand is also the first source
operand. The first and second operands are XMM registers. The third source operand can be a XMM register or a
32-bit memory location.
VFMADD132SS: Multiplies the low single-precision floating-point value from the first source operand to the low
single-precision floating-point value in the third source operand, adds the infinite precision intermediate result to
the low single-precision floating-point value in the second source operand, performs rounding and stores the
resulting single-precision floating-point value to the destination operand (first source operand).
VFMADD213SS: Multiplies the low single-precision floating-point value from the second source operand to the low
single-precision floating-point value in the first source operand, adds the infinite precision intermediate result to
the low single-precision floating-point value in the third source operand, performs rounding and stores the
resulting single-precision floating-point value to the destination operand (first source operand).
VFMADD231SS: Multiplies the low single-precision floating-point value from the second source operand to the low
single-precision floating-point value in the third source operand, adds the infinite precision intermediate result to
the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting
single-precision floating-point value to the destination operand (first source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Add of Scalar Single-Precision" doc_id="x86_64" token="vfmadd213ss">Performs a SIMD multiply-add computation on single-precision floating-point values using three source operands
and writes the multiply-add results in the destination operand. The destination operand is also the first source
operand. The first and second operands are XMM registers. The third source operand can be a XMM register or a
32-bit memory location.
VFMADD132SS: Multiplies the low single-precision floating-point value from the first source operand to the low
single-precision floating-point value in the third source operand, adds the infinite precision intermediate result to
the low single-precision floating-point value in the second source operand, performs rounding and stores the
resulting single-precision floating-point value to the destination operand (first source operand).
VFMADD213SS: Multiplies the low single-precision floating-point value from the second source operand to the low
single-precision floating-point value in the first source operand, adds the infinite precision intermediate result to
the low single-precision floating-point value in the third source operand, performs rounding and stores the
resulting single-precision floating-point value to the destination operand (first source operand).
VFMADD231SS: Multiplies the low single-precision floating-point value from the second source operand to the low
single-precision floating-point value in the third source operand, adds the infinite precision intermediate result to
the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting
single-precision floating-point value to the destination operand (first source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Add of Scalar Single-Precision" doc_id="x86_64" token="vfmadd231ss">Performs a SIMD multiply-add computation on single-precision floating-point values using three source operands
and writes the multiply-add results in the destination operand. The destination operand is also the first source
operand. The first and second operands are XMM registers. The third source operand can be a XMM register or a
32-bit memory location.
VFMADD132SS: Multiplies the low single-precision floating-point value from the first source operand to the low
single-precision floating-point value in the third source operand, adds the infinite precision intermediate result to
the low single-precision floating-point value in the second source operand, performs rounding and stores the
resulting single-precision floating-point value to the destination operand (first source operand).
VFMADD213SS: Multiplies the low single-precision floating-point value from the second source operand to the low
single-precision floating-point value in the first source operand, adds the infinite precision intermediate result to
the low single-precision floating-point value in the third source operand, performs rounding and stores the
resulting single-precision floating-point value to the destination operand (first source operand).
VFMADD231SS: Multiplies the low single-precision floating-point value from the second source operand to the low
single-precision floating-point value in the third source operand, adds the infinite precision intermediate result to
the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting
single-precision floating-point value to the destination operand (first source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Alternating" doc_id="x86_64" token="vfmaddsub132pd">VFMADDSUB132PD: Multiplies the two, four, or eight packed double-precision floating-point values from the first
source operand to the two or four packed double-precision floating-point values in the third source operand. From
the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the
even double-precision floating-point values in the second source operand, performs rounding and stores the
resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
VFMADDSUB213PD: Multiplies the two, four, or eight packed double-precision floating-point values from the
second source operand to the two or four packed double-precision floating-point values in the first source operand.
From the infinite precision intermediate result, adds the odd double-precision floating-point elements and
subtracts the even double-precision floating-point values in the third source operand, performs rounding and
stores the resulting two or four packed double-precision floating-point values to the destination operand (first
source operand).
VFMADDSUB231PD: Multiplies the two, four, or eight packed double-precision floating-point values from the
second source operand to the two or four packed double-precision floating-point values in the third source
operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and
subtracts the even double-precision floating-point values in the first source operand, performs rounding and stores
the resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.</hint>
<hint page="0" header="Fused Multiply-Alternating" doc_id="x86_64" token="vfmaddsub213pd">VFMADDSUB132PD: Multiplies the two, four, or eight packed double-precision floating-point values from the first
source operand to the two or four packed double-precision floating-point values in the third source operand. From
the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the
even double-precision floating-point values in the second source operand, performs rounding and stores the
resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
VFMADDSUB213PD: Multiplies the two, four, or eight packed double-precision floating-point values from the
second source operand to the two or four packed double-precision floating-point values in the first source operand.
From the infinite precision intermediate result, adds the odd double-precision floating-point elements and
subtracts the even double-precision floating-point values in the third source operand, performs rounding and
stores the resulting two or four packed double-precision floating-point values to the destination operand (first
source operand).
VFMADDSUB231PD: Multiplies the two, four, or eight packed double-precision floating-point values from the
second source operand to the two or four packed double-precision floating-point values in the third source
operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and
subtracts the even double-precision floating-point values in the first source operand, performs rounding and stores
the resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.</hint>
<hint page="0" header="Fused Multiply-Alternating" doc_id="x86_64" token="vfmaddsub231pd">VFMADDSUB132PD: Multiplies the two, four, or eight packed double-precision floating-point values from the first
source operand to the two or four packed double-precision floating-point values in the third source operand. From
the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the
even double-precision floating-point values in the second source operand, performs rounding and stores the
resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
VFMADDSUB213PD: Multiplies the two, four, or eight packed double-precision floating-point values from the
second source operand to the two or four packed double-precision floating-point values in the first source operand.
From the infinite precision intermediate result, adds the odd double-precision floating-point elements and
subtracts the even double-precision floating-point values in the third source operand, performs rounding and
stores the resulting two or four packed double-precision floating-point values to the destination operand (first
source operand).
VFMADDSUB231PD: Multiplies the two, four, or eight packed double-precision floating-point values from the
second source operand to the two or four packed double-precision floating-point values in the third source
operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and
subtracts the even double-precision floating-point values in the first source operand, performs rounding and stores
the resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.</hint>
<hint page="0" header="Fused Multiply-Alternating" doc_id="x86_64" token="vfmaddsub132ps">VFMADDSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the corresponding packed single-precision floating-point values in the third source operand.
From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts
the even single-precision floating-point values in the second source operand, performs rounding and stores the
resulting packed single-precision floating-point values to the destination operand (first source operand).
VFMADDSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the
second source operand to the corresponding packed single-precision floating-point values in the first source
operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and
subtracts the even single-precision floating-point values in the third source operand, performs rounding and stores
the resulting packed single-precision floating-point values to the destination operand (first source operand).
VFMADDSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the
second source operand to the corresponding packed single-precision floating-point values in the third source
operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and
subtracts the even single-precision floating-point values in the first source operand, performs rounding and stores
the resulting packed single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.
Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the
opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations
involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction
column.</hint>
<hint page="0" header="Fused Multiply-Alternating" doc_id="x86_64" token="vfmaddsub213ps">VFMADDSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the corresponding packed single-precision floating-point values in the third source operand.
From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts
the even single-precision floating-point values in the second source operand, performs rounding and stores the
resulting packed single-precision floating-point values to the destination operand (first source operand).
VFMADDSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the
second source operand to the corresponding packed single-precision floating-point values in the first source
operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and
subtracts the even single-precision floating-point values in the third source operand, performs rounding and stores
the resulting packed single-precision floating-point values to the destination operand (first source operand).
VFMADDSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the
second source operand to the corresponding packed single-precision floating-point values in the third source
operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and
subtracts the even single-precision floating-point values in the first source operand, performs rounding and stores
the resulting packed single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.
Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the
opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations
involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction
column.</hint>
<hint page="0" header="Fused Multiply-Alternating" doc_id="x86_64" token="vfmaddsub231ps">VFMADDSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the corresponding packed single-precision floating-point values in the third source operand.
From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts
the even single-precision floating-point values in the second source operand, performs rounding and stores the
resulting packed single-precision floating-point values to the destination operand (first source operand).
VFMADDSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the
second source operand to the corresponding packed single-precision floating-point values in the first source
operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and
subtracts the even single-precision floating-point values in the third source operand, performs rounding and stores
the resulting packed single-precision floating-point values to the destination operand (first source operand).
VFMADDSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the
second source operand to the corresponding packed single-precision floating-point values in the third source
operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and
subtracts the even single-precision floating-point values in the first source operand, performs rounding and stores
the resulting packed single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.
Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the
opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations
involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction
column.</hint>
<hint page="0" header="Fused Multiply-Alternating" doc_id="x86_64" token="vfmsubadd132pd">VFMSUBADD132PD: Multiplies the two, four, or eight packed double-precision floating-point values from the first
source operand to the two or four packed double-precision floating-point values in the third source operand. From
the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the
even double-precision floating-point values in the second source operand, performs rounding and stores the
resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
VFMSUBADD213PD: Multiplies the two, four, or eight packed double-precision floating-point values from the
second source operand to the two or four packed double-precision floating-point values in the first source operand.
From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and
adds the even double-precision floating-point values in the third source operand, performs rounding and stores the
resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
VFMSUBADD231PD: Multiplies the two, four, or eight packed double-precision floating-point values from the
second source operand to the two or four packed double-precision floating-point values in the third source operand.
From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and
adds the even double-precision floating-point values in the first source operand, performs rounding and stores the
resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.</hint>
<hint page="0" header="Fused Multiply-Alternating" doc_id="x86_64" token="vfmsubadd213pd">VFMSUBADD132PD: Multiplies the two, four, or eight packed double-precision floating-point values from the first
source operand to the two or four packed double-precision floating-point values in the third source operand. From
the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the
even double-precision floating-point values in the second source operand, performs rounding and stores the
resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
VFMSUBADD213PD: Multiplies the two, four, or eight packed double-precision floating-point values from the
second source operand to the two or four packed double-precision floating-point values in the first source operand.
From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and
adds the even double-precision floating-point values in the third source operand, performs rounding and stores the
resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
VFMSUBADD231PD: Multiplies the two, four, or eight packed double-precision floating-point values from the
second source operand to the two or four packed double-precision floating-point values in the third source operand.
From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and
adds the even double-precision floating-point values in the first source operand, performs rounding and stores the
resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.</hint>
<hint page="0" header="Fused Multiply-Alternating" doc_id="x86_64" token="vfmsubadd231pd">VFMSUBADD132PD: Multiplies the two, four, or eight packed double-precision floating-point values from the first
source operand to the two or four packed double-precision floating-point values in the third source operand. From
the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the
even double-precision floating-point values in the second source operand, performs rounding and stores the
resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
VFMSUBADD213PD: Multiplies the two, four, or eight packed double-precision floating-point values from the
second source operand to the two or four packed double-precision floating-point values in the first source operand.
From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and
adds the even double-precision floating-point values in the third source operand, performs rounding and stores the
resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
VFMSUBADD231PD: Multiplies the two, four, or eight packed double-precision floating-point values from the
second source operand to the two or four packed double-precision floating-point values in the third source operand.
From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and
adds the even double-precision floating-point values in the first source operand, performs rounding and stores the
resulting two or four packed double-precision floating-point values to the destination operand (first source
operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.</hint>
<hint page="0" header="Fused Multiply-Alternating" doc_id="x86_64" token="vfmsubadd132ps">VFMSUBADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the corresponding packed single-precision floating-point values in the third source operand.
From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds
the even single-precision floating-point values in the second source operand, performs rounding and stores the
resulting packed single-precision floating-point values to the destination operand (first source operand).
VFMSUBADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the
second source operand to the corresponding packed single-precision floating-point values in the first source
operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements
and adds the even single-precision floating-point values in the third source operand, performs rounding and stores
the resulting packed single-precision floating-point values to the destination operand (first source operand).
VFMSUBADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the
second source operand to the corresponding packed single-precision floating-point values in the third source
operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements
and adds the even single-precision floating-point values in the first source operand, performs rounding and stores
the resulting packed single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.
Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the
opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations
involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction
column.</hint>
<hint page="0" header="Fused Multiply-Alternating" doc_id="x86_64" token="vfmsubadd213ps">VFMSUBADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the corresponding packed single-precision floating-point values in the third source operand.
From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds
the even single-precision floating-point values in the second source operand, performs rounding and stores the
resulting packed single-precision floating-point values to the destination operand (first source operand).
VFMSUBADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the
second source operand to the corresponding packed single-precision floating-point values in the first source
operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements
and adds the even single-precision floating-point values in the third source operand, performs rounding and stores
the resulting packed single-precision floating-point values to the destination operand (first source operand).
VFMSUBADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the
second source operand to the corresponding packed single-precision floating-point values in the third source
operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements
and adds the even single-precision floating-point values in the first source operand, performs rounding and stores
the resulting packed single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.
Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the
opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations
involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction
column.</hint>
<hint page="0" header="Fused Multiply-Alternating" doc_id="x86_64" token="vfmsubadd231ps">VFMSUBADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the corresponding packed single-precision floating-point values in the third source operand.
From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds
the even single-precision floating-point values in the second source operand, performs rounding and stores the
resulting packed single-precision floating-point values to the destination operand (first source operand).
VFMSUBADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the
second source operand to the corresponding packed single-precision floating-point values in the first source
operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements
and adds the even single-precision floating-point values in the third source operand, performs rounding and stores
the resulting packed single-precision floating-point values to the destination operand (first source operand).
VFMSUBADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the
second source operand to the corresponding packed single-precision floating-point values in the third source
operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements
and adds the even single-precision floating-point values in the first source operand, performs rounding and stores
the resulting packed single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.
Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the
opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations
involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction
column.</hint>
<hint page="0" header="Fused Multiply-Subtract of Packed Double-" doc_id="x86_64" token="vfmsub132pd">Performs a set of SIMD multiply-subtract computation on packed double-precision floating-point values using three
source operands and writes the multiply-subtract results in the destination operand. The destination operand is
also the first source operand. The second operand must be a SIMD register. The third source operand can be a
SIMD register or a memory location.
VFMSUB132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source
operand to the two, four or eight packed double-precision floating-point values in the third source operand. From
the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point
values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-
precision floating-point values to the destination operand (first source operand).
VFMSUB213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source operand to the two, four or eight packed double-precision floating-point values in the first source operand.
From the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-
point values in the third source operand, performs rounding and stores the resulting two, four or eight packed
double-precision floating-point values to the destination operand (first source operand).
VFMSUB231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source to the two, four or eight packed double-precision floating-point values in the third source operand. From the
infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point values
in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision
floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Subtract of Packed Double-" doc_id="x86_64" token="vfmsub213pd">Performs a set of SIMD multiply-subtract computation on packed double-precision floating-point values using three
source operands and writes the multiply-subtract results in the destination operand. The destination operand is
also the first source operand. The second operand must be a SIMD register. The third source operand can be a
SIMD register or a memory location.
VFMSUB132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source
operand to the two, four or eight packed double-precision floating-point values in the third source operand. From
the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point
values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-
precision floating-point values to the destination operand (first source operand).
VFMSUB213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source operand to the two, four or eight packed double-precision floating-point values in the first source operand.
From the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-
point values in the third source operand, performs rounding and stores the resulting two, four or eight packed
double-precision floating-point values to the destination operand (first source operand).
VFMSUB231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source to the two, four or eight packed double-precision floating-point values in the third source operand. From the
infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point values
in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision
floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Subtract of Packed Double-" doc_id="x86_64" token="vfmsub231pd">Performs a set of SIMD multiply-subtract computation on packed double-precision floating-point values using three
source operands and writes the multiply-subtract results in the destination operand. The destination operand is
also the first source operand. The second operand must be a SIMD register. The third source operand can be a
SIMD register or a memory location.
VFMSUB132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source
operand to the two, four or eight packed double-precision floating-point values in the third source operand. From
the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point
values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-
precision floating-point values to the destination operand (first source operand).
VFMSUB213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source operand to the two, four or eight packed double-precision floating-point values in the first source operand.
From the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-
point values in the third source operand, performs rounding and stores the resulting two, four or eight packed
double-precision floating-point values to the destination operand (first source operand).
VFMSUB231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source to the two, four or eight packed double-precision floating-point values in the third source operand. From the
infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point values
in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision
floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Subtract of Packed Single-" doc_id="x86_64" token="vfmsub132ps">Performs a set of SIMD multiply-subtract computation on packed single-precision floating-point values using three
source operands and writes the multiply-subtract results in the destination operand. The destination operand is
also the first source operand. The second operand must be a SIMD register. The third source operand can be a
SIMD register or a memory location.
VFMSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision
floating-point values in the second source operand, performs rounding and stores the resulting four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFMSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the first source
operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision
floating-point values in the third source operand, performs rounding and stores the resulting four, eight or sixteen
packed single-precision floating-point values to the destination operand (first source operand).
VFMSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From
the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision floating-point
values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-
precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Subtract of Packed Single-" doc_id="x86_64" token="vfmsub213ps">Performs a set of SIMD multiply-subtract computation on packed single-precision floating-point values using three
source operands and writes the multiply-subtract results in the destination operand. The destination operand is
also the first source operand. The second operand must be a SIMD register. The third source operand can be a
SIMD register or a memory location.
VFMSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision
floating-point values in the second source operand, performs rounding and stores the resulting four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFMSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the first source
operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision
floating-point values in the third source operand, performs rounding and stores the resulting four, eight or sixteen
packed single-precision floating-point values to the destination operand (first source operand).
VFMSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From
the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision floating-point
values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-
precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Subtract of Packed Single-" doc_id="x86_64" token="vfmsub231ps">Performs a set of SIMD multiply-subtract computation on packed single-precision floating-point values using three
source operands and writes the multiply-subtract results in the destination operand. The destination operand is
also the first source operand. The second operand must be a SIMD register. The third source operand can be a
SIMD register or a memory location.
VFMSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision
floating-point values in the second source operand, performs rounding and stores the resulting four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFMSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the first source
operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision
floating-point values in the third source operand, performs rounding and stores the resulting four, eight or sixteen
packed single-precision floating-point values to the destination operand (first source operand).
VFMSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From
the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision floating-point
values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-
precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Subtract of Scalar Double-" doc_id="x86_64" token="vfmsub132sd">Performs a SIMD multiply-subtract computation on the low packed double-precision floating-point values using
three source operands and writes the multiply-subtract result in the destination operand. The destination operand
is also the first source operand. The second operand must be a XMM register. The third source operand can be a
XMM register or a 64-bit memory location.
VFMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to
the low packed double-precision floating-point value in the third source operand. From the infinite precision inter-
mediate result, subtracts the low packed double-precision floating-point values in the second source operand,
performs rounding and stores the resulting packed double-precision floating-point value to the destination operand
(first source operand).
VFMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand to
the low packed double-precision floating-point value in the first source operand. From the infinite precision inter-
mediate result, subtracts the low packed double-precision floating-point value in the third source operand,
performs rounding and stores the resulting packed double-precision floating-point value to the destination operand
(first source operand).
VFMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low
packed double-precision floating-point value in the third source operand. From the infinite precision intermediate
result, subtracts the low packed double-precision floating-point value in the first source operand, performs
rounding and stores the resulting packed double-precision floating-point value to the destination operand (first
source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Subtract of Scalar Double-" doc_id="x86_64" token="vfmsub213sd">Performs a SIMD multiply-subtract computation on the low packed double-precision floating-point values using
three source operands and writes the multiply-subtract result in the destination operand. The destination operand
is also the first source operand. The second operand must be a XMM register. The third source operand can be a
XMM register or a 64-bit memory location.
VFMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to
the low packed double-precision floating-point value in the third source operand. From the infinite precision inter-
mediate result, subtracts the low packed double-precision floating-point values in the second source operand,
performs rounding and stores the resulting packed double-precision floating-point value to the destination operand
(first source operand).
VFMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand to
the low packed double-precision floating-point value in the first source operand. From the infinite precision inter-
mediate result, subtracts the low packed double-precision floating-point value in the third source operand,
performs rounding and stores the resulting packed double-precision floating-point value to the destination operand
(first source operand).
VFMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low
packed double-precision floating-point value in the third source operand. From the infinite precision intermediate
result, subtracts the low packed double-precision floating-point value in the first source operand, performs
rounding and stores the resulting packed double-precision floating-point value to the destination operand (first
source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Subtract of Scalar Double-" doc_id="x86_64" token="vfmsub231sd">Performs a SIMD multiply-subtract computation on the low packed double-precision floating-point values using
three source operands and writes the multiply-subtract result in the destination operand. The destination operand
is also the first source operand. The second operand must be a XMM register. The third source operand can be a
XMM register or a 64-bit memory location.
VFMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to
the low packed double-precision floating-point value in the third source operand. From the infinite precision inter-
mediate result, subtracts the low packed double-precision floating-point values in the second source operand,
performs rounding and stores the resulting packed double-precision floating-point value to the destination operand
(first source operand).
VFMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand to
the low packed double-precision floating-point value in the first source operand. From the infinite precision inter-
mediate result, subtracts the low packed double-precision floating-point value in the third source operand,
performs rounding and stores the resulting packed double-precision floating-point value to the destination operand
(first source operand).
VFMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low
packed double-precision floating-point value in the third source operand. From the infinite precision intermediate
result, subtracts the low packed double-precision floating-point value in the first source operand, performs
rounding and stores the resulting packed double-precision floating-point value to the destination operand (first
source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Subtract of Scalar Single-" doc_id="x86_64" token="vfmsub132ss">Performs a SIMD multiply-subtract computation on the low packed single-precision floating-point values using
three source operands and writes the multiply-subtract result in the destination operand. The destination operand
is also the first source operand. The second operand must be a XMM register. The third source operand can be a
XMM register or a 32-bit memory location.
VFMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the
low packed single-precision floating-point value in the third source operand. From the infinite precision interme-
diate result, subtracts the low packed single-precision floating-point values in the second source operand, performs
rounding and stores the resulting packed single-precision floating-point value to the destination operand (first
source operand).
VFMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to
the low packed single-precision floating-point value in the first source operand. From the infinite precision interme-
diate result, subtracts the low packed single-precision floating-point value in the third source operand, performs
rounding and stores the resulting packed single-precision floating-point value to the destination operand (first
source operand).
VFMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low
packed single-precision floating-point value in the third source operand. From the infinite precision intermediate
result, subtracts the low packed single-precision floating-point value in the first source operand, performs rounding
and stores the resulting packed single-precision floating-point value to the destination operand (first source
operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Subtract of Scalar Single-" doc_id="x86_64" token="vfmsub213ss">Performs a SIMD multiply-subtract computation on the low packed single-precision floating-point values using
three source operands and writes the multiply-subtract result in the destination operand. The destination operand
is also the first source operand. The second operand must be a XMM register. The third source operand can be a
XMM register or a 32-bit memory location.
VFMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the
low packed single-precision floating-point value in the third source operand. From the infinite precision interme-
diate result, subtracts the low packed single-precision floating-point values in the second source operand, performs
rounding and stores the resulting packed single-precision floating-point value to the destination operand (first
source operand).
VFMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to
the low packed single-precision floating-point value in the first source operand. From the infinite precision interme-
diate result, subtracts the low packed single-precision floating-point value in the third source operand, performs
rounding and stores the resulting packed single-precision floating-point value to the destination operand (first
source operand).
VFMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low
packed single-precision floating-point value in the third source operand. From the infinite precision intermediate
result, subtracts the low packed single-precision floating-point value in the first source operand, performs rounding
and stores the resulting packed single-precision floating-point value to the destination operand (first source
operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Multiply-Subtract of Scalar Single-" doc_id="x86_64" token="vfmsub231ss">Performs a SIMD multiply-subtract computation on the low packed single-precision floating-point values using
three source operands and writes the multiply-subtract result in the destination operand. The destination operand
is also the first source operand. The second operand must be a XMM register. The third source operand can be a
XMM register or a 32-bit memory location.
VFMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the
low packed single-precision floating-point value in the third source operand. From the infinite precision interme-
diate result, subtracts the low packed single-precision floating-point values in the second source operand, performs
rounding and stores the resulting packed single-precision floating-point value to the destination operand (first
source operand).
VFMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to
the low packed single-precision floating-point value in the first source operand. From the infinite precision interme-
diate result, subtracts the low packed single-precision floating-point value in the third source operand, performs
rounding and stores the resulting packed single-precision floating-point value to the destination operand (first
source operand).
VFMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low
packed single-precision floating-point value in the third source operand. From the infinite precision intermediate
result, subtracts the low packed single-precision floating-point value in the first source operand, performs rounding
and stores the resulting packed single-precision floating-point value to the destination operand (first source
operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Add of Packed" doc_id="x86_64" token="vfnmadd132pd">VFNMADD132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first
source operand to the two, four or eight packed double-precision floating-point values in the third source operand,
adds the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-
point values in the second source operand, performs rounding and stores the resulting two, four or eight packed
double-precision floating-point values to the destination operand (first source operand).
VFNMADD213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source operand to the two, four or eight packed double-precision floating-point values in the first source operand,
adds the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-
point values in the third source operand, performs rounding and stores the resulting two, four or eight packed
double-precision floating-point values to the destination operand (first source operand).
VFNMADD231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source to the two, four or eight packed double-precision floating-point values in the third source operand, the
negated infinite precision intermediate result to the two, four or eight packed double-precision floating-point values
in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision
floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Add of Packed" doc_id="x86_64" token="vfnmadd213pd">VFNMADD132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first
source operand to the two, four or eight packed double-precision floating-point values in the third source operand,
adds the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-
point values in the second source operand, performs rounding and stores the resulting two, four or eight packed
double-precision floating-point values to the destination operand (first source operand).
VFNMADD213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source operand to the two, four or eight packed double-precision floating-point values in the first source operand,
adds the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-
point values in the third source operand, performs rounding and stores the resulting two, four or eight packed
double-precision floating-point values to the destination operand (first source operand).
VFNMADD231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source to the two, four or eight packed double-precision floating-point values in the third source operand, the
negated infinite precision intermediate result to the two, four or eight packed double-precision floating-point values
in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision
floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Add of Packed" doc_id="x86_64" token="vfnmadd231pd">VFNMADD132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first
source operand to the two, four or eight packed double-precision floating-point values in the third source operand,
adds the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-
point values in the second source operand, performs rounding and stores the resulting two, four or eight packed
double-precision floating-point values to the destination operand (first source operand).
VFNMADD213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source operand to the two, four or eight packed double-precision floating-point values in the first source operand,
adds the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-
point values in the third source operand, performs rounding and stores the resulting two, four or eight packed
double-precision floating-point values to the destination operand (first source operand).
VFNMADD231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source to the two, four or eight packed double-precision floating-point values in the third source operand, the
negated infinite precision intermediate result to the two, four or eight packed double-precision floating-point values
in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision
floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Add of Packed" doc_id="x86_64" token="vfnmadd132ps">VFNMADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-preci-
sion floating-point values in the second source operand, performs rounding and stores the resulting four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFNMADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the first source
operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-preci-
sion floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFNMADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-preci-
sion floating-point values in the first source operand, performs rounding and stores the resulting four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Add of Packed" doc_id="x86_64" token="vfnmadd213ps">VFNMADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-preci-
sion floating-point values in the second source operand, performs rounding and stores the resulting four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFNMADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the first source
operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-preci-
sion floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFNMADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-preci-
sion floating-point values in the first source operand, performs rounding and stores the resulting four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Add of Packed" doc_id="x86_64" token="vfnmadd231ps">VFNMADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-preci-
sion floating-point values in the second source operand, performs rounding and stores the resulting four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFNMADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the first source
operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-preci-
sion floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFNMADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-preci-
sion floating-point values in the first source operand, performs rounding and stores the resulting four, eight or
sixteen packed single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Add of Scalar" doc_id="x86_64" token="vfnmadd132sd">VFNMADD132SD: Multiplies the low packed double-precision floating-point value from the first source operand to
the low packed double-precision floating-point value in the third source operand, adds the negated infinite preci-
sion intermediate result to the low packed double-precision floating-point values in the second source operand,
performs rounding and stores the resulting packed double-precision floating-point value to the destination operand
(first source operand).
VFNMADD213SD: Multiplies the low packed double-precision floating-point value from the second source operand
to the low packed double-precision floating-point value in the first source operand, adds the negated infinite preci-
sion intermediate result to the low packed double-precision floating-point value in the third source operand,
performs rounding and stores the resulting packed double-precision floating-point value to the destination operand
(first source operand).
VFNMADD231SD: Multiplies the low packed double-precision floating-point value from the second source to the low
packed double-precision floating-point value in the third source operand, adds the negated infinite precision inter-
mediate result to the low packed double-precision floating-point value in the first source operand, performs
rounding and stores the resulting packed double-precision floating-point value to the destination operand (first
source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Add of Scalar" doc_id="x86_64" token="vfnmadd213sd">VFNMADD132SD: Multiplies the low packed double-precision floating-point value from the first source operand to
the low packed double-precision floating-point value in the third source operand, adds the negated infinite preci-
sion intermediate result to the low packed double-precision floating-point values in the second source operand,
performs rounding and stores the resulting packed double-precision floating-point value to the destination operand
(first source operand).
VFNMADD213SD: Multiplies the low packed double-precision floating-point value from the second source operand
to the low packed double-precision floating-point value in the first source operand, adds the negated infinite preci-
sion intermediate result to the low packed double-precision floating-point value in the third source operand,
performs rounding and stores the resulting packed double-precision floating-point value to the destination operand
(first source operand).
VFNMADD231SD: Multiplies the low packed double-precision floating-point value from the second source to the low
packed double-precision floating-point value in the third source operand, adds the negated infinite precision inter-
mediate result to the low packed double-precision floating-point value in the first source operand, performs
rounding and stores the resulting packed double-precision floating-point value to the destination operand (first
source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Add of Scalar" doc_id="x86_64" token="vfnmadd231sd">VFNMADD132SD: Multiplies the low packed double-precision floating-point value from the first source operand to
the low packed double-precision floating-point value in the third source operand, adds the negated infinite preci-
sion intermediate result to the low packed double-precision floating-point values in the second source operand,
performs rounding and stores the resulting packed double-precision floating-point value to the destination operand
(first source operand).
VFNMADD213SD: Multiplies the low packed double-precision floating-point value from the second source operand
to the low packed double-precision floating-point value in the first source operand, adds the negated infinite preci-
sion intermediate result to the low packed double-precision floating-point value in the third source operand,
performs rounding and stores the resulting packed double-precision floating-point value to the destination operand
(first source operand).
VFNMADD231SD: Multiplies the low packed double-precision floating-point value from the second source to the low
packed double-precision floating-point value in the third source operand, adds the negated infinite precision inter-
mediate result to the low packed double-precision floating-point value in the first source operand, performs
rounding and stores the resulting packed double-precision floating-point value to the destination operand (first
source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Add of Scalar" doc_id="x86_64" token="vfnmadd132ss">VFNMADD132SS: Multiplies the low packed single-precision floating-point value from the first source operand to
the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision
intermediate result to the low packed single-precision floating-point value in the second source operand, performs
rounding and stores the resulting packed single-precision floating-point value to the destination operand (first
source operand).
VFNMADD213SS: Multiplies the low packed single-precision floating-point value from the second source operand
to the low packed single-precision floating-point value in the first source operand, adds the negated infinite preci-
sion intermediate result to the low packed single-precision floating-point value in the third source operand,
performs rounding and stores the resulting packed single-precision floating-point value to the destination operand
(first source operand).
VFNMADD231SS: Multiplies the low packed single-precision floating-point value from the second source operand
to the low packed single-precision floating-point value in the third source operand, adds the negated infinite preci-
sion intermediate result to the low packed single-precision floating-point value in the first source operand,
performs rounding and stores the resulting packed single-precision floating-point value to the destination operand
(first source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Add of Scalar" doc_id="x86_64" token="vfnmadd213ss">VFNMADD132SS: Multiplies the low packed single-precision floating-point value from the first source operand to
the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision
intermediate result to the low packed single-precision floating-point value in the second source operand, performs
rounding and stores the resulting packed single-precision floating-point value to the destination operand (first
source operand).
VFNMADD213SS: Multiplies the low packed single-precision floating-point value from the second source operand
to the low packed single-precision floating-point value in the first source operand, adds the negated infinite preci-
sion intermediate result to the low packed single-precision floating-point value in the third source operand,
performs rounding and stores the resulting packed single-precision floating-point value to the destination operand
(first source operand).
VFNMADD231SS: Multiplies the low packed single-precision floating-point value from the second source operand
to the low packed single-precision floating-point value in the third source operand, adds the negated infinite preci-
sion intermediate result to the low packed single-precision floating-point value in the first source operand,
performs rounding and stores the resulting packed single-precision floating-point value to the destination operand
(first source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Add of Scalar" doc_id="x86_64" token="vfnmadd231ss">VFNMADD132SS: Multiplies the low packed single-precision floating-point value from the first source operand to
the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision
intermediate result to the low packed single-precision floating-point value in the second source operand, performs
rounding and stores the resulting packed single-precision floating-point value to the destination operand (first
source operand).
VFNMADD213SS: Multiplies the low packed single-precision floating-point value from the second source operand
to the low packed single-precision floating-point value in the first source operand, adds the negated infinite preci-
sion intermediate result to the low packed single-precision floating-point value in the third source operand,
performs rounding and stores the resulting packed single-precision floating-point value to the destination operand
(first source operand).
VFNMADD231SS: Multiplies the low packed single-precision floating-point value from the second source operand
to the low packed single-precision floating-point value in the third source operand, adds the negated infinite preci-
sion intermediate result to the low packed single-precision floating-point value in the first source operand,
performs rounding and stores the resulting packed single-precision floating-point value to the destination operand
(first source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Subtract of" doc_id="x86_64" token="vfnmsub132pd">VFNMSUB132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first
source operand to the two, four or eight packed double-precision floating-point values in the third source operand.
From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision
floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight
packed double-precision floating-point values to the destination operand (first source operand).
VFNMSUB213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source operand to the two, four or eight packed double-precision floating-point values in the first source operand.
From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision
floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight
packed double-precision floating-point values to the destination operand (first source operand).
VFNMSUB231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source to the two, four or eight packed double-precision floating-point values in the third source operand. From
negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision floating-
point values in the first source operand, performs rounding and stores the resulting two, four or eight packed
double-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Subtract of" doc_id="x86_64" token="vfnmsub213pd">VFNMSUB132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first
source operand to the two, four or eight packed double-precision floating-point values in the third source operand.
From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision
floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight
packed double-precision floating-point values to the destination operand (first source operand).
VFNMSUB213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source operand to the two, four or eight packed double-precision floating-point values in the first source operand.
From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision
floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight
packed double-precision floating-point values to the destination operand (first source operand).
VFNMSUB231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source to the two, four or eight packed double-precision floating-point values in the third source operand. From
negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision floating-
point values in the first source operand, performs rounding and stores the resulting two, four or eight packed
double-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Subtract of" doc_id="x86_64" token="vfnmsub231pd">VFNMSUB132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first
source operand to the two, four or eight packed double-precision floating-point values in the third source operand.
From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision
floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight
packed double-precision floating-point values to the destination operand (first source operand).
VFNMSUB213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source operand to the two, four or eight packed double-precision floating-point values in the first source operand.
From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision
floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight
packed double-precision floating-point values to the destination operand (first source operand).
VFNMSUB231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second
source to the two, four or eight packed double-precision floating-point values in the third source operand. From
negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision floating-
point values in the first source operand, performs rounding and stores the resulting two, four or eight packed
double-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Subtract of" doc_id="x86_64" token="vfnmsub132ps">VFNMSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-
precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight
or sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFNMSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the first source
operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-
precision floating-point values in the third source operand, performs rounding and stores the resulting four, eight
or sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFNMSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From
negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-precision floating-
point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed
single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Subtract of" doc_id="x86_64" token="vfnmsub213ps">VFNMSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-
precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight
or sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFNMSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the first source
operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-
precision floating-point values in the third source operand, performs rounding and stores the resulting four, eight
or sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFNMSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From
negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-precision floating-
point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed
single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Subtract of" doc_id="x86_64" token="vfnmsub231ps">VFNMSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first
source operand to the four, eight or sixteen packed single-precision floating-point values in the third source
operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-
precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight
or sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFNMSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source operand to the four, eight or sixteen packed single-precision floating-point values in the first source
operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-
precision floating-point values in the third source operand, performs rounding and stores the resulting four, eight
or sixteen packed single-precision floating-point values to the destination operand (first source operand).
VFNMSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second
source to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From
negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-precision floating-
point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed
single-precision floating-point values to the destination operand (first source operand).
EVEX encoded versions: The destination operand (also first source operand) and the second source operand are
ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory loca-
tion or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is condition-
ally updated with write mask k1.
VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in
reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a
YMM register or a 256-bit memory location and encoded in rm_field.
VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in
reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a
XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination
register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Subtract of" doc_id="x86_64" token="vfnmsub132sd">VFNMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to
the low packed double-precision floating-point value in the third source operand. From negated infinite precision
intermediate result, subtracts the low double-precision floating-point value in the second source operand, performs
rounding and stores the resulting packed double-precision floating-point value to the destination operand (first
source operand).
VFNMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand
to the low packed double-precision floating-point value in the first source operand. From negated infinite precision
intermediate result, subtracts the low double-precision floating-point value in the third source operand, performs
rounding and stores the resulting packed double-precision floating-point value to the destination operand (first
source operand).
VFNMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low
packed double-precision floating-point value in the third source operand. From negated infinite precision interme-
diate result, subtracts the low double-precision floating-point value in the first source operand, performs rounding
and stores the resulting packed double-precision floating-point value to the destination operand (first source
operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Subtract of" doc_id="x86_64" token="vfnmsub213sd">VFNMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to
the low packed double-precision floating-point value in the third source operand. From negated infinite precision
intermediate result, subtracts the low double-precision floating-point value in the second source operand, performs
rounding and stores the resulting packed double-precision floating-point value to the destination operand (first
source operand).
VFNMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand
to the low packed double-precision floating-point value in the first source operand. From negated infinite precision
intermediate result, subtracts the low double-precision floating-point value in the third source operand, performs
rounding and stores the resulting packed double-precision floating-point value to the destination operand (first
source operand).
VFNMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low
packed double-precision floating-point value in the third source operand. From negated infinite precision interme-
diate result, subtracts the low double-precision floating-point value in the first source operand, performs rounding
and stores the resulting packed double-precision floating-point value to the destination operand (first source
operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Subtract of" doc_id="x86_64" token="vfnmsub231sd">VFNMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to
the low packed double-precision floating-point value in the third source operand. From negated infinite precision
intermediate result, subtracts the low double-precision floating-point value in the second source operand, performs
rounding and stores the resulting packed double-precision floating-point value to the destination operand (first
source operand).
VFNMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand
to the low packed double-precision floating-point value in the first source operand. From negated infinite precision
intermediate result, subtracts the low double-precision floating-point value in the third source operand, performs
rounding and stores the resulting packed double-precision floating-point value to the destination operand (first
source operand).
VFNMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low
packed double-precision floating-point value in the third source operand. From negated infinite precision interme-
diate result, subtracts the low double-precision floating-point value in the first source operand, performs rounding
and stores the resulting packed double-precision floating-point value to the destination operand (first source
operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.</hint>
<hint page="0" header="Fused Negative Multiply-Subtract of" doc_id="x86_64" token="vfnmsub132ss">VFNMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to
the low packed single-precision floating-point value in the third source operand. From negated infinite precision
intermediate result, the low single-precision floating-point value in the second source operand, performs rounding
and stores the resulting packed single-precision floating-point value to the destination operand (first source
operand).
VFNMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to
the low packed single-precision floating-point value in the first source operand. From negated infinite precision
intermediate result, the low single-precision floating-point value in the third source operand, performs rounding
and stores the resulting packed single-precision floating-point value to the destination operand (first source
operand).
VFNMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low
packed single-precision floating-point value in the third source operand. From negated infinite precision interme-
diate result, the low single-precision floating-point value in the first source operand, performs rounding and stores
the resulting packed single-precision floating-point value to the destination operand (first source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.
EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.
Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the
opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations
involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction
column.</hint>
<hint page="0" header="Fused Negative Multiply-Subtract of" doc_id="x86_64" token="vfnmsub213ss">VFNMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to
the low packed single-precision floating-point value in the third source operand. From negated infinite precision
intermediate result, the low single-precision floating-point value in the second source operand, performs rounding
and stores the resulting packed single-precision floating-point value to the destination operand (first source
operand).
VFNMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to
the low packed single-precision floating-point value in the first source operand. From negated infinite precision
intermediate result, the low single-precision floating-point value in the third source operand, performs rounding
and stores the resulting packed single-precision floating-point value to the destination operand (first source
operand).
VFNMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low
packed single-precision floating-point value in the third source operand. From negated infinite precision interme-
diate result, the low single-precision floating-point value in the first source operand, performs rounding and stores
the resulting packed single-precision floating-point value to the destination operand (first source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.
EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.
Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the
opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations
involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction
column.</hint>
<hint page="0" header="Fused Negative Multiply-Subtract of" doc_id="x86_64" token="vfnmsub231ss">VFNMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to
the low packed single-precision floating-point value in the third source operand. From negated infinite precision
intermediate result, the low single-precision floating-point value in the second source operand, performs rounding
and stores the resulting packed single-precision floating-point value to the destination operand (first source
operand).
VFNMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to
the low packed single-precision floating-point value in the first source operand. From negated infinite precision
intermediate result, the low single-precision floating-point value in the third source operand, performs rounding
and stores the resulting packed single-precision floating-point value to the destination operand (first source
operand).
VFNMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low
packed single-precision floating-point value in the third source operand. From negated infinite precision interme-
diate result, the low single-precision floating-point value in the first source operand, performs rounding and stores
the resulting packed single-precision floating-point value to the destination operand (first source operand).
VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field.
The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field.
Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.
EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.
Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the
opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations
involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction
column.</hint>
<hint page="0" header="Tests Types Of a Packed Float64 Values" doc_id="x86_64" token="vfpclasspd">The FPCLASSPD instruction checks the packed double precision floating point values for special categories, speci-
fied by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point values that the
input data element is classified against. The classified results of all specified categories of an input value are ORed
together to form the final boolean result for the input element. The result of each element is written to the corre-
sponding bit in a mask register k2 according to the writemask k1. Bits [MAX_KL-1:8/4/2] of the destination are
cleared.
The classification categories specified by imm8 are shown in Figure 5-13. The classification test for each category
is listed in Table 5-6.</hint>
<hint page="0" header="Tests Types Of a Packed Float32 Values" doc_id="x86_64" token="vfpclassps">The FPCLASSPS instruction checks the packed single-precision floating point values for special categories, specified
by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point values that the input
data element is classified against. The classified results of all specified categories of an input value are ORed
together to form the final boolean result for the input element. The result of each element is written to the corre-
sponding bit in a mask register k2 according to the writemask k1. Bits [MAX_KL-1:16/8/4] of the destination are
cleared.
The classification categories specified by imm8 are shown in Figure 5-13. The classification test for each category
is listed in Table 5-6.
The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector
broadcasted from a 32-bit memory location.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Tests Types Of a Scalar Float64 Values" doc_id="x86_64" token="vfpclasssd">The FPCLASSSD instruction checks the low double precision floating point value in the source operand for special
categories, specified by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point
values that the input data element is classified against. The classified results of all specified categories of an input
value are ORed together to form the final boolean result for the input element. The result is written to the low bit
in a mask register k2 according to the writemask k1. Bits MAX_KL-1: 1 of the destination are cleared.
The classification categories specified by imm8 are shown in Figure 5-13. The classification test for each category
is listed in Table 5-6.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Tests Types Of a Scalar Float32 Values" doc_id="x86_64" token="vfpclassss">The FPCLASSSS instruction checks the low single-precision floating point value in the source operand for special
categories, specified by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point
values that the input data element is classified against. The classified results of all specified categories of an input
value are ORed together to form the final boolean result for the input element. The result is written to the low bit
in a mask register k2 according to the writemask k1. Bits MAX_KL-1: 1 of the destination are cleared.
The classification categories specified by imm8 are shown in Figure 5-13. The classification test for each category
is listed in Table 5-6.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Gather Packed DP FP Values Using Signed Dword/Qword Indices" doc_id="x86_64" token="vgatherdpd">The instruction conditionally loads up to 2 or 4 double-precision floating-point values from memory addresses
specified by the memory operand (the second operand) and using qword indices. The memory operand uses the
VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for
an array of indices relative to the base and a constant scale factor.
The mask operand (the third operand) specifies the conditional load operation from each memory address and the
corresponding update of each data element of the destination operand (the first operand). Conditionality is speci-
fied by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the
corresponding element of the destination register is left unchanged. The width of data element in the destination
register and mask register are identical. The entire mask register will be set to zero by this instruction unless the
instruction causes an exception.
Using dword indices in the lower half of the mask register, the instruction conditionally loads up to 2 or 4 double-
precision floating-point values from the VSIB addressing memory operand, and updates the destination register.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask operand are partially updated; those elements that have been gathered are placed into the
destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gath-
ered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction
breakpoint is not re-triggered when the instruction is continued.
If the data size and index size are different, part of the destination register and part of the mask register do not
correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both
of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception
before gathering any elements.</hint>
<hint page="0" header="Gather Packed DP FP Values Using Signed Dword/Qword Indices" doc_id="x86_64" token="vgatherqpd">The instruction conditionally loads up to 2 or 4 double-precision floating-point values from memory addresses
specified by the memory operand (the second operand) and using qword indices. The memory operand uses the
VSIB form of the SIB byte to specify a general purpose register operand as the common base, a vector register for
an array of indices relative to the base and a constant scale factor.
The mask operand (the third operand) specifies the conditional load operation from each memory address and the
corresponding update of each data element of the destination operand (the first operand). Conditionality is speci-
fied by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the
corresponding element of the destination register is left unchanged. The width of data element in the destination
register and mask register are identical. The entire mask register will be set to zero by this instruction unless the
instruction causes an exception.
Using dword indices in the lower half of the mask register, the instruction conditionally loads up to 2 or 4 double-
precision floating-point values from the VSIB addressing memory operand, and updates the destination register.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask operand are partially updated; those elements that have been gathered are placed into the
destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gath-
ered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction
breakpoint is not re-triggered when the instruction is continued.
If the data size and index size are different, part of the destination register and part of the mask register do not
correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both
of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception
before gathering any elements.</hint>
<hint page="0" header="Gather Packed SP FP values Using Signed Dword/Qword Indices" doc_id="x86_64" token="vgatherdps">The instruction conditionally loads up to 4 or 8 single-precision floating-point values from memory addresses spec-
ified by the memory operand (the second operand) and using dword indices. The memory operand uses the VSIB
form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an
array of indices relative to the base and a constant scale factor.
The mask operand (the third operand) specifies the conditional load operation from each memory address and the
corresponding update of each data element of the destination operand (the first operand). Conditionality is speci-
fied by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the
corresponding element of the destination register is left unchanged. The width of data element in the destination
register and mask register are identical. The entire mask register will be set to zero by this instruction unless the
instruction causes an exception.
Using qword indices, the instruction conditionally loads up to 2 or 4 single-precision floating-point values from the
VSIB addressing memory operand, and updates the lower half of the destination register. The upper 128 or 256 bits
of the destination register are zero'ed with qword indices.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask operand are partially updated; those elements that have been gathered are placed into the
destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gath-
ered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction
breakpoint is not re-triggered when the instruction is continued.
If the data size and index size are different, part of the destination register and part of the mask register do not
correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both
of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception
before gathering any elements.</hint>
<hint page="0" header="Gather Packed SP FP values Using Signed Dword/Qword Indices" doc_id="x86_64" token="vgatherqps">The instruction conditionally loads up to 4 or 8 single-precision floating-point values from memory addresses spec-
ified by the memory operand (the second operand) and using dword indices. The memory operand uses the VSIB
form of the SIB byte to specify a general purpose register operand as the common base, a vector register for an
array of indices relative to the base and a constant scale factor.
The mask operand (the third operand) specifies the conditional load operation from each memory address and the
corresponding update of each data element of the destination operand (the first operand). Conditionality is speci-
fied by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the
corresponding element of the destination register is left unchanged. The width of data element in the destination
register and mask register are identical. The entire mask register will be set to zero by this instruction unless the
instruction causes an exception.
Using qword indices, the instruction conditionally loads up to 2 or 4 single-precision floating-point values from the
VSIB addressing memory operand, and updates the lower half of the destination register. The upper 128 or 256 bits
of the destination register are zero'ed with qword indices.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask operand are partially updated; those elements that have been gathered are placed into the
destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gath-
ered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction
breakpoint is not re-triggered when the instruction is continued.
If the data size and index size are different, part of the destination register and part of the mask register do not
correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both
of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception
before gathering any elements.</hint>
<hint page="0" header="Gather Packed Single, Packed Double with Signed Dword" doc_id="x86_64" token="vgatherdps">A set of single-precision/double-precision faulting-point memory locations pointed by base address BASE_ADDR
and index vector V_INDEX with scale SCALE are gathered. The result is written into a vector register. The elements
are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only
be loaded if their corresponding mask bit is one. If an element's mask bit is not set, the corresponding element of
the destination register is left unchanged. The entire mask register will be set to zero by this instruction unless it
triggers an exception.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the right most one with its mask bit set). When this happens, the destination
register and the mask register (k1) are partially updated; those elements that have been gathered are placed into
the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already
gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruc-
tion breakpoint is not re-triggered when the instruction is continued.
If the data element size is less than the index element size, the higher part of the destination register and the mask
register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may
update these unused elements to one or both of those registers even if the instruction triggers an exception, and
even if the instruction triggers the exception before gathering any elements.
Note that:
.     The values may be read from memory in any order. Memory ordering with other instructions follows the Intel-
      64 memory-ordering model.
.     Faults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all
      elements closer to the LSB of the destination zmm will be completed (and non-faulting). Individual elements
      closer to the MSB may or may not be completed. If a given element triggers multiple faults, they are delivered
      in the conventional order.
.     Elements may be gathered in any order, but faults must be delivered in a right-to left order; thus, elements to
      the left of a faulting one may be gathered before the fault is delivered. A given implementation of this
      instruction is repeatable - given the same input values and architectural state, the same set of elements to the
      left of the faulting one will be gathered.</hint>
<hint page="0" header="Gather Packed Single, Packed Double with Signed Dword" doc_id="x86_64" token="vgatherdpd">A set of single-precision/double-precision faulting-point memory locations pointed by base address BASE_ADDR
and index vector V_INDEX with scale SCALE are gathered. The result is written into a vector register. The elements
are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only
be loaded if their corresponding mask bit is one. If an element's mask bit is not set, the corresponding element of
the destination register is left unchanged. The entire mask register will be set to zero by this instruction unless it
triggers an exception.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the right most one with its mask bit set). When this happens, the destination
register and the mask register (k1) are partially updated; those elements that have been gathered are placed into
the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already
gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruc-
tion breakpoint is not re-triggered when the instruction is continued.
If the data element size is less than the index element size, the higher part of the destination register and the mask
register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may
update these unused elements to one or both of those registers even if the instruction triggers an exception, and
even if the instruction triggers the exception before gathering any elements.
Note that:
.     The values may be read from memory in any order. Memory ordering with other instructions follows the Intel-
      64 memory-ordering model.
.     Faults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all
      elements closer to the LSB of the destination zmm will be completed (and non-faulting). Individual elements
      closer to the MSB may or may not be completed. If a given element triggers multiple faults, they are delivered
      in the conventional order.
.     Elements may be gathered in any order, but faults must be delivered in a right-to left order; thus, elements to
      the left of a faulting one may be gathered before the fault is delivered. A given implementation of this
      instruction is repeatable - given the same input values and architectural state, the same set of elements to the
      left of the faulting one will be gathered.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vgatherpf0dps">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T0):
. T0 (temporal data)-prefetch data into the first level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vgatherpf0qps">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T0):
. T0 (temporal data)-prefetch data into the first level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vgatherpf0dpd">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T0):
. T0 (temporal data)-prefetch data into the first level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vgatherpf0qpd">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T0):
. T0 (temporal data)-prefetch data into the first level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vgatherpf1dps">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T1):
. T1 (temporal data)-prefetch data into the second level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vgatherpf1qps">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T1):
. T1 (temporal data)-prefetch data into the second level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vgatherpf1dpd">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T1):
. T1 (temporal data)-prefetch data into the second level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vgatherpf1qpd">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T1):
. T1 (temporal data)-prefetch data into the second level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Gather Packed Single, Packed Double with Signed Qword Indices" doc_id="x86_64" token="vgatherqps">A set of 8 single-precision/double-precision faulting-point memory locations pointed by base address BASE_ADDR
and index vector V_INDEX with scale SCALE are gathered. The result is written into vector a register. The elements
are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be
loaded if their corresponding mask bit is one. If an element's mask bit is not set, the corresponding element of the
destination register is left unchanged. The entire mask register will be set to zero by this instruction unless it trig-
gers an exception.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register (k1) are partially updated; those elements that have been gathered are placed into
the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already
gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruc-
tion breakpoint is not re-triggered when the instruction is continued.
If the data element size is less than the index element size, the higher part of the destination register and the mask
register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may
update these unused elements to one or both of those registers even if the instruction triggers an exception, and
even if the instruction triggers the exception before gathering any elements.
Note that:
.     The values may be read from memory in any order. Memory ordering with other instructions follows the Intel-
      64 memory-ordering model.
.     Faults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all
      elements closer to the LSB of the destination zmm will be completed (and non-faulting). Individual elements
      closer to the MSB may or may not be completed. If a given element triggers multiple faults, they are delivered
      in the conventional order.</hint>
<hint page="0" header="Gather Packed Single, Packed Double with Signed Qword Indices" doc_id="x86_64" token="vgatherqpd">A set of 8 single-precision/double-precision faulting-point memory locations pointed by base address BASE_ADDR
and index vector V_INDEX with scale SCALE are gathered. The result is written into vector a register. The elements
are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be
loaded if their corresponding mask bit is one. If an element's mask bit is not set, the corresponding element of the
destination register is left unchanged. The entire mask register will be set to zero by this instruction unless it trig-
gers an exception.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register (k1) are partially updated; those elements that have been gathered are placed into
the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already
gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruc-
tion breakpoint is not re-triggered when the instruction is continued.
If the data element size is less than the index element size, the higher part of the destination register and the mask
register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may
update these unused elements to one or both of those registers even if the instruction triggers an exception, and
even if the instruction triggers the exception before gathering any elements.
Note that:
.     The values may be read from memory in any order. Memory ordering with other instructions follows the Intel-
      64 memory-ordering model.
.     Faults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all
      elements closer to the LSB of the destination zmm will be completed (and non-faulting). Individual elements
      closer to the MSB may or may not be completed. If a given element triggers multiple faults, they are delivered
      in the conventional order.</hint>
<hint page="0" header="Gather Packed Dword Values Using Signed Dword/Qword" doc_id="x86_64" token="vpgatherdd">The instruction conditionally loads up to 4 or 8 dword values from memory addresses specified by the memory
operand (the second operand) and using dword indices. The memory operand uses the VSIB form of the SIB byte
to specify a general purpose register operand as the common base, a vector register for an array of indices relative
to the base and a constant scale factor.
The mask operand (the third operand) specifies the conditional load operation from each memory address and the
corresponding update of each data element of the destination operand (the first operand). Conditionality is speci-
fied by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the
corresponding element of the destination register is left unchanged. The width of data element in the destination
register and mask register are identical. The entire mask register will be set to zero by this instruction unless the
instruction causes an exception.
Using qword indices, the instruction conditionally loads up to 2 or 4 qword values from the VSIB addressing
memory operand, and updates the lower half of the destination register. The upper 128 or 256 bits of the destina-
tion register are zero'ed with qword indices.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask operand are partially updated; those elements that have been gathered are placed into the
destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gath-
ered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction
breakpoint is not re-triggered when the instruction is continued.
If the data size and index size are different, part of the destination register and part of the mask register do not
correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both
of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception
before gathering any elements.
VEX.128 version: For dword indices, the instruction will gather four dword values. For qword indices, the instruc-
tion will gather two values and zeroes the upper 64 bits of the destination.</hint>
<hint page="0" header="Gather Packed Dword Values Using Signed Dword/Qword" doc_id="x86_64" token="vpgatherqd">The instruction conditionally loads up to 4 or 8 dword values from memory addresses specified by the memory
operand (the second operand) and using dword indices. The memory operand uses the VSIB form of the SIB byte
to specify a general purpose register operand as the common base, a vector register for an array of indices relative
to the base and a constant scale factor.
The mask operand (the third operand) specifies the conditional load operation from each memory address and the
corresponding update of each data element of the destination operand (the first operand). Conditionality is speci-
fied by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the
corresponding element of the destination register is left unchanged. The width of data element in the destination
register and mask register are identical. The entire mask register will be set to zero by this instruction unless the
instruction causes an exception.
Using qword indices, the instruction conditionally loads up to 2 or 4 qword values from the VSIB addressing
memory operand, and updates the lower half of the destination register. The upper 128 or 256 bits of the destina-
tion register are zero'ed with qword indices.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask operand are partially updated; those elements that have been gathered are placed into the
destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gath-
ered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction
breakpoint is not re-triggered when the instruction is continued.
If the data size and index size are different, part of the destination register and part of the mask register do not
correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both
of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception
before gathering any elements.
VEX.128 version: For dword indices, the instruction will gather four dword values. For qword indices, the instruc-
tion will gather two values and zeroes the upper 64 bits of the destination.</hint>
<hint page="0" header="Gather Packed Dword, Packed Qword with Signed Dword Indices" doc_id="x86_64" token="vpgatherdd">A set of 16 or 8 doubleword/quadword memory locations pointed to by base address BASE_ADDR and index vector
VINDEX with scale SCALE are gathered. The result is written into vector zmm1. The elements are specified via the
VSIB (i.e., the index register is a zmm, holding packed indices). Elements will only be loaded if their corresponding
mask bit is one. If an element's mask bit is not set, the corresponding element of the destination register (zmm1)
is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an exception.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register (k1) are partially updated; those elements that have been gathered are placed into
the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already
gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruc-
tion breakpoint is not re-triggered when the instruction is continued.
If the data element size is less than the index element size, the higher part of the destination register and the mask
register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may
update these unused elements to one or both of those registers even if the instruction triggers an exception, and
even if the instruction triggers the exception before gathering any elements.
Note that:
.     The values may be read from memory in any order. Memory ordering with other instructions follows the Intel-
      64 memory-ordering model.
.     Faults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all
      elements closer to the LSB of the destination zmm will be completed (and non-faulting). Individual elements
      closer to the MSB may or may not be completed. If a given element triggers multiple faults, they are delivered
      in the conventional order.
.     Elements may be gathered in any order, but faults must be delivered in a right-to-left order; thus, elements to
      the left of a faulting one may be gathered before the fault is delivered. A given implementation of this
      instruction is repeatable - given the same input values and architectural state, the same set of elements to the
      left of the faulting one will be gathered.
.     This instruction does not perform AC checks, and so will never deliver an AC fault.
.     Not valid with 16-bit effective addresses. Will deliver a #UD fault.
.     These instructions do not accept zeroing-masking since the 0 values in k1 are used to determine completion.</hint>
<hint page="0" header="Gather Packed Dword, Packed Qword with Signed Dword Indices" doc_id="x86_64" token="vpgatherdq">A set of 16 or 8 doubleword/quadword memory locations pointed to by base address BASE_ADDR and index vector
VINDEX with scale SCALE are gathered. The result is written into vector zmm1. The elements are specified via the
VSIB (i.e., the index register is a zmm, holding packed indices). Elements will only be loaded if their corresponding
mask bit is one. If an element's mask bit is not set, the corresponding element of the destination register (zmm1)
is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an exception.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register (k1) are partially updated; those elements that have been gathered are placed into
the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already
gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruc-
tion breakpoint is not re-triggered when the instruction is continued.
If the data element size is less than the index element size, the higher part of the destination register and the mask
register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may
update these unused elements to one or both of those registers even if the instruction triggers an exception, and
even if the instruction triggers the exception before gathering any elements.
Note that:
.     The values may be read from memory in any order. Memory ordering with other instructions follows the Intel-
      64 memory-ordering model.
.     Faults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all
      elements closer to the LSB of the destination zmm will be completed (and non-faulting). Individual elements
      closer to the MSB may or may not be completed. If a given element triggers multiple faults, they are delivered
      in the conventional order.
.     Elements may be gathered in any order, but faults must be delivered in a right-to-left order; thus, elements to
      the left of a faulting one may be gathered before the fault is delivered. A given implementation of this
      instruction is repeatable - given the same input values and architectural state, the same set of elements to the
      left of the faulting one will be gathered.
.     This instruction does not perform AC checks, and so will never deliver an AC fault.
.     Not valid with 16-bit effective addresses. Will deliver a #UD fault.
.     These instructions do not accept zeroing-masking since the 0 values in k1 are used to determine completion.</hint>
<hint page="0" header="Gather Packed Qword Values Using Signed Dword/Qword" doc_id="x86_64" token="vpgatherdq">The instruction conditionally loads up to 2 or 4 qword values from memory addresses specified by the memory
operand (the second operand) and using qword indices. The memory operand uses the VSIB form of the SIB byte
to specify a general purpose register operand as the common base, a vector register for an array of indices relative
to the base and a constant scale factor.
The mask operand (the third operand) specifies the conditional load operation from each memory address and the
corresponding update of each data element of the destination operand (the first operand). Conditionality is speci-
fied by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the
corresponding element of the destination register is left unchanged. The width of data element in the destination
register and mask register are identical. The entire mask register will be set to zero by this instruction unless the
instruction causes an exception.
Using dword indices in the lower half of the mask register, the instruction conditionally loads up to 2 or 4 qword
values from the VSIB addressing memory operand, and updates the destination register.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask operand are partially updated; those elements that have been gathered are placed into the
destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gath-
ered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction
breakpoint is not re-triggered when the instruction is continued.
If the data size and index size are different, part of the destination register and part of the mask register do not
correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both
of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception
before gathering any elements.
VEX.128 version: The instruction will gather two qword values. For dword indices, only the lower two indices in the
vector index register are used.</hint>
<hint page="0" header="Gather Packed Qword Values Using Signed Dword/Qword" doc_id="x86_64" token="vpgatherqq">The instruction conditionally loads up to 2 or 4 qword values from memory addresses specified by the memory
operand (the second operand) and using qword indices. The memory operand uses the VSIB form of the SIB byte
to specify a general purpose register operand as the common base, a vector register for an array of indices relative
to the base and a constant scale factor.
The mask operand (the third operand) specifies the conditional load operation from each memory address and the
corresponding update of each data element of the destination operand (the first operand). Conditionality is speci-
fied by the most significant bit of each data element of the mask register. If an element's mask bit is not set, the
corresponding element of the destination register is left unchanged. The width of data element in the destination
register and mask register are identical. The entire mask register will be set to zero by this instruction unless the
instruction causes an exception.
Using dword indices in the lower half of the mask register, the instruction conditionally loads up to 2 or 4 qword
values from the VSIB addressing memory operand, and updates the destination register.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask operand are partially updated; those elements that have been gathered are placed into the
destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gath-
ered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction
breakpoint is not re-triggered when the instruction is continued.
If the data size and index size are different, part of the destination register and part of the mask register do not
correspond to any elements being gathered. This instruction sets those parts to zero. It may do this to one or both
of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception
before gathering any elements.
VEX.128 version: The instruction will gather two qword values. For dword indices, only the lower two indices in the
vector index register are used.</hint>
<hint page="0" header="Gather Packed Dword, Packed Qword with Signed Qword Indices" doc_id="x86_64" token="vpgatherqd">A set of 8 doubleword/quadword memory locations pointed to by base address BASE_ADDR and index vector
VINDEX with scale SCALE are gathered. The result is written into a vector register. The elements are specified via
the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be loaded if their
corresponding mask bit is one. If an element's mask bit is not set, the corresponding element of the destination
register is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an excep-
tion.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register (k1) are partially updated; those elements that have been gathered are placed into
the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already
gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruc-
tion breakpoint is not re-triggered when the instruction is continued.
If the data element size is less than the index element size, the higher part of the destination register and the mask
register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may
update these unused elements to one or both of those registers even if the instruction triggers an exception, and
even if the instruction triggers the exception before gathering any elements.
Note that:
.     The values may be read from memory in any order. Memory ordering with other instructions follows the Intel-
      64 memory-ordering model.
.     Faults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all
      elements closer to the LSB of the destination zmm will be completed (and non-faulting). Individual elements
      closer to the MSB may or may not be completed. If a given element triggers multiple faults, they are delivered
      in the conventional order.
.     Elements may be gathered in any order, but faults must be delivered in a right-to-left order; thus, elements to
      the left of a faulting one may be gathered before the fault is delivered. A given implementation of this
      instruction is repeatable - given the same input values and architectural state, the same set of elements to the
      left of the faulting one will be gathered.</hint>
<hint page="0" header="Gather Packed Dword, Packed Qword with Signed Qword Indices" doc_id="x86_64" token="vpgatherqq">A set of 8 doubleword/quadword memory locations pointed to by base address BASE_ADDR and index vector
VINDEX with scale SCALE are gathered. The result is written into a vector register. The elements are specified via
the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be loaded if their
corresponding mask bit is one. If an element's mask bit is not set, the corresponding element of the destination
register is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an excep-
tion.
This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register (k1) are partially updated; those elements that have been gathered are placed into
the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already
gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruc-
tion breakpoint is not re-triggered when the instruction is continued.
If the data element size is less than the index element size, the higher part of the destination register and the mask
register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may
update these unused elements to one or both of those registers even if the instruction triggers an exception, and
even if the instruction triggers the exception before gathering any elements.
Note that:
.     The values may be read from memory in any order. Memory ordering with other instructions follows the Intel-
      64 memory-ordering model.
.     Faults are delivered in a right-to-left manner. That is, if a fault is triggered by an element and delivered, all
      elements closer to the LSB of the destination zmm will be completed (and non-faulting). Individual elements
      closer to the MSB may or may not be completed. If a given element triggers multiple faults, they are delivered
      in the conventional order.
.     Elements may be gathered in any order, but faults must be delivered in a right-to-left order; thus, elements to
      the left of a faulting one may be gathered before the fault is delivered. A given implementation of this
      instruction is repeatable - given the same input values and architectural state, the same set of elements to the
      left of the faulting one will be gathered.</hint>
<hint page="0" header="Convert Exponents of Packed DP FP Values to DP FP Values" doc_id="x86_64" token="vgetexppd">Extracts the biased exponents from the normalized DP FP representation of each qword data element of the source
operand (the second operand) as unbiased signed integer value, or convert the denormal representation of input
data to unbiased negative integer values. Each integer value of the unbiased exponent is converted to double-
precision FP value and written to the corresponding qword elements of the destination operand (the first operand)
as DP FP numbers.
The destination operand is a ZMM/YMM/XMM register and updated under the writemask. The source operand can
be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from
a 64-bit memory location.
EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.
Each GETEXP operation converts the exponent value into a FP number (permitting input value in denormal repre-
sentation). Special cases of input values are listed in Table 5-7.
The formula is:
GETEXP(x) = floor(log2(|x|))
Notation floor(x) stands for the greatest integer not exceeding real number x.</hint>
<hint page="0" header="Convert Exponents of Packed SP FP Values to SP FP Values" doc_id="x86_64" token="vgetexpps">Extracts the biased exponents from the normalized SP FP representation of each dword element of the source
operand (the second operand) as unbiased signed integer value, or convert the denormal representation of input
data to unbiased negative integer values. Each integer value of the unbiased exponent is converted to single-preci-
sion FP value and written to the corresponding dword elements of the destination operand (the first operand) as SP
FP numbers.
The destination operand is a ZMM/YMM/XMM register and updated under the writemask. The source operand can
be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from
a 32-bit memory location.
EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.
Each GETEXP operation converts the exponent value into a FP number (permitting input value in denormal repre-
sentation). Special cases of input values are listed in Table 5-8.
The formula is:
GETEXP(x) = floor(log2(|x|))
Notation floor(x) stands for maximal integer not exceeding real number x.
Software usage of VGETEXPxx and VGETMANTxx instructions generally involve a combination of GETEXP operation
and GETMANT operation (see VGETMANTPD). Thus VGETEXPxx instruction do not require software to handle SIMD
FP exceptions.</hint>
<hint page="0" header="Convert Exponents of Scalar DP FP Values to DP FP Value" doc_id="x86_64" token="vgetexpsd">Extracts the biased exponent from the normalized DP FP representation of the low qword data element of the
source operand (the third operand) as unbiased signed integer value, or convert the denormal representation of
input data to unbiased negative integer values. The integer value of the unbiased exponent is converted to double-
precision FP value and written to the destination operand (the first operand) as DP FP numbers. Bits (127:64) of
the XMM register destination are copied from corresponding bits in the first source operand.
The destination must be a XMM register, the source operand can be a XMM register or a float64 memory location.
The low quadword element of the destination operand is conditionally updated with writemask k1.
Each GETEXP operation converts the exponent value into a FP number (permitting input value in denormal repre-
sentation). Special cases of input values are listed in Table 5-7.
The formula is:
GETEXP(x) = floor(log2(|x|))
Notation floor(x) stands for maximal integer not exceeding real number x.</hint>
<hint page="0" header="Convert Exponents of Scalar SP FP Values to SP FP Value" doc_id="x86_64" token="vgetexpss">Extracts the biased exponent from the normalized SP FP representation of the low doubleword data element of the
source operand (the third operand) as unbiased signed integer value, or convert the denormal representation of
input data to unbiased negative integer values. The integer value of the unbiased exponent is converted to single-
precision FP value and written to the destination operand (the first operand) as SP FP numbers. Bits (127:32) of
the XMM register destination are copied from corresponding bits in the first source operand.
The destination must be a XMM register, the source operand can be a XMM register or a float32 memory location.
The the low doubleword element of the destination operand is conditionally updated with writemask k1.
Each GETEXP operation converts the exponent value into a FP number (permitting input value in denormal repre-
sentation). Special cases of input values are listed in Table 5-8.
The formula is:
GETEXP(x) = floor(log2(|x|))
Notation floor(x) stands for maximal integer not exceeding real number x.
Software usage of VGETEXPxx and VGETMANTxx instructions generally involve a combination of GETEXP operation
and GETMANT operation (see VGETMANTPD). Thus VGETEXPxx instruction do not require software to handle SIMD
FP exceptions.</hint>
<hint page="0" header="Extract Float64 Vector of Normalized Mantissas from Float64 Vector" doc_id="x86_64" token="vgetmantpd">Convert double-precision floating values in the source operand (the second operand) to DP FP values with the
mantissa normalization and sign control specified by the imm8 byte, see Figure 5-15. The converted results are
written to the destination operand (the first operand) using writemask k1. The normalized mantissa is specified by
interv (imm8[1:0]) and the sign control (sc) is specified by bits 3:2 of the immediate byte.
The destination operand is a ZMM/YMM/XMM register updated under the writemask. The source operand can be a
ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-
bit memory location.</hint>
<hint page="0" header="Extract Float32 Vector of Normalized Mantissas from Float32 Vector" doc_id="x86_64" token="vgetmantps">Convert single-precision floating values in the source operand (the second operand) to SP FP values with the
mantissa normalization and sign control specified by the imm8 byte, see Figure 5-15. The converted results are
written to the destination operand (the first operand) using writemask k1. The normalized mantissa is specified by
interv (imm8[1:0]) and the sign control (sc) is specified by bits 3:2 of the immediate byte.
The destination operand is a ZMM/YMM/XMM register updated under the writemask. The source operand can be a
ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-
bit memory location.
For each input SP FP value x, The conversion operation is:</hint>
<hint page="0" header="Extract Float64 of Normalized Mantissas from Float64 Scalar" doc_id="x86_64" token="vgetmantsd">Convert the double-precision floating values in the low quadword element of the second source operand (the third
operand) to DP FP value with the mantissa normalization and sign control specified by the imm8 byte, see
Figure 5-15. The converted result is written to the low quadword element of the destination operand (the first
operand) using writemask k1. Bits (127:64) of the XMM register destination are copied from corresponding
bits in the first source operand. The normalized mantissa is specified by interv (imm8[1:0]) and the sign control
(sc) is specified by bits 3:2 of the immediate byte.
The conversion operation is:</hint>
<hint page="0" header="Extract Float32 Vector of Normalized Mantissa from Float32 Vector" doc_id="x86_64" token="vgetmantss">Convert the single-precision floating values in the low doubleword element of the second source operand (the third
operand) to SP FP value with the mantissa normalization and sign control specified by the imm8 byte, see
Figure 5-15. The converted result is written to the low doubleword element of the destination operand (the first
operand) using writemask k1. Bits (127:32) of the XMM register destination are copied from corresponding
bits in the first source operand. The normalized mantissa is specified by interv (imm8[1:0]) and the sign control
(sc) is specified by bits 3:2 of the immediate byte.
The conversion operation is:</hint>
<hint page="0" header="Insert Packed" doc_id="x86_64" token="vinsertf128">VINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second
source operand (the third operand) into the destination operand (the first operand) at an 128-bit granularity offset
multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination operand are copied from
the corresponding fields of the first source operand (the second operand). The second source operand can be either
an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.
VINSERTF32x4: The destination operand is a ZMM/YMM register and updated at 32-bit granularity according to the
writemask. The high 6/7 bits of the immediate are ignored.
VINSERTF64x2: The destination operand is a ZMM/YMM register and updated at 64-bit granularity according to the
writemask. The high 6/7 bits of the immediate are ignored.
VINSERTF32x8 and VINSERTF64x4 inserts 256-bits of packed floating-point values from the second source operand
(the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by
imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source
operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory
location. The high 7 bits of the immediate are ignored. The destination operand is a ZMM register and updated at
32/64-bit granularity according to the writemask.</hint>
<hint page="0" header="Insert Packed" doc_id="x86_64" token="vinsertf32x4">VINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second
source operand (the third operand) into the destination operand (the first operand) at an 128-bit granularity offset
multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination operand are copied from
the corresponding fields of the first source operand (the second operand). The second source operand can be either
an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.
VINSERTF32x4: The destination operand is a ZMM/YMM register and updated at 32-bit granularity according to the
writemask. The high 6/7 bits of the immediate are ignored.
VINSERTF64x2: The destination operand is a ZMM/YMM register and updated at 64-bit granularity according to the
writemask. The high 6/7 bits of the immediate are ignored.
VINSERTF32x8 and VINSERTF64x4 inserts 256-bits of packed floating-point values from the second source operand
(the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by
imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source
operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory
location. The high 7 bits of the immediate are ignored. The destination operand is a ZMM register and updated at
32/64-bit granularity according to the writemask.</hint>
<hint page="0" header="Insert Packed" doc_id="x86_64" token="vinsertf64x2">VINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second
source operand (the third operand) into the destination operand (the first operand) at an 128-bit granularity offset
multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination operand are copied from
the corresponding fields of the first source operand (the second operand). The second source operand can be either
an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.
VINSERTF32x4: The destination operand is a ZMM/YMM register and updated at 32-bit granularity according to the
writemask. The high 6/7 bits of the immediate are ignored.
VINSERTF64x2: The destination operand is a ZMM/YMM register and updated at 64-bit granularity according to the
writemask. The high 6/7 bits of the immediate are ignored.
VINSERTF32x8 and VINSERTF64x4 inserts 256-bits of packed floating-point values from the second source operand
(the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by
imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source
operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory
location. The high 7 bits of the immediate are ignored. The destination operand is a ZMM register and updated at
32/64-bit granularity according to the writemask.</hint>
<hint page="0" header="Insert Packed" doc_id="x86_64" token="vinsertf32x8">VINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second
source operand (the third operand) into the destination operand (the first operand) at an 128-bit granularity offset
multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination operand are copied from
the corresponding fields of the first source operand (the second operand). The second source operand can be either
an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.
VINSERTF32x4: The destination operand is a ZMM/YMM register and updated at 32-bit granularity according to the
writemask. The high 6/7 bits of the immediate are ignored.
VINSERTF64x2: The destination operand is a ZMM/YMM register and updated at 64-bit granularity according to the
writemask. The high 6/7 bits of the immediate are ignored.
VINSERTF32x8 and VINSERTF64x4 inserts 256-bits of packed floating-point values from the second source operand
(the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by
imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source
operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory
location. The high 7 bits of the immediate are ignored. The destination operand is a ZMM register and updated at
32/64-bit granularity according to the writemask.</hint>
<hint page="0" header="Insert Packed" doc_id="x86_64" token="vinsertf64x4">VINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second
source operand (the third operand) into the destination operand (the first operand) at an 128-bit granularity offset
multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination operand are copied from
the corresponding fields of the first source operand (the second operand). The second source operand can be either
an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.
VINSERTF32x4: The destination operand is a ZMM/YMM register and updated at 32-bit granularity according to the
writemask. The high 6/7 bits of the immediate are ignored.
VINSERTF64x2: The destination operand is a ZMM/YMM register and updated at 64-bit granularity according to the
writemask. The high 6/7 bits of the immediate are ignored.
VINSERTF32x8 and VINSERTF64x4 inserts 256-bits of packed floating-point values from the second source operand
(the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by
imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source
operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory
location. The high 7 bits of the immediate are ignored. The destination operand is a ZMM register and updated at
32/64-bit granularity according to the writemask.</hint>
<hint page="0" header="Insert Packed" doc_id="x86_64" token="vinserti128">VINSERTI32x4 and VINSERTI64x2 inserts 128-bits of packed integer values from the second source operand (the
third operand) into the destination operand (the first operand) at an 128-bit granular offset multiplied by imm8[0]
(256-bit) or imm8[1:0]. The remaining portions of the destination are copied from the corresponding fields of the
first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit
memory location. The high 6/7bits of the immediate are ignored. The destination operand is a ZMM/YMM register
and updated at 32 and 64-bit granularity according to the writemask.
VINSERTI32x8 and VINSERTI64x4 inserts 256-bits of packed integer values from the second source operand (the
third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0].
The remaining portions of the destination are copied from the corresponding fields of the first source operand (the
second operand). The second source operand can be either an YMM register or a 256-bit memory location. The
upper bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32 and 64-bit
granularity according to the writemask.
VINSERTI128 inserts 128-bits of packed integer data from the second source operand (the third operand) into the
destination operand (the first operand) at a 128-bit granular offset multiplied by imm8[0]. The remaining portions
of the destination are copied from the corresponding fields of the first source operand (the second operand). The
second source operand can be either an XMM register or a 128-bit memory location. The high 7 bits of the imme-
diate are ignored. VEX.L must be 1, otherwise attempt to execute this instruction with VEX.L=0 will cause #UD.</hint>
<hint page="0" header="Insert Packed" doc_id="x86_64" token="vinserti32x4">VINSERTI32x4 and VINSERTI64x2 inserts 128-bits of packed integer values from the second source operand (the
third operand) into the destination operand (the first operand) at an 128-bit granular offset multiplied by imm8[0]
(256-bit) or imm8[1:0]. The remaining portions of the destination are copied from the corresponding fields of the
first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit
memory location. The high 6/7bits of the immediate are ignored. The destination operand is a ZMM/YMM register
and updated at 32 and 64-bit granularity according to the writemask.
VINSERTI32x8 and VINSERTI64x4 inserts 256-bits of packed integer values from the second source operand (the
third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0].
The remaining portions of the destination are copied from the corresponding fields of the first source operand (the
second operand). The second source operand can be either an YMM register or a 256-bit memory location. The
upper bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32 and 64-bit
granularity according to the writemask.
VINSERTI128 inserts 128-bits of packed integer data from the second source operand (the third operand) into the
destination operand (the first operand) at a 128-bit granular offset multiplied by imm8[0]. The remaining portions
of the destination are copied from the corresponding fields of the first source operand (the second operand). The
second source operand can be either an XMM register or a 128-bit memory location. The high 7 bits of the imme-
diate are ignored. VEX.L must be 1, otherwise attempt to execute this instruction with VEX.L=0 will cause #UD.</hint>
<hint page="0" header="Insert Packed" doc_id="x86_64" token="vinserti64x2">VINSERTI32x4 and VINSERTI64x2 inserts 128-bits of packed integer values from the second source operand (the
third operand) into the destination operand (the first operand) at an 128-bit granular offset multiplied by imm8[0]
(256-bit) or imm8[1:0]. The remaining portions of the destination are copied from the corresponding fields of the
first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit
memory location. The high 6/7bits of the immediate are ignored. The destination operand is a ZMM/YMM register
and updated at 32 and 64-bit granularity according to the writemask.
VINSERTI32x8 and VINSERTI64x4 inserts 256-bits of packed integer values from the second source operand (the
third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0].
The remaining portions of the destination are copied from the corresponding fields of the first source operand (the
second operand). The second source operand can be either an YMM register or a 256-bit memory location. The
upper bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32 and 64-bit
granularity according to the writemask.
VINSERTI128 inserts 128-bits of packed integer data from the second source operand (the third operand) into the
destination operand (the first operand) at a 128-bit granular offset multiplied by imm8[0]. The remaining portions
of the destination are copied from the corresponding fields of the first source operand (the second operand). The
second source operand can be either an XMM register or a 128-bit memory location. The high 7 bits of the imme-
diate are ignored. VEX.L must be 1, otherwise attempt to execute this instruction with VEX.L=0 will cause #UD.</hint>
<hint page="0" header="Insert Packed" doc_id="x86_64" token="vinserti32x8">VINSERTI32x4 and VINSERTI64x2 inserts 128-bits of packed integer values from the second source operand (the
third operand) into the destination operand (the first operand) at an 128-bit granular offset multiplied by imm8[0]
(256-bit) or imm8[1:0]. The remaining portions of the destination are copied from the corresponding fields of the
first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit
memory location. The high 6/7bits of the immediate are ignored. The destination operand is a ZMM/YMM register
and updated at 32 and 64-bit granularity according to the writemask.
VINSERTI32x8 and VINSERTI64x4 inserts 256-bits of packed integer values from the second source operand (the
third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0].
The remaining portions of the destination are copied from the corresponding fields of the first source operand (the
second operand). The second source operand can be either an YMM register or a 256-bit memory location. The
upper bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32 and 64-bit
granularity according to the writemask.
VINSERTI128 inserts 128-bits of packed integer data from the second source operand (the third operand) into the
destination operand (the first operand) at a 128-bit granular offset multiplied by imm8[0]. The remaining portions
of the destination are copied from the corresponding fields of the first source operand (the second operand). The
second source operand can be either an XMM register or a 128-bit memory location. The high 7 bits of the imme-
diate are ignored. VEX.L must be 1, otherwise attempt to execute this instruction with VEX.L=0 will cause #UD.</hint>
<hint page="0" header="Insert Packed" doc_id="x86_64" token="vinserti64x4">VINSERTI32x4 and VINSERTI64x2 inserts 128-bits of packed integer values from the second source operand (the
third operand) into the destination operand (the first operand) at an 128-bit granular offset multiplied by imm8[0]
(256-bit) or imm8[1:0]. The remaining portions of the destination are copied from the corresponding fields of the
first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit
memory location. The high 6/7bits of the immediate are ignored. The destination operand is a ZMM/YMM register
and updated at 32 and 64-bit granularity according to the writemask.
VINSERTI32x8 and VINSERTI64x4 inserts 256-bits of packed integer values from the second source operand (the
third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0].
The remaining portions of the destination are copied from the corresponding fields of the first source operand (the
second operand). The second source operand can be either an YMM register or a 256-bit memory location. The
upper bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32 and 64-bit
granularity according to the writemask.
VINSERTI128 inserts 128-bits of packed integer data from the second source operand (the third operand) into the
destination operand (the first operand) at a 128-bit granular offset multiplied by imm8[0]. The remaining portions
of the destination are copied from the corresponding fields of the first source operand (the second operand). The
second source operand can be either an XMM register or a 128-bit memory location. The high 7 bits of the imme-
diate are ignored. VEX.L must be 1, otherwise attempt to execute this instruction with VEX.L=0 will cause #UD.</hint>
<hint page="0" header="Conditional SIMD Packed Loads and Stores" doc_id="x86_64" token="vmaskmov">Conditionally moves packed data elements from the second source operand into the corresponding data element of
the destination operand, depending on the mask bits associated with each data element. The mask bits are speci-
fied in the first source operand.
The mask bit for each data element is the most significant bit of that element in the first source operand. If a mask
is 1, the corresponding data element is copied from the second source operand to the destination operand. If the
mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in
the store form.
The second source operand is a memory address for the load form of these instruction. The destination operand is
a memory address for the store form of these instructions. The other operands are both XMM registers (for
VEX.128 version) or YMM registers (for VEX.256 version).
Faults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to
referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no
faults will be detected if the mask bits are all zero.
Unlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to
these instructions.
Instruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits
of all 1s.
VMASKMOV should not be used to access memory mapped I/O and un-cached memory as the access and the
ordering of the individual loads or stores it does is implementation specific.</hint>
<hint page="0" header="Blend Packed Dwords" doc_id="x86_64" token="vpblendd">Dword elements from the source operand (second operand) are conditionally written to the destination operand
(first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a
mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the
mask, corresponding to a word, is "1", then the word is copied, else the word is unchanged.
VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The
first source and destination operands are XMM registers. Bits (VLMAX-1:128) of the corresponding YMM register
are zeroed.
VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register
or a 256-bit memory location. The destination operand is a YMM register.</hint>
<hint page="0" header="Blend Byte/Word Vectors Using an Opmask Control" doc_id="x86_64" token="vpblendmb">Performs an element-by-element blending of byte/word elements between the first source operand byte vector
register and the second source operand byte vector from memory or register, using the instruction mask as
selector. The result is written into the destination byte vector register.
The destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a
ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit memory location.
The mask is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every
element of the destination is conditionally selected between first source or second source using the value of the
related mask bit (0 for first source, 1 for second source).</hint>
<hint page="0" header="Blend Byte/Word Vectors Using an Opmask Control" doc_id="x86_64" token="vpblendmw">Performs an element-by-element blending of byte/word elements between the first source operand byte vector
register and the second source operand byte vector from memory or register, using the instruction mask as
selector. The result is written into the destination byte vector register.
The destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a
ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit memory location.
The mask is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every
element of the destination is conditionally selected between first source or second source using the value of the
related mask bit (0 for first source, 1 for second source).</hint>
<hint page="0" header="Blend Int32/Int64 Vectors Using an OpMask Control" doc_id="x86_64" token="vpblendmd">Performs an element-by-element blending of dword/qword elements between the first source operand (the second
operand) and the elements of the second source operand (the third operand) using an opmask register as select
control. The blended result is written into the destination.
The destination and first source operands are ZMM registers. The second source operand can be a ZMM register, a
512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location.
The opmask register is not used as a writemask for this instruction. Instead, the mask is used as an element
selector: every element of the destination is conditionally selected between first source or second source using the
value of the related mask bit (0 for the first source operand, 1 for the second source operand).
If EVEX.z is set, the elements with corresponding mask bit value of 0 in the destination operand are zeroed.</hint>
<hint page="0" header="Blend Int32/Int64 Vectors Using an OpMask Control" doc_id="x86_64" token="vpblendmq">Performs an element-by-element blending of dword/qword elements between the first source operand (the second
operand) and the elements of the second source operand (the third operand) using an opmask register as select
control. The blended result is written into the destination.
The destination and first source operands are ZMM registers. The second source operand can be a ZMM register, a
512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location.
The opmask register is not used as a writemask for this instruction. Instead, the mask is used as an element
selector: every element of the destination is conditionally selected between first source or second source using the
value of the related mask bit (0 for the first source operand, 1 for the second source operand).
If EVEX.z is set, the elements with corresponding mask bit value of 0 in the destination operand are zeroed.</hint>
<hint page="0" header="Load with Broadcast Integer Data from General Purpose Register" doc_id="x86_64" token="vpbroadcastb">Broadcasts a 8-bit, 16-bit, 32-bit or 64-bit value from a general-purpose register (the second operand) to all the
locations in the destination vector register (the first operand) using the writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Load with Broadcast Integer Data from General Purpose Register" doc_id="x86_64" token="vpbroadcastw">Broadcasts a 8-bit, 16-bit, 32-bit or 64-bit value from a general-purpose register (the second operand) to all the
locations in the destination vector register (the first operand) using the writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Load with Broadcast Integer Data from General Purpose Register" doc_id="x86_64" token="vpbroadcastd">Broadcasts a 8-bit, 16-bit, 32-bit or 64-bit value from a general-purpose register (the second operand) to all the
locations in the destination vector register (the first operand) using the writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Load with Broadcast Integer Data from General Purpose Register" doc_id="x86_64" token="vpbroadcastq">Broadcasts a 8-bit, 16-bit, 32-bit or 64-bit value from a general-purpose register (the second operand) to all the
locations in the destination vector register (the first operand) using the writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Load Integer and Broadcast" doc_id="x86_64" token="vpbroadcast">Load integer data from the source operand (the second operand) and broadcast to all elements of the destination
operand (the first operand).
VEX256-encoded VPBROADCASTB/W/D/Q: The source operand is 8-bit, 16-bit, 32-bit, 64-bit memory location or
the low 8-bit, 16-bit 32-bit, 64-bit data in an XMM register. The destination operand is a YMM register.
VPBROADCASTI128 support the source operand of 128-bit memory location. Register source encodings for
VPBROADCASTI128 is reserved and will #UD. Bits (MAX_VL-1:256) of the destination register are zeroed.
EVEX-encoded VPBROADCASTD/Q: The source operand is a 32-bit, 64-bit memory location or the low 32-bit, 64-
bit data in an XMM register. The destination operand is a ZMM/YMM/XMM register and updated according to the
writemask k1.
VPBROADCASTI32X4 and VPBROADCASTI64X4: The destination operand is a ZMM register and updated according
to the writemask k1. The source operand is 128-bit or 256-bit memory location. Register source encodings for
VBROADCASTI32X4 and VBROADCASTI64X4 are reserved and will #UD.
Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
If VPBROADCASTI128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will
cause an #UD exception.</hint>
<hint page="0" header="Compare Packed Byte Values Into Mask" doc_id="x86_64" token="vpcmpb">Performs a SIMD compare of the packed byte values in the second source operand and the first source operand and
returns the results of the comparison to the mask destination operand. The comparison predicate operand (imme-
diate byte) specifies the type of comparison performed on each pair of packed values in the two source operands.
The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).
VPCMPB performs a comparison between pairs of signed byte values.
VPCMPUB performs a comparison between pairs of unsigned byte values.
The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a
ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand (first operand) is a mask
register k1. Up to 64/32/16 comparisons are performed with results written to the destination operand under the
writemask k2.</hint>
<hint page="0" header="Compare Packed Byte Values Into Mask" doc_id="x86_64" token="vpcmpub">Performs a SIMD compare of the packed byte values in the second source operand and the first source operand and
returns the results of the comparison to the mask destination operand. The comparison predicate operand (imme-
diate byte) specifies the type of comparison performed on each pair of packed values in the two source operands.
The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).
VPCMPB performs a comparison between pairs of signed byte values.
VPCMPUB performs a comparison between pairs of unsigned byte values.
The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a
ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand (first operand) is a mask
register k1. Up to 64/32/16 comparisons are performed with results written to the destination operand under the
writemask k2.</hint>
<hint page="0" header="Compare Packed Integer Values into Mask" doc_id="x86_64" token="vpcmpd">Performs a SIMD compare of the packed integer values in the second source operand and the first source operand
and returns the results of the comparison to the mask destination operand. The comparison predicate operand
(immediate byte) specifies the type of comparison performed on each pair of packed values in the two source oper-
ands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).
VPCMPD/VPCMPUD performs a comparison between pairs of signed/unsigned doubleword integer values.
The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a
ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32-bit
memory location. The destination operand (first operand) is a mask register k1. Up to 16/8/4 comparisons are
performed with results written to the destination operand under the writemask k2.
The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed.
Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table
5-10.</hint>
<hint page="0" header="Compare Packed Integer Values into Mask" doc_id="x86_64" token="vpcmpud">Performs a SIMD compare of the packed integer values in the second source operand and the first source operand
and returns the results of the comparison to the mask destination operand. The comparison predicate operand
(immediate byte) specifies the type of comparison performed on each pair of packed values in the two source oper-
ands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).
VPCMPD/VPCMPUD performs a comparison between pairs of signed/unsigned doubleword integer values.
The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a
ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32-bit
memory location. The destination operand (first operand) is a mask register k1. Up to 16/8/4 comparisons are
performed with results written to the destination operand under the writemask k2.
The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed.
Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table
5-10.</hint>
<hint page="0" header="Compare Packed Integer Values into Mask" doc_id="x86_64" token="vpcmpq">Performs a SIMD compare of the packed integer values in the second source operand and the first source operand
and returns the results of the comparison to the mask destination operand. The comparison predicate operand
(immediate byte) specifies the type of comparison performed on each pair of packed values in the two source oper-
ands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).
VPCMPQ/VPCMPUQ performs a comparison between pairs of signed/unsigned quadword integer values.
The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a
ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 64-bit
memory location. The destination operand (first operand) is a mask register k1. Up to 8/4/2 comparisons are
performed with results written to the destination operand under the writemask k2.
The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed.
Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table
5-10.</hint>
<hint page="0" header="Compare Packed Integer Values into Mask" doc_id="x86_64" token="vpcmpuq">Performs a SIMD compare of the packed integer values in the second source operand and the first source operand
and returns the results of the comparison to the mask destination operand. The comparison predicate operand
(immediate byte) specifies the type of comparison performed on each pair of packed values in the two source oper-
ands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).
VPCMPQ/VPCMPUQ performs a comparison between pairs of signed/unsigned quadword integer values.
The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a
ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 64-bit
memory location. The destination operand (first operand) is a mask register k1. Up to 8/4/2 comparisons are
performed with results written to the destination operand under the writemask k2.
The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed.
Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table
5-10.</hint>
<hint page="0" header="Compare Packed Word Values Into Mask" doc_id="x86_64" token="vpcmpw">Performs a SIMD compare of the packed integer word in the second source operand and the first source operand
and returns the results of the comparison to the mask destination operand. The comparison predicate operand
(immediate byte) specifies the type of comparison performed on each pair of packed values in the two source oper-
ands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).
VPCMPW performs a comparison between pairs of signed word values.
VPCMPUW performs a comparison between pairs of unsigned word values.
The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a
ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand (first operand) is a mask
register k1. Up to 32/16/8 comparisons are performed with results written to the destination operand under the
writemask k2.
The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed.
Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table
5-10.</hint>
<hint page="0" header="Compare Packed Word Values Into Mask" doc_id="x86_64" token="vpcmpuw">Performs a SIMD compare of the packed integer word in the second source operand and the first source operand
and returns the results of the comparison to the mask destination operand. The comparison predicate operand
(immediate byte) specifies the type of comparison performed on each pair of packed values in the two source oper-
ands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).
VPCMPW performs a comparison between pairs of signed word values.
VPCMPUW performs a comparison between pairs of unsigned word values.
The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a
ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand (first operand) is a mask
register k1. Up to 32/16/8 comparisons are performed with results written to the destination operand under the
writemask k2.
The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed.
Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table
5-10.</hint>
<hint page="0" header="Store Sparse Packed Doubleword Integer Values into Dense Memory/Register" doc_id="x86_64" token="vpcompressd">Compress (store) up to 16/8/4 doubleword integer values from the source operand (second operand) to the desti-
nation operand (first operand). The source operand is a ZMM/YMM/XMM register, the destination operand can be a
ZMM/YMM/XMM register or a 512/256/128-bit memory location.
The opmask register k1 selects the active elements (partial vector or possibly non-contiguous if less than 16 active
elements) from the source operand to compress into a contiguous vector. The contiguous vector is written to the
destination starting from the low element of the destination operand.
Memory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z
must be zero.
Register destination version: If the vector length of the contiguous vector is less than that of the input vector in the
source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper
bits are zeroed.
Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element
instead of the size of the full vector.</hint>
<hint page="0" header="Store Sparse Packed Quadword Integer Values into Dense Memory/Register" doc_id="x86_64" token="vpcompressq">Compress (stores) up to 8/4/2 quadword integer values from the source operand (second operand) to the destina-
tion operand (first operand). The source operand is a ZMM/YMM/XMM register, the destination operand can be a
ZMM/YMM/XMM register or a 512/256/128-bit memory location.
The opmask register k1 selects the active elements (partial vector or possibly non-contiguous if less than 8 active
elements) from the source operand to compress into a contiguous vector. The contiguous vector is written to the
destination starting from the low element of the destination operand.
Memory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z
must be zero.
Register destination version: If the vector length of the contiguous vector is less than that of the input vector in the
source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper
bits are zeroed.
Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element
instead of the size of the full vector.</hint>
<hint page="0" header="Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense" doc_id="x86_64" token="vpconflictd">Test each dword/qword element of the source operand (the second operand) for equality with all other elements in
the source operand closer to the least significant element. Each element's comparison results form a bit vector,
which is then zero extended and written to the destination according to the writemask.
EVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector
broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated
using writemask k1.
EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector
broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated
using writemask k1.
EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector
broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated
using writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense" doc_id="x86_64" token="vpconflictq">Test each dword/qword element of the source operand (the second operand) for equality with all other elements in
the source operand closer to the least significant element. Each element's comparison results form a bit vector,
which is then zero extended and written to the destination according to the writemask.
EVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector
broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated
using writemask k1.
EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector
broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated
using writemask k1.
EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector
broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated
using writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Permute Floating-Point Values" doc_id="x86_64" token="vperm2f128">Permute 128 bit floating-point-containing fields from the first source operand (second operand) and second source
operand (third operand) using bits in the 8-bit immediate and store results in the destination operand (first
operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit
memory location, and the destination operand is a YMM register.</hint>
<hint page="0" header="Permute Integer Values" doc_id="x86_64" token="vperm2i128">Permute 128 bit integer data from the first source operand (second operand) and second source operand (third
operand) using bits in the 8-bit immediate and store results in the destination operand (first operand). The first
source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and
the destination operand is a YMM register.</hint>
<hint page="0" header="Permute Packed Doublewords/Words Elements" doc_id="x86_64" token="vpermd">Copies doublewords (or words) from the second source operand (the third operand) to the destination operand (the
first operand) according to the indices in the first source operand (the second operand). Note that this instruction
permits a doubleword (word) in the source operand to be copied to more than one location in the destination
operand.
VEX.256 encoded VPERMD: The first and second operands are YMM registers, the third operand can be a YMM
register or memory location. Bits (MAX_VL-1:256) of the corresponding destination register are zeroed.
EVEX encoded VPERMD: The first and second operands are ZMM/YMM registers, the third operand can be a
ZMM/YMM register, a 512/256-bit memory location or a 512/256-bit vector broadcasted from a 32-bit memory
location. The elements in the destination are updated using the writemask k1.
VPERMW: first and second operands are ZMM/YMM/XMM registers, the third operand can be a ZMM/YMM/XMM
register, or a 512/256/128-bit memory location. The destination is updated using the writemask k1.
EVEX.128 encoded versions: Bits (MAX_VL-1:128) of the corresponding ZMM register are zeroed.</hint>
<hint page="0" header="Permute Packed Doublewords/Words Elements" doc_id="x86_64" token="vpermw">Copies doublewords (or words) from the second source operand (the third operand) to the destination operand (the
first operand) according to the indices in the first source operand (the second operand). Note that this instruction
permits a doubleword (word) in the source operand to be copied to more than one location in the destination
operand.
VEX.256 encoded VPERMD: The first and second operands are YMM registers, the third operand can be a YMM
register or memory location. Bits (MAX_VL-1:256) of the corresponding destination register are zeroed.
EVEX encoded VPERMD: The first and second operands are ZMM/YMM registers, the third operand can be a
ZMM/YMM register, a 512/256-bit memory location or a 512/256-bit vector broadcasted from a 32-bit memory
location. The elements in the destination are updated using the writemask k1.
VPERMW: first and second operands are ZMM/YMM/XMM registers, the third operand can be a ZMM/YMM/XMM
register, or a 512/256/128-bit memory location. The destination is updated using the writemask k1.
EVEX.128 encoded versions: Bits (MAX_VL-1:128) of the corresponding ZMM register are zeroed.</hint>
<hint page="0" header="Full Permute From Two Tables Overwriting the Index" doc_id="x86_64" token="vpermi2w">Permutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the
second source operand) using indices in the first operand to select elements from the second and third operands.
The selected elements are written to the destination operand (the first operand) according to the writemask k1.
The first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select
elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the
result.
D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit
memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the
low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).
Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits
[3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If
the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.
Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each
input table.
Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit
memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each
input table.
Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than
one location in the destination operand. Note also that in this case, the same table can be reused for example for a
second iteration, while the index elements are overwritten.
Bits (MAX_VL-1:256/128) of the destination are zeroed for VL=256,128.</hint>
<hint page="0" header="Full Permute From Two Tables Overwriting the Index" doc_id="x86_64" token="vpermi2d">Permutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the
second source operand) using indices in the first operand to select elements from the second and third operands.
The selected elements are written to the destination operand (the first operand) according to the writemask k1.
The first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select
elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the
result.
D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit
memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the
low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).
Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits
[3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If
the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.
Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each
input table.
Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit
memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each
input table.
Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than
one location in the destination operand. Note also that in this case, the same table can be reused for example for a
second iteration, while the index elements are overwritten.
Bits (MAX_VL-1:256/128) of the destination are zeroed for VL=256,128.</hint>
<hint page="0" header="Full Permute From Two Tables Overwriting the Index" doc_id="x86_64" token="vpermi2q">Permutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the
second source operand) using indices in the first operand to select elements from the second and third operands.
The selected elements are written to the destination operand (the first operand) according to the writemask k1.
The first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select
elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the
result.
D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit
memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the
low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).
Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits
[3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If
the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.
Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each
input table.
Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit
memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each
input table.
Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than
one location in the destination operand. Note also that in this case, the same table can be reused for example for a
second iteration, while the index elements are overwritten.
Bits (MAX_VL-1:256/128) of the destination are zeroed for VL=256,128.</hint>
<hint page="0" header="Full Permute From Two Tables Overwriting the Index" doc_id="x86_64" token="vpermi2ps">Permutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the
second source operand) using indices in the first operand to select elements from the second and third operands.
The selected elements are written to the destination operand (the first operand) according to the writemask k1.
The first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select
elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the
result.
D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit
memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the
low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).
Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits
[3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If
the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.
Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each
input table.
Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit
memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each
input table.
Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than
one location in the destination operand. Note also that in this case, the same table can be reused for example for a
second iteration, while the index elements are overwritten.
Bits (MAX_VL-1:256/128) of the destination are zeroed for VL=256,128.</hint>
<hint page="0" header="Full Permute From Two Tables Overwriting the Index" doc_id="x86_64" token="vpermi2pd">Permutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the
second source operand) using indices in the first operand to select elements from the second and third operands.
The selected elements are written to the destination operand (the first operand) according to the writemask k1.
The first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select
elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the
result.
D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit
memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the
low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).
Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits
[3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If
the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.
Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each
input table.
Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit
memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each
input table.
Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than
one location in the destination operand. Note also that in this case, the same table can be reused for example for a
second iteration, while the index elements are overwritten.
Bits (MAX_VL-1:256/128) of the destination are zeroed for VL=256,128.</hint>
<hint page="0" header="Permute In-Lane of Pairs of Double-Precision Floating-Point Values" doc_id="x86_64" token="vpermilpd"></hint>
<hint page="0" header="Permute In-Lane of Quadruples of Single-Precision Floating-Point Values" doc_id="x86_64" token="vpermilps"></hint>
<hint page="0" header="Permute Double-Precision Floating-Point Elements" doc_id="x86_64" token="vpermpd">The imm8 version: Copies quadword elements of double-precision floating-point values from the source operand
(the second operand) to the destination operand (the first operand) according to the indices specified by the imme-
diate operand (the third operand). Each two-bit value in the immediate byte selects a qword element in the source
operand.
VEX version: The source operand can be a YMM register or a memory location. Bits (MAX_VL-1:256) of the corre-
sponding destination register are zeroed.
In EVEX.512 encoded version, The elements in the destination are updated using the writemask k1 and the imm8
bits are reused as control bits for the upper 256-bit half when the control bits are coming from immediate. The
source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit
memory location.
The imm8 versions: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.
The vector control version: Copies quadword elements of double-precision floating-point values from the second
source operand (the third operand) to the destination operand (the first operand) according to the indices in the
first source operand (the second operand). The first 3 bits of each 64 bit element in the index operand selects
which quadword in the second source operand to copy. The first and second operands are ZMM registers, the third
operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory
location. The elements in the destination are updated using the writemask k1.
Note that this instruction permits a qword in the source operand to be copied to multiple locations in the destina-
tion operand.
If VPERMPD is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an
#UD exception.</hint>
<hint page="0" header="Permute Single-Precision Floating-Point Elements" doc_id="x86_64" token="vpermps">Copies doubleword elements of single-precision floating-point values from the second source operand (the third
operand) to the destination operand (the first operand) according to the indices in the first source operand (the
second operand). Note that this instruction permits a doubleword in the source operand to be copied to more than
one location in the destination operand.
VEX.256 versions: The first and second operands are YMM registers, the third operand can be a YMM register or
memory location. Bits (MAX_VL-1:256) of the corresponding destination register are zeroed.
EVEX encoded version: The first and second operands are ZMM registers, the third operand can be a ZMM register,
a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The elements in the
destination are updated using the writemask k1.
If VPERMPS is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an
#UD exception.</hint>
<hint page="0" header="Qwords Element Permutation" doc_id="x86_64" token="vpermq">The imm8 version: Copies quadwords from the source operand (the second operand) to the destination operand
(the first operand) according to the indices specified by the immediate operand (the third operand). Each two-bit
value in the immediate byte selects a qword element in the source operand.
VEX version: The source operand can be a YMM register or a memory location. Bits (MAX_VL-1:256) of the corre-
sponding destination register are zeroed.
In EVEX.512 encoded version, The elements in the destination are updated using the writemask k1 and the imm8
bits are reused as control bits for the upper 256-bit half when the control bits are coming from immediate. The
source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit
memory location.
Immediate control versions: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will
#UD.
The vector control version: Copies quadwords from the second source operand (the third operand) to the destina-
tion operand (the first operand) according to the indices in the first source operand (the second operand). The first
3 bits of each 64 bit element in the index operand selects which quadword in the second source operand to copy.
The first and second operands are ZMM registers, the third operand can be a ZMM register, a 512-bit memory loca-
tion or a 512-bit vector broadcasted from a 64-bit memory location. The elements in the destination are updated
using the writemask k1.
Note that this instruction permits a qword in the source operand to be copied to multiple locations in the destina-
tion operand.
If VPERMPQ is encoded with VEX.L= 0 or EVEX.128, an attempt to execute the instruction will cause an #UD excep-
tion.</hint>
<hint page="0" header="Load Sparse Packed Doubleword Integer Values from Dense Memory / Register" doc_id="x86_64" token="vpexpandd">Expand (load) up to 16 contiguous doubleword integer values of the input vector in the source operand (the second
operand) to sparse elements in the destination operand (the first operand), selected by the writemask k1. The
destination operand is a ZMM register, the source operand can be a ZMM register or memory location.
The input vector starts from the lowest element in the source operand. The opmask register k1 selects the destina-
tion elements (a partial vector or sparse elements if less than 8 elements) to be replaced by the ascending
elements in the input vector. Destination elements not selected by the writemask k1 are either unmodified or
zeroed, depending on EVEX.z.
Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element
instead of the size of the full vector.</hint>
<hint page="0" header="Load Sparse Packed Quadword Integer Values from Dense Memory / Register" doc_id="x86_64" token="vpexpandq">Expand (load) up to 8 quadword integer values from the source operand (the second operand) to sparse elements
in the destination operand (the first operand), selected by the writemask k1. The destination operand is a ZMM
register, the source operand can be a ZMM register or memory location.
The input vector starts from the lowest element in the source operand. The opmask register k1 selects the destina-
tion elements (a partial vector or sparse elements if less than 8 elements) to be replaced by the ascending
elements in the input vector. Destination elements not selected by the writemask k1 are either unmodified or
zeroed, depending on EVEX.z.
Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element
instead of the size of the full vector.</hint>
<hint page="0" header="Count the Number of Leading Zero Bits for Packed Dword, Packed Qword Values" doc_id="x86_64" token="vplzcntd">Counts the number of leading most significant zero bits in each dword or qword element of the source operand (the
second operand) and stores the results in the destination register (the first operand) according to the writemask.
If an element is zero, the result for that element is the operand size of the element.
EVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector
broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated
using writemask k1.
EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector
broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated
using writemask k1.
EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector
broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated
using writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Count the Number of Leading Zero Bits for Packed Dword, Packed Qword Values" doc_id="x86_64" token="vplzcntq">Counts the number of leading most significant zero bits in each dword or qword element of the source operand (the
second operand) and stores the results in the destination register (the first operand) according to the writemask.
If an element is zero, the result for that element is the operand size of the element.
EVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector
broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated
using writemask k1.
EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector
broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated
using writemask k1.
EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector
broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated
using writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Conditional SIMD Integer Packed Loads and Stores" doc_id="x86_64" token="vpmaskmov">Conditionally moves packed data elements from the second source operand into the corresponding data element
of the destination operand, depending on the mask bits associated with each data element. The mask bits are
specified in the first source operand.
The mask bit for each data element is the most significant bit of that element in the first source operand. If a mask
is 1, the corresponding data element is copied from the second source operand to the destination operand. If the
mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in
the store form.
The second source operand is a memory address for the load form of these instructions. The destination operand
is a memory address for the store form of these instructions. The other operands are either XMM registers (for
VEX.128 version) or YMM registers (for VEX.256 version).
Faults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to
referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no
faults will be detected if the mask bits are all zero.
Unlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to
these instructions.
Instruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits
of all 1s.</hint>
<hint page="0" header="Convert a Mask Register to a Vector" doc_id="x86_64" token="vpmovm2b">Converts a mask register to a vector register. Each element in the destination register is set to all 1's or all 0's
depending on the value of the corresponding bit in the source mask register.
The source operand is a mask register. The destination operand is a ZMM/YMM/XMM register.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert a Mask Register to a Vector" doc_id="x86_64" token="vpmovm2w">Converts a mask register to a vector register. Each element in the destination register is set to all 1's or all 0's
depending on the value of the corresponding bit in the source mask register.
The source operand is a mask register. The destination operand is a ZMM/YMM/XMM register.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert a Mask Register to a Vector" doc_id="x86_64" token="vpmovm2d">Converts a mask register to a vector register. Each element in the destination register is set to all 1's or all 0's
depending on the value of the corresponding bit in the source mask register.
The source operand is a mask register. The destination operand is a ZMM/YMM/XMM register.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert a Mask Register to a Vector" doc_id="x86_64" token="vpmovm2q">Converts a mask register to a vector register. Each element in the destination register is set to all 1's or all 0's
depending on the value of the corresponding bit in the source mask register.
The source operand is a mask register. The destination operand is a ZMM/YMM/XMM register.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert a Vector Register to a Mask" doc_id="x86_64" token="vpmovb2m">Converts a vector register to a mask register. Each element in the destination register is set to 1 or 0 depending on
the value of most significant bit of the corresponding element in the source register.
The source operand is a ZMM/YMM/XMM register. The destination operand is a mask register.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert a Vector Register to a Mask" doc_id="x86_64" token="vpmovw2m">Converts a vector register to a mask register. Each element in the destination register is set to 1 or 0 depending on
the value of most significant bit of the corresponding element in the source register.
The source operand is a ZMM/YMM/XMM register. The destination operand is a mask register.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert a Vector Register to a Mask" doc_id="x86_64" token="vpmovd2m">Converts a vector register to a mask register. Each element in the destination register is set to 1 or 0 depending on
the value of most significant bit of the corresponding element in the source register.
The source operand is a ZMM/YMM/XMM register. The destination operand is a mask register.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Convert a Vector Register to a Mask" doc_id="x86_64" token="vpmovq2m">Converts a vector register to a mask register. Each element in the destination register is set to 1 or 0 depending on
the value of most significant bit of the corresponding element in the source register.
The source operand is a ZMM/YMM/XMM register. The destination operand is a mask register.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert QWord to Byte" doc_id="x86_64" token="vpmovqb">VPMOVQB down converts 64-bit integer elements in the source operand (the second operand) into packed byte
elements using truncation. VPMOVSQB converts signed 64-bit integers into packed signed bytes using signed satu-
ration. VPMOVUSQB convert unsigned quad-word values into unsigned byte values using unsigned saturation. The
source operand is a vector register. The destination operand is an XMM register or a memory location.
Down-converted byte elements are written to the destination operand (the first operand) from the least-significant
byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAX_VL-1:64) of the
destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert QWord to Byte" doc_id="x86_64" token="vpmovsqb">VPMOVQB down converts 64-bit integer elements in the source operand (the second operand) into packed byte
elements using truncation. VPMOVSQB converts signed 64-bit integers into packed signed bytes using signed satu-
ration. VPMOVUSQB convert unsigned quad-word values into unsigned byte values using unsigned saturation. The
source operand is a vector register. The destination operand is an XMM register or a memory location.
Down-converted byte elements are written to the destination operand (the first operand) from the least-significant
byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAX_VL-1:64) of the
destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert QWord to Byte" doc_id="x86_64" token="vpmovusqb">VPMOVQB down converts 64-bit integer elements in the source operand (the second operand) into packed byte
elements using truncation. VPMOVSQB converts signed 64-bit integers into packed signed bytes using signed satu-
ration. VPMOVUSQB convert unsigned quad-word values into unsigned byte values using unsigned saturation. The
source operand is a vector register. The destination operand is an XMM register or a memory location.
Down-converted byte elements are written to the destination operand (the first operand) from the least-significant
byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAX_VL-1:64) of the
destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert QWord to Word" doc_id="x86_64" token="vpmovqw">VPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed words
using truncation. VPMOVSQW converts signed 64-bit integers into packed signed words using signed saturation.
VPMOVUSQW convert unsigned quad-word values into unsigned word values using unsigned saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit
memory location.
Down-converted word elements are written to the destination operand (the first operand) from the least-significant
word. Word elements of the destination operand are updated according to the writemask. Bits (MAX_VL-
1:128/64/32) of the register destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert QWord to Word" doc_id="x86_64" token="vpmovsqw">VPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed words
using truncation. VPMOVSQW converts signed 64-bit integers into packed signed words using signed saturation.
VPMOVUSQW convert unsigned quad-word values into unsigned word values using unsigned saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit
memory location.
Down-converted word elements are written to the destination operand (the first operand) from the least-significant
word. Word elements of the destination operand are updated according to the writemask. Bits (MAX_VL-
1:128/64/32) of the register destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert QWord to Word" doc_id="x86_64" token="vpmovusqw">VPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed words
using truncation. VPMOVSQW converts signed 64-bit integers into packed signed words using signed saturation.
VPMOVUSQW convert unsigned quad-word values into unsigned word values using unsigned saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit
memory location.
Down-converted word elements are written to the destination operand (the first operand) from the least-significant
word. Word elements of the destination operand are updated according to the writemask. Bits (MAX_VL-
1:128/64/32) of the register destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert QWord to DWord" doc_id="x86_64" token="vpmovqd">VPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed double-
words using truncation. VPMOVSQW converts signed 64-bit integers into packed signed doublewords using signed
saturation. VPMOVUSQW convert unsigned quad-word values into unsigned double-word values using unsigned
saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a
256/128/64-bit memory location.
Down-converted doubleword elements are written to the destination operand (the first operand) from the least-
significant doubleword. Doubleword elements of the destination operand are updated according to the writemask.
Bits (MAX_VL-1:256/128/64) of the register destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert QWord to DWord" doc_id="x86_64" token="vpmovsqd">VPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed double-
words using truncation. VPMOVSQW converts signed 64-bit integers into packed signed doublewords using signed
saturation. VPMOVUSQW convert unsigned quad-word values into unsigned double-word values using unsigned
saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a
256/128/64-bit memory location.
Down-converted doubleword elements are written to the destination operand (the first operand) from the least-
significant doubleword. Doubleword elements of the destination operand are updated according to the writemask.
Bits (MAX_VL-1:256/128/64) of the register destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert QWord to DWord" doc_id="x86_64" token="vpmovusqd">VPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed double-
words using truncation. VPMOVSQW converts signed 64-bit integers into packed signed doublewords using signed
saturation. VPMOVUSQW convert unsigned quad-word values into unsigned double-word values using unsigned
saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a
256/128/64-bit memory location.
Down-converted doubleword elements are written to the destination operand (the first operand) from the least-
significant doubleword. Doubleword elements of the destination operand are updated according to the writemask.
Bits (MAX_VL-1:256/128/64) of the register destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert DWord to Byte" doc_id="x86_64" token="vpmovdb">VPMOVDB down converts 32-bit integer elements in the source operand (the second operand) into packed bytes
using truncation. VPMOVSDB converts signed 32-bit integers into packed signed bytes using signed saturation.
VPMOVUSDB convert unsigned double-word values into unsigned byte values using unsigned saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit
memory location.
Down-converted byte elements are written to the destination operand (the first operand) from the least-significant
byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAX_VL-
1:128/64/32) of the register destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert DWord to Byte" doc_id="x86_64" token="vpmovsdb">VPMOVDB down converts 32-bit integer elements in the source operand (the second operand) into packed bytes
using truncation. VPMOVSDB converts signed 32-bit integers into packed signed bytes using signed saturation.
VPMOVUSDB convert unsigned double-word values into unsigned byte values using unsigned saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit
memory location.
Down-converted byte elements are written to the destination operand (the first operand) from the least-significant
byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAX_VL-
1:128/64/32) of the register destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert DWord to Byte" doc_id="x86_64" token="vpmovusdb">VPMOVDB down converts 32-bit integer elements in the source operand (the second operand) into packed bytes
using truncation. VPMOVSDB converts signed 32-bit integers into packed signed bytes using signed saturation.
VPMOVUSDB convert unsigned double-word values into unsigned byte values using unsigned saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit
memory location.
Down-converted byte elements are written to the destination operand (the first operand) from the least-significant
byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAX_VL-
1:128/64/32) of the register destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert DWord to Word" doc_id="x86_64" token="vpmovdw">VPMOVDW down converts 32-bit integer elements in the source operand (the second operand) into packed words
using truncation. VPMOVSDW converts signed 32-bit integers into packed signed words using signed saturation.
VPMOVUSDW convert unsigned double-word values into unsigned word values using unsigned saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a
256/128/64-bit memory location.
Down-converted word elements are written to the destination operand (the first operand) from the least-significant
word. Word elements of the destination operand are updated according to the writemask. Bits (MAX_VL-
1:256/128/64) of the register destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert DWord to Word" doc_id="x86_64" token="vpmovsdw">VPMOVDW down converts 32-bit integer elements in the source operand (the second operand) into packed words
using truncation. VPMOVSDW converts signed 32-bit integers into packed signed words using signed saturation.
VPMOVUSDW convert unsigned double-word values into unsigned word values using unsigned saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a
256/128/64-bit memory location.
Down-converted word elements are written to the destination operand (the first operand) from the least-significant
word. Word elements of the destination operand are updated according to the writemask. Bits (MAX_VL-
1:256/128/64) of the register destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert DWord to Word" doc_id="x86_64" token="vpmovusdw">VPMOVDW down converts 32-bit integer elements in the source operand (the second operand) into packed words
using truncation. VPMOVSDW converts signed 32-bit integers into packed signed words using signed saturation.
VPMOVUSDW convert unsigned double-word values into unsigned word values using unsigned saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a
256/128/64-bit memory location.
Down-converted word elements are written to the destination operand (the first operand) from the least-significant
word. Word elements of the destination operand are updated according to the writemask. Bits (MAX_VL-
1:256/128/64) of the register destination are zeroed.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert Word to Byte" doc_id="x86_64" token="vpmovwb">VPMOVWB down converts 16-bit integers into packed bytes using truncation. VPMOVSWB converts signed 16-bit
integers into packed signed bytes using signed saturation. VPMOVUSWB convert unsigned word values into
unsigned byte values using unsigned saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a
256/128/64-bit memory location.
Down-converted byte elements are written to the destination operand (the first operand) from the least-significant
byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAX_VL-
1:256/128/64) of the register destination are zeroed.
Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert Word to Byte" doc_id="x86_64" token="vpmovswb">VPMOVWB down converts 16-bit integers into packed bytes using truncation. VPMOVSWB converts signed 16-bit
integers into packed signed bytes using signed saturation. VPMOVUSWB convert unsigned word values into
unsigned byte values using unsigned saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a
256/128/64-bit memory location.
Down-converted byte elements are written to the destination operand (the first operand) from the least-significant
byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAX_VL-
1:256/128/64) of the register destination are zeroed.
Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Down Convert Word to Byte" doc_id="x86_64" token="vpmovuswb">VPMOVWB down converts 16-bit integers into packed bytes using truncation. VPMOVSWB converts signed 16-bit
integers into packed signed bytes using signed saturation. VPMOVUSWB convert unsigned word values into
unsigned byte values using unsigned saturation.
The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a
256/128/64-bit memory location.
Down-converted byte elements are written to the destination operand (the first operand) from the least-significant
byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAX_VL-
1:256/128/64) of the register destination are zeroed.
Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Bit Rotate Left" doc_id="x86_64" token="prold"></hint>
<hint page="0" header="Bit Rotate Left" doc_id="x86_64" token="prolvd"></hint>
<hint page="0" header="Bit Rotate Left" doc_id="x86_64" token="prolq"></hint>
<hint page="0" header="Bit Rotate Left" doc_id="x86_64" token="prolvq"></hint>
<hint page="0" header="Bit Rotate Right" doc_id="x86_64" token="prord"></hint>
<hint page="0" header="Bit Rotate Right" doc_id="x86_64" token="prorvd"></hint>
<hint page="0" header="Bit Rotate Right" doc_id="x86_64" token="prorq"></hint>
<hint page="0" header="Bit Rotate Right" doc_id="x86_64" token="prorvq"></hint>
<hint page="0" header="Scatter Packed Dword, Packed" doc_id="x86_64" token="vpscatterdd">Stores up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to
the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The
elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements
will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruc-
tion unless it triggers an exception.
This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register are partially updated. If any traps or interrupts are pending from already scattered
elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction break-
point is not re-triggered when the instruction is continued.
Note that:
.     Only writes to overlapping vector indices are guaranteed to be ordered with respect to each other (from LSB to
      MSB of the source registers). Note that this also include partially overlapping vector indices. Writes that are not
      overlapped may happen in any order. Memory ordering with other instructions follows the Intel-64 memory
      ordering model. Note that this does not account for non-overlapping indices that map into the same physical
      address locations.</hint>
<hint page="0" header="Scatter Packed Dword, Packed" doc_id="x86_64" token="vpscatterdq">Stores up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to
the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The
elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements
will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruc-
tion unless it triggers an exception.
This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register are partially updated. If any traps or interrupts are pending from already scattered
elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction break-
point is not re-triggered when the instruction is continued.
Note that:
.     Only writes to overlapping vector indices are guaranteed to be ordered with respect to each other (from LSB to
      MSB of the source registers). Note that this also include partially overlapping vector indices. Writes that are not
      overlapped may happen in any order. Memory ordering with other instructions follows the Intel-64 memory
      ordering model. Note that this does not account for non-overlapping indices that map into the same physical
      address locations.</hint>
<hint page="0" header="Scatter Packed Dword, Packed" doc_id="x86_64" token="vpscatterqd">Stores up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to
the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The
elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements
will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruc-
tion unless it triggers an exception.
This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register are partially updated. If any traps or interrupts are pending from already scattered
elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction break-
point is not re-triggered when the instruction is continued.
Note that:
.     Only writes to overlapping vector indices are guaranteed to be ordered with respect to each other (from LSB to
      MSB of the source registers). Note that this also include partially overlapping vector indices. Writes that are not
      overlapped may happen in any order. Memory ordering with other instructions follows the Intel-64 memory
      ordering model. Note that this does not account for non-overlapping indices that map into the same physical
      address locations.</hint>
<hint page="0" header="Scatter Packed Dword, Packed" doc_id="x86_64" token="vpscatterqq">Stores up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to
the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The
elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements
will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruc-
tion unless it triggers an exception.
This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register are partially updated. If any traps or interrupts are pending from already scattered
elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction break-
point is not re-triggered when the instruction is continued.
Note that:
.     Only writes to overlapping vector indices are guaranteed to be ordered with respect to each other (from LSB to
      MSB of the source registers). Note that this also include partially overlapping vector indices. Writes that are not
      overlapped may happen in any order. Memory ordering with other instructions follows the Intel-64 memory
      ordering model. Note that this does not account for non-overlapping indices that map into the same physical
      address locations.</hint>
<hint page="0" header="Variable Bit Shift Left Logical" doc_id="x86_64" token="vpsllvw"></hint>
<hint page="0" header="Variable Bit Shift Left Logical" doc_id="x86_64" token="vpsllvd"></hint>
<hint page="0" header="Variable Bit Shift Left Logical" doc_id="x86_64" token="vpsllvq"></hint>
<hint page="0" header="Variable Bit Shift Right Arithmetic" doc_id="x86_64" token="vpsravw"></hint>
<hint page="0" header="Variable Bit Shift Right Arithmetic" doc_id="x86_64" token="vpsravd"></hint>
<hint page="0" header="Variable Bit Shift Right Arithmetic" doc_id="x86_64" token="vpsravq"></hint>
<hint page="0" header="Variable Bit Shift Right Logical" doc_id="x86_64" token="vpsrlvw"></hint>
<hint page="0" header="Variable Bit Shift Right Logical" doc_id="x86_64" token="vpsrlvd"></hint>
<hint page="0" header="Variable Bit Shift Right Logical" doc_id="x86_64" token="vpsrlvq"></hint>
<hint page="0" header="Bitwise Ternary Logic" doc_id="x86_64" token="vpternlogd">VPTERNLOGD/Q takes three bit vectors of 512-bit length (in the first, second and third operand) as input data to
form a set of 512 indices, each index is comprised of one bit from each input vector. The imm8 byte specifies a
boolean logic table producing a binary value for each 3-bit index value. The final 512-bit boolean result is written
to the destination operand (the first operand) using the writemask k1 with the granularity of doubleword element
or quadword element into the destination.
The destination operand is a ZMM (EVEX.512)/YMM (EVEX.256)/XMM (EVEX.128) register. The first source operand
is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit
memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location The destination
operand is a ZMM register conditionally updated with writemask k1.</hint>
<hint page="0" header="Bitwise Ternary Logic" doc_id="x86_64" token="vpternlogq">VPTERNLOGD/Q takes three bit vectors of 512-bit length (in the first, second and third operand) as input data to
form a set of 512 indices, each index is comprised of one bit from each input vector. The imm8 byte specifies a
boolean logic table producing a binary value for each 3-bit index value. The final 512-bit boolean result is written
to the destination operand (the first operand) using the writemask k1 with the granularity of doubleword element
or quadword element into the destination.
The destination operand is a ZMM (EVEX.512)/YMM (EVEX.256)/XMM (EVEX.128) register. The first source operand
is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit
memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location The destination
operand is a ZMM register conditionally updated with writemask k1.</hint>
<hint page="0" header="Logical AND and Set Mask" doc_id="x86_64" token="vptestmb"></hint>
<hint page="0" header="Logical AND and Set Mask" doc_id="x86_64" token="vptestmw"></hint>
<hint page="0" header="Logical AND and Set Mask" doc_id="x86_64" token="vptestmd"></hint>
<hint page="0" header="Logical AND and Set Mask" doc_id="x86_64" token="vptestmq"></hint>
<hint page="0" header="Logical NAND and Set" doc_id="x86_64" token="vptestnmb">Performs a bitwise logical NAND operation on the byte/word/doubleword/quadword element of the first source
operand (the second operand) with the corresponding element of the second source operand (the third operand)
and stores the logical comparison result into each bit of the destination operand (the first operand) according to the
writemask k1. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and
second src operands is zero; otherwise it is set to 0.
EVEX encoded VPTESTNMD/Q: The first source operand is a ZMM/YMM/XMM registers. The second source operand
can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted
from a 32/64-bit memory location. The destination is updated according to the writemask.
EVEX encoded VPTESTNMB/W: The first source operand is a ZMM/YMM/XMM registers. The second source operand
can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the
writemask.</hint>
<hint page="0" header="Logical NAND and Set" doc_id="x86_64" token="vptestnmw">Performs a bitwise logical NAND operation on the byte/word/doubleword/quadword element of the first source
operand (the second operand) with the corresponding element of the second source operand (the third operand)
and stores the logical comparison result into each bit of the destination operand (the first operand) according to the
writemask k1. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and
second src operands is zero; otherwise it is set to 0.
EVEX encoded VPTESTNMD/Q: The first source operand is a ZMM/YMM/XMM registers. The second source operand
can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted
from a 32/64-bit memory location. The destination is updated according to the writemask.
EVEX encoded VPTESTNMB/W: The first source operand is a ZMM/YMM/XMM registers. The second source operand
can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the
writemask.</hint>
<hint page="0" header="Logical NAND and Set" doc_id="x86_64" token="vptestnmd">Performs a bitwise logical NAND operation on the byte/word/doubleword/quadword element of the first source
operand (the second operand) with the corresponding element of the second source operand (the third operand)
and stores the logical comparison result into each bit of the destination operand (the first operand) according to the
writemask k1. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and
second src operands is zero; otherwise it is set to 0.
EVEX encoded VPTESTNMD/Q: The first source operand is a ZMM/YMM/XMM registers. The second source operand
can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted
from a 32/64-bit memory location. The destination is updated according to the writemask.
EVEX encoded VPTESTNMB/W: The first source operand is a ZMM/YMM/XMM registers. The second source operand
can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the
writemask.</hint>
<hint page="0" header="Logical NAND and Set" doc_id="x86_64" token="vptestnmq">Performs a bitwise logical NAND operation on the byte/word/doubleword/quadword element of the first source
operand (the second operand) with the corresponding element of the second source operand (the third operand)
and stores the logical comparison result into each bit of the destination operand (the first operand) according to the
writemask k1. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and
second src operands is zero; otherwise it is set to 0.
EVEX encoded VPTESTNMD/Q: The first source operand is a ZMM/YMM/XMM registers. The second source operand
can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted
from a 32/64-bit memory location. The destination is updated according to the writemask.
EVEX encoded VPTESTNMB/W: The first source operand is a ZMM/YMM/XMM registers. The second source operand
can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the
writemask.</hint>
<hint page="0" header="Range Restriction Calculation For Packed Pairs of Float64 Values" doc_id="x86_64" token="vrangepd">This instruction calculates 2/4/8 range operation outputs from two sets of packed input double-precision FP values
in the first source operand (the second operand) and the second source operand (the third operand). The range
outputs are written to the destination operand (the first operand) under the writemask k1.
Bits7:4 of imm8 byte must be zero. The range operation output is performed in two parts, each configured by a
two-bit control field within imm8[3:0]:
.     Imm8[1:0] specifies the initial comparison operation to be one of max, min, max absolute value or min
      absolute value of the input value pair. Each comparison of two input values produces an intermediate result that
      combines with the sign selection control (Imm8[3:2]) to determine the final range operation output.
.     Imm8[3:2] specifies the sign of the range operation output to be one of the following: from the first input
      value, from the comparison result, set or clear.
The encodings of Imm8[1:0] and Imm8[3:2] are shown in Figure 5-27.</hint>
<hint page="0" header="Range Restriction Calculation For Packed Pairs of Float32 Values" doc_id="x86_64" token="vrangeps">This instruction calculates 4/8/16 range operation outputs from two sets of packed input single-precision FP values
in the first source operand (the second operand) and the second source operand (the third operand). The range
outputs are written to the destination operand (the first operand) under the writemask k1.
Bits7:4 of imm8 byte must be zero. The range operation output is performed in two parts, each configured by a
two-bit control field within imm8[3:0]:
.     Imm8[1:0] specifies the initial comparison operation to be one of max, min, max absolute value or min
      absolute value of the input value pair. Each comparison of two input values produces an intermediate result
      that combines with the sign selection control (Imm8[3:2]) to determine the final range operation output.
.     Imm8[3:2] specifies the sign of the range operation output to be one of the following: from the first input
      value, from the comparison result, set or clear.
The encodings of Imm8[1:0] and Imm8[3:2] are shown in Figure 5-27.
When one or more of the input value is a NAN, the comparison operation may signal invalid exception (IE). Details
with one of more input value is NAN is listed in Table 5-12. If the comparison raises an IE, the sign select control
(Imm8[3:2]) has no effect to the range operation output, this is indicated also in Table 5-12.
When both input values are zeros of opposite signs, the comparison operation of MIN/MAX in the range compare
operation is slightly different from the conceptually similar FP MIN/MAX operation that are found in the instructions
VMAXPD/VMINPD. The details of MIN/MAX/MIN_ABS/MAX_ABS operation for VRANGEPD/PS/SD/SS for magni-
tude-0, opposite-signed input cases are listed in Table 5-13.
Additionally, non-zero, equal-magnitude with opposite-sign input values perform MIN_ABS or MAX_ABS compar-
ison operation with result listed in Table 5-14.</hint>
<hint page="0" header="Range Restriction Calculation From a pair of Scalar Float64 Values" doc_id="x86_64" token="vrangesd">This instruction calculates a range operation output from two input double-precision FP values in the low qword
element of the first source operand (the second operand) and second source operand (the third operand). The
range output is written to the low qword element of the destination operand (the first operand) under the
writemask k1.
Bits7:4 of imm8 byte must be zero. The range operation output is performed in two parts, each configured by a
two-bit control field within imm8[3:0]:
.     Imm8[1:0] specifies the initial comparison operation to be one of max, min, max absolute value or min
      absolute value of the input value pair. Each comparison of two input values produces an intermediate result
      that combines with the sign selection control (Imm8[3:2]) to determine the final range operation output.
.     Imm8[3:2] specifies the sign of the range operation output to be one of the following: from the first input
      value, from the comparison result, set or clear.
The encodings of Imm8[1:0] and Imm8[3:2] are shown in Figure 5-27.
Bits 128:63 of the destination operand are copied from the respective element of the first source operand.
When one or more of the input value is a NAN, the comparison operation may signal invalid exception (IE). Details
with one of more input value is NAN is listed in Table 5-12. If the comparison raises an IE, the sign select control
(Imm8[3:2] has no effect to the range operation output, this is indicated also in Table 5-12.
When both input values are zeros of opposite signs, the comparison operation of MIN/MAX in the range compare
operation is slightly different from the conceptually similar FP MIN/MAX operation that are found in the instructions
VMAXPD/VMINPD. The details of MIN/MAX/MIN_ABS/MAX_ABS operation for VRANGEPD/PS/SD/SS for magni-
tude-0, opposite-signed input cases are listed in Table 5-13.
Additionally, non-zero, equal-magnitude with opposite-sign input values perform MIN_ABS or MAX_ABS compar-
ison operation with result listed in Table 5-14.</hint>
<hint page="0" header="Range Restriction Calculation From a Pair of Scalar Float32 Values" doc_id="x86_64" token="vrangess">This instruction calculates a range operation output from two input single-precision FP values in the low dword
element of the first source operand (the second operand) and second source operand (the third operand). The
range output is written to the low dword element of the destination operand (the first operand) under the
writemask k1.
Bits7:4 of imm8 byte must be zero. The range operation output is performed in two parts, each configured by a
two-bit control field within imm8[3:0]:
.     Imm8[1:0] specifies the initial comparison operation to be one of max, min, max absolute value or min
      absolute value of the input value pair. Each comparison of two input values produces an intermediate result that
      combines with the sign selection control (Imm8[3:2]) to determine the final range operation output.
.     Imm8[3:2] specifies the sign of the range operation output to be one of the following: from the first input
      value, from the comparison result, set or clear.
The encodings of Imm8[1:0] and Imm8[3:2] are shown in Figure 5-27.
Bits 128:31 of the destination operand are copied from the respective elements of the first source operand.
When one or more of the input value is a NAN, the comparison operation may signal invalid exception (IE). Details
with one of more input value is NAN is listed in Table 5-12. If the comparison raises an IE, the sign select control
(Imm8[3:2]) has no effect to the range operation output, this is indicated also in Table 5-12.
When both input values are zeros of opposite signs, the comparison operation of MIN/MAX in the range compare
operation is slightly different from the conceptually similar FP MIN/MAX operation that are found in the instructions
VMAXPD/VMINPD. The details of MIN/MAX/MIN_ABS/MAX_ABS operation for VRANGEPD/PS/SD/SS for magni-
tude-0, opposite-signed input cases are listed in Table 5-13.
Additionally, non-zero, equal-magnitude with opposite-sign input values perform MIN_ABS or MAX_ABS compar-
ison operation with result listed in Table 5-14.</hint>
<hint page="0" header="Compute Approximate Reciprocals of Packed Float64 Values" doc_id="x86_64" token="vrcp14pd">This instruction performs a SIMD computation of the approximate reciprocals of eight/four/two packed double-
precision floating-point values in the source operand (the second operand) and stores the packed double-precision
floating-point results in the destination operand. The maximum relative error for this approximation is less than 2-
14
   .
The source operand can be a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-
bit memory location. The destination operand is a ZMM register conditionally updated according to the writemask.
The VRCP14PD instruction is not affected by the rounding control bits in the MXCSR register. When a source value
is a 0.0, an inf with the sign of the source value is returned. A denormal source value will be treated as zero only in
case of DAZ bit set in MXCSR. Otherwise it is treated correctly (i.e. not as a 0.0). Underflow results are flushed to
zero only in case of FTZ bit set in MXCSR. Otherwise it will be treated correctly (i.e. correct underflow result is
written) with the sign of the operand. When a source value is a SNaN or QNaN, the SNaN is converted to a QNaN
or the source QNaN is returned.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.</hint>
<hint page="0" header="Compute Approximate Reciprocal of Scalar Float64 Value" doc_id="x86_64" token="vrcp14sd">This instruction performs a SIMD computation of the approximate reciprocal of the low double-precision floating-
point value in the second source operand (the third operand) stores the result in the low quadword element of the
destination operand (the first operand) according to the writemask k1. Bits (127:64) of the XMM register destina-
tion are copied from corresponding bits in the first source operand (the second operand). The maximum relative
error for this approximation is less than 2-14. The source operand can be an XMM register or a 64-bit memory loca-
tion. The destination operand is an XMM register.
The VRCP14SD instruction is not affected by the rounding control bits in the MXCSR register. When a source value
is a 0.0, an inf with the sign of the source value is returned. A denormal source value will be treated as zero only in
case of DAZ bit set in MXCSR. Otherwise it is treated correctly (i.e. not as a 0.0). Underflow results are flushed to
zero only in case of FTZ bit set in MXCSR. Otherwise it will be treated correctly (i.e. correct underflow result is
written) with the sign of the operand. When a source value is a SNaN or QNaN, the SNaN is converted to a QNaN
or the source QNaN is returned. See Table 5-15 for special-case input values.
MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.
A numerically exact implementation of VRCP14xx can be found at https://software.intel.com/en-us/articles/refer-
ence-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Compute Approximate Reciprocals of Packed Float32 Values" doc_id="x86_64" token="vrcp14ps">This instruction performs a SIMD computation of the approximate reciprocals of the packed single-precision
floating-point values in the source operand (the second operand) and stores the packed single-precision floating-
point results in the destination operand (the first operand). The maximum relative error for this approximation is
less than 2-14.
The source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-
bit memory location. The destination operand is a ZMM register conditionally updated according to the writemask.
The VRCP14PS instruction is not affected by the rounding control bits in the MXCSR register. When a source value
is a 0.0, an inf with the sign of the source value is returned. A denormal source value will be treated as zero only in
case of DAZ bit set in MXCSR. Otherwise it is treated correctly (i.e. not as a 0.0). Underflow results are flushed to
zero only in case of FTZ bit set in MXCSR. Otherwise it will be treated correctly (i.e. correct underflow result is
written) with the sign of the operand. When a source value is a SNaN or QNaN, the SNaN is converted to a QNaN
or the source QNaN is returned.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.</hint>
<hint page="0" header="Compute Approximate Reciprocal of Scalar Float32 Value" doc_id="x86_64" token="vrcp14ss">This instruction performs a SIMD computation of the approximate reciprocal of the low single-precision floating-
point value in the second source operand (the third operand) and stores the result in the low quadword element of
the destination operand (the first operand) according to the writemask k1. Bits (127:32) of the XMM register desti-
nation are copied from corresponding bits in the first source operand (the second operand). The maximum relative
error for this approximation is less than 2-14. The source operand can be an XMM register or a 32-bit memory loca-
tion. The destination operand is an XMM register.
The VRCP14SS instruction is not affected by the rounding control bits in the MXCSR register. When a source value
is a 0.0, an inf with the sign of the source value is returned. A denormal source value will be treated as zero only in
case of DAZ bit set in MXCSR. Otherwise it is treated correctly (i.e. not as a 0.0). Underflow results are flushed to
zero only in case of FTZ bit set in MXCSR. Otherwise it will be treated correctly (i.e. correct underflow result is
written) with the sign of the operand. When a source value is a SNaN or QNaN, the SNaN is converted to a QNaN
or the source QNaN is returned. See Table 5-16 for special-case input values.
MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.
A numerically exact implementation of VRCP14xx can be found at https://software.intel.com/en-us/articles/refer-
ence-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Approximation to the Reciprocal of Packed Double-Precision Floating-Point Values" doc_id="x86_64" token="vrcp28pd">Computes the reciprocal approximation of the float64 values in the source operand (the second operand) and store
the results to the destination operand (the first operand). The approximate reciprocal is evaluated with less than
2^-28 of maximum relative error.
Denormal input values are treated as zeros and do not signal #DE, irrespective of MXCSR.DAZ. Denormal results
are flushed to zeros and do not signal #UE, irrespective of MXCSR.FZ.
If any source element is NaN, the quietized NaN source value is returned for that element. If any source element is
+-inf, +-0.0 is returned for that element. Also, if any source element is +-0.0, +-inf is returned for that element.
The source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit
memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
A numerically exact implementation of VRCP28xx can be found at https://software.intel.com/en-us/articles/refer-
ence-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Approximation to the Reciprocal of Scalar Double-Precision Floating-Point Value" doc_id="x86_64" token="vrcp28sd">Computes the reciprocal approximation of the low float64 value in the second source operand (the third operand)
and store the result to the destination operand (the first operand). The approximate reciprocal is evaluated with
less than 2^-28 of maximum relative error. The result is written into the low float64 element of the destination
operand according to the writemask k1. Bits 127:64 of the destination is copied from the corresponding bits of the
first source operand (the second operand).
A denormal input value is treated as zero and does not signal #DE, irrespective of MXCSR.DAZ. A denormal result
is flushed to zero and does not signal #UE, irrespective of MXCSR.FZ.
If any source element is NaN, the quietized NaN source value is returned for that element. If any source element is
+-inf, +-0.0 is returned for that element. Also, if any source element is +-0.0, +-inf is returned for that element.
The first source operand is an XMM register. The second source operand is an XMM register or a 64-bit memory
location. The destination operand is a XMM register, conditionally updated using writemask k1.
A numerically exact implementation of VRCP28xx can be found at https://software.intel.com/en-us/articles/refer-
ence-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Approximation to the Reciprocal of Packed Single-Precision Floating-Point Values" doc_id="x86_64" token="vrcp28ps">Computes the reciprocal approximation of the float32 values in the source operand (the second operand) and store
the results to the destination operand (the first operand) using the writemask k1. The approximate reciprocal is
evaluated with less than 2^-28 of maximum relative error prior to final rounding. The final results are rounded to
&lt; 2^-23 relative error before written to the destination.
Denormal input values are treated as zeros and do not signal #DE, irrespective of MXCSR.DAZ. Denormal results
are flushed to zeros and do not signal #UE, irrespective of MXCSR.FZ.
If any source element is NaN, the quietized NaN source value is returned for that element. If any source element is
+-inf, +-0.0 is returned for that element. Also, if any source element is +-0.0, +-inf is returned for that element.
The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit
memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
A numerically exact implementation of VRCP28xx can be found at https://software.intel.com/en-us/articles/refer-
ence-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Approximation to the Reciprocal of Scalar Single-Precision Floating-Point Value" doc_id="x86_64" token="vrcp28ss">Computes the reciprocal approximation of the low float32 value in the second source operand (the third operand)
and store the result to the destination operand (the first operand). The approximate reciprocal is evaluated with
less than 2^-28 of maximum relative error prior to final rounding. The final result is rounded to &lt; 2^-23 relative
error before written into the low float32 element of the destination according to writemask k1. Bits 127:32 of the
destination is copied from the corresponding bits of the first source operand (the second operand).
A denormal input value is treated as zero and does not signal #DE, irrespective of MXCSR.DAZ. A denormal result
is flushed to zero and does not signal #UE, irrespective of MXCSR.FZ.
If any source element is NaN, the quietized NaN source value is returned for that element. If any source element is
+-inf, +-0.0 is returned for that element. Also, if any source element is +-0.0, +-inf is returned for that element.
The first source operand is an XMM register. The second source operand is an XMM register or a 32-bit memory
location. The destination operand is a XMM register, conditionally updated using writemask k1.
A numerically exact implementation of VRCP28xx can be found at https://software.intel.com/en-us/articles/refer-
ence-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Perform Reduction Transformation on Packed Float64 Values" doc_id="x86_64" token="vreducepd">Perform reduction transformation of the packed binary encoded double-precision FP values in the source operand
(the second operand) and store the reduced results in binary FP format to the destination operand (the first
operand) under the writemask k1.
The reduction transformation subtracts the integer part and the leading M fractional bits from the binary FP source
value, where M is a unsigned integer specified by imm8[7:4], see Figure 5-28. Specifically, the reduction transfor-
mation can be expressed as:
dest = src - (ROUND(2M*src))*2-M;
where "Round()" treats "src", "2M", and their product as binary FP numbers with normalized significand and bi-
ased exponents.
The magnitude of the reduced result can be expressed by considering src= 2p*man2,
where 'man2' is the normalized significand and 'p' is the unbiased exponent
Then if RC = RNE: 0&lt;=|Reduced Result|&lt;=2p-M-1
Then if RC != RNE: 0&lt;=|Reduced Result|&lt;2p-M
This instruction might end up with a precision exception set. However, in case of SPE set (i.e. Suppress Precision
Exception, which is imm8[3]=1), no precision exception is reported.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.</hint>
<hint page="0" header="Perform a Reduction Transformation on a Scalar Float64 Value" doc_id="x86_64" token="vreducesd">Perform a reduction transformation of the binary encoded double-precision FP value in the low qword element of
the second source operand (the third operand) and store the reduced result in binary FP format to the low qword
element of the destination operand (the first operand) under the writemask k1. Bits 127:64 of the destination
operand are copied from respective qword elements of the first source operand (the second operand).
The reduction transformation subtracts the integer part and the leading M fractional bits from the binary FP source
value, where M is a unsigned integer specified by imm8[7:4], see Figure 5-28. Specifically, the reduction transfor-
mation can be expressed as:
dest = src - (ROUND(2M*src))*2-M;
where "Round()" treats "src", "2M", and their product as binary FP numbers with normalized significand and bi-
ased exponents.
The magnitude of the reduced result can be expressed by considering src= 2p*man2,
where 'man2' is the normalized significand and 'p' is the unbiased exponent
Then if RC = RNE: 0&lt;=|Reduced Result|&lt;=2p-M-1
Then if RC != RNE: 0&lt;=|Reduced Result|&lt;2p-M
This instruction might end up with a precision exception set. However, in case of SPE set (i.e. Suppress Precision
Exception, which is imm8[3]=1), no precision exception is reported.
The operation is write masked.
Handling of special case of input values are listed in Table 5-21.</hint>
<hint page="0" header="Perform Reduction Transformation on Packed Float32 Values" doc_id="x86_64" token="vreduceps">Perform reduction transformation of the packed binary encoded single-precision FP values in the source operand
(the second operand) and store the reduced results in binary FP format to the destination operand (the first
operand) under the writemask k1.
The reduction transformation subtracts the integer part and the leading M fractional bits from the binary FP source
value, where M is a unsigned integer specified by imm8[7:4], see Figure 5-28. Specifically, the reduction transfor-
mation can be expressed as:
dest = src - (ROUND(2M*src))*2-M;
where "Round()" treats "src", "2M", and their product as binary FP numbers with normalized significand and bi-
ased exponents.
The magnitude of the reduced result can be expressed by considering src= 2p*man2,
where 'man2' is the normalized significand and 'p' is the unbiased exponent
Then if RC = RNE: 0&lt;=|Reduced Result|&lt;=2p-M-1
Then if RC != RNE: 0&lt;=|Reduced Result|&lt;2p-M</hint>
<hint page="0" header="Perform a Reduction Transformation on a Scalar Float32 Value" doc_id="x86_64" token="vreducess">Perform a reduction transformation of the binary encoded single-precision FP value in the low dword element of the
second source operand (the third operand) and store the reduced result in binary FP format to the low dword
element of the destination operand (the first operand) under the writemask k1. Bits 127:32 of the destination
operand are copied from respective dword elements of the first source operand (the second operand).
The reduction transformation subtracts the integer part and the leading M fractional bits from the binary FP source
value, where M is a unsigned integer specified by imm8[7:4], see Figure 5-28. Specifically, the reduction transfor-
mation can be expressed as:
dest = src - (ROUND(2M*src))*2-M;
where "Round()" treats "src", "2M", and their product as binary FP numbers with normalized significand and bi-
ased exponents.
The magnitude of the reduced result can be expressed by considering src= 2p*man2,
where 'man2' is the normalized significand and 'p' is the unbiased exponent
Then if RC = RNE: 0&lt;=|Reduced Result|&lt;=2p-M-1
Then if RC != RNE: 0&lt;=|Reduced Result|&lt;2p-M</hint>
<hint page="0" header="Round Packed Float64 Values To Include A Given Number Of Fraction Bits" doc_id="x86_64" token="vrndscalepd">Round the double-precision floating-point values in the source operand by the rounding mode specified in the
immediate operand (see Figure 5-29) and places the result in the destination operand.
The destination operand (the first operand) is a ZMM/YMM/XMM register conditionally updated according to the
writemask. The source operand (the second operand) can be a ZMM/YMM/XMM register, a 512/256/128-bit
memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location.
The rounding process rounds the input to an integral value, plus number bits of fraction that are specified by
imm8[7:4] (to be included in the result) and returns the result as a double-precision floating-point value.
It should be noticed that no overflow is induced while executing this instruction (although the source is scaled by
the imm8[7:4] value).
The immediate operand also specifies control fields for the rounding operation, three bit fields are defined and
shown in the "Immediate Control Description" figure below. Bit 3 of the immediate byte controls the processor
behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky
rounding-mode value (Immediate control table below lists the encoded values for rounding-mode field).
The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an
SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before
rounding.
The sign of the result of this instruction is preserved, including the sign of zero.
The formula of the operation on each data element for VRNDSCALEPD is
    ROUND(x) = 2-M*Round_to_INT(x*2M, round_ctrl),
    round_ctrl = imm[3:0];
    M=imm[7:4];
The operation of x*2M is computed as if the exponent range is unlimited (i.e. no overflow ever occurs).</hint>
<hint page="0" header="Round Scalar Float64 Value To Include A Given Number Of Fraction Bits" doc_id="x86_64" token="vrndscalesd">Rounds a double-precision floating-point value in the low quadword (see Figure 5-29) element the second source
operand (the third operand) by the rounding mode specified in the immediate operand and places the result in the
corresponding element of the destination operand (the third operand) according to the writemask. The quadword
element at bits 127:64 of the destination is copied from the first source operand (the second operand).
The destination and first source operands are XMM registers, the 2nd source operand can be an XMM register or
memory location. Bits MAX_VL-1:128 of the destination register are cleared.
The rounding process rounds the input to an integral value, plus number bits of fraction that are specified by
imm8[7:4] (to be included in the result) and returns the result as a double-precision floating-point value.
It should be noticed that no overflow is induced while executing this instruction (although the source is scaled by
the imm8[7:4] value).
The immediate operand also specifies control fields for the rounding operation, three bit fields are defined and
shown in the "Immediate Control Description" figure below. Bit 3 of the immediate byte controls the processor
behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky
rounding-mode value (Immediate control table below lists the encoded values for rounding-mode field).
The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an
SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before
rounding.
The sign of the result of this instruction is preserved, including the sign of zero.</hint>
<hint page="0" header="Round Packed Float32 Values To Include A Given Number Of Fraction Bits" doc_id="x86_64" token="vrndscaleps">Round the single-precision floating-point values in the source operand by the rounding mode specified in the imme-
diate operand (see Figure 5-29) and places the result in the destination operand.
The destination operand (the first operand) is a ZMM register conditionally updated according to the writemask.
The source operand (the second operand) can be a ZMM register, a 512-bit memory location, or a 512-bit vector
broadcasted from a 32-bit memory location.
The rounding process rounds the input to an integral value, plus number bits of fraction that are specified by
imm8[7:4] (to be included in the result) and returns the result as a single-precision floating-point value.
It should be noticed that no overflow is induced while executing this instruction (although the source is scaled by
the imm8[7:4] value).
The immediate operand also specifies control fields for the rounding operation, three bit fields are defined and
shown in the "Immediate Control Description" figure below. Bit 3 of the immediate byte controls the processor
behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky
rounding-mode value (Immediate control table below lists the encoded values for rounding-mode field).
The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an
SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before
rounding.
The sign of the result of this instruction is preserved, including the sign of zero.</hint>
<hint page="0" header="Round Scalar Float32 Value To Include A Given Number Of Fraction Bits" doc_id="x86_64" token="vrndscaless">Rounds the single-precision floating-point value in the low doubleword element of the second source operand (the
third operand) by the rounding mode specified in the immediate operand (see Figure 5-29) and places the result in
the corresponding element of the destination operand (the first operand) according to the writemask. The double-
word elements at bits 127:32 of the destination are copied from the first source operand (the second operand).
The destination and first source operands are XMM registers, the 2nd source operand can be an XMM register or
memory location. Bits MAX_VL-1:128 of the destination register are cleared.
The rounding process rounds the input to an integral value, plus number bits of fraction that are specified by
imm8[7:4] (to be included in the result) and returns the result as a single-precision floating-point value.
It should be noticed that no overflow is induced while executing this instruction (although the source is scaled by
the imm8[7:4] value).
The immediate operand also specifies control fields for the rounding operation, three bit fields are defined and
shown in the "Immediate Control Description" figure below. Bit 3 of the immediate byte controls the processor
behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky
rounding-mode value (Immediate control tables below lists the encoded values for rounding-mode field).
The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an
SNaN then it will be converted to a QNaN. If DAZ is set to '1 then denormals will be converted to zero before
rounding.
The sign of the result of this instruction is preserved, including the sign of zero.</hint>
<hint page="0" header="Compute Approximate Reciprocals of Square Roots of Packed Float64 Values" doc_id="x86_64" token="vrsqrt14pd">This instruction performs a SIMD computation of the approximate reciprocals of the square roots of the eight
packed double-precision floating-point values in the source operand (the second operand) and stores the packed
double-precision floating-point results in the destination operand (the first operand) according to the writemask.
The maximum relative error for this approximation is less than 2-14.
EVEX.512 encoded version: The source operand can be a ZMM register, a 512-bit memory location, or a 512-bit
vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally
updated using writemask k1.
EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector
broadcasted from a 64-bit memory location. The destination operand is a YMM register, conditionally updated using
writemask k1.
EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector
broadcasted from a 64-bit memory location. The destination operand is a XMM register, conditionally updated using
writemask k1.
The VRSQRT14PD instruction is not affected by the rounding control bits in the MXCSR register. When a source
value is a 0.0, an inf with the sign of the source value is returned. When the source operand is an +inf then +ZERO
value is returned. A denormal source value is treated as zero only if DAZ bit is set in MXCSR. Otherwise it is treated
correctly and performs the approximation with the specified masked response. When a source value is a negative
value (other than 0.0) a floating-point QNaN_indefinite is returned. When a source value is an SNaN or QNaN, the
SNaN is converted to a QNaN or the source QNaN is returned.
MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.
Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.
A numerically exact implementation of VRSQRT14xx can be found at https://software.intel.com/en-us/arti-
cles/reference-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Compute Approximate Reciprocal of Square Root of Scalar Float64 Value" doc_id="x86_64" token="vrsqrt14sd">Computes the approximate reciprocal of the square roots of the scalar double-precision floating-point value in the
low quadword element of the source operand (the second operand) and stores the result in the low quadword
element of the destination operand (the first operand) according to the writemask. The maximum relative error for
this approximation is less than 2-14. The source operand can be an XMM register or a 32-bit memory location. The
destination operand is an XMM register.
Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits
(MAX_VL-1:128) of the destination register are zeroed.
The VRSQRT14SD instruction is not affected by the rounding control bits in the MXCSR register. When a source
value is a 0.0, an inf with the sign of the source value is returned. When the source operand is an +inf then +ZERO
value is returned. A denormal source value is treated as zero only if DAZ bit is set in MXCSR. Otherwise it is treated
correctly and performs the approximation with the specified masked response. When a source value is a negative
value (other than 0.0) a floating-point QNaN_indefinite is returned. When a source value is an SNaN or QNaN, the
SNaN is converted to a QNaN or the source QNaN is returned.
MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.
A numerically exact implementation of VRSQRT14xx can be found at https://software.intel.com/en-us/arti-
cles/reference-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Compute Approximate Reciprocals of Square Roots of Packed Float32 Values" doc_id="x86_64" token="vrsqrt14ps">This instruction performs a SIMD computation of the approximate reciprocals of the square roots of 16 packed
single-precision floating-point values in the source operand (the second operand) and stores the packed single-
precision floating-point results in the destination operand (the first operand) according to the writemask. The
maximum relative error for this approximation is less than 2-14.
EVEX.512 encoded version: The source operand can be a ZMM register, a 512-bit memory location or a 512-bit
vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally
updated using writemask k1.
EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector
broadcasted from a 32-bit memory location. The destination operand is a YMM register, conditionally updated using
writemask k1.
EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector
broadcasted from a 32-bit memory location. The destination operand is a XMM register, conditionally updated using
writemask k1.
The VRSQRT14PS instruction is not affected by the rounding control bits in the MXCSR register. When a source
value is a 0.0, an inf with the sign of the source value is returned. When the source operand is an +inf then +ZERO
value is returned. A denormal source value is treated as zero only if DAZ bit is set in MXCSR. Otherwise it is treated
correctly and performs the approximation with the specified masked response. When a source value is a negative
value (other than 0.0) a floating-point QNaN_indefinite is returned. When a source value is an SNaN or QNaN, the
SNaN is converted to a QNaN or the source QNaN is returned.
MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.
Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.
A numerically exact implementation of VRSQRT14xx can be found at https://software.intel.com/en-us/arti-
cles/reference-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Compute Approximate Reciprocal of Square Root of Scalar Float32 Value" doc_id="x86_64" token="vrsqrt14ss">Computes of the approximate reciprocal of the square root of the scalar single-precision floating-point value in the
low doubleword element of the source operand (the second operand) and stores the result in the low doubleword
element of the destination operand (the first operand) according to the writemask. The maximum relative error for
this approximation is less than 2-14. The source operand can be an XMM register or a 32-bit memory location. The
destination operand is an XMM register.
Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits
(MAX_VL-1:128) of the destination register are zeroed.
The VRSQRT14SS instruction is not affected by the rounding control bits in the MXCSR register. When a source
value is a 0.0, an inf with the sign of the source value is returned. When the source operand is an inf, zero with the
sign of the source value is returned. A denormal source value is treated as zero only if DAZ bit is set in MXCSR.
Otherwise it is treated correctly and performs the approximation with the specified masked response. When a
source value is a negative value (other than 0.0) a floating-point indefinite is returned. When a source value is an
SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.
MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.
A numerically exact implementation of VRSQRT14xx can be found at https://software.intel.com/en-us/arti-
cles/reference-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Approximation to the Reciprocal Square Root of Packed Double-Precision" doc_id="x86_64" token="vrsqrt28pd">Computes the reciprocal square root of the float64 values in the source operand (the second operand) and store
the results to the destination operand (the first operand). The approximate reciprocal is evaluated with less than
2^-28 of maximum relative error.
If any source element is NaN, the quietized NaN source value is returned for that element. Negative (non-zero)
source numbers, as well as -inf, return the canonical NaN and set the Invalid Flag (#I).
A value of -0 must return -inf and set the DivByZero flags (#Z). Negative numbers should return NaN and set the
Invalid flag (#I). Note however that the instruction flush input denormals to zero of the same sign, so negative
denormals return -inf and set the DivByZero flag.
The source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit
memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
A numerically exact implementation of VRSQRT28xx can be found at https://software.intel.com/en-us/arti-
cles/reference-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Approximation to the Reciprocal Square Root of Scalar Double-Precision" doc_id="x86_64" token="vrsqrt28sd">Computes the reciprocal square root of the low float64 value in the second source operand (the third operand) and
store the result to the destination operand (the first operand). The approximate reciprocal square root is evaluated
with less than 2^-28 of maximum relative error. The result is written into the low float64 element of xmm1
according to the writemask k1. Bits 127:64 of the destination is copied from the corresponding bits of the first source operand
(the second operand).
If any source element is NaN, the quietized NaN source value is returned for that element. Negative (non-zero)
source numbers, as well as -inf, return the canonical NaN and set the Invalid Flag (#I).
A value of -0 must return -inf and set the DivByZero flags (#Z). Negative numbers should return NaN and set the
Invalid flag (#I). Note however that the instruction flush input denormals to zero of the same sign, so negative
denormals return -inf and set the DivByZero flag.
The first source operand is an XMM register. The second source operand is an XMM register or a 64-bit memory
location. The destination operand is a XMM register.
A numerically exact implementation of VRSQRT28xx can be found at https://software.intel.com/en-us/arti-
cles/reference-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Approximation to the Reciprocal Square Root of Packed Single-Precision" doc_id="x86_64" token="vrsqrt28ps">Computes the reciprocal square root of the float32 values in the source operand (the second operand) and store
the results to the destination operand (the first operand). The approximate reciprocal is evaluated with less than
2^-28 of maximum relative error prior to final rounding. The final results is rounded to &lt; 2^-23 relative error
before written to the destination.
If any source element is NaN, the quietized NaN source value is returned for that element. Negative (non-zero)
source numbers, as well as -inf, return the canonical NaN and set the Invalid Flag (#I).
A value of -0 must return -inf and set the DivByZero flags (#Z). Negative numbers should return NaN and set the
Invalid flag (#I). Note however that the instruction flush input denormals to zero of the same sign, so negative
denormals return -inf and set the DivByZero flag.
The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit
memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.
EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.
A numerically exact implementation of VRSQRT28xx can be found at https://software.intel.com/en-us/arti-
cles/reference-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Approximation to the Reciprocal Square Root of Scalar Single-Precision Floating-" doc_id="x86_64" token="vrsqrt28ss">Computes the reciprocal square root of the low float32 value in the second source operand (the third operand) and
store the result to the destination operand (the first operand). The approximate reciprocal square root is evaluated
with less than 2^-28 of maximum relative error prior to final rounding. The final result is rounded to &lt; 2^-23 rela-
tive error before written to the low float32 element of the destination according to the writemask k1. Bits 127:32 of
the destination is copied from the corresponding bits of the first source operand (the second operand).
If any source element is NaN, the quietized NaN source value is returned for that element. Negative (non-zero)
source numbers, as well as -inf, return the canonical NaN and set the Invalid Flag (#I).
A value of -0 must return -inf and set the DivByZero flags (#Z). Negative numbers should return NaN and set the
Invalid flag (#I). Note however that the instruction flush input denormals to zero of the same sign, so negative
denormals return -inf and set the DivByZero flag.
The first source operand is an XMM register. The second source operand is an XMM register or a 32-bit memory
location. The destination operand is a XMM register.
A numerically exact implementation of VRSQRT28xx can be found at https://software.intel.com/en-us/arti-
cles/reference-implementations-for-IA-approximation-instructions-vrcp14-vrsqrt14-vrcp28-vrsqrt28-vexp2.</hint>
<hint page="0" header="Scale Packed Float64 Values With Float64 Values" doc_id="x86_64" token="vscalefpd">Performs a floating-point scale of the packed double-precision floating-point values in the first source operand by
multiplying it by 2 power of the double-precision floating-point values in second source operand.
The equation of this operation is given by:
zmm1 := zmm2*2floor(zmm3).
Floor(zmm3) means maximum integer value &lt;= zmm3.
If the result cannot be represented in double precision, then the proper overflow response (for positive scaling
operand), or the proper underflow response (for negative scaling operand) is issued. The overflow and underflow
responses are dependent on the rounding mode (for IEEE-compliant rounding), as well as on other settings in
MXCSR (exception mask bits, FTZ bit), and on the SAE bit.
The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a
512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The
destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.
Handling of special-case input values are listed in Table 5-31 and Table 5-32.</hint>
<hint page="0" header="Scale Scalar Float64 Values With Float64 Values" doc_id="x86_64" token="vscalefsd">Performs a floating-point scale of the packed double-precision floating-point value in the first source operand by
multiplying it by 2 power of the double-precision floating-point value in second source operand.
The equation of this operation is given by:
xmm1 := xmm2*2floor(xmm3).
Floor(xmm3) means maximum integer value &lt;= xmm3.
If the result cannot be represented in double precision, then the proper overflow response (for positive scaling
operand), or the proper underflow response (for negative scaling operand) is issued. The overflow and underflow
responses are dependent on the rounding mode (for IEEE-compliant rounding), as well as on other settings in
MXCSR (exception mask bits, FTZ bit), and on the SAE bit.
EVEX encoded version: The first source operand is an XMM register. The second source operand is an XMM register
or a memory location. The destination operand is an XMM register conditionally updated with writemask k1.
Handling of special-case input values are listed in Table 5-31 and Table 5-32.</hint>
<hint page="0" header="Scale Packed Float32 Values With Float32 Values" doc_id="x86_64" token="vscalefps">Performs a floating-point scale of the packed single-precision floating-point values in the first source operand by
multiplying it by 2 power of the float32 values in second source operand.
The equation of this operation is given by:
zmm1 := zmm2*2floor(zmm3).
Floor(zmm3) means maximum integer value &lt;= zmm3.</hint>
<hint page="0" header="Scale Scalar Float32 Value With Float32 Value" doc_id="x86_64" token="vscalefss">Performs a floating-point scale of the scalar single-precision floating-point value in the first source operand by
multiplying it by 2 power of the float32 value in second source operand.
The equation of this operation is given by:
xmm1 := xmm2*2floor(xmm3).
Floor(xmm3) means maximum integer value &lt;= xmm3.</hint>
<hint page="0" header="Scatter Packed Single, Packed" doc_id="x86_64" token="vscatterdps">Stores up to 16 elements (or 8 elements) in doubleword/quadword vector zmm1 to the memory locations pointed
by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB
(i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corre-
sponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an excep-
tion.
This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register (k1) are partially updated. If any traps or interrupts are pending from already scat-
tered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction
breakpoint is not re-triggered when the instruction is continued.
Note that:
.     Only writes to overlapping vector indices are guaranteed to be ordered with respect to each other (from LSB to
      MSB of the source registers). Note that this also include partially overlapping vector indices. Writes that are not
      overlapped may happen in any order. Memory ordering with other instructions follows the Intel-64 memory
      ordering model. Note that this does not account for non-overlapping indices that map into the same physical
      address locations.</hint>
<hint page="0" header="Scatter Packed Single, Packed" doc_id="x86_64" token="vscatterdpd">Stores up to 16 elements (or 8 elements) in doubleword/quadword vector zmm1 to the memory locations pointed
by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB
(i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corre-
sponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an excep-
tion.
This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register (k1) are partially updated. If any traps or interrupts are pending from already scat-
tered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction
breakpoint is not re-triggered when the instruction is continued.
Note that:
.     Only writes to overlapping vector indices are guaranteed to be ordered with respect to each other (from LSB to
      MSB of the source registers). Note that this also include partially overlapping vector indices. Writes that are not
      overlapped may happen in any order. Memory ordering with other instructions follows the Intel-64 memory
      ordering model. Note that this does not account for non-overlapping indices that map into the same physical
      address locations.</hint>
<hint page="0" header="Scatter Packed Single, Packed" doc_id="x86_64" token="vscatterqps">Stores up to 16 elements (or 8 elements) in doubleword/quadword vector zmm1 to the memory locations pointed
by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB
(i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corre-
sponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an excep-
tion.
This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register (k1) are partially updated. If any traps or interrupts are pending from already scat-
tered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction
breakpoint is not re-triggered when the instruction is continued.
Note that:
.     Only writes to overlapping vector indices are guaranteed to be ordered with respect to each other (from LSB to
      MSB of the source registers). Note that this also include partially overlapping vector indices. Writes that are not
      overlapped may happen in any order. Memory ordering with other instructions follows the Intel-64 memory
      ordering model. Note that this does not account for non-overlapping indices that map into the same physical
      address locations.</hint>
<hint page="0" header="Scatter Packed Single, Packed" doc_id="x86_64" token="vscatterqpd">Stores up to 16 elements (or 8 elements) in doubleword/quadword vector zmm1 to the memory locations pointed
by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB
(i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corre-
sponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an excep-
tion.
This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception
is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination
register and the mask register (k1) are partially updated. If any traps or interrupts are pending from already scat-
tered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction
breakpoint is not re-triggered when the instruction is continued.
Note that:
.     Only writes to overlapping vector indices are guaranteed to be ordered with respect to each other (from LSB to
      MSB of the source registers). Note that this also include partially overlapping vector indices. Writes that are not
      overlapped may happen in any order. Memory ordering with other instructions follows the Intel-64 memory
      ordering model. Note that this does not account for non-overlapping indices that map into the same physical
      address locations.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vscatterpf0dps">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
cache lines will be brought into exclusive state (RFO) specified by a locality hint (T0):
. T0 (temporal data)-prefetch data into the first level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vscatterpf0qps">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
cache lines will be brought into exclusive state (RFO) specified by a locality hint (T0):
. T0 (temporal data)-prefetch data into the first level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vscatterpf0dpd">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
cache lines will be brought into exclusive state (RFO) specified by a locality hint (T0):
. T0 (temporal data)-prefetch data into the first level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vscatterpf0qpd">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
cache lines will be brought into exclusive state (RFO) specified by a locality hint (T0):
. T0 (temporal data)-prefetch data into the first level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vscatterpf1dps">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
cache lines will be brought into exclusive state (RFO) specified by a locality hint (T1):
. T1 (temporal data)-prefetch data into the second level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vscatterpf1qps">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
cache lines will be brought into exclusive state (RFO) specified by a locality hint (T1):
. T1 (temporal data)-prefetch data into the second level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vscatterpf1dpd">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
cache lines will be brought into exclusive state (RFO) specified by a locality hint (T1):
. T1 (temporal data)-prefetch data into the second level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Sparse Prefetch" doc_id="x86_64" token="vscatterpf1qpd">The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The
elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only
be prefetched if their corresponding mask bit is one.
cache lines will be brought into exclusive state (RFO) specified by a locality hint (T1):
. T1 (temporal data)-prefetch data into the second level cache.
[PS data] For dword indices, the instruction will prefetch sixteen memory locations. For qword indices, the instruc-
tion will prefetch eight values.
[PD data] For dword and qword indices, the instruction will prefetch eight memory locations.
Note that:
(1) The prefetches may happen in any order (or not at all). The instruction is a hint.
(2) The mask is left unchanged.
(3) Not valid with 16-bit effective addresses. Will deliver a #UD fault.
(4) No FP nor memory faults may be produced by this instruction.
(5) Prefetches do not handle cache line splits
(6) A #UD is signaled if the memory operand is encoded without the SIB byte.</hint>
<hint page="0" header="Shuffle Packed Values at 128-bit" doc_id="x86_64" token="vshuff32x4">256-bit Version: Moves one of the two 128-bit packed single-precision floating-point values from the first source
operand (second operand) into the low 128-bit of the destination operand (first operand); moves one of the two
packed 128-bit floating-point values from the second source operand (third operand) into the high 128-bit of the
destination operand. The selector operand (third operand) determines which values are moved to the destination
operand.
512-bit Version: Moves two of the four 128-bit packed single-precision floating-point values from the first source
operand (second operand) into the low 256-bit of each double qword of the destination operand (first operand);
moves two of the four packed 128-bit floating-point values from the second source operand (third operand) into
the high 256-bit of the destination operand. The selector operand (third operand) determines which values are
moved to the destination operand.
The first source operand is a vector register. The second source operand can be a ZMM register, a 512-bit memory
location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a vector
register.
The writemask updates the destination operand with the granularity of 32/64-bit data elements.</hint>
<hint page="0" header="Shuffle Packed Values at 128-bit" doc_id="x86_64" token="vshuff64x2">256-bit Version: Moves one of the two 128-bit packed single-precision floating-point values from the first source
operand (second operand) into the low 128-bit of the destination operand (first operand); moves one of the two
packed 128-bit floating-point values from the second source operand (third operand) into the high 128-bit of the
destination operand. The selector operand (third operand) determines which values are moved to the destination
operand.
512-bit Version: Moves two of the four 128-bit packed single-precision floating-point values from the first source
operand (second operand) into the low 256-bit of each double qword of the destination operand (first operand);
moves two of the four packed 128-bit floating-point values from the second source operand (third operand) into
the high 256-bit of the destination operand. The selector operand (third operand) determines which values are
moved to the destination operand.
The first source operand is a vector register. The second source operand can be a ZMM register, a 512-bit memory
location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a vector
register.
The writemask updates the destination operand with the granularity of 32/64-bit data elements.</hint>
<hint page="0" header="Shuffle Packed Values at 128-bit" doc_id="x86_64" token="vshufi32x4">256-bit Version: Moves one of the two 128-bit packed single-precision floating-point values from the first source
operand (second operand) into the low 128-bit of the destination operand (first operand); moves one of the two
packed 128-bit floating-point values from the second source operand (third operand) into the high 128-bit of the
destination operand. The selector operand (third operand) determines which values are moved to the destination
operand.
512-bit Version: Moves two of the four 128-bit packed single-precision floating-point values from the first source
operand (second operand) into the low 256-bit of each double qword of the destination operand (first operand);
moves two of the four packed 128-bit floating-point values from the second source operand (third operand) into
the high 256-bit of the destination operand. The selector operand (third operand) determines which values are
moved to the destination operand.
The first source operand is a vector register. The second source operand can be a ZMM register, a 512-bit memory
location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a vector
register.
The writemask updates the destination operand with the granularity of 32/64-bit data elements.</hint>
<hint page="0" header="Shuffle Packed Values at 128-bit" doc_id="x86_64" token="vshufi64x2">256-bit Version: Moves one of the two 128-bit packed single-precision floating-point values from the first source
operand (second operand) into the low 128-bit of the destination operand (first operand); moves one of the two
packed 128-bit floating-point values from the second source operand (third operand) into the high 128-bit of the
destination operand. The selector operand (third operand) determines which values are moved to the destination
operand.
512-bit Version: Moves two of the four 128-bit packed single-precision floating-point values from the first source
operand (second operand) into the low 256-bit of each double qword of the destination operand (first operand);
moves two of the four packed 128-bit floating-point values from the second source operand (third operand) into
the high 256-bit of the destination operand. The selector operand (third operand) determines which values are
moved to the destination operand.
The first source operand is a vector register. The second source operand can be a ZMM register, a 512-bit memory
location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a vector
register.
The writemask updates the destination operand with the granularity of 32/64-bit data elements.</hint>
<hint page="0" header="Packed Bit Test" doc_id="x86_64" token="vtestpd">VTESTPS performs a bitwise comparison of all the sign bits of the packed single-precision elements in the first
source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with
the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND of the source sign bits with the
inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with
VEX.W=1 will cause #UD.
VTESTPD performs a bitwise comparison of all the sign bits of the double-precision elements in the first source
operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest
sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND the source sign bits with the inverted dest
sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will
cause #UD.
The first source register is specified by the ModR/M reg field.
128-bit version: The first source register is an XMM register. The second source register can be an XMM register or
a 128-bit memory location. The destination register is not modified.
VEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM
register or a 256-bit memory location. The destination register is not modified.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Packed Bit Test" doc_id="x86_64" token="vtestps">VTESTPS performs a bitwise comparison of all the sign bits of the packed single-precision elements in the first
source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with
the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND of the source sign bits with the
inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with
VEX.W=1 will cause #UD.
VTESTPD performs a bitwise comparison of all the sign bits of the double-precision elements in the first source
operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest
sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND the source sign bits with the inverted dest
sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will
cause #UD.
The first source register is specified by the ModR/M reg field.
128-bit version: The first source register is an XMM register. The second source register can be an XMM register or
a 128-bit memory location. The destination register is not modified.
VEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM
register or a 256-bit memory location. The destination register is not modified.
Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</hint>
<hint page="0" header="Zero All YMM Registers" doc_id="x86_64" token="vzeroall">The instruction zeros contents of all XMM or YMM registers.
Note: VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD. In Compatibility and legacy 32-
bit mode only the lower 8 registers are modified.</hint>
<hint page="0" header="Zero Upper Bits of YMM Registers" doc_id="x86_64" token="vzeroupper">The instruction zeros the bits in position 128 and higher of all YMM registers. The lower 128-bits of the registers
(the corresponding XMM registers) are unmodified.
This instruction is recommended when transitioning between AVX and legacy SSE code - it will eliminate perfor-
mance penalties caused by false dependencies.
Note: VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD. In Compatibility and legacy 32-bit
mode only the lower 8 registers are modified.</hint>
<hint page="0" header="Wait" doc_id="x86_64" token="wait">Causes the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding.
(FWAIT is an alternate mnemonic for WAIT.)
This instruction is useful for synchronizing exceptions in critical sections of code. Coding a WAIT instruction after a
floating-point instruction ensures that any unmasked floating-point exceptions the instruction may raise are
handled before the processor can modify the instruction's results. See the section titled "Floating-Point Exception
Synchronization" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1,
for more information on using the WAIT/FWAIT instruction.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Wait" doc_id="x86_64" token="fwait">Causes the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding.
(FWAIT is an alternate mnemonic for WAIT.)
This instruction is useful for synchronizing exceptions in critical sections of code. Coding a WAIT instruction after a
floating-point instruction ensures that any unmasked floating-point exceptions the instruction may raise are
handled before the processor can modify the instruction's results. See the section titled "Floating-Point Exception
Synchronization" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1,
for more information on using the WAIT/FWAIT instruction.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Write Back and Invalidate Cache" doc_id="x86_64" token="wbinvd">Writes back all modified cache lines in the processor's internal cache to main memory and invalidates (flushes) the
internal caches. The instruction then issues a special-function bus cycle that directs external caches to also write
back modified data and another bus cycle to indicate that the external caches should be invalidated.
After executing this instruction, the processor does not wait for the external caches to complete their write-back
and flushing operations before proceeding with instruction execution. It is the responsibility of hardware to respond
to the cache write-back and flush signals. The amount of time or cycles for WBINVD to complete will vary due to
size and other factors of different cache hierarchies. As a consequence, the use of the WBINVD instruction can have
an impact on logical processor interrupt/event response time. Additional information of WBINVD behavior in a
cache hierarchy with hierarchical sharing topology can be found in Chapter 2 of the Intel 64 and IA-32 Architec-
tures Software Developer's Manual, Volume 3A.
The WBINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a
program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction (see
"Serializing Instructions" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Developer's Manual,
Volume 3A).
In situations where cache coherency with main memory is not a concern, software can use the INVD instruction.
This instruction's operation is the same in non-64-bit modes and 64-bit mode.</hint>
<hint page="0" header="Write FS/GS Segment Base" doc_id="x86_64" token="wrfsbase">Loads the FS or GS segment base address with the general-purpose register indicated by the modR/M:r/m field.
The source operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the
operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source
register are ignored and upper 32 bits of the base address (for FS or GS) are cleared.
This instruction is supported only in 64-bit mode.</hint>
<hint page="0" header="Write FS/GS Segment Base" doc_id="x86_64" token="wrgsbase">Loads the FS or GS segment base address with the general-purpose register indicated by the modR/M:r/m field.
The source operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the
operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source
register are ignored and upper 32 bits of the base address (for FS or GS) are cleared.
This instruction is supported only in 64-bit mode.</hint>
<hint page="0" header="Write to Model Specific Register" doc_id="x86_64" token="wrmsr">Writes the contents of registers EDX:EAX into the 64-bit model specific register (MSR) specified in the ECX register.
(On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The contents of
the EDX register are copied to high-order 32 bits of the selected MSR and the contents of the EAX register are
copied to low-order 32 bits of the MSR. (On processors that support the Intel 64 architecture, the high-order 32
bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an MSR should be set to values previously
read.
This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection
exception #GP(0) is generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a
general protection exception. The processor will also generate a general protection exception if software attempts
to write to bits in a reserved MSR.
When the WRMSR instruction is used to write to an MTRR, the TLBs are invalidated. This includes global entries (see
"Translation Lookaside Buffers (TLBs)" in Chapter 3 of the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 3A).
MSRs control functions for testability, execution tracing, performance-monitoring and machine check errors.
Chapter 35, "Model-Specific Registers (MSRs)", in the Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 3C, lists all MSRs that can be written with this instruction and their addresses. Note that each
processor family has its own set of MSRs.
The WRMSR instruction is a serializing instruction (see "Serializing Instructions" in Chapter 8 of the Intel 64 and
IA-32 Architectures Software Developer's Manual, Volume 3A). Note that WRMSR to the IA32_TSC_DEADLINE
MSR (MSR index 6E0H) and the X2APIC MSRs (MSR indices 802H to 83FH) are not serializing.
The CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before
using this instruction.</hint>
<hint page="0" header="Write Data to User Page Key Register" doc_id="x86_64" token="wrpkru">Writes the value of EAX into PKRU. ECX and EDX must be 0 when WRPKRU is executed; otherwise, a general-
protection exception (#GP) occurs.
WRPKRU can be executed only if CR4.PKE = 1; otherwise, an invalid-opcode exception (#UD) occurs. Software can
discover the value of CR4.PKE by examining CPUID.(EAX=07H,ECX=0H):ECX.OSPKE [bit 4].
On processors that support the Intel 64 Architecture, the high-order 32-bits of RCX, RDX and RAX are ignored.</hint>
<hint page="0" header="Hardware Lock Elision Prefix Hints" doc_id="x86_64" token="xacquire">The XACQUIRE prefix is a hint to start lock elision on the memory address specified by the instruction and the
XRELEASE prefix is a hint to end lock elision on the memory address specified by the instruction.
The XACQUIRE prefix hint can only be used with the following instructions (these instructions are also referred to
as XACQUIRE-enabled when used with the XACQUIRE prefix):
.     Instructions with an explicit LOCK prefix (F0H) prepended to forms of the instruction where the destination
      operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCHG8B, DEC, INC, NEG, NOT,
      OR, SBB, SUB, XOR, XADD, and XCHG.
.     The XCHG instruction either with or without the presence of the LOCK prefix.
The XRELEASE prefix hint can only be used with the following instructions (also referred to as XRELEASE-enabled
when used with the XRELEASE prefix):
.     Instructions with an explicit LOCK prefix (F0H) prepended to forms of the instruction where the destination
      operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCHG8B, DEC, INC, NEG, NOT,
      OR, SBB, SUB, XOR, XADD, and XCHG.
.     The XCHG instruction either with or without the presence of the LOCK prefix.
.     The "MOV mem, reg" (Opcode 88H/89H) and "MOV mem, imm" (Opcode C6H/C7H) instructions. In these
      cases, the XRELEASE is recognized without the presence of the LOCK prefix.
The lock variables must satisfy the guidelines described in Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 1, Section 16.3.3, for elision to be successful, otherwise an HLE abort may be signaled.
If an encoded byte sequence that meets XACQUIRE/XRELEASE requirements includes both prefixes, then the HLE
semantic is determined by the prefix byte that is placed closest to the instruction opcode. For example, an F3F2C6
will not be treated as a XRELEASE-enabled instruction since the F2H (XACQUIRE) is closest to the instruction
opcode C6. Similarly, an F2F3F0 prefixed instruction will be treated as a XRELEASE-enabled instruction since F3H
(XRELEASE) is closest to the instruction opcode.</hint>
<hint page="0" header="Hardware Lock Elision Prefix Hints" doc_id="x86_64" token="xrelease">The XACQUIRE prefix is a hint to start lock elision on the memory address specified by the instruction and the
XRELEASE prefix is a hint to end lock elision on the memory address specified by the instruction.
The XACQUIRE prefix hint can only be used with the following instructions (these instructions are also referred to
as XACQUIRE-enabled when used with the XACQUIRE prefix):
.     Instructions with an explicit LOCK prefix (F0H) prepended to forms of the instruction where the destination
      operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCHG8B, DEC, INC, NEG, NOT,
      OR, SBB, SUB, XOR, XADD, and XCHG.
.     The XCHG instruction either with or without the presence of the LOCK prefix.
The XRELEASE prefix hint can only be used with the following instructions (also referred to as XRELEASE-enabled
when used with the XRELEASE prefix):
.     Instructions with an explicit LOCK prefix (F0H) prepended to forms of the instruction where the destination
      operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCHG8B, DEC, INC, NEG, NOT,
      OR, SBB, SUB, XOR, XADD, and XCHG.
.     The XCHG instruction either with or without the presence of the LOCK prefix.
.     The "MOV mem, reg" (Opcode 88H/89H) and "MOV mem, imm" (Opcode C6H/C7H) instructions. In these
      cases, the XRELEASE is recognized without the presence of the LOCK prefix.
The lock variables must satisfy the guidelines described in Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 1, Section 16.3.3, for elision to be successful, otherwise an HLE abort may be signaled.
If an encoded byte sequence that meets XACQUIRE/XRELEASE requirements includes both prefixes, then the HLE
semantic is determined by the prefix byte that is placed closest to the instruction opcode. For example, an F3F2C6
will not be treated as a XRELEASE-enabled instruction since the F2H (XACQUIRE) is closest to the instruction
opcode C6. Similarly, an F2F3F0 prefixed instruction will be treated as a XRELEASE-enabled instruction since F3H
(XRELEASE) is closest to the instruction opcode.</hint>
<hint page="0" header="Transactional Abort" doc_id="x86_64" token="xabort">XABORT forces an RTM abort. Following an RTM abort, the logical processor resumes execution at the fallback
address computed through the outermost XBEGIN instruction. The EAX register is updated to reflect an XABORT
instruction caused the abort, and the imm8 argument will be provided in bits 31:24 of EAX.</hint>
<hint page="0" header="Exchange and Add" doc_id="x86_64" token="xadd">Exchanges the first operand (destination operand) with the second operand (source operand), then loads the sum
of the two values into the destination operand. The destination operand can be a register or a memory location; the
source operand is a register.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
the summary chart at the beginning of this section for encoding data and limits.
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</hint>
<hint page="0" header="Transactional Begin" doc_id="x86_64" token="xbegin">The XBEGIN instruction specifies the start of an RTM code region. If the logical processor was not already in trans-
actional execution, then the XBEGIN instruction causes the logical processor to transition into transactional execu-
tion. The XBEGIN instruction that transitions the logical processor into transactional execution is referred to as the
outermost XBEGIN instruction. The instruction also specifies a relative offset to compute the address of the fallback
code path following a transactional abort.
On an RTM abort, the logical processor discards all architectural register and memory updates performed during
the RTM execution and restores architectural state to that corresponding to the outermost XBEGIN instruction. The
fallback address following an abort is computed from the outermost XBEGIN instruction.</hint>
<hint page="0" header="Exchange Register/Memory with Register" doc_id="x86_64" token="xchg">Exchanges the contents of the destination (first) and source (second) operands. The operands can be two general-
purpose registers or a register and a memory location. If a memory operand is referenced, the processor's locking
protocol is automatically implemented for the duration of the exchange operation, regardless of the presence or
absence of the LOCK prefix or of the value of the IOPL. (See the LOCK prefix description in this chapter for more
information on the locking protocol.)
This instruction is useful for implementing semaphores or similar data structures for process synchronization. (See
"Bus Locking" in Chapter 8 of the Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, for
more information on bus locking.)
The XCHG instruction can also be used instead of the BSWAP instruction for 16-bit operands.
In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.R permits
access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See
the summary chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Transactional End" doc_id="x86_64" token="xend">The instruction marks the end of an RTM code region. If this corresponds to the outermost scope (that is, including
this XEND instruction, the number of XBEGIN instructions is the same as number of XEND instructions), the logical
processor will attempt to commit the logical processor state atomically. If the commit fails, the logical processor will
rollback all architectural register and memory updates performed during the RTM execution. The logical processor
will resume execution at the fallback address computed from the outermost XBEGIN instruction. The EAX register
is updated to reflect RTM abort information.
XEND executed outside a transactional region will cause a #GP (General Protection Fault).</hint>
<hint page="0" header="Get Value of Extended Control Register" doc_id="x86_64" token="xgetbv">Reads the contents of the extended control register (XCR) specified in the ECX register into registers EDX:EAX. (On
processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is
loaded with the high-order 32 bits of the XCR and the EAX register is loaded with the low-order 32 bits. (On proces-
sors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer
than 64 bits are implemented in the XCR being read, the values returned to EDX:EAX in unimplemented bit loca-
tions are undefined.
XCR0 is supported on any processor that supports the XGETBV instruction. If
CPUID.(EAX=0DH,ECX=1):EAX.XG1[bit 2] = 1, executing XGETBV with ECX = 1 returns in EDX:EAX the logical-
AND of XCR0 and the current value of the XINUSE state-component bitmap. This allows software to discover the
state of the init optimization used by XSAVEOPT and XSAVES. See Chapter 13, "Managing State Using the XSAVE
Feature Set," in Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1.
Use of any other value for ECX results in a general-protection (#GP) exception.</hint>
<hint page="0" header="Table Look-up Translation" doc_id="x86_64" token="xlat">Locates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the
contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer.
The XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX
registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The DS segment may
be overridden with a segment override prefix.)
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operand" form and the "no-
operand" form. The explicit-operand form (specified with the XLAT mnemonic) allows the base address of the table
to be specified explicitly with a symbol. This explicit-operands form is provided to allow documentation; however,
note that the documentation provided by this form can be misleading. That is, the symbol does not have to specify
the correct base address. The base address is always specified by the DS:(E)BX registers, which must be loaded
correctly before the XLAT instruction is executed.
The no-operands form (XLATB) provides a "short form" of the XLAT instructions. Here also the processor assumes
that the DS:(E)BX registers contain the base address of the table.
In 64-bit mode, operation is similar to that in legacy or compatibility mode. AL is used to specify the table index
(the operand size is fixed at 8 bits). RBX, however, is used to specify the table's base address. See the summary
chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Table Look-up Translation" doc_id="x86_64" token="xlatb">Locates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the
contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer.
The XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX
registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The DS segment may
be overridden with a segment override prefix.)
At the assembly-code level, two forms of this instruction are allowed: the "explicit-operand" form and the "no-
operand" form. The explicit-operand form (specified with the XLAT mnemonic) allows the base address of the table
to be specified explicitly with a symbol. This explicit-operands form is provided to allow documentation; however,
note that the documentation provided by this form can be misleading. That is, the symbol does not have to specify
the correct base address. The base address is always specified by the DS:(E)BX registers, which must be loaded
correctly before the XLAT instruction is executed.
The no-operands form (XLATB) provides a "short form" of the XLAT instructions. Here also the processor assumes
that the DS:(E)BX registers contain the base address of the table.
In 64-bit mode, operation is similar to that in legacy or compatibility mode. AL is used to specify the table index
(the operand size is fixed at 8 bits). RBX, however, is used to specify the table's base address. See the summary
chart at the beginning of this section for encoding data and limits.</hint>
<hint page="0" header="Logical Exclusive OR" doc_id="x86_64" token="xor">Performs a bitwise exclusive OR (XOR) operation on the destination (first) and source (second) operands and
stores the result in the destination operand location. The source operand can be an immediate, a register, or a
memory location; the destination operand can be a register or a memory location. (However, two memory oper-
ands cannot be used in one instruction.) Each bit of the result is 1 if the corresponding bits of the operands are
different; each bit is 0 if the corresponding bits are the same.
This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</hint>
<hint page="0" header="Bitwise Logical XOR of Packed Double Precision Floating-Point Values" doc_id="x86_64" token="xorpd">Performs a bitwise logical XOR of the two, four or eight packed double-precision floating-point values from the first
source operand and the second source operand, and stores the result in the destination operand
EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand can be a ZMM
register or a vector memory location. The destination operand is a ZMM register conditionally updated with
writemask k1.
VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand
is a YMM register or a 256-bit memory location. The destination operand is a YMM register (conditionally updated
with writemask k1 in case of EVEX). The upper bits (MAX_VL-1:256) of the corresponding ZMM register destination
are zeroed.
VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand
is an XMM register or 128-bit memory location. The destination operand is an XMM register (conditionally updated
with writemask k1 in case of EVEX). The upper bits (MAX_VL-1:128) of the corresponding ZMM register destination
are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
register destination are unmodified.</hint>
<hint page="0" header="Bitwise Logical XOR of Packed Single Precision Floating-Point Values" doc_id="x86_64" token="xorps">Performs a bitwise logical XOR of the four, eight or sixteen packed single-precision floating-point values from the
first source operand and the second source operand, and stores the result in the destination operand
EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand can be a ZMM
register or a vector memory location. The destination operand is a ZMM register conditionally updated with
writemask k1.
VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand
is a YMM register or a 256-bit memory location. The destination operand is a YMM register (conditionally updated
with writemask k1 in case of EVEX). The upper bits (MAX_VL-1:256) of the corresponding ZMM register destination
are zeroed.
VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand
is an XMM register or 128-bit memory location. The destination operand is an XMM register (conditionally updated
with writemask k1 in case of EVEX). The upper bits (MAX_VL-1:128) of the corresponding ZMM register destination
are zeroed.
128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The desti-
nation is not distinct from the first source XMM register and the upper bits (MAX_VL-1:128) of the corresponding
register destination are unmodified.</hint>
<hint page="0" header="Restore Processor Extended States" doc_id="x86_64" token="xrstor">Performs a full or partial restore of processor state components from the XSAVE area located at the memory
address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The
specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the
logical-AND of EDX:EAX and XCR0.
The format of the XSAVE area is detailed in Section 13.4, "XSAVE Area," of Intel 64 and IA-32 Architectures Soft-
ware Developer's Manual, Volume 1.
Section 13.8, "Operation of XRSTOR," of Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1 provides a detailed description of the operation of the XRSTOR instruction. The following items provide a high-
level outline:
.   Execution of XRSTOR may take one of two forms: standard and compacted. Bit 63 of the XCOMP_BV field in the
    XSAVE header determines which form is used: value 0 specifies the standard form, while value 1 specifies the
    compacted form.
.   If RFBM[i] = 0, XRSTOR does not update state component i.1
.   If RFBM[i] = 1 and bit i is clear in the XSTATE_BV field in the XSAVE header, XRSTOR initializes state
    component i.
.   If RFBM[i] = 1 and XSTATE_BV[i] = 1, XRSTOR loads state component i from the XSAVE area.
.   The standard form of XRSTOR treats MXCSR (which is part of state component 1 - SSE) differently from the
    XMM registers. If either form attempts to load MXCSR with an illegal value, a general-protection exception
    (#GP) occurs.
.   XRSTOR loads the internal value XRSTOR_INFO, which may be used to optimize a subsequent execution of
    XSAVEOPT or XSAVES.
.   Immediately following an execution of XRSTOR, the processor tracks as in-use (not in initial configuration) any
    state component i for which RFBM[i] = 1 and XSTATE_BV[i] = 1; it tracks as modified any state component
    i for which RFBM[i] = 0.
Use of a source operand not aligned to 64-byte boundary (for 64-bit and 32-bit modes) results in a general-protec-
tion (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</hint>
<hint page="0" header="Restore Processor Extended States Supervisor" doc_id="x86_64" token="xrstors">Performs a full or partial restore of processor state components from the XSAVE area located at the memory
address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The
specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the
logical-AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XRSTORS may be executed only if
CPL = 0.
The format of the XSAVE area is detailed in Section 13.4, "XSAVE Area," of Intel 64 and IA-32 Architectures Soft-
ware Developer's Manual, Volume 1.
Section 13.12, "Operation of XRSTORS," of Intel 64 and IA-32 Architectures Software Developer's Manual,
Volume 1 provides a detailed description of the operation of the XRSTOR instruction. The following items provide a
high-level outline:
.   Execution of XRSTORS is similar to that of the compacted form of XRSTOR; XRSTORS cannot restore from an
    XSAVE area in which the extended region is in the standard format (see Section 13.4.3, "Extended Region of an
    XSAVE Area").
.   XRSTORS differs from XRSTOR in that it can restore state components corresponding to bits set in the
    IA32_XSS MSR.
.   If RFBM[i] = 0, XRSTORS does not update state component i.
.   If RFBM[i] = 1 and bit i is clear in the XSTATE_BV field in the XSAVE header, XRSTORS initializes state
    component i.
.   If RFBM[i] = 1 and XSTATE_BV[i] = 1, XRSTORS loads state component i from the XSAVE area.
.   If XRSTORS attempts to load MXCSR with an illegal value, a general-protection exception (#GP) occurs.
.   XRSTORS loads the internal value XRSTOR_INFO, which may be used to optimize a subsequent execution of
    XSAVEOPT or XSAVES.
.   Immediately following an execution of XRSTORS, the processor tracks as in-use (not in initial configuration)
    any state component i for which RFBM[i] = 1 and XSTATE_BV[i] = 1; it tracks as modified any state component
    i for which RFBM[i] = 0.
Use of a source operand not aligned to 64-byte boundary (for 64-bit and 32-bit modes) results in a general-protec-
tion (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</hint>
<hint page="0" header="Save Processor Extended States" doc_id="x86_64" token="xsave">Performs a full or partial save of processor state components to the XSAVE area located at the memory address
specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The
specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the
logical-AND of EDX:EAX and XCR0.
The format of the XSAVE area is detailed in Section 13.4, "XSAVE Area," of Intel 64 and IA-32 Architectures Soft-
ware Developer's Manual, Volume 1.
Section 13.7, "Operation of XSAVE," of Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 1
provides a detailed description of the operation of the XSAVE instruction. The following items provide a high-level
outline:
.   XSAVE saves state component i if and only if RFBM[i] = 1.1
.   XSAVE does not modify bytes 511:464 of the legacy region of the XSAVE area (see Section 13.4.1, "Legacy
    Region of an XSAVE Area").
.   XSAVE reads the XSTATE_BV field of the XSAVE header (see Section 13.4.2, "XSAVE Header") and writes a
    modified value back to memory as follows. If RFBM[i] = 1, XSAVE writes XSTATE_BV[i] with the value of
    XINUSE[i]. (XINUSE is a bitmap by which the processor tracks the status of various state components. See
    Section 13.6, "Processor Tracking of XSAVE-Managed State.") If RFBM[i] = 0, XSAVE writes XSTATE_BV[i] with
    the value that it read from memory (it does not modify the bit). XSAVE does not write to any part of the XSAVE
    header other than the XSTATE_BV field.
.   XSAVE always uses the standard format of the extended region of the XSAVE area (see Section 13.4.3,
    "Extended Region of an XSAVE Area").
Use of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a
general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</hint>
<hint page="0" header="Save Processor Extended States with Compaction" doc_id="x86_64" token="xsavec">Performs a full or partial save of processor state components to the XSAVE area located at the memory address
specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The
specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the
logical-AND of EDX:EAX and XCR0.
The format of the XSAVE area is detailed in Section 13.4, "XSAVE Area," of Intel 64 and IA-32 Architectures Soft-
ware Developer's Manual, Volume 1.
Section 13.10, "Operation of XSAVEC," of Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1 provides a detailed description of the operation of the XSAVEC instruction. The following items provide a high-
level outline:
.   Execution of XSAVEC is similar to that of XSAVE. XSAVEC differs from XSAVE in that it uses compaction and that
    it may use the init optimization.
.   XSAVEC saves state component i if and only if RFBM[i] = 1 and XINUSE[i] = 1.1 (XINUSE is a bitmap by which
    the processor tracks the status of various state components. See Section 13.6, "Processor Tracking of XSAVE-
    Managed State.")
.   XSAVEC does not modify bytes 511:464 of the legacy region of the XSAVE area (see Section 13.4.1, "Legacy
    Region of an XSAVE Area").
.   XSAVEC writes the logical AND of RFBM and XINUSE to the XSTATE_BV field of the XSAVE header.2,3 (See
    Section 13.4.2, "XSAVE Header.") XSAVEC sets bit 63 of the XCOMP_BV field and sets bits 62:0 of that field to
    RFBM[62:0]. XSAVEC does not write to any parts of the XSAVE header other than the XSTATE_BV and
    XCOMP_BV fields.
.   XSAVEC always uses the compacted format of the extended region of the XSAVE area (see Section 13.4.3,
    "Extended Region of an XSAVE Area").
Use of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a
general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</hint>
<hint page="0" header="Save Processor Extended States Optimized" doc_id="x86_64" token="xsaveopt">Performs a full or partial save of processor state components to the XSAVE area located at the memory address
specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The
specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the
logical-AND of EDX:EAX and XCR0.
The format of the XSAVE area is detailed in Section 13.4, "XSAVE Area," of Intel 64 and IA-32 Architectures Soft-
ware Developer's Manual, Volume 1.
Section 13.9, "Operation of XSAVEOPT," of Intel 64 and IA-32 Architectures Software Developer's Manual,
Volume 1 provides a detailed description of the operation of the XSAVEOPT instruction. The following items provide
a high-level outline:
.   Execution of XSAVEOPT is similar to that of XSAVE. XSAVEOPT differs from XSAVE in that it uses compaction
    and that it may use the init and modified optimizations. The performance of XSAVEOPT will be equal to or better
    than that of XSAVE.
.   XSAVEOPT saves state component i only if RFBM[i] = 1 and XINUSE[i] = 1.1 (XINUSE is a bitmap by which the
    processor tracks the status of various state components. See Section 13.6, "Processor Tracking of XSAVE-
    Managed State.") Even if both bits are 1, XSAVEOPT may optimize and not save state component i if (1) state
    component i has not been modified since the last execution of XRTOR or XRSTORS; and (2) this execution of
    XSAVES corresponds to that last execution of XRTOR or XRSTORS as determined by the internal value
    XRSTOR_INFO (see the Operation section below).
.   XSAVEOPT does not modify bytes 511:464 of the legacy region of the XSAVE area (see Section 13.4.1, "Legacy
    Region of an XSAVE Area").
.   XSAVEOPT reads the XSTATE_BV field of the XSAVE header (see Section 13.4.2, "XSAVE Header") and writes a
    modified value back to memory as follows. If RFBM[i] = 1, XSAVEOPT writes XSTATE_BV[i] with the value of
    XINUSE[i]. If RFBM[i] = 0, XSAVEOPT writes XSTATE_BV[i] with the value that it read from memory (it does
    not modify the bit). XSAVEOPT does not write to any part of the XSAVE header other than the XSTATE_BV field.
.   XSAVEOPT always uses the standard format of the extended region of the XSAVE area (see Section 13.4.3,
    "Extended Region of an XSAVE Area").
Use of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) will result in a
general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</hint>
<hint page="0" header="Save Processor Extended States Supervisor" doc_id="x86_64" token="xsaves">Performs a full or partial save of processor state components to the XSAVE area located at the memory address
specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The
specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), the logical-
AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XSAVES may be executed only if CPL = 0.
The format of the XSAVE area is detailed in Section 13.4, "XSAVE Area," of Intel 64 and IA-32 Architectures Soft-
ware Developer's Manual, Volume 1.
Section 13.11, "Operation of XSAVES," of Intel 64 and IA-32 Architectures Software Developer's Manual, Volume
1 provides a detailed description of the operation of the XSAVES instruction. The following items provide a high-
level outline:
.   Execution of XSAVES is similar to that of XSAVEC. XSAVES differs from XSAVEC in that it can save state
    components corresponding to bits set in the IA32_XSS MSR and that it may use the modified optimization.
.   XSAVES saves state component i only if RFBM[i] = 1 and XINUSE[i] = 1.1 (XINUSE is a bitmap by which the
    processor tracks the status of various state components. See Section 13.6, "Processor Tracking of XSAVE-
    Managed State.") Even if both bits are 1, XSAVES may optimize and not save state component i if (1) state
    component i has not been modified since the last execution of XRTOR or XRSTORS; and (2) this execution of
    XSAVES correspond to that last execution of XRTOR or XRSTORS as determined by XRSTOR_INFO (see the
    Operation section below).
.   XSAVES does not modify bytes 511:464 of the legacy region of the XSAVE area (see Section 13.4.1, "Legacy
    Region of an XSAVE Area").
.   XSAVES writes the logical AND of RFBM and XINUSE to the XSTATE_BV field of the XSAVE header.2 (See Section
    13.4.2, "XSAVE Header.") XSAVES sets bit 63 of the XCOMP_BV field and sets bits 62:0 of that field to
    RFBM[62:0]. XSAVES does not write to any parts of the XSAVE header other than the XSTATE_BV and
    XCOMP_BV fields.
.   XSAVES always uses the compacted format of the extended region of the XSAVE area (see Section 13.4.3,
    "Extended Region of an XSAVE Area").
Use of a destination operand not aligned to 64-byte boundary (in either 64-bit or 32-bit modes) results in a
general-protection (#GP) exception. In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.</hint>
<hint page="0" header="Set Extended Control Register" doc_id="x86_64" token="xsetbv">Writes the contents of registers EDX:EAX into the 64-bit extended control register (XCR) specified in the ECX
register. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The
contents of the EDX register are copied to high-order 32 bits of the selected XCR and the contents of the EAX
register are copied to low-order 32 bits of the XCR. (On processors that support the Intel 64 architecture, the high-
order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an XCR should be set to values
previously read.
This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection
exception #GP(0) is generated. Specifying a reserved or unimplemented XCR in ECX will also cause a general
protection exception. The processor will also generate a general protection exception if software attempts to write
to reserved bits in an XCR.
Currently, only XCR0 is supported. Thus, all other values of ECX are reserved and will cause a #GP(0). Note that
bit 0 of XCR0 (corresponding to x87 state) must be set to 1; the instruction will cause a #GP(0) if an attempt is
made to clear this bit. In addition, the instruction causes a #GP(0) if an attempt is made to set XCR0[2] (AVX state)
while clearing XCR0[1] (SSE state); it is necessary to set both bits to use AVX instructions; Section 13.3, "Enabling
the XSAVE Feature Set and XSAVE-Enabled Features," of Intel 64 and IA-32 Architectures Software Developer's
Manual, Volume 1.</hint>
<hint page="0" header="Test If In Transactional Execution" doc_id="x86_64" token="xtest">The XTEST instruction queries the transactional execution status. If the instruction executes inside a transaction-
ally executing RTM region or a transactionally executing HLE region, then the ZF flag is cleared, else it is set.</hint>

		</group>
	</elements>
</documentation>

```

`FRIEND/AArch32Extender.cpp`:

```cpp
//
//  AArch32Extender.cpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 12/09/2017.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#include <ida.hpp>
#include <idp.hpp>
#include <allins.hpp>
#include <regex>

#if IDA_SDK_VERSION >= 700
	#include <segregs.hpp>
#else
	#include <srarea.hpp>
#endif

#include "AArch32Extender.hpp"
#include "IDAAPI.hpp"

#ifdef __EA64__
	#define PRINTF_ADDR	"%llX"
#else
	#define PRINTF_ADDR	"%X"
#endif

#define BAIL_IF(cond, ...)		\
	do							\
	{							\
		if ((cond))				\
		{						\
			msg(__VA_ARGS__);	\
			goto bail;			\
		}						\
	}							\
	while (0)

const uint32_t kRegT = 20;

constexpr uint32_t MakeOpHash(uint32_t coproc, uint32_t opc1, uint32_t CRn, uint32_t CRm, uint32_t opc2 = 0)
{
	return ((coproc << 16) | (opc1 << 12) | (CRn << 8) | (CRm << 4) | (opc2 << 0));
}

// created using https://github.com/gdelugre/ida-arm-system-highlight and DDI0406C_C_armv7ar_arm.pdf
// { MakeOpHash(coproc, opc1, CRn, CRm, opc2),   "MNEMONIC" },      // Description
std::map<uint32_t, const char*> AArch32Extender::s_operandMap = {
	{ MakeOpHash(15, 0, 0, 0, 0),   "MIDR"          },      // Main ID Register
	{ MakeOpHash(15, 0, 0, 0, 1),   "CTR"           },      // Cache Type Register
	{ MakeOpHash(15, 0, 0, 0, 2),   "TCMTR"         },      // TCM Type Register
	{ MakeOpHash(15, 0, 0, 0, 3),   "TLBTR"         },      // TLB Type Register
	{ MakeOpHash(15, 0, 0, 0, 4),   "MIDR"          },      // alias to MIDR
	{ MakeOpHash(15, 0, 0, 0, 5),   "MPIDR"         },      // Multiprocessor Affinity Register
	{ MakeOpHash(15, 0, 0, 0, 6),   "REVIDR"        },      // Revision ID Register
	{ MakeOpHash(15, 0, 0, 0, 7),   "MIDR"          },      // alias to MIDR
	{ MakeOpHash(15, 0, 0, 1, 0),   "ID_PFR0"       },      // Processor Feature Register 0
	{ MakeOpHash(15, 0, 0, 1, 1),   "ID_PFR1"       },      // Processor Feature Register 1
	{ MakeOpHash(15, 0, 0, 1, 2),   "ID_DFR0"       },      // Debug Feature Register 0
	{ MakeOpHash(15, 0, 0, 1, 3),   "ID_AFR0"       },      // Auxiliary Feature Register 0
	{ MakeOpHash(15, 0, 0, 1, 4),   "ID_MMFR0"      },      // Memory Model Feature Register 0
	{ MakeOpHash(15, 0, 0, 1, 5),   "ID_MMFR1"      },      // Memory Model Feature Register 1
	{ MakeOpHash(15, 0, 0, 1, 6),   "ID_MMFR2"      },      // Memory Model Feature Register 2
	{ MakeOpHash(15, 0, 0, 1, 7),   "ID_MMFR3"      },      // Memory Model Feature Register 3
	{ MakeOpHash(15, 0, 0, 2, 6),   "ID_MMFR4"      },      // Memory Model Feature Register 4 (AArch32)
	{ MakeOpHash(15, 0, 0, 2, 0),   "ID_ISAR0"      },      // Instruction Set Attribute Register 0
	{ MakeOpHash(15, 0, 0, 2, 1),   "ID_ISAR1"      },      // Instruction Set Attribute Register 1
	{ MakeOpHash(15, 0, 0, 2, 2),   "ID_ISAR2"      },      // Instruction Set Attribute Register 2
	{ MakeOpHash(15, 0, 0, 2, 3),   "ID_ISAR3"      },      // Instruction Set Attribute Register 3
	{ MakeOpHash(15, 0, 0, 2, 4),   "ID_ISAR4"      },      // Instruction Set Attribute Register 4
	{ MakeOpHash(15, 0, 0, 2, 5),   "ID_ISAR5"      },      // Instruction Set Attribute Register 5
	{ MakeOpHash(15, 0, 0, 2, 7),   "ID_ISAR6"      },      // Instruction Set Attribute Register 6 (AArch32)
	{ MakeOpHash(15, 1, 0, 0, 0),   "CCSIDR"        },      // Current Cache Size ID Register
	{ MakeOpHash(15, 1, 0, 0, 2),   "CCSIDR2"       },      // Current Cache Size ID Register 2 (AArch32)
	{ MakeOpHash(15, 1, 0, 0, 1),   "CLIDR"         },      // Cache Level ID Register
	{ MakeOpHash(15, 1, 0, 0, 7),   "AIDR"          },      // Auxiliary ID Register
	{ MakeOpHash(15, 2, 0, 0, 0),   "CSSELR"        },      // Cache Size Selection Register
	{ MakeOpHash(15, 4, 0, 0, 0),   "VPIDR"         },      // Virtualization Processor ID Register
	{ MakeOpHash(15, 4, 0, 0, 5),   "VMPIDR"        },      // Virtualization Multiprocessor ID Register
	{ MakeOpHash(15, 0, 1, 0, 0),   "SCTLR"         },      // System Control Register
	{ MakeOpHash(15, 0, 1, 0, 1),   "ACTLR"         },      // Auxiliary Control Register
	{ MakeOpHash(15, 0, 1, 0, 3),   "ACTLR2"        },      // Auxiliary Control Register 2 (AArch32)
	{ MakeOpHash(15, 0, 1, 0, 2),   "CPACR"         },      // Architectural Feature Access Control Register
	{ MakeOpHash(15, 0, 1, 1, 0),   "SCR"           },      // Secure Configuration Register
	{ MakeOpHash(15, 0, 1, 1, 1),   "SDER"          },      // Secure Debug Enable Register
	{ MakeOpHash(15, 0, 1, 3, 1),   "SDCR"          },      // Secure Debug Control Register (AArch32)
	{ MakeOpHash(15, 0, 1, 1, 2),   "NSACR"         },      // Non-Secure Access Control Register
	{ MakeOpHash(15, 4, 1, 0, 0),   "HSCTLR"        },      // Hyp System Control Register
	{ MakeOpHash(15, 4, 1, 0, 1),   "HACTLR"        },      // Hyp Auxiliary Control Register
	{ MakeOpHash(15, 4, 1, 0, 3),   "HACTLR2"       },      // Hyp Auxiliary Control Register 2 (AArch32)
	{ MakeOpHash(15, 4, 1, 1, 0),   "HCR"           },      // Hyp Configuration Register
	{ MakeOpHash(15, 4, 1, 1, 4),   "HCR2"          },      // Hyp Configuration Register 2 (AArch32)
	{ MakeOpHash(15, 4, 1, 1, 1),   "HDCR"          },      // Hyp Debug Control Register
	{ MakeOpHash(15, 4, 1, 1, 2),   "HCPTR"         },      // Hyp Architectural Feature Trap Register
	{ MakeOpHash(15, 4, 1, 1, 3),   "HSTR"          },      // Hyp System Trap Register
	{ MakeOpHash(15, 4, 1, 1, 7),   "HACR"          },      // Hyp Auxiliary Configuration Register
	{ MakeOpHash(15, 0, 2, 0, 0),   "TTBR0"         },      // Translation Table Base Register 0
	{ MakeOpHash(15, 0, 2, 0, 1),   "TTBR1"         },      // Translation Table Base Register 1
	{ MakeOpHash(15, 0, 2, 0, 2),   "TTBCR"         },      // Translation Table Base Control Register
	{ MakeOpHash(15, 0, 2, 0, 3),   "TTBCR2"        },      // Translation Table Base Control Register 2 (AArch32)
	{ MakeOpHash(15, 4, 2, 0, 2),   "HTCR"          },      // Hyp Translation Control Register
	{ MakeOpHash(15, 4, 2, 1, 2),   "VTCR"          },      // Virtualization Translation Control Register
	{ MakeOpHash(15, 0, 3, 0, 0),   "DACR"          },      // Domain Access Control Register
	{ MakeOpHash(15, 0, 5, 0, 0),   "DFSR"          },      // Data Fault Status Register
	{ MakeOpHash(15, 0, 5, 0, 1),   "IFSR"          },      // Instruction Fault Status Register
	{ MakeOpHash(15, 0, 5, 1, 0),   "ADFSR"         },      // Auxiliary Data Fault Status Register
	{ MakeOpHash(15, 0, 5, 1, 1),   "AIFSR"         },      // Auxiliary Instruction Fault Status Register
	{ MakeOpHash(15, 4, 5, 1, 0),   "HADFSR"        },      // Hyp Auxiliary Data Fault Status Register
	{ MakeOpHash(15, 4, 5, 1, 1),   "HAIFSR"        },      // Hyp Auxiliary Instruction Fault Status Register
	{ MakeOpHash(15, 4, 5, 2, 0),   "HSR"           },      // Hyp Syndrome Register
	{ MakeOpHash(15, 0, 6, 0, 2),   "IFAR"          },      // Instruction Fault Address Register
	{ MakeOpHash(15, 4, 6, 0, 0),   "HDFAR"         },      // Hyp Data Fault Address Register
	{ MakeOpHash(15, 4, 6, 0, 2),   "HIFAR"         },      // Hyp Instruction Fault Address Register
	{ MakeOpHash(15, 4, 6, 0, 4),   "HPFAR"         },      // Hyp IPA Fault Address Register

	{ MakeOpHash(15, 0, 6, 0, 0),   "DFAR__NA_ProtBaseSizeDRegion0" }, // Data Fault Address Register / Base and Size Data Protection Region 0
	{ MakeOpHash(15, 0, 6, 1, 0),   "NA_ProtBaseSizeDRegion1" }, // Base and Size Data Protection Region 1
	{ MakeOpHash(15, 0, 6, 2, 0),   "NA_ProtBaseSizeDRegion2" }, // Base and Size Data Protection Region 2
	{ MakeOpHash(15, 0, 6, 3, 0),   "NA_ProtBaseSizeDRegion3" }, // Base and Size Data Protection Region 3
	{ MakeOpHash(15, 0, 6, 4, 0),   "NA_ProtBaseSizeDRegion4" }, // Base and Size Data Protection Region 4
	{ MakeOpHash(15, 0, 6, 5, 0),   "NA_ProtBaseSizeDRegion5" }, // Base and Size Data Protection Region 5
	{ MakeOpHash(15, 0, 6, 6, 0),   "NA_ProtBaseSizeDRegion6" }, // Base and Size Data Protection Region 6
	{ MakeOpHash(15, 0, 6, 7, 0),   "NA_ProtBaseSizeDRegion7" }, // Base and Size Data Protection Region 7
	{ MakeOpHash(15, 0, 6, 8, 0),   "NA_ProtBaseSizeDRegion8" }, // Base and Size Data Protection Region 8
	{ MakeOpHash(15, 0, 6, 9, 0),   "NA_ProtBaseSizeDRegion9" }, // Base and Size Data Protection Region 9
	{ MakeOpHash(15, 0, 6, 10, 0),   "NA_ProtBaseSizeDRegion10" }, // Base and Size Data Protection Region 10
	{ MakeOpHash(15, 0, 6, 11, 0),   "NA_ProtBaseSizeDRegion11" }, // Base and Size Data Protection Region 11
	{ MakeOpHash(15, 0, 6, 12, 0),   "NA_ProtBaseSizeDRegion12" }, // Base and Size Data Protection Region 12
	{ MakeOpHash(15, 0, 6, 13, 0),   "NA_ProtBaseSizeDRegion13" }, // Base and Size Data Protection Region 13
	{ MakeOpHash(15, 0, 6, 14, 0),   "NA_ProtBaseSizeDRegion14" }, // Base and Size Data Protection Region 14
	{ MakeOpHash(15, 0, 6, 15, 0),   "NA_ProtBaseSizeDRegion15" }, // Base and Size Data Protection Region 15
	
	{ MakeOpHash(15, 0, 6, 0, 1),   "WFAR__NA_ProtBaseSizeIRegion0" }, // Watchpoint Fault Address (AArch32) / Base and Size Instruction Protection Region 0
	{ MakeOpHash(15, 0, 6, 1, 1),   "NA_ProtBaseSizeIRegion1" }, // Base and Size Instruction Protection Region 1
	{ MakeOpHash(15, 0, 6, 2, 1),   "NA_ProtBaseSizeIRegion2" }, // Base and Size Instruction Protection Region 2
	{ MakeOpHash(15, 0, 6, 3, 1),   "NA_ProtBaseSizeIRegion3" }, // Base and Size Instruction Protection Region 3
	{ MakeOpHash(15, 0, 6, 4, 1),   "NA_ProtBaseSizeIRegion4" }, // Base and Size Instruction Protection Region 4
	{ MakeOpHash(15, 0, 6, 5, 1),   "NA_ProtBaseSizeIRegion5" }, // Base and Size Instruction Protection Region 5
	{ MakeOpHash(15, 0, 6, 6, 1),   "NA_ProtBaseSizeIRegion6" }, // Base and Size Instruction Protection Region 6
	{ MakeOpHash(15, 0, 6, 7, 1),   "NA_ProtBaseSizeIRegion7" }, // Base and Size Instruction Protection Region 7
	{ MakeOpHash(15, 0, 6, 8, 1),   "NA_ProtBaseSizeIRegion8" }, // Base and Size Instruction Protection Region 8
	{ MakeOpHash(15, 0, 6, 9, 1),   "NA_ProtBaseSizeIRegion9" }, // Base and Size Instruction Protection Region 9
	{ MakeOpHash(15, 0, 6, 10, 1),   "NA_ProtBaseSizeIRegion10" }, // Base and Size Instruction Protection Region 10
	{ MakeOpHash(15, 0, 6, 11, 1),   "NA_ProtBaseSizeIRegion11" }, // Base and Size Instruction Protection Region 11
	{ MakeOpHash(15, 0, 6, 12, 1),   "NA_ProtBaseSizeIRegion12" }, // Base and Size Instruction Protection Region 12
	{ MakeOpHash(15, 0, 6, 13, 1),   "NA_ProtBaseSizeIRegion13" }, // Base and Size Instruction Protection Region 13
	{ MakeOpHash(15, 0, 6, 14, 1),   "NA_ProtBaseSizeIRegion14" }, // Base and Size Instruction Protection Region 14
	{ MakeOpHash(15, 0, 6, 15, 1),   "NA_ProtBaseSizeIRegion15" }, // Base and Size Instruction Protection Region 15
	
	{ MakeOpHash(15, 0, 6, 1, 2),   "NA_RegSizeEnable" },   // Region Size and Enable Register
	{ MakeOpHash(15, 0, 6, 1, 4),   "NA_RegAccessControl" }, // Region Access Control Register

	// Cache Maintenance Registers
	{ MakeOpHash(15, 0, 7, 0, 4),   "NOP"           },      // No Operation / Wait For Interrupt / Unpredictable
	{ MakeOpHash(15, 0, 7, 1, 0),   "ICIALLUIS"     },      // Instruction Cache Invalidate All to PoU, Inner Shareable
	{ MakeOpHash(15, 0, 7, 1, 6),   "BPIALLIS"      },      // Branch Predictor Invalidate All, Inner Shareable
	{ MakeOpHash(15, 0, 7, 4, 0),   "PAR"           },      // Physical Address Register
	{ MakeOpHash(15, 0, 7, 5, 0),   "ICIALLU"       },      // Instruction Cache Invalidate All to PoU
	{ MakeOpHash(15, 0, 7, 5, 1),   "ICIMVAU"       },      // Instruction Cache line Invalidate by VA to PoU
	{ MakeOpHash(15, 0, 7, 5, 2),   "NA_InvAllICacheSetWay" }, // Invalidate all instruction caches by set/way *
	{ MakeOpHash(15, 0, 7, 5, 4),   "CP15ISB"       },      // Instruction Synchronization Barrier System instruction
	{ MakeOpHash(15, 0, 7, 5, 6),   "BPIALL"        },      // Branch Predictor Invalidate All
	{ MakeOpHash(15, 0, 7, 5, 7),   "BPIMVA"        },      // Branch Predictor Invalidate by VA
	{ MakeOpHash(15, 0, 7, 6, 0),   "NA_InvAllDCache" }, 	// Invalidate entire data cache *
	{ MakeOpHash(15, 0, 7, 6, 1),   "DCIMVAC"       },      // Data Cache line Invalidate by VA to PoC
	{ MakeOpHash(15, 0, 7, 6, 2),   "DCISW"         },      // Data Cache line Invalidate by Set/Way
	{ MakeOpHash(15, 0, 7, 7, 0),   "NA_InvInDCache" }, 	// Invalidate instruction cache and data cache" *
	{ MakeOpHash(15, 0, 7, 8, 0),   "ATS1CPR"       },      // Address Translate Stage 1 Current state PL1 Read
	{ MakeOpHash(15, 0, 7, 8, 1),   "ATS1CPW"       },      // Address Translate Stage 1 Current state PL1 Write
	{ MakeOpHash(15, 0, 7, 8, 2),   "ATS1CUR"       },      // Address Translate Stage 1 Current state Unprivileged Read
	{ MakeOpHash(15, 0, 7, 8, 3),   "ATS1CUW"       },      // Address Translate Stage 1 Current state Unprivileged Write
	{ MakeOpHash(15, 0, 7, 8, 4),   "ATS12NSOPR"    },      // Address Translate Stages 1 and 2 Non-secure Only PL1 Read
	{ MakeOpHash(15, 0, 7, 8, 5),   "ATS12NSOPW"    },      // Address Translate Stages 1 and 2 Non-secure Only PL1 Write
	{ MakeOpHash(15, 0, 7, 8, 6),   "ATS12NSOUR"    },      // Address Translate Stages 1 and 2 Non-secure Only Unprivileged Read
	{ MakeOpHash(15, 0, 7, 8, 7),   "ATS12NSOUW"    },      // Address Translate Stages 1 and 2 Non-secure Only Unprivileged Write
	{ MakeOpHash(15, 0, 7, 9, 0),   "ATS1CPRP"      },      // Address Translate Stage 1 Current state PL1 Read PAN (AArch32)
	{ MakeOpHash(15, 0, 7, 9, 1),   "ATS1CPWP"      },      // Address Translate Stage 1 Current state PL1 Write PAN (AArch32)
	{ MakeOpHash(15, 0, 7, 10, 0),  "NA_CleanDCache" },  	// Clean entire data cache
	{ MakeOpHash(15, 0, 7, 10, 1),  "DCCMVAC"       },      // Data Cache line Clean by VA to PoC
	{ MakeOpHash(15, 0, 7, 10, 2),  "DCCSW"         },      // Data Cache line Clean by Set/Way
	{ MakeOpHash(15, 0, 7, 10, 3),  "NA_TestCleanDCache" }, // Test and clean data cache
	{ MakeOpHash(15, 0, 7, 10, 4),  "CP15DSB"       },      // Data Synchronization Barrier System instruction
	{ MakeOpHash(15, 0, 7, 10, 5),  "CP15DMB"       },      // Data Memory Barrier System instruction
	{ MakeOpHash(15, 0, 7, 10, 6),  "NA_ReadCacheDirtyStatReg" }, // Read Cache Dirty Status Register
	{ MakeOpHash(15, 0, 7, 11, 1),  "DCCMVAU"       },      // Data Cache line Clean by VA to PoU
	{ MakeOpHash(15, 0, 7, 12, 4),  "NA_ReadBlockTransStatRer" }, // Read Block Transfer Status Register
	{ MakeOpHash(15, 0, 7, 12, 5),  "NA_StopPrefetchRange" }, // Stop Prefetch Range
	{ MakeOpHash(15, 0, 7, 13, 1),  "NOP"           },      // No Operation / Prefetch Instruction Cache Line
	{ MakeOpHash(15, 0, 7, 14, 0),  "NA_CleanInvAllDCache" }, // Clean and invalidate entire data cache
	{ MakeOpHash(15, 0, 7, 14, 1),  "DCCIMVAC"      },      // Data Cache line Clean and Invalidate by VA to PoC
	{ MakeOpHash(15, 0, 7, 14, 2),  "DCCISW"        },      // Data Cache line Clean and Invalidate by Set/Way
	{ MakeOpHash(15, 0, 7, 14, 3),  "NA_TestCleanInvDCache" }, // Test, clean, and invalidate data cache
	{ MakeOpHash(15, 4, 7, 8, 0),   "ATS1HR"        },      // Address Translate Stage 1 Hyp mode Read
	{ MakeOpHash(15, 4, 7, 8, 1),   "ATS1HW"        },      // Stage 1 Hyp mode write
	
	// TLB maintenance operations
	{ MakeOpHash(15, 0, 8, 3, 0),   "TLBIALLIS"     },      // TLB Invalidate All, Inner Shareable
	{ MakeOpHash(15, 0, 8, 3, 1),   "TLBIMVAIS"     },      // TLB Invalidate by VA, Inner Shareable
	{ MakeOpHash(15, 0, 8, 3, 2),   "TLBIASIDIS"    },      // TLB Invalidate by ASID match, Inner Shareable
	{ MakeOpHash(15, 0, 8, 3, 3),   "TLBIMVAAIS"    },      // TLB Invalidate by VA, All ASID, Inner Shareable
	{ MakeOpHash(15, 0, 8, 3, 5),   "TLBIMVALIS"    },      // TLB Invalidate by VA, Last level, Inner Shareable (AArch32)
	{ MakeOpHash(15, 0, 8, 3, 7),   "TLBIMVAALIS"   },      // TLB Invalidate by VA, All ASID, Last level, Inner Shareable (AArch32)
	{ MakeOpHash(15, 0, 8, 5, 0),   "ITLBIALL"      },      // Instruction TLB Invalidate All
	{ MakeOpHash(15, 0, 8, 5, 1),   "ITLBIMVA"      },      // Instruction TLB Invalidate by VA
	{ MakeOpHash(15, 0, 8, 5, 2),   "ITLBIASID"     },      // Instruction TLB Invalidate by ASID match
	{ MakeOpHash(15, 0, 8, 6, 0),   "DTLBIALL"      },      // Data TLB Invalidate All
	{ MakeOpHash(15, 0, 8, 6, 1),   "DTLBIMVA"      },      // Data TLB Invalidate by VA
	{ MakeOpHash(15, 0, 8, 6, 2),   "DTLBIASID"     },      // Data TLB Invalidate by ASID match
	{ MakeOpHash(15, 0, 8, 7, 0),   "TLBIALL"       },      // TLB Invalidate All
	{ MakeOpHash(15, 0, 8, 7, 1),   "TLBIMVA"       },      // TLB Invalidate by VA
	{ MakeOpHash(15, 0, 8, 7, 2),   "TLBIASID"      },      // TLB Invalidate by ASID match
	{ MakeOpHash(15, 0, 8, 7, 3),   "TLBIMVAA"      },      // TLB Invalidate by VA, All ASID
	{ MakeOpHash(15, 0, 8, 7, 5),   "TLBIMVAL"      },      // TLB Invalidate by VA, Last level (AArch32)
	{ MakeOpHash(15, 0, 8, 7, 7),   "TLBIMVAAL"     },      // TLB Invalidate by VA, All ASID, Last level (AArch32)
	{ MakeOpHash(15, 4, 8, 0, 1),   "TLBIIPAS2IS"   },      // TLB Invalidate by Intermediate Physical Address, Stage 2, Inner Shareable (AArch32)
	{ MakeOpHash(15, 4, 8, 0, 5),   "TLBIIPAS2LIS"  },      // TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, Inner Shareable (AArch32)
	{ MakeOpHash(15, 4, 8, 3, 0),   "TLBIALLHIS"    },      // TLB Invalidate All, Hyp mode, Inner Shareable
	{ MakeOpHash(15, 4, 8, 3, 1),   "TLBIMVAHIS"    },      // TLB Invalidate by VA, Hyp mode, Inner Shareable
	{ MakeOpHash(15, 4, 8, 3, 4),   "TLBIALLNSNHIS" },      // TLB Invalidate All, Non-Secure Non-Hyp, Inner Shareable
	{ MakeOpHash(15, 4, 8, 3, 5),   "TLBIMVALHIS"   },      // TLB Invalidate by VA, Last level, Hyp mode, Inner Shareable (AArch32)
	{ MakeOpHash(15, 4, 8, 4, 1),   "TLBIIPAS2"     },      // TLB Invalidate by Intermediate Physical Address, Stage 2 (AArch32)
	{ MakeOpHash(15, 4, 8, 4, 5),   "TLBIIPAS2L"    },      // TLB Invalidate by Intermediate Physical Address, Stage 2, Last level (AArch32)
	{ MakeOpHash(15, 4, 8, 7, 0),   "TLBIALLH"      },      // TLB Invalidate All, Hyp mode
	{ MakeOpHash(15, 4, 8, 7, 1),   "TLBIMVAH"      },      // TLB Invalidate by VA, Hyp mode
	{ MakeOpHash(15, 4, 8, 7, 4),   "TLBIALLNSNH"   },      // TLB Invalidate All, Non-Secure Non-Hyp
	{ MakeOpHash(15, 4, 8, 7, 5),   "TLBIMVALH"     },      // TLB Invalidate by VA, Last level, Hyp mode (AArch32)
	
	{ MakeOpHash(15, 0, 9, 0, 0),   "NA_DCacheLock" },      // Data Cache Lockdown
	{ MakeOpHash(15, 0, 9, 0, 1),   "NA_ICacheLock" },      // Instruction Cache Lockdown
	{ MakeOpHash(15, 0, 9, 1, 0),   "NA_DTCMRegion" },   	// Data TCM Region
	{ MakeOpHash(15, 0, 9, 1, 1),   "NA_ITCMRegion" },      // Instruction TCM Region
	{ MakeOpHash(15, 1, 9, 0, 2),   "L2CTLR"        },      // L2 Control Register (AArch32)
	{ MakeOpHash(15, 1, 9, 0, 3),   "L2ECTLR"       },      // L2 Extended Control Register (AArch32)
	
	// Performance Monitor Registers
	{ MakeOpHash(15, 0, 9, 12, 0),  "PMCR"          },      // Performance Monitors Control Register
	{ MakeOpHash(15, 0, 9, 12, 1),  "PMCNTENSET"    },      // Performance Monitor Count Enable Set Register
	{ MakeOpHash(15, 0, 9, 12, 2),  "PMCNTENCLR"    },      // Performance Monitor Control Enable Clear Register
	{ MakeOpHash(15, 0, 9, 12, 3),  "PMOVSR"        },      // Performance Monitors Overflow Flag Status Register
	{ MakeOpHash(15, 0, 9, 12, 4),  "PMSWINC"       },      // Performance Monitors Software Increment register
	{ MakeOpHash(15, 0, 9, 12, 5),  "PMSELR"        },      // Performance Monitors Event Counter Selection Register
	{ MakeOpHash(15, 0, 9, 12, 6),  "PMCEID0"       },      // Performance Monitors Common Event Identification register 0
	{ MakeOpHash(15, 0, 9, 12, 7),  "PMCEID1"       },      // Performance Monitors Common Event Identification register 1
	{ MakeOpHash(15, 0, 9, 13, 0),  "PMCCNTR"       },      // Performance Monitors Cycle Count Register
	{ MakeOpHash(15, 0, 9, 13, 1),  "PMXEVTYPER"    },      // Performance Monitors Selected Event Type Register
	{ MakeOpHash(15, 0, 9, 13, 2),  "PMXEVCNTR"     },      // Performance Monitors Selected Event Count Register
	{ MakeOpHash(15, 0, 9, 14, 0),  "PMUSERENR"     },      // Performance Monitors User Enable Register
	{ MakeOpHash(15, 0, 9, 14, 1),  "PMINTENSET"    },      // Performance Monitors Interrupt Enable Set register
	{ MakeOpHash(15, 0, 9, 14, 2),  "PMINTENCLR"    },      // Performance Monitors Interrupt Enable Clear register
	{ MakeOpHash(15, 0, 9, 14, 3),  "PMOVSSET"      },      // Performance Monitors Overflow Flag Status Set register
	
	{ MakeOpHash(15, 0, 9, 14, 4),  "PMCEID2"       },      // Performance Monitors Common Event Identification register 2 (AArch32)
	{ MakeOpHash(15, 0, 9, 14, 5),  "PMCEID3"       },      // Performance Monitors Common Event Identification register 3 (AArch32)
	{ MakeOpHash(15, 0, 14, 8, 0),  "PMEVCNTR0"     },      // Performance Monitors Event Count Register 0 (AArch32)
	{ MakeOpHash(15, 0, 14, 8, 1),  "PMEVCNTR1"     },      // Performance Monitors Event Count Register 1 (AArch32)
	{ MakeOpHash(15, 0, 14, 8, 2),  "PMEVCNTR2"     },      // Performance Monitors Event Count Register 2 (AArch32)
	{ MakeOpHash(15, 0, 14, 8, 3),  "PMEVCNTR3"     },      // Performance Monitors Event Count Register 3 (AArch32)
	{ MakeOpHash(15, 0, 14, 8, 4),  "PMEVCNTR4"     },      // Performance Monitors Event Count Register 4 (AArch32)
	{ MakeOpHash(15, 0, 14, 8, 5),  "PMEVCNTR5"     },      // Performance Monitors Event Count Register 5 (AArch32)
	{ MakeOpHash(15, 0, 14, 8, 6),  "PMEVCNTR6"     },      // Performance Monitors Event Count Register 6 (AArch32)
	{ MakeOpHash(15, 0, 14, 8, 7),  "PMEVCNTR7"     },      // Performance Monitors Event Count Register 7 (AArch32)
	{ MakeOpHash(15, 0, 14, 9, 0),  "PMEVCNTR8"     },      // Performance Monitors Event Count Register 8 (AArch32)
	{ MakeOpHash(15, 0, 14, 9, 1),  "PMEVCNTR9"     },      // Performance Monitors Event Count Register 9 (AArch32)
	{ MakeOpHash(15, 0, 14, 9, 2),  "PMEVCNTR10"    },      // Performance Monitors Event Count Register 10 (AArch32)
	{ MakeOpHash(15, 0, 14, 9, 3),  "PMEVCNTR11"    },      // Performance Monitors Event Count Register 11 (AArch32)
	{ MakeOpHash(15, 0, 14, 9, 4),  "PMEVCNTR12"    },      // Performance Monitors Event Count Register 12 (AArch32)
	{ MakeOpHash(15, 0, 14, 9, 5),  "PMEVCNTR13"    },      // Performance Monitors Event Count Register 13 (AArch32)
	{ MakeOpHash(15, 0, 14, 9, 6),  "PMEVCNTR14"    },      // Performance Monitors Event Count Register 14 (AArch32)
	{ MakeOpHash(15, 0, 14, 9, 7),  "PMEVCNTR15"    },      // Performance Monitors Event Count Register 15 (AArch32)
	{ MakeOpHash(15, 0, 14, 10, 0), "PMEVCNTR16"    },      // Performance Monitors Event Count Register 16 (AArch32)
	{ MakeOpHash(15, 0, 14, 10, 1), "PMEVCNTR17"    },      // Performance Monitors Event Count Register 17 (AArch32)
	{ MakeOpHash(15, 0, 14, 10, 2), "PMEVCNTR18"    },      // Performance Monitors Event Count Register 18 (AArch32)
	{ MakeOpHash(15, 0, 14, 10, 3), "PMEVCNTR19"    },      // Performance Monitors Event Count Register 19 (AArch32)
	{ MakeOpHash(15, 0, 14, 10, 4), "PMEVCNTR20"    },      // Performance Monitors Event Count Register 20 (AArch32)
	{ MakeOpHash(15, 0, 14, 10, 5), "PMEVCNTR21"    },      // Performance Monitors Event Count Register 21 (AArch32)
	{ MakeOpHash(15, 0, 14, 10, 6), "PMEVCNTR22"    },      // Performance Monitors Event Count Register 22 (AArch32)
	{ MakeOpHash(15, 0, 14, 10, 7), "PMEVCNTR23"    },      // Performance Monitors Event Count Register 23 (AArch32)
	{ MakeOpHash(15, 0, 14, 11, 0), "PMEVCNTR24"    },      // Performance Monitors Event Count Register 24 (AArch32)
	{ MakeOpHash(15, 0, 14, 11, 1), "PMEVCNTR25"    },      // Performance Monitors Event Count Register 25 (AArch32)
	{ MakeOpHash(15, 0, 14, 11, 2), "PMEVCNTR26"    },      // Performance Monitors Event Count Register 26 (AArch32)
	{ MakeOpHash(15, 0, 14, 11, 3), "PMEVCNTR27"    },      // Performance Monitors Event Count Register 27 (AArch32)
	{ MakeOpHash(15, 0, 14, 11, 4), "PMEVCNTR28"    },      // Performance Monitors Event Count Register 28 (AArch32)
	{ MakeOpHash(15, 0, 14, 11, 5), "PMEVCNTR29"    },      // Performance Monitors Event Count Register 29 (AArch32)
	{ MakeOpHash(15, 0, 14, 11, 6), "PMEVCNTR30"    },      // Performance Monitors Event Count Register 30 (AArch32)
	{ MakeOpHash(15, 0, 14, 12, 0), "PMEVTYPER0"    },      // Performance Monitors Event Type Register 0 (AArch32)
	{ MakeOpHash(15, 0, 14, 12, 1), "PMEVTYPER1"    },      // Performance Monitors Event Type Register 1 (AArch32)
	{ MakeOpHash(15, 0, 14, 12, 2), "PMEVTYPER2"    },      // Performance Monitors Event Type Register 2 (AArch32)
	{ MakeOpHash(15, 0, 14, 12, 3), "PMEVTYPER3"    },      // Performance Monitors Event Type Register 3 (AArch32)
	{ MakeOpHash(15, 0, 14, 12, 4), "PMEVTYPER4"    },      // Performance Monitors Event Type Register 4 (AArch32)
	{ MakeOpHash(15, 0, 14, 12, 5), "PMEVTYPER5"    },      // Performance Monitors Event Type Register 5 (AArch32)
	{ MakeOpHash(15, 0, 14, 12, 6), "PMEVTYPER6"    },      // Performance Monitors Event Type Register 6 (AArch32)
	{ MakeOpHash(15, 0, 14, 12, 7), "PMEVTYPER7"    },      // Performance Monitors Event Type Register 7 (AArch32)
	{ MakeOpHash(15, 0, 14, 13, 0), "PMEVTYPER8"    },      // Performance Monitors Event Type Register 8 (AArch32)
	{ MakeOpHash(15, 0, 14, 13, 1), "PMEVTYPER9"    },      // Performance Monitors Event Type Register 9 (AArch32)
	{ MakeOpHash(15, 0, 14, 13, 2), "PMEVTYPER10"   },      // Performance Monitors Event Type Register 10 (AArch32)
	{ MakeOpHash(15, 0, 14, 13, 3), "PMEVTYPER11"   },      // Performance Monitors Event Type Register 11 (AArch32)
	{ MakeOpHash(15, 0, 14, 13, 4), "PMEVTYPER12"   },      // Performance Monitors Event Type Register 12 (AArch32)
	{ MakeOpHash(15, 0, 14, 13, 5), "PMEVTYPER13"   },      // Performance Monitors Event Type Register 13 (AArch32)
	{ MakeOpHash(15, 0, 14, 13, 6), "PMEVTYPER14"   },      // Performance Monitors Event Type Register 14 (AArch32)
	{ MakeOpHash(15, 0, 14, 13, 7), "PMEVTYPER15"   },      // Performance Monitors Event Type Register 15 (AArch32)
	{ MakeOpHash(15, 0, 14, 14, 0), "PMEVTYPER16"   },      // Performance Monitors Event Type Register 16 (AArch32)
	{ MakeOpHash(15, 0, 14, 14, 1), "PMEVTYPER17"   },      // Performance Monitors Event Type Register 17 (AArch32)
	{ MakeOpHash(15, 0, 14, 14, 2), "PMEVTYPER18"   },      // Performance Monitors Event Type Register 18 (AArch32)
	{ MakeOpHash(15, 0, 14, 14, 3), "PMEVTYPER19"   },      // Performance Monitors Event Type Register 19 (AArch32)
	{ MakeOpHash(15, 0, 14, 14, 4), "PMEVTYPER20"   },      // Performance Monitors Event Type Register 20 (AArch32)
	{ MakeOpHash(15, 0, 14, 14, 5), "PMEVTYPER21"   },      // Performance Monitors Event Type Register 21 (AArch32)
	{ MakeOpHash(15, 0, 14, 14, 6), "PMEVTYPER22"   },      // Performance Monitors Event Type Register 22 (AArch32)
	{ MakeOpHash(15, 0, 14, 14, 7), "PMEVTYPER23"   },      // Performance Monitors Event Type Register 23 (AArch32)
	{ MakeOpHash(15, 0, 14, 15, 0), "PMEVTYPER24"   },      // Performance Monitors Event Type Register 24 (AArch32)
	{ MakeOpHash(15, 0, 14, 15, 1), "PMEVTYPER25"   },      // Performance Monitors Event Type Register 25 (AArch32)
	{ MakeOpHash(15, 0, 14, 15, 2), "PMEVTYPER26"   },      // Performance Monitors Event Type Register 26 (AArch32)
	{ MakeOpHash(15, 0, 14, 15, 3), "PMEVTYPER27"   },      // Performance Monitors Event Type Register 27 (AArch32)
	{ MakeOpHash(15, 0, 14, 15, 4), "PMEVTYPER28"   },      // Performance Monitors Event Type Register 28 (AArch32)
	{ MakeOpHash(15, 0, 14, 15, 5), "PMEVTYPER29"   },      // Performance Monitors Event Type Register 29 (AArch32)
	{ MakeOpHash(15, 0, 14, 15, 6), "PMEVTYPER30"   },      // Performance Monitors Event Type Register 30 (AArch32)
	{ MakeOpHash(15, 0, 14, 15, 7), "PMCCFILTR"     },      // Performance Monitors Cycle Count Filter Register (AArch32)
	
	// Memory Attribute Registers
	{ MakeOpHash(15, 0, 10, 0, 0),  "NA_TLBLock"    },      // TLB Lockdown
	{ MakeOpHash(15, 0, 10, 2, 0),  "MAIR0"         },      // Memory Attribute Indirection Register 0 / PRRR - Primary Region Remap Register
	{ MakeOpHash(15, 0, 10, 2, 1),  "MAIR1"         },      // Memory Attribute Indirection Register 1 / NMRR - Normal Memory Remap Register
	{ MakeOpHash(15, 0, 10, 3, 0),  "AMAIR0"        },      // Auxiliary Memory Attribute Indirection Register 0
	{ MakeOpHash(15, 0, 10, 3, 1),  "AMAIR1"        },      // Auxiliary Memory Attribute Indirection Register 1
	{ MakeOpHash(15, 4, 10, 2, 0),  "HMAIR0"        },      // Hyp Memory Attribute Indirection Register 0
	{ MakeOpHash(15, 4, 10, 2, 1),  "HMAIR1"        },      // Hyp Memory Attribute Indirection Register 1
	{ MakeOpHash(15, 4, 10, 3, 0),  "HAMAIR0"       },      // Hyp Auxiliary Memory Attribute Indirection Register 0
	{ MakeOpHash(15, 4, 10, 3, 1),  "HAMAIR1"       },      // Hyp Auxiliary Memory Attribute Indirection Register 1
	
	// DMA Registers (ARM11)
	{ MakeOpHash(15, 0, 11, 0, 0),  "NA_DMAIdStatPresent" }, // DMA Identification and Status (Present)
	{ MakeOpHash(15, 0, 11, 0, 1),  "NA_DMAIdStatQueued" }, // DMA Identification and Status (Queued)
	{ MakeOpHash(15, 0, 11, 0, 2),  "NA_DMAIdStatRunning" }, // DMA Identification and Status (Running)
	{ MakeOpHash(15, 0, 11, 0, 3),  "NA_DMAIdStatInt" },   // DMA Identification and Status (Interrupting)
	{ MakeOpHash(15, 0, 11, 1, 0),  "NA_DMAUserAccess" },  // DMA User Accessibility
	{ MakeOpHash(15, 0, 11, 2, 0),  "NA_DMAChNum"  },      // DMA Channel Number)
	{ MakeOpHash(15, 0, 11, 3, 0),  "NA_DMAEnableStop" },  // DMA Enable (Stop)
	{ MakeOpHash(15, 0, 11, 3, 1),  "NA_DMAEnableStart" }, // DMA Enable (Start)
	{ MakeOpHash(15, 0, 11, 3, 2),  "NA_DMAEnableClean" }, // DMA Enable (Clear)
	{ MakeOpHash(15, 0, 11, 4, 0),  "NA_DMAControl" },     // DMA Control
	{ MakeOpHash(15, 0, 11, 5, 0),  "NA_DMAIntStartAddr" }, // DMA Internal Start Address
	{ MakeOpHash(15, 0, 11, 6, 0),  "NA_DMAExtStartAddr" }, // DMA External Start Address
	{ MakeOpHash(15, 0, 11, 7, 0),  "NA_DMAIntEndAddr" },   // DMA Internal End Address
	{ MakeOpHash(15, 0, 11, 8, 0),  "NA_DMAChStatus" },     // DMA Channel Status
	{ MakeOpHash(15, 0, 11, 15, 0), "NA_DMAContextID" },    // DMA Context ID
	
	// Reset Management Registers.
	{ MakeOpHash(15, 0, 12, 0, 0),  "VBAR"          },      // Vector Base Address Register
	{ MakeOpHash(15, 0, 12, 0, 1),  "RVBAR"         },      // Reset Vector Base Address Register (RVBAR) / Monitor Vector Base Address Register (MVBAR)
	{ MakeOpHash(15, 0, 12, 0, 2),  "RMR"           },      // Reset Management Register (AArch32)
	{ MakeOpHash(15, 4, 12, 0, 2),  "HRMR"          },      // Hyp Reset Management Register (AArch32)
	
	{ MakeOpHash(15, 0, 12, 1, 0),  "ISR"           },      // Interrupt Status Register
	{ MakeOpHash(15, 4, 12, 0, 0),  "HVBAR"         },      // Hyp Vector Base Address Register
	
	{ MakeOpHash(15, 0, 13, 0, 0),  "FCSEIDR"       },      // FCSE Process ID register
	{ MakeOpHash(15, 0, 13, 0, 1),  "CONTEXTIDR"    },      // Context ID Register
	{ MakeOpHash(15, 0, 13, 0, 2),  "TPIDRURW"      },      // PL0 Read/Write Software Thread ID Register
	{ MakeOpHash(15, 0, 13, 0, 3),  "TPIDRURO"      },      // PL0 Read-Only Software Thread ID Register
	{ MakeOpHash(15, 0, 13, 0, 4),  "TPIDRPRW"      },      // PL1 Software Thread ID Register
	{ MakeOpHash(15, 4, 13, 0, 2),  "HTPIDR"        },      // Hyp Software Thread ID Register
	
	// Generic Timer Registers.
	{ MakeOpHash(15, 0, 14, 0, 0),  "CNTFRQ"        },      // Counter-timer Frequency register
	{ MakeOpHash(15, 0, 14, 1, 0),  "CNTKCTL"       },      // Counter-timer Kernel Control register
	{ MakeOpHash(15, 0, 14, 2, 0),  "CNTP_TVAL"     },      // Counter-timer Physical Timer TimerValue (CNTP_TVAL) / Counter-timer Hyp Physical Timer TimerValue register (CNTHP_TVAL)
	{ MakeOpHash(15, 0, 14, 2, 1),  "CNTP_CTL"      },      // Counter-timer Physical Timer Control (CNTP_CTL) / Counter-timer Hyp Physical Timer Control register (CNTHP_CTL)
	{ MakeOpHash(15, 0, 14, 3, 0),  "CNTV_TVAL"     },      // Counter-timer Virtual Timer TimerValue (CNTV_TVAL) / Counter-timer Virtual Timer TimerValue register (EL2) (CNTHV_TVAL)
	{ MakeOpHash(15, 0, 14, 3, 1),  "CNTV_CTL"      },      // Counter-timer Virtual Timer Control (CNTV_CTL) / Counter-timer Virtual Timer Control register (EL2) (CNTHV_CTL)
	{ MakeOpHash(15, 4, 14, 1, 0),  "CNTHCTL"       },      // Counter-timer Hyp Control register
	{ MakeOpHash(15, 4, 14, 2, 0),  "CNTHP_TVAL"    },      // Counter-timer Hyp Physical Timer TimerValue register
	{ MakeOpHash(15, 4, 14, 2, 1),  "CNTHP_CTL"     },      // Counter-timer Hyp Physical Timer Control register
	
	// Generic Interrupt Controller Registers (AArch32)
	{ MakeOpHash(15, 0, 4, 6, 0),   "ICC_PMR"       },      // Interrupt Controller Interrupt Priority Mask (ICC_PMR) / Interrupt Controller Virtual Interrupt Priority Mask Register (ICV_PMR)
	{ MakeOpHash(15, 0, 12, 8, 0),  "ICC_IAR0"      },      // Interrupt Controller Interrupt Acknowledge Register (ICC_IAR0) / Interrupt Controller Virtual Interrupt Acknowledge Register 0 (ICV_IAR0)
	{ MakeOpHash(15, 0, 12, 8, 1),  "ICC_EOIR0"     },      // Interrupt Controller End Of Interrupt Register (ICC_EOIR0) / Interrupt Controller Virtual End Of Interrupt Register 0 (ICV_EOIR0)
	{ MakeOpHash(15, 0, 12, 8, 2),  "ICC_HPPIR0"    },      // Interrupt Controller Highest Priority Pending Interrupt Register (ICC_HPPIR0) / Interrupt Controller Virtual Highest Priority Pending Interrupt Register 0 (ICV_HPPIR0)
	{ MakeOpHash(15, 0, 12, 8, 3),  "ICC_BPR0"      },      // Interrupt Controller Binary Point Register (ICC_BPR0) / Interrupt Controller Virtual Binary Point Register 0 (ICV_BPR0)
	{ MakeOpHash(15, 0, 12, 8, 4),  "ICC_AP0R0"     },      // Interrupt Controller Active Priorities Group 0 Register (ICC_AP0R0) / Interrupt Controller Virtual Active Priorities Group 0 Register 0 (ICV_AP0R0)
	{ MakeOpHash(15, 0, 12, 8, 5),  "ICC_AP0R1"     },      // Interrupt Controller Active Priorities Group 0 Register (ICC_AP0R1) / Interrupt Controller Virtual Active Priorities Group 0 Register 1 (ICV_AP0R1)
	{ MakeOpHash(15, 0, 12, 8, 6),  "ICC_AP0R2"     },      // Interrupt Controller Active Priorities Group 0 Register (ICC_AP0R2) / Interrupt Controller Virtual Active Priorities Group 0 Register 2 (ICV_AP0R2)
	{ MakeOpHash(15, 0, 12, 8, 7),  "ICC_AP0R3"     },      // Interrupt Controller Active Priorities Group 0 Register (ICC_AP0R3) / Interrupt Controller Virtual Active Priorities Group 0 Register 3 (ICV_AP0R3)
	{ MakeOpHash(15, 0, 12, 9, 0),  "ICC_AP1R0"     },      // Interrupt Controller Active Priorities Group 1 Register (ICC_AP1R0) / Interrupt Controller Virtual Active Priorities Group 1 Register 0 (ICV_AP1R0)
	{ MakeOpHash(15, 0, 12, 9, 1),  "ICC_AP1R1"     },      // Interrupt Controller Active Priorities Group 1 Register (ICC_AP1R1) / Interrupt Controller Virtual Active Priorities Group 1 Register 1 (ICV_AP1R1)
	{ MakeOpHash(15, 0, 12, 9, 2),  "ICC_AP1R2"     },      // Interrupt Controller Active Priorities Group 1 Register (ICC_AP1R2) / Interrupt Controller Virtual Active Priorities Group 1 Register 2 (ICV_AP1R2)
	{ MakeOpHash(15, 0, 12, 9, 3),  "ICC_AP1R3"     },      // Interrupt Controller Active Priorities Group 1 Register (ICC_AP1R3) / Interrupt Controller Virtual Active Priorities Group 1 Register 3 (ICV_AP1R3)
	{ MakeOpHash(15, 0, 12, 11, 1), "ICC_DIR"       },      // Interrupt Controller Deactivate Interrupt (ICC_DIR) / Interrupt Controller Deactivate Virtual Interrupt Register (ICV_DIR)
	{ MakeOpHash(15, 0, 12, 11, 3), "ICC_RPR"       },      // Interrupt Controller Running Priority (ICC_RPR) / Interrupt Controller Virtual Running Priority Register (ICV_RPR)
	{ MakeOpHash(15, 0, 12, 12, 0), "ICC_IAR1"      },      // Interrupt Controller Interrupt Acknowledge Register (ICC_IAR1) / Interrupt Controller Virtual Interrupt Acknowledge Register 1 (ICV_IAR1)
	{ MakeOpHash(15, 0, 12, 12, 1), "ICC_EOIR1"     },      // Interrupt Controller End Of Interrupt Register (ICC_EOIR1) / Interrupt Controller Virtual End Of Interrupt Register 1 (ICV_EOIR1)
	{ MakeOpHash(15, 0, 12, 12, 2), "ICC_HPPIR1"    },      // Interrupt Controller Highest Priority Pending Interrupt Register (ICC_HPPIR1) / Interrupt Controller Virtual Highest Priority Pending Interrupt Register 1 (ICV_HPPIR1)
	{ MakeOpHash(15, 0, 12, 12, 3), "ICC_BPR1"      },      // Interrupt Controller Binary Point Register (ICC_BPR1) / Interrupt Controller Virtual Binary Point Register 1 (ICV_BPR1)
	{ MakeOpHash(15, 0, 12, 12, 4), "ICC_CTLR"      },      // Interrupt Controller Control (ICC_CTLR) / Interrupt Controller Virtual Control Register (ICV_CTLR)
	{ MakeOpHash(15, 0, 12, 12, 5), "ICC_SRE"       },      // Interrupt Controller System Register Enable register
	{ MakeOpHash(15, 0, 12, 12, 6), "ICC_IGRPEN0"   },      // Interrupt Controller Interrupt Group 0 Enable (ICC_IGRPEN0) / Interrupt Controller Virtual Interrupt Group 0 Enable register (ICV_IGRPEN0)
	{ MakeOpHash(15, 0, 12, 12, 7), "ICC_IGRPEN1"   },      // Interrupt Controller Interrupt Group 1 Enable (ICC_IGRPEN1) / Interrupt Controller Virtual Interrupt Group 1 Enable register (ICV_IGRPEN1)
	{ MakeOpHash(15, 4, 12, 8, 0),  "ICH_AP0R0"     },      // Interrupt Controller Hyp Active Priorities Group 0 Register 0
	{ MakeOpHash(15, 4, 12, 8, 1),  "ICH_AP0R1"     },      // Interrupt Controller Hyp Active Priorities Group 0 Register 1
	{ MakeOpHash(15, 4, 12, 8, 2),  "ICH_AP0R2"     },      // Interrupt Controller Hyp Active Priorities Group 0 Register 2
	{ MakeOpHash(15, 4, 12, 8, 3),  "ICH_AP0R3"     },      // Interrupt Controller Hyp Active Priorities Group 0 Register 3
	{ MakeOpHash(15, 4, 12, 9, 0),  "ICH_AP1R0"     },      // Interrupt Controller Hyp Active Priorities Group 1 Register 0
	{ MakeOpHash(15, 4, 12, 9, 1),  "ICH_AP1R1"     },      // Interrupt Controller Hyp Active Priorities Group 1 Register 1
	{ MakeOpHash(15, 4, 12, 9, 2),  "ICH_AP1R2"     },      // Interrupt Controller Hyp Active Priorities Group 1 Register 2
	{ MakeOpHash(15, 4, 12, 9, 3),  "ICH_AP1R3"     },      // Interrupt Controller Hyp Active Priorities Group 1 Register 3
	{ MakeOpHash(15, 4, 12, 9, 5),  "ICC_HSRE"      },      // Interrupt Controller Hyp System Register Enable register
	{ MakeOpHash(15, 4, 12, 11, 0), "ICH_HCR"       },      // Interrupt Controller Hyp Control Register
	{ MakeOpHash(15, 4, 12, 11, 1), "ICH_VTR"       },      // Interrupt Controller VGIC Type Register
	{ MakeOpHash(15, 4, 12, 11, 2), "ICH_MISR"      },      // Interrupt Controller Maintenance Interrupt State Register
	{ MakeOpHash(15, 4, 12, 11, 3), "ICH_EISR"      },      // Interrupt Controller End of Interrupt Status Register
	{ MakeOpHash(15, 4, 12, 11, 5), "ICH_ELRSR"     },      // Interrupt Controller Empty List Register Status Register
	{ MakeOpHash(15, 4, 12, 11, 7), "ICH_VMCR"      },      // Interrupt Controller Virtual Machine Control Register
	{ MakeOpHash(15, 4, 12, 12, 0), "ICH_LR0"       },      // Interrupt Controller List Register 0
	{ MakeOpHash(15, 4, 12, 12, 1), "ICH_LR1"       },      // Interrupt Controller List Register 1
	{ MakeOpHash(15, 4, 12, 12, 2), "ICH_LR2"       },      // Interrupt Controller List Register 2
	{ MakeOpHash(15, 4, 12, 12, 3), "ICH_LR3"       },      // Interrupt Controller List Register 3
	{ MakeOpHash(15, 4, 12, 12, 4), "ICH_LR4"       },      // Interrupt Controller List Register 4
	{ MakeOpHash(15, 4, 12, 12, 5), "ICH_LR5"       },      // Interrupt Controller List Register 5
	{ MakeOpHash(15, 4, 12, 12, 6), "ICH_LR6"       },      // Interrupt Controller List Register 6
	{ MakeOpHash(15, 4, 12, 12, 7), "ICH_LR7"       },      // Interrupt Controller List Register 7
	{ MakeOpHash(15, 4, 12, 13, 0), "ICH_LR8"       },      // Interrupt Controller List Register 8
	{ MakeOpHash(15, 4, 12, 13, 1), "ICH_LR9"       },      // Interrupt Controller List Register 9
	{ MakeOpHash(15, 4, 12, 13, 2), "ICH_LR10"      },      // Interrupt Controller List Register 10
	{ MakeOpHash(15, 4, 12, 13, 3), "ICH_LR11"      },      // Interrupt Controller List Register 11
	{ MakeOpHash(15, 4, 12, 13, 4), "ICH_LR12"      },      // Interrupt Controller List Register 12
	{ MakeOpHash(15, 4, 12, 13, 5), "ICH_LR13"      },      // Interrupt Controller List Register 13
	{ MakeOpHash(15, 4, 12, 13, 6), "ICH_LR14"      },      // Interrupt Controller List Register 14
	{ MakeOpHash(15, 4, 12, 13, 7), "ICH_LR15"      },      // Interrupt Controller List Register 15
	{ MakeOpHash(15, 4, 12, 14, 0), "ICH_LRC0"      },      // Interrupt Controller List Register 0
	{ MakeOpHash(15, 4, 12, 14, 1), "ICH_LRC1"      },      // Interrupt Controller List Register 1
	{ MakeOpHash(15, 4, 12, 14, 2), "ICH_LRC2"      },      // Interrupt Controller List Register 2
	{ MakeOpHash(15, 4, 12, 14, 3), "ICH_LRC3"      },      // Interrupt Controller List Register 3
	{ MakeOpHash(15, 4, 12, 14, 4), "ICH_LRC4"      },      // Interrupt Controller List Register 4
	{ MakeOpHash(15, 4, 12, 14, 5), "ICH_LRC5"      },      // Interrupt Controller List Register 5
	{ MakeOpHash(15, 4, 12, 14, 6), "ICH_LRC6"      },      // Interrupt Controller List Register 6
	{ MakeOpHash(15, 4, 12, 14, 7), "ICH_LRC7"      },      // Interrupt Controller List Register 7
	{ MakeOpHash(15, 4, 12, 15, 0), "ICH_LRC8"      },      // Interrupt Controller List Register 8
	{ MakeOpHash(15, 4, 12, 15, 1), "ICH_LRC9"      },      // Interrupt Controller List Register 9
	{ MakeOpHash(15, 4, 12, 15, 2), "ICH_LRC10"     },      // Interrupt Controller List Register 10
	{ MakeOpHash(15, 4, 12, 15, 3), "ICH_LRC11"     },      // Interrupt Controller List Register 11
	{ MakeOpHash(15, 4, 12, 15, 4), "ICH_LRC12"     },      // Interrupt Controller List Register 12
	{ MakeOpHash(15, 4, 12, 15, 5), "ICH_LRC13"     },      // Interrupt Controller List Register 13
	{ MakeOpHash(15, 4, 12, 15, 6), "ICH_LRC14"     },      // Interrupt Controller List Register 14
	{ MakeOpHash(15, 4, 12, 15, 7), "ICH_LRC15"     },      // Interrupt Controller List Register 15
	{ MakeOpHash(15, 6, 12, 12, 4), "ICC_MCTLR"     },      // Interrupt Controller Monitor Control Register
	{ MakeOpHash(15, 6, 12, 12, 5), "ICC_MSRE"      },      // Interrupt Controller Monitor System Register Enable register
	{ MakeOpHash(15, 6, 12, 12, 7), "ICC_MGRPEN1"   },      // Interrupt Controller Monitor Interrupt Group 1 Enable register
	
	{ MakeOpHash(15, 0, 15, 0, 0),  "IL1Data0"      },      // Instruction L1 Data n Register
	{ MakeOpHash(15, 0, 15, 0, 1),  "IL1Data1"      },      // Instruction L1 Data n Register
	{ MakeOpHash(15, 0, 15, 0, 2),  "IL1Data2"      },      // Instruction L1 Data n Register
	{ MakeOpHash(15, 0, 15, 1, 0),  "DL1Data0"      },      // Data L1 Data n Register
	{ MakeOpHash(15, 0, 15, 1, 1),  "DL1Data1"      },      // Data L1 Data n Register
	{ MakeOpHash(15, 0, 15, 1, 2),  "DL1Data2"      },      // Data L1 Data n Register
	{ MakeOpHash(15, 0, 15, 2, 0),  "NA_DataMemRemap" },    // Data Memory Remap (ARM11)
	{ MakeOpHash(15, 0, 15, 2, 1),  "NA_InstMemRemap" },    // Instruction Memory Remap (ARM11)
	{ MakeOpHash(15, 0, 15, 2, 2),  "NA_DMAMemRemap" },     // DMA Memory Remap (ARM11)
	{ MakeOpHash(15, 0, 15, 2, 3),  "NA_PerifPortMemRemap" }, // Peripheral Port Memory Remap (ARM11)
	{ MakeOpHash(15, 0, 15, 4, 0),  "RAMINDEX"      },      // RAM Index Register
	{ MakeOpHash(15, 0, 15, 12, 0), "NA_PMonControl" },     // Performance Monitor Control (ARM11)
	{ MakeOpHash(15, 0, 15, 12, 1), "CCNT"          },      // Cycle Counter (ARM11)
	{ MakeOpHash(15, 0, 15, 12, 2), "PMN0"          },      // Count 0 (ARM11)
	{ MakeOpHash(15, 0, 15, 12, 3), "PMN1"          },      // Count 1 (ARM11)
	{ MakeOpHash(15, 1, 15, 0, 0),  "L2ACTLR"       },      // L2 Auxiliary Control Register
	{ MakeOpHash(15, 1, 15, 0, 3),  "L2FPR"         },      // L2 Prefetch Control Register
	{ MakeOpHash(15, 3, 15, 0, 0),  "NA_DDebugCache" },     // Data Debug Cache (ARM11)
	{ MakeOpHash(15, 3, 15, 0, 1),  "NA_IDebugCache" },     // Instruction Debug Cache (ARM11)
	{ MakeOpHash(15, 3, 15, 2, 0),  "NA_DTagRAMReadOp" },   // Data Tag RAM Read Operation (ARM11)
	{ MakeOpHash(15, 3, 15, 2, 1),  "NA_ITagRAMReadOp" },   // Instruction Tag RAM Read Operation (ARM11)
	{ MakeOpHash(15, 4, 15, 0, 0),  "CBAR"          },      // Configuration Base Address Register
	{ MakeOpHash(15, 5, 15, 4, 0),  "NA_DMicroTLBIdx" },    // Data MicroTLB Index (ARM11)
	{ MakeOpHash(15, 5, 15, 4, 1),  "NA_IMicroTLBIdx" },    // Instruction MicroTLB Index (ARM11)
	{ MakeOpHash(15, 5, 15, 4, 2),  "NA_ReadMainTLBEntry" }, // Read Main TLB Entry (ARM11)
	{ MakeOpHash(15, 5, 15, 4, 4),  "NA_WriteMainTLBEntry" }, // Write Main TLB Entry (ARM11)
	{ MakeOpHash(15, 5, 15, 5, 0),  "NA_DMicroTLBVA" },     // Data MicroTLB VA (ARM11)
	{ MakeOpHash(15, 5, 15, 5, 1),  "NA_IMicroTLBVA" },     // Instruction MicroTLB VA (ARM11)
	{ MakeOpHash(15, 5, 15, 5, 2),  "NA_MainTLBVA" },       // Main TLB VA (ARM11)
	{ MakeOpHash(15, 5, 15, 7, 0),  "NA_DMicroTLBAttr" },   // Data MicroTLB Attribute (ARM11)
	{ MakeOpHash(15, 5, 15, 7, 1),  "NA_IMicroTLBAttr" },   // Instruction MicroTLB Attribute (ARM11)
	{ MakeOpHash(15, 5, 15, 7, 2),  "NA_MainTLBAttr" },     // Main TLB Attribute (ARM11)
	{ MakeOpHash(15, 7, 15, 0, 0),  "NA_CacheDebugControl" }, // Cache Debug Control (ARM11)
	{ MakeOpHash(15, 7, 15, 1, 0),  "NA_TLBDebugControl" }, // TLB Debug Control (ARM11)

	{ MakeOpHash(15, 0, 15, 3, 2),  "NA_ReadITLBCAMinL1Data01" }, // Read I-TLB CAM into data L1 data 0/1 Register (Cortex-A8)
	{ MakeOpHash(15, 0, 15, 0, 3),  "NA_WriteDL1Data0toDTLBAttr" }, // Write D-L1 data 0 Register to D-TLB ATTR (Cortex-A8)
	{ MakeOpHash(15, 0, 15, 1, 3),  "NA_WriteIL1Data0toITLBAttr" }, // Write I-L1 data 0 Register to I-TLB ATTR (Cortex-A8)
	{ MakeOpHash(15, 0, 15, 3, 3),  "NA_ReadITLBATTRinL1Data0" }, // Read I-TLB ATTR into data L1 data 0 Register (Cortex-A8)
	{ MakeOpHash(15, 0, 15, 0, 4),  "NA_WriteDL1Data0toDTLBPA" }, // Write D-L1 data 0 Register to D-TLB PA (Cortex-A8)
	{ MakeOpHash(15, 0, 15, 2, 4),  "NA_ReadDTLBPAinL1Data0" }, // Read D-TLB PA into data L1 data 0 Register (Cortex-A8)
	{ MakeOpHash(15, 0, 15, 1, 4),  "NA_WriteIL1Data0toITLBPA" }, // Write I-L1 data 0 Register to I-TLB PA (Cortex-A8)
	{ MakeOpHash(15, 0, 15, 3, 4),  "NA_ReadITLBPAinL1Data0" }, // Read I-TLB PA into data L1 data 0 Register (Cortex-A8)

	{ MakeOpHash(15, 0, 8, 5, 3),  "NA_InvITLBSingleEntry" }, //  Invalidate Instruction TLB Single Entry on MVA only Register
	{ MakeOpHash(15, 0, 8, 6, 3),  "NA_InvDTLB" },           //  Invalidate Data TLB Register
	{ MakeOpHash(15, 5, 15, 6, 2), "NA_MainTLBAttr" },       //  Main TLB Attribute Register

	{ MakeOpHash(15, 3, 15, 2, 2), "NA_DTagRAMParityReadOp" }, // Data Tag RAM Parity Read Operation
	{ MakeOpHash(15, 3, 15, 2, 3), "NA_ICacheTagRAMParityReadOp" }, // Instruction cache Tag RAM Parity Read Operation
	{ MakeOpHash(15, 3, 15, 4, 1), "NA_ICacheDataRAMReadOp" }, // Instruction Cache Data RAM Read Operation
	{ MakeOpHash(15, 3, 15, 4, 2), "NA_DCacheDataRAMReadOp" }, // Data Cache Data RAM Parity Read Operation
	{ MakeOpHash(15, 3, 15, 4, 3), "NA_ICacheDataRAMParityReadOp" }, // Instruction Cache Data RAM Parity Read Operation	c15, Cache Data RAM parity read 
	{ MakeOpHash(15, 3, 15, 8, 0), "NA_ICacheMasterValid" }, // Instruction Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 8, 1), "NA_ICacheMasterValid" }, // Instruction Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 8, 2), "NA_ICacheMasterValid" }, // Instruction Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 8, 3), "NA_ICacheMasterValid" }, // Instruction Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 8, 4), "NA_ICacheMasterValid" }, // Instruction Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 8, 5), "NA_ICacheMasterValid" }, // Instruction Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 8, 6), "NA_ICacheMasterValid" }, // Instruction Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 8, 7), "NA_ICacheMasterValid" }, // Instruction Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 12, 0), "NA_DCacheMasterValid" }, //  Data Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 12, 1), "NA_DCacheMasterValid" }, //  Data Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 12, 2), "NA_DCacheMasterValid" }, //  Data Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 12, 3), "NA_DCacheMasterValid" }, //  Data Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 12, 4), "NA_DCacheMasterValid" }, //  Data Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 12, 5), "NA_DCacheMasterValid" }, //  Data Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 12, 6), "NA_DCacheMasterValid" }, //  Data Cache Master Valid Register
	{ MakeOpHash(15, 3, 15, 12, 7), "NA_DCacheMasterValid" }, //  Data Cache Master Valid Register
	{ MakeOpHash(15, 7, 15, 2, 0), "NA_DTagRAMOp" },      	// Data Tag RAM operation
	{ MakeOpHash(15, 7, 15, 2, 1), "NA_ICacheTagRAMOp" }, 	// Instruction cache Tag RAM operation
	{ MakeOpHash(15, 7, 15, 2, 2), "NA_DValidRAMnDirtyRAMOp" }, // Data Valid RAM and Dirty RAM operation
	{ MakeOpHash(15, 7, 15, 4, 1), "NA_ICacheDataRAM" },	// Instruction Cache Data RAM

	// Jazelle Registers
	{ MakeOpHash(14, 7, 0, 0, 0),   "JIDR"          },      // Jazelle ID Register
	{ MakeOpHash(14, 7, 1, 0, 0),   "JOSCR"         },      // Jazelle OS Control Register
	{ MakeOpHash(14, 7, 2, 0, 0),   "JMCR"          },      // Jazelle Main Configuration Register
	
	// Debug Registers
	{ MakeOpHash(15, 3, 4, 5, 0),   "DSPSR"         },      // Debug Saved Program Status Register (AArch32)
	{ MakeOpHash(15, 3, 4, 5, 1),   "DLR"           },      // Debug Link Register (AArch32)
	{ MakeOpHash(14, 0, 0, 0, 0),   "DBGDIDR"       },      // Debug ID Register
	{ MakeOpHash(14, 0, 0, 6, 0),   "DBGWFAR"       },      // Debug Watchpoint Fault Address Register
	{ MakeOpHash(14, 0, 0, 6, 2),   "DBGOSECCR"     },      // Debug OS Lock Exception Catch Control Register (AArch32)
	{ MakeOpHash(14, 0, 0, 7, 0),   "DBGVCR"        },      // Debug Vector Catch Register
	{ MakeOpHash(14, 0, 0, 9, 0),   "DBGECR"        },      // Debug Event Catch Register
	{ MakeOpHash(14, 0, 0, 10, 0),  "DBGDSCCR"      },      // Debug State Cache Control
	{ MakeOpHash(14, 0, 0, 11, 0),  "DBGDSMCR"      },      // Debug State MMU Control
	{ MakeOpHash(14, 0, 0, 0, 2),   "DBGDTRRXext"   },      // Debug OS Lock Data Transfer Register, Receive, External View
	{ MakeOpHash(14, 0, 0, 2, 0),   "DBGDCCINT"     },      // DCC Interrupt Enable Register (AArch32)
	{ MakeOpHash(14, 0, 0, 2, 2),   "DBGDSCRext"    },      // Debug Status and Control Register, External View
	{ MakeOpHash(14, 0, 0, 3, 2),   "DBGDTRTXext"   },      // Debug OS Lock Data Transfer Register, Transmit
	{ MakeOpHash(14, 0, 0, 4, 2),   "DBGDRCR"       },      // Debug Run Control
	{ MakeOpHash(14, 0, 0, 0, 4),   "DBGBVR0"       },      // Debug Breakpoint Value Register 0
	{ MakeOpHash(14, 0, 0, 1, 4),   "DBGBVR1"       },      // Debug Breakpoint Value Register 1
	{ MakeOpHash(14, 0, 0, 2, 4),   "DBGBVR2"       },      // Debug Breakpoint Value Register 2
	{ MakeOpHash(14, 0, 0, 3, 4),   "DBGBVR3"       },      // Debug Breakpoint Value Register 3
	{ MakeOpHash(14, 0, 0, 4, 4),   "DBGBVR4"       },      // Debug Breakpoint Value Register 4
	{ MakeOpHash(14, 0, 0, 5, 4),   "DBGBVR5"       },      // Debug Breakpoint Value Register 5
	{ MakeOpHash(14, 0, 0, 6, 4),   "DBGBVR6"       },      // Debug Breakpoint Value Register 6
	{ MakeOpHash(14, 0, 0, 7, 4),   "DBGBVR7"       },      // Debug Breakpoint Value Register 7
	{ MakeOpHash(14, 0, 0, 8, 4),   "DBGBVR8"       },      // Debug Breakpoint Value Register 8
	{ MakeOpHash(14, 0, 0, 9, 4),   "DBGBVR9"       },      // Debug Breakpoint Value Register 9
	{ MakeOpHash(14, 0, 0, 10, 4),  "DBGBVR10"      },      // Debug Breakpoint Value Register 10
	{ MakeOpHash(14, 0, 0, 11, 4),  "DBGBVR11"      },      // Debug Breakpoint Value Register 11
	{ MakeOpHash(14, 0, 0, 12, 4),  "DBGBVR12"      },      // Debug Breakpoint Value Register 12
	{ MakeOpHash(14, 0, 0, 13, 4),  "DBGBVR13"      },      // Debug Breakpoint Value Register 13
	{ MakeOpHash(14, 0, 0, 14, 4),  "DBGBVR14"      },      // Debug Breakpoint Value Register 14
	{ MakeOpHash(14, 0, 0, 15, 4),  "DBGBVR15"      },      // Debug Breakpoint Value Register 15
	{ MakeOpHash(14, 0, 0, 0, 5),   "DBGBCR0"       },      // Debug Breakpoint Control Register 0
	{ MakeOpHash(14, 0, 0, 1, 5),   "DBGBCR1"       },      // Debug Breakpoint Control Register 1
	{ MakeOpHash(14, 0, 0, 2, 5),   "DBGBCR2"       },      // Debug Breakpoint Control Register 2
	{ MakeOpHash(14, 0, 0, 3, 5),   "DBGBCR3"       },      // Debug Breakpoint Control Register 3
	{ MakeOpHash(14, 0, 0, 4, 5),   "DBGBCR4"       },      // Debug Breakpoint Control Register 4
	{ MakeOpHash(14, 0, 0, 5, 5),   "DBGBCR5"       },      // Debug Breakpoint Control Register 5
	{ MakeOpHash(14, 0, 0, 6, 5),   "DBGBCR6"       },      // Debug Breakpoint Control Register 6
	{ MakeOpHash(14, 0, 0, 7, 5),   "DBGBCR7"       },      // Debug Breakpoint Control Register 7
	{ MakeOpHash(14, 0, 0, 8, 5),   "DBGBCR8"       },      // Debug Breakpoint Control Register 8
	{ MakeOpHash(14, 0, 0, 9, 5),   "DBGBCR9"       },      // Debug Breakpoint Control Register 9
	{ MakeOpHash(14, 0, 0, 10, 5),  "DBGBCR10"      },      // Debug Breakpoint Control Register 10
	{ MakeOpHash(14, 0, 0, 11, 5),  "DBGBCR11"      },      // Debug Breakpoint Control Register 11
	{ MakeOpHash(14, 0, 0, 12, 5),  "DBGBCR12"      },      // Debug Breakpoint Control Register 12
	{ MakeOpHash(14, 0, 0, 13, 5),  "DBGBCR13"      },      // Debug Breakpoint Control Register 13
	{ MakeOpHash(14, 0, 0, 14, 5),  "DBGBCR14"      },      // Debug Breakpoint Control Register 14
	{ MakeOpHash(14, 0, 0, 15, 5),  "DBGBCR15"      },      // Debug Breakpoint Control Register 15
	{ MakeOpHash(14, 0, 0, 0, 6),   "DBGWVR0"       },      // Debug Watchpoint Value Register 0
	{ MakeOpHash(14, 0, 0, 1, 6),   "DBGWVR1"       },      // Debug Watchpoint Value Register 1
	{ MakeOpHash(14, 0, 0, 2, 6),   "DBGWVR2"       },      // Debug Watchpoint Value Register 2
	{ MakeOpHash(14, 0, 0, 3, 6),   "DBGWVR3"       },      // Debug Watchpoint Value Register 3
	{ MakeOpHash(14, 0, 0, 4, 6),   "DBGWVR4"       },      // Debug Watchpoint Value Register 4
	{ MakeOpHash(14, 0, 0, 5, 6),   "DBGWVR5"       },      // Debug Watchpoint Value Register 5
	{ MakeOpHash(14, 0, 0, 6, 6),   "DBGWVR6"       },      // Debug Watchpoint Value Register 6
	{ MakeOpHash(14, 0, 0, 7, 6),   "DBGWVR7"       },      // Debug Watchpoint Value Register 7
	{ MakeOpHash(14, 0, 0, 8, 6),   "DBGWVR8"       },      // Debug Watchpoint Value Register 8
	{ MakeOpHash(14, 0, 0, 9, 6),   "DBGWVR9"       },      // Debug Watchpoint Value Register 9
	{ MakeOpHash(14, 0, 0, 10, 6),  "DBGWVR10"      },      // Debug Watchpoint Value Register 10
	{ MakeOpHash(14, 0, 0, 11, 6),  "DBGWVR11"      },      // Debug Watchpoint Value Register 11
	{ MakeOpHash(14, 0, 0, 12, 6),  "DBGWVR12"      },      // Debug Watchpoint Value Register 12
	{ MakeOpHash(14, 0, 0, 13, 6),  "DBGWVR13"      },      // Debug Watchpoint Value Register 13
	{ MakeOpHash(14, 0, 0, 14, 6),  "DBGWVR14"      },      // Debug Watchpoint Value Register 14
	{ MakeOpHash(14, 0, 0, 15, 6),  "DBGWVR15"      },      // Debug Watchpoint Value Register 15
	{ MakeOpHash(14, 0, 0, 0, 7),   "DBGWCR0"       },      // Debug Watchpoint Control Register 0
	{ MakeOpHash(14, 0, 0, 1, 7),   "DBGWCR1"       },      // Debug Watchpoint Control Register 1
	{ MakeOpHash(14, 0, 0, 2, 7),   "DBGWCR2"       },      // Debug Watchpoint Control Register 2
	{ MakeOpHash(14, 0, 0, 3, 7),   "DBGWCR3"       },      // Debug Watchpoint Control Register 3
	{ MakeOpHash(14, 0, 0, 4, 7),   "DBGWCR4"       },      // Debug Watchpoint Control Register 4
	{ MakeOpHash(14, 0, 0, 5, 7),   "DBGWCR5"       },      // Debug Watchpoint Control Register 5
	{ MakeOpHash(14, 0, 0, 6, 7),   "DBGWCR6"       },      // Debug Watchpoint Control Register 6
	{ MakeOpHash(14, 0, 0, 7, 7),   "DBGWCR7"       },      // Debug Watchpoint Control Register 7
	{ MakeOpHash(14, 0, 0, 8, 7),   "DBGWCR8"       },      // Debug Watchpoint Control Register 8
	{ MakeOpHash(14, 0, 0, 9, 7),   "DBGWCR9"       },      // Debug Watchpoint Control Register 9
	{ MakeOpHash(14, 0, 0, 10, 7),  "DBGWCR10"      },      // Debug Watchpoint Control Register 10
	{ MakeOpHash(14, 0, 0, 11, 7),  "DBGWCR11"      },      // Debug Watchpoint Control Register 11
	{ MakeOpHash(14, 0, 0, 12, 7),  "DBGWCR12"      },      // Debug Watchpoint Control Register 12
	{ MakeOpHash(14, 0, 0, 13, 7),  "DBGWCR13"      },      // Debug Watchpoint Control Register 13
	{ MakeOpHash(14, 0, 0, 14, 7),  "DBGWCR14"      },      // Debug Watchpoint Control Register 14
	{ MakeOpHash(14, 0, 0, 15, 7),  "DBGWCR15"      },      // Debug Watchpoint Control Register 15
	{ MakeOpHash(14, 0, 1, 0, 1),   "DBGBXVR0"      },      // Debug Breakpoint Extended Value Register 0
	{ MakeOpHash(14, 0, 1, 1, 1),   "DBGBXVR1"      },      // Debug Breakpoint Extended Value Register 1
	{ MakeOpHash(14, 0, 1, 2, 1),   "DBGBXVR2"      },      // Debug Breakpoint Extended Value Register 2
	{ MakeOpHash(14, 0, 1, 3, 1),   "DBGBXVR3"      },      // Debug Breakpoint Extended Value Register 3
	{ MakeOpHash(14, 0, 1, 4, 1),   "DBGBXVR4"      },      // Debug Breakpoint Extended Value Register 4
	{ MakeOpHash(14, 0, 1, 5, 1),   "DBGBXVR5"      },      // Debug Breakpoint Extended Value Register 5
	{ MakeOpHash(14, 0, 1, 6, 1),   "DBGBXVR6"      },      // Debug Breakpoint Extended Value Register 6
	{ MakeOpHash(14, 0, 1, 7, 1),   "DBGBXVR7"      },      // Debug Breakpoint Extended Value Register 7
	{ MakeOpHash(14, 0, 1, 8, 1),   "DBGBXVR8"      },      // Debug Breakpoint Extended Value Register 8
	{ MakeOpHash(14, 0, 1, 9, 1),   "DBGBXVR9"      },      // Debug Breakpoint Extended Value Register 9
	{ MakeOpHash(14, 0, 1, 10, 1),  "DBGBXVR10"     },      // Debug Breakpoint Extended Value Register 10
	{ MakeOpHash(14, 0, 1, 11, 1),  "DBGBXVR11"     },      // Debug Breakpoint Extended Value Register 11
	{ MakeOpHash(14, 0, 1, 12, 1),  "DBGBXVR12"     },      // Debug Breakpoint Extended Value Register 12
	{ MakeOpHash(14, 0, 1, 13, 1),  "DBGBXVR13"     },      // Debug Breakpoint Extended Value Register 13
	{ MakeOpHash(14, 0, 1, 14, 1),  "DBGBXVR14"     },      // Debug Breakpoint Extended Value Register 14
	{ MakeOpHash(14, 0, 1, 15, 1),  "DBGBXVR15"     },      // Debug Breakpoint Extended Value Register 15
	{ MakeOpHash(14, 0, 1, 0, 4),   "DBGOSLAR"      },      // Debug OS Lock Access Register
	{ MakeOpHash(14, 0, 1, 1, 4),   "DBGOSLSR"      },      // Debug OS Lock Status Register
	{ MakeOpHash(14, 0, 1, 2, 4),   "DBGOSSRR"      },      // Debug OS Save and Restore
	{ MakeOpHash(14, 0, 1, 4, 4),   "DBGPRCR"       },      // Debug Power Control Register
	{ MakeOpHash(14, 0, 1, 5, 4),   "DBGPRSR"       },      // Debug Power Status Register
	{ MakeOpHash(14, 0, 7, 0, 4),   "DBGITCTRL"     },      // Debug Integration Mode Control
	{ MakeOpHash(14, 0, 7, 14, 6),  "DBGAUTHSTATUS" },      // Debug Authentication Status register
	{ MakeOpHash(14, 0, 7, 0, 7),   "DBGDEVID2"     },      // Debug Device ID register 2
	{ MakeOpHash(14, 0, 7, 1, 7),   "DBGDEVID1"     },      // Debug Device ID register 1
	{ MakeOpHash(14, 0, 7, 2, 7),   "DBGDEVID"      },      // Debug Device ID register 0
	{ MakeOpHash(14, 0, 7, 8, 6),   "DBGCLAIMSET"   },      // Debug Claim Tag Set register
	{ MakeOpHash(14, 0, 7, 9, 6),   "DBGCLAIMCLR"   },      // Debug Claim Tag Clear register
	{ MakeOpHash(14, 0, 0, 1, 0),   "DBGDSCRint"    },      // Debug Status and Control Register, Internal View
	{ MakeOpHash(14, 0, 0, 5, 0),   "DBGDTRRXint"   },      // Debug Data Transfer Register (DBGDTRRXint) / Debug Data Transfer Register, Transmit (DBGDTRTXint)
	{ MakeOpHash(14, 0, 1, 0, 0),   "DBGDRAR"       },      // Debug ROM Address Register
	{ MakeOpHash(14, 0, 1, 3, 4),   "DBGOSDLR"      },      // Debug OS Double Lock Register / OS Double Lock
	{ MakeOpHash(14, 0, 2, 0, 0),   "DBGDSAR"       },      // Debug Self Address Register
};

bool AArch32Extender::init()
{
	if (IDAAPI_IsBE()) {
		m_modeARM = cs_mode(CS_MODE_ARM | CS_MODE_BIG_ENDIAN);
		m_modeThumb = cs_mode(CS_MODE_THUMB | CS_MODE_BIG_ENDIAN);
	}
	else {
		m_modeARM = cs_mode(CS_MODE_ARM | CS_MODE_LITTLE_ENDIAN);
		m_modeThumb = cs_mode(CS_MODE_THUMB | CS_MODE_LITTLE_ENDIAN);
	}
	if (cs_open(CS_ARCH_ARM, m_modeARM, &m_capstoneHandle) != CS_ERR_OK)
	{
		msg("[FRIEND]: failed to initialize capstone\n");
		return false;
	}
	
	cs_option(m_capstoneHandle, CS_OPT_DETAIL, CS_OPT_ON);
	
	return true;
}

bool AArch32Extender::close()
{
	if (m_capstoneHandle != 0)
	{
		if (cs_close(&m_capstoneHandle) != CS_ERR_OK)
			return false;
	}
	
	return true;
}

bool AArch32Extender::output(uint16_t itype, ea_t address, uint32_t size, ProcOutput& procOutput)
{
	switch (itype)
	{
		case ARM_mcr:
		case ARM_mrc:
			return printMoveOutput(address, size, procOutput);
			
		default:
			break;
	}
	return false;
}

bool AArch32Extender::getSystemRegisterName(ea_t address, char* nameBuffer, uint32_t nameLength)
{
	bool ret = false;
	
	cs_insn *capstoneDisasm;
	cs_insn ci;
	uint8_t rawInstruction[4] = {0};
	size_t count = 0;
	uint32_t size = 0;
	
#if IDA_SDK_VERSION >= 700
	insn_t insn;
	decode_insn(&insn, address);
	size = insn.size;
#else
	decode_insn(address);
	size = cmd.size;
#endif
	
	BAIL_IF(IDAAPI_GetBytes(rawInstruction, size, address) == 0, "[FRIEND]: unable to read instruction at " PRINTF_ADDR "\n", address);
	
	if (isThumbArea(address))
		cs_option(m_capstoneHandle, CS_OPT_MODE, m_modeThumb);
	else
		cs_option(m_capstoneHandle, CS_OPT_MODE, m_modeARM);
	
	count = cs_disasm(m_capstoneHandle, rawInstruction, size, address, 1, &capstoneDisasm);
	BAIL_IF(count <= 0, "[FRIEND]: unable to decode instruction at " PRINTF_ADDR " [ %.2X%.2X%.2X%.2X ]\n",
			address, rawInstruction[0], rawInstruction[1], rawInstruction[2], rawInstruction[3]);
	
	ci = capstoneDisasm[0];
	
	if (ci.detail && ci.detail->arm.op_count > 4)
	{
		cs_arm_op* ops = ci.detail->arm.operands;
		
		uint32_t opHash = 0;
		if (ci.detail->arm.op_count == 6)
			opHash = MakeOpHash(ops[0].imm, ops[1].imm, ops[3].imm, ops[4].imm, ops[5].imm);
		else
			opHash = MakeOpHash(ops[0].imm, ops[1].imm, ops[3].imm, ops[4].imm);
		
		BAIL_IF(s_operandMap.find(opHash) == s_operandMap.end(), "[FRIEND]: unable to find register for instruction at " PRINTF_ADDR " [ %.2X%.2X%.2X%.2X ]\n",
				address, rawInstruction[0], rawInstruction[1], rawInstruction[2], rawInstruction[3]);
		
		auto cpRegName = s_operandMap[opHash];
		
		qstrncpy(nameBuffer, SCOLOR_ON, nameLength);
		qstrncat(nameBuffer, SCOLOR_REG, nameLength);
		qstrncat(nameBuffer, cpRegName, nameLength);
		qstrncat(nameBuffer, SCOLOR_OFF, nameLength);
		qstrncat(nameBuffer, SCOLOR_REG, nameLength);
		
		qstrupr(nameBuffer);
	}

	ret = true;
		
bail:

	if (count > 0)
		cs_free(capstoneDisasm, 1);
	
	return ret;
}

bool AArch32Extender::isEnabled()
{
	return m_enabled;
}

bool AArch32Extender::setEnabled(bool enabled)
{
	m_enabled = enabled;
	return true;
}

bool AArch32Extender::isThumbArea(ea_t address)
{
	sel_t t = IDAAPI_GetSegmentReg(address, kRegT);
	return t != BADSEL && t != 0;
}

bool AArch32Extender::printMoveOutput(ea_t address, uint32_t size, ProcOutput& procOutput)
{
	bool ret = false;
	
	cs_insn *capstoneDisasm;
	cs_insn ci;
	uint8_t rawInstruction[4] = {0};
	std::string mnemonic;
	size_t count = 0;
	
	BAIL_IF(IDAAPI_GetBytes(rawInstruction, size, address) == 0, "[FRIEND]: unable to read instruction at " PRINTF_ADDR "\n", address);
	
	if (isThumbArea(address))
		cs_option(m_capstoneHandle, CS_OPT_MODE, m_modeThumb);
	else
		cs_option(m_capstoneHandle, CS_OPT_MODE, m_modeARM);
	
	count = cs_disasm(m_capstoneHandle, rawInstruction, size, address, 1, &capstoneDisasm);
	BAIL_IF(count <= 0, "[FRIEND]: unable to decode instruction at " PRINTF_ADDR " [ %.2X%.2X%.2X%.2X ]\n",
			address, rawInstruction[0], rawInstruction[1], rawInstruction[2], rawInstruction[3]);
	
	ci = capstoneDisasm[0];
	
	if (ci.detail && ci.detail->arm.op_count > 4)
	{
		cs_arm_op* ops = ci.detail->arm.operands;

		uint32_t opHash = 0;
		if (ci.detail->arm.op_count == 6)
			opHash = MakeOpHash(ops[0].imm, ops[1].imm, ops[3].imm, ops[4].imm, ops[5].imm);
		else
			opHash = MakeOpHash(ops[0].imm, ops[1].imm, ops[3].imm, ops[4].imm);
		
		BAIL_IF(s_operandMap.find(opHash) == s_operandMap.end(), "[FRIEND]: unable to find register for instruction at " PRINTF_ADDR " [ %.2X%.2X%.2X%.2X ]\n",
				address, rawInstruction[0], rawInstruction[1], rawInstruction[2], rawInstruction[3]);

		char regName[kMaxElementNameLength] = {0};
		qstrncpy(regName, cs_reg_name(m_capstoneHandle, ops[2].reg), sizeof(regName));
		
		std::string gpRegName(qstrupr(regName));
		std::string cpRegName(s_operandMap[opHash]);
		
		std::string operands("");
		
		if (ci.mnemonic[1] == 'R') // MRC
		{
			operands += SCOLOR_ON SCOLOR_REG + gpRegName + SCOLOR_OFF SCOLOR_REG;
			operands += ", ";
			operands += SCOLOR_ON SCOLOR_REG + cpRegName + SCOLOR_OFF SCOLOR_REG;
		}
		else // MCR
		{
			operands += SCOLOR_ON SCOLOR_REG + cpRegName + SCOLOR_OFF SCOLOR_REG;
			operands += ", ";
			operands += SCOLOR_ON SCOLOR_REG + gpRegName + SCOLOR_OFF SCOLOR_REG;
		}

		procOutput.init();
		
		mnemonic = (SCOLOR_ON SCOLOR_INSN + std::string(qstrupr(ci.mnemonic)) + SCOLOR_OFF SCOLOR_INSN);

		procOutput.printf("%-20s", mnemonic.c_str());
		procOutput.line(operands.c_str(), COLOR_UNAME);
		
		procOutput.flush();
		
		ret = true;
	}
	
bail:

	if (count > 0)
		cs_free(capstoneDisasm, 1);
	
	return ret;
}

```

`FRIEND/AArch32Extender.hpp`:

```hpp
//
//  AArch32Extender.hpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 12/09/2017.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#pragma once

#include <map>
#include "capstone.h"

#include "ProcExtender.hpp"

class AArch32Extender : public ProcExtender
{
public:
	
	AArch32Extender() {};
	~AArch32Extender() {};
	
	bool	init() override;
	bool	close() override;
	
	bool	output(uint16_t itype, ea_t address, uint32_t size, ProcOutput& procOutput) override;
	
	bool	getSystemRegisterName(ea_t address, char* nameBuffer, uint32_t nameLength) override;
	
private:
	
	bool	isEnabled() override;
	bool	setEnabled(bool enabled) override;

	bool	isThumbArea(ea_t address);
	bool	printMoveOutput(ea_t address, uint32_t size, ProcOutput& procOutput);
	
private:
	
	static 	std::map<uint32_t, const char*> s_operandMap;
	
	csh		m_capstoneHandle = 0;
	cs_mode m_modeARM = cs_mode(0);
	cs_mode m_modeThumb = cs_mode(0);
};

```

`FRIEND/AArch64Extender.cpp`:

```cpp
//
//  AArch64Extender.cpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 11/11/2016.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#include <regex>

#include <idp.hpp>
#include <allins.hpp>

#include "AArch64Extender.hpp"
#include "IDAAPI.hpp"

#ifdef __EA64__
	#define PRINTF_ADDR	"%llX"
#else
	#define PRINTF_ADDR	"%X"
#endif

#define BAIL_IF(cond, ...)		\
	do							\
	{							\
		if ((cond))				\
		{						\
			msg(__VA_ARGS__);	\
			goto bail;			\
		}						\
	}							\
	while (0)

#define RegisterInfo(optype, itype, reg) ((optype << 24) | (itype << 20) | reg)

bool AArch64Extender::init()
{
	if (cs_open(CS_ARCH_ARM64, CS_MODE_ARM, &m_capstoneHandle) != CS_ERR_OK)
	{
		msg("[FRIEND]: failed to initialize capstone\n");
		return false;
	}
	
	cs_option(m_capstoneHandle, CS_OPT_DETAIL, CS_OPT_ON);
	
	return true;
}

bool AArch64Extender::close()
{
	if (m_capstoneHandle != 0)
	{
		if (cs_close(&m_capstoneHandle) != CS_ERR_OK)
			return false;
	}
	
	return true;
}

bool AArch64Extender::output(uint16_t itype, ea_t address, uint32_t size, ProcOutput& procOutput)
{
	switch (itype)
	{
		case ARM_msr:
		case ARM_mrs:
		case ARM_sys:
			return printCapstoneOutput(address, size, procOutput);
		default:
			break;
	}
	return false;
}

bool AArch64Extender::getSystemRegisterName(ea_t address, char* nameBuffer, uint32_t nameLength)
{
	bool ret = false;
	
	cs_insn *capstoneDisasm;
	cs_insn ci;
	uint32_t rawInstruction = 0;
	size_t count = 0;
	
	cs_arm64_op* ops = nullptr;
	uint32_t sysRegIdx = -1;
	arm64_op_type type = ARM64_OP_INVALID;
	uint8_t insn_type = 0;
	
	const char* tmp = nullptr;
	
	BAIL_IF(IDAAPI_GetBytes(&rawInstruction, sizeof(rawInstruction), address) == 0, "[FRIEND]: unable to read instruction at " PRINTF_ADDR "\n", address);
	
	count = cs_disasm(m_capstoneHandle, (const uint8_t*)&rawInstruction, sizeof(rawInstruction), address, 1, &capstoneDisasm);
	BAIL_IF(count <= 0, "[FRIEND]: unable to decode instruction at " PRINTF_ADDR " [ %.4X ]\n", address, rawInstruction);
	
	ci = capstoneDisasm[0];
	
	BAIL_IF(ci.id != ARM64_INS_MRS && ci.id != ARM64_INS_MSR, "[FRIEND]: unsupported instruction at " PRINTF_ADDR " [ %.4X ]\n", address, rawInstruction);
	BAIL_IF(ci.detail == nullptr, "[FRIEND]: unable to get details for instruction at " PRINTF_ADDR " [ %.4X ]\n", address, rawInstruction);
	
	ops = ci.detail->arm64.operands;
	
	sysRegIdx = (ci.id == ARM64_INS_MSR)? 0 : 1;
	type = ops[sysRegIdx].type;
	insn_type = 0;
	
	tmp = cs_reg_name(m_capstoneHandle, RegisterInfo(type, insn_type, ops[sysRegIdx].reg));
	BAIL_IF(tmp == nullptr, "[FRIEND]: unable to get register name for instruction at " PRINTF_ADDR " [ %.4X ]\n", address, rawInstruction);
	
	qstrncpy(nameBuffer, SCOLOR_ON, nameLength);
	qstrncat(nameBuffer, SCOLOR_REG, nameLength);
	qstrncat(nameBuffer, tmp, nameLength);
	qstrncat(nameBuffer, SCOLOR_OFF, nameLength);
	qstrncat(nameBuffer, SCOLOR_REG, nameLength);
	
	qstrupr(nameBuffer);
	
	ret = true;
	
bail:

	if (count > 0)
		cs_free(capstoneDisasm, 1);
	
	return ret;
}

bool AArch64Extender::isEnabled()
{
	return m_enabled;
}

bool AArch64Extender::setEnabled(bool enabled)
{
	m_enabled = enabled;
	return true;
}

bool AArch64Extender::printCapstoneOutput(ea_t address, uint32_t size, ProcOutput& procOutput)
{
	bool ret = false;
	
	cs_insn *capstoneDisasm;
	cs_insn ci;
	uint8_t rawInstruction[4] = {0};
	std::string mnemonic;
	size_t count = 0;
	
	BAIL_IF(IDAAPI_GetBytes(rawInstruction, size, address) == 0, "[FRIEND]: unable to read instruction at " PRINTF_ADDR "\n", address);

	count = cs_disasm(m_capstoneHandle, rawInstruction, size, address, 1, &capstoneDisasm);
	BAIL_IF(count <= 0, "[FRIEND]: unable to decode instruction at " PRINTF_ADDR " [ %.2X%.2X%.2X%.2X ]\n", address,
			rawInstruction[0], rawInstruction[1], rawInstruction[2], rawInstruction[3]);
	
	ci = capstoneDisasm[0];
	
	procOutput.init();
	
	mnemonic = (SCOLOR_ON SCOLOR_INSN + std::string(qstrupr(ci.mnemonic)) + SCOLOR_OFF SCOLOR_INSN);
	
	procOutput.printf("%-20s", mnemonic.c_str());
	
	if (ci.detail)
	{
		std::string operands(qstrupr(ci.op_str));
		
		uint8_t op_count = ci.detail->arm64.op_count;
		cs_arm64_op* ops = ci.detail->arm64.operands;
		for (int i=0; i < op_count; i++)
		{
			arm64_op_type type = ops[i].type;
			uint8_t insn_type = 0;
			
			switch (ci.id)
			{
				case ARM64_INS_AT:		insn_type = 1; break;
				case ARM64_INS_DC:		insn_type = 2; break;
				case ARM64_INS_IC:		insn_type = 3; break;
				case ARM64_INS_TLBI:	insn_type = 4; break;
				case ARM64_INS_ISB:		insn_type = 1; break;
				case ARM64_INS_DMB:		insn_type = 2; break;
				case ARM64_INS_DSB:		insn_type = 3; break;
				default:
					break;
			}
			
			const char* tmp = cs_reg_name(m_capstoneHandle, RegisterInfo(type, insn_type, ops[i].reg));
			if (tmp)
			{
				char regName[kMaxElementNameLength] = {0};
				
				qstrncpy(regName, tmp, sizeof(regName));
				std::string reg(qstrupr(regName));
				
				operands = std::regex_replace(operands, std::regex(reg), SCOLOR_ON SCOLOR_REG + reg + SCOLOR_OFF SCOLOR_REG);
			}
		}
		
		procOutput.line(operands.c_str(), COLOR_UNAME);
	}
	else
	{
		if(qstrstr(ci.op_str, "0x") != nullptr)
			procOutput.line(ci.op_str, COLOR_REG);
		else
			procOutput.line(qstrupr(ci.op_str), COLOR_REG);
	}

	procOutput.flush();
	
	ret = true;
	
bail:
	
	if (count > 0)
		cs_free(capstoneDisasm, 1);
	
	return ret;
}

```

`FRIEND/AArch64Extender.hpp`:

```hpp
//
//  AArch64Extender.hpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 11/11/2016.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#pragma once

#include "capstone.h"

#include "ProcExtender.hpp"

class AArch64Extender : public ProcExtender
{
public:
	
	AArch64Extender() {};
	~AArch64Extender() {};
	
	bool	init() override;
	bool	close() override;
	
	bool	output(uint16_t itype, ea_t address, uint32_t size, ProcOutput& procOutput) override;
	
	bool	getSystemRegisterName(ea_t address, char* nameBuffer, uint32_t nameLength) override;
	
private:
	
	bool	isEnabled() override;
	bool	setEnabled(bool enabled) override;
	
	bool	printCapstoneOutput(ea_t address, uint32_t size, ProcOutput& procOutput);
	
private:
	
	csh		m_capstoneHandle = 0;
};

```

`FRIEND/Documentation.cpp`:

```cpp
//
//  Documentation.cpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 11/11/2016.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#include <string>
#include <sstream>
#include <regex>

#include <loader.hpp>

#include "Documentation.hpp"

#define COL_STDSTR(str, tag) SCOLOR_ON tag << str << SCOLOR_OFF tag

bool Documentation::loadConfigFile(std::string filePath)
{
	resetConfigFile();
	
	auto result = m_xmlDoc.load_file(filePath.c_str());
	if (! result)
		return false;

	m_queryVars.add("doc_id", pugi::xpath_type_string);
	m_queryVars.add("group_idx", pugi::xpath_type_number);
	m_queryVars.add("token_id", pugi::xpath_type_string);
	m_getDocQuery = pugi::xpath_query("/documentation/document[@id = string($doc_id)]/path", &m_queryVars);
	m_getTokenQuery = pugi::xpath_query("/documentation/elements/group[$group_idx]/hint[@token = string($token_id)]", &m_queryVars);
	
	try
	{
		auto elementsNode = m_xmlDoc.child("documentation").child("elements");

		uint32_t index = 1;
		for (pugi::xml_node groupNode: elementsNode.children("group"))
		{
			Group group;
			
			group.enable = false;
			
			std::string type = groupNode.attribute("type").value();
			if (type == "reg")
				group.type = ElementType::Register;
			else if (type == "ins")
				group.type = ElementType::Instruction;
			else
				group.type = ElementType::Unknown;
			
			group.name = groupNode.attribute("name").value();
			group.index = index;
			
			m_groups.push_back(group);
			
			index++;
		}
	}
	catch (const pugi::xpath_exception& e)
	{
		resetConfigFile();
		
		msg("[FRIEND]: unable to load configuration (%s)\n", e.what());
		return false;
	}

	msg("[FRIEND]: configuration xml loaded from %s\n", filePath.c_str());
	
	return true;
}

bool Documentation::resetConfigFile()
{
	m_xmlDoc.reset();
	m_groups.clear();
	
	return true;
}

bool Documentation::registerAction()
{
	m_actionDesc = ACTION_DESC_LITERAL(
		m_actionName,		// action name
		m_popupTitle,		// action title
		this,				// handler
		nullptr,			// shortcut
		nullptr,			// tooltip
		-1);				// icon

	return register_action(m_actionDesc);
}

bool Documentation::unregisterAction()
{
	return unregister_action(m_actionName);
}

bool Documentation::areHintsEnabled()
{
	return m_hintsEnabled;
}

void Documentation::setHintsEnabled(bool enabled)
{
	m_hintsEnabled = enabled;
}

bool Documentation::availableForIdentifier()
{
	if (m_xmlDoc.empty())
		return false;
	
#if IDA_SDK_VERSION < 700
	char identifier[128] = {0};
	
	bool res = get_highlighted_identifier(identifier, sizeof(identifier), 0);
	if (!res)
		return res;
#else
	qstring tmp;
	uint32_t flags;
	get_highlight(&tmp, get_current_viewer(), &flags);
	const char* identifier = tmp.c_str();
#endif
	
	bool found = false;
	for (Group& group : m_groups)
	{
		if (group.enable == false)
			continue;
		
		m_queryVars.set("token_id", identifier);
		m_queryVars.set("group_idx", double(group.index));
		
		try
		{
			auto token_xnode = m_getTokenQuery.evaluate_node(m_xmlDoc);
			if (token_xnode.node().empty())
				continue;
			
			m_identifierNode = token_xnode.node();
			found = true;
			break;
		}
		catch (const pugi::xpath_exception& e)
		{
			msg("[FRIEND]: unable to find token (%s)\n", e.what());
		}
	}
	
	return found;
}

const char* Documentation::getActionName() const
{
	return m_actionName;
}

const char* Documentation::getActionMenuTitle() const
{
	return m_popupTitle;
}

uint32_t Documentation::getGroupCount()
{
	return m_groups.size();
}

const char* Documentation::getGroupName(uint32_t index)
{
	if (index >= m_groups.size())
		return nullptr;
	
	return m_groups[index].name.c_str();
}

bool Documentation::isGroupEnabled(uint32_t index)
{
	if (index < m_groups.size())
		return m_groups[index].enable;
	
	return false;
}

bool Documentation::setGroupEnabled(uint32_t index)
{
	if (index < m_groups.size())
	{
		m_groups[index].enable = true;
		return true;
	}
	
	return false;
}

void Documentation::disableAllGroups()
{
	for (Group& group : m_groups)
	{
		group.enable = false;
	}
}

int	Documentation::getElementHint(ElementType type, char* element, qstring &hint)
{
	auto unescapeString = [] (std::string input) -> std::string {
		std::string output;
		
		output = std::regex_replace(input, std::regex("&quot;"), "\"");
		output = std::regex_replace(output, std::regex("&amp;"), "&");
		output = std::regex_replace(output, std::regex("&apos;"), "'");
		output = std::regex_replace(output, std::regex("&lt;"), "<");
		output = std::regex_replace(output, std::regex("&gt;"), ">");

		return output;
	};
	
	int out_lines = 0;
	pugi::xml_node elementNode;

	bool found = false;
	for (Group group : m_groups)
	{
		if (group.enable == false)
			continue;
		
		if (group.type == ElementType::Unknown)
			continue;
		
		if (group.type != type)
			continue;
	
		m_queryVars.set("token_id", element);
		m_queryVars.set("group_idx", double(group.index));
		
		try
		{
			auto token_xnode = m_getTokenQuery.evaluate_node(m_xmlDoc);
			if (token_xnode.node().empty())
				continue;
			
			elementNode = token_xnode.node();
			found = true;
			break;
		}
		catch (const pugi::xpath_exception& e)
		{
			msg("[FRIEND]: unable to find token (%s)\n", e.what());
		}
	}
	
	if (found == false)
		return 0;

	std::ostringstream hint_text;

	// get header attribute
	std::string header = elementNode.attribute("header").value();
	if (header[0] != '\0')
	{
		// add header line to hint
		hint_text << " " << COL_STDSTR(unescapeString(header), SCOLOR_LOCNAME) << " ";
		out_lines++;
	}
	
	// get info attribute
	std::string info = unescapeString(elementNode.child_value());
	if (info[0] != '\0')
	{
		if (out_lines != 0)
		{
			hint_text << "\n ";
			out_lines++;
		}
		
		std::stringstream desc(info);
		std::string token;
		
		// add info lines to hint
		while (std::getline(desc, token))
		{
			if (out_lines != 0)
				hint_text << "\n ";
			hint_text << COL_STDSTR(token, SCOLOR_AUTOCMT) << " ";
			out_lines++;
		}
	}
	
	hint = hint_text.str().c_str();
	return out_lines;
}

bool Documentation::getReferenceDetails(ReferenceDetails& details)
{
	auto doc_id = m_identifierNode.attribute("doc_id").value();
	if (doc_id[0] == '\0') {
		msg("[FRIEND]: unable to find attribute 'doc_id' for \"%s\"\n", m_identifierNode.attribute("token").value());
		return false;
	}
	
	details.doc_id = doc_id;
	
	auto pageAttr = m_identifierNode.attribute("page");
	if (pageAttr.value()[0] == '\0') {
		msg("[FRIEND]: unable to find attribute 'page' for \"%s\"\n", m_identifierNode.attribute("token").value());
		return false;
	}
	
	details.page = pageAttr.as_int();
	
	return true;
}

bool Documentation::openInBrowser(ReferenceDetails& details)
{
	m_queryVars.set("doc_id", details.doc_id.c_str());

	auto doc_xnode = m_getDocQuery.evaluate_node(m_xmlDoc);
	auto node = doc_xnode.node();
	if (node.empty())
	{
		msg("[FRIEND]: unable to find document %s\n", details.doc_id.c_str());
		return false;
	}

	std::string docpath = node.child_value();
	std::string linkToken = "http";
	
	std::stringstream sstream;
	
	if(docpath.length() > linkToken.length() && docpath.compare(0, linkToken.length(), linkToken) == 0)
	{
		sstream << "osascript -e '" <<
		"tell application \"Google Chrome\"\n" <<
		"	set URL of active tab of window 1 to \"" << docpath << "\"\n" <<
		"	delay 1\n" <<
		"	reload active tab of window 1\n" <<
		"end tell\n" <<
		"'";
	}
	else
	{
		sstream << "osascript -e '" <<
		"tell application \"Google Chrome\"\n" <<
		"	set URL of active tab of window 1 to \"file://" << docpath << "?#page=" << details.page << "\"\n" <<
		"	delay 1\n" <<
		"	reload active tab of window 1\n" <<
		"end tell\n" <<
		"'";
	}
	
	// open pdf page in separate thread
	auto ascript = sstream.str();
	m_scriptThread = std::thread([ascript] () {
		system(ascript.c_str());
	});
	m_scriptThread.detach();
	
	return true;
}

// MARK:: action_handler_t methods

int idaapi Documentation::activate(action_activation_ctx_t *)
{
	ReferenceDetails details;
	
	bool res = getReferenceDetails(details);
	if (! res)
		return 0;
	
	openInBrowser(details);
	
	return 0;
}

action_state_t idaapi Documentation::update(action_update_ctx_t *)
{
	return AST_ENABLE_ALWAYS;
}

```

`FRIEND/Documentation.hpp`:

```hpp
//
//  Documentation.hpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 11/11/2016.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#pragma once

#include <ida.hpp>
#include <idp.hpp>
#include <vector>
#include <thread>

#include "pugixml.hpp"

enum class ElementType
{
	Register,
	Instruction,
	Unknown,
};

class Documentation : public action_handler_t
{
public:
	
	Documentation() {}
	
	bool			loadConfigFile(std::string filePath);
	bool			resetConfigFile();
	
	bool			registerAction();
	bool			unregisterAction();
	
	bool			areHintsEnabled();
	void			setHintsEnabled(bool enabled);
	bool			availableForIdentifier();

	const char*		getActionName() const;
	const char*		getActionMenuTitle() const;
	
	uint32_t		getGroupCount();
	const char*		getGroupName(uint32_t index);
	bool			isGroupEnabled(uint32_t index);
	bool			setGroupEnabled(uint32_t index);
	void			disableAllGroups();
	
	int				getElementHint(ElementType type, char* element, qstring &hint);
	
private:
	
	struct ReferenceDetails
	{
		std::string	doc_id;
		uint32_t	page;
	};
	
	bool			getReferenceDetails(ReferenceDetails& details);
	
	bool			openInBrowser(ReferenceDetails& details);
	
private:
	
	virtual int idaapi activate(action_activation_ctx_t *);
	virtual action_state_t idaapi update(action_update_ctx_t *);
	
private:
	
	bool						m_hintsEnabled = false;
	
	action_desc_t				m_actionDesc;
	
	const char*					m_actionName = "FRIEND::Documentation::Show";
	const char*					m_popupTitle = "Show Documentation";
	
	pugi::xml_document			m_xmlDoc;
	pugi::xpath_variable_set	m_queryVars;
	pugi::xpath_query			m_getDocQuery;
	pugi::xpath_query			m_getTokenQuery;
	pugi::xml_node				m_identifierNode;
	
	struct Group
	{
		bool		enable;
		ElementType type;
		std::string name;
		uint32_t	index;
	};
	
	std::vector<Group>			m_groups;
	
	std::thread					m_scriptThread;
};

```

`FRIEND/FRIEND.cpp`:

```cpp
//
//  FRIEND.cpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 11/11/2016.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>

#if (IDA_SDK_VERSION < 700) && defined(__X64__)
	#error Incompatible SDK version. Please use SDK 7.0 or higher
#elif (IDA_SDK_VERSION >= 700) && !defined(__X64__)
	#error Incompatible SDK version. Please use SDK 6.95 or lower
#endif

#if defined(USE_HEXRAYS)
	#include <hexrays.hpp>
#endif

#include "PluginDelegate.hpp"
#include "AArch64Extender.hpp"
#include "AArch32Extender.hpp"
#include "Documentation.hpp"
#include "FunctionSummary.hpp"
#include "Settings.hpp"
#include "IDAAPI.hpp"

#if defined(COMPILER_GCC) || defined(__clang__)
    #define ATTR_UNUSED __attribute__((unused))
#else
    #define ATTR_UNUSED
#endif

// The netnode helper.
// Using this node we will save current configuration information in the
// IDA database.
static const char gNodeName[] = "$ FRIEND instance";
static const uint32_t kPluginNode_Instance = 'objn';
static const uint32_t kPluginNode_Settings = 'setn';
static netnode gPluginNode(gNodeName);

#if defined(USE_HEXRAYS)
#if IDA_SDK_VERSION < 760
	// Hex-Rays API pointer
	hexdsp_t *hexdsp = nullptr;
#endif
#endif

char gPluginHelp[] = "FRIEND";
char gPluginComment[] = "This module improves disassembly and embeds register/instruction documentation to IDA.";
char gPluginWantedName[] = "FRIEND";
char gPluginWantedHotkey[] = "";

#define BAIL_IF(cond, ...)		\
	do							\
	{							\
		if ((cond))				\
		{						\
			msg(__VA_ARGS__);	\
			goto bail;			\
		}						\
	}							\
	while (0)

// MARK: - FRIEND class

class FRIEND final : public PluginDelegate
{
public:
	FRIEND() {}
	~FRIEND() {}
	
	bool init()
	{
		m_settings.setDelegate(this);
		
		m_documentation = new Documentation();
		BAIL_IF(m_documentation == nullptr, "[FRIEND]: unable to init plugin (no memory)");

		m_documentation->registerAction();

		if (ph.id == PLFM_ARM)
		{
			if (ph.use64())
			{
				// AArch64 processor module extender
				m_procExtender = new AArch64Extender();
				BAIL_IF(m_procExtender == nullptr, "[FRIEND]: unable to init plugin (no memory)");
			}
			else
			{
				// ARMv7 processor module extender
				m_procExtender = new AArch32Extender();
				BAIL_IF(m_procExtender == nullptr, "[FRIEND]: unable to init plugin (no memory)");
			}
			m_procExtender->init();
		}
		
		m_funcSummary = new FunctionSummary();
		BAIL_IF(m_documentation == nullptr, "[FRIEND]: unable to init plugin (no memory)");
		
		// Hook UI notifications
		hook_to_notification_point(HT_UI, FRIEND::s_ui_hook, this);
		
		return true;
		
	bail:
		
		return false;
	}
	
	void showSettings()
	{
		m_settings.show();
	}
	
	void close()
	{
		setProcExtenderEnabled(false);
		setHintsEnabled(false);
		
		// Unhook UI notifications
		unhook_from_notification_point(HT_UI, FRIEND::s_ui_hook, this);
		
		if (m_funcSummary)
		{
			delete m_funcSummary;
			m_funcSummary = nullptr;
		}
		
		if (m_procExtender)
		{
			m_procExtender->close();
			delete m_procExtender;
			m_procExtender = nullptr;
		}
		
		if (m_documentation)
		{
			m_documentation->unregisterAction();
			delete m_documentation;
			m_documentation = nullptr;
		}
		
	#if defined(USE_HEXRAYS)
		if (m_supportsHexRays)
		{
			term_hexrays_plugin();
			m_supportsHexRays = false;
		}
	#endif
	}
	
	// MARK: Static functions

#if IDA_SDK_VERSION >= 750
	static plugmod_t *s_init(void)
#else
	static int s_init(void)
#endif
	{
		if (exist(gPluginNode) == false)
			gPluginNode.create(gNodeName);
		
		auto plugin = new FRIEND();
		if (plugin->init() == false)
			return PLUGIN_SKIP;
		
		gPluginNode.supset(kPluginNode_Instance, &plugin, sizeof(decltype(plugin)));
		
		msg("[FRIEND]: plugin loaded\n");
		return PLUGIN_KEEP;
	}
	
	static idaapi_run_ret_t s_run(idaapi_run_args_t)
	{
		FRIEND* plugin = nullptr;

		gPluginNode.supval(kPluginNode_Instance, &plugin, sizeof(decltype(plugin)));
		
		if (plugin)
			plugin->showSettings();

		idaapi_run_return(true);
	}
	
	static void s_term(void)
	{
		FRIEND* plugin = nullptr;

		gPluginNode.supval(kPluginNode_Instance, &plugin, sizeof(decltype(plugin)));
		
		if (plugin)
		{
			plugin->close();
			delete plugin;
		}

		gPluginNode.supdel(kPluginNode_Instance);
		
		msg("[FRIEND]: plugin terminated\n");
	}
	
private:
	static idaapi_hook_cb_ret_t idaapi s_idp_hook(void* user_data, int notification_code, va_list va)
	{
		return ((FRIEND*)user_data)->idpHook(notification_code, va);
	}

	static idaapi_hook_cb_ret_t idaapi s_ui_hook(void* user_data, int notification_code, va_list va)
	{
		return ((FRIEND*)user_data)->uiHook(notification_code, va);
	}

#if defined(USE_HEXRAYS)
	#if (IDA_SDK_VERSION < 710)
	static int idaapi s_hexrays_hook(void* user_data, hexrays_event_t event, va_list va)
	#else
	static ssize_t idaapi s_hexrays_hook(void* user_data, hexrays_event_t event, va_list va)
	#endif
	{
		return ((FRIEND*)user_data)->hexRaysHook(event, va);
	}
#endif
	
	// MARK: IDA Hooks
	
	idaapi_hook_cb_ret_t idpHook(int notification_code, va_list va)
	{
		if (m_procExtender == nullptr)
			return 0;
		
		if (m_procExtender->isEnabled() == false)
			return 0;
		
		switch (notification_code) {
			case processor_t::idaapi_out_instruction:
			{
				idaapi_hook_cb_ret_t ret;
			#if IDA_SDK_VERSION >= 700
				outctx_t* ctx = va_arg(va, outctx_t *);
				auto& insn = ctx->insn;
				
				class Output : public ProcOutput
				{
				public:
					Output(outctx_t* ctx) : m_ctx(ctx) {}
					
					AS_PRINTF(2, 0) void printf(const char* format, ...) override
					{
						va_list va;
						va_start(va, format);
						m_ctx->out_vprintf(format, va);
						va_end(va);
					}
					void	line(const char* line, color_t color=0) override
					{
						m_ctx->out_line(line, color);
					}
					void	flush() override
					{
						m_ctx->flush_outbuf();
					}
				private:
					outctx_t* m_ctx = nullptr;
				} procOutput(ctx);
				
				ret = 1;
			#else
				auto& insn = cmd;
				
				class Output : public ProcOutput
				{
				public:
					void	init() override
					{
						init_output_buffer(m_idaOutputBuffer, sizeof(m_idaOutputBuffer));
					}
					AS_PRINTF(2, 0) void printf(const char* format, ...) override
					{
						char tmp[kMaxElementNameLength * 2];
						va_list va;
						va_start(va, format);
						vsprintf(tmp, format, va);
						va_end(va);
						
						out_line(tmp, COLOR_DEFAULT);
					}
					void	line(const char* line, color_t color) override
					{
						out_line(line, color);
					}
					void	flush() override
					{
						term_output_buffer();
						
						gl_comm = 1;
						MakeLine(m_idaOutputBuffer);
					}
				private:
					char m_idaOutputBuffer[MAXSTR];
				} procOutput;
				
				ret = 2;
			#endif

				if (m_procExtender->output(insn.itype, insn.ea, insn.size, procOutput))
				{
					return ret;
				}
				
				break;
			}
			default:
				break;
		}
		
		return 0;
	}
	
	idaapi_hook_cb_ret_t uiHook(int notification_code, va_list va)
	{
	#if defined(USE_HEXRAYS)
		auto is_hexrays_plugin = [] (const plugin_info_t *pinfo) -> bool {
			bool is_hexrays = false;
			if ( pinfo != nullptr && pinfo->entry != nullptr )
			{
				const plugin_t *p = pinfo->entry;
				if ( streq(p->wanted_name, "Hex-Rays Decompiler") )
					is_hexrays = true;
			}
			return is_hexrays;
		};
	#endif
		
		switch (notification_code) {
		#if defined(USE_HEXRAYS)
			case ui_plugin_loaded:
			{
            #if IDA_SDK_VERSION < 760
				if (hexdsp == nullptr)
				{
            #endif
					if (is_hexrays_plugin(va_arg(va, plugin_info_t *)))
					{
						m_supportsHexRays = init_hexrays_plugin();
					}
            #if IDA_SDK_VERSION < 760
				}
            #endif
				break;
			}
			case ui_plugin_unloading:
			{
            #if IDA_SDK_VERSION < 760
				if (hexdsp != nullptr)
				{
            #endif
					if (is_hexrays_plugin(va_arg(va, plugin_info_t *)))
					{
						remove_hexrays_callback(FRIEND::s_hexrays_hook, this);
						term_hexrays_plugin();
						m_supportsHexRays = false;
					}
            #if IDA_SDK_VERSION < 760
				}
            #endif
				break;
			}
		#endif
			case ui_ready_to_run:
			{
				// IDA is fully loaded, check for HexRays support
				msg("[FRIEND]: HexRays Decompiler is %s\n", (m_supportsHexRays)? "supported" : "not supported");
				
				m_settings.load();
				
				break;
			}
			case idaapi_ui_finish_populating_form_popup:
			{
				auto form = va_arg(va, idaapi_form_t *);
				if ( IDAAPI_GetFormType(form) == BWN_DISASM )
				{
					auto popup = va_arg(va, TPopupMenu *);
				#if IDA_SDK_VERSION < 700
					auto view = get_tform_idaview(form);
					if ( view != nullptr )
				#endif
					{
						bool addSeparator = false;
						
						if (m_documentation->availableForIdentifier())
						{
							if (! addSeparator)
							{
								attach_action_to_popup(form, popup, "-");
								addSeparator = true;
							}
							
							attach_action_to_popup(form, popup, m_documentation->getActionName());
						}
					}
				}
				
				break;
			}
			case ui_get_custom_viewer_hint:
			{
			#if IDA_SDK_VERSION >= 700
				qstring &hint			= *va_arg(va, qstring *);
				auto form				= va_arg(va, idaapi_form_t *);
				auto place				= va_arg(va, place_t *);
				auto important_lines	= va_arg(va, int *);
			#else
				auto form				= va_arg(va, idaapi_form_t *);
				auto place				= va_arg(va, place_t *);
				auto important_lines	= va_arg(va, int *);
				qstring &hint			= *va_arg(va, qstring *);
			#endif
				idaapi_form_type_t formType = IDAAPI_GetFormType(form);
				if (formType != BWN_DISASM)
					return 0;
				
				if ( place == nullptr )
					return 0;
			#if IDA_SDK_VERSION < 690
				auto ea = ((idaplace_t *)place)->ea;
			#else
				auto ea = place->toea();
			#endif
				
				if (IDAAPI_IsCode(IDAAPI_GetFlags(ea)) == false)
					return 0;
				
				// try to generate register/instruction hint otherwise
				int x, y;
			#if IDA_SDK_VERSION >= 700
				auto view = form;
			#else
				auto view = get_tform_idaview(form);
			#endif
				
				if (get_custom_viewer_place(view, true, &x, &y) == nullptr )
					return 0;
				
				const char* tagged_line = get_custom_viewer_curline(view, true);
				if (tagged_line == nullptr || uintptr_t(tagged_line) == -1)
					return 0;
				
				auto extractElement = [x] (const char* tagged_line, int16_t& start) -> bool {
					size_t length = qstrlen(tagged_line);
					uint16_t byte_offset = 0;
					uint16_t disp_offset = 0;
					
					// find tag closest to cursor
					while (disp_offset <= x && byte_offset < length)
					{
						char cur_char = tagged_line[byte_offset];
						if (cur_char == COLOR_ON)
						{
							start = byte_offset + 2;
							byte_offset += 2;
						}
						else if (cur_char == COLOR_OFF)
						{
							start = -1;
							byte_offset += 2;
						}
						else
						{
							disp_offset++;
							byte_offset++;
						}
					}
					
					return true;
				};
				
				// check if we have xref from current ea and summary is enabled
				xrefblk_t xb;
				if (m_funcSummary->isEnabled() && xb.first_from(ea, XREF_FAR))
				{
					// check if it is code reference
					if (IDAAPI_IsCode(IDAAPI_GetFlags(xb.to)))
					{
						// check element under cursor
						int16_t elem_start = -1;
						if (extractElement(tagged_line, elem_start))
						{
							color_t elem_type = tagged_line[elem_start - 1];
							
							// generate hint if it is address
							if (elem_type == COLOR_ADDR)
							{
								*important_lines = m_funcSummary->getSummaryHint(xb.to, hint);
								
								if (*important_lines != 0)
									return 1;
							}
						}
					}
				}
				
				// otherwise check if instruction/register hinst are enabled
				if (m_documentation->areHintsEnabled() == false)
					return 0;
				
				// generate documentation hint
				*important_lines = createHintFromDoc(tagged_line, hint, extractElement);
				
				if (*important_lines == 0)
					return 0;
				
				return 1;
			}
			default:
				break;
		}
		
		return 0;
	}

#if defined(USE_HEXRAYS)
	int hexRaysHook(hexrays_event_t event, va_list va)
	{
		switch ( event )
		{
			case hxe_maturity:
			{
				cfunc_t *cfunc = va_arg(va, cfunc_t *);
				ctree_maturity_t new_maturity = va_argi(va, ctree_maturity_t);
				if ( new_maturity == CMAT_FINAL )
				{
					struct ida_local sysreg_calls : public ctree_parentee_t
					{
					private:
						ATTR_UNUSED cfunc_t*		cfunc;
									ProcExtender*	procExtender = nullptr;
						
					public:
						sysreg_calls(cfunc_t *cf, ProcExtender* proc)
							: ctree_parentee_t(), cfunc(cf), procExtender(proc)
						{ }
						
						int idaapi visit_expr(cexpr_t *e)
						{
							if ( e->op != cot_call )
								return 0;

							if ( e->x->op != cot_helper )
								return 0;

							if (streq(e->x->helper, "ARM64_SYSREG"))
							{
								// fill helper string with system register name
								auto helper = new char[kMaxElementNameLength];
								if (procExtender->getSystemRegisterName(e->ea, helper, kMaxElementNameLength) == false)
								{
									delete[] helper;
									return 0;
								}
								
								// release cot_call expression
								e->cleanup();
								
								// create cot_helper expression
								e->replace_by(new cexpr_t(cot_helper, nullptr));
								e->helper = helper;
								e->exflags = EXFL_ALONE; // standalone helper
							}
							else if (streq(e->x->helper, "__mcr"))
							{
								// fill helper string with system register name
								auto helper = new char[kMaxElementNameLength];
								if (procExtender->getSystemRegisterName(e->ea, helper, kMaxElementNameLength) == false)
								{
									delete[] helper;
									return 0;
								}
								
								// rename '__mcr' to '_WriteSystemReg'
								delete[] e->x->helper;
								e->x->helper = new char[kMaxElementNameLength];
							#if _MSC_VER
								const char* func_name = "_WriteSystemReg";
								strncpy_s(e->x->helper, kMaxElementNameLength, func_name, strlen(func_name));
							#else
								strncpy(e->x->helper, "_WriteSystemReg", kMaxElementNameLength);
							#endif
								
								// fix args
								auto& args = *(e->a);
								auto src = new cexpr_t();
								args[2].swap(*src); // save rvalue
								
								args.clear();
								args.push_back();
								args[0].cleanup();
								args[0].replace_by(new cexpr_t(cot_helper, nullptr));
								args[0].helper = helper;
								args[0].exflags = EXFL_ALONE; // standalone helper
								
								args.push_back();
								args[1].replace_by(src); // restore rvalue
							}
							else if (streq(e->x->helper, "__mrc"))
							{
								// fill helper string with system register name
								auto helper = new char[kMaxElementNameLength];
								if (procExtender->getSystemRegisterName(e->ea, helper, kMaxElementNameLength) == false)
								{
									delete[] helper;
									return 0;
								}
								
								// rename '__mrc' to '_ReadSystemReg'
								delete[] e->x->helper;
								e->x->helper = new char[kMaxElementNameLength];
							#if _MSC_VER
								const char* func_name = "_ReadSystemReg";
								strncpy_s(e->x->helper, kMaxElementNameLength, func_name, strlen(func_name));
							#else
								strncpy(e->x->helper, "_ReadSystemReg", kMaxElementNameLength);
							#endif

								// fix args
								auto& args = *(e->a);

								args.clear();
								args.push_back();
								args[0].cleanup();
								args[0].replace_by(new cexpr_t(cot_helper, nullptr));
								args[0].helper = helper;
								args[0].exflags = EXFL_ALONE; // standalone helper
							}

							return 0;
						}
					};
					
					sysreg_calls calls(cfunc, m_procExtender);
					calls.apply_to(&cfunc->body, nullptr);
					
					cfunc->verify(FORBID_UNUSED_LABELS, true);
				}
			}
			break;
			case hxe_create_hint:
			{
				if (m_documentation->areHintsEnabled() == false)
					return 0;
				
				auto vu					= va_arg(va, vdui_t *);
				qstring &hint			= *va_arg(va, qstring *);
				auto important_lines	= va_arg(va, int *);
				
				// get ctree item under cursor (VDI_EXPR: Expression)
				auto el = vu->item.e;
				
				if (el->op == cot_empty)
					return 0;
				
				// check if we can generate function summary
				if (el->op == cot_obj || el->op == cot_call)
				{
					ea_t fea;
					if (el->op == cot_call)
						fea = el->x->obj_ea; // if cursor is on a bracket
					else
						fea = el->obj_ea; // if cursor is on function name
					
					if (m_funcSummary->isEnabled() && IDAAPI_IsCode(IDAAPI_GetFlags(fea)))
					{
						*important_lines = m_funcSummary->getSummaryHint(fea, hint);
						
						if (*important_lines != 0)
							return 1;
					}
				}
				
				// registers can only be certain element types
				if (el->op != cot_helper && el->op != cit_asm)
					return 0;
				
				// TODO: for cit_asm elements get text in __asm { ... } and implement
				//       extractElement lambda code for register under cursor
				if (el->op == cit_asm)
					return 0;
				
				// try to generate register/instruction hint otherwise
				const char* tagged_line = el->helper;
				if (tagged_line == nullptr || uintptr_t(tagged_line) == -1)
					return 0;
				
				*important_lines = createHintFromDoc(tagged_line, hint, [] (const char* tagged_line, int16_t& start) -> bool {
					// check COLOR start tag
					char cur_char = tagged_line[0];
					if (cur_char != COLOR_ON)
						return false;
					
					start = 2;
					return true;
				});
				
				if (*important_lines == 0)
					return 0;
					
				return 1;
			}
			break;
			case hxe_populating_popup:
			{
				auto form = va_arg(va, idaapi_form_t *);
				auto popup = va_arg(va, TPopupMenu *);
				
			#if IDA_SDK_VERSION < 700
				auto view = get_tform_vdui(form);
				if ( view != nullptr )
			#endif
				{
					bool addSeparator = false;
					
					if (m_documentation->availableForIdentifier())
					{
						if (! addSeparator)
						{
							attach_action_to_popup(form, popup, "-");
							addSeparator = true;
						}
						
						attach_action_to_popup(form, popup, m_documentation->getActionName());
					}
				}
				
				break;
			}
			default:
				break;
		}
		return 0;
	}
#endif
	
	template<typename F>
	int createHintFromDoc(const char* tagged_line, qstring &hint, F extractElement)
	{
		uint16_t length = qstrlen(tagged_line);
		int16_t elem_start = -1;
		int16_t elem_len = -1;
		
		if (extractElement(tagged_line, elem_start) == false)
			return 0;
		
		if (elem_start == -1)
			return 0;
		
		uint16_t byte_offset = elem_start;
		color_t elem_type = tagged_line[byte_offset - 1];
		
		// validate COLOR type tag
		if (elem_type != COLOR_INSN && elem_type != COLOR_REG && elem_type != COLOR_KEYWORD &&
			elem_type != COLOR_OPND1 && elem_type != COLOR_OPND2 && elem_type != COLOR_OPND3 &&
			elem_type != COLOR_OPND4 && elem_type != COLOR_OPND5 && elem_type != COLOR_OPND6)
			return 0;
		
		// find end of item string
		while (tagged_line[byte_offset] != COLOR_OFF && byte_offset < length)
			byte_offset++;
		elem_len = byte_offset - elem_start;
		
		if (elem_len == 0)
			return 0;
		
		char elem_str[kMaxElementNameLength]={0};
		
	#if _MSC_VER
		strncpy_s(elem_str, &tagged_line[elem_start], elem_len);
	#else
		strncpy(elem_str, &tagged_line[elem_start], elem_len);
	#endif
		
		if (elem_type == COLOR_INSN)
		{
			return m_documentation->getElementHint(ElementType::Instruction, elem_str, hint);
		}
		else // COLOR_REG, COLOR_KEYWORD, COLOR_OPNDx
		{
			return m_documentation->getElementHint(ElementType::Register, elem_str, hint);
		}
	}
	
	// MARK: PluginDelegate
	
	Documentation* getDocumentation() override
	{
		return m_documentation;
	}
	
	ProcExtender* getProcExtender() override
	{
		return m_procExtender;
	}
	
	bool setHintsEnabled(bool enabled) override
	{
		m_documentation->setHintsEnabled(enabled);
		msg("[FRIEND]: Hints %s\n", enabled ? "enabled" : "disabled");
		
		return true;
	}

	bool setProcExtenderEnabled(bool enabled) override
	{
		if (m_procExtender == nullptr)
			return false;

		if (enabled)
		{
			hook_to_notification_point(HT_IDP, FRIEND::s_idp_hook, this);
			
		#if defined(USE_HEXRAYS)
			if (m_supportsHexRays)
				install_hexrays_callback(FRIEND::s_hexrays_hook, this);
		#endif
			
			request_refresh(IWID_DISASMS);
		}
		else
		{
		#if defined(USE_HEXRAYS)
			if (m_supportsHexRays)
				remove_hexrays_callback(FRIEND::s_hexrays_hook, this);
		#endif

			unhook_from_notification_point(HT_IDP, FRIEND::s_idp_hook, this);
		}
		
		m_procExtender->setEnabled(enabled);
		msg("[FRIEND]: Processor Extender %s\n", enabled ? "enabled" : "disabled");
		
		return true;
	}
	
	bool setFuncSummaryEnabled(bool enabled) override
	{
		m_funcSummary->setEnabled(enabled);
		msg("[FRIEND]: Function Summary %s\n", enabled ? "enabled" : "disabled");
		
		return true;
	}
	
	bool getSettingsBlobSize(int32_t& size) override
	{
		size = gPluginNode.supval(kPluginNode_Settings, nullptr, 0);
		if (size > 0)
			return true;
		else
			return false;
	}
	
	bool loadSettingsBlob(uint8*& data, int32_t size) override
	{
		if (gPluginNode.supval(kPluginNode_Settings, data, size) > 0)
		{
			msg("[FRIEND]: Settings loaded from IDB\n");
			return true;
		}
		
		return false;
	}
	
	bool saveSettingsBlob(uint8*& data, int32_t size) override
	{
		gPluginNode.supdel(kPluginNode_Settings);
		if (gPluginNode.supset(kPluginNode_Settings, data, size) != 0)
		{
			msg("[FRIEND]: Settings saved to IDB\n");
			return true;
		}
		
		return false;
	}
	
	bool deleteSettingsBlob() override
	{
		gPluginNode.supdel(kPluginNode_Settings);
		return true;
	}
	
private:
	
	Settings			m_settings;
	
	Documentation*		m_documentation = nullptr;
	ProcExtender*		m_procExtender = nullptr;
	FunctionSummary*	m_funcSummary = nullptr;
	
	bool			    m_supportsHexRays = false;
};

//--------------------------------------------------------------------------
//
//      PLUGIN DESCRIPTION BLOCK
//
//--------------------------------------------------------------------------
#if IDA_SDK_VERSION >= 750
	plugmod_t *idaapi pluginInit(void)			{ return FRIEND::s_init();		}
#else
	int idaapi pluginInit(void)			{ return FRIEND::s_init();		}
#endif
	void idaapi pluginTerminate(void)	{ FRIEND::s_term();				}
#if IDA_SDK_VERSION >= 700
	bool idaapi pluginRun(size_t args) 	{ return FRIEND::s_run(args);	}
#else
	void idaapi pluginRun(int args) 	{ FRIEND::s_run(args);			}
#endif

plugin_t PLUGIN =
{
	IDP_INTERFACE_VERSION,
	PLUGIN_PROC | PLUGIN_DRAW,	// plugin flags
	pluginInit,					// initialize

	pluginTerminate,			// terminate. this pointer may be NULL.

	pluginRun,					// invoke plugin

	gPluginComment,				// long comment about the plugin
								// it could appear in the status line
								// or as a hint

	gPluginHelp,				// multiline help about the plugin

	gPluginWantedName,			// the preferred short name of the plugin
	gPluginWantedHotkey			// the preferred hotkey to run the plugin
};

```

`FRIEND/FunctionSummary.cpp`:

```cpp
//
//  FunctionSummary.cpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 11/7/17.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#include <sstream>

#include <idp.hpp>
#include <funcs.hpp>

#include "FunctionSummary.hpp"
#include "IDAAPI.hpp"

#define COL_STDSTR(str, tag) SCOLOR_ON tag << str << SCOLOR_OFF tag

bool 	FunctionSummary::isEnabled()
{
	return m_enabled;
}

bool	FunctionSummary::setEnabled(bool enabled)
{
	m_enabled = enabled;
	return true;
}

int	FunctionSummary::getSummaryHint(ea_t address, qstring &hint)
{
	int out_lines = 0;
	
	func_t* pfn = get_func(address);
	if (pfn == nullptr)
		return 0;
	
	uint32_t callCnt = 0;
	uint32_t strCnt = 0;
	func_item_iterator_t fii;
	ea_t fea;
	qstring tmp;
	
	struct RefInfo {
		ea_t		address;
		qstring		string;
		uint32_t	count;
	};
	
	qlist<RefInfo> flist;
	qlist<RefInfo> slist;
	
	for (bool ok = fii.set(pfn, address); ok; ok = fii.next_addr() )
	{
		fea = fii.current();
	
	#if IDA_SDK_VERSION >= 700
		insn_t insn;
		if ( decode_insn(&insn, fea) > 0 && is_call_insn(insn) )
	#else
		if(is_call_insn(fea))
	#endif
		{
			auto ref = get_first_fcref_from(fea);
			if (ref != BADADDR)
			{
				RefInfo item;
				item.count = 1;
				item.address = ref;
				IDAAPI_GetFuncName(&item.string, item.address);
				
				if (callCnt != 0 && flist.back().address == item.address)
					flist.back().count++;
				else
					flist.push_back(item);
				
				callCnt++;
			}
		}
		else
		{
			auto ref = get_first_dref_from(fea);
			if (ref != BADADDR)
			{
				// some strings are nested two levels; they point to an offset just outside the function
				// and then this offset points to the real string
				auto ref2 = get_first_dref_from(ref);
				if (!IDAAPI_IsString(IDAAPI_GetFlags(ref)) && ref2 != BADADDR)
					ref = ref2;

				if (IDAAPI_IsString(IDAAPI_GetFlags(ref)))
				{
					RefInfo item;
					item.count = 1;
					item.address = ref;
					
					size_t refLen = IDAAPI_GetMaxStringLength(ref, IDAAPI_STRTYPE_C, ALOPT_IGNHEADS);
				#if IDA_SDK_VERSION >= 700
					IDAAPI_GetStringContent(&item.string, ref, refLen, STRTYPE_C);
				#else
					char ctmp[256];
					IDAAPI_GetStringContent(ref, refLen, IDAAPI_STRTYPE_C, ctmp, 256);
					item.string = ctmp;
				#endif
					
					item.string.replace("\n", "\\n");
					
					if (strCnt != 0 && slist.back().address == ref)
						slist.back().count++;
					else
						slist.push_back(item);
					
					strCnt++;
				}
			}
		}
		
	}
	
	IDAAPI_GetFuncName(&tmp, address);
	
	std::ostringstream sum_hint;
	sum_hint << " " << tmp.c_str() << COL_STDSTR(": ", SCOLOR_AUTOCMT) <<
	COL_STDSTR(callCnt, SCOLOR_CREFTAIL) << COL_STDSTR(" calls, ", SCOLOR_AUTOCMT) <<
	COL_STDSTR(strCnt, SCOLOR_CREFTAIL) << COL_STDSTR(" strings \n", SCOLOR_AUTOCMT);
	out_lines = 1;
	
	bool pad = false;
	if (flist.size())
	{
		sum_hint << "\n " << COL_STDSTR("Calls:\n", SCOLOR_MACRO);
		out_lines += 2;
		
		while (! flist.empty())
		{
			auto item = flist.front();
			sum_hint << COL_STDSTR("  - ", SCOLOR_AUTOCMT) << COL_STDSTR(item.string.c_str(), SCOLOR_CNAME);
			if (item.count != 1)
				sum_hint << COL_STDSTR(" x", SCOLOR_CREFTAIL) << COL_STDSTR(item.count, SCOLOR_CREFTAIL) << " \n";
			else
				sum_hint << " \n";
			
			flist.pop_front();
			out_lines++;
		}
		
		pad = true;
	}
	
	if (slist.size())
	{
		sum_hint << "\n " << COL_STDSTR("Strings:\n", SCOLOR_MACRO);
		out_lines += 2;
		
		while (! slist.empty())
		{
			auto item = slist.front();
			sum_hint << COL_STDSTR("  - ", SCOLOR_AUTOCMT) << COL_STDSTR(item.string.c_str(), SCOLOR_DSTR);
			if (item.count != 1)
				sum_hint << COL_STDSTR(" x", SCOLOR_CREFTAIL) << COL_STDSTR(item.count, SCOLOR_CREFTAIL) << " \n";
			else
				sum_hint << " \n";
			
			slist.pop_front();
			out_lines++;
		}
		
		pad = true;
	}
	
	if (pad)
	{
		sum_hint << "\n";
		out_lines++;
	}
	
	hint = sum_hint.str().c_str();
	return out_lines;
}

```

`FRIEND/FunctionSummary.hpp`:

```hpp
//
//  FunctionSummary.hpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 11/7/17.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#pragma once

#include <pro.h>

class FunctionSummary
{
public:
	FunctionSummary() {};
	~FunctionSummary() {};
	
	bool 	isEnabled();
	bool	setEnabled(bool enabled);
	int		getSummaryHint(ea_t address, qstring &hint);
	
private:
	
	bool	m_enabled = false;
	
};

```

`FRIEND/IDAAPI.hpp`:

```hpp
//
//  IDAAPI.hpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 16/09/2017.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#pragma once

#if IDA_SDK_VERSION >= 700

	#define idaapi_form_t							TWidget
	#define idaapi_form_type_t						twidget_type_t

	#define idaapi_chooser_sel_base					0
	#define idaapi_chooser_sel_t					sizevec_t
	#define idaapi_hook_cb_ret_t					ssize_t
	#define idaapi_run_args_t						size_t
	#define idaapi_run_ret_t						bool
	#define idaapi_run_return(x)					return (x)
#if IDA_SDK_VERSION >= 730
	#define IDAAPI_IsBE()							(inf_is_be())
#else
	#define IDAAPI_IsBE()							(inf.is_be())
#endif
	#define IDAAPI_AskForm							ask_form
	#define IDAAPI_GetFlags							get_flags
	#define IDAAPI_GetFuncName						get_func_name
	#define IDAAPI_IsString							is_strlit
	#define IDAAPI_IsCode							is_code
	#define IDAAPI_STRTYPE_C						STRTYPE_C
	#define IDAAPI_GetStringContent					get_strlit_contents
	#define IDAAPI_GetMaxStringLength				get_max_strlit_length
	#define IDAAPI_GetFormType						get_widget_type
	#define IDAAPI_GetBytes(buf, size, ea)			get_bytes((buf), (size), (ea))
	#define IDAAPI_GetSegmentReg					get_sreg

	#define idaapi_ui_finish_populating_form_popup	ui_finish_populating_widget_popup
	#define idaapi_out_instruction					ev_out_insn

#else

	#define idaapi_form_t							TForm
	#define idaapi_form_type_t						tform_type_t

	#define idaapi_chooser_sel_base					1
	#define idaapi_chooser_sel_t					intvec_t
	#define idaapi_hook_cb_ret_t					int
	#define idaapi_run_args_t						int
	#define idaapi_run_ret_t						void
	#define idaapi_run_return(x)

	#define IDAAPI_IsBE()							(inf.mf == true)
	#define IDAAPI_AskForm							AskUsingForm_c
	#define IDAAPI_GetFlags							getFlags
	#define IDAAPI_GetFuncName						get_func_name2
	#define IDAAPI_IsString							isASCII
	#define IDAAPI_IsCode							isCode
	#define IDAAPI_STRTYPE_C						ASCSTR_C
	#define IDAAPI_GetStringContent					get_ascii_contents2
	#define IDAAPI_GetMaxStringLength				get_max_ascii_length
	#define IDAAPI_GetFormType						get_tform_type
	#define IDAAPI_GetBytes(buf, size, ea)			get_many_bytes((ea), (buf), (size))
	#define IDAAPI_GetSegmentReg					get_segreg

	#define idaapi_ui_finish_populating_form_popup	ui_finish_populating_tform_popup
	#define idaapi_out_instruction					custom_out

#endif

```

`FRIEND/PluginDelegate.hpp`:

```hpp
//
//  PluginDelegate.hpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 11/11/2016.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#pragma once

class Documentation;
class ProcExtender;

class PluginDelegate
{
public:
	virtual Documentation*	getDocumentation() = 0;
	virtual ProcExtender*	getProcExtender() = 0;
	
	virtual bool			setHintsEnabled(bool enabled) = 0;
	virtual bool			setProcExtenderEnabled(bool enabled) = 0;
	virtual bool			setFuncSummaryEnabled(bool enabled) = 0;
	
	virtual bool			getSettingsBlobSize(int32_t& size) = 0;
	virtual bool			loadSettingsBlob(uint8*& data, int32_t size) = 0;
	virtual bool			saveSettingsBlob(uint8*& data, int32_t size) = 0;
	virtual bool			deleteSettingsBlob() = 0;
};

```

`FRIEND/ProcExtender.hpp`:

```hpp
//
//  ProcExtender.h
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 11/11/2016.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#pragma once

#include <pro.h>

static const uint32_t kMaxElementNameLength	= 32;

class ProcOutput
{
public:
	virtual void	init() {};
	virtual void	printf(const char* format, ...) {};
	virtual void	line(const char* line, color_t color=0) {};
	virtual void	flush() {};
};

class ProcExtender
{
public:
	virtual ~ProcExtender() {}
	
	virtual bool	init() = 0;
	virtual bool	close() = 0;

	virtual bool	isEnabled() = 0;
	virtual bool	setEnabled(bool enabled) = 0;

	virtual bool	output(uint16_t itype, ea_t address, uint32_t size, ProcOutput& procOutput) = 0;
	virtual bool	getSystemRegisterName(ea_t address, char* nameBuffer, uint32_t nameLength) = 0;
	
protected:
	bool			m_enabled = false;
	
};

```

`FRIEND/Settings.cpp`:

```cpp
//
//  Settings.cpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 11/11/2016.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#include <ida.hpp>
#include <idp.hpp>

#include "Settings.hpp"
#include "Documentation.hpp"
#include "ProcExtender.hpp"
#include "PluginDelegate.hpp"
#include "IDAAPI.hpp"

enum FormActions {
	kFormAction_Init			= -1,
	kFormAction_Term			= -2,
	kFormAction_ConfigFile		=  3,
	kFormAction_HintGroups		=  4,
	kFormAction_EnableProc		=  5,
	kFormAction_EnableHints		=  6,
	kFormAction_EnableSummary	=  7,
	kFormAction_SaveSettings	=  8,
};

const ushort kCheckBoxMask_ProcEnable		= (0b0001);
const ushort kCheckBoxMask_DocEnable		= (0b0010);
const ushort kCheckBoxMask_SummaryEnable	= (0b0100);
const ushort kCheckBoxMask_SaveSettings		= (0b1000);

// Settings serialization

typedef enum : uint32_t {
	kItemTag_ConfigFile,
	kItemTag_HintGroups,
	kItemTag_EnableProc,
	kItemTag_EnableHints,
	kItemTag_EnableSummary,
	kItemTag_Terminator,
} ItemTag;

struct Element
{
	uint32_t	size;
	ItemTag		tag;
};

struct BlobHeader : Element {
	uint32_t version;
};

struct ItemHeader : Element {
	uint32_t 	num;
};

struct ItemBool : ItemHeader {
	uint32_t	value;
};

const uint32_t kSettingsBlobVersion 	= 0x0100;
const ItemTag kSettingsBlobHeaderTag 	= ItemTag('frnd');

///

#if IDA_SDK_VERSION >= 700

struct group_chooser_t : public chooser_multi_t
{
public:
	group_chooser_t(Documentation* doc)
		: chooser_multi_t(CH_KEEP, 1, kWidths, kHeaders), m_doc(doc)
	{height = 10;}
	
	~group_chooser_t()
	{}
	
	size_t idaapi get_count() const override
	{
		if (m_doc == nullptr)
			return 0;
		
		return m_doc->getGroupCount();
	}

	void idaapi get_row(qstrvec_t *cols,
						int *icon_,
						chooser_item_attrs_t *attrs,
						size_t n) const override
	{
		qstrvec_t &cols_array = *cols;

		if (m_doc == nullptr)
		{
			cols_array[0][0] = '\0';
			return;
		}

		cols_array[0].sprnt("%s", m_doc->getGroupName(n));
	}
	
private:
	
	const int kWidths[1] = { 45 };
	const char* kHeaders[1] = { "Element groups" };
	
	Documentation* m_doc = nullptr;
};


#endif

///

int idaapi Settings::s_formCallback(int fid, form_actions_t &fa)
{
	switch ( fid )
	{
		case kFormAction_Init:
		{
			break;
		}
		case kFormAction_Term:
		{
			break;
		}
		case kFormAction_ConfigFile:
		{
			Documentation* doc = (Documentation*)fa.get_ud();
			if (doc == nullptr)
				break;

			char configPath[MAXSTR] = {0};
			fa.get_path_value(fid, configPath, MAXSTR);
			
			std::string path(configPath);
			
			if (path != "")
				doc->loadConfigFile(path);
			else
				doc->resetConfigFile();
			
			fa.refresh_field(kFormAction_HintGroups);
			break;
		}
		case kFormAction_HintGroups:
		{
			break;
		}
		case kFormAction_EnableProc:
		{
			break;
		}
		case kFormAction_EnableHints:
		{
			break;
		}
		case kFormAction_EnableSummary:
		{
			break;
		}
		case kFormAction_SaveSettings:
		{
			break;
		}
		default:
			break;
	}
	
	return 1;
}

bool Settings::show()
{
	Documentation* doc = nullptr;
	ProcExtender* proc = nullptr;
	
	if (m_delegate)
	{
		doc = m_delegate->getDocumentation();
		proc = m_delegate->getProcExtender();
	}
	
	char configPath[MAXSTR] = {0};

	static const char form[] =
	"STARTITEM 0\n"
	"FRIEND Settings\n\n"
	"%/%*"
	"              Flexible Register/Instruction Extender aNd Documentation\n"
	"<XML Config\\::f3:0:43::>"
	"\n"
	"<:E4::55::>\n\n"
	"<Enable Processor Extender:C5>\n"
	"<Enable Hints:C6>\n"
	"<Enable Function Summary:C7>\n"
	"<Save Settings in IDB:C8>>\n"
	"\n";

	// set config file
	qstrncpy(configPath, m_configPath.c_str(), MAXSTR);
	
	// set hint group chooser
#if IDA_SDK_VERSION >= 700
	group_chooser_t group_chooser(doc);
#else
	static const int widths[] = { 55 };
	
	chooser_info_t group_chooser;
	memset(&group_chooser, 0, sizeof(chooser_info_t));
	group_chooser.cb = sizeof(chooser_info_t);
	group_chooser.flags = CH_NOIDB | CH_MULTI;
	group_chooser.icon = -1;
	group_chooser.columns = 1;
	group_chooser.widths = widths;
	group_chooser.obj = doc;
	group_chooser.sizer = [] (void *obj) -> uint32 {
		Documentation* doc = (Documentation*)obj;
		if (doc == nullptr)
			return 0;
		
		return doc->getGroupCount();
	};
	group_chooser.getl = [] (void *obj, uint32 n, char *const *arrptr) {
		if ( n == 0 ) // generate the column headers
		{
			qstrncpy(arrptr[0], "Element groups", MAXSTR);
			return;
		}
		
		Documentation* doc = (Documentation*)obj;
		if (doc == nullptr)
		{
			arrptr[0][0] = 0;
			return;
		}
		
		qsnprintf(arrptr[0], MAXSTR, "%s", doc->getGroupName(n-1));
	};
#endif
	
	idaapi_chooser_sel_t group_select;
	
	//
	if (doc && doc->getGroupCount() != 0)
	{
		for (uint32_t i = 0; i < doc->getGroupCount(); i++)
		{
			if (doc->isGroupEnabled(i)) {
				group_select.push_back(idaapi_chooser_sel_base + i);
			}
		}
	}

	ushort checkboxMask = 0;
	checkboxMask |= (m_procEnabled)? kCheckBoxMask_ProcEnable : 0;
	checkboxMask |= (m_docEnabled)? kCheckBoxMask_DocEnable : 0;
	checkboxMask |= (m_summaryEnabled)? kCheckBoxMask_SummaryEnable : 0;
	checkboxMask |= (m_saveSettings)? kCheckBoxMask_SaveSettings : 0;
	
	if ( IDAAPI_AskForm(form,
						s_formCallback, doc,
						configPath,
						&group_chooser, &group_select,
						&checkboxMask) > 0 )
	{
		if (doc)
		{
			doc->disableAllGroups();
			for (auto index : group_select)
			{
				doc->setGroupEnabled(index - idaapi_chooser_sel_base);
			}
		}
		
		bool procEnabled = checkboxMask & kCheckBoxMask_ProcEnable;
		bool docEnabled = checkboxMask & kCheckBoxMask_DocEnable;
		bool summaryEnabled = checkboxMask & kCheckBoxMask_SummaryEnable;
		bool saveSettings = checkboxMask & kCheckBoxMask_SaveSettings;
		
		if (m_delegate)
		{
			if (docEnabled != m_docEnabled)
				m_delegate->setHintsEnabled(docEnabled);
			
			if (procEnabled != m_procEnabled)
				m_delegate->setProcExtenderEnabled(procEnabled);
			
			if (summaryEnabled != m_summaryEnabled)
				m_delegate->setFuncSummaryEnabled(summaryEnabled);
			
			if ((saveSettings != m_saveSettings) && (saveSettings == false))
				m_delegate->deleteSettingsBlob();
		}

		m_docEnabled = docEnabled;
		m_procEnabled = procEnabled;
		m_summaryEnabled = summaryEnabled;
		m_saveSettings = saveSettings;

		m_configPath = std::string(configPath);
		
		if (m_delegate && m_saveSettings)
		{
			// serialize settings
			int32_t blobSize = 0;
			blobSize += sizeof(BlobHeader);												// blob header
			blobSize += sizeof(ItemHeader) + m_configPath.size() + 1;					// config file path + '\0'
			blobSize += sizeof(ItemHeader) + (group_select.size() * sizeof(uint32_t));	// selected hint groups
			blobSize += sizeof(ItemBool);												// processor extentsion flag
			blobSize += sizeof(ItemBool);												// hints flag
			blobSize += sizeof(ItemBool);												// function summary flag
			blobSize += sizeof(ItemHeader);												// terminator
			
			uint8_t* blob = new uint8_t[blobSize];
			memset(blob, 0, blobSize);
			
			uint8_t* blob_ptr = blob;
			
			// Blob header
			BlobHeader* blob_hdr = (BlobHeader*)blob_ptr;
			blob_hdr->size = sizeof(BlobHeader);
			blob_hdr->tag = kSettingsBlobHeaderTag;
			blob_hdr->version = kSettingsBlobVersion;
			blob_ptr += blob_hdr->size;
			
			// config file path
			ItemHeader* item_config = (ItemHeader*)blob_ptr;
			item_config->size = sizeof(ItemHeader) + m_configPath.size() + 1;
			item_config->tag = kItemTag_ConfigFile;
			item_config->num = 1;
			memcpy(blob_ptr + sizeof(ItemHeader), m_configPath.c_str(), m_configPath.size());
			blob_ptr += item_config->size;
			
			// selected hint groups
			ItemHeader* item_hints = (ItemHeader*)blob_ptr;
			item_hints->size = sizeof(ItemHeader) + (group_select.size() * sizeof(uint32_t));
			item_hints->tag = kItemTag_HintGroups;
			item_hints->num = group_select.size();
			uint32_t* group_ptr = (uint32_t*)(blob_ptr + sizeof(ItemHeader));
			for (auto index : group_select)
			{
				*group_ptr = index - idaapi_chooser_sel_base;
				group_ptr++;
			}
			blob_ptr += item_hints->size;
			
			// processor extension flag
			ItemBool* item_procflag = (ItemBool*)blob_ptr;
			item_procflag->size = sizeof(ItemBool);
			item_procflag->tag = kItemTag_EnableProc;
			item_procflag->num = 1;
			item_procflag->value = m_procEnabled? 1 : 0;
			blob_ptr += item_procflag->size;

			// hints flag
			ItemBool* item_hintflag = (ItemBool*)blob_ptr;
			item_hintflag->size = sizeof(ItemBool);
			item_hintflag->tag = kItemTag_EnableHints;
			item_hintflag->num = 1;
			item_hintflag->value = m_docEnabled? 1 : 0;
			blob_ptr += item_hintflag->size;

			// function summary flag
			ItemBool* item_summflag = (ItemBool*)blob_ptr;
			item_summflag->size = sizeof(ItemBool);
			item_summflag->tag = kItemTag_EnableSummary;
			item_summflag->num = 1;
			item_summflag->value = m_summaryEnabled? 1 : 0;
			blob_ptr += item_summflag->size;

			// terminator
			ItemHeader* terminator = (ItemHeader*)blob_ptr;
			terminator->size = sizeof(ItemHeader);
			terminator->tag = kItemTag_Terminator;
			blob_ptr += terminator->size;
			
			m_delegate->saveSettingsBlob(blob, blobSize);
			
			delete[] blob;
		}
		
		return true;
	}
	
	return false;
}

void Settings::load()
{
	if (m_delegate == nullptr)
		return;
	
	int32_t size;
	if (m_delegate->getSettingsBlobSize(size) == false)
		return;
	
	uint8_t* blob = new uint8_t[size];

	m_delegate->loadSettingsBlob(blob, size);

	// unzerialize settings
	
	Documentation* doc = m_delegate->getDocumentation();
	
	if (((BlobHeader*)blob)->tag != kSettingsBlobHeaderTag) {
		delete[] blob;
		return;
	}
	
	uint8_t* blob_ptr = blob;
	while (blob_ptr < (blob + size))
	{
		Element* e = (Element*)blob_ptr;
		
		if (e->tag == kItemTag_Terminator)
			break;
		
		switch (e->tag)
		{
			case kItemTag_ConfigFile:
			{
				m_configPath = std::string((char*)(blob_ptr + sizeof(ItemHeader)));
				doc->loadConfigFile(m_configPath);
				break;
			}
			case kItemTag_HintGroups:
			{
				if (doc->getGroupCount() == 0)
					break;
				
				ItemHeader* item_hints = (ItemHeader*)e;
				uint32_t* group_ptr = (uint32_t*)(blob_ptr + sizeof(ItemHeader));
				doc->disableAllGroups();

				while (item_hints->num)
				{
					doc->setGroupEnabled(*group_ptr);
					item_hints->num--;
					group_ptr++;
				}
				break;
			}
			case kItemTag_EnableProc:
			{
				ItemBool* item_procflag = (ItemBool*)blob_ptr;

				m_procEnabled = (item_procflag->value != 0)? true : false;
				m_delegate->setProcExtenderEnabled(m_procEnabled);
				
				break;
			}
			case kItemTag_EnableHints:
			{
				ItemBool* item_hintflag = (ItemBool*)blob_ptr;
				
				m_docEnabled = (item_hintflag->value != 0)? true : false;
				m_delegate->setHintsEnabled(m_docEnabled);

				break;
			}
			case kItemTag_EnableSummary:
			{
				ItemBool* item_summflag = (ItemBool*)blob_ptr;

				m_summaryEnabled = (item_summflag->value != 0)? true : false;
				m_delegate->setFuncSummaryEnabled(m_summaryEnabled);

				break;
			}
			default:
				break;
		}
		
		blob_ptr += e->size;
	}
	
	delete[] blob;
	
	m_saveSettings = true;
}

```

`FRIEND/Settings.hpp`:

```hpp
//
//  Settings.hpp
//  Flexible Register/Instruction Extender aNd Documentation
//
//  Created by Alexander Hude on 11/11/2016.
//  Copyright © 2017 Alexander Hude. All rights reserved.
//

#pragma once

#include <string>

class PluginDelegate;

class Settings
{
public:
	
	Settings() {}
	
	void		setDelegate(PluginDelegate* delegate) {m_delegate = delegate;}
	void		load();
	bool		show();
	
private:
	
	static int idaapi s_formCallback(int fid, form_actions_t &fa);

private:
	
	PluginDelegate* m_delegate;
	
	std::string	m_configPath;
	
	bool		m_procEnabled = false;
	bool		m_docEnabled = false;
	bool		m_summaryEnabled = false;
	bool		m_saveSettings = false;
};

```

`HintEditor/Dependencies/AEXML.framework/Versions/A/Headers/AEXML-Swift.h`:

```h
#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.4 (swiftlang-1205.0.26.9 clang-1205.0.19.55)
#ifndef AEXML_SWIFT_H
#define AEXML_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="AEXML",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSXMLParser;
@class NSString;

/// Simple wrapper around <code>Foundation.XMLParser</code>.
SWIFT_CLASS("_TtC5AEXML11AEXMLParser")
@interface AEXMLParser : NSObject <NSXMLParserDelegate>
- (void)parser:(NSXMLParser * _Nonnull)parser didStartElement:(NSString * _Nonnull)elementName namespaceURI:(NSString * _Nullable)namespaceURI qualifiedName:(NSString * _Nullable)qName attributes:(NSDictionary<NSString *, NSString *> * _Nonnull)attributeDict;
- (void)parser:(NSXMLParser * _Nonnull)parser foundCharacters:(NSString * _Nonnull)string;
- (void)parser:(NSXMLParser * _Nonnull)parser didEndElement:(NSString * _Nonnull)elementName namespaceURI:(NSString * _Nullable)namespaceURI qualifiedName:(NSString * _Nullable)qName;
- (void)parser:(NSXMLParser * _Nonnull)parser parseErrorOccurred:(NSError * _Nonnull)parseError;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.4 (swiftlang-1205.0.26.9 clang-1205.0.19.55)
#ifndef AEXML_SWIFT_H
#define AEXML_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="AEXML",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSXMLParser;
@class NSString;

/// Simple wrapper around <code>Foundation.XMLParser</code>.
SWIFT_CLASS("_TtC5AEXML11AEXMLParser")
@interface AEXMLParser : NSObject <NSXMLParserDelegate>
- (void)parser:(NSXMLParser * _Nonnull)parser didStartElement:(NSString * _Nonnull)elementName namespaceURI:(NSString * _Nullable)namespaceURI qualifiedName:(NSString * _Nullable)qName attributes:(NSDictionary<NSString *, NSString *> * _Nonnull)attributeDict;
- (void)parser:(NSXMLParser * _Nonnull)parser foundCharacters:(NSString * _Nonnull)string;
- (void)parser:(NSXMLParser * _Nonnull)parser didEndElement:(NSString * _Nonnull)elementName namespaceURI:(NSString * _Nullable)namespaceURI qualifiedName:(NSString * _Nullable)qName;
- (void)parser:(NSXMLParser * _Nonnull)parser parseErrorOccurred:(NSError * _Nonnull)parseError;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#endif

```

`HintEditor/Dependencies/AEXML.framework/Versions/A/Headers/AEXML.h`:

```h
/**
 *  https://github.com/tadija/AEXML
 *  Copyright © Marko Tadić 2014-2021
 *  Licensed under the MIT license
 */

#import <Foundation/Foundation.h>

FOUNDATION_EXPORT double AEXMLVersionNumber;
FOUNDATION_EXPORT const unsigned char AEXMLVersionString[];

```

`HintEditor/Dependencies/AEXML.framework/Versions/A/Modules/module.modulemap`:

```modulemap
framework module AEXML {
  umbrella header "AEXML.h"

  export *
  module * { export * }
}

module AEXML.Swift {
    header "AEXML-Swift.h"
    requires objc
}

```

`HintEditor/Dependencies/AEXML.framework/Versions/A/Resources/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>BuildMachineOSBuild</key>
	<string>20G730</string>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleExecutable</key>
	<string>AEXML</string>
	<key>CFBundleIdentifier</key>
	<string>net.tadija.AEXML</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>AEXML</string>
	<key>CFBundlePackageType</key>
	<string>FMWK</string>
	<key>CFBundleShortVersionString</key>
	<string>4.6.1</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleSupportedPlatforms</key>
	<array>
		<string>MacOSX</string>
	</array>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>DTCompiler</key>
	<string>com.apple.compilers.llvm.clang.1_0</string>
	<key>DTPlatformBuild</key>
	<string>12E262</string>
	<key>DTPlatformName</key>
	<string>macosx</string>
	<key>DTPlatformVersion</key>
	<string>11.3</string>
	<key>DTSDKBuild</key>
	<string>20E214</string>
	<key>DTSDKName</key>
	<string>macosx11.3</string>
	<key>DTXcode</key>
	<string>1250</string>
	<key>DTXcodeBuild</key>
	<string>12E262</string>
	<key>LSMinimumSystemVersion</key>
	<string>10.10</string>
</dict>
</plist>

```

`HintEditor/Dependencies/AEXML.framework/Versions/A/_CodeSignature/CodeResources`:

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>files</key>
	<dict>
		<key>Resources/Info.plist</key>
		<data>
		pUBaQuLbCDmRgaeeawxiDCxRxuw=
		</data>
	</dict>
	<key>files2</key>
	<dict>
		<key>Headers/AEXML-Swift.h</key>
		<dict>
			<key>hash</key>
			<data>
			F/ONBxa1mQ5GwHsuG0gDWFa12bE=
			</data>
			<key>hash2</key>
			<data>
			0PiNgzu2/exXzrg4UgHP67++Ud/XdB1Fnaw7+Wy5d88=
			</data>
		</dict>
		<key>Headers/AEXML.h</key>
		<dict>
			<key>hash</key>
			<data>
			mqS6oVXd8m9FkjQqXn5yeBXxp48=
			</data>
			<key>hash2</key>
			<data>
			1qmapgYsXDPGdxz0dtzKuQrjj/kaXAnnmVHiSupsncI=
			</data>
		</dict>
		<key>Modules/AEXML.swiftmodule/Project/arm64-apple-macos.swiftsourceinfo</key>
		<dict>
			<key>hash</key>
			<data>
			uE4ikm6K0907oL7CFvC3wd5KHi4=
			</data>
			<key>hash2</key>
			<data>
			YspbQsnSNj5vsbpzxgRF/ESoqwmAipAe3Nq1KNIkuIw=
			</data>
		</dict>
		<key>Modules/AEXML.swiftmodule/Project/arm64.swiftsourceinfo</key>
		<dict>
			<key>hash</key>
			<data>
			uE4ikm6K0907oL7CFvC3wd5KHi4=
			</data>
			<key>hash2</key>
			<data>
			YspbQsnSNj5vsbpzxgRF/ESoqwmAipAe3Nq1KNIkuIw=
			</data>
		</dict>
		<key>Modules/AEXML.swiftmodule/Project/x86_64-apple-macos.swiftsourceinfo</key>
		<dict>
			<key>hash</key>
			<data>
			CCR5HrB41h+HmLH4fI4u6a+fxV8=
			</data>
			<key>hash2</key>
			<data>
			Rs4ZL5kbzXXn2wkZlyZGOvl9dJqIF+q2IrIEC0DwAgM=
			</data>
		</dict>
		<key>Modules/AEXML.swiftmodule/Project/x86_64.swiftsourceinfo</key>
		<dict>
			<key>hash</key>
			<data>
			CCR5HrB41h+HmLH4fI4u6a+fxV8=
			</data>
			<key>hash2</key>
			<data>
			Rs4ZL5kbzXXn2wkZlyZGOvl9dJqIF+q2IrIEC0DwAgM=
			</data>
		</dict>
		<key>Modules/AEXML.swiftmodule/arm64-apple-macos.swiftdoc</key>
		<dict>
			<key>hash</key>
			<data>
			ymcAjp530hGqQh9T97SMmVCQTxQ=
			</data>
			<key>hash2</key>
			<data>
			qScgWagtcEdiFO16YUweSeIcGw2VorIRvYGtCGuxWHw=
			</data>
		</dict>
		<key>Modules/AEXML.swiftmodule/arm64-apple-macos.swiftmodule</key>
		<dict>
			<key>hash</key>
			<data>
			wD38u+cbEnH2wIV70MgJfAQw3VY=
			</data>
			<key>hash2</key>
			<data>
			/bnbWOC9vRrMnJPvmzOW4C8A5kjR8BzDZc4ExCYULy8=
			</data>
		</dict>
		<key>Modules/AEXML.swiftmodule/arm64.swiftdoc</key>
		<dict>
			<key>hash</key>
			<data>
			ymcAjp530hGqQh9T97SMmVCQTxQ=
			</data>
			<key>hash2</key>
			<data>
			qScgWagtcEdiFO16YUweSeIcGw2VorIRvYGtCGuxWHw=
			</data>
		</dict>
		<key>Modules/AEXML.swiftmodule/arm64.swiftmodule</key>
		<dict>
			<key>hash</key>
			<data>
			wD38u+cbEnH2wIV70MgJfAQw3VY=
			</data>
			<key>hash2</key>
			<data>
			/bnbWOC9vRrMnJPvmzOW4C8A5kjR8BzDZc4ExCYULy8=
			</data>
		</dict>
		<key>Modules/AEXML.swiftmodule/x86_64-apple-macos.swiftdoc</key>
		<dict>
			<key>hash</key>
			<data>
			Jx7Y6JBCE1536N1czG+SnNhiIyo=
			</data>
			<key>hash2</key>
			<data>
			WKuP4Y2URQCfgRPma2JEvQooIWv+W8o4+UItLHDAffI=
			</data>
		</dict>
		<key>Modules/AEXML.swiftmodule/x86_64-apple-macos.swiftmodule</key>
		<dict>
			<key>hash</key>
			<data>
			xY3hyGcQFvMpCfT0+5ctAiovQLo=
			</data>
			<key>hash2</key>
			<data>
			c0MiGOtjWs3FYd2ITlQ6IEDZMoUteTmXqrsUMwLKrfA=
			</data>
		</dict>
		<key>Modules/AEXML.swiftmodule/x86_64.swiftdoc</key>
		<dict>
			<key>hash</key>
			<data>
			Jx7Y6JBCE1536N1czG+SnNhiIyo=
			</data>
			<key>hash2</key>
			<data>
			WKuP4Y2URQCfgRPma2JEvQooIWv+W8o4+UItLHDAffI=
			</data>
		</dict>
		<key>Modules/AEXML.swiftmodule/x86_64.swiftmodule</key>
		<dict>
			<key>hash</key>
			<data>
			xY3hyGcQFvMpCfT0+5ctAiovQLo=
			</data>
			<key>hash2</key>
			<data>
			c0MiGOtjWs3FYd2ITlQ6IEDZMoUteTmXqrsUMwLKrfA=
			</data>
		</dict>
		<key>Modules/module.modulemap</key>
		<dict>
			<key>hash</key>
			<data>
			cZUUf9ehCd+e7jSzNCrQUpwL764=
			</data>
			<key>hash2</key>
			<data>
			4Xc56AdOOTcEqrYSruzU6mMYadjB+Cng/HGI7kixfzU=
			</data>
		</dict>
		<key>Resources/Info.plist</key>
		<dict>
			<key>hash</key>
			<data>
			pUBaQuLbCDmRgaeeawxiDCxRxuw=
			</data>
			<key>hash2</key>
			<data>
			Jpo9vpqYQTPnB0nk/rbEz4FSgC2zDS+5X+davquzRUI=
			</data>
		</dict>
	</dict>
	<key>rules</key>
	<dict>
		<key>^Resources/</key>
		<true/>
		<key>^Resources/.*\.lproj/</key>
		<dict>
			<key>optional</key>
			<true/>
			<key>weight</key>
			<real>1000</real>
		</dict>
		<key>^Resources/.*\.lproj/locversion.plist$</key>
		<dict>
			<key>omit</key>
			<true/>
			<key>weight</key>
			<real>1100</real>
		</dict>
		<key>^Resources/Base\.lproj/</key>
		<dict>
			<key>weight</key>
			<real>1010</real>
		</dict>
		<key>^version.plist$</key>
		<true/>
	</dict>
	<key>rules2</key>
	<dict>
		<key>.*\.dSYM($|/)</key>
		<dict>
			<key>weight</key>
			<real>11</real>
		</dict>
		<key>^(.*/)?\.DS_Store$</key>
		<dict>
			<key>omit</key>
			<true/>
			<key>weight</key>
			<real>2000</real>
		</dict>
		<key>^(Frameworks|SharedFrameworks|PlugIns|Plug-ins|XPCServices|Helpers|MacOS|Library/(Automator|Spotlight|LoginItems))/</key>
		<dict>
			<key>nested</key>
			<true/>
			<key>weight</key>
			<real>10</real>
		</dict>
		<key>^.*</key>
		<true/>
		<key>^Info\.plist$</key>
		<dict>
			<key>omit</key>
			<true/>
			<key>weight</key>
			<real>20</real>
		</dict>
		<key>^PkgInfo$</key>
		<dict>
			<key>omit</key>
			<true/>
			<key>weight</key>
			<real>20</real>
		</dict>
		<key>^Resources/</key>
		<dict>
			<key>weight</key>
			<real>20</real>
		</dict>
		<key>^Resources/.*\.lproj/</key>
		<dict>
			<key>optional</key>
			<true/>
			<key>weight</key>
			<real>1000</real>
		</dict>
		<key>^Resources/.*\.lproj/locversion.plist$</key>
		<dict>
			<key>omit</key>
			<true/>
			<key>weight</key>
			<real>1100</real>
		</dict>
		<key>^Resources/Base\.lproj/</key>
		<dict>
			<key>weight</key>
			<real>1010</real>
		</dict>
		<key>^[^/]+$</key>
		<dict>
			<key>nested</key>
			<true/>
			<key>weight</key>
			<real>10</real>
		</dict>
		<key>^embedded\.provisionprofile$</key>
		<dict>
			<key>weight</key>
			<real>20</real>
		</dict>
		<key>^version\.plist$</key>
		<dict>
			<key>weight</key>
			<real>20</real>
		</dict>
	</dict>
</dict>
</plist>

```

`HintEditor/HintEditor/AppDelegate.swift`:

```swift
//
//  AppDelegate.swift
//  HintEditor
//
//  Created by Alexander Hude on 10/11/2016.
//  Copyright © 2016 Fried Apple. All rights reserved.
//

import Cocoa
import AEXML

@NSApplicationMain
class AppDelegate: NSObject, NSApplicationDelegate {
	
	@IBOutlet weak var window: NSWindow!
	
	func applicationDidFinishLaunching(_ aNotification: Notification) {
		// Insert code here to initialize your application
	}
	
	func applicationWillTerminate(_ aNotification: Notification) {
		// Insert code here to tear down your application
	}
	
	func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
		return true
	}
	
}


```

`HintEditor/HintEditor/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.3)
project(HintEditor Swift)

include(BundleUtilities)

set(CMAKE_Swift_LANGUAGE_VERSION 5)

# use latest macOS SDK
set(CMAKE_OSX_SYSROOT "macosx")

# set minimum deployment target
set(CMAKE_OSX_DEPLOYMENT_TARGET "10.10")

set(
    HEADERS
    HintEditor-Bridging-Header.h
)

set(
    SOURCES
    AppDelegate.swift
    ViewController.swift
)

set(
    STORYBOARDS
    storyboards/Main.storyboard
)

# Create the app target
add_executable(
    ${PROJECT_NAME}
    MACOSX_BUNDLE
    ${HEADERS}
    ${SOURCES}
    ${STORYBOARDS}
)

# Find AEXML
find_library(
    FRAMEWORK_AEXML
    NAMES AEXML
    PATHS ${PROJECT_SOURCE_DIR}/../Dependencies
    REQUIRED
)

# Link the app to AEXML
target_link_libraries(
    ${PROJECT_NAME}
    ${FRAMEWORK_AEXML}
)

# Set app properties
set_property(
    TARGET
    ${PROJECT_NAME}
    PROPERTY XCODE_ATTRIBUTE_SWIFT_OBJC_BRIDGING_HEADER
    "HintEditor-Bridging-Header.h"
)

set_target_properties(
    ${PROJECT_NAME}
    PROPERTIES
    MACOSX_BUNDLE YES
    RESOURCE "${STORYBOARDS}"
    
    MACOSX_BUNDLE_INFO_PLIST "${PROJECT_SOURCE_DIR}/Info.plist"
    # Set the app's linker search path to the default location on iOS
    XCODE_ATTRIBUTE_LD_RUNPATH_SEARCH_PATHS "@executable_path/../Frameworks"
)

# Create Frameworks directory in app bundle
set_target_properties(
    ${PROJECT_NAME}
    PROPERTIES
    XCODE_ATTRIBUTE_PRODUCT_NAME
    "${PROJECT_NAME}"
    XCODE_ATTRIBUTE_BUNDLE_IDENTIFIER
    "com.FriedApple.${PROJECT_NAME}"
)

# Copy the framework into the bundle
add_custom_command(
    TARGET
    ${PROJECT_NAME}
    POST_BUILD COMMAND ${CMAKE_COMMAND} -E make_directory
    ${PROJECT_BINARY_DIR}/$<CONFIG>${CMAKE_XCODE_EFFECTIVE_PLATFORMS}/${PROJECT_NAME}.app/Contents/Frameworks/
)

# Copy the framework into the bundle
add_custom_command(
    TARGET
    ${PROJECT_NAME}
    POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_directory
    ${PROJECT_SOURCE_DIR}/../Dependencies/
    ${PROJECT_BINARY_DIR}/$<CONFIG>${CMAKE_XCODE_EFFECTIVE_PLATFORMS}/${PROJECT_NAME}.app/Contents/Frameworks/
)

```

`HintEditor/HintEditor/HintEditor-Bridging-Header.h`:

```h
//
//  Use this file to import your target's public headers that you would like to expose to Swift.
//

#import <Cocoa/Cocoa.h>

@interface NSTextView (Placeholder)

@property (nonatomic, retain) NSString *placeholderString;

@end

@implementation NSTextView (Placeholder)

@dynamic placeholderString;

@end

```

`HintEditor/HintEditor/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>Copyright © 2016 Fried Apple Team. All rights reserved.</string>
	<key>NSMainStoryboardFile</key>
	<string>Main</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>

```

`HintEditor/HintEditor/ViewController.swift`:

```swift
//
//  ViewController.swift
//  HintEditor
//
//  Created by Alexander Hude on 10/11/2016.
//  Copyright © 2016 Fried Apple. All rights reserved.
//

import Cocoa
import AEXML

// MARK: String escaping/unescaping

extension String
{
	func escapeEntities() -> String
	{
		return CFXMLCreateStringByEscapingEntities(nil, self as CFString, nil) as String
	}
	
	func unescapeEntities() -> String
	{
		return CFXMLCreateStringByUnescapingEntities(nil, self as CFString, nil) as String
	}
}

// MARK: InfoTextView class

class InfoTextView : NSTextView
{
	// replace TAB with spaces
	override func doCommand(by selector: Selector) {
		if selector == #selector(NSResponder.insertTab(_:))
		{
			let TAB = String(repeating: " ", count: 4)
            self.insertText(TAB, replacementRange: NSMakeRange(self.string.count, self.string.count))
		}
		else
		{
			super.doCommand(by: selector)
		}
	}
}

// MARK: PreviewTextField class

@IBDesignable
class PreviewTextView : NSTextView
{
	@IBInspectable override var backgroundColor: NSColor {
		didSet {
			layer?.backgroundColor = backgroundColor.cgColor
		}
	}
	
	@IBInspectable var hintHeaderColor: NSColor?
	
	@IBInspectable var hintInfoColor: NSColor?
	
#if TARGET_INTERFACE_BUILDER
	override func prepareForInterfaceBuilder()
	{
		self.string = ""
		var preview : String
		var attribute : NSMutableAttributedString
		
		// Generate header
		preview = " Instruction Header"
		attribute = NSMutableAttributedString.init(string: preview)
		let headerRange = (preview as NSString).range(of: preview)
		let boldFont = NSFontManager.shared().convert(self.font!, toHaveTrait: .boldFontMask)
		attribute.addAttribute(NSForegroundColorAttributeName, value: self.hintHeaderColor!, range: headerRange)
		attribute.addAttribute(NSFontAttributeName, value: boldFont, range: headerRange)
			
		self.textStorage?.append(attribute)
		
		preview = ""

		preview += " \n\n"
		
		let infoString =	" This is a placeholder for instruction description\n" +
							" Instuction operands:\n" +
							" - operand 1\n" +
							" - operand 2\n" +
							" - operand 3"
		preview += infoString
			
		attribute = NSMutableAttributedString.init(string: preview)
		let infoRange = (preview as NSString).range(of: preview)
		let unboldFont = NSFontManager.shared().convert(self.font!, toHaveTrait: .unboldFontMask)
		attribute.addAttribute(NSForegroundColorAttributeName, value: self.hintInfoColor!, range: infoRange)
		attribute.addAttribute(NSFontAttributeName, value: unboldFont, range: infoRange)
			
		self.textStorage?.append(attribute)
	}
#endif
}

// MARK: ViewController class

class ViewController: NSViewController
{
	class Hint
	{
		let token: String
		
		init(_ token: String)
		{
			self.token = token
		}
	}
	
	class Group
	{
		let name: String
		
		var hints: [Hint]!
		
		init(_ name: String)
		{
			self.name = name
			self.hints = []
		}
	}
	
	var elements : [Group] = []
	var elementsFiltered : [Group] = []
	var filterString: String = ""
	
	var xmlPath : String?
	var xmlDoc : AEXMLDocument?
	
	var filteredGroupIndex : Int? = nil
	var filteredHintIndex : Int? = nil
	var elementChanged = false
	
	@IBOutlet weak var elementsView: NSOutlineView!
	
	@IBOutlet weak var tokenField: NSTextField!
	@IBOutlet weak var docField: NSTextField!
	@IBOutlet weak var pageField: NSTextField!
	@IBOutlet weak var headerField: NSTextField!
	@IBOutlet var infoField: InfoTextView!
	@IBOutlet var previewField: PreviewTextView!
	
	@IBOutlet weak var saveButton: NSButton!
	@IBOutlet weak var addButton: NSButton!
	@IBOutlet weak var deleteButton: NSButton!
	
	@IBOutlet weak var searchField: NSSearchField!
	// MARK: local methods
	
	func readHint(groupIndex: Int, hintIndex: Int)
	{
		let element = xmlDoc?.root["elements"]["group"].all![groupIndex]["hint"].all![hintIndex]
		
		if let id = element?.attributes["token"]
		{
			tokenField.stringValue = id
		}
		
		if let doc = element?.attributes["doc_id"]
		{
			docField.stringValue = doc
		}
		
		if let page = element?.attributes["page"]
		{
			pageField.stringValue = page
		}
		
		if let header = element?.attributes["header"]
		{
			headerField.stringValue = header.unescapeEntities()
		}
		
		if let info = element?.value
		{
			infoField.string = info
		}
		
		generatePreview()
		
		elementChanged = false
		
		updateButtonStates()
	}
	
	func clearFields()
	{
		for field in [ tokenField, docField, pageField, headerField ]
		{
			field?.stringValue = ""
		}
		
		for field in [ infoField, previewField ] as [NSTextView]
		{
			field.string = ""
		}
	}

	
	func generatePreview()
	{
		guard filteredGroupIndex != nil else {
			return
		}
		
		previewField.string = ""
		
		if headerField.stringValue != ""
		{
			let preview = " " + headerField.stringValue
			
			let attribute = NSMutableAttributedString.init(string: preview)
			let headerRange = (preview as NSString).range(of: preview)
            let boldFont = NSFontManager.shared.convert(previewField.font!, toHaveTrait: .boldFontMask)
            attribute.addAttribute(NSAttributedString.Key.foregroundColor, value: previewField.hintHeaderColor!, range: headerRange)
            attribute.addAttribute(NSAttributedString.Key.font, value: boldFont, range: headerRange)
			
			previewField.textStorage?.append(attribute)
		}
		
		if infoField.string != ""
		{
			var preview = ""
			
			if headerField.stringValue != ""
			{
				preview += " \n\n"
			}
			
			let kUnicode_LineSeparator = 0x2028
            let infoString = infoField.string.replacingOccurrences(of: String(describing: UnicodeScalar(kUnicode_LineSeparator)!), with: "\n ")
				.replacingOccurrences(of: "\n", with: "\n ")
				.replacingOccurrences(of: "\r", with: "\n ")
            preview += " " + infoString
			
			let attribute = NSMutableAttributedString.init(string: preview)
			let infoRange = (preview as NSString).range(of: preview)
            let unboldFont = NSFontManager.shared.convert(previewField.font!, toHaveTrait: .unboldFontMask)
            attribute.addAttribute(NSAttributedString.Key.foregroundColor, value: previewField.hintInfoColor!, range: infoRange)
            attribute.addAttribute(NSAttributedString.Key.font, value: unboldFont, range: infoRange)
			
			previewField.textStorage?.append(attribute)
		}
	}
	
	func filterHints(for string: String)
	{
		filteredGroupIndex = nil
		filteredHintIndex = nil
		
		elementsFiltered.removeAll()
		for group in elements
		{
			let newGroup = Group(group.name)

			newGroup.hints = group.hints.filter {
				string == "" || $0.token.localizedCaseInsensitiveContains(string)
			}
			
            elementsFiltered.append(newGroup)
		}
		
		filterString = string
		
		elementsView.reloadData()
	}
	
	func updateButtonStates()
	{
		guard filteredGroupIndex != nil else {
			
			// allow nothing
			saveButton.isEnabled = false
			addButton.isEnabled = false
			deleteButton.isEnabled = false
			
			return
		}
		
		let tokenEmpty = tokenField.stringValue.isEmpty
		
		if filteredHintIndex != nil
		{
			let tokenModified = tokenField.stringValue != elementsFiltered[filteredGroupIndex!].hints[filteredHintIndex!].token
			
			if tokenModified == true
			{
				if tokenEmpty == false
				{
					// allow to add element with token
					addButton.isEnabled = true
					
					saveButton.isEnabled = false
					deleteButton.isEnabled = false
				}
				else
				{
					// allow nothing
					saveButton.isEnabled = false
					addButton.isEnabled = false
					deleteButton.isEnabled = false
				}
			}
			else
			{
				// allow to save and delete element
				if elementChanged == false
				{
					saveButton.isEnabled = false
				}
				else
				{
					saveButton.isEnabled = true
				}
				deleteButton.isEnabled = true

				addButton.isEnabled = false
			}
			
			elementChanged = true
		}
		else
		{
			// group selected
			if tokenEmpty == false
			{
				// allow to add element with token
				addButton.isEnabled = true

				saveButton.isEnabled = false
				deleteButton.isEnabled = false
			}
			else
			{
				// allow nothing
				saveButton.isEnabled = false
				addButton.isEnabled = false
				deleteButton.isEnabled = false
			}
		}
	}
	
	// MARK: NSViewController initialization
	
	override func viewDidLoad() {
		super.viewDidLoad()
		
		// Do any additional setup after loading the view.
	
		infoField.placeholderString = "info"
		previewField.placeholderString = "preview"
		
		for textView in [ infoField, previewField ] as [NSTextView]
		{
			textView.textContainer!.widthTracksTextView  = false
			textView.textContainer!.heightTracksTextView = false
			textView.textContainer!.containerSize        = CGSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude)
		}
		
        let attributes = [NSAttributedString.Key.font: tokenField.font as Any]
		infoField.typingAttributes = attributes
		previewField.typingAttributes = attributes
		
		elementsView.sizeLastColumnToFit();
		
		updateButtonStates()
		
		DispatchQueue.main.async {
			self.tokenField.becomeFirstResponder()
		}
	}
	
	override var representedObject: Any? {
		didSet {
			// Update the view, if already loaded.
		}
	}

	// MARK: File menu handlers
	
	override var acceptsFirstResponder: Bool { return true }
	
	@IBAction func openDocument(_ sender: Any)
	{
		let fileDialog: NSOpenPanel = NSOpenPanel()
		fileDialog.allowsMultipleSelection = false
		fileDialog.allowsOtherFileTypes = false
		fileDialog.canChooseDirectories = false
		fileDialog.allowedFileTypes = ["xml"]
		fileDialog.runModal()
		
		guard
			let path = fileDialog.url?.path,
			let data = try? Data(contentsOf: URL(fileURLWithPath: path))
			else {
				return
		}

		clearFields()
		elements.removeAll()
		elementsFiltered.removeAll()
		filteredGroupIndex = nil
		filteredHintIndex = nil
		
		updateButtonStates()
		
		do
		{
			xmlDoc = try AEXMLDocument(xml: data)
			xmlPath = path

			guard let groups = xmlDoc?.root["elements"]["group"].all else {
				throw AEXMLError.elementNotFound
			}
			
			for group in groups
			{
				guard let name = group.attributes["name"] else {
					continue
				}
				
				let newGroup = Group(name)
				
				guard let hints = group["hint"].all else {
                    elements.append(newGroup)
                    continue
				}
				
				for token in hints
				{
					guard let id = token.attributes["token"] else {
						continue
					}
					
					newGroup.hints.append(Hint(id))
				}
				
				elements.append(newGroup)
			}
			
			filterHints(for: "")
		}
		catch
		{
			print("HintEditor: Unable to open XML file: \(error)")
		}

		elementsView.reloadData()
	}
	
	@IBAction func saveDocument(_ sender: Any)
	{
		guard xmlDoc != nil && xmlPath != nil else {
			return
		}

		do
		{
			try xmlDoc?.xml.write(to: URL(fileURLWithPath: xmlPath!), atomically: false, encoding: String.Encoding.utf8)
		}
		catch
		{
			print("HintEditor: Unable to write XML file: \(error)")
		}
	}
	
	@IBAction func performClose(_ sender: Any)
	{
		guard xmlDoc != nil else {
			return
		}
		
		clearFields()
		
		xmlPath = nil
		xmlDoc = nil
		
		elements.removeAll()
		elementsFiltered.removeAll()
		filteredGroupIndex = nil
		filteredHintIndex = nil
		
		updateButtonStates()
		
		elementsView.reloadData()
	}
	
	// MARK: Hint button handlers
	
	@IBAction func saveHint(_ sender: Any)
	{
		if tokenField.stringValue == elementsFiltered[filteredGroupIndex!].hints[filteredHintIndex!].token
		{
			// token is same, update element
			guard
                let realGroupIdx = elements.firstIndex(where: {$0.name == elementsFiltered[filteredGroupIndex!].name}),
                let realHintIdx = elements[realGroupIdx].hints.firstIndex(where: {$0.token == tokenField.stringValue})
			else
			{
				return
			}

			guard let element = xmlDoc?.root["elements"]["group"].all![realGroupIdx]["hint"].all![realHintIdx] else {
				addHint(sender)
				return
			}
			
			element.attributes["token"] = tokenField.stringValue
			element.attributes["doc_id"] = docField.stringValue
			element.attributes["page"] = pageField.stringValue
			element.attributes["header"] = headerField.stringValue
			
			let kUnicode_LineSeparator = 0x2028
            element.value = infoField.string.replacingOccurrences(of: String(describing: UnicodeScalar(kUnicode_LineSeparator)!), with: "\n")
				.replacingOccurrences(of: "\r", with: "\n")
			
			elementChanged = false
			saveButton.isEnabled = false
		}
		else
		{
			// token has changed, create new element
			addHint(sender)
		}
	}
	
	@IBAction func addHint(_ sender: Any)
	{
		guard filteredGroupIndex != nil else {
			return
		}

		guard
            let realGroupIdx = elements.firstIndex(where: {$0.name == elementsFiltered[filteredGroupIndex!].name}),
			let group = xmlDoc?.root["elements"]["group"].all![realGroupIdx]
		else
		{
			return
		}
		
        if let hints = group["hint"].all(withAttributes: ["token" : tokenField.stringValue])
		{
            if !hints.isEmpty
            {
                print("HintEditor: Hint with id=\"\(tokenField.stringValue)\" already exists!")
                return
            }
		}
		
		let attributes = [
			"token":	tokenField.stringValue,
			"doc_id":	docField.stringValue,
			"page":		pageField.stringValue,
			"header":	headerField.stringValue
		]
		
		// fix line breaks
		let kUnicode_LineSeparator = 0x2028
        let infoString = infoField.string.replacingOccurrences(of: String(describing: UnicodeScalar(kUnicode_LineSeparator)!), with: "\n")
			.replacingOccurrences(of: "\r", with: "\n")
		
		let newHint = Hint(tokenField.stringValue)
		var filteredHint : Hint?
		
		if filteredHintIndex == nil
		{
			// insert first
			group.addChild(name: "hint", value: infoString, attributes:attributes, at:0)
			
			elements[realGroupIdx].hints!.insert(newHint, at:0)
			
			// check if new token matches search filter
			if searchField.stringValue.isEmpty == true ||
				tokenField.stringValue.localizedCaseInsensitiveContains(searchField.stringValue)
			{
				filteredHint = Hint(tokenField.stringValue)
				filteredHintIndex = 0
			}
		}
		else
		{
			let selectedHintToken = elementsFiltered[filteredGroupIndex!].hints[filteredHintIndex!].token
            guard let realHintIdx = elements[realGroupIdx].hints.firstIndex(where: {$0.token == selectedHintToken}) else {
				return
			}
			
			// insert after currentHintIndex
			group.addChild(name: "hint", value: infoString, attributes:attributes, at:realHintIdx + 1)
			
			elements[realGroupIdx].hints!.insert(newHint, at:realHintIdx + 1)

			// check if new token matches search filter
			if searchField.stringValue.isEmpty == true ||
				tokenField.stringValue.localizedCaseInsensitiveContains(searchField.stringValue)
			{
				filteredHint = Hint(tokenField.stringValue)
				filteredHintIndex! += 1
			}
		}
		
		if filteredHint != nil
		{
			elementsFiltered[filteredGroupIndex!].hints!.insert(filteredHint!, at:filteredHintIndex!)
			elementsView.reloadData()
		}
		else
		{
			guard
                let groupIdx = elements.firstIndex(where: {$0.name == elementsFiltered[filteredGroupIndex!].name}),
                let hintIdx = elements[realGroupIdx].hints.firstIndex(where: {$0.token == tokenField.stringValue})
			else
			{
				return
			}

			// reset search filter
			searchField.stringValue = ""
			filterHints(for: searchField.stringValue)
			
			filteredGroupIndex = groupIdx
			filteredHintIndex = hintIdx
			
			elementsView.reloadData()
			
			elementsView.expandItem(elementsFiltered[groupIdx], expandChildren: false)
			filteredHint = elementsFiltered[groupIdx].hints[hintIdx]
		}

		// move selection to the new element
		DispatchQueue.main.async {
			let rowIndex = self.elementsView.row(forItem: filteredHint)
			if rowIndex != -1
			{
				self.elementsView.selectRowIndexes(IndexSet(integer:rowIndex), byExtendingSelection: false)
			}
		}
	}
	
	@IBAction func deleteHint(_ sender: Any)
	{
		guard
			filteredGroupIndex != nil,
			filteredHintIndex != nil,
            let realGroupIdx = elements.firstIndex(where: {$0.name == elementsFiltered[filteredGroupIndex!].name}),
            let realHintIdx = elements[realGroupIdx].hints.firstIndex(where: {$0.token == tokenField.stringValue}),
			let element = xmlDoc?.root["elements"]["group"].all![realGroupIdx]["hint"].all![realHintIdx]
		else {
			return
		}
		
		clearFields()
		
		element.removeFromParent()
		elements[realGroupIdx].hints!.remove(at: realHintIdx)
		elementsFiltered[filteredGroupIndex!].hints!.remove(at: filteredHintIndex!)

		clearFields()
	
		filteredGroupIndex = nil
		filteredHintIndex = nil
		
		updateButtonStates()
		
		elementsView.reloadData()
	}

	@IBAction func searchHint(_ sender: Any)
	{
		clearFields();
		
		updateButtonStates()
		
		filterHints(for: (sender as! NSSearchField).stringValue)
	}
}

// MARK: NSTextFieldDelegate

extension ViewController: NSTextFieldDelegate
{
	func controlTextDidChange(_ notification: Notification)
	{
		guard let textField = notification.object as? NSTextField else {
			return
		}
		
		if [ tokenField, docField, pageField, headerField ].contains(textField)
		{
			generatePreview()
			
			updateButtonStates()
		}
	}
}

// MARK: NSControlTextEditingDelegate

extension ViewController: NSControlTextEditingDelegate
{
	// replace TAB with spaces
	func control(_ control: NSControl, textView: NSTextView, doCommandBy commandSelector: Selector) -> Bool
	{
		var result = false
		
		if commandSelector == #selector(NSResponder.insertTab(_:))
		{
			if textView === headerField
			{
				let TAB = String(repeating: " ", count: 4)
                textView.insertText(TAB, replacementRange: NSMakeRange(textView.string.count, textView.string.count))
				result = true
			}
		}

		return result
	}
}


extension ViewController: NSTextViewDelegate
{
	func textDidChange(_ notification: Notification)
	{
		guard let textView = notification.object as? NSTextView else {
			return
		}
		
		if infoField === textView
		{
			generatePreview()
			
			updateButtonStates()
		}
	}
}

// MARK: NSOutlineViewDataSource

extension ViewController: NSOutlineViewDataSource
{
	func outlineView(_ outlineView: NSOutlineView, numberOfChildrenOfItem item: Any?) -> Int
	{
		guard xmlDoc != nil else {
			return 0
		}
		
		if let group = item as? Group
		{
			return group.hints.count
		}
		return elementsFiltered.count
	}
	
	func outlineView(_ outlineView: NSOutlineView, child index: Int, ofItem item: Any?) -> Any
	{
		if let group = item as? Group
		{
			return group.hints[index]
		}
		
		return elementsFiltered[index]
	}
	
	func outlineView(_ outlineView: NSOutlineView, isItemExpandable item: Any) -> Bool
	{
		if let group = item as? Group
		{
			return group.hints.count > 0
		}
		
		return false
	}
}

// MARK: NSOutlineViewDelegate

extension ViewController: NSOutlineViewDelegate {
	func outlineView(_ outlineView: NSOutlineView, viewFor tableColumn: NSTableColumn?, item: Any) -> NSView?
	{
		var view: NSTableCellView?
		
		var text = ""
		
		if let group = item as? Group
		{
			text = group.name
		}
		
		if let hint = item as? Hint
		{
			text = hint.token
		}
		
        view = outlineView.makeView(withIdentifier: NSUserInterfaceItemIdentifier(rawValue: "ElementCell"), owner: self) as? NSTableCellView
		if let textField = view?.textField
		{
			textField.stringValue = text
			textField.sizeToFit()
			
			
			if let font = textField.font
			{
				if item is Group
				{
                    textField.font = NSFontManager.shared.convert(font, toHaveTrait: .boldFontMask)
				}
				else
				{
                    textField.font = NSFontManager.shared.convert(font, toHaveTrait: .unboldFontMask)
				}
			}
		}
		
		return view
	}
	
	func outlineViewSelectionDidChange(_ notification: Notification)
	{
		guard let outlineView = notification.object as? NSOutlineView else {
			return
		}
		
		let selectedIndex = outlineView.selectedRow
		
		guard selectedIndex != -1 else {
			clearFields()

			filteredGroupIndex = nil
			filteredHintIndex = nil
			
			updateButtonStates()
			
			return
		}

		if let hint = outlineView.item(atRow: selectedIndex) as? Hint
		{
			guard
				let group = outlineView.parent(forItem: hint) as? Group,
                let groupIndex = elementsFiltered.firstIndex(where: { $0 === group } ),
                let hintIndex = group.hints.firstIndex(where: { $0 === hint } )
			else {
				print("HintEditor: Unable to get element with index \(selectedIndex)")
				return
			}
			
			filteredGroupIndex = groupIndex
			filteredHintIndex = hintIndex
			
			guard
                let realGroupIdx = elements.firstIndex(where: {$0.name == group.name}),
                let realHintIdx = elements[realGroupIdx].hints.firstIndex(where: {$0.token == hint.token})
			else
			{
				return
			}
			
			deleteButton.isEnabled = true
			readHint(groupIndex: realGroupIdx, hintIndex: realHintIdx)
		}
		else
		{
			guard
				let group = outlineView.item(atRow: selectedIndex) as? Group,
                let groupIndex = elementsFiltered.firstIndex(where: { $0 === group } )
			else {
				print("HintEditor: Unable to get element with index \(selectedIndex)")
				return
			}
			
			clearFields()

			filteredGroupIndex = groupIndex
			filteredHintIndex = nil

			updateButtonStates()
		}
	}
}

```

`HintEditor/HintEditor/storyboards/Main.storyboard`:

```storyboard
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.Storyboard.XIB" version="3.0" toolsVersion="18122" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" initialViewController="B8D-0N-5wS">
    <dependencies>
        <deployment identifier="macosx"/>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="18122"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--Application-->
        <scene sceneID="JPo-4y-FX3">
            <objects>
                <application id="hnw-xV-0zn" sceneMemberID="viewController">
                    <menu key="mainMenu" title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
                        <items>
                            <menuItem title="HintEditor" id="1Xt-HY-uBw">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="HintEditor" systemMenu="apple" id="uQy-DD-JDr">
                                    <items>
                                        <menuItem title="About HintEditor" id="5kV-Vb-QxS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontStandardAboutPanel:" target="Ady-hI-5gd" id="Exp-CZ-Vem"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                                        <menuItem title="Preferences…" keyEquivalent="," id="BOF-NM-1cW"/>
                                        <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                                        <menuItem title="Services" id="NMo-om-nkz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                                        <menuItem title="Hide HintEditor" keyEquivalent="h" id="Olw-nP-bQN">
                                            <connections>
                                                <action selector="hide:" target="Ady-hI-5gd" id="PnN-Uc-m68"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="hideOtherApplications:" target="Ady-hI-5gd" id="VT4-aY-XCT"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Show All" id="Kd2-mp-pUS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="unhideAllApplications:" target="Ady-hI-5gd" id="Dhg-Le-xox"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                                        <menuItem title="Quit HintEditor" keyEquivalent="q" id="4sb-4s-VLi">
                                            <connections>
                                                <action selector="terminate:" target="Ady-hI-5gd" id="Te7-pn-YzF"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="File" id="dMs-cI-mzQ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="File" id="bib-Uj-vzu">
                                    <items>
                                        <menuItem title="New" keyEquivalent="n" id="Was-JA-tGl">
                                            <connections>
                                                <action selector="newDocument:" target="Ady-hI-5gd" id="4Si-XN-c54"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Open…" keyEquivalent="o" id="IAo-SY-fd9">
                                            <connections>
                                                <action selector="openDocument:" target="Ady-hI-5gd" id="o72-5Q-Wep"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Open Recent" id="tXI-mr-wws">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Open Recent" systemMenu="recentDocuments" id="oas-Oc-fiZ">
                                                <items>
                                                    <menuItem title="Clear Menu" id="vNY-rz-j42">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="clearRecentDocuments:" target="Ady-hI-5gd" id="Daa-9d-B3U"/>
                                                        </connections>
                                                    </menuItem>
                                                </items>
                                            </menu>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="m54-Is-iLE"/>
                                        <menuItem title="Close" keyEquivalent="w" id="DVo-aG-piG">
                                            <connections>
                                                <action selector="performClose:" target="Ady-hI-5gd" id="HmO-Ls-i7Q"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Save…" keyEquivalent="s" id="pxx-59-PXV">
                                            <connections>
                                                <action selector="saveDocument:" target="Ady-hI-5gd" id="teZ-XB-qJY"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Save As…" keyEquivalent="S" id="Bw7-FT-i3A">
                                            <connections>
                                                <action selector="saveDocumentAs:" target="Ady-hI-5gd" id="mDf-zr-I0C"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Revert to Saved" keyEquivalent="r" id="KaW-ft-85H">
                                            <connections>
                                                <action selector="revertDocumentToSaved:" target="Ady-hI-5gd" id="iJ3-Pv-kwq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="aJh-i4-bef"/>
                                        <menuItem title="Page Setup…" keyEquivalent="P" id="qIS-W8-SiK">
                                            <modifierMask key="keyEquivalentModifierMask" shift="YES" command="YES"/>
                                            <connections>
                                                <action selector="runPageLayout:" target="Ady-hI-5gd" id="Din-rz-gC5"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Print…" keyEquivalent="p" id="aTl-1u-JFS">
                                            <connections>
                                                <action selector="print:" target="Ady-hI-5gd" id="qaZ-4w-aoO"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Edit" id="5QF-Oa-p0T">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                                    <items>
                                        <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                            <connections>
                                                <action selector="undo:" target="Ady-hI-5gd" id="M6e-cu-g7V"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                            <connections>
                                                <action selector="redo:" target="Ady-hI-5gd" id="oIA-Rs-6OD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                                        <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                            <connections>
                                                <action selector="cut:" target="Ady-hI-5gd" id="YJe-68-I9s"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                            <connections>
                                                <action selector="copy:" target="Ady-hI-5gd" id="G1f-GL-Joy"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                            <connections>
                                                <action selector="paste:" target="Ady-hI-5gd" id="UvS-8e-Qdg"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="pasteAsPlainText:" target="Ady-hI-5gd" id="cEh-KX-wJQ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Delete" id="pa3-QI-u2k">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="delete:" target="Ady-hI-5gd" id="0Mk-Ml-PaM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                            <connections>
                                                <action selector="selectAll:" target="Ady-hI-5gd" id="VNm-Mi-diN"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                                        <menuItem title="Find" id="4EN-yA-p0u">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                                <items>
                                                    <menuItem title="Find…" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                                        <connections>
                                                            <action selector="performFindPanelAction:" target="Ady-hI-5gd" id="cD7-Qs-BN4"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Find and Replace…" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                                        <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                                        <connections>
                                                            <action selector="performFindPanelAction:" target="Ady-hI-5gd" id="WD3-Gg-5AJ"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                                        <connections>
                                                            <action selector="performFindPanelAction:" target="Ady-hI-5gd" id="NDo-RZ-v9R"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                                        <connections>
                                                            <action selector="performFindPanelAction:" target="Ady-hI-5gd" id="HOh-sY-3ay"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                                        <connections>
                                                            <action selector="performFindPanelAction:" target="Ady-hI-5gd" id="U76-nv-p5D"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                                        <connections>
                                                            <action selector="centerSelectionInVisibleArea:" target="Ady-hI-5gd" id="IOG-6D-g5B"/>
                                                        </connections>
                                                    </menuItem>
                                                </items>
                                            </menu>
                                        </menuItem>
                                        <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                                <items>
                                                    <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                                        <connections>
                                                            <action selector="showGuessPanel:" target="Ady-hI-5gd" id="vFj-Ks-hy3"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                                        <connections>
                                                            <action selector="checkSpelling:" target="Ady-hI-5gd" id="fz7-VC-reM"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                                    <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="toggleContinuousSpellChecking:" target="Ady-hI-5gd" id="7w6-Qz-0kB"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="toggleGrammarChecking:" target="Ady-hI-5gd" id="muD-Qn-j4w"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="toggleAutomaticSpellingCorrection:" target="Ady-hI-5gd" id="2lM-Qi-WAP"/>
                                                        </connections>
                                                    </menuItem>
                                                </items>
                                            </menu>
                                        </menuItem>
                                        <menuItem title="Substitutions" id="9ic-FL-obx">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                                <items>
                                                    <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="orderFrontSubstitutionsPanel:" target="Ady-hI-5gd" id="oku-mr-iSq"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                                    <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="toggleSmartInsertDelete:" target="Ady-hI-5gd" id="3IJ-Se-DZD"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="toggleAutomaticQuoteSubstitution:" target="Ady-hI-5gd" id="ptq-xd-QOA"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="toggleAutomaticDashSubstitution:" target="Ady-hI-5gd" id="oCt-pO-9gS"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Smart Links" id="cwL-P1-jid">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="toggleAutomaticLinkDetection:" target="Ady-hI-5gd" id="Gip-E3-Fov"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="toggleAutomaticDataDetection:" target="Ady-hI-5gd" id="R1I-Nq-Kbl"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="toggleAutomaticTextReplacement:" target="Ady-hI-5gd" id="DvP-Fe-Py6"/>
                                                        </connections>
                                                    </menuItem>
                                                </items>
                                            </menu>
                                        </menuItem>
                                        <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                                <items>
                                                    <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="uppercaseWord:" target="Ady-hI-5gd" id="sPh-Tk-edu"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="lowercaseWord:" target="Ady-hI-5gd" id="iUZ-b5-hil"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="capitalizeWord:" target="Ady-hI-5gd" id="26H-TL-nsh"/>
                                                        </connections>
                                                    </menuItem>
                                                </items>
                                            </menu>
                                        </menuItem>
                                        <menuItem title="Speech" id="xrE-MZ-jX0">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                                <items>
                                                    <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="startSpeaking:" target="Ady-hI-5gd" id="654-Ng-kyl"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="stopSpeaking:" target="Ady-hI-5gd" id="dX8-6p-jy9"/>
                                                        </connections>
                                                    </menuItem>
                                                </items>
                                            </menu>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Format" id="jxT-CU-nIS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Format" id="GEO-Iw-cKr">
                                    <items>
                                        <menuItem title="Font" id="Gi5-1S-RQB">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Font" systemMenu="font" id="aXa-aM-Jaq">
                                                <items>
                                                    <menuItem title="Show Fonts" keyEquivalent="t" id="Q5e-8K-NDq"/>
                                                    <menuItem title="Bold" tag="2" keyEquivalent="b" id="GB9-OM-e27"/>
                                                    <menuItem title="Italic" tag="1" keyEquivalent="i" id="Vjx-xi-njq"/>
                                                    <menuItem title="Underline" keyEquivalent="u" id="WRG-CD-K1S">
                                                        <connections>
                                                            <action selector="underline:" target="Ady-hI-5gd" id="FYS-2b-JAY"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem isSeparatorItem="YES" id="5gT-KC-WSO"/>
                                                    <menuItem title="Bigger" tag="3" keyEquivalent="+" id="Ptp-SP-VEL"/>
                                                    <menuItem title="Smaller" tag="4" keyEquivalent="-" id="i1d-Er-qST"/>
                                                    <menuItem isSeparatorItem="YES" id="kx3-Dk-x3B"/>
                                                    <menuItem title="Kern" id="jBQ-r6-VK2">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <menu key="submenu" title="Kern" id="tlD-Oa-oAM">
                                                            <items>
                                                                <menuItem title="Use Default" id="GUa-eO-cwY">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="useStandardKerning:" target="Ady-hI-5gd" id="6dk-9l-Ckg"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem title="Use None" id="cDB-IK-hbR">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="turnOffKerning:" target="Ady-hI-5gd" id="U8a-gz-Maa"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem title="Tighten" id="46P-cB-AYj">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="tightenKerning:" target="Ady-hI-5gd" id="hr7-Nz-8ro"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem title="Loosen" id="ogc-rX-tC1">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="loosenKerning:" target="Ady-hI-5gd" id="8i4-f9-FKE"/>
                                                                    </connections>
                                                                </menuItem>
                                                            </items>
                                                        </menu>
                                                    </menuItem>
                                                    <menuItem title="Ligatures" id="o6e-r0-MWq">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <menu key="submenu" title="Ligatures" id="w0m-vy-SC9">
                                                            <items>
                                                                <menuItem title="Use Default" id="agt-UL-0e3">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="useStandardLigatures:" target="Ady-hI-5gd" id="7uR-wd-Dx6"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem title="Use None" id="J7y-lM-qPV">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="turnOffLigatures:" target="Ady-hI-5gd" id="iX2-gA-Ilz"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem title="Use All" id="xQD-1f-W4t">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="useAllLigatures:" target="Ady-hI-5gd" id="KcB-kA-TuK"/>
                                                                    </connections>
                                                                </menuItem>
                                                            </items>
                                                        </menu>
                                                    </menuItem>
                                                    <menuItem title="Baseline" id="OaQ-X3-Vso">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <menu key="submenu" title="Baseline" id="ijk-EB-dga">
                                                            <items>
                                                                <menuItem title="Use Default" id="3Om-Ey-2VK">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="unscript:" target="Ady-hI-5gd" id="0vZ-95-Ywn"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem title="Superscript" id="Rqc-34-cIF">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="superscript:" target="Ady-hI-5gd" id="3qV-fo-wpU"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem title="Subscript" id="I0S-gh-46l">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="subscript:" target="Ady-hI-5gd" id="Q6W-4W-IGz"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem title="Raise" id="2h7-ER-AoG">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="raiseBaseline:" target="Ady-hI-5gd" id="4sk-31-7Q9"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem title="Lower" id="1tx-W0-xDw">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="lowerBaseline:" target="Ady-hI-5gd" id="OF1-bc-KW4"/>
                                                                    </connections>
                                                                </menuItem>
                                                            </items>
                                                        </menu>
                                                    </menuItem>
                                                    <menuItem isSeparatorItem="YES" id="Ndw-q3-faq"/>
                                                    <menuItem title="Show Colors" keyEquivalent="C" id="bgn-CT-cEk">
                                                        <connections>
                                                            <action selector="orderFrontColorPanel:" target="Ady-hI-5gd" id="mSX-Xz-DV3"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem isSeparatorItem="YES" id="iMs-zA-UFJ"/>
                                                    <menuItem title="Copy Style" keyEquivalent="c" id="5Vv-lz-BsD">
                                                        <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                                        <connections>
                                                            <action selector="copyFont:" target="Ady-hI-5gd" id="GJO-xA-L4q"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Paste Style" keyEquivalent="v" id="vKC-jM-MkH">
                                                        <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                                        <connections>
                                                            <action selector="pasteFont:" target="Ady-hI-5gd" id="JfD-CL-leO"/>
                                                        </connections>
                                                    </menuItem>
                                                </items>
                                            </menu>
                                        </menuItem>
                                        <menuItem title="Text" id="Fal-I4-PZk">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Text" id="d9c-me-L2H">
                                                <items>
                                                    <menuItem title="Align Left" keyEquivalent="{" id="ZM1-6Q-yy1">
                                                        <connections>
                                                            <action selector="alignLeft:" target="Ady-hI-5gd" id="zUv-R1-uAa"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Center" keyEquivalent="|" id="VIY-Ag-zcb">
                                                        <connections>
                                                            <action selector="alignCenter:" target="Ady-hI-5gd" id="spX-mk-kcS"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Justify" id="J5U-5w-g23">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="alignJustified:" target="Ady-hI-5gd" id="ljL-7U-jND"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Align Right" keyEquivalent="}" id="wb2-vD-lq4">
                                                        <connections>
                                                            <action selector="alignRight:" target="Ady-hI-5gd" id="r48-bG-YeY"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem isSeparatorItem="YES" id="4s2-GY-VfK"/>
                                                    <menuItem title="Writing Direction" id="H1b-Si-o9J">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <menu key="submenu" title="Writing Direction" id="8mr-sm-Yjd">
                                                            <items>
                                                                <menuItem title="Paragraph" enabled="NO" id="ZvO-Gk-QUH">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                </menuItem>
                                                                <menuItem id="YGs-j5-SAR">
                                                                    <string key="title">	Default</string>
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="makeBaseWritingDirectionNatural:" target="Ady-hI-5gd" id="qtV-5e-UBP"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem id="Lbh-J2-qVU">
                                                                    <string key="title">	Left to Right</string>
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="makeBaseWritingDirectionLeftToRight:" target="Ady-hI-5gd" id="S0X-9S-QSf"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem id="jFq-tB-4Kx">
                                                                    <string key="title">	Right to Left</string>
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="makeBaseWritingDirectionRightToLeft:" target="Ady-hI-5gd" id="5fk-qB-AqJ"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem isSeparatorItem="YES" id="swp-gr-a21"/>
                                                                <menuItem title="Selection" enabled="NO" id="cqv-fj-IhA">
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                </menuItem>
                                                                <menuItem id="Nop-cj-93Q">
                                                                    <string key="title">	Default</string>
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="makeTextWritingDirectionNatural:" target="Ady-hI-5gd" id="lPI-Se-ZHp"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem id="BgM-ve-c93">
                                                                    <string key="title">	Left to Right</string>
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="makeTextWritingDirectionLeftToRight:" target="Ady-hI-5gd" id="caW-Bv-w94"/>
                                                                    </connections>
                                                                </menuItem>
                                                                <menuItem id="RB4-Sm-HuC">
                                                                    <string key="title">	Right to Left</string>
                                                                    <modifierMask key="keyEquivalentModifierMask"/>
                                                                    <connections>
                                                                        <action selector="makeTextWritingDirectionRightToLeft:" target="Ady-hI-5gd" id="EXD-6r-ZUu"/>
                                                                    </connections>
                                                                </menuItem>
                                                            </items>
                                                        </menu>
                                                    </menuItem>
                                                    <menuItem isSeparatorItem="YES" id="fKy-g9-1gm"/>
                                                    <menuItem title="Show Ruler" id="vLm-3I-IUL">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="toggleRuler:" target="Ady-hI-5gd" id="FOx-HJ-KwY"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Copy Ruler" keyEquivalent="c" id="MkV-Pr-PK5">
                                                        <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                                        <connections>
                                                            <action selector="copyRuler:" target="Ady-hI-5gd" id="71i-fW-3W2"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Paste Ruler" keyEquivalent="v" id="LVM-kO-fVI">
                                                        <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                                        <connections>
                                                            <action selector="pasteRuler:" target="Ady-hI-5gd" id="cSh-wd-qM2"/>
                                                        </connections>
                                                    </menuItem>
                                                </items>
                                            </menu>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="View" id="H8h-7b-M4v">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="View" id="HyV-fh-RgO">
                                    <items>
                                        <menuItem title="Show Toolbar" keyEquivalent="t" id="snW-S8-Cw5">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="toggleToolbarShown:" target="Ady-hI-5gd" id="BXY-wc-z0C"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Customize Toolbar…" id="1UK-8n-QPP">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="runToolbarCustomizationPalette:" target="Ady-hI-5gd" id="pQI-g3-MTW"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="hB3-LF-h0Y"/>
                                        <menuItem title="Show Sidebar" keyEquivalent="s" id="kIP-vf-haE">
                                            <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                            <connections>
                                                <action selector="toggleSidebar:" target="Ady-hI-5gd" id="iwa-gc-5KM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                            <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                            <connections>
                                                <action selector="toggleFullScreen:" target="Ady-hI-5gd" id="dU3-MA-1Rq"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Window" id="aUF-d1-5bR">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                                    <items>
                                        <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                            <connections>
                                                <action selector="performMiniaturize:" target="Ady-hI-5gd" id="VwT-WD-YPe"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Zoom" id="R4o-n2-Eq4">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="performZoom:" target="Ady-hI-5gd" id="DIl-cC-cCs"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                                        <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="arrangeInFront:" target="Ady-hI-5gd" id="DRN-fu-gQh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Help" id="wpr-3q-Mcd">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Help" systemMenu="help" id="F2S-fz-NVQ">
                                    <items>
                                        <menuItem title="HintEditor Help" keyEquivalent="?" id="FKE-Sm-Kum">
                                            <connections>
                                                <action selector="showHelp:" target="Ady-hI-5gd" id="y7X-2Q-9no"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                    <connections>
                        <outlet property="delegate" destination="Voe-Tx-rLC" id="PrD-fu-P6m"/>
                    </connections>
                </application>
                <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="HintEditor" customModuleProvider="target"/>
                <customObject id="Ady-hI-5gd" userLabel="First Responder" customClass="NSResponder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="76" y="-93"/>
        </scene>
        <!--Window Controller-->
        <scene sceneID="R2V-B0-nI4">
            <objects>
                <windowController id="B8D-0N-5wS" sceneMemberID="viewController">
                    <window key="window" title="FRIEND Hint Editor" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" visibleAtLaunch="NO" animationBehavior="default" id="IQv-IB-iLA">
                        <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
                        <windowPositionMask key="initialPositionMask" leftStrut="YES" rightStrut="YES" topStrut="YES" bottomStrut="YES"/>
                        <rect key="contentRect" x="196" y="240" width="900" height="500"/>
                        <rect key="screenRect" x="0.0" y="0.0" width="1680" height="1027"/>
                        <value key="minSize" type="size" width="900" height="500"/>
                        <connections>
                            <outlet property="delegate" destination="B8D-0N-5wS" id="NfY-hL-azW"/>
                        </connections>
                    </window>
                    <connections>
                        <segue destination="XfG-lQ-9wD" kind="relationship" relationship="window.shadowedContentViewController" id="cq2-FE-JQM"/>
                    </connections>
                </windowController>
                <customObject id="Oky-zY-oP4" userLabel="First Responder" customClass="NSResponder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="75" y="250"/>
        </scene>
        <!--View Controller-->
        <scene sceneID="hIz-AP-VOD">
            <objects>
                <viewController id="XfG-lQ-9wD" customClass="ViewController" customModule="HintEditor" customModuleProvider="target" sceneMemberID="viewController">
                    <view key="view" wantsLayer="YES" misplaced="YES" id="q0o-zd-I2n">
                        <rect key="frame" x="0.0" y="0.0" width="900" height="496"/>
                        <autoresizingMask key="autoresizingMask"/>
                        <subviews>
                            <textField verticalHuggingPriority="750" allowsCharacterPickerTouchBarItem="YES" translatesAutoresizingMaskIntoConstraints="NO" id="EcY-1n-n6X">
                                <rect key="frame" x="532" y="428" width="348" height="19"/>
                                <textFieldCell key="cell" lineBreakMode="truncatingTail" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" placeholderString="header" drawsBackground="YES" usesSingleLineMode="YES" id="vJy-pK-Nyk">
                                    <font key="font" size="12" name="Menlo-Regular"/>
                                    <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
                                    <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
                                </textFieldCell>
                                <connections>
                                    <outlet property="delegate" destination="XfG-lQ-9wD" id="eI3-1k-7IK"/>
                                </connections>
                            </textField>
                            <textField verticalHuggingPriority="750" allowsCharacterPickerTouchBarItem="YES" translatesAutoresizingMaskIntoConstraints="NO" id="zq9-3x-uDG">
                                <rect key="frame" x="428" y="428" width="96" height="19"/>
                                <constraints>
                                    <constraint firstAttribute="width" constant="96" id="Q32-Ts-LtS"/>
                                </constraints>
                                <textFieldCell key="cell" lineBreakMode="truncatingTail" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" placeholderString="page" drawsBackground="YES" usesSingleLineMode="YES" id="Gkd-cu-MVh">
                                    <font key="font" size="12" name="Menlo-Regular"/>
                                    <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
                                    <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
                                </textFieldCell>
                                <connections>
                                    <outlet property="delegate" destination="XfG-lQ-9wD" id="6Bb-vi-eat"/>
                                </connections>
                            </textField>
                            <textField verticalHuggingPriority="750" allowsCharacterPickerTouchBarItem="YES" translatesAutoresizingMaskIntoConstraints="NO" id="MKn-2F-2bj">
                                <rect key="frame" x="428" y="457" width="214" height="19"/>
                                <textFieldCell key="cell" lineBreakMode="truncatingTail" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" placeholderString="token" drawsBackground="YES" usesSingleLineMode="YES" id="NGj-ER-VMT">
                                    <font key="font" size="12" name="Menlo-Regular"/>
                                    <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
                                    <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
                                </textFieldCell>
                                <connections>
                                    <outlet property="delegate" destination="XfG-lQ-9wD" id="XzY-YX-APw"/>
                                </connections>
                            </textField>
                            <textField verticalHuggingPriority="750" allowsCharacterPickerTouchBarItem="YES" translatesAutoresizingMaskIntoConstraints="NO" id="ZFI-DJ-s16">
                                <rect key="frame" x="650" y="457" width="230" height="19"/>
                                <textFieldCell key="cell" lineBreakMode="truncatingTail" selectable="YES" editable="YES" sendsActionOnEndEditing="YES" state="on" borderStyle="bezel" placeholderString="doc" drawsBackground="YES" usesSingleLineMode="YES" id="qeh-tt-pJF">
                                    <font key="font" size="12" name="Menlo-Regular"/>
                                    <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
                                    <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
                                </textFieldCell>
                                <connections>
                                    <outlet property="delegate" destination="XfG-lQ-9wD" id="hwz-PD-Z9d"/>
                                </connections>
                            </textField>
                            <scrollView autohidesScrollers="YES" horizontalLineScroll="20" horizontalPageScroll="10" verticalLineScroll="20" verticalPageScroll="10" usesPredominantAxisScrolling="NO" translatesAutoresizingMaskIntoConstraints="NO" id="0dT-ZM-1vF">
                                <rect key="frame" x="20" y="20" width="400" height="456"/>
                                <clipView key="contentView" id="rn8-dN-n5c">
                                    <rect key="frame" x="1" y="1" width="398" height="454"/>
                                    <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                    <subviews>
                                        <outlineView verticalHuggingPriority="750" allowsExpansionToolTips="YES" columnReordering="NO" columnResizing="NO" multipleSelection="NO" autosaveColumns="NO" rowHeight="18" rowSizeStyle="automatic" viewBased="YES" indentationPerLevel="5" autoresizesOutlineColumn="YES" outlineTableColumn="uaa-vZ-dlK" id="Y5E-CH-GCS">
                                            <rect key="frame" x="0.0" y="0.0" width="398" height="454"/>
                                            <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                            <size key="intercellSpacing" width="3" height="2"/>
                                            <color key="backgroundColor" name="controlBackgroundColor" catalog="System" colorSpace="catalog"/>
                                            <color key="gridColor" name="gridColor" catalog="System" colorSpace="catalog"/>
                                            <tableColumns>
                                                <tableColumn width="116" minWidth="40" maxWidth="1000" id="uaa-vZ-dlK">
                                                    <tableHeaderCell key="headerCell" lineBreakMode="truncatingTail" borderStyle="border">
                                                        <color key="textColor" name="headerTextColor" catalog="System" colorSpace="catalog"/>
                                                        <color key="backgroundColor" name="headerColor" catalog="System" colorSpace="catalog"/>
                                                    </tableHeaderCell>
                                                    <textFieldCell key="dataCell" lineBreakMode="truncatingTail" selectable="YES" editable="YES" title="Text Cell" id="6Vd-jg-Duz">
                                                        <font key="font" metaFont="system"/>
                                                        <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
                                                        <color key="backgroundColor" name="controlBackgroundColor" catalog="System" colorSpace="catalog"/>
                                                    </textFieldCell>
                                                    <tableColumnResizingMask key="resizingMask" resizeWithTable="YES" userResizable="YES"/>
                                                    <prototypeCellViews>
                                                        <tableCellView identifier="ElementCell" misplaced="YES" id="NcD-vf-vX8">
                                                            <rect key="frame" x="1" y="1" width="125" height="18"/>
                                                            <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                                            <subviews>
                                                                <textField verticalHuggingPriority="750" horizontalCompressionResistancePriority="250" allowsCharacterPickerTouchBarItem="YES" translatesAutoresizingMaskIntoConstraints="NO" id="buW-H4-rym">
                                                                    <rect key="frame" x="0.0" y="0.0" width="125" height="14"/>
                                                                    <textFieldCell key="cell" lineBreakMode="truncatingTail" sendsActionOnEndEditing="YES" title="Table View Cell" id="4eM-Mf-Y40">
                                                                        <font key="font" size="12" name="Menlo-Regular"/>
                                                                        <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
                                                                        <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
                                                                    </textFieldCell>
                                                                </textField>
                                                            </subviews>
                                                            <constraints>
                                                                <constraint firstAttribute="bottom" secondItem="buW-H4-rym" secondAttribute="bottom" id="3i9-lL-zBj"/>
                                                                <constraint firstItem="buW-H4-rym" firstAttribute="leading" secondItem="NcD-vf-vX8" secondAttribute="leading" constant="2" id="N5E-9Y-y4a"/>
                                                                <constraint firstAttribute="trailing" secondItem="buW-H4-rym" secondAttribute="trailing" constant="2" id="REy-kr-FzX"/>
                                                                <constraint firstItem="buW-H4-rym" firstAttribute="top" secondItem="NcD-vf-vX8" secondAttribute="top" id="mPa-pX-WOc"/>
                                                            </constraints>
                                                            <connections>
                                                                <outlet property="textField" destination="buW-H4-rym" id="fh2-GW-nGi"/>
                                                            </connections>
                                                        </tableCellView>
                                                    </prototypeCellViews>
                                                </tableColumn>
                                            </tableColumns>
                                            <connections>
                                                <outlet property="dataSource" destination="XfG-lQ-9wD" id="G5f-BQ-TVy"/>
                                                <outlet property="delegate" destination="XfG-lQ-9wD" id="dPR-cZ-dqw"/>
                                            </connections>
                                        </outlineView>
                                    </subviews>
                                </clipView>
                                <constraints>
                                    <constraint firstAttribute="width" constant="400" id="Jbc-Hg-OKR"/>
                                </constraints>
                                <scroller key="horizontalScroller" hidden="YES" wantsLayer="YES" verticalHuggingPriority="750" horizontal="YES" id="kCq-oS-gqI">
                                    <rect key="frame" x="1" y="119" width="223" height="15"/>
                                    <autoresizingMask key="autoresizingMask"/>
                                </scroller>
                                <scroller key="verticalScroller" hidden="YES" wantsLayer="YES" verticalHuggingPriority="750" horizontal="NO" id="QUw-ih-yVR">
                                    <rect key="frame" x="224" y="17" width="15" height="102"/>
                                    <autoresizingMask key="autoresizingMask"/>
                                </scroller>
                            </scrollView>
                            <button verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="glp-bM-rKv">
                                <rect key="frame" x="420" y="13" width="84" height="32"/>
                                <constraints>
                                    <constraint firstAttribute="width" constant="70" id="Aiw-05-ddO"/>
                                </constraints>
                                <buttonCell key="cell" type="push" title="Save" bezelStyle="rounded" alignment="center" enabled="NO" borderStyle="border" imageScaling="proportionallyDown" inset="2" id="13k-nf-V52">
                                    <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
                                    <font key="font" metaFont="system"/>
                                </buttonCell>
                                <connections>
                                    <action selector="saveHint:" target="XfG-lQ-9wD" id="gmz-dk-TU1"/>
                                </connections>
                            </button>
                            <button verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="qB8-ax-fdR">
                                <rect key="frame" x="803" y="13" width="84" height="32"/>
                                <constraints>
                                    <constraint firstAttribute="width" constant="70" id="KNc-Xp-ChU"/>
                                </constraints>
                                <buttonCell key="cell" type="push" title="Delete" bezelStyle="rounded" alignment="center" enabled="NO" borderStyle="border" imageScaling="proportionallyDown" inset="2" id="sWT-41-bSD">
                                    <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
                                    <font key="font" metaFont="system"/>
                                </buttonCell>
                                <connections>
                                    <action selector="deleteHint:" target="XfG-lQ-9wD" id="Aem-2E-DBH"/>
                                </connections>
                            </button>
                            <button verticalHuggingPriority="750" translatesAutoresizingMaskIntoConstraints="NO" id="pr1-FX-u7z">
                                <rect key="frame" x="721" y="13" width="84" height="32"/>
                                <constraints>
                                    <constraint firstAttribute="width" constant="70" id="yMT-wy-OcQ"/>
                                </constraints>
                                <buttonCell key="cell" type="push" title="Add" bezelStyle="rounded" alignment="center" enabled="NO" borderStyle="border" imageScaling="proportionallyDown" inset="2" id="fwp-0i-pll">
                                    <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
                                    <font key="font" metaFont="system"/>
                                </buttonCell>
                                <connections>
                                    <action selector="addHint:" target="XfG-lQ-9wD" id="8Ni-mr-BQ3"/>
                                </connections>
                            </button>
                            <scrollView autohidesScrollers="YES" horizontalLineScroll="10" horizontalPageScroll="10" verticalLineScroll="10" verticalPageScroll="10" usesPredominantAxisScrolling="NO" translatesAutoresizingMaskIntoConstraints="NO" id="Cyq-nh-uUX">
                                <rect key="frame" x="428" y="238" width="452" height="182"/>
                                <clipView key="contentView" drawsBackground="NO" id="li7-fI-fHG">
                                    <rect key="frame" x="1" y="1" width="450" height="180"/>
                                    <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                    <subviews>
                                        <textView importsGraphics="NO" richText="NO" horizontallyResizable="YES" verticallyResizable="YES" findStyle="panel" allowsUndo="YES" allowsNonContiguousLayout="YES" quoteSubstitution="YES" dashSubstitution="YES" smartInsertDelete="YES" id="G6X-7E-FbY" customClass="InfoTextView" customModule="HintEditor" customModuleProvider="target">
                                            <rect key="frame" x="0.0" y="0.0" width="450" height="180"/>
                                            <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                            <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
                                            <color key="backgroundColor" name="controlColor" catalog="System" colorSpace="catalog"/>
                                            <size key="minSize" width="450" height="180"/>
                                            <size key="maxSize" width="10000000" height="10000000"/>
                                            <color key="insertionPointColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
                                            <connections>
                                                <outlet property="delegate" destination="XfG-lQ-9wD" id="m6H-bS-j5Y"/>
                                            </connections>
                                        </textView>
                                    </subviews>
                                </clipView>
                                <scroller key="horizontalScroller" hidden="YES" wantsLayer="YES" verticalHuggingPriority="750" doubleValue="1" horizontal="YES" id="Vxk-0K-9os">
                                    <rect key="frame" x="1" y="162" width="500" height="16"/>
                                    <autoresizingMask key="autoresizingMask"/>
                                </scroller>
                                <scroller key="verticalScroller" hidden="YES" wantsLayer="YES" verticalHuggingPriority="750" doubleValue="1" horizontal="NO" id="dWf-sb-dWp">
                                    <rect key="frame" x="435" y="1" width="16" height="180"/>
                                    <autoresizingMask key="autoresizingMask"/>
                                </scroller>
                            </scrollView>
                            <scrollView wantsLayer="YES" horizontalLineScroll="10" horizontalPageScroll="10" verticalLineScroll="10" verticalPageScroll="10" hasHorizontalScroller="NO" hasVerticalScroller="NO" usesPredominantAxisScrolling="NO" horizontalScrollElasticity="none" verticalScrollElasticity="none" translatesAutoresizingMaskIntoConstraints="NO" id="nVz-Vf-4ey">
                                <rect key="frame" x="428" y="48" width="452" height="182"/>
                                <clipView key="contentView" drawsBackground="NO" id="87a-jh-X96">
                                    <rect key="frame" x="1" y="1" width="450" height="180"/>
                                    <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                    <subviews>
                                        <textView editable="NO" selectable="NO" importsGraphics="NO" richText="NO" horizontallyResizable="YES" verticallyResizable="YES" allowsUndo="YES" allowsNonContiguousLayout="YES" id="1sf-mb-9Lo" customClass="PreviewTextView" customModule="HintEditor" customModuleProvider="target">
                                            <rect key="frame" x="0.0" y="0.0" width="450" height="180"/>
                                            <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                            <color key="textColor" name="textColor" catalog="System" colorSpace="catalog"/>
                                            <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
                                            <size key="minSize" width="450" height="180"/>
                                            <size key="maxSize" width="10000000" height="10000000"/>
                                            <color key="insertionPointColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
                                            <userDefinedRuntimeAttributes>
                                                <userDefinedRuntimeAttribute type="color" keyPath="backgroundColor">
                                                    <color key="value" red="1" green="0.94733601369999998" blue="0.67812771110000003" alpha="1" colorSpace="calibratedRGB"/>
                                                </userDefinedRuntimeAttribute>
                                                <userDefinedRuntimeAttribute type="color" keyPath="hintHeaderColor">
                                                    <color key="value" red="0.0" green="0.50196081400000003" blue="0.0" alpha="1" colorSpace="calibratedRGB"/>
                                                </userDefinedRuntimeAttribute>
                                                <userDefinedRuntimeAttribute type="color" keyPath="hintInfoColor">
                                                    <color key="value" red="0.49803921579999999" green="0.49803921579999999" blue="0.49803921579999999" alpha="1" colorSpace="calibratedRGB"/>
                                                </userDefinedRuntimeAttribute>
                                            </userDefinedRuntimeAttributes>
                                        </textView>
                                    </subviews>
                                </clipView>
                                <scroller key="horizontalScroller" hidden="YES" wantsLayer="YES" verticalHuggingPriority="750" doubleValue="1" horizontal="YES" id="Y4H-uk-SvP">
                                    <rect key="frame" x="-100" y="-100" width="87" height="18"/>
                                    <autoresizingMask key="autoresizingMask"/>
                                </scroller>
                                <scroller key="verticalScroller" hidden="YES" wantsLayer="YES" verticalHuggingPriority="750" doubleValue="1" horizontal="NO" id="aht-TH-2FD">
                                    <rect key="frame" x="-100" y="-100" width="16" height="178"/>
                                    <autoresizingMask key="autoresizingMask"/>
                                </scroller>
                            </scrollView>
                            <searchField wantsLayer="YES" verticalHuggingPriority="750" allowsCharacterPickerTouchBarItem="YES" translatesAutoresizingMaskIntoConstraints="NO" id="sHP-Oa-nmw">
                                <rect key="frame" x="505" y="19" width="215" height="22"/>
                                <searchFieldCell key="cell" scrollable="YES" lineBreakMode="clipping" selectable="YES" editable="YES" borderStyle="bezel" usesSingleLineMode="YES" bezelStyle="round" id="dAJ-ni-S9J">
                                    <font key="font" metaFont="system"/>
                                    <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
                                    <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
                                </searchFieldCell>
                                <connections>
                                    <action selector="searchHint:" target="XfG-lQ-9wD" id="UpM-Je-toB"/>
                                </connections>
                            </searchField>
                        </subviews>
                        <constraints>
                            <constraint firstItem="MKn-2F-2bj" firstAttribute="width" secondItem="ZFI-DJ-s16" secondAttribute="width" constant="-16" id="0nA-pa-wXm"/>
                            <constraint firstItem="EcY-1n-n6X" firstAttribute="leading" secondItem="zq9-3x-uDG" secondAttribute="trailing" constant="8" id="1uF-tP-qzZ"/>
                            <constraint firstItem="ZFI-DJ-s16" firstAttribute="leading" secondItem="MKn-2F-2bj" secondAttribute="trailing" constant="8" id="2Mx-Rs-vde"/>
                            <constraint firstItem="pr1-FX-u7z" firstAttribute="top" secondItem="nVz-Vf-4ey" secondAttribute="bottom" constant="8" id="2TH-dn-bQG"/>
                            <constraint firstItem="sHP-Oa-nmw" firstAttribute="leading" secondItem="glp-bM-rKv" secondAttribute="trailing" constant="8" id="5Ll-jn-hGD"/>
                            <constraint firstAttribute="trailing" secondItem="nVz-Vf-4ey" secondAttribute="trailing" constant="20" id="CoJ-Vv-ny6"/>
                            <constraint firstItem="Cyq-nh-uUX" firstAttribute="leading" secondItem="0dT-ZM-1vF" secondAttribute="trailing" constant="8" id="ErM-4V-KU5"/>
                            <constraint firstItem="glp-bM-rKv" firstAttribute="top" secondItem="nVz-Vf-4ey" secondAttribute="bottom" constant="8" id="HCl-aZ-eME"/>
                            <constraint firstAttribute="bottom" secondItem="sHP-Oa-nmw" secondAttribute="bottom" constant="19" id="J1g-Hq-iGc"/>
                            <constraint firstItem="qB8-ax-fdR" firstAttribute="top" secondItem="nVz-Vf-4ey" secondAttribute="bottom" constant="8" id="JOt-Cm-xok"/>
                            <constraint firstItem="Cyq-nh-uUX" firstAttribute="top" secondItem="EcY-1n-n6X" secondAttribute="bottom" constant="8" id="KME-5l-AW5"/>
                            <constraint firstItem="qB8-ax-fdR" firstAttribute="leading" secondItem="pr1-FX-u7z" secondAttribute="trailing" constant="12" id="LEl-f6-01t"/>
                            <constraint firstItem="nVz-Vf-4ey" firstAttribute="leading" secondItem="0dT-ZM-1vF" secondAttribute="trailing" constant="8" id="RTj-nL-QuX"/>
                            <constraint firstItem="ZFI-DJ-s16" firstAttribute="top" secondItem="q0o-zd-I2n" secondAttribute="top" constant="20" id="Vfg-rY-Y0P"/>
                            <constraint firstItem="nVz-Vf-4ey" firstAttribute="top" secondItem="Cyq-nh-uUX" secondAttribute="bottom" constant="8" id="Wpk-kE-7X5"/>
                            <constraint firstItem="zq9-3x-uDG" firstAttribute="leading" secondItem="0dT-ZM-1vF" secondAttribute="trailing" constant="8" id="bXu-Wc-s3L"/>
                            <constraint firstAttribute="trailing" secondItem="EcY-1n-n6X" secondAttribute="trailing" constant="20" id="bYK-Ok-Hmw"/>
                            <constraint firstItem="qB8-ax-fdR" firstAttribute="width" secondItem="glp-bM-rKv" secondAttribute="width" id="cg9-7S-YCE"/>
                            <constraint firstItem="MKn-2F-2bj" firstAttribute="leading" secondItem="0dT-ZM-1vF" secondAttribute="trailing" constant="8" id="d7B-vK-Mbf"/>
                            <constraint firstAttribute="bottom" secondItem="0dT-ZM-1vF" secondAttribute="bottom" constant="20" id="iUn-qk-DOz"/>
                            <constraint firstAttribute="trailing" secondItem="ZFI-DJ-s16" secondAttribute="trailing" constant="20" id="k4f-rR-7aB"/>
                            <constraint firstItem="Cyq-nh-uUX" firstAttribute="height" secondItem="nVz-Vf-4ey" secondAttribute="height" id="kSd-TC-wHD"/>
                            <constraint firstAttribute="trailing" secondItem="qB8-ax-fdR" secondAttribute="trailing" constant="20" id="kVe-rf-pdM"/>
                            <constraint firstAttribute="bottom" secondItem="glp-bM-rKv" secondAttribute="bottom" constant="20" id="kfI-31-SAH"/>
                            <constraint firstItem="MKn-2F-2bj" firstAttribute="top" secondItem="q0o-zd-I2n" secondAttribute="top" constant="20" id="lNv-M6-9ZA" userLabel="Text Field.top = top + 20"/>
                            <constraint firstItem="EcY-1n-n6X" firstAttribute="top" secondItem="MKn-2F-2bj" secondAttribute="bottom" constant="10" id="rcY-Oy-rwm"/>
                            <constraint firstItem="0dT-ZM-1vF" firstAttribute="top" secondItem="q0o-zd-I2n" secondAttribute="top" constant="20" id="sE2-0a-aIy"/>
                            <constraint firstAttribute="trailing" secondItem="Cyq-nh-uUX" secondAttribute="trailing" constant="20" id="ujP-cR-6D4"/>
                            <constraint firstItem="pr1-FX-u7z" firstAttribute="width" secondItem="glp-bM-rKv" secondAttribute="width" id="v7j-hd-p1d"/>
                            <constraint firstItem="glp-bM-rKv" firstAttribute="leading" secondItem="0dT-ZM-1vF" secondAttribute="trailing" constant="7" id="vTd-Yx-5nk"/>
                            <constraint firstItem="0dT-ZM-1vF" firstAttribute="leading" secondItem="q0o-zd-I2n" secondAttribute="leading" constant="20" id="wVc-sx-X2n"/>
                            <constraint firstAttribute="bottom" secondItem="qB8-ax-fdR" secondAttribute="bottom" constant="20" id="wc7-wq-VEg"/>
                            <constraint firstItem="pr1-FX-u7z" firstAttribute="leading" secondItem="sHP-Oa-nmw" secondAttribute="trailing" constant="8" id="xBK-kF-n2Q"/>
                            <constraint firstItem="Cyq-nh-uUX" firstAttribute="top" secondItem="zq9-3x-uDG" secondAttribute="bottom" constant="8" id="zDn-lf-mRp"/>
                        </constraints>
                    </view>
                    <connections>
                        <outlet property="addButton" destination="pr1-FX-u7z" id="hYP-sb-Vgm"/>
                        <outlet property="deleteButton" destination="qB8-ax-fdR" id="mSU-Qh-1KM"/>
                        <outlet property="docField" destination="ZFI-DJ-s16" id="3hs-Sb-W7g"/>
                        <outlet property="elementsView" destination="Y5E-CH-GCS" id="3PK-Of-yzv"/>
                        <outlet property="headerField" destination="EcY-1n-n6X" id="cKj-eH-T7C"/>
                        <outlet property="infoField" destination="G6X-7E-FbY" id="kkj-DC-Rh5"/>
                        <outlet property="pageField" destination="zq9-3x-uDG" id="aLa-dj-cBF"/>
                        <outlet property="previewField" destination="1sf-mb-9Lo" id="2Bo-My-FRj"/>
                        <outlet property="saveButton" destination="glp-bM-rKv" id="69p-et-h28"/>
                        <outlet property="searchField" destination="sHP-Oa-nmw" id="bef-jl-JyJ"/>
                        <outlet property="tokenField" destination="MKn-2F-2bj" id="J4H-WU-r6d"/>
                    </connections>
                </viewController>
                <customObject id="rPt-NT-nkU" userLabel="First Responder" customClass="NSResponder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="75" y="963"/>
        </scene>
    </scenes>
</document>

```

`Patches/aexml.diff`:

```diff
diff --git a/Sources/Element.swift b/Sources/Element.swift
index d45f647..e1c238c 100644
--- a/Sources/Element.swift
+++ b/Sources/Element.swift
@@ -163,9 +163,14 @@ open class AEXMLElement {
     
         - returns: Child XML element with `self` as `parent`.
     */
-    @discardableResult open func addChild(_ child: AEXMLElement) -> AEXMLElement {
+    @discardableResult open func addChild(_ child: AEXMLElement, at index: Int? = nil) -> AEXMLElement {
         child.parent = self
-        children.append(child)
+        if let idx = index {
+            children.insert(child, at: idx)
+        }
+        else {
+            children.append(child)
+        }
         return child
     }
     
@@ -180,10 +185,11 @@ open class AEXMLElement {
     */
     @discardableResult open func addChild(name: String,
                        value: String? = nil,
-                       attributes: [String : String] = [String : String]()) -> AEXMLElement
+                       attributes: [String : String] = [String : String](),
+                       at index: Int? = nil) -> AEXMLElement
     {
         let child = AEXMLElement(name: name, value: value, attributes: attributes)
-        return addChild(child)
+        return addChild(child, at: index)
     }
     
     /// Removes `self` from `parent` XML element.

```

`Patches/capstone.diff`:

```diff
diff --git a/arch/AArch64/AArch64InstPrinter.c b/arch/AArch64/AArch64InstPrinter.c
index 26d482f4..4c705950 100644
--- a/arch/AArch64/AArch64InstPrinter.c
+++ b/arch/AArch64/AArch64InstPrinter.c
@@ -477,18 +477,18 @@ static bool printSysAlias(MCInst *MI, SStream *O)
 				if (Op1Val == 0 && Op2Val == 0) {
 					Asm = "ic\tialluis";
 					insn_id = ARM64_INS_IC;
-					op_ic = ARM64_IC_IALLUIS;
+					op_ic = A64IC_IALLUIS;
 				}
 				break;
 			case 5:
 				if (Op1Val == 0 && Op2Val == 0) {
 					Asm = "ic\tiallu";
 					insn_id = ARM64_INS_IC;
-					op_ic = ARM64_IC_IALLU;
+					op_ic = A64IC_IALLU;
 				} else if (Op1Val == 3 && Op2Val == 1) {
 					Asm = "ic\tivau";
 					insn_id = ARM64_INS_IC;
-					op_ic = ARM64_IC_IVAU;
+					op_ic = A64IC_IVAU;
 				}
 				break;
 
@@ -497,48 +497,48 @@ static bool printSysAlias(MCInst *MI, SStream *O)
 				if (Op1Val == 3 && Op2Val == 1) {
 					Asm = "dc\tzva";
 					insn_id = ARM64_INS_DC;
-					op_dc = ARM64_DC_ZVA;
+					op_dc = A64DC_ZVA;
 				}
 				break;
 			case 6:
 				if (Op1Val == 0 && Op2Val == 1) {
 					Asm = "dc\tivac";
 					insn_id = ARM64_INS_DC;
-					op_dc = ARM64_DC_IVAC;
+					op_dc = A64DC_IVAC;
 				}
 				if (Op1Val == 0 && Op2Val == 2) {
 					Asm = "dc\tisw";
 					insn_id = ARM64_INS_DC;
-					op_dc = ARM64_DC_ISW;
+					op_dc = A64DC_ISW;
 				}
 				break;
 			case 10:
 				if (Op1Val == 3 && Op2Val == 1) {
 					Asm = "dc\tcvac";
 					insn_id = ARM64_INS_DC;
-					op_dc = ARM64_DC_CVAC;
+					op_dc = A64DC_CVAC;
 				} else if (Op1Val == 0 && Op2Val == 2) {
 					Asm = "dc\tcsw";
 					insn_id = ARM64_INS_DC;
-					op_dc = ARM64_DC_CSW;
+					op_dc = A64DC_CSW;
 				}
 				break;
 			case 11:
 				if (Op1Val == 3 && Op2Val == 1) {
 					Asm = "dc\tcvau";
 					insn_id = ARM64_INS_DC;
-					op_dc = ARM64_DC_CVAU;
+					op_dc = A64DC_CVAU;
 				}
 				break;
 			case 14:
 				if (Op1Val == 3 && Op2Val == 1) {
 					Asm = "dc\tcivac";
 					insn_id = ARM64_INS_DC;
-					op_dc = ARM64_DC_CIVAC;
+					op_dc = A64DC_CIVAC;
 				} else if (Op1Val == 0 && Op2Val == 2) {
 					Asm = "dc\tcisw";
 					insn_id = ARM64_INS_DC;
-					op_dc = ARM64_DC_CISW;
+					op_dc = A64DC_CISW;
 				}
 				break;
 
@@ -551,30 +551,30 @@ static bool printSysAlias(MCInst *MI, SStream *O)
 						switch (Op2Val) {
 							default:
 								break;
-							case 0: Asm = "at\ts1e1r"; insn_id = ARM64_INS_AT; op_at = ARM64_AT_S1E1R; break;
-							case 1: Asm = "at\ts1e1w"; insn_id = ARM64_INS_AT; op_at = ARM64_AT_S1E1W; break;
-							case 2: Asm = "at\ts1e0r"; insn_id = ARM64_INS_AT; op_at = ARM64_AT_S1E0R; break;
-							case 3: Asm = "at\ts1e0w"; insn_id = ARM64_INS_AT; op_at = ARM64_AT_S1E0W; break;
+							case 0: Asm = "at\ts1e1r"; insn_id = ARM64_INS_AT; op_at = A64AT_S1E1R; break;
+							case 1: Asm = "at\ts1e1w"; insn_id = ARM64_INS_AT; op_at = A64AT_S1E1W; break;
+							case 2: Asm = "at\ts1e0r"; insn_id = ARM64_INS_AT; op_at = A64AT_S1E0R; break;
+							case 3: Asm = "at\ts1e0w"; insn_id = ARM64_INS_AT; op_at = A64AT_S1E0W; break;
 						}
 						break;
 					case 4:
 						switch (Op2Val) {
 							default:
 								break;
-							case 0: Asm = "at\ts1e2r"; insn_id = ARM64_INS_AT; op_at = ARM64_AT_S1E2R; break;
-							case 1: Asm = "at\ts1e2w"; insn_id = ARM64_INS_AT; op_at = ARM64_AT_S1E2W; break;
-							case 4: Asm = "at\ts12e1r"; insn_id = ARM64_INS_AT; op_at = ARM64_AT_S1E1R; break;
-							case 5: Asm = "at\ts12e1w"; insn_id = ARM64_INS_AT; op_at = ARM64_AT_S1E1W; break;
-							case 6: Asm = "at\ts12e0r"; insn_id = ARM64_INS_AT; op_at = ARM64_AT_S1E0R; break;
-							case 7: Asm = "at\ts12e0w"; insn_id = ARM64_INS_AT; op_at = ARM64_AT_S1E0W; break;
+							case 0: Asm = "at\ts1e2r"; insn_id = ARM64_INS_AT; op_at = A64AT_S1E2R; break;
+							case 1: Asm = "at\ts1e2w"; insn_id = ARM64_INS_AT; op_at = A64AT_S1E2W; break;
+							case 4: Asm = "at\ts12e1r"; insn_id = ARM64_INS_AT; op_at = A64AT_S1E1R; break;
+							case 5: Asm = "at\ts12e1w"; insn_id = ARM64_INS_AT; op_at = A64AT_S1E1W; break;
+							case 6: Asm = "at\ts12e0r"; insn_id = ARM64_INS_AT; op_at = A64AT_S1E0R; break;
+							case 7: Asm = "at\ts12e0w"; insn_id = ARM64_INS_AT; op_at = A64AT_S1E0W; break;
 						}
 						break;
 					case 6:
 						switch (Op2Val) {
 							default:
 								break;
-							case 0: Asm = "at\ts1e3r"; insn_id = ARM64_INS_AT; op_at = ARM64_AT_S1E3R; break;
-							case 1: Asm = "at\ts1e3w"; insn_id = ARM64_INS_AT; op_at = ARM64_AT_S1E3W; break;
+							case 0: Asm = "at\ts1e3r"; insn_id = ARM64_INS_AT; op_at = A64AT_S1E3R; break;
+							case 1: Asm = "at\ts1e3w"; insn_id = ARM64_INS_AT; op_at = A64AT_S1E3W; break;
 						}
 						break;
 				}
@@ -593,32 +593,32 @@ static bool printSysAlias(MCInst *MI, SStream *O)
 						switch (Op2Val) {
 							default:
 								break;
-							case 0: Asm = "tlbi\tvmalle1is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VMALLE1IS; break;
-							case 1: Asm = "tlbi\tvae1is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VAE1IS; break;
-							case 2: Asm = "tlbi\taside1is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_ASIDE1IS; break;
-							case 3: Asm = "tlbi\tvaae1is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VAAE1IS; break;
-							case 5: Asm = "tlbi\tvale1is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VALE1IS; break;
-							case 7: Asm = "tlbi\tvaale1is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VAALE1IS; break;
+							case 0: Asm = "tlbi\tvmalle1is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VMALLE1IS; break;
+							case 1: Asm = "tlbi\tvae1is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VAE1IS; break;
+							case 2: Asm = "tlbi\taside1is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_ASIDE1IS; break;
+							case 3: Asm = "tlbi\tvaae1is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VAAE1IS; break;
+							case 5: Asm = "tlbi\tvale1is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VALE1IS; break;
+							case 7: Asm = "tlbi\tvaale1is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VAALE1IS; break;
 						}
 						break;
 					case 4:
 						switch (Op2Val) {
 							default:
 								break;
-							case 0: Asm = "tlbi\talle2is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_ALLE2IS; break;
-							case 1: Asm = "tlbi\tvae2is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VAE2IS; break;
-							case 4: Asm = "tlbi\talle1is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_ALLE1IS; break;
-							case 5: Asm = "tlbi\tvale2is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VALE2IS; break;
-							case 6: Asm = "tlbi\tvmalls12e1is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VMALLS12E1IS; break;
+							case 0: Asm = "tlbi\talle2is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_ALLE2IS; break;
+							case 1: Asm = "tlbi\tvae2is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VAE2IS; break;
+							case 4: Asm = "tlbi\talle1is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_ALLE1IS; break;
+							case 5: Asm = "tlbi\tvale2is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VALE2IS; break;
+							case 6: Asm = "tlbi\tvmalls12e1is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VMALLS12E1IS; break;
 						}
 						break;
 					case 6:
 						switch (Op2Val) {
 							default:
 								break;
-							case 0: Asm = "tlbi\talle3is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_ALLE3IS; break;
-							case 1: Asm = "tlbi\tvae3is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VAE3IS; break;
-							case 5: Asm = "tlbi\tvale3is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VALE3IS; break;
+							case 0: Asm = "tlbi\talle3is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_ALLE3IS; break;
+							case 1: Asm = "tlbi\tvae3is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VAE3IS; break;
+							case 5: Asm = "tlbi\tvale3is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VALE3IS; break;
 						}
 						break;
 				}
@@ -631,8 +631,8 @@ static bool printSysAlias(MCInst *MI, SStream *O)
 						switch (Op2Val) {
 							default:
 								break;
-							case 1: Asm = "tlbi\tipas2e1is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_IPAS2E1IS; break;
-							case 5: Asm = "tlbi\tipas2le1is"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_IPAS2LE1IS; break;
+							case 1: Asm = "tlbi\tipas2e1is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_IPAS2E1IS; break;
+							case 5: Asm = "tlbi\tipas2le1is"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_IPAS2LE1IS; break;
 						}
 						break;
 				}
@@ -645,8 +645,8 @@ static bool printSysAlias(MCInst *MI, SStream *O)
 						switch (Op2Val) {
 							default:
 								break;
-							case 1: Asm = "tlbi\tipas2e1"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_IPAS2E1; break;
-							case 5: Asm = "tlbi\tipas2le1"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_IPAS2LE1; break;
+							case 1: Asm = "tlbi\tipas2e1"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_IPAS2E1; break;
+							case 5: Asm = "tlbi\tipas2le1"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_IPAS2LE1; break;
 						}
 						break;
 				}
@@ -659,32 +659,32 @@ static bool printSysAlias(MCInst *MI, SStream *O)
 						switch (Op2Val) {
 							default:
 								break;
-							case 0: Asm = "tlbi\tvmalle1"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VMALLE1; break;
-							case 1: Asm = "tlbi\tvae1"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VAE1; break;
-							case 2: Asm = "tlbi\taside1"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_ASIDE1; break;
-							case 3: Asm = "tlbi\tvaae1"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VAAE1; break;
-							case 5: Asm = "tlbi\tvale1"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VALE1; break;
-							case 7: Asm = "tlbi\tvaale1"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VAALE1; break;
+							case 0: Asm = "tlbi\tvmalle1"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VMALLE1; break;
+							case 1: Asm = "tlbi\tvae1"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VAE1; break;
+							case 2: Asm = "tlbi\taside1"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_ASIDE1; break;
+							case 3: Asm = "tlbi\tvaae1"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VAAE1; break;
+							case 5: Asm = "tlbi\tvale1"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VALE1; break;
+							case 7: Asm = "tlbi\tvaale1"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VAALE1; break;
 						}
 						break;
 					case 4:
 						switch (Op2Val) {
 							default:
 								break;
-							case 0: Asm = "tlbi\talle2"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_ALLE2; break;
-							case 1: Asm = "tlbi\tvae2"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VAE2; break;
-							case 4: Asm = "tlbi\talle1"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_ALLE1; break;
-							case 5: Asm = "tlbi\tvale2"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VALE2; break;
-							case 6: Asm = "tlbi\tvmalls12e1"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VMALLS12E1; break;
+							case 0: Asm = "tlbi\talle2"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_ALLE2; break;
+							case 1: Asm = "tlbi\tvae2"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VAE2; break;
+							case 4: Asm = "tlbi\talle1"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_ALLE1; break;
+							case 5: Asm = "tlbi\tvale2"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VALE2; break;
+							case 6: Asm = "tlbi\tvmalls12e1"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VMALLS12E1; break;
 						}
 						break;
 					case 6:
 						switch (Op2Val) {
 							default:
 								break;
-							case 0: Asm = "tlbi\talle3"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_ALLE3; break;
-							case 1: Asm = "tlbi\tvae3"; insn_id = ARM64_INS_TLBI;  op_tlbi = ARM64_TLBI_VAE3; break;
-							case 5: Asm = "tlbi\tvale3"; insn_id = ARM64_INS_TLBI; op_tlbi = ARM64_TLBI_VALE3; break;
+							case 0: Asm = "tlbi\talle3"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_ALLE3; break;
+							case 1: Asm = "tlbi\tvae3"; insn_id = ARM64_INS_TLBI;  op_tlbi = A64TLBI_VAE3; break;
+							case 5: Asm = "tlbi\tvale3"; insn_id = ARM64_INS_TLBI; op_tlbi = A64TLBI_VALE3; break;
 						}
 						break;
 				}
diff --git a/arch/AArch64/AArch64Module.c b/arch/AArch64/AArch64Module.c
index 7fc5ddf4..be6124a9 100644
--- a/arch/AArch64/AArch64Module.c
+++ b/arch/AArch64/AArch64Module.c
@@ -9,6 +9,90 @@
 #include "AArch64InstPrinter.h"
 #include "AArch64Mapping.h"
 #include "AArch64Module.h"
+#include "AArch64BaseInfo.h"
+
+const char *AArch64_reg_name_ex(csh handle, unsigned int reg_info)
+{
+	bool valid;
+	static char regNameString[128] = {0};
+	char* regName = regNameString;
+
+	#define GetRegType(reg_info) ((reg_info >> 24) & 0xFF)
+	#define GetRegValue(reg_info) (reg_info & 0xFFFFF)
+	#define GetInsnType(reg_info) ((reg_info >> 20) & 0xF)
+
+	arm64_op_type type = GetRegType(reg_info);
+	if (type == 0)
+		type = ARM64_OP_REG;
+
+	uint32_t value = GetRegValue(reg_info);
+
+	switch (type)
+	{
+		case ARM64_OP_REG:
+			if (value < ARM64_REG_ENDING)
+				return AArch64_reg_name(handle, value);
+		case ARM64_OP_REG_MRS:
+			A64SysRegMapper_toString(&AArch64_MRSMapper, value, regName);
+			return regName;
+		case ARM64_OP_REG_MSR:
+			A64SysRegMapper_toString(&AArch64_MSRMapper, value, regName);
+			return regName;
+		case ARM64_OP_PSTATE:
+			regName = A64NamedImmMapper_toString(&A64PState_PStateMapper, value, &valid);
+			if (valid)
+				return regName;
+		case ARM64_OP_SYS:
+			switch (GetInsnType(reg_info))
+			{
+				case 1: // ARM64_INS_AT
+					regName = A64NamedImmMapper_toString(&A64AT_ATMapper, value, &valid);
+					if (valid)
+						return regName;
+					break;
+				case 2: // ARM64_INS_DC
+					regName = A64NamedImmMapper_toString(&A64DC_DCMapper, value, &valid);
+					if (valid)
+						return regName;
+					break;
+				case 3: // ARM64_INS_IC
+					regName = A64NamedImmMapper_toString(&A64IC_ICMapper, value, &valid);
+					if (valid)
+						return regName;
+					break;
+				case 4: // ARM64_INS_TLBI
+					regName = A64NamedImmMapper_toString(&A64TLBI_TLBIMapper, value, &valid);
+					if (valid)
+						return regName;
+					break;
+				default:
+					break;
+			}
+		case ARM64_OP_BARRIER:
+			switch (GetInsnType(reg_info))
+			{
+				case 1: // ARM64_INS_ISB
+					regName = A64NamedImmMapper_toString(&A64ISB_ISBMapper, value, &valid);
+					if (valid)
+						return regName;
+					break;
+				case 2: // ARM64_INS_DMB
+				case 3: // ARM64_INS_DSB
+					regName = A64NamedImmMapper_toString(&A64DB_DBarrierMapper, value, &valid);
+					if (valid)
+						return regName;
+					break;
+
+				default:
+					break;
+			}
+
+		default:
+			return NULL;
+	}
+
+	return NULL;
+}
 
 cs_err AArch64_global_init(cs_struct *ud)
 {
@@ -20,7 +104,7 @@ cs_err AArch64_global_init(cs_struct *ud)
 	ud->printer_info = mri;
 	ud->getinsn_info = mri;
 	ud->disasm = AArch64_getInstruction;
-	ud->reg_name = AArch64_reg_name;
+	ud->reg_name = AArch64_reg_name_ex;
 	ud->insn_id = AArch64_get_insn_id;
 	ud->insn_name = AArch64_insn_name;
 	ud->group_name = AArch64_group_name;

```

`README.md`:

```md
# FRIEND

**F**lexible **R**egister/**I**nstruction **E**xtender a**N**d **D**ocumentation

## Features

FRIEND is an IDA plugin created to improve disassembly and bring register/instruction documentation right into IDA View.

### 1. Improved processor modules using third party libraries (like Capstone)   

![](./Resources/screenshots/proc_ext.png)

### 2. Hints for instructions and registers in IDA View and Decompiler View   

![](./Resources/screenshots/reg_ins_hints.png)

### 3. Ability to show external reference for highlighted item in a browser    

![](./Resources/screenshots/external_doc.png)

### 4. Function Summary in IDA View and Decompiler View   

![](./Resources/screenshots/summary.png)

### 5. Ability to pick only features you are interested in and save setting in IDB

![](./Resources/screenshots/settings.png)

Note: it may be confusing if there's only one element group, you still need to
click on it to enable the features.

## How to build

### Preparing the build environment

To build the IDA plugin, there are few dependencies to satisfy:

* [CMake](https://cmake.org/download/) 3.3 or higher
* GCC or Clang on Linux/macOS. On Windows, use the
  Visual Studio 2015.
* Git
* IDA SDK (unpack into ``idasdk``)
* Hex-Rays SDK (optional, copy to ``hexrays_sdk``)

Unzip the contents of the IDA SDK into `idasdk`, and copy the Hex-Rays SDK to hexrays_sdk (use `-DUSE_HEXRAYS=OFF` with cmake to build without HexRays support). On Linux or MacOS, one can use the following commands:

```sh
$ unzip /path/to/idasdkXX.zip -d idasdk
$ mv idasdk/idasdkXX/* idasdk
$ rm -r idasdk/idasdkXX
$ cp -r /path/to/ida/plugins/hexrays_sdk hexrays_sdk
```

### CMake options

`USE_HEXRAYS=OFF` - to build without HexRays decompiler SDK (`ON` by default)  
`USE_IDA6_SDK=ON` - to build against IDA 6.x SDK (`OFF` by default)

### Linux

Use ``cmake`` to prepare the build environment and run ``make`` to build the plugins:

```sh
$ mkdir _build
$ cd _build
$ cmake [-DUSE_HEXRAYS=OFF] [-DUSE_IDA6_SDK=ON] ..
$ make
```

### MacOS

Use ``cmake`` to prepare the build environment and run ``make`` to build the plugins:

```sh
$ mkdir _build
$ cd _build
$ cmake [-DUSE_HEXRAYS=OFF] [-DUSE_IDA6_SDK=ON] ..
$ make
```

If you prefer to have an Xcode project and build everything from there, run the following commands instead:

```sh
$ mkdir _build
$ cd _build
$ cmake -G Xcode [-DUSE_HEXRAYS=OFF] [-DUSE_IDA6_SDK=ON] ..
$ open FRIEND.xcodeproj # or simply run xcodebuild
```

### Windows

Use ``cmake`` to prepare the build environment and run ``make`` to build the plugins:

```sh
$ mkdir _build
$ cd _build
$ "%VS140COMNTOOLS%\..\..\VC\vcvarsall.bat" x86
$ cmake -G "Visual Studio 14 2015" [-DUSE_HEXRAYS=OFF] [-DUSE_IDA6_SDK=ON] ..
$ msbuild FRIEND.sln /p:Configuration=Release
```

x64 build instructions (tested for IDA Pro 7.0 on Windows 10 x64):
```sh
mkdir _build64
cd _build64
"%VS140COMNTOOLS%\..\..\VC\vcvarsall.bat" x64
cmake -G "Visual Studio 14 2015 Win64" [-DUSE_HEXRAYS=OFF] [-DUSE_IDA6_SDK=ON] ..
msbuild FRIEND.sln /p:Configuration=Release /p:Platform=X64 /m
```

## Installation

Copy the built binaries into the IDA Pro plugins directory. These are the default paths:

OS      | Plugin path
--------|-------------------------------------------
Linux   | `/opt/ida-X.X/plugins`
macOS   | `/Applications/IDA Pro X.X/idabin/plugins`
Windows | `%ProgramFiles(x86)%\IDA 6.X\plugins` or `%ProgramFiles%\IDA 7.X\plugins`

## Configuration files

The content of hints is discussed [here](https://github.com/alexhude/FRIEND/issues/1)

FRIEND configuration file has following structure:

```
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<documentation>
	<document id="pdf_id" name="ARM Architecture Reference Manual" version="A.k">
		<path>/path/to/your/pdf/or/link</path>
	</document>
	<elements>
		<group type="reg" name="Group Name">
			<hint page="1" header="Element Header" doc_id="pdf_id" token="R0">info</>
			...
		</group>
		<group type="ins" name="Group Name">
			<hint page="2" header="Element Header" doc_id="pdf_id" token="MOV">info</>
			...
		</group>
		...
	</elements>
</documentation>
```

Please note that you have to put your own \<path\> to pdf file to be able to use external documentation in a browser.

You can use a local file too.  Assuming your pdf is in `/Users/foo/doc/doc.pdf`, just
put that after `<path>`.  Do not add `file://` as it will be prepended later.

## Hint Editor

To make contribution to this project easier, there is a simple config editor.  
![](./Resources/screenshots/hint_editor.png)

__NOTE:__ It can only be built on MacOS with Xcode 8 or higher. Other systems are not supported.

Use ``cmake`` to generate Xcode project.

```sh
$ cd HintEditor/HintEditor/
$ mkdir _build
$ cd _build
$ cmake -G Xcode ..
$ xcodebuild
```

Launch the application bundle with ``open``:

```
$ open Debug/HintEditor.app
```

## Dependencies

FRIEND requires:  
- [IDA SDK](https://www.hex-rays.com/products/ida/support/download.shtml)   
- [Capstone](https://github.com/aquynh/capstone) (built with Patches/capstone.diff)  
- [pugixml](https://github.com/zeux/pugixml)

Hint Editor requires:  
- [AEXML](https://github.com/tadija/AEXML) (built with Patches/aexml.diff)  

## Credits

@ **in7egral, mbazaliy** for bug reports and all kind of support    
@ __qwertyoruiopz, iH8sn0w, Morpheus\_\_\_\_\_\_, xerub, msolnik, marcograss, pr0x13, \_argp, oleavr, brinlyau__ and other gang for inspiration  
@ __\_kamino\___ for porting project to Windows and Linux  
@ __williballenthin__ for the idea of function summary

```

`cmake/FindIdaSdk.cmake`:

```cmake
# Copyright 2011-2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Locates and configures the IDA Pro SDK.
#
# Defines the following variables:
#
#   IdaSdk_INCLUDE_DIRS - Include directories for the IDA Pro SDK.
#   IdaSdk_PLATFORM - IDA SDK platform, one of __LINUX__, __NT__ or __MAC__.
#
# Example:
#
#   find_package(IdaSdk REQUIRED)
#   include_directories(${IdaSdk_INCLUDE_DIRS})
#
#   # Builds target plugin32.plx
#   add_ida_plugin(plugin32 myplugin.cc)
#   # Builds targets plugin.plx and plugin.plx64
#   add_ida_plugin(plugin EA64 myplugin.cc)
#   # Builds target plugin64.plx64
#   add_ida_plugin(plugin64 NOEA32 EA64 myplugin.cc)
#
#   Builds targets ldr.llx and ldr64.llx64
#   add_ida_loader(ldr EA64 myloader.cc)

include(CMakeParseArguments)

set(IdaSdk_DIR ${PROJECT_SOURCE_DIR}/idasdk CACHE STRING "Path to IDA SDK")
set(IdaSdk_INCLUDE_DIRS ${IdaSdk_DIR}/include)

# Define some platform specific variables for later use.
if(APPLE)
  set(IdaSdk_PLATFORM __MAC__)
  if(USE_IDA6_SDK)
    set(_plx .pmc)
    set(_plx64 .pmc64)
    set(_llx .lmc)
    set(_llx64 64.lmc64)  # An additional "64"
  else()
    set(_plx .dylib)
    set(_llx .dylib)
    set(_plx64 64.dylib)  # An additional "64"
    set(_llx64 64.dylib)  # An additional "64"
  endif()
elseif(UNIX)
  set(IdaSdk_PLATFORM __LINUX__)
  if(USE_IDA6_SDK)
    set(_plx .plx)
    set(_plx64 .plx64)
    set(_llx .llx)
    set(_llx64 64.llx64)  # An additional "64"
  else()
    set(_plx .so)
    set(_llx .so)
    set(_plx64 64.so)     # An additional "64"
    set(_llx64 64.so)     # An additional "64"
  endif()
elseif(WIN32)
  set(IdaSdk_PLATFORM __NT__)
  if(USE_IDA6_SDK)
    set(_plx .plw)
    set(_plx64 .p64)
    set(_llx .ldw)
    set(_llx64 64.l64)    # An additional "64"
  else()
    set(_plx .dll)
    set(_llx .dll)
    set(_plx64 64.dll)    # An additional "64"
    set(_llx64 64.dll)    # An additional "64"
  endif()
else()
  message(FATAL_ERROR "Unsupported system type: ${CMAKE_SYSTEM_NAME}")
endif()

if(USE_IDA6_SDK)
  set(_osx_arch "$(ARCHS_STANDARD_32_BIT)")
  set(_lib_path "x86")
else()
  set(_osx_arch "$(ARCHS_STANDARD)")
  set(_lib_path "x64")
endif()

function(_ida_plugin name ea64 link_script)  # ARGN contains sources
  # Define a module with the specified sources.
  add_library(${name} MODULE ${ARGN})

  # Build for 64bit
  if(NOT USE_IDA6_SDK)
    target_compile_definitions(${name} PUBLIC __X64__)
  endif()

  # Support for 64-bit addresses.
  if(ea64)
    target_compile_definitions(${name} PUBLIC __EA64__)
  endif()

  # Add the necessary __IDP__ define and allow to use "dangerous" and standard
  # file functions.
  target_compile_definitions(${name} PUBLIC
                             ${IdaSdk_PLATFORM}
                             __IDP__
                             USE_DANGEROUS_FUNCTIONS
                             USE_STANDARD_FILE_FUNCTIONS)

  set_target_properties(${name} PROPERTIES PREFIX "" SUFFIX "")
  if(UNIX)
    if(USE_IDA6_SDK)
      # Always build a 32-bit executable and use the linker script needed for IDA.
      target_compile_options(${name} PUBLIC -m32)
    endif()

    if(APPLE)
      set(CMAKE_OSX_ARCHITECTURES ${_osx_arch})
      set(dynamic_lookup -Wl,-flat_namespace
                         -Wl,-undefined,warning
                         -Wl,-exported_symbol,_PLUGIN)
    else()
      set(script_flag -Wl,--version-script ${IdaSdk_DIR}/${link_script})
    endif()

    if(USE_IDA6_SDK)
      target_link_libraries(${name} -m32 ${script_flag} ${dynamic_lookup})
    else()
      target_link_libraries(${name} ${script_flag} ${dynamic_lookup})
    endif()

    # For qrefcnt_obj_t in ida.hpp
    target_compile_options(${name} PUBLIC -Wno-non-virtual-dtor)
  elseif(WIN32)
    if(ea64)
      set(IdaSdk_LIBRARY ${IdaSdk_DIR}/lib/${_lib_path}_win_vc_64/ida.lib)
    else()
      set(IdaSdk_LIBRARY ${IdaSdk_DIR}/lib/${_lib_path}_win_vc_32/ida.lib)
    endif()
    target_link_libraries(${name} ${IdaSdk_LIBRARY})
  endif()
endfunction()

function(add_ida_plugin name)
  set(options NOEA32 EA64)
  cmake_parse_arguments(add_ida_plugin "${options}" "" "" ${ARGN})

  if(NOT DEFINED(add_ida_plugin_NOEA32))
    _ida_plugin(${name}${_plx} FALSE plugins/plugin.script
                ${add_ida_plugin_UNPARSED_ARGUMENTS})
  endif()
  if(add_ida_plugin_EA64)
    _ida_plugin(${name}${_plx64} TRUE plugins/plugin.script
                ${add_ida_plugin_UNPARSED_ARGUMENTS})
  endif()
endfunction()

function(add_ida_loader name)
  set(options NOEA32 EA64)
  cmake_parse_arguments(add_ida_loader "${options}" "" "" ${ARGN})

  if(NOT DEFINED(add_ida_loader_NOEA32))
    _ida_plugin(${name}${_llx} FALSE ldr/ldr.script
                ${add_ida_loader_UNPARSED_ARGUMENTS})
  endif()
  if(add_ida_loader_EA64)
    _ida_plugin(${name}${_llx64} TRUE ldr/ldr.script
                ${add_ida_loader_UNPARSED_ARGUMENTS})
  endif()
endfunction()


```