Project Path: arc_Net5F_AmalgamEngine_tzzg1q2g

Source Tree:

```txt
arc_Net5F_AmalgamEngine_tzzg1q2g
├── CMake
│   ├── AddressSanitizer.cmake
│   ├── FindSDL2.cmake
│   ├── FindSDL2_gfx.cmake
│   ├── FindSDL2_image.cmake
│   ├── FindSDL2_mixer.cmake
│   ├── FindSDL2_ttf.cmake
│   ├── SDL2_net.cmake
│   ├── ThreadSanitizer.cmake
│   ├── copy_if_does_not_exist.cmake
│   ├── lua.cmake
│   └── readerwriterqueue.cmake
├── CMakeLists.txt
├── CMakeSettings.json
├── LICENSE.txt
├── Libraries
│   ├── AmalgamUI
│   ├── CircularBuffer
│   ├── QueuedEvents
│   ├── SDL_net
│   ├── SQLiteCpp
│   ├── bitsery
│   ├── entt
│   ├── libmorton
│   ├── lua
│   ├── lz4
│   ├── mp11
│   ├── nativefiledialog-extended
│   ├── readerwriterqueue
│   ├── sol2
│   └── tracy
├── README.md
├── Resources
│   ├── EngineDefaults
│   │   └── Common
│   │       └── Assets
│   │           └── Textures
│   │               └── Defaults
│   │                   └── Icon.png
│   └── ResourceImporter
│       ├── Common
│       │   └── Assets
│       │       ├── Fonts
│       │       │   └── B612-Regular.ttf
│       │       └── Textures
│       │           ├── Checkbox
│       │           │   ├── Checked.png
│       │           │   └── Unchecked.png
│       │           ├── Dialogs
│       │           │   └── Shadow.png
│       │           ├── HamburgerButton
│       │           │   ├── Hovered.png
│       │           │   ├── Normal.png
│       │           │   └── Pressed.png
│       │           ├── HeaderBackground.png
│       │           ├── Highlights
│       │           │   ├── Hovered.png
│       │           │   └── Selected.png
│       │           ├── Icons
│       │           │   ├── Collapsed_1600.png
│       │           │   ├── Collapsed_1920.png
│       │           │   ├── Expanded_1600.png
│       │           │   ├── Expanded_1920.png
│       │           │   ├── Minus.png
│       │           │   ├── MinusHovered.png
│       │           │   ├── Plus.png
│       │           │   └── PlusHovered.png
│       │           ├── MainButton
│       │           │   ├── Disabled.png
│       │           │   ├── DisabledThick.png
│       │           │   ├── Hovered.png
│       │           │   ├── HoveredThick.png
│       │           │   ├── Normal.png
│       │           │   ├── NormalThick.png
│       │           │   ├── Pressed.png
│       │           │   └── PressedThick.png
│       │           ├── SpriteEditView
│       │           │   └── Checkerboard.png
│       │           ├── SpritePanel
│       │           │   └── Background_1600.png
│       │           ├── TextInput
│       │           │   ├── Disabled.png
│       │           │   ├── Hovered.png
│       │           │   ├── Normal.png
│       │           │   └── Selected.png
│       │           ├── Thumbnail
│       │           │   ├── Active.png
│       │           │   ├── Backdrop.png
│       │           │   ├── Hovered.png
│       │           │   └── Selected.png
│       │           └── WindowBackground.png
│       ├── Linux
│       │   └── README.txt
│       └── Windows
│           └── README.txt
├── Scripts
│   └── Linux
│       ├── FormatEngineSource.sh
│       ├── GetRequiredCmake.sh
│       ├── InstallDependencies.sh
│       ├── InstallLoadTestDependencies.sh
│       └── InstallServerDependencies.sh
└── Source
    ├── CMakeLists.txt
    ├── ClientLib
    │   ├── CMakeLists.txt
    │   ├── Config
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   ├── UserConfig.cpp
    │   │   │   └── UserConfigInitializer.cpp
    │   │   └── Public
    │   │       ├── UserConfig.h
    │   │       ├── UserConfig.json
    │   │       ├── UserConfigInitializer.h
    │   │       └── UserConfigStructs.h
    │   ├── Launch
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   └── Application.cpp
    │   │   └── Public
    │   │       └── Application.h
    │   ├── Network
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   ├── MessageProcessor.cpp
    │   │   │   └── Network.cpp
    │   │   └── Public
    │   │       ├── ConnectionError.h
    │   │       ├── IMessageProcessorExtension.h
    │   │       ├── MessageProcessor.h
    │   │       ├── MessageProcessorContext.h
    │   │       ├── Network.h
    │   │       └── PlayerMovementUpdate.h
    │   ├── Renderer
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   ├── Renderer.cpp
    │   │   │   └── WorldSpriteSorter.cpp
    │   │   └── Public
    │   │       ├── IRendererExtension.h
    │   │       ├── Renderer.h
    │   │       ├── RendererContext.h
    │   │       ├── SpriteSortInfo.h
    │   │       └── WorldSpriteSorter.h
    │   ├── Simulation
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   ├── AVEntityHelpers.cpp
    │   │   │   ├── AVSystem.cpp
    │   │   │   ├── CameraSystem.cpp
    │   │   │   ├── CastHelper.cpp
    │   │   │   ├── CastSystem.cpp
    │   │   │   ├── ChunkUpdateSystem.cpp
    │   │   │   ├── ComponentUpdateSystem.cpp
    │   │   │   ├── EntityLifetimeSystem.cpp
    │   │   │   ├── GraphicData
    │   │   │   │   └── GraphicData.cpp
    │   │   │   ├── GraphicHelpers.cpp
    │   │   │   ├── GraphicSystem.cpp
    │   │   │   ├── IconData
    │   │   │   │   └── IconData.cpp
    │   │   │   ├── InventorySystem.cpp
    │   │   │   ├── ItemData
    │   │   │   │   └── ItemData.cpp
    │   │   │   ├── ItemSystem.cpp
    │   │   │   ├── NpcMovementSystem.cpp
    │   │   │   ├── PlayerInputSystem.cpp
    │   │   │   ├── PlayerMovementSystem.cpp
    │   │   │   ├── ReplicationTickOffset.cpp
    │   │   │   ├── ServerConnectionSystem.cpp
    │   │   │   ├── Simulation.cpp
    │   │   │   ├── TileMap
    │   │   │   │   └── TileMap.cpp
    │   │   │   ├── TileUpdateSystem.cpp
    │   │   │   └── World.cpp
    │   │   └── Public
    │   │       ├── AVEntityHelpers.h
    │   │       ├── AVEntityID.h
    │   │       ├── AVSystem.h
    │   │       ├── CameraSystem.h
    │   │       ├── CastHelper.h
    │   │       ├── CastSystem.h
    │   │       ├── CastableData
    │   │       │   ├── AVEntityState.h
    │   │       │   └── VisualEffectState.h
    │   │       ├── ChunkUpdateSystem.h
    │   │       ├── ComponentUpdateSystem.h
    │   │       ├── Components
    │   │       │   ├── AVEffects.h
    │   │       │   ├── ClientCastState.h
    │   │       │   ├── ClientGraphicState.h
    │   │       │   ├── InputHistory.h
    │   │       │   └── NeedsAdjacentChunks.h
    │   │       ├── EntityLifetimeSystem.h
    │   │       ├── EnttGroups.h
    │   │       ├── Events
    │   │       │   └── SimulationStarted.h
    │   │       ├── GraphicData
    │   │       │   ├── AnimationRenderData.h
    │   │       │   ├── GraphicData.h
    │   │       │   └── SpriteRenderData.h
    │   │       ├── GraphicHelpers.h
    │   │       ├── GraphicSystem.h
    │   │       ├── ISimulationExtension.h
    │   │       ├── IconData
    │   │       │   ├── IconData.h
    │   │       │   └── IconRenderData.h
    │   │       ├── InventorySystem.h
    │   │       ├── ItemData
    │   │       │   ├── ItemCache.h
    │   │       │   └── ItemData.h
    │   │       ├── ItemSystem.h
    │   │       ├── NpcMovementSystem.h
    │   │       ├── PlayerInputSystem.h
    │   │       ├── PlayerMovementSystem.h
    │   │       ├── ReplicationTickOffset.h
    │   │       ├── ServerConnectionSystem.h
    │   │       ├── Simulation.h
    │   │       ├── SimulationContext.h
    │   │       ├── TileMap
    │   │       │   └── TileMap.h
    │   │       ├── TileUpdateSystem.h
    │   │       ├── World.h
    │   │       └── WorldObjectID.h
    │   ├── UserInterface
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   ├── UserInterface.cpp
    │   │   │   └── WorldObjectLocator.cpp
    │   │   └── Public
    │   │       ├── IUserInterfaceExtension.h
    │   │       ├── PhantomSpriteInfo.h
    │   │       ├── SpriteColorModInfo.h
    │   │       ├── UserInterface.h
    │   │       ├── UserInterfaceContext.h
    │   │       └── WorldObjectLocator.h
    │   └── Utility
    │       ├── CMakeLists.txt
    │       ├── Private
    │       │   └── ClientTransforms.cpp
    │       └── Public
    │           └── ClientTransforms.h
    ├── EngineSupplementExamples
    │   ├── Client
    │   │   └── Config
    │   │       └── Public
    │   │           └── Config.h
    │   ├── README.md
    │   ├── Server
    │   │   ├── Config
    │   │   │   └── Public
    │   │   │       └── Config.h
    │   │   └── Simulation
    │   │       └── Public
    │   │           └── TypeLists
    │   │               ├── ProjectAITypes.h
    │   │               ├── ProjectObservedComponentTypes.h
    │   │               └── ProjectPersistedComponentTypes.h
    │   └── Shared
    │       ├── Config
    │       │   └── Public
    │       │       └── SharedConfig.h
    │       ├── Simulation
    │       │   └── Public
    │       │       ├── CastableData
    │       │       │   ├── CastableDef.h
    │       │       │   ├── CastableProjectData.h
    │       │       │   ├── CastableRequirementType.h
    │       │       │   ├── EntityInteractionType.h
    │       │       │   ├── ItemInteractionType.h
    │       │       │   ├── SpellType.h
    │       │       │   └── ValidateCast.h
    │       │       ├── CollisionLayerType.h
    │       │       ├── EntityGraphicType.h
    │       │       └── TypeLists
    │       │           ├── ProjectItemPropertyTypes.h
    │       │           └── ProjectReplicatedComponentTypes.h
    │       └── UserInterface
    │           └── Public
    │               └── DisplayStrings.h
    ├── ResourceImporter
    │   ├── CMakeLists.txt
    │   ├── Config
    │   │   ├── CMakeLists.txt
    │   │   └── Public
    │   │       └── Config.h
    │   ├── DataModel
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   ├── AnimationModel.cpp
    │   │   │   ├── BoundingBoxModel.cpp
    │   │   │   ├── DataModel.cpp
    │   │   │   ├── EditorAnimation.cpp
    │   │   │   ├── EditorGraphicRef.cpp
    │   │   │   ├── EditorSprite.cpp
    │   │   │   ├── EntityGraphicSetModel.cpp
    │   │   │   ├── GraphicSetModel.cpp
    │   │   │   ├── IconModel.cpp
    │   │   │   └── SpriteModel.cpp
    │   │   └── Public
    │   │       ├── AnimationModel.h
    │   │       ├── BoundingBoxModel.h
    │   │       ├── DataModel.h
    │   │       ├── EditorAnimation.h
    │   │       ├── EditorBoundingBox.h
    │   │       ├── EditorEntityGraphicSet.h
    │   │       ├── EditorFloorGraphicSet.h
    │   │       ├── EditorGraphicRef.h
    │   │       ├── EditorIcon.h
    │   │       ├── EditorIconSheet.h
    │   │       ├── EditorObjectGraphicSet.h
    │   │       ├── EditorSprite.h
    │   │       ├── EditorSpriteSheet.h
    │   │       ├── EditorTerrainGraphicSet.h
    │   │       ├── EditorWallGraphicSet.h
    │   │       ├── EntityGraphicSetModel.h
    │   │       ├── GraphicSetModel.h
    │   │       ├── IconModel.h
    │   │       ├── LibraryItemData.h
    │   │       ├── SpriteModel.h
    │   │       └── SpriteSheetID.h
    │   ├── Launch
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   ├── Application.cpp
    │   │   │   └── main.cpp
    │   │   └── Public
    │   │       └── Application.h
    │   ├── Renderer
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   └── Renderer.cpp
    │   │   └── Public
    │   │       └── Renderer.h
    │   ├── UserInterface
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   ├── MainScreen.cpp
    │   │   │   ├── TitleScreen.cpp
    │   │   │   ├── UserInterface.cpp
    │   │   │   ├── Widgets
    │   │   │   │   ├── AnimationElementsListItem.cpp
    │   │   │   │   ├── AnimationTimeline.cpp
    │   │   │   │   ├── BoundingBoxGizmo.cpp
    │   │   │   │   ├── GraphicSetSlot.cpp
    │   │   │   │   ├── LibraryCollapsibleContainer.cpp
    │   │   │   │   ├── LibraryListItem.cpp
    │   │   │   │   ├── MainButton.cpp
    │   │   │   │   ├── MainTextInput.cpp
    │   │   │   │   ├── MainThumbnail.cpp
    │   │   │   │   ├── ParentListItem.cpp
    │   │   │   │   ├── PointGizmo.cpp
    │   │   │   │   ├── StageGraphic.cpp
    │   │   │   │   ├── TimelineFrame.cpp
    │   │   │   │   ├── TimelineHandle.cpp
    │   │   │   │   └── TitleButton.cpp
    │   │   │   └── Windows
    │   │   │       ├── AddIconSheetDialog.cpp
    │   │   │       ├── AddSpriteDialog.cpp
    │   │   │       ├── AnimationEditView.cpp
    │   │   │       ├── AnimationElementsWindow.cpp
    │   │   │       ├── AnimationPropertiesWindow.cpp
    │   │   │       ├── BoundingBoxEditView.cpp
    │   │   │       ├── BoundingBoxPropertiesWindow.cpp
    │   │   │       ├── EntityGraphicSetEditView.cpp
    │   │   │       ├── EntityGraphicSetPropertiesWindow.cpp
    │   │   │       ├── GraphicSetEditView.cpp
    │   │   │       ├── GraphicSetPropertiesWindow.cpp
    │   │   │       ├── HamburgerButtonWindow.cpp
    │   │   │       ├── HamburgerMenu.cpp
    │   │   │       ├── IconEditView.cpp
    │   │   │       ├── IconPropertiesWindow.cpp
    │   │   │       ├── LibraryAddMenu.cpp
    │   │   │       ├── LibraryWindow.cpp
    │   │   │       ├── SaveBoundingBoxDialog.cpp
    │   │   │       ├── SpriteEditView.cpp
    │   │   │       ├── SpritePropertiesWindow.cpp
    │   │   │       ├── SpriteSheetEditView.cpp
    │   │   │       ├── SpriteSheetPropertiesWindow.cpp
    │   │   │       └── TitleWindow.cpp
    │   │   └── Public
    │   │       ├── MainScreen.h
    │   │       ├── TitleScreen.h
    │   │       ├── UserInterface.h
    │   │       ├── Widgets
    │   │       │   ├── AnimationElementsListItem.h
    │   │       │   ├── AnimationTimeline.h
    │   │       │   ├── BoundingBoxGizmo.h
    │   │       │   ├── GraphicSetSlot.h
    │   │       │   ├── LibraryCollapsibleContainer.h
    │   │       │   ├── LibraryListItem.h
    │   │       │   ├── MainButton.h
    │   │       │   ├── MainTextInput.h
    │   │       │   ├── MainThumbnail.h
    │   │       │   ├── ParentListItem.h
    │   │       │   ├── PointGizmo.h
    │   │       │   ├── StageGraphic.h
    │   │       │   ├── TimelineFrame.h
    │   │       │   ├── TimelineHandle.h
    │   │       │   └── TitleButton.h
    │   │       └── Windows
    │   │           ├── AddIconSheetDialog.h
    │   │           ├── AddSpriteDialog.h
    │   │           ├── AnimationEditView.h
    │   │           ├── AnimationElementsWindow.h
    │   │           ├── AnimationPropertiesWindow.h
    │   │           ├── BoundingBoxEditView.h
    │   │           ├── BoundingBoxPropertiesWindow.h
    │   │           ├── EntityGraphicSetEditView.h
    │   │           ├── EntityGraphicSetPropertiesWindow.h
    │   │           ├── GraphicSetEditView.h
    │   │           ├── GraphicSetPropertiesWindow.h
    │   │           ├── HamburgerButtonWindow.h
    │   │           ├── HamburgerMenu.h
    │   │           ├── IconEditView.h
    │   │           ├── IconPropertiesWindow.h
    │   │           ├── LibraryAddMenu.h
    │   │           ├── LibraryWindow.h
    │   │           ├── SaveBoundingBoxDialog.h
    │   │           ├── SpriteEditView.h
    │   │           ├── SpritePropertiesWindow.h
    │   │           ├── SpriteSheetEditView.h
    │   │           ├── SpriteSheetPropertiesWindow.h
    │   │           └── TitleWindow.h
    │   └── Utility
    │       ├── CMakeLists.txt
    │       ├── Private
    │       │   └── SpriteTools.cpp
    │       └── Public
    │           └── SpriteTools.h
    ├── ServerLib
    │   ├── CMakeLists.txt
    │   ├── Config
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   ├── UserConfig.cpp
    │   │   │   └── UserConfigInitializer.cpp
    │   │   └── Public
    │   │       ├── UserConfig.h
    │   │       └── UserConfigInitializer.h
    │   ├── Launch
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   └── Application.cpp
    │   │   └── Public
    │   │       └── Application.h
    │   ├── Network
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   ├── Client.cpp
    │   │   │   ├── ClientHandler.cpp
    │   │   │   ├── MessageProcessor.cpp
    │   │   │   └── Network.cpp
    │   │   └── Public
    │   │       ├── Client.h
    │   │       ├── ClientConnectionEvent.h
    │   │       ├── ClientHandler.h
    │   │       ├── ClientMap.h
    │   │       ├── IMessageProcessorExtension.h
    │   │       ├── MessageProcessor.h
    │   │       ├── MessageProcessorContext.h
    │   │       └── Network.h
    │   └── Simulation
    │       ├── CMakeLists.txt
    │       ├── Private
    │       │   ├── AISystem.cpp
    │       │   ├── CastHelper.cpp
    │       │   ├── CastSystem.cpp
    │       │   ├── ChunkStreamingSystem.cpp
    │       │   ├── ClientAOISystem.cpp
    │       │   ├── ClientConnectionSystem.cpp
    │       │   ├── ComponentChangeSystem.cpp
    │       │   ├── ComponentSyncSystem.cpp
    │       │   ├── Components
    │       │   │   └── StoredValues.cpp
    │       │   ├── Database.cpp
    │       │   ├── DialogueSystem.cpp
    │       │   ├── GraphicData
    │       │   │   └── GraphicData.cpp
    │       │   ├── IconData
    │       │   │   └── IconData.cpp
    │       │   ├── InputSystem.cpp
    │       │   ├── InventoryHelper.cpp
    │       │   ├── InventorySystem.cpp
    │       │   ├── ItemData
    │       │   │   └── ItemData.cpp
    │       │   ├── ItemSystem.cpp
    │       │   ├── Lua
    │       │   │   └── EngineLuaBindings.cpp
    │       │   ├── MovementSyncSystem.cpp
    │       │   ├── MovementSystem.cpp
    │       │   ├── NceLifetimeSystem.cpp
    │       │   ├── SaveSystem.cpp
    │       │   ├── ScriptDataSystem.cpp
    │       │   ├── Simulation.cpp
    │       │   ├── TileMap
    │       │   │   └── TileMap.cpp
    │       │   ├── TileUpdateSystem.cpp
    │       │   └── World.cpp
    │       └── Public
    │           ├── AILogic.h
    │           ├── AISystem.h
    │           ├── CastHelper.h
    │           ├── CastSystem.h
    │           ├── ChunkStreamingSystem.h
    │           ├── ClientAOISystem.h
    │           ├── ClientConnectionSystem.h
    │           ├── ComponentChangeSystem.h
    │           ├── ComponentSyncSystem.h
    │           ├── Components
    │           │   ├── CastState.h
    │           │   ├── ClientSimData.h
    │           │   ├── Dialogue.h
    │           │   ├── ItemHandler.h
    │           │   ├── ReplicatedComponentList.h
    │           │   ├── SaveTimestamp.h
    │           │   └── StoredValues.h
    │           ├── Database.h
    │           ├── DialogueSystem.h
    │           ├── EntityItemHandlerScript.h
    │           ├── EntityStoredValueID.h
    │           ├── EntityStoredValueIDMap.h
    │           ├── EnttGroups.h
    │           ├── EventSorter.h
    │           ├── GlobalStoredValueMap.h
    │           ├── GraphicData
    │           │   └── GraphicData.h
    │           ├── ISimulationExtension.h
    │           ├── IconData
    │           │   └── IconData.h
    │           ├── InputSystem.h
    │           ├── InventoryHelper.h
    │           ├── InventorySystem.h
    │           ├── ItemData
    │           │   └── ItemData.h
    │           ├── ItemSystem.h
    │           ├── Lua
    │           │   ├── DialogueChoiceConditionLua.h
    │           │   ├── DialogueLua.h
    │           │   ├── EngineLuaBindings.h
    │           │   ├── EntityInitLua.h
    │           │   ├── EntityItemHandlerLua.h
    │           │   └── ItemInitLua.h
    │           ├── MovementSyncSystem.h
    │           ├── MovementSystem.h
    │           ├── NceLifetimeSystem.h
    │           ├── PersistedComponent.h
    │           ├── SaveSystem.h
    │           ├── ScriptDataSystem.h
    │           ├── Simulation.h
    │           ├── SimulationContext.h
    │           ├── SpawnStrategy.h
    │           ├── TileMap
    │           │   └── TileMap.h
    │           ├── TileUpdateSystem.h
    │           ├── TypeLists
    │           │   ├── EngineObservedComponentTypes.h
    │           │   └── EnginePersistedComponentTypes.h
    │           └── World.h
    ├── SharedLib
    │   ├── CMakeLists.txt
    │   ├── Messages
    │   │   ├── CMakeLists.txt
    │   │   └── Public
    │   │       ├── CastCooldownInit.h
    │   │       ├── CastFailed.h
    │   │       ├── CastRequest.h
    │   │       ├── CastStarted.h
    │   │       ├── ChunkDataRequest.h
    │   │       ├── ChunkUpdate.h
    │   │       ├── ChunkWireSnapshot.h
    │   │       ├── CombineItems.h
    │   │       ├── CombineItemsRequest.h
    │   │       ├── ComponentUpdate.h
    │   │       ├── ConnectionRequest.h
    │   │       ├── ConnectionResponse.h
    │   │       ├── DialogueChoiceRequest.h
    │   │       ├── DialogueResponse.h
    │   │       ├── EngineMessageType.h
    │   │       ├── EntityDelete.h
    │   │       ├── EntityDeleteRequest.h
    │   │       ├── EntityInit.h
    │   │       ├── EntityInitRequest.h
    │   │       ├── EntityInitScriptRequest.h
    │   │       ├── EntityInitScriptResponse.h
    │   │       ├── EntityNameChangeRequest.h
    │   │       ├── ExplicitConfirmation.h
    │   │       ├── GraphicStateChangeRequest.h
    │   │       ├── Heartbeat.h
    │   │       ├── InputChangeRequest.h
    │   │       ├── InventoryAddItem.h
    │   │       ├── InventoryInit.h
    │   │       ├── InventoryMoveItem.h
    │   │       ├── InventoryOperation.h
    │   │       ├── InventoryRemoveItem.h
    │   │       ├── ItemChangeRequest.h
    │   │       ├── ItemDataRequest.h
    │   │       ├── ItemError.h
    │   │       ├── ItemInitRequest.h
    │   │       ├── ItemInitScriptRequest.h
    │   │       ├── ItemInitScriptResponse.h
    │   │       ├── ItemUpdate.h
    │   │       ├── MovementState.h
    │   │       ├── MovementUpdate.h
    │   │       ├── SystemMessage.h
    │   │       ├── TileAddLayer.h
    │   │       ├── TileClearLayers.h
    │   │       ├── TileExtentClearLayers.h
    │   │       ├── TileRemoveLayer.h
    │   │       └── UseItemOnEntityRequest.h
    │   ├── Network
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   ├── Acceptor.cpp
    │   │   │   ├── NetworkStats.cpp
    │   │   │   ├── Peer.cpp
    │   │   │   ├── SocketSet.cpp
    │   │   │   └── TcpSocket.cpp
    │   │   └── Public
    │   │       ├── Acceptor.h
    │   │       ├── BufferPool.h
    │   │       ├── DispatchMessage.h
    │   │       ├── NetworkDefs.h
    │   │       ├── NetworkID.h
    │   │       ├── NetworkStats.h
    │   │       ├── Peer.h
    │   │       ├── SocketSet.h
    │   │       └── TcpSocket.h
    │   ├── Simulation
    │   │   ├── CMakeLists.txt
    │   │   ├── Private
    │   │   │   ├── BoundingBox.cpp
    │   │   │   ├── CastableData
    │   │   │   │   ├── Castable.cpp
    │   │   │   │   └── CastableData.cpp
    │   │   │   ├── CollisionLocator.cpp
    │   │   │   ├── CollisionLocatorRaycastStrategy.cpp
    │   │   │   ├── Components
    │   │   │   │   ├── Camera.cpp
    │   │   │   │   ├── CastCooldown.cpp
    │   │   │   │   ├── CollisionBitSets.cpp
    │   │   │   │   ├── Interaction.cpp
    │   │   │   │   └── Inventory.cpp
    │   │   │   ├── Cylinder.cpp
    │   │   │   ├── EntityLocator.cpp
    │   │   │   ├── EntityMover.cpp
    │   │   │   ├── GraphicData
    │   │   │   │   ├── Animation.cpp
    │   │   │   │   ├── GraphicDataBase.cpp
    │   │   │   │   ├── GraphicID.cpp
    │   │   │   │   ├── GraphicRef.cpp
    │   │   │   │   └── GraphicSets.cpp
    │   │   │   ├── IconData
    │   │   │   │   └── IconDataBase.cpp
    │   │   │   ├── ItemData
    │   │   │   │   ├── Item.cpp
    │   │   │   │   └── ItemDataBase.cpp
    │   │   │   ├── MovementHelpers.cpp
    │   │   │   ├── Ray.cpp
    │   │   │   ├── ResourceData.cpp
    │   │   │   ├── TileMap
    │   │   │   │   ├── CellExtent.cpp
    │   │   │   │   ├── CellPosition.cpp
    │   │   │   │   ├── Chunk.cpp
    │   │   │   │   ├── ChunkExtent.cpp
    │   │   │   │   ├── ChunkPosition.cpp
    │   │   │   │   ├── Floor.cpp
    │   │   │   │   ├── Terrain.cpp
    │   │   │   │   ├── Tile.cpp
    │   │   │   │   ├── TileExtent.cpp
    │   │   │   │   ├── TileLayer.cpp
    │   │   │   │   ├── TileMapBase.cpp
    │   │   │   │   └── TilePosition.cpp
    │   │   │   └── Vector3.cpp
    │   │   └── Public
    │   │       ├── AMMath.h
    │   │       ├── BoundingBox.h
    │   │       ├── BoundingBoxID.h
    │   │       ├── CastableData
    │   │       │   ├── AVEntity.h
    │   │       │   ├── CastFailureType.h
    │   │       │   ├── CastInfo.h
    │   │       │   ├── Castable.h
    │   │       │   ├── CastableData.h
    │   │       │   ├── CastableID.h
    │   │       │   ├── EngineCastableDef.h
    │   │       │   └── VisualEffect.h
    │   │       ├── CollisionLocator.h
    │   │       ├── CollisionLocatorRaycastStrategy.h
    │   │       ├── Components
    │   │       │   ├── Camera.h
    │   │       │   ├── CastCooldown.h
    │   │       │   ├── Collision.h
    │   │       │   ├── CollisionBitSets.h
    │   │       │   ├── EntityInitScript.h
    │   │       │   ├── GraphicState.h
    │   │       │   ├── Input.h
    │   │       │   ├── Interaction.h
    │   │       │   ├── Inventory.h
    │   │       │   ├── IsClientEntity.h
    │   │       │   ├── Movement.h
    │   │       │   ├── MovementModifiers.h
    │   │       │   ├── Name.h
    │   │       │   ├── Position.h
    │   │       │   ├── PreviousPosition.h
    │   │       │   └── Rotation.h
    │   │       ├── Cylinder.h
    │   │       ├── DialogueEvent.h
    │   │       ├── DiscreteExtent.h
    │   │       ├── DiscreteImpl.h
    │   │       ├── DiscretePosition.h
    │   │       ├── EngineCollisionLayerType.h
    │   │       ├── EngineEntityGraphicType.h
    │   │       ├── EngineEntityInteractionType.h
    │   │       ├── EngineItemInteractionType.h
    │   │       ├── EntityLocator.h
    │   │       ├── EntityMover.h
    │   │       ├── EnttObserver.h
    │   │       ├── GraphicData
    │   │       │   ├── Animation.h
    │   │       │   ├── AnimationID.h
    │   │       │   ├── GraphicDataBase.h
    │   │       │   ├── GraphicID.h
    │   │       │   ├── GraphicRef.h
    │   │       │   ├── GraphicSetIDs.h
    │   │       │   ├── GraphicSets.h
    │   │       │   ├── Sprite.h
    │   │       │   └── SpriteID.h
    │   │       ├── IconData
    │   │       │   ├── Icon.h
    │   │       │   ├── IconDataBase.h
    │   │       │   └── IconID.h
    │   │       ├── ItemData
    │   │       │   ├── Item.h
    │   │       │   ├── ItemCombination.h
    │   │       │   ├── ItemDataBase.h
    │   │       │   ├── ItemID.h
    │   │       │   ├── ItemInitScript.h
    │   │       │   └── ItemProperty.h
    │   │       ├── MovementHelpers.h
    │   │       ├── Ray.h
    │   │       ├── ReplicatedComponent.h
    │   │       ├── ResourceData.h
    │   │       ├── TileMap
    │   │       │   ├── CellExtent.h
    │   │       │   ├── CellPosition.h
    │   │       │   ├── Chunk.h
    │   │       │   ├── ChunkExtent.h
    │   │       │   ├── ChunkPosition.h
    │   │       │   ├── ChunkSnapshot.h
    │   │       │   ├── Floor.h
    │   │       │   ├── Terrain.h
    │   │       │   ├── Tile.h
    │   │       │   ├── TileExtent.h
    │   │       │   ├── TileLayer.h
    │   │       │   ├── TileLayerID.h
    │   │       │   ├── TileMapBase.h
    │   │       │   ├── TileMapSnapshot.h
    │   │       │   ├── TileOffset.h
    │   │       │   ├── TilePosition.h
    │   │       │   └── Wall.h
    │   │       ├── TypeLists
    │   │       │   └── EngineReplicatedComponentTypes.h
    │   │       └── Vector3.h
    │   └── Utility
    │       ├── CMakeLists.txt
    │       ├── Private
    │       │   ├── AssetCache.cpp
    │       │   ├── ByteTools.cpp
    │       │   ├── IDPool.cpp
    │       │   ├── Log.cpp
    │       │   ├── Morton.cpp
    │       │   ├── Paths.cpp
    │       │   ├── PeriodicCaller.cpp
    │       │   ├── SDL.cpp
    │       │   ├── SDLHelpers.cpp
    │       │   ├── SDLNet.cpp
    │       │   ├── SDLRenderer.cpp
    │       │   ├── SDLWindow.cpp
    │       │   ├── StringTools.cpp
    │       │   ├── Timer.cpp
    │       │   ├── Transforms.cpp
    │       │   └── pch.h
    │       └── Public
    │           ├── AMAssert.h
    │           ├── AssetCache.h
    │           ├── BinaryBuffer.h
    │           ├── ByteTools.h
    │           ├── ConstexprTools.h
    │           ├── Deserialize.h
    │           ├── HashTools.h
    │           ├── IDPool.h
    │           ├── Log.h
    │           ├── Morton.h
    │           ├── OSEventHandler.h
    │           ├── Paths.h
    │           ├── PeriodicCaller.h
    │           ├── SDLHelpers.h
    │           ├── SDL_Wrappers
    │           │   ├── SDL.h
    │           │   ├── SDLNet.h
    │           │   ├── SDLRenderer.h
    │           │   └── SDLWindow.h
    │           ├── Serialize.h
    │           ├── SerializeBuffer.h
    │           ├── StringTools.h
    │           ├── Timer.h
    │           ├── Transforms.h
    │           └── VariantTools.h
    ├── Tests
    │   ├── CMakeLists.txt
    │   ├── TestSandboxes
    │   │   ├── CMakeLists.txt
    │   │   ├── Graphics
    │   │   │   ├── CMakeLists.txt
    │   │   │   └── Private
    │   │   │       └── FrameTimeTestMain.cpp
    │   │   └── Network
    │   │       ├── CMakeLists.txt
    │   │       ├── ClockTest
    │   │       │   ├── CMakeLists.txt
    │   │       │   └── Private
    │   │       │       ├── ClockTestClientMain.cpp
    │   │       │       └── ClockTestServerMain.cpp
    │   │       ├── DriftTest
    │   │       │   ├── CMakeLists.txt
    │   │       │   └── Private
    │   │       │       ├── DriftTestClientMain.cpp
    │   │       │       └── DriftTestServerMain.cpp
    │   │       ├── LatencyTest
    │   │       │   ├── CMakeLists.txt
    │   │       │   └── Private
    │   │       │       ├── LatencyTestClientMain.cpp
    │   │       │       └── LatencyTestServerMain.cpp
    │   │       └── LoadTest
    │   │           ├── CMakeLists.txt
    │   │           ├── Private
    │   │           │   ├── LoadTestClientMain.cpp
    │   │           │   ├── NetworkSimulation.cpp
    │   │           │   ├── SimulatedClient.cpp
    │   │           │   └── WorldSimulation.cpp
    │   │           └── Public
    │   │               ├── NetworkSimulation.h
    │   │               ├── SimulatedClient.h
    │   │               └── WorldSimulation.h
    │   └── UnitTests
    │       ├── CMakeLists.txt
    │       └── Private
    │           ├── TestBoundingBox.cpp
    │           ├── TestEntityLocator.cpp
    │           └── TestMain.cpp
    └── Tools
        ├── CMakeLists.txt
        └── EngineDatabaseMigrator
            ├── CMakeLists.txt
            └── Private
                ├── EngineDatabaseMigratorMain.cpp
                ├── MigrateEngineComponents.cpp
                ├── MigrateEngineComponents.h
                ├── MigrationRunner.cpp
                └── MigrationRunner.h

```

`CMake/AddressSanitizer.cmake`:

```cmake
# Support for building with AddressSanitizer (ASan) -
# https://code.google.com/p/address-sanitizer/
#
# Note: Including this file enables ASan for all targets in the current 
#       directory and all sub-directories (that are added after including 
#       this file).

INCLUDE(CheckCCompilerFlag)
INCLUDE(CheckCXXCompilerFlag)
INCLUDE(CMakePushCheckState)

CMAKE_PUSH_CHECK_STATE(RESET)
SET(CMAKE_REQUIRED_FLAGS "-fsanitize=address") # Also needs to be a link flag for test to pass
CHECK_C_COMPILER_FLAG("-fsanitize=address" HAVE_FLAG_SANITIZE_ADDRESS_C)
CHECK_CXX_COMPILER_FLAG("-fsanitize=address" HAVE_FLAG_SANITIZE_ADDRESS_CXX)
CMAKE_POP_CHECK_STATE()

IF(HAVE_FLAG_SANITIZE_ADDRESS_C AND HAVE_FLAG_SANITIZE_ADDRESS_CXX)
    SET(ADDRESS_SANITIZER_FLAG "-fsanitize=address")

    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${ADDRESS_SANITIZER_FLAG}")
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${ADDRESS_SANITIZER_FLAG}")
    SET(CMAKE_CGO_LDFLAGS "${CMAKE_CGO_LDFLAGS} ${ADDRESS_SANITIZER_FLAG}")

    ADD_DEFINITIONS(-DADDRESS_SANITIZER)

    MESSAGE(STATUS "AM: AddressSanitizer enabled.")
ELSE()
    MESSAGE(FATAL_ERROR "AM_ADDRESSSANITIZER enabled but compiler doesn't support AddressSanitizer - cannot continue.")
ENDIF()

```

`CMake/FindSDL2.cmake`:

```cmake
# Distributed under the OSI-approved BSD 3-Clause License. See accompanying
# file Copyright.txt or https://cmake.org/licensing for details.

#.rst:
# FindSDL2
# -------
#
# Locate SDL2 library
#
# This module defines
#
# ::
#
# SDL2_LIBRARY, the name of the library to link against
# SDL2_FOUND, if false, do not try to link to SDL
# SDL2_INCLUDE_DIR, where to find SDL.h
# SDL2_VERSION_STRING, human-readable string containing the version of SDL
#
#
#
# This module responds to the flag:
#
# ::
#
# SDL2_BUILDING_LIBRARY
# If this is defined, then no SDL2_main will be linked in because
# only applications need main().
# Otherwise, it is assumed you are building an application and this
# module will attempt to locate and set the proper link flags
# as part of the returned SDL2_LIBRARY variable.
#
#
#
# Don't forget to include SDLmain.h and SDLmain.m your project for the
# OS X framework based version. (Other versions link to -lSDLmain which
# this module will try to find on your behalf.) Also for OS X, this
# module will automatically add the -framework Cocoa on your behalf.
#
#
#
# Additional Note: If you see an empty SDL2_LIBRARY_TEMP in your
# configuration and no SDL2_LIBRARY, it means CMake did not find your SDL
# library (SDL.dll, libsdl.so, SDL.framework, etc). Set
# SDL2_LIBRARY_TEMP to point to your SDL library, and configure again.
# Similarly, if you see an empty SDLMAIN_LIBRARY, you should set this
# value as appropriate. These values are used to generate the final
# SDL2_LIBRARY variable, but when these values are unset, SDL2_LIBRARY
# does not get created.
#
#
#
# $SDLDIR is an environment variable that would correspond to the
# ./configure --prefix=$SDLDIR used in building SDL. l.e.galup 9-20-02
#
# Modified by Eric Wing. Added code to assist with automated building
# by using environmental variables and providing a more
# controlled/consistent search behavior. Added new modifications to
# recognize OS X frameworks and additional Unix paths (FreeBSD, etc).
# Also corrected the header search path to follow "proper" SDL
# guidelines. Added a search for SDLmain which is needed by some
# platforms. Added a search for threads which is needed by some
# platforms. Added needed compile switches for MinGW.
#
# On OSX, this will prefer the Framework version (if found) over others.
# People will have to manually change the cache values of SDL2_LIBRARY to
# override this selection or set the CMake environment
# CMAKE_INCLUDE_PATH to modify the search paths.
#
# Note that the header path has changed from SDL/SDL.h to just SDL.h
# This needed to change because "proper" SDL convention is #include
# "SDL.h", not <SDL/SDL.h>. This is done for portability reasons
# because not all systems place things in SDL/ (see FreeBSD).

if(NOT SDL2_DIR)
  set(SDL2_DIR "" CACHE PATH "SDL2 directory")
endif()

find_path(SDL2_INCLUDE_DIR SDL.h
  HINTS
    ENV SDLDIR
    ${SDL2_DIR}
  PATH_SUFFIXES SDL2
                # path suffixes to search inside ENV{SDLDIR}
                include/SDL2 include
)

if(CMAKE_SIZEOF_VOID_P EQUAL 8)
  set(VC_LIB_PATH_SUFFIX lib/x64)
else()
  set(VC_LIB_PATH_SUFFIX lib/x86)
endif()

# SDL-1.1 is the name used by FreeBSD ports...
# don't confuse it for the version number.
find_library(SDL2_LIBRARY_TEMP
  NAMES SDL2
  HINTS
    ENV SDLDIR
    ${SDL2_DIR}
  PATH_SUFFIXES lib ${VC_LIB_PATH_SUFFIX}
)

# Hide this cache variable from the user, it's an internal implementation
# detail. The documented library variable for the user is SDL2_LIBRARY
# which is derived from SDL2_LIBRARY_TEMP further below.
set_property(CACHE SDL2_LIBRARY_TEMP PROPERTY TYPE INTERNAL)

if(NOT SDL2_BUILDING_LIBRARY)
  if(NOT SDL2_INCLUDE_DIR MATCHES ".framework")
    # Non-OS X framework versions expect you to also dynamically link to
    # SDLmain. This is mainly for Windows and OS X. Other (Unix) platforms
    # seem to provide SDLmain for compatibility even though they don't
    # necessarily need it.
    find_library(SDL2MAIN_LIBRARY
      NAMES SDL2main
      HINTS
        ENV SDLDIR
        ${SDL2_DIR}
      PATH_SUFFIXES lib ${VC_LIB_PATH_SUFFIX}
      PATHS
      /sw
      /opt/local
      /opt/csw
      /opt
    )
  endif()
endif()

# SDL may require threads on your system.
# The Apple build may not need an explicit flag because one of the
# frameworks may already provide it.
# But for non-OSX systems, I will use the CMake Threads package.
if(NOT APPLE)
  find_package(Threads)
endif()

# MinGW needs an additional link flag, -mwindows
# It's total link flags should look like -lmingw32 -lSDLmain -lSDL -mwindows
if(MINGW)
  set(MINGW32_LIBRARY mingw32 "-mwindows" CACHE STRING "link flags for MinGW")
endif()

if(SDL2_LIBRARY_TEMP)
  # For SDLmain
  if(SDL2MAIN_LIBRARY AND NOT SDL2_BUILDING_LIBRARY)
    list(FIND SDL2_LIBRARY_TEMP "${SDL2MAIN_LIBRARY}" _SDL2_MAIN_INDEX)
    if(_SDL2_MAIN_INDEX EQUAL -1)
      set(SDL2_LIBRARY_TEMP "${SDL2MAIN_LIBRARY}" ${SDL2_LIBRARY_TEMP})
    endif()
    unset(_SDL2_MAIN_INDEX)
  endif()

  # For OS X, SDL uses Cocoa as a backend so it must link to Cocoa.
  # CMake doesn't display the -framework Cocoa string in the UI even
  # though it actually is there if I modify a pre-used variable.
  # I think it has something to do with the CACHE STRING.
  # So I use a temporary variable until the end so I can set the
  # "real" variable in one-shot.
  if(APPLE)
    set(SDL2_LIBRARY_TEMP ${SDL2_LIBRARY_TEMP} "-framework Cocoa")
  endif()

  # For threads, as mentioned Apple doesn't need this.
  # In fact, there seems to be a problem if I used the Threads package
  # and try using this line, so I'm just skipping it entirely for OS X.
  if(NOT APPLE)
    set(SDL2_LIBRARY_TEMP ${SDL2_LIBRARY_TEMP} ${CMAKE_THREAD_LIBS_INIT})
  endif()

  # For MinGW library
  if(MINGW)
    set(SDL2_LIBRARY_TEMP ${MINGW32_LIBRARY} ${SDL2_LIBRARY_TEMP})
  endif()

  # Set the final string here so the GUI reflects the final state.
  set(SDL2_LIBRARY ${SDL2_LIBRARY_TEMP} CACHE STRING "Where the SDL Library can be found")
endif()

if(SDL2_INCLUDE_DIR AND EXISTS "${SDL2_INCLUDE_DIR}/SDL2_version.h")
  file(STRINGS "${SDL2_INCLUDE_DIR}/SDL2_version.h" SDL2_VERSION_MAJOR_LINE REGEX "^#define[ \t]+SDL2_MAJOR_VERSION[ \t]+[0-9]+$")
  file(STRINGS "${SDL2_INCLUDE_DIR}/SDL2_version.h" SDL2_VERSION_MINOR_LINE REGEX "^#define[ \t]+SDL2_MINOR_VERSION[ \t]+[0-9]+$")
  file(STRINGS "${SDL2_INCLUDE_DIR}/SDL2_version.h" SDL2_VERSION_PATCH_LINE REGEX "^#define[ \t]+SDL2_PATCHLEVEL[ \t]+[0-9]+$")
  string(REGEX REPLACE "^#define[ \t]+SDL2_MAJOR_VERSION[ \t]+([0-9]+)$" "\\1" SDL2_VERSION_MAJOR "${SDL2_VERSION_MAJOR_LINE}")
  string(REGEX REPLACE "^#define[ \t]+SDL2_MINOR_VERSION[ \t]+([0-9]+)$" "\\1" SDL2_VERSION_MINOR "${SDL2_VERSION_MINOR_LINE}")
  string(REGEX REPLACE "^#define[ \t]+SDL2_PATCHLEVEL[ \t]+([0-9]+)$" "\\1" SDL2_VERSION_PATCH "${SDL2_VERSION_PATCH_LINE}")
  set(SDL2_VERSION_STRING ${SDL2_VERSION_MAJOR}.${SDL2_VERSION_MINOR}.${SDL2_VERSION_PATCH})
  unset(SDL2_VERSION_MAJOR_LINE)
  unset(SDL2_VERSION_MINOR_LINE)
  unset(SDL2_VERSION_PATCH_LINE)
  unset(SDL2_VERSION_MAJOR)
  unset(SDL2_VERSION_MINOR)
  unset(SDL2_VERSION_PATCH)
endif()

set(SDL2_LIBRARIES ${SDL2_LIBRARY})
set(SDL2_INCLUDE_DIRS ${SDL2_INCLUDE_DIR})

include(FindPackageHandleStandardArgs)

FIND_PACKAGE_HANDLE_STANDARD_ARGS(SDL2
                                  REQUIRED_VARS SDL2_LIBRARIES SDL2_INCLUDE_DIRS
                                  VERSION_VAR SDL2_VERSION_STRING)

mark_as_advanced(SDL2_LIBRARY SDL2_INCLUDE_DIR)

# Create imported target SDL2::SDL2
if(SDL2_FOUND AND NOT TARGET SDL2::SDL2)
  # SDL2_LIBRARY is a list, we need to separate the main library from additional ones
  set(_sdl2_libs ${SDL2_LIBRARY})
  
  # Find the actual SDL2.lib (not SDL2main.lib)
  set(_sdl2_main_lib "")
  set(_sdl2_extra_libs "")
  
  foreach(_lib ${_sdl2_libs})
    # Check if this is the main SDL2 library (not SDL2main)
    if(_lib MATCHES "SDL2\\.lib$" OR (_lib MATCHES "libSDL2" AND NOT _lib MATCHES "main"))
      set(_sdl2_main_lib "${_lib}")
    else()
      list(APPEND _sdl2_extra_libs "${_lib}")
    endif()
  endforeach()
  
  # Create the target
  if(_sdl2_main_lib)
    add_library(SDL2::SDL2 UNKNOWN IMPORTED)
    set_target_properties(SDL2::SDL2 PROPERTIES
      INTERFACE_INCLUDE_DIRECTORIES "${SDL2_INCLUDE_DIRS}"
      IMPORTED_LOCATION "${_sdl2_main_lib}"
    )
    
    # Add SDL2main and other libraries as interface dependencies
    if(_sdl2_extra_libs)
      set_target_properties(SDL2::SDL2 PROPERTIES
        INTERFACE_LINK_LIBRARIES "${_sdl2_extra_libs}"
      )
    endif()
  else()
    # Fallback: use INTERFACE library if we can't find the main lib
    add_library(SDL2::SDL2 INTERFACE IMPORTED)
    set_target_properties(SDL2::SDL2 PROPERTIES
      INTERFACE_INCLUDE_DIRECTORIES "${SDL2_INCLUDE_DIRS}"
      INTERFACE_LINK_LIBRARIES "${SDL2_LIBRARY}"
    )
  endif()
  
  unset(_sdl2_libs)
  unset(_sdl2_main_lib)
  unset(_sdl2_extra_libs)
endif()

```

`CMake/FindSDL2_gfx.cmake`:

```cmake
# Copyright 2019 Google LLC
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# - Locate SDL2_gfx library
# This module defines:
# SDL2_GFX_LIBRARIES, the name of the library to link against
# SDL2_GFX_INCLUDE_DIRS, where to find the headers
# SDL2_GFX_FOUND, if false, do not try to link against
# SDL2_GFX_VERSION_STRING - human-readable string containing the version of SDL2_gfx
#
# For backward compatiblity the following variables are also set:
# SDL2GFX_LIBRARY (same value as SDL2_GFX_LIBRARIES)
# SDL2GFX_INCLUDE_DIR (same value as SDL2_GFX_INCLUDE_DIRS)
# SDL2GFX_FOUND (same value as SDL2_GFX_FOUND)
#
# $SDL2DIR is an environment variable that would
# correspond to the ./configure --prefix=$SDL2DIR
# used in building SDL2.
#
# Created by Eric Wing. This was influenced by the FindSDL2.cmake
# module, but with modifications to recognize OS X frameworks and
# additional Unix paths (FreeBSD, etc).

#=============================================================================
# Copyright 2005-2009 Kitware, Inc.
# Copyright 2012 Benjamin Eikel
#
# Distributed under the OSI-approved BSD License (the "License");
# see accompanying file Copyright.txt for details.
#
# This software is distributed WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the License for more information.
#=============================================================================
# (To distribute this file outside of CMake, substitute the full
# License text for the above reference.)

if(NOT SDL2_GFX_INCLUDE_DIR AND SDL2GFX_INCLUDE_DIR)
  set(SDL2_GFX_INCLUDE_DIR ${SDL2GFX_INCLUDE_DIR} CACHE PATH "directory cache
entry initialized from old variable name")
endif()
find_path(SDL2_GFX_INCLUDE_DIR SDL2_gfxPrimitives.h
  HINTS
    ENV SDL2GFXDIR
    ENV SDL2DIR
  PATH_SUFFIXES include/SDL2 include
  PATHS
  ${CMAKE_SOURCE_DIR}/deps
)

if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(VC_LIB_PATH_SUFFIX lib/x64)
else()
    set(VC_LIB_PATH_SUFFIX lib/x86)
endif()

if(NOT SDL2_GFX_LIBRARY AND SDL2GFX_LIBRARY)
  set(SDL2_GFX_LIBRARY ${SDL2GFX_LIBRARY} CACHE FILEPATH "file cache entry
initialized from old variable name")
endif()
find_library(SDL2_GFX_LIBRARY
  NAMES SDL2_gfx
  HINTS
    ENV SDL2GFXDIR
    ENV SDL2DIR
  PATH_SUFFIXES lib ${VC_LIB_PATH_SUFFIX}
  PATHS
  ${CMAKE_SOURCE_DIR}/deps
)

if(SDL2_GFX_INCLUDE_DIR AND EXISTS "${SDL2_GFX_INCLUDE_DIR}/SDL2_gfxPrimitives.h")
  file(STRINGS "${SDL2_GFX_INCLUDE_DIR}/SDL2_gfxPrimitives.h" SDL2_GFX_VERSION_MAJOR_LINE REGEX "^#define[ \t]+SDL2_GFXPRIMITIVES_MAJOR[ \t]+[0-9]+$")
  file(STRINGS "${SDL2_GFX_INCLUDE_DIR}/SDL2_gfxPrimitives.h" SDL2_GFX_VERSION_MINOR_LINE REGEX "^#define[ \t]+SDL2_GFXPRIMITIVES_MINOR[ \t]+[0-9]+$")
  file(STRINGS "${SDL2_GFX_INCLUDE_DIR}/SDL2_gfxPrimitives.h" SDL2_GFX_VERSION_PATCH_LINE REGEX "^#define[ \t]+SDL2_GFXPRIMITIVES_MICRO[ \t]+[0-9]+$")
  string(REGEX REPLACE "^#define[ \t]+SDL2_GFXPRIMITIVES_MAJOR[ \t]+([0-9]+)$" "\\1" SDL2_GFX_VERSION_MAJOR "${SDL2_GFX_VERSION_MAJOR_LINE}")
  string(REGEX REPLACE "^#define[ \t]+SDL2_GFXPRIMITIVES_MINOR[ \t]+([0-9]+)$" "\\1" SDL2_GFX_VERSION_MINOR "${SDL2_GFX_VERSION_MINOR_LINE}")
  string(REGEX REPLACE "^#define[ \t]+SDL2_GFXPRIMITIVES_MICRO[ \t]+([0-9]+)$" "\\1" SDL2_GFX_VERSION_PATCH "${SDL2_GFX_VERSION_PATCH_LINE}")
  set(SDL2_GFX_VERSION_STRING ${SDL2_GFX_VERSION_MAJOR}.${SDL2_GFX_VERSION_MINOR}.${SDL2_GFX_VERSION_PATCH})
  unset(SDL2_GFX_VERSION_MAJOR_LINE)
  unset(SDL2_GFX_VERSION_MINOR_LINE)
  unset(SDL2_GFX_VERSION_PATCH_LINE)
  unset(SDL2_GFX_VERSION_MAJOR)
  unset(SDL2_GFX_VERSION_MINOR)
  unset(SDL2_GFX_VERSION_PATCH)
endif()

set(SDL2_GFX_LIBRARIES ${SDL2_GFX_LIBRARY})
set(SDL2_GFX_INCLUDE_DIRS ${SDL2_GFX_INCLUDE_DIR})

# for backward compatiblity
set(SDL2GFX_LIBRARY ${SDL2_GFX_LIBRARIES})
set(SDL2GFX_INCLUDE_DIR ${SDL2_GFX_INCLUDE_DIRS})
set(SDL2GFX_FOUND ${SDL2_GFX_FOUND})

include(FindPackageHandleStandardArgs)

FIND_PACKAGE_HANDLE_STANDARD_ARGS(SDL2_gfx
                                  REQUIRED_VARS SDL2_GFX_LIBRARIES SDL2_GFX_INCLUDE_DIRS
                                  VERSION_VAR SDL2_GFX_VERSION_STRING)



mark_as_advanced(SDL2_GFX_LIBRARY SDL2_GFX_INCLUDE_DIR)

# Create imported target SDL2_gfx::SDL2_gfx
if(SDL2_GFX_FOUND AND NOT TARGET SDL2_gfx::SDL2_gfx)
  add_library(SDL2_gfx::SDL2_gfx UNKNOWN IMPORTED)
  set_target_properties(SDL2_gfx::SDL2_gfx PROPERTIES
    INTERFACE_INCLUDE_DIRECTORIES "${SDL2_GFX_INCLUDE_DIRS}"
    IMPORTED_LOCATION "${SDL2_GFX_LIBRARY}"
    IMPORTED_LINK_INTERFACE_LANGUAGES "C"
  )
endif()

```

`CMake/FindSDL2_image.cmake`:

```cmake
# Distributed under the OSI-approved BSD 3-Clause License. See accompanying
# file Copyright.txt or https://cmake.org/licensing for details.

#.rst:
# FindSDL2_image
# -------------
#
# Locate SDL2_image library
#
# This module defines:
#
# ::
#
# SDL2_IMAGE_LIBRARIES, the name of the library to link against
# SDL2_IMAGE_INCLUDE_DIRS, where to find the headers
# SDL2_IMAGE_FOUND, if false, do not try to link against
# SDL2_IMAGE_VERSION_STRING - human-readable string containing the
# version of SDL_image
#
#
#
# For backward compatibility the following variables are also set:
#
# ::
#
# SDL2IMAGE_LIBRARY (same value as SDL_IMAGE_LIBRARIES)
# SDL2IMAGE_INCLUDE_DIR (same value as SDL_IMAGE_INCLUDE_DIRS)
# SDL2IMAGE_FOUND (same value as SDL_IMAGE_FOUND)
#
#
#
# $SDL2DIR is an environment variable that would correspond to the
# ./configure --prefix=$SDL2DIR used in building SDL.
#
# Created by Eric Wing. This was influenced by the FindSDL.cmake
# module, but with modifications to recognize OS X frameworks and
# additional Unix paths (FreeBSD, etc).

if(NOT SDL2_IMAGE_INCLUDE_DIR AND SDL2IMAGE_INCLUDE_DIR)
  set(SDL2_IMAGE_INCLUDE_DIR ${SDL2IMAGE_INCLUDE_DIR} CACHE PATH "directory cache entry initialized from old variable name")
endif()
find_path(SDL2_IMAGE_INCLUDE_DIR SDL_image.h
  HINTS
    ENV SDL2IMAGEDIR
    ENV SDL2DIR
    ${SDL2_DIR}
  PATH_SUFFIXES SDL2
                # path suffixes to search inside ENV{SDL2DIR}
                include/SDL2 include
)

if(CMAKE_SIZEOF_VOID_P EQUAL 8)
  set(VC_LIB_PATH_SUFFIX lib/x64)
else()
  set(VC_LIB_PATH_SUFFIX lib/x86)
endif()

if(NOT SDL2_IMAGE_LIBRARY AND SDL2IMAGE_LIBRARY)
  set(SDL2_IMAGE_LIBRARY ${SDL2IMAGE_LIBRARY} CACHE FILEPATH "file cache entry initialized from old variable name")
endif()
find_library(SDL2_IMAGE_LIBRARY
  NAMES SDL2_image
  HINTS
  ENV SDL2IMAGEDIR
  ENV SDL2DIR
  ${SDL2_DIR}
  PATH_SUFFIXES lib ${VC_LIB_PATH_SUFFIX}
)

if(SDL2_IMAGE_INCLUDE_DIR AND EXISTS "${SDL2_IMAGE_INCLUDE_DIR}/SDL_image.h")
  file(STRINGS "${SDL2_IMAGE_INCLUDE_DIR}/SDL_image.h" SDL2_IMAGE_VERSION_MAJOR_LINE REGEX "^#define[ \t]+SDL_IMAGE_MAJOR_VERSION[ \t]+[0-9]+$")
  file(STRINGS "${SDL2_IMAGE_INCLUDE_DIR}/SDL_image.h" SDL2_IMAGE_VERSION_MINOR_LINE REGEX "^#define[ \t]+SDL_IMAGE_MINOR_VERSION[ \t]+[0-9]+$")
  file(STRINGS "${SDL2_IMAGE_INCLUDE_DIR}/SDL_image.h" SDL2_IMAGE_VERSION_PATCH_LINE REGEX "^#define[ \t]+SDL_IMAGE_PATCHLEVEL[ \t]+[0-9]+$")
  string(REGEX REPLACE "^#define[ \t]+SDL_IMAGE_MAJOR_VERSION[ \t]+([0-9]+)$" "\\1" SDL2_IMAGE_VERSION_MAJOR "${SDL_IMAGE_VERSION_MAJOR_LINE}")
  string(REGEX REPLACE "^#define[ \t]+SDL_IMAGE_MINOR_VERSION[ \t]+([0-9]+)$" "\\1" SDL2_IMAGE_VERSION_MINOR "${SDL_IMAGE_VERSION_MINOR_LINE}")
  string(REGEX REPLACE "^#define[ \t]+SDL_IMAGE_PATCHLEVEL[ \t]+([0-9]+)$" "\\1" SDL2_IMAGE_VERSION_PATCH "${SDL_IMAGE_VERSION_PATCH_LINE}")
  set(SDL2_IMAGE_VERSION_STRING ${SDL2_IMAGE_VERSION_MAJOR}.${SDL2_IMAGE_VERSION_MINOR}.${SDL2_IMAGE_VERSION_PATCH})
  unset(SDL2_IMAGE_VERSION_MAJOR_LINE)
  unset(SDL2_IMAGE_VERSION_MINOR_LINE)
  unset(SDL2_IMAGE_VERSION_PATCH_LINE)
  unset(SDL2_IMAGE_VERSION_MAJOR)
  unset(SDL2_IMAGE_VERSION_MINOR)
  unset(SDL2_IMAGE_VERSION_PATCH)
endif()

set(SDL2_IMAGE_LIBRARIES ${SDL2_IMAGE_LIBRARY})
set(SDL2_IMAGE_INCLUDE_DIRS ${SDL2_IMAGE_INCLUDE_DIR})

include(FindPackageHandleStandardArgs)

FIND_PACKAGE_HANDLE_STANDARD_ARGS(SDL2_image
                                  REQUIRED_VARS SDL2_IMAGE_LIBRARIES SDL2_IMAGE_INCLUDE_DIRS
                                  VERSION_VAR SDL2_IMAGE_VERSION_STRING)

# for backward compatibility
set(SDL2IMAGE_LIBRARY ${SDL2_IMAGE_LIBRARIES})
set(SDL2IMAGE_INCLUDE_DIR ${SDL2_IMAGE_INCLUDE_DIRS})
set(SDL2IMAGE_FOUND ${SDL2_IMAGE_FOUND})

mark_as_advanced(SDL2_IMAGE_LIBRARY SDL2_IMAGE_INCLUDE_DIR)

# Create imported target SDL2_image::SDL2_image
if(SDL2_IMAGE_FOUND AND NOT TARGET SDL2_image::SDL2_image)
  add_library(SDL2_image::SDL2_image UNKNOWN IMPORTED)
  set_target_properties(SDL2_image::SDL2_image PROPERTIES
    INTERFACE_INCLUDE_DIRECTORIES "${SDL2_IMAGE_INCLUDE_DIRS}"
    IMPORTED_LOCATION "${SDL2_IMAGE_LIBRARY}"
    IMPORTED_LINK_INTERFACE_LANGUAGES "C"
  )
endif()

```

`CMake/FindSDL2_mixer.cmake`:

```cmake
# Locate SDL_MIXER library
#
# This module defines:
#
# ::
#
#   SDL2_MIXER_LIBRARIES, the name of the library to link against
#   SDL2_MIXER_INCLUDE_DIRS, where to find the headers
#   SDL2_MIXER_FOUND, if false, do not try to link against
#   SDL2_MIXER_VERSION_STRING - human-readable string containing the version of SDL_MIXER
#
#
#
# For backward compatibility the following variables are also set:
#
# ::
#
#   SDLMIXER_LIBRARY (same value as SDL2_MIXER_LIBRARIES)
#   SDLMIXER_INCLUDE_DIR (same value as SDL2_MIXER_INCLUDE_DIRS)
#   SDLMIXER_FOUND (same value as SDL2_MIXER_FOUND)
#
#
#
# $SDLDIR is an environment variable that would correspond to the
# ./configure --prefix=$SDLDIR used in building SDL.
#
# Created by Eric Wing.  This was influenced by the FindSDL.cmake
# module, but with modifications to recognize OS X frameworks and
# additional Unix paths (FreeBSD, etc).

#=============================================================================
# Copyright 2005-2009 Kitware, Inc.
# Copyright 2012 Benjamin Eikel
#
# Distributed under the OSI-approved BSD License (the "License");
# see accompanying file Copyright.txt for details.
#
# This software is distributed WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the License for more information.
#=============================================================================
# (To distribute this file outside of CMake, substitute the full
#  License text for the above reference.)

find_path(SDL2_MIXER_INCLUDE_DIR SDL_mixer.h
        HINTS
        ENV SDL2MIXERDIR
        ENV SDL2DIR
        PATH_SUFFIXES SDL2
        # path suffixes to search inside ENV{SDLDIR}
        include/SDL2 include
        PATHS ${SDL2_MIXER_PATH}
        )

if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(VC_LIB_PATH_SUFFIX lib/x64)
else()
    set(VC_LIB_PATH_SUFFIX lib/x86)
endif()

find_library(SDL2_MIXER_LIBRARY
        NAMES SDL2_mixer
        HINTS
        ENV SDL2MIXERDIR
        ENV SDL2DIR
        PATH_SUFFIXES lib ${VC_LIB_PATH_SUFFIX}
        PATHS ${SDL2_MIXER_PATH}
        )

if(SDL2_MIXER_INCLUDE_DIR AND EXISTS "${SDL2_MIXER_INCLUDE_DIR}/SDL_MIXER.h")
    file(STRINGS "${SDL2_MIXER_INCLUDE_DIR}/SDL_MIXER.h" SDL2_MIXER_VERSION_MAJOR_LINE REGEX "^#define[ \t]+SDL_MIXER_MAJOR_VERSION[ \t]+[0-9]+$")
    file(STRINGS "${SDL2_MIXER_INCLUDE_DIR}/SDL_MIXER.h" SDL2_MIXER_VERSION_MINOR_LINE REGEX "^#define[ \t]+SDL_MIXER_MINOR_VERSION[ \t]+[0-9]+$")
    file(STRINGS "${SDL2_MIXER_INCLUDE_DIR}/SDL_MIXER.h" SDL2_MIXER_VERSION_PATCH_LINE REGEX "^#define[ \t]+SDL_MIXER_PATCHLEVEL[ \t]+[0-9]+$")
    string(REGEX REPLACE "^#define[ \t]+SDL_MIXER_MAJOR_VERSION[ \t]+([0-9]+)$" "\\1" SDL2_MIXER_VERSION_MAJOR "${SDL2_MIXER_VERSION_MAJOR_LINE}")
    string(REGEX REPLACE "^#define[ \t]+SDL_MIXER_MINOR_VERSION[ \t]+([0-9]+)$" "\\1" SDL2_MIXER_VERSION_MINOR "${SDL2_MIXER_VERSION_MINOR_LINE}")
    string(REGEX REPLACE "^#define[ \t]+SDL_MIXER_PATCHLEVEL[ \t]+([0-9]+)$" "\\1" SDL2_MIXER_VERSION_PATCH "${SDL2_MIXER_VERSION_PATCH_LINE}")
    set(SDL2_MIXER_VERSION_STRING ${SDL2_MIXER_VERSION_MAJOR}.${SDL2_MIXER_VERSION_MINOR}.${SDL2_MIXER_VERSION_PATCH})
    unset(SDL2_MIXER_VERSION_MAJOR_LINE)
    unset(SDL2_MIXER_VERSION_MINOR_LINE)
    unset(SDL2_MIXER_VERSION_PATCH_LINE)
    unset(SDL2_MIXER_VERSION_MAJOR)
    unset(SDL2_MIXER_VERSION_MINOR)
    unset(SDL2_MIXER_VERSION_PATCH)
endif()

set(SDL2_MIXER_LIBRARIES ${SDL2_MIXER_LIBRARY})
set(SDL2_MIXER_INCLUDE_DIRS ${SDL2_MIXER_INCLUDE_DIR})

include(FindPackageHandleStandardArgs)

FIND_PACKAGE_HANDLE_STANDARD_ARGS(SDL2_mixer
        REQUIRED_VARS SDL2_MIXER_LIBRARIES SDL2_MIXER_INCLUDE_DIRS
        VERSION_VAR SDL2_MIXER_VERSION_STRING)

# for backward compatibility
set(SDLMIXER_LIBRARY ${SDL2_MIXER_LIBRARIES})
set(SDLMIXER_INCLUDE_DIR ${SDL2_MIXER_INCLUDE_DIRS})
set(SDLMIXER_FOUND ${SDL2_MIXER_FOUND})

mark_as_advanced(SDL2_MIXER_LIBRARY SDL2_MIXER_INCLUDE_DIR)

# Create imported target SDL2_mixer::SDL2_mixer
if(SDL2_MIXER_FOUND AND NOT TARGET SDL2_mixer::SDL2_mixer)
  add_library(SDL2_mixer::SDL2_mixer UNKNOWN IMPORTED)
  set_target_properties(SDL2_mixer::SDL2_mixer PROPERTIES
    INTERFACE_INCLUDE_DIRECTORIES "${SDL2_MIXER_INCLUDE_DIRS}"
    IMPORTED_LOCATION "${SDL2_MIXER_LIBRARY}"
    IMPORTED_LINK_INTERFACE_LANGUAGES "C"
  )
endif()

```

`CMake/FindSDL2_ttf.cmake`:

```cmake
# Locate SDL_ttf library
#
# This module defines:
#
# ::
#
#   SDL2_TTF_LIBRARIES, the name of the library to link against
#   SDL2_TTF_INCLUDE_DIRS, where to find the headers
#   SDL2_TTF_FOUND, if false, do not try to link against
#   SDL2_TTF_VERSION_STRING - human-readable string containing the version of SDL_ttf
#
#
#
# For backward compatibility the following variables are also set:
#
# ::
#
#   SDLTTF_LIBRARY (same value as SDL2_TTF_LIBRARIES)
#   SDLTTF_INCLUDE_DIR (same value as SDL2_TTF_INCLUDE_DIRS)
#   SDLTTF_FOUND (same value as SDL2_TTF_FOUND)
#
#
#
# $SDLDIR is an environment variable that would correspond to the
# ./configure --prefix=$SDLDIR used in building SDL.
#
# Created by Eric Wing.  This was influenced by the FindSDL.cmake
# module, but with modifications to recognize OS X frameworks and
# additional Unix paths (FreeBSD, etc).

#=============================================================================
# Copyright 2005-2009 Kitware, Inc.
# Copyright 2012 Benjamin Eikel
#
# Distributed under the OSI-approved BSD License (the "License");
# see accompanying file Copyright.txt for details.
#
# This software is distributed WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the License for more information.
#=============================================================================
# (To distribute this file outside of CMake, substitute the full
#  License text for the above reference.)

find_path(SDL2_TTF_INCLUDE_DIR SDL_ttf.h
        HINTS
        ENV SDL2TTFDIR
        ENV SDL2DIR
        PATH_SUFFIXES SDL2
        # path suffixes to search inside ENV{SDLDIR}
        include/SDL2 include
        PATHS ${SDL2_TTF_PATH}
        )

if (CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(VC_LIB_PATH_SUFFIX lib/x64)
else ()
    set(VC_LIB_PATH_SUFFIX lib/x86)
endif ()

find_library(SDL2_TTF_LIBRARY
        NAMES SDL2_ttf
        HINTS
        ENV SDL2TTFDIR
        ENV SDL2DIR
        PATH_SUFFIXES lib ${VC_LIB_PATH_SUFFIX}
        PATHS ${SDL2_TTF_PATH}
        )

if (SDL2_TTF_INCLUDE_DIR AND EXISTS "${SDL2_TTF_INCLUDE_DIR}/SDL_ttf.h")
    file(STRINGS "${SDL2_TTF_INCLUDE_DIR}/SDL_ttf.h" SDL2_TTF_VERSION_MAJOR_LINE REGEX "^#define[ \t]+SDL_TTF_MAJOR_VERSION[ \t]+[0-9]+$")
    file(STRINGS "${SDL2_TTF_INCLUDE_DIR}/SDL_ttf.h" SDL2_TTF_VERSION_MINOR_LINE REGEX "^#define[ \t]+SDL_TTF_MINOR_VERSION[ \t]+[0-9]+$")
    file(STRINGS "${SDL2_TTF_INCLUDE_DIR}/SDL_ttf.h" SDL2_TTF_VERSION_PATCH_LINE REGEX "^#define[ \t]+SDL_TTF_PATCHLEVEL[ \t]+[0-9]+$")
    string(REGEX REPLACE "^#define[ \t]+SDL_TTF_MAJOR_VERSION[ \t]+([0-9]+)$" "\\1" SDL2_TTF_VERSION_MAJOR "${SDL2_TTF_VERSION_MAJOR_LINE}")
    string(REGEX REPLACE "^#define[ \t]+SDL_TTF_MINOR_VERSION[ \t]+([0-9]+)$" "\\1" SDL2_TTF_VERSION_MINOR "${SDL2_TTF_VERSION_MINOR_LINE}")
    string(REGEX REPLACE "^#define[ \t]+SDL_TTF_PATCHLEVEL[ \t]+([0-9]+)$" "\\1" SDL2_TTF_VERSION_PATCH "${SDL2_TTF_VERSION_PATCH_LINE}")
    set(SDL2_TTF_VERSION_STRING ${SDL2_TTF_VERSION_MAJOR}.${SDL2_TTF_VERSION_MINOR}.${SDL2_TTF_VERSION_PATCH})
    unset(SDL2_TTF_VERSION_MAJOR_LINE)
    unset(SDL2_TTF_VERSION_MINOR_LINE)
    unset(SDL2_TTF_VERSION_PATCH_LINE)
    unset(SDL2_TTF_VERSION_MAJOR)
    unset(SDL2_TTF_VERSION_MINOR)
    unset(SDL2_TTF_VERSION_PATCH)
endif ()

set(SDL2_TTF_LIBRARIES ${SDL2_TTF_LIBRARY})
set(SDL2_TTF_INCLUDE_DIRS ${SDL2_TTF_INCLUDE_DIR})

include(FindPackageHandleStandardArgs)

FIND_PACKAGE_HANDLE_STANDARD_ARGS(SDL2_ttf
        REQUIRED_VARS SDL2_TTF_LIBRARIES SDL2_TTF_INCLUDE_DIRS
        VERSION_VAR SDL2_TTF_VERSION_STRING)

# for backward compatibility
set(SDLTTF_LIBRARY ${SDL2_TTF_LIBRARIES})
set(SDLTTF_INCLUDE_DIR ${SDL2_TTF_INCLUDE_DIRS})
set(SDLTTF_FOUND ${SDL2_TTF_FOUND})

mark_as_advanced(SDL2_TTF_LIBRARY SDL2_TTF_INCLUDE_DIR)

# Create imported target SDL2_ttf::SDL2_ttf
if(SDL2_TTF_FOUND AND NOT TARGET SDL2_ttf::SDL2_ttf)
  add_library(SDL2_ttf::SDL2_ttf UNKNOWN IMPORTED)
  set_target_properties(SDL2_ttf::SDL2_ttf PROPERTIES
    INTERFACE_INCLUDE_DIRECTORIES "${SDL2_TTF_INCLUDE_DIRS}"
    IMPORTED_LOCATION "${SDL2_TTF_LIBRARY}"
    IMPORTED_LINK_INTERFACE_LANGUAGES "C"
  )
endif()

```

`CMake/SDL2_net.cmake`:

```cmake
cmake_minimum_required(VERSION 3.5)

message(STATUS "Configuring SDL_net")

# Add our static library target
add_library(SDL2_net-static STATIC
       ${PROJECT_SOURCE_DIR}/Libraries/SDL_net/SDLnet.c
       ${PROJECT_SOURCE_DIR}/Libraries/SDL_net/SDLnetTCP.c
       ${PROJECT_SOURCE_DIR}/Libraries/SDL_net/SDLnetUDP.c
       ${PROJECT_SOURCE_DIR}/Libraries/SDL_net/SDLnetselect.c
       ${PROJECT_SOURCE_DIR}/Libraries/SDL_net/SDLnetsys.h
       ${PROJECT_SOURCE_DIR}/Libraries/SDL_net/SDL_net.h
)
set_target_properties(SDL2_net-static PROPERTIES OUTPUT_NAME "SDL2_net")

target_include_directories(SDL2_net-static
    PRIVATE
        ${SDL2_INCLUDE_DIRS}
    PUBLIC
        ${PROJECT_SOURCE_DIR}/Libraries/SDL_net
)

target_link_libraries(SDL2_net-static PRIVATE ${SDL2_LIBRARIES})

if(MINGW OR MSVC)
    target_link_libraries(SDL2_net-static PRIVATE ws2_32 iphlpapi)
endif()

# Disable Nagle's algorithm.
target_compile_options(SDL2_net-static PRIVATE -DTCP_NODELAY)

```

`CMake/ThreadSanitizer.cmake`:

```cmake
# Support for building with ThreadSanitizer (TSan) -
# https://code.google.com/p/thread-sanitizer/
#
# Copied from ForestDB under the Apache-2.0 License.
# https://github.com/couchbase/forestdb
#
# Note: Including this file enables TSan for all targets in the current 
#       directory and all sub-directories (that are added after including 
#       this file).

INCLUDE(CheckCCompilerFlag)
INCLUDE(CheckCXXCompilerFlag)
INCLUDE(CMakePushCheckState)

CMAKE_PUSH_CHECK_STATE(RESET)
SET(CMAKE_REQUIRED_FLAGS "-fsanitize=thread") # Also needs to be a link flag for test to pass
CHECK_C_COMPILER_FLAG("-fsanitize=thread" HAVE_FLAG_SANITIZE_THREAD_C)
CHECK_CXX_COMPILER_FLAG("-fsanitize=thread" HAVE_FLAG_SANITIZE_THREAD_CXX)
CMAKE_POP_CHECK_STATE()

IF(HAVE_FLAG_SANITIZE_THREAD_C AND HAVE_FLAG_SANITIZE_THREAD_CXX)
    SET(THREAD_SANITIZER_FLAG "-fsanitize=thread")

    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${THREAD_SANITIZER_FLAG}")
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${THREAD_SANITIZER_FLAG}")
    SET(CMAKE_CGO_LDFLAGS "${CMAKE_CGO_LDFLAGS} ${THREAD_SANITIZER_FLAG}")

    ADD_DEFINITIONS(-DTHREAD_SANITIZER)

    MESSAGE(STATUS "AM: ThreadSanitizer enabled.")
ELSE()
    MESSAGE(FATAL_ERROR "AM_THREADSANITIZER enabled but compiler doesn't support ThreadSanitizer - cannot continue.")
ENDIF()

```

`CMake/copy_if_does_not_exist.cmake`:

```cmake
# Copies a file into CMAKE_CURRENT_BINARY_DIR only if it doesn't already exist there.
function(copy_if_does_not_exist fileRelPath)
    set(inputFilePath "${PROJECT_SOURCE_DIR}/${fileRelPath}")
    set(outputDir "${CMAKE_CURRENT_BINARY_DIR}/")
    get_filename_component(outputFileName ${fileRelPath} NAME)
    set(outputFilePath "${outputDir}${outputFileName}")
    if (NOT EXISTS ${outputFilePath})
        file(COPY ${inputFilePath} DESTINATION ${outputDir})
    endif()
endfunction()

```

`CMake/lua.cmake`:

```cmake
cmake_minimum_required(VERSION 3.5)

message(STATUS "Configuring Lua")

# Add our static library target
add_library(Lua STATIC
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lapi.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lcode.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lctype.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/ldebug.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/ldo.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/ldump.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lfunc.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lgc.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/llex.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lmem.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lobject.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lopcodes.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lparser.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lstate.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lstring.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/ltable.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/ltm.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lundump.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lvm.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lzio.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lauxlib.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lbaselib.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lcorolib.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/ldblib.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/liolib.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lmathlib.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/loslib.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lstrlib.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/ltablib.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/lutf8lib.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/loadlib.c
      ${PROJECT_SOURCE_DIR}/Libraries/lua/linit.c
)

target_include_directories(Lua
    PUBLIC
        ${PROJECT_SOURCE_DIR}/Libraries/lua
)

```

`CMake/readerwriterqueue.cmake`:

```cmake
cmake_minimum_required(VERSION 3.5)

# Add our header-only library target
add_library(readerwriterqueue INTERFACE)

target_include_directories(readerwriterqueue
    INTERFACE
        ${PROJECT_SOURCE_DIR}/Libraries/readerwriterqueue/
)

target_sources(readerwriterqueue INTERFACE
    ${PROJECT_SOURCE_DIR}/Libraries/readerwriterqueue/readerwriterqueue.h
    ${PROJECT_SOURCE_DIR}/Libraries/readerwriterqueue/atomicops.h
)

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.24)

# Temp: Set to new behavior to avoid warning.
cmake_policy(SET CMP0135 NEW)

project(AmalgamEngine)

# Tell CMake where the CMake folder is.
list(APPEND CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/CMake")

###############################################################################
# Options
###############################################################################
option(AM_BUILD_RESOURCE_IMPORTER "Build Amalgam Engine Resource Importer." OFF)

option(AM_BUILD_TOOLS "Build Amalgam Engine tools." OFF)

option(AM_BUILD_TESTS "Build Amalgam Engine tests." OFF)

###############################################################################
# Dependencies
###############################################################################
# On Windows, if the user hasn't provided paths to the SDL libs, download them.
include(FetchContent)
if (CMAKE_SYSTEM_NAME STREQUAL "Windows")
    if (NOT DEFINED SDL2_DIR)
        message(STATUS "Downloading dependency: SDL2")
        FetchContent_Declare(SDL2Download
            URL https://www.libsdl.org/release/SDL2-devel-2.0.20-VC.zip
            URL_HASH MD5=85fe721cb9aa42fb6703da6f30b5df45
        )
        FetchContent_MakeAvailable(SDL2Download)
        set(SDL2_DIR ${sdl2download_SOURCE_DIR} CACHE STRING "")
        set(SDL2_INCLUDE_DIR ${sdl2download_SOURCE_DIR}/include CACHE STRING "")
    endif()
    if (NOT DEFINED SDL2_IMAGE_LIBRARY)
        message(STATUS "Downloading dependency: SDL2_Image")
        FetchContent_Declare(SDL2ImageDownload
            URL https://www.libsdl.org/projects/SDL_image/release/SDL2_image-devel-2.0.5-VC.zip
            URL_HASH MD5=b6c8c85b64e01b7096364036438b3333
        )
        FetchContent_MakeAvailable(SDL2ImageDownload)
        set(SDL2_IMAGE_LIBRARY ${sdl2imagedownload_SOURCE_DIR}/lib/x64/SDL2_image.lib CACHE STRING "")
        set(SDL2_IMAGE_INCLUDE_DIR ${sdl2imagedownload_SOURCE_DIR}/include CACHE STRING "")
    endif()
    if (NOT DEFINED SDL2_MIXER_LIBRARY)
        message(STATUS "Downloading dependency: SDL2_Mixer")
        FetchContent_Declare(SDL2MixerDownload
            URL https://www.libsdl.org/projects/SDL_mixer/release/SDL2_mixer-devel-2.0.4-VC.zip
            URL_HASH MD5=9fd36fba973a7011b9e9a1fa5193a53a
        )
        FetchContent_MakeAvailable(SDL2MixerDownload)
        set(SDL2_MIXER_LIBRARY ${sdl2mixerdownload_SOURCE_DIR}/lib/x64/SDL2_mixer.lib CACHE STRING "")
        set(SDL2_MIXER_INCLUDE_DIR ${sdl2mixerdownload_SOURCE_DIR}/include CACHE STRING "")
    endif()
    if (NOT DEFINED SDL2_TTF_LIBRARY)
        message(STATUS "Downloading dependency: SDL2_TTF")
        FetchContent_Declare(SDL2TtfDownload
            URL https://github.com/libsdl-org/SDL_ttf/releases/download/release-2.20.1/SDL2_ttf-devel-2.20.1-VC.zip
            URL_HASH MD5=0e93c9052d01eebb9c18b1e641322637
        )
        FetchContent_MakeAvailable(SDL2TtfDownload)
        set(SDL2_TTF_LIBRARY ${sdl2ttfdownload_SOURCE_DIR}/lib/x64/SDL2_ttf.lib CACHE STRING "")
        set(SDL2_TTF_INCLUDE_DIR ${sdl2ttfdownload_SOURCE_DIR}/include CACHE STRING "")
    endif()
    if (NOT DEFINED SDL2_GFX_LIBRARY)
        message(STATUS "Downloading dependency: SDL2_GFX")
        FetchContent_Declare(SDL2GfxDownload
            URL https://github.com/Net5F/SDL_gfx/releases/download/1.0.4/SDL2_gfx-devel-1.0.4.zip
            URL_HASH MD5=381bc9fd5e7052e98ce5710893a31304
        )
        FetchContent_MakeAvailable(SDL2GfxDownload)
        set(SDL2_GFX_LIBRARY ${sdl2gfxdownload_SOURCE_DIR}/lib/x64/SDL2_gfx.lib CACHE STRING "")
        set(SDL2_GFX_INCLUDE_DIR ${sdl2gfxdownload_SOURCE_DIR}/include CACHE STRING "")
    endif()
endif()

# Find SDL2 and associated libs.
find_package(SDL2 REQUIRED)
find_package(SDL2_image REQUIRED)
find_package(SDL2_mixer REQUIRED)
find_package(SDL2_ttf REQUIRED)
find_package(SDL2_gfx REQUIRED)
include("${PROJECT_SOURCE_DIR}/CMake/SDL2_net.cmake")

# Configure lz4.
option(LZ4_BUILD_CLI "Build lz4 program" OFF)
option(LZ4_BUILD_LEGACY_LZ4C "Build lz4c program with legacy argument support" OFF)
add_subdirectory("${PROJECT_SOURCE_DIR}/Libraries/lz4/build/cmake/"
                 "${PROJECT_BINARY_DIR}/Libraries/lz4/")

# Configure Boost MP11.
add_subdirectory("${PROJECT_SOURCE_DIR}/Libraries/mp11/"
                 "${PROJECT_BINARY_DIR}/Libraries/mp11/")

# Configure bitsery.
add_subdirectory("${PROJECT_SOURCE_DIR}/Libraries/bitsery/"
                 "${PROJECT_BINARY_DIR}/Libraries/bitsery/"
                 EXCLUDE_FROM_ALL)

# Configure Tracy.
option(TRACY_ENABLE "Enable Tracy profiling." OFF)
option(TRACY_ON_DEMAND "Wait for connection before starting profiling." ON)
# (Disabled because it requires extra dependencies. Can enable if useful.)
option(TRACY_NO_CALLSTACK "Disable all callstack related functionality" ON)
# (Below 2 are disabled because they didn't seem useful. Can enable if useful.)
option(TRACY_NO_VSYNC_CAPTURE "Disable capture of hardware Vsync events" ON)
option(TRACY_NO_FRAME_IMAGE  "Disable the frame image support and its thread" ON)
# (Disabled because it uses a lot of CPU in the remote server.)
option(TRACY_NO_SYSTEM_TRACING  "Disable systrace sampling" ON)
# (Disabled because the remote server doesn't support the default timers.)
option(TRACY_TIMER_FALLBACK "Use lower resolution timers" ON)
# (Disabled because it was failing to compile.)
option(TRACY_NO_CRASH_HANDLER "Disable crash handling" ON)
add_subdirectory("${PROJECT_SOURCE_DIR}/Libraries/tracy/"
                 "${PROJECT_BINARY_DIR}/Libraries/tracy/"
                 EXCLUDE_FROM_ALL)

# Configure nlohmann json.
# Note: We use FetchContent because it's a much smaller download (100KB vs 300MB).
message(STATUS "Downloading dependency if not present: nlohmann_json")
set(JSON_MultipleHeaders ON CACHE INTERNAL "Enable forward declaration.")
FetchContent_Declare(json
    URL https://github.com/nlohmann/json/releases/download/v3.12.0/json.tar.xz
    URL_HASH MD5=e155202b2a589137f6804724bd182f12
)
FetchContent_MakeAvailable(json)
                 
# Configure nativefiledialog-extended.
add_subdirectory("${PROJECT_SOURCE_DIR}/Libraries/nativefiledialog-extended/"
                 "${PROJECT_BINARY_DIR}/Libraries/nativefiledialog-extended/"
                 EXCLUDE_FROM_ALL)

# Configure Lua.
include("${PROJECT_SOURCE_DIR}/CMake/lua.cmake")

# Configure Sol2.
option(SOL2_SYSTEM_INCLUDE "Sol2 as system include" OFF)
option(SOL2_ENABLE_INSTALL "Enable installation of Sol2" OFF)
add_subdirectory("${PROJECT_SOURCE_DIR}/Libraries/sol2/"
                 "${PROJECT_BINARY_DIR}/Libraries/sol2/")

# Configure SQLiteCpp.
option(SQLITECPP_INCLUDE_SCRIPT "Include config & script files." OFF)
option(SQLITE_ENABLE_ASSERT_HANDLER "Enable the user definition of a assertion_failed() handler." ON)
option(SQLITECPP_RUN_CPPLINT "Run cpplint.py tool for Google C++ StyleGuide." OFF)
option(SQLITECPP_RUN_CPPCHECK "Run cppcheck C++ static analysis tool." OFF)
add_subdirectory("${PROJECT_SOURCE_DIR}/Libraries/SQLiteCpp/"
                 "${PROJECT_BINARY_DIR}/Libraries/SQLiteCpp/" EXCLUDE_FROM_ALL)

# Configure libmorton.
add_subdirectory("${PROJECT_SOURCE_DIR}/Libraries/libmorton/"
                 "${PROJECT_BINARY_DIR}/Libraries/libmorton/" EXCLUDE_FROM_ALL)

# Configure header-only readerwriterqueue.
include("${PROJECT_SOURCE_DIR}/CMake/readerwriterqueue.cmake")

# Configure header-only CircularBuffer.
add_subdirectory("${PROJECT_SOURCE_DIR}/Libraries/CircularBuffer/"
                 "${PROJECT_BINARY_DIR}/Libraries/CircularBuffer/")

# Configure header-only QueuedEvents.
add_subdirectory("${PROJECT_SOURCE_DIR}/Libraries/QueuedEvents/"
                 "${PROJECT_BINARY_DIR}/Libraries/QueuedEvents/")

# Configure header-only EnTT.
option(ENTT_INCLUDE_HEADERS "Add all EnTT headers to the EnTT target." ON)
add_subdirectory("${PROJECT_SOURCE_DIR}/Libraries/entt/"
                 "${PROJECT_BINARY_DIR}/Libraries/entt/"
                 EXCLUDE_FROM_ALL)

# Configure AmalgamUI.
add_subdirectory("${PROJECT_SOURCE_DIR}/Libraries/AmalgamUI/"
                 "${PROJECT_BINARY_DIR}/Libraries/AmalgamUI/")

###############################################################################
# Source
###############################################################################
# Configure our project source.
add_subdirectory(Source)

```

`CMakeSettings.json`:

```json
{
    "configurations": [
        {
            "name": "x64-Debug",
            "generator": "Ninja",
            "configurationType": "Debug",
            "inheritEnvironments": [ "msvc_x64_x64" ],
            "buildRoot": "${projectDir}\\Build\\Windows\\Debug",
            "installRoot": "${projectDir}\\out\\install\\${name}",
            "cmakeCommandArgs": "",
            "buildCommandArgs": "",
            "ctestCommandArgs": "",
            "variables": [
                {
                    "name": "SDL2_INCLUDE_DIR",
                    "value": "E:/Libraries/SDL2/SDL2-2.0.20/include",
                    "type": "PATH"
                },
                {
                    "name": "SDL2_DIR",
                    "value": "E:/Libraries/SDL2/SDL2-2.0.20",
                    "type": "PATH"
                },
                {
                    "name": "SDL2_IMAGE_INCLUDE_DIR",
                    "value": "E:/Libraries/SDL2/SDL2_image-2.0.5/include",
                    "type": "PATH"
                },
                {
                    "name": "SDL2_IMAGE_LIBRARY",
                    "value": "E:/Libraries/SDL2/SDL2_image-2.0.5/lib/x64/SDL2_image.lib",
                    "type": "FILEPATH"
                },
                {
                    "name": "SDL2_MIXER_INCLUDE_DIR",
                    "value": "E:/Libraries/SDL2/SDL2_mixer-2.0.4/include",
                    "type": "PATH"
                },
                {
                    "name": "SDL2_MIXER_LIBRARY",
                    "value": "E:/Libraries/SDL2/SDL2_mixer-2.0.4/lib/x64/SDL2_mixer.lib",
                    "type": "FILEPATH"
                },
                {
                    "name": "SDL2_TTF_INCLUDE_DIR",
                    "value": "E:/Libraries/SDL2/SDL2_ttf-2.0.18/include",
                    "type": "PATH"
                },
                {
                    "name": "SDL2_TTF_LIBRARY",
                    "value": "E:/Libraries/SDL2/SDL2_ttf-2.0.18/lib/x64/SDL2_ttf.lib",
                    "type": "FILEPATH"
                },
                {
                    "name": "SDL2_GFX_INCLUDE_DIR",
                    "value": "E:/Libraries/SDL2/SDL2_gfx-1.0.4/include",
                    "type": "PATH"
                },
                {
                    "name": "SDL2_GFX_LIBRARY",
                    "value": "E:/Libraries/SDL2/SDL2_gfx-1.0.4/lib/x64/SDL2_gfx.lib",
                    "type": "FILEPATH"
                }
            ]
        },
        {
            "name": "x64-Release",
            "generator": "Ninja",
            "configurationType": "Release",
            "buildRoot": "${projectDir}\\Build\\Windows\\Release",
            "installRoot": "${projectDir}\\out\\install\\${name}",
            "cmakeCommandArgs": "",
            "buildCommandArgs": "",
            "ctestCommandArgs": "",
            "inheritEnvironments": [ "msvc_x64_x64" ],
            "variables": [
                {
                    "name": "SDL2_INCLUDE_DIR",
                    "value": "E:/Libraries/SDL2/SDL2-2.0.20/include",
                    "type": "PATH"
                },
                {
                    "name": "SDL2_DIR",
                    "value": "E:/Libraries/SDL2/SDL2-2.0.20",
                    "type": "PATH"
                },
                {
                    "name": "SDL2_IMAGE_INCLUDE_DIR",
                    "value": "E:/Libraries/SDL2/SDL2_image-2.0.5/include",
                    "type": "PATH"
                },
                {
                    "name": "SDL2_IMAGE_LIBRARY",
                    "value": "E:/Libraries/SDL2/SDL2_image-2.0.5/lib/x64/SDL2_image.lib",
                    "type": "FILEPATH"
                },
                {
                    "name": "SDL2_MIXER_INCLUDE_DIR",
                    "value": "E:/Libraries/SDL2/SDL2_mixer-2.0.4/include",
                    "type": "PATH"
                },
                {
                    "name": "SDL2_MIXER_LIBRARY",
                    "value": "E:/Libraries/SDL2/SDL2_mixer-2.0.4/lib/x64/SDL2_mixer.lib",
                    "type": "FILEPATH"
                },
                {
                    "name": "SDL2_TTF_INCLUDE_DIR",
                    "value": "E:/Libraries/SDL2/SDL2_ttf-2.0.18/include",
                    "type": "PATH"
                },
                {
                    "name": "SDL2_TTF_LIBRARY",
                    "value": "E:/Libraries/SDL2/SDL2_ttf-2.0.18/lib/x64/SDL2_ttf.lib",
                    "type": "FILEPATH"
                },
                {
                    "name": "SDL2_GFX_INCLUDE_DIR",
                    "value": "E:/Libraries/SDL2/SDL2_gfx-1.0.4/include",
                    "type": "PATH"
                },
                {
                    "name": "SDL2_GFX_LIBRARY",
                    "value": "E:/Libraries/SDL2/SDL2_gfx-1.0.4/lib/x64/SDL2_gfx.lib",
                    "type": "FILEPATH"
                }
            ]
        }
    ]
}
```

`LICENSE.txt`:

```txt
Mozilla Public License Version 2.0
==================================

1. Definitions
--------------

1.1. "Contributor"
    means each individual or legal entity that creates, contributes to
    the creation of, or owns Covered Software.

1.2. "Contributor Version"
    means the combination of the Contributions of others (if any) used
    by a Contributor and that particular Contributor's Contribution.

1.3. "Contribution"
    means Covered Software of a particular Contributor.

1.4. "Covered Software"
    means Source Code Form to which the initial Contributor has attached
    the notice in Exhibit A, the Executable Form of such Source Code
    Form, and Modifications of such Source Code Form, in each case
    including portions thereof.

1.5. "Incompatible With Secondary Licenses"
    means

    (a) that the initial Contributor has attached the notice described
        in Exhibit B to the Covered Software; or

    (b) that the Covered Software was made available under the terms of
        version 1.1 or earlier of the License, but not also under the
        terms of a Secondary License.

1.6. "Executable Form"
    means any form of the work other than Source Code Form.

1.7. "Larger Work"
    means a work that combines Covered Software with other material, in
    a separate file or files, that is not Covered Software.

1.8. "License"
    means this document.

1.9. "Licensable"
    means having the right to grant, to the maximum extent possible,
    whether at the time of the initial grant or subsequently, any and
    all of the rights conveyed by this License.

1.10. "Modifications"
    means any of the following:

    (a) any file in Source Code Form that results from an addition to,
        deletion from, or modification of the contents of Covered
        Software; or

    (b) any new file in Source Code Form that contains any Covered
        Software.

1.11. "Patent Claims" of a Contributor
    means any patent claim(s), including without limitation, method,
    process, and apparatus claims, in any patent Licensable by such
    Contributor that would be infringed, but for the grant of the
    License, by the making, using, selling, offering for sale, having
    made, import, or transfer of either its Contributions or its
    Contributor Version.

1.12. "Secondary License"
    means either the GNU General Public License, Version 2.0, the GNU
    Lesser General Public License, Version 2.1, the GNU Affero General
    Public License, Version 3.0, or any later versions of those
    licenses.

1.13. "Source Code Form"
    means the form of the work preferred for making modifications.

1.14. "You" (or "Your")
    means an individual or a legal entity exercising rights under this
    License. For legal entities, "You" includes any entity that
    controls, is controlled by, or is under common control with You. For
    purposes of this definition, "control" means (a) the power, direct
    or indirect, to cause the direction or management of such entity,
    whether by contract or otherwise, or (b) ownership of more than
    fifty percent (50%) of the outstanding shares or beneficial
    ownership of such entity.

2. License Grants and Conditions
--------------------------------

2.1. Grants

Each Contributor hereby grants You a world-wide, royalty-free,
non-exclusive license:

(a) under intellectual property rights (other than patent or trademark)
    Licensable by such Contributor to use, reproduce, make available,
    modify, display, perform, distribute, and otherwise exploit its
    Contributions, either on an unmodified basis, with Modifications, or
    as part of a Larger Work; and

(b) under Patent Claims of such Contributor to make, use, sell, offer
    for sale, have made, import, and otherwise transfer either its
    Contributions or its Contributor Version.

2.2. Effective Date

The licenses granted in Section 2.1 with respect to any Contribution
become effective for each Contribution on the date the Contributor first
distributes such Contribution.

2.3. Limitations on Grant Scope

The licenses granted in this Section 2 are the only rights granted under
this License. No additional rights or licenses will be implied from the
distribution or licensing of Covered Software under this License.
Notwithstanding Section 2.1(b) above, no patent license is granted by a
Contributor:

(a) for any code that a Contributor has removed from Covered Software;
    or

(b) for infringements caused by: (i) Your and any other third party's
    modifications of Covered Software, or (ii) the combination of its
    Contributions with other software (except as part of its Contributor
    Version); or

(c) under Patent Claims infringed by Covered Software in the absence of
    its Contributions.

This License does not grant any rights in the trademarks, service marks,
or logos of any Contributor (except as may be necessary to comply with
the notice requirements in Section 3.4).

2.4. Subsequent Licenses

No Contributor makes additional grants as a result of Your choice to
distribute the Covered Software under a subsequent version of this
License (see Section 10.2) or under the terms of a Secondary License (if
permitted under the terms of Section 3.3).

2.5. Representation

Each Contributor represents that the Contributor believes its
Contributions are its original creation(s) or it has sufficient rights
to grant the rights to its Contributions conveyed by this License.

2.6. Fair Use

This License is not intended to limit any rights You have under
applicable copyright doctrines of fair use, fair dealing, or other
equivalents.

2.7. Conditions

Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
in Section 2.1.

3. Responsibilities
-------------------

3.1. Distribution of Source Form

All distribution of Covered Software in Source Code Form, including any
Modifications that You create or to which You contribute, must be under
the terms of this License. You must inform recipients that the Source
Code Form of the Covered Software is governed by the terms of this
License, and how they can obtain a copy of this License. You may not
attempt to alter or restrict the recipients' rights in the Source Code
Form.

3.2. Distribution of Executable Form

If You distribute Covered Software in Executable Form then:

(a) such Covered Software must also be made available in Source Code
    Form, as described in Section 3.1, and You must inform recipients of
    the Executable Form how they can obtain a copy of such Source Code
    Form by reasonable means in a timely manner, at a charge no more
    than the cost of distribution to the recipient; and

(b) You may distribute such Executable Form under the terms of this
    License, or sublicense it under different terms, provided that the
    license for the Executable Form does not attempt to limit or alter
    the recipients' rights in the Source Code Form under this License.

3.3. Distribution of a Larger Work

You may create and distribute a Larger Work under terms of Your choice,
provided that You also comply with the requirements of this License for
the Covered Software. If the Larger Work is a combination of Covered
Software with a work governed by one or more Secondary Licenses, and the
Covered Software is not Incompatible With Secondary Licenses, this
License permits You to additionally distribute such Covered Software
under the terms of such Secondary License(s), so that the recipient of
the Larger Work may, at their option, further distribute the Covered
Software under the terms of either this License or such Secondary
License(s).

3.4. Notices

You may not remove or alter the substance of any license notices
(including copyright notices, patent notices, disclaimers of warranty,
or limitations of liability) contained within the Source Code Form of
the Covered Software, except that You may alter any license notices to
the extent required to remedy known factual inaccuracies.

3.5. Application of Additional Terms

You may choose to offer, and to charge a fee for, warranty, support,
indemnity or liability obligations to one or more recipients of Covered
Software. However, You may do so only on Your own behalf, and not on
behalf of any Contributor. You must make it absolutely clear that any
such warranty, support, indemnity, or liability obligation is offered by
You alone, and You hereby agree to indemnify every Contributor for any
liability incurred by such Contributor as a result of warranty, support,
indemnity or liability terms You offer. You may include additional
disclaimers of warranty and limitations of liability specific to any
jurisdiction.

4. Inability to Comply Due to Statute or Regulation
---------------------------------------------------

If it is impossible for You to comply with any of the terms of this
License with respect to some or all of the Covered Software due to
statute, judicial order, or regulation then You must: (a) comply with
the terms of this License to the maximum extent possible; and (b)
describe the limitations and the code they affect. Such description must
be placed in a text file included with all distributions of the Covered
Software under this License. Except to the extent prohibited by statute
or regulation, such description must be sufficiently detailed for a
recipient of ordinary skill to be able to understand it.

5. Termination
--------------

5.1. The rights granted under this License will terminate automatically
if You fail to comply with any of its terms. However, if You become
compliant, then the rights granted under this License from a particular
Contributor are reinstated (a) provisionally, unless and until such
Contributor explicitly and finally terminates Your grants, and (b) on an
ongoing basis, if such Contributor fails to notify You of the
non-compliance by some reasonable means prior to 60 days after You have
come back into compliance. Moreover, Your grants from a particular
Contributor are reinstated on an ongoing basis if such Contributor
notifies You of the non-compliance by some reasonable means, this is the
first time You have received notice of non-compliance with this License
from such Contributor, and You become compliant prior to 30 days after
Your receipt of the notice.

5.2. If You initiate litigation against any entity by asserting a patent
infringement claim (excluding declaratory judgment actions,
counter-claims, and cross-claims) alleging that a Contributor Version
directly or indirectly infringes any patent, then the rights granted to
You by any and all Contributors for the Covered Software under Section
2.1 of this License shall terminate.

5.3. In the event of termination under Sections 5.1 or 5.2 above, all
end user license agreements (excluding distributors and resellers) which
have been validly granted by You or Your distributors under this License
prior to termination shall survive termination.

************************************************************************
*                                                                      *
*  6. Disclaimer of Warranty                                           *
*  -------------------------                                           *
*                                                                      *
*  Covered Software is provided under this License on an "as is"       *
*  basis, without warranty of any kind, either expressed, implied, or  *
*  statutory, including, without limitation, warranties that the       *
*  Covered Software is free of defects, merchantable, fit for a        *
*  particular purpose or non-infringing. The entire risk as to the     *
*  quality and performance of the Covered Software is with You.        *
*  Should any Covered Software prove defective in any respect, You     *
*  (not any Contributor) assume the cost of any necessary servicing,   *
*  repair, or correction. This disclaimer of warranty constitutes an   *
*  essential part of this License. No use of any Covered Software is   *
*  authorized under this License except under this disclaimer.         *
*                                                                      *
************************************************************************

************************************************************************
*                                                                      *
*  7. Limitation of Liability                                          *
*  --------------------------                                          *
*                                                                      *
*  Under no circumstances and under no legal theory, whether tort      *
*  (including negligence), contract, or otherwise, shall any           *
*  Contributor, or anyone who distributes Covered Software as          *
*  permitted above, be liable to You for any direct, indirect,         *
*  special, incidental, or consequential damages of any character      *
*  including, without limitation, damages for lost profits, loss of    *
*  goodwill, work stoppage, computer failure or malfunction, or any    *
*  and all other commercial damages or losses, even if such party      *
*  shall have been informed of the possibility of such damages. This   *
*  limitation of liability shall not apply to liability for death or   *
*  personal injury resulting from such party's negligence to the       *
*  extent applicable law prohibits such limitation. Some               *
*  jurisdictions do not allow the exclusion or limitation of           *
*  incidental or consequential damages, so this exclusion and          *
*  limitation may not apply to You.                                    *
*                                                                      *
************************************************************************

8. Litigation
-------------

Any litigation relating to this License may be brought only in the
courts of a jurisdiction where the defendant maintains its principal
place of business and such litigation shall be governed by laws of that
jurisdiction, without reference to its conflict-of-law provisions.
Nothing in this Section shall prevent a party's ability to bring
cross-claims or counter-claims.

9. Miscellaneous
----------------

This License represents the complete agreement concerning the subject
matter hereof. If any provision of this License is held to be
unenforceable, such provision shall be reformed only to the extent
necessary to make it enforceable. Any law or regulation which provides
that the language of a contract shall be construed against the drafter
shall not be used to construe this License against a Contributor.

10. Versions of the License
---------------------------

10.1. New Versions

Mozilla Foundation is the license steward. Except as provided in Section
10.3, no one other than the license steward has the right to modify or
publish new versions of this License. Each version will be given a
distinguishing version number.

10.2. Effect of New Versions

You may distribute the Covered Software under the terms of the version
of the License under which You originally received the Covered Software,
or under the terms of any subsequent version published by the license
steward.

10.3. Modified Versions

If you create software not governed by this License, and you want to
create a new license for such software, you may create and use a
modified version of this License if you rename the license and remove
any references to the name of the license steward (except to note that
such modified license differs from this License).

10.4. Distributing Source Code Form that is Incompatible With Secondary
Licenses

If You choose to distribute Source Code Form that is Incompatible With
Secondary Licenses under the terms of this version of the License, the
notice described in Exhibit B of this License must be attached.

Exhibit A - Source Code Form License Notice
-------------------------------------------

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

If it is not possible or desirable to put the notice in a particular
file, then You may include the notice in a location (such as a LICENSE
file in a relevant directory) where a recipient would be likely to look
for such a notice.

You may add additional accurate notices of copyright ownership.

Exhibit B - "Incompatible With Secondary Licenses" Notice
---------------------------------------------------------

  This Source Code Form is "Incompatible With Secondary Licenses", as
  defined by the Mozilla Public License, v. 2.0.

```

`README.md`:

```md

## The Amalgam Engine - An engine for easily creating virtual worlds

For more information, visit [worlds.place](https://worlds.place/).

If you'd like to get involved, please join the Discord: https://discord.gg/EA2Sg3ar74

## Vision
(Not all implemented yet, see [Roadmap](https://worlds.place/roadmap.html) or more detailed [Task Board](https://trello.com/b/8Z8VoAiX/amalgam-engine-tasks))
* Easily create your own isometric, sprite-based virtual world.
* Start from a template and have a full working world, including client, server, text chat, and account management.
* All needed networking is built-in, and adding new messages for your custom features is extremely easy.
* Supports 1000+ users in groups of 10, or 150+ users in 1 area, all being very active.
* Targeted for use on relatively low-spec hardware (tested on a $30/mo rented server).
* Live, in-world map editing. Use permissions to let players build things, or restrict it to your developers.

## Template Projects
### Repose
Repose is our first template project. If you'd like to make a world, you can fork Repose and use it as a fully-functioning starting point.

[Check out the project and download the latest playable release here.](https://github.com/Net5F/Repose)

## Building
Note: You rarely need to build the engine by itself, this section just provides canonical instructions. Instead, see the Template Projects section.

### Windows
#### Visual Studio (MSVC)
1. Open CMakeLists.txt in Visual Studio (`Open` -> `CMake`).
1. (Optional) Open CMakeSettings.json (in this repo) and enable `AM_BUILD_RESOURCE_IMPORTER` to build the Resource Importer.
1. `Project` -> `Generate CMake cache` (or just let it run if you have auto-config on).
1. `Build` -> `Build All`

Note: The Resource Importer should be built within your project, since it relies on config values from your project's Override/SharedConfig.h.

#### MinGW
For MSYS2/MinGW, we don't have a dependency install script. Here's the list:

    pacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-make mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja mingw-w64-x86_64-gdb mingw-w64-x86_64-SDL2 mingw-w64-x86_64-SDL2_image mingw-w64-x86_64-SDL2_mixer mingw-w64-x86_64-SDL2_ttf mingw-w64-x86_64-SDL2_gfx mingw-w64-x86_64-SDL2_net mingw-w64-x86_64-catch
    
Then, build through the Eclipse project or follow the Linux instructions for a command line build.

### Linux
Note: This is only tested on Ubuntu 20.04. If you have experience in multi-distro builds, please get involved!

1. Run `Scripts/Linux/InstallDependencies.sh`, then build through the Eclipse project, or:
1. (From the base of the repo) `mkdir -p Build/Linux/Release`
1. `cd Build/Linux/Release`
1. `cmake -DCMAKE_BUILD_TYPE=Release -G Ninja ../../../`
   1. You can optionally add `-DAM_BUILD_RESOURCE_IMPORTER` to build the Resource Importer.
1. `ninja all`

### macOS

Note: AmalgamEngine requires GCC to build on macOS. Clang / Apple Clang does not yet support C++ features required by this project (as of Apple Clang 14 / Clang 15).

1. Use the Homebrew package manager to install dependencies: `brew install gcc make cmake ninja sdl2 sdl2_image sdl2_mixer sdl2_ttf sdl2_gfx sdl2_net`
1. (From the base of the repo) `mkdir -p Build/macOS/Release`
1. `cd Build/macOS/Release`
1. `CC=gcc-NN CXX=g++-NN cmake -DCMAKE_BUILD_TYPE=Release -G Ninja ../../../`. Replace the `NN` in `gcc-NN` and `g++-NN` with the version of GCC that you installed with Homebrew. This is important, as using `gcc` without a version number will alias to `clang`.
   1. ~~You can optionally add `-DAM_BUILD_RESOURCE_IMPORTER` to build the Resource Importer.~~ Resource Importer doesn't currently build on macOS due to GCC not being able to build with Apple SDK headers which use certain Objective C extensions.
1. `ninja all`

## Packaging
Note: You rarely need to package the engine by itself, this section just provides canonical instructions. Instead, see the Template Projects section.

To package the applications in a way that can be shared, first run the desired build. Then, run:
```
// Assuming you're at the base of the repo.
cmake --install Build/Windows/Release --prefix Packages/Windows
```
where 'Build/Windows/Release' is your desired build to package, and 'Packages/Windows' is your desired output directory.

On Windows, you can use Visual Studio's developer terminal (`Tools` -> `Command Line` -> `Developer Command Prompt`) for easy access to CMake.

## Contributing
Contributions are very welcome! Feel free to work on features or bugfixes and submit PRs, they'll all be promptly reviewed. If you're looking for ways to contribute, check the [Task Board](https://trello.com/b/8Z8VoAiX/amalgam-engine-tasks).

There's a fairly solid vision for the near-future of this engine. If you would like to work on a larger feature, please make sure it's on [the roadmap](https://worlds.place/roadmap.html), or [join the discord](https://discord.gg/EA2Sg3ar74) and discuss it before getting started.

```

`Resources/ResourceImporter/Linux/README.txt`:

```txt
Hello! Thanks for downloading. I hope you enjoy.
- Net_

###################
## Installation
###################
No installation is required, just run the application.

If you have issues, please make sure that you have SDL2 installed.
    For Ubuntu: sudo apt install libsdl2-2.0-0 libsdl2-image-2.0-0 libsdl2-mixer-2.0-0 libsdl2-ttf-2.0-0 libsdl2-gfx-1.0-0

```

`Resources/ResourceImporter/Windows/README.txt`:

```txt
Hello! Thanks for downloading. I hope you enjoy.
- Net_

###################
## Installation
###################
No installation is required, just run the .exe file.

If you have issues, please make sure that you have the latest Visual C++ Redistributable:
    Direct link
        https://aka.ms/vs/17/release/vc_redist.x64.exe
    Microsoft support page
        https://docs.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170

```

`Scripts/Linux/FormatEngineSource.sh`:

```sh
#!/bin/bash

REQUIRED_PKG="clang-format"
PKG_OK=$(dpkg-query -W --showformat='${Status}\n' $REQUIRED_PKG|grep "install ok installed")
if [ "" = "$PKG_OK" ]; then
  echo "$REQUIRED_PKG not found. Installing."
  sudo apt --yes install $REQUIRED_PKG 
fi

# Grab the full path to the base of the repo (assuming this script is in Scripts/Linux)
BasePath="$( cd "$( dirname "${BASH_SOURCE[0]}" )/../.." >/dev/null 2>&1 && pwd )"

echo "Running clang-format on engine source code."
find $BasePath/Source -iname '*.h' -o -iname '*.cpp' | xargs clang-format -i
echo "Done."
    

```

`Scripts/Linux/GetRequiredCmake.sh`:

```sh
#!/bin/bash

# This script builds a new enough cmake from source to use for this project.
# If your OS version is new enough, you won't need to use this.

version=3.24.3

sudo apt install build-essential libssl-dev
sudo apt purge --auto-remove cmake

mkdir temp
cd temp

wget https://github.com/Kitware/CMake/releases/download/v$version/cmake-$version.tar.gz --no-check-certificate

tar -xzvf cmake-$version.tar.gz

cd CMake-$version

# Build and install
./bootstrap
make -j$(nproc)
sudo make install

cd ../..
rm -r temp


```

`Scripts/Linux/InstallDependencies.sh`:

```sh
#!/bin/bash

# Installs the dependencies required to do an engine build.
# Tested on 20.04, 24.04.

sudo apt update

sudo apt install g++ cmake libsdl2-dev libsdl2-image-dev libsdl2-mixer-dev libsdl2-ttf-dev libsdl2-gfx-dev libgtk-3-dev ninja-build

```

`Scripts/Linux/InstallLoadTestDependencies.sh`:

```sh
#!/bin/bash

# Installs the dependencies required to run an Amalgam Engine Server application.
# Tested on 24.04.

sudo apt update

sudo apt install libsdl2-2.0-0 

```

`Scripts/Linux/InstallServerDependencies.sh`:

```sh
#!/bin/bash

# Installs the dependencies required to run an Amalgam Engine Server application.
# Tested on 24.04.

sudo apt update

sudo apt install libsdl2-2.0-0 

```

`Source/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.13)

###############################################################################
# Modules
###############################################################################
# Configure Shared library.
add_subdirectory(SharedLib)

# Configure Client library.
add_subdirectory(ClientLib)

# Configure Server library.
add_subdirectory(ServerLib)

# Configure Resource Importer.
if (AM_BUILD_RESOURCE_IMPORTER)
    add_subdirectory(ResourceImporter)
endif()

# Configure Tools.
if (AM_BUILD_TOOLS)
    add_subdirectory(Tools)
endif()

# Configure tests.
if (AM_BUILD_TESTS)
    add_subdirectory(Tests)
endif()

```

`Source/ClientLib/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

message(STATUS "Configuring Amalgam Engine Client Library")

# Add our static library target.
add_library(ClientLib STATIC "")

# Provide an alias that can be used whether the target comes from 
# add_subdirectory() or find_package().
add_library(AmalgamEngine::ClientLib ALIAS ClientLib)

target_include_directories(ClientLib
    PUBLIC
        ${SDL2_INCLUDE_DIRS} ${SDL2_IMAGE_INCLUDE_DIRS} 
        ${SDL2_MIXER_INCLUDE_DIRS} ${SDL2_TTF_INCLUDE_DIRS}
        ${SDL2_GFX_INCLUDE_DIRS} ${SDL2PP_INCLUDE_DIRS}
)

# Inherit Shared's precompiled header.
# CMake causes issues when using precompiled headers with GCC on macOS,
# so precompiled headers are disabled for that target.
if ((NOT APPLE) OR (CMAKE_CXX_COMPILER_ID MATCHES "Clang|AppleClang"))
    target_precompile_headers(ClientLib REUSE_FROM SharedLib)
endif()

target_link_libraries(ClientLib
    PUBLIC
        ${SDL2_LIBRARIES} ${SDL2_IMAGE_LIBRARIES}
        ${SDL2_MIXER_LIBRARIES} ${SDL2_TTF_LIBRARIES}
        ${SDL2_GFX_LIBRARIES} ${SDL2PP_LIBRARIES}
        AmalgamUI
        Bitsery::bitsery
        readerwriterqueue
        CircularBuffer
        EnTT::EnTT
        QueuedEvents
        SharedLib
)

# Compile with C++23.
target_compile_features(ClientLib PRIVATE cxx_std_23)
set_target_properties(ClientLib PROPERTIES CXX_EXTENSIONS OFF)

# Enable compile warnings.
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    target_compile_options(ClientLib PUBLIC -Wall -Wextra)
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    target_compile_options(ClientLib PUBLIC /W3 /permissive-)
endif()

# Build all of the subdirectories.
add_subdirectory(Config)
add_subdirectory(Launch)
add_subdirectory(Network)
add_subdirectory(Renderer)
add_subdirectory(Simulation)
add_subdirectory(UserInterface)
add_subdirectory(Utility)

```

`Source/ClientLib/Config/CMakeLists.txt`:

```txt
target_sources(ClientLib
    PRIVATE
        Private/UserConfig.cpp
        Private/UserConfigInitializer.cpp
    PUBLIC
        Public/UserConfig.h
        Public/UserConfigInitializer.h
        Public/UserConfigStructs.h
)

target_include_directories(ClientLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ClientLib/Config/Private/UserConfig.cpp`:

```cpp
#include "UserConfig.h"
#include "Paths.h"
#include "Log.h"
#include "nlohmann/json.hpp"
#include <SDL.h>
#include <string>
#include <fstream>

namespace AM
{
namespace Client
{

UserConfig::UserConfig()
: fullscreenMode{}
, windowSizeWidth{}
, windowSizeHeight{}
, framesPerSecond{}
, frameTimestepS{}
, serverIP{}
, serverPort{}
{
    // Open the file.
    std::string fullPath{Paths::BASE_PATH};
    fullPath += "UserConfig.json";
    std::ifstream workingFile(fullPath);
    if (!(workingFile.is_open())) {
        LOG_FATAL("Failed to open UserConfig.json");
    }

    // Parse the file into a json structure.
    nlohmann::json json;
    try {
        json = nlohmann::json::parse(workingFile, nullptr, true, true);
    } catch (nlohmann::json::exception& e) {
        LOG_FATAL("Failed to parse UserConfig.json: %s", e.what());
    }

    // Initialize our members.
    try {
        init(json);
    } catch (nlohmann::json::exception& e) {
        LOG_FATAL("%s", e.what());
    }
}

UserConfig& UserConfig::get()
{
    static UserConfig userConfig;
    return userConfig;
}

unsigned int UserConfig::getFullscreenMode()
{
    return fullscreenMode;
}

void UserConfig::setFullscreenMode(unsigned int inFullscreenMode)
{
    if (inFullscreenMode != 0 && inFullscreenMode != 1) {
        LOG_FATAL("Invalid fullscreenMode value: %u", inFullscreenMode);
    }
    fullscreenMode = inFullscreenMode;
}

SDL_Rect UserConfig::getWindowSize()
{
    return {0, 0, windowSizeWidth, windowSizeHeight};
}

void UserConfig::setWindowSize(const SDL_Rect& inWindowSize)
{
    // Default to the given window size.
    windowSizeWidth = inWindowSize.w;
    windowSizeHeight = inWindowSize.h;

    // If fullscreen is selected, use the desktop size instead.
    // Note: SDL_GetDesktopDisplayMode() requires the SDL video subsystem
    //       to be initialized, so we have to check for that first.
    if ((fullscreenMode != 0) && SDL_WasInit(SDL_INIT_VIDEO)) {
        SDL_DisplayMode displayMode;
        SDL_GetDesktopDisplayMode(0, &displayMode);
        windowSizeWidth = displayMode.w;
        windowSizeHeight = displayMode.h;
    }
}

unsigned int UserConfig::getFramesPerSecond()
{
    return framesPerSecond;
}

double UserConfig::getFrameTimestepS()
{
    return frameTimestepS;
}

void UserConfig::setFramesPerSecond(unsigned int inFramesPerSecond)
{
    framesPerSecond = inFramesPerSecond;
    frameTimestepS = (1.0 / static_cast<double>(framesPerSecond));
}

ServerAddress UserConfig::getServerAddress()
{
    return {serverIP, serverPort};
}

void UserConfig::setServerAddress(const ServerAddress& inServerAddress)
{
    serverIP = inServerAddress.IP;
    serverPort = inServerAddress.port;
}

void UserConfig::init(nlohmann::json& json)
{
    // Fullscreen mode.
    setFullscreenMode(json.at("fullscreenMode"));

    // Window size.
    setWindowSize(
        {0, 0, json.at("windowSizeWidth"), json.at("windowSizeHeight")});

    // Server address.
    setServerAddress({json.at("serverIP"), json.at("serverPort")});

    // Framerate.
    setFramesPerSecond(json.at("framesPerSecond"));
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Config/Private/UserConfigInitializer.cpp`:

```cpp
#include "UserConfigInitializer.h"
#include "UserConfig.h"

namespace AM
{
namespace Client
{
UserConfigInitializer::UserConfigInitializer()
{
    UserConfig::get();
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Config/Public/UserConfig.h`:

```h
#pragma once

#include "UserConfigStructs.h"
#include "nlohmann/json_fwd.hpp"
#include <SDL_rect.h>

namespace AM
{
namespace Client
{
/**
 * A singleton instance that loads the user-defined configuration from
 * UserConfig.json into memory and provides an interface for accessing and
 * modifying it.
 *
 * Note: This class expects a UserConfig.json file to be present in the same
 *       directory as the application executable.
 *
 * TODO: If we eventually decide to live-refresh some of these fields, we can
 *       add signals that get emitted on change.
 *       E.g.:
 *           Public
 *               entt::sigh<void(ScreenRect)> windowSizeChanged;
 *           Private
 *               entt::sink<void(ScreenRect)> windowSizeSink;
 */
class UserConfig
{
public:
    /**
     * @pre SDL must be initialized.
     */
    UserConfig();

    /**
     * Returns the singleton instance.
     */
    static UserConfig& get();

    //-------------------------------------------------------------------------
    // Configuration Interface
    //-------------------------------------------------------------------------
    unsigned int getFullscreenMode();
    void setFullscreenMode(unsigned int inFullscreenMode);

    SDL_Rect getWindowSize();
    void setWindowSize(const SDL_Rect& inWindowSize);

    unsigned int getFramesPerSecond();
    double getFrameTimestepS();
    void setFramesPerSecond(unsigned int inFramesPerSecond);

    ServerAddress getServerAddress();
    void setServerAddress(const ServerAddress& inServerAddress);

private:
    /**
     * Initializes our members using the given json.
     * @throw nlohmann::json::exception if an expected field is not found.
     */
    void init(nlohmann::json& json);

    unsigned int fullscreenMode;

    int windowSizeWidth;
    int windowSizeHeight;

    unsigned int framesPerSecond;
    double frameTimestepS;

    std::string serverIP;
    unsigned int serverPort;
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Config/Public/UserConfig.json`:

```json
/**
 * This is an example UserConfig.json file, these values are not actually used. 
 * Projects can reference this file to understand what fields they must 
 * provide in their UserConfig.json.
 */

{
  // Sets full screen preference.
  // 0 = Windowed
  // 1 = Borderless windowed
  "fullscreenMode": 0,

  // The size of the application window.
  // Note: We currently only support 16:9 aspect ratios.
  // Note: If fullscreenMode is Fullscreen or Fullscreen windowed,
  //       this setting is ignored and the desktop size is used.
  "windowSizeWidth": 1600,
  "windowSizeHeight": 900,

  // The application framerate.
  "framesPerSecond": 60,

  // The IP address and port of the simulation server.
  "serverIP": "104.237.139.17",
  // "serverIP": "127.0.0.1",
  "serverPort": 41499
}

```

`Source/ClientLib/Config/Public/UserConfigInitializer.h`:

```h
#pragma once

namespace AM
{
namespace Client
{
/**
 * Minimal helper class to facilitate calling UserConfig::get() from an
 * initializer list.
 *
 * UserConfig::get() must first be called after SDL is initialized, but before
 * any threads are spun up that may cause race conditions around UserConfig
 * member access.
 */
class UserConfigInitializer
{
public:
    UserConfigInitializer();
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Config/Public/UserConfigStructs.h`:

```h
#pragma once

#include <string>

/**
 * This file contains structs used in UserConfig.h to combine related
 * config fields.
 */
namespace AM
{
namespace Client
{

struct ServerAddress {
    std::string IP{};

    unsigned int port{};
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Launch/CMakeLists.txt`:

```txt
target_sources(ClientLib
    PRIVATE
        Private/Application.cpp
    PUBLIC
        Public/Application.h
)

target_include_directories(ClientLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ClientLib/Launch/Private/Application.cpp`:

```cpp
#include "Application.h"
#include "Timer.h"
#include "Config.h"
#include "SharedConfig.h"
#include "UserConfig.h"
#include "Paths.h"
#include "SDLHelpers.h"
#include "Log.h"
#include <SDL.h>
#include <memory>

namespace AM
{
namespace Client
{
Application::Application()
: sdl{SDL_INIT_VIDEO}
, userConfigInitializer{}
, sdlWindow{Config::WINDOW_TITLE,
            SDL_WINDOWPOS_UNDEFINED,
            SDL_WINDOWPOS_UNDEFINED,
            UserConfig::get().getWindowSize().w,
            UserConfig::get().getWindowSize().h,
            SDL_WINDOW_SHOWN}
, sdlRenderer{sdlWindow.get(), -1, SDL_RENDERER_ACCELERATED}
, simEventDispatcher{}
, uiEventDispatcher{}
, networkEventDispatcher{}
, assetCache{sdlRenderer.get()}
, resourceData{}
, graphicData{resourceData.get(), assetCache}
, iconData{resourceData.get()}
, itemData{}
, castableData{graphicData}
, messageProcessorContext{networkEventDispatcher}
, network{messageProcessorContext}
, simulationContext{simulation,
                    network,
                    simEventDispatcher,
                    uiEventDispatcher,
                    networkEventDispatcher,
                    graphicData,
                    iconData,
                    itemData,
                    castableData}
, simulation{simulationContext}
, uiContext{simulation,
            userInterface.getWorldObjectLocator(),
            network,
            uiEventDispatcher,
            simEventDispatcher,
            networkEventDispatcher,
            sdlRenderer.get(),
            graphicData,
            iconData,
            itemData}
, userInterface{uiContext}
, rendererContext{sdlRenderer.get(), simulation.getWorld(), userInterface,
                  [&]() { return simCaller.getProgress(); }, graphicData}
, renderer{rendererContext}
, networkCaller{std::bind_front(&Network::tick, &network),
                SharedConfig::CLIENT_NETWORK_TICK_TIMESTEP_S, "Network", true}
, uiCaller{std::bind_front(&UserInterface::tick, &userInterface),
           Config::UI_TICK_TIMESTEP_S, "UserInterface", true}
, simCaller{std::bind_front(&Simulation::tick, &simulation),
            SharedConfig::SIM_TICK_TIMESTEP_S, "Sim", false}
, rendererCaller{std::bind_front(&Renderer::render, &renderer),
                 UserConfig::get().getFrameTimestepS(), "Renderer", true}
, messageProcessorExtension{}
, rendererExtension{}
, simulationExtension{}
, userInterfaceExtension{}
, eventHandlers{this, &renderer, &userInterface, &simulation}
, exitRequested{false}
{
    // Initialize the global timer.
    Timer::getGlobalTime();

    // Set fullscreen mode.
    unsigned int fullscreenMode{UserConfig::get().getFullscreenMode()};
    switch (fullscreenMode) {
        case 0: {
            SDLHelpers::setWindowFullscreen(sdlWindow.get(), 0);
            break;
        case 1:
            SDLHelpers::setWindowFullscreen(sdlWindow.get(),
                                            SDL_WINDOW_FULLSCREEN);
            break;
        }
        // Note: We removed real fullscreen because it was behaving weirdly and
        //       causing network timeouts, and having just windowed and
        //       borderless seems fine.
        default: {
            LOG_FATAL("Invalid fullscreen value: %d", fullscreenMode);
            break;
        }
    }

    // Enable delay reporting.
    simCaller.reportDelays(Simulation::SIM_DELAYED_TIME_S);

    // Set up our event filter.
    SDL_SetEventFilter(&Application::filterEvents, this);
}

void Application::start()
{
    // If any of the extensions aren't registered, exit early.
    if (!messageProcessorExtension || !rendererExtension || !simulationExtension
        || !userInterfaceExtension) {
        LOG_FATAL("All extensions must be registered before calling start()");
    }

    // Prime the timers so they don't start at 0.
    simCaller.initTimer();
    uiCaller.initTimer();
    networkCaller.initTimer();
    rendererCaller.initTimer();
    while (!exitRequested) {
        // Let the simulation process an iteration if it needs to.
        simCaller.update();

        // Let the UI widgets tick if they need to.
        uiCaller.update();

        // Send a heartbeat if necessary.
        networkCaller.update();

        // Let the renderer render if it needs to.
        rendererCaller.update();

        // If we have enough time, dispatch events.
        if (enoughTimeTillNextCall(DISPATCH_MINIMUM_TIME_S)) {
            dispatchOSEvents();
        }

        // If we have enough time, sleep.
        if (enoughTimeTillNextCall(Config::SLEEP_MINIMUM_TIME_S)) {
            // We have enough time to sleep for a few ms.
            // Note: We try to delay for 1ms because the OS will generally end
            //       up delaying us for 1-3ms.
            SDL_Delay(1);
        }
    }
}

bool Application::handleOSEvent(SDL_Event& event)
{
    switch (event.type) {
        case SDL_QUIT: {
            exitRequested = true;
            return true;
        }
    }

    return false;
}

void Application::dispatchOSEvents()
{
    // Dispatch all waiting SDL events.
    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        // Pass the event to each handler in order, stopping if it returns as
        // handled.
        for (OSEventHandler* handler : eventHandlers) {
            if (handler->handleOSEvent(event)) {
                break;
            }
        }
    }
}

bool Application::enoughTimeTillNextCall(double minimumTime)
{
    if ((simCaller.getTimeTillNextCall() > minimumTime)
        && (networkCaller.getTimeTillNextCall() > minimumTime)
        && (rendererCaller.getTimeTillNextCall() > minimumTime)) {
        return true;
    }
    else {
        return false;
    }
}

int Application::filterEvents(void*, SDL_Event*)
{
    // Application* app{static_cast<Application*>(userData)};

    // Currently no events that we care to filter.
    //
    // switch (event->type) {
    // }

    return 1;
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Launch/Public/Application.h`:

```h
#pragma once

#include "OSEventHandler.h"
#include "UserConfigInitializer.h"
#include "Network.h"
#include "Simulation.h"
#include "Renderer.h"
#include "AssetCache.h"
#include "ResourceData.h"
#include "GraphicData.h"
#include "IconData.h"
#include "ItemData.h"
#include "CastableData.h"
#include "QueuedEvents.h"
#include "UserInterface.h"
#include "PeriodicCaller.h"
#include "MessageProcessorContext.h"
#include "RendererContext.h"
#include "SimulationContext.h"
#include "UserInterfaceContext.h"
#include "IMessageProcessorExtension.h"
#include "IRendererExtension.h"
#include "ISimulationExtension.h"
#include "IUserInterfaceExtension.h"

#include "entt/signal/dispatcher.hpp"

#include "SDL_Wrappers/SDL.h"
#include "SDL_Wrappers/SDLWindow.h"
#include "SDL_Wrappers/SDLRenderer.h"

#include <atomic>
#include <functional>

namespace AM
{
namespace Client
{
/**
 * The start of all client application activity. Owns all of the application's
 * modules (Simulation, Network, etc).
 *
 * Also manages the main thread's loop, calling each module's update function
 * when appropriate.
 */
class Application : public OSEventHandler
{
public:
    Application();

    ~Application(){};

    /**
     * Begins the application. Assumes control of the thread until the
     * application exits.
     * 
     * Note: All extension classes must be registered before calling this 
     *       function.
     */
    void start();

    /**
     * Handles application-relevant events, such as exit requests.
     */
    bool handleOSEvent(SDL_Event& event) override;

    //-------------------------------------------------------------------------
    // Engine Extension Registration
    //-------------------------------------------------------------------------
    /**
     * Registers an extension class to be called by the MessageProcessor.
     *
     * Note: The extension class type T must derive from
     *       IMessageProcessorExtension and must implement a constructor of
     *       the form T(MessageProcessorExDependencies).
     */
    template<typename T>
    void registerMessageProcessorExtension();

    /**
     * Registers an extension class to be called by the Renderer.
     *
     * Note: The extension class type T must derive from IRendererExtension
     *       and must implement a constructor of the form
     *       T(RendererExDependencies).
     */
    template<typename T>
    void registerRendererExtension();

    /**
     * Registers an extension class to be called by the Simulation.
     *
     * Note: The extension class type T must derive from ISimulationExtension
     *       and must implement a constructor of the form
     *       T(SimulationExDependencies).
     */
    template<typename T>
    void registerSimulationExtension();

    /**
     * Registers an extension class to be called by the UserInterface.
     *
     * Note: The extension class type T must derive from IUserInterfaceExtension
     *       and must implement a constructor of the form
     *       T(UserInterfaceExDependencies).
     */
    template<typename T>
    void registerUserInterfaceExtension();

private:
    /** The minimum "time to next call" required to trigger an event dispatch.
        Event polling can take up to 5-6ms depending on how much is waiting.
        We prioritize the PeriodicCallers getting called on time, so we only
        dispatch events if there's a reasonable gap until the next needs to be
        called. */
    static constexpr double DISPATCH_MINIMUM_TIME_S{.003};

    /**
     * Dispatches waiting events to the eventHandlers.
     * Events are propagated through the vector in order, starting at index 0.
     * If an event is handled (handleOSEvent() returns true), propagation
     * stops.
     */
    void dispatchOSEvents();

    /**
     * Returns true if all PeriodicCallers have at least minimumTime left until
     * their next call. Else, false.
     */
    bool enoughTimeTillNextCall(double minimumTime);

    /**
     * Used to filter events before they arrive in the SDL event queue.
     *
     * Called asynchronously when SDL_PumpEvents is called (during
     * SDL_PollEvent). May run on a different core.
     */
    static int filterEvents(void* userData, SDL_Event* event);

    //-------------------------------------------------------------------------
    // SDL Objects
    //-------------------------------------------------------------------------
    SDL sdl;

    /** Initializes UserConfig. Must be constructed after SDL is initialized
        and before anything else. */
    UserConfigInitializer userConfigInitializer;

    SDLWindow sdlWindow;

    /** The SDL renderer that we use to render the UI and world.
        We use SDLRenderer for convenience of initialization here, but
        all other parts of the engine directly use SDL_Renderer (so that we
        can use SDL_Texture, which is better for the AssetCache.) */
    SDLRenderer sdlRenderer;

    //-------------------------------------------------------------------------
    // Event Busses
    //-------------------------------------------------------------------------
    /** Used for Sim -> UI events. */
    entt::dispatcher simEventDispatcher;

    /** Used for UI -> Sim events. */
    entt::dispatcher uiEventDispatcher;

    /** Used for Network -> Sim/UI message events. */
    EventDispatcher networkEventDispatcher;

    //-------------------------------------------------------------------------
    // Data, Modules, Contexts
    //-------------------------------------------------------------------------
    AssetCache assetCache;
    ResourceData resourceData;
    GraphicData graphicData;
    IconData iconData;
    ItemData itemData;
    CastableData castableData;

    MessageProcessorContext messageProcessorContext;
    Network network;

    SimulationContext simulationContext;
    Simulation simulation;

    UserInterfaceContext uiContext;
    UserInterface userInterface;

    RendererContext rendererContext;
    Renderer renderer;

    //-------------------------------------------------------------------------
    // PeriodicCallers
    //-------------------------------------------------------------------------
    /** Calls network.tick() at the network tick rate. */
    PeriodicCaller networkCaller;

    /** Calls userInterface.tick() at our UI tick rate. */
    PeriodicCaller uiCaller;

    /** Calls simulation.tick() at the sim tick rate. */
    PeriodicCaller simCaller;

    /** Calls renderer.render() at our frame rate. */
    PeriodicCaller rendererCaller;

    //-------------------------------------------------------------------------
    // Module Extensions
    //-------------------------------------------------------------------------
    /** Contains the project's extension functions.
        Allows the project to provide code and have it be called at the 
        appropriate time.
        Note: This class guarantees that these extensions will be set and non-
              null before the loop starts running. This means we don't need to 
              null check the extension pointers in any class. */
    std::unique_ptr<IMessageProcessorExtension> messageProcessorExtension;
    std::unique_ptr<IRendererExtension> rendererExtension;
    std::unique_ptr<ISimulationExtension> simulationExtension;
    std::unique_ptr<IUserInterfaceExtension> userInterfaceExtension;

    //-------------------------------------------------------------------------
    // Additional, used during the loop
    //-------------------------------------------------------------------------
    /** An ordered vector of OS-event-handling objects. */
    std::vector<OSEventHandler*> eventHandlers;

    /** True if there has been a request to exit the program, else false. */
    std::atomic<bool> exitRequested;
};

template<typename T>
void Application::registerMessageProcessorExtension()
{
    messageProcessorExtension = std::make_unique<T>(messageProcessorContext);
    network.setMessageProcessorExtension(messageProcessorExtension.get());
}

template<typename T>
void Application::registerRendererExtension()
{
    rendererExtension = std::make_unique<T>(rendererContext);
    renderer.setExtension(rendererExtension.get());
}

template<typename T>
void Application::registerSimulationExtension()
{
    simulationExtension = std::make_unique<T>(simulationContext);
    simulation.setExtension(simulationExtension.get());
}

template<typename T>
void Application::registerUserInterfaceExtension()
{
    userInterfaceExtension = std::make_unique<T>(uiContext);
    userInterface.setExtension(userInterfaceExtension.get());
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Network/CMakeLists.txt`:

```txt
target_sources(ClientLib
	PRIVATE
		Private/Network.cpp
		Private/MessageProcessor.cpp
	PUBLIC
		Public/ConnectionError.h
		Public/IMessageProcessorExtension.h
		Public/MessageProcessor.h
		Public/MessageProcessorContext.h
		Public/Network.h
		Public/PlayerMovementUpdate.h
)

target_include_directories(ClientLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ClientLib/Network/Private/MessageProcessor.cpp`:

```cpp
#include "MessageProcessor.h"
#include "MessageProcessorContext.h"
#include "QueuedEvents.h"
#include "Deserialize.h"
#include "DispatchMessage.h"
#include "IMessageProcessorExtension.h"
#include "ExplicitConfirmation.h"
#include "ConnectionResponse.h"
#include "SystemMessage.h"
#include "EntityInit.h"
#include "EntityDelete.h"
#include "EntityInitScriptResponse.h"
#include "MovementUpdate.h"
#include "ComponentUpdate.h"
#include "ChunkUpdate.h"
#include "InventoryInit.h"
#include "CastCooldownInit.h"
#include "ItemError.h"
#include "ItemUpdate.h"
#include "ItemInitScriptResponse.h"
#include "CombineItems.h"
#include "DialogueResponse.h"
#include "CastFailed.h"
#include "CastStarted.h"
#include "TileAddLayer.h"
#include "TileRemoveLayer.h"
#include "TileClearLayers.h"
#include "TileExtentClearLayers.h"
#include "InventoryOperation.h"
#include "PlayerMovementUpdate.h"
#include "Log.h"
#include "AMAssert.h"

namespace AM
{
namespace Client
{
MessageProcessor::MessageProcessor(
    const MessageProcessorContext& inMessageProcessorContext)
: networkEventDispatcher{inMessageProcessorContext.networkEventDispatcher}
, playerEntity{entt::null}
, lastReceivedTick{0}
, extension{nullptr}
{
}

void MessageProcessor::processReceivedMessage(Uint8 messageType,
                                              Uint8* messageBuffer,
                                              std::size_t messageSize)
{
    // Match the enum values to their event types.
    EngineMessageType engineMessageType{
        static_cast<EngineMessageType>(messageType)};
    switch (engineMessageType) {
        case EngineMessageType::ExplicitConfirmation: {
            handleExplicitConfirmation(messageBuffer, messageSize);
            break;
        }
        case EngineMessageType::ConnectionResponse: {
            handleConnectionResponse(messageBuffer, messageSize);
            break;
        }
        case EngineMessageType::SystemMessage: {
            dispatchMessage<SystemMessage>(messageBuffer, messageSize,
                                           networkEventDispatcher);
            break;
        }
        case EngineMessageType::EntityInit: {
            dispatchMessage<EntityInit>(messageBuffer, messageSize,
                                        networkEventDispatcher);
            break;
        }
        case EngineMessageType::EntityDelete: {
            dispatchMessage<EntityDelete>(messageBuffer, messageSize,
                                          networkEventDispatcher);
            break;
        }
        case EngineMessageType::EntityInitScriptResponse: {
            dispatchMessage<EntityInitScriptResponse>(
                messageBuffer, messageSize, networkEventDispatcher);
            break;
        }
        case EngineMessageType::MovementUpdate: {
            handleMovementUpdate(messageBuffer, messageSize);
            break;
        }
        case EngineMessageType::ComponentUpdate: {
            handleComponentUpdate(messageBuffer, messageSize);
            break;
        }
        case EngineMessageType::ChunkUpdate: {
            dispatchMessageSharedPtr<ChunkUpdate>(messageBuffer, messageSize,
                                                  networkEventDispatcher);
            break;
        }
        case EngineMessageType::InventoryInit: {
            dispatchMessage<InventoryInit>(messageBuffer, messageSize,
                                           networkEventDispatcher);
            break;
        }
        case EngineMessageType::CastCooldownInit: {
            dispatchMessage<CastCooldownInit>(messageBuffer, messageSize,
                                              networkEventDispatcher);
            break;
        }
        case EngineMessageType::ItemError: {
            dispatchMessage<ItemError>(messageBuffer, messageSize,
                                       networkEventDispatcher);
            break;
        }
        case EngineMessageType::ItemUpdate: {
            dispatchMessage<ItemUpdate>(messageBuffer, messageSize,
                                        networkEventDispatcher);
            break;
        }
        case EngineMessageType::ItemInitScriptResponse: {
            dispatchMessage<ItemInitScriptResponse>(messageBuffer, messageSize,
                                                    networkEventDispatcher);
            break;
        }
        case EngineMessageType::CombineItems: {
            dispatchMessage<CombineItems>(messageBuffer, messageSize,
                                          networkEventDispatcher);
            break;
        }
        case EngineMessageType::DialogueResponse: {
            dispatchMessage<DialogueResponse>(messageBuffer, messageSize,
                                              networkEventDispatcher);
            break;
        }
        case EngineMessageType::CastFailed: {
            dispatchMessage<CastFailed>(messageBuffer, messageSize,
                                        networkEventDispatcher);
            break;
        }
        case EngineMessageType::CastStarted: {
            dispatchMessage<CastStarted>(messageBuffer, messageSize,
                                         networkEventDispatcher);
            break;
        }
        case EngineMessageType::TileAddLayer: {
            dispatchMessage<TileAddLayer>(messageBuffer, messageSize,
                                          networkEventDispatcher);
            break;
        }
        case EngineMessageType::TileRemoveLayer: {
            dispatchMessage<TileRemoveLayer>(messageBuffer, messageSize,
                                             networkEventDispatcher);
            break;
        }
        case EngineMessageType::TileClearLayers: {
            dispatchMessage<TileClearLayers>(messageBuffer, messageSize,
                                             networkEventDispatcher);
            break;
        }
        case EngineMessageType::TileExtentClearLayers: {
            dispatchMessage<TileExtentClearLayers>(messageBuffer, messageSize,
                                                   networkEventDispatcher);
            break;
        }
        case EngineMessageType::InventoryOperation: {
            dispatchMessage<InventoryOperation>(messageBuffer, messageSize,
                                                networkEventDispatcher);
            break;
        }
        default: {
            // If we don't have a handler for this message type, pass it to
            // the project.
            extension->processReceivedMessage(messageType, messageBuffer,
                                              messageSize);
            break;
        }
    }
}

Uint32 MessageProcessor::getLastReceivedTick()
{
    return lastReceivedTick;
}

void MessageProcessor::setExtension(IMessageProcessorExtension* inExtension)
{
    extension = inExtension;
}

void MessageProcessor::handleExplicitConfirmation(Uint8* messageBuffer,
                                                  std::size_t messageSize)
{
    // Deserialize the message.
    ExplicitConfirmation explicitConfirmation{};
    Deserialize::fromBuffer(messageBuffer, messageSize, explicitConfirmation);

    // Move lastReceivedTick forward.
    lastReceivedTick += explicitConfirmation.confirmedTickCount;
}

void MessageProcessor::handleConnectionResponse(Uint8* messageBuffer,
                                                std::size_t messageSize)
{
    // Deserialize the message.
    ConnectionResponse connectionResponse{};
    Deserialize::fromBuffer(messageBuffer, messageSize, connectionResponse);

    // Save our player entity so we can determine which update messages are for
    // the player.
    playerEntity = connectionResponse.entity;

    // Initialize lastReceivedTick.
    lastReceivedTick = connectionResponse.tickNum;

    // Push the message into any subscribed queues.
    networkEventDispatcher.push<ConnectionResponse>(connectionResponse);
}

void MessageProcessor::handleMovementUpdate(Uint8* messageBuffer,
                                            std::size_t messageSize)
{
    // Deserialize the message.
    std::shared_ptr<MovementUpdate> movementUpdate{
        std::make_shared<MovementUpdate>()};
    Deserialize::fromBuffer(messageBuffer, messageSize, *movementUpdate);

    // If the message's tick is newer than our saved tick, update it.
    if (movementUpdate->tickNum > lastReceivedTick) {
        lastReceivedTick = movementUpdate->tickNum;
    }
    AM_ASSERT((movementUpdate->tickNum >= lastReceivedTick),
              "Received ticks out of order. last: %u, new: %u",
              lastReceivedTick.load(), movementUpdate->tickNum);

    // If the player entity is present, process it and erase it from the
    // message.
    std::vector<MovementState>& movementStates{movementUpdate->movementStates};
    for (auto it = movementStates.begin(); it != movementStates.end(); ++it) {
        MovementState& movementState{*it};
        if (movementState.entity == playerEntity) {
            PlayerMovementUpdate playerMovementUpdate{
                {movementState.entity, movementState.input,
                 movementState.position, movementState.movement},
                movementUpdate->tickNum};
            networkEventDispatcher.push(playerMovementUpdate);

            movementStates.erase(it);
            break;
        }
    }

    // If there are NPC entities remaining in the message, push it.
    if (movementStates.size() > 0) {
        networkEventDispatcher.push<std::shared_ptr<const MovementUpdate>>(
            movementUpdate);
    }
}

void MessageProcessor::handleComponentUpdate(Uint8* messageBuffer,
                                             std::size_t messageSize)
{
    // Deserialize the message.
    ComponentUpdate componentUpdate{};
    Deserialize::fromBuffer(messageBuffer, messageSize, componentUpdate);

    // If the message's tick is newer than our saved tick, update it.
    if (componentUpdate.tickNum > lastReceivedTick) {
        lastReceivedTick = componentUpdate.tickNum;
    }
    AM_ASSERT((componentUpdate.tickNum >= lastReceivedTick),
              "Received ticks out of order. last: %u, new: %u",
              lastReceivedTick.load(), componentUpdate.tickNum);

    networkEventDispatcher.push(componentUpdate);
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Network/Private/Network.cpp`:

```cpp
#include "Network.h"
#include "MessageProcessorContext.h"
#include "QueuedEvents.h"
#include "Heartbeat.h"
#include "ConnectionError.h"
#include "Config.h"
#include "UserConfig.h"
#include "NetworkStats.h"
#include "IMessageProcessorExtension.h"
#include "AMAssert.h"
#include <SDL_net.h>

namespace AM
{
namespace Client
{
Network::Network(const MessageProcessorContext& inMessageProcessorContext)
: server{nullptr}
, networkEventDispatcher{inMessageProcessorContext.networkEventDispatcher}
, messageProcessor{inMessageProcessorContext}
, tickAdjustment{0}
, adjustmentIteration{0}
, isApplyingTickAdjustment{false}
, messagesSentSinceTick{0}
, currentTickPtr{nullptr}
, receiveThreadObj{}
, exitRequested{false}
, headerRecBuffer(SERVER_HEADER_SIZE)
, batchRecBuffer(SharedConfig::MAX_BATCH_SIZE)
, decompressedBatchRecBuffer(SharedConfig::MAX_BATCH_SIZE)
, netstatsLoggingEnabled{true}
, ticksSinceNetstatsLog{0}
{
    if (!Config::RUN_OFFLINE) {
        SDLNet_Init();
    }
}

Network::~Network()
{
    exitRequested = true;

    if (!Config::RUN_OFFLINE) {
        if (receiveThreadObj.joinable()) {
            receiveThreadObj.join();
        }
        SDLNet_Quit();
    }
}

void Network::connect()
{
    if (server != nullptr) {
        LOG_INFO("Attempted to connect while connected.");
        return;
    }

    // Spin up the receive thread (will start the connection attempt).
    exitRequested = false;
    receiveThreadObj = std::jthread(&Network::connectAndReceive, this);
}

void Network::disconnect()
{
    // Spin down the receive thread.
    exitRequested = true;
    if (receiveThreadObj.joinable()) {
        receiveThreadObj.join();
    }
    server = nullptr;
    adjustmentIteration = 0;
    isApplyingTickAdjustment = false;
    messagesSentSinceTick = 0;
    ticksSinceNetstatsLog = 0;
}

void Network::tick()
{
    if (!Config::RUN_OFFLINE && (server != nullptr)) {
        // If the sim is running, send a heartbeat if we need to.
        if (*currentTickPtr != 0) {
            sendHeartbeatIfNecessary();
        }

        // If it's time to log our network statistics, do so.
        if (netstatsLoggingEnabled) {
            ticksSinceNetstatsLog++;
            if (ticksSinceNetstatsLog == TICKS_TILL_STATS_DUMP) {
                logNetworkStatistics();
                ticksSinceNetstatsLog = 0;
            }
        }
    }
}

Uint32 Network::getLastReceivedTick()
{
    return messageProcessor.getLastReceivedTick();
}

int Network::transferTickAdjustment()
{
    if (isApplyingTickAdjustment) {
        int currentAdjustment = tickAdjustment;
        if (currentAdjustment < 0) {
            // The sim can only freeze for 1 tick at a time, transfer 1 from
            // tickAdjustment.
            tickAdjustment += 1;
            return -1;
        }
        else if (currentAdjustment > 0) {
            // The sim can process multiple iterations to catch up, transfer
            // all of tickAdjustment.
            tickAdjustment -= currentAdjustment;
            return currentAdjustment;
        }
        else {
            // We finished applying the adjustment, increment the iteration.
            adjustmentIteration++;
            isApplyingTickAdjustment = false;
            return 0;
        }
    }
    else {
        return 0;
    }
}

void Network::registerCurrentTickPtr(
    const std::atomic<Uint32>* inCurrentTickPtr)
{
    currentTickPtr = inCurrentTickPtr;
}

void Network::setNetstatsLoggingEnabled(bool inNetstatsLoggingEnabled)
{
    netstatsLoggingEnabled = inNetstatsLoggingEnabled;
}

void Network::setMessageProcessorExtension(
    IMessageProcessorExtension* extension)
{
    messageProcessor.setExtension(extension);
}

void Network::send(const BinaryBufferSharedPtr& message)
{
    if ((server == nullptr) || !(server->isConnected())) {
        // Note: Receive thread is responsible for emitting ConnectionError.
        LOG_INFO("Tried to send while server is disconnected.");
        return;
    }
    // Note: serializeAndSend() is responsible for checking message size.

    // Send the message.
    NetworkResult result{server->send(message)};
    if (result == NetworkResult::Success) {
        messagesSentSinceTick++;

        // Record the number of sent bytes.
        NetworkStats::recordBytesSent(
            static_cast<unsigned int>(message->size()));
    }
    else {
        // Note: Receive thread is responsible for emitting ConnectionError.
        LOG_INFO("Message send failed.");
    }
}

void Network::sendHeartbeatIfNecessary()
{
    // If we haven't sent any relevant messages since the last tick.
    if (messagesSentSinceTick == 0) {
        // Send the heartbeat message.
        serializeAndSend<Heartbeat>({*currentTickPtr});
    }

    messagesSentSinceTick = 0;
}

void Network::connectAndReceive()
{
    // Try to connect.
    ServerAddress serverAddress{UserConfig::get().getServerAddress()};
    server = Peer::initiate(serverAddress.IP, serverAddress.port);
    if (server != nullptr) {
        // Note: The server sends us a ConnectionResponse when we connect the
        //       socket. Eventually, we'll instead send a ConnectionRequest to
        //       the login server here.
    }
    else {
        networkEventDispatcher.emplace<ConnectionError>(
            ConnectionError::Type::Failed);
        return;
    }

    // Receive message batches from the server.
    while (!exitRequested) {
        if (!(server->isReady(true))) {
            // There wasn't any activity, delay so we don't waste CPU
            // spinning.
            SDL_Delay(INACTIVE_DELAY_TIME_MS);
        }

        // Data is waiting. Receive it.
        int bytesReceived{
            server->receiveBytes(headerRecBuffer.data(), SERVER_HEADER_SIZE)};
        if (bytesReceived < 0) {
            LOG_INFO("Found server to be disconnected while trying to receive "
                     "header.");
            networkEventDispatcher.emplace<ConnectionError>(
                ConnectionError::Type::Disconnected);
            return;
        }

        processBatch();
    }
}

void Network::processBatch()
{
    // Start tracking the number of received bytes.
    unsigned int bytesReceived{SERVER_HEADER_SIZE};

    // Check if we need to adjust the tick offset.
    adjustIfNeeded(headerRecBuffer[ServerHeaderIndex::TickAdjustment],
                   headerRecBuffer[ServerHeaderIndex::AdjustmentIteration]);

    /* Process the BatchSize header field. */
    // Read the high bit of batchSize to tell whether the batch is compressed
    // or not. If the high bit is set, the batch is compressed.
    Uint16 batchSize{
        ByteTools::read16(&(headerRecBuffer[ServerHeaderIndex::BatchSize]))};
    bool batchIsCompressed{(batchSize & (1U << 15)) != 0};

    // Reset the high bit of batchSize to get the real size.
    batchSize &= ~(1U << 15);

    /* Process the batch, if it contains any data. */
    if (batchSize > 0) {
        // Receive the expected bytes.
        int result{server->receiveBytesWait(&(batchRecBuffer[0]), batchSize)};
        if (result < 0) {
            LOG_INFO("Found server to be disconnected while trying to receive "
                     "batch.");
            return;
        }

        // Track the number of bytes we've received.
        bytesReceived += MESSAGE_HEADER_SIZE + batchSize;

        // If the payload is compressed, decompress it.
        Uint8* bufferToUse{&(batchRecBuffer[0])};
        if (batchIsCompressed) {
            batchSize = static_cast<Uint16>(
                ByteTools::decompress(&(batchRecBuffer[0]), batchSize,
                                      &(decompressedBatchRecBuffer[0]),
                                      SharedConfig::MAX_BATCH_SIZE));

            bufferToUse = &(decompressedBatchRecBuffer[0]);
        }

        // Process the messages.
        std::size_t bufferIndex{0};
        while (bufferIndex < batchSize) {
            Uint8 messageType{
                bufferToUse[bufferIndex + MessageHeaderIndex::MessageType]};
            Uint16 messageSize{ByteTools::read16(
                &(bufferToUse[bufferIndex + MessageHeaderIndex::Size]))};

            messageProcessor.processReceivedMessage(
                messageType,
                &(bufferToUse[bufferIndex + MessageHeaderIndex::MessageStart]),
                messageSize);

            bufferIndex += MESSAGE_HEADER_SIZE + messageSize;
            AM_ASSERT((bufferIndex <= batchSize),
                      "Buffer index is wrong. %u, %u", bufferIndex, batchSize);
        }

        AM_ASSERT((bufferIndex == batchSize),
                  "Didn't process correct number of bytes. %u, %u", bufferIndex,
                  batchSize);
    }

    // Record the number of received bytes.
    NetworkStats::recordBytesReceived(bytesReceived);
}

void Network::adjustIfNeeded(Sint8 receivedTickAdj, Uint8 receivedAdjIteration)
{
    if (receivedTickAdj != 0) {
        Uint8 currentAdjIteration{adjustmentIteration};

        // If it's the current iteration and we aren't already applying it.
        if ((receivedAdjIteration == currentAdjIteration)
            && !isApplyingTickAdjustment) {
            // Set the adjustment to be applied.
            tickAdjustment += receivedTickAdj;
            isApplyingTickAdjustment = true;
            LOG_INFO("Received tick adjustment: %d, iteration: %u",
                     receivedTickAdj, receivedAdjIteration);
        }
        else if (receivedAdjIteration > currentAdjIteration) {
            if (isApplyingTickAdjustment) {
                LOG_FATAL("Received future adjustment iteration while applying "
                          "the last. current: %u, received: %u",
                          currentAdjIteration, receivedAdjIteration);
            }
            else {
                LOG_FATAL("Out of sequence adjustment iteration. current: %u, "
                          "received: %u",
                          currentAdjIteration, receivedAdjIteration);
            }
        }
    }
}

void Network::logNetworkStatistics()
{
    // Dump the stats from the tracker.
    NetStatsDump netStats{NetworkStats::dumpStats()};

    // Log the stats.
    float bytesSentPerSecond{netStats.bytesSent
                             / static_cast<float>(SECONDS_TILL_STATS_DUMP)};
    float bytesReceivedPerSecond{netStats.bytesReceived
                                 / static_cast<float>(SECONDS_TILL_STATS_DUMP)};
    LOG_INFO("Bytes sent per second: %.0f, Bytes received per second: %.0f",
             bytesSentPerSecond, bytesReceivedPerSecond);
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Network/Public/ConnectionError.h`:

```h
#pragma once

namespace AM
{
namespace Client
{

/**
 * Communicates that a connection error occurred.
 */
struct ConnectionError {
    enum class Type {
        Failed,      /*!< We failed to connect. */
        Disconnected /*!< We lost our connection to the server. */
    };

    /** The type of connection error that occurred. */
    Type type{Type::Disconnected};
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Network/Public/IMessageProcessorExtension.h`:

```h
#pragma once

#include <SDL_stdinc.h>
#include <cstddef>

namespace AM
{
namespace Client
{

/**
 * Defines an extension for the engine's Client::MessageProcessor class.
 *
 * Extensions are implemented by the project, and are given generic functions
 * ("hooks") in which they can implement relevant project logic.
 *
 * The project can register the extension class with the engine through
 * Application::registerMessageProcessorExtension().
 */
class IMessageProcessorExtension
{
public:
    // Canonical constructor (derived class must implement):
    // MessageProcessorExtension(const MessageProcessorExDependencies& deps)

    /**
     * Called when a message is received that the engine doesn't have a handler
     * for.
     */
    virtual void processReceivedMessage(Uint8 messageType, Uint8* messageBuffer,
                                        std::size_t messageSize)
        = 0;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Network/Public/MessageProcessor.h`:

```h
#pragma once

#include "entt/fwd.hpp"
#include <SDL_stdinc.h>
#include <memory>
#include <vector>
#include <span>
#include <atomic>

namespace AM
{
class EventDispatcher;

namespace Client
{
class IMessageProcessorExtension;
struct MessageProcessorContext;

/**
 * Processes received messages.
 *
 * If the message is relevant to the network layer, it's passed to a matching
 * function that contains all of its handling logic.
 *
 * If the message isn't relevant to the network layer, it's passed to a generic
 * function that pushes it straight down to the simulation layer.
 *
 * If the message isn't relevant to the engine at all, it's passed to the
 * project.
 */
class MessageProcessor
{
public:
    MessageProcessor(const MessageProcessorContext& inMessageProcessorContext);

    /**
     * Deserializes and handles received messages.
     *
     * See class comment.
     *
     * @param messageType  The type of the received message.
     * @param messageBuffer A buffer containing a serialized message, starting
     *                      at index 0.
     * @param messageSize  The length in bytes of the message in messageBuffer.
     */
    void processReceivedMessage(Uint8 messageType, Uint8* messageBuffer,
                                std::size_t messageSize);

    /**
     * Returns the latest tick that we've received an update message for.
     */
    Uint32 getLastReceivedTick();

    /**
     * See extension member comment.
     */
    void setExtension(IMessageProcessorExtension* inExtension);

private:
    //-------------------------------------------------------------------------
    // Handlers for messages relevant to the network layer.
    //-------------------------------------------------------------------------
    /** Pushes ExplicitConfirmation event. */
    void handleExplicitConfirmation(Uint8* messageBuffer,
                                    std::size_t messageSize);

    /** Pushes ConnectionResponse event. */
    void handleConnectionResponse(Uint8* messageBuffer,
                                  std::size_t messageSize);

    /** Pushes PlayerMovementUpdate and MovementUpdate events. */
    void handleMovementUpdate(Uint8* messageBuffer, std::size_t messageSize);

    /** Pushes ComponentUpdate event. */
    void handleComponentUpdate(Uint8* messageBuffer, std::size_t messageSize);
    //-------------------------------------------------------------------------

    /** The dispatcher for network events. Used to send events to the
        subscribed queues. */
    EventDispatcher& networkEventDispatcher;

    /** The entity that this client is controlling. Used when we receive client
        entity updates, to tell if they contain data relevant to the player
        entity. */
    entt::entity playerEntity;

    /** The latest tick that we've received a message or confirmation for. */
    std::atomic<Uint32> lastReceivedTick;

    /** Contains the project's message processing extension functions.
        Allows the project to provide message processing code and have it be
        called at the appropriate time. */
    IMessageProcessorExtension* extension;
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Network/Public/MessageProcessorContext.h`:

```h
#pragma once

namespace AM
{
class EventDispatcher;

namespace Client
{

/**
 * Provides the dependencies that MessageProcessor logic may use.
 */
struct MessageProcessorContext {
public:
    EventDispatcher& networkEventDispatcher;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Network/Public/Network.h`:

```h
#pragma once

#include "SharedConfig.h"
#include "NetworkDefs.h"
#include "MessageProcessor.h"
#include "Serialize.h"
#include "Peer.h"
#include "Deserialize.h"
#include "ByteTools.h"
#include "Log.h"
#include <SDL_stdinc.h>
#include <string>
#include <memory>
#include <atomic>
#include <thread>

namespace AM
{
struct ConnectionResponse;
struct EntityUpdate;

namespace Client
{
struct MessageProcessorContext;
class IMessageProcessorExtension;
/**
 * Provides a convenient interface for connecting to the server, sending
 * and receiving messages, and other network-related functionality.
 *
 * Note: ServerConnectionSystem is responsible for calling connect() and
 * disconnect(). If a connection error is detected, this class will push a
 * ConnectionError event and ServerConnectionSystem will handle it.
 */
class Network
{
public:
    Network(const MessageProcessorContext& inMessageProcessorContext);

    ~Network();

    // TODO: If the IP provided in UserConfig.json is invalid, the receive
    //       thread will stall for a long time while waiting for
    //       SDLNet_TCP_Open() to return. If we move off SDL_Net, improve this.
    /**
     * Spins up the connectAndReceive thread.
     *
     * Note: ServerConnectionSystem is responsible for calling this. See class
     *       comment.
     */
    void connect();

    /**
     * Cleans up our server connection and spins down the receive thread.
     *
     * Note: ServerConnectionSystem is responsible for calling this. See class
     *       comment.
     */
    void disconnect();

    /**
     * Updates accumulatedTime. If greater than the tick timestep and no
     * messages have been sent since the last heartbeat, sends a message.
     *
     * Also logs network statistics periodically.
     */
    void tick();

    /**
     * Sends bytes over the network.
     * Errors if the server is disconnected.
     *
     * @param messageStruct A structure that defines MESSAGE_TYPE and has an
     *                      associated serialize() function.
     */
    template<typename T>
    void serializeAndSend(const T& messageStruct);

    /**
     * Returns the latest tick that we've received an update message for.
     */
    Uint32 getLastReceivedTick();

    // TODO: Just return the total adjustment and let the sim figure it out.
    /**
     * Returns the amount that the sim tick should be adjusted by.
     *
     * The server adds to our tickAdjustment when we're too far ahead or behind
     * it.
     *
     * @return 1 if there's a negative tickAdjustment (the sim can only freeze 1
     *         tick at a time), else 0 or a negative amount equal to the current
     *         tickAdjustment.
     */
    int transferTickAdjustment();

    /**
     * Used for passing us a pointer to the Simulation's currentTick.
     */
    void registerCurrentTickPtr(const std::atomic<Uint32>* inCurrentTickPtr);

    /**
     * Enables the periodic printing and logging of network stats.
     */
    void setNetstatsLoggingEnabled(bool inNetstatsLoggingEnabled);

    /**
     * See MessageProcessor::extension member comment.
     */
    void setMessageProcessorExtension(IMessageProcessorExtension* extension);

private:
    /**
     * How long the receive loop in connectAndReceive should delay if no
     * socket activity was reported on the socket.
     */
    static constexpr unsigned int INACTIVE_DELAY_TIME_MS{1};

    /**
     * Sends bytes over the network.
     * Errors if the server is disconnected.
     */
    void send(const BinaryBufferSharedPtr& message);

    /**
     * If we haven't sent any messages since the last network tick, sends a
     * heartbeat.
     */
    void sendHeartbeatIfNecessary();

    /**
     * Thread function, started from connect().
     *
     * First, tries to connect to the server.
     * If successful, receives messages from the server and passes them to
     * processBatch().
     */
    void connectAndReceive();

    /**
     * Processes the received header and following batch.
     * If any messages are expected, receives the messages.
     */
    void processBatch();

    /**
     * Checks if we need to process the received adjustment, does so if
     * necessary.
     * @param receivedTickAdj The received tick adjustment.
     * @param receivedAdjIteration The adjustment iteration for the received
     *                             adjustment.
     */
    void adjustIfNeeded(Sint8 receivedTickAdj, Uint8 receivedAdjIteration);

    /**
     * Logs the network stats such as bytes sent/received per second.
     */
    void logNetworkStatistics();

    std::shared_ptr<Peer> server;

    /** Used to dispatch events from the network to the simulation. */
    EventDispatcher& networkEventDispatcher;

    /** Deserializes messages, does any network-layer message handling, and
        pushes messages into the eventDispatcher. */
    MessageProcessor messageProcessor;

    /** The adjustment that the server has told us to apply to the tick. */
    std::atomic<int> tickAdjustment;

    /** Tracks what iteration of tick offset adjustments we're on.
        Used to make sure that we don't double-count adjustments. */
    std::atomic<Uint8> adjustmentIteration;

    /** True when we're waiting for the sim to finish applying an adjustment. */
    std::atomic<bool> isApplyingTickAdjustment;

    /** Tracks if we've sent a message since the last network tick.
        Used to determine if we need to heartbeat. */
    unsigned int messagesSentSinceTick;

    /** Pointer to the game's current tick. */
    const std::atomic<Uint32>* currentTickPtr;

    /** Calls pollForMessages(). */
    std::jthread receiveThreadObj;
    /** Turn false to signal that the receive thread should end. */
    std::atomic<bool> exitRequested;

    /** Holds a received server header while we process it. */
    BinaryBuffer headerRecBuffer;
    /** Holds a received message batch while we pass its messages to
        MessageProcessor. */
    BinaryBuffer batchRecBuffer;
    /** If a batch is compressed, it's decompressed into this buffer before
        processing. */
    BinaryBuffer decompressedBatchRecBuffer;

    /** The number of seconds we'll wait before logging our network
        statistics. */
    static constexpr unsigned int SECONDS_TILL_STATS_DUMP{5};
    static constexpr unsigned int TICKS_TILL_STATS_DUMP{
        static_cast<unsigned int>(
            (1 / SharedConfig::CLIENT_NETWORK_TICK_TIMESTEP_S)
            * SECONDS_TILL_STATS_DUMP)};

    /** Whether network statistics logging is enabled or not. */
    bool netstatsLoggingEnabled;

    /** The number of ticks since we last logged our network statistics. */
    unsigned int ticksSinceNetstatsLog;
};

template<typename T>
void Network::serializeAndSend(const T& messageStruct)
{
    // Check that the message isn't too big.
    // Note: We don't compress messages on this side, so we know the final
    //       message size at this point.
    std::size_t totalMessageSize{CLIENT_HEADER_SIZE + MESSAGE_HEADER_SIZE
                                 + Serialize::measureSize(messageStruct)};
    if (totalMessageSize > CLIENT_MAX_MESSAGE_SIZE) {
        LOG_INFO("Tried to send a too-large message. Size: %u, max: %u",
                  totalMessageSize, CLIENT_MAX_MESSAGE_SIZE);
        return;
    }

    // Serialize the message struct into a buffer, leaving room for the
    // headers.
    BinaryBufferSharedPtr messageBuffer{
        std::make_shared<BinaryBuffer>(totalMessageSize)};
    std::size_t messageSize{Serialize::toBuffer(
        messageBuffer->data(), messageBuffer->size(), messageStruct,
        (CLIENT_HEADER_SIZE + MESSAGE_HEADER_SIZE))};

    // Copy the adjustment iteration into the client header.
    messageBuffer->at(ClientHeaderIndex::AdjustmentIteration)
        = adjustmentIteration;

    // Copy the message type into the message header.
    // TODO: Add a nice compile-time message if T doesn't define MESSAGE_TYPE.
    messageBuffer->at(CLIENT_HEADER_SIZE + MessageHeaderIndex::MessageType)
        = static_cast<Uint8>(T::MESSAGE_TYPE);

    // Copy the message size into the message header.
    ByteTools::write16(static_cast<Uint16>(messageSize),
                       (messageBuffer->data() + CLIENT_HEADER_SIZE
                        + MessageHeaderIndex::Size));

    // Send the message.
    send(messageBuffer);
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Network/Public/PlayerMovementUpdate.h`:

```h
#pragma once

#include "MovementState.h"
#include <SDL_stdinc.h>

namespace AM
{
namespace Client
{
/**
 * Holds updated movement state for the player entity.
 *
 * This isn't an actual message that gets sent by the server, instead it gets
 * split out when we receive a ComponentUpdate with the relevant data.
 */
struct PlayerMovementUpdate : public MovementState {
    /** The tick that this update corresponds to. */
    Uint32 tickNum{0};
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Renderer/CMakeLists.txt`:

```txt
target_sources(ClientLib
    PRIVATE
        Private/Renderer.cpp
        Private/WorldSpriteSorter.cpp
    PUBLIC
        Public/IRendererExtension.h
        Public/Renderer.h
        Public/RendererContext.h
        Public/SpriteSortInfo.h
        Public/WorldSpriteSorter.h
)

target_include_directories(ClientLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ClientLib/Renderer/Private/Renderer.cpp`:

```cpp
#include "Renderer.h"
#include "RendererContext.h"
#include "World.h"
#include "UserInterface.h"
#include "GraphicData.h"
#include "Config.h"
#include "Position.h"
#include "PreviousPosition.h"
#include "Sprite.h"
#include "Camera.h"
#include "IRendererExtension.h"
#include "Transforms.h"
#include "MovementHelpers.h"
#include "Log.h"
#include <SDL_render.h>
#include <SDL2_gfxPrimitives.h>

namespace AM
{
namespace Client
{
Renderer::Renderer(const RendererContext& inRendererContext)
: sdlRenderer{inRendererContext.sdlRenderer}
, world{inRendererContext.world}
, userInterface{inRendererContext.userInterface}
, graphicData{inRendererContext.graphicData}
, getSimTickProgress{inRendererContext.getSimTickProgress}
, worldSpriteSorter{world, graphicData, userInterface}
, extension{nullptr}
{
}

void Renderer::render()
{
    /* Set up the camera for this frame. */
    // Get how far we are between sim ticks in decimal percent.
    double alpha{getSimTickProgress()};

    // If we have a valid player entity, get the lerped camera.
    // Note: When we're disconnected from the server, the camera will be
    //       default (the UI will be covering it anyway).
    Camera lerpedCamera{};
    if (world.playerEntity != entt::null) {
        lerpedCamera = getLerpedCamera(alpha);
    }

    /* Render. */
    // Clear the screen to prepare for drawing.
    SDL_RenderClear(sdlRenderer);

    // Call the project's pre-world-rendering logic.
    extension->beforeWorld(lerpedCamera, alpha);

    // Draw tiles and entities.
    // Note: As part of this, the sorter's sorted sprites vector is updated.
    renderWorld(lerpedCamera, alpha);

    // Call the project's post-world-rendering logic.
    extension->afterWorld(lerpedCamera, alpha);

    // Draw UI elements.
    // Note: We pass the sorted sprites list so the UI can update its locator.
    userInterface.render(lerpedCamera, worldSpriteSorter.getSortedSprites());

    // Render the finished buffer to the screen.
    SDL_RenderPresent(sdlRenderer);
}

bool Renderer::handleOSEvent(SDL_Event& event)
{
    // Check if the project wants to handle the event.
    if (extension->handleOSEvent(event)) {
        return true;
    }

    // The project didn't handle the event. Handle it ourselves.
    switch (event.type) {
        case SDL_WINDOWEVENT:
            // TODO: Handle this.
            return true;
    }

    return false;
}

void Renderer::setExtension(IRendererExtension* inExtension)
{
    extension = inExtension;
}

Camera Renderer::getLerpedCamera(double alpha)
{
    // Get the lerped camera position based on the alpha.
    auto [playerCamera, playerPosition, playerPreviousPos]
        = world.registry.get<Camera, Position, PreviousPosition>(
            world.playerEntity);
    Position cameraLerp{MovementHelpers::interpolatePosition(
        playerCamera.prevTarget, playerCamera.target, alpha)};

    // Point the camera at the lerped position.
    Camera lerpedCamera{playerCamera};
    lerpedCamera.target = cameraLerp;

    // Get iso screen coords for the center point of camera.
    SDL_FPoint lerpedCameraCenter{Transforms::worldToScreen(
        lerpedCamera.target, lerpedCamera.zoomFactor)};

    // Calc where the top left of the lerpedCamera is in screen space.
    lerpedCamera.screenExtent.x
        = lerpedCameraCenter.x - (lerpedCamera.screenExtent.w / 2);
    lerpedCamera.screenExtent.y
        = lerpedCameraCenter.y - (lerpedCamera.screenExtent.h / 2);

    // Save the last calculated screen position of the camera for use in
    // screen -> world calcs.
    playerCamera.screenExtent.x = lerpedCamera.screenExtent.x;
    playerCamera.screenExtent.y = lerpedCamera.screenExtent.y;

    return lerpedCamera;
}

void Renderer::renderWorld(const Camera& camera, double alpha)
{
    // Prepare sprites (bounds updating, screen position calcs, depth sorting).
    worldSpriteSorter.sortSprites(camera, alpha);
    const std::vector<SpriteSortInfo>& sortedSprites{
        worldSpriteSorter.getSortedSprites()};

    // Draw depth-sorted tiles and sprites.
    // Note: These are already culled during the gather step.
    for (const SpriteSortInfo& spriteInfo : sortedSprites) {
        // Render the sprite.
        renderSprite(spriteInfo);

        // If this sprite belongs to an entity that has visual effects, render
        // them on top of it.
        if (const entt::entity* entity{
                std::get_if<entt::entity>(&spriteInfo.spriteOwnerID)}) {
            renderEntityVisualEffects(*entity);
        }

        // For debugging: Render the sprite's bounding box.
        //drawBoundingBox(spriteInfo.worldBounds, camera);
    }
}

void Renderer::renderSprite(const SpriteSortInfo& spriteInfo)
{
    const SpriteRenderData& renderData{
        graphicData.getSpriteRenderData(spriteInfo.sprite->numericID)};
    const SDL_Color& colorMod{spriteInfo.colorMod};

    // Apply the alpha mod that the UI gave us.
    SDL_SetTextureAlphaMod(renderData.texture.get(), colorMod.a);

    // Render the sprite with an appropriate blend mode.
    if (renderData.premultiplyAlpha) {
        static SDL_BlendMode premultipliedAlphaBlendMode{
            SDL_ComposeCustomBlendMode(
                SDL_BLENDFACTOR_ONE, SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,
                SDL_BLENDOPERATION_ADD, SDL_BLENDFACTOR_ONE,
                SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,
                SDL_BLENDOPERATION_ADD)};
        SDL_SetTextureBlendMode(renderData.texture.get(),
                                premultipliedAlphaBlendMode);
        SDL_RenderCopyF(sdlRenderer, renderData.texture.get(),
                        &(renderData.textureExtent), &(spriteInfo.screenExtent));
    }
    else {
        SDL_SetTextureBlendMode(renderData.texture.get(),
                                SDL_BLENDMODE_BLEND);
        SDL_RenderCopyF(sdlRenderer, renderData.texture.get(),
                        &(renderData.textureExtent), &(spriteInfo.screenExtent));
    }

    // If the UI gave us a color mod to apply, render an additional sprite
    // with an additive blend mode and apply the color to that.
    if (colorMod.r > 0 || colorMod.g > 0 || colorMod.b > 0) {
        SDL_SetTextureColorMod(renderData.texture.get(), colorMod.r,
                               colorMod.g, colorMod.b);
        SDL_SetTextureBlendMode(renderData.texture.get(),
                                SDL_BLENDMODE_ADD);

        SDL_RenderCopyF(sdlRenderer, renderData.texture.get(),
                        &(renderData.textureExtent),
                        &(spriteInfo.screenExtent));

        SDL_SetTextureBlendMode(renderData.texture.get(),
                                SDL_BLENDMODE_BLEND);
        SDL_SetTextureColorMod(renderData.texture.get(), 255, 255, 255);
    }

    // Reset the texture's alpha.
    SDL_SetTextureAlphaMod(renderData.texture.get(), 255);
}

void Renderer::renderEntityVisualEffects(entt::entity entity)
{
    const auto& visualEffects{
        worldSpriteSorter.getEntityVisualEffects(entity)};
    for (const auto& visualEffect : visualEffects) {
        const SpriteRenderData& renderData{
            graphicData.getSpriteRenderData(visualEffect.spriteID)};

        // Render the sprite with an appropriate blend mode.
        if (renderData.premultiplyAlpha) {
            static SDL_BlendMode premultipliedAlphaBlendMode{
                SDL_ComposeCustomBlendMode(
                    SDL_BLENDFACTOR_ONE,
                    SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,
                    SDL_BLENDOPERATION_ADD, SDL_BLENDFACTOR_ONE,
                    SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,
                    SDL_BLENDOPERATION_ADD)};
            SDL_SetTextureBlendMode(renderData.texture.get(),
                                    premultipliedAlphaBlendMode);
            SDL_RenderCopyF(sdlRenderer, renderData.texture.get(),
                            &(renderData.textureExtent),
                            &(visualEffect.screenExtent));
        }
        else {
            SDL_SetTextureBlendMode(renderData.texture.get(),
                                    SDL_BLENDMODE_BLEND);
            SDL_RenderCopyF(sdlRenderer, renderData.texture.get(),
                            &(renderData.textureExtent),
                            &(visualEffect.screenExtent));
        }
    }
}

void Renderer::drawBoundingBox(const BoundingBox& box, const Camera& camera)
{
    // If the bounding box is flat, don't render it (this avoids rendering the 
    // floor tile bounds, which typically aren't what you're trying to see). 
    if (box.isEmpty()) {
        return;
    }

    // Transform all the vertices to screen space.
    std::vector<SDL_FPoint> verts;
    Vector3 point{box.min.x, box.min.y, box.min.z};
    verts.push_back(Transforms::worldToScreen(point, camera.zoomFactor));
    point = {box.max.x, box.min.y, box.min.z};
    verts.push_back(Transforms::worldToScreen(point, camera.zoomFactor));
    point = {box.max.x, box.max.y, box.min.z};
    verts.push_back(Transforms::worldToScreen(point, camera.zoomFactor));
    point = {box.min.x, box.max.y, box.min.z};
    verts.push_back(Transforms::worldToScreen(point, camera.zoomFactor));

    point = {box.min.x, box.min.y, box.max.z};
    verts.push_back(Transforms::worldToScreen(point, camera.zoomFactor));
    point = {box.max.x, box.min.y, box.max.z};
    verts.push_back(Transforms::worldToScreen(point, camera.zoomFactor));
    point = {box.max.x, box.max.y, box.max.z};
    verts.push_back(Transforms::worldToScreen(point, camera.zoomFactor));
    point = {box.min.x, box.max.y, box.max.z};
    verts.push_back(Transforms::worldToScreen(point, camera.zoomFactor));

    // Adjust all verts for the camera.
    for (SDL_FPoint& vert : verts) {
        vert.x = std::round(vert.x - camera.screenExtent.x);
        vert.y = std::round(vert.y - camera.screenExtent.y);
    }

    // Fill Sint arrays with the verts.
    Sint16 xValues[8] = {};
    Sint16 yValues[8] = {};
    for (unsigned int i{0}; i < 8; ++i) {
        xValues[i] = static_cast<Sint16>(verts[i].x);
        yValues[i] = static_cast<Sint16>(verts[i].y);
    }

    // Draw the faces.
    filledPolygonRGBA(sdlRenderer, xValues, yValues, 4, 200, 0, 50, 150);
    filledPolygonRGBA(sdlRenderer, &(xValues[4]), &(yValues[4]), 4, 255, 0, 0,
                      150);

    SDL_SetRenderDrawColor(sdlRenderer, 0, 0, 0, 255);
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Renderer/Private/WorldSpriteSorter.cpp`:

```cpp
#include "WorldSpriteSorter.h"
#include "World.h"
#include "GraphicData.h"
#include "UserInterface.h"
#include "Camera.h"
#include "SharedConfig.h"
#include "MovementHelpers.h"
#include "Transforms.h"
#include "ClientTransforms.h"
#include "TileLayer.h"
#include "TileLayerID.h"
#include "TileExtent.h"
#include "SharedConfig.h"
#include "SpriteRenderData.h"
#include "Collision.h"
#include "GraphicState.h"
#include "ClientGraphicState.h"
#include "AVEntityState.h"
#include "AVEffects.h"
#include "Floor.h"
#include "VariantTools.h"
#include "Timer.h"
#include <SDL_rect.h>
#include <cmath>
#include <algorithm>

namespace AM
{
namespace Client
{
WorldSpriteSorter::WorldSpriteSorter(World& inWorld,
                                     const GraphicData& inGraphicData,
                                     const UserInterface& inUI)
: world{inWorld}
, graphicData{inGraphicData}
, ui{inUI}
, phantomSprites{}
, spriteColorMods{}
, sortedSprites{}
, spritesToSort{}
, lastAnimationTimestamp{}
, currentAnimationTimestamp{}
{
}

void WorldSpriteSorter::sortSprites(const Camera& camera, double alpha)
{
    // Get our new timestamp.
    lastAnimationTimestamp = currentAnimationTimestamp;
    currentAnimationTimestamp = Timer::getGlobalTime();

    // Clear the old data.
    sortedSprites.clear();
    entityVisualEffectIndices.clear();
    entityVisualEffects.clear();

    // Gather sprites relevant to this frame and calc their screen extents.
    gatherSpriteInfo(camera, alpha);

    // Sort the sprites by visual depth.
    sortSpritesByDepth();

    // Push the now-sorted sprites into the sorted vector.
    sortedSprites.insert(sortedSprites.end(),
                         std::make_move_iterator(spritesToSort.begin()),
                         std::make_move_iterator(spritesToSort.end()));
    spritesToSort.clear();
}

const std::vector<SpriteSortInfo>& WorldSpriteSorter::getSortedSprites()
{
    // Return the sorted vector of sprites.
    return sortedSprites;
}

std::span<const WorldSpriteSorter::VisualEffectRenderInfo>
    WorldSpriteSorter::getEntityVisualEffects(entt::entity entity)
{
    // If this entity has visual effects, return them.
    auto it{std::ranges::find_if(
        entityVisualEffectIndices,
        [&](const auto& effect) { return effect.entity == entity; })};
    if (it != entityVisualEffectIndices.end()) {
        return {(entityVisualEffects.begin() + it->startIndex), it->count};
    }
    else {
        // No visual effects, return an empty span.
        return {};
    }
}

void WorldSpriteSorter::gatherSpriteInfo(const Camera& camera, double alpha)
{
    // Save a temporary copy of the UI's current phantoms and color mods.
    phantomSprites = ui.getPhantomSprites();
    spriteColorMods = ui.getSpriteColorMods();

    // Gather all relevant tiles.
    gatherTileSpriteInfo(camera);

    // Gather all relevant entities.
    gatherEntitySpriteInfo(camera, alpha);

    // Clear our temporary vectors.
    phantomSprites.clear();
    spriteColorMods.clear();
}

void WorldSpriteSorter::gatherTileSpriteInfo(const Camera& camera)
{
    // Gather all tiles that are in view.
    TileExtent tileViewExtent{
        camera.getTileViewExtent(world.tileMap.getTileExtent())};
    for (int z{tileViewExtent.z}; z <= tileViewExtent.zMax(); ++z) {
        for (int y{tileViewExtent.y}; y <= tileViewExtent.yMax(); ++y) {
            for (int x{tileViewExtent.x}; x <= tileViewExtent.xMax(); ++x) {
                TilePosition tilePosition{x, y, z};

                // Push all of this tile's sprites into the appropriate vectors.
                // Note: tile will be nullptr if the chunk is empty.
                if (const Tile * tile{world.tileMap.cgetTile(tilePosition)}) {
                    pushTerrainSprites(*tile, camera, tilePosition);
                    pushFloorSprite(*tile, camera, tilePosition);
                    pushWallSprites(*tile, camera, tilePosition);
                    pushObjectSprites(*tile, camera, tilePosition);
                }
            }
        }
    }

    // Gather all of the UI's phantom tile sprites that weren't already used.
    for (const PhantomSpriteInfo& info : phantomSprites) {
        if (info.layerType != TileLayer::Type::None) {
            GraphicRef graphic{getPhantomGraphic(info)};

            // If it's a wall phantom, make it match the terrain height.
            TileOffset tileOffset{info.tileOffset};
            if (info.layerType == TileLayer::Type::Wall) {
                tileOffset.z = getTerrainHeight(info.tilePosition);
            }

            pushTileSprite(graphic, camera,
                           {info.tilePosition, tileOffset, info.layerType,
                            info.graphicSet->numericID, info.graphicValue},
                           true);
        }
    }
}

void WorldSpriteSorter::gatherEntitySpriteInfo(const Camera& camera,
                                               double alpha)
{
    // Gather all server-synchronized entities.
    gatherServerEntitySpriteInfo(camera, alpha);

    // Gather all A/V entities.
    gatherAVEntitySpriteInfo(camera, alpha);

    // Gather all of the UI's phantom entity sprites.
    for (const PhantomSpriteInfo& info : phantomSprites) {
        if (info.layerType == TileLayer::Type::None) {
            GraphicRef graphic{getPhantomGraphic(info)};
            pushEntitySprite<entt::entity>(
                entt::null, info.position, graphic.getFirstSprite(), camera,
                static_cast<EntityGraphicSetID>(info.graphicSet->numericID),
                static_cast<EntityGraphicType>(info.graphicValue),
                info.graphicDirection);
        }
    }
}

void WorldSpriteSorter::gatherServerEntitySpriteInfo(const Camera& camera,
                                                     double alpha)
{
    entt::registry& registry{world.registry};

    // Gather all graphical entities.
    auto view
        = registry.view<Position, GraphicState, ClientGraphicState>();
    for (entt::entity entity : view) {
        auto [position, graphicState, clientGraphicState]
            = view.get<Position, GraphicState, ClientGraphicState>(
                entity);

        // If this entity has a PreviousPosition, calc a lerp'd position.
        Position renderPosition{position};
        if (registry.all_of<PreviousPosition>(entity)) {
            const auto& previousPos{registry.get<PreviousPosition>(entity)};
            renderPosition = MovementHelpers::interpolatePosition(
                previousPos, position, alpha);
        }

        // Push the entity's sprite to be sorted.
        const Sprite* sprite{getEntitySprite(graphicState, clientGraphicState)};
        if (!sprite) {
            continue;
        }
        pushEntitySprite(entity, renderPosition, *sprite, camera,
                         graphicState.graphicSetID,
                         clientGraphicState.graphicType,
                         clientGraphicState.graphicDirection);

        // Push the entity's visual effects, if it has any.
        pushEntityVisualEffects(entity, renderPosition, camera);
    }
}

void WorldSpriteSorter::gatherAVEntitySpriteInfo(const Camera& camera,
                                                 double alpha)
{
    entt::basic_registry<AVEntityID>& avRegistry{world.avRegistry};

    // Gather all A/V entities.
    auto view = avRegistry.view<Position, GraphicState, ClientGraphicState,
                                AVEntityState>();
    for (AVEntityID entity : view) {
        auto [position, graphicState, clientGraphicState, avEntityState]
            = view.get<Position, GraphicState, ClientGraphicState,
                       AVEntityState>(entity);

        // If this entity has a PreviousPosition, calc a lerp'd position.
        Position renderPosition{position};
        if (avRegistry.all_of<PreviousPosition>(entity)) {
            const auto& previousPos{avRegistry.get<PreviousPosition>(entity)};
            renderPosition = MovementHelpers::interpolatePosition(
                previousPos, position, alpha);
        }

        // Push the entity's sprite to be sorted.
        const Sprite* sprite{getEntitySprite(graphicState, clientGraphicState)};
        if (!sprite) {
            continue;
        }
        pushEntitySprite(entity, renderPosition, *sprite, camera,
                         graphicState.graphicSetID,
                         clientGraphicState.graphicType,
                         clientGraphicState.graphicDirection);

        // If this A/V entity just began, set its start time.
        if (avEntityState.setStartTime) {
            avEntityState.phaseStartTime = currentAnimationTimestamp;
            avEntityState.setStartTime = false;
        }

        // Note: A/V entities don't have visual effects.
    }
}

void WorldSpriteSorter::pushTerrainSprites(
    const Tile& tile, const Camera& camera, const TilePosition& tilePosition)
{
    // Note: Each tile can only have 1 terrain, but we get a span just to 
    //       follow the pattern of the other types.
    std::span<const TileLayer> terrains{
        tile.getLayers(TileLayer::Type::Terrain)};
    for (const TileLayer& terrain : terrains) {
        GraphicRef graphic{terrain.getGraphic()};
        if (graphic.getGraphicID() != NULL_GRAPHIC_ID) {
            Uint8 graphicValue{terrain.graphicValue};

            // If the UI wants this sprite replaced with a phantom, replace it.
            auto phantomSpriteInfo = std::find_if(
                phantomSprites.begin(), phantomSprites.end(),
                [&](const PhantomSpriteInfo& info) {
                    return ((info.layerType == TileLayer::Type::Terrain)
                            && (info.tilePosition == tilePosition));
                });
            if (phantomSpriteInfo != phantomSprites.end()) {
                graphic = getPhantomGraphic(*phantomSpriteInfo);
                graphicValue = phantomSpriteInfo->graphicValue;
                phantomSprites.erase(phantomSpriteInfo);
            }

            pushTileSprite(graphic, camera,
                           {tilePosition, TileOffset{},
                            TileLayer::Type::Terrain,
                            terrain.graphicSet.get().numericID, graphicValue},
                           false);
        }
    }
}

void WorldSpriteSorter::pushFloorSprite(const Tile& tile, const Camera& camera,
                                        const TilePosition& tilePosition)
{
    std::span<const TileLayer> floors{
        tile.getLayers(TileLayer::Type::Floor)};
    for (const TileLayer& floor : floors) {
        GraphicRef graphic{floor.getGraphic()};
        if (graphic.getGraphicID() != NULL_GRAPHIC_ID) {
            pushTileSprite(
                graphic, camera,
                {tilePosition, floor.tileOffset, TileLayer::Type::Floor,
                 floor.graphicSet.get().numericID, floor.graphicValue},
                false);
        }
    }
}

void WorldSpriteSorter::pushWallSprites(const Tile& tile, const Camera& camera,
                                        const TilePosition& tilePosition)
{
    // Make this wall match the tile's terrain height.
    // Note: Walls don't normally use offsets, but it's convenient to do it 
    //       this way.
    TileOffset tileOffset{0, 0, getTerrainHeight(tilePosition)};

    std::span<const TileLayer> walls{tile.getLayers(TileLayer::Type::Wall)};
    for (const TileLayer& wall : walls) {
        GraphicRef graphic{wall.getGraphic()};
        if (graphic.getGraphicID() != NULL_GRAPHIC_ID) {
            // If the UI wants this sprite replaced with a phantom, replace it.
            auto phantomSpriteInfo = std::find_if(
                phantomSprites.begin(), phantomSprites.end(),
                [&](const PhantomSpriteInfo& info) {
                    if ((info.layerType == TileLayer::Type::Wall)
                        && (info.tilePosition == tilePosition)) {
                        // Check if we need to replace a N with a NE fill.
                        if ((wall.graphicValue == Wall::Type::North)
                            && (info.wallType
                                == Wall::Type::NorthEastGapFill)) {
                            return true;
                        }
                        // Check if we need to replace a NW fill with a W or N.
                        else if ((wall.graphicValue
                                  == Wall::Type::NorthWestGapFill)
                                 && ((info.wallType == Wall::Type::West)
                                     || (info.wallType == Wall::Type::North))) {
                            return true;
                        }
                        else if (info.wallType == wall.graphicValue) {
                            // Otherwise, check if the type matches.
                            return true;
                        }
                    }
                    return false;
                });
            if (phantomSpriteInfo != phantomSprites.end()) {
                graphic = getPhantomGraphic(*phantomSpriteInfo);
                phantomSprites.erase(phantomSpriteInfo);
            }

            pushTileSprite(graphic, camera,
                           {tilePosition, tileOffset, TileLayer::Type::Wall,
                            wall.graphicSet.get().numericID, wall.graphicValue},
                           false);
        }
    }
}

void WorldSpriteSorter::pushObjectSprites(const Tile& tile,
                                          const Camera& camera,
                                          const TilePosition& tilePosition)
{
    std::span<const TileLayer> objects{tile.getLayers(TileLayer::Type::Object)};
    for (const TileLayer& object : objects) {
        GraphicRef graphic{object.getGraphic()};
        if (graphic.getGraphicID() != NULL_GRAPHIC_ID) {
            pushTileSprite(
                graphic, camera,
                {tilePosition, object.tileOffset, TileLayer::Type::Object,
                 object.graphicSet.get().numericID, object.graphicValue},
                false);
        }
    }
}

void WorldSpriteSorter::pushTileSprite(const GraphicRef& graphic,
                                       const Camera& camera,
                                       const TileLayerID& layerID,
                                       bool isFullPhantom)
{
    // Get the current sprite for this graphic.
    // Note: We sync tile animations to the global timer so they all line up.
    const Sprite* sprite{graphic.getSpriteAtTime(Timer::getGlobalTime())};
    if (!sprite) {
        return;
    }

    // Get the iso screen extent for this sprite.
    const SpriteRenderData& renderData{
        graphicData.getSpriteRenderData(sprite->numericID)};
    SDL_FRect screenExtent{ClientTransforms::tileToScreenExtent(
        layerID.tilePosition, layerID.tileOffset, renderData, camera)};

    // If this is a Terrain layer, offset it based on its starting height.
    // Note: We only need to do this visually, Terrain::calcWorldBounds adds 
    //       start height to the bounds appropriately below.
    if (layerID.type == TileLayer::Type::Terrain) {
        Terrain::Height startHeight{
            Terrain::getStartHeight(layerID.graphicValue)};
        screenExtent.y -= Transforms::worldZToScreenY(
            Terrain::getHeightWorldValue(startHeight), camera.zoomFactor);
    }

    // If this sprite isn't on screen, skip it.
    if (!isWithinScreenBounds(screenExtent, camera)) {
        return;
    }

    // If the UI wants a color mod on this sprite, use it.
    SDL_Color colorMod{getColorMod<TileLayerID>(layerID)};

    // If this sprite comes from an existing tile layer or is a phantom that
    // replaces an existing sprite, set the layer's ID. Otherwise, leave it
    // as std::monostate to show that this is a full phantom.
    WorldObjectID worldObjectID{};
    if (!isFullPhantom) {
        worldObjectID = layerID;
    }

    // Calc the sprite's world bounds.
    BoundingBox worldBounds{};
    if (layerID.type == TileLayer::Type::Terrain) {
        // For terrain, we ignore the sprite's modelBounds and instead 
        // generate a bounding volume based on the terrain type.
        worldBounds = Terrain::calcWorldBounds(layerID.tilePosition,
                                               layerID.graphicValue);
    }
    else if (layerID.type == TileLayer::Type::Floor) {
        // For floors, we ignore the sprite's modelBounds and instead 
        // generate a flat, tile-sized bounding volume.
        worldBounds = Floor::calcWorldBounds(layerID.tilePosition);
    }
    else {
        worldBounds = Transforms::modelToWorldTile(graphic.getModelBounds(),
                                                   layerID.tilePosition);
    }
    worldBounds.min.x += layerID.tileOffset.x;
    worldBounds.min.y += layerID.tileOffset.y;
    worldBounds.min.z += layerID.tileOffset.z;
    worldBounds.max.x += layerID.tileOffset.x;
    worldBounds.max.y += layerID.tileOffset.y;
    worldBounds.max.z += layerID.tileOffset.z;

    // Push the sprite to be sorted.
    spritesToSort.emplace_back(sprite, worldObjectID, worldBounds,
                               screenExtent, colorMod);
}

const Sprite*
    WorldSpriteSorter::getEntitySprite(const GraphicState& graphicState,
                                       ClientGraphicState& clientGraphicState)
{
    // Get the current sprite for this graphic.
    const EntityGraphicSet& graphicSet{
        graphicData.getEntityGraphicSet(graphicState.graphicSetID)};
    AM_ASSERT(graphicSet.graphics.contains(clientGraphicState.graphicType),
              "Tried to get entity sprite that doesn't exist in set. Set: %s, "
              "Graphic type: %u",
              graphicSet.displayName.c_str(), clientGraphicState.graphicType);
    const auto& graphicArr{
        graphicSet.graphics.at(clientGraphicState.graphicType)};
    const GraphicRef graphic{
        graphicArr.at(clientGraphicState.graphicDirection)};

    // If this animation just began, set its start time.
    if (clientGraphicState.setStartTime) {
        clientGraphicState.animationStartTime = currentAnimationTimestamp;
        clientGraphicState.setStartTime = false;
    }

    // Calc how far we are into this animation and get the appropriate
    // sprite (or just get the sprite, if this isn't an animation).
    double animationTime{currentAnimationTimestamp
                         - clientGraphicState.animationStartTime};
    const Sprite* sprite{graphic.getSpriteAtTime(animationTime)};

    return sprite;
}

template<typename T>
void WorldSpriteSorter::pushEntitySprite(T entity, const Position& position,
                                         const Sprite& sprite,
                                         const Camera& camera,
                                         EntityGraphicSetID graphicSetID,
                                         EntityGraphicType graphicType,
                                         Rotation::Direction graphicDirection)
{
    // Get the iso screen extent for the sprite.
    const SpriteRenderData& renderData{
        graphicData.getSpriteRenderData(sprite.numericID)};
    const EntityGraphicSet& graphicSet{
        graphicData.getEntityGraphicSet(graphicSetID)};

    SDL_FRect screenExtent{ClientTransforms::entityToScreenExtent(
        position, graphicSet.getCollisionModelBounds().getBottomCenterPoint(),
        graphicData.getRenderAlignmentOffset(graphicSetID, graphicType,
                                             graphicDirection),
        renderData, camera)};

    // If the sprite is on screen, push the render info.
    if (isWithinScreenBounds(screenExtent, camera)) {
        // Get a box for this entity, to use for sorting.
        // Note: We sort using the standard collision model bounds (from 
        //       IdleSouth). We could instead use the current sprite, but
        //       that would open us up to potentially sorting boxes that are
        //       clipping inside of eachother.
        BoundingBox worldBounds{Transforms::modelToWorldEntity(
            graphicSet.getCollisionModelBounds(), position)};

        // If the UI wants a color mod on this sprite, use it.
        SDL_Color colorMod{getColorMod<T>(entity)};

        // If this sprite doesn't come from a phantom, set the owner ID.
        WorldObjectID ownerID{std::monostate{}};
        if (entity != entt::null) {
            ownerID = entity;
        }

        // Push the entity's render info for this frame.
        spritesToSort.emplace_back(&sprite, ownerID, worldBounds, screenExtent,
                                   colorMod);
    }
}

void WorldSpriteSorter::pushEntityVisualEffects(entt::entity entity,
                                                const Position& position,
                                                const Camera& camera)
{
    // If this entity has any visual effects, calculate their screen extent 
    // and pass them to the callback.
    if (AVEffects*
          avEffects{world.registry.try_get<AVEffects>(entity)}) {
        // Push an index entry for this entity.
        entityVisualEffectIndices.emplace_back(entity,
                                               entityVisualEffects.size(),
                                               avEffects->visualEffects.size());

        // Calculate screen extents and push each effect.
        for (VisualEffectState& effectState : avEffects->visualEffects) {
            // If this effect just began, set its start time.
            if (effectState.startTime == 0) {
                effectState.startTime = currentAnimationTimestamp;
            }

            // Calc how far we are into this animation and get the appropriate
            // sprite (or just get the sprite, if this isn't an animation).
            GraphicRef graphic{graphicData.getGraphic(
                effectState.visualEffect.get().graphicID)};
            double animationTime{currentAnimationTimestamp
                                 - effectState.startTime};
            const Sprite* sprite{graphic.getSpriteAtTime(animationTime)};
            if (!sprite) {
                continue;
            }

            // Place the effect on top of the entity and get its screen extent.
            const SpriteRenderData& renderData{
                graphicData.getSpriteRenderData(sprite->numericID)};
            SDL_FRect screenExtent{ClientTransforms::entityToScreenExtent(
                position, graphic.getModelBounds().getBottomCenterPoint(),
                Vector3{}, renderData, camera)};

            entityVisualEffects.emplace_back(sprite->numericID, screenExtent);
        }
    }
}

void WorldSpriteSorter::sortSpritesByDepth()
{
    // Calculate dependencies (who is behind who).
    calcDepthDependencies();

    // Calculate depth values.
    int depthValue{0};
    for (SpriteSortInfo& spriteInfo : spritesToSort) {
        visitSprite(spriteInfo, depthValue);
    }

    // Sort sprites by depth.
    std::sort(spritesToSort.begin(), spritesToSort.end(),
              [](const SpriteSortInfo& lhs, const SpriteSortInfo& rhs) -> bool {
                  return lhs.depthValue < rhs.depthValue;
              });
}

void WorldSpriteSorter::calcDepthDependencies()
{
    // Calculate all dependencies.
    for (std::size_t i{0}; i < spritesToSort.size(); ++i) {
        for (std::size_t j{0}; j < spritesToSort.size(); ++j) {
            if (i != j) {
                SpriteSortInfo& spriteA{spritesToSort[i]};
                SpriteSortInfo& spriteB{spritesToSort[j]};

                // If an A/V entity is intersecting something, consider the 
                // A/V entity to be in front.
                if (std::holds_alternative<AVEntityID>(spriteB.spriteOwnerID)
                    && spriteB.worldBounds.intersects(spriteA.worldBounds)) {
                    continue;
                }

                if ((spriteB.worldBounds.min.x < spriteA.worldBounds.max.x)
                    && (spriteB.worldBounds.min.y < spriteA.worldBounds.max.y)
                    && (spriteB.worldBounds.min.z
                        < spriteA.worldBounds.max.z)) {
                    // B is behind A, push it into A.spritesBehind.
                    spriteA.spritesBehind.push_back(&spriteB);
                }
            }
        }
    }
}

void WorldSpriteSorter::visitSprite(SpriteSortInfo& spriteInfo, int& depthValue)
{
    if (!(spriteInfo.visited)) {
        spriteInfo.visited = true;

        for (std::size_t i{0}; i < spriteInfo.spritesBehind.size(); ++i) {
            if (spriteInfo.spritesBehind[i] == nullptr) {
                break;
            }
            else {
                visitSprite(*(spriteInfo.spritesBehind[i]), depthValue);
                spriteInfo.spritesBehind[i] = nullptr;
            }
        }

        spriteInfo.depthValue = depthValue;
        depthValue++;
    }
}

// TEMP: Remove these when we upgrade SDL
SDL_bool SDL_RectEmptyFloat(const SDL_FRect* r)
{
    return ((!r) || (r->w <= 0.0f) || (r->h <= 0.0f)) ? SDL_TRUE : SDL_FALSE;
}

SDL_bool SDL_HasRectIntersectionFloat(const SDL_FRect* A, const SDL_FRect* B)
{
    float Amin, Amax, Bmin, Bmax;

    if (!A) {
        SDL_InvalidParamError("A");
        return SDL_FALSE;
    }
    else if (!B) {
        SDL_InvalidParamError("B");
        return SDL_FALSE;
    }
    else if (SDL_RectEmptyFloat(A) || SDL_RectEmptyFloat(B)) {
        return SDL_FALSE; /* Special cases for empty rects */
    }

    /* Horizontal intersection */
    Amin = A->x;
    Amax = Amin + A->w;
    Bmin = B->x;
    Bmax = Bmin + B->w;
    if (Bmin > Amin) {
        Amin = Bmin;
    }
    if (Bmax < Amax) {
        Amax = Bmax;
    }
    if (Amax <= Amin) {
        return SDL_FALSE;
    }
    /* Vertical intersection */
    Amin = A->y;
    Amax = Amin + A->h;
    Bmin = B->y;
    Bmax = Bmin + B->h;
    if (Bmin > Amin) {
        Amin = Bmin;
    }
    if (Bmax < Amax) {
        Amax = Bmax;
    }
    if (Amax <= Amin) {
        return SDL_FALSE;
    }
    return SDL_TRUE;
}
// END TEMP: Remove these when we upgrade SDL

bool WorldSpriteSorter::isWithinScreenBounds(const SDL_FRect& extent,
                                             const Camera& camera)
{
    // The extent is in final screen coordinates, so we only need to check if
    // it's within the rect formed by (0, 0) and (camera.width, camera.height).
    SDL_FRect cameraExtent{0, 0, camera.screenExtent.w, camera.screenExtent.h};
    return (SDL_HasRectIntersectionFloat(&extent, &cameraExtent) == SDL_TRUE);
}

GraphicRef WorldSpriteSorter::getPhantomGraphic(
    const PhantomSpriteInfo& phantomSpriteInfo)
{
    // If the set is null for whatever reason, return the null sprite.
    if (!(phantomSpriteInfo.graphicSet)) {
        return GraphicRef{graphicData.getSprite(NULL_SPRITE_ID)};
    }

    // If layerType != None, this is a tile phantom.
    if (phantomSpriteInfo.layerType != TileLayer::Type::None) {
        return TileLayer::getGraphic(phantomSpriteInfo.layerType,
                                     *(phantomSpriteInfo.graphicSet),
                                     phantomSpriteInfo.graphicValue);
    }
    else {
        // Entity phantom.
        EntityGraphicType type{
            static_cast<EntityGraphicType>(phantomSpriteInfo.graphicValue)};
        const EntityGraphicSet& graphicSet{static_cast<const EntityGraphicSet&>(
            *(phantomSpriteInfo.graphicSet))};
        auto graphicIt{graphicSet.graphics.find(type)};
        if (graphicIt != graphicSet.graphics.end()) {
            return graphicIt->second.at(phantomSpriteInfo.graphicDirection);
        }
    }

    return GraphicRef{graphicData.getSprite(NULL_SPRITE_ID)};
}

template<typename T>
SDL_Color WorldSpriteSorter::getColorMod(const T& objectID)
{
    auto objectIDsMatch = [&](const SpriteColorModInfo& info) {
        // If this color mod is for the same type of object.
        if (const T* colorModLayerID = std::get_if<T>(&(info.objectToModify))) {
            // If the IDs match, return true.
            if (*colorModLayerID == objectID) {
                return true;
            }
        }

        return false;
    };

    // If the UI wants a color mod on this sprite, use it.
    auto colorModInfo = std::find_if(spriteColorMods.begin(),
                                     spriteColorMods.end(), objectIDsMatch);
    if (colorModInfo != spriteColorMods.end()) {
        // Remove this color mod from our temp vector, since it's been used.
        SDL_Color colorMod{colorModInfo->colorMod};
        spriteColorMods.erase(colorModInfo);
        return colorMod;
    }
    else {
        return {0, 0, 0, 255};
    }
}

Uint8 WorldSpriteSorter::getTerrainHeight(const TilePosition& tilePosition)
{
    if (const Tile* tile{world.tileMap.cgetTile(tilePosition)}) {
        if (auto* terrain{tile->findLayer(TileLayer::Type::Terrain)}) {
            Terrain::Height height{
                Terrain::getTotalHeight(terrain->graphicValue)};
            return static_cast<Uint8>(Terrain::getHeightWorldValue(height));
        }
    }

    return 0;
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Renderer/Public/IRendererExtension.h`:

```h
#pragma once

#include "OSEventHandler.h"

namespace AM
{
struct Camera;

namespace Client
{

/**
 * Defines an extension for the engine's Client::Renderer class.
 *
 * Extensions are implemented by the project, and are given generic functions
 * ("hooks") in which they can implement relevant project logic.
 *
 * The project can register the extension class with the engine through
 * Application::registerRendererExtension().
 */
class IRendererExtension : public OSEventHandler
{
public:
    // Canonical constructor (derived class must implement):
    // RendererExtension(const RendererContext& rendererContext)

    /**
     * Called before tiles and entities are rendered.
     *
     * @param lerpedCamera  The camera to calculate screen position with.
     * @param alpha  How far we are between sim ticks, as a percentage from
     *               0.0 to 1.0. Used to interpolate between positions.
     */
    virtual void beforeWorld(const Camera& lerpedCamera, double alpha) = 0;

    /**
     * Called after tiles and entities are rendered.
     *
     * @param lerpedCamera  The camera to calculate screen position with.
     * @param alpha  How far we are between sim ticks, as a percentage from
     *               0.0 to 1.0. Used to interpolate between positions.
     */
    virtual void afterWorld(const Camera& lerpedCamera, double alpha) = 0;

    /**
     * See OSEventHandler for details.
     *
     * Note: Renderer will pass events to this class first. If the event is
     *       not handled, then Renderer will attempt to handle it.
     */
    bool handleOSEvent(SDL_Event& event) override = 0;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Renderer/Public/Renderer.h`:

```h
#pragma once

#include "OSEventHandler.h"
#include "PeriodicCaller.h"
#include "WorldSpriteSorter.h"

struct SDL_Renderer;

namespace AM
{
struct Sprite;
struct BoundingBox;
struct Camera;
namespace Client
{
struct RendererContext;
class World;
class UserInterface;
class GraphicData;
class IRendererExtension;

/**
 * Pulls information from the Simulation and other sources to isometrically
 * render the player's view of the world.
 *
 * Also kicks off the UI rendering.
 */
class Renderer : public OSEventHandler
{
public:
    Renderer(const RendererContext& inRendererContext);

    /**
     * Renders the player's view of the world, then kicks off the UI rendering.
     */
    void render();

    /**
     * Handles window events.
     */
    bool handleOSEvent(SDL_Event& event) override;

    /**
     * See extension member comment.
     */
    void setExtension(IRendererExtension* inExtension);

private:
    /**
     * Gets the player entity's current camera, lerped to match the given alpha.
     */
    Camera getLerpedCamera(double alpha);

    /**
     * Renders the vector of sprites returned by
     * worldSpritePreparer.prepareSprites().
     *
     * @param camera  The camera to calculate screen position with.
     * @param alpha  How far we are between sim ticks, as a percentage from
     *               0.0 to 1.0. Used to interpolate between positions.
     */
    void renderWorld(const Camera& camera, double alpha);

    /**
     * Renders a sprite using the given info.
     */
    void renderSprite(const SpriteSortInfo& spriteInfo);

    /**
     * Renders the given entity's visual effects, if it has any.
     */
    void renderEntityVisualEffects(entt::entity entity);

    /**
     * Draws the given box. Useful for debug visuals.
     * Note: Don't use this for anything real, it's super slow.
     */
    void drawBoundingBox(const BoundingBox& box, const Camera& camera);

    SDL_Renderer* sdlRenderer;

    /** Used to grab the entity data that we need to render. */
    World& world;

    /** Used to begin the UI rendering. */
    UserInterface& userInterface;

    /** Used for getting graphics render data. */
    GraphicData& graphicData;

    std::function<double(void)> getSimTickProgress;

    WorldSpriteSorter worldSpriteSorter;

    /** Contains the project's rendering extension functions.
        Allows the project to provide rendering code and have it be called at 
        the appropriate time. */
    IRendererExtension* extension;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Renderer/Public/RendererContext.h`:

```h
#pragma once

#include <functional>

struct SDL_Renderer;

namespace AM
{
class World;
class UserInterface;
class GraphicData;

namespace Client
{

/**
 * Provides the dependencies that Renderer objects may use.
 */
struct RendererContext {
public:
    SDL_Renderer* sdlRenderer;

    World& world;

    UserInterface& userInterface;

    /** Returns how far the sim tick is towards its next call, as a 
        percentage from 0 - 1. */
    std::function<double(void)> getSimTickProgress;

    GraphicData& graphicData;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Renderer/Public/SpriteSortInfo.h`:

```h
#pragma once

#include "Sprite.h"
#include "WorldObjectID.h"
#include <SDL_rect.h>
#include <vector>
#include <variant>

namespace AM
{
namespace Client
{
/**
 * Used for storing information relevant to sorting a sprite.
 */
struct SpriteSortInfo {
    //-------------------------------------------------------------------------
    // Sprite data
    //-------------------------------------------------------------------------
    /** The sprite that is associated with this render information. */
    const Sprite* sprite;

    /** The tile layer or entity that the sprite comes from, or std::monostate
        if this is a full phantom (not replacing an existing layer).
        Used when we pass the sorted sprites to the UI's locator. */
    WorldObjectID spriteOwnerID;

    /** The world-space bounding box that has been calculated for this sprite
        in the current frame, based on the associated entity's lerped
        position.
        Used during topological sorting. */
    BoundingBox worldBounds{};

    /** The screen extent that has been calculated for this sprite in the
        current frame, based on the associated entity's lerped position.
        Used during rendering and passed to the UI's locator. */
    SDL_FRect screenExtent{};

    /** If non-default, the UI wants us to multiply this sprite's color and
        transparency by these values. */
    SDL_Color colorMod{0, 0, 0, 255};

    //-------------------------------------------------------------------------
    // Topological sort data
    //-------------------------------------------------------------------------
    /** The depth value of the sprite in the current frame.
        Higher value means further in front. */
    int depthValue{0};

    /** The sprites that are behind this sprite in the current frame.
        Necessary for our topological sort. */
    std::vector<SpriteSortInfo*> spritesBehind{};

    /** True if this sprite has been visited on the current topological
        sort pass. */
    bool visited{false};
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Renderer/Public/WorldSpriteSorter.h`:

```h
#pragma once

#include "SpriteSortInfo.h"
#include "PhantomSpriteInfo.h"
#include "SpriteColorModInfo.h"
#include "EntityGraphicType.h"
#include "GraphicID.h"
#include <vector>

struct SDL_FRect;

namespace AM
{
struct Camera;
class Tile;
struct TileLayerID;
struct GraphicState;
struct Rotation;

namespace Client
{
class World;
class GraphicData;
class UserInterface;
struct ClientGraphicState;

/**
 * Gathers all of the World's entity and tile layer sprites and sorts them
 * into their proper draw order.
 */
class WorldSpriteSorter
{
public:
    WorldSpriteSorter(World& inWorld, const GraphicData& inGraphicData,
                      const UserInterface& inUI);

    /**
     * Clears the stored sprite info, gathers the updated batch of sprites,
     * and sorts them into their proper draw order.
     */
    void sortSprites(const Camera& camera, double alpha);

    /**
     * @return A reference to the vector of sprites that was built during the
     *         last sortSprites() call.
     *
     * Note: Some of the returned vector's elements may be pure phantoms.
     *       Phantoms will have an empty spriteOwnerID field.
     */
    const std::vector<SpriteSortInfo>& getSortedSprites();

    struct VisualEffectRenderInfo {
        SpriteID spriteID{};
        SDL_FRect screenExtent{};
    };
    /**
     * @retrun A span containing all visual effects for the given entity.
     */
    std::span<const VisualEffectRenderInfo>
        getEntityVisualEffects(entt::entity entity);

private:
    /**
     * Gathers the sprites that should be drawn on this frame, calculates their
     * screen position and bounding box for this frame, and pushes their data
     * into the sprites vector.
     *
     * @param camera  The camera to calculate screen position with.
     * @param alpha  For entities, the alpha to lerp between positions with.
     *
     * @post sortedSprites is filled with the floor sprites, and spritesToSort
     *       is filled with the sprites that need to be sorted.
     */
    void gatherSpriteInfo(const Camera& camera, double alpha);

    /**
     * Performs the tile portion of the gather step.
     */
    void gatherTileSpriteInfo(const Camera& camera);

    /**
     * Performs the entity portion of the gather step.
     */
    void gatherEntitySpriteInfo(const Camera& camera, double alpha);

    /**
     * Gathers the server-synchronized entity data.
     */
    void gatherServerEntitySpriteInfo(const Camera& camera, double alpha);

    /**
     * Gathers the A/V entity data.
     */
    void gatherAVEntitySpriteInfo(const Camera& camera, double alpha);

    // All of these just call pushTileSprite(), but Floor and Wall also check
    // if the UI wants to swap any of their sprites with a phantom.
    void pushTerrainSprites(const Tile& tile, const Camera& camera,
                            const TilePosition& tilePosition);
    void pushFloorSprite(const Tile& tile, const Camera& camera,
                         const TilePosition& tilePosition);
    void pushWallSprites(const Tile& tile, const Camera& camera,
                         const TilePosition& tilePosition);
    void pushObjectSprites(const Tile& tile, const Camera& camera,
                           const TilePosition& tilePosition);

    /**
     * Pushes the given tile graphic into the appropriate vector, based on
     * whether it needs to be sorted or not.
     */
    void pushTileSprite(const GraphicRef& graphic, const Camera& camera,
                        const TileLayerID& layerID, bool isFullPhantom);

    /**
     * Pushes the given entity sprite into the sorting vector.
     * @param T An entt::entity or AVEntityID.
     * @return true if a sprite was pushed, else false (sprite was outside of 
     *         the screen bounds).
     */
    template<typename T>
    void pushEntitySprite(T entity, const Position& position,
                          const Sprite& sprite, const Camera& camera,
                          EntityGraphicSetID graphicSetID,
                          EntityGraphicType graphicType,
                          Rotation::Direction graphicDirection);

    /**
     * Returns the current sprite for the given entity data, or nullptr if 
     * the entity doesn't have a sprite to display.
     * Updates clientGraphicState's data if necessary.
     */
    const Sprite* getEntitySprite(const GraphicState& graphicState,
                                  ClientGraphicState& clientGraphicState);

    /**
     * If the given entity has any visual effects, pushes them into 
     * entityVisualEffects.
     */
    void pushEntityVisualEffects(entt::entity entity, const Position& position,
                                 const Camera& camera);

    /**
     * Sorts the sprites into their draw order (farthest sprite first).
     */
    void sortSpritesByDepth();

    /**
     * Determines which sprites are behind eachother, from the viewer's
     * perspective. Necessary for depth sorting.
     *
     * @post Each element.spritesBehind in sprites is filled with the sprites
     *       that are behind that element's sprite.
     */
    void calcDepthDependencies();

    /**
     * Recursive function for finding sprite depth. Used by sortSpritesByDepth.
     *
     * @param spriteInfo  The sprite that we're visiting.
     * @param depthValue  The next depth value to assign.
     */
    void visitSprite(SpriteSortInfo& spriteInfo, int& depthValue);

    /**
     * Returns true if any part of the given extent is within the given
     * camera's bounds, else false.
     *
     * @param extent  An extent in final screen coordinates.
     * @param camera  The camera to use for screen width/height checks.
     */
    bool isWithinScreenBounds(const SDL_FRect& extent, const Camera& camera);

    /**
     * Returns an appropriate graphic for the given phantom info.
     */
    GraphicRef getPhantomGraphic(const PhantomSpriteInfo& phantomSpriteInfo);

    /**
     * Returns a color mod from spriteColorMods for the given world object ID
     * if one exists, else returns {255, 255, 255, 255}.
     * If a color mod is returned, it will be removed from spriteColorMods.
     */
    template<typename T>
    SDL_Color getColorMod(const T& objectID);

    /**
     * Returns the height of the terrain at the given position, in world units.
     */
    Uint8 getTerrainHeight(const TilePosition& tilePosition);

    /** Used for gathering graphics. */
    World& world;

    /** Used for getting graphic render data. */
    const GraphicData& graphicData;

    /** Used for getting sprite color mods and phantom sprites. */
    const UserInterface& ui;

    /** Stores a temporary copy of the UI's desired phantom sprites.
        We make a copy so that we can remove them as they get used. */
    std::vector<PhantomSpriteInfo> phantomSprites;

    /** Stores a temporary copy of the UI's desired sprite color mods.
        We make a copy so that we can remove them as they get used. */
    std::vector<SpriteColorModInfo> spriteColorMods;

    /** Stores the sorted sprite info from the last prepareSprites() call.
        Calculations and sorting are done in-place. */
    std::vector<SpriteSortInfo> sortedSprites;

    /** Holds sprites that need to be sorted. Sprites are pushed during
        gatherSpriteInfo() and sorted during sortSpritesByDepth(). */
    std::vector<SpriteSortInfo> spritesToSort;

    struct EntityVisualEffectIndex {
        /** The entity that the effects belong to. */
        entt::entity entity{};
        /** The first index in entityVisualEffects that contains effects for 
            this entity. */
        std::size_t startIndex{};
        /** The number of effects. */
        std::size_t count{};
    };
    /** A parallel vector for indexing into entityVisualEffects. */
    std::vector<EntityVisualEffectIndex> entityVisualEffectIndices;

    /** Holds the current frame's entity visual effects. */
    std::vector<VisualEffectRenderInfo> entityVisualEffects;

    /** The global timestamp that we're using during the current render 
        frame. */
    double lastAnimationTimestamp;

    /** The global timestamp that we used during the last render frame. 
        Allows us to calculate time deltas. */
    double currentAnimationTimestamp;
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/CMakeLists.txt`:

```txt
target_sources(ClientLib
    PRIVATE
        Private/AVEntityHelpers.cpp
        Private/AVSystem.cpp
        Private/CameraSystem.cpp
        Private/CastHelper.cpp
        Private/CastSystem.cpp
        Private/ChunkUpdateSystem.cpp
        Private/ComponentUpdateSystem.cpp
        Private/EntityLifetimeSystem.cpp
        Private/GraphicHelpers.cpp
        Private/GraphicSystem.cpp
        Private/InventorySystem.cpp
        Private/ItemSystem.cpp
        Private/NpcMovementSystem.cpp
        Private/PlayerInputSystem.cpp
        Private/PlayerMovementSystem.cpp
        Private/ReplicationTickOffset.cpp
        Private/ServerConnectionSystem.cpp
        Private/Simulation.cpp
        Private/TileUpdateSystem.cpp
        Private/World.cpp
        Private/GraphicData/GraphicData.cpp
        Private/IconData/IconData.cpp
        Private/ItemData/ItemData.cpp
        Private/TileMap/TileMap.cpp
    PUBLIC
        Public/AVEntityHelpers.h
        Public/AVEntityID.h
        Public/AVSystem.h
        Public/CameraSystem.h
        Public/CastHelper.h
        Public/CastSystem.h
        Public/ChunkUpdateSystem.h
        Public/ComponentUpdateSystem.h
        Public/EntityLifetimeSystem.h
        Public/EnttGroups.h
        Public/GraphicHelpers.h
        Public/GraphicSystem.h
        Public/InventorySystem.h
        Public/ISimulationExtension.h
        Public/ItemSystem.h
        Public/NpcMovementSystem.h
        Public/PlayerInputSystem.h
        Public/PlayerMovementSystem.h
        Public/ReplicationTickOffset.h
        Public/ServerConnectionSystem.h
        Public/Simulation.h
        Public/SimulationContext.h
        Public/TileUpdateSystem.h
        Public/World.h
        Public/WorldObjectID.h
        Public/CastableData/AVEntityState.h
        Public/CastableData/VisualEffectState.h
        Public/Components/AVEffects.h
        Public/Components/ClientCastState.h
        Public/Components/ClientGraphicState.h
        Public/Components/InputHistory.h
        Public/Components/NeedsAdjacentChunks.h
        Public/Events/SimulationStarted.h
        Public/GraphicData/AnimationRenderData.h
        Public/GraphicData/GraphicData.h
        Public/GraphicData/SpriteRenderData.h
        Public/IconData/IconData.h
        Public/IconData/IconRenderData.h
        Public/ItemData/ItemCache.h
        Public/ItemData/ItemData.h
        Public/TileMap/TileMap.h
)

target_include_directories(ClientLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/GraphicData
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/IconData
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/ItemData
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/TileMap
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/CastableData
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/Components
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/Events
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/GraphicData
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/IconData
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/ItemData
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/TileMap
)

```

`Source/ClientLib/Simulation/Private/AVEntityHelpers.cpp`:

```cpp
#include "AVEntityHelpers.h"
#include "entt/entity/registry.hpp"

namespace AM
{
namespace Client
{

std::optional<Position>
    AVEntityHelpers::getCasterPosition(entt::entity casterEntity,
                                       const entt::registry& registry)
{
    if (registry.valid(casterEntity)) {
        return registry.get<Position>(casterEntity);
    }

    // Caster is gone, don't spawn this entity.
    return {};
}

std::optional<Position> AVEntityHelpers::getTargetPosition(
    AVEntity::Behavior behavior, entt::entity targetEntity,
    const Position& targetPosition, const Position& currentPosition,
    const entt::registry& registry, bool isFirstPhase)
{
    switch (behavior) {
        case AVEntity::Behavior::MoveToEntity:
        case AVEntity::Behavior::FollowEntityStartCaster:
        case AVEntity::Behavior::FollowEntityStartTarget: {
            if (const auto* position{
                    registry.try_get<Position>(targetEntity)}) {
                return *position;
            }
            else {
                // Entity no longer exists.
                return {};
            }
        }
        case AVEntity::Behavior::MoveToPosition:
        case AVEntity::Behavior::FollowDirection:
        case AVEntity::Behavior::StaticPosition:
            return targetPosition;
        case AVEntity::Behavior::CurrentPosition: {
            if (!isFirstPhase) {
                return currentPosition;
            }
            else {
                break;
            }
        }
    }

    return {};
}

std::optional<AVEntityHelpers::StartStateReturn> AVEntityHelpers::getStartState(
    AVEntity::Behavior behavior, const Position& casterPosition,
    const Position& targetPosition, float startDistance)
{
    switch (behavior) {
        case AVEntity::Behavior::MoveToEntity:
        case AVEntity::Behavior::FollowEntityStartCaster:
        case AVEntity::Behavior::MoveToPosition:
        case AVEntity::Behavior::FollowDirection: {
            // Calculate a direction vector that points towards the target.
            Vector3 directionVec{targetPosition - casterPosition};
            directionVec.normalize();

            // Start at the front of the caster, offset towards the target.
            return StartStateReturn{
                casterPosition + (directionVec * startDistance),
                EntityGraphicType::Run, vectorToClosestDirection(directionVec)};
        }
        case AVEntity::Behavior::FollowEntityStartTarget:
        case AVEntity::Behavior::StaticPosition:
            return StartStateReturn{targetPosition, EntityGraphicType::Idle,
                                    Rotation::Direction::South};
        case AVEntity::Behavior::CurrentPosition:
            // CurrentPosition is invalid as a first phase.
            return {};
    }

    return {};
}

std::optional<AVEntityHelpers::GraphicStateReturn>
    AVEntityHelpers::getGraphicState(AVEntity::Behavior behavior,
                                     const Position& casterPosition,
                                     const Position& targetPosition)
{
    switch (behavior) {
        case AVEntity::Behavior::MoveToEntity:
        case AVEntity::Behavior::FollowEntityStartCaster:
        case AVEntity::Behavior::MoveToPosition:
        case AVEntity::Behavior::FollowDirection: {
            // If the entity has reached the target position, we don't know 
            // which direction to face. Return None so the caller knows to use
            // the previous direction.
            if (casterPosition == targetPosition) {
                return GraphicStateReturn{EntityGraphicType::Run,
                                          Rotation::Direction::None};
            }

            Vector3 directionVec{targetPosition - casterPosition};
            directionVec.normalize();
            return GraphicStateReturn{EntityGraphicType::Run,
                                      vectorToClosestDirection(directionVec)};
        }
        case AVEntity::Behavior::FollowEntityStartTarget:
        case AVEntity::Behavior::StaticPosition:
        case AVEntity::Behavior::CurrentPosition:
            return GraphicStateReturn{EntityGraphicType::Idle,
                                      Rotation::Direction::South};
    }

    return {};
}

bool AVEntityHelpers::timeElapsed(AVEntity::Behavior behavior, double startTime,
                                  double durationS, double currentTime,
                                  GraphicRef currentGraphic)
{
    switch (behavior) {
        case AVEntity::Behavior::FollowEntityStartCaster:
        case AVEntity::Behavior::FollowDirection:
        case AVEntity::Behavior::FollowEntityStartTarget:
        case AVEntity::Behavior::StaticPosition:
        case AVEntity::Behavior::CurrentPosition: {
            // If the phase hasn't started yet, return false.
            if (startTime == 0) {
                return false;
            }

            // If a duration was given, use it.
            if (durationS != -1) {
                double endTime{startTime + durationS};
                return (currentTime >= endTime);
            }

            // Duration == -1. Use the graphic's duration.
            if (std::holds_alternative<
                    std::reference_wrapper<const Sprite>>(currentGraphic)) {
                // Sprites have no duration, end immediately.
                return true;
            }
            else {
                const auto& animation{
                    std::get<std::reference_wrapper<const Animation>>(
                        currentGraphic)};

                // Subtract 1 tick's worth of time, since the A/V entity will 
                // be alive for an extra tick after we increment.
                double endTime{startTime + animation.get().getLengthS()
                               - SharedConfig::SIM_TICK_TIMESTEP_S};
                if (currentTime >= endTime) {
                    return true;
                }
            }
            break;
        }
        default:
            break;
    }

    return false;
}

bool AVEntityHelpers::positionReached(AVEntity::Behavior behavior,
                                      const Position& entityPos,
                                      const Position& targetPos)
{
    // If this is a position-based phase and we've reached the target, 
    // return true.
    switch (behavior) {
        case AVEntity::Behavior::MoveToEntity:
        case AVEntity::Behavior::MoveToPosition: {
            if (entityPos == targetPos) {
                return true;
            }
            break;
        }
        default:
            break;
    }

    return false;
}

Rotation::Direction
    AVEntityHelpers::vectorToClosestDirection(const Vector3& directionVector)
{
    // Drop the Z axis since direction is 2D.
    Vector3 directionVector2D{directionVector.x, directionVector.y, 0};
    directionVector2D.normalize();

    // Multiply and round so that each axis has a value of -1, 0, or 1.
    // E.g. for the X axis, -1 == West, 0 == Center, 1 == East.
    int x{static_cast<int>(std::lround(directionVector2D.x))};
    int y{static_cast<int>(std::lround(directionVector2D.y))};

    // Return the appropriate direction.
    if (x == -1 && y == -1) {
        return Rotation::Direction::NorthWest;
    }
    else if (x == -1 && y == 0) {
        return Rotation::Direction::West;
    }
    else if (x == -1 && y == 1) {
        return Rotation::Direction::SouthWest;
    }
    else if (x == 0 && y == -1) {
        return Rotation::Direction::North;
    }
    else if (x == 0 && y == 1) {
        return Rotation::Direction::South;
    }
    else if (x == 1 && y == -1) {
        return Rotation::Direction::NorthEast;
    }
    else if (x == 1 && y == 0) {
        return Rotation::Direction::East;
    }
    else if (x == 1 && y == 1) {
        return Rotation::Direction::SouthEast;
    }

    // Direction vector is (0, 0). Default to South.
    return Rotation::Direction::South;
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Private/AVSystem.cpp`:

```cpp
#include "AVSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "GraphicData.h"
#include "ClientGraphicState.h"
#include "GraphicHelpers.h"
#include "AVEffects.h"
#include "AVEntityState.h"
#include "AVEntityHelpers.h"
#include "EnttGroups.h"
#include "Timer.h"

namespace AM
{
namespace Client
{

AVSystem::AVSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, graphicData{inSimContext.graphicData}
{
}

void AVSystem::updateAVEffectsAndEntities()
{
    updateAVEffects();

    updateAVEntities();
}

void AVSystem::updateAVEffects()
{
    auto view{world.registry.view<AVEffects>()};
    for (auto [entity, avEffects] : view.each()) {
        // Update visual effects.
        updateVisualEffects(avEffects.visualEffects);

        // Update audio effects.
    }
}

void AVSystem::updateVisualEffects(
    std::vector<VisualEffectState>& visualEffects)
{
    double currentTime{Timer::getGlobalTime()};

    for (auto it{visualEffects.begin()}; it != visualEffects.end();) {
        // If the effect hasn't been started yet, skip it.
        VisualEffectState& effectState{*it};
        if (effectState.startTime == 0) {
            it++;
            continue;
        }

        // Determine whether this effect's graphic is a sprite or animation.
        bool isAnimation{
            isAnimationID(effectState.visualEffect.get().graphicID)};

        // If this is a PlayOnce animation, check if we've reached the end.
        double endTime{};
        if (isAnimation
            && (it->visualEffect.get().loopMode
                == VisualEffect::LoopMode::PlayOnce)) {
            const Animation& animation{graphicData.getAnimation(
                toAnimationID(effectState.visualEffect.get().graphicID))};
            endTime = effectState.startTime + animation.getLengthS();
        }
        else {
            // LoopMode::Loop.
            endTime = effectState.startTime
                      + effectState.visualEffect.get().loopTime;
        }

        // If the effect is completed, destroy it.
        if (currentTime >= endTime) {
            it = visualEffects.erase(it);
        }
        else {
            it++;
        }
    }
}

void AVSystem::updateAVEntities()
{
    double currentTime{Timer::getGlobalTime()};

    // Process the current phase for each A/V entity.
    auto view{world.avRegistry.view<Position, PreviousPosition, AVEntityState,
                                    GraphicState, ClientGraphicState>()};
    for (auto [entity, position, previousPosition, avEntityState,
               graphicState, clientGraphicState] :
         view.each()) {
        // If the current phase has completed, increment to the next.
        if (!incrementPhaseIfNecessary(avEntityState, position, graphicState,
                                       clientGraphicState, currentTime)) {
            world.avRegistry.destroy(entity);
            continue;
        }

        // If all phases have completed, delete the entity.
        const AVEntity& avEntity{avEntityState.avEntity.get()};
        if (avEntityState.currentPhaseIndex == avEntity.phases.size()) {
            world.avRegistry.destroy(entity);
            continue;
        }

        // Entity is still alive, update it.
        if (!updateAVEntity(avEntityState, position, previousPosition,
                            graphicState, clientGraphicState)) {
            world.avRegistry.destroy(entity);
            continue;
        }
    }
}

bool AVSystem::incrementPhaseIfNecessary(AVEntityState& avEntityState,
                                         const Position& position,
                                         const GraphicState& graphicState,
                                         ClientGraphicState& clientGraphicState,
                                         double currentTime)
{
    // Determine the target's position.
    const AVEntity& avEntity{avEntityState.avEntity.get()};
    const AVEntity::Phase& lastPhase{
        avEntity.phases.at(avEntityState.currentPhaseIndex)};
    std::optional<Position> lastTargetOpt{
        AVEntityHelpers::getTargetPosition(
            lastPhase.behavior, avEntityState.targetEntity,
            static_cast<Position>(avEntityState.targetPosition), position,
            world.registry, false)};
    if (!lastTargetOpt) {
        return false;
    }
    Position lastTargetPosition{lastTargetOpt.value()};

    // If the entity has reached the completion condition for this phase, 
    // move to the next phase.
    const EntityGraphicSet& lastGraphicSet{
        graphicData.getEntityGraphicSet(graphicState.graphicSetID)};
    GraphicRef lastGraphic{
        lastGraphicSet.graphics.at(clientGraphicState.graphicType)
            .at(clientGraphicState.graphicDirection)};
    if (AVEntityHelpers::timeElapsed(
            lastPhase.behavior, avEntityState.phaseStartTime,
            lastPhase.durationS, currentTime, lastGraphic)
        || AVEntityHelpers::positionReached(lastPhase.behavior, position,
                                            lastTargetPosition)) {
        avEntityState.currentPhaseIndex++;

        // If all phases have completed, exit early.
        if (avEntityState.currentPhaseIndex == avEntity.phases.size()) {
            return true;
        }

        avEntityState.setStartTime = true;

        // If the graphic changed, flag the graphic start time to be reset.
        const AVEntity::Phase& newPhase{
            avEntity.phases.at(avEntityState.currentPhaseIndex)};
        if (lastPhase.graphicSetID != newPhase.graphicSetID) {
            clientGraphicState.setStartTime = true;
        }
    }

    return true;
}

bool AVSystem::updateAVEntity(const AVEntityState& avEntityState,
                              Position& position,
                              PreviousPosition& previousPosition,
                              GraphicState& graphicState,
                              ClientGraphicState& clientGraphicState)
{
    // Determine the target's position.
    const AVEntity& avEntity{avEntityState.avEntity.get()};
    const AVEntity::Phase& phase{
        avEntity.phases.at(avEntityState.currentPhaseIndex)};
    std::optional<Position> targetOpt{AVEntityHelpers::getTargetPosition(
        phase.behavior, avEntityState.targetEntity,
        static_cast<Position>(avEntityState.targetPosition), position,
        world.registry, false)};
    if (!targetOpt) {
        return false;
    }
    Position targetPosition{targetOpt.value()};

    // Save the entity's old position.
    previousPosition = position;

    // Move the entity towards the target.
    position = position.moveTowards(targetPosition, phase.movementSpeed);

    // Get the entity's desired graphic state.
    auto graphicStateOpt{AVEntityHelpers::getGraphicState(
        phase.behavior, position, targetPosition)};
    if (!graphicStateOpt) {
        return false;
    }
    auto& [desiredGraphicType, desiredGraphicDirection]
        = graphicStateOpt.value();

    // If the desired direction is None, getGraphicState is telling us to use 
    // the previous direction.
    if (desiredGraphicDirection == Rotation::Direction::None) {
        desiredGraphicDirection = clientGraphicState.graphicDirection;
    }

    // Set the new graphic, accounting for missing graphics in the set.
    graphicState.graphicSetID = phase.graphicSetID;
    const EntityGraphicSet& graphicSet{
        graphicData.getEntityGraphicSet(graphicState.graphicSetID)};
    GraphicHelpers::GraphicReturn newGraphic{
        GraphicHelpers::getGraphicOrFallback(
            graphicSet, desiredGraphicType, desiredGraphicDirection,
            desiredGraphicType, desiredGraphicDirection)};
    if (newGraphic.type != clientGraphicState.graphicType) {
        clientGraphicState.graphicType = newGraphic.type;
        clientGraphicState.setStartTime = true;
    }
    if (newGraphic.direction != clientGraphicState.graphicDirection) {
        clientGraphicState.graphicDirection = newGraphic.direction;
        // Note: We don't reset the animation start time, since we want e.g. 
        //       a run animation to play smoothly when changing direction.
    }

    return true;
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Private/CameraSystem.cpp`:

```cpp
#include "CameraSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "Camera.h"
#include "Position.h"
#include "Log.h"

namespace AM
{
namespace Client
{
CameraSystem::CameraSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
{
}

void CameraSystem::moveCameras()
{
    auto cameraGroup = world.registry.group<Camera>(entt::get<Position>);
    for (auto [entity, camera, position] : cameraGroup.each()) {
        // Save the camera's previous target position.
        camera.prevTarget = camera.target;

        // Update the camera to its new target position based on its behavior.
        switch (camera.behavior) {
            case Camera::Fixed:
                // Doesn't move on its own.
                break;
            case Camera::CenterOnEntity:
                camera.target = position;
                break;
            default:
                break;
        }

        // Update the camera's view bounds.
        camera.viewBounds.min.x = camera.target.x - SharedConfig::VIEW_RADIUS;
        camera.viewBounds.max.x = camera.target.x + SharedConfig::VIEW_RADIUS;
        camera.viewBounds.min.y = camera.target.y - SharedConfig::VIEW_RADIUS;
        camera.viewBounds.max.y = camera.target.y + SharedConfig::VIEW_RADIUS;
        // Note: The camera can always see down to Z == 0.
        camera.viewBounds.min.z = 0;
        camera.viewBounds.max.z = camera.target.z + SharedConfig::VIEW_RADIUS;
        // Note: We purposely don't clip to the tile map's bounds, because it's 
        //       reasonable to view things outside of the map.
    }
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Private/CastHelper.cpp`:

```cpp
#include "CastHelper.h"
#include "Simulation.h"
#include "World.h"
#include "Network.h"
#include "ItemData.h"
#include "CastableData.h"
#include "Inventory.h"
#include "Castable.h"
#include "ClientCastState.h"
#include "ValidateCast.h"
#include "CastFailed.h"
#include "CastStarted.h"
#include "CastRequest.h"
#include "Position.h"
#include "PreviousPosition.h"
#include "CastCooldown.h"
#include "Cylinder.h"
#include "SharedConfig.h"

namespace AM
{
namespace Client
{

CastHelper::CastHelper(Simulation& inSimulation, Network& inNetwork,
                       const ItemData& inItemData,
                       const CastableData& inCastableData)
: simulation{inSimulation}
, world{inSimulation.getWorld()}
, network{inNetwork}
, itemData{inItemData}
, castableData{inCastableData}
, castItemInteractionQueue{}
, castEntityInteractionQueue{}
, castSpellQueue{}
{
}

void CastHelper::queueItemInteraction(const CastItemInteractionParams& params)
{
    castItemInteractionQueue.emplace(params);
}

void CastHelper::queueEntityInteraction(
    const CastEntityInteractionParams& params)
{
    castEntityInteractionQueue.emplace(params);
}

void CastHelper::queueSpell(const CastSpellParams& params)
{
    castSpellQueue.emplace(params);
}

CastFailureType
    CastHelper::castItemInteraction(const CastItemInteractionParams& params)
{
    // Check that the item exists and actually has this interaction type.
    // Note: This implicitly checks that the entity owns the item, since it
    //       uses the slot index.
    // Note: If we ever hit a situation where the item in the requested slot
    //       doesn't match what the user clicked, we can also put the item ID
    //       in the request message to confirm.
    const auto& inventory{world.registry.get<Inventory>(world.playerEntity)};
    const Item* item{inventory.getItem(params.slotIndex, itemData)};
    if (!item) {
        return CastFailureType::InvalidItem;
    }
    else if (!(item->supportsInteraction(params.interactionType))) {
        return CastFailureType::InteractionNotSupported;
    }

    // Check that the requested interaction has an associated Castable.
    const Castable* castable{castableData.getCastable(params.interactionType)};
    if (!castable) {
        return CastFailureType::InvalidCastable;
    }

    // Perform the shared validation checks.
    CastFailureType failureType{
        performSharedChecks(*castable, world.playerEntity, params.targetEntity,
                            params.targetPosition)};
    if (failureType != CastFailureType::None) {
        return failureType;
    }

    // Add a ClientCastState to the entity (we replace in case they're in the 
    // CastComplete state).
    world.registry.emplace_or_replace<ClientCastState>(
        world.playerEntity,
        ClientCastState{.castInfo{castable, world.playerEntity, item,
                                  params.targetEntity, params.targetPosition},
                        .endTick{0}});

    // Send a cast request.
    network.serializeAndSend(CastRequest{
        simulation.getCurrentTick(), castable->castableID, params.slotIndex,
        params.targetEntity, params.targetPosition});

    return CastFailureType::None;
}

CastFailureType
    CastHelper::castEntityInteraction(const CastEntityInteractionParams& params)
{
    // Check that the requested interaction has an associated Castable.
    const Castable* castable{castableData.getCastable(params.interactionType)};
    if (!castable) {
        return CastFailureType::InvalidCastable;
    }

    // Perform the shared validation checks.
    CastFailureType failureType{
        performSharedChecks(*castable, world.playerEntity, params.targetEntity,
                            params.targetPosition)};
    if (failureType != CastFailureType::None) {
        return failureType;
    }

    // We check above that the target entity is valid if one was provided, but 
    // entity interactions require a target entity. Check that it's non-null.
    if (params.targetEntity == entt::null) {
        return CastFailureType::InvalidTargetEntity;
    }

    // Add a ClientCastState to the entity (we replace in case they're in the 
    // CastComplete state).
    world.registry.emplace_or_replace<ClientCastState>(
        world.playerEntity,
        ClientCastState{.castInfo{castable, world.playerEntity, nullptr,
                                  params.targetEntity, params.targetPosition},
                        .endTick{0}});

    // Send a cast request.
    network.serializeAndSend(
        CastRequest{simulation.getCurrentTick(), castable->castableID, 0,
                    params.targetEntity, params.targetPosition});

    return CastFailureType::None;
}

CastFailureType CastHelper::castSpell(const CastSpellParams& params)
{
    // Check that the requested interaction has an associated Castable.
    const Castable* castable{castableData.getCastable(params.interactionType)};
    if (!castable) {
        return CastFailureType::InvalidCastable;
    }

    // Perform the shared validation checks.
    CastFailureType failureType{
        performSharedChecks(*castable, world.playerEntity, params.targetEntity,
                            params.targetPosition)};
    if (failureType != CastFailureType::None) {
        return failureType;
    }

    // We check above that the target entity is valid if one was provided, but 
    // entity interactions require a target entity. Check that it's non-null.
    if (params.targetEntity == entt::null) {
        return CastFailureType::InvalidTargetEntity;
    }

    // Add a ClientCastState to the entity (we replace in case they're in the 
    // CastComplete state).
    world.registry.emplace_or_replace<ClientCastState>(
        world.playerEntity,
        ClientCastState{.castInfo{castable, world.playerEntity, nullptr,
                                  params.targetEntity, params.targetPosition},
                        .endTick{0}});

    // Send a cast request.
    network.serializeAndSend(
        CastRequest{simulation.getCurrentTick(), castable->castableID, 0,
                    params.targetEntity, params.targetPosition});

    return CastFailureType::None;
}

CastFailureType CastHelper::performSharedChecks(const Castable& castable,
                                                entt::entity casterEntity,
                                                entt::entity targetEntity,
                                                const Vector3& targetPosition)
{
    entt::registry& registry{world.registry};

    // Check that the caster entity exists.
    // Note: This should only be able to fail if a non-CastSystem caller 
    //       doesn't fill the struct properly.
    if (!(registry.valid(casterEntity))) {
        return CastFailureType::InvalidCasterEntity;
    }

    // If this isn't an instant cast, check that the caster isn't moving.
    const Position& casterPosition{registry.get<Position>(casterEntity)};
    if (castable.castTime != 0) {
        // Note: Since we compare to the previous tick's position, it takes an 
        //       extra tick after movement stops before we let casts go through.
        //       We consider this to be fine.
        const PreviousPosition* previousPosition{
            registry.try_get<PreviousPosition>(casterEntity)};
        if (previousPosition && (casterPosition != *previousPosition)) {
            return CastFailureType::Movement;
        }
    }

    // Check that the caster isn't already casting.
    // Note: If it's in the CastComplete state, we're fine with overwriting it.
    if (const auto* castState{registry.try_get<ClientCastState>(casterEntity)};
        castState && (castState->state == ClientCastState::State::Casting)) {
        return CastFailureType::AlreadyCasting;
    }

    // Check that this cast isn't on cooldown, and the GCD isn't active.
    if (auto* castCooldown{registry.try_get<CastCooldown>(casterEntity)}) {
        if (castCooldown->isCastOnCooldown(castable.castableID,
                                           simulation.getCurrentTick())) {
            return CastFailureType::OnCooldown;
        }
    }

    // If a target entity was provided or the Castable requires a target entity,
    // check that it exists.
    if ((targetEntity != entt::null)
        || (castable.targetType == Castable::TargetType::Entity)) {
        if (!(registry.valid(targetEntity))) {
            return CastFailureType::InvalidTargetEntity;
        }
    }

    // If the Castable uses a target entity, validate it.
    // Note: We only check LoS on the server, to avoid rejecting casts that 
    //       may succeed.
    if ((castable.targetType == Castable::TargetType::Entity)
        || ((castable.targetType == Castable::TargetType::SelfOrEntity)
            && (targetEntity != entt::null))) {
        // Check that the caster is in range of the target entity.
        // Note: We already checked that both entities exist above.
        // Note: targetEntityPos is different than the targetPosition param.
        const Position& targetEntityPos{registry.get<Position>(targetEntity)};
        float squaredRange{castable.range * castable.range};
        if (casterPosition.squaredDistanceTo(targetEntityPos) > squaredRange) {
            return CastFailureType::OutOfRange;
        }
    }
    // If the Castable uses a target circle, validate it.
    else if (castable.targetType == Castable::TargetType::Circle) {
        // Check that the target position is within the map bounds.
        Cylinder targetCylinder{castable.getTargetCylinder(targetPosition)};
        if (!(world.tileMap.getTileExtent().contains(targetCylinder))) {
            return CastFailureType::InvalidTargetPosition;
        }

        // Check that the caster is in range of the target position.
        float squaredDistance{casterPosition.squaredDistanceTo(targetPosition)};
        if (squaredDistance > castable.range) {
            return CastFailureType::OutOfRange;
        }
    }

    return CastFailureType::None;
};

} // namespace Client 
} // namespace AM

```

`Source/ClientLib/Simulation/Private/CastSystem.cpp`:

```cpp
#include "CastSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "Network.h"
#include "GraphicData.h"
#include "ItemData.h"
#include "CastableData.h"
#include "ClientCastState.h"
#include "CastCooldown.h"
#include "Castable.h"
#include "AVEffects.h"
#include "EnttGroups.h"
#include "ClientGraphicState.h"
#include "GraphicHelpers.h"
#include "AVEntityState.h"
#include "AVEntityHelpers.h"
#include "entt/signal/dispatcher.hpp"

namespace AM
{
namespace Client
{

CastSystem::CastSystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, graphicData{inSimContext.graphicData}
, castableData{inSimContext.castableData}
, simEventDispatcher{inSimContext.simEventDispatcher}
, castStartedQueue{inSimContext.networkEventDispatcher}
, castFailedQueue{inSimContext.networkEventDispatcher}
, castCooldownInitQueue{inSimContext.networkEventDispatcher}
{
}

void CastSystem::processCasts()
{
    // Process any waiting UI cast requests.
    processUICasts();

    // Process any waiting cast messages.
    while (const CastStarted* castStarted{castStartedQueue.peek()}) {
        handleCastStarted(*castStarted);
        castStartedQueue.pop();
    }

    while (const CastFailed* castFailed{castFailedQueue.peek()}) {
        handleCastFailed(*castFailed);
        castFailedQueue.pop();
    }

    while (const CastCooldownInit
           * castCooldownInit{castCooldownInitQueue.peek()}) {
        handleCastCooldownInit(*castCooldownInit);
        castCooldownInitQueue.pop();
    }

    // Update ongoing casts.
    updateCasts();
}

void CastSystem::processUICasts()
{
    // Note: This setup is a little weird (we pop from CastHelper queue, then 
    //       pass the struct to a CastHelper function), but we need the return
    //       type so we can signal failures.

    CastHelper& castHelper{world.castHelper};
    auto& castItemInteractionQueue{castHelper.castItemInteractionQueue};
    for (; !(castItemInteractionQueue.empty());
         castItemInteractionQueue.pop()) {
        const auto& params{castItemInteractionQueue.front()};
        CastFailureType failureType{castHelper.castItemInteraction(params)};
        if (failureType != CastFailureType::None) {
            simEventDispatcher.trigger(CastFailed{
                world.playerEntity, params.interactionType, failureType});
        }
    }

    auto& castEntityInteractionQueue{castHelper.castEntityInteractionQueue};
    for (; !(castEntityInteractionQueue.empty());
         castEntityInteractionQueue.pop()) {
        const auto& params{castEntityInteractionQueue.front()};
        CastFailureType failureType{castHelper.castEntityInteraction(params)};
        if (failureType != CastFailureType::None) {
            simEventDispatcher.trigger(CastFailed{
                world.playerEntity, params.interactionType, failureType});
        }
    }

    auto& castSpellQueue{castHelper.castSpellQueue};
    for (; !(castSpellQueue.empty()); castSpellQueue.pop()) {
        const auto& params{castSpellQueue.front()};
        CastFailureType failureType{castHelper.castSpell(params)};
        if (failureType != CastFailureType::None) {
            simEventDispatcher.trigger(CastFailed{
                world.playerEntity, params.interactionType, failureType});
        }
    }
}

void CastSystem::handleCastStarted(const CastStarted& castStarted)
{
    entt::registry& registry{world.registry};

    // If the given entity doesn't exist, we can't do anything.
    if (!(registry.valid(castStarted.casterEntity))) {
        return;
    }

    // If this entity has an ongoing cast, kill it.
    registry.remove<ClientCastState>(castStarted.casterEntity);

    // Start the cast.
    const Castable* castable{castableData.getCastable(castStarted.castableID)};
    CastInfo castInfo{castable, castStarted.casterEntity, nullptr,
                      castStarted.targetEntity, castStarted.targetPosition};
    registry.emplace<ClientCastState>(castStarted.casterEntity, castInfo,
                                      ClientCastState::State::Casting);
}

void CastSystem::handleCastFailed(const CastFailed& castFailed)
{
    // Try to match the failed cast info with an ongoing cast.
    if (auto* castState{world.registry.try_get<ClientCastState>(
            castFailed.casterEntity)}) {
        if (castState->castInfo.castable->castableID
            == castFailed.castableID) {
            // If the failure is a type that results in the cast ending, 
            // kill the cast.
            if (castFailed.castFailureType != CastFailureType::AlreadyCasting) {
                world.registry.erase<ClientCastState>(castFailed.casterEntity);
            }

            // If this is for the player entity, signal it to the UI.
            if (castFailed.casterEntity == world.playerEntity) {
                simEventDispatcher.trigger(castFailed);
            }
        }
    }
}

void CastSystem::handleCastCooldownInit(
    const CastCooldownInit& castCooldownInit)
{
    // Apply the given CastCooldown to the player entity.
    // Note: We only receive this message for the player entity, never any 
    //       other entity.
    // Note: We may be replacing a predicted cooldown by doing this, but the 
    //       server-given cooldown will be more accurate anyway.
    world.registry.emplace_or_replace<CastCooldown>(
        world.playerEntity, castCooldownInit.castCooldown);
}

void CastSystem::updateCasts()
{
    auto view{world.registry.view<ClientCastState>()};
    auto movementGroup{EnttGroups::getMovementGroup(world.registry)};
    Uint32 currentTick{simulation.getCurrentTick()};

    // Iterate each entity that is currently casting.
    for (auto [entity, castState] : view.each()) {
        // If this cast is unstarted, start it.
        if (castState.endTick == 0) {
            startCast(castState);
            continue;
        }

        // If the player entity has moved, cancel the cast.
        // Note: We don't predict cast failures on non-player entities.
        // Note: The player entity always has a PreviousPosition.
        if (entity == world.playerEntity) {
            auto [position, prevPosition]
                = movementGroup.get<Position, PreviousPosition>(entity);
            if (position != prevPosition) {
                cancelCast(castState);
                continue;
            }
        }

        // If the cast has reached its finish time, finish it.
        if ((castState.state == ClientCastState::State::Casting)
            && (currentTick == castState.endTick)) {
            // Note: We only check pre-finish cast validity on the server, to 
            //       avoid rejecting casts that may succeed.
            finishCast(castState);
            continue;
        }

        // If the "cast complete" animation has finished, end the cast.
        if ((castState.state == ClientCastState::State::CastComplete)
            && (currentTick == castState.endTick)) {
            world.registry.erase<ClientCastState>(entity);
            continue;
        }
    }
}

void CastSystem::startCast(ClientCastState& castState)
{
    // Note: CastHelper ensures that castState.castInfo.casterEntity is the 
    //       same entity that owns castState.

    // If this cast triggers the GCD, track it.
    // Note: If CastCooldown gets created here, its lastUpdateTick will be set 
    //       to currentTick.
    // Note: CastCooldown may get created here even if it isn't used. That's 
    //       fine, the entity has at least shown the capability to cast things.
    CastInfo& castInfo{castState.castInfo};
    Uint32 currentTick{simulation.getCurrentTick()};
    CastCooldown& castCooldown{world.registry.get_or_emplace<CastCooldown>(
        castInfo.casterEntity, currentTick)};
    if (castInfo.castable->triggersGCD) {
        castCooldown.gcdTicksRemaining
            = SharedConfig::CAST_GLOBAL_COOLDOWN_TICKS;
    }

    // If this is an instant cast, finish it immediately.
    if (castInfo.castable->castTime == 0) {
        finishCast(castState);
    }
    else {
        // Not an instant cast. Set its end tick.
        Uint32 castTimeTicks{static_cast<Uint32>(
            castInfo.castable->castTime / SharedConfig::SIM_TICK_TIMESTEP_S)};
        castState.endTick = currentTick + castTimeTicks;
    }
}

void CastSystem::cancelCast(ClientCastState& castState)
{
    // Reset the GCD.
    CastInfo& castInfo{castState.castInfo};
    CastCooldown& castCooldown{
        world.registry.get<CastCooldown>(castInfo.casterEntity)};
    castCooldown.gcdTicksRemaining = 0;

    // If the caster is the player entity, signal the failure to the UI (the 
    // server doesn't send failure messages for the player entity, since we 
    // can detect them ourself).
    if (castInfo.casterEntity == world.playerEntity) {
        simEventDispatcher.trigger(CastFailed{
            castInfo.casterEntity, castState.castInfo.castable->castableID,
            CastFailureType::Movement});
    }

    // Cancel the cast.
    world.registry.erase<ClientCastState>(castInfo.casterEntity);
}

void CastSystem::finishCast(ClientCastState& castState)
{
    // If this castable has a cooldown, track it.
    const CastInfo& castInfo{castState.castInfo};
    if (castInfo.castable->cooldownTime > 0) {
        Uint32 castTimeTicks{
            static_cast<Uint32>(castInfo.castable->cooldownTime
                                / SharedConfig::SIM_TICK_TIMESTEP_S)};

        CastCooldown& castCooldown{
            world.registry.get<CastCooldown>(castInfo.casterEntity)};
        castCooldown.cooldowns.emplace_back(castInfo.castable->castableID,
                                            castTimeTicks);
    }

    // If the caster has a valid graphic, mark the cast as complete and
    // play its audio/visual effects.
    if (Uint32 castCompleteEndTick{getCastCompleteEndTick(
            castState.castInfo.casterEntity, *(castState.castInfo.castable))}) {
        castState.state = ClientCastState::State::CastComplete;
        castState.endTick = castCompleteEndTick;
    }
    else
    {
        // No valid graphic, end the cast.
        world.registry.erase<ClientCastState>(castState.castInfo.casterEntity);
    }

    // Play any AV effects and create any AV entities.
    playAVEffects(castState.castInfo);
}

Uint32 CastSystem::getCastCompleteEndTick(entt::entity entity,
                                          const Castable& castable)
{
    // Check that the Castable has a "cast complete" graphic.
    if (castable.castCompleteGraphicType == EntityGraphicType::NotSet) {
        return 0;
    }

    // Check that the entity has graphics enabled.
    const GraphicState* graphicState{
        world.registry.try_get<GraphicState>(entity)};
    if (!graphicState) {
        return 0;
    }

    // Check that the entity's graphic set has the Castable's "cast complete" 
    // graphic type.
    const EntityGraphicSet& graphicSet{
        graphicData.getEntityGraphicSet(graphicState->graphicSetID)};
    auto graphicArrIt{
        graphicSet.graphics.find(castable.castCompleteGraphicType)};
    if (graphicArrIt == graphicSet.graphics.end()) {
        return 0;
    }

    // Check that the graphic array has at least one graphic.
    // Note: We use the first non-null graphic from the array, which may not
    //       match the entity's current direction. We assume that all 
    //       directions of this graphic type have the same length, so it 
    //       shouldn't matter.
    const GraphicRef* graphic{nullptr};
    for (const GraphicRef& graphicRef : graphicArrIt->second) {
        if (graphicRef.getGraphicID()) {
            graphic = &graphicRef;
            break;
        }
    }
    if (!graphic) {
        return 0;
    }

    // Check that the graphic is an animation (we use the animation's length to
    // know how long to be in the "cast complete" state, so we can't support 
    // individual sprites).
    const auto* animation{
        std::get_if<std::reference_wrapper<const Animation>>(graphic)};
    if (!animation) {
        return 0;
    }

    Uint32 castCompleteEndTick{simulation.getCurrentTick()
                               + animation->get().getLengthTicks()};
    return castCompleteEndTick;
}

void CastSystem::playAVEffects(const CastInfo& castInfo)
{
    // If this castable has AV effects, add them to the caster.
    if (!(castInfo.castable->castCompleteVisualEffects.empty())) {
        AVEffects& avEffects{
            world.registry.get_or_emplace<AVEffects>(castInfo.casterEntity)};

        for (const VisualEffect& visualEffect :
             castInfo.castable->castCompleteVisualEffects) {
            avEffects.visualEffects.emplace_back(visualEffect);
        }
    }

    // If this castable spawns AV entities, add them to the A/V registry.
    for (const AVEntity& avEntity :
         castInfo.castable->castCompleteAVEntities) {
        // If this entity def has no phases, skip it.
        if (avEntity.phases.empty()) {
            continue;
        }
        const AVEntity::Phase& firstPhase{avEntity.phases.at(0)};

        // Get the caster's position.
        std::optional<Position> casterOpt{AVEntityHelpers::getCasterPosition(
            castInfo.casterEntity, world.registry)};
        if (!casterOpt) {
            continue;
        }
        Position casterPosition{casterOpt.value()};

        // Determine the target's position.
        std::optional<Position> targetOpt{AVEntityHelpers::getTargetPosition(
            firstPhase.behavior, castInfo.targetEntity,
            static_cast<Position>(castInfo.targetPosition), {}, world.registry,
            true)};
        if (!targetOpt) {
            continue;
        }
        Position targetPosition{targetOpt.value()};

        // Determine the A/V entity's desired starting state.
        auto startStateOpt{AVEntityHelpers::getStartState(
            firstPhase.behavior, casterPosition, targetPosition,
            avEntity.startDistance)};
        if (!startStateOpt) {
            continue;
        }
        auto& [startPosition, desiredGraphicType, desiredGraphicDirection]
            = startStateOpt.value();

        // Get a valid graphic from the graphic set.
        const EntityGraphicSet& graphicSet{
            graphicData.getEntityGraphicSet(firstPhase.graphicSetID)};
        auto graphicReturn{GraphicHelpers::getGraphicOrFallback(
            graphicSet, desiredGraphicType, desiredGraphicDirection,
            desiredGraphicType, desiredGraphicDirection)};

        AVEntityID newAVEntity{world.avRegistry.create()};
        world.avRegistry.emplace<Position>(newAVEntity, startPosition);
        world.avRegistry.emplace<PreviousPosition>(newAVEntity, startPosition);
        world.avRegistry.emplace<GraphicState>(newAVEntity,
                                               firstPhase.graphicSetID);
        world.avRegistry.emplace<ClientGraphicState>(
            newAVEntity, graphicReturn.type, graphicReturn.direction);
        world.avRegistry.emplace<AVEntityState>(newAVEntity, avEntity,
                                                castInfo.targetEntity,
                                                castInfo.targetPosition);
    }
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Private/ChunkUpdateSystem.cpp`:

```cpp
#include "ChunkUpdateSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "MovementHelpers.h"
#include "World.h"
#include "Network.h"
#include "Position.h"
#include "PreviousPosition.h"
#include "NeedsAdjacentChunks.h"
#include "ChunkExtent.h"
#include "ChunkDataRequest.h"
#include "ChunkWireSnapshot.h"
#include "Morton.h"
#include "SharedConfig.h"
#include "Config.h"
#include "Log.h"
#include <memory>

namespace AM
{
namespace Client
{
ChunkUpdateSystem::ChunkUpdateSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, chunkUpdateQueue{inSimContext.networkEventDispatcher}
{
}

void ChunkUpdateSystem::updateChunks()
{
    // Request chunk updates, if necessary.
    requestNeededUpdates();

    // Process any received chunk updates.
    receiveAndApplyUpdates();
}

void ChunkUpdateSystem::requestNeededUpdates()
{
    entt::registry& registry{world.registry};
    Position& currentPosition{registry.get<Position>(world.playerEntity)};
    PreviousPosition& previousPosition{
        registry.get<PreviousPosition>(world.playerEntity)};

    // If we're flagged as needing to load all adjacent chunks, request them.
    if (registry.all_of<NeedsAdjacentChunks>(world.playerEntity)) {
        requestAllInRangeChunks(ChunkPosition(currentPosition));

        registry.erase<NeedsAdjacentChunks>(world.playerEntity);
    }
    // If we moved, check if we're in range of any new chunks.
    else if (previousPosition != currentPosition) {
        // If we moved into a new chunk.
        ChunkPosition previousChunk(previousPosition);
        ChunkPosition currentChunk(currentPosition);
        if (previousChunk != currentChunk) {
            // Request the chunks that we're now in range of.
            requestNewInRangeChunks(previousChunk, currentChunk);
        }
    }
}

void ChunkUpdateSystem::requestAllInRangeChunks(
    const ChunkPosition& currentChunk)
{
    // Determine which chunks are in range of the given position.
    // Note: The range is hardcoded to be all chunks directly surrounding the 
    //       given chunk in the X/Y directions, and every chunk along the Z 
    //       axis.
    const ChunkExtent& mapChunkExtent{world.tileMap.getChunkExtent()};
    ChunkExtent currentExtent{
        (currentChunk.x - 1),  (currentChunk.y - 1), mapChunkExtent.z, 3, 3,
        mapChunkExtent.zLength};

    // Bound the range to the map boundaries.
    currentExtent = currentExtent.intersectWith(mapChunkExtent);

    // Iterate over the range, adding all chunks to a request.
    ChunkDataRequest chunkDataRequest{};
    for (int i{0}; i < currentExtent.zLength; ++i) {
        for (int j{0}; j < currentExtent.yLength; ++j) {
            for (int k{0}; k < currentExtent.xLength; ++k) {
                int chunkX{currentExtent.x + k};
                int chunkY{currentExtent.y + j};
                int chunkZ{currentExtent.z + i};
                chunkDataRequest.requestedChunks.emplace_back(chunkX, chunkY,
                                                              chunkZ);
            }
        }
    }

    // Send the request.
    network.serializeAndSend(chunkDataRequest);
}

void ChunkUpdateSystem::requestNewInRangeChunks(
    const ChunkPosition& previousChunk, const ChunkPosition& currentChunk)
{
    // Determine which chunks are in range of each chunk position.
    // Note: The range is hardcoded to be all chunks directly surrounding the 
    //       given chunk in the X/Y directions, and every chunk in the Z 
    //       direction.
    const ChunkExtent& mapChunkExtent{world.tileMap.getChunkExtent()};
    ChunkExtent previousExtent{
        (previousChunk.x - 1), (previousChunk.y - 1), 0, 3, 3,
        mapChunkExtent.zLength};
    ChunkExtent currentExtent{
        (currentChunk.x - 1),  (currentChunk.y - 1), 0, 3, 3,
        mapChunkExtent.zLength};

    // Bound each range to the map boundaries.
    previousExtent = previousExtent.intersectWith(mapChunkExtent);
    currentExtent = currentExtent.intersectWith(mapChunkExtent);

    // Iterate over the current extent, adding any new chunks to a request.
    ChunkDataRequest chunkDataRequest;
    for (int z{0}; z < currentExtent.zLength; ++z) {
        for (int y{0}; y < currentExtent.yLength; ++y) {
            for (int x{0}; x < currentExtent.xLength; ++x) {
                // If this chunk isn't in range of the previous chunk, add it.
                ChunkPosition chunkPosition{currentExtent.x + x,
                                            currentExtent.y + y,
                                            currentExtent.z + z};

                if (!(previousExtent.contains(chunkPosition))) {
                    chunkDataRequest.requestedChunks.emplace_back(
                        chunkPosition.x, chunkPosition.y, chunkPosition.z);
                }
            }
        }
    }

    // Send the request.
    network.serializeAndSend(chunkDataRequest);
}

void ChunkUpdateSystem::receiveAndApplyUpdates()
{
    // Disable auto collision rebuild (it's more efficient to do it all after).
    world.tileMap.setAutoRebuildCollision(false);

    // Process any received chunk updates.
    std::shared_ptr<const ChunkUpdate> receivedUpdate{nullptr};
    while (chunkUpdateQueue.pop(receivedUpdate)) {
        // Apply all chunk snapshots from the update to our map.
        for (const ChunkWireSnapshot& chunk : receivedUpdate->chunks) {
            applyChunkSnapshot(chunk);
        }
    }

    // Re-enable auto collision rebuild (rebuilds any dirty tiles).
    world.tileMap.setAutoRebuildCollision(true);
}

void ChunkUpdateSystem::applyChunkSnapshot(
    const ChunkWireSnapshot& chunkSnapshot)
{
    // Load the chunk snapshot into our map.
    world.tileMap.loadChunk(
        chunkSnapshot, {chunkSnapshot.x, chunkSnapshot.y, chunkSnapshot.z});
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Private/ComponentUpdateSystem.cpp`:

```cpp
#include "ComponentUpdateSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "Network.h"
#include "GraphicData.h"
#include "Position.h"
#include "Collision.h"
#include "ClientGraphicState.h"
#include "IsClientEntity.h"
#include "Transforms.h"
#include "Log.h"

namespace AM
{
namespace Client
{

ComponentUpdateSystem::ComponentUpdateSystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, graphicData{inSimContext.graphicData}
, componentUpdateQueue{inSimContext.networkEventDispatcher}
{
    world.registry.on_update<GraphicState>()
        .connect<&ComponentUpdateSystem::onGraphicStateUpdated>(this);
    world.registry.on_update<CollisionBitSets>()
        .connect<&ComponentUpdateSystem::onCollisionBitSetsUpdated>(this);
}

ComponentUpdateSystem::~ComponentUpdateSystem()
{
    world.registry.on_update<GraphicState>()
        .disconnect<&ComponentUpdateSystem::onGraphicStateUpdated>(this);
    world.registry.on_update<CollisionBitSets>()
        .disconnect<&ComponentUpdateSystem::onCollisionBitSetsUpdated>(this);
}

void ComponentUpdateSystem::processUpdates()
{
    // We want to process updates until we've either processed the desired
    // tick, or have run out of data.
    // Note: If a component update needs to be resolved against local predicted
    //       state, that component update needs to be intercepted before it gets
    //       here. Otherwise, it will be auto-applied over your predicted state.
    Uint32 desiredTick{simulation.getReplicationTick()};

    // Immediately process any player entity messages, push the rest into a
    // secondary queue.
    {
        ComponentUpdate componentUpdate{};
        while (componentUpdateQueue.pop(componentUpdate)) {
            if (componentUpdate.entity == world.playerEntity) {
                processComponentUpdate(componentUpdate);
            }
            else {
                componentUpdateSecondaryQueue.push(componentUpdate);
            }
        }
    }

    // Process all messages in the secondary queue.
    while (!(componentUpdateSecondaryQueue.empty())) {
        ComponentUpdate& componentUpdate{componentUpdateSecondaryQueue.front()};

        // If we've reached the desired tick, save the rest of the messages for
        // later.
        if (componentUpdate.tickNum > desiredTick) {
            break;
        }

        // Process the message.
        processComponentUpdate(componentUpdate);

        componentUpdateSecondaryQueue.pop();
    }
}

void ComponentUpdateSystem::processComponentUpdate(
    const ComponentUpdate& componentUpdate)
{
    entt::registry& registry{world.registry};

    // Construct or update any updated components.
    for (const auto& componentVariant : componentUpdate.updatedComponents) {
        std::visit(
            [&](const auto& component) {
                using T = std::decay_t<decltype(component)>;
                registry.emplace_or_replace<T>(componentUpdate.entity,
                                               component);
            },
            componentVariant);
    }

    // Destroy any destroyed components.
    // Note: We use remove instead of erase, since it's possible to receive a 
    //       destroy message without ever receiving a construct message (the 
    //       component was constructed and destroyed on the same tick).
    for (Uint8 componentIndex : componentUpdate.destroyedComponents) {
        boost::mp11::mp_with_index<
            boost::mp11::mp_size<ReplicatedComponentTypes>>(
            componentIndex, [&](auto I) {
                using ComponentType
                    = boost::mp11::mp_at_c<ReplicatedComponentTypes, I>;
                registry.remove<ComponentType>(componentUpdate.entity);
            });
    }
}

void ComponentUpdateSystem::onGraphicStateUpdated(entt::registry& registry,
                                                  entt::entity entity)
{
    // Since the graphic state was updated, we need to update the entity's
    // collision.
    auto [position, graphicState, clientGraphicState]
        = registry.get<Position, GraphicState, ClientGraphicState>(entity);
    const EntityGraphicSet& graphicSet{
        graphicData.getEntityGraphicSet(graphicState.graphicSetID)};

    // Note: We assume that an entity with GraphicState always has a
    //       Collision and CollisionBitSets.
    const BoundingBox& modelBounds{graphicSet.getCollisionModelBounds()};
    const Collision& collision{
        registry.patch<Collision>(entity, [&](Collision& collision) {
            collision.modelBounds = modelBounds;
            collision.worldBounds
                = Transforms::modelToWorldEntity(modelBounds, position);
        })};

    // Update their collision in the locator.
    const CollisionBitSets& collisionBitSets{
        registry.get<CollisionBitSets>(entity)};
    world.collisionLocator.updateEntity(entity, collision.worldBounds,
                                        collisionBitSets.getCollisionLayers());

    // Default the entity's current graphic type to Idle South since it 
    // always must be valid and we don't know if the new graphic set has 
    // the old type.
    // GraphicSystem will set it to a real value the next time it runs.
    clientGraphicState.graphicType = EntityGraphicType::Idle;
    clientGraphicState.graphicDirection = Rotation::Direction::South;
}

void ComponentUpdateSystem::onCollisionBitSetsUpdated(entt::registry& registry,
                                                      entt::entity entity)
{
    // Note: We assume that an entity with a CollisionBitSets always has a 
    //       Collision.
    const auto [collision, collisionBitSets]
        = registry.get<Collision, CollisionBitSets>(entity);
    world.collisionLocator.updateEntity(entity, collision.worldBounds,
                                        collisionBitSets.getCollisionLayers());
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Private/EntityLifetimeSystem.cpp`:

```cpp
#include "EntityLifetimeSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "Network.h"
#include "GraphicData.h"
#include "Name.h"
#include "PreviousPosition.h"
#include "Movement.h"
#include "MovementModifiers.h"
#include "Collision.h"
#include "UserConfig.h"
#include "Camera.h"
#include "Inventory.h"
#include "InputHistory.h"
#include "NeedsAdjacentChunks.h"
#include "ClientGraphicState.h"
#include "GraphicState.h"
#include "SDLHelpers.h"
#include "Transforms.h"
#include "MovementHelpers.h"
#include "Config.h"
#include "entt/entity/registry.hpp"
#include <variant>
#include <string_view>

namespace AM
{
namespace Client
{

EntityLifetimeSystem::EntityLifetimeSystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, graphicData{inSimContext.graphicData}
, entityInitSecondaryQueue{}
, entityInitQueue{inSimContext.networkEventDispatcher}
, entityDeleteQueue{inSimContext.networkEventDispatcher}
{
}

void EntityLifetimeSystem::processUpdates()
{
    // We want to process updates until we've either processed the desired
    // tick, or have run out of data.
    Uint32 desiredTick{simulation.getReplicationTick()};

    // Process any waiting EntityDelete messages, up to desiredTick.
    processEntityDeletes(desiredTick);

    // Process any waiting init messages, up to desiredTick.
    processEntityInits(desiredTick);
}

void EntityLifetimeSystem::processEntityDeletes(Uint32 desiredTick)
{
    entt::registry& registry{world.registry};

    // Delete the entities that left our AOI on this tick (or previous ticks).
    EntityDelete* entityDelete{entityDeleteQueue.peek()};
    while ((entityDelete != nullptr)
           && (entityDelete->tickNum <= desiredTick)) {
        if (registry.valid(entityDelete->entity)) {
            world.entityLocator.removeEntity(entityDelete->entity);
            world.collisionLocator.removeEntity(entityDelete->entity);
            registry.destroy(entityDelete->entity);

            LOG_INFO("Entity removed: %u. Desired tick: %u, Message tick: %u",
                     entityDelete->entity, desiredTick, entityDelete->tickNum);
        }
        else {
            LOG_FATAL("Asked to delete invalid entity: %u",
                      entityDelete->entity);
        }

        entityDeleteQueue.pop();
        entityDelete = entityDeleteQueue.peek();
    }
}

void EntityLifetimeSystem::processEntityInits(Uint32 desiredTick)
{
    // Immediately process any player entity messages, push the rest into a
    // secondary queue.
    {
        EntityInit entityInit{};
        while (entityInitQueue.pop(entityInit)) {
            // If the player entity is present, process it and erase it from
            // the message.
            for (auto it{entityInit.entityData.begin()};
                 it != entityInit.entityData.end();) {
                if (it->entity == world.playerEntity) {
                    processEntityData(entityInit.tickNum, *it);
                    it = entityInit.entityData.erase(it);
                }
                else {
                    ++it;
                }
            }

            // If there are NPC entities remaining in the message, push it.
            if (entityInit.entityData.size() > 0) {
                entityInitSecondaryQueue.push(entityInit);
            }
        }
    }

    // Process all messages in the secondary queue.
    while (!(entityInitSecondaryQueue.empty())) {
        EntityInit& entityInit{entityInitSecondaryQueue.front()};

        // If we've reached the desired tick, save the rest of the messages for
        // later.
        if (entityInit.tickNum > desiredTick) {
            break;
        }

        // Process the message.
        for (const EntityInit::EntityData& entityData : entityInit.entityData) {
            processEntityData(entityInit.tickNum, entityData);
        }

        entityInitSecondaryQueue.pop();
    }
}

void EntityLifetimeSystem::processEntityData(
    Uint32 tickNum, const EntityInit::EntityData& entityData)
{
    entt::registry& registry{world.registry};

    // Create the entity.
    entt::entity newEntity{registry.create(entityData.entity)};
    if (newEntity != entityData.entity) {
        LOG_FATAL("Created entity ID doesn't match received entity ID. "
                  "Created: %u, received: %u",
                  newEntity, entityData.entity);
    }

    // All entities have a position.
    registry.emplace<Position>(newEntity, entityData.position);
    world.entityLocator.updateEntity(newEntity, entityData.position);

    // Add any replicated components that the server sent.
    for (const ReplicatedComponent& componentVariant : entityData.components) {
        std::visit(
            [&](const auto& component) {
                using T = std::decay_t<decltype(component)>;
                registry.emplace<T>(newEntity, component);
            },
            componentVariant);
    }

    // Add any client-only or non-replicated components.
    // Note: Be careful with holding onto references here. If components
    //       are added to the same group, the ref will be invalidated.

    // Entities with an Input are capable of movement, so we add a
    // PreviousPosition. They'll also have an auto-replicated Movement,
    // MovementModifiers, and Rotation.
    if (registry.all_of<Input>(newEntity)) {
        const Position& position{registry.get<Position>(newEntity)};
        registry.emplace<PreviousPosition>(newEntity, position);
    }

    // When entities have a GraphicState, the server gives them a Collision.
    // It isn't replicated, so we add it manually.
    if (const auto* graphicState{registry.try_get<GraphicState>(newEntity)}) {
        // Note: Entity collision always comes from its Idle South graphic.
        const EntityGraphicSet& graphicSet{
            graphicData.getEntityGraphicSet(graphicState->graphicSetID)};

        // Add the Collision.
        const BoundingBox& modelBounds{graphicSet.getCollisionModelBounds()};
        const Position& position{registry.get<Position>(newEntity)};
        const Collision& collision{registry.emplace<Collision>(
            newEntity, modelBounds,
            Transforms::modelToWorldEntity(modelBounds, position))};

        // Entities with Collision get added to the locator.
        // Note: We assume that an entity with GraphicState always has a
        //       Collision and CollisionBitSets.
        const CollisionBitSets& collisionBitSets{
            registry.get<CollisionBitSets>(newEntity)};
        world.collisionLocator.updateEntity(
            newEntity, collision.worldBounds,
            collisionBitSets.getCollisionLayers());

        // Entities with GraphicState also get a ClientGraphicState.
        // Set it to match the entity's Rotation, or South if it has none.
        Rotation::Direction graphicDirection{Rotation::Direction::South};
        if (const auto* rotation{registry.try_get<Rotation>(newEntity)}) {
            graphicDirection = rotation->direction;
        }
        registry.emplace<ClientGraphicState>(newEntity, EntityGraphicType::Idle,
                                             graphicDirection);
    }

    // If this is the player entity, add any client components specific to it.
    if (newEntity == world.playerEntity) {
        finishPlayerEntity();
        LOG_INFO("Player entity added: %u. Message tick: %u", newEntity,
                 tickNum);
    }
    else {
        LOG_INFO("Peer entity added: %u. Message tick: %u", newEntity, tickNum);
    }
}

void EntityLifetimeSystem::finishPlayerEntity()
{
    entt::registry& registry{world.registry};
    entt::entity playerEntity{world.playerEntity};

    // TODO: Switch to logical screen size and do scaling in Renderer.
    UserConfig& userConfig{UserConfig::get()};
    const Position& position{registry.get<Position>(playerEntity)};
    registry.emplace<Camera>(
        playerEntity, Camera::CenterOnEntity, position,
        PreviousPosition{position}, BoundingBox{},
        SDLHelpers::rectToFRect(userConfig.getWindowSize()));

    registry.emplace<Inventory>(playerEntity);
    registry.emplace<InputHistory>(playerEntity);

    // Flag that we need to request all map data.
    registry.emplace<NeedsAdjacentChunks>(playerEntity);
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Private/GraphicData/GraphicData.cpp`:

```cpp
#include "GraphicData.h"
#include "AssetCache.h"
#include "SpriteID.h"
#include "Config.h"
#include "Paths.h"
#include "Log.h"
#include "nlohmann/json.hpp"

namespace AM
{
namespace Client
{
GraphicData::GraphicData(const nlohmann::json& resourceDataJson,
                       AssetCache& assetCache)
: GraphicDataBase(resourceDataJson)
{
    // Parse the json structure to construct our sprite render data.
    parseJson(resourceDataJson, assetCache);
}

const SpriteRenderData&
    GraphicData::getSpriteRenderData(SpriteID numericID) const
{
    if (numericID >= spriteRenderData.size()) {
        LOG_ERROR("Invalid numeric ID while getting sprite render data: %d",
                  numericID);
        return spriteRenderData[0];
    }

    return spriteRenderData[numericID];
}

const AnimationRenderData&
    GraphicData::getAnimationRenderData(AnimationID numericID) const
{
    if (numericID >= animationRenderData.size()) {
        LOG_ERROR("Invalid numeric ID while getting animation render data: %d",
                  numericID);
        return animationRenderData[0];
    }

    return animationRenderData[numericID];
}

void GraphicData::parseJson(const nlohmann::json& json, AssetCache& assetCache)
{
    // Add the null sprite.
    spriteRenderData.emplace_back();

    // Parse the json and catch any parsing errors.
    try {
        // Resize our vectors.
        spriteRenderData.resize(sprites.size());
        animationRenderData.resize(animations.size());

        // Parse every sprite sheet in the json.
        std::string texturePath{};
        for (auto& sheetJson : json["spriteSheets"].items()) {
            // Get this sheet's texture.
            texturePath = Paths::TEXTURE_DIR;
            texturePath += "SpriteSheets/";
            texturePath += sheetJson.value()["displayName"].get<std::string>();
            texturePath += ".png";

            TextureHandle texture{};
            texture = assetCache.requestTexture(
                texturePath, Config::SPRITE_SCALING_QUALITY);
            if (!texture) {
                // Note: requestTexture will LOG_ERROR if the file isn't found.
                continue;
            }

            // Parse every sprite in this sheet.
            for (auto& spriteJson : sheetJson.value()["sprites"].items()) {
                parseSprite(spriteJson.value(), texturePath, texture);
            }
        }
        
        // Parse every animation in the json.
        for (auto& animationJson : json["animations"].items()) {
            parseAnimation(animationJson.value());
        }
    } catch (nlohmann::json::type_error& e) {
        LOG_FATAL(
            "Failed to parse sprites and sprite sets in ResourceData.json: %s",
            e.what());
    }
}

void GraphicData::parseSprite(const nlohmann::json& spriteJson,
                              const std::string& spriteSheetRelPath,
                              const TextureHandle& texture)
{
    // Get the numeric identifier.
    SpriteID numericID{spriteJson.at("numericID")};

    // Add the parent sprite sheet's path and texture.
    SpriteRenderData& renderData{spriteRenderData[numericID]};
    renderData.spriteSheetRelPath = spriteSheetRelPath;
    renderData.texture = texture;

    // Add this sprite's extent within the sprite sheet.
    renderData.textureExtent.x = spriteJson.at("textureExtent").at("x");
    renderData.textureExtent.y = spriteJson.at("textureExtent").at("y");
    renderData.textureExtent.w = spriteJson.at("textureExtent").at("w");
    renderData.textureExtent.h = spriteJson.at("textureExtent").at("h");

    // Add the stage origin.
    renderData.stageOrigin.x = spriteJson.at("stageX");
    renderData.stageOrigin.y = spriteJson.at("stageY");

    // Add the premultiply alpha setting.
    renderData.premultiplyAlpha = spriteJson.at("premultiplyAlpha");
}

void GraphicData::parseAnimation(const nlohmann::json& animationJson)
{
    // Get the numeric identifier.
    AnimationID numericID{animationJson.at("numericID")};

    // Add the entity alignment anchor.
    AnimationRenderData& renderData{animationRenderData[numericID]};
    if (animationJson.contains("entityAlignmentAnchor")) {
        renderData.entityAlignmentAnchor
            = {animationJson.at("entityAlignmentAnchor").at("x"),
               animationJson.at("entityAlignmentAnchor").at("y"),
               animationJson.at("entityAlignmentAnchor").at("z")};
    }
}

Vector3
    GraphicData::getRenderAlignmentOffset(EntityGraphicSetID setID,
                                          EntityGraphicType graphicType,
                                          Rotation::Direction direction) const
{
    const EntityGraphicSet& graphicSet{getEntityGraphicSet(setID)};
    if (!(graphicSet.graphics.contains(EntityGraphicType::Idle))) {
        LOG_ERROR("Entity graphic set is missing Idle: %s.",
                  graphicSet.displayName.c_str());
        return {};
    }
    if (!(graphicSet.graphics.contains(graphicType))) {
        LOG_ERROR("Entity graphic set is missing requested type: %s, %u.",
                  graphicSet.displayName.c_str(), graphicType);
        return {};
    }

    // If the requested graphic is a Sprite, return 0 (sprites don't have 
    // alignment anchors).
    const auto& graphicArr{graphicSet.graphics.at(graphicType)};
    const GraphicRef& graphicRef{graphicArr.at(direction)};
    if (std::holds_alternative<std::reference_wrapper<const Sprite>>(
            graphicRef)) {
        return {};
    }

    // If the requested Animation doesn't have an alignment anchor, return 0.
    const auto& animation{
        std::get<std::reference_wrapper<const Animation>>(graphicRef)};
    const AnimationRenderData& renderData{
        getAnimationRenderData(animation.get().numericID)};
    if (!(renderData.entityAlignmentAnchor)) {
        return {};
    }

    // Return the difference between the Idle South graphic's bottom center and 
    // the requested animation's alignment anchor.
    const auto& idleGraphicArr{graphicSet.graphics.at(EntityGraphicType::Idle)};
    Vector3 idleSouthBottomCenter{idleGraphicArr.at(Rotation::Direction::South)
                                      .getModelBounds()
                                      .getBottomCenterPoint()};
    Vector3 alignmentAnchor{renderData.entityAlignmentAnchor.value()};
    return (idleSouthBottomCenter - alignmentAnchor);
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Private/GraphicHelpers.cpp`:

```cpp
#include "GraphicHelpers.h"

namespace AM
{
namespace Client
{

GraphicHelpers::GraphicReturn GraphicHelpers::getGraphicOrFallback(
    const EntityGraphicSet& graphicSet, EntityGraphicType currentType,
    Rotation::Direction currentDirection, EntityGraphicType desiredType,
    Rotation::Direction desiredDirection)
{
    // If the graphic set contains the desired graphic, use it.
    if (graphicSet.contains(desiredType, desiredDirection)) {
        return {desiredType, desiredDirection};
    }

    // The set doesn't have the desired graphic. Find the closest match.

    // #### Ordinal Strafing ####
    // If the new rotation is an ordinal direction and the current direction 
    // includes that direction, don't change it.
    // This will cause a "strafe" effect when moving ordinally, if the 
    // ordinal graphics are missing but the cardinal are present.
    bool isDesiredSW{(desiredDirection == Rotation::Direction::SouthWest)};
    bool isDesiredNW{(desiredDirection == Rotation::Direction::NorthWest)};
    bool isDesiredNE{(desiredDirection == Rotation::Direction::NorthEast)};
    bool isDesiredSE{(desiredDirection == Rotation::Direction::SouthEast)};
    bool isCurrentSouth{currentDirection == Rotation::Direction::South};
    bool isCurrentWest{currentDirection == Rotation::Direction::West};
    bool isCurrentNorth{currentDirection == Rotation::Direction::North};
    bool isCurrentEast{currentDirection == Rotation::Direction::East};
    if ((isDesiredSW && (isCurrentSouth || isCurrentWest))
        || (isDesiredNW && (isCurrentNorth || isCurrentWest))
        || (isDesiredNE && (isCurrentNorth || isCurrentEast))
        || (isDesiredSE && (isCurrentSouth || isCurrentEast))) {
        // Try to use the current graphic. Otherwise, fall back to the Idle 
        // graphic (the graphic set may have changed).
        if (graphicSet.contains(currentType, currentDirection)) {
            return {currentType, currentDirection};
        }
        else if (graphicSet.contains(EntityGraphicType::Idle,
                                     currentDirection)) {
            return {EntityGraphicType::Idle, currentDirection};
        }
    }

    // #### Ordinal -> Cardinal ####
    // If the new rotation is an ordinal direction, try to use a cardinal 
    // direction. 
    if ((isDesiredSW || isDesiredSE)
        && graphicSet.contains(desiredType, Rotation::Direction::South)) {
        return {desiredType, Rotation::Direction::South};
    }
    else if ((isDesiredNW || isDesiredNE)
             && graphicSet.contains(desiredType, Rotation::Direction::North)) {
        return {desiredType, Rotation::Direction::North};
    }

    // #### Idle With Desired Direction ####
    // If the graphic set contains an Idle graphic for the desired direction, 
    // use it.
    if (graphicSet.contains(EntityGraphicType::Idle, desiredDirection)) {
        return {EntityGraphicType::Idle, desiredDirection};
    }

    // #### Idle With Ordinal -> Cardinal ####
    // If the new rotation is an ordinal direction, try to use a cardinal 
    // direction with an Idle graphic.
    if ((isDesiredSW || isDesiredSE)
        && graphicSet.contains(EntityGraphicType::Idle,
                               Rotation::Direction::South)) {
        return {EntityGraphicType::Idle, Rotation::Direction::South};
    }
    else if ((isDesiredNW || isDesiredNE)
             && graphicSet.contains(EntityGraphicType::Idle,
                                    Rotation::Direction::North)) {
        return {EntityGraphicType::Idle, Rotation::Direction::North};
    }

    // #### Default: Idle South ####
    return {EntityGraphicType::Idle, Rotation::Direction::South};
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Private/GraphicSystem.cpp`:

```cpp
#include "GraphicSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "GraphicData.h"
#include "ISimulationExtension.h"
#include "Rotation.h"
#include "GraphicState.h"
#include "ClientGraphicState.h"
#include "Input.h"
#include "ClientCastState.h"
#include "GraphicHelpers.h"
#include "Log.h"
#include "AMAssert.h"

namespace AM
{
namespace Client
{

GraphicSystem::GraphicSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, graphicData{inSimContext.graphicData}
, extension{nullptr}
{
}

void GraphicSystem::updateAnimations()
{
    // Update all entity sprites to match their current rotation.
    // Note: This iterates static entities, even though most don't change state
    //       very often. If this becomes a performance issue, we can revisit.
    auto view{world.registry.view<Rotation, GraphicState, ClientGraphicState>()};
    for (auto [entity, rotation, graphicState, clientGraphicState] :
         view.each()) {
        // Give the project a chance to update the graphic type.
        EntityGraphicType graphicType{
            extension->getUpdatedGraphicType(entity)};
        if (graphicType != EntityGraphicType::NotSet) {
            clientGraphicState.graphicType = graphicType;
            clientGraphicState.setStartTime = true;
            continue;
        }

        // Determine which graphic type is desired, based on the current 
        // entity state.
        EntityGraphicType desiredGraphicType{getDesiredGraphicType(entity)};

        // Get the new graphic, accounting for missing graphics in the set.
        const EntityGraphicSet& graphicSet{
            graphicData.getEntityGraphicSet(graphicState.graphicSetID)};
        GraphicHelpers::GraphicReturn newGraphic{
            GraphicHelpers::getGraphicOrFallback(
                graphicSet, clientGraphicState.graphicType,
                clientGraphicState.graphicDirection, desiredGraphicType,
                rotation.direction)};

        // If the graphic has changed, update the component.
        if (newGraphic.type != clientGraphicState.graphicType) {
            clientGraphicState.graphicType = newGraphic.type;
            clientGraphicState.setStartTime = true;
        }
        if (newGraphic.direction != clientGraphicState.graphicDirection) {
            clientGraphicState.graphicDirection = newGraphic.direction;
            // Note: We don't reset the animation time, since we want e.g. 
            //       a run animation to play smoothly when changing direction.
        }
    }
}

void GraphicSystem::setExtension(ISimulationExtension* inExtension)
{
    extension = std::move(inExtension);
}

EntityGraphicType GraphicSystem::getDesiredGraphicType(entt::entity entity)
{
    // If the entity is moving, use a run graphic.
    if (const Input* input{world.registry.try_get<Input>(entity)};
        input && input->inputStates.any()) {
        return EntityGraphicType::Run;
    }
    // If the entity is casting, use the appropriate graphic from the 
    // Castable.
    else if (const auto* castState{
                 world.registry.try_get<ClientCastState>(entity)}) {
        if (castState->state == ClientCastState::State::Casting) {
            return castState->castInfo.castable->castingGraphicType;
        }
        else {
            // CastComplete
            return castState->castInfo.castable->castCompleteGraphicType;
        }
    }

    // Default: Use an idle graphic.
    return EntityGraphicType::Idle;
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Private/IconData/IconData.cpp`:

```cpp
#include "IconData.h"
#include "StringTools.h"
#include "Paths.h"
#include "Log.h"
#include "nlohmann/json.hpp"

namespace
{
/** A scratch buffer used while processing string IDs.
    Must be file-local so it can be accessed by const functions. */
std::string workStringID{};
}

namespace AM
{
namespace Client
{
IconData::IconData(const nlohmann::json& resourceDataJson)
: IconDataBase(resourceDataJson)
{
    // Parse the json structure to construct our icon render data.
    parseJson(resourceDataJson);
}

const IconRenderData& IconData::getRenderData(std::string_view stringID) const
{
    const Icon& icon{getIcon(stringID)};
    return getRenderData(icon.numericID);
}

const IconRenderData& IconData::getRenderData(IconID numericID) const
{
    if (numericID >= renderData.size()) {
        LOG_FATAL("Invalid numeric ID while getting icon render data: %d",
                  numericID);
    }

    return renderData[numericID];
}

void IconData::parseJson(const nlohmann::json& json)
{
    // Parse the json and catch any parsing errors.
    try {
        // Add the null icon, giving it our engine-default texture.
        renderData.emplace_back(Paths::TEXTURE_DIR + "Defaults/Icon.png",
                                SDL_Rect{0, 0, 64, 64});

        // Parse every icon sheet in the json.
        for (auto& sheetJson : json["iconSheets"].items()) {
            // Get this sheet's texture path.
            std::string texturePath{Paths::TEXTURE_DIR};
            texturePath += sheetJson.value()["relPath"].get<std::string>();

            // Parse every icon in this sheet.
            for (auto& iconJson : sheetJson.value()["icons"].items()) {
                parseIcon(iconJson.value(), texturePath);
            }
        }
    } catch (nlohmann::json::type_error& e) {
        LOG_FATAL("Failed to parse icon sheets in ResourceData.json: %s",
                  e.what());
    }
}

void IconData::parseIcon(const nlohmann::json& iconJson,
                         const std::string& iconSheetRelPath)
{
    // Add the render data to the renderData vector.
    IconRenderData& iconRenderData{renderData.emplace_back()};

    // Add the parent icon sheet's path and texture.
    iconRenderData.iconSheetRelPath = iconSheetRelPath;

    // Add this icon's extent within the icon sheet.
    iconRenderData.textureExtent.x = iconJson.at("textureExtent").at("x");
    iconRenderData.textureExtent.y = iconJson.at("textureExtent").at("y");
    iconRenderData.textureExtent.w = iconJson.at("textureExtent").at("w");
    iconRenderData.textureExtent.h = iconJson.at("textureExtent").at("h");
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Private/InventorySystem.cpp`:

```cpp
#include "InventorySystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "ItemData.h"
#include "Inventory.h"
#include "ItemDataRequest.h"
#include "AMAssert.h"
#include "Log.h"
#include <algorithm>

namespace AM
{
namespace Client
{
InventorySystem::InventorySystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, itemData{inSimContext.itemData}
, inventoryInitQueue{inSimContext.networkEventDispatcher}
, inventoryOperationQueue{inSimContext.networkEventDispatcher}
{
}

void InventorySystem::processInventoryUpdates()
{
    // Process any waiting inventory messages.
    InventoryInit inventoryInit{};
    while (inventoryInitQueue.pop(inventoryInit)) {
        initInventory(inventoryInit);
    }

    InventoryOperation inventoryOperation{};
    while (inventoryOperationQueue.pop(inventoryOperation)) {
        std::visit(
            [this](const auto& operation) { processOperation(operation); },
            inventoryOperation.operation);
    }
}

void InventorySystem::initInventory(const InventoryInit& inventoryInit)
{
    // Initialize the player's inventory with the given items.
    world.registry.patch<Inventory>(
        world.playerEntity, [&](Inventory& inventory) {
            // Init the inventory's size.
            inventory.resize(inventoryInit.size);

            // Add all the given items to the player's inventory.
            std::vector<ItemID> itemsToRequest{};
            for (std::size_t i{0}; i < inventoryInit.slots.size(); ++i) {
                const InventoryInit::ItemSlot& itemSlot{inventoryInit.slots[i]};
                inventory.slots[i].ID = itemSlot.ID;
                inventory.slots[i].count = itemSlot.count;

                // If this slot is non-empty and we don't have the latest 
                // definition for the item in it, add it to the vector.
                if (itemSlot.ID
                    && (!(itemData.getItem(itemSlot.ID))
                        || (itemData.getItemVersion(itemSlot.ID)
                            < itemSlot.version))) {
                    itemsToRequest.push_back(itemSlot.ID);
                }
            }

            // Remove duplicates from the vector.
            std::sort(itemsToRequest.begin(), itemsToRequest.end());
            itemsToRequest.erase(
                std::unique(itemsToRequest.begin(), itemsToRequest.end()),
                itemsToRequest.end());

            // Request definitions for any out-of-date items.
            for (ItemID itemID : itemsToRequest) {
                network.serializeAndSend(ItemDataRequest{itemID});
            }
        });
}

void InventorySystem::processOperation(const InventoryAddItem& inventoryAddItem)
{
    // Try to add the item.
    world.registry.patch<Inventory>(
        world.playerEntity, [&](Inventory& inventory) {
            ItemID itemID{inventoryAddItem.itemID};
            if (inventory.addItem(itemID, inventoryAddItem.count,
                                  inventoryAddItem.maxStackSize)) {
                // Successfully added. If we don't have the latest definition
                // for the item, request it.
                ItemVersion itemVersion{inventoryAddItem.version};
                if (!(itemData.getItem(itemID))
                    || (itemData.getItemVersion(itemID) < itemVersion)) {
                    network.serializeAndSend(ItemDataRequest{itemID});
                }
            }
        });
}

void InventorySystem::processOperation(
    const InventoryRemoveItem& inventoryRemoveItem)
{
    // Try to delete the item.
    world.registry.patch<Inventory>(
        world.playerEntity, [&](Inventory& inventory) {
            inventory.removeItem(inventoryRemoveItem.slotIndex,
                                 inventoryRemoveItem.count);
        });
}

void InventorySystem::processOperation(
    const InventoryMoveItem& inventoryMoveItem)
{
    // Try to move the item(s).
    world.registry.patch<Inventory>(
        world.playerEntity, [&](Inventory& inventory) {
            inventory.moveItem(inventoryMoveItem.sourceSlotIndex,
                               inventoryMoveItem.destSlotIndex);
        });
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Private/ItemData/ItemData.cpp`:

```cpp
#include "ItemData.h"
#include "Log.h"

namespace AM
{
namespace Client
{
ItemData::ItemData()
: ItemDataBase()
{
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Private/ItemSystem.cpp`:

```cpp
#include "ItemSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "Network.h"
#include "ItemData.h"
#include "Inventory.h"
#include "ItemDataRequest.h"
#include "ItemCache.h"
#include "Serialize.h"
#include "Deserialize.h"
#include "StringTools.h"
#include "Paths.h"
#include "Log.h"
#include <filesystem>

namespace AM
{
namespace Client
{
ItemSystem::ItemSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, itemData{inSimContext.itemData}
, itemUpdateQueue{inSimContext.networkEventDispatcher}
, combineItemsQueue{inSimContext.networkEventDispatcher}
{
    // Load all items from ItemCache.bin into ItemData.
    // Note: We need to check that the items aren't already loaded, since this 
    //       system will be re-constructed by Simulation when we disconnect.
    if (itemData.getAllItems().empty()) {
        loadItemCache();
    }

    // When an item is created or updated, save it to the cache.
    itemData.itemCreated.connect<&ItemSystem::saveItemCache>(this);
    itemData.itemUpdated.connect<&ItemSystem::saveItemCache>(this);
}

ItemSystem::~ItemSystem()
{
    itemData.itemCreated.disconnect<&ItemSystem::saveItemCache>(this);
    itemData.itemUpdated.disconnect<&ItemSystem::saveItemCache>(this);
}

void ItemSystem::processItemUpdates()
{
    // Process any waiting item definition updates.
    ItemUpdate itemUpdate{};
    while (itemUpdateQueue.pop(itemUpdate)) {
        // Load the given item definition into ItemData, overwriting any 
        // existing item if present.
        Item item{.displayName = itemUpdate.displayName,
                  .stringID = itemUpdate.stringID,
                  .numericID = itemUpdate.numericID,
                  .iconID = itemUpdate.iconID,
                  .maxStackSize = itemUpdate.maxStackSize,
                  .supportedInteractions = itemUpdate.supportedInteractions};
        itemData.loadItem(item, itemUpdate.version);
    }

    // Process any waiting item combinations.
    CombineItems combineItems{};
    while (combineItemsQueue.pop(combineItems)) {
        world.registry.patch<Inventory>(
            world.playerEntity, [&](Inventory& inventory) {
                inventory.combineItems(combineItems.sourceSlotIndex,
                                       combineItems.targetSlotIndex,
                                       combineItems.resultItemID,
                                       combineItems.resultItemMaxStackSize);
            });

        // If we don't have the latest definition for the new item, request
        // it.
        ItemID resultItemID{combineItems.resultItemID};
        if (!(itemData.getItem(resultItemID))
            || (itemData.getItemVersion(resultItemID)
                < combineItems.resultItemVersion)) {
            network.serializeAndSend(ItemDataRequest{resultItemID});
        }
    }
}

void ItemSystem::loadItemCache()
{
    // If the cache doesn't exist, return early.
    std::string cachePath{Paths::BASE_PATH + "ItemCache.bin"};
    if (!std::filesystem::exists(cachePath)) {
        return;
    }

    // Deserialize the item cache.
    ItemCache itemCache{};
    bool loadSuccessful{Deserialize::fromFile(cachePath, itemCache)};
    if (!loadSuccessful) {
        LOG_FATAL("Failed to deserialize item cache at path: %s",
                  cachePath.c_str());
    }

    // Push all cached items into ItemData.
    for (const ItemCache::ItemEntry& itemEntry : itemCache.items) {
        itemData.loadItem(itemEntry.item, itemEntry.version);
    }
}

void ItemSystem::saveItemCache()
{
    // Gather all items from ItemData.
    ItemCache itemCache{};
    const auto& items{itemData.getAllItems()};
    itemCache.items.resize(items.size());

    int index{0};
    for (auto& [itemID, item] : items) {
        itemCache.items[index] = {item, itemData.getItemVersion(itemID)};
        index++;
    }

    // Serialize the item cache and write it into a file.
    bool saveSuccessful{
        Serialize::toFile((Paths::BASE_PATH + "ItemCache.bin"), itemCache)};
    if (!saveSuccessful) {
        LOG_FATAL("Failed to serialize and save the item cache.");
    }
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Private/NpcMovementSystem.cpp`:

```cpp
#include "NpcMovementSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "Network.h"
#include "MovementHelpers.h"
#include "MovementUpdate.h"
#include "Name.h"
#include "EnttGroups.h"
#include "Transforms.h"
#include "Config.h"
#include "SharedConfig.h"
#include "Log.h"
#include "entt/entity/registry.hpp"
#include <memory>

namespace AM
{
namespace Client
{
NpcMovementSystem::NpcMovementSystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, entityMover{world.registry, world.tileMap, world.entityLocator,
              world.collisionLocator}
, npcMovementUpdateQueue{inSimContext.networkEventDispatcher}
, lastProcessedTick{0}
{
}

void NpcMovementSystem::updateNpcs()
{
    if (Config::RUN_OFFLINE) {
        // No need to process NPCs if we're running offline.
        return;
    }

    // If this is our first run, initialize our lastProcessedTick.
    if (lastProcessedTick == 0) {
        initLastProcessedTick();
    }

    // While we haven't reached the desired tick and have more data to process.
    Uint32 desiredTick{simulation.getReplicationTick()};
    Uint32 lastReceivedTick{network.getLastReceivedTick()};
    while ((lastProcessedTick < desiredTick)
           && (lastProcessedTick < lastReceivedTick)) {
        // Move all NPCs as if their inputs didn't change.
        moveAllNpcs();

        // If there's an update message waiting.
        std::shared_ptr<const MovementUpdate>* npcMovementUpdate{
            npcMovementUpdateQueue.peek()};
        if ((npcMovementUpdate != nullptr)) {
            Uint32 messageTick{(*npcMovementUpdate)->tickNum};
            AM_ASSERT((messageTick >= (lastProcessedTick + 1)),
                      "Processed NPC movement out of order.");

            // If the update is for this tick, apply it.
            if (messageTick == (lastProcessedTick + 1)) {
                applyUpdateMessage(*(npcMovementUpdate->get()));
                npcMovementUpdateQueue.pop();
            }
        }

        lastProcessedTick++;
    }

    // Signal the updated components to any observers.
    emitUpdateSignals();

    // If we wanted to process more ticks but ran out of data, log it.
    if (lastProcessedTick < desiredTick) {
        LOG_INFO("Ran out of NPC data. lastProcessed: %u, desired: %u, "
                 "lastReceived: %u, queueSize: %u",
                 lastProcessedTick, desiredTick, lastReceivedTick,
                 npcMovementUpdateQueue.size());
    }
}

void NpcMovementSystem::initLastProcessedTick()
{
    // Since we aren't ran until a server connection is established, the sim's
    // currentTick is set to what the server gave us in ConnectionResponse.
    // Our first received updates will be for that tick, so we init to
    // currentTick - 1 to prepare for processing them.
    lastProcessedTick = simulation.getReplicationTick() - 1;
}

void NpcMovementSystem::moveAllNpcs()
{
    auto movementGroup{EnttGroups::getMovementGroup(world.registry)};
    for (auto [entity, input, position, previousPosition, movement,
               movementMods, rotation, collision, collisionBitSets,
               graphicState] :
         movementGroup.each()) {
        // Save their old position.
        previousPosition = position;

        // Move the entity.
        entityMover.moveEntity(
            {.entity{entity},
             .inputStates{input.inputStates},
             .position{position},
             .previousPosition{previousPosition},
             .movement{movement},
             .movementMods{movementMods},
             .rotation{rotation},
             .collision{collision},
             .collisionBitSets{collisionBitSets},
             .deltaSeconds{SharedConfig::SIM_TICK_TIMESTEP_S}});
    }
}

void NpcMovementSystem::applyUpdateMessage(
    const MovementUpdate& npcMovementUpdate)
{
    entt::registry& registry{world.registry};
    auto movementGroup{EnttGroups::getMovementGroup(registry)};

    // Apply each updated entity's new state.
    for (const MovementState& movementState :
         npcMovementUpdate.movementStates) {
        // Check that the entity exists.
        // TODO: There's possibly an issue here if we receive a MovementUpdate
        //       while the sim happens to be at this system, and the update's
        //       tick is up for processing. We might end up here before
        //       EntityLifetimeSystem was able to construct the entity.
        entt::entity entity{movementState.entity};
        if (!(registry.valid(entity))) {
            LOG_FATAL(
                "Received update for invalid entity: %u. Message tick: %u",
                entity, npcMovementUpdate.tickNum);
        }

        // Get the entity's components.
        auto [input, position, previousPosition, movement, rotation, collision]
            = movementGroup.get<Input, Position, PreviousPosition, Movement,
                                Rotation, Collision>(entity);

        // Apply the received component updates.
        input = movementState.input;
        position = movementState.position;
        movement = movementState.movement;
        rotation = MovementHelpers::calcRotation(rotation, input.inputStates);

        // If the previous position hasn't been initialized, set it to the
        // current position so they don't lerp in from the origin.
        if (!(previousPosition.isInitialized)) {
            previousPosition = position;
            previousPosition.isInitialized = true;
        }

        // Move their collision box to their new position.
        collision.worldBounds
            = Transforms::modelToWorldEntity(collision.modelBounds, position);
    }
}

void NpcMovementSystem::emitUpdateSignals()
{
    // Emit update signals to any observers.
    auto view{world.registry.view<Position, PreviousPosition>()};
    for (entt::entity entity : view) {
        world.registry.patch<Position>(entity, [](auto&) {});
    }
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Private/PlayerInputSystem.cpp`:

```cpp
#include "PlayerInputSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "Network.h"
#include "Input.h"
#include "InputHistory.h"
#include "InputChangeRequest.h"
#include "Camera.h"
#include "Config.h"
#include "AUI/Core.h"
#include "Log.h"

namespace AM
{
namespace Client
{
PlayerInputSystem::PlayerInputSystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, currentZoomLevelIndex{Config::DEFAULT_ZOOM_LEVEL_INDEX}
{
}

void PlayerInputSystem::processMomentaryInput(SDL_Event& event)
{
    switch (event.type) {
        case SDL_MOUSEWHEEL:
            processMouseWheel(event.wheel);
            break;
        default:
            // No default behavior.
            break;
    }
}

void PlayerInputSystem::processHeldInputs()
{
    // If a text input UI widget is capturing keyboard input, do nothing.
    if (AUI::Core::getIsTextInputFocused()) {
        return;
    }

    const Uint8* keyStates{SDL_GetKeyboardState(nullptr)};
    Input::StateArr newInputStates{};

    // Get the latest state of all the keys that we care about.
    if (keyStates[SDL_SCANCODE_W]) {
        newInputStates[Input::YDown] = Input::Pressed;
    }
    if (keyStates[SDL_SCANCODE_A]) {
        newInputStates[Input::XDown] = Input::Pressed;
    }
    if (keyStates[SDL_SCANCODE_S]) {
        newInputStates[Input::YUp] = Input::Pressed;
    }
    if (keyStates[SDL_SCANCODE_D]) {
        newInputStates[Input::XUp] = Input::Pressed;
    }
    if (keyStates[SDL_SCANCODE_SPACE]) {
        newInputStates[Input::Jump] = Input::Pressed;
    }
    if (keyStates[SDL_SCANCODE_LCTRL]) {
        newInputStates[Input::Crouch] = Input::Pressed;
    }

    // Update our saved input state.
    Input& playerInput{world.registry.get<Input>(world.playerEntity)};
    bool inputHasChanged{false};
    for (std::size_t inputType{0}; inputType < Input::Type::Count;
         ++inputType) {
        // If the saved state doesn't match the latest.
        if (newInputStates[inputType] != playerInput.inputStates[inputType]) {
            // Save the new state.
            playerInput.inputStates[inputType] = newInputStates[inputType];
            inputHasChanged = true;
        }
    }

    // If our input state has changed, ask the server to apply the new state.
    if (inputHasChanged && !Config::RUN_OFFLINE) {
        network.serializeAndSend<InputChangeRequest>(
            {simulation.getCurrentTick(), playerInput});
    }
}

void PlayerInputSystem::addCurrentInputsToHistory()
{
    CircularBuffer<Input::StateArr, InputHistory::LENGTH>& playerInputHistory{
        world.registry.get<InputHistory>(world.playerEntity).inputHistory};
    Input::StateArr& playerInputs{
        world.registry.get<Input>(world.playerEntity).inputStates};

    // Push the player's current inputs into the player's input history.
    playerInputHistory.push(playerInputs);
}

void PlayerInputSystem::processMouseWheel(SDL_MouseWheelEvent& wheelEvent)
{
    // If zooming is disabled, do nothing.
    if (!Config::ENABLE_MOUSE_ZOOM) {
        return;
    }

    // Only process zoom if the player has a camera.
    if (world.registry.all_of<Camera>(world.playerEntity)) {
        // Update the current zoom level based on the mouse wheel movement.
        // Note: We zoom a set amount per tick regardless of how much they
        //       scrolled.
        if ((wheelEvent.y > 0)
            && (currentZoomLevelIndex < (Config::ZOOM_LEVELS.size()) - 1)) {
            currentZoomLevelIndex++;
        }
        else if ((wheelEvent.y < 0) && (currentZoomLevelIndex > 0)) {
            currentZoomLevelIndex--;
        }

        Camera& camera{world.registry.get<Camera>(world.playerEntity)};
        camera.zoomFactor = Config::ZOOM_LEVELS.at(currentZoomLevelIndex);
    }
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Private/PlayerMovementSystem.cpp`:

```cpp
#include "PlayerMovementSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "MovementHelpers.h"
#include "World.h"
#include "Network.h"
#include "Position.h"
#include "Input.h"
#include "InputHistory.h"
#include "PreviousPosition.h"
#include "Movement.h"
#include "MovementModifiers.h"
#include "Rotation.h"
#include "Sprite.h"
#include "Collision.h"
#include "Transforms.h"
#include "SharedConfig.h"
#include "Config.h"
#include "Log.h"
#include "AMAssert.h"
#include <memory>

namespace AM
{
namespace Client
{
PlayerMovementSystem::PlayerMovementSystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, entityMover{world.registry, world.tileMap, world.entityLocator,
              world.collisionLocator}
, playerMovementUpdateQueue{inSimContext.networkEventDispatcher}
{
}

void PlayerMovementSystem::processMovement()
{
    // Save the old position.
    auto [position, previousPosition]
        = world.registry.get<Position, PreviousPosition>(world.playerEntity);
    previousPosition = position;

    // If we're online, process any updates from the server.
    if (!Config::RUN_OFFLINE) {
        // Apply any player entity updates from the server.
        // If an update is applied, the player entity's actual components will 
        // be moved back in time to match the update's state.
        Uint32 lastUpdateTick{processPlayerUpdates()};

        // If we received updates, replay the inputs that came after them.
        if (lastUpdateTick != 0) {
            replayInputs(lastUpdateTick);

            // Check if there was a mismatch between the position we had and
            // where the server thought we should be.
            if (previousPosition != position) {
                printMismatchInfo(lastUpdateTick);
            }
        }
    }

    // Process the player entity's movement for this tick.
    Input& input{world.registry.get<Input>(world.playerEntity)};
    movePlayerEntity(input.inputStates);

    // Signal the updated components to any observers.
    emitUpdateSignals();
}

Uint32 PlayerMovementSystem::processPlayerUpdates()
{
    entt::registry& registry{world.registry};
    auto [input, position, previousPosition, movement, rotation, collision,
          inputHistory]
        = registry.get<Input, Position, PreviousPosition, Movement, Rotation,
                       Collision, InputHistory>(world.playerEntity);

    /* Process any messages for us from the server. */
    PlayerMovementUpdate movementUpdate{};
    Uint32 lastUpdateTick{0};
    while (playerMovementUpdateQueue.pop(movementUpdate)) {
        // Check that the update's tick is in the past.
        Uint32 updateTick{movementUpdate.tickNum};
        Uint32 currentTick{simulation.getCurrentTick()};
        checkReceivedTickValidity(updateTick, currentTick);

        lastUpdateTick = updateTick;

        // Check that the diff is valid.
        Uint32 tickDiff{simulation.getCurrentTick() - updateTick};
        if (!checkTickDiffValidity(tickDiff)) {
            continue;
        }

        // Check if the received input disagrees with what we predicted.
        const Input& receivedInput{movementUpdate.input};
        if (receivedInput.inputStates != inputHistory.inputHistory[tickDiff]) {
            // Our prediction was wrong, accept the received input and set all
            // inputs in the history after the mismatched input to match it.
            // TODO: This may be incorrect, but it's uncommon and hard to
            // verify. We may want to more carefully overwrite existing inputs.
            input.inputStates = receivedInput.inputStates;
            for (std::size_t i{0}; i <= tickDiff; ++i) {
                inputHistory.inputHistory[i] = receivedInput.inputStates;
            }

            // Set our old position to the current so we aren't oddly lerping
            // back.
            previousPosition = position;
        }

        // Apply the rest of the received movement state.
        position = movementUpdate.position;
        movement = movementUpdate.movement;
        rotation = MovementHelpers::calcRotation(rotation, input.inputStates);
        collision.worldBounds
            = Transforms::modelToWorldEntity(collision.modelBounds, position);
    }

    return lastUpdateTick;
}

void PlayerMovementSystem::replayInputs(Uint32 lastUpdateTick)
{
    // Replay all inputs newer than lastUpdateTick, except the current
    // tick's input.
    Uint32 currentTick{simulation.getCurrentTick()};
    auto& inputHistory{world.registry.get<InputHistory>(world.playerEntity)};
    for (Uint32 tickToProcess{lastUpdateTick + 1}; tickToProcess < currentTick;
         ++tickToProcess) {
        // Check that the diff is valid.
        Uint32 tickDiff{currentTick - tickToProcess};
        checkTickDiffValidity(tickDiff);

        // Replay the input state and move the entity.
        movePlayerEntity(inputHistory.inputHistory[tickDiff]);
    }
}

void PlayerMovementSystem::movePlayerEntity(const Input::StateArr& inputStates)
{
    auto [position, previousPosition, movement, movementMods, rotation,
          collision, collisionBitSets]
        = world.registry
              .get<Position, PreviousPosition, Movement, MovementModifiers,
                   Rotation, Collision, CollisionBitSets>(world.playerEntity);

    // Move the entity.
    entityMover.moveEntity({.entity{world.playerEntity},
                            .inputStates{inputStates},
                            .position{position},
                            .previousPosition{previousPosition},
                            .movement{movement},
                            .movementMods{movementMods},
                            .rotation{rotation},
                            .collision{collision},
                            .collisionBitSets{collisionBitSets},
                            .deltaSeconds{SharedConfig::SIM_TICK_TIMESTEP_S}});
}

void PlayerMovementSystem::emitUpdateSignals()
{
    // Emit update signals to any observers.
    world.registry.patch<Position>(world.playerEntity, [](auto&) {});
}

void PlayerMovementSystem::printMismatchInfo(Uint32 lastUpdateTick)
{
    auto [position, previousPosition]
        = world.registry.get<Position, PreviousPosition>(world.playerEntity);

    LOG_INFO("Predicted position mismatched after replay: (%.6f, "
             "%.6f, %.6f) -> (%.6f, %.6f, %.6f)",
             previousPosition.x, previousPosition.y,
             previousPosition.z, position.x, position.y, position.z);
    LOG_INFO("lastUpdateTick: %u", lastUpdateTick);
}

void PlayerMovementSystem::checkReceivedTickValidity(
    [[maybe_unused]] Uint32 updateTick, [[maybe_unused]] Uint32 currentTick)
{
    AM_ASSERT((updateTick <= currentTick),
              "Received data for tick %u on tick %u. Server is in the future, "
              "can't replay inputs.",
              updateTick, currentTick);
}

bool PlayerMovementSystem::checkTickDiffValidity(Uint32 tickDiff)
{
    // The history includes the current tick, so we only have LENGTH - 1
    // worth of previous data to use (i.e. it's 0-indexed).
    if (tickDiff > (InputHistory::LENGTH - 1)) {
        LOG_ERROR("Too few items in the player input history. "
                  "Increase the length or reduce lag. tickDiff: %u, "
                  "historyLength: %u",
                  tickDiff, InputHistory::LENGTH);
        return false;
    }

    return true;
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Private/ReplicationTickOffset.cpp`:

```cpp
#include "ReplicationTickOffset.h"
#include "Log.h"

namespace AM
{
namespace Client
{

void ReplicationTickOffset::applyAdjustment(int adjustment)
{
    // We set our client ahead of the server by an amount equal to our latency,
    // but this means that received messages will appear to be doubly far into
    // the past.
    // To account for this, we double the adjustment before applying.
    // We also negate it since we're reversing the direction.
    offset += (-2 * adjustment);

    if (offset >= 0) {
        LOG_FATAL("Adjusted replication tick offset too far into the "
                  "future. offset: %u",
                  offset);
    }
}

int ReplicationTickOffset::get() const
{
    return offset;
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Private/ServerConnectionSystem.cpp`:

```cpp
#include "ServerConnectionSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "Network.h"
#include "GraphicData.h"
#include "SimulationStarted.h"
#include "Name.h"
#include "Inventory.h"
#include "PreviousPosition.h"
#include "Position.h"
#include "Movement.h"
#include "MovementModifiers.h"
#include "Collision.h"
#include "InputHistory.h"
#include "Rotation.h"
#include "ClientGraphicState.h"
#include "GraphicState.h"
#include "IsClientEntity.h"
#include "UserConfig.h"
#include "Camera.h"
#include "SDLHelpers.h"
#include "NeedsAdjacentChunks.h"
#include "Transforms.h"
#include "Config.h"
#include "Log.h"
#include "entt/signal/dispatcher.hpp"

namespace AM
{
namespace Client
{
ServerConnectionSystem::ServerConnectionSystem(
    const SimulationContext& inSimContext, std::atomic<Uint32>& inCurrentTick)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, graphicData{inSimContext.graphicData}
, simEventDispatcher{inSimContext.simEventDispatcher}
, currentTick{inCurrentTick}
, connectionRequestQueue{}
, connectionResponseQueue{inSimContext.networkEventDispatcher}
, connectionErrorQueue{inSimContext.networkEventDispatcher}
, connectionState{ConnectionState::Disconnected}
, connectionAttemptTimer{}
{
    // Listen for UI connection requests.
    inSimContext.uiEventDispatcher.sink<ConnectionRequest>()
        .connect<&ServerConnectionSystem::onUIConnectionRequest>(*this);
}

void ServerConnectionSystem::processConnectionEvents()
{
    if (connectionState == ConnectionState::Disconnected) {
        // Check for a connection request from the UI.
        if (!(connectionRequestQueue.empty())) {
            ConnectionRequest connectionRequest{connectionRequestQueue.front()};
            connectionRequestQueue.pop();
            if (Config::RUN_OFFLINE) {
                // No need to connect if we're running offline. Just mock up
                // the player data.
                initMockSimState();
                return;
            }
            else {
                // Kick off a connection attempt with the server.
                // Note: Eventually we'll instead send a ConnectionRequest to
                //       the login server here with our login info.
                network.connect();
                connectionState = ConnectionState::AwaitingResponse;
                connectionAttemptTimer.reset();
            }
        }
    }
    else if (connectionState == ConnectionState::AwaitingResponse) {
        // Wait for a connection response from the server.
        ConnectionResponse connectionResponse;
        if (connectionResponseQueue.pop(connectionResponse)) {
            initSimState(connectionResponse);
            connectionState = ConnectionState::Connected;
            simEventDispatcher.trigger<SimulationStarted>();
        }

        // If we've timed out, send a failure signal.
        if (connectionAttemptTimer.getTime() >= CONNECTION_RESPONSE_WAIT_S) {
            simEventDispatcher.trigger<ConnectionError>(
                {ConnectionError::Type::Failed});
            connectionState = ConnectionState::Disconnected;
        }
    }

    // If the connection is lost, reset all network and sim state.
    ConnectionError connectionError;
    if (connectionErrorQueue.pop(connectionError)) {
        simEventDispatcher.trigger(connectionError);
        network.disconnect();
        clearSimState();
        connectionState = ConnectionState::Disconnected;
    }
}

ServerConnectionSystem::ConnectionState
    ServerConnectionSystem::getConnectionState()
{
    return connectionState;
}

void ServerConnectionSystem::onUIConnectionRequest(
    ConnectionRequest& connectionRequest)
{
    connectionRequestQueue.emplace(connectionRequest);
}

void ServerConnectionSystem::initSimState(
    ConnectionResponse& connectionResponse)
{
    LOG_INFO("Received connection response. ID: %u, tick: %u",
             connectionResponse.entity, connectionResponse.tickNum);

    // Resize the world's tile map.
    world.tileMap.setMapSize(connectionResponse.mapXLengthChunks,
                             connectionResponse.mapYLengthChunks,
                             connectionResponse.mapZLengthChunks);
    LOG_INFO("Setting map size to: (%u, %u, %u)ch.",
             connectionResponse.mapXLengthChunks,
             connectionResponse.mapYLengthChunks,
             connectionResponse.mapZLengthChunks);

    // Allocate the locator grids.
    world.entityLocator.setGridSize(world.tileMap.getTileExtent());
    world.collisionLocator.setGridSize(world.tileMap.getTileExtent());

    // Aim our tick for some reasonable point ahead of the server.
    // The server will adjust us after the first message anyway.
    currentTick = connectionResponse.tickNum + Config::INITIAL_TICK_OFFSET;

    // Save the player entity ID so we can treat it differently.
    world.playerEntity = connectionResponse.entity;
}

void ServerConnectionSystem::initMockSimState()
{
    // Create the player entity.
    entt::registry& registry{world.registry};
    entt::entity newEntity{registry.create()};

    // Save the player entity ID for convenience.
    world.playerEntity = newEntity;

    // Set up the player's sim components.
    // Note: Be careful with holding onto references here. If components
    //       are added to the same group, the ref will be invalidated.
    registry.emplace<IsClientEntity>(newEntity);
    registry.emplace<Name>(newEntity,
                           std::to_string(static_cast<Uint32>(newEntity)));
    registry.emplace<Inventory>(newEntity);

    registry.emplace<Input>(newEntity);
    registry.emplace<Position>(newEntity, 0.0f, 0.0f, 0.0f);
    world.entityLocator.updateEntity(newEntity, {0.0f, 0.0f, 0.0f});
    registry.emplace<PreviousPosition>(newEntity, 0.0f, 0.0f, 0.0f);
    registry.emplace<Movement>(newEntity);
    registry.emplace<MovementModifiers>(newEntity);
    registry.emplace<Rotation>(newEntity);
    registry.emplace<InputHistory>(newEntity);

    const EntityGraphicSet& graphicSet{graphicData.getEntityGraphicSet(
        SharedConfig::DEFAULT_ENTITY_GRAPHIC_SET)};
    registry.emplace<GraphicState>(newEntity, graphicSet.numericID);

    // Entity collision always comes from its Idle South graphic.
    const auto& graphicArr{graphicSet.graphics.at(EntityGraphicType::Idle)};
    const GraphicRef& graphic{graphicArr.at(Rotation::Direction::South)};
    const BoundingBox& modelBounds{graphic.getModelBounds()};
    const Collision& collision{registry.emplace<Collision>(
        newEntity, modelBounds,
        Transforms::modelToWorldEntity(modelBounds,
                                       registry.get<Position>(newEntity)))};
    const CollisionBitSets& collisionBitSets{
        registry.emplace<CollisionBitSets>(newEntity)};

    // Entities with Collision get added to the locator.
    world.collisionLocator.updateEntity(newEntity, collision.worldBounds,
                                        collisionBitSets.getCollisionLayers());

    // Entities with GraphicState also get a ClientGraphicState.
    registry.emplace<ClientGraphicState>(newEntity, EntityGraphicType::Idle,
                                         Rotation::Direction::South);

    // TODO: Switch to logical screen size and do scaling in Renderer.
    UserConfig& userConfig{UserConfig::get()};
    registry.emplace<Camera>(
        newEntity, Camera::CenterOnEntity, Position{}, PreviousPosition{},
        BoundingBox{}, SDLHelpers::rectToFRect(userConfig.getWindowSize()));
}

void ServerConnectionSystem::clearSimState()
{
    world.registry.clear();
    world.playerEntity = entt::null;
    world.tileMap.clear();

    // The current tick needs to be set back to 0 so the Network knows to stop
    // sending heartbeats.
    currentTick = 0;
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Private/Simulation.cpp`:

```cpp
#include "Simulation.h"
#include "SimulationContext.h"
#include "Network.h"
#include "GraphicData.h"
#include "ItemData.h"
#include "CastableData.h"
#include "ISimulationExtension.h"
#include "ChunkUpdateSystem.h"
#include "TileUpdateSystem.h"
#include "EntityLifetimeSystem.h"
#include "PlayerInputSystem.h"
#include "PlayerMovementSystem.h"
#include "NpcMovementSystem.h"
#include "ItemSystem.h"
#include "InventorySystem.h"
#include "CastSystem.h"
#include "ComponentUpdateSystem.h"
#include "GraphicSystem.h"
#include "AVSystem.h"
#include "CameraSystem.h"
#include "Item.h"
#include "Config.h"
#include "Log.h"
#include "entt/entity/registry.hpp"
#include <memory>
#include <string>

namespace AM
{
namespace Client
{
Simulation::Simulation(const SimulationContext& inSimContext)
: simContext{inSimContext}
, network{inSimContext.network}
, graphicData{inSimContext.graphicData}
, itemData{inSimContext.itemData}
, castableData{inSimContext.castableData}
, world{inSimContext}
, currentTick{0}
, extension{nullptr}
, serverConnectionSystem{inSimContext, currentTick}
{
    // Register our current tick pointer with the classes that care.
    Log::registerCurrentTickPtr(&currentTick);
    network.registerCurrentTickPtr(&currentTick);

    // Initialize our systems to prepare them to run.
    initializeSystems();
}

Simulation::~Simulation() = default;

World& Simulation::getWorld()
{
    return world;
}

const World& Simulation::getWorld() const
{
    return world;
}

Uint32 Simulation::getCurrentTick() const
{
    return currentTick;
}

Uint32 Simulation::getReplicationTick() const
{
    return (currentTick + replicationTickOffset.get());
}

void Simulation::tick()
{
    // If we're online, process any server connection events.
    if (!Config::RUN_OFFLINE) {
        using ConnectionState = ServerConnectionSystem::ConnectionState;

        auto previousConnectionState{
            serverConnectionSystem.getConnectionState()};

        serverConnectionSystem.processConnectionEvents();

        auto currentConnectionState{
            serverConnectionSystem.getConnectionState()};

        // If we just lost connection, re-initialize our systems to prepare
        // them for the next run.
        if ((previousConnectionState == ConnectionState::Connected)
            && (currentConnectionState == ConnectionState::Disconnected)) {
            initializeSystems();
        }

        // If we aren't connected, return early.
        if (serverConnectionSystem.getConnectionState()
            != ConnectionState::Connected) {
            return;
        }
    }

    /* Calculate what tick we should be on. */
    // Increment the tick to the next.
    Uint32 targetTick{currentTick + 1};

    // If we're online, apply any adjustments that we receive from the
    // server.
    if (!Config::RUN_OFFLINE) {
        int adjustment{network.transferTickAdjustment()};
        if (adjustment != 0) {
            targetTick += adjustment;

            // Make sure NPC replication takes the adjustment into account.
            replicationTickOffset.applyAdjustment(adjustment);
        }
    }

    // Process ticks until we match what the server wants.
    // Note: This may cause us to not process any ticks, or to process multiple
    //       ticks.
    while (currentTick < targetTick) {
        /* Run all systems. */
        // Call the project's pre-everything logic.
        extension->beforeAll();

        // Process entities that need to be constructed or destructed.
        entityLifetimeSystem->processUpdates();

        // Process chunk updates from the server.
        chunkUpdateSystem->updateChunks();

        // Process tile updates from the server.
        tileUpdateSystem->updateTiles();

        // Call the project's pre-movement logic.
        extension->afterMapAndConnectionUpdates();

        // Process the held user input state and send change requests to the
        // server.
        // Note: Mouse and momentary inputs are processed through our OS event
        //       handling, prior to this tick.
        playerInputSystem->processHeldInputs();

        // Push the new input state into the player's history.
        playerInputSystem->addCurrentInputsToHistory();

        // Process player movement.
        playerMovementSystem->processMovement();

        // Process NPC movement.
        npcMovementSystem->updateNpcs();

        // Process any waiting item definition updates.
        itemSystem->processItemUpdates();

        // Process any waiting inventory updates.
        inventorySystem->processInventoryUpdates();

        // Process ongoing casts and any waiting cast updates.
        castSystem->processCasts();

        // Call the project's post-sim-update logic.
        extension->afterSimUpdate();

        // Process component updates from the server.
        // Note: We do this last because the state that we receive is the
        //       final state for this tick.
        componentUpdateSystem->processUpdates();

        // Update every entity's graphic state.
        graphicSystem->updateAnimations();

        // Update our local-only AV effects and entities.
        avSystem->updateAVEffectsAndEntities();

        // Move all cameras to their new positions.
        cameraSystem->moveCameras();

        // Call the project's post-everything logic.
        extension->afterAll();

        currentTick++;
    }
}

bool Simulation::handleOSEvent(SDL_Event& event)
{
    switch (event.type) {
        case SDL_MOUSEMOTION: {
            return false;
        }
        default: {
            // Default to assuming it's a momentary input.
            playerInputSystem->processMomentaryInput(event);
            return true;
        }
    }

    return false;
}

void Simulation::setExtension(ISimulationExtension* inExtension)
{
    extension = inExtension;
    graphicSystem->setExtension(extension);

    // Tell the project to initialize its systems.
    extension->initializeSystems();
}

void Simulation::initializeSystems()
{
    // Initialize our engine systems.
    chunkUpdateSystem = std::make_unique<ChunkUpdateSystem>(simContext);
    tileUpdateSystem = std::make_unique<TileUpdateSystem>(simContext);
    entityLifetimeSystem = std::make_unique<EntityLifetimeSystem>(simContext);
    playerInputSystem = std::make_unique<PlayerInputSystem>(simContext);
    playerMovementSystem = std::make_unique<PlayerMovementSystem>(simContext);
    npcMovementSystem = std::make_unique<NpcMovementSystem>(simContext);
    itemSystem = std::make_unique<ItemSystem>(simContext);
    inventorySystem = std::make_unique<InventorySystem>(simContext);
    castSystem = std::make_unique<CastSystem>(simContext);
    componentUpdateSystem = std::make_unique<ComponentUpdateSystem>(simContext);
    graphicSystem = std::make_unique<GraphicSystem>(simContext);
    avSystem = std::make_unique<AVSystem>(simContext);
    cameraSystem = std::make_unique<CameraSystem>(simContext);

    // If the project extension is already set, re-set it to handle that 
    // initialization.
    if (extension) {
        setExtension(extension);
    }
}

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Private/TileMap/TileMap.cpp`:

```cpp
#include "TileMap.h"
#include "GraphicData.h"
#include "CollisionLocator.h"
#include "Paths.h"
#include "Position.h"
#include "Transforms.h"
#include "Serialize.h"
#include "Deserialize.h"
#include "ByteTools.h"
#include "TileMapSnapshot.h"
#include "Config.h"
#include "SharedConfig.h"
#include "Timer.h"
#include "Log.h"
#include "AMAssert.h"

namespace AM
{
namespace Client
{
TileMap::TileMap(const GraphicData& inGraphicData,
                 CollisionLocator& inCollisionLocator)
: TileMapBase{inGraphicData, inCollisionLocator, false}
, sizeChangedSig{}
, sizeChanged{sizeChangedSig}
{
    if (Config::RUN_OFFLINE) {
        LOG_INFO("Offline mode. Constructing default tile map.");

        // Set our map size.
        setMapSize(1, 1, 1);

        // If we have any terrain graphic sets, fill the map with the first one.
        const std::vector<TerrainGraphicSet>& terrainGraphicSets{
            graphicData.getAllTerrainGraphicSets()};
        if (terrainGraphicSets.size() > 0) {
            const TerrainGraphicSet& terrainGraphicSet{terrainGraphicSets[0]};
            for (int x{tileExtent.x}; x <= tileExtent.xMax(); ++x) {
                for (int y{tileExtent.y}; y <= tileExtent.yMax(); ++y) {
                    addTerrain({x, y, 0}, terrainGraphicSet,
                               Terrain::Height::Flat);
                }
            }
        }
    }
}

void TileMap::setMapSize(Uint16 inMapXLengthChunks, Uint16 inMapYLengthChunks,
                         Uint16 inMapZLengthChunks)
{
    // Set our map size.
    chunkExtent = ChunkExtent::fromMapLengths(
        inMapXLengthChunks, inMapYLengthChunks, inMapZLengthChunks);
    tileExtent = TileExtent{chunkExtent};

    // Signal that the size changed.
    sizeChangedSig.publish(tileExtent);
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Private/TileUpdateSystem.cpp`:

```cpp
#include "TileUpdateSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "Network.h"
#include "AMAssert.h"
#include <variant>

namespace AM
{
namespace Client
{
TileUpdateSystem::TileUpdateSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, addLayerQueue{inSimContext.networkEventDispatcher}
, removeLayerQueue{inSimContext.networkEventDispatcher}
, clearLayersQueue{inSimContext.networkEventDispatcher}
, extentClearLayersQueue{inSimContext.networkEventDispatcher}
{
}

void TileUpdateSystem::updateTiles()
{
    // Disable auto collision rebuild (it's more efficient to do it all after).
    world.tileMap.setAutoRebuildCollision(false);

    // Process any waiting tile updates from the server.
    TileClearLayers tileClearLayers{};
    while (clearLayersQueue.pop(tileClearLayers)) {
        clearTileLayers(tileClearLayers);
    }

    TileExtentClearLayers tileExtentClearLayers{};
    while (extentClearLayersQueue.pop(tileExtentClearLayers)) {
        clearExtentLayers(tileExtentClearLayers);
    }

    TileAddLayer tileAddLayer{};
    while (addLayerQueue.pop(tileAddLayer)) {
        addTileLayer(tileAddLayer);
    }

    TileRemoveLayer tileRemoveLayer{};
    while (removeLayerQueue.pop(tileRemoveLayer)) {
        remTileLayer(tileRemoveLayer);
    }

    // Re-enable auto collision rebuild (rebuilds any dirty tiles).
    world.tileMap.setAutoRebuildCollision(true);
}

void TileUpdateSystem::addTileLayer(const TileAddLayer& addLayerRequest)
{
    if (addLayerRequest.layerType == TileLayer::Type::Terrain) {
        world.tileMap.addTerrain(
            addLayerRequest.tilePosition, addLayerRequest.graphicSetID,
            static_cast<Terrain::Value>(addLayerRequest.graphicValue));
    }
    else if (addLayerRequest.layerType == TileLayer::Type::Floor) {
        world.tileMap.addFloor(
            addLayerRequest.tilePosition, addLayerRequest.tileOffset,
            addLayerRequest.graphicSetID,
            static_cast<Rotation::Direction>(addLayerRequest.graphicValue));
    }
    else if (addLayerRequest.layerType == TileLayer::Type::Wall) {
        world.tileMap.addWall(
            addLayerRequest.tilePosition, addLayerRequest.graphicSetID,
            static_cast<Wall::Type>(addLayerRequest.graphicValue));
    }
    else if (addLayerRequest.layerType == TileLayer::Type::Object) {
        world.tileMap.addObject(
            addLayerRequest.tilePosition, addLayerRequest.tileOffset,
            addLayerRequest.graphicSetID,
            static_cast<Rotation::Direction>(addLayerRequest.graphicValue));
    }
}

void TileUpdateSystem::remTileLayer(const TileRemoveLayer& remLayerRequest)
{
    if (remLayerRequest.layerType == TileLayer::Type::Terrain) {
        world.tileMap.remTerrain(remLayerRequest.tilePosition);
    }
    else if (remLayerRequest.layerType == TileLayer::Type::Floor) {
        world.tileMap.remFloor(
            remLayerRequest.tilePosition, remLayerRequest.tileOffset,
            remLayerRequest.graphicSetID,
            static_cast<Rotation::Direction>(remLayerRequest.graphicValue));
    }
    else if (remLayerRequest.layerType == TileLayer::Type::Wall) {
        world.tileMap.remWall(
            remLayerRequest.tilePosition,
            static_cast<Wall::Type>(remLayerRequest.graphicValue));
    }
    else if (remLayerRequest.layerType == TileLayer::Type::Object) {
        world.tileMap.remObject(
            remLayerRequest.tilePosition, remLayerRequest.tileOffset,
            remLayerRequest.graphicSetID,
            static_cast<Rotation::Direction>(remLayerRequest.graphicValue));
    }
}

void TileUpdateSystem::clearTileLayers(
    const TileClearLayers& clearLayersRequest)
{
    world.tileMap.clearTileLayers(clearLayersRequest.tilePosition,
                                  clearLayersRequest.layerTypesToClear);
}

void TileUpdateSystem::clearExtentLayers(
    const TileExtentClearLayers& clearExtentLayersRequest)
{
    world.tileMap.clearExtentLayers(clearExtentLayersRequest.tileExtent,
                                    clearExtentLayersRequest.layerTypesToClear);
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Private/World.cpp`:

```cpp
#include "World.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "GraphicData.h"
#include "ItemData.h"
#include "CastableData.h"
#include "EnttGroups.h"

namespace AM
{
namespace Client
{
World::World(const SimulationContext& inSimContext)
: registry{}
, avRegistry{}
, playerEntity{entt::null}
, entityLocator{registry}
, collisionLocator{}
, tileMap{inSimContext.graphicData, collisionLocator}
, castHelper{inSimContext.simulation, inSimContext.network,
             inSimContext.itemData, inSimContext.castableData}
{
    // Initialize our entt groups, before anyone tries to use them.
    EnttGroups::init(registry);
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/AVEntityHelpers.h`:

```h
#pragma once

#include "AVEntity.h"
#include "Position.h"
#include "Rotation.h"
#include "entt/entity/registry.hpp"
#include <optional>

namespace AM
{
namespace Client
{
/**
 * Shared static functions for working with A/V entities.
 */
class AVEntityHelpers
{
public:
    /**
     * If casterEntity is valid, returns its position. Else, returns null.
     */
    static std::optional<Position>
        getCasterPosition(entt::entity casterEntity,
                          const entt::registry& registry);

    /**
     * Returns the appropriate target position for the given behavior, either 
     * targetEntity's position or targetPosition.
     */
    static std::optional<Position> getTargetPosition(
        AVEntity::Behavior behavior, entt::entity targetEntity,
        const Position& targetPosition, const Position& currentPosition,
        const entt::registry& registry, bool isFirstPhase);

    struct StartStateReturn {
        Position startPosition{};
        EntityGraphicType graphicType{};
        Rotation::Direction graphicDirection{};
    };
    /**
     * Returns the appropriate starting position and graphic state for the 
     * given behavior.
     */
    static std::optional<StartStateReturn>
        getStartState(AVEntity::Behavior behavior,
                      const Position& casterPosition,
                      const Position& targetPosition, float startDistance);

    struct GraphicStateReturn {
        EntityGraphicType graphicType{};
        Rotation::Direction graphicDirection{};
    };
    /**
     * Returns the appropriate graphic state for the given behavior.
     *
     * If behavior is one of the types that points towards targetPosition, and 
     * casterPosition == targetPosition, returns Rotation::Direction::None.
     * This lets the caller know to use the previous direction.
     */
    static std::optional<GraphicStateReturn>
        getGraphicState(AVEntity::Behavior behavior,
                        const Position& casterPosition,
                        const Position& targetPosition);

    /**
     * If the given behavior is time-based and its time has elapsed, returns 
     * true.
     */
    static bool timeElapsed(AVEntity::Behavior behavior, double startTime,
                            double durationS, double currentTime,
                            GraphicRef currentGraphic);

    /**
     * If the given behavior is position-based and entityPos == targetPos, 
     * returns true.
     */
    static bool positionReached(AVEntity::Behavior behavior,
                                const Position& entityPos,
                                const Position& targetPos);

    /**
     * Converts the given direction vector to the closest X/Y direction 
     * value. Ignores the Z axis.
     */
    static Rotation::Direction
        vectorToClosestDirection(const Vector3& directionVector);
};

} // End namespace Client
} // End namespace AM


```

`Source/ClientLib/Simulation/Public/AVEntityID.h`:

```h
#pragma once

#include "entt/fwd.hpp"

namespace AM
{
namespace Client
{

/**
 * An ID type for A/V entities.
 */
enum class AVEntityID : uint32_t {};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/AVSystem.h`:

```h
#pragma once

#include "Rotation.h"
#include <vector>

namespace AM
{
struct Vector3;
struct AVEntity;
struct Position;
struct PreviousPosition;
struct GraphicState;

namespace Client
{
struct SimulationContext;
class World;
class GraphicData;
struct VisualEffectState;
struct AVEntityState;
struct ClientGraphicState;

/**
 * Updates audio/visual effects and entities.
 *
 * A/V effects are attached to a particular entity, and follow that entity 
 * around for a set period of time. These are used for e.g. a power-up effect.
 *
 * A/V entities are spawned as local-only entities, and have a set of logic 
 * to perform before being destroyed. These are used for e.g. a blizzard spell.
 */
class AVSystem
{
public:
    AVSystem(const SimulationContext& inSimContext);

    /**
     * Updates A/V effects and entities.
     */
    void updateAVEffectsAndEntities();

private:
    /**
     * Updates all AVEffects components.
     */
    void updateAVEffects();

    /**
     * Updates all of the given visual effects.
     */
    void updateVisualEffects(std::vector<VisualEffectState>& visualEffects);

    /**
     * Updates all A/V entities.
     */
    void updateAVEntities();

    /**
     * If the given phase is completed, increments to the next phase.
     * @return false if the update was invalid and the entity should be deleted.
     */
    bool incrementPhaseIfNecessary(AVEntityState& avEntityState,
                                   const Position& position,
                                   const GraphicState& graphicState,
                                   ClientGraphicState& clientGraphicState,
                                   double currentTime);

    /**
     * Updates the given A/V entity to the next tick.
     * @return false if the update was invalid and the entity should be deleted.
     */
    bool updateAVEntity(const AVEntityState& avEntityState,
                        Position& position,
                        PreviousPosition& previousPosition,
                        GraphicState& graphicState,
                        ClientGraphicState& clientGraphicState);

    /** Used to access entity data. */
    World& world;
    const GraphicData& graphicData;
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/CameraSystem.h`:

```h
#pragma once

namespace AM
{
struct Position;
struct Camera;

namespace Client
{
struct SimulationContext;
class World;

/**
 * Moves camera entities according to their behavior.
 */
class CameraSystem
{
public:
    CameraSystem(const SimulationContext& inSimContext);

    /**
     * Moves all cameras to their appropriate next positions.
     */
    void moveCameras();

private:
    World& world;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/CastHelper.h`:

```h
#pragma once

#include "CastInfo.h"
#include "CastFailureType.h"
#include "ItemInteractionType.h"
#include "EntityInteractionType.h"
#include "SpellType.h"
#include "entt/fwd.hpp"
#include <SDL_stdinc.h>
#include <unordered_map>
#include <functional>
#include <limits>
#include <queue>

namespace AM
{
class CastableData;
struct Castable;
struct Vector3;

namespace Client
{
class Simulation;
class World;
class Network;
class ItemData;

/**
 * Helper class for casting Castables.
 */
class CastHelper
{
public:
    CastHelper(Simulation& inSimulation, Network& inNetwork,
               const ItemData& inItemData, const CastableData& inCastableData);

    struct CastItemInteractionParams;
    /**
     * Queues the given item interaction to be cast during the next CastSystem 
     * tick.
     */
    void queueItemInteraction(const CastItemInteractionParams& params);

    struct CastEntityInteractionParams;
    /**
     * Queues the given entity interaction to be cast during the next CastSystem
     * tick.
     */
    void queueEntityInteraction(const CastEntityInteractionParams& params);

    struct CastSpellParams;
    /**
     * Queues the given spell to be cast during the next CastSystem tick.
     */
    void queueSpell(const CastSpellParams& params);

private:
    /**
     * Casts an item interaction, using the given info.
     * 
     * @return None if the cast is successful, otherwise returns the reason for
     *         failure.
     */
    CastFailureType
        castItemInteraction(const CastItemInteractionParams& params);

    /**
     * Casts an entity interaction, using the given info.
     *
     * @return None if the cast is successful, otherwise returns the reason for
     *         failure.
     */
    CastFailureType
        castEntityInteraction(const CastEntityInteractionParams& params);

    /**
     * Casts a spell, using the given info.
     *
     * @return None if the cast is successful, otherwise returns the reason for
     *         failure.
     */
    CastFailureType castSpell(const CastSpellParams& params);

    /**
     * Performs generic validation that's applicable to all 3 types of 
     * Castable.
     *
     * @return None if validation passed, otherwise returns the cause of 
     *         failure.
     */
    CastFailureType performSharedChecks(const Castable& castable,
                                        entt::entity casterEntity,
                                        entt::entity targetEntity,
                                        const Vector3& targetPosition);

    /** Used to get the current tick. */
    Simulation& simulation;
    World& world;
    /** Used to send cast requests. We could send them in CastSystem, but we 
        do it here to reduce latency as much as possible. */
    Network& network;
    const ItemData& itemData;
    const CastableData& castableData;

    // We friend CastSystem so it can use the queues and cast() functions 
    // without letting users get confused and call e.g. castSpell() instead of 
    // queueSpell(). Ideally, we would set this up differently to avoid 
    // exposing the rest of our private state.
    friend class CastSystem;

public:
struct CastItemInteractionParams {
    // Note: The player entity is always assumed to be the caster.

    /** The item interaction to cast. */
    ItemInteractionType interactionType{};
    /** The slot of the item that is being used, within casterEntity's 
        inventory. */
    Uint8 slotIndex{};
    /** (Optional) The target entity. If the Castable's targetToolType is 
        Entity, this must be valid. */
    entt::entity targetEntity{entt::null};
    /** (Optional) The target position. If the Castable's targetToolType 
        is Circle, this must be valid. */
    Vector3 targetPosition{std::numeric_limits<float>::max(),
                           std::numeric_limits<float>::max(),
                           std::numeric_limits<float>::max()};
};

struct CastEntityInteractionParams {
    // Note: The player entity is always assumed to be the caster.

    /** The entity interaction to cast. */
    EntityInteractionType interactionType{};
    /** The target entity. */
    entt::entity targetEntity{entt::null};
    /** (Optional) The target position. If the Castable's targetToolType 
        is Circle, this must be valid. */
    Vector3 targetPosition{std::numeric_limits<float>::max(),
                           std::numeric_limits<float>::max(),
                           std::numeric_limits<float>::max()};
};

struct CastSpellParams {
    // Note: The player entity is always assumed to be the caster.

    /** The item interaction to cast. */
    SpellType interactionType{};
    /** (Optional) The target entity. If the Castable's targetToolType is 
        Entity, this must be valid. */
    entt::entity targetEntity{entt::null};
    /** (Optional) The target position. If the Castable's targetToolType 
        is Circle, this must be valid. */
    Vector3 targetPosition{std::numeric_limits<float>::max(),
                           std::numeric_limits<float>::max(),
                           std::numeric_limits<float>::max()};
};

private:
    // Queues that hold cast requests sent by the UI. 
    std::queue<CastItemInteractionParams> castItemInteractionQueue;
    std::queue<CastEntityInteractionParams> castEntityInteractionQueue;
    std::queue<CastSpellParams> castSpellQueue;
};

} // End namespace Client 
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/CastSystem.h`:

```h
#pragma once

#include "CastStarted.h"
#include "CastFailed.h"
#include "CastCooldownInit.h"
#include "Rotation.h"
#include "QueuedEvents.h"

namespace AM
{
class CastableData;
struct CastInfo;
struct Castable;

namespace Client
{
struct SimulationContext;
class Simulation;
class World;
class Network;
class GraphicData;
struct ClientCastState;

/**
 * Handles cast-related messages and all processing of ongoing casts.
 */
class CastSystem
{
public:
    CastSystem(const SimulationContext& inSimContext);

    /**
     * Handles received cast messages, and updates ongoing casts.
     */
    void processCasts();

private:
    /**
     * Processes any waiting casts that the UI queued through CastHelper.
     */
    void processUICasts();

    /**
     * Starts the given cast.
     */
    void handleCastStarted(const CastStarted& castStarted);

    /**
     * If the given message matches an ongoing cast, cancels it.
     */
    void handleCastFailed(const CastFailed& castFailed);

    /**
     * Initializes the player entity's CastCooldown component to the given 
     * state.
     */
    void handleCastCooldownInit(const CastCooldownInit& castCooldownInit);

    /**
     * Updates any ongoing casts, completing them as necessary.
     */
    void updateCasts();

    /**
     * Sets any entity state related to the cast being started.
     */
    void startCast(ClientCastState& castState);

    /**
     * Cancels the current cast, resetting cooldowns and sending error signals 
     * appropriately.
     */
    void cancelCast(ClientCastState& castState);

    /**
     * Finishes the given cast, either ending it or continuing on to the "cast 
     * complete" state.
     */
    void finishCast(ClientCastState& castState);

    /**
     * Returns the tick when the given entity should end the "cast complete" 
     * graphic of the given Castable, assuming they start on the current tick.
     *
     * Returns 0 if the given entity doesn't have a "cast complete" graphic.
     */
    Uint32 getCastCompleteEndTick(entt::entity entity,
                                  const Castable& castable);

    /**
     * Handles playing AV effects and creating AV entities for the given 
     * finished cast.
     */
    void playAVEffects(const CastInfo& castInfo);

    /** Used to get the current tick. */
    Simulation& simulation;
    /** Used to access entity data and castHelper. */
    World& world;
    /** Used to receive cast started/failed messages, and send cast requests. */
    Network& network;
    const GraphicData& graphicData;
    const CastableData& castableData;

    /** Used to send cast failure events to the UI. */
    entt::dispatcher& simEventDispatcher;

    EventQueue<CastStarted> castStartedQueue;
    EventQueue<CastFailed> castFailedQueue;
    EventQueue<CastCooldownInit> castCooldownInitQueue;
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/CastableData/AVEntityState.h`:

```h
#pragma once

#include "AVEntity.h"
#include "Vector3.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include <functional>

namespace AM
{
namespace Client
{

/**
 * An instance of a client-only entity for displaying audio/visual effects.
 */
struct AVEntityState {
    /** The definition that this entity is an instance of.
        Note: This should never be nullptr. */
    std::reference_wrapper<const AVEntity> avEntity;

    /** The target entity, if one was provided. */
    entt::entity targetEntity{entt::null};

    /** The target position, if one was provided. */
    Vector3 targetPosition{0, 0, 0};

    /** The index within phases of the current phase. */
    std::size_t currentPhaseIndex{0};

    /** Used to track when the phase is incremented, so we can reset timers 
        on the first tick of the new phase. */
    bool phaseWasIncremented{false};

    //-------------------------------------------------------------------------
    // Timing state (managed by WorldSpriteSorter)
    //-------------------------------------------------------------------------
    /** A timestamp of when the current phase was started. */
    double phaseStartTime{0};

    /** If true, a new phase has begun and startTime needs to be reset when 
        its first frame is rendered. */
    bool setStartTime{true};
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/CastableData/VisualEffectState.h`:

```h
#pragma once

#include "VisualEffect.h"
#include <functional>

namespace AM
{
namespace Client
{

/**
 * An instance of a single visual effect.
 *
 * Typically, this will be attached to an entity to display a temporary graphic, 
 * e.g. showing a heal graphic when an entity uses a health item.
 *
 * When the graphic is done playing, this effect is automatically destroyed.
 */
struct VisualEffectState {
    /** The definition that this is an instance of. */
    std::reference_wrapper<const VisualEffect> visualEffect;

    //-------------------------------------------------------------------------
    // Timing state (managed by WorldSpriteSorter)
    //-------------------------------------------------------------------------
    /** A timestamp of when this effect was started.
        If 0, this effect has not yet started playing. */
    double startTime{0};
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/ChunkUpdateSystem.h`:

```h
#pragma once

#include "QueuedEvents.h"
#include "ChunkUpdate.h"
#include "ChunkPosition.h"
#include <SDL_stdinc.h>

namespace AM
{
struct ChunkWireSnapshot;

namespace Client
{
struct SimulationContext;
class World;
class Network;
class SpriteData;
class TileMap;

/**
 * Requests needed tile map chunk data, and applies received chunk updates.
 */
class ChunkUpdateSystem
{
public:
    ChunkUpdateSystem(const SimulationContext& inSimContext);

    /**
     * Requests any needed chunk data and applies received chunk updates.
     */
    void updateChunks();

private:
    /**
     * Checks if we need new chunk data. If so, sends a ChunkUpdateRequest to
     * the server.
     */
    void requestNeededUpdates();

    /**
     * Requests all currently in-range chunks from the server.
     *
     * @param currentChunk  The chunk that we are currently in.
     */
    void requestAllInRangeChunks(const ChunkPosition& currentChunk);

    /**
     * Determines which chunks we just got in range of and requests them from
     * the server.
     *
     * @param previousChunk  The chunk that we were previously in.
     * @param currentChunk  The chunk that we are now in.
     */
    void requestNewInRangeChunks(const ChunkPosition& previousChunk,
                                 const ChunkPosition& currentChunk);

    /**
     * Receives any waiting chunk updates from the queue and applies them
     * to our tile map.
     */
    void receiveAndApplyUpdates();

    /**
     * Applies the given chunk snapshot's state to our tile map.
     */
    void applyChunkSnapshot(const ChunkWireSnapshot& chunkSnapshot);

    /** Used to access the player entity and components. */
    World& world;
    /** Used to send chunk update request messages and receive chunk updates. */
    Network& network;

    EventQueue<std::shared_ptr<const ChunkUpdate>> chunkUpdateQueue;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/ComponentUpdateSystem.h`:

```h
#pragma once

#include "ComponentUpdate.h"
#include "QueuedEvents.h"
#include <queue>

namespace AM
{
namespace Client
{
struct SimulationContext;
class Simulation;
class World;
class Network;
class GraphicData;

/**
 * Applies received entity component updates.
 */
class ComponentUpdateSystem
{
public:
    ComponentUpdateSystem(const SimulationContext& inSimContext);

    ~ComponentUpdateSystem();

    /**
     * Processes any received component updates.
     */
    void processUpdates();

private:
    void processComponentUpdate(const ComponentUpdate& componentUpdate);

    /**
     * Updates Collision state when a GraphicState is updated.
     * Neither component is replicated, so we need to maintain them ourselves.
     */
    void onGraphicStateUpdated(entt::registry& registry, entt::entity entity);

    /**
     * Updates the entity's collision in CollisionLocator.
     */
    void onCollisionBitSetsUpdated(entt::registry& registry,
                                   entt::entity entity);

    /** Used to get the current replication tick. */
    Simulation& simulation;
    /** Used to access the components we need to update. */
    World& world;
    /** Used to receive component update messages. */
    Network& network;
    /** Used to update components when GraphicState is updated. */
    GraphicData& graphicData;

    /** We pop messages off componentUpdateQueue and push them into here, so
        we can find and immediately process any messages for the player
        entity. */
    std::queue<ComponentUpdate> componentUpdateSecondaryQueue;

    EventQueue<ComponentUpdate> componentUpdateQueue;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/Components/AVEffects.h`:

```h
#pragma once

#include "VisualEffectState.h"
#include <vector>
#include <variant>

namespace AM
{
namespace Client
{

/**
 * Tracks all audio/visual effects that are currently active on an entity.
 */
struct AVEffects {
    /** This entity's currently active visual effects. */
    std::vector<VisualEffectState> visualEffects{};

    /** This entity's currently active audio effects. */
    //std::vector<AVEffect> avEffects{};
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/Components/ClientCastState.h`:

```h
#pragma once

#include "CastableID.h"
#include "CastInfo.h"
#include <SDL_stdinc.h>

namespace AM
{
namespace Client
{

/**
 * Tracks whether an entity is currently casting a Castable.
 * 
 * To match the behavior of Server::CastState, this component will only be 
 * present on an entity if a cast is currently ongoing. It gets removed when 
 * the cast ends.
 */
struct ClientCastState {
    /** The current cast's info. */
    CastInfo castInfo{};

    enum class State {
        /** A cast is ongoing. */
        Casting,
        /** The cast has successfully completed and the "cast complete" 
            graphic should be shown. */
        CastComplete
    };
    /** The casting state that the entity is currently in. */
    State state{};

    /** The tick that the current state will finish on. If 0, this cast hasn't 
        been processed for the first time yet. */
    Uint32 endTick{0};
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/Components/ClientGraphicState.h`:

```h
#pragma once

#include "EntityGraphicType.h"
#include "Rotation.h"

namespace AM
{
namespace Client
{
/**
 * Holds client-only graphic-related state.
 *
 * Note: This is modified by both the sim and Renderer/WorldSpriteSorter.
 *       Usually only sim classes are allowed to update components, but it's 
 *       convenient here.
 */
struct ClientGraphicState
{
    /** The entity's current graphic type.
        The systems that set this will make sure it's always a valid slot 
        within the entity's graphic set. */
    EntityGraphicType graphicType{};

    /** The rotation of the current graphic.
        The systems that set this will make sure it's always a valid slot 
        within the entity's graphic set. */
    Rotation::Direction graphicDirection{};

    //-------------------------------------------------------------------------
    // Timing state (managed by WorldSpriteSorter)
    //-------------------------------------------------------------------------
    /** A timestamp of when the current animation was started. */
    double animationStartTime{};

    /** If true, a new animation has begun and animationStartTime needs to be  
        reset when its first frame is rendered. */
    bool setStartTime{true};
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/Components/InputHistory.h`:

```h
#pragma once

#include "Input.h"
#include "Movement.h"
#include "CircularBuffer.h"

namespace AM
{
namespace Client
{
/**
 * Stores a history of inputs that have been applied to the player entity.
 *
 * Only used for the player entity. You can use this component to distinguish 
 * between player and non-player entities.
 */
struct InputHistory {
public:
    /**
     * The number of input snapshots that we'll remember.
     * TODO: If this is ever an issue, we can make CircularBuffer dynamic and
     *       exponentially grow it, and remove this.
     */
    static constexpr unsigned int LENGTH{20};

    /** Tracks the inputs that were applied to this entity.
        Increasing indices are further back in time--if index 0 is the current
        tick, index 1 is the previous tick, etc. */
    CircularBuffer<Input::StateArr, LENGTH> inputHistory;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/Components/NeedsAdjacentChunks.h`:

```h
#pragma once

namespace AM
{
namespace Client
{
/**
 * Used to flag that we've just connected or just teleported and need to load
 * all adjacent tile map chunks.
 */
struct NeedsAdjacentChunks {
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/EntityLifetimeSystem.h`:

```h
#pragma once

#include "Rotation.h"
#include "EntityInit.h"
#include "EntityDelete.h"
#include "QueuedEvents.h"
#include <queue>

namespace AM
{
struct EntityGraphicSet;

namespace Client
{
struct SimulationContext;
class Simulation;
class World;
class Network;
class GraphicData;

/**
 * Maintains the entity registry, constructing and deleting entities based
 * on messages from the server.
 */
class EntityLifetimeSystem
{
public:
    EntityLifetimeSystem(const SimulationContext& inSimContext);

    /**
     * Processes any waiting EntityInit or EntityDelete messages.
     */
    void processUpdates();

private:
    /**
     * Processes waiting EntityDelete messages, up to desiredTick.
     */
    void processEntityDeletes(Uint32 desiredTick);

    /**
     * Processes waiting EntityInit messages, up to desiredTick.
     */
    void processEntityInits(Uint32 desiredTick);
    void processEntityData(Uint32 tickNum,
                           const EntityInit::EntityData& entityData);

    /**
     * Handles any processing that's specific to the player entity.
     */
    void finishPlayerEntity();

    /** Used to get the current tick number. */
    Simulation& simulation;
    /** Used to access components. */
    World& world;
    /** Used to get graphics data when constructing entities. */
    GraphicData& graphicData;

    /** We pop messages off entityInitQueue and push them into here, so
        we can find and immediately process any messages for the player
        entity. */
    std::queue<EntityInit> entityInitSecondaryQueue;

    EventQueue<EntityInit> entityInitQueue;
    EventQueue<EntityDelete> entityDeleteQueue;
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/EnttGroups.h`:

```h
#pragma once

#include "Input.h"
#include "Position.h"
#include "PreviousPosition.h"
#include "Movement.h"
#include "MovementModifiers.h"
#include "Rotation.h"
#include "Collision.h"
#include "CollisionBitSets.h"
#include "InputHistory.h"
#include "GraphicState.h"
#include "entt/entity/registry.hpp"
#include <type_traits>

namespace AM
{
namespace Client
{
/**
 * A helper class for establishing and working with the entt groups that the  
 * client uses.
 * 
 * Groups can be finicky to work with. If you establish a group <Foo, Bar, Baz>
 * and later try to get group <Foo, Baz>, it'll result in a compiler error. 
 * To make them easier to work with, we provide these functions that return the 
 * most-restrictive versions of each group.
 *
 * Other less-restrictive groups may be made by hand (e.g. <Foo, Bar> in the 
 * above example), as long as they're compatible with the constraints imposed 
 * by these groups.
 */
class EnttGroups
{
public:
    /**
     * Returns the movement group, a group used for NPC movement and entity 
     * sprite sorting.
     */
    static auto getMovementGroup(entt::registry& registry)
    {
        return registry
            .group<Input, Position, PreviousPosition, Movement,
                   MovementModifiers, Rotation, Collision, CollisionBitSets>(
                entt::get<GraphicState>, entt::exclude<InputHistory>);
    }

    /**
     * Initializes all of the entt groups that the client uses.
     */
    static void init(entt::registry& registry)
    {
        getMovementGroup(registry);
    }
};

} // namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/Events/SimulationStarted.h`:

```h
#pragma once

#include "entt/fwd.hpp"

namespace AM
{
namespace Client
{

/**
 * An event to show that the simulation has started running.
 */
struct SimulationStarted
{
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/GraphicData/AnimationRenderData.h`:

```h
#pragma once

#include "Vector3.h"
#include <optional>

namespace AM
{
namespace Client
{

/**
 * Holds a animation's rendering-related data.
 *
 * We store any rendering-only data separately, so the server can optimally 
 * access only the data it needs.
 *
 * See Animation.h for the rest of the animation data.
 */
struct AnimationRenderData {
    /** Only used for entities, during render sorting.
        When entities change animation, the new animation needs to line up with
        the old one so the entity doesn't look like it's teleporting around. 
        If non-null, this is the model-space point that should be aligned 
        with IdleSouth. */
    std::optional<Vector3> entityAlignmentAnchor{};
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/GraphicData/GraphicData.h`:

```h
#pragma once

#include "GraphicDataBase.h"
#include "SpriteRenderData.h"
#include "AnimationRenderData.h"
#include <vector>

namespace AM
{
class AssetCache;

namespace Client
{
/**
 * See GraphicDataBase class comment.
 *
 * Beyond the parsing that GraphicDataBase performs, this class loads the
 * rendering-specific graphics data and provides an interface for accessing it.
 *
 * The data in this class is immutable. To modify it, edit ResourceData.json
 * using the ResourceImporter.
 */
class GraphicData : public GraphicDataBase
{
public:
    /**
     * Calls GraphicDataBase() constructor, then load the rendering-specific
     * graphics data from the given json.
     *
     * Errors if resourceDataJson doesn't contain a spriteSheets section.
     */
    GraphicData(const nlohmann::json& resourceDataJson, AssetCache& assetCache);

    /**
     * Get a sprite's render data, using its numeric ID.
     */
    const SpriteRenderData& getSpriteRenderData(SpriteID numericID) const;

    /**
     * Get an animation's render data, using its numeric ID.
     */
    const AnimationRenderData&
        getAnimationRenderData(AnimationID numericID) const;

    /**
     * Returns an appropriate world-space offset to use when rendering the 
     * given graphic from the given set.
     *
     * If the graphic is an Animation, its alignment offset will be returned.
     * If the graphic is a Sprite, {0, 0, 0} will be returned (Sprites don't 
     * support alignment offsets).
     *
     * Note: Alignment offsets aren't used by the sim. Instead, it just centers 
     *       IdleSouth's modelBounds on the entity's Position. The renderer 
     *       then needs to do some work to make sure the sprite lines up.
     */
    Vector3 getRenderAlignmentOffset(EntityGraphicSetID setID,
                                     EntityGraphicType graphicType,
                                     Rotation::Direction direction) const;

private:
    /**
     * Parses the given json, constructing graphics and pushing them into the
     * renderData vector.
     *
     * @param json  The json to parse. Must be loaded from a valid
     *              ResourceData.json.
     * @param assetCache  The asset cache to load sprite sheet textures into.
     */
    void parseJson(const nlohmann::json& json, AssetCache& assetCache);

    /**
     * Parses the given sprite json and adds the resulting sprite to the
     * spriteRenderData vector.
     *
     * @param spriteJson The json to parse. Must be a valid sprite section
     *                   from ResourceData.json.
     * @param spriteSheetRelPath The relative path to the sprite sheet image
     *                           file that holds this sprite.
     * @param texture The texture of the spritesheet that contains the sprite.
     */
    void parseSprite(const nlohmann::json& spriteJson,
                     const std::string& spriteSheetRelPath,
                     const TextureHandle& texture);

    /**
     * Parses the given animation json and adds the resulting animation to the
     * animationRenderData vector.
     *
     * @param animationJson The json to parse. Must be a valid animation section
     *                      from ResourceData.json.
     */
    void parseAnimation(const nlohmann::json& animationJson);

    /** The loaded rendering data for each sprite, indexed by their numeric
        IDs */
    std::vector<SpriteRenderData> spriteRenderData;

    /** The loaded rendering data for each animation, indexed by their numeric
        IDs */
    std::vector<AnimationRenderData> animationRenderData;
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/GraphicData/SpriteRenderData.h`:

```h
#pragma once

#include "AssetCache.h"
#include <SDL_rect.h>

namespace AM
{
namespace Client
{

/**
 * Holds a sprite's rendering-related data.
 *
 * We store any rendering-only data separately, so the server can optimally 
 * access only the data it needs.
 *
 * See Sprite.h for the rest of the sprite data.
 */
struct SpriteRenderData {
    /** The relative path to the sprite sheet image file that holds this
        sprite. Used for passing the sprite to our UI library, which has its
        own texture cache. */
    std::string spriteSheetRelPath{};

    /** The texture that contains this sprite. */
    std::shared_ptr<SDL_Texture> texture{};

    /** This sprite's actual-space UV position and size within its texture. */
    SDL_Rect textureExtent{0, 0, 0, 0};

    /** The actual-space point within the sprite where the "stage" starts.
        The "stage" is the coordinate space that we overlay onto the sprite 
        image. */
    SDL_Point stageOrigin{0, 0};

    /** If true, this sprite will have its alpha premultiplied. */
    bool premultiplyAlpha{false};
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/GraphicHelpers.h`:

```h
#pragma once

#include "GraphicSets.h"
#include "EntityGraphicType.h"
#include "Rotation.h"

namespace AM
{
namespace Client
{
/**
 * Shared static functions for updating graphics.
 */
class GraphicHelpers
{
public:
    struct GraphicReturn {
        EntityGraphicType type{};
        Rotation::Direction direction{};
    };
    /**
     * Tries to return a graphic from graphicSet, matching the desired graphic 
     * type and direction. If the set doesn't have a graphic in that slot, 
     * returns the closest matching graphic.
     */
    static GraphicReturn getGraphicOrFallback(
        const EntityGraphicSet& graphicSet, EntityGraphicType currentType,
        Rotation::Direction currentDirection, EntityGraphicType desiredType,
        Rotation::Direction desiredDirection);
};

} // End namespace Client
} // End namespace AM


```

`Source/ClientLib/Simulation/Public/GraphicSystem.h`:

```h
#pragma once

#include "EntityGraphicType.h"
#include "entt/fwd.hpp"

namespace AM
{
namespace Client
{
struct SimulationContext;
class World;
class GraphicData;
class ISimulationExtension;

/**
 * Handles updating each entity's graphic state to reflect their current sim 
 * state.
 *
 * Does not render anything (that's handled by Renderer).
 */
class GraphicSystem
{
public:
    GraphicSystem(const SimulationContext& inSimContext);

    /**
     * Updates each entity's sprite to reflect their current state.
     */
    void updateAnimations();

    void setExtension(ISimulationExtension* inExtension);

private:
    /**
     * Returns the desired graphic type for the given entity, based on its 
     * current state.
     */
    EntityGraphicType getDesiredGraphicType(entt::entity entity);

    /** Used to get entity GraphicState components. */
    World& world;

    /** Used to get entity graphics. */
    GraphicData& graphicData;

    /** If non-nullptr, contains the project's simulation extension functions.
        Used to give the project a chance to update entity graphics. */
    ISimulationExtension* extension;
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/ISimulationExtension.h`:

```h
#pragma once

#include "OSEventHandler.h"
#include "EntityGraphicType.h"
#include "entt/fwd.hpp"

namespace AM
{
namespace Client
{

/**
 * Defines an extension for the engine's Client::Simulation class.
 *
 * Extensions are implemented by the project, and are given generic functions
 * ("hooks") in which they can implement relevant project logic.
 *
 * The project can register the extension class with the engine through
 * Application::registerSimulationExtension().
 */
class ISimulationExtension : public OSEventHandler
{
public:
    // Canonical constructor (derived class must implement):
    // SimulationExtension(const SimulationContext& context)

    /**
     * Initializes or re-initializes our simulation systems.
     *
     * Used to put the systems in a consistent state, so they don't need to
     * account for disconnects/reconnects.
     */
    virtual void initializeSystems() = 0;

    /**
     * Called first in the simulation loop.
     */
    virtual void beforeAll() = 0;

    /**
     * Called after the tile map is updated and peer entities are added/removed.
     */
    virtual void afterMapAndConnectionUpdates() = 0;

    /**
     * Called after the general simulation update logic (movement, interactions,
     * etc.)
     */
    virtual void afterSimUpdate() = 0;

    /**
     * Called after all other systems.
     */
    virtual void afterAll() = 0;

    /**
     * See OSEventHandler for details.
     *
     * Note: Simulation will pass events to this class first. If the event is
     *       not handled, then Simulation will attempt to handle it.
     */
    bool handleOSEvent(SDL_Event& event) override = 0;

    //-------------------------------------------------------------------------
    // Simulation System Hooks (Hooks into engine systems)
    //-------------------------------------------------------------------------
    // These functions allow the project to affect various World state 
    // modifications.

    /**
     * Gives the project a chance to update the type of graphic that the given 
     * entity should use, based on its current sim state.
     *
     * The project must handle graphic type updates when the entity is doing 
     * something that the engine isn't aware of. For example, if the project 
     * implements swimming, this function should check if the entity is swimming
     * and return a Swimming graphic type if so.
     * 
     * If this function returns NotSet, the engine will set the entity's graphic 
     * type to one of the types in EngineEntityGraphicType.
     *
     * @return The entity's new graphic type, or NotSet if no project-implemented
     *         graphic types are appropriate.
     */
    virtual EntityGraphicType getUpdatedGraphicType(entt::entity entity) = 0;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/IconData/IconData.h`:

```h
#pragma once

#include "IconDataBase.h"
#include "IconRenderData.h"
#include <vector>

namespace AM
{
namespace Client
{
/**
 * See IconDataBase class comment.
 *
 * Beyond the parsing that IconDataBase performs, this class loads the
 * rendering-specific icon data and provides an interface for accessing it.
 *
 * The data in this class is immutable. To modify it, edit ResourceData.json
 * using the ResourceImporter.
 */
class IconData : public IconDataBase
{
public:
    /**
     * Calls IconDataBase() constructor, then load the rendering-specific
     * icon data from the given json.
     *
     * Note: We don't need to actually load any textures, since icons are
     *       only used by the UI (which manages its own textures).
     *
     * Errors if resourceDataJson doesn't contain a iconSheets section.
     */
    IconData(const nlohmann::json& resourceDataJson);

    /**
     * Get a icon's render data, using its string ID.
     */
    const IconRenderData& getRenderData(std::string_view stringID) const;

    /**
     * Get a icon's render data, using its numeric ID.
     */
    const IconRenderData& getRenderData(IconID numericID) const;

private:
    /**
     * Parses the given json, constructing icons and pushing them into the
     * renderData vector.
     *
     * @param json  The json to parse. Must be loaded from a valid
     *              ResourceData.json.
     */
    void parseJson(const nlohmann::json& json);

    /**
     * Parses the given icon json and adds the resulting icon to the
     * renderData vector.
     *
     * @param iconJson  The json to parse. Must be a valid icon section
     *                    from ResourceData.json.
     * @param iconSheetRelPath  The relative path to the icon sheet image
     *                            file that holds this icon.
     * @param texture  The texture of the iconsheet that contains the icon.
     */
    void parseIcon(const nlohmann::json& iconJson,
                   const std::string& iconSheetRelPath);

    /** The loaded rendering data for each icon, indexed by their numeric
        IDs */
    std::vector<IconRenderData> renderData;
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/IconData/IconRenderData.h`:

```h
#pragma once

#include "AssetCache.h"
#include <SDL_rect.h>

namespace AM
{
namespace Client
{

/**
 * Holds a icon's rendering-related data.
 *
 * See Icon.h for more info.
 */
struct IconRenderData {
    /** The relative path to the icon sheet image file that holds this
        icon. Used for passing the icon to our UI library, which has its
        own texture cache. */
    std::string iconSheetRelPath{};

    /** UV position and size in texture. */
    SDL_Rect textureExtent{0, 0, 0, 0};
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/InventorySystem.h`:

```h
#pragma once

#include "InventoryInit.h"
#include "InventoryOperation.h"
#include "QueuedEvents.h"

namespace AM
{
namespace Client
{
struct SimulationContext;
class World;
class Network;
class ItemData;

/**
 * Processes inventory updates and requests needed item definitions.
 */
class InventorySystem
{
public:
    InventorySystem(const SimulationContext& inSimContext);

    /**
     * Processes inventory update messages.
     */
    void processInventoryUpdates();

private:
    /**
     * Sets the player's inventory to the given state.
     */
    void initInventory(const InventoryInit& inventoryInit);

    /**
     * Adds the item to the player's inventory.
     */
    void processOperation(const InventoryAddItem& inventoryAddItem);

    /**
     * Removes the specified item from the player's inventory.
     */
    void processOperation(const InventoryRemoveItem& inventoryRemoveItem);

    /**
     * Moves the specified item to the specified slot in the player's
     * inventory.
     */
    void processOperation(const InventoryMoveItem& inventoryMoveItem);

    /** Used for accessing item and inventory data. */
    World& world;
    /** Used for sending requests and receiving inventory data. */
    Network& network;
    const ItemData& itemData;

    EventQueue<InventoryInit> inventoryInitQueue;
    EventQueue<InventoryOperation> inventoryOperationQueue;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/ItemData/ItemCache.h`:

```h
#pragma once

#include "Item.h"
#include <vector>

namespace AM
{
namespace Client
{

/**
 * Used to save/load ItemCache.bin.
 *
 * Holds a list of items in a serializable form.
 */
struct ItemCache
{
    /** Used as a "we should never hit this" cap on the number of items in the 
        cache. */
    static constexpr std::size_t MAX_ITEMS{10000};

    struct ItemEntry {
        Item item{};
        ItemVersion version{};
    };

    std::vector<ItemEntry> items{};
};

template<typename S>
void serialize(S& serializer, ItemCache::ItemEntry& itemEntry)
{
    serializer.object(itemEntry.item);
    serializer.value2b(itemEntry.version);
}

template<typename S>
void serialize(S& serializer, ItemCache& itemCache)
{
    serializer.container(itemCache.items, ItemCache::MAX_ITEMS);
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/ItemData/ItemData.h`:

```h
#pragma once

#include "ItemDataBase.h"

namespace AM
{
namespace Client
{
/**
 * See ItemDataBase class comment.
 */
class ItemData : public ItemDataBase
{
public:
    ItemData();
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/ItemSystem.h`:

```h
#pragma once

#include "ItemUpdate.h"
#include "CombineItems.h"
#include "QueuedEvents.h"

namespace AM
{
namespace Client
{
struct SimulationContext;
class World;
class Network;
class ItemData;

/**
 * Processes item definition updates and item combination updates.
 */
class ItemSystem
{
public:
    ItemSystem(const SimulationContext& inSimContext);
    ~ItemSystem();

    /**
     * Processes item update messages.
     */
    void processItemUpdates();

private:
    /**
     * Loads all items from ItemCache.bin into ItemData.
     */
    void loadItemCache();

    /**
     * Saves all items from ItemData into ItemCache.bin.
     */
    void saveItemCache();

    /** Used for updating inventories. */
    World& world;
    /** Used for sending requests and receiving item data. */
    Network& network;
    /** Used for accessing item data and subscribing to updates. */
    ItemData& itemData;

    EventQueue<ItemUpdate> itemUpdateQueue;
    EventQueue<CombineItems> combineItemsQueue;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/NpcMovementSystem.h`:

```h
#pragma once

#include "EntityMover.h"
#include "QueuedEvents.h"
#include <SDL_stdinc.h>

namespace AM
{
struct MovementUpdate;

namespace Client
{
struct SimulationContext;
class Simulation;
class World;
class Network;

/**
 * Processes NPC (non-player-controlled) entity update messages and moves their
 * entities appropriately.
 *
 * Note: By "NPC", we mean any entity that isn't controlled by this client's
 *       player. See IsClientEntity.h for more info.
 */
class NpcMovementSystem
{
public:
    NpcMovementSystem(const SimulationContext& inSimContext);

    /**
     * If we've received data for the appropriate ticks, updates all NPCs.
     * Else, does no updates, leaving NPCs where they are.
     */
    void updateNpcs();

private:
    /**
     * Initializes lastProcessedTick based on the sim's currentTick.
     */
    void initLastProcessedTick();

    /**
     * Moves all NPCs using their current inputs.
     */
    void moveAllNpcs();

    /**
     * Applies the given update message to the entity world state.
     */
    void applyUpdateMessage(const MovementUpdate& npcMovementUpdate);

    /**
     * Calls registry.patch() on each updated NPC's Position component to
     * trigger any on_update callbacks that are connected to them. We don't
     * patch until the end, because we may update the components multiple times
     * before we're done.
     *
     * Note: We only update Position because it's all we need right now. If
     *       the others are needed, they can be added.
     */
    void emitUpdateSignals();

    /** Used to get the current tick. */
    Simulation& simulation;
    /** Used to access components. */
    World& world;
    /** Used to send entity info request messages. */
    Network& network;

    EntityMover entityMover;

    EventQueue<std::shared_ptr<const MovementUpdate>> npcMovementUpdateQueue;

    /** The last tick that we processed update data for. */
    Uint32 lastProcessedTick;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/PlayerInputSystem.h`:

```h
#pragma once

#include "Network.h"
#include <SDL_events.h>

namespace AM
{
namespace Client
{
struct SimulationContext;
class Simulation;
class World;
class Network;

/**
 * Processes the player's input state.
 *
 * Performs updates locally, and sends state change requests to the server.
 * If a change is refused, PlayerMovementSystem will handle the resolution of
 * our local state.
 */
class PlayerInputSystem
{
public:
    PlayerInputSystem(const SimulationContext& inSimContext);

    /**
     * Updates the player's input state with the given event.
     */
    void processMomentaryInput(SDL_Event& event);

    /**
     * Processes held inputs (movement, etc).
     * @pre SDL_PollEvent or SDL_PumpEvents must have been recently called.
     */
    void processHeldInputs();

    /**
     * Adds the current player input state to the world's playerInputHistory.
     */
    void addCurrentInputsToHistory();

private:
    /**
     * Processes any mouse wheel movement since the last tick.
     */
    void processMouseWheel(SDL_MouseWheelEvent& wheelEvent);

    Simulation& simulation;
    World& world;
    Network& network;

    /** The index within ZOOM_LEVELS that is currently selected. */
    std::size_t currentZoomLevelIndex;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/PlayerMovementSystem.h`:

```h
#pragma once

#include "EntityMover.h"
#include "PlayerMovementUpdate.h"
#include "QueuedEvents.h"
#include <SDL_stdinc.h>

namespace AM
{
namespace Client
{
struct SimulationContext;
class Simulation;
class World;
class Network;

/**
 * Processes movement update messages for the player's entity and moves the
 * entity appropriately.
 *
 * Since the player entity is simulated in the future (in relation to the 
 * server), any situation where the player's movement changes in a way that we
 * can't predict (buffs/debuffs, gear changes, etc), we potentially will fall 
 * out of sync.
 * We soft-solve this by having the server "announce" changes instead of 
 * immediately performing them. Instead of immediately applying the debuff, the 
 * server must announce "this debuff will apply on tick X". This gives the 
 * the client time to receive the message and apply the change on the same tick 
 * as the server.
 * If the client receives the message late, a desync is unavoidable. The client 
 * must request a resync and deal with whatever rubberbanding occurs.
 */
class PlayerMovementSystem
{
public:
    PlayerMovementSystem(const SimulationContext& inSimContext);

    /**
     * Processes the player entity's movement for this tick.
     *
     * If we received any player entity movement updates from the server,
     * applies them and replays inputs.
     */
    void processMovement();

private:
    /**
     * Processes any waiting player entity updates (sent by the server).
     *
     * @return The tick number of the newest message that we received.
     */
    Uint32 processPlayerUpdates();

    /**
     * Replay any inputs that are from newer ticks than lastUpdateTick.
     */
    void replayInputs(Uint32 lastUpdateTick);

    /**
     * Processes a single tick of player entity movement.
     *
     * @param inputStates The input state to use to move the entity.
     *                 
     */
    void movePlayerEntity(const Input::StateArr& inputStates);

    /**
     * Calls registry.patch() on the player's Position component to trigger
     * any on_update callbacks that are connected to them.
     * We don't patch until the end, because we may update the components
     * multiple times before we're done.
     *
     * Note: We only update Position because it's all we need right now. If
     *       the others are needed, they can be added.
     */
    void emitUpdateSignals();

    /** Debug printing, asserting. */
    void printMismatchInfo(Uint32 lastUpdateTick);
    void checkReceivedTickValidity(Uint32 updateTick, Uint32 currentTick);
    bool checkTickDiffValidity(Uint32 tickDiff);

    /** Used to get the current tick. */
    Simulation& simulation;
    /** Used to access components. */
    World& world;
    /** Used to get the latest received tick. */
    Network& network;

    EntityMover entityMover;

    EventQueue<PlayerMovementUpdate> playerMovementUpdateQueue;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/ReplicationTickOffset.h`:

```h
#pragma once

#include "Config.h"

namespace AM
{
namespace Client
{
/**
 * Represents a tick offset used while replicating non-predicted state, such
 * as NPC movement and tile map updates.
 *
 * This tick offset is negative, representing some point in the past.
 */
struct ReplicationTickOffset {
public:
    /**
     * Applies the given tick adjustment (received from the server) to
     * this offset.
     */
    void applyAdjustment(int adjustment);

    /**
     * Returns the value of this tick offset.
     */
    int get() const;

private:
    /** How far into the past to replicate at.
        e.g. If offset == -5, on tick 15 we'll replicate NPC data for tick 10.
        */
    int offset{Config::INITIAL_REPLICATION_OFFSET};
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/ServerConnectionSystem.h`:

```h
#pragma once

#include "QueuedEvents.h"
#include "ConnectionRequest.h"
#include "ConnectionResponse.h"
#include "ConnectionError.h"
#include "Timer.h"
#include "entt/signal/fwd.hpp"
#include "SDL_stdinc.h"
#include <queue>
#include <atomic>

namespace AM
{
namespace Client
{
struct SimulationContext;
class Simulation;
class World;
class Network;
class GraphicData;

/**
 * Processes server connect/disconnect events and initializes the sim state
 * when we connect.
 */
class ServerConnectionSystem
{
public:
    enum class ConnectionState { Disconnected, AwaitingResponse, Connected };

    ServerConnectionSystem(const SimulationContext& inSimContext,
                           std::atomic<Uint32>& inCurrentTick);

    /**
     * Waits for connection events from the UI. When one is received, attempts
     * to connect to the server.
     *
     * While connected, detects disconnects and sends the disconnect event.
     */
    void processConnectionEvents();

    /** Returns the current state of our connection to the server. */
    ConnectionState getConnectionState();

private:
    /** How long the sim should wait for the server to send a connection
        response, in seconds. */
    static constexpr double CONNECTION_RESPONSE_WAIT_S{5};

    void onUIConnectionRequest(ConnectionRequest& connectionRequest);

    /**
     * Requests to connect to the game server, waits for an assigned EntityID,
     * and constructs the player.
     */
    void initSimState(ConnectionResponse& connectionResponse);

    /**
     * Fills in player data as if we connected to the server.
     */
    void initMockSimState();

    /**
     * Clears all sim state. Used when the connection is lost.
     */
    void clearSimState();

    World& world;
    Network& network;
    GraphicData& graphicData;

    /** Used to send connection events to the UI. */
    entt::dispatcher& simEventDispatcher;

    /** The sim's current tick. Set when we receive a connection response.
        Note: This is the only system that should have a mutable reference. */
    std::atomic<Uint32>& currentTick;

    /** Connection requests, received from the UI. */
    std::queue<ConnectionRequest> connectionRequestQueue;

    /** Connection responses, received from the server. */
    EventQueue<ConnectionResponse> connectionResponseQueue;

    /** Connection error events, received from the server. */
    EventQueue<ConnectionError> connectionErrorQueue;

    /** Tracks the state of our connection with the server. */
    ConnectionState connectionState;

    /** Times our connection attempt, so we can time out if necessary. */
    Timer connectionAttemptTimer;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/Simulation.h`:

```h
#pragma once

#include "OSEventHandler.h"
#include "World.h"
#include "ServerConnectionSystem.h"
#include "ReplicationTickOffset.h"
#include "ConnectionError.h"
#include <atomic>

namespace AM
{
class CastableData;
struct Item;
struct CastFailed;

namespace Client
{
struct SimulationContext;
class Network;
class GraphicData;
class ItemData;
class ISimulationExtension;
class ChunkUpdateSystem;
class TileUpdateSystem;
class EntityLifetimeSystem;
class PlayerInputSystem;
class PlayerMovementSystem;
class NpcMovementSystem;
class ItemSystem;
class InventorySystem;
class CastSystem;
class ComponentUpdateSystem;
class GraphicSystem;
class AVSystem;
class CameraSystem;

/**
 * Manages the simulation, including world state and system processing.
 *
 * The simulation is built on an ECS architecture:
 *   Entities exist in a registry, owned by the World class.
 *   Components that hold data are attached to each entity.
 *   Systems that act on sets of components are owned and ran by this class.
 */
class Simulation : public OSEventHandler
{
public:
    /** An unreasonable amount of time for the sim tick to be late by. */
    static constexpr double SIM_DELAYED_TIME_S{.001};

    Simulation(const SimulationContext& inSimContext);

    ~Simulation();

    /**
     * Returns a reference to the simulation's world state.
     */
    World& getWorld();
    const World& getWorld() const;

    /**
     * Returns our current tick.
     *
     * Our current tick aims to be some amount ahead of the server, so that
     * our messages will arrive before their intended tick is processed.
     *
     * Note: This is used for predicted state (such as player movement).
     */
    Uint32 getCurrentTick() const;

    /**
     * Returns the tick that we're replicating non-predicted server state at.
     *
     * Our replication tick aims to be some amount behind the server, so that
     * we can smoothly replicate the received server state without network
     * inconsistencies causing choppiness.
     *
     * Note: This is used for non-predicted state (such as NPC movement).
     */
    Uint32 getReplicationTick() const;

    /**
     * Processes the next sim iteration.
     */
    void tick();

    /**
     * Handles user input events, specifically mouse and momentary events.
     * Note: If the pre-tick handling of these events ever becomes an issue,
     *       we could instead queue them, to be processed during the tick.
     */
    bool handleOSEvent(SDL_Event& event) override;

    /**
     * See extension member comment.
     */
    void setExtension(ISimulationExtension* inExtension);

private:
    /**
     * Initializes or re-initializes our simulation systems.
     *
     * Used to put the systems in a consistent state, so they don't need to
     * account for disconnects/reconnects.
     */
    void initializeSystems();

    /** Note: We save this since we need to pass it to the systems at deferred-
              initialization time. */
    const SimulationContext& simContext;

    /** Used to receive events (through the Network's dispatcher) and to
        send messages. */
    Network& network;
    GraphicData& graphicData;
    ItemData& itemData;
    CastableData& castableData;

    /** The local world's state. */
    World world;

    /** The tick number that we're currently on.
        Initialized based on the number that the server tells us it's on. */
    std::atomic<Uint32> currentTick;

    /** How far into the past to replicate non-predicted state at. */
    ReplicationTickOffset replicationTickOffset;

    /** Contains the project's simulation extension functions.
        Allows the project to provide simulation code and have it be called at
        the appropriate time. */
    ISimulationExtension* extension;

    //-------------------------------------------------------------------------
    // Systems
    //-------------------------------------------------------------------------
    // Note: This system is always alive, so it can process connection events.
    ServerConnectionSystem serverConnectionSystem;

    // Note: These are pointers so that we can delete/reconstruct them when we
    //       connect to the server. This gives them a consistent starting state.
    std::unique_ptr<ChunkUpdateSystem> chunkUpdateSystem;
    std::unique_ptr<TileUpdateSystem> tileUpdateSystem;
    std::unique_ptr<EntityLifetimeSystem> entityLifetimeSystem;
    std::unique_ptr<PlayerInputSystem> playerInputSystem;
    std::unique_ptr<PlayerMovementSystem> playerMovementSystem;
    std::unique_ptr<NpcMovementSystem> npcMovementSystem;
    std::unique_ptr<ItemSystem> itemSystem;
    std::unique_ptr<InventorySystem> inventorySystem;
    std::unique_ptr<CastSystem> castSystem;
    std::unique_ptr<ComponentUpdateSystem> componentUpdateSystem;
    std::unique_ptr<GraphicSystem> graphicSystem;
    std::unique_ptr<AVSystem> avSystem;
    std::unique_ptr<CameraSystem> cameraSystem;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/SimulationContext.h`:

```h
#pragma once

#include "entt/signal/fwd.hpp"

namespace AM
{
class EventDispatcher;
class CastableData;

namespace Client
{
class Simulation;
class Network;
class GraphicData;
class IconData;
class ItemData;

/**
 * Provides the dependencies that the project's Simulation objects may use.
 */
struct SimulationContext {
public:
    /** World state, current tick. */
    Simulation& simulation;

    /** Server messaging. */
    Network& network;

    /** Sim -> UI events. */
    entt::dispatcher& simEventDispatcher;

    /** UI -> Sim events. */
    entt::dispatcher& uiEventDispatcher;

    /** Network -> Sim/UI message events. */
    EventDispatcher& networkEventDispatcher;

    GraphicData& graphicData;

    IconData& iconData;

    ItemData& itemData;

    CastableData& castableData;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/TileMap/TileMap.h`:

```h
#pragma once

#include "TileMapBase.h"
#include "entt/signal/sigh.hpp"
#include <SDL_stdinc.h>

namespace AM
{
class CollisionLocator;

namespace Client
{
class GraphicData;

/**
 * Owns and manages the world's tile map state.
 * Tiles are conceptually organized into 16x16 chunks.
 *
 * Tile map data is streamed from the server at runtime.
 */
class TileMap : public TileMapBase
{
public:
    /**
     * Attempts to parse TileMap.bin and construct the tile map.
     *
     * Errors if TileMap.bin doesn't exist or it fails to parse.
     */
    TileMap(const GraphicData& inGraphicData,
            CollisionLocator& inCollisionLocator);

    /**
     * Sets the size of the map and resizes the chunks vector.
     */
    void setMapSize(Uint16 inMapXLengthChunks, Uint16 inMapYLengthChunks,
                    Uint16 inMapZLengthChunks);

private:
    entt::sigh<void(TileExtent)> sizeChangedSig;

public:
    /** The tile map's size (extent) has changed. */
    entt::sink<entt::sigh<void(TileExtent)>> sizeChanged;
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Simulation/Public/TileUpdateSystem.h`:

```h
#pragma once

#include "QueuedEvents.h"
#include "TileAddLayer.h"
#include "TileRemoveLayer.h"
#include "TileClearLayers.h"
#include "TileExtentClearLayers.h"

namespace AM
{
namespace Client
{
struct SimulationContext;
class World;
class Network;

/**
 * Processes tile updates.
 *
 * Note: If an updated tile collides with an entity, visual desyncs can occur.
 *       This client-side visual desync can occur for NPC entities as well as
 *       the player entity.
 *       This desync is easily fixed, the offending entity just needs to change
 *       inputs. The received authoritative state will correct the desync.
 *       In the future, we may wish to build a more sophisticated solution.
 */
class TileUpdateSystem
{
public:
    TileUpdateSystem(const SimulationContext& inSimContext);

    /**
     * Processes received tile updates, applying them to the tile map.
     */
    void updateTiles();

private:
    /**
     * Adds the tile layer to the map.
     */
    void addTileLayer(const TileAddLayer& addLayer);

    /**
     * Removes the tile layer from the map.
     */
    void remTileLayer(const TileRemoveLayer& remLayer);

    /**
     * Clears the tile layers from the map.
     */
    void clearTileLayers(const TileClearLayers& clearLayers);

    /**
     * Clears the tile layers from the map.
     */
    void clearExtentLayers(const TileExtentClearLayers& clearExtentLayers);

    /** Used to access the tile map. */
    World& world;
    /** Used to receive tile updates. */
    Network& network;

    /** Tile updates, received from the network. */
    EventQueue<TileAddLayer> addLayerQueue;
    EventQueue<TileRemoveLayer> removeLayerQueue;
    EventQueue<TileClearLayers> clearLayersQueue;
    EventQueue<TileExtentClearLayers> extentClearLayersQueue;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/World.h`:

```h
#pragma once

#include "TileMap.h"
#include "EntityLocator.h"
#include "CollisionLocator.h"
#include "CastHelper.h"
#include "AVEntityID.h"
#include "entt/entity/registry.hpp"

struct SDL_Rect;

namespace AM
{
class CastableData;

namespace Client
{
struct SimulationContext;
class Simulation;
class Network;
class GraphicData;
class ItemData;

/**
 * Owns and manages the persistence of all world state.
 *
 * The client's world state consists of:
 *   Map data
 *     See TileMap.h
 *   Entity data
 *     Maintained at runtime in an ECS registry.
 *
 * Also provides helpers for common uses of world state.
 */
class World
{
public:
    World(const SimulationContext& inSimContext);

    /** Server-synchronized entity data registry. For entity state that we try
        to keep in sync with the server. */
    entt::registry registry;

    /** Audio/visual entity data registry. A/V entities are processed 
        by AVSystem and aren't synchronized with the server and other 
        clients. */
    entt::basic_registry<AVEntityID> avRegistry;

    /** The entity that this client is controlling. */
    entt::entity playerEntity;

    /** Spatial partitioning grid for efficiently locating entities by
        position. */
    EntityLocator entityLocator;

    /** Spatial partitioning grid for efficiently locating entities and tile 
        layers by their collision volumes. */
    CollisionLocator collisionLocator;

    /** The tile map that makes up the world. */
    TileMap tileMap;

    /** Helper class for casting Castables. */
    CastHelper castHelper;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/Simulation/Public/WorldObjectID.h`:

```h
#pragma once

#include "TileLayerID.h"
#include "AVEntityID.h"
#include "entt/fwd.hpp"
#include <variant>

namespace AM
{
namespace Client
{

/**
 * A variant used when we need to generically identify an object from the
 * simulation's World.
 *
 * Useful, e.g., when returning the object that the user clicked on.
 *
 * Note: "Object" doesn't mean the same as when we say "Object tile layer".
 *       A better name for this would be welcome.
 */
using WorldObjectID
    = std::variant<std::monostate, TileLayerID, entt::entity, AVEntityID>;

} // namespace Client
} // namespace AM

```

`Source/ClientLib/UserInterface/CMakeLists.txt`:

```txt
target_sources(ClientLib
    PRIVATE
        Private/UserInterface.cpp
        Private/WorldObjectLocator.cpp
    PUBLIC
        Public/IUserInterfaceExtension.h
        Public/PhantomSpriteInfo.h
        Public/SpriteColorModInfo.h
        Public/UserInterface.h
        Public/UserInterfaceContext.h
        Public/WorldObjectLocator.h
)

target_include_directories(ClientLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ClientLib/UserInterface/Private/UserInterface.cpp`:

```cpp
#include "UserInterface.h"
#include "UserInterfaceContext.h"
#include "Simulation.h"
#include "Config.h"
#include "Camera.h"
#include "IUserInterfaceExtension.h"
#include "SharedConfig.h"
#include "UserConfig.h"
#include "Transforms.h"
#include "ClientTransforms.h"
#include "Log.h"

namespace AM
{
namespace Client
{

UserInterface::UserInterface(const UserInterfaceContext& inUIContext)
: world{inUIContext.simulation.getWorld()}
, extension{nullptr}
, worldObjectLocator{}
{
}

std::vector<PhantomSpriteInfo> UserInterface::getPhantomSprites() const
{
    // Get the project's phantom tiles.
    return extension->getPhantomSprites();
}

std::vector<SpriteColorModInfo> UserInterface::getSpriteColorMods() const
{
    // Get the project's tile color mods.
    return extension->getSpriteColorMods();
}

void UserInterface::tick(double timestepS)
{
    // Call the project's UI tick logic.
    extension->tick(timestepS);
}

void UserInterface::render(const Camera& camera,
                           const std::vector<SpriteSortInfo>& sortedSprites)
{
    // Call the project's UI rendering logic.
    extension->render(camera);

    // Update our locator's data and fill it with the latest sprites.
    worldObjectLocator.setCamera(camera);
    worldObjectLocator.setExtent(
        camera.getTileViewExtent(world.tileMap.getTileExtent()));

    worldObjectLocator.clear();
    for (const SpriteSortInfo& spriteInfo : sortedSprites) {
        // If this sprite isn't a full phantom or an A/V entity, add it.
        if (!std::get_if<std::monostate>(&(spriteInfo.spriteOwnerID))
            && !std::get_if<AVEntityID>(&(spriteInfo.spriteOwnerID))) {
            worldObjectLocator.addWorldObject(spriteInfo.spriteOwnerID,
                                              spriteInfo.worldBounds);
        }
    }
}

bool UserInterface::handleOSEvent(SDL_Event& event)
{
    // Let the project handle it.
    return extension->handleOSEvent(event);
}

const WorldObjectLocator& UserInterface::getWorldObjectLocator()
{
    return worldObjectLocator;
}

void UserInterface::setExtension(IUserInterfaceExtension* inExtension)
{
    extension = inExtension;
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/UserInterface/Private/WorldObjectLocator.cpp`:

```cpp
#include "WorldObjectLocator.h"
#include "SDLHelpers.h"
#include "Transforms.h"
#include "AMAssert.h"
#include "entt/entity/entity.hpp"
#include <stdexcept>
#include <cmath>

namespace AM
{
namespace Client
{

WorldObjectLocator::WorldObjectLocator()
: locatorBounds{}
, locatorCellExtent{}
, camera{}
, objectMap{}
{
}

void WorldObjectLocator::addWorldObject(const WorldObjectID& objectID,
                                        const BoundingBox& objectWorldBounds)
{
    // If objectID is empty, fail.
    if (std::get_if<std::monostate>(&objectID)) {
        LOG_ERROR("Tried to use an empty world object ID.");
    }

    // Find the cells that the bounding box intersects.
    CellExtent boxCellExtent(objectWorldBounds, CELL_WORLD_WIDTH,
                             CELL_WORLD_HEIGHT);

    // Make sure each length is at least 1, or else the box won't be added to 
    // any cells.
    // (This occurs if the box forms a plane.)
    if (boxCellExtent.xLength < 1) {
        boxCellExtent.xLength = 1;
    }
    if (boxCellExtent.yLength < 1) {
        boxCellExtent.yLength = 1;
    }
    if (boxCellExtent.zLength < 1) {
        boxCellExtent.zLength = 1;
    }

    // Add the object to all the cells that it occupies.
    for (int z{boxCellExtent.z}; z <= boxCellExtent.zMax(); ++z) {
        for (int y{boxCellExtent.y}; y <= boxCellExtent.yMax(); ++y) {
            for (int x{boxCellExtent.x}; x <= boxCellExtent.xMax(); ++x) {
                std::vector<WorldObject>& objectVec{objectMap[{x, y, z}]};
                objectVec.emplace_back(objectID, objectWorldBounds);
            }
        }
    }
}

WorldObjectID
    WorldObjectLocator::getObjectUnderPoint(const SDL_Point& screenPoint) const
{
    // DDA Algorithm Ref: https://lodev.org/cgtutor/raycasting.html
    //                    https://www.youtube.com/watch?v=NbSee-XM7WA

    // Cast a world-space ray from the plane formed by camera.target.z to the 
    // given point on the screen.
    std::optional<Ray> rayOpt{Transforms::screenToWorldRay(
        SDLHelpers::pointToFPoint(screenPoint), camera)};
    if (!(rayOpt.has_value())) {
        return {};
    }
    Ray& ray{rayOpt.value()};

    // Calc the t values of how long we have to travel along the ray to
    // fully move through 1 cell in each direction.
    // Note: Since our ray is from our iso camera, X/Y will always be equal.
    const float unitStepX{std::abs(1 / ray.direction.x)};
    const float unitStepZ{std::abs(1 / ray.direction.z)};
    const float cellStepX{unitStepX * CELL_WORLD_WIDTH};
    const float cellStepY{cellStepX};
    const float cellStepZ{unitStepZ * CELL_WORLD_HEIGHT};

    // These hold the t values where the next intersection occurs in each 
    // direction.
    // Note: Dividing by CELL_WORLD_ gives us a ratio of total cell size, 
    //       which we can then multiply by cellStep to get "how much of a 
    //       step would we have to make along the ray to reach the next cell".
    CellPosition currentCellPosition(TilePosition(ray.origin),
                                     Config::WORLD_OBJECT_LOCATOR_CELL_WIDTH,
                                     Config::WORLD_OBJECT_LOCATOR_CELL_HEIGHT);
    float nextIntersectionX{
        (ray.origin.x - (currentCellPosition.x * CELL_WORLD_WIDTH))
        / CELL_WORLD_WIDTH * cellStepX};
    float nextIntersectionY{
        (ray.origin.y - (currentCellPosition.y * CELL_WORLD_WIDTH))
        / CELL_WORLD_WIDTH * cellStepY};
    float nextIntersectionZ{
        (ray.origin.z - (currentCellPosition.z * CELL_WORLD_HEIGHT))
        / CELL_WORLD_HEIGHT * cellStepZ};

    // Find the furthest intersection between the ray and the camera's view
    // bounds, so we know where to stop the walk (tMin will be invalid since our
    // point is inside the bounds).
    // Note: This ray starts at the camera bounds and travels downwards.
    auto [didIntersect, _, tMax] = camera.viewBounds.intersects(
        ray, 0, std::numeric_limits<float>::infinity());
    AM_ASSERT(didIntersect,
              "Ray towards screen failed to intersect camera's view bounds.");
    Position viewIntersection{ray.getPointAtT(tMax)};
    CellPosition endCellPosition{TilePosition(viewIntersection),
                                 Config::WORLD_OBJECT_LOCATOR_CELL_WIDTH,
                                 Config::WORLD_OBJECT_LOCATOR_CELL_HEIGHT};

    // Walk along the ray, checking each cell for a hit world object.
    // (We iterate until we walk past the end position along some axis).
    while ((currentCellPosition.x >= endCellPosition.x)
           && (currentCellPosition.y >= endCellPosition.y)
           && (currentCellPosition.z >= endCellPosition.z)) {
        // If an object in this cell intersects the ray, return it.
        auto pair{objectMap.find(currentCellPosition)};
        if (pair != objectMap.end()) {
            const std::vector<WorldObject>& objectVector{pair->second};

            // Note: Objects are in render order, so we need to reverse iterate.
            for (auto it{objectVector.rbegin()}; it != objectVector.rend();
                 ++it) {
                const WorldObject& object{*it};
                if (object.worldBounds.intersects(ray)) {
                    return object.objectID;
                }
            }
        }

        // Move towards the next closest cell.
        if ((nextIntersectionX < nextIntersectionY)
            && (nextIntersectionX < nextIntersectionZ)) {
            nextIntersectionX += cellStepX;
            currentCellPosition.x -= 1;
        }
        else if ((nextIntersectionY < nextIntersectionX)
            && (nextIntersectionY < nextIntersectionZ)) {
            nextIntersectionY += cellStepY;
            currentCellPosition.y -= 1;
        }
        else {
            nextIntersectionZ += cellStepZ;
            currentCellPosition.z -= 1;
        }
    }

    // No intersected object found. Return null.
    return {};
}

void WorldObjectLocator::clear()
{
    objectMap.clear();
}

void WorldObjectLocator::setCamera(const Camera& inCamera)
{
    camera = inCamera;
}

void WorldObjectLocator::setExtent(const TileExtent& inTileExtent)
{
    locatorBounds = BoundingBox(inTileExtent);
    // Note: We don't want our rays to immediately intersect with these bounds,
    //       so we drop the Z bound below the extent.
    locatorBounds.min.z -= 0.1f;

    locatorCellExtent
        = CellExtent(inTileExtent, Config::WORLD_OBJECT_LOCATOR_CELL_WIDTH,
                     Config::WORLD_OBJECT_LOCATOR_CELL_HEIGHT);
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/UserInterface/Public/IUserInterfaceExtension.h`:

```h
#pragma once

#include "OSEventHandler.h"
#include "PhantomSpriteInfo.h"
#include "SpriteColorModInfo.h"
#include <vector>

namespace AM
{
struct Camera;

namespace Client
{

/**
 * Defines an extension for the engine's Client::UserInterface class.
 *
 * Extensions are implemented by the project, and are given generic functions
 * ("hooks") in which they can implement relevant project logic.
 *
 * The project can register the extension class with the engine through
 * Application::registerUserInterfaceExtension().
 */
class IUserInterfaceExtension : public OSEventHandler
{
public:
    // Canonical constructor (derived class must implement):
    // UserInterfaceExtension(const UserInterfaceContext& uiContext)

    /**
     * Returns all of the project UI's phantom sprites.
     * Phantom sprites are used when you want to visually add or replace a tile
     * layer or entity without actually modifying the sim.
     */
    virtual std::vector<PhantomSpriteInfo> getPhantomSprites() const = 0;

    /**
     * Returns all of the project UI's sprite color modifications.
     * Color mods are used when you want to modify the color or transparency
     * of a tile layer or entity.
     */
    virtual std::vector<SpriteColorModInfo> getSpriteColorMods() const = 0;

    /**
     * Called during the UI tick.
     *
     * @param tick  The time since this function was last called.
     */
    virtual void tick(double timestepS) = 0;

    /**
     * Called when the UI should be rendered.
     *
     * @param camera  The camera to calculate screen position with.
     */
    virtual void render(const Camera& camera) = 0;

    /**
     * See OSEventHandler for details.
     */
    bool handleOSEvent(SDL_Event& event) override = 0;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/UserInterface/Public/PhantomSpriteInfo.h`:

```h
#pragma once

#include "TilePosition.h"
#include "TileLayer.h"
#include "TileOffset.h"
#include "Wall.h"
#include "Position.h"
#include "Rotation.h"
#include "Sprite.h"

namespace AM
{
struct Sprite;
namespace Client
{

/**
 * Used by the UI when it wants a "phantom" sprite to be shown to the user.
 *
 * This can either be a tile phantom, or an entity phantom (see layerType's
 * comment).
 *
 * Phantoms are visual-only, so they're purely a UI/Renderer concern and don't
 * get added to the simulation.
 *
 * Terrain and Wall tile layer phantoms will replace any sprites in the same 
 * spot. Objects and other tile layer types will be added on top instead of 
 * replacing.
 *
 * An example usage is when a user is in build mode and is trying to place a
 * wall. A phantom wall sprite will follow the user's mouse to show where the
 * wall will be placed when they click.
 *
 * Note: Currently we only support phantom sprites. If we ever want to support 
 *       phantom animations, this should be renamed to PhantomGraphicInfo and 
 *       replace Sprite with GraphicRef.
 */
struct PhantomSpriteInfo {
    /** If this is a tile phantom, this is the position of the phantom's tile. */
    TilePosition tilePosition{};

    /** If this is a Floor or Object tile phantom, this is the phantom's offset
        relative to tilePosition.
        Note: Terrain and Wall phantoms shouldn't be given offsets, 
              they're already handled by WorldSpriteSorter. */
    TileOffset tileOffset{};

    /** The phantom's tile layer type. If this != None, this is a tile phantom.
        If this == None, this is an entity phantom. */
    TileLayer::Type layerType{TileLayer::Type::None};

    /** If layerType == Wall, this is the type of wall. */
    Wall::Type wallType{Wall::Type::None};

    /** If this is an entity phantom (layerType == None), this is the phantom's
        world position. */
    Position position{};

    /** The graphic set of the phantom sprite to add. */
    const GraphicSet* graphicSet{nullptr};

    /** The graphic value of the phantom sprite to add. */
    Uint8 graphicValue{};

    /** If this is an entity phantom (layerType == None), this is the phantom's
        graphic direction. */
    Rotation::Direction graphicDirection{};
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/UserInterface/Public/SpriteColorModInfo.h`:

```h
#pragma once

#include "WorldObjectID.h"
#include <SDL_pixels.h>

namespace AM
{
namespace Client
{

/**
 * Used by the UI when it wants a sprite to have its color and/or transparency
 * modified.
 */
struct SpriteColorModInfo {
    /** The world object that we want to modify the color of.
        Note: Since phantom entities don't have an entity ID, you can use
              entt::null to target them. */
    WorldObjectID objectToModify;

    /** The color and transparency to multiply the sprite by.
        Note: Instead of directly multiplying the sprite by this color (which
              would make it darker), we render an additional sprite with an
              additive blend mode and multiply that one by this color.
              Alpha is applied to both sprites. */
    SDL_Color colorMod{0, 0, 0, 255};
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/UserInterface/Public/UserInterface.h`:

```h
#pragma once

#include "OSEventHandler.h"
#include "PhantomSpriteInfo.h"
#include "SpriteColorModInfo.h"
#include "SpriteSortInfo.h"
#include "WorldObjectLocator.h"
#include <memory>

namespace AM
{
struct Camera;

namespace Client
{
struct UserInterfaceContext;
class World;
class IUserInterfaceExtension;

/**
 * Drives the project's UI through the extension interface.
 *
 * Provides a way for the Renderer to know how the UI wants to affect the world
 * rendering (which sprites to highlight, phantom sprites to insert for build
 * mode, etc).
 */
class UserInterface : public OSEventHandler
{
public:
    UserInterface(const UserInterfaceContext& inUIContext);

    /**
     * Returns all of the project UI's phantom sprites.
     * Phantom sprites are used when you want to visually add or replace a tile
     * layer or entity without actually modifying the sim.
     */
    std::vector<PhantomSpriteInfo> getPhantomSprites() const;

    /**
     * Returns all of the project UI's sprite color modifications.
     * Color mods are used when you want to modify the color or transparency
     * of a tile layer or entity.
     */
    std::vector<SpriteColorModInfo> getSpriteColorMods() const;

    /**
     * Calls the project's UI tick(), if present.
     *
     * @param tick  The time since this function was last called.
     */
    void tick(double timestepS);

    /**
     * Calls the project's UI render(), if present.
     *
     * @param camera  The camera to calculate screen position with.
     * @param sortedSprites  The sorted list of world sprites that were drawn on
     *                       this frame. Used to update worldObjectLocator.
     */
    void render(const Camera& camera,
                const std::vector<SpriteSortInfo>& sortedSprites);

    /**
     * Passes the given event to the project's UI handler, if present.
     */
    bool handleOSEvent(SDL_Event& event) override;

    const WorldObjectLocator& getWorldObjectLocator();

    /**
     * See extension member comment.
     */
    void setExtension(IUserInterfaceExtension* inExtension);

private:
    /** Used to get tile map info for the locator. */
    const World& world;

    /** Contains the project's UI extension functions.
        Allows the project to provide UI code and have it be called at the
        appropriate time. */
    IUserInterfaceExtension* extension;

    /** Used in hit testing for mouse events. */
    WorldObjectLocator worldObjectLocator;
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/UserInterface/Public/UserInterfaceContext.h`:

```h
#pragma once

#include "entt/signal/fwd.hpp"

struct SDL_Renderer;

namespace AM
{
class EventDispatcher;

namespace Client
{
class Simulation;
class WorldObjectLocator;
class Network;
class GraphicData;
class ItemData;
class IconData;

/**
 * Provides the dependencies that UserInterface objects may use.
 */
struct UserInterfaceContext {
public:
    /** World state, current tick. */
    Simulation& simulation;

    /** Find entities or tile layers that a mouse event hit. */
    const WorldObjectLocator& worldObjectLocator;

    /** Server messaging. */
    Network& network;

    /** UI -> Sim events. */
    entt::dispatcher& uiEventDispatcher;

    /** Sim -> UI events. */
    entt::dispatcher& simEventDispatcher;

    /** Network -> Sim/UI message events. */
    EventDispatcher& networkEventDispatcher;

    SDL_Renderer* sdlRenderer;

    GraphicData& graphicData;

    IconData& iconData;

    ItemData& itemData;
};

} // namespace Client
} // namespace AM

```

`Source/ClientLib/UserInterface/Public/WorldObjectLocator.h`:

```h
#pragma once

#include "Camera.h"
#include "WorldObjectID.h"
#include "CellExtent.h"
#include "CellPosition.h"
#include "Config.h"
#include <SDL_rect.h>
#include <vector>
#include <unordered_map>

namespace AM
{
namespace Client
{

/**
 * A spatial partitioning hash map that tracks where world objects (tile
 * layers, entities) are located and the order in which they were drawn to the
 * screen.
 *
 * Used by the UI to quickly find which tile layer or entity the mouse is
 * hovering over.
 *
 * In constract to the similar EntityLocator and CollisionLocator, this class 
 * is UI-centric (for hit testing mouse events), whereas the others are sim-
 * centric (for getting all entities at a particular location in the world, 
 * with no regard for draw order).
 *
 * Internally, world objects are organized into "cells", each of which has a
 * size corresponding to a configurable cell size. This value can be tweaked
 * to affect performance.
 */
class WorldObjectLocator
{
public:
    WorldObjectLocator();

    // There shouldn't be any reason to copy or move a locator. If it's needed,
    // we can revisit this.
    WorldObjectLocator(const WorldObjectLocator& other) = delete;
    WorldObjectLocator(WorldObjectLocator&& other) = delete;

    /**
     * Adds the given world object to the locator.
     *
     * The given extent will be stored. To update the object's extent in
     * this locator, call clear() and re-add the object.
     *
     * Note: Objects are layered according to the order that they're added
     *       in. E.g. if 2 overlapping objects are added, the second will
     *       be considered to be in front of the first.
     *
     * Note: Assumes the given object is fully within this locator's extent.
     *       Don't pass in object that are outside its bounds.
     *
     * @param objectID  The object to add.
     * @param objectWorldBounds  The object's world-space bounding box.
     */
    void addWorldObject(const WorldObjectID& objectID,
                        const BoundingBox& objectWorldBounds);

    /**
     * Returns the top-most world object under the given screen-space point.
     * If multiple objects are intersected, the one drawn on top will be
     * returned.
     *
     * @param screenPoint  The point on the screen to hit test with.
     * @return The ID of the intersected object. If no layer is hit, the variant
     *         type will == std::monostate.
     */
    WorldObjectID getObjectUnderPoint(const SDL_Point& screenPoint) const;

    /**
     * Clears all of our internal data structures, getting rid of any tracked
     * objects.
     */
    void clear();

    /**
     * Sets the camera that will be used for screen/world conversions.
     */
    void setCamera(const Camera& inCamera);

    /**
     * Sets the part of the world map that this locator covers.
     *
     * Typically, this will match the view extent of the player's camera.
     *
     * All tracked widgets must be fully within these bounds.
     */
    void setExtent(const TileExtent& inTileExtent);

private:
    /** A simple structure for holding tracked objects. */
    struct WorldObject {
        WorldObjectID objectID{};
        BoundingBox worldBounds{};
    };

    /** The width of a cell in world units. */
    static constexpr float CELL_WORLD_WIDTH{
        Config::WORLD_OBJECT_LOCATOR_CELL_WIDTH
        * SharedConfig::TILE_WORLD_WIDTH};

    /** The height of a cell in world units. */
    static constexpr float CELL_WORLD_HEIGHT{
        Config::WORLD_OBJECT_LOCATOR_CELL_HEIGHT
        * SharedConfig::TILE_WORLD_HEIGHT};

    /** The part of the world map that this locator currently covers, in
        world units. */
    BoundingBox locatorBounds;

    /** The part of the world map that this locator currently covers, with
        cells as the unit. */
    CellExtent locatorCellExtent;

    /** The camera to use for screen/world conversions. */
    Camera camera;

    /** A spatial partitioning hash map, mapping cell positions -> vectors
        containing the world objects that currently intersect with that cell. */
    std::unordered_map<CellPosition, std::vector<WorldObject>> objectMap;
};

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Utility/CMakeLists.txt`:

```txt
target_sources(ClientLib
    PRIVATE
        Private/ClientTransforms.cpp
    PUBLIC
        Public/ClientTransforms.h
)

target_include_directories(ClientLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ClientLib/Utility/Private/ClientTransforms.cpp`:

```cpp
#include "ClientTransforms.h"
#include "Transforms.h"
#include "Camera.h"
#include "Sprite.h"
#include "SpriteRenderData.h"
#include "Position.h"
#include "Vector3.h"
#include "TilePosition.h"
#include "TileOffset.h"
#include "SharedConfig.h"
#include "Log.h"

namespace AM
{
namespace Client
{
SDL_FRect ClientTransforms::entityToScreenExtent(
    const Position& position, const Vector3& idleSouthBottomCenter,
    const Vector3& alignmentOffset, const SpriteRenderData& renderData,
    const Camera& camera)
{
    // Transform the position to a point in screen space.
    // Note: This applies the camera's zoom to the position, so we don't need
    //       to do it again.
    SDL_FPoint screenPoint{
        Transforms::worldToScreen(position, camera.zoomFactor)};

    // Offset the sprite to line up with where the "stage" starts within the 
    // image.
    screenPoint.x -= (renderData.stageOrigin.x * camera.zoomFactor);
    screenPoint.y -= (renderData.stageOrigin.y * camera.zoomFactor);

    // Offset the sprite to line up with IdleSouth's modelBounds bottom center.
    SDL_FPoint idleSouthBottomCenterScreen{
        Transforms::worldToScreen(idleSouthBottomCenter, camera.zoomFactor)};
    screenPoint.x -= idleSouthBottomCenterScreen.x;
    screenPoint.y -= idleSouthBottomCenterScreen.y;

    // Offset the sprite to account for the alignment offset.
    SDL_FPoint alignmentOffsetScreen{
        Transforms::worldToScreen(alignmentOffset, camera.zoomFactor)};
    screenPoint.x += alignmentOffsetScreen.x;
    screenPoint.y += alignmentOffsetScreen.y;

    // Apply the camera position adjustment.
    float adjustedX{screenPoint.x - camera.screenExtent.x};
    float adjustedY{screenPoint.y - camera.screenExtent.y};

    // Apply the camera's zoom to the sprite size.
    float zoomedWidth{renderData.textureExtent.w * camera.zoomFactor};
    float zoomedHeight{renderData.textureExtent.h * camera.zoomFactor};

    return {adjustedX, adjustedY, zoomedWidth, zoomedHeight};
}

SDL_FRect ClientTransforms::tileToScreenExtent(
    const TilePosition& tilePosition, const TileOffset& tileOffset,
    const SpriteRenderData& renderData, const Camera& camera)
{
    // Transform the position to a point in screen space.
    // Note: This applies the camera's zoom to the position, so we don't need
    //       to do it again.
    Vector3 tileOrigin{tilePosition.getOriginPoint()};
    Vector3 worldPoint{tileOrigin.x + static_cast<float>(tileOffset.x),
                       tileOrigin.y + static_cast<float>(tileOffset.y),
                       tileOrigin.z + static_cast<float>(tileOffset.z)};
    SDL_FPoint screenPoint{
        Transforms::worldToScreen(worldPoint, camera.zoomFactor)};

    // Offset the sprite to line up with where the "stage" starts within the 
    // image.
    screenPoint.x -= (renderData.stageOrigin.x * camera.zoomFactor);
    screenPoint.y -= (renderData.stageOrigin.y * camera.zoomFactor);

    // Apply the camera adjustment.
    float adjustedX{screenPoint.x - camera.screenExtent.x};
    float adjustedY{screenPoint.y - camera.screenExtent.y};

    // Apply the camera's zoom to the tile size.
    float zoomedWidth{renderData.textureExtent.w * camera.zoomFactor};
    float zoomedHeight{renderData.textureExtent.h * camera.zoomFactor};

    return {adjustedX, adjustedY, zoomedWidth, zoomedHeight};
}

} // End namespace Client
} // End namespace AM

```

`Source/ClientLib/Utility/Public/ClientTransforms.h`:

```h
#pragma once

#include <SDL_rect.h>

namespace AM
{
struct Camera;
struct Sprite;
struct Position;
struct Vector3;
struct TilePosition;
struct TileOffset;

namespace Client
{
struct SpriteRenderData;

/**
 * Client-specific static functions for transforming between world and screen
 * space.
 */
class ClientTransforms
{
public:
    /**
     * Calculates where an entity should be drawn on screen.
     *
     * @return A final screen space extent for the entity.
     */
    static SDL_FRect entityToScreenExtent(const Position& position,
                                          const Vector3& idleSouthBottomCenter,
                                          const Vector3& alignmentOffset,
                                          const SpriteRenderData& renderData,
                                          const Camera& camera);

    /**
     * Calculates where a tile should be drawn on screen.
     *
     * @return A final screen space extent for the tile.
     */
    static SDL_FRect tileToScreenExtent(const TilePosition& tilePosition,
                                        const TileOffset& tileOffset,
                                        const SpriteRenderData& renderData,
                                        const Camera& camera);
};

} // End namespace Client
} // End namespace AM

```

`Source/EngineSupplementExamples/Client/Config/Public/Config.h`:

```h
#pragma once

#include "SharedConfig.h"
#include <SDL_stdinc.h>
#include <SDL_render.h>
#include <string>

namespace AM
{
namespace Client
{
/**
 * Contains configuration constants relevant to the Client.
 */
class Config
{
public:
    //-------------------------------------------------------------------------
    // Network
    //-------------------------------------------------------------------------
    /** If true, the connection to the server will be mocked and we'll run
        without it. */
    static constexpr bool RUN_OFFLINE{false};

    /** How far our client's simulation will be ahead of the server's
        simulation.
        We start with this offset, then keep ourselves ahead by using the
        adjustments that the server sends us.
        Doesn't matter much since the server will quickly adjust us. */
    static constexpr Sint8 INITIAL_TICK_OFFSET{5};

    /** How far into the past to begin replicating non-predicted state at.
        We negate INITIAL_TICK_OFFSET since we want to be in the past instead
        of in the future. Additionally, we double it since the messages we
        receive will appear to be doubly far into the past (since we're in the
        future.) */
    static constexpr Sint8 INITIAL_REPLICATION_OFFSET{-2 * INITIAL_TICK_OFFSET};

    /** How long we should wait before considering the server to be timed out.
     */
    static constexpr double SERVER_TIMEOUT_S{
        SharedConfig::SERVER_NETWORK_TICK_TIMESTEP_S * 2};

    //-------------------------------------------------------------------------
    // Simulation
    //-------------------------------------------------------------------------
    /** The x and y axis width, in tiles, of a cell in our world object spatial
        partitioning structure (WorldObjectLocator).
        Note: The tile map's size must be evenly divisible by this number. */
    static constexpr std::size_t WORLD_OBJECT_LOCATOR_CELL_WIDTH{4};

    /** The z axis height, in tiles, of a cell in our world object spatial
        partitioning structure (WorldObjectLocator).
        Note: The tile map's size must be evenly divisible by this number. */
    static constexpr std::size_t WORLD_OBJECT_LOCATOR_CELL_HEIGHT{2};

    //-------------------------------------------------------------------------
    // Renderer, User Interface
    //-------------------------------------------------------------------------
    /**
     * The title that will show on the application window.
     */
    static constexpr const char* WINDOW_TITLE{"Amalgam"};

    /**
     * The logical screen size that we're targeting.
     *
     * The developer can write layout logic in reference to this logical size,
     * and it will be scaled to match the actual size above.
     */
    static constexpr unsigned int LOGICAL_SCREEN_WIDTH{1920};
    static constexpr unsigned int LOGICAL_SCREEN_HEIGHT{1080};

    /**
     * Sets the quality of scaling/filtering algorithm used for sprite 
     * textures (i.e any textures rendered by Renderer).
     * 
     * UI textures ignore this setting.
     */
    static constexpr SDL_ScaleMode SPRITE_SCALING_QUALITY{SDL_ScaleModeLinear};

    /** The rate at which the user interfaces fires off tick() events. */
    static constexpr unsigned int UI_TICKS_PER_SECOND{30};
    static constexpr double UI_TICK_TIMESTEP_S{
        1.0 / static_cast<double>(UI_TICKS_PER_SECOND)};

    /** We sleep for 1ms when possible to reduce our CPU usage. We can't trust
        the scheduler to come back to us after exactly 1ms though, so we busy
        wait if something needs to be called soon.
        Higher value == more CPU usage.
        If you pick too small of a number, two issues can occur:
          1. If < ~.003, the scheduler may not give us time when we need it.
          2. If < ~.010, our low CPU usage might cause Windows to put us into
             energy saving mode, causing visual jitter. */
    static constexpr double SLEEP_MINIMUM_TIME_S{.010};

    /** If true, zooming with the mouse scroll wheel will be enabled. */
    static constexpr bool ENABLE_MOUSE_ZOOM{false};

    /** The levels of zoom that the player can select. */
    static constexpr std::array<float, 8> ZOOM_LEVELS{0.25, 0.5, 0.75, 1,
                                                      1.25, 1.5, 1.75, 2};

    /** The index in the ZOOM_LEVELS vector that the camera should initially 
        be set to. */
    static constexpr std::size_t DEFAULT_ZOOM_LEVEL_INDEX{3};
};

} // End namespace Client
} // End namespace AM

```

`Source/EngineSupplementExamples/README.md`:

```md
This directory provides examples for each expected file in the project's `EngineSupplement` directory.

The files in this directory are not built or used in any way.

Example README.md for the base of the EngineSupplement directory:
```
In this directory, the project provides files that will be built as part of the engine.

We use this mechanism for a few things, such as:
* Enum definitions
  * There's no good alternative for providing project enums to the engine.
* Config headers
  * For any configuration constants that we don't want to expose to the end user.
* Type lists and Components
  * We tested an alternative using type erasure, but it performed significantly worse than providing type definitions to the engine and using a variant.

**Note: Since these files are built as part of the engine, if they depend on
        a project file, that file must also be made visible to the relevant 
        engine CMake target.**
```

```

`Source/EngineSupplementExamples/Server/Config/Public/Config.h`:

```h
#pragma once

#include "SpawnStrategy.h"
#include "SharedConfig.h"
#include "ConstexprTools.h"
#include <SDL_stdinc.h>
#include <string>

namespace AM
{
namespace Server
{
/**
 * Contains configuration constants relevant to the Server.
 */
class Config
{
public:
    //-------------------------------------------------------------------------
    // Simulation
    //-------------------------------------------------------------------------
    /** The strategy that we'll use when spawning entities. */
    static constexpr SpawnStrategy SPAWN_STRATEGY{SpawnStrategy::Fixed};

    // SpawnPoint::Fixed Config
    /** Fixed spawn position. */
    static constexpr float SPAWN_POINT_FIXED_X{32};
    static constexpr float SPAWN_POINT_FIXED_Y{32};

    // SpawnPoint::Random Config
    // Note: We offset these positions to keep entities in bounds while moving.
    /** The min and max X positions that entities will be spawned within. */
    static constexpr float SPAWN_POINT_RANDOM_MIN_X{
        SharedConfig::TILE_WORLD_WIDTH};
    static constexpr float SPAWN_POINT_RANDOM_MAX_X{
        static_cast<unsigned int>(SharedConfig::AOI_RADIUS)
        - SharedConfig::TILE_WORLD_WIDTH};

    /** The min and max Y positions that entities will be spawned within. */
    static constexpr float SPAWN_POINT_RANDOM_MIN_Y{
        SharedConfig::TILE_WORLD_WIDTH};
    static constexpr float SPAWN_POINT_RANDOM_MAX_Y{
        static_cast<unsigned int>(SharedConfig::AOI_RADIUS)
        - SharedConfig::TILE_WORLD_WIDTH};

    // SpawnPoint::Grouped Config
    // Note: Spawns will start at the NW corner of the map, at Z==0.
    /** The number of columns and rows that a group consists of. */
    static constexpr unsigned int SPAWN_POINT_GROUP_COLUMNS{5};
    static constexpr unsigned int SPAWN_POINT_GROUP_ROWS{2};

    /** The amount of padding between rows and columns within a group. */
    static constexpr float SPAWN_POINT_GROUP_PADDING_X{32};
    static constexpr float SPAWN_POINT_GROUP_PADDING_Y{32};

    /** The offset between groups. */
    static constexpr float SPAWN_POINT_GROUP_OFFSET_X{500};
    static constexpr float SPAWN_POINT_GROUP_OFFSET_Y{500};

    /** How often the world's data (tile map, entities, etc) should be saved, 
        in seconds. */
    static constexpr float SAVE_PERIOD_S{60 * 15};

    //-------------------------------------------------------------------------
    // Network
    //-------------------------------------------------------------------------
    ////////////////////////////////////////////////////////////////////////////
    // A tick diff is the difference between a message's intended tick and our
    // current tick (a positive diff means the client is ahead of the server).
    //
    // Client connection management works as such:
    // 1. If the client is too far ahead or behind, send an adjustment.
    //    (See TICKDIFF_ACCEPTABLE_* and TICKDIFF_TARGET.)
    //
    // 2. If a single tickdiff is lower than TICKDIFF_MAX_BOUND_LOWER or
    //    higher than TICKDIFF_MAX_BOUND_UPPER, disconnect them.
    //
    // 3. If we haven't received data from the client within CLIENT_TIMEOUT_S
    //    seconds, disconnect them.
    ////////////////////////////////////////////////////////////////////////////

    /** The port that the server listens for incoming client connections on. */
    static constexpr unsigned int SERVER_PORT{41499};

    /** The maximum number of clients that we will allow. */
    static constexpr unsigned int MAX_CLIENTS{1010};

    /** How long we should wait before considering the client to be timed out.
        Arbitrarily chosen. If too high, we set ourselves up to take a huge
       spike of data for a very late client. */
    static constexpr double CLIENT_TIMEOUT_S{4};

    /** The minimum amount of time worth of tick differences that we'll
        remember. */
    static constexpr double TICKDIFF_HISTORY_S{.5};
    /** The integer number of diffs that we'll remember in the history. */
    static constexpr unsigned int TICKDIFF_HISTORY_LENGTH{
        ConstexprTools::ceilInt(TICKDIFF_HISTORY_S
                                / SharedConfig::SIM_TICK_TIMESTEP_S)};

    /** The range of difference (inclusive) between a received message's tickNum
        and our current tickNum that we won't send an adjustment for. */
    static constexpr Sint64 TICKDIFF_ACCEPTABLE_BOUND_LOWER{1};
    static constexpr Sint64 TICKDIFF_ACCEPTABLE_BOUND_UPPER{3};
    /** The value that we'll adjust clients to if they fall outside the bounds.
     */
    static constexpr Sint64 TICKDIFF_TARGET{2};

    /** The range of difference (inclusive) between a received message's tickNum
        and our current tickNum that will cause us to disconnect a client. */
    static constexpr Sint64 TICKDIFF_MAX_BOUND_LOWER{SDL_MIN_SINT8};
    static constexpr Sint64 TICKDIFF_MAX_BOUND_UPPER{ConstexprTools::ceilInt(
        CLIENT_TIMEOUT_S / SharedConfig::SIM_TICK_TIMESTEP_S)};
    static_assert(TICKDIFF_MAX_BOUND_UPPER <= SDL_MAX_SINT8,
                  "Bound is too high (must fit in SINT8).");

    /** The minimum number of fresh diffs we'll use to calculate an adjustment.
        Aims to prevent thrashing. */
    static constexpr unsigned int MIN_FRESH_DIFFS{3};
};

} // End namespace Server
} // End namespace AM

```

`Source/EngineSupplementExamples/Server/Simulation/Public/TypeLists/ProjectAITypes.h`:

```h
#pragma once

#include "boost/mp11/list.hpp"

namespace AM
{
// Note: AI is server-only.
namespace Server
{
/**
 * Add AI classes to this list to have them be processed by the engine.
 * 
 * Note: Every type in this list must be derived from AILogic.
 */
using ProjectAITypes = boost::mp11::mp_list<>;

} // End namespace Server
} // End namespace AM

```

`Source/EngineSupplementExamples/Server/Simulation/Public/TypeLists/ProjectObservedComponentTypes.h`:

```h
#pragma once

#include "boost/mp11/list.hpp"

namespace AM
{
namespace Server
{
/**
 * See EngineReplicatedComponentTypes.h for more info.
 */
using ProjectObservedComponentTypes = boost::mp11::mp_list<>;

} // End namespace Server
} // End namespace AM

```

`Source/EngineSupplementExamples/Server/Simulation/Public/TypeLists/ProjectPersistedComponentTypes.h`:

```h
#pragma once

#include "boost/mp11/list.hpp"
#include "bitsery/traits/vector.h"
#include "bitsery/ext/std_variant.h"
#include <variant>
#include <vector>

namespace AM
{
// Note: Persisted components are server-only.
namespace Server
{
/**
 * The version number of the project's components and component list.
 *
 * If ProjectPersistedComponentTypes is changed in any way, or the fields of any
 * component in the list are changed in a way that changes their serialization, 
 * you must increment this number and run a migration.
 */
static constexpr unsigned int PROJECT_COMPONENTS_VERSION{0};

/**
 * All of the project's component types that should be saved to the database 
 * and loaded at startup.
 *
 * Note: If you change this list in any way, or change the fields of any included
 *       types in a way that breaks serialization, you must increment 
 *       PROJECT_COMPONENTS_VERSION and run a migration.
 */
using ProjectPersistedComponentTypes = boost::mp11::mp_list<>;

/**
 * A variant that holds a persisted engine component.
 *
 * Used by the server to save entity state to the database.
 */
using ProjectPersistedComponent
    = boost::mp11::mp_rename<ProjectPersistedComponentTypes, std::variant>;

template<typename S>
void serialize(S& serializer,
               std::vector<ProjectPersistedComponent>& projectComponents)
{
    serializer.enableBitPacking([&](typename S::BPEnabledType& sbp) {
        sbp.container(
            projectComponents,
            boost::mp11::mp_size<ProjectPersistedComponentTypes>::value,
            [](typename S::BPEnabledType& serializer,
               ProjectPersistedComponent& component) {
                serializer.ext(component, bitsery::ext::StdVariant{});
            });
    });
}

} // End namespace Server
} // End namespace AM

#endif // defined(AM_OVERRIDE_CONFIG)

```

`Source/EngineSupplementExamples/Shared/Config/Public/SharedConfig.h`:

```h
#pragma once

#include <cstddef>

namespace AM
{
/**
 * Contains shared configuration constants that must be consistent between the
 * client, server, and resource importer.
 *
 * Note: When you update the engine, you may need to add additional fields
 *       here. Refer to the engine's default SharedConfig.h.
 */
class SharedConfig
{
public:
    //-------------------------------------------------------------------------
    // Simulation
    //-------------------------------------------------------------------------
    /** The rate at which the simulation will be processed. */
    static constexpr unsigned int SIM_TICKS_PER_SECOND{30};
    static constexpr double SIM_TICK_TIMESTEP_S{
        1.0 / static_cast<double>(SIM_TICKS_PER_SECOND)};

    /** The max number of entities that we will allow. */
    static constexpr std::size_t MAX_ENTITIES{1100};

    /** The max number of interactions that an entity can support.
        Interactions are the options that show up when you right-click an 
        entity or item. */
    static constexpr std::size_t MAX_ENTITY_INTERACTIONS{64};

    /** The max number of non-built-in interactions that an item can support. */
    static constexpr std::size_t MAX_ITEM_CUSTOM_INTERACTIONS{64};

    /** The maximum map size that we'll load, in tiles. */
    static constexpr std::size_t MAX_MAP_WIDTH_TILES{1'024};

    /** The x and y axis width, in world units, of our tiles. */
    static constexpr std::size_t TILE_WORLD_WIDTH{32};

    /** The z axis height, in world units, of our tiles. */
    static constexpr std::size_t TILE_WORLD_HEIGHT{84};

    /** The x and y axis width, in tiles, of our chunks.
        Note: This doesn't apply to the z axis. Chunks are always 1 tile tall. */
    static constexpr std::size_t CHUNK_WIDTH{16};

    /** The number of tiles in a chunk. */
    static constexpr std::size_t CHUNK_TILE_COUNT{CHUNK_WIDTH * CHUNK_WIDTH};

    /** The x and y axis width, in tiles, of a cell in our entity spatial
        partitioning grid (EntityLocator). */
    static constexpr std::size_t ENTITY_LOCATOR_CELL_WIDTH{4};

    /** The z axis width, in tiles, of a cell in our entity spatial partitioning 
        grid (EntityLocator). */
    static constexpr std::size_t ENTITY_LOCATOR_CELL_HEIGHT{2};

    /** The x and y axis width, in tiles, of a cell in our collision spatial
        partitioning grid (CollisionLocator). */
    static constexpr std::size_t COLLISION_LOCATOR_CELL_WIDTH{4};

    /** The z axis width, in tiles, of a cell in our collision spatial 
        partitioning grid (CollisionLocator). */
    static constexpr std::size_t COLLISION_LOCATOR_CELL_HEIGHT{2};

    /** The number of world units around an entity that are considered to be
        within the entity's "Area of Interest" cylinder.
        Used in the simulation to tell if data is relevant to a client. */
    static constexpr float AOI_RADIUS{TILE_WORLD_WIDTH * 8};

    /** The number of world units above and below an entity that are considered
        to be within the entity's "Area of Interest" cylinder. */
    static constexpr float AOI_HALF_HEIGHT{TILE_WORLD_HEIGHT * 3};

    /** The string ID of the default graphic set for entities. */
    static constexpr const char* DEFAULT_ENTITY_GRAPHIC_SET{"ghost"};

    /** The force of gravity in world units per second. */
    static constexpr float FORCE_OF_GRAVITY{20};

    /** The maximum negative Z velocity that entities can reach. */
    static constexpr float TERMINAL_VELOCITY{-300};

    /** The amount of velocity that's added to the player if they try to move 
        while falling straight through the air, e.g. after jumping straight up.
        This is a constant instead of being affected by runspeed, because it's 
        intended to be a consistent, small movement. */
    static constexpr float VERTICAL_FALL_MOVE_VELOCITY{15};

    /** The distance above a casting target circle that will be included in 
        the area of effect. */
    static constexpr float CAST_TARGET_CYLINDER_HEIGHT{3};
    static constexpr float CAST_TARGET_CYLINDER_HALF_HEIGHT{
        CAST_TARGET_CYLINDER_HEIGHT / 2.0};

    /** The length of the global cooldown for casting. */
    static constexpr double CAST_GLOBAL_COOLDOWN_S{1.0};
    static constexpr unsigned int CAST_GLOBAL_COOLDOWN_TICKS{
        static_cast<unsigned int>(CAST_GLOBAL_COOLDOWN_S
                                  / SIM_TICK_TIMESTEP_S)};

    /** The standard range for entity interactions, such as "Talk".
        This is the max distance between the caster and the target entity.
        This will be the range of all engine-provided entity interactions, and 
        you can choose to use it for project interactions as well. */
    static constexpr float CAST_ENTITY_INTERACTION_STANDARD_RANGE{
        TILE_WORLD_WIDTH};

    //-------------------------------------------------------------------------
    // Network
    //-------------------------------------------------------------------------
    /** The rate at which the server will batch and send queued messages. */
    static constexpr unsigned int SERVER_NETWORK_TICKS_PER_SECOND{20};
    static constexpr double SERVER_NETWORK_TICK_TIMESTEP_S{
        1.0 / static_cast<double>(SERVER_NETWORK_TICKS_PER_SECOND)};

    /** The rate at which the client will heartbeat (if necessary). */
    static constexpr unsigned int CLIENT_NETWORK_TICKS_PER_SECOND{1};
    static constexpr double CLIENT_NETWORK_TICK_TIMESTEP_S{
        1.0 / static_cast<double>(CLIENT_NETWORK_TICKS_PER_SECOND)};

    /** Message batches larger than this size (in bytes) will be compressed
        before sending. */
    static constexpr std::size_t BATCH_COMPRESSION_THRESHOLD{50};

    /** The max size that an uncompressed message batch can be.
        Used to allocate our message buffers.

        If it was free, we would just send the actual uncompressed size of
        each message batch over the wire. To save bytes, we instead configure
        this constant.
        Our message buffers are very small relative to available RAM, so there
        isn't much harm in raising this to be well above what we actually need.

        Note: Each simulated client in LoadTestClient instantiates a buffer,
              so you may need to be conscious of this size in that case. */
    static constexpr std::size_t MAX_BATCH_SIZE{20'000};

    //-------------------------------------------------------------------------
    // Renderer
    //-------------------------------------------------------------------------
    /** The width of the top face of a tile in screen coordinates. */
    static constexpr unsigned int TILE_FACE_SCREEN_WIDTH{256};
    /** The height of the top face of a tile in screen coordinates. */
    static constexpr unsigned int TILE_FACE_SCREEN_HEIGHT{128};
    /** The height of the side of a tile in screen coordinates, i.e. how tall 
        the world-space z axis height of a tile should appear on screen.
        Since Z coordinate contribution to the screen Y axis is linear, 
        this / TILE_WORLD_HEIGHT can be thought of as our "Z scaling factor" */
    static constexpr unsigned int TILE_SIDE_SCREEN_HEIGHT{168};

    /** The number of world units around the player that are considered to be
        within the player's view range.
        Used to determine how much of the world should be rendered. */
    static constexpr float VIEW_RADIUS{TILE_WORLD_WIDTH * 8};

    //-------------------------------------------------------------------------
    // Project
    //-------------------------------------------------------------------------
    /** If true, build mode will only be allowed in the "build area".
        If false, clients can make changes anywhere in the world. */
    static constexpr bool RESTRICT_WORLD_CHANGES{false};
};

} // End namespace AM

```

`Source/EngineSupplementExamples/Shared/Simulation/Public/CastableData/CastableDef.h`:

```h
#pragma once

#include "CastableID.h"
#include "Castable.h"
#include "GraphicDataBase.h"
#include <functional>

namespace AM
{

/**
 * Use this class to define all of the castables in your project (item 
 * interactions, entity interactions, and spells).
 */
class CastableDef {
public:
    static void defineCastables(const GraphicDataBase& graphicData,
        std::function<void(CastableID, const Castable&)> addCastable)
    {
        // Fireball
        {
            Castable castable{
                .range{64},
                .castTime{1},
                .cooldownTime{2},
                .triggersGCD{true},
                .castingGraphicType{EntityGraphicType::Crouch},
                //.castCompleteGraphicType{EntityGraphicType::Crouch}
            };

            //VisualEffect visualEffect{
            //    .graphicID{toGraphicID(
            //        graphicData.getAnimation("explosion").numericID)},
            //    .loopMode{VisualEffect::LoopMode::Loop},
            //    .loopTime{3}};
            //castable.castCompleteVisualEffects.emplace_back(visualEffect);

            AVEntity avEntity{.startDistance{10}, .canMoveVertically{true}};
            AVEntity::Phase phase{
                .graphicSetID{
                    graphicData.getEntityGraphicSet("Fireball").numericID},
                .behavior{AVEntity::Behavior::MoveToEntity},
                .movementSpeed{5.f}};
            avEntity.phases.emplace_back(phase);
            castable.castCompleteAVEntities.emplace_back(avEntity);

            addCastable(SpellType::Fireball, castable);
        }
    }
};

} // namespace AM

```

`Source/EngineSupplementExamples/Shared/Simulation/Public/CastableData/CastableProjectData.h`:

```h
#pragma once

namespace AM
{

/**
 * Project-specific data for castables.
 *
 * For example, a project may want all castables to have icons.
 * It would do so by adding an icon field here, setting it during castable 
 * init, and processing it in the UI.
 */
struct CastableProjectData {
};

} // namespace AM

```

`Source/EngineSupplementExamples/Shared/Simulation/Public/CastableData/CastableRequirementType.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/**
 * The types of requirements that a Castable may have.
 */
enum class CastableRequirementType : Uint8 {
    // StatStrength = 0
};

} // End namespace AM

```

`Source/EngineSupplementExamples/Shared/Simulation/Public/CastableData/EntityInteractionType.h`:

```h
#pragma once

#include "EngineEntityInteractionType.h"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * The types of interactions that a user may be able to perform on an entity.
 */
enum class EntityInteractionType : Uint8 {
    // Engine interactions (copied here so we can use one strongly-typed enum).
    NotSet = static_cast<Uint8>(EngineEntityInteractionType::NotSet),
    Talk = static_cast<Uint8>(EngineEntityInteractionType::Talk),

    // Project interactions.
    // Sunflower garden
    Replant = static_cast<Uint8>(EngineEntityInteractionType::PROJECT_START),
};

} // End namespace AM

```

`Source/EngineSupplementExamples/Shared/Simulation/Public/CastableData/ItemInteractionType.h`:

```h
#pragma once

#include "EngineItemInteractionType.h"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * The types of interactions that a user may be able to perform on an item.
 *
 * Note: When you update the engine, you may need to add additional values
 *       here. Refer to the engine's default ItemInteractionType.h.
 */
enum class ItemInteractionType : Uint8 {
    // Engine interactions (copied here so we can use one strongly-typed enum).
    NotSet = static_cast<Uint8>(EngineItemInteractionType::NotSet),

    // Note: All items support Examine, Destroy (handled by
    //       InventoryDeleteItem), and UseOn (handled by CombineItems and 
    //       UseItemOnEntityRequest).
    UseOn = static_cast<Uint8>(EngineItemInteractionType::UseOn),
    Destroy = static_cast<Uint8>(EngineItemInteractionType::Destroy),
    Examine = static_cast<Uint8>(EngineItemInteractionType::Examine),

    // Project interactions.
    // MyInteraction =
    // static_cast<Uint8>(EngineItemInteractionType::PROJECT_START),
};

} // End namespace AM

```

`Source/EngineSupplementExamples/Shared/Simulation/Public/CastableData/SpellType.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/**
 * The types of spells that an entity may cast.
 */
enum class SpellType : Uint8 {
    // Note: NotSet must always be present.
    NotSet = 0,
    Fireball
};

} // End namespace AM

```

`Source/EngineSupplementExamples/Shared/Simulation/Public/CastableData/ValidateCast.h`:

```h
#pragma once

#include "Castable.h"
#include "Castable.h"
#include "entt/fwd.hpp"
#include "entt/entity/registry.hpp"
#include <vector>

namespace AM
{

/**
 * This function is called when an entity is trying to cast something. Use it 
 * to check if the entity meets the Castable's requirements.
 *
 * @return true if casterEntity is allowed to cast castable. Else, false.
 */
inline bool validateCast(entt::entity casterEntity, const Castable& castable,
                         const entt::registry& registry)
{
    // const Stats* stats{registry.try_get(casterEntity)};
    // if (!stats) {
    //     // Can't cast without stats. Return early.
    //     return false;
    // }

    // If casterEntity doesn't meet one of the requirements, return false.
    //for (const Castable::Requirement& requirement : castable.requirements) {
    //    switch (requirement.type) {
    //        case CastableRequirementType::StatStrength:
    //            if (stats.strength < requirementValue) {
    //                return false;
    //            }
    //            break;
    //        default:
    //            break;
    //    }
    //}

    return true;
}

} // End namespace AM

```

`Source/EngineSupplementExamples/Shared/Simulation/Public/CollisionLayerType.h`:

```h
#pragma once

#include "EngineCollisionLayerType.h"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * The collision layer types that are available to the collision system.
 * 
 * Used by CollisionLocator for collision and raycasting.
 */
struct CollisionLayerType
{
    enum Value : Uint16 {
        // Engine collision layer types (copied here so we can use one strongly-
        // typed enum).
        TerrainWall = static_cast<Uint8>(EngineCollisionLayerType::TerrainWall),
        Object = static_cast<Uint8>(EngineCollisionLayerType::Object),
        ClientEntity = static_cast<Uint8>(EngineCollisionLayerType::ClientEntity),
        NonClientEntity
        = static_cast<Uint8>(EngineCollisionLayerType::NonClientEntity),
        BlockCollision = static_cast<Uint8>(EngineCollisionLayerType::BlockCollision),
        BlockLoS = static_cast<Uint8>(EngineCollisionLayerType::BlockLoS),

        // Project collision layer types.
        // Note: To avoid conflicting with future layer types that the engine 
        //       may add, we start at the highest bit and move downwards.
        // MyLayerType1 = 1 << (15 - 0),
        // MyLayerType2 = 1 << (15 - 1),
    };
};

} // End namespace AM

```

`Source/EngineSupplementExamples/Shared/Simulation/Public/EntityGraphicType.h`:

```h
#pragma once

#include "EngineEntityGraphicType.h"
#include "AMAssert.h"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * The types of graphics that may be displayed to represent an entity, 
 * depending on what that entity's state is.
 *
 * Each entity graphic type can face 8 directions, depending on the entity's 
 * Rotation component.
 *
 * Controls the graphic types that show up for entity graphic sets in  
 * ResourceImporter.
 */
enum class EntityGraphicType : Uint8 {
    // Engine graphic types (copied here so we can use one strongly-typed enum).
    NotSet = static_cast<Uint8>(EngineEntityGraphicType::NotSet),
    /** Note: All graphic sets are expected to contain IdleSouth. */
    Idle = static_cast<Uint8>(EngineEntityGraphicType::Idle),
    Run = static_cast<Uint8>(EngineEntityGraphicType::Run),
    Crouch = static_cast<Uint8>(EngineEntityGraphicType::Crouch),
    Jump = static_cast<Uint8>(EngineEntityGraphicType::Jump),

    // Project graphic types.
    PROJECT_START = static_cast<Uint8>(EngineEntityGraphicType::PROJECT_START),
    // MyGraphicType,

    PROJECT_END 
};

} // End namespace AM

```

`Source/EngineSupplementExamples/Shared/Simulation/Public/TypeLists/ProjectItemPropertyTypes.h`:

```h
#pragma once

#include <SDL_stdinc.h>
#include "boost/mp11/list.hpp"

namespace AM
{
/** The type of plant that will be grown. */
struct SeedType {
    enum Value : Uint8 { Sunflower, Leek, Pepper };

    Value value{};
};
template<typename S>
void serialize(S& serializer, SeedType& seedType)
{
    serializer.value1b(seedType.value);
}

/** The list of project properties that may be attached to an item. */
using ProjectItemPropertyTypes = boost::mp11::mp_list<SeedType>;

} // End namespace AM

```

`Source/EngineSupplementExamples/Shared/Simulation/Public/TypeLists/ProjectReplicatedComponentTypes.h`:

```h
#pragma once

#include "boost/mp11/list.hpp"

namespace AM
{
/**
 * See EngineReplicatedComponentTypes.h for more info.
 */
using ProjectReplicatedComponentTypes = boost::mp11::mp_list<>;

} // End namespace AM

```

`Source/EngineSupplementExamples/Shared/UserInterface/Public/DisplayStrings.h`:

```h
#pragma once

#include "EntityInteractionType.h"
#include "ItemInteractionType.h"
#include "EntityGraphicType.h"
#include "Log.h"
#include <SDL_stdinc.h>
#include <string>

namespace AM
{
/**
 * Shared functions for converting enums to display strings.
 */
namespace DisplayStrings
{
inline std::string get(EntityInteractionType interactionType)
{
    switch (interactionType) {
        // Engine interaction types.
        case EntityInteractionType::Talk:
            return "Talk";
        // Project interaction types.
        case EntityInteractionType::Replant:
            return "Replant";
        default:
            break;
    }

    LOG_ERROR("Tried to get display string for unknown interaction type.");
    return "?";
}

inline std::string get(ItemInteractionType interactionType)
{
    switch (interactionType) {
        // Engine interaction types.
        case ItemInteractionType::UseOn:
            return "Use";
        case ItemInteractionType::Destroy:
            return "Destroy";
        case ItemInteractionType::Examine:
            return "Examine";
        // Project interaction types.
        default:
            break;
    }

    LOG_ERROR("Tried to get display string for unknown interaction type.");
    return "?";
}

inline std::string get(EntityGraphicType graphicType)
{
    switch (graphicType) {
        // Engine graphic types.
        case EntityGraphicType::Idle:
            return "Idle";
        case EntityGraphicType::Run:
            return "Run";
        case EntityGraphicType::Crouch:
            return "Crouch";
        case EntityGraphicType::Jump:
            return "Jump";
        // Project graphic types.
        default:
            break;
    }

    LOG_ERROR("Tried to get display string for unknown graphic type.");
    return "?";
}

} // namespace DisplayStrings
} // namespace AM

```

`Source/ResourceImporter/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

message(STATUS "Configuring Amalgam Engine ResourceImporter")

###############################################################################
# Configure Step
###############################################################################
add_executable(ResourceImporter WIN32 "")

target_include_directories(ResourceImporter
    PRIVATE
        ${SDL2_INCLUDE_DIRS} ${SDL2_IMAGE_INCLUDE_DIRS} 
        ${SDL2_MIXER_INCLUDE_DIRS} ${SDL2_TTF_INCLUDE_DIRS}
        ${SDL2_GFX_INCLUDE_DIRS} ${SDL2PP_INCLUDE_DIRS}
)

# Inherit Shared's precompiled header.
# CMake causes issues when using precompiled headers with GCC on macOS,
# so precompiled headers are disabled for that target.
if ((NOT APPLE) OR (CMAKE_CXX_COMPILER_ID MATCHES "Clang|AppleClang"))
    target_precompile_headers(ResourceImporter REUSE_FROM SharedLib)
endif()

target_link_libraries(ResourceImporter
    PRIVATE
        ${SDL2_LIBRARIES} ${SDL2_IMAGE_LIBRARIES}
        ${SDL2_MIXER_LIBRARIES} ${SDL2_TTF_LIBRARIES}
        ${SDL2_GFX_LIBRARIES} ${SDL2PP_LIBRARIES}
        AmalgamUI
        EnTT::EnTT
        nfd
        nlohmann_json::nlohmann_json
        SharedLib
)

# Compile with C++23.
target_compile_features(ResourceImporter PRIVATE cxx_std_23)
set_target_properties(ResourceImporter PROPERTIES CXX_EXTENSIONS OFF)

# Enable compile warnings.
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    target_compile_options(ResourceImporter PUBLIC -Wall -Wextra)
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    target_compile_options(ResourceImporter PUBLIC /W3 /permissive-)
endif()

# Copy assets to the build directory.
file(COPY ${PROJECT_SOURCE_DIR}/Resources/ResourceImporter/Common/Assets/
     DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/Assets/)

# On Windows, copy the SDL2 DLLs into the build folder so we can run our executable.
if (CMAKE_SYSTEM_NAME STREQUAL "Windows")
    list(APPEND SDL2_DLL_PATHS 
         ${SDL2_DIR}/lib/x64/
         ${SDL2_IMAGE_INCLUDE_DIR}/../lib/x64
         ${SDL2_MIXER_INCLUDE_DIR}/../lib/x64
         ${SDL2_TTF_INCLUDE_DIR}/../lib/x64
         ${SDL2_GFX_INCLUDE_DIR}/../lib/x64
    )

    foreach(DLL_PATH ${SDL2_DLL_PATHS})
        file(GLOB SDL2_DLLS ${DLL_PATH}/*.dll)
        file(COPY ${SDL2_DLLS} DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/)
    endforeach()
endif()

# Build all of the subdirectories
add_subdirectory(Config)
add_subdirectory(DataModel)
add_subdirectory(Launch)
add_subdirectory(Renderer)
add_subdirectory(UserInterface)
add_subdirectory(Utility)

###############################################################################
# Install Step (Packaging the application)
###############################################################################
# Define an install step that copies the executable and all resources.
install(TARGETS ResourceImporter RUNTIME DESTINATION ${CMAKE_PROJECT_NAME}/ResourceImporter)
install(DIRECTORY ${PROJECT_SOURCE_DIR}/Resources/ResourceImporter/Common/
        DESTINATION ${CMAKE_PROJECT_NAME}/ResourceImporter)

# Add platform-specific files to the install step.
if (CMAKE_SYSTEM_NAME STREQUAL "Windows")
    install(DIRECTORY ${PROJECT_SOURCE_DIR}/Resources/ResourceImporter/Windows/
            DESTINATION ${CMAKE_PROJECT_NAME}/ResourceImporter)

    # On Windows, we provide the SDL2 DLLs.
    foreach(DLL_PATH ${SDL2_DLL_PATHS})
        install(DIRECTORY ${DLL_PATH}/
                DESTINATION ${CMAKE_PROJECT_NAME}/ResourceImporter
                FILES_MATCHING PATTERN "*.dll")
    endforeach()
elseif (CMAKE_SYSTEM_NAME STREQUAL "Linux")
    install(DIRECTORY ${PROJECT_SOURCE_DIR}/Resources/ResourceImporter/Linux/
            DESTINATION ${CMAKE_PROJECT_NAME}/ResourceImporter)
endif()

```

`Source/ResourceImporter/Config/CMakeLists.txt`:

```txt
target_sources(ResourceImporter
    PUBLIC
        Public/Config.h
)

target_include_directories(ResourceImporter
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ResourceImporter/Config/Public/Config.h`:

```h
#pragma once

#include <SDL_render.h>
#include <string>

namespace AM
{
namespace ResourceImporter
{
/**
 * Module-specific configuration data.
 */
class Config
{
public:
    /** The actual size of the window we're rendering to. */
    static constexpr unsigned int ACTUAL_SCREEN_WIDTH{1600};
    static constexpr unsigned int ACTUAL_SCREEN_HEIGHT{900};

    /**
     * The logical screen size that we're targeting.
     *
     * The developer can write layout logic in reference to this logical size,
     * and it will be scaled to match the actual size above.
     */
    static constexpr unsigned int LOGICAL_SCREEN_WIDTH{1920};
    static constexpr unsigned int LOGICAL_SCREEN_HEIGHT{1080};

    /**
     * Sets full screen preference.
     * 0 = windowed.
     * 1 = Real fullscreen.
     * 2 = Fullscreen windowed.
     */
    static constexpr unsigned int FULLSCREEN_MODE{0};

    /**
     * Sets the quality of scaling/filtering algorithm used for sprite 
     * textures (i.e any textures rendered by Renderer).
     * 
     * UI textures ignore this setting.
     */
    static constexpr SDL_ScaleMode SPRITE_SCALING_QUALITY{SDL_ScaleModeLinear};

    /** The rate at which the user interfaces fires off tick() events. */
    static constexpr unsigned int UI_TICKS_PER_SECOND{30};
    static constexpr double UI_TICK_TIMESTEP_S{
        1.0 / static_cast<double>(UI_TICKS_PER_SECOND)};
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/CMakeLists.txt`:

```txt
target_sources(ResourceImporter
    PRIVATE
        Private/AnimationModel.cpp
        Private/BoundingBoxModel.cpp
        Private/DataModel.cpp
        Private/EditorAnimation.cpp
        Private/EditorGraphicRef.cpp
        Private/EditorSprite.cpp
        Private/EntityGraphicSetModel.cpp
        Private/GraphicSetModel.cpp
        Private/IconModel.cpp
        Private/SpriteModel.cpp
    PUBLIC
        Public/AnimationModel.h
        Public/BoundingBoxModel.h
        Public/DataModel.h
        Public/EditorAnimation.h
        Public/EditorBoundingBox.h
        Public/EditorEntityGraphicSet.h
        Public/EditorFloorGraphicSet.h
        Public/EditorGraphicRef.h
        Public/EditorIcon.h
        Public/EditorIconSheet.h
        Public/EditorObjectGraphicSet.h
        Public/EditorSprite.h
        Public/EditorSpriteSheet.h
        Public/EditorTerrainGraphicSet.h
        Public/EditorWallGraphicSet.h
        Public/EntityGraphicSetModel.h
        Public/GraphicSetModel.h
        Public/IconModel.h
        Public/LibraryItemData.h
        Public/SpriteModel.h
        Public/SpriteSheetID.h
)

target_include_directories(ResourceImporter
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ResourceImporter/DataModel/Private/AnimationModel.cpp`:

```cpp
#include "AnimationModel.h"
#include "DataModel.h"
#include "StringTools.h"
#include "nlohmann/json.hpp"
#include "Log.h"

namespace AM
{
namespace ResourceImporter
{

AnimationModel::AnimationModel(DataModel& inDataModel)
: dataModel{inDataModel}
, animationMap{}
, animationNameMap{}
, animationIDPool{IDPool::ReservationStrategy::ReuseLowest, 32}
, errorString{}
, animationAddedSig{}
, animationRemovedSig{}
, animationDisplayNameChangedSig{}
, animationFrameCountChangedSig{}
, animationFpsChangedSig{}
, animationLoopStartFrameChangedSig{}
, animationFrameChangedSig{}
, animationModelBoundsIDChangedSig{}
, animationCustomModelBoundsChangedSig{}
, animationCollisionEnabledChangedSig{}
, animationEntityAlignmentAnchorChangedSig{}
, animationAdded{animationAddedSig}
, animationRemoved{animationRemovedSig}
, animationDisplayNameChanged{animationDisplayNameChangedSig}
, animationFrameCountChanged{animationFrameCountChangedSig}
, animationFpsChanged{animationFpsChangedSig}
, animationLoopStartFrameChanged{animationLoopStartFrameChangedSig}
, animationFrameChanged{animationFrameChangedSig}
, animationModelBoundsIDChanged{animationModelBoundsIDChangedSig}
, animationCustomModelBoundsChanged{animationCustomModelBoundsChangedSig}
, animationCollisionEnabledChanged{animationCollisionEnabledChangedSig}
, animationEntityAlignmentAnchorChanged{
      animationEntityAlignmentAnchorChangedSig}
{
    // Reserve the null animation ID (the engine provides it in code, 
    // so we don't need it in the json).
    animationIDPool.reserveID();
}

bool AnimationModel::load(const nlohmann::json& json)
{
    try {
        // Add each animation.
        for (auto& animationJson : json.at("animations").items()) {
            if (!parseAnimation(animationJson.value())) {
                return false;
            }
        }
    } catch (nlohmann::json::exception& e) {
        resetModelState();
        errorString = "Parse failure - ";
        errorString += e.what();
        return false;
    }

    return true;
}

void AnimationModel::save(nlohmann::json& json)
{
    json["animations"] = nlohmann::json::array();

    // Fill the json with each animation in the model.
    int i{0};
    for (auto& animationPair : animationMap) {
        // Add the display name.
        EditorAnimation& animation{animationPair.second};
        json["animations"][i]["displayName"] = animation.displayName;

        // Add the numeric ID.
        json["animations"][i]["numericID"] = animation.numericID;

        // Add the frame count, fps, and loop start frame.
        json["animations"][i]["frameCount"] = animation.frameCount;
        json["animations"][i]["fps"] = animation.fps;
        json["animations"][i]["loopStartFrame"] = animation.loopStartFrame;

        // If the animation has any filled frames, add them.
        // Note: Frame numbers/IDs are parallel arrays to save file space. If we 
        //       switch to a binary format, they can be combined into a single 
        //       struct or used as key/value in a map.
        if ((animation.frames.size() > 0)
            && (animation.frames[0].sprite.get().numericID != NULL_SPRITE_ID)) {
            int j{0};
            for (auto& [frameNumber, sprite] : animation.frames) {
                json["animations"][i]["frameNumbers"][j] = frameNumber;
                json["animations"][i]["spriteIDs"][j] = sprite.get().numericID;

                j++;
            }
        }
        else {
            // No filled frames, add a null sprite.
            json["animations"][i]["frameNumbers"][0] = 0;
            json["animations"][i]["spriteIDs"][0] = NULL_SPRITE_ID;
        }

        // Add collisionEnabled.
        json["animations"][i]["collisionEnabled"] = animation.collisionEnabled;

        // Add modelBoundsID.
        // Note: The engine doesn't use this, but this editor needs it.
        json["animations"][i]["modelBoundsID"] = animation.modelBoundsID;

        // Add the model-space bounds.
        // Note: This will either be a shared bounding box or a custom one 
        //       depending on modelBoundsID. In either case, we always save to 
        //       modelBounds because that's what the engine uses. 
        const BoundingBox& animationModelBounds{
            animation.getModelBounds(dataModel.boundingBoxModel)}; 
        json["animations"][i]["modelBounds"]["minX"]
            = animationModelBounds.min.x;
        json["animations"][i]["modelBounds"]["maxX"]
            = animationModelBounds.max.x;
        json["animations"][i]["modelBounds"]["minY"]
            = animationModelBounds.min.y;
        json["animations"][i]["modelBounds"]["maxY"]
            = animationModelBounds.max.y;
        json["animations"][i]["modelBounds"]["minZ"]
            = animationModelBounds.min.z;
        json["animations"][i]["modelBounds"]["maxZ"]
            = animationModelBounds.max.z;

        // Add the entity alignment anchor, if present.
        if (animation.entityAlignmentAnchor) {
            const Vector3& alignmentAnchor{
                animation.entityAlignmentAnchor.value()};
            json["animations"][i]["entityAlignmentAnchor"]["x"]
                = alignmentAnchor.x;
            json["animations"][i]["entityAlignmentAnchor"]["y"]
                = alignmentAnchor.y;
            json["animations"][i]["entityAlignmentAnchor"]["z"]
                = alignmentAnchor.z;
        }

        i++;
    }
}

const EditorAnimation&
    AnimationModel::addOrGetAnimation(std::string_view displayName)
{
    // Try to find an animation with the given name.
    auto animationNameIt{animationNameMap.find(displayName)};
    if (animationNameIt == animationNameMap.end()) {
        // Doesn't exist. Add a new animation and return its ID.
        return addAnimation(displayName);
    }

    // Return the existing animation.
    return animationMap.at(animationNameIt->second);
}

void AnimationModel::remAnimation(AnimationID animationID)
{
    // Find the animation in the map.
    auto animationIt{animationMap.find(animationID)};
    if (animationIt == animationMap.end()) {
        LOG_FATAL("Invalid ID while removing animation.");
    }

    // Free the animation's ID.
    animationIDPool.freeID(animationID);

    // Erase the animation.
    animationNameMap.erase(animationIt->second.displayName);
    animationMap.erase(animationIt);

    // Clear this animation from any sets that reference it.
    dataModel.graphicSetModel.removeGraphicIDFromSets(toGraphicID(animationID));
    dataModel.entityGraphicSetModel.removeGraphicIDFromSets(
        toGraphicID(animationID));

    // Signal that the animation was erased.
    animationRemovedSig.publish(animationID);
}

const EditorAnimation&
    AnimationModel::getAnimation(AnimationID animationID) const
{
    auto animationIt{animationMap.find(animationID)};
    if (animationIt == animationMap.end()) {
        LOG_FATAL("Tried to get animation with invalid ID: %d",
                  animationID);
    }

    return animationIt->second;
}

const EditorAnimation*
    AnimationModel::getAnimation(std::string_view displayName) const
{
    auto animationNameIt{animationNameMap.find(displayName)};
    if (animationNameIt == animationNameMap.end()) {
        return nullptr;
    }

    return &(animationMap.at(animationNameIt->second));
}

void AnimationModel::setAnimationFrameCount(AnimationID animationID,
                                            Uint8 newFrameCount)
{
    auto animationPair{animationMap.find(animationID)};
    if (animationPair == animationMap.end()) {
        LOG_FATAL("Tried to set frame count using invalid animation ID.");
    }

    // If loopStartFrame is past the end of the new frame count, pull it back 
    // in.
    EditorAnimation& animation{animationPair->second};
    if (animation.loopStartFrame > newFrameCount) {
        animation.loopStartFrame = newFrameCount;
        animationLoopStartFrameChangedSig.publish(animationID,
                                                  animation.loopStartFrame);
    }

    // Set the new frame count and signal the change.
    animation.frameCount = newFrameCount;
    animationFrameCountChangedSig.publish(animationID, newFrameCount);
}

void AnimationModel::setAnimationFps(AnimationID animationID, Uint8 newFps)
{
    auto animationPair{animationMap.find(animationID)};
    if (animationPair == animationMap.end()) {
        LOG_FATAL("Tried to set frame count using invalid animation ID.");
    }

    // Set the new fps and signal the change.
    EditorAnimation& animation{animationPair->second};
    animation.fps = newFps;

    animationFpsChangedSig.publish(animationID, newFps);
}

void AnimationModel::setAnimationLoopStartFrame(AnimationID animationID,
                                                Uint8 newLoopStartFrame)
{
    auto animationPair{animationMap.find(animationID)};
    if (animationPair == animationMap.end()) {
        LOG_FATAL("Tried to set loop start frame using invalid animation ID.");
    }

    // If the new frame number isn't valid, exit early.
    EditorAnimation& animation{animationPair->second};
    if (newLoopStartFrame > animation.frameCount) {
        return;
    }

    // Set the new loop start frame and signal the change.
    animation.loopStartFrame = newLoopStartFrame;

    animationLoopStartFrameChangedSig.publish(animationID, newLoopStartFrame);
}

void AnimationModel::setAnimationModelBoundsID(AnimationID animationID,
                                         BoundingBoxID newModelBoundsID)
{
    auto animationPair{animationMap.find(animationID)};
    if (animationPair == animationMap.end()) {
        LOG_FATAL("Tried to set modelBoundsID using invalid animation ID.");
    }

    // Set the new ID and signal the change.
    EditorAnimation& animation{animationPair->second};
    animation.modelBoundsID = newModelBoundsID;

    animationModelBoundsIDChangedSig.publish(animationID, newModelBoundsID);
}

void AnimationModel::setAnimationCustomModelBounds(AnimationID animationID,
                                       const BoundingBox& newModelBounds)
{
    auto animationPair{animationMap.find(animationID)};
    if (animationPair == animationMap.end()) {
        LOG_FATAL("Tried to set customModelBounds using invalid animation ID.");
    }

    // Set the new model bounds and signal the change.
    EditorAnimation& animation{animationPair->second};
    animation.customModelBounds = newModelBounds;

    animationCustomModelBoundsChangedSig.publish(animationID, newModelBounds);
}

void AnimationModel::setAnimationCollisionEnabled(AnimationID animationID,
                                                  bool newCollisionEnabled)
{
    auto animationPair{animationMap.find(animationID)};
    if (animationPair == animationMap.end()) {
        LOG_FATAL("Tried to set collisionEnabled using invalid animation ID.");
    }

    // Set the new collisionEnabled and signal the change.
    EditorAnimation& animation{animationPair->second};
    animation.collisionEnabled = newCollisionEnabled;

    animationCollisionEnabledChangedSig.publish(animationID,
                                                newCollisionEnabled);
}

void AnimationModel::setAnimationEntityAlignmentAnchor(
    AnimationID animationID,
    const std::optional<Vector3>& newEntityAlignmentAnchor)
{
    auto animationPair{animationMap.find(animationID)};
    if (animationPair == animationMap.end()) {
        LOG_FATAL(
            "Tried to set entityAlignmentAnchor using invalid animation ID.");
    }

    // Set the new entityAlignmentAnchor and signal the change.
    EditorAnimation& animation{animationPair->second};
    animation.entityAlignmentAnchor = newEntityAlignmentAnchor;

    animationEntityAlignmentAnchorChangedSig.publish(animationID,
                                                     newEntityAlignmentAnchor);
}

void AnimationModel::addAnimationFrame(AnimationID animationID,
                                       const EditorSprite& newSprite)
{
    auto animationPair{animationMap.find(animationID)};
    if (animationPair == animationMap.end()) {
        LOG_FATAL("Tried to add frame using invalid animation ID.");
    }

    EditorAnimation& animation{animationPair->second};
    std::vector<const EditorSprite*> frames{animation.getExpandedFrameVector()};

    // If the new sprite isn't the same size as the other sprites, don't add it.
    for (const EditorAnimation::Frame& frame : animation.frames) {
        const SDL_Rect& textureExtent{frame.sprite.get().textureExtent};
        if ((newSprite.textureExtent.w != textureExtent.w)
            || (newSprite.textureExtent.h != textureExtent.h)) {
            return;
        }
    }

    // If there are no filled frames in the animation, and there are empty 
    // frames, add the sprite to the first frame.
    // Note: This should only occur with newly created animations.
    int frameNumber{-1};
    if ((animation.frames.size() == 0) && (animation.frameCount > 0)) {
        frames.at(0) = &newSprite;
        frameNumber = 0;
    }
    else {
        // The animation has filled frames. If the last filled frame has an 
        // empty slot after it, add the sprite to that slot.
        for (std::size_t i{frames.size()}; i-- > 0;) {
            if (frames.at(i)) {
                // Found the last filled frame. Is there an empty frame after it?
                if ((i + 1) < frames.size()) {
                    // There's an empty frame after, add the sprite to it.
                    frames.at(i + 1) = &newSprite;
                    frameNumber = static_cast<Uint8>(i + 1);
                }

                break;
            }
        }

        // If the last frame wasn't followed by an empty slot, add the sprite 
        // to a new frame at the end.
        if (frameNumber == -1) {
            frames.emplace_back(&newSprite);
            frameNumber = static_cast<Uint8>(frames.size() - 1);

            // Update the frame count, since we added a frame.
            animation.frameCount = static_cast<Uint8>(frames.size());
            animationFrameCountChangedSig.publish(animationID,
                                                  animation.frameCount);
            // Note: We don't update loop start because the user will likely be
            //       adding all their sprites at once, in which case we want to 
            //       keep loopStartFrame at 0 (to loop all). The downside is, 
            //       if the user sets their loopStart elsewhere (e.g. the end, 
            //       to loop none) and then adds a sprite, they may need to re-
            //       adjust their loop start.
        }
    }

    // Update the animation and signal the change.
    animation.setFromExpandedFrameVector(frames);
    animationFrameChangedSig.publish(animationID, frameNumber, &newSprite);
}

void AnimationModel::swapAnimationFrames(AnimationID animationID,
                                         Uint8 sourceFrameNumber,
                                         Uint8 destFrameNumber)
{
    auto animationPair{animationMap.find(animationID)};
    if (animationPair == animationMap.end()) {
        LOG_FATAL("Tried to swap frames using invalid animation ID.");
    }

    EditorAnimation& animation{animationPair->second};
    AM_ASSERT(sourceFrameNumber < animation.frameCount,
              "Invalid frame number.");
    AM_ASSERT(destFrameNumber < animation.frameCount,
              "Invalid frame number.");
    std::vector<const EditorSprite*> frames{animation.getExpandedFrameVector()};

    // Swap the frames.
    const EditorSprite* oldSourceSprite{frames.at(sourceFrameNumber)};
    frames.at(sourceFrameNumber) = frames.at(destFrameNumber);
    frames.at(destFrameNumber) = oldSourceSprite;

    // Update the animation and signal the changes.
    animation.setFromExpandedFrameVector(frames);
    animationFrameChangedSig.publish(animationID, sourceFrameNumber,
                                     frames.at(sourceFrameNumber));
    animationFrameChangedSig.publish(animationID, destFrameNumber,
                                     frames.at(destFrameNumber));
}

void AnimationModel::clearAnimationFrame(AnimationID animationID,
                                         Uint8 frameNumber)
{
    auto animationPair{animationMap.find(animationID)};
    if (animationPair == animationMap.end()) {
        LOG_FATAL("Tried to clear frame using invalid animation ID.");
    }

    EditorAnimation& animation{animationPair->second};
    AM_ASSERT(frameNumber < animation.frameCount, "Invalid frame number.");

    // If a frame matches the given number, erase it.
    std::vector<EditorAnimation::Frame>& frames{animation.frames};
    bool wasErased{false};
    for (auto it = frames.begin(); it != frames.end(); ++it) {
        if (it->frameNumber == frameNumber) {
            frames.erase(it);
            wasErased = true;
            break;
        }
    }

    // Signal the change.
    if (wasErased) {
        animationFrameChangedSig.publish(animationID, frameNumber, nullptr);
    }
}

void AnimationModel::resetModelState()
{
    animationMap.clear();
    animationIDPool.freeAllIDs();
}

const std::string& AnimationModel::getErrorString()
{
    return errorString;
}

bool AnimationModel::parseAnimation(const nlohmann::json& animationJson)
{
    // Mark the animation's ID as reserved so it doesn't get reused.
    AnimationID animationID{
        animationJson.at("numericID").get<AnimationID>()};
    animationIDPool.markIDAsReserved(animationID);

    animationMap.emplace(animationID, EditorAnimation{animationID});
    EditorAnimation& animation{animationMap[animationID]};

    // If the display name isn't unique, fail.
    std::string displayName{
        animationJson.at("displayName").get<std::string>()};
    if (!animationNameIsUnique(animationID, displayName)) {
        errorString = "Animation display name isn't unique: ";
        errorString += animation.displayName.c_str();
        return false;
    }
    animationNameMap.emplace(displayName, animationID);

    // Add the display name.
    animation.displayName = displayName;

    // Add the frame count and fps.
    animation.frameCount = animationJson.at("frameCount");
    animation.fps = animationJson.at("fps");

    // Add the loop start frame.
    animation.loopStartFrame = animationJson.at("loopStartFrame");

    // Add the frames.
    // Note: Frame numbers/IDs are parallel arrays to save file space. If we 
    //       switch to a binary format, they can be combined into a single 
    //       struct or used as key/value in a map.
    const auto& frameNumbersJson{animationJson.at("frameNumbers")};
    const auto& spriteIdsJson{animationJson.at("spriteIDs")};
    for (std::size_t i{0}; i < frameNumbersJson.size(); ++i) {
        // Note: We skip frames that contain the null sprite.
        SpriteID spriteID{spriteIdsJson.at(i).get<SpriteID>()};
        if (spriteID) {
            Uint8 frameNumber{frameNumbersJson.at(i).get<Uint8>()};
            const EditorSprite& sprite{
                dataModel.spriteModel.getSprite(spriteID)};
            animation.frames.emplace_back(frameNumber, sprite);
        }
    }

    // Add collisionEnabled.
    animation.collisionEnabled = animationJson.at("collisionEnabled");

    // Add modelBoundsID.
    animation.modelBoundsID = animationJson.at("modelBoundsID");

    // Default our custom bounds to the saved modelBounds, regardless of 
    // whether we use a shared bounding box or not.
    animation.customModelBounds.min.x
        = animationJson.at("modelBounds").at("minX");
    animation.customModelBounds.max.x
        = animationJson.at("modelBounds").at("maxX");
    animation.customModelBounds.min.y
        = animationJson.at("modelBounds").at("minY");
    animation.customModelBounds.max.y
        = animationJson.at("modelBounds").at("maxY");
    animation.customModelBounds.min.z
        = animationJson.at("modelBounds").at("minZ");
    animation.customModelBounds.max.z
        = animationJson.at("modelBounds").at("maxZ");

    // Add entityAlignmentAnchor, if present.
    if (animationJson.contains("entityAlignmentAnchor")) {
        animation.entityAlignmentAnchor
            = {animationJson.at("entityAlignmentAnchor").at("x"),
               animationJson.at("entityAlignmentAnchor").at("y"),
               animationJson.at("entityAlignmentAnchor").at("z")};
    }

    // Signal the new animation to the UI.
    animationAddedSig.publish(animationID, animation);

    return true;
}

bool AnimationModel::animationNameIsUnique(AnimationID animationID,
                                               const std::string& displayName)
{
    // If the desired name is already in the map, and the owner of the name 
    // isn't the given ID, the name isn't unique.
    auto it{animationNameMap.find(displayName)};
    if ((it != animationNameMap.end()) && (it->second != animationID)) {
        return false;
    }

    // Name isn't in the map, or it's owned by the same ID.
    return true;
}

const EditorAnimation&
    AnimationModel::addAnimation(std::string_view displayName)
{
    AM_ASSERT(animationNameMap.find(displayName) == animationNameMap.end(),
              "Animation name already in use.");

    AnimationID numericID{
        static_cast<AnimationID>(animationIDPool.reserveID())};

    // Add the new animation to the maps.
    animationMap.emplace(numericID,
                         EditorAnimation{numericID, std::string{displayName}});
    animationNameMap.emplace(displayName, numericID);

    // Default to a non-0 bounding box so it's easier to click.
    EditorAnimation& animation{animationMap.at(numericID)};
    static constexpr BoundingBox defaultBox{{0, 0, 0}, {20, 20, 20}};
    animation.customModelBounds = defaultBox;

    // Signal the new animation to the UI.
    animationAddedSig.publish(numericID, animation);

    return animation;
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/Private/BoundingBoxModel.cpp`:

```cpp
#include "BoundingBoxModel.h"
#include "DataModel.h"
#include "nlohmann/json.hpp"
#include "Log.h"

namespace AM
{
namespace ResourceImporter
{

BoundingBoxModel::BoundingBoxModel(DataModel& inDataModel)
: dataModel{inDataModel}
, boundingBoxMap{}
, boundingBoxNameMap{}
, boundingBoxIDPool{IDPool::ReservationStrategy::ReuseLowest, 32}
, errorString{}
, boundingBoxAddedSig{}
, boundingBoxRemovedSig{}
, boundingBoxDisplayNameChangedSig{}
, boundingBoxBoundsChangedSig{}
, boundingBoxAdded{boundingBoxAddedSig}
, boundingBoxRemoved{boundingBoxRemovedSig}
, boundingBoxDisplayNameChanged{boundingBoxDisplayNameChangedSig}
, boundingBoxBoundsChanged{boundingBoxBoundsChangedSig}
{
    // Reserve the null bounding box ID (the engine provides it in code, 
    // so we don't need it in the json).
    boundingBoxIDPool.reserveID();
}

bool BoundingBoxModel::load(const nlohmann::json& json)
{
    try {
        // Add each bounding box.
        for (auto& boundsJson : json.at("boundingBoxes").items()) {
            if (!parseBoundingBox(boundsJson.value())) {
                return false;
            }
        }
    } catch (nlohmann::json::exception& e) {
        resetModelState();
        errorString = "Parse failure - ";
        errorString += e.what();
        return false;
    }

    return true;
}

void BoundingBoxModel::save(nlohmann::json& json)
{
    json["boundingBoxes"] = nlohmann::json::array();

    // Fill the json with each bounding box in the model.
    int i{0};
    for (auto& boundsPair : boundingBoxMap) {
        // Add the display name.
        EditorBoundingBox& bounds{boundsPair.second};
        json["boundingBoxes"][i]["displayName"] = bounds.displayName;

        // Note: We don't need a string ID because the engine never 
        //       directly refers to these bounding boxes.

        // Add the numeric ID.
        json["boundingBoxes"][i]["numericID"] = bounds.numericID;

        // Add the model-space bounds.
        json["boundingBoxes"][i]["modelBounds"]["minX"]
            = bounds.modelBounds.min.x;
        json["boundingBoxes"][i]["modelBounds"]["maxX"]
            = bounds.modelBounds.max.x;
        json["boundingBoxes"][i]["modelBounds"]["minY"]
            = bounds.modelBounds.min.y;
        json["boundingBoxes"][i]["modelBounds"]["maxY"]
            = bounds.modelBounds.max.y;
        json["boundingBoxes"][i]["modelBounds"]["minZ"]
            = bounds.modelBounds.min.z;
        json["boundingBoxes"][i]["modelBounds"]["maxZ"]
            = bounds.modelBounds.max.z;

        i++;
    }
}

bool BoundingBoxModel::addBoundingBox()
{
    // Generate a unique name.
    int nameCount{0};
    std::string displayName{"NewBoundingBox"};
    while (!boundingBoxNameIsUnique(NULL_BOUNDING_BOX_ID, displayName)) {
        displayName = "NewBoundingBox" + std::to_string(nameCount);
        nameCount++;
    }

    // Add the box and signal to the UI that it was added.
    EditorBoundingBox& boundingBox{
        addBoundingBoxInternal(displayName, {{0, 0, 0}, {20, 20, 20}})};

    // Set the new bounding box as the active library item.
    dataModel.setActiveBoundingBox(boundingBox.numericID);

    return true;
}

BoundingBoxID
    BoundingBoxModel::addOrUpdateBoundingBox(const std::string& displayName,
                                             const BoundingBox& modelBounds)
{
    // If the name isn't taken, add a new box and signal to the UI that it 
    // was added.
    auto it{boundingBoxNameMap.find(displayName)};
    if (it == boundingBoxNameMap.end()) {
        EditorBoundingBox& boundingBox{
            addBoundingBoxInternal(displayName, modelBounds)};
        return boundingBox.numericID;
    }

    // A box already exists with the given name. Update it and signal to the UI 
    // that it was updated.
    BoundingBoxID boundingBoxID{it->second};
    setBoundingBoxBounds(boundingBoxID, modelBounds);

    return boundingBoxID;
}

void BoundingBoxModel::remBoundingBox(BoundingBoxID boundingBoxID)
{
    // Find the boundingBox in the map.
    auto boundingBoxIt{boundingBoxMap.find(boundingBoxID)};
    if (boundingBoxIt == boundingBoxMap.end()) {
        LOG_FATAL("Invalid ID while removing bounding box.");
    }

    // Free the boundingBox's ID.
    boundingBoxIDPool.freeID(boundingBoxID);

    // Erase the bounding box.
    boundingBoxNameMap.erase(boundingBoxIt->second.displayName);
    boundingBoxMap.erase(boundingBoxIt);

    // Signal that the bounding box was erased.
    boundingBoxRemovedSig.publish(boundingBoxID);
}

const EditorBoundingBox&
    BoundingBoxModel::getBoundingBox(BoundingBoxID boundingBoxID) const
{
    auto boundingBoxIt{boundingBoxMap.find(boundingBoxID)};
    if (boundingBoxIt == boundingBoxMap.end()) {
        LOG_FATAL("Tried to get bounding box with invalid ID: %d",
                  boundingBoxID);
    }

    return boundingBoxIt->second;
}

void BoundingBoxModel::setBoundingBoxDisplayName(
    BoundingBoxID boundingBoxID, const std::string& newDisplayName)
{
    auto boundingBoxPair{ boundingBoxMap.find(boundingBoxID) };
    if (boundingBoxPair == boundingBoxMap.end()) {
        LOG_FATAL("Tried to set name using invalid bounding box ID.");
    }

    // Set the new display name and make it unique.
    // Note: All characters that a user can enter are valid in the display
    //       name string, so we don't need to validate.
    int appendedNum{ 0 };
    std::string uniqueDisplayName{ newDisplayName };
    while (!boundingBoxNameIsUnique(boundingBoxID, uniqueDisplayName)) {
        uniqueDisplayName = newDisplayName + std::to_string(appendedNum);
        appendedNum++;
    }

    EditorBoundingBox& boundingBox{ boundingBoxPair->second };
    boundingBoxNameMap.erase(boundingBox.displayName);
    boundingBoxNameMap.emplace(uniqueDisplayName, boundingBoxID);
    boundingBox.displayName = uniqueDisplayName;

    // Signal the change.
    boundingBoxDisplayNameChangedSig.publish(boundingBoxID,
        boundingBox.displayName);
}

void BoundingBoxModel::setBoundingBoxBounds(
    BoundingBoxID boundingBoxID, const BoundingBox& newBounds)
{
    auto boundingBoxPair{ boundingBoxMap.find(boundingBoxID) };
    if (boundingBoxPair == boundingBoxMap.end()) {
        LOG_FATAL("Tried to set bounds using invalid bounding box ID.");
    }

    EditorBoundingBox& boundingBox{ boundingBoxPair->second };
    boundingBox.modelBounds = newBounds;

    // Signal the change.
    boundingBoxBoundsChangedSig.publish(boundingBoxID, boundingBox.modelBounds);
}

void BoundingBoxModel::resetModelState()
{
    boundingBoxMap.clear();
    boundingBoxIDPool.freeAllIDs();
}

const std::string& BoundingBoxModel::getErrorString()
{
    return errorString;
}

bool BoundingBoxModel::parseBoundingBox(const nlohmann::json& boundsJson)
{
    // Mark the bounding box's ID as reserved so it doesn't get reused.
    BoundingBoxID boundingBoxID{
        boundsJson.at("numericID").get<BoundingBoxID>() };
    boundingBoxIDPool.markIDAsReserved(boundingBoxID);

    boundingBoxMap.emplace(boundingBoxID, EditorBoundingBox{ boundingBoxID });
    EditorBoundingBox& boundingBox{ boundingBoxMap[boundingBoxID] };

    // If the display name isn't unique, fail.
    std::string displayName{
        boundsJson.at("displayName").get<std::string>() };
    if (!boundingBoxNameIsUnique(boundingBoxID, displayName)) {
        errorString = "Bounding box display name isn't unique: ";
        errorString += boundingBox.displayName.c_str();
        return false;
    }
    boundingBoxNameMap.emplace(displayName, boundingBoxID);

    // Add the display name.
    boundingBox.displayName = displayName;

    // Add the model-space bounds.
    boundingBox.modelBounds.min.x = boundsJson.at("modelBounds").at("minX");
    boundingBox.modelBounds.max.x = boundsJson.at("modelBounds").at("maxX");
    boundingBox.modelBounds.min.y = boundsJson.at("modelBounds").at("minY");
    boundingBox.modelBounds.max.y = boundsJson.at("modelBounds").at("maxY");
    boundingBox.modelBounds.min.z = boundsJson.at("modelBounds").at("minZ");
    boundingBox.modelBounds.max.z = boundsJson.at("modelBounds").at("maxZ");

    // Signal the new bounding box to the UI.
    boundingBoxAddedSig.publish(boundingBoxID, boundingBox);

    return true;
}

bool BoundingBoxModel::boundingBoxNameIsUnique(BoundingBoxID boundingBoxID,
    const std::string& displayName)
{
    // If the desired name is already in the map, and the owner of the name 
    // isn't the given ID, the name isn't unique.
    auto it{boundingBoxNameMap.find(displayName)};
    if ((it != boundingBoxNameMap.end()) && (it->second != boundingBoxID)) {
        return false;
    }

    // Name isn't in the map, or it's owned by the same ID.
    return true;
}

EditorBoundingBox&
    BoundingBoxModel::addBoundingBoxInternal(const std::string& displayName,
                                             const BoundingBox& modelBounds)
{
    BoundingBoxID numericID{
        static_cast<BoundingBoxID>(boundingBoxIDPool.reserveID())};

    // Add the new bounding box to the maps. Default to a non-0 bounding box so 
    // it's easier to click.
    boundingBoxMap.emplace(
        numericID, EditorBoundingBox{numericID, displayName, modelBounds});
    boundingBoxNameMap.emplace(displayName, numericID);

    // Signal the new bounding box to the UI.
    EditorBoundingBox& boundingBox{boundingBoxMap.at(numericID)};
    boundingBoxAddedSig.publish(numericID, boundingBox);

    return boundingBox;
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/Private/DataModel.cpp`:

```cpp
#include "DataModel.h"
#include "Log.h"
#include "AMAssert.h"
#include "AUI/Core.h"
#include "nlohmann/json.hpp"
#include <SDL_render.h>
#include <SDL_image.h>
#include <filesystem>
#include <algorithm>
#include <cctype>
#include <iostream>

namespace AM
{
namespace ResourceImporter
{
DataModel::DataModel(SDL_Renderer* inSdlRenderer)
: spriteModel{*this, inSdlRenderer}
, animationModel{*this}
, boundingBoxModel{*this}
, graphicSetModel{*this}
, entityGraphicSetModel{*this}
, iconModel{*this, inSdlRenderer}
, workingJsonPath{""}
, workingTexturesDir{""}
, workingIndividualSpritesDir{""}
, activeLibraryItemChangedSig{}
, activeLibraryItemChanged{activeLibraryItemChangedSig}
{
}

bool DataModel::open(std::string_view resourcesPath)
{
    // Check that the selected path is a directory named "Resources".
    if (!(resourcesPath.ends_with("Resources"))) {
        errorString
            = "Please select the \"Resources\" directory in your project.";
        return false;
    }

    // Check that the asset directories exist.
    std::string texturesDir{resourcesPath};
    texturesDir.append("/Client/Common/Assets/Textures/");
    if (std::filesystem::exists(texturesDir)) {
        workingTexturesDir = texturesDir;
    }
    else {
        errorString = "Textures directory does not exist. Please adopt the "
                      "expected project layout.";
        return false;
    }

    // If there's already a ResourceData.json, load it.
    workingJsonPath = resourcesPath;
    workingJsonPath += "/Shared/Common/ResourceData.json";
    bool result{false};
    if (std::filesystem::exists(workingJsonPath)) {
        result = loadJson(workingJsonPath);
    }
    else {
        // Json doesn't exist. Create it.
        std::string jsonParentPath{resourcesPath};
        jsonParentPath += "/Shared/Common/";
        result = createJson(jsonParentPath);
    }

    // If the operation failed, return early.
    if (!result) {
        workingJsonPath = "";
        return false;
    }

    std::string individualSpritessDir{resourcesPath};
    individualSpritessDir.append("/Client/Common/Assets/IndividualSprites/");
    if (std::filesystem::exists(individualSpritessDir)) {
        workingIndividualSpritesDir = individualSpritessDir;
    }
    else {
        errorString = "IndividualSprites directory does not exist. Please "
                      "adopt the expected project layout.";
        return false;
    }

    return true;
}

void DataModel::save()
{
    // Save each part of the model to a json object.
    nlohmann::json json;
    boundingBoxModel.save(json);
    spriteModel.save(json);
    animationModel.save(json);
    graphicSetModel.save(json);
    entityGraphicSetModel.save(json);
    iconModel.save(json);

    // Write the json to our working file.
    std::ofstream workingFile(workingJsonPath, std::ios::trunc);
    if (!(workingFile.is_open())) {
        LOG_FATAL("File failed to open: %s.", workingJsonPath.c_str());
    }

    std::string jsonDump{json.dump(4)};
    workingFile << jsonDump;
}

EditorGraphicRef DataModel::getGraphic(GraphicID graphicID)
{
    if (isSpriteID(graphicID)) {
        return EditorGraphicRef{spriteModel.getSprite(toSpriteID(graphicID))};
    }
    else {
        return EditorGraphicRef{
            animationModel.getAnimation(toAnimationID(graphicID))};
    }
}

void DataModel::setActiveSpriteSheet(int newActiveSpriteSheetID)
{
    // Note: This will error if the sheet ID is invalid. This is good, since
    //       we don't expect any invalid IDs to be floating around.
    const EditorSpriteSheet& spriteSheet{
        spriteModel.getSpriteSheet(newActiveSpriteSheetID)};

    // Signal the active sprite to the UI.
    activeLibraryItemChangedSig.publish(spriteSheet);
}

void DataModel::setActiveSprite(SpriteID newActiveSpriteID)
{
    // Note: This will error if the sprite ID is invalid. This is good, since
    //       we don't expect any invalid IDs to be floating around.
    const EditorSprite& sprite{spriteModel.getSprite(newActiveSpriteID)};

    // Signal the active sprite to the UI.
    activeLibraryItemChangedSig.publish(sprite);
}

void DataModel::setActiveAnimation(AnimationID newActiveAnimationID)
{
    // Note: This will error if the animation ID is invalid. This is good, since
    //       we don't expect any invalid IDs to be floating around.
    const EditorAnimation& animation{
        animationModel.getAnimation(newActiveAnimationID)};

    // Signal the active animation to the UI.
    activeLibraryItemChangedSig.publish(animation);
}

void DataModel::setActiveBoundingBox(BoundingBoxID newActiveBoundingBoxID)
{
    // Note: This will error if the ID is invalid. This is good, since we don't
    //       expect any invalid IDs to be floating around.
    const EditorBoundingBox& boundingBox{
        boundingBoxModel.getBoundingBox(newActiveBoundingBoxID)};

    // Signal the active bounding box to the UI.
    activeLibraryItemChangedSig.publish(boundingBox);
}

void DataModel::setActiveGraphicSet(GraphicSet::Type type,
                                    Uint16 newActiveGraphicSetID)
{
    // Match the sprite set type, then:
    //   1. Get the set with the given ID (error if it doesn't exist).
    //   2. Signal it out.
    switch (type) {
        case GraphicSet::Type::Terrain: {
            activeLibraryItemChangedSig.publish(
                graphicSetModel.getTerrain(newActiveGraphicSetID));
            return;
        }
        case GraphicSet::Type::Floor: {
            activeLibraryItemChangedSig.publish(
                graphicSetModel.getFloor(newActiveGraphicSetID));
            return;
        }
        case GraphicSet::Type::Wall: {
            activeLibraryItemChangedSig.publish(
                graphicSetModel.getWall(newActiveGraphicSetID));
            return;
        }
        case GraphicSet::Type::Object: {
            activeLibraryItemChangedSig.publish(
                graphicSetModel.getObject(newActiveGraphicSetID));
            return;
        }
        case GraphicSet::Type::Entity: {
            activeLibraryItemChangedSig.publish(
                entityGraphicSetModel.getEntity(newActiveGraphicSetID));
            return;
        }
        default: {
            LOG_FATAL("Unsupported graphic set type: %u", type);
        }
    }
}

void DataModel::setActiveIcon(IconID newActiveIconID)
{
    // Note: This will error if the ID is invalid. This is good, since we don't
    //       expect any invalid IDs to be floating around.
    const EditorIcon& icon{iconModel.getIcon(newActiveIconID)};

    // Signal the active icon to the UI.
    activeLibraryItemChangedSig.publish(icon);
}

const std::string& DataModel::getWorkingTexturesDir() const
{
    return workingTexturesDir;
}

const std::string& DataModel::getWorkingIndividualSpritesDir() const
{
    return workingIndividualSpritesDir;
}

const std::string& DataModel::getErrorString() const
{
    return errorString;
}

bool DataModel::validateRelPath(const std::string& relPath)
{
    // Construct the file path.
    std::filesystem::path filePath{getWorkingTexturesDir()};
    filePath.append(relPath);

    // Check if the file exists.
    if (std::filesystem::exists(filePath)) {
        return true;
    }
    else {
        errorString = "File not found at Assets/Textures/";
        errorString += relPath;
        return false;
    }
}

bool DataModel::createJson(const std::string& inJsonFilePath)
{
    // Create the file.
    std::ofstream workingJson(inJsonFilePath, std::ios::app);
    workingJson.close();

    // Save our empty model structure.
    save();

    return true;
}

bool DataModel::loadJson(const std::string& inJsonFilePath)
{
    // Open the file.
    std::ifstream workingJsonFile(inJsonFilePath);
    if (!(workingJsonFile.is_open())) {
        errorString = "File failed to open.";
        return false;
    }

    // Parse the file into a json structure.
    nlohmann::json json;
    std::string parseError{""};
    try {
        json = nlohmann::json::parse(workingJsonFile, nullptr);
    } catch (nlohmann::json::exception& e) {
        parseError = e.what();
    }

    // Load the data into each model.
    if (parseError == "") {
        if (!boundingBoxModel.load(json)) {
            parseError = boundingBoxModel.getErrorString();
        }
        else if (!spriteModel.load(json)) {
            parseError = spriteModel.getErrorString();
        }
        else if (!animationModel.load(json)) {
            parseError = animationModel.getErrorString();
        }
        else if (!graphicSetModel.load(json)) {
            parseError = graphicSetModel.getErrorString();
        }
        else if (!entityGraphicSetModel.load(json)) {
            parseError = entityGraphicSetModel.getErrorString();
        }
        else if (!iconModel.load(json)) {
            parseError = iconModel.getErrorString();
        }
    }

    if (parseError != "") {
        resetModelState();
        errorString = parseError;
        return false;
    }

    return true;
}

void DataModel::resetModelState()
{
    workingJsonPath = "";
    workingTexturesDir = "";
    workingIndividualSpritesDir = "";

    spriteModel.resetModelState();
    graphicSetModel.resetModelState();
    entityGraphicSetModel.resetModelState();
    iconModel.resetModelState();
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/Private/EditorAnimation.cpp`:

```cpp
#include "EditorAnimation.h"
#include "BoundingBoxModel.h"
#include "AMAssert.h"

namespace AM
{
namespace ResourceImporter
{

const BoundingBox&
    EditorAnimation::getModelBounds(const BoundingBoxModel& boundingBoxModel) const
{
    if (modelBoundsID) {
        return boundingBoxModel.getBoundingBox(modelBoundsID).modelBounds;
    }
    else {
        return customModelBounds;
    }
}

const EditorSprite* EditorAnimation::getSpriteAtTime(double animationTime) const
{ 
    if (frames.size() == 0) {
        return nullptr;
    }

    // Calculate which frame should be displayed at the given time.
    double frameDuration{1.0 / static_cast<double>(fps)};
    std::size_t desiredFrame{
        static_cast<std::size_t>(animationTime / frameDuration)};

    // Wrap the frame number if necessary.
    desiredFrame %= frames.size();

    // Find the sprite closest to, but not surpassing, the desired frame.
    const EditorSprite* sprite{&(frames[0].sprite.get())};
    for (std::size_t i{0}; i < (frames.size() - 1); ++i) {
        if ((frames[i].frameNumber <= desiredFrame) && 
            (frames[i + 1].frameNumber > desiredFrame)) {
            sprite = &(frames[i].sprite.get());
            break;
        }
    }

    return sprite;
}

const EditorSprite* EditorAnimation::getSpriteAtFrame(Uint8 frameNumber) const
{
    // Try to find a sprite to display.
    for (auto it{frames.rbegin()}; it != frames.rend(); ++it) {
        if (it->frameNumber == frameNumber) {
            // Found the desired frame.
            return &(it->sprite.get());
        }
        else if (it->frameNumber < frameNumber) {
            // The desired frame wasn't found, but a previous frame with a 
            // sprite was found.
            return &(it->sprite.get());
        }
    }

    // No sprite found in the desired frame or a previous frame. Return nullptr.
    return nullptr;
}

std::vector<const EditorSprite*> EditorAnimation::getExpandedFrameVector() const
{
    std::vector<const EditorSprite*> expandedFrameVector(frameCount, nullptr);
    for (const EditorAnimation::Frame& frame : frames) {
        expandedFrameVector.at(frame.frameNumber) = &(frame.sprite.get());
    }

    return expandedFrameVector;
}

void EditorAnimation::setFromExpandedFrameVector(
    const std::vector<const EditorSprite*>& expandedFrameVector)
{
    frames.clear();

    Uint8 frameNumber{0};
    for (const EditorSprite* frame : expandedFrameVector) {
        if (frame) {
            frames.emplace_back(frameNumber, *frame);
        }

        frameNumber++;
    }

    frameCount = static_cast<Uint8>(expandedFrameVector.size());
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/Private/EditorGraphicRef.cpp`:

```cpp
#include "EditorGraphicRef.h"
#include "BoundingBoxModel.h"
#include "VariantTools.h"
#include "Log.h"

namespace AM
{
namespace ResourceImporter
{

GraphicID EditorGraphicRef::getGraphicID() const
{
    GraphicID graphicID{NULL_GRAPHIC_ID};
    std::visit(VariantTools::Overload{
        [&](std::reference_wrapper<const EditorSprite> sprite) {
            graphicID = toGraphicID(sprite.get().numericID);
        },
        [&](std::reference_wrapper<const EditorAnimation> animation) {
            graphicID = toGraphicID(animation.get().numericID);
        }
    }, *this);

    return graphicID;
}

const std::string& EditorGraphicRef::getDisplayName() const
{
    const std::string* displayName{};
    std::visit(
        [&](const auto& underlying) {
            displayName = &(underlying.get().displayName);
        },
        *this);

    return *displayName;
}

bool EditorGraphicRef::getCollisionEnabled() const
{
    bool collisionEnabled{false};
    std::visit(
        [&](const auto& underlying) {
            collisionEnabled = underlying.get().collisionEnabled;
        },
        *this);

    return collisionEnabled;
}

const BoundingBox& EditorGraphicRef::getModelBounds(
    const BoundingBoxModel& boundingBoxModel) const
{
    const BoundingBox* modelBounds{nullptr};
    std::visit(
        [&](const auto& underlying) {
            modelBounds = &(underlying.get().getModelBounds(boundingBoxModel));
        },
        *this);

    return *modelBounds;
}

const EditorSprite* EditorGraphicRef::getFirstSprite() const
{
    const EditorSprite* spritePtr{nullptr};
    std::visit(VariantTools::Overload{
        [&](std::reference_wrapper<const EditorSprite> sprite) {
            spritePtr = &(sprite.get());
        },
        [&](std::reference_wrapper<const EditorAnimation> animation) {
            if (animation.get().frames.size() > 0) {
                spritePtr = &(animation.get().frames[0].sprite.get());
            }
        }
    }, *this);

    return spritePtr;
}

const EditorSprite* EditorGraphicRef::getSpriteAtTime(double animationTime) const
{
    const EditorSprite* spritePtr{nullptr};
    std::visit(VariantTools::Overload{
        [&](std::reference_wrapper<const EditorSprite> sprite) {
            spritePtr = &(sprite.get());
        },
        [&](std::reference_wrapper<const EditorAnimation> animation) {
            spritePtr = animation.get().getSpriteAtTime(animationTime);
        }
    }, *this);

    return spritePtr;
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/Private/EditorSprite.cpp`:

```cpp
#include "EditorSprite.h"
#include "BoundingBoxModel.h"

namespace AM
{
namespace ResourceImporter
{

const BoundingBox&
    EditorSprite::getModelBounds(const BoundingBoxModel& boundingBoxModel) const
{
    if (modelBoundsID) {
        return boundingBoxModel.getBoundingBox(modelBoundsID).modelBounds;
    }
    else {
        return customModelBounds;
    }
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/Private/EntityGraphicSetModel.cpp`:

```cpp
#include "EntityGraphicSetModel.h"
#include "DataModel.h"
#include "StringTools.h"
#include "nlohmann/json.hpp"

namespace AM
{
namespace ResourceImporter
{
EntityGraphicSetModel::EntityGraphicSetModel(DataModel& inDataModel)
: dataModel{inDataModel}
, entityIDPool{IDPool::ReservationStrategy::ReuseLowest, 32}
, errorString{}
, entityAddedSig{}
, entityRemovedSig{}
, entitySlotChangedSig{}
, entityDisplayNameChangedSig{}
, entityAdded{entityAddedSig}
, entityRemoved{entityRemovedSig}
, entitySlotChanged{entitySlotChangedSig}
, entityDisplayNameChanged{entityDisplayNameChangedSig}
{
    // Reserve the null ID (the engine provides it in code, so we don't need it
    // in the json).
    entityIDPool.reserveID();
}

bool EntityGraphicSetModel::load(const nlohmann::json& json)
{
    try {
        for (auto& entityJson : json.at("entities").items()) {
            if (!parseEntityGraphicSet(entityJson.value())) {
                resetModelState();
                return false;
            }
        }
    } catch (nlohmann::json::exception& e) {
        resetModelState();
        errorString = "Parse failure - ";
        errorString += e.what();
        return false;
    }

    return true;
}

void EntityGraphicSetModel::save(nlohmann::json& json)
{
    json["entities"] = nlohmann::json::array();

    // Fill the json with each entity graphic set in the model.
    // Note: We encourage people to always have an Idle South graphic (since 
    //       that's what we use in any situation that needs a default), but 
    //       we don't require it. If they end up with an unclickable entity 
    //       because they didn't add any graphics to a set, they can easily fix
    //       it.
    int i{0};
    for (auto& graphicSetPair : entityMap) {
        EditorEntityGraphicSet& graphicSet{graphicSetPair.second};
        json["entities"][i]["displayName"] = graphicSet.displayName;
        json["entities"][i]["numericID"] = graphicSet.numericID;

        // Note: Types/Values are parallel arrays to save file space. If we 
        //       switch to a binary format, they can be combined into a single 
        //       struct or used as key/value in a map.
        for (auto& [entityGraphicType, graphicID] : graphicSet.graphicIDs) {
            json["entities"][i]["graphicIDTypes"].push_back(entityGraphicType);
            json["entities"][i]["graphicIDValues"].push_back(graphicID);
        }

        i++;
    }
}

bool EntityGraphicSetModel::addEntity()
{
    EntityGraphicSetID numericID{
        static_cast<EntityGraphicSetID>(entityIDPool.reserveID())};

    // Generate a unique name.
    int nameCount{0};
    std::string displayName{"NewEntity"};
    while (!graphicSetNameIsUnique(numericID, displayName)) {
        displayName = "NewEntity" + std::to_string(nameCount);
        nameCount++;
    }

    // Add the new, empty graphic set to the map.
    entityMap.emplace(numericID,
                      EditorEntityGraphicSet{numericID, displayName});
    EditorEntityGraphicSet& graphicSet{entityMap[numericID]};
    graphicSet.graphicIDs.emplace(
        EntityGraphicType::Idle,
        std::array<GraphicID, Rotation::Direction::Count>{
            /* NULL_GRAPHIC_ID */});

    // Signal the new graphic set to the UI.
    entityAddedSig.publish(numericID, graphicSet);

    // Set the new graphic set as the active library item.
    dataModel.setActiveGraphicSet(GraphicSet::Type::Entity, numericID);

    return true;
}

void EntityGraphicSetModel::remEntity(EntityGraphicSetID entityID)
{
    // Find the entity in the map.
    auto entityIt{entityMap.find(entityID)};
    if (entityIt == entityMap.end()) {
        LOG_FATAL("Invalid ID while removing entity.");
    }

    // Free the entity's ID.
    entityIDPool.freeID(entityID);

    // Erase the entity.
    entityMap.erase(entityIt);

    // Signal that the graphic set was erased.
    entityRemovedSig.publish(entityID);
}

const EditorEntityGraphicSet&
    EntityGraphicSetModel::getEntity(EntityGraphicSetID entityID)
{
    auto entityIt{entityMap.find(entityID)};
    if (entityIt == entityMap.end()) {
        LOG_FATAL("Tried to get entity with invalid ID: %d", entityID);
    }

    return entityIt->second;
}

void EntityGraphicSetModel::setEntityDisplayName(
    EntityGraphicSetID graphicSetID, const std::string& newDisplayName)
{
    auto graphicSetPair{entityMap.find(graphicSetID)};
    if (graphicSetPair == entityMap.end()) {
        LOG_FATAL("Tried to set name using invalid graphic set ID.");
    }

    // Set the new display name and make it unique.
    // Note: All characters that a user can enter are valid in the display
    //       name string, so we don't need to validate.
    int appendedNum{0};
    std::string uniqueDisplayName{newDisplayName};
    while (!graphicSetNameIsUnique(graphicSetID, uniqueDisplayName)) {
        uniqueDisplayName = newDisplayName + std::to_string(appendedNum);
        appendedNum++;
    }

    EditorEntityGraphicSet& graphicSet{graphicSetPair->second};
    graphicSet.displayName = uniqueDisplayName;

    // Signal the change.
    entityDisplayNameChangedSig.publish(graphicSetID, graphicSet.displayName);
}

void EntityGraphicSetModel::setEntitySlot(EntityGraphicSetID graphicSetID,
                                          EntityGraphicType graphicType,
                                          Rotation::Direction direction,
                                          GraphicID newGraphicID)
{
    auto graphicSetPair{entityMap.find(graphicSetID)};
    if (graphicSetPair == entityMap.end()) {
        LOG_FATAL("Tried to set slot using invalid graphic set ID.");
    }

    // If newGraphicID is non-null, update or add it to the map.
    EditorEntityGraphicSet& graphicSet{graphicSetPair->second};
    if (newGraphicID) {
        graphicSet.graphicIDs[graphicType].at(direction) = newGraphicID;
    }
    // newGraphicID is null. Clear the map entry.
    else {
        // Never erase Idle, just set it to the null graphic.
        if (graphicType == EntityGraphicType::Idle) {
            for (GraphicID& id : graphicSet.graphicIDs.at(graphicType)) {
                id = NULL_GRAPHIC_ID;
            }
        }
        else {
            graphicSet.graphicIDs.erase(graphicType);
        }
    }

    // Signal the change.
    entitySlotChangedSig.publish(graphicSetID, graphicType, direction,
                                 newGraphicID);
}

void EntityGraphicSetModel::resetModelState()
{
    entityMap.clear();
    entityIDPool.freeAllIDs();
}

void EntityGraphicSetModel::removeGraphicIDFromSets(GraphicID graphicID)
{
    // For each graphic set in the map.
    for (auto& pair : entityMap) {
        EditorEntityGraphicSet& graphicSet{pair.second};

        // For each graphic type in the set.
        auto& graphicIDs{graphicSet.graphicIDs};
        for (auto it{graphicIDs.begin()}; it != graphicIDs.end();) {
            auto& graphicIDArr{it->second};

            // For each graphic in the array.
            for (int i{0}; i < Rotation::Direction::Count; ++i) {
                // If graphicID is present, erase it and signal.
                if (graphicIDArr.at(i) == graphicID) {
                    graphicIDArr.at(i) = NULL_GRAPHIC_ID;
                    entitySlotChangedSig.publish(
                        graphicSet.numericID, it->first,
                        static_cast<Rotation::Direction>(i), NULL_GRAPHIC_ID);
                }
            }

            // If a non-Idle array is now empty, erase this type from the map.
            if ((it->first != EntityGraphicType::Idle)
                && std::ranges::all_of(graphicIDArr, [](GraphicID id) {
                       return id == NULL_GRAPHIC_ID;
                   })) {
                it = graphicIDs.erase(it);
            }
            else {
                it++;
            }
        }
    }
}

const std::string& EntityGraphicSetModel::getErrorString()
{
    return errorString;
}

bool EntityGraphicSetModel::parseEntityGraphicSet(const nlohmann::json& graphicSetJson)
{
    EntityGraphicSetID numericID{
        static_cast<EntityGraphicSetID>(entityIDPool.reserveID())};

    // If the display name isn't unique, error.
    std::string displayName{graphicSetJson.at("displayName").get<std::string>()};
    if (!graphicSetNameIsUnique(numericID, displayName)) {
        errorString = "Entity display name isn't unique: ";
        errorString += displayName.c_str();
        return false;
    }

    // Add the graphic set's graphics.
    // Note: Types/Values are parallel arrays to save file space. If we switch 
    //       to a binary format, they can be combined into a single struct or 
    //       used as key/value in a map.
    const auto& graphicIDTypesJson{graphicSetJson.at("graphicIDTypes")};
    const auto& graphicIDValuesJson{graphicSetJson.at("graphicIDValues")};
    std::unordered_map<EntityGraphicType,
                       std::array<GraphicID, Rotation::Direction::Count>>
        graphicIDs{};
    for (std::size_t i{0}; i < graphicIDTypesJson.size(); ++i) {
        EntityGraphicType graphicType{
            graphicIDTypesJson.at(i).get<EntityGraphicType>()};
        const auto& graphicIDArr{graphicIDValuesJson.at(i)};

        graphicIDs.emplace(graphicType, graphicIDArr);
    }

    // If Idle isn't present, error (must always be present).
    if (!(graphicIDs.contains(EntityGraphicType::Idle))) {
        errorString = "Entity is missing Idle graphics: ";
        errorString += displayName.c_str();
        return false;
    }

    // Save the graphic set in the appropriate map.
    entityMap.emplace(
        numericID, EditorEntityGraphicSet{numericID, displayName, graphicIDs});

    // Signal the new graphic set to the UI.
    EditorEntityGraphicSet& graphicSet{entityMap[numericID]};
    entityAddedSig.publish(numericID, graphicSet);

    return true;
}

bool EntityGraphicSetModel::graphicSetNameIsUnique(
    EntityGraphicSetID graphicSetID, const std::string& displayName)
{
    // Dumbly look through all names for a match.
    // TODO: Eventually, this should change to a name map that we keep updated.
    bool isUnique{true};
    for (const auto& graphicSetPair : entityMap) {
        int idToCheck{graphicSetPair.first};
        const EditorEntityGraphicSet& graphicSet{graphicSetPair.second};

        if ((idToCheck != graphicSetID)
            && (displayName == graphicSet.displayName)) {
            isUnique = false;
        }
    }

    return isUnique;
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/Private/GraphicSetModel.cpp`:

```cpp
#include "GraphicSetModel.h"
#include "DataModel.h"
#include "StringTools.h"
#include "nlohmann/json.hpp"

namespace AM
{
namespace ResourceImporter
{
GraphicSetModel::GraphicSetModel(DataModel& inDataModel)
: dataModel{inDataModel}
, terrainIDPool{IDPool::ReservationStrategy::ReuseLowest, 32}
, floorIDPool{IDPool::ReservationStrategy::ReuseLowest, 32}
, wallIDPool{IDPool::ReservationStrategy::ReuseLowest, 32}
, objectIDPool{IDPool::ReservationStrategy::ReuseLowest, 32}
, errorString{}
, terrainAddedSig{}
, floorAddedSig{}
, wallAddedSig{}
, objectAddedSig{}
, graphicSetRemovedSig{}
, graphicSetSlotChangedSig{}
, graphicSetDisplayNameChangedSig{}
, terrainAdded{terrainAddedSig}
, floorAdded{floorAddedSig}
, wallAdded{wallAddedSig}
, objectAdded{objectAddedSig}
, graphicSetRemoved{graphicSetRemovedSig}
, graphicSetSlotChanged{graphicSetSlotChangedSig}
, graphicSetDisplayNameChanged{graphicSetDisplayNameChangedSig}
{
    // Reserve the null ID for each graphic set type (the engine provides it in 
    // code, so we don't need it in the json).
    terrainIDPool.reserveID();
    floorIDPool.reserveID();
    wallIDPool.reserveID();
    objectIDPool.reserveID();
}

bool GraphicSetModel::load(const nlohmann::json& json)
{
    try {
        // Add each type of graphic set.
        for (auto& terrainJson : json.at("terrain").items()) {
            if (!parseTerrainGraphicSet(terrainJson.value())) {
                resetModelState();
                return false;
            }
        }
        for (auto& floorJson : json.at("floors").items()) {
            if (!parseFloorGraphicSet(floorJson.value())) {
                resetModelState();
                return false;
            }
        }
        for (auto& wallJson : json.at("walls").items()) {
            std::string resultString{};
            if (!parseWallGraphicSet(wallJson.value())) {
                resetModelState();
                return false;
            }
        }
        for (auto& objectJson : json.at("objects").items()) {
            if (!parseObjectGraphicSet(objectJson.value())) {
                resetModelState();
                return false;
            }
        }
    } catch (nlohmann::json::exception& e) {
        resetModelState();
        errorString = "Parse failure - ";
        errorString += e.what();
        return false;
    }

    return true;
}

void GraphicSetModel::save(nlohmann::json& json)
{
    saveTerrain(json);
    saveFloors(json);
    saveWalls(json);
    saveObjects(json);
}

bool GraphicSetModel::addTerrain()
{
    TerrainGraphicSetID numericID{
        static_cast<TerrainGraphicSetID>(terrainIDPool.reserveID())};

    // Generate a unique name.
    int nameCount{0};
    std::string displayName{"NewTerrain"};
    while (!graphicSetNameIsUnique<EditorTerrainGraphicSet>(numericID,
                                                                displayName)) {
        displayName = "NewTerrain" + std::to_string(nameCount);
        nameCount++;
    }

    // Add the new, empty graphic set to the map.
    std::array<GraphicID, Terrain::Height::Count> graphicIDs{
        /* NULL_GRAPHIC_ID */};
    terrainMap.emplace(numericID, EditorTerrainGraphicSet{
                                            numericID, displayName, graphicIDs});

    // Signal the new graphic set to the UI.
    EditorTerrainGraphicSet& graphicSet{terrainMap[numericID]};
    terrainAddedSig.publish(numericID, graphicSet);

    // Set the new graphic as the active library item.
    dataModel.setActiveGraphicSet(GraphicSet::Type::Terrain, numericID);

    return true;
}

bool GraphicSetModel::addFloor()
{
    Uint16 numericID{static_cast<Uint16>(floorIDPool.reserveID())};

    // Generate a unique name.
    int nameCount{0};
    std::string displayName{"NewFloor"};
    while (
        !graphicSetNameIsUnique<EditorFloorGraphicSet>(numericID, displayName)) {
        displayName = "NewFloor" + std::to_string(nameCount);
        nameCount++;
    }

    // Add the new, empty graphic set to the map.
    std::array<GraphicID, Rotation::Direction::Count> graphicIDs{
        /* NULL_GRAPHIC_ID */};
    floorMap.emplace(numericID,
                     EditorFloorGraphicSet{numericID, displayName, graphicIDs});

    // Signal the new graphic set to the UI.
    EditorFloorGraphicSet& graphicSet{floorMap[numericID]};
    floorAddedSig.publish(numericID, graphicSet);

    // Set the new graphic set as the active library item.
    dataModel.setActiveGraphicSet(GraphicSet::Type::Floor, numericID);

    return true;
}

bool GraphicSetModel::addWall()
{
    WallGraphicSetID numericID{
        static_cast<WallGraphicSetID>(wallIDPool.reserveID())};

    // Generate a unique name.
    int nameCount{0};
    std::string displayName{"NewWall"};
    while (
        !graphicSetNameIsUnique<EditorWallGraphicSet>(numericID, displayName)) {
        displayName = "NewWall" + std::to_string(nameCount);
        nameCount++;
    }

    // Add the new, empty graphic set to the map.
    std::array<GraphicID, Wall::Type::Count> graphicIDs{
        /* NULL_GRAPHIC_ID */};
    wallMap.emplace(numericID,
                    EditorWallGraphicSet{numericID, displayName, graphicIDs});

    // Signal the new graphic set to the UI.
    EditorWallGraphicSet& graphicSet{wallMap[numericID]};
    wallAddedSig.publish(numericID, graphicSet);

    // Set the new graphic as the active library item.
    dataModel.setActiveGraphicSet(GraphicSet::Type::Wall, numericID);

    return true;
}

bool GraphicSetModel::addObject()
{
    ObjectGraphicSetID numericID{
        static_cast<ObjectGraphicSetID>(objectIDPool.reserveID())};

    // Generate a unique name.
    int nameCount{0};
    std::string displayName{"NewObject"};
    while (
        !graphicSetNameIsUnique<EditorObjectGraphicSet>(numericID, displayName)) {
        displayName = "NewObject" + std::to_string(nameCount);
        nameCount++;
    }

    // Add the new, empty graphic set to the map.
    std::array<GraphicID, Rotation::Direction::Count> graphicIDs{
        /* NULL_GRAPHIC_ID */};
    objectMap.emplace(numericID,
                      EditorObjectGraphicSet{numericID, displayName, graphicIDs});

    // Signal the new graphic set to the UI.
    EditorObjectGraphicSet& graphicSet{objectMap[numericID]};
    objectAddedSig.publish(numericID, graphicSet);

    // Set the new graphic as the active library item.
    dataModel.setActiveGraphicSet(GraphicSet::Type::Object, numericID);

    return true;
}

void GraphicSetModel::remTerrain(TerrainGraphicSetID terrainID)
{
    // Find the terrain in the map.
    auto terrainIt{terrainMap.find(terrainID)};
    if (terrainIt == terrainMap.end()) {
        LOG_FATAL("Invalid ID while removing terrain.");
    }

    // Free the terrain's ID.
    terrainIDPool.freeID(terrainID);

    // Erase the terrain.
    terrainMap.erase(terrainIt);

    // Signal that the graphic set was erased.
    graphicSetRemovedSig.publish(GraphicSet::Type::Terrain, terrainID);
}

void GraphicSetModel::remFloor(FloorGraphicSetID floorID)
{
    // Find the floor in the map.
    auto floorIt{floorMap.find(floorID)};
    if (floorIt == floorMap.end()) {
        LOG_FATAL("Invalid ID while removing floor.");
    }

    // Free the floor's ID.
    floorIDPool.freeID(floorID);

    // Erase the floor.
    floorMap.erase(floorIt);

    // Signal that the graphic set was erased.
    graphicSetRemovedSig.publish(GraphicSet::Type::Floor, floorID);
}

void GraphicSetModel::remWall(WallGraphicSetID wallID)
{
    // Find the wall in the map.
    auto wallIt{wallMap.find(wallID)};
    if (wallIt == wallMap.end()) {
        LOG_FATAL("Invalid ID while removing wall.");
    }

    // Free the wall's ID.
    wallIDPool.freeID(wallID);

    // Erase the wall.
    wallMap.erase(wallIt);

    // Signal that the graphic set was erased.
    graphicSetRemovedSig.publish(GraphicSet::Type::Wall, wallID);
}

void GraphicSetModel::remObject(ObjectGraphicSetID objectID)
{
    // Find the floor in the map.
    auto objectIt{objectMap.find(objectID)};
    if (objectIt == objectMap.end()) {
        LOG_FATAL("Invalid ID while removing object.");
    }

    // Free the object's ID.
    objectIDPool.freeID(objectID);

    // Erase the object.
    objectMap.erase(objectIt);

    // Signal that the graphic set was erased.
    graphicSetRemovedSig.publish(GraphicSet::Type::Object, objectID);
}

const EditorTerrainGraphicSet&
    GraphicSetModel::getTerrain(TerrainGraphicSetID terrainID)
{
    auto terrainIt{terrainMap.find(terrainID)};
    if (terrainIt == terrainMap.end()) {
        LOG_FATAL("Tried to get terrain with invalid ID: %d", terrainID);
    }

    return terrainIt->second;
}

const EditorFloorGraphicSet& GraphicSetModel::getFloor(FloorGraphicSetID floorID)
{
    auto floorIt{floorMap.find(floorID)};
    if (floorIt == floorMap.end()) {
        LOG_FATAL("Tried to get floor with invalid ID: %d", floorID);
    }

    return floorIt->second;
}

const EditorWallGraphicSet& GraphicSetModel::getWall(WallGraphicSetID wallID)
{
    auto wallIt{wallMap.find(wallID)};
    if (wallIt == wallMap.end()) {
        LOG_FATAL("Tried to get wall with invalid ID: %d", wallID);
    }

    return wallIt->second;
}

const EditorObjectGraphicSet&
    GraphicSetModel::getObject(ObjectGraphicSetID objectID)
{
    auto objectIt{objectMap.find(objectID)};
    if (objectIt == objectMap.end()) {
        LOG_FATAL("Tried to get object with invalid ID: %d", objectID);
    }

    return objectIt->second;
}

void GraphicSetModel::setGraphicSetDisplayName(GraphicSet::Type type,
                                             Uint16 graphicSetID,
                                             const std::string& newDisplayName)
{
    switch (type) {
        case GraphicSet::Type::Terrain: {
            setGraphicSetDisplayName<EditorTerrainGraphicSet>(
                type, graphicSetID, newDisplayName);
            break;
        }
        case GraphicSet::Type::Floor: {
            setGraphicSetDisplayName<EditorFloorGraphicSet>(type, graphicSetID,
                                                          newDisplayName);
            break;
        }
        case GraphicSet::Type::Wall: {
            setGraphicSetDisplayName<EditorWallGraphicSet>(type, graphicSetID,
                                                         newDisplayName);
            break;
        }
        case GraphicSet::Type::Object: {
            setGraphicSetDisplayName<EditorObjectGraphicSet>(type, graphicSetID,
                                                           newDisplayName);
            break;
        }
        default: {
            LOG_FATAL("Invalid graphic set type.");
            break;
        }
    }
}

void GraphicSetModel::setGraphicSetSlot(GraphicSet::Type type, Uint16 graphicSetID,
                                      std::size_t index, GraphicID newGraphicID)
{
    switch (type) {
        case GraphicSet::Type::Terrain: {
            setGraphicSetSlot<EditorTerrainGraphicSet>(type, graphicSetID,
                                                       index, newGraphicID);
            break;
        }
        case GraphicSet::Type::Floor: {
            setGraphicSetSlot<EditorFloorGraphicSet>(type, graphicSetID, index,
                                                   newGraphicID);
            break;
        }
        case GraphicSet::Type::Wall: {
            setGraphicSetSlot<EditorWallGraphicSet>(type, graphicSetID, index,
                                                  newGraphicID);
            break;
        }
        case GraphicSet::Type::Object: {
            setGraphicSetSlot<EditorObjectGraphicSet>(type, graphicSetID, index,
                                                    newGraphicID);
            break;
        }
        default: {
            LOG_FATAL("Invalid graphic set type.");
            break;
        }
    }
}

void GraphicSetModel::resetModelState()
{
    terrainMap.clear();
    floorMap.clear();
    wallMap.clear();
    objectMap.clear();
    terrainIDPool.freeAllIDs();
    floorIDPool.freeAllIDs();
    wallIDPool.freeAllIDs();
    objectIDPool.freeAllIDs();
}

void GraphicSetModel::removeGraphicIDFromSets(GraphicID graphicID)
{
    // Given one of the graphic set maps, this will replace all instances of
    // graphicID with NULL_GRAPHIC_ID and emit a graphicSetGraphicIDChanged.
    auto replaceIDInSets = [this]<typename T>(std::map<Uint16, T>& graphicSetMap,
                                              GraphicSet::Type type,
                                              GraphicID graphicID) {
        // For each graphic set in the map.
        for (auto& pair : graphicSetMap) {
            T& graphicSet{pair.second};

            // For each slot in the set.
            for (std::size_t i = 0; i < graphicSet.graphicIDs.size(); ++i) {
                // If the ID matches oldGraphicID, replace it and signal.
                GraphicID& slotGraphicID{graphicSet.graphicIDs[i]};
                if (slotGraphicID == graphicID) {
                    slotGraphicID = NULL_GRAPHIC_ID;
                    graphicSetSlotChangedSig.publish(type, graphicSet.numericID,
                                                     static_cast<Uint16>(i),
                                                     NULL_GRAPHIC_ID);
                }
            }
        }
    };

    replaceIDInSets(terrainMap, GraphicSet::Type::Terrain, graphicID);
    replaceIDInSets(floorMap, GraphicSet::Type::Floor, graphicID);
    replaceIDInSets(wallMap, GraphicSet::Type::Wall, graphicID);
    replaceIDInSets(objectMap, GraphicSet::Type::Object, graphicID);
}

const std::string& GraphicSetModel::getErrorString()
{
    return errorString;
}

bool GraphicSetModel::parseTerrainGraphicSet(
    const nlohmann::json& graphicSetJson)
{
    TerrainGraphicSetID numericID{
        static_cast<TerrainGraphicSetID>(terrainIDPool.reserveID())};
    std::string displayName{graphicSetJson.at("displayName").get<std::string>()};

    // Add the graphic set's graphics.
    const nlohmann::json& graphicIDJson{graphicSetJson.at("graphicIDs")};
    std::array<GraphicID, Terrain::Height::Count> graphicIDs{};
    for (std::size_t i = 0; i < graphicIDs.size(); ++i) {
        graphicIDs[i] = graphicIDJson[i].get<GraphicID>();
        if (!graphicSetNameIsUnique<EditorTerrainGraphicSet>(
                numericID, displayName)) {
            errorString = "Terrain display name isn't unique: ";
            errorString += displayName.c_str();
            return false;
        }
    }

    // Save the graphic set in the appropriate map.
    terrainMap.emplace(
        numericID, EditorTerrainGraphicSet{numericID, displayName, graphicIDs});

    // Signal the new graphic set to the UI.
    EditorTerrainGraphicSet& graphicSet{terrainMap[numericID]};
    terrainAddedSig.publish(numericID, graphicSet);

    return true;
}

bool GraphicSetModel::parseFloorGraphicSet(const nlohmann::json& graphicSetJson)
{
    FloorGraphicSetID numericID{
        static_cast<FloorGraphicSetID>(floorIDPool.reserveID())};
    std::string displayName{graphicSetJson.at("displayName").get<std::string>()};

    // Add the graphic set's graphics.
    const nlohmann::json& graphicIDJson{graphicSetJson.at("graphicIDs")};
    std::array<GraphicID, Rotation::Direction::Count> graphicIDs{};
    for (std::size_t i = 0; i < graphicIDs.size(); ++i) {
        graphicIDs[i] = graphicIDJson[i].get<GraphicID>();
        if (!graphicSetNameIsUnique<EditorFloorGraphicSet>(numericID,
                                                           displayName)) {
            errorString = "Floor display name isn't unique: ";
            errorString += displayName.c_str();
            return false;
        }
    }

    // Save the graphic set in the appropriate map.
    floorMap.emplace(numericID,
                     EditorFloorGraphicSet{numericID, displayName, graphicIDs});

    // Signal the new graphic set to the UI.
    EditorFloorGraphicSet& graphicSet{floorMap[numericID]};
    floorAddedSig.publish(numericID, graphicSet);

    return true;
}

bool GraphicSetModel::parseWallGraphicSet(const nlohmann::json& graphicSetJson)
{
    WallGraphicSetID numericID{
        static_cast<WallGraphicSetID>(wallIDPool.reserveID())};
    std::string displayName{graphicSetJson.at("displayName").get<std::string>()};

    // Add the graphic set's graphics.
    const nlohmann::json& graphicIDJson{graphicSetJson.at("graphicIDs")};
    std::array<GraphicID, Wall::Type::Count> graphicIDs{};
    for (std::size_t i = 0; i < graphicIDs.size(); ++i) {
        graphicIDs[i] = graphicIDJson[i].get<GraphicID>();
        if (!graphicSetNameIsUnique<EditorWallGraphicSet>(numericID,
                                                          displayName)) {
            errorString = "Wall display name isn't unique: ";
            errorString += displayName.c_str();
            return false;
        }
    }

    // Save the graphic set in the appropriate map.
    wallMap.emplace(numericID,
                    EditorWallGraphicSet{numericID, displayName, graphicIDs});

    // Signal the new graphic set to the UI.
    EditorWallGraphicSet& graphicSet{wallMap[numericID]};
    wallAddedSig.publish(numericID, graphicSet);

    return true;
}

bool GraphicSetModel::parseObjectGraphicSet(const nlohmann::json& graphicSetJson)
{
    ObjectGraphicSetID numericID{
        static_cast<ObjectGraphicSetID>(objectIDPool.reserveID())};
    std::string displayName{graphicSetJson.at("displayName").get<std::string>()};

    // Add the graphic set's graphics.
    const nlohmann::json& graphicIDJson{graphicSetJson.at("graphicIDs")};
    std::array<GraphicID, Rotation::Direction::Count> graphicIDs{};
    for (std::size_t i = 0; i < graphicIDs.size(); ++i) {
        graphicIDs[i] = graphicIDJson[i].get<GraphicID>();
        if (!graphicSetNameIsUnique<EditorObjectGraphicSet>(numericID,
                                                            displayName)) {
            errorString = "Object display name isn't unique: ";
            errorString += displayName.c_str();
            return false;
        }
    }

    // Save the graphic set in the appropriate map.
    objectMap.emplace(numericID,
                      EditorObjectGraphicSet{numericID, displayName, graphicIDs});

    // Signal the new graphic set to the UI.
    EditorObjectGraphicSet& graphicSet{objectMap[numericID]};
    objectAddedSig.publish(numericID, graphicSet);

    return true;
}

template<typename T>
std::map<Uint16, T>& GraphicSetModel::getMapForGraphicSetType()
{
    std::map<Uint16, T>* map{nullptr};
    if constexpr (std::same_as<T, EditorTerrainGraphicSet>) {
        return terrainMap;
    }
    else if constexpr (std::same_as<T, EditorFloorGraphicSet>) {
        return floorMap;
    }
    else if constexpr (std::same_as<T, EditorWallGraphicSet>) {
        return wallMap;
    }
    else if constexpr (std::same_as<T, EditorObjectGraphicSet>) {
        return objectMap;
    }
    else {
        LOG_FATAL("Invalid graphic set type.");
        return floorMap;
    }
}

template<typename T>
bool GraphicSetModel::graphicSetNameIsUnique(Uint16 graphicSetID,
                                           const std::string& displayName)
{
    auto& graphicSetMap{getMapForGraphicSetType<T>()};

    // Dumbly look through all names for a match.
    // TODO: Eventually, this should change to a name map that we keep updated.
    bool isUnique{true};
    for (const auto& graphicSetPair : graphicSetMap) {
        int idToCheck{graphicSetPair.first};
        const T& graphicSet{graphicSetPair.second};

        if ((idToCheck != graphicSetID)
            && (displayName == graphicSet.displayName)) {
            isUnique = false;
        }
    }

    return isUnique;
}

template<typename T>
void GraphicSetModel::setGraphicSetDisplayName(GraphicSet::Type type,
                                             Uint16 graphicSetID,
                                             const std::string& newDisplayName)
{
    auto& graphicSetMap{getMapForGraphicSetType<T>()};

    auto graphicSetPair{graphicSetMap.find(graphicSetID)};
    if (graphicSetPair == graphicSetMap.end()) {
        LOG_FATAL("Tried to set name using invalid graphic set ID.");
    }

    // Set the new display name and make it unique.
    // Note: All characters that a user can enter are valid in the display
    //       name string, so we don't need to validate.
    int appendedNum{0};
    std::string uniqueDisplayName{newDisplayName};
    while (!graphicSetNameIsUnique<T>(graphicSetID, uniqueDisplayName)) {
        uniqueDisplayName = newDisplayName + std::to_string(appendedNum);
        appendedNum++;
    }

    T& graphicSet{graphicSetPair->second};
    graphicSet.displayName = uniqueDisplayName;

    // Signal the change.
    graphicSetDisplayNameChangedSig.publish(type, graphicSetID,
                                           graphicSet.displayName);
}

template<typename T>
void GraphicSetModel::setGraphicSetSlot(GraphicSet::Type type, Uint16 graphicSetID,
                                      std::size_t index, GraphicID newGraphicID)
{
    auto& graphicSetMap{getMapForGraphicSetType<T>()};

    auto graphicSetPair{graphicSetMap.find(graphicSetID)};
    if (graphicSetPair == graphicSetMap.end()) {
        LOG_FATAL("Tried to set slot using invalid graphic set ID.");
    }

    // Check that the specified set can hold the given index.
    T& graphicSet{graphicSetPair->second};
    if (index >= graphicSet.graphicIDs.size()) {
        LOG_FATAL("Tried to set slot using out of bounds index.");
    }

    graphicSet.graphicIDs[index] = newGraphicID;

    // Signal the change.
    graphicSetSlotChangedSig.publish(type, graphicSetID, index, newGraphicID);
}

void GraphicSetModel::saveTerrain(nlohmann::json& json)
{
    json["terrain"] = nlohmann::json::array();

    // Fill the json with each terrain graphic set in the model.
    int i{0};
    for (auto& graphicSetPair : terrainMap) {
        EditorTerrainGraphicSet& graphicSet{graphicSetPair.second};
        json["terrain"][i]["displayName"] = graphicSet.displayName;
        json["terrain"][i]["numericID"] = graphicSet.numericID;
        for (std::size_t j = 0; j < graphicSet.graphicIDs.size(); ++j) {
            json["terrain"][i]["graphicIDs"][j] = graphicSet.graphicIDs[j];
        }

        i++;
    }
}

void GraphicSetModel::saveFloors(nlohmann::json& json)
{
    json["floors"] = nlohmann::json::array();

    // Fill the json with each floor graphic set in the model.
    int i{0};
    for (auto& graphicSetPair : floorMap) {
        EditorFloorGraphicSet& graphicSet{graphicSetPair.second};
        json["floors"][i]["displayName"] = graphicSet.displayName;
        json["floors"][i]["numericID"] = graphicSet.numericID;
        for (std::size_t j = 0; j < graphicSet.graphicIDs.size(); ++j) {
            json["floors"][i]["graphicIDs"][j] = graphicSet.graphicIDs[j];
        }

        i++;
    }
}

void GraphicSetModel::saveWalls(nlohmann::json& json)
{
    json["walls"] = nlohmann::json::array();

    // Fill the json with each wall graphic set in the model.
    int i{0};
    for (auto& graphicSetPair : wallMap) {
        EditorWallGraphicSet& graphicSet{graphicSetPair.second};
        json["walls"][i]["displayName"] = graphicSet.displayName;
        json["walls"][i]["numericID"] = graphicSet.numericID;
        for (std::size_t j = 0; j < graphicSet.graphicIDs.size(); ++j) {
            json["walls"][i]["graphicIDs"][j] = graphicSet.graphicIDs[j];
        }

        i++;
    }
}

void GraphicSetModel::saveObjects(nlohmann::json& json)
{
    json["objects"] = nlohmann::json::array();

    // Fill the json with each object graphic set in the model.
    int i{0};
    for (auto& graphicSetPair : objectMap) {
        EditorObjectGraphicSet& graphicSet{graphicSetPair.second};
        json["objects"][i]["displayName"] = graphicSet.displayName;
        json["objects"][i]["numericID"] = graphicSet.numericID;
        for (std::size_t j = 0; j < graphicSet.graphicIDs.size(); ++j) {
            json["objects"][i]["graphicIDs"][j] = graphicSet.graphicIDs[j];
        }

        i++;
    }
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/Private/IconModel.cpp`:

```cpp
#include "IconModel.h"
#include "DataModel.h"
#include "StringTools.h"
#include "nlohmann/json.hpp"
#include <SDL_render.h>
#include <SDL_image.h>
#include "Log.h"

namespace AM
{
namespace ResourceImporter
{

IconModel::IconModel(DataModel& inDataModel, SDL_Renderer* inSdlRenderer)
: dataModel{inDataModel}
, sdlRenderer{inSdlRenderer}
, iconSheetMap{}
, iconMap{}
, sheetIDPool{IDPool::ReservationStrategy::ReuseLowest, 32}
, iconIDPool{IDPool::ReservationStrategy::ReuseLowest, 32}
, errorString{}
, sheetAddedSig{}
, sheetRemovedSig{}
, iconRemovedSig{}
, iconDisplayNameChangedSig{}
, sheetAdded{sheetAddedSig}
, sheetRemoved{sheetRemovedSig}
, iconRemoved{iconRemovedSig}
, iconDisplayNameChanged{iconDisplayNameChangedSig}
{
    // Reserve the null icon's ID (the engine provides it in code, so we don't
    // need it in the json).
    iconIDPool.reserveID();
}

bool IconModel::load(const nlohmann::json& json)
{
    try {
        // Iterate every icon sheet and add all their icons.
        for (auto& sheetJson : json.at("iconSheets").items()) {
            if (!parseIconSheet(sheetJson.value())) {
                return false;
            }
        }
    } catch (nlohmann::json::exception& e) {
        resetModelState();
        errorString = "Parse failure - ";
        errorString += e.what();
        return false;
    }

    return true;
}

void IconModel::save(nlohmann::json& json)
{
    json["iconSheets"] = nlohmann::json::array();

    /* Fill the json with our current model data. */
    // For each icon sheet.
    int i{0};
    for (auto& sheetPair : iconSheetMap) {
        // Add this sheet's relative path.
        EditorIconSheet& iconSheet{sheetPair.second};
        json["iconSheets"][i]["relPath"] = iconSheet.relPath;

        // For each icon in this sheet.
        for (std::size_t j = 0; j < iconSheet.iconIDs.size(); ++j) {
            // Add the display name.
            EditorIcon& icon{iconMap[iconSheet.iconIDs[j]]};
            json["iconSheets"][i]["icons"][j]["displayName"] = icon.displayName;

            // Derive the string ID from the display name and add it.
            std::string stringID{};
            StringTools::deriveStringID(icon.displayName, stringID);
            json["iconSheets"][i]["icons"][j]["stringID"] = stringID;

            // Add the numeric ID.
            json["iconSheets"][i]["icons"][j]["numericID"] = icon.numericID;

            // Add the icon sheet texture extent.
            json["iconSheets"][i]["icons"][j]["textureExtent"]["x"]
                = icon.textureExtent.x;
            json["iconSheets"][i]["icons"][j]["textureExtent"]["y"]
                = icon.textureExtent.y;
            json["iconSheets"][i]["icons"][j]["textureExtent"]["w"]
                = icon.textureExtent.w;
            json["iconSheets"][i]["icons"][j]["textureExtent"]["h"]
                = icon.textureExtent.h;
        }

        i++;
    }
}

bool IconModel::addIconSheet(const std::string& relPath,
                             const std::string& iconWidth,
                             const std::string& iconHeight,
                             const std::string& baseName)
{
    /* Validate the data. */
    // Check if we already have the given sheet.
    for (const auto& sheetPair : iconSheetMap) {
        if (sheetPair.second.relPath == relPath) {
            errorString = "Error: Path conflicts with existing icon sheet.";
            return false;
        }
    }

    // Prepend the texture directory to the given relative path.
    std::string fullPath{dataModel.getWorkingTexturesDir()};
    fullPath += relPath;

    // Validate that the file at the given path is a valid texture.
    int sheetWidth{0};
    int sheetHeight{0};
    SDL_Texture* sheetTexture{IMG_LoadTexture(sdlRenderer, fullPath.c_str())};
    if (sheetTexture != nullptr) {
        // Save the texture size for later.
        SDL_QueryTexture(sheetTexture, nullptr, nullptr, &sheetWidth,
                         &sheetHeight);

        // We don't need the actual texture right now, destroy it.
        SDL_DestroyTexture(sheetTexture);
    }
    else {
        errorString = "Error: File at given path is not a valid image. Path: ";
        errorString += dataModel.getWorkingTexturesDir();
        errorString += relPath;
        return false;
    }

    // Validate the width/height/yOffset.
    int iconWidthI{0};
    int iconHeightI{0};
    try {
        iconWidthI = std::stoi(iconWidth);
        iconHeightI = std::stoi(iconHeight);
    } catch (std::exception&) {
        errorString = "Error: Width or height is not a valid integer.";
        return false;
    }

    // Validate the size of the texture.
    if ((iconWidthI > sheetWidth) || (iconHeightI > sheetHeight)) {
        errorString = "Error: Sheet must be larger than icon size.";
        return false;
    }

    /* Add the icon sheet and icons. */
    int sheetID{static_cast<int>(sheetIDPool.reserveID())};
    iconSheetMap.emplace(sheetID, EditorIconSheet{relPath, {}});

    // For each icon in this texture.
    EditorIconSheet& iconSheet{iconSheetMap[sheetID]};
    int iconCount{0};
    for (int y = 0; y <= (sheetHeight - iconHeightI); y += iconHeightI) {
        for (int x = 0; x <= (sheetWidth - iconWidthI); x += iconWidthI) {
            // Build the icon's display name (baseName_count).
            std::string displayName{baseName};
            displayName += std::to_string(iconCount);

            // Find the icon's extent within the sheet texture.
            SDL_Rect textureExtent{x, y, iconWidthI, iconHeightI};

            // Add the icon to the map and sheet.
            IconID iconID{static_cast<IconID>(iconIDPool.reserveID())};
            iconMap.emplace(iconID, EditorIcon{iconID, iconSheet.relPath,
                                               displayName, textureExtent});
            iconSheet.iconIDs.push_back(iconID);

            // Increment the count (used for the display name).
            iconCount++;
        }
    }

    // Signal the new sheet to the UI.
    sheetAddedSig.publish(sheetID, iconSheet);

    return true;
}

void IconModel::remIconSheet(int sheetID)
{
    // Find the sheet in the map.
    auto sheetIt{iconSheetMap.find(sheetID)};
    if (sheetIt == iconSheetMap.end()) {
        LOG_FATAL("Invalid ID while removing icon sheet.");
    }

    // Erase all of the sheet's icons.
    for (IconID iconID : sheetIt->second.iconIDs) {
        remIcon(iconID);
    }

    // Free the sheet's ID.
    sheetIDPool.freeID(sheetID);

    // Erase the sheet.
    iconSheetMap.erase(sheetIt);

    // Signal that the sheet was erased.
    sheetRemovedSig.publish(sheetID);
}

void IconModel::remIcon(IconID iconID)
{
    // Find the icon in the map.
    auto iconIt{iconMap.find(iconID)};
    if (iconIt == iconMap.end()) {
        LOG_FATAL("Invalid ID while removing icon.");
    }

    // Free the icon's ID.
    iconIDPool.freeID(iconID);

    // Erase the icon.
    iconMap.erase(iconIt);

    // Signal that the icon was erased.
    iconRemovedSig.publish(iconID);
}

const EditorIcon& IconModel::getIcon(IconID iconID)
{
    auto iconIt{iconMap.find(iconID)};
    if (iconIt == iconMap.end()) {
        LOG_FATAL("Tried to get icon with invalid ID: %d", iconID);
    }

    return iconIt->second;
}

void IconModel::setIconDisplayName(IconID iconID,
                                   const std::string& newDisplayName)
{
    auto iconPair{iconMap.find(iconID)};
    if (iconPair == iconMap.end()) {
        LOG_FATAL("Tried to set name using invalid icon ID.");
    }

    // Set the new display name and make it unique.
    // Note: All characters that a user can enter are valid in the display
    //       name string, so we don't need to validate.
    int appendedNum{0};
    std::string uniqueDisplayName{newDisplayName};
    while (!iconNameIsUnique(iconID, uniqueDisplayName)) {
        uniqueDisplayName = newDisplayName + std::to_string(appendedNum);
        appendedNum++;
    }

    EditorIcon& icon{iconPair->second};
    icon.displayName = uniqueDisplayName;

    // Signal the change.
    iconDisplayNameChangedSig.publish(iconID, icon.displayName);
}

void IconModel::resetModelState()
{
    iconSheetMap.clear();
    iconMap.clear();
    sheetIDPool.freeAllIDs();
    iconIDPool.freeAllIDs();
}

const std::string& IconModel::getErrorString()
{
    return errorString;
}

bool IconModel::parseIconSheet(const nlohmann::json& sheetJson)
{
    int sheetID{static_cast<int>(sheetIDPool.reserveID())};
    iconSheetMap.emplace(sheetID, EditorIconSheet{});
    EditorIconSheet& iconSheet{iconSheetMap[sheetID]};

    // Add this sheet's relative path.
    iconSheet.relPath = sheetJson.at("relPath").get<std::string>();
    if (!(dataModel.validateRelPath(iconSheet.relPath))) {
        errorString = "Failed to find icon sheet at path: ";
        errorString += iconSheet.relPath;
        return false;
    }

    // For every icon in the sheet.
    for (auto& iconJson : sheetJson.at("icons").items()) {
        if (!parseIcon(iconJson.value(), iconSheet)) {
            return false;
        }
    }

    // Signal the new sheet to the UI.
    sheetAddedSig.publish(sheetID, iconSheet);

    return true;
}

bool IconModel::parseIcon(const nlohmann::json& iconJson,
                          EditorIconSheet& iconSheet)
{
    // Mark the icon's ID as reserved so it doesn't get reused.
    IconID iconID{iconJson.at("numericID").get<IconID>()};
    iconIDPool.markIDAsReserved(iconID);

    iconMap.emplace(iconID, EditorIcon{iconID, iconSheet.relPath});
    iconSheet.iconIDs.push_back(iconID);
    EditorIcon& icon{iconMap[iconID]};

    // If the display name isn't unique, fail.
    std::string displayName{iconJson.at("displayName").get<std::string>()};
    if (!iconNameIsUnique(iconID, displayName)) {
        errorString = "Icon display name isn't unique: ";
        errorString += icon.displayName.c_str();
        return false;
    }

    // Add the display name.
    icon.displayName = displayName;

    // Add this icon's extent within the icon sheet.
    icon.textureExtent.x = iconJson.at("textureExtent").at("x");
    icon.textureExtent.y = iconJson.at("textureExtent").at("y");
    icon.textureExtent.w = iconJson.at("textureExtent").at("w");
    icon.textureExtent.h = iconJson.at("textureExtent").at("h");

    return true;
}

bool IconModel::iconNameIsUnique(IconID iconID, const std::string& displayName)
{
    // Dumbly look through all names for a match.
    // Note: Eventually, this should change to a name map that we keep updated.
    bool isUnique{true};
    for (const auto& iconPair : iconMap) {
        IconID idToCheck{iconPair.first};
        const EditorIcon& icon{iconPair.second};

        if ((idToCheck != iconID) && (displayName == icon.displayName)) {
            isUnique = false;
        }
    }

    return isUnique;
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/Private/SpriteModel.cpp`:

```cpp
#include "SpriteModel.h"
#include "DataModel.h"
#include "GraphicSetModel.h"
#include "EntityGraphicSetModel.h"
#include "SpriteID.h"
#include "StringTools.h"
#include "SpriteTools.h"
#include "SDLHelpers.h"
#include "Log.h"
#include "nlohmann/json.hpp"
#include <SDL_render.h>
#include <SDL_image.h>
#include <filesystem>

namespace AM
{
namespace ResourceImporter
{
SpriteModel::SpriteModel(DataModel& inDataModel, SDL_Renderer* inSdlRenderer)
: dataModel{inDataModel}
, sdlRenderer{inSdlRenderer}
, spriteSheetMap{}
, spriteMap{}
, sheetIDPool{IDPool::ReservationStrategy::ReuseLowest, 32}
, spriteIDPool{IDPool::ReservationStrategy::ReuseLowest, 32}
, errorString{}
, sheetAddedSig{}
, sheetRemovedSig{}
, spriteRemovedSig{}
, spriteSheetDisplayNameChangedSig{}
, spriteDisplayNameChangedSig{}
, spriteModelBoundsIDChangedSig{}
, spriteCustomModelBoundsChangedSig{}
, spriteCollisionEnabledChangedSig{}
, spriteStageOriginChangedSig{}
, spritePremultiplyAlphaChangedSig{}
, sheetAdded{sheetAddedSig}
, sheetRemoved{sheetRemovedSig}
, spriteAdded{spriteAddedSig}
, spriteRemoved{spriteRemovedSig}
, spriteSheetDisplayNameChanged{spriteSheetDisplayNameChangedSig}
, spriteDisplayNameChanged{spriteDisplayNameChangedSig}
, spriteModelBoundsIDChanged{spriteModelBoundsIDChangedSig}
, spriteCustomModelBoundsChanged{spriteCustomModelBoundsChangedSig}
, spriteCollisionEnabledChanged{spriteCollisionEnabledChangedSig}
, spriteStageOriginChanged{spriteStageOriginChangedSig}
, spritePremultiplyAlphaChanged{spritePremultiplyAlphaChangedSig}
{
    // Reserve the null sprite and sheet's ID (the engine provides it in code, 
    // so we don't need it in the json).
    spriteIDPool.reserveID();
    sheetIDPool.reserveID();

    // Check that ARGB8888 is supported (it should always be, but just to be 
    // safe).
    // Note: We standardize on ARGB8888 for our texture generation, so it 
    //       doesn't vary based on the host platform.
    SDL_RendererInfo info{};
    SDL_GetRendererInfo(sdlRenderer, &info);
    bool argb8888Found{false};
    for (auto pixelFormat : info.texture_formats) {
        if (pixelFormat == SDL_PIXELFORMAT_ARGB8888) {
            argb8888Found = true;
        }
    }
    if (!argb8888Found) {
        LOG_FATAL("Platform must support ARGB8888 pixel format.");
    }
}

bool SpriteModel::load(const nlohmann::json& json)
{
    try {
        // Iterate every sprite sheet and add all their sprites.
        for (auto& sheetJson : json.at("spriteSheets").items()) {
            if (!parseSpriteSheet(sheetJson.value())) {
                return false;
            }
        }
    } catch (nlohmann::json::exception& e) {
        resetModelState();
        errorString = "Parse failure - ";
        errorString += e.what();
        return false;
    }

    return true;
}

void SpriteModel::save(nlohmann::json& json)
{
    json["spriteSheets"] = nlohmann::json::array();

    /* Fill the json with our current model data. */
    // For each sprite sheet.
    int i{0};
    for (auto& sheetPair : spriteSheetMap) {
        // Add this sheet's display name.
        EditorSpriteSheet& spriteSheet{sheetPair.second};
        json["spriteSheets"][i]["displayName"] = spriteSheet.displayName;
        json["spriteSheets"][i]["textureWidth"] = spriteSheet.textureWidth;
        json["spriteSheets"][i]["textureHeight"] = spriteSheet.textureHeight;

        // For each sprite in this sheet.
        for (std::size_t j = 0; j < spriteSheet.spriteIDs.size(); ++j) {
            // Add the display name.
            EditorSprite& sprite{spriteMap[spriteSheet.spriteIDs[j]]};
            json["spriteSheets"][i]["sprites"][j]["displayName"]
                = sprite.displayName;

            // Add the numeric ID.
            json["spriteSheets"][i]["sprites"][j]["numericID"]
                = sprite.numericID;

            // Add the path to the sprite's individual image file.
            json["spriteSheets"][i]["sprites"][j]["imagePath"]
                = sprite.imagePath;

            // Add the sprite sheet texture extent.
            json["spriteSheets"][i]["sprites"][j]["textureExtent"]["x"]
                = sprite.textureExtent.x;
            json["spriteSheets"][i]["sprites"][j]["textureExtent"]["y"]
                = sprite.textureExtent.y;
            json["spriteSheets"][i]["sprites"][j]["textureExtent"]["w"]
                = sprite.textureExtent.w;
            json["spriteSheets"][i]["sprites"][j]["textureExtent"]["h"]
                = sprite.textureExtent.h;

            // Add the stage origin.
            json["spriteSheets"][i]["sprites"][j]["stageX"]
                = sprite.stageOrigin.x;
            json["spriteSheets"][i]["sprites"][j]["stageY"]
                = sprite.stageOrigin.y;

            // Add collisionEnabled.
            json["spriteSheets"][i]["sprites"][j]["collisionEnabled"]
                = sprite.collisionEnabled;

            // Add modelBoundsID.
            // Note: The engine doesn't use this, but this editor needs it.
            json["spriteSheets"][i]["sprites"][j]["modelBoundsID"]
                = sprite.modelBoundsID;

            // Add the model-space bounds.
            // Note: This will either be a shared bounding box or a custom one 
            //       depending on modelBoundsID. In either case, we always save
            //       to modelBounds because that's what the engine uses. 
            const BoundingBox& spriteModelBounds{
                sprite.getModelBounds(dataModel.boundingBoxModel)}; 
            json["spriteSheets"][i]["sprites"][j]["modelBounds"]["minX"]
                = spriteModelBounds.min.x;
            json["spriteSheets"][i]["sprites"][j]["modelBounds"]["maxX"]
                = spriteModelBounds.max.x;
            json["spriteSheets"][i]["sprites"][j]["modelBounds"]["minY"]
                = spriteModelBounds.min.y;
            json["spriteSheets"][i]["sprites"][j]["modelBounds"]["maxY"]
                = spriteModelBounds.max.y;
            json["spriteSheets"][i]["sprites"][j]["modelBounds"]["minZ"]
                = spriteModelBounds.min.z;
            json["spriteSheets"][i]["sprites"][j]["modelBounds"]["maxZ"]
                = spriteModelBounds.max.z;

            // Add premultiplyAlpha.
            json["spriteSheets"][i]["sprites"][j]["premultiplyAlpha"]
                = sprite.premultiplyAlpha;
        }

        i++;
    }
}

void SpriteModel::exportSpriteSheetImages()
{
    // Delete all of the existing files in the SpriteSheets directory.
    std::string spriteSheetsPath{dataModel.getWorkingTexturesDir()
                                 + "SpriteSheets"};
    for (const std::filesystem::directory_entry& entry :
         std::filesystem::directory_iterator(spriteSheetsPath)) {
        std::filesystem::remove_all(entry.path());
    }

    // Generate a texture for each sprite sheet and save it to a png file.
    for (auto& [spriteSheetID, spriteSheet] : spriteSheetMap) {
        SDL_Texture* spriteSheetTexture{
            SpriteTools::generateSpriteSheetTexture(dataModel, spriteSheet)};

        std::string filePath{spriteSheetsPath};
        filePath += "/" + spriteSheet.displayName + ".png";
        if (!(SDLHelpers::savePng(filePath, sdlRenderer, spriteSheetTexture))) {
            LOG_INFO("Failed to generate image for sprite sheet: %s",
                     spriteSheet.displayName.c_str());
        }
    }
}

bool SpriteModel::addSpriteSheet()
{
    SpriteSheetID numericID{
        static_cast<SpriteSheetID>(sheetIDPool.reserveID())};

    // Generate a unique name.
    int nameCount{0};
    std::string displayName{"NewSpriteSheet"};
    while (!spriteSheetNameIsUnique(numericID, displayName)) {
        displayName = "NewSpriteSheet" + std::to_string(nameCount);
        nameCount++;
    }

    // Add the new sprite sheet to the maps.
    spriteSheetMap.emplace(numericID,
                           EditorSpriteSheet{numericID, displayName});
    spriteSheetNameMap.emplace(displayName, numericID);

    // Signal the new sheet to the UI.
    EditorSpriteSheet& spriteSheet{spriteSheetMap.at(numericID)};
    sheetAddedSig.publish(numericID, spriteSheet);

    // Set the new sheet as the active library item.
    dataModel.setActiveSpriteSheet(numericID);

    return true;
}

void SpriteModel::remSpriteSheet(SpriteSheetID sheetID)
{
    // Find the sheet in the map.
    auto sheetIt{spriteSheetMap.find(sheetID)};
    if (sheetIt == spriteSheetMap.end()) {
        LOG_FATAL("Invalid ID while removing sprite sheet.");
    }

    // Erase all of the sheet's sprites.
    // Note: We need to make a copy of the IDs vector, since the original 
    //       will be modified as we iterate.
    std::vector<SpriteID> spriteIDs{sheetIt->second.spriteIDs};
    for (SpriteID spriteID : spriteIDs) {
        remSprite(spriteID);
    }

    // Free the sheet's ID.
    sheetIDPool.freeID(sheetID);

    // Erase the sheet.
    spriteSheetNameMap.erase(sheetIt->second.displayName);
    spriteSheetMap.erase(sheetIt);

    // Signal that the sheet was erased.
    sheetRemovedSig.publish(sheetID);
}

bool SpriteModel::addSprite(const std::string& imageRelPath,
                            SpriteSheetID parentSheetID,
                            const std::string& stageOriginX,
                            const std::string& stageOriginY,
                            bool premultiplyAlpha)
{
    // Get the file name from the image path (we use the file name as the 
    // sprite's display name).
    std::string displayName{StringTools::getFileNameNoExtension(imageRelPath)};

    // If the given name isn't unique, fail.
    if (!spriteNameIsUnique(NULL_SPRITE_ID, displayName)) {
        errorString = "Name is already in use.";
        return false;
    }

    // Get the sprite texture's size.
    std::string fullImagePath{dataModel.getWorkingIndividualSpritesDir()};
    fullImagePath += imageRelPath;
    SDL_Texture* texture{IMG_LoadTexture(sdlRenderer, fullImagePath.c_str())};
    if (!texture) {
        errorString = "Failed to load texture: ";
        errorString += fullImagePath.c_str();
        return false;
    }
    SDL_Rect textureExtent{};
    SDL_QueryTexture(texture, nullptr, nullptr,
                     &(textureExtent.w), &(textureExtent.h));
    SDL_DestroyTexture(texture);

    // Validate the stage origin.
    SDL_Point stageOrigin{};
    try {
        stageOrigin.x = std::stoi(stageOriginX);
        stageOrigin.y = std::stoi(stageOriginY);
    } catch (std::exception&) {
        errorString = "Stage origin X or Y is not a valid integer.";
        return false;
    }

    // If the sprite is going to be added to an existing animation, validate 
    // the texture size (all sprites in an animation must be the same size).
    if (getFrameNumber(displayName) != -1) {
        AnimationModel& animationModel{dataModel.animationModel};
        std::string_view animationName{deriveAnimationName(displayName)};
        if (const EditorAnimation
            * animation{animationModel.getAnimation(animationName)}) {
            // Sprite is going to be added to this animation. Validate size.
            for (const auto& frame : animation->frames) {
                const SDL_Rect& animTextureExtent{
                    frame.sprite.get().textureExtent};
                if ((textureExtent.w != animTextureExtent.w)
                    || (textureExtent.h != animTextureExtent.h)) {
                    errorString
                        = "All sprites in an animation must be the same size.";
                    return false;
                }
            }
        }
    }

    // Add the new sprite to the maps.
    SpriteID numericID{static_cast<SpriteID>(spriteIDPool.reserveID())};
    spriteMap.emplace(numericID,
                      EditorSprite{.numericID = numericID,
                                   .imagePath = imageRelPath,
                                   .displayName = displayName,
                                   .textureExtent = textureExtent,
                                   .stageOrigin = stageOrigin,
                                   .premultiplyAlpha = premultiplyAlpha});
    spriteNameMap.emplace(displayName, numericID);

    // Default to a non-0 bounding box so it's easier to click.
    EditorSprite& sprite{spriteMap.at(numericID)};
    static constexpr BoundingBox defaultBox{{0, 0, 0}, {20, 20, 20}};
    sprite.customModelBounds = defaultBox;

    // Add the sprite to its parent sheet.
    EditorSpriteSheet& parentSheet{mgetSpriteSheet(parentSheetID)};
    parentSheet.spriteIDs.push_back(numericID);

    // Refresh the sheet to account for the new sprite.
    refreshSpriteSheet(parentSheet);

    // Signal the new sprite to the UI.
    spriteAddedSig.publish(numericID, sprite, parentSheetID);

    // Add the sprite to an animation if necessary.
    addSpriteToAnimationIfNecessary(sprite);

    return true;
}

void SpriteModel::remSprite(SpriteID spriteID)
{
    // Find the sprite in the map.
    auto spriteIt{spriteMap.find(spriteID)};
    if (spriteIt == spriteMap.end()) {
        LOG_FATAL("Invalid ID while removing sprite.");
    }

    // Find the sheet that contains this sprite and remove it.
    EditorSpriteSheet* parentSpriteSheet{nullptr};
    for (auto& [spriteSheetID, spriteSheet] : spriteSheetMap) {
        std::vector<SpriteID>& spriteIDs{spriteSheet.spriteIDs};
        for (auto it{spriteIDs.begin()}; it != spriteIDs.end(); ++it) {
            if (*it == spriteID) {
                spriteIDs.erase(it);
                parentSpriteSheet = &spriteSheet;
                break;
            }
        }

        // If we found the sprite, stop looking.
        if (parentSpriteSheet) {
            break;
        }
    }
    AM_ASSERT(parentSpriteSheet, "Sprite did not belong to a sprite sheet.");

    // Refresh the sheet to account for the removed sprite.
    refreshSpriteSheet(*parentSpriteSheet);

    // If the sprite is in an animation, remove it.
    remSpriteFromAnimationIfNecessary(spriteIt->second);

    // Clear this sprite from any sets that reference it.
    dataModel.graphicSetModel.removeGraphicIDFromSets(toGraphicID(spriteID));
    dataModel.entityGraphicSetModel.removeGraphicIDFromSets(
        toGraphicID(spriteID));

    // Free the sprite's ID.
    spriteIDPool.freeID(spriteID);

    // Erase the sprite.
    spriteNameMap.erase(spriteIt->second.displayName);
    spriteMap.erase(spriteIt);

    // Signal that the sprite was erased.
    spriteRemovedSig.publish(spriteID, parentSpriteSheet->numericID);
}

const EditorSpriteSheet&
    SpriteModel::getSpriteSheet(SpriteSheetID sheetID) const
{
    auto spriteSheetIt{spriteSheetMap.find(sheetID)};
    if (spriteSheetIt == spriteSheetMap.end()) {
        LOG_FATAL("Tried to get sprite sheet with invalid ID: %d",
                  sheetID);
    }

    return spriteSheetIt->second;
}

const EditorSprite& SpriteModel::getSprite(SpriteID spriteID) const
{
    auto spriteIt{spriteMap.find(spriteID)};
    if (spriteIt == spriteMap.end()) {
        LOG_FATAL("Tried to get sprite with invalid ID: %d", spriteID);
    }

    return spriteIt->second;
}

void SpriteModel::setSpriteSheetDisplayName(SpriteSheetID spriteSheetID,
                                            const std::string& newDisplayName)
{
    auto spriteSheetPair{spriteSheetMap.find(spriteSheetID)};
    if (spriteSheetPair == spriteSheetMap.end()) {
        LOG_FATAL("Tried to set name using invalid sprite sheet ID.");
    }

    // Set the new display name and make it unique.
    // Note: All characters that a user can enter are valid in the display
    //       name string, so we don't need to validate.
    int appendedNum{0};
    std::string uniqueDisplayName{newDisplayName};
    while (!spriteSheetNameIsUnique(spriteSheetID, uniqueDisplayName)) {
        uniqueDisplayName = newDisplayName + std::to_string(appendedNum);
        appendedNum++;
    }

    EditorSpriteSheet& spriteSheet{spriteSheetPair->second};
    spriteSheet.displayName = uniqueDisplayName;

    // Signal the change.
    spriteSheetDisplayNameChangedSig.publish(spriteSheetID,
                                             spriteSheet.displayName);
}

void SpriteModel::setSpriteModelBoundsID(SpriteID spriteID,
                                         BoundingBoxID newModelBoundsID)
{
    auto spritePair{spriteMap.find(spriteID)};
    if (spritePair == spriteMap.end()) {
        LOG_FATAL("Tried to set modelBoundsID using invalid sprite ID.");
    }

    // Set the new ID and signal the change.
    EditorSprite& sprite{spritePair->second};
    sprite.modelBoundsID = newModelBoundsID;

    spriteModelBoundsIDChangedSig.publish(spriteID, newModelBoundsID);
}

void SpriteModel::setSpriteCustomModelBounds(SpriteID spriteID,
                                       const BoundingBox& newModelBounds)
{
    auto spritePair{spriteMap.find(spriteID)};
    if (spritePair == spriteMap.end()) {
        LOG_FATAL("Tried to set customModelBounds using invalid sprite ID.");
    }

    // Set the new model bounds and signal the change.
    EditorSprite& sprite{spritePair->second};
    sprite.customModelBounds = newModelBounds;

    spriteCustomModelBoundsChangedSig.publish(spriteID, newModelBounds);
}

void SpriteModel::setSpriteStageOrigin(SpriteID spriteID,
                                       const SDL_Point& newStageOrigin)
{
    auto spritePair{spriteMap.find(spriteID)};
    if (spritePair == spriteMap.end()) {
        LOG_FATAL("Tried to set stageOrigin using invalid sprite ID.");
    }

    // Set the new stageOrigin and signal the change.
    EditorSprite& sprite{spritePair->second};
    sprite.stageOrigin = newStageOrigin;

    spriteStageOriginChangedSig.publish(spriteID, newStageOrigin);
}

void SpriteModel::setSpriteCollisionEnabled(SpriteID spriteID,
                                            bool newCollisionEnabled)
{
    auto spritePair{spriteMap.find(spriteID)};
    if (spritePair == spriteMap.end()) {
        LOG_FATAL("Tried to set collisionEnabled using invalid sprite ID.");
    }

    // Set the new collisionEnabled and signal the change.
    EditorSprite& sprite{spritePair->second};
    sprite.collisionEnabled = newCollisionEnabled;

    spriteCollisionEnabledChangedSig.publish(spriteID, newCollisionEnabled);
}

void SpriteModel::setSpritePremultiplyAlpha(SpriteID spriteID,
                                            bool newPremultiplyAlpha)
{
    auto spritePair{spriteMap.find(spriteID)};
    if (spritePair == spriteMap.end()) {
        LOG_FATAL("Tried to set premultiplyAlpha using invalid sprite ID.");
    }

    // Set the new premultiplyAlpha and signal the change.
    EditorSprite& sprite{spritePair->second};
    sprite.premultiplyAlpha = newPremultiplyAlpha;

    spritePremultiplyAlphaChangedSig.publish(spriteID, newPremultiplyAlpha);
}

void SpriteModel::resetModelState()
{
    spriteSheetMap.clear();
    spriteMap.clear();
    sheetIDPool.freeAllIDs();
    spriteIDPool.freeAllIDs();
}

const std::string& SpriteModel::getErrorString()
{
    return errorString;
}

EditorSpriteSheet& SpriteModel::mgetSpriteSheet(SpriteSheetID sheetID)
{
    auto spriteSheetIt{spriteSheetMap.find(sheetID)};
    if (spriteSheetIt == spriteSheetMap.end()) {
        LOG_FATAL("Tried to get sprite sheet with invalid ID: %d",
                  sheetID);
    }

    return spriteSheetIt->second;
}

EditorSprite& SpriteModel::mgetSprite(SpriteID spriteID)
{
    auto spriteIt{spriteMap.find(spriteID)};
    if (spriteIt == spriteMap.end()) {
        LOG_FATAL("Tried to get sprite with invalid ID: %d", spriteID);
    }

    return spriteIt->second;
}

bool SpriteModel::parseSpriteSheet(const nlohmann::json& sheetJson)
{
    SpriteSheetID sheetID{static_cast<SpriteSheetID>(sheetIDPool.reserveID())};
    spriteSheetMap.emplace(sheetID, EditorSpriteSheet{sheetID});
    EditorSpriteSheet& spriteSheet{spriteSheetMap[sheetID]};

    // If the display name isn't unique, fail.
    std::string displayName{sheetJson.at("displayName").get<std::string>()};
    if (!spriteSheetNameIsUnique(sheetID, displayName)) {
        errorString = "Sprite sheet display name isn't unique: ";
        errorString += spriteSheet.displayName.c_str();
        return false;
    }
    spriteNameMap.emplace(displayName, sheetID);

    // Add the display name.
    spriteSheet.displayName = displayName;

    // Add the texture size.
    spriteSheet.textureWidth = sheetJson.at("textureWidth");
    spriteSheet.textureHeight = sheetJson.at("textureHeight");

    // Parse every sprite in this sheet.
    for (auto& spriteJson : sheetJson.at("sprites").items()) {
        if (!parseSprite(spriteJson.value(), spriteSheet)) {
            return false;
        }
    }

    // Set the sheet size and each sprite's texture position.
    refreshSpriteSheet(spriteSheet);

    // Signal the new sheet to the UI.
    sheetAddedSig.publish(sheetID, spriteSheet);

    // Signal the new sprites to the UI.
    for (SpriteID spriteID : spriteSheet.spriteIDs) {
        const EditorSprite& sprite{getSprite(spriteID)};
        spriteAddedSig.publish(spriteID, sprite, spriteSheet.numericID);
    }

    return true;
}

bool SpriteModel::parseSprite(const nlohmann::json& spriteJson,
                              EditorSpriteSheet& spriteSheet)
{
    // Mark the sprite's ID as reserved so it doesn't get reused.
    SpriteID spriteID{spriteJson.at("numericID").get<SpriteID>()};
    spriteIDPool.markIDAsReserved(spriteID);

    // Add the sprite to the sprite sheets and the maps.
    spriteMap.emplace(spriteID, EditorSprite{spriteID});
    spriteSheet.spriteIDs.push_back(spriteID);
    EditorSprite& sprite{spriteMap[spriteID]};

    // Add the image path.
    std::string imagePath{spriteJson.at("imagePath").get<std::string>()};
    sprite.imagePath = imagePath;

    // If the display name isn't unique, fail.
    std::string displayName{spriteJson.at("displayName").get<std::string>()};
    if (!spriteNameIsUnique(spriteID, displayName)) {
        errorString = "Sprite display name isn't unique: ";
        errorString += sprite.displayName.c_str();
        return false;
    }
    spriteNameMap.emplace(displayName, spriteID);

    // Add the display name.
    sprite.displayName = displayName;

    // Add this sprite's extent within the sprite sheet.
    sprite.textureExtent.x = spriteJson.at("textureExtent").at("x");
    sprite.textureExtent.y = spriteJson.at("textureExtent").at("y");
    sprite.textureExtent.w = spriteJson.at("textureExtent").at("w");
    sprite.textureExtent.h = spriteJson.at("textureExtent").at("h");

    // Add the stage origin. 
    sprite.stageOrigin.x = spriteJson.at("stageX");
    sprite.stageOrigin.y = spriteJson.at("stageY");
    
    // Add collisionEnabled.
    sprite.collisionEnabled = spriteJson.at("collisionEnabled");

    // Add modelBoundsID.
    sprite.modelBoundsID = spriteJson.at("modelBoundsID");

    // Default our custom bounds to the saved modelBounds, regardless of 
    // whether we use a shared bounding box or not.
    sprite.customModelBounds.min.x = spriteJson.at("modelBounds").at("minX");
    sprite.customModelBounds.max.x = spriteJson.at("modelBounds").at("maxX");
    sprite.customModelBounds.min.y = spriteJson.at("modelBounds").at("minY");
    sprite.customModelBounds.max.y = spriteJson.at("modelBounds").at("maxY");
    sprite.customModelBounds.min.z = spriteJson.at("modelBounds").at("minZ");
    sprite.customModelBounds.max.z = spriteJson.at("modelBounds").at("maxZ");

    // Add premultiplyAlpha.
    sprite.premultiplyAlpha = spriteJson.at("premultiplyAlpha");

    // Note: We signal from parseSpriteSheet() instead of here, so that the 
    //       sheet can be signalled first.

    return true;
}

bool SpriteModel::spriteSheetNameIsUnique(SpriteSheetID spriteSheetID,
                                          const std::string& displayName)
{
    // If the desired name is already in the map, and the owner of the name 
    // isn't the given ID, the name isn't unique.
    auto it{spriteSheetNameMap.find(displayName)};
    if ((it != spriteSheetNameMap.end()) && (it->second != spriteSheetID)) {
        return false;
    }

    // Name isn't in the map, or it's owned by the same ID.
    return true;
}

bool SpriteModel::spriteNameIsUnique(SpriteID spriteID,
                                     const std::string& displayName)
{
    // If the desired name is already in the map, and the owner of the name 
    // isn't the given ID, the name isn't unique.
    auto it{spriteNameMap.find(displayName)};
    if ((it != spriteNameMap.end()) && (it->second != spriteID)) {
        return false;
    }

    // Name isn't in the map, or it's owned by the same ID.
    return true;
}

void SpriteModel::refreshSpriteSheet(EditorSpriteSheet& spriteSheet)
{
    // Algorithm: For now, we just build a grid where each cell is large 
    //            enough to fit the largest sprite.
    //            Ideally, this would more intelligently pack the sprites to 
    //            minimize empty space.

    // If there are no sprites, exit early.
    if (spriteSheet.spriteIDs.size() == 0) {
        spriteSheet.textureWidth = 0;
        spriteSheet.textureHeight = 0;
        return;
    }

    // Determine the largest sprite size.
    int maxSpriteWidth{0};
    int maxSpriteHeight{0};
    for (SpriteID spriteID : spriteSheet.spriteIDs) {
        EditorSprite& sprite{mgetSprite(spriteID)};
        if (sprite.textureExtent.w > maxSpriteWidth) {
            maxSpriteWidth = sprite.textureExtent.w;
        }
        if (sprite.textureExtent.h > maxSpriteHeight) {
            maxSpriteHeight = sprite.textureExtent.h;
        }
    }

    // Add 2px padding to avoid bleed when using texture filtering.
    maxSpriteWidth += 2;
    maxSpriteHeight += 2;

    // Find the power of two that our texture's side lengths should equal, in 
    // order to fit all of the sprites (assuming a square grid).
    int spriteCount{static_cast<int>(spriteSheet.spriteIDs.size())};
    int spritesPerRow{};
    for (int powerOfTwo{0}; true; ++powerOfTwo) {
        int gridSideLength{static_cast<int>(std::pow(2, powerOfTwo))};

        // Determine how many sprites can fit with this side length.
        spritesPerRow = gridSideLength / maxSpriteWidth;
        int spritesPerColumn{gridSideLength / maxSpriteHeight};
        if ((spritesPerRow < 1) || (spritesPerColumn < 1)) {
            // Can't fit any, continue to the next power of two.
            continue;
        }

        // If this power of two can fit all of the sprites, set it as our 
        // texture size.
        int gridCellCount{spritesPerRow * spritesPerColumn};
        if (gridCellCount >= spriteCount) {
            spriteSheet.textureWidth = gridSideLength;
            spriteSheet.textureHeight = gridSideLength;

            // If we're only going to fill half of the sheet or less, halve the 
            // height to save space.
            if (spriteCount <= (gridCellCount / 2)) {
                if (spriteCount == 1) {
                    spriteSheet.textureWidth /= 2;
                }
                else {
                    spriteSheet.textureHeight /= 2;
                }
            }
            break;
        }
    }

    // Place the sprites.
    int gridX{0};
    int gridY{0};
    for (SpriteID spriteID : spriteSheet.spriteIDs) {
        EditorSprite& sprite{mgetSprite(spriteID)};

        sprite.textureExtent.x = (gridX * maxSpriteWidth);
        sprite.textureExtent.y = (gridY * maxSpriteHeight);

        // If the next sprite would go past the edge of the grid, wrap to the 
        // next row.
        gridX++;
        if (gridX == spritesPerRow) {
            gridX = 0;
            gridY++;
        }
    }
}

void SpriteModel::addSpriteToAnimationIfNecessary(const EditorSprite& sprite)
{
    // If the sprite's display name contains a frame number, add it to an 
    // animation.
    // Note: Since we don't want to re-arrange someone's animation if they've 
    //       changed the order, we just add the sprite to the end. If we're 
    //       bulk adding sprites to an animation, the file system should serve 
    //       them to us in order anyway.
    if (getFrameNumber(sprite.displayName) != -1) {
        // Name contains a frame number. Derive the associated animation's name.
        AnimationModel& animationModel{dataModel.animationModel};
        std::string_view animationName{deriveAnimationName(sprite.displayName)};

        // Add this frame to the end of the animation.
        const EditorAnimation& animation{
            animationModel.addOrGetAnimation(animationName)};
        animationModel.addAnimationFrame(animation.numericID, sprite);
    }
}

void SpriteModel::remSpriteFromAnimationIfNecessary(const EditorSprite& sprite)
{
    // If the sprite's display name contains a frame number, remove it from the
    // animation.
    if (getFrameNumber(sprite.displayName) != -1) {
        // Name contains a frame number. Get the animation.
        std::string_view animationName{deriveAnimationName(sprite.displayName)};
        AnimationModel& animationModel{dataModel.animationModel};
        if (const EditorAnimation
            * animation{animationModel.getAnimation(animationName)}) {
            // Find which frame the sprite is in.
            // Note: This may be different than the frame number in the sprite's
            //       name, since frames can be reordered.
            int frameNumber{-1};
            for (const auto& frame : animation->frames) {
                if (frame.sprite.get().numericID == sprite.numericID) {
                    frameNumber = frame.frameNumber;
                    break;
                }
            }
            AM_ASSERT(frameNumber != -1, "Failed to find sprite in animation.");

            // Remove the sprite from the animation frame.
            dataModel.animationModel.clearAnimationFrame(
                animation->numericID, static_cast<Uint8>(frameNumber));

            // If the animation is now empty, delete it.
            if (animation->frames.empty()) {
                dataModel.animationModel.remAnimation(animation->numericID);
            }
        }
        else {
            AM_ASSERT(false, "Animation did not exist when expected.");
        }
    }
}

int SpriteModel::getFrameNumber(const std::string& displayName)
{
    // If the sprite's name ends in "_n" where n is a positive number, return 
    // it.
    if (auto pos{displayName.find_last_of('_')}; pos != displayName.npos) {
        // Get the string following the '_' and convert it to an integer.
        std::string frameNumberString{displayName.substr(pos + 1)};
        int frameNumber{-1};
        try {
            frameNumber = std::stoi(frameNumberString);
        } catch (std::exception&) {
            // The string following the '_' was not a valid number. Return
            // early.
            return -1;
        }

        // Check that the integer is valid.
        if (frameNumber < 0) {
            return -1;
        }

        return frameNumber;
    }

    return -1;
}

std::string_view
    SpriteModel::deriveAnimationName(std::string_view spriteDisplayName)
{
    return spriteDisplayName.substr(0, spriteDisplayName.find_last_of('_'));
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/Public/AnimationModel.h`:

```h
#pragma once

#include "AnimationID.h"
#include "EditorAnimation.h"
#include "IDPool.h"
#include "HashTools.h"
#include "entt/signal/sigh.hpp"
#include "nlohmann/json_fwd.hpp"
#include <map>
#include <string>

namespace AM
{
namespace ResourceImporter
{

class DataModel;

/**
 * Holds data for animations.
 */
class AnimationModel
{
public:
    AnimationModel(DataModel& inDataModel);

    /**
     * Attempts to load the "animations" section of the given json into this 
     * model.
     *
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool load(const nlohmann::json& json);

    /**
     * Saves the current state of this data model into the given json's
     * "animations" section.
     */
    void save(nlohmann::json& json);

    /**
     * Returns an animation with the given name. If it doesn't already exist, 
     * a new empty animation will be created.
     */
    const EditorAnimation& addOrGetAnimation(std::string_view displayName);

    /**
     * Removes the animation with the given ID from the associated map.
     *
     * Error if the given ID isn't present in the map.
     */
    void remAnimation(AnimationID animationID);

    const EditorAnimation& getAnimation(AnimationID animationID) const;
    const EditorAnimation* getAnimation(std::string_view displayName) const;

    // Animation properties.
    // Note: We don't offer a setter for DisplayName because it should always 
    //       be based on the sprite image filename.
    void setAnimationFrameCount(AnimationID animationID, Uint8 newFrameCount);
    void setAnimationFps(AnimationID animationID, Uint8 newFps);
    void setAnimationLoopStartFrame(AnimationID animationID,
                                    Uint8 newLoopStartFrame);
    void setAnimationModelBoundsID(AnimationID animationID,
                                BoundingBoxID newModelBoundsID);
    void setAnimationCustomModelBounds(AnimationID animationID,
                                    const BoundingBox& newModelBounds);
    void setAnimationCollisionEnabled(AnimationID animationID,
                                      bool newCollisionEnabled);
    void setAnimationEntityAlignmentAnchor(
        AnimationID animationID,
        const std::optional<Vector3>& newEntityAlignmentAnchor);
    /**
     * Adds the given sprite as a frame in the given animation.
     * The sprite will be added to the first empty frame. If there are no 
     * empty frames, the animation will be made longer by 1 frame to make 
     * room.
     */
    void addAnimationFrame(AnimationID animationID, const EditorSprite& sprite);
    /**
     * Swaps the contents of two frames in the given animation.
     */
    void swapAnimationFrames(AnimationID animationID, Uint8 sourceFrameNumber,
                             Uint8 destFrameNumber);
    /**
     * Clears a frame from the given animation, removing it from its frames
     * vector.
     * If the frame doesn't exist, does nothing.
     */
    void clearAnimationFrame(AnimationID animationID, Uint8 frameNumber);

    /** Resets the model state, setting it back to default. */
    void resetModelState();

    const std::string& getErrorString();

private:
    /**
     * @param animationJson  The json to parse. Must be a valid animation
     *                       section from ResourceData.json.
     */
    bool parseAnimation(const nlohmann::json& animationJson);

    /**
     * Checks if the given name is unique among all animations in the model.
     *
     * @param animationID  The ID of the animation that might get displayName. 
     *                     If it already is set to displayName, it won't be 
     *                     counted as non-unique.
     * @param displayName  The display name that the animation will be set to.
     */
    bool animationNameIsUnique(AnimationID animationID,
                                 const std::string& displayName);

    /**
     * Adds a new animation with the given name and returns it.
     */
    const EditorAnimation& addAnimation(std::string_view displayName);

    DataModel& dataModel;

    /** Maps animation IDs -> the animation that we currently have loaded. */
    std::map<AnimationID, EditorAnimation> animationMap;

    /** Maps animation names -> their ID. */
    std::unordered_map<std::string, AnimationID, string_hash, std::equal_to<>>
        animationNameMap;

    /** Used for generating temporary animation IDs that are only used
        internally by this editor. */
    IDPool animationIDPool;

    /** If one of our parsing functions returns false, this holds a string
        describing the error that occurred. */
    std::string errorString;

    //-------------------------------------------------------------------------
    // Signals
    //-------------------------------------------------------------------------
    entt::sigh<void(AnimationID animationID,
                    const EditorAnimation& animation)>
        animationAddedSig;
    entt::sigh<void(AnimationID animationID)> animationRemovedSig;

    entt::sigh<void(AnimationID animationID,
                    const std::string& newDisplayName)>
        animationDisplayNameChangedSig;
    entt::sigh<void(AnimationID animationID, Uint8 newFrameCount)>
        animationFrameCountChangedSig;
    entt::sigh<void(AnimationID animationID, Uint8 newFps)>
        animationFpsChangedSig;
    entt::sigh<void(AnimationID animationID, Uint8 newLoopStartFrame)>
        animationLoopStartFrameChangedSig;
    entt::sigh<void(AnimationID animationID, Uint8 newFrameNumber,
                    const EditorSprite* newSprite)>
        animationFrameChangedSig;
    entt::sigh<void(AnimationID animationID, BoundingBoxID newModelBoundsID)>
        animationModelBoundsIDChangedSig;
    entt::sigh<void(AnimationID animationID, const BoundingBox& newCustomModelBounds)>
        animationCustomModelBoundsChangedSig;
    entt::sigh<void(AnimationID animationID, bool newCollisionEnabled)>
        animationCollisionEnabledChangedSig;
    entt::sigh<void(AnimationID animationID,
                    const std::optional<Vector3>& newEntityAlignmentAnchor)>
        animationEntityAlignmentAnchorChangedSig;

public:
    //-------------------------------------------------------------------------
    // Signal Sinks
    //-------------------------------------------------------------------------
    /** An animation was added to the model. */
    entt::sink<entt::sigh<void(AnimationID animationID,
                               const EditorAnimation& animation)>>
        animationAdded;

    /** An animation was removed from the model. */
    entt::sink<entt::sigh<void(AnimationID animationID)>>
        animationRemoved;

    /** An animation's display name has changed. */
    entt::sink<entt::sigh<void(AnimationID animationID,
                               const std::string& newDisplayName)>>
        animationDisplayNameChanged;

    /** An animation's frame count has changed. */
    entt::sink<entt::sigh<void(AnimationID animationID, Uint8 newFrameCount)>>
        animationFrameCountChanged;

    /** An animation's fps has changed. */
    entt::sink<entt::sigh<void(AnimationID animationID, Uint8 newFps)>>
        animationFpsChanged;

    /** An animation's loop start frame. */
    entt::sink<
        entt::sigh<void(AnimationID animationID, Uint8 newLoopStartFrame)>>
        animationLoopStartFrameChanged;

    /** An animation frame has changed.
        newSprite == nullptr if frame was cleared. */
    entt::sink<entt::sigh<void(AnimationID animationID, Uint8 newFrameNumber,
                               const EditorSprite* newSprite)>>
        animationFrameChanged;

    /** An animation's bounding box ID has changed. */
    entt::sink<
        entt::sigh<void(AnimationID animationID, BoundingBoxID newModelBoundsID)>>
        animationModelBoundsIDChanged;

    /** A animation's custom bounding box has changed. */
    entt::sink<entt::sigh<void(AnimationID animationID,
                               const BoundingBox& newCustomModelBounds)>>
        animationCustomModelBoundsChanged;

    /** An animation's collisionEnabled has changed. */
    entt::sink<
        entt::sigh<void(AnimationID animationID, bool newCollisionEnabled)>>
        animationCollisionEnabledChanged;

    /** An animation's entity alignment anchor has been added, removed, or 
        updated. */
    entt::sink<entt::sigh<void(
        AnimationID animationID,
        const std::optional<Vector3>& newEntityAlignmentAnchor)>>
        animationEntityAlignmentAnchorChanged;
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/BoundingBoxModel.h`:

```h
#pragma once

#include "BoundingBoxID.h"
#include "EditorBoundingBox.h"
#include "IDPool.h"
#include "entt/signal/sigh.hpp"
#include "nlohmann/json_fwd.hpp"
#include <map>
#include <string>

namespace AM
{
namespace ResourceImporter
{

class DataModel;

/**
 * Holds data for bounding boxes.
 *
 * Note: The engine doesn't actually load this data (or anything from the 
 *       "boundingBoxes" section of ResourceData.json). Instead, we copy the 
 *       relevant bounds data directly into the Sprites and Animations that 
 *       use them.
 */
class BoundingBoxModel
{
public:
    BoundingBoxModel(DataModel& inDataModel);

    /**
     * Attempts to load the "boundingBoxes" section of the given json into this 
     * model.
     *
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool load(const nlohmann::json& json);

    /**
     * Saves the current state of this data model into the given json's
     * "boundingBoxes" section.
     */
    void save(nlohmann::json& json);

    /**
     * Adds a default bounding box and loads it.
     */
    bool addBoundingBox();

    /**
     * Adds a bounding box with the given name and bounds, or updates an 
     * existing one if the name is already taken.
     */
    BoundingBoxID addOrUpdateBoundingBox(const std::string& displayName,
                                         const BoundingBox& modelBounds);

    /**
     * Removes the bounding box with the given ID from the associated map.
     *
     * Error if the given ID isn't present in the map.
     */
    void remBoundingBox(BoundingBoxID boundingBoxID);

    const EditorBoundingBox& getBoundingBox(BoundingBoxID boundingBoxID) const;

    // Bounding box properties.
    void setBoundingBoxDisplayName(BoundingBoxID boundingBoxID,
                                   const std::string& newDisplayName);
    void setBoundingBoxBounds(BoundingBoxID boundingBoxID,
                              const BoundingBox& newBounds);

    /** Resets the model state, setting it back to default. */
    void resetModelState();

    const std::string& getErrorString();

private:
    /**
     * @param boundsJson  The json to parse. Must be a valid bounding box
     *                    section from ResourceData.json.
     */
    bool parseBoundingBox(const nlohmann::json& boundsJson);

    /**
     * Checks if the given name is unique among all bounding boxes in the model.
     *
     * @param boundingBoxID  The ID of the bounds that might get displayName. 
     *                       If it already is set to displayName, it won't be 
     *                       counted as non-unique.
     * @param displayName  The display name that the bounds will be set to.
     */
    bool boundingBoxNameIsUnique(BoundingBoxID boundingBoxID,
                                 const std::string& displayName);

    /**
     * Adds a bounding box with the given name, signals to the UI that 
     * the box was added, and returns it.
     * Note: This doesn't check that the name is unique. You must ensure that 
     *       yourself.
     */
    EditorBoundingBox& addBoundingBoxInternal(const std::string& displayName,
                                              const BoundingBox& modelBounds);

    DataModel& dataModel;

    /** Maps bounding box IDs -> the bounding boxes that we currently have 
        loaded. */
    std::map<BoundingBoxID, EditorBoundingBox> boundingBoxMap;

    /** Maps bounding box names -> their ID. */
    std::unordered_map<std::string, BoundingBoxID> boundingBoxNameMap;

    /** Used for generating temporary bounding box IDs that are only used
        internally by this editor. */
    IDPool boundingBoxIDPool;

    /** If one of our parsing functions returns false, this holds a string
        describing the error that occurred. */
    std::string errorString;

    //-------------------------------------------------------------------------
    // Signals
    //-------------------------------------------------------------------------
    entt::sigh<void(BoundingBoxID boundingBoxID,
                    const EditorBoundingBox& boundingBox)>
        boundingBoxAddedSig;
    entt::sigh<void(BoundingBoxID boundingBoxID)> boundingBoxRemovedSig;

    entt::sigh<void(BoundingBoxID boundingBoxID,
                    const std::string& newDisplayName)>
        boundingBoxDisplayNameChangedSig;
    entt::sigh<void(BoundingBoxID boundingBoxID, const BoundingBox& newBounds)>
        boundingBoxBoundsChangedSig;

public:
    //-------------------------------------------------------------------------
    // Signal Sinks
    //-------------------------------------------------------------------------
    /** A bounding box was added to the model. */
    entt::sink<entt::sigh<void(BoundingBoxID boundingBoxID,
                               const EditorBoundingBox& boundingBox)>>
        boundingBoxAdded;

    /** A bounding box was removed from the model. */
    entt::sink<entt::sigh<void(BoundingBoxID boundingBoxID)>>
        boundingBoxRemoved;

    /** A bounding box's display name has changed. */
    entt::sink<entt::sigh<void(BoundingBoxID boundingBoxID,
                               const std::string& newDisplayName)>>
        boundingBoxDisplayNameChanged;

    /** A bounding box's bounds have changed. */
    entt::sink<entt::sigh<void(BoundingBoxID boundingBoxID,
                               const BoundingBox& newBounds)>>
        boundingBoxBoundsChanged;
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/DataModel.h`:

```h
#pragma once

#include "GraphicSets.h"
#include "LibraryItemData.h"
#include "BoundingBoxModel.h"
#include "GraphicSetModel.h"
#include "EntityGraphicSetModel.h"
#include "SpriteModel.h"
#include "AnimationModel.h"
#include "IconModel.h"
#include "EditorGraphicRef.h"
#include "entt/signal/sigh.hpp"
#include "nlohmann/json_fwd.hpp"
#include <fstream>
#include <map>
#include <string>

struct SDL_Renderer;

namespace AM
{
namespace ResourceImporter
{
/**
 * A data model that holds our resource data in memory and supports saving it
 * into a ResourceData.json file.
 *
 * Note: All ID spaces are separate (i.e. sprites, sprite sheets, floors, etc
 *       all have unique ID spaces).
 * Note: The sprite numeric ID space might accrue gaps as sprite are deleted.
 *       This is known and expected. Sprites are ordered in the UI by their
 *       sheet's ID, so it shouldn't inconvenience users.
 */
class DataModel
{
public:
    DataModel(SDL_Renderer* inSdlRenderer);

    SpriteModel spriteModel;
    AnimationModel animationModel;
    BoundingBoxModel boundingBoxModel;
    GraphicSetModel graphicSetModel;
    EntityGraphicSetModel entityGraphicSetModel;
    IconModel iconModel;

    /**
     * Creates a new ResourceData.json file at the given path and saves to it.
     *
     * @param resourcesPath The path to the Resources directory.
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool open(std::string_view resourcesPath);

    /**
     * Saves the current state of this data model into the ResourceData.json
     * file at the previously loaded path.
     */
    void save();

    /**
     * Returns a reference to the graphic with the given ID.
     * Note: This would normally belong to a specific model, but graphics may 
     *       be either a Sprite or Animation (which each have their own model).
     */
    EditorGraphicRef getGraphic(GraphicID graphicID);

    // Note: Each of these "setActive" functions affect the current active 
    //       library item. There's only 1 active library item at a time, these 
    //       are only set up like this because they aren't easily templated.
    /** Sets the current active library item to the given sprite sheet. */
    void setActiveSpriteSheet(int newActiveSpriteSheetID);

    /** Sets the current active library item to the given sprite. */
    void setActiveSprite(SpriteID newActiveSpriteID);

    /** Sets the current active library item to the given animation. */
    void setActiveAnimation(AnimationID newActiveAnimationID);

    /** Sets the current active library item to the given bounding box. */
    void setActiveBoundingBox(BoundingBoxID newActiveBoundingBoxID);

    /** Sets the current active library item to the given graphic set. */
    void setActiveGraphicSet(GraphicSet::Type type,
                             Uint16 newActiveGraphicSetID);

    /** Sets the current active library item to the given icon. */
    void setActiveIcon(IconID newActiveIconID);

    const std::string& getWorkingTexturesDir() const;
    const std::string& getWorkingIndividualSpritesDir() const;

    const std::string& getErrorString() const;

    /**
     * Checks that the given relative path corresponds to a valid sprite
     * sheet image in the working Resources directory.
     *
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool validateRelPath(const std::string& relPath);

private:
    /**
     * Creates a new ResourceData.json file at the given path and saves to it.
     *
     * @param inJsonFilePath The full path to the ResourceData.json file.
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool createJson(const std::string& inJsonFilePath);

    /**
     * Attempts to open the ResourceData.json at the given path, parse it,
     * and load the data into this model.
     *
     * @param inJsonFilePath The full path to the ResourceData.json file.
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool loadJson(const std::string& inJsonFilePath);

    /** Resets the model state, setting it back to default. */
    void resetModelState();

    /** The ResourceData.json file that we currently have loaded and are working
        on. */
    std::string workingJsonPath;

    /** The Client/Common/Assets/Textures directory path. */
    std::string workingTexturesDir;

    /** The Client/Common/Assets/IndividualSprites directory path. */
    std::string workingIndividualSpritesDir;

    /** If one of our member model's load functions returns false, this holds a
        string describing the error that occurred. */
    std::string errorString;

    //-------------------------------------------------------------------------
    // Signals
    //-------------------------------------------------------------------------
    entt::sigh<void(const LibraryItemData& newActiveItem)>
        activeLibraryItemChangedSig;

public:
    //-------------------------------------------------------------------------
    // Signal Sinks
    //-------------------------------------------------------------------------
    /** The active library item has changed. */
    entt::sink<entt::sigh<void(const LibraryItemData& newActiveItem)>>
        activeLibraryItemChanged;
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/EditorAnimation.h`:

```h
#pragma once

#include "AnimationID.h"
#include "EditorSprite.h"
#include "BoundingBoxID.h"
#include "BoundingBox.h"
#include <SDL_rect.h>
#include <string>
#include <vector>
#include <functional>
#include <optional>

namespace AM
{
namespace ResourceImporter
{

class BoundingBoxModel;

/**
 * Holds the data necessary for editing and saving an animation.
 * Part of AnimationModel.
 */
struct EditorAnimation {
    /** This animation's unique numeric identifier. */
    AnimationID numericID{NULL_ANIMATION_ID};

    /** Unique display name, shown in the UI.  */
    std::string displayName{""};

    /** How long this animation is, in frames. */
    Uint8 frameCount{1};

    /** This animation's framerate (frames per second). */
    Uint8 fps{10};

    /** When the animation completes, it will loop to this frame and continue 
        playing. If == frameCount, no frames will be looped.
        Must always be <= frameCount. */
    Uint8 loopStartFrame{0};

    struct Frame
    {
        Uint8 frameNumber{0};
        // Note: This gets serialized in ResourceData.json as "spriteID".
        std::reference_wrapper<const EditorSprite> sprite;
    };
    /** The frames of this animation, ordered by ascending frameNumber.
        Only holds frames that actually contain a sprite.
        Note: There will always be at least 1 frame present. */
    std::vector<Frame> frames;

    /** If true, this animation's modelBounds will be used in collision checks.
        Floors never have collision, regardless of this setting. */
    bool collisionEnabled{false};

    /** If non-null, this is the ID of this animation's model-space bounding box.
        Defines the animation's 3D volume.
        Used in hit testing for user mouse events, and for collision checks (
        if collisionEnabled). */
    BoundingBoxID modelBoundsID{NULL_BOUNDING_BOX_ID};

    /** If modelBoundsID is null, this is the animation's custom model-space 
        bounding box. */
    BoundingBox customModelBounds{};

    /** Only used for entities, during render sorting.
        When entities change animation, the new animation needs to line up with
        the old one so the entity doesn't look like it's teleporting around. 
        If non-null, this is the model-space point that should be aligned 
        with IdleSouth. */
    std::optional<Vector3> entityAlignmentAnchor{};

    /**
     * Returns this animation's model-space bounding box.
     *
     * If modelBoundsID is non-null, returns the associated bounding box. Else, 
     * returns customModelBounds.
     */
    const BoundingBox&
        getModelBounds(const BoundingBoxModel& boundingBoxModel) const;

    /**
     * Returns the sprite that should be displayed at the given animation time, 
     * or nullptr if this animation has no frames.
     */
    const EditorSprite* getSpriteAtTime(double animationTime) const;

    /**
     * Returns the sprite that should be displayed at the given frame.
     * If the given frame doesn't have a sprite, returns the closest sprite 
     * from a previous frame.
     * If there are no previous frames with a sprite, returns nullptr.
     */
    const EditorSprite* getSpriteAtFrame(Uint8 frameNumber) const;

    /**
     * Returns a vector that contains all the frames of this animation, 
     * including empty frames (as nullptr).
     *
     * This form is more convenient during modifications (add, swap, remove), 
     * but less convenient to iterate through.
     */
    std::vector<const EditorSprite*> getExpandedFrameVector() const;

    /**
     * Clears this animation and fills it to match the given vector.
     */
    void setFromExpandedFrameVector(
        const std::vector<const EditorSprite*>& expandedFrameVector);
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/EditorBoundingBox.h`:

```h
#pragma once

#include "BoundingBoxID.h"
#include "BoundingBox.h"
#include <string>

namespace AM
{
namespace ResourceImporter
{

/**
 * Holds the data necessary for editing and saving a bounding box.
 * Part of BoundingBoxModel.
 */
struct EditorBoundingBox {
    /** This bounding box's unique numeric identifier. */
    BoundingBoxID numericID{NULL_BOUNDING_BOX_ID};

    /** Unique display name, shown in the UI.  */
    std::string displayName{""};

    /** Model-space bounding box. */
    BoundingBox modelBounds{};
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/EditorEntityGraphicSet.h`:

```h
#pragma once

#include "GraphicID.h"
#include "GraphicSetIDs.h"
#include "EntityGraphicType.h"
#include "Rotation.h"
#include <SDL_stdinc.h>
#include <string>
#include <unordered_map>
#include <array>

namespace AM
{
namespace ResourceImporter
{
/**
 * Holds the data necessary for editing and saving an entity graphic set.
 * Part of EntityGraphicSetModel.
 */
struct EditorEntityGraphicSet {
    /** This graphic set's unique numeric identifier.
        Note: This ID may change when this graphic set is saved to the json. */
    EntityGraphicSetID numericID{0};

    /** Unique display name, shown in the UI.  */
    std::string displayName{""};

    /** The entity graphic types that this set contains.
        Each graphic type is associated with an array of up to 8 graphics, one 
        for each possible rotation of the entity.
        The Idle graphic type will always be present. All others are optional.
        If any slots weren't assigned a graphic, they will be set to 
        NULL_GRAPHIC_ID in the array. */
    std::unordered_map<EntityGraphicType,
                       std::array<GraphicID, Rotation::Direction::Count>>
        graphicIDs{};
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/EditorFloorGraphicSet.h`:

```h
#pragma once

#include "Rotation.h"
#include "GraphicID.h"
#include "GraphicSetIDs.h"
#include <SDL_stdinc.h>
#include <string>
#include <array>

namespace AM
{
namespace ResourceImporter
{
/**
 * Holds the data necessary for editing and saving a floor graphic set.
 * Part of GraphicSetModel.
 */
struct EditorFloorGraphicSet {
    /** This graphic set's unique numeric identifier.
        Note: This ID may change when this graphic set is saved to the json. */
    FloorGraphicSetID numericID{0};

    /** Unique display name, shown in the UI.  */
    std::string displayName{""};

    /** The numeric IDs for each graphic in this set.
        Floors support 8 directions of rotation. At least 1 graphic
        must be set. If a direction isn't provided, it should be set to
        NULL_GRAPHIC_ID. */
    std::array<GraphicID, Rotation::Direction::Count> graphicIDs{
        /* NULL_GRAPHIC_ID */ };
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/EditorGraphicRef.h`:

```h
#pragma once

#include "EditorSprite.h"
#include "EditorAnimation.h"
#include "GraphicID.h"
#include <variant>

namespace AM
{
namespace ResourceImporter
{

class BoundingBoxModel;

/**
 * Holds a reference to either an EditorSprite or an EditorAnimation.
 *
 * Used in situations where both are supported (graphic sets).
 */
struct EditorGraphicRef
: public std::variant<std::reference_wrapper<const EditorSprite>,
                      std::reference_wrapper<const EditorAnimation>> {
    /**
     * Returns the graphic ID for the Sprite or Animation that this ref points 
     * to.
     * 
     * The top bit is this graphic's type. 0 == Sprite, 1 == Animation.
     * The bottom 31 bits are the Sprite or Animation's ID.
     */
    GraphicID getGraphicID() const;

    const std::string& getDisplayName() const;

    bool getCollisionEnabled() const;

    const BoundingBox&
        getModelBounds(const BoundingBoxModel& boundingBoxModel) const;

    /**
     * If this ref points to a Sprite, returns it.
     * If this ref points to an Animation, returns the first sprite in the 
     * animation or nullptr if the animation has no frames.
     */
    const EditorSprite* getFirstSprite() const;

    /**
     * If this ref points to a Sprite, returns it.
     * If this ref points to an Animation, returns the sprite that should be 
     * displayed at the given animation time or nullptr if the animation has 
     * no frames.
     */
    const EditorSprite* getSpriteAtTime(double animationTime) const;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/Public/EditorIcon.h`:

```h
#pragma once

#include "IconID.h"
#include <SDL_stdinc.h>
#include <SDL_rect.h>
#include <string>

namespace AM
{
namespace ResourceImporter
{
/**
 * Holds the data necessary for editing and saving an icon.
 * Part of IconModel.
 */
struct EditorIcon {
    /** This icon's unique numeric identifier.
        Note: This ID may change when this icon is saved to the json. */
    IconID numericID{0};

    /** The unique relPath of the icon sheet that this icon is from. */
    std::string parentIconSheetPath{""};

    /** Unique display name, shown in the UI.  */
    std::string displayName{""};

    /** UV position and size in texture. */
    SDL_Rect textureExtent{0, 0, 0, 0};
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/EditorIconSheet.h`:

```h
#pragma once

#include "IconID.h"
#include <SDL_stdinc.h>
#include <string>
#include <vector>

namespace AM
{
namespace ResourceImporter
{
/**
 * Holds the data necessary for editing and saving an icon sheet.
 * Part of IconModel.
 */
struct EditorIconSheet {
    /** The path to the icon sheet image file, relative to the application's
        base directory. */
    std::string relPath{};

    /** The runtime IDs for each icon in this sheet. */
    std::vector<IconID> iconIDs{};
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/EditorObjectGraphicSet.h`:

```h
#pragma once

#include "Rotation.h"
#include "GraphicID.h"
#include "GraphicSetIDs.h"
#include <SDL_stdinc.h>
#include <string>
#include <array>

namespace AM
{
namespace ResourceImporter
{
/**
 * Holds the data necessary for editing and saving an object graphic set.
 * Part of GraphicSetModel.
 */
struct EditorObjectGraphicSet {
    /** This graphic set's unique numeric identifier.
        Note: This ID may change when this graphic set is saved to the json. */
    ObjectGraphicSetID numericID{0};

    /** Unique display name, shown in the UI.  */
    std::string displayName{""};

    /** The numeric IDs for each graphic in this set.
        Objects support 8 directions of rotation. At least 1 graphic must be
        set. If a direction isn't provided, it should be set to
        NULL_GRAPHIC_ID. */
    std::array<GraphicID, Rotation::Direction::Count> graphicIDs{
        NULL_GRAPHIC_ID, NULL_GRAPHIC_ID, NULL_GRAPHIC_ID, NULL_GRAPHIC_ID,
        NULL_GRAPHIC_ID, NULL_GRAPHIC_ID, NULL_GRAPHIC_ID, NULL_GRAPHIC_ID};
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/EditorSprite.h`:

```h
#pragma once

#include "SpriteID.h"
#include "SpriteSheetID.h"
#include "BoundingBoxID.h"
#include "BoundingBox.h"
#include <SDL_rect.h>
#include <string>

namespace AM
{
namespace ResourceImporter
{

class BoundingBoxModel;

/**
 * Holds the data necessary for editing and saving a sprite.
 * Part of SpriteModel.
 */
struct EditorSprite {
    /** This sprite's unique numeric identifier. */
    SpriteID numericID{NULL_SPRITE_ID};

    // Note: We don't need to store the sprite sheet ID, since sprite sheets 
    //       know which sprites they own (both in memory and in json).

    /** The relPath to the individual image file for this sprite. */
    std::string imagePath{""};

    /** Unique display name, shown in the UI.  */
    std::string displayName{""};

    /** This sprite's actual-space UV position and size within its parent 
        sprite sheet texture. */
    SDL_Rect textureExtent{0, 0, 0, 0};

    /** The actual-space point within the sprite where the "stage" starts.
        The "stage" is the coordinate space that we overlay onto the sprite 
        image. */
    SDL_Point stageOrigin{0, 0};

    /** If true, this sprite's modelBounds will be used in collision checks.
        Floors never have collision, regardless of this setting. */
    bool collisionEnabled{false};

    /** If non-null, this is the ID of this sprite's model-space bounding box.
        Defines the sprite's 3D volume.
        Used in hit testing for user mouse events, and for collision checks (
        if collisionEnabled). */
    BoundingBoxID modelBoundsID{NULL_BOUNDING_BOX_ID};

    /** If modelBoundsID is null, this is the sprite's custom model-space 
        bounding box. */
    BoundingBox customModelBounds{};

    /** If true, this sprite will have its alpha premultiplied. */
    bool premultiplyAlpha{false};

    /**
     * Returns this sprite's model-space bounding box.
     *
     * If modelBoundsID is non-null, returns the associated bounding box. Else, 
     * returns customModelBounds.
     */
    const BoundingBox&
        getModelBounds(const BoundingBoxModel& boundingBoxModel) const;
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/EditorSpriteSheet.h`:

```h
#pragma once

#include "SpriteSheetID.h"
#include "SpriteID.h"
#include <SDL_rect.h>
#include <string>
#include <vector>

namespace AM
{
namespace ResourceImporter
{
/**
 * Holds the data necessary for editing and saving a sprite sheet.
 * Part of SpriteModel.
 */
struct EditorSpriteSheet {
    /** This sprite sheet's unique numeric identifier.
        Note: Sprite sheet numeric IDs aren't saved to the json or used by 
              the engine, so we just generate new ones each time the 
              importer is ran. */
    SpriteSheetID numericID{NULL_SPRITE_SHEET_ID};

    /** Unique display name. Shown in the UI, and used as the name of the 
        exported sprite sheet image file. */
    std::string displayName{""};

    /** The width of the generated sprite sheet texture. */
    int textureWidth{0};
    /** The height of the generated sprite sheet texture. */
    int textureHeight{0};

    /** The numeric IDs for each sprite in this sheet. */
    std::vector<SpriteID> spriteIDs{};
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/EditorTerrainGraphicSet.h`:

```h
#pragma once

#include "Terrain.h"
#include "GraphicID.h"
#include "GraphicSetIDs.h"
#include <SDL_stdinc.h>
#include <string>
#include <array>

namespace AM
{
namespace ResourceImporter
{
/**
 * Holds the data necessary for editing and saving a terrain graphic set.
 * Part of GraphicSetModel.
 */
struct EditorTerrainGraphicSet {
    /** This graphic set's unique numeric identifier.
        Note: This ID may change when this graphic set is saved to the json. */
    TerrainGraphicSetID numericID{0};

    /** Unique display name, shown in the UI.  */
    std::string displayName{""};

    /** The numeric IDs for each graphic in this set.
        If a graphic isn't provided, it should be set to NULL_GRAPHIC_ID. */
    std::array<GraphicID, Terrain::Height::Count> graphicIDs{
        /* NULL_GRAPHIC_ID */ };
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/EditorWallGraphicSet.h`:

```h
#pragma once

#include "Wall.h"
#include "GraphicID.h"
#include "GraphicSetIDs.h"
#include <SDL_stdinc.h>
#include <string>
#include <array>

namespace AM
{
namespace ResourceImporter
{
/**
 * Holds the data necessary for editing and saving a floor graphic set.
 * Part of GraphicSetModel.
 */
struct EditorWallGraphicSet {
    /** This graphic set's unique numeric identifier.
        Note: This ID may change when this graphic set is saved to the json. */
    WallGraphicSetID numericID{0};

    /** Unique display name, shown in the UI.  */
    std::string displayName{""};

    /** The numeric IDs for each graphic in this set.
        Walls require the 4 types of wall graphics that our modular wall
        system uses. */
    std::array<GraphicID, Wall::Type::Count> graphicIDs{
        /* NULL_GRAPHIC_ID */ };
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/EntityGraphicSetModel.h`:

```h
#pragma once

#include "GraphicSets.h"
#include "EditorEntityGraphicSet.h"
#include "IDPool.h"
#include "entt/signal/sigh.hpp"
#include "nlohmann/json_fwd.hpp"
#include <map>
#include <string>

namespace AM
{
namespace ResourceImporter
{

class DataModel;

/**
 * Holds data for entity graphic sets.
 */
class EntityGraphicSetModel
{
public:
    EntityGraphicSetModel(DataModel& inDataModel);

    /**
     * Attempts to load the "entities" section of the given json into this model.
     *
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool load(const nlohmann::json& json);

    /**
     * Saves the current state of this data model into the given json's
     * "entites" section.
     */
    void save(nlohmann::json& json);

    /**
     * Adds a blank entity graphic set and loads it.
     */
    bool addEntity();

    /**
     * Removes the entity graphic set with the given ID from the associated 
     * map.
     *
     * Error if the given ID isn't present in the map.
     *
     * @param entityID  The editor ID of the graphic set to remove.
     */
    void remEntity(EntityGraphicSetID entityID);

    const EditorEntityGraphicSet& getEntity(EntityGraphicSetID entityID);

    // Entity graphic set properties.
    void setEntityDisplayName(EntityGraphicSetID graphicSetID,
                              const std::string& newDisplayName);
    /** If newGraphicID is null, the slot will be cleared. */
    void setEntitySlot(EntityGraphicSetID graphicSetID,
                       EntityGraphicType graphicType,
                       Rotation::Direction direction, GraphicID newGraphicID);

    /** Resets the model state, setting it back to default. */
    void resetModelState();

    /**
     * Iterates all the graphic sets and replaces any instances of graphicID
     * with NULL_GRAPHIC_ID.
     */
    void removeGraphicIDFromSets(GraphicID graphicID);

    const std::string& getErrorString();

private:
    // Parsing functions.
    /**
     * @param graphicSetJson  The json to parse. Must be a valid entity graphic
     *                        set section from ResourceData.json.
     */
    bool parseEntityGraphicSet(const nlohmann::json& graphicSetJson);

    /**
     * Checks if the given name is unique among all entity graphic sets in the 
     * model.
     *
     * @param graphicSetID  The ID of the graphic set that might get displayName.
     *                      If it already is set to displayName, it won't be 
     *                      counted as non-unique.
     * @param displayName  The display name that the graphic set will be set to.
     */
    bool graphicSetNameIsUnique(EntityGraphicSetID graphicSetID,
                                const std::string& displayName);

    DataModel& dataModel;

    // Note: These all use Uint16 instead of the specific ID type, so we can 
    //       interact with them generically.
    /** Maps entity IDs -> the entity graphic sets that we currently have loaded.
     */
    std::map<EntityGraphicSetID, EditorEntityGraphicSet> entityMap;

    /** Used for generating temporary graphic set IDs that are only used
        internally by this editor. */
    IDPool entityIDPool;

    /** If one of our parsing functions returns false, this holds a string
        describing the error that occurred. */
    std::string errorString;

    //-------------------------------------------------------------------------
    // Signals
    //-------------------------------------------------------------------------
    entt::sigh<void(EntityGraphicSetID entityID,
                    const EditorEntityGraphicSet& entity)>
        entityAddedSig;

    entt::sigh<void(EntityGraphicSetID graphicSetID)> entityRemovedSig;
    entt::sigh<void(EntityGraphicSetID graphicSetID,
                    EntityGraphicType graphicType, Rotation::Direction,
                    GraphicID newGraphicID)>
        entitySlotChangedSig;
    entt::sigh<void(EntityGraphicSetID graphicSetID,
                    const std::string& newDisplayName)>
        entityDisplayNameChangedSig;

public:
    //-------------------------------------------------------------------------
    // Signal Sinks
    //-------------------------------------------------------------------------
    /** A floor graphic set was added to the model. */
    entt::sink<entt::sigh<void(EntityGraphicSetID entityID,
                               const EditorEntityGraphicSet& entity)>>
        entityAdded;

    /** An entity set was removed from the model. */
    entt::sink<entt::sigh<void(EntityGraphicSetID graphicSetID)>> entityRemoved;

    /** An entity graphic set's graphic of the given type was changed.
        If ID == null, the slot was cleared. */
    entt::sink<entt::sigh<void(
        EntityGraphicSetID graphicSetID, EntityGraphicType graphicType,
        Rotation::Direction direction, GraphicID newGraphicID)>>
        entitySlotChanged;

    /** An entity graphic set's display name has changed. */
    entt::sink<entt::sigh<void(EntityGraphicSetID graphicSetID,
                               const std::string& newDisplayName)>>
        entityDisplayNameChanged;
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/GraphicSetModel.h`:

```h
#pragma once

#include "GraphicSets.h"
#include "EditorFloorGraphicSet.h"
#include "EditorTerrainGraphicSet.h"
#include "EditorWallGraphicSet.h"
#include "EditorObjectGraphicSet.h"
#include "IDPool.h"
#include "entt/signal/sigh.hpp"
#include "nlohmann/json_fwd.hpp"
#include <map>
#include <string>

namespace AM
{
namespace ResourceImporter
{

class DataModel;

/**
 * Holds data for Floor, Floor Covering, Wall, and Object graphic sets.
 * Entity graphic sets use EntityGraphicSetModel.
 */
class GraphicSetModel
{
public:
    GraphicSetModel(DataModel& inDataModel);

    /**
     * Attempts to load the "floors", "floorCoverings", "walls", and "objects"
     * sections of the given json into this model.
     *
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool load(const nlohmann::json& json);

    /**
     * Saves the current state of this data model into the given json's
     * "floors", "floorCoverings", "walls", and "objects" sections.
     */
    void save(nlohmann::json& json);

    /**
     * Adds a blank graphic set of the appropriate type and loads it.
     */
    bool addTerrain();
    bool addFloor();
    bool addWall();
    bool addObject();

    /**
     * Removes the graphic set of the appropriate type with the given ID from
     * the associated map.
     *
     * Error if the given ID isn't present in the map.
     *
     * @param graphicSetID  The editor ID of the graphic set to remove.
     */
    void remTerrain(TerrainGraphicSetID terrainID);
    void remFloor(FloorGraphicSetID floorCoveringID);
    void remWall(WallGraphicSetID wallID);
    void remObject(ObjectGraphicSetID objectID);

    const EditorTerrainGraphicSet& getTerrain(TerrainGraphicSetID terrainID);
    const EditorFloorGraphicSet&
        getFloor(FloorGraphicSetID floorID);
    const EditorWallGraphicSet& getWall(WallGraphicSetID wallID);
    const EditorObjectGraphicSet& getObject(ObjectGraphicSetID objectID);

    // Graphic set properties.
    void setGraphicSetDisplayName(GraphicSet::Type type, Uint16 graphicSetID,
                                 const std::string& newDisplayName);
    void setGraphicSetSlot(GraphicSet::Type type, Uint16 graphicSetID,
                          std::size_t index, GraphicID newGraphicID);

    /** Resets the model state, setting it back to default. */
    void resetModelState();

    /**
     * Iterates all the graphic sets and replaces any instances of graphicID
     * with NULL_GRAPHIC_ID.
     */
    void removeGraphicIDFromSets(GraphicID graphicID);

    const std::string& getErrorString();

private:
    // Parsing functions.
    /**
     * @param graphicSetJson  The json to parse. Must be a valid graphic set
     *                        section from ResourceData.json, for the appropriate
     *                        set type.
     */
    bool parseTerrainGraphicSet(const nlohmann::json& graphicSetJson);
    bool parseFloorGraphicSet(const nlohmann::json& graphicSetJson);
    bool parseWallGraphicSet(const nlohmann::json& graphicSetJson);
    bool parseObjectGraphicSet(const nlohmann::json& graphicSetJson);

    /**
     * Returns the appropriate map for the given graphic set type.
     */
    template<typename T>
    std::map<Uint16, T>& getMapForGraphicSetType();

    /**
     * Checks if the given name is unique among all graphic sets of the same 
     * type in the model.
     *
     * @param graphicSetID  The ID of the graphic set that might get displayName.
     *                      If it already is set to displayName, it won't be 
     *                      counted as non-unique.
     * @param displayName  The display name that the graphic set will be set to.
     */
    template<typename T>
    bool graphicSetNameIsUnique(Uint16 graphicSetID,
                               const std::string& displayName);

    /**
     * Implementation for setGraphicSetDisplayName().
     */
    template<typename T>
    void setGraphicSetDisplayName(GraphicSet::Type type, Uint16 graphicSetID,
                                 const std::string& newDisplayName);

    /**
     * Implementation for setGraphicSetSlot().
     */
    template<typename T>
    void setGraphicSetSlot(GraphicSet::Type type, Uint16 graphicSetID,
                          std::size_t index, GraphicID newGraphicID);

    // Save functions.
    void saveTerrain(nlohmann::json& json);
    void saveFloors(nlohmann::json& json);
    void saveWalls(nlohmann::json& json);
    void saveObjects(nlohmann::json& json);

    DataModel& dataModel;

    // Note: These all use Uint16 instead of the specific ID type, so we can 
    //       interact with them generically.
    /** Maps terrain IDs -> the terrain graphic sets that we currently have 
        loaded. */
    std::map<Uint16, EditorTerrainGraphicSet> terrainMap;

    /** Maps floor IDs -> the floor graphic sets that we currently have loaded. 
     */
    std::map<Uint16, EditorFloorGraphicSet> floorMap;

    /** Maps wall IDs -> the wall graphic sets that we currently have loaded. */
    std::map<Uint16, EditorWallGraphicSet> wallMap;

    /** Maps object IDs -> the object graphic sets that we currently have loaded.
     */
    std::map<Uint16, EditorObjectGraphicSet> objectMap;

    /** Used for generating temporary graphic set IDs that are only used
        internally by this editor. */
    IDPool terrainIDPool;
    IDPool floorIDPool;
    IDPool wallIDPool;
    IDPool objectIDPool;

    /** If one of our parsing functions returns false, this holds a string
        describing the error that occurred. */
    std::string errorString;

    //-------------------------------------------------------------------------
    // Signals
    //-------------------------------------------------------------------------
    entt::sigh<void(TerrainGraphicSetID floorID,
                    const EditorTerrainGraphicSet& floor)>
        terrainAddedSig;
    entt::sigh<void(FloorGraphicSetID floorCoveringID,
                    const EditorFloorGraphicSet& floorCovering)>
        floorAddedSig;
    entt::sigh<void(WallGraphicSetID wallID, const EditorWallGraphicSet& wall)>
        wallAddedSig;
    entt::sigh<void(ObjectGraphicSetID objectID,
                    const EditorObjectGraphicSet& object)>
        objectAddedSig;

    entt::sigh<void(GraphicSet::Type type, Uint16 graphicSetID)>
        graphicSetRemovedSig;
    entt::sigh<void(GraphicSet::Type type, Uint16 graphicSetID, std::size_t index,
                    GraphicID newGraphicID)>
        graphicSetSlotChangedSig;
    entt::sigh<void(GraphicSet::Type type, Uint16 graphicSetID,
                    const std::string& newDisplayName)>
        graphicSetDisplayNameChangedSig;

public:
    //-------------------------------------------------------------------------
    // Signal Sinks
    //-------------------------------------------------------------------------
    /** A terrain graphic set was added to the model. */
    entt::sink<
        entt::sigh<void(TerrainGraphicSetID terrainID,
                        const EditorTerrainGraphicSet& terrain)>>
        terrainAdded;
    /** A floor graphic set was added to the model. */
    entt::sink<entt::sigh<void(FloorGraphicSetID floorID,
                               const EditorFloorGraphicSet& floor)>>
        floorAdded;
    /** A wall graphic set was added to the model. */
    entt::sink<entt::sigh<void(WallGraphicSetID wallID,
                               const EditorWallGraphicSet& wall)>>
        wallAdded;
    /** An object graphic set was added to the model. */
    entt::sink<entt::sigh<void(ObjectGraphicSetID objectID,
                               const EditorObjectGraphicSet& floor)>>
        objectAdded;

    /** A graphic set was removed from the model. */
    entt::sink<entt::sigh<void(GraphicSet::Type type, Uint16 graphicSetID)>>
        graphicSetRemoved;

    /** A graphic set's graphic at the given index was changed. */
    entt::sink<entt::sigh<void(GraphicSet::Type type, Uint16 graphicSetID,
                               std::size_t index, GraphicID newGraphicID)>>
        graphicSetSlotChanged;

    /** A graphic set's display name has changed. */
    entt::sink<entt::sigh<void(GraphicSet::Type type, Uint16 graphicSetID,
                               const std::string& newDisplayName)>>
        graphicSetDisplayNameChanged;
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/IconModel.h`:

```h
#pragma once

#include "EditorIconSheet.h"
#include "EditorIcon.h"
#include "IconID.h"
#include "IDPool.h"
#include "entt/signal/sigh.hpp"
#include "nlohmann/json_fwd.hpp"
#include <map>
#include <string>

struct SDL_Renderer;

namespace AM
{
namespace ResourceImporter
{

class DataModel;

/**
 * Holds data for icons and their parent icon sheets.
 */
class IconModel
{
public:
    IconModel(DataModel& inDataModel, SDL_Renderer* inSdlRenderer);

    /**
     * Attempts to load the "iconSheets" section of the given json into this
     * model.
     *
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool load(const nlohmann::json& json);

    /**
     * Saves the current state of this data model into the given json's
     * "iconSheets" section.
     */
    void save(nlohmann::json& json);

    /**
     * If the given data is valid, adds a new icon sheet to the back of the
     * iconSheets vector. All icons in the sheet will be extracted and
     * added to the sheet's icons vector.
     *
     * Note: We currently only support icon sheets with consistent icon
     *       sizes and no padding.
     *
     * @param relPath The path to the desired icon sheet, relative to
     *                the application's base directory.
     * @param iconWidth How wide each icon is.
     * @param iconHeight How tall each icon is.
     * @param baseName The name to prepend to each icon's number. (e.g.
     *                 "mob_" results in "mob_0", "mob_1", etc.)
     *
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool addIconSheet(const std::string& relPath, const std::string& iconWidth,
                      const std::string& iconHeight,
                      const std::string& baseName);

    /**
     * Removes the icon sheet with the given ID from the icon sheet map.
     *
     * Errors if the given ID isn't present in iconSheetMap.
     *
     * @param sheetID The editor ID of the sheet to remove.
     */
    void remIconSheet(int sheetID);

    /**
     * Removes the icon with the given ID from the icon map.
     *
     * Errors if the given ID isn't present in iconMap.
     *
     * @param iconID The editor ID of the icon to remove.
     */
    void remIcon(IconID iconID);

    const EditorIcon& getIcon(IconID iconID);

    // Icon properties.
    void setIconDisplayName(IconID iconID, const std::string& newDisplayName);

    /** Resets the model state, setting it back to default. */
    void resetModelState();

    const std::string& getErrorString();

private:
    /**
     * @param sheetJson The json to parse. Must be a valid icon sheet section
     *                  from ResourceData.json.
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool parseIconSheet(const nlohmann::json& sheetJson);
    /**
     * @param iconJson The json to parse. Must be a valid icon section
     *                 from ResourceData.json.
     * @param iconSheet The sheet that this icon is from.
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool parseIcon(const nlohmann::json& iconJson, EditorIconSheet& iconSheet);

    /**
     * Checks if the given name is unique among all icons in the model.
     *
     * @param iconID The ID of the icon that might get displayName. If it
     *               already is set to displayName, it won't be counted as
     *               non-unique.
     * @param displayName The display name that the icon will be set to.
     */
    bool iconNameIsUnique(IconID iconID, const std::string& displayName);

    DataModel& dataModel;

    /** Used for validating user-selected sprite sheet textures. */
    SDL_Renderer* sdlRenderer;

    /** Maps sheet IDs -> the icon sheets that we currently have loaded. */
    std::map<int, EditorIconSheet> iconSheetMap;

    /** Maps icon IDs -> the icons that we currently have loaded. */
    std::map<IconID, EditorIcon> iconMap;

    /** Used for generating temporary icon IDs that are only used internally
        by this editor. */
    IDPool sheetIDPool;
    IDPool iconIDPool;

    /** If one of our parsing functions returns false, this holds a string
        describing the error that occurred. */
    std::string errorString;

    //-------------------------------------------------------------------------
    // Signals
    //-------------------------------------------------------------------------
    entt::sigh<void(int sheetID, const EditorIconSheet& sheet)> sheetAddedSig;
    entt::sigh<void(int sheetID)> sheetRemovedSig;
    entt::sigh<void(IconID iconID)> iconRemovedSig;

    entt::sigh<void(IconID iconID, const std::string& newDisplayName)>
        iconDisplayNameChangedSig;

public:
    //-------------------------------------------------------------------------
    // Signal Sinks
    //-------------------------------------------------------------------------
    /** A icon sheet was added to the model. */
    entt::sink<entt::sigh<void(int sheetID, const EditorIconSheet& sheet)>>
        sheetAdded;
    /** A icon sheet was removed from the model. */
    entt::sink<entt::sigh<void(int sheetID)>> sheetRemoved;
    /** A icon was removed from the model. */
    entt::sink<entt::sigh<void(IconID iconID)>> iconRemoved;

    /** A icon's display name has changed. */
    entt::sink<
        entt::sigh<void(IconID iconID, const std::string& newDisplayName)>>
        iconDisplayNameChanged;
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/LibraryItemData.h`:

```h
#pragma once

#include "EditorSpriteSheet.h"
#include "EditorSprite.h"
#include "EditorAnimation.h"
#include "EditorTerrainGraphicSet.h"
#include "EditorFloorGraphicSet.h"
#include "EditorWallGraphicSet.h"
#include "EditorObjectGraphicSet.h"
#include "EditorEntityGraphicSet.h"
#include "EditorIcon.h"
#include "EditorBoundingBox.h"
#include <variant>

namespace AM
{
namespace ResourceImporter
{

/**
 * A generic way to reference the data associated with a LibraryListItem.
 *
 * This only includes the types that the user is able to double click to load
 * into the edit stage.
 *
 * Note: These pointers should never be null, you don't need to check them. 
 *       We just use them because std::reference_wrapper is 
 */
using LibraryItemData
    = std::variant<std::monostate, 
                   std::reference_wrapper<const EditorSpriteSheet>,
                   std::reference_wrapper<const EditorSprite>,
                   std::reference_wrapper<const EditorAnimation>,
                   std::reference_wrapper<const EditorBoundingBox>,
                   std::reference_wrapper<const EditorTerrainGraphicSet>,
                   std::reference_wrapper<const EditorFloorGraphicSet>,
                   std::reference_wrapper<const EditorWallGraphicSet>,
                   std::reference_wrapper<const EditorObjectGraphicSet>,
                   std::reference_wrapper<const EditorEntityGraphicSet>,
                   std::reference_wrapper<const EditorIcon>>;

// Note: We define these convenience functions because variant<reference_wrapper>
//       is very noisy otherwise.
template<typename T>
bool holds_alternative(const LibraryItemData& libraryItemData)
{
    return std::holds_alternative<std::reference_wrapper<const T>>(
        libraryItemData);
}

template <typename T>
const T& get(const LibraryItemData& libraryItemData)
{
    return std::get<std::reference_wrapper<const T>>(libraryItemData).get();
}

template <typename T>
const T* get_if(const LibraryItemData* libraryItemData)
{
    const auto* dataPtr{
        std::get_if<std::reference_wrapper<const T>>(libraryItemData)};
    if (dataPtr) {
        return &(dataPtr->get());
    }
    else {
        return nullptr;
    }
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/DataModel/Public/SpriteModel.h`:

```h
#pragma once

#include "EditorSpriteSheet.h"
#include "EditorSprite.h"
#include "SpriteSheetID.h"
#include "BoundingBox.h"
#include "IDPool.h"
#include "entt/signal/sigh.hpp"
#include "nlohmann/json_fwd.hpp"
#include <map>
#include <string>

struct SDL_Renderer;

namespace AM
{
namespace ResourceImporter
{

class DataModel;

/**
 * Holds data for sprites and their parent sprite sheets.
 */
class SpriteModel
{
public:
    SpriteModel(DataModel& inDataModel, SDL_Renderer* inSdlRenderer);

    /**
     * Attempts to load the "spriteSheets" section of the given json into this
     * model.
     *
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool load(const nlohmann::json& json);

    /**
     * Saves the current state of this data model into the given json's
     * "spriteSheets" section.
     */
    void save(nlohmann::json& json);

    /**
     * Generates images for each sprite sheet and saves them to the SpriteSheets
     * directory.
     */
    void exportSpriteSheetImages();

    /**
     * Adds a new empty sprite sheet and loads it.
     */
    bool addSpriteSheet();

    /**
     * Removes the sprite sheet with the given ID from the sprite sheet map.
     *
     * Errors if the given ID isn't present in spriteSheetMap.
     *
     * @param sheetID The editor ID of the sheet to remove.
     */
    void remSpriteSheet(SpriteSheetID sheetID);

    /**
     * Adds a sprite with the given image.
     * The sprite's name will be derived from its filename. If the name ends in
     * "_<n>", the new sprite will also be added to an Animation.
     *
     * @param imageRelPath The relative path to the sprite's individual image 
     *                     file.
     * @param parentSheetID The ID of the sprite's parent sprite sheet.
     * @param stageOriginX/Y Where the stage should begin, relative to the top 
     *                       left of the sprite image.
     * @param premultiplyAlpha If true, this sprite will have its alpha 
     *                         premultiplied.
     *
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool addSprite(const std::string& imageRelPath, SpriteSheetID parentSheetID,
                   const std::string& stageOriginX,
                   const std::string& stageOriginY, bool premultiplyAlpha);

    /**
     * Removes the sprite with the given ID from the sprite map.
     *
     * Errors if the given ID isn't present in spriteMap.
     *
     * @param spriteID The editor ID of the sprite to remove.
     */
    void remSprite(SpriteID spriteID);

    const EditorSpriteSheet& getSpriteSheet(SpriteSheetID sheetID) const;
    const EditorSprite& getSprite(SpriteID spriteID) const;

    // Sprite sheet properties.
    void setSpriteSheetDisplayName(SpriteSheetID spriteSheetID,
                                   const std::string& newDisplayName);

    // Sprite properties.
    // Note: We don't offer a setter for DisplayName because it should always 
    //       be based on the image filename.
    void setSpriteModelBoundsID(SpriteID spriteID,
                                BoundingBoxID newModelBoundsID);
    void setSpriteCustomModelBounds(SpriteID spriteID,
                                    const BoundingBox& newModelBounds);
    void setSpriteCollisionEnabled(SpriteID spriteID, bool newCollisionEnabled);
    void setSpriteStageOrigin(SpriteID spriteID,
                              const SDL_Point& newStageOrigin);
    void setSpritePremultiplyAlpha(SpriteID spriteID, bool newPremultiplyAlpha);

    /** Resets the model state, setting it back to default. */
    void resetModelState();

    const std::string& getErrorString();

private:
    // Note: These are named differently to disambiguate them, since they aren't 
    //       accessible outside of this class.
    EditorSpriteSheet& mgetSpriteSheet(SpriteSheetID sheetID);
    EditorSprite& mgetSprite(SpriteID spriteID);

    // Parsing functions.
    /**
     * @param sheetJson The json to parse. Must be a valid sprite sheet section
     *                  from ResourceData.json.
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool parseSpriteSheet(const nlohmann::json& sheetJson);
    /**
     * @param spriteJson The json to parse. Must be a valid sprite section
     *                   from ResourceData.json.
     * @param spriteSheet The sheet that this sprite is from.
     * @return true if successful. If false, getErrorString() will return more
     *         information.
     */
    bool parseSprite(const nlohmann::json& spriteJson,
                     EditorSpriteSheet& spriteSheet);

    /**
     * Checks if the given name is unique among all sprite sheets in the model.
     *
     * @param spriteSheetID The ID of the sprite sheet that might get 
     *                      displayName. If it already is set to displayName, 
     *                      it won't be counted as non-unique.
     * @param displayName The display name that the sprite will be set to.
     */
    bool spriteSheetNameIsUnique(SpriteSheetID spriteSheetID,
                                 const std::string& displayName);

    /**
     * Checks if the given name is unique among all sprites in the model.
     *
     * @param spriteID The ID of the sprite that might get displayName. If it
     *                 already is set to displayName, it won't be counted as
     *                 non-unique.
     * @param displayName The display name that the sprite will be set to.
     */
    bool spriteNameIsUnique(SpriteID spriteID, const std::string& displayName);

    /**
     * Sets the texture position of each sprite in the given sheet, and sets the 
     * sheet's size.
     */
    void refreshSpriteSheet(EditorSpriteSheet& spriteSheet);

    /**
     * If the given sprite is named such that it should be added to an 
     * animation, adds it. If the animation doesn't already exist, it will be 
     * created.
     */
    void addSpriteToAnimationIfNecessary(const EditorSprite& sprite);

    /**
     * If the given sprite is in an animation, removes it.
     */
    void remSpriteFromAnimationIfNecessary(const EditorSprite& sprite);

    /**
     * Returns a frame number from the end of the given sprite display name,
     * if one is present.
     * If the file name has no trailing frame number, returns -1.
     */
    int getFrameNumber(const std::string& displayName);

    /**
     * Derives an Animation display name from a given Sprite's display name by 
     * removing the trailing frame number.
     */
    std::string_view deriveAnimationName(std::string_view spriteDisplayName);

    DataModel& dataModel;

    /** Used for validating user-selected sprite sheet textures. */
    SDL_Renderer* sdlRenderer;

    /** Maps sheet IDs -> the sprite sheets that we currently have loaded. */
    std::map<SpriteSheetID, EditorSpriteSheet> spriteSheetMap;

    /** Maps sprite IDs -> the sprites that we currently have loaded. */
    std::map<SpriteID, EditorSprite> spriteMap;

    /** Maps sprite sheet names -> their ID. */
    std::unordered_map<std::string, SpriteSheetID> spriteSheetNameMap;

    /** Maps sprite names -> their ID. */
    std::unordered_map<std::string, SpriteID> spriteNameMap;

    /** Used for generating temporary sprite sheet IDs that are only used
        internally by this editor. */
    IDPool sheetIDPool;
    IDPool spriteIDPool;

    /** If one of our parsing functions returns false, this holds a string
        describing the error that occurred. */
    std::string errorString;

    //-------------------------------------------------------------------------
    // Signals
    //-------------------------------------------------------------------------
    entt::sigh<void(SpriteSheetID sheetID, const EditorSpriteSheet& sheet)>
        sheetAddedSig;
    entt::sigh<void(SpriteSheetID sheetID)> sheetRemovedSig;
    entt::sigh<void(SpriteID spriteID, const EditorSprite& sprite,
                    SpriteSheetID parentSheetID)>
        spriteAddedSig;
    entt::sigh<void(SpriteID spriteID, SpriteSheetID parentSheetID)>
        spriteRemovedSig;

    entt::sigh<void(SpriteSheetID spriteSheetID,
                    const std::string& newDisplayName)>
        spriteSheetDisplayNameChangedSig;

    entt::sigh<void(SpriteID spriteID, const std::string& newDisplayName)>
        spriteDisplayNameChangedSig;
    entt::sigh<void(SpriteID spriteID, BoundingBoxID newModelBoundsID)>
        spriteModelBoundsIDChangedSig;
    entt::sigh<void(SpriteID spriteID, const BoundingBox& newCustomModelBounds)>
        spriteCustomModelBoundsChangedSig;
    entt::sigh<void(SpriteID spriteID, bool newCollisionEnabled)>
        spriteCollisionEnabledChangedSig;
    entt::sigh<void(SpriteID spriteID, const SDL_Point& newStageOrigin)>
        spriteStageOriginChangedSig;
    entt::sigh<void(SpriteID spriteID, bool newPremultiplyAlpha)>
        spritePremultiplyAlphaChangedSig;

public:
    //-------------------------------------------------------------------------
    // Signal Sinks
    //-------------------------------------------------------------------------
    /** A sprite sheet was added to the model. */
    entt::sink<
        entt::sigh<void(SpriteSheetID sheetID, const EditorSpriteSheet& sheet)>>
        sheetAdded;
    /** A sprite sheet was removed from the model. */
    entt::sink<entt::sigh<void(SpriteSheetID sheetID)>> sheetRemoved;
    /** A sprite was added to from the model. */
    entt::sink<entt::sigh<void(SpriteID spriteID, const EditorSprite& sprite,
                               SpriteSheetID parentSheetID)>>
        spriteAdded;
    /** A sprite was removed from the model. */
    entt::sink<entt::sigh<void(SpriteID spriteID, SpriteSheetID parentSheetID)>>
        spriteRemoved;

    /** A sprite sheet's display name has changed. */
    entt::sink<entt::sigh<void(SpriteSheetID spriteSheetID,
                               const std::string& newDisplayName)>>
        spriteSheetDisplayNameChanged;

    /** A sprite's display name has changed. */
    entt::sink<
        entt::sigh<void(SpriteID spriteID, const std::string& newDisplayName)>>
        spriteDisplayNameChanged;
    /** A sprite's bounding box ID has changed. */
    entt::sink<
        entt::sigh<void(SpriteID spriteID, BoundingBoxID newModelBoundsID)>>
        spriteModelBoundsIDChanged;
    /** A sprite's custom bounding box has changed. */
    entt::sink<entt::sigh<void(SpriteID spriteID,
                               const BoundingBox& newCustomModelBounds)>>
        spriteCustomModelBoundsChanged;
    /** A sprite's "collision enabled" field has changed. */
    entt::sink<entt::sigh<void(SpriteID spriteID, bool newCollisionEnabled)>>
        spriteCollisionEnabledChanged;
    /** A sprite's stage origin has changed. */
    entt::sink<
        entt::sigh<void(SpriteID spriteID, const SDL_Point& newStageOrigin)>>
        spriteStageOriginChanged;
    /** A sprite's "premultiply alpha" field has changed. */
    entt::sink<entt::sigh<void(SpriteID spriteID, bool newPremultiplyAlpha)>>
        spritePremultiplyAlphaChanged;
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/DataModel/Public/SpriteSheetID.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/** A sprite sheet's numeric ID. */
using SpriteSheetID = Uint32;

/**
 * The ID of the "null sprite sheet", or the ID used to indicate that a sprite 
 * sheet is not present.
 *
 * Note: Since the null ID is 0, you can do null checks like 
 *       "if (spriteSheetID)".
 */
static constexpr SpriteSheetID NULL_SPRITE_SHEET_ID{0};

} // End namespace AM

```

`Source/ResourceImporter/Launch/CMakeLists.txt`:

```txt
target_sources(ResourceImporter
    PRIVATE
        Private/main.cpp
        Private/Application.cpp
    PUBLIC
        Public/Application.h
)

target_include_directories(ResourceImporter
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ResourceImporter/Launch/Private/Application.cpp`:

```cpp
#include "Application.h"
#include "Config.h"
#include "Paths.h"
#include "SDLHelpers.h"
#include "Log.h"

#include <SDL.h>
#include "nfd.hpp"

#include <memory>
#include <functional>

namespace AM
{
namespace ResourceImporter
{
Application::Application()
: sdl{SDL_INIT_VIDEO}
, sdlWindow{"Amalgam Engine Resource Importer",
            SDL_WINDOWPOS_UNDEFINED,
            SDL_WINDOWPOS_UNDEFINED,
            Config::ACTUAL_SCREEN_WIDTH,
            Config::ACTUAL_SCREEN_HEIGHT,
            SDL_WINDOW_SHOWN}
, sdlRenderer{sdlWindow.get(), -1, SDL_RENDERER_ACCELERATED}
, assetCache{sdlRenderer.get()}
, dataModel{sdlRenderer.get()}
, userInterface{sdlRenderer.get(), assetCache, dataModel}
, uiCaller{std::bind_front(&UserInterface::tick, &userInterface),
           Config::UI_TICK_TIMESTEP_S, "UserInterface", true}
, renderer{sdlRenderer.get(), userInterface}
, rendererCaller{std::bind_front(&Renderer::render, &renderer),
                 Renderer::FRAME_TIMESTEP_S, "Renderer", true}
, eventHandlers{this, &userInterface, &renderer}
, exitRequested{false}
{
    // Initialize the global timer.
    Timer::getGlobalTime();

    // Initialize nativefiledialog.
    if (NFD_Init() != NFD_OKAY) {
        LOG_FATAL("Nativefiledialog failed to initialize properly.");
    }

    // Set fullscreen mode.
    switch (Config::FULLSCREEN_MODE) {
        case 0:
            SDLHelpers::setWindowFullscreen(sdlWindow.get(), 0);
            break;
        case 1:
            SDLHelpers::setWindowFullscreen(sdlWindow.get(),
                                            SDL_WINDOW_FULLSCREEN);
            break;
        case 2:
            SDLHelpers::setWindowFullscreen(sdlWindow.get(),
                                            SDL_WINDOW_FULLSCREEN_DESKTOP);
            break;
        default:
            LOG_FATAL("Invalid fullscreen value: %d", Config::FULLSCREEN_MODE);
    }

    // Set up our event filter.
    SDL_SetEventFilter(&Application::filterEvents, this);
}

Application::~Application()
{
    // De-initialize nativefiledialog.
    NFD_Quit();
}

void Application::start()
{
    // Prime the timers so they don't start at 0.
    rendererCaller.initTimer();
    uiCaller.initTimer();
    while (!exitRequested) {
        // Let the renderer render if it needs to.
        rendererCaller.update();

        // Let the UI widgets tick if they need to.
        uiCaller.update();

        // If we have enough time, dispatch events.
        if (enoughTimeTillNextCall(DISPATCH_MINIMUM_TIME_S)) {
            dispatchEvents();
        }

        // If we have enough time, sleep.
        if (enoughTimeTillNextCall(SLEEP_MINIMUM_TIME_S)) {
            // We have enough time to sleep for a few ms.
            // Note: We try to delay for 1ms because the OS will generally end
            //       up delaying us for 1-3ms.
            SDL_Delay(1);
        }
    }
}

bool Application::handleOSEvent(SDL_Event& event)
{
    switch (event.type) {
        case SDL_QUIT:
            exitRequested = true;
            return true;
    }

    return false;
}

void Application::dispatchEvents()
{
    // Dispatch all waiting SDL events.
    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        // Pass the event to each handler in order, stopping if it returns as
        // handled.
        for (OSEventHandler* handler : eventHandlers) {
            if (handler->handleOSEvent(event)) {
                break;
            }
        }
    }
}

bool Application::enoughTimeTillNextCall(double minimumTime)
{
    if ((uiCaller.getTimeTillNextCall() > minimumTime)
        && (rendererCaller.getTimeTillNextCall() > minimumTime)) {
        return true;
    }
    else {
        return false;
    }
}

int Application::filterEvents(void*, SDL_Event*)
{
    //Application* app{static_cast<Application*>(userData)};

    // Currently no events that we care to filter.
    //
    // switch (event->type) {
    // }

    return 1;
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/Launch/Private/main.cpp`:

```cpp
#include "Log.h"
#include "Application.h"

#include <exception>

using namespace AM;
using namespace AM::ResourceImporter;

// SDL2 needs this signature for main, but we don't use the parameters.
int main(int, char**)
try {
    // Set up file logging.
    Log::enableFileLogging("ResourceImporter.log");

    // Start the application (assumes control of the thread).
    Application app;
    app.start();

    return 0;
}  catch (std::exception& e) {
    LOG_INFO("%s", e.what());
    return 1;
}

```

`Source/ResourceImporter/Launch/Public/Application.h`:

```h
#pragma once

#include "OSEventHandler.h"
#include "UserInterface.h"
#include "Renderer.h"
#include "PeriodicCaller.h"
#include "DataModel.h"
#include "AssetCache.h"

#include "SDL_Wrappers/SDL.h"
#include "SDL_Wrappers/SDLWindow.h"
#include "SDL_Wrappers/SDLRenderer.h"

#include <string>
#include <atomic>

namespace AM
{
namespace ResourceImporter
{
/**
 * Maintains the lifetime of all app modules and manages the main thread's
 * loop.
 */
class Application : public OSEventHandler
{
public:
    Application();

    ~Application();

    /**
     * Begins the application. Assumes control of the thread until the
     * application exits.
     */
    void start();

    /**
     * Handles application-relevant events, such as exit requests.
     */
    bool handleOSEvent(SDL_Event& event) override;

private:
    /** The minimum "time to next call" required to trigger an event dispatch.
        Event polling can take up to 5-6ms depending on how much is waiting.
        We prioritize the PeriodicCallers getting called on time, so we only
        dispatch events if there's a reasonable gap until the next needs to be
        called. */
    static constexpr double DISPATCH_MINIMUM_TIME_S{.003};

    /** The minimum "time to next call" required to trigger a main loop sleep.
        We sleep for 1ms when possible to reduce our CPU usage. We can't trust
        the scheduler to come back to us after exactly 1ms though, so we busy
        wait if something needs to be called soon.
        Higher value == more CPU usage. */
    static constexpr double SLEEP_MINIMUM_TIME_S{.003};

    /**
     * Dispatches waiting events to the eventHandlers.
     * Events are propagated through the vector in order, starting at index 0.
     * If an event is handled (handleOSEvent() returns true), propagation stops.
     */
    void dispatchEvents();

    /**
     * Returns true if all PeriodicCallers have at least minimumTime left until
     * their next call. Else, false.
     */
    bool enoughTimeTillNextCall(double minimumTime);

    /**
     * Used to filter events before they arrive in the SDL event queue.
     *
     * Called asynchronously when SDL_PumpEvents is called (during
     * SDL_PollEvent). May run on a different core.
     */
    static int filterEvents(void* userData, SDL_Event* event);

    SDL sdl;

    SDLWindow sdlWindow;

    /** The SDL renderer that we use to render the UI and world.
        We use SDLRenderer for convenience of initialization here, but
        all other parts of the engine directly use SDL_Renderer (so that we
        can use SDL_Texture, which is better for the AssetCache.) */
    SDLRenderer sdlRenderer;

    /** The application's asset cache. Used for caching textures. */
    AssetCache assetCache;

    /** The data model that holds the user's project data. */
    DataModel dataModel;

    UserInterface userInterface;
    /** Calls userInterface.tick() at our UI tick rate. */
    PeriodicCaller uiCaller;

    Renderer renderer;
    /** Calls renderer.render() at our frame rate. */
    PeriodicCaller rendererCaller;

    /** An ordered vector of event handlers. */
    std::vector<OSEventHandler*> eventHandlers;

    /** True if there has been a request to exit the program, else false. */
    std::atomic<bool> exitRequested;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/Renderer/CMakeLists.txt`:

```txt
target_sources(ResourceImporter
    PRIVATE
        Private/Renderer.cpp
    PUBLIC
        Public/Renderer.h
)

target_include_directories(ResourceImporter
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
		${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ResourceImporter/Renderer/Private/Renderer.cpp`:

```cpp
#include "Renderer.h"
#include "UserInterface.h"
#include "Log.h"
#include <SDL_render.h>
#include <SDL2_gfxPrimitives.h>

namespace AM
{
namespace ResourceImporter
{
Renderer::Renderer(SDL_Renderer* inSdlRenderer, UserInterface& inUI)
: sdlRenderer{inSdlRenderer}
, ui{inUI}
{
}

void Renderer::render()
{
    /* Render. */
    // Clear the current rendering target to prepare for rendering.
    SDL_RenderClear(sdlRenderer);

    // Render the current UI screen.
    ui.render();

    // Present the finished back buffer to the user's screen.
    SDL_RenderPresent(sdlRenderer);
}

bool Renderer::handleOSEvent(SDL_Event& event)
{
    switch (event.type) {
        case SDL_WINDOWEVENT:
            // TODO: Handle this.
            return true;
    }

    return false;
}

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/Renderer/Public/Renderer.h`:

```h
#pragma once

#include "OSEventHandler.h"
#include "PeriodicCaller.h"

struct SDL_Renderer;

namespace AM
{
namespace ResourceImporter
{
class UserInterface;

/**
 * Renders the UI.
 */
class Renderer : public OSEventHandler
{
public:
    static constexpr unsigned int FRAMES_PER_SECOND{60};
    static constexpr double FRAME_TIMESTEP_S{
        1.0 / static_cast<double>(FRAMES_PER_SECOND)};

    Renderer(SDL_Renderer* inSdlRenderer, UserInterface& inUI);

    /**
     * Renders the UI.
     */
    void render();

    /**
     * Handles window events.
     */
    bool handleOSEvent(SDL_Event& event) override;

private:
    SDL_Renderer* sdlRenderer;

    /** Used to begin the UI rendering. */
    UserInterface& ui;
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/UserInterface/CMakeLists.txt`:

```txt
target_sources(ResourceImporter
    PRIVATE
        Private/Widgets/AnimationElementsListItem.cpp
        Private/Widgets/AnimationTimeline.cpp
        Private/Widgets/BoundingBoxGizmo.cpp
        Private/Widgets/GraphicSetSlot.cpp
        Private/Widgets/LibraryCollapsibleContainer.cpp
        Private/Widgets/LibraryListItem.cpp
        Private/Widgets/MainButton.cpp
        Private/Widgets/MainTextInput.cpp
        Private/Widgets/MainThumbnail.cpp
        Private/Widgets/ParentListItem.cpp
        Private/Widgets/PointGizmo.cpp
        Private/Widgets/StageGraphic.cpp
        Private/Widgets/TimelineFrame.cpp
        Private/Widgets/TimelineHandle.cpp
        Private/Widgets/TitleButton.cpp
        Private/Windows/AddIconSheetDialog.cpp
        Private/Windows/AddSpriteDialog.cpp
        Private/Windows/AnimationEditView.cpp
        Private/Windows/AnimationElementsWindow.cpp
        Private/Windows/AnimationPropertiesWindow.cpp
        Private/Windows/BoundingBoxEditView.cpp
        Private/Windows/BoundingBoxPropertiesWindow.cpp
        Private/Windows/EntityGraphicSetEditView.cpp
        Private/Windows/EntityGraphicSetPropertiesWindow.cpp
        Private/Windows/GraphicSetEditView.cpp
        Private/Windows/GraphicSetPropertiesWindow.cpp
        Private/Windows/HamburgerButtonWindow.cpp
        Private/Windows/HamburgerMenu.cpp
        Private/Windows/IconEditView.cpp
        Private/Windows/IconPropertiesWindow.cpp
        Private/Windows/LibraryAddMenu.cpp
        Private/Windows/LibraryWindow.cpp
        Private/Windows/SaveBoundingBoxDialog.cpp
        Private/Windows/SpriteEditView.cpp
        Private/Windows/SpritePropertiesWindow.cpp
        Private/Windows/SpriteSheetEditView.cpp
        Private/Windows/SpriteSheetPropertiesWindow.cpp
        Private/Windows/TitleWindow.cpp
        Private/MainScreen.cpp
        Private/TitleScreen.cpp
        Private/UserInterface.cpp
    PUBLIC
        Public/Widgets/AnimationElementsListItem.h
        Public/Widgets/AnimationTimeline.h
        Public/Widgets/BoundingBoxGizmo.h
        Public/Widgets/GraphicSetSlot.h
        Public/Widgets/LibraryCollapsibleContainer.h
        Public/Widgets/LibraryListItem.h
        Public/Widgets/MainButton.h
        Public/Widgets/MainTextInput.h
        Public/Widgets/MainThumbnail.h
        Public/Widgets/ParentListItem.h
        Public/Widgets/PointGizmo.h
        Public/Widgets/StageGraphic.h
        Public/Widgets/TimelineFrame.h
        Public/Widgets/TimelineHandle.h
        Public/Widgets/TitleButton.h
        Public/Windows/AddIconSheetDialog.h
        Public/Windows/AddSpriteDialog.h
        Public/Windows/AnimationEditView.h
        Public/Windows/AnimationElementsWindow.h
        Public/Windows/AnimationPropertiesWindow.h
        Public/Windows/BoundingBoxEditView.h
        Public/Windows/BoundingBoxPropertiesWindow.h
        Public/Windows/EntityGraphicSetEditView.h
        Public/Windows/EntityGraphicSetPropertiesWindow.h
        Public/Windows/GraphicSetEditView.h
        Public/Windows/GraphicSetPropertiesWindow.h
        Public/Windows/HamburgerButtonWindow.h
        Public/Windows/HamburgerMenu.h
        Public/Windows/IconEditView.h
        Public/Windows/IconPropertiesWindow.h
        Public/Windows/LibraryAddMenu.h
        Public/Windows/LibraryWindow.h
        Public/Windows/SaveBoundingBoxDialog.h
        Public/Windows/SpriteEditView.h
        Public/Windows/SpritePropertiesWindow.h
        Public/Windows/SpriteSheetEditView.h
        Public/Windows/SpriteSheetPropertiesWindow.h
        Public/Windows/TitleWindow.h
        Public/MainScreen.h
        Public/TitleScreen.h
        Public/UserInterface.h
)

target_include_directories(ResourceImporter
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/Widgets
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/Windows
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/Widgets
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/Windows
)

```

`Source/ResourceImporter/UserInterface/Private/MainScreen.cpp`:

```cpp
#include "MainScreen.h"
#include "DataModel.h"
#include "Paths.h"
#include "AUI/Core.h"
#include "nfd.h"
#include "Log.h"

namespace AM
{
namespace ResourceImporter
{
MainScreen::MainScreen(DataModel& inDataModel)
: AUI::Screen("MainScreen")
, dataModel{inDataModel}
, libraryWindow{*this, dataModel}
, spriteSheetEditView{dataModel}
, boundingBoxEditView{dataModel, libraryWindow}
, spriteEditView{dataModel}
, animationElementsWindow{*this, dataModel}
, animationEditView{dataModel, libraryWindow, animationElementsWindow}
, iconEditView{dataModel}
, graphicSetEditView{dataModel, libraryWindow}
, entityGraphicSetEditView{dataModel, libraryWindow}
, spriteSheetPropertiesWindow{*this, dataModel}
, boundingBoxPropertiesWindow{dataModel, libraryWindow}
, spritePropertiesWindow{*this, dataModel, libraryWindow}
, animationPropertiesWindow{*this, dataModel, libraryWindow}
, graphicSetPropertiesWindow{dataModel}
, entityGraphicSetPropertiesWindow{dataModel}
, iconPropertiesWindow{dataModel}
, libraryAddMenu{}
, hamburgerButtonWindow{*this}
, hamburgerMenu{}
, confirmationDialog{{0, 0, 1920, 1080}, "ConfirmationDialog"}
, addSpriteDialog{*this, dataModel}
, addIconSheetDialog{dataModel}
, saveBoundingBoxDialog{dataModel}
{
    // Add our windows so they're included in rendering, etc.
    windows.push_back(libraryWindow);
    windows.push_back(spriteSheetEditView);
    windows.push_back(spriteSheetEditView);
    windows.push_back(boundingBoxEditView);
    windows.push_back(spriteEditView);
    windows.push_back(animationElementsWindow);
    windows.push_back(animationEditView);
    windows.push_back(graphicSetEditView);
    windows.push_back(entityGraphicSetEditView);
    windows.push_back(iconEditView);
    windows.push_back(spriteSheetPropertiesWindow);
    windows.push_back(boundingBoxPropertiesWindow);
    windows.push_back(spritePropertiesWindow);
    windows.push_back(animationPropertiesWindow);
    windows.push_back(graphicSetPropertiesWindow);
    windows.push_back(entityGraphicSetPropertiesWindow);
    windows.push_back(iconPropertiesWindow);
    windows.push_back(libraryAddMenu);
    windows.push_back(hamburgerButtonWindow);
    windows.push_back(hamburgerMenu);
    windows.push_back(confirmationDialog);
    windows.push_back(addSpriteDialog);
    windows.push_back(addIconSheetDialog);
    windows.push_back(saveBoundingBoxDialog);

    /* Confirmation dialog. */
    // Background shadow image.
    confirmationDialog.shadowImage.setLogicalExtent({0, 0, 1920, 1080});
    confirmationDialog.shadowImage.setSimpleImage(Paths::TEXTURE_DIR
                                                  + "Dialogs/Shadow.png");

    // Background image.
    confirmationDialog.backgroundImage.setLogicalExtent({710, 370, 500, 300});
    confirmationDialog.backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});

    // Body text.
    confirmationDialog.bodyText.setLogicalExtent({734, 390, 426, 132});
    confirmationDialog.bodyText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"),
                                        20);
    confirmationDialog.bodyText.setColor({255, 255, 255, 255});

    // Buttons.
    auto styleDialogButton = [&](AUI::Button& button, const SDL_Rect& logicalExtent) {
        button.setLogicalExtent(logicalExtent);
        SDL_Rect imageExtent{0, 0, logicalExtent.w, logicalExtent.h};
        button.normalImage.setLogicalExtent(imageExtent);
        button.hoveredImage.setLogicalExtent(imageExtent);
        button.pressedImage.setLogicalExtent(imageExtent);
        button.text.setLogicalExtent({-1, -1, logicalExtent.w, logicalExtent.h});
        button.normalImage.setNineSliceImage(
            Paths::TEXTURE_DIR + "MainButton/Normal.png", {4, 4, 4, 4});
        button.hoveredImage.setNineSliceImage(
            Paths::TEXTURE_DIR + "MainButton/Hovered.png", {4, 4, 4, 4});
        button.pressedImage.setNineSliceImage(
            Paths::TEXTURE_DIR + "MainButton/Pressed.png", {4, 4, 4, 4});
        button.text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
        button.text.setColor({255, 255, 255, 255});
    };
    styleDialogButton(confirmationDialog.confirmButton, {1074, 604, 120, 50});
    styleDialogButton(confirmationDialog.cancelButton, {940, 604, 120, 50});
    confirmationDialog.cancelButton.text.setText("Cancel");

    // Set up the dialog's cancel button callback.
    confirmationDialog.cancelButton.setOnPressed([this]() {
        // Close the dialog.
        confirmationDialog.setIsVisible(false);
    });

    /* Library add menu. */
    libraryAddMenu.addSpriteSheetButton.setOnPressed([this]() {
        dataModel.spriteModel.addSpriteSheet();
        dropFocus();
    });
    libraryAddMenu.addTerrainButton.setOnPressed([this]() {
        dataModel.graphicSetModel.addTerrain();
        dropFocus();
    });
    libraryAddMenu.addFloorButton.setOnPressed([this]() {
        dataModel.graphicSetModel.addFloor();
        dropFocus();
    });
    libraryAddMenu.addWallButton.setOnPressed([this]() {
        dataModel.graphicSetModel.addWall();
        dropFocus();
    });
    libraryAddMenu.addObjectButton.setOnPressed([this]() {
        dataModel.graphicSetModel.addObject();
        dropFocus();
    });
    libraryAddMenu.addEntityButton.setOnPressed([this]() {
        dataModel.entityGraphicSetModel.addEntity();
        dropFocus();
    });
    libraryAddMenu.addIconSheetButton.setOnPressed([this]() {
        addIconSheetDialog.setIsVisible(true);
        dropFocus();
    });

    /* Hamburger menu. */
    hamburgerMenu.saveButton.setOnPressed([this]() {
        openConfirmationDialog("Save over existing ResourceData.json?", "Save",
                               [&]() { dataModel.save(); });
        dropFocus();
    });
    hamburgerMenu.exportButton.setOnPressed([this]() {
        openConfirmationDialog(
            "This will export sprite sheet image files into the SpriteSheets "
            "directory, overwriting any files currently present.\n\nProceed?",
            "Export",
            [&]() { dataModel.spriteModel.exportSpriteSheetImages(); });
        dropFocus();
    });

    // Make the modal dialogs invisible.
    libraryAddMenu.setIsVisible(false);
    hamburgerMenu.setIsVisible(false);
    confirmationDialog.setIsVisible(false);
    addSpriteDialog.setIsVisible(false);
    addIconSheetDialog.setIsVisible(false);
    saveBoundingBoxDialog.setIsVisible(false);

    // Make the edit stages and properties windows invisible
    spriteSheetEditView.setIsVisible(false);
    spriteSheetPropertiesWindow.setIsVisible(false);
    boundingBoxEditView.setIsVisible(false);
    boundingBoxPropertiesWindow.setIsVisible(false);
    spriteEditView.setIsVisible(false);
    spritePropertiesWindow.setIsVisible(false);
    animationElementsWindow.setIsVisible(false);
    animationEditView.setIsVisible(false);
    animationPropertiesWindow.setIsVisible(false);
    graphicSetEditView.setIsVisible(false);
    graphicSetPropertiesWindow.setIsVisible(false);
    entityGraphicSetEditView.setIsVisible(false);
    entityGraphicSetPropertiesWindow.setIsVisible(false);
    iconEditView.setIsVisible(false);
    iconPropertiesWindow.setIsVisible(false);

    // When the user selects a new item in the library, make the proper windows
    // visible.
    dataModel.activeLibraryItemChanged
        .connect<&MainScreen::onActiveLibraryItemChanged>(*this);
}

void MainScreen::openConfirmationDialog(
    const std::string& bodyText, const std::string& confirmButtonText,
    std::function<void(void)> onConfirmation)
{
    // Set the dialog's text and make sure the cancel button is visible.
    confirmationDialog.bodyText.setText(bodyText);
    confirmationDialog.confirmButton.text.setText(confirmButtonText);
    confirmationDialog.cancelButton.setIsVisible(true);

    // Set the dialog's confirmation callback.
    userOnConfirmation = std::move(onConfirmation);
    confirmationDialog.confirmButton.setOnPressed([&]() {
        // Call the user's callback.
        userOnConfirmation();

        // Close the dialog.
        confirmationDialog.setIsVisible(false);
    });

    // Open the dialog.
    confirmationDialog.setIsVisible(true);
}

void MainScreen::openErrorDialog(const std::string& bodyText)
{
    // Note: We just repurpose the confirmationDialog by hiding the cancel 
    //       button and using the confirm button to cancel.

    // Hide the "Cancel" button and repurpose the "Confirm" button for closing.
    confirmationDialog.cancelButton.setIsVisible(false);
    confirmationDialog.confirmButton.text.setText("Okay");
    confirmationDialog.confirmButton.setOnPressed([&]() {
        // Close the dialog.
        confirmationDialog.setIsVisible(false);
    });

    // Set the dialog's text.
    confirmationDialog.bodyText.setText(bodyText);

    // Open the dialog.
    confirmationDialog.setIsVisible(true);
}

void MainScreen::openSaveBoundingBoxDialog(
    const BoundingBox& modelBoundsToSave,
    std::function<void(BoundingBoxID)> saveCallback)
{
    saveBoundingBoxDialog.setSaveData(modelBoundsToSave,
                                      std::move(saveCallback));
    saveBoundingBoxDialog.setIsVisible(true);
}

void MainScreen::openLibraryAddMenu()
{
    // If the menu isn't already open.
    if (!libraryAddMenu.getIsVisible()) {
        // Open the menu and focus it, so it can close itself if necessary.
        libraryAddMenu.setIsVisible(true);
        setFocusAfterNextLayout(&libraryAddMenu);
    }
}

void MainScreen::openHamburgerMenu()
{
    // If the menu isn't already open.
    if (!hamburgerMenu.getIsVisible()) {
        // Open the menu and focus it, so it can close itself if necessary.
        hamburgerMenu.setIsVisible(true);
        setFocusAfterNextLayout(&hamburgerMenu);
    }
}

void MainScreen::openAddSpriteDialog(
    const std::vector<std::string>& spriteImageRelPaths)
{
    // Pass the vector through and open the dialog.
    addSpriteDialog.setSpriteImageRelPaths(spriteImageRelPaths);
    addSpriteDialog.setIsVisible(true);
}

void MainScreen::render()
{
    // Fill the background with the background color.
    SDL_Renderer* renderer{AUI::Core::getRenderer()};
    SDL_SetRenderDrawColor(renderer, 35, 35, 38, 255);
    SDL_RenderClear(renderer);

    // Update our child widget's layouts and render them.
    Screen::render();
}

void MainScreen::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Make everything invisible.
    spriteSheetEditView.setIsVisible(false);
    spriteSheetPropertiesWindow.setIsVisible(false);
    boundingBoxEditView.setIsVisible(false);
    boundingBoxPropertiesWindow.setIsVisible(false);
    spriteEditView.setIsVisible(false);
    spritePropertiesWindow.setIsVisible(false);
    animationElementsWindow.setIsVisible(false);
    animationEditView.setIsVisible(false);
    animationPropertiesWindow.setIsVisible(false);
    graphicSetEditView.setIsVisible(false);
    graphicSetPropertiesWindow.setIsVisible(false);
    entityGraphicSetEditView.setIsVisible(false);
    entityGraphicSetPropertiesWindow.setIsVisible(false);
    iconEditView.setIsVisible(false);
    iconPropertiesWindow.setIsVisible(false);

    // Make the appropriate windows visible, based on the new item's type.
    if (holds_alternative<EditorSpriteSheet>(newActiveItem)) {
        spriteSheetEditView.setIsVisible(true);
        spriteSheetPropertiesWindow.setIsVisible(true);
    }
    else if (holds_alternative<EditorBoundingBox>(newActiveItem)) {
        boundingBoxEditView.setIsVisible(true);
        boundingBoxPropertiesWindow.setIsVisible(true);
    }
    else if (holds_alternative<EditorSprite>(newActiveItem)) {
        spriteEditView.setIsVisible(true);
        spritePropertiesWindow.setIsVisible(true);
    }
    else if (holds_alternative<EditorAnimation>(newActiveItem)) {
        animationElementsWindow.setIsVisible(true);
        animationEditView.setIsVisible(true);
        animationPropertiesWindow.setIsVisible(true);
    }
    else if (holds_alternative<EditorEntityGraphicSet>(newActiveItem)) {
        entityGraphicSetEditView.setIsVisible(true);
        entityGraphicSetPropertiesWindow.setIsVisible(true);
    }
    else if (holds_alternative<EditorIcon>(newActiveItem)) {
        iconEditView.setIsVisible(true);
        iconPropertiesWindow.setIsVisible(true);
    }
    else {
        // The new active item is a non-entity graphic set.
        graphicSetEditView.setIsVisible(true);
        graphicSetPropertiesWindow.setIsVisible(true);
    }
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/TitleScreen.cpp`:

```cpp
#include "TitleScreen.h"
#include "UserInterface.h"
#include "AUI/Core.h"

namespace AM
{
namespace ResourceImporter
{
TitleScreen::TitleScreen(UserInterface& inUserInterface, DataModel& inDataModel)
: AUI::Screen("TitleScreen")
, titleWindow{inUserInterface, inDataModel}
{
    // Add our windows so they're included in rendering, etc.
    windows.push_back(titleWindow);
}

void TitleScreen::render()
{
    // Fill the background with the background color.
    SDL_Renderer* renderer{AUI::Core::getRenderer()};
    SDL_SetRenderDrawColor(renderer, 37, 37, 52, 255);
    SDL_RenderClear(renderer);

    // Update our window's layouts and render them.
    Screen::render();
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/UserInterface.cpp`:

```cpp
#include "UserInterface.h"
#include "AssetCache.h"
#include "Config.h"
#include "AUI/Core.h"
#include "Log.h"

namespace AM
{
namespace ResourceImporter
{
UserInterface::UserInterface(SDL_Renderer* inRenderer, AssetCache&,
                             DataModel& inDataModel)
: auiInitializer{inRenderer,
                 {Config::LOGICAL_SCREEN_WIDTH, Config::LOGICAL_SCREEN_HEIGHT},
                 {Config::ACTUAL_SCREEN_WIDTH, Config::ACTUAL_SCREEN_HEIGHT}}
, titleScreen{*this, inDataModel}
, mainScreen{inDataModel}
, currentScreen{&titleScreen}
{
}

void UserInterface::changeScreenTo(ScreenType screenType)
{
    switch (screenType) {
        case ScreenType::TitleScreen: {
            currentScreen = &titleScreen;
            break;
        }
        case ScreenType::MainScreen: {
            currentScreen = &mainScreen;
            break;
        }
        default: {
            currentScreen = &titleScreen;
            break;
        }
    }
}

void UserInterface::tick(double timestepS)
{
    // Let AUI process the next tick.
    currentScreen->tick(timestepS);
}

void UserInterface::render()
{
    if (currentScreen != nullptr) {
        currentScreen->render();
    }
}

bool UserInterface::handleOSEvent(SDL_Event& event)
{
    return currentScreen->handleOSEvent(event);
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/AnimationElementsListItem.cpp`:

```cpp
#include "AnimationElementsListItem.h"
#include "Paths.h"
#include "AUI/Text.h"

namespace AM
{
namespace ResourceImporter
{
AnimationElementsListItem::AnimationElementsListItem(
    const SDL_Rect& inLogicalExtent, const std::string& inText,
    const std::string& inDebugName)
: AUI::Widget(inLogicalExtent, inDebugName)
, hoveredImage({0, 0, logicalExtent.w, logicalExtent.h})
, selectedImage({0, 0, logicalExtent.w, logicalExtent.h})
, text({0, 0, logicalExtent.w, logicalExtent.h})
, currentState{State::Normal}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(hoveredImage);
    children.push_back(selectedImage);
    children.push_back(text);

    // Add our backgrounds.
    hoveredImage.setSimpleImage(Paths::TEXTURE_DIR + "Highlights/Hovered.png");
    selectedImage.setSimpleImage(Paths::TEXTURE_DIR
                                 + "Highlights/Selected.png");

    // Set our text properties.
    text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    text.setColor({255, 255, 255, 255});
    text.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    text.setText(inText);
    setLeftPadding(12);

    // Make the images we aren't using invisible.
    hoveredImage.setIsVisible(false);
    selectedImage.setIsVisible(false);
}

void AnimationElementsListItem::enable()
{
    SDL_Point cursorPosition{};
    SDL_GetMouseState(&(cursorPosition.x), &(cursorPosition.y));
    cursorPosition.x -= clippedExtent.x;
    cursorPosition.y -= clippedExtent.y;

    // Check if we're currently hovered.
    if (containsPoint(cursorPosition)) {
        setCurrentState(State::Hovered);
    }
    else {
        setCurrentState(State::Normal);
    }
}

void AnimationElementsListItem::disable()
{
    setCurrentState(State::Disabled);
}

void AnimationElementsListItem::select()
{
    // If we are already selected, do nothing.
    if (currentState == State::Selected) {
        return;
    }

    // Flag that we're now selected.
    setCurrentState(State::Selected);

    // If the user set a callback for this event, call it.
    if (onSelected) {
        onSelected(this);
    }
}

void AnimationElementsListItem::deselect()
{
    // If we aren't selected, do nothing.
    if (currentState != State::Selected) {
        return;
    }

    // A different list item must have been selected, so we know that we 
    // aren't hovered. Go to normal.
    setCurrentState(State::Normal);

    // If the user set a callback for this event, call it.
    if (onDeselected) {
        onDeselected(this);
    }
}

AnimationElementsListItem::State
    AnimationElementsListItem::getCurrentState() const
{
    return currentState;
}

void AnimationElementsListItem::setLeftPadding(int inLeftPadding)
{
    text.setLogicalExtent(
        {inLeftPadding, 0, (logicalExtent.w - inLeftPadding), logicalExtent.h});
}

void AnimationElementsListItem::setOnSelected(
    std::function<void(AnimationElementsListItem*)> inOnSelected)
{
    onSelected = std::move(inOnSelected);
}

void AnimationElementsListItem::setOnDeselected(
    std::function<void(AnimationElementsListItem*)> inOnDeselected)
{
    onDeselected = std::move(inOnDeselected);
}

AUI::EventResult AnimationElementsListItem::onMouseDown(AUI::MouseButtonType buttonType,
                                              const SDL_Point&)
{
    // Only respond to the left mouse button.
    if (buttonType != AUI::MouseButtonType::Left) {
        return AUI::EventResult{.wasHandled{false}};
    }
    // If we're disabled, ignore the event.
    else if (currentState == State::Disabled) {
        return AUI::EventResult{.wasHandled{false}};
    }

    // If we aren't already selected, select this widget.
    if (currentState != State::Selected) {
        select();
    }

    return AUI::EventResult{.wasHandled{true}};
}

AUI::EventResult AnimationElementsListItem::onMouseDoubleClick(
    AUI::MouseButtonType buttonType, const SDL_Point& cursorPosition)
{
    // We treat additional clicks as regular MouseDown events.
    return onMouseDown(buttonType, cursorPosition);
}

void AnimationElementsListItem::onMouseEnter()
{
    // If we're selected or disabled, ignore the event.
    if ((currentState == State::Selected)
        || (currentState == State::Disabled)) {
        return;
    }

    // If we're normal, change to hovered.
    if (currentState == State::Normal) {
        setCurrentState(State::Hovered);
    }
}

void AnimationElementsListItem::onMouseLeave()
{
    // If we're disabled, ignore the event.
    if (currentState == State::Disabled) {
        return;
    }

    // If we're hovered, go to normal.
    if (currentState == State::Hovered) {
        setCurrentState(State::Normal);
    }
}

void AnimationElementsListItem::setCurrentState(State inState)
{
    // Set the new state.
    currentState = inState;

    // Set all of our graphics to the default state.
    hoveredImage.setIsVisible(false);
    selectedImage.setIsVisible(false);
    text.setColor({255, 255, 255, 255});

    switch (currentState) {
        case State::Normal: {
            // Use defaults.
            break;
        }
        case State::Hovered: {
            hoveredImage.setIsVisible(true);
            break;
        }
        case State::Selected: {
            selectedImage.setIsVisible(true);
            break;
        }
        case State::Disabled: {
            text.setColor({166, 166, 166, 255});
            break;
        }
    }
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/AnimationTimeline.cpp`:

```cpp
#include "AnimationTimeline.h"
#include "EditorAnimation.h"
#include "TimelineFrame.h"
#include "Paths.h"
#include "AMAssert.h"
#include "AUI/ScalingHelpers.h"
#include "AUI/Core.h"
#include "Log.h"
#include <algorithm>

namespace AM
{
namespace ResourceImporter
{
AnimationTimeline::AnimationTimeline(const SDL_Rect& inLogicalExtent,
                                     const std::string& inDebugName)
: AUI::Widget(inLogicalExtent, inDebugName)
, numberContainer{{0, 24 + 4, logicalExtent.w, 18}, "NumberContainer"}
, frameContainer{{0, 48, logicalExtent.w, 26}, "FrameContainer"}
, loopHandle{{0, 0, 18, 48}}
, frameScrubber{{0, 24, 18, 48}}
, selectedFrameNumber{0}
, activeAnimation{nullptr}
, originSpriteDragFrameNumber{0}
, currentSpriteDragFrameNumber{0}
, animationAccumulator{0}
, playingAnimation{false}
, loopBackgroundExtent{}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(numberContainer);
    children.push_back(frameContainer);
    children.push_back(loopHandle);
    children.push_back(frameScrubber);

    /* Numbers. */
    numberContainer.setNumRows(1);
    numberContainer.setCellWidth(24 + 96);
    numberContainer.setCellHeight(18);
    numberContainer.setScrollingEnabled(false);

    /* Frame container. */
    frameContainer.setNumRows(1);
    frameContainer.setCellWidth(TimelineFrame::LOGICAL_WIDTH);
    frameContainer.setCellHeight(26);
    frameContainer.setScrollingEnabled(false);

    /* Frame handles. */
    frameScrubber.setColor({24, 155, 243, 191});
    frameScrubber.setRenderLine(true);
    loopHandle.setColor({255, 191, 0, 191});
    loopHandle.setRenderLine(false);

    frameScrubber.setOnDragged([&](const SDL_Point& cursorPosition) {
        onFrameScrubberDragged(cursorPosition);
    });
    loopHandle.setOnDragged([&](const SDL_Point& cursorPosition) {
        onLoopHandleDragged(cursorPosition);
    });
}

void AnimationTimeline::setActiveAnimation(
    const EditorAnimation& newActiveAnimation)
{
    activeAnimation = &newActiveAnimation;

    refreshFrames();

    setFrameScrubberPosition(0);
    setLoopStartFrame(activeAnimation->loopStartFrame);
}

void AnimationTimeline::setFrameCount(Uint8 newFrameCount)
{
    refreshFrames();

    // Move the scrubber if necessary.
    if (selectedFrameNumber >= newFrameCount) {
        setFrameScrubberPosition(newFrameCount - 1);
    }

    // Note: If loopStartFrame is larger than newFrameCount, the model handles 
    //       updating and signalling it before the frame count signal is 
    //       emitted.
}

void AnimationTimeline::setLoopStartFrame(Uint8 newLoopStartFrame)
{
    setLoopHandlePosition(newLoopStartFrame);
}

void AnimationTimeline::setFrame(Uint8 frameNumber, bool hasSprite)
{
    TimelineFrame& frame{
        static_cast<TimelineFrame&>(*frameContainer[frameNumber])};
    frame.hasSprite = hasSprite;

    // If the frame is currently selected, refresh it so the user gets notified 
    // of the sprite change.
    if (frameNumber == selectedFrameNumber) {
        setFrameScrubberPosition(selectedFrameNumber);
    }
}

void AnimationTimeline::playOrPauseAnimation()
{
    if (!playingAnimation) {
        setFrameScrubberPosition(0);
        animationTimer.reset();
        animationAccumulator = 0;
        playingAnimation = true;
    }
    else {
        playingAnimation = false;
    }
}

Uint8 AnimationTimeline::getSelectedFrameNumber() const
{
    return selectedFrameNumber;
}

void AnimationTimeline::setOnSelectionChanged(
    std::function<void(Uint8)> inOnSelectionChanged)
{
    onSelectionChanged = std::move(inOnSelectionChanged);
}

void AnimationTimeline::setOnLoopStartFrameChanged(
    std::function<void(Uint8 newLoopStartFrame)> inOnLoopStartFrameChanged)
{
    onLoopStartFrameChanged = std::move(inOnLoopStartFrameChanged);
}

void AnimationTimeline::setOnSpriteMoved(
    std::function<void(Uint8, Uint8)> inOnSpriteMoved)
{
    onSpriteMoved = std::move(inOnSpriteMoved);
}

void AnimationTimeline::onTick(double)
{
    // If we aren't playing an animation, do nothing.
    if (!playingAnimation) {
        return;
    }

    // If enough time has passed, go to the next frame.
    animationAccumulator += animationTimer.getTimeAndReset();
    double animationTimestepS{1
                              / static_cast<double>(activeAnimation->fps)};
    while (animationAccumulator > animationTimestepS) {
        // If we're already at the last frame, loop or end the animation.
        Uint8 frameCount{activeAnimation->frameCount};
        Uint8 loopStartFrame{activeAnimation->loopStartFrame};
        if (selectedFrameNumber == (frameCount - 1)) {
            if (loopStartFrame != frameCount) {
                // Loop back to the start frame.
                setFrameScrubberPosition(loopStartFrame);
            }
            else {
                // No loop, stop playing the animation.
                playingAnimation = false;
                return;
            }
        }
        else {
            // Proceed to the next frame.
            setFrameScrubberPosition(selectedFrameNumber + 1);
        }

        animationAccumulator -= animationTimestepS;
    }
}

void AnimationTimeline::render(const SDL_Point& windowTopLeft)
{
    // If this widget is fully clipped, don't render it.
    if (SDL_RectEmpty(&clippedExtent)) {
        return;
    }

    // Render the loop background.
    int loopCount{activeAnimation->frameCount
                  - activeAnimation->loopStartFrame};
    if (loopCount != 0) {
        int scaledFrameWidth{
            AUI::ScalingHelpers::logicalToActual(TimelineFrame::LOGICAL_WIDTH)};
        int loopBackgroundX{
            clippedExtent.x + windowTopLeft.x
            + (scaledFrameWidth * activeAnimation->loopStartFrame)};
        int loopBackgroundWidth{scaledFrameWidth * loopCount};

        SDL_Rect loopBackgroundExtent{
            loopBackgroundX, (clippedExtent.y + windowTopLeft.y),
            loopBackgroundWidth, AUI::ScalingHelpers::logicalToActual(24 * 2)};
        SDL_SetRenderDrawBlendMode(AUI::Core::getRenderer(),
                                   SDL_BLENDMODE_BLEND);
        SDL_SetRenderDrawColor(AUI::Core::getRenderer(), 255, 191, 0, 64);
        SDL_RenderFillRect(AUI::Core::getRenderer(), &loopBackgroundExtent);
    }

    // Render our child widgets.
    Widget::render(windowTopLeft);
}

void AnimationTimeline::onFrameScrubberDragged(const SDL_Point& cursorPosition)
{
    // Ignore scrubber interactions if we're playing an animation.
    if (playingAnimation) {
        return;
    }

    Uint8 cursorFrame{getCursorFrame(cursorPosition)};

    // If the cursor isn't aligned with the current selected frame, select the 
    // new one.
    if ((cursorFrame != selectedFrameNumber)
        && (cursorFrame < frameContainer.size())) {
        setFrameScrubberPosition(cursorFrame);
    }
}

void AnimationTimeline::onLoopHandleDragged(const SDL_Point& cursorPosition)
{
    // Ignore loop handle interactions if we're playing an animation.
    if (playingAnimation) {
        return;
    }

    Uint8 cursorFrame{getCursorFrame(cursorPosition)};

    // If the cursor isn't aligned with the current loop frame, select the 
    // new one.
    // Note: The loop handle can go 1 frame past the timeline, to set 
    //       loopFrameCount to 0.
    if ((cursorFrame != activeAnimation->loopStartFrame)
        && (cursorFrame <= frameContainer.size())) {
        setLoopHandlePosition(cursorFrame);

        // If the user set a callback, call it.
        // Note: We do this here instead of in setLoopHandlePosition because 
        //       we only want to signal the change on drag (i.e. not when 
        //       setLoopStartFrame() is called).
        if (onLoopStartFrameChanged) {
            onLoopStartFrameChanged(cursorFrame);
        }
    }
}

void AnimationTimeline::onSpriteDragStarted(Uint8 frameNumber,
                                            const SDL_Point& cursorPosition)
{
    // Remember where the drag started.
    originSpriteDragFrameNumber = frameNumber;
    currentSpriteDragFrameNumber = frameNumber;
}

void AnimationTimeline::onSpriteDragged(Uint8 frameNumber,
                                        const SDL_Point& cursorPosition)
{
    // If the cursor is over a new frame, reset the old frame's circle 
    // and add one to the new frame.
    Uint8 cursorFrame{getCursorFrame(cursorPosition)};
    if (cursorFrame != currentSpriteDragFrameNumber) {
        TimelineFrame& oldCurrentFrame{static_cast<TimelineFrame&>(
            *frameContainer[currentSpriteDragFrameNumber])};
        TimelineFrame& newCurrentFrame{static_cast<TimelineFrame&>(
            *frameContainer[cursorFrame])};

        // If we're moving from the origin frame, remove its marker.
        if (currentSpriteDragFrameNumber == originSpriteDragFrameNumber) {
            oldCurrentFrame.hasSprite = false;
        }
        else {
            // Not the origin frame, return it to whatever it was.
            // Note: We don't use getSpriteAtFrame() because it may return a 
            //       sprite from a previous frame.
            auto expandedFrameVector{activeAnimation->getExpandedFrameVector()};
            oldCurrentFrame.hasSprite
                = (expandedFrameVector.at(currentSpriteDragFrameNumber)
                   != nullptr);
        }
        newCurrentFrame.hasSprite = true;

        currentSpriteDragFrameNumber = cursorFrame;
    }
}

void AnimationTimeline::onSpriteDragReleased(Uint8 frameNumber,
                                             const SDL_Point& cursorPosition)
{
    // Reset the display state.
    TimelineFrame& originFrame{static_cast<TimelineFrame&>(
        *frameContainer[originSpriteDragFrameNumber])};
    TimelineFrame& currentFrame{static_cast<TimelineFrame&>(
        *frameContainer[currentSpriteDragFrameNumber])};

    bool originHasSprite{originFrame.hasSprite};
    bool currentHasSprite{currentFrame.hasSprite};
    originFrame.hasSprite = currentHasSprite;
    currentFrame.hasSprite = originHasSprite;

    // If the cursor is over a new frame, move the sprite to it.
    if ((currentSpriteDragFrameNumber != originSpriteDragFrameNumber)
        && onSpriteMoved) {
        onSpriteMoved(originSpriteDragFrameNumber,
                      currentSpriteDragFrameNumber);
    }
}

void AnimationTimeline::refreshFrames()
{
    // Fill the frame container with empty frames to match the animation's frame 
    // count.
    frameContainer.clear();
    numberContainer.clear();
    for (Uint8 i{0}; i < activeAnimation->frameCount; ++i) {
        auto frame{std::make_unique<TimelineFrame>()};
        frame->setOnPressed([&, i]() { setFrameScrubberPosition(i); });
        frame->setOnSpriteDragStarted([&, i](const SDL_Point& cursorPosition) {
            onSpriteDragStarted(i, cursorPosition);
        });
        frame->setOnSpriteDragged([&, i](const SDL_Point& cursorPosition) {
            onSpriteDragged(i, cursorPosition);
        });
        frame->setOnSpriteDragReleased([&, i](const SDL_Point& cursorPosition) {
            onSpriteDragReleased(i, cursorPosition);
        });

        // Darken every 5th frame and add a number above it.
        if (i % 5 == 0) {
            frame->drawDarkBackground = true;

            auto numberText{std::make_unique<AUI::Text>(SDL_Rect{0, 0, 24, 18},
                                                        "NumberText")};
            styleNumberText(*numberText, std::to_string(i));
            numberContainer.push_back(std::move(numberText));
        }

        frameContainer.push_back(std::move(frame));
    }

    // Fill the frames that contain sprites.
    for (const EditorAnimation::Frame& frame : activeAnimation->frames) {
        AM_ASSERT(frame.frameNumber < frameContainer.size(),
                  "Invalid frame number.");
        TimelineFrame& timelineFrame{
            static_cast<TimelineFrame&>(*frameContainer[frame.frameNumber])};
        timelineFrame.hasSprite = true;
    }

    // Update this widget's width to match the frames, adding an extra frame's
    // width for the loop handle.
    SDL_Rect newLogicalExtent{logicalExtent};
    newLogicalExtent.w
        = activeAnimation->frameCount * TimelineFrame::LOGICAL_WIDTH;
    newLogicalExtent.w += TimelineFrame::LOGICAL_WIDTH;
    setLogicalExtent(newLogicalExtent);

    // Any time we update the frames, we want to stop playing the old animation
    // (so we're forced to reset the play state).
    playingAnimation = false;
}

void AnimationTimeline::setFrameScrubberPosition(Uint8 frameNumber)
{
    // Set the new frame number.
    selectedFrameNumber = frameNumber;

    // Center the scrubber over the new frame.
    AM_ASSERT(frameNumber < frameContainer.size(), "Invalid frame number.");

    SDL_Rect newScrubberExtent{frameScrubber.getLogicalExtent()};
    newScrubberExtent.x = TimelineFrame::LOGICAL_WIDTH * frameNumber;
    frameScrubber.setLogicalExtent(newScrubberExtent);

    // If the user set a callback, call it.
    if (onSelectionChanged) {
        onSelectionChanged(selectedFrameNumber);
    }
}

void AnimationTimeline::setLoopHandlePosition(Uint8 frameNumber)
{
    // Center the handle over the new frame.
    AM_ASSERT(frameNumber <= frameContainer.size(), "Invalid frame number.");

    SDL_Rect newHandleExtent{loopHandle.getLogicalExtent()};
    newHandleExtent.x = TimelineFrame::LOGICAL_WIDTH * frameNumber;
    loopHandle.setLogicalExtent(newHandleExtent);
}

Uint8 AnimationTimeline::getCursorFrame(const SDL_Point& cursorPosition)
{
    // Offset the cursor to be relative to this widget's top left.
    SDL_Point offsetCursorPosition{cursorPosition};
    offsetCursorPosition.x -= clippedExtent.x;
    offsetCursorPosition.y -= clippedExtent.y;

    // Calculate which frame the cursor is aligned with.
    int cursorFrame{
        AUI::ScalingHelpers::actualToLogical(offsetCursorPosition.x)};
    cursorFrame /= TimelineFrame::LOGICAL_WIDTH;

    // Clamp to valid values.
    cursorFrame = std::clamp(cursorFrame, 0,
                             static_cast<int>(frameContainer.size()));

    return static_cast<Uint8>(cursorFrame);
}

void AnimationTimeline::styleNumberText(AUI::Text& textObject,
                                        const std::string& text)
{
    textObject.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 16);
    textObject.setColor({255, 255, 255, 255});
    textObject.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Center);
    textObject.setText(text);
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/BoundingBoxGizmo.cpp`:

```cpp
#include "BoundingBoxGizmo.h"
#include "Transforms.h"
#include "Camera.h"
#include "Position.h"
#include "SpriteTools.h"
#include "SharedConfig.h"
#include "Log.h"
#include "AUI/Core.h"
#include "AUI/ScalingHelpers.h"
#include "AUI/SDLHelpers.h"
#include <algorithm>
#include <SDL_rect.h>
#include <SDL2_gfxPrimitives.h>

namespace AM
{
namespace ResourceImporter
{
BoundingBoxGizmo::BoundingBoxGizmo(const SDL_Rect& inLogicalExtent)
: AUI::Widget(inLogicalExtent, "BoundingBoxGizmo")
, lastUsedScreenSize{0, 0}
, boundingBox{}
, isEnabled{true}
, scaledRectSize{AUI::ScalingHelpers::logicalToActual(LOGICAL_RECT_SIZE)}
, scaledLineWidth{AUI::ScalingHelpers::logicalToActual(LOGICAL_LINE_WIDTH)}
, logicalSpriteImageExtent{0, 0, 0, 0}
, logicalStageOrigin{0, 0}
, stageWorldExtent{}
, positionControlExtent{0, 0, scaledRectSize, scaledRectSize}
, xControlExtent{0, 0, scaledRectSize, scaledRectSize}
, yControlExtent{0, 0, scaledRectSize, scaledRectSize}
, zControlExtent{0, 0, scaledRectSize, scaledRectSize}
, lineXMinPoint{}
, lineXMaxPoint{}
, lineYMinPoint{}
, lineYMaxPoint{}
, lineZMinPoint{}
, lineZMaxPoint{}
, planeXCoords{}
, planeYCoords{}
, currentHeldControl{Control::None}
{
}

void BoundingBoxGizmo::enable()
{
    isEnabled = true;
    refreshGraphics();
}

void BoundingBoxGizmo::disable()
{
    isEnabled = false;
    refreshGraphics();
}

void BoundingBoxGizmo::setSpriteImageSize(int logicalSpriteWidth,
                                          int logicalSpriteHeight)
{
    logicalSpriteImageExtent.x
        = (logicalExtent.w / 2) - (logicalSpriteWidth / 2);
    logicalSpriteImageExtent.y
        = (logicalExtent.h / 2) - (logicalSpriteHeight / 2);
    logicalSpriteImageExtent.w = logicalSpriteWidth;
    logicalSpriteImageExtent.h = logicalSpriteHeight;

    updateStageExtent();
    refreshGraphics();
}

void BoundingBoxGizmo::setStageOrigin(const SDL_Point& inLogicalStageOrigin)
{
    logicalStageOrigin = inLogicalStageOrigin;
    updateStageExtent();
    refreshGraphics();
}

void BoundingBoxGizmo::setBoundingBox(const BoundingBox& newBoundingBox)
{
    boundingBox = newBoundingBox;
    refreshGraphics();
}

const SDL_Rect& BoundingBoxGizmo::getLogicalCenteredSpriteExtent() const
{
    return logicalSpriteImageExtent;
}

void BoundingBoxGizmo::setOnBoundingBoxUpdated(
    std::function<void(const BoundingBox&)> inOnBoundingBoxUpdated)
{
    onBoundingBoxUpdated = std::move(inOnBoundingBoxUpdated);
}

void BoundingBoxGizmo::setLogicalExtent(const SDL_Rect& inLogicalExtent)
{
    Widget::setLogicalExtent(inLogicalExtent);
    updateStageExtent();
    refreshGraphics();
}

void BoundingBoxGizmo::arrange(const SDL_Point& startPosition,
                               const SDL_Rect& availableExtent,
                               AUI::WidgetLocator* widgetLocator)
{
    // Note: This custom arrange isn't really needed, since ResourceImporter
    //       isn't likely to change screen size at runtime. It's nice to keep
    //       as an example though, of what to do if you have custom graphics 
    //       that rely on clippedExtent for layout.

    // Run the normal arrange step.
    Widget::arrange(startPosition, availableExtent, widgetLocator);

    // If this widget is fully clipped, return early.
    if (SDL_RectEmpty(&clippedExtent)) {
        return;
    }

    // If the UI scaling has changed, refresh everything.
    // Note: This has to be done after arranging, since it uses clippedExtent.
    if (lastUsedScreenSize != AUI::Core::getActualScreenSize()) {
        refreshScaling();
        lastUsedScreenSize = AUI::Core::getActualScreenSize();
    }
}

void BoundingBoxGizmo::render(const SDL_Point& windowTopLeft)
{
    // If this widget is fully clipped, don't render it.
    if (SDL_RectEmpty(&clippedExtent)) {
        return;
    }

    renderPlanes(windowTopLeft);
    renderLines(windowTopLeft);
    renderControls(windowTopLeft);
}

AUI::EventResult BoundingBoxGizmo::onMouseDown(AUI::MouseButtonType buttonType,
                                               const SDL_Point& cursorPosition)
{
    // Do nothing if disabled. Only respond to the left mouse button.
    if (!isEnabled || (buttonType != AUI::MouseButtonType::Left)) {
        return AUI::EventResult{.wasHandled{false}};
    }

    // Check if the mouse press hit any of our controls.
    if (SDL_PointInRect(&cursorPosition, &positionControlExtent)) {
        currentHeldControl = Control::Position;
    }
    else if (SDL_PointInRect(&cursorPosition, &xControlExtent)) {
        currentHeldControl = Control::X;
    }
    else if (SDL_PointInRect(&cursorPosition, &yControlExtent)) {
        currentHeldControl = Control::Y;
    }
    else if (SDL_PointInRect(&cursorPosition, &zControlExtent)) {
        currentHeldControl = Control::Z;
    }

    // If the cursor is holding a control, set mouse capture so we get the
    // associated MouseUp.
    if (currentHeldControl != Control::None) {
        return AUI::EventResult{.wasHandled{true}, .setMouseCapture{this}};
    }
    else {
        return AUI::EventResult{.wasHandled{true}};
    }
}

AUI::EventResult BoundingBoxGizmo::onMouseUp(AUI::MouseButtonType buttonType,
                                             const SDL_Point&)
{
    // Only respond to the left mouse button.
    if (buttonType != AUI::MouseButtonType::Left) {
        return AUI::EventResult{.wasHandled{false}};
    }

    // If we're holding a control, release it and release mouse capture.
    if (currentHeldControl != Control::None) {
        currentHeldControl = Control::None;
        return AUI::EventResult{.wasHandled{true}, .releaseMouseCapture{true}};
    }
    else {
        return AUI::EventResult{.wasHandled{true}};
    }
}

AUI::EventResult BoundingBoxGizmo::onMouseMove(const SDL_Point& cursorPosition)
{
    // If a control isn't currently being held, ignore the event.
    if (currentHeldControl == Control::None) {
        return AUI::EventResult{.wasHandled{false}};
    }

    /* Translate the mouse position to world space. */
    // Account for this widget's position.
    SDL_Rect actualSpriteImageExtent{
        AUI::ScalingHelpers::logicalToActual(logicalSpriteImageExtent)};
    SDL_Point actualStageOrigin{
        AUI::ScalingHelpers::logicalToActual(logicalStageOrigin)};
    int finalXOffset{clippedExtent.x + actualSpriteImageExtent.x
                     + actualStageOrigin.x};
    int finalYOffset{clippedExtent.y + actualSpriteImageExtent.y
                     + actualStageOrigin.y};

    // Apply the offset to the mouse position and convert to logical space.
    SDL_Point offsetMousePoint{cursorPosition.x - finalXOffset,
                               cursorPosition.y - finalYOffset};
    offsetMousePoint = AUI::ScalingHelpers::actualToLogical(offsetMousePoint);

    // Convert the screen-space mouse point to world space.
    SDL_FPoint offsetMouseScreenPoint{static_cast<float>(offsetMousePoint.x),
                                      static_cast<float>(offsetMousePoint.y)};
    Position mouseWorldPos{
        Transforms::screenToWorldMinimum(offsetMouseScreenPoint, {})};

    // Adjust the currently pressed control appropriately.
    switch (currentHeldControl) {
        case Control::Position: {
            updatePositionBounds(mouseWorldPos);
            break;
        }
        case Control::X: {
            updateXBounds(mouseWorldPos);
            break;
        }
        case Control::Y: {
            updateYBounds(mouseWorldPos);
            break;
        }
        case Control::Z: {
            updateZBounds(cursorPosition.y);
            break;
        }
        default: {
            break;
        }
    }

    return AUI::EventResult{.wasHandled{true}};
}

void BoundingBoxGizmo::refreshScaling()
{
    // Re-calculate our control rectangle size.
    scaledRectSize = AUI::ScalingHelpers::logicalToActual(LOGICAL_RECT_SIZE);

    // Re-calculate our line width.
    scaledLineWidth = AUI::ScalingHelpers::logicalToActual(LOGICAL_LINE_WIDTH);

    // Refresh our controls to reflect the new sizes.
    refreshGraphics();
}

void BoundingBoxGizmo::updateStageExtent()
{
    stageWorldExtent = SpriteTools::calcSpriteStageWorldExtent(
        logicalSpriteImageExtent, logicalStageOrigin);
}

void BoundingBoxGizmo::refreshGraphics()
{
    // Calculate where the bounding box is on the screen.
    std::vector<SDL_Point> screenPoints{};
    calcBoundingBoxScreenPoints(screenPoints);

    // Move the controls, lines, and planes to the correct positions.
    moveControls(screenPoints);
    moveLines(screenPoints);
    movePlanes(screenPoints);
}

void BoundingBoxGizmo::updatePositionBounds(const Position& mouseWorldPos)
{
    // TODO: If shift is held, only move along the Z axis

    // Note: The expected behavior is to move along the x/y plane and
    //       leave minZ where it was.
    BoundingBox updatedBounds{boundingBox};
    float& minX{updatedBounds.min.x};
    float& minY{updatedBounds.min.y};
    float& maxX{updatedBounds.max.x};
    float& maxY{updatedBounds.max.y};

    // Move the min bounds to follow the max bounds.
    float diffX{mouseWorldPos.x - maxX};
    float diffY{mouseWorldPos.y - maxY};
    minX += diffX;
    minY += diffY;

    // Move the max bounds to their new position.
    maxX = mouseWorldPos.x;
    maxY = mouseWorldPos.y;

    // If we moved below the model-space origin (0, 0), bring the box bounds
    // back in.
    if (minX < 0) {
        maxX += -minX;
        minX = 0;
    }
    if (minY < 0) {
        maxY += -minY;
        minY = 0;
    }

    // If we moved outside the stage bounds, bring the box bounds back in.
    if (maxX > stageWorldExtent.max.x) {
        float diff{maxX - stageWorldExtent.max.x};
        minX -= diff;
        maxX -= diff;
    }
    if (maxY > stageWorldExtent.max.y) {
        float diff{maxY - stageWorldExtent.max.y};
        minY -= diff;
        maxY -= diff;
    }

    // Signal the updated bounding box.
    // Note: We don't update our internal bounding box until our owner saves the
    //       update in the model and it signals us.
    if (onBoundingBoxUpdated) {
        onBoundingBoxUpdated(updatedBounds);
    }
}

void BoundingBoxGizmo::updateXBounds(const Position& mouseWorldPos)
{
    // Clamp the new value to its bounds.
    BoundingBox updatedBounds{boundingBox};
    updatedBounds.min.x = std::clamp(mouseWorldPos.x, 0.f, updatedBounds.max.x);

    // Signal the updated bounding box.
    // Note: We don't update our internal bounding box until our owner 
    //       saves the update in the model and calls setBoundingBox().
    if (onBoundingBoxUpdated) {
        onBoundingBoxUpdated(updatedBounds);
    }
}

void BoundingBoxGizmo::updateYBounds(const Position& mouseWorldPos)
{
    // Clamp the new value to its bounds.
    BoundingBox updatedBounds{boundingBox};
    updatedBounds.min.y = std::clamp(mouseWorldPos.y, 0.f, updatedBounds.max.y);

    // Signal the updated bounding box.
    if (onBoundingBoxUpdated) {
        onBoundingBoxUpdated(updatedBounds);
    }
}

void BoundingBoxGizmo::updateZBounds(int mouseScreenYPos)
{
    // Note: The screenToWorld() transformation can't handle z-axis
    // movement (not enough data from a 2d point), so we have to do it
    // using our contextual information.

    // Set maxZ relative to the distance between the mouse and the
    // position control (the position control is always our reference
    // for where minimum Z is.)
    float mouseZHeight{positionControlExtent.y + (scaledRectSize / 2.f)
                       - mouseScreenYPos};

    // Convert to logical space.
    mouseZHeight = AUI::ScalingHelpers::actualToLogical(mouseZHeight);

    // Apply our screen -> world Z scaling.
    mouseZHeight = Transforms::screenYToWorldZ(mouseZHeight, 1.f);

    // Set maxZ, making sure it doesn't go below minZ or beyond the stage.
    BoundingBox updatedBounds{boundingBox};
    updatedBounds.max.z
        = std::clamp(mouseZHeight, updatedBounds.min.z, stageWorldExtent.max.z);

    // Signal the updated bounding box.
    if (onBoundingBoxUpdated) {
        onBoundingBoxUpdated(updatedBounds);
    }
}

void BoundingBoxGizmo::calcBoundingBoxScreenPoints(
    std::vector<SDL_Point>& boundsScreenPoints)
{
    /* Transform the world positions to screen points. */
    std::array<SDL_FPoint, 7> screenPoints{};

    // Push the points in the correct order.
    const Vector3& minPoint{boundingBox.min};
    const Vector3& maxPoint{boundingBox.max};
    Vector3 point{minPoint.x, maxPoint.y, minPoint.z};
    screenPoints[0] = Transforms::worldToScreen(point, 1);

    point = {maxPoint.x, maxPoint.y, minPoint.z};
    screenPoints[1] = Transforms::worldToScreen(point, 1);

    point = {maxPoint.x, minPoint.y, minPoint.z};
    screenPoints[2] = Transforms::worldToScreen(point, 1);

    point = {minPoint.x, maxPoint.y, maxPoint.z};
    screenPoints[3] = Transforms::worldToScreen(point, 1);

    point = {maxPoint.x, maxPoint.y, maxPoint.z};
    screenPoints[4] = Transforms::worldToScreen(point, 1);

    point = {maxPoint.x, minPoint.y, maxPoint.z};
    screenPoints[5] = Transforms::worldToScreen(point, 1);

    point = {minPoint.x, minPoint.y, maxPoint.z};
    screenPoints[6] = Transforms::worldToScreen(point, 1);

    // Account for this widget's position and the image's position.
    SDL_Rect actualSpriteImageExtent{
        AUI::ScalingHelpers::logicalToActual(logicalSpriteImageExtent)};
    SDL_Point actualStageOrigin{
        AUI::ScalingHelpers::logicalToActual(logicalStageOrigin)};
    int finalXOffset{clippedExtent.x + actualSpriteImageExtent.x
                     + actualStageOrigin.x};
    int finalYOffset{clippedExtent.y + actualSpriteImageExtent.y
                     + actualStageOrigin.y};

    // Scale and offset each point, then push it into the return vector.
    for (SDL_FPoint& point : screenPoints) {
        // Scale and round the point.
        point.x = std::round(AUI::ScalingHelpers::logicalToActual(point.x));
        point.y = std::round(AUI::ScalingHelpers::logicalToActual(point.y));

        // Offset the point.
        point.x += finalXOffset;
        point.y += finalYOffset;

        // Cast to int and push into the return vector.
        boundsScreenPoints.push_back(
            {static_cast<int>(point.x), static_cast<int>(point.y)});
    }
}

void BoundingBoxGizmo::moveControls(std::vector<SDL_Point>& boundsScreenPoints)
{
    // Calc half the control rectangle size so we can center the controls.
    int halfRectSize{static_cast<int>(scaledRectSize / 2.f)};

    // Move the control extents.
    positionControlExtent.x = boundsScreenPoints[1].x - halfRectSize;
    positionControlExtent.y = boundsScreenPoints[1].y - halfRectSize;

    xControlExtent.x = boundsScreenPoints[0].x - halfRectSize;
    xControlExtent.y = boundsScreenPoints[0].y - halfRectSize;

    yControlExtent.x = boundsScreenPoints[2].x - halfRectSize;
    yControlExtent.y = boundsScreenPoints[2].y - halfRectSize;

    zControlExtent.x = boundsScreenPoints[4].x - halfRectSize;
    zControlExtent.y = boundsScreenPoints[4].y - halfRectSize;
}

void BoundingBoxGizmo::moveLines(std::vector<SDL_Point>& boundsScreenPoints)
{
    // Move the lines.
    lineXMinPoint = {boundsScreenPoints[0].x, boundsScreenPoints[0].y};
    lineXMaxPoint = {boundsScreenPoints[1].x, boundsScreenPoints[1].y};

    lineYMinPoint = {boundsScreenPoints[2].x, boundsScreenPoints[2].y};
    lineYMaxPoint = {boundsScreenPoints[1].x, boundsScreenPoints[1].y};

    lineZMinPoint = {boundsScreenPoints[1].x, boundsScreenPoints[1].y};
    lineZMaxPoint = {boundsScreenPoints[4].x, boundsScreenPoints[4].y};
}

void BoundingBoxGizmo::movePlanes(std::vector<SDL_Point>& boundsScreenPoints)
{
    // Set the coords for the X-axis plane (coords 0 - 3, starting from top
    // left and going clockwise.)
    planeXCoords[0] = boundsScreenPoints[4].x;
    planeYCoords[0] = boundsScreenPoints[4].y;
    planeXCoords[1] = boundsScreenPoints[5].x;
    planeYCoords[1] = boundsScreenPoints[5].y;
    planeXCoords[2] = boundsScreenPoints[2].x;
    planeYCoords[2] = boundsScreenPoints[2].y;
    planeXCoords[3] = boundsScreenPoints[1].x;
    planeYCoords[3] = boundsScreenPoints[1].y;

    // Set the coords for the Y-axis plane (coords 4 - 7, starting from top
    // left and going clockwise.)
    planeXCoords[4] = boundsScreenPoints[3].x;
    planeYCoords[4] = boundsScreenPoints[3].y;
    planeXCoords[5] = boundsScreenPoints[4].x;
    planeYCoords[5] = boundsScreenPoints[4].y;
    planeXCoords[6] = boundsScreenPoints[1].x;
    planeYCoords[6] = boundsScreenPoints[1].y;
    planeXCoords[7] = boundsScreenPoints[0].x;
    planeYCoords[7] = boundsScreenPoints[0].y;

    // Set the coords for the Z-axis plane (coords 8 - 11, starting from top
    // left and going clockwise.)
    planeXCoords[8] = boundsScreenPoints[6].x;
    planeYCoords[8] = boundsScreenPoints[6].y;
    planeXCoords[9] = boundsScreenPoints[5].x;
    planeYCoords[9] = boundsScreenPoints[5].y;
    planeXCoords[10] = boundsScreenPoints[4].x;
    planeYCoords[10] = boundsScreenPoints[4].y;
    planeXCoords[11] = boundsScreenPoints[3].x;
    planeYCoords[11] = boundsScreenPoints[3].y;
}

void BoundingBoxGizmo::renderControls(const SDL_Point& windowTopLeft)
{
    // If this gizmo is disabled, make it semi-transparent.
    float alpha{BASE_ALPHA};
    if (!isEnabled) {
        alpha *= DISABLED_ALPHA_FACTOR;
    }

    // Position control
    SDL_Rect offsetExtent{positionControlExtent};
    offsetExtent.x += windowTopLeft.x;
    offsetExtent.y += windowTopLeft.y;

    SDL_SetRenderDrawBlendMode(AUI::Core::getRenderer(), SDL_BLENDMODE_BLEND);
    SDL_SetRenderDrawColor(AUI::Core::getRenderer(), 0, 0, 0,
                           static_cast<Uint8>(alpha));
    SDL_RenderFillRect(AUI::Core::getRenderer(), &offsetExtent);

    // X control
    offsetExtent = xControlExtent;
    offsetExtent.x += windowTopLeft.x;
    offsetExtent.y += windowTopLeft.y;

    SDL_SetRenderDrawColor(AUI::Core::getRenderer(), 148, 0, 0,
                           static_cast<Uint8>(alpha));
    SDL_RenderFillRect(AUI::Core::getRenderer(), &offsetExtent);

    // Y control
    offsetExtent = yControlExtent;
    offsetExtent.x += windowTopLeft.x;
    offsetExtent.y += windowTopLeft.y;

    SDL_SetRenderDrawColor(AUI::Core::getRenderer(), 0, 149, 0,
                           static_cast<Uint8>(alpha));
    SDL_RenderFillRect(AUI::Core::getRenderer(), &offsetExtent);

    // Z control
    offsetExtent = zControlExtent;
    offsetExtent.x += windowTopLeft.x;
    offsetExtent.y += windowTopLeft.y;

    SDL_SetRenderDrawColor(AUI::Core::getRenderer(), 0, 82, 240,
                           static_cast<Uint8>(alpha));
    SDL_RenderFillRect(AUI::Core::getRenderer(), &offsetExtent);
}

void BoundingBoxGizmo::renderLines(const SDL_Point& windowTopLeft)
{
    // If this gizmo is disabled, make it semi-transparent.
    float alpha{BASE_ALPHA};
    if (!isEnabled) {
        alpha *= DISABLED_ALPHA_FACTOR;
    }

    // X-axis line
    SDL_Point offsetMinPoint{lineXMinPoint};
    SDL_Point offsetMaxPoint{lineXMaxPoint};
    offsetMinPoint.x += windowTopLeft.x;
    offsetMinPoint.y += windowTopLeft.y;
    offsetMaxPoint.x += windowTopLeft.x;
    offsetMaxPoint.y += windowTopLeft.y;

    thickLineRGBA(AUI::Core::getRenderer(), offsetMinPoint.x, offsetMinPoint.y,
                  offsetMaxPoint.x, offsetMaxPoint.y, scaledLineWidth, 148, 0,
                  0, static_cast<Uint8>(alpha));

    // Y-axis line
    offsetMinPoint = lineYMinPoint;
    offsetMaxPoint = lineYMaxPoint;
    offsetMinPoint.x += windowTopLeft.x;
    offsetMinPoint.y += windowTopLeft.y;
    offsetMaxPoint.x += windowTopLeft.x;
    offsetMaxPoint.y += windowTopLeft.y;

    thickLineRGBA(AUI::Core::getRenderer(), offsetMinPoint.x, offsetMinPoint.y,
                  offsetMaxPoint.x, offsetMaxPoint.y, scaledLineWidth, 0, 149,
                  0, static_cast<Uint8>(alpha));

    // Z-axis line
    offsetMinPoint = lineZMinPoint;
    offsetMaxPoint = lineZMaxPoint;
    offsetMinPoint.x += windowTopLeft.x;
    offsetMinPoint.y += windowTopLeft.y;
    offsetMaxPoint.x += windowTopLeft.x;
    offsetMaxPoint.y += windowTopLeft.y;

    thickLineRGBA(AUI::Core::getRenderer(), offsetMinPoint.x, offsetMinPoint.y,
                  offsetMaxPoint.x, offsetMaxPoint.y, scaledLineWidth, 0, 82,
                  240, static_cast<Uint8>(alpha));
}

void BoundingBoxGizmo::renderPlanes(const SDL_Point& windowTopLeft)
{
    /* Offset all the points. */
    std::array<Sint16, 12> offsetXCoords{};
    for (std::size_t i = 0; i < offsetXCoords.size(); ++i) {
        offsetXCoords[i] = planeXCoords[i] + windowTopLeft.x;
    }

    std::array<Sint16, 12> offsetYCoords{};
    for (std::size_t i = 0; i < offsetYCoords.size(); ++i) {
        offsetYCoords[i] = planeYCoords[i] + windowTopLeft.y;
    }

    /* Draw the planes. */
    // If this gizmo is disabled, make it semi-transparent.
    float alpha{BASE_ALPHA * PLANE_ALPHA_FACTOR};
    if (!isEnabled) {
        alpha *= DISABLED_ALPHA_FACTOR;
    }

    // X-axis plane
    filledPolygonRGBA(AUI::Core::getRenderer(), &(offsetXCoords[0]),
                      &(offsetYCoords[0]), 4, 0, 149, 0,
                      static_cast<Uint8>(alpha));

    // Y-axis plane
    filledPolygonRGBA(AUI::Core::getRenderer(), &(offsetXCoords[4]),
                      &(offsetYCoords[4]), 4, 148, 0, 0,
                      static_cast<Uint8>(alpha));

    // Z-axis plane
    filledPolygonRGBA(AUI::Core::getRenderer(), &(offsetXCoords[8]),
                      &(offsetYCoords[8]), 4, 0, 82, 240,
                      static_cast<Uint8>(alpha));
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/GraphicSetSlot.cpp`:

```cpp
#include "GraphicSetSlot.h"
#include "Paths.h"

namespace AM
{
namespace ResourceImporter
{
GraphicSetSlot::GraphicSetSlot(int logicalWidth)
: AUI::Widget({0, 0, logicalWidth, 255}, "GraphicSetSlot")
, topText{{0, 0, logicalExtent.w, 30}}
, checkerboardImage{{(logicalExtent.w - 120) / 2, 45, 120, 120}}
, spriteImage{{(logicalExtent.w - 120) / 2, 45, 120, 120}}
, spriteNameText{{0, 175, logicalExtent.w, 27}}
, assignButton{{(logicalExtent.w - 112) / 2, 208, 112, 38}, "Assign"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(topText);
    children.push_back(checkerboardImage);
    children.push_back(spriteImage);
    children.push_back(spriteNameText);
    children.push_back(assignButton);

    // Set our text properties.
    topText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 24);
    topText.setColor({255, 255, 255, 255});
    topText.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Center);

    spriteNameText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    spriteNameText.setColor({255, 255, 255, 255});
    spriteNameText.setHorizontalAlignment(
        AUI::Text::HorizontalAlignment::Center);

    // Set our background image.
    checkerboardImage.setTiledImage(Paths::TEXTURE_DIR
                                    + "SpriteEditView/Checkerboard.png");
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/LibraryCollapsibleContainer.cpp`:

```cpp
#include "LibraryCollapsibleContainer.h"
#include "Paths.h"

namespace AM
{
namespace ResourceImporter
{
LibraryCollapsibleContainer::LibraryCollapsibleContainer(
    const std::string& inHeaderText, const std::string& inDebugName)
: AUI::CollapsibleContainer({0, 0, 318, 30}, inDebugName)
{
    // Add our arrow images.
    expandedImage.setLogicalExtent({8, 4, 20, 20});
    collapsedImage.setLogicalExtent({8, 4, 20, 20});
    expandedImage.setMultiResImage(
        {{{1600, 900}, (Paths::TEXTURE_DIR + "Icons/Expanded_1600.png")},
         {{1920, 1080}, (Paths::TEXTURE_DIR + "Icons/Expanded_1920.png")}});
    collapsedImage.setMultiResImage(
        {{{1600, 900}, (Paths::TEXTURE_DIR + "Icons/Collapsed_1600.png")},
         {{1920, 1080}, (Paths::TEXTURE_DIR + "Icons/Collapsed_1920.png")}});

    // Set our text properties.
    headerText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    headerText.setColor({255, 255, 255, 255});
    headerText.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    headerText.setText(inHeaderText);
    headerText.setLogicalExtent(
        {25, 0, (logicalExtent.w - 25), logicalExtent.h});

    // Set our padding.
    setLeftPadding(8);
}

void LibraryCollapsibleContainer::setLeftPadding(int inLeftPadding)
{
    int imageX{0 + inLeftPadding};
    int textX{25 + inLeftPadding};

    expandedImage.setLogicalExtent({imageX, 4, 20, 20});
    collapsedImage.setLogicalExtent({imageX, 4, 20, 20});
    headerText.setLogicalExtent(
        {textX, 0, (logicalExtent.w - textX), logicalExtent.h});
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/LibraryListItem.cpp`:

```cpp
#include "LibraryListItem.h"
#include "Paths.h"
#include "AUI/Text.h"

namespace AM
{
namespace ResourceImporter
{
LibraryListItem::LibraryListItem(const std::string& inText,
                                 const std::string& inDebugName)
: AUI::Widget({0, 0, 318, 30}, inDebugName)
, type{}
, ID{0}
, hoveredImage({0, 0, logicalExtent.w, logicalExtent.h})
, selectedImage({0, 0, logicalExtent.w, logicalExtent.h})
, text({0, 0, logicalExtent.w, logicalExtent.h})
, isHovered{false}
, isSelected{false}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(hoveredImage);
    children.push_back(selectedImage);
    children.push_back(text);

    // Add our backgrounds.
    hoveredImage.setSimpleImage(Paths::TEXTURE_DIR + "Highlights/Hovered.png");
    selectedImage.setSimpleImage(Paths::TEXTURE_DIR
                                 + "Highlights/Selected.png");

    // Set our text properties.
    text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    text.setColor({255, 255, 255, 255});
    text.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    text.setText(inText);

    // Make the images we aren't using invisible.
    hoveredImage.setIsVisible(false);
    selectedImage.setIsVisible(false);
}

void LibraryListItem::select()
{
    // If we are already selected, do nothing.
    if (isSelected) {
        return;
    }

    // Flag that we're now selected.
    setIsSelected(true);

    // If the user set a callback for this event, call it.
    if (onSelected) {
        onSelected(this);
    }
}

void LibraryListItem::deselect()
{
    // If we aren't selected, do nothing.
    if (!isSelected) {
        return;
    }

    // Flag that we're not selected.
    setIsSelected(false);

    // If the user set a callback for this event, call it.
    if (onDeselected) {
        onDeselected(this);
    }
}

bool LibraryListItem::getIsHovered() const
{
    return isHovered;
}

bool LibraryListItem::getIsSelected() const
{
    return isSelected;
}

void LibraryListItem::setLeftPadding(int inLeftPadding)
{
    text.setLogicalExtent(
        {inLeftPadding, 0, (logicalExtent.w - inLeftPadding), logicalExtent.h});
}

void LibraryListItem::setOnSelected(
    std::function<void(LibraryListItem*)> inOnSelected)
{
    onSelected = std::move(inOnSelected);
}

void LibraryListItem::setOnDeselected(
    std::function<void(LibraryListItem*)> inOnDeselected)
{
    onDeselected = std::move(inOnDeselected);
}

void LibraryListItem::setOnActivated(
    std::function<void(LibraryListItem*)> inOnActivated)
{
    onActivated = std::move(inOnActivated);
}

AUI::EventResult LibraryListItem::onMouseDown(AUI::MouseButtonType buttonType,
                                              const SDL_Point&)
{
    // Only respond to the left mouse button.
    if (buttonType != AUI::MouseButtonType::Left) {
        return AUI::EventResult{.wasHandled{false}};
    }

    // If we aren't already selected, select this widget.
    if (!isSelected) {
        select();
    }
    // If we're already selected and the ctrl key is held, deselect.
    else {
        const Uint8* keyStates{SDL_GetKeyboardState(nullptr)};
        if (keyStates[SDL_SCANCODE_LCTRL] || keyStates[SDL_SCANCODE_RCTRL]) {
            setIsSelected(false);
            if (onDeselected) {
                onDeselected(this);
            }
        }
    }

    return AUI::EventResult{.wasHandled{true}};
}

AUI::EventResult
    LibraryListItem::onMouseDoubleClick(AUI::MouseButtonType buttonType,
                                        const SDL_Point&)
{
    // Only respond to the left mouse button.
    if (buttonType != AUI::MouseButtonType::Left) {
        return AUI::EventResult{.wasHandled{false}};
    }

    // If we aren't already selected, select this widget.
    if (!isSelected) {
        select();
    }
    // If we're already selected and the ctrl key is held, deselect.
    else {
        const Uint8* keyStates{SDL_GetKeyboardState(nullptr)};
        if (keyStates[SDL_SCANCODE_LCTRL] || keyStates[SDL_SCANCODE_RCTRL]) {
            setIsSelected(false);
            if (onDeselected) {
                onDeselected(this);
            }

            return AUI::EventResult{.wasHandled{true}};
        }
    }

    // If the user set a callback for this event, call it.
    // Note: We don't activate if shift or ctrl is held, since the user is 
    //       likely trying to quickly select multiple items.
    if (onActivated && !modifierKeyIsHeld()) {
        onActivated(this);
    }

    return AUI::EventResult{.wasHandled{true}};
}

void LibraryListItem::onMouseEnter()
{
    // If we're selected, ignore hovers.
    if (isSelected) {
        return;
    }

    // If we're not hovered, become hovered.
    if (!isHovered) {
        setIsHovered(true);
    }
}

void LibraryListItem::onMouseLeave()
{
    // If we're hovered, unhover.
    if (isHovered) {
        setIsHovered(false);
    }
}

void LibraryListItem::setIsHovered(bool inIsHovered)
{
    isHovered = inIsHovered;
    hoveredImage.setIsVisible(isHovered);
}

void LibraryListItem::setIsSelected(bool inIsSelected)
{
    isSelected = inIsSelected;
    selectedImage.setIsVisible(isSelected);
}

bool LibraryListItem::modifierKeyIsHeld()
{
    const Uint8* keyStates{SDL_GetKeyboardState(nullptr)};
    bool shiftIsHeld{keyStates[SDL_SCANCODE_LSHIFT]
                     || keyStates[SDL_SCANCODE_RSHIFT]};
    bool ctrlIsHeld{keyStates[SDL_SCANCODE_LCTRL]
                    || keyStates[SDL_SCANCODE_RCTRL]};

    return shiftIsHeld || ctrlIsHeld;
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/MainButton.cpp`:

```cpp
#include "MainButton.h"
#include "Paths.h"

namespace AM
{
namespace ResourceImporter
{
MainButton::MainButton(const SDL_Rect& inLogicalExtent,
                       const std::string& inText,
                       const std::string& inDebugName)
: AUI::Button(inLogicalExtent, inDebugName)
{
    // Add our backgrounds.
    normalImage.setNineSliceImage(Paths::TEXTURE_DIR + "MainButton/Normal.png",
                                  {2, 2, 2, 2});
    hoveredImage.setNineSliceImage(
        Paths::TEXTURE_DIR + "MainButton/Hovered.png", {2, 2, 2, 2});
    pressedImage.setNineSliceImage(
        Paths::TEXTURE_DIR + "MainButton/Pressed.png", {2, 2, 2, 2});
    disabledImage.setNineSliceImage(
        Paths::TEXTURE_DIR + "MainButton/Disabled.png", {2, 2, 2, 2});

    // Set our text properties.
    text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    text.setColor({255, 255, 255, 255});
    text.setText(inText);
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/MainTextInput.cpp`:

```cpp
#include "MainTextInput.h"
#include "Paths.h"

namespace AM
{
namespace ResourceImporter
{
MainTextInput::MainTextInput(const SDL_Rect& inLogicalExtent,
                             const std::string& inDebugName)
: AUI::TextInput(inLogicalExtent, inDebugName)
{
    // Add our backgrounds.
    normalImage.setSimpleImage(Paths::TEXTURE_DIR + "TextInput/Normal.png");
    hoveredImage.setSimpleImage(Paths::TEXTURE_DIR + "TextInput/Hovered.png");
    focusedImage.setSimpleImage(Paths::TEXTURE_DIR + "TextInput/Selected.png");
    disabledImage.setSimpleImage(Paths::TEXTURE_DIR + "TextInput/Disabled.png");

    // Set our text properties.
    setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 25);

    // Set our input box properties.
    setCursorWidth(2);
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/MainThumbnail.cpp`:

```cpp
#include "MainThumbnail.h"
#include "Paths.h"

namespace AM
{
namespace ResourceImporter
{
MainThumbnail::MainThumbnail(const std::string& inDebugName)
: AUI::Thumbnail({0, 0, 150, 150}, inDebugName)
{
    // Add our backgrounds.
    hoveredImage.setSimpleImage(Paths::TEXTURE_DIR + "Thumbnail/Hovered.png");
    activeImage.setSimpleImage(Paths::TEXTURE_DIR + "Thumbnail/Active.png");
    backdropImage.setSimpleImage(Paths::TEXTURE_DIR + "Thumbnail/Backdrop.png");
    selectedImage.setSimpleImage(Paths::TEXTURE_DIR + "Thumbnail/Selected.png");

    // Move our thumbnail image to the right position.
    thumbnailImage.setLogicalExtent({27, 15, 96, 96});

    // Set our text properties.
    setTextLogicalExtent({13, 120, 123, 20});
    setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 15);
    setTextColor({255, 255, 255, 255});
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/ParentListItem.cpp`:

```cpp
#include "ParentListItem.h"
#include "Paths.h"
#include "AUI/ScalingHelpers.h"
#include <SDL_rect.h>

namespace AM
{
namespace ResourceImporter
{
ParentListItem::ParentListItem(const std::string& inHeaderText,
                               const std::string& inDebugName)
: LibraryListItem("", inDebugName)
// Note: We use our child's text and leave our parent ListItem's blank, so
//       that all of the text and arrows are above our highlight images.
, childListItemContainer(inHeaderText)
{
    // Add our children so they're included in rendering, etc.
    children.push_back(childListItemContainer);

    // Set our padding.
    childListItemContainer.setLeftPadding(32);

    // Set our child container's click region to cover from the far left, to
    // the start of our text.
    SDL_Rect textLogicalExtent{
        childListItemContainer.headerText.getLogicalExtent()};
    childListItemContainer.setClickRegionLogicalExtent(
        {0, 0, textLogicalExtent.x, textLogicalExtent.h});
}

AUI::EventResult ParentListItem::onMouseDown(AUI::MouseButtonType buttonType,
                                             const SDL_Point& cursorPosition)
{
    // Only respond to the left mouse button.
    if (buttonType != AUI::MouseButtonType::Left) {
        return AUI::EventResult{.wasHandled{false}};
    }

    // If our text was clicked, select this widget.
    if (SDL_PointInRect(&cursorPosition, &(text.getClippedExtent()))) {
        // Note: Our only difference in behavior from LibraryListItem is that 
        //       we only react to clicking on the text region, so we can just 
        //       call its handler.
        LibraryListItem::onMouseDown(buttonType, cursorPosition);
        return AUI::EventResult{.wasHandled{true}};
    }

    // Note: If our arrow was clicked, it'll be handled when this propagates
    //       to our child collapsible container.
    return AUI::EventResult{.wasHandled{false}};
}

AUI::EventResult
    ParentListItem::onMouseDoubleClick(AUI::MouseButtonType buttonType,
                                       const SDL_Point& cursorPosition)
{
    // Only respond to the left mouse button.
    if (buttonType != AUI::MouseButtonType::Left) {
        return AUI::EventResult{.wasHandled{false}};
    }

    // If our text was clicked, select this widget.
    if (SDL_PointInRect(&cursorPosition, &(text.getClippedExtent()))) {
        // Note: Our only difference in behavior from LibraryListItem is that 
        //       we only react to clicking on the text region, so we can just 
        //       call its handler.
        LibraryListItem::onMouseDoubleClick(buttonType, cursorPosition);
    }

    // Note: If our arrow was clicked, it'll be handled when this propagates
    //       to our child collapsible container.
    return AUI::EventResult{.wasHandled{false}};
}

AUI::EventResult ParentListItem::onMouseMove(const SDL_Point& cursorPosition)
{
    // If the mouse is within the header extent.
    SDL_Rect headerExtent{childListItemContainer.getHeaderExtent()};
    if (SDL_PointInRect(&cursorPosition, &headerExtent)) {
        // If we're not selected or hovered, become hovered.
        if (!isSelected && !isHovered) {
            setIsHovered(true);
        }

        return AUI::EventResult{.wasHandled{true}};
    }
    else if (isHovered) {
        // We're hovered and the mouse is outside the header, unhover.
        setIsHovered(false);
    }

    return AUI::EventResult{.wasHandled{false}};
}

void ParentListItem::onMouseEnter()
{
    // We handle this in onMouseMove(), but we override this to stop
    // LibraryListItem's behavior.
}

void ParentListItem::onMouseLeave()
{
    // If we're hovered, unhover.
    if (isHovered) {
        setIsHovered(false);
    }
}

void ParentListItem::measure(const SDL_Rect& availableExtent)
{
    // Run the normal measure step (measures our children and sets our 
    // scaledExtent).
    Widget::measure(availableExtent);

    // Since our child container might expand or collapse, adjust our height to 
    // match.
    logicalExtent.h = childListItemContainer.getLogicalExtent().h;
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/PointGizmo.cpp`:

```cpp
#include "PointGizmo.h"
#include "Transforms.h"
#include "Camera.h"
#include "Position.h"
#include "SpriteTools.h"
#include "SharedConfig.h"
#include "Log.h"
#include "AUI/Core.h"
#include "AUI/ScalingHelpers.h"
#include "AUI/SDLHelpers.h"
#include <algorithm>
#include <SDL_rect.h>
#include <SDL2_gfxPrimitives.h>

namespace AM
{
namespace ResourceImporter
{
PointGizmo::PointGizmo(const SDL_Rect& inLogicalExtent)
: AUI::Widget(inLogicalExtent, "PointGizmo")
, lastUsedScreenSize{0, 0}
, point{}
, isEnabled{true}
, scaledRectSize{AUI::ScalingHelpers::logicalToActual(LOGICAL_RECT_SIZE)}
, logicalSpriteImageExtent{0, 0, 0, 0}
, logicalStageOrigin{0, 0}
, stageWorldExtent{}
, pointControlExtent{0, 0, scaledRectSize, scaledRectSize}
, currentlyHeld{false}
{
}

void PointGizmo::enable()
{
    isEnabled = true;
    refreshGraphics();
}

void PointGizmo::disable()
{
    isEnabled = false;
    refreshGraphics();
}

void PointGizmo::setSpriteImageSize(int logicalSpriteWidth,
                                          int logicalSpriteHeight)
{
    logicalSpriteImageExtent.x
        = (logicalExtent.w / 2) - (logicalSpriteWidth / 2);
    logicalSpriteImageExtent.y
        = (logicalExtent.h / 2) - (logicalSpriteHeight / 2);
    logicalSpriteImageExtent.w = logicalSpriteWidth;
    logicalSpriteImageExtent.h = logicalSpriteHeight;

    updateStageExtent();
    refreshGraphics();
}

void PointGizmo::setStageOrigin(const SDL_Point& inLogicalStageOrigin)
{
    logicalStageOrigin = inLogicalStageOrigin;
    updateStageExtent();
    refreshGraphics();
}

void PointGizmo::setPoint(const Vector3& newPoint)
{
    point = newPoint;
    refreshGraphics();
}

const SDL_Rect& PointGizmo::getLogicalCenteredSpriteExtent() const
{
    return logicalSpriteImageExtent;
}

void PointGizmo::setOnPointUpdated(
    std::function<void(const Vector3&)> inOnPointUpdated)
{
    onPointUpdated = std::move(inOnPointUpdated);
}

void PointGizmo::setLogicalExtent(const SDL_Rect& inLogicalExtent)
{
    Widget::setLogicalExtent(inLogicalExtent);
    updateStageExtent();
    refreshGraphics();
}

void PointGizmo::arrange(const SDL_Point& startPosition,
                               const SDL_Rect& availableExtent,
                               AUI::WidgetLocator* widgetLocator)
{
    // Note: This custom arrange isn't really needed, since ResourceImporter
    //       isn't likely to change screen size at runtime. It's nice to keep
    //       as an example though, of what to do if you have custom graphics 
    //       that rely on clippedExtent for layout.

    // Run the normal arrange step.
    Widget::arrange(startPosition, availableExtent, widgetLocator);

    // If this widget is fully clipped, return early.
    if (SDL_RectEmpty(&clippedExtent)) {
        return;
    }

    // If the UI scaling has changed, refresh everything.
    // Note: This has to be done after arranging, since it uses clippedExtent.
    if (lastUsedScreenSize != AUI::Core::getActualScreenSize()) {
        refreshScaling();
        lastUsedScreenSize = AUI::Core::getActualScreenSize();
    }
}

void PointGizmo::render(const SDL_Point& windowTopLeft)
{
    // If this widget is fully clipped, don't render it.
    if (SDL_RectEmpty(&clippedExtent)) {
        return;
    }

    // If this gizmo is disabled, make it semi-transparent.
    float alpha{BASE_ALPHA};
    if (!isEnabled) {
        alpha *= DISABLED_ALPHA_FACTOR;
    }

    // Render the point.
    SDL_Rect offsetExtent{pointControlExtent};
    offsetExtent.x += windowTopLeft.x;
    offsetExtent.y += windowTopLeft.y;

    SDL_SetRenderDrawBlendMode(AUI::Core::getRenderer(), SDL_BLENDMODE_BLEND);
    SDL_SetRenderDrawColor(AUI::Core::getRenderer(), 0, 0, 0,
                           static_cast<Uint8>(alpha));
    SDL_RenderFillRect(AUI::Core::getRenderer(), &offsetExtent);
}

AUI::EventResult PointGizmo::onMouseDown(AUI::MouseButtonType buttonType,
                                               const SDL_Point& cursorPosition)
{
    // Do nothing if disabled. Only respond to the left mouse button.
    if (!isEnabled || (buttonType != AUI::MouseButtonType::Left)) {
        return AUI::EventResult{.wasHandled{false}};
    }

    // Check if the mouse press hit our control.
    if (SDL_PointInRect(&cursorPosition, &pointControlExtent)) {
        currentlyHeld = true;
    }

    // If the cursor is holding a control, set mouse capture so we get the
    // associated MouseUp.
    if (currentlyHeld) {
        return AUI::EventResult{.wasHandled{true}, .setMouseCapture{this}};
    }
    else {
        return AUI::EventResult{.wasHandled{true}};
    }
}

AUI::EventResult PointGizmo::onMouseUp(AUI::MouseButtonType buttonType,
                                             const SDL_Point&)
{
    // Only respond to the left mouse button.
    if (buttonType != AUI::MouseButtonType::Left) {
        return AUI::EventResult{.wasHandled{false}};
    }

    // If we're holding a control, release it and release mouse capture.
    if (currentlyHeld) {
        currentlyHeld = false;
        return AUI::EventResult{.wasHandled{true}, .releaseMouseCapture{true}};
    }
    else {
        return AUI::EventResult{.wasHandled{true}};
    }
}

AUI::EventResult PointGizmo::onMouseMove(const SDL_Point& cursorPosition)
{
    // If a control isn't currently being held, ignore the event.
    if (!currentlyHeld) {
        return AUI::EventResult{.wasHandled{false}};
    }

    /* Translate the mouse position to world space. */
    // Account for this widget's position.
    SDL_Rect actualSpriteImageExtent{
        AUI::ScalingHelpers::logicalToActual(logicalSpriteImageExtent)};
    SDL_Point actualStageOrigin{
        AUI::ScalingHelpers::logicalToActual(logicalStageOrigin)};
    int finalXOffset{clippedExtent.x + actualSpriteImageExtent.x
                     + actualStageOrigin.x};
    int finalYOffset{clippedExtent.y + actualSpriteImageExtent.y
                     + actualStageOrigin.y};

    // Apply the offset to the mouse position and convert to logical space.
    SDL_Point offsetMousePoint{cursorPosition.x - finalXOffset,
                               cursorPosition.y - finalYOffset};
    offsetMousePoint = AUI::ScalingHelpers::actualToLogical(offsetMousePoint);

    // Convert the screen-space mouse point to world space.
    SDL_FPoint offsetMouseScreenPoint{static_cast<float>(offsetMousePoint.x),
                                      static_cast<float>(offsetMousePoint.y)};
    Position mouseWorldPos{
        Transforms::screenToWorldMinimum(offsetMouseScreenPoint, {})};

    // Adjust the currently pressed control appropriately.
    updatePoint(mouseWorldPos);

    return AUI::EventResult{.wasHandled{true}};
}

void PointGizmo::refreshScaling()
{
    // Re-calculate our control rectangle size.
    scaledRectSize = AUI::ScalingHelpers::logicalToActual(LOGICAL_RECT_SIZE);

    // Refresh our controls to reflect the new sizes.
    refreshGraphics();
}

void PointGizmo::updateStageExtent()
{
    stageWorldExtent = SpriteTools::calcSpriteStageWorldExtent(
        logicalSpriteImageExtent, logicalStageOrigin);
}

void PointGizmo::refreshGraphics()
{
    // Calculate where the point is on the screen.
    SDL_FPoint screenPoint{Transforms::worldToScreen(point, 1)};

    // Account for this widget's position and the image's position.
    SDL_Rect actualSpriteImageExtent{
        AUI::ScalingHelpers::logicalToActual(logicalSpriteImageExtent)};
    SDL_Point actualStageOrigin{
        AUI::ScalingHelpers::logicalToActual(logicalStageOrigin)};
    int finalXOffset{clippedExtent.x + actualSpriteImageExtent.x
                     + actualStageOrigin.x};
    int finalYOffset{clippedExtent.y + actualSpriteImageExtent.y
                     + actualStageOrigin.y};

    // Scale and round the point.
    screenPoint.x
        = std::round(AUI::ScalingHelpers::logicalToActual(screenPoint.x));
    screenPoint.y
        = std::round(AUI::ScalingHelpers::logicalToActual(screenPoint.y));

    // Offset the point.
    screenPoint.x += finalXOffset;
    screenPoint.y += finalYOffset;

    // Calc half the control rectangle size so we can center the control.
    int halfRectSize{static_cast<int>(scaledRectSize / 2.f)};

    // Move the control to the correct position.
    pointControlExtent.x = static_cast<int>(screenPoint.x - halfRectSize);
    pointControlExtent.y = static_cast<int>(screenPoint.y - halfRectSize);
}

void PointGizmo::updatePoint(const Position& mouseWorldPos)
{
    // TODO: If shift is held, only move along the Z axis

    // Note: The expected behavior is to move along the x/y plane and
    //       leave minZ where it was.
    Vector3 updatedPoint{point};
    float& x{updatedPoint.x};
    float& y{updatedPoint.y};

    // Move the point to its new position.
    x = mouseWorldPos.x;
    y = mouseWorldPos.y;

    // If we moved below the model-space origin (0, 0), bring the point back 
    // in.
    if (x < 0) {
        x = 0;
    }
    if (y < 0) {
        y = 0;
    }

    // If we moved outside the stage bounds, bring the point back in.
    if (x > stageWorldExtent.max.x) {
        x = stageWorldExtent.max.x;
    }
    if (y > stageWorldExtent.max.y) {
        y = stageWorldExtent.max.y;
    }

    // Signal the updated point.
    // Note: We don't update our internal point until our owner saves the 
    //       update in the model and it signals us.
    if (onPointUpdated) {
        onPointUpdated(updatedPoint);
    }
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/StageGraphic.cpp`:

```cpp
#include "StageGraphic.h"
#include "SpriteTools.h"
#include "Transforms.h"
#include "BoundingBox.h"
#include "AUI/Core.h"
#include "AUI/ScalingHelpers.h"
#include <SDL2_gfxPrimitives.h>

namespace AM
{
namespace ResourceImporter
{
StageGraphic::StageGraphic(const SDL_Rect& inLogicalExtent)
: AUI::Widget({320, 58, 1297, 1022}, "StageGraphic")
, stageXCoords{}
, stageYCoords{}
{
}

void StageGraphic::updateStage(const SDL_Rect& spriteTextureExtent,
                               const SDL_Point& stageOrigin,
                               const SDL_Point& actualSpriteImageOffset)
{
    // Calculate where the stage is on the screen, for our generated graphics.
    std::vector<SDL_Point> screenPoints{};
    calcStageScreenPoints(spriteTextureExtent, stageOrigin,
                          actualSpriteImageOffset, screenPoints);

    // Move the stage graphic coords to the correct positions.
    moveStageGraphic(screenPoints);
}

void StageGraphic::render(const SDL_Point& windowTopLeft)
{
    // If this widget is fully clipped, don't render it.
    if (SDL_RectEmpty(&clippedExtent)) {
        return;
    }

    renderStage(windowTopLeft);
}

void StageGraphic::calcStageScreenPoints(
    const SDL_Rect& spriteTextureExtent, const SDL_Point& stageOrigin,
    const SDL_Point& actualSpriteImageOffset,
    std::vector<SDL_Point>& stageScreenPoints)
{
    /* Transform the world positions to screen points. */
    std::array<SDL_FPoint, 4> screenPoints{};

    // Push the points in the correct order.
    BoundingBox stageWorldExtent{SpriteTools::calcSpriteStageWorldExtent(
        spriteTextureExtent, stageOrigin)};
    const Vector3& minPoint{stageWorldExtent.min};
    const Vector3& maxPoint{stageWorldExtent.max};
    Vector3 point{minPoint.x, minPoint.y, minPoint.z};
    screenPoints[0] = Transforms::worldToScreen(point, 1);

    point = {maxPoint.x, minPoint.y, minPoint.z};
    screenPoints[1] = Transforms::worldToScreen(point, 1);

    point = {maxPoint.x, maxPoint.y, minPoint.z};
    screenPoints[2] = Transforms::worldToScreen(point, 1);

    point = {minPoint.x, maxPoint.y, minPoint.z};
    screenPoints[3] = Transforms::worldToScreen(point, 1);

    // Account for the gizmo's position and the image's position.
    SDL_Point actualStageOrigin{
        AUI::ScalingHelpers::logicalToActual(stageOrigin)};
    int finalXOffset{actualSpriteImageOffset.x + actualStageOrigin.x};
    int finalYOffset{actualSpriteImageOffset.y + actualStageOrigin.y};

    // Scale and offset each point, then push it into the return vector.
    for (SDL_FPoint& point : screenPoints) {
        // Scale and round the point.
        point.x = std::round(AUI::ScalingHelpers::logicalToActual(point.x));
        point.y = std::round(AUI::ScalingHelpers::logicalToActual(point.y));

        // Offset the point.
        point.x += finalXOffset;
        point.y += finalYOffset;

        // Cast to int and push into the return vector.
        stageScreenPoints.push_back(
            {static_cast<int>(point.x), static_cast<int>(point.y)});
    }
}

void StageGraphic::moveStageGraphic(
    std::vector<SDL_Point>& stageScreenPoints)
{
    // Set the coords for the bottom face of the stage. (coords 0 - 3, starting
    // from top left and going clockwise.)
    stageXCoords[0] = stageScreenPoints[0].x;
    stageYCoords[0] = stageScreenPoints[0].y;
    stageXCoords[1] = stageScreenPoints[1].x;
    stageYCoords[1] = stageScreenPoints[1].y;
    stageXCoords[2] = stageScreenPoints[2].x;
    stageYCoords[2] = stageScreenPoints[2].y;
    stageXCoords[3] = stageScreenPoints[3].x;
    stageYCoords[3] = stageScreenPoints[3].y;
}

void StageGraphic::renderStage(const SDL_Point& windowTopLeft)
{
    /* Offset all the points. */
    std::array<Sint16, 4> offsetXCoords{};
    for (std::size_t i = 0; i < offsetXCoords.size(); ++i) {
        offsetXCoords[i] = stageXCoords[i] + windowTopLeft.x;
    }

    std::array<Sint16, 4> offsetYCoords{};
    for (std::size_t i = 0; i < offsetYCoords.size(); ++i) {
        offsetYCoords[i] = stageYCoords[i] + windowTopLeft.y;
    }

    /* Draw the stage's floor bounds. */
    filledPolygonRGBA(AUI::Core::getRenderer(), &(offsetXCoords[0]),
                      &(offsetYCoords[0]), 4, 0, 149, 0,
                      static_cast<Uint8>(STAGE_ALPHA));
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/TimelineFrame.cpp`:

```cpp
#include "TimelineFrame.h"
#include "AUI/Core.h"
#include "AUI/ScalingHelpers.h"
#include <SDL2_gfxPrimitives.h>

namespace AM
{
namespace ResourceImporter
{
TimelineFrame::TimelineFrame()
: AUI::Widget({0, 0, LOGICAL_WIDTH, 26}, "TimelineFrame")
, hasSprite{false}
, drawDarkBackground{false}
, isDragging{false}
{
}

void TimelineFrame::setOnPressed(std::function<void(void)> inOnPressed)
{
    onPressed = std::move(inOnPressed);
}

void TimelineFrame::setOnSpriteDragStarted(
    std::function<void(const SDL_Point&)> inOnSpriteDragStarted)
{
    onSpriteDragStarted = std::move(inOnSpriteDragStarted);
}

void TimelineFrame::setOnSpriteDragged(
    std::function<void(const SDL_Point&)> inOnSpriteDragged)
{
    onSpriteDragged = std::move(inOnSpriteDragged);
}

void TimelineFrame::setOnSpriteDragReleased(
    std::function<void(const SDL_Point&)> inOnSpriteDragReleased)
{
    onSpriteDragReleased = std::move(inOnSpriteDragReleased);
}

void TimelineFrame::render(const SDL_Point& windowTopLeft)
{
    // Render the larger outline rectangle.
    SDL_Rect finalExtent{clippedExtent};
    finalExtent.x += windowTopLeft.x;
    finalExtent.y += windowTopLeft.y;
    SDL_SetRenderDrawColor(AUI::Core::getRenderer(), 184, 184, 184, 255);
    SDL_RenderFillRect(AUI::Core::getRenderer(), &finalExtent);

    // Render the body rectangle.
    const int borderSize{AUI::ScalingHelpers::logicalToActual(1)};
    finalExtent.x += borderSize;
    finalExtent.y += borderSize;
    finalExtent.w -= (borderSize * 2);
    finalExtent.h -= (borderSize * 2);
    if (!drawDarkBackground) {
        SDL_SetRenderDrawColor(AUI::Core::getRenderer(), 230, 230, 230, 255);
    }
    SDL_RenderFillRect(AUI::Core::getRenderer(), &finalExtent);

    // If this frame has a sprite, render the circle.
    if (hasSprite) {
        SDL_Point frameCenter{(finalExtent.x + (finalExtent.w / 2)),
                              (finalExtent.y + (finalExtent.h / 2))};
        int radius{AUI::ScalingHelpers::logicalToActual(7)};
        filledCircleRGBA(AUI::Core::getRenderer(), frameCenter.x, frameCenter.y,
                         radius, 64, 64, 64, 255);
    }
}

AUI::EventResult TimelineFrame::onMouseDown(AUI::MouseButtonType buttonType,
                                           const SDL_Point& cursorPosition)
{
    // If the right mouse button was pressed and we have a sprite to drag, 
    // start dragging.
    if ((buttonType == AUI::MouseButtonType::Right) && hasSprite) {
        isDragging = true;

        if (onSpriteDragStarted) {
            onSpriteDragStarted(cursorPosition);
        }

        return AUI::EventResult{.wasHandled{true}, .setMouseCapture{this}};
    }
    // Otherwise, only respond to the left mouse button.
    else if (buttonType != AUI::MouseButtonType::Left) {
        return AUI::EventResult{.wasHandled{false}};
    }

    // If the user set a callback, call it.
    if (onPressed) {
        onPressed();
    }

    return AUI::EventResult{.wasHandled{true}};
}

AUI::EventResult
    TimelineFrame::onMouseDoubleClick(AUI::MouseButtonType buttonType,
                                     const SDL_Point& cursorPosition)
{
    // We treat additional clicks as regular MouseDown events.
    return onMouseDown(buttonType, cursorPosition);
}

AUI::EventResult TimelineFrame::onMouseUp(AUI::MouseButtonType buttonType,
                                         const SDL_Point& cursorPosition)
{
    if (isDragging) {
        isDragging = false;

        if (onSpriteDragReleased) {
            onSpriteDragReleased(cursorPosition);
        }

        return AUI::EventResult{.wasHandled{true}};
    }

    return AUI::EventResult{.wasHandled{false}, .releaseMouseCapture{true}};
}

AUI::EventResult TimelineFrame::onMouseMove(const SDL_Point& cursorPosition)
{
    if (isDragging) {
        if (onSpriteDragged) {
            onSpriteDragged(cursorPosition);
        }

        return AUI::EventResult{.wasHandled{true}};
    }

    return AUI::EventResult{.wasHandled{false}};
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/TimelineHandle.cpp`:

```cpp
#include "TimelineHandle.h"
#include "AUI/Core.h"
#include "AUI/WidgetLocator.h"
#include "AUI/ScalingHelpers.h"

namespace AM
{
namespace ResourceImporter
{
TimelineHandle::TimelineHandle(const SDL_Rect& inLogicalExtent)
: AUI::Widget(inLogicalExtent, "TimelineHandle")
, color{24, 155, 243, 191}
, renderLine{true}
, isDragging{false}
, rectLogicalExtent{0, 0, 24, 24}
, rectClippedExtent{0, 0, 0, 0}
, lineLogicalExtent{9, 24, 6, 24}
, lineClippedExtent{0, 0, 0, 0}
{
}

void TimelineHandle::setOnDragged(
    std::function<void(const SDL_Point&)> inOnDragged)
{
    onDragged = std::move(inOnDragged);
}

void TimelineHandle::setColor(const SDL_Color& inColor)
{
    color = inColor;
}

void TimelineHandle::setRenderLine(bool inRenderLine)
{
    renderLine = inRenderLine;
}

void TimelineHandle::arrange(const SDL_Point& startPosition,
                               const SDL_Rect& availableExtent,
                               AUI::WidgetLocator* widgetLocator)
{
    // Run the normal arrange step.
    Widget::arrange(startPosition, availableExtent, widgetLocator);

    // If this widget is fully clipped, return early.
    if (SDL_RectEmpty(&clippedExtent)) {
        return;
    }

    // Note: One could imagine creating widgets to wrap these graphics so 
    //       they could be automatically managed by the layout system.
    //       It seems very heavyweight to add them to the widget tree just 
    //       for layout/rendering though, so we handle this manually.
    SDL_Rect rectOffsetExtent{rectLogicalExtent};
    rectOffsetExtent.x += logicalExtent.x;
    rectOffsetExtent.y += logicalExtent.y;
    rectClippedExtent = AUI::ScalingHelpers::logicalToClipped(
        rectOffsetExtent, startPosition, availableExtent);

    SDL_Rect lineOffsetExtent{lineLogicalExtent};
    lineOffsetExtent.x += logicalExtent.x;
    lineOffsetExtent.y += logicalExtent.y;
    lineClippedExtent = AUI::ScalingHelpers::logicalToClipped(
        lineOffsetExtent, startPosition, availableExtent);
}

void TimelineHandle::render(const SDL_Point& windowTopLeft)
{
    // Render the rect.
    SDL_SetRenderDrawBlendMode(AUI::Core::getRenderer(), SDL_BLENDMODE_BLEND);
    SDL_SetRenderDrawColor(AUI::Core::getRenderer(), color.r, color.g, color.b,
                           color.a);
    if (!SDL_RectEmpty(&rectClippedExtent)) {
        SDL_Rect finalExtent{rectClippedExtent};
        finalExtent.x += windowTopLeft.x;
        finalExtent.y += windowTopLeft.y;
        SDL_RenderFillRect(AUI::Core::getRenderer(), &finalExtent);
    }

    // Render the line.
    if (renderLine && !SDL_RectEmpty(&lineClippedExtent)) {
        SDL_Rect finalExtent{lineClippedExtent};
        finalExtent.x += windowTopLeft.x;
        finalExtent.y += windowTopLeft.y;
        SDL_RenderFillRect(AUI::Core::getRenderer(), &finalExtent);
    }
}

AUI::EventResult TimelineHandle::onMouseDown(AUI::MouseButtonType buttonType,
                                           const SDL_Point& cursorPosition)
{
    // Only respond to the left mouse button.
    if (buttonType != AUI::MouseButtonType::Left) {
        return AUI::EventResult{.wasHandled{false}};
    }

    isDragging = true;

    return AUI::EventResult{.wasHandled{true}, .setMouseCapture{this}};
}

AUI::EventResult
    TimelineHandle::onMouseDoubleClick(AUI::MouseButtonType buttonType,
                                     const SDL_Point& cursorPosition)
{
    // We treat additional clicks as regular MouseDown events.
    return onMouseDown(buttonType, cursorPosition);
}

AUI::EventResult TimelineHandle::onMouseUp(AUI::MouseButtonType buttonType,
                                             const SDL_Point& cursorPosition)
{
    if (isDragging) {
        isDragging = false;
        return AUI::EventResult{.wasHandled{true}};
    }

    return AUI::EventResult{.wasHandled{false}, .releaseMouseCapture{true}};
}

AUI::EventResult TimelineHandle::onMouseMove(const SDL_Point& cursorPosition)
{
    if (isDragging && onDragged) {
        onDragged(cursorPosition);
        return AUI::EventResult{.wasHandled{true}};
    }

    return AUI::EventResult{.wasHandled{false}};
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Widgets/TitleButton.cpp`:

```cpp
#include "TitleButton.h"
#include "Paths.h"

namespace AM
{
namespace ResourceImporter
{
TitleButton::TitleButton(const SDL_Rect& inLogicalExtent,
                         const std::string& inText,
                         const std::string& inDebugName)
: AUI::Button(inLogicalExtent, inDebugName)
{
    // Add our backgrounds.
    normalImage.setNineSliceImage(
        Paths::TEXTURE_DIR + "MainButton/NormalThick.png", {4, 4, 4, 4});
    hoveredImage.setNineSliceImage(
        Paths::TEXTURE_DIR + "MainButton/HoveredThick.png", {4, 4, 4, 4});
    pressedImage.setNineSliceImage(
        Paths::TEXTURE_DIR + "MainButton/PressedThick.png", {4, 4, 4, 4});
    disabledImage.setNineSliceImage(
        Paths::TEXTURE_DIR + "MainButton/DisabledThick.png", {4, 4, 4, 4});

    // Set our text properties.
    text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 33);
    text.setColor({255, 255, 255, 255});
    text.setText(inText);
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/AddIconSheetDialog.cpp`:

```cpp
#include "AddIconSheetDialog.h"
#include "MainScreen.h"
#include "MainThumbnail.h"
#include "DataModel.h"
#include "Paths.h"

namespace AM
{
namespace ResourceImporter
{
AddIconSheetDialog::AddIconSheetDialog(DataModel& inDataModel)
: AUI::Window({0, 0, 1920, 1080}, "AddIconSheetDialog")
, shadowImage({0, 0, logicalExtent.w, logicalExtent.h})
, backgroundImage({719, 208, 523, 506})
, headerText({747, 228, 280, 60})
, pathLabel({747, 300, 151, 38})
, pathInput({919, 300, 180, 38})
, widthLabel({747, 350, 151, 38})
, widthInput({919, 350, 180, 38})
, heightLabel({747, 400, 151, 38})
, heightInput({919, 400, 180, 38})
, nameLabel({747, 450, 151, 38})
, nameInput({919, 450, 180, 38})
, addButton({1099, 640, 123, 56}, "Add")
, cancelButton({958, 640, 123, 56}, "Cancel")
, dataModel{inDataModel}
, errorText({748, 556, 466, 60})
{
    // Add our children so they're included in rendering, etc.
    children.push_back(shadowImage);
    children.push_back(backgroundImage);
    children.push_back(headerText);
    children.push_back(pathLabel);
    children.push_back(pathInput);
    children.push_back(widthLabel);
    children.push_back(widthInput);
    children.push_back(heightLabel);
    children.push_back(heightInput);
    children.push_back(nameLabel);
    children.push_back(nameInput);
    children.push_back(addButton);
    children.push_back(cancelButton);
    children.push_back(errorText);

    /* Background shadow image. */
    shadowImage.setSimpleImage(Paths::TEXTURE_DIR + "Dialogs/Shadow.png");

    /* Background image. */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});

    /* Header text. */
    headerText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 32);
    headerText.setColor({255, 255, 255, 255});
    headerText.setText("Add icon sheet");

    /* Path entry. */
    pathLabel.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 21);
    pathLabel.setColor({255, 255, 255, 255});
    pathLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    pathLabel.setText("Relative Path");

    pathInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    pathInput.setPadding({0, 8, 0, 8});

    /* Width entry. */
    widthLabel.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 21);
    widthLabel.setColor({255, 255, 255, 255});
    widthLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    widthLabel.setText("Icon Width");

    widthInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    widthInput.setPadding({0, 8, 0, 8});

    /* Height entry. */
    heightLabel.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 21);
    heightLabel.setColor({255, 255, 255, 255});
    heightLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    heightLabel.setText("Icon Height");

    heightInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    heightInput.setPadding({0, 8, 0, 8});

    /* Name entry. */
    nameLabel.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 21);
    nameLabel.setColor({255, 255, 255, 255});
    nameLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    nameLabel.setText("Base Name");

    nameInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    nameInput.setPadding({0, 8, 0, 8});

    /* Confirmation buttons. */
    // Add a callback to validate the input and add the new icon sheet.
    addButton.setOnPressed([this]() {
        // Pass the user-inputted data to the model.
        bool result{dataModel.iconModel.addIconSheet(
            pathInput.getText(), widthInput.getText(), heightInput.getText(),
            nameInput.getText())};

        // If the data was valid.
        if (result) {
            // Clear this dialog's text to prepare for the next usage.
            clear();

            // Remove the dialog.
            errorText.setIsVisible(false);
            setIsVisible(false);
        }
        else {
            // Data wasn't valid, display an error string.
            errorText.setText(dataModel.spriteModel.getErrorString());
            errorText.setIsVisible(true);
        }
    });

    // Add a callback to remove the dialog on cancel.
    cancelButton.setOnPressed([&]() {
        // Clear the text inputs and labels.
        clear();

        // Remove the dialog.
        setIsVisible(false);
    });

    /* Error text. */
    errorText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 20);
    errorText.setColor({255, 255, 255, 255});
    errorText.setText("Uninitialized.");
    errorText.setIsVisible(false);
}

void AddIconSheetDialog::clear()
{
    pathInput.setText("");
    widthInput.setText("");
    heightInput.setText("");
    nameInput.setText("");
    errorText.setText("");
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/AddSpriteDialog.cpp`:

```cpp
#include "AddSpriteDialog.h"
#include "MainScreen.h"
#include "MainThumbnail.h"
#include "DataModel.h"
#include "Paths.h"

namespace AM
{
namespace ResourceImporter
{
AddSpriteDialog::AddSpriteDialog(MainScreen& inMainScreen,
                                 DataModel& inDataModel)
: AUI::Window({0, 0, 1920, 1080}, "AddSpriteDialog")
, shadowImage({0, 0, logicalExtent.w, logicalExtent.h})
, backgroundImage({719, 208, 523, 506})
, headerText({747, 228, 280, 60})
, stageOriginXLabel({747, 300, 210, 38})
, stageOriginXInput({967, 300, 180, 38})
, stageOriginYLabel({747, 350, 210, 38})
, stageOriginYInput({967, 350, 180, 38})
, premultiplyAlphaLabel({747, 400, 210, 38})
, premultiplyAlphaInput({967, 408, 22, 22})
, addButton({1098, 640, 120, 50}, "Add")
, cancelButton({958, 640, 120, 50}, "Cancel")
, mainScreen{inMainScreen}
, dataModel{inDataModel}
, activeSpriteSheetID{NULL_SPRITE_SHEET_ID}
, spriteImageRelPaths{}
, errorText({747, 408, 466, 60})
{
    // Add our children so they're included in rendering, etc.
    children.push_back(shadowImage);
    children.push_back(backgroundImage);
    children.push_back(headerText);
    children.push_back(stageOriginXLabel);
    children.push_back(stageOriginXInput);
    children.push_back(stageOriginYLabel);
    children.push_back(stageOriginYInput);
    children.push_back(premultiplyAlphaLabel);
    children.push_back(premultiplyAlphaInput);
    children.push_back(addButton);
    children.push_back(cancelButton);
    children.push_back(errorText);

    /* Background shadow image. */
    shadowImage.setSimpleImage(Paths::TEXTURE_DIR + "Dialogs/Shadow.png");

    /* Background image. */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});

    /* Header text. */
    headerText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 32);
    headerText.setColor({255, 255, 255, 255});
    headerText.setText("Add sprite");

    /* Stage origin entry. */
    auto styleLabel
        = [&](AUI::Text& label, const std::string& text, int fontSize) {
        label.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), fontSize);
        label.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
        label.setColor({255, 255, 255, 255});
        label.setText(text);
    };
    styleLabel(stageOriginXLabel, "Stage Origin X", 21);

    auto styleTextInput = [&](AUI::TextInput& textInput) {
        textInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
        textInput.setPadding({0, 8, 0, 8});
    };
    styleTextInput(stageOriginXInput);

    styleLabel(stageOriginYLabel, "Stage Origin Y", 21);
    styleTextInput(stageOriginYInput);

    /* Premultiply alpha entry. */
    styleLabel(premultiplyAlphaLabel, "Premultiply alpha", 21);

    premultiplyAlphaInput.uncheckedImage.setSimpleImage(
        Paths::TEXTURE_DIR + "Checkbox/Unchecked.png");
    premultiplyAlphaInput.checkedImage.setSimpleImage(Paths::TEXTURE_DIR
                                                      + "Checkbox/Checked.png");
    premultiplyAlphaInput.setOnChecked([this]() {});
    premultiplyAlphaInput.setOnUnchecked([this]() {});

    /* Confirmation buttons. */
    // Add a callback to validate the input and add the new sprites.
    addButton.setOnPressed([this]() {
        // Pass the user-inputted data to the model.
        bool allSpritesAdded{true};
        for (const std::string& spriteImageRelPath : spriteImageRelPaths) {
            bool premultiplyAlpha{premultiplyAlphaInput.getCurrentState()
                                  == AUI::Checkbox::State::Checked};
            if (!(dataModel.spriteModel.addSprite(
                    spriteImageRelPath, activeSpriteSheetID,
                    stageOriginXInput.getText(), stageOriginYInput.getText(),
                    premultiplyAlpha))) {
                std::string errorString{"Failed to add sprite: "};
                errorString += dataModel.spriteModel.getErrorString();
                mainScreen.openErrorDialog(errorString);
                break;
            }
        }

        // Clear this dialog's text to prepare for the next usage.
        clear();

        // Remove the dialog.
        errorText.setIsVisible(false);
        setIsVisible(false);
    });

    // Add a callback to remove the dialog on cancel.
    cancelButton.setOnPressed([&]() {
        // Clear the text inputs and labels.
        clear();

        // Remove the dialog.
        setIsVisible(false);
    });

    /* Error text. */
    errorText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 20);
    errorText.setColor({255, 255, 255, 255});
    errorText.setText("Uninitialized.");
    errorText.setIsVisible(false);

    // When the active sprite sheet is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&AddSpriteDialog::onActiveLibraryItemChanged>(*this);
}

void AddSpriteDialog::setSpriteImageRelPaths(
    const std::vector<std::string>& inSpriteImageRelPaths)
{
    spriteImageRelPaths = inSpriteImageRelPaths;

    std::string headerString{"Add "};
    headerString += std::to_string(spriteImageRelPaths.size());
    headerString += " sprite(s)";
    headerText.setText(headerString);
}

void AddSpriteDialog::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // If the new active item is a sprite sheet, save its ID.
    const EditorSpriteSheet* newActiveSpriteSheet{
        get_if<EditorSpriteSheet>(&newActiveItem)};
    if (newActiveSpriteSheet) {
        activeSpriteSheetID = newActiveSpriteSheet->numericID;
    }
    else {
        activeSpriteSheetID = NULL_SPRITE_SHEET_ID;
    }
}

void AddSpriteDialog::clear()
{
    stageOriginXInput.setText("");
    stageOriginYInput.setText("");
    errorText.setText("");
    premultiplyAlphaInput.setCurrentState(AUI::Checkbox::State::Unchecked);
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/AnimationEditView.cpp`:

```cpp
#include "AnimationEditView.h"
#include "DataModel.h"
#include "LibraryWindow.h"
#include "AnimationTimeline.h"
#include "SpriteID.h"
#include "Config.h"
#include "Paths.h"
#include "AUI/Core.h"
#include "AUI/ScalingHelpers.h"

namespace AM
{
namespace ResourceImporter
{
AnimationEditView::AnimationEditView(
    DataModel& inDataModel, LibraryWindow& inLibraryWindow,
    AnimationElementsWindow& inAnimationElementsWindow)
: AUI::Window({320, 58, 1297, 1022}, "AnimationEditView")
, dataModel{inDataModel}
, libraryWindow{inLibraryWindow}
, animationElementsWindow{inAnimationElementsWindow}
, activeAnimationID{NULL_SPRITE_ID}
, topText{{0, 0, logicalExtent.w, 34}, "TopText"}
, checkerboardImage{{0, 0, 100, 100}, "BackgroundImage"}
, stageGraphic{logicalExtent}
, spriteImage{{0, 0, 100, 100}, "SpriteImage"}
, boundingBoxGizmo{{0, 52, 1297, 732}}
, entityAlignmentAnchorGizmo{{0, 52, 1297, 732}}
, timelineScrollArea{{109, 772, 1080, 74}, "TimelineScrollArea"}
, descText{{24, 898, 1240, 100}, "DescText"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(topText);
    children.push_back(checkerboardImage);
    children.push_back(stageGraphic);
    children.push_back(spriteImage);
    children.push_back(boundingBoxGizmo);
    children.push_back(entityAlignmentAnchorGizmo);
    children.push_back(timelineScrollArea);
    children.push_back(descText);

    // Flag ourselves as focusable, so we can receive keyboard events.
    isFocusable = true;

    /* Text */
    topText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 26);
    topText.setColor({255, 255, 255, 255});
    topText.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Center);
    topText.setText("Animation");

    styleText(descText);
    descText.setText(
        "To play the animation: press the space bar. To move sprites within "
        "the timeline: right click and drag.\n\nEntity Alignment Anchors are "
        "only relevant to entity animations. Use them to manually align "
        "animations that don't naturally align with IdleSouth. If an animation "
        "does align with IdleSouth, no anchor is necessary.");

    /* Active sprite and checkerboard background. */
    checkerboardImage.setTiledImage(Paths::TEXTURE_DIR
                                    + "SpriteEditView/Checkerboard.png");
    checkerboardImage.setIsVisible(false);
    spriteImage.setIsVisible(false);

    /* Gizmos. */
    boundingBoxGizmo.setIsVisible(false);
    boundingBoxGizmo.setOnBoundingBoxUpdated(
        [&](const BoundingBox& updatedBounds) {
            onGizmoBoundingBoxUpdated(updatedBounds);
        });
    entityAlignmentAnchorGizmo.setIsVisible(false);
    entityAlignmentAnchorGizmo.setOnPointUpdated(
        [&](const Vector3& updatedPoint) {
            onGizmoEntityAlignmentAnchorUpdated(updatedPoint);
        });

    /* Timeline */
    SDL_Rect timelineExtent{timelineScrollArea.getLogicalExtent()};
    timelineScrollArea.content = std::make_unique<AnimationTimeline>(
        SDL_Rect{0, 0, timelineExtent.w, timelineExtent.h},
        "AnimationTimeline");
    timelineScrollArea.setScrollOrientation(AUI::Orientation::Horizontal);
    timeline
        = static_cast<AnimationTimeline*>(timelineScrollArea.content.get());

    // When the active animation is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&AnimationEditView::onActiveLibraryItemChanged>(*this);
    AnimationModel& animationModel{dataModel.animationModel};
    animationModel.animationFrameCountChanged
        .connect<&AnimationEditView::onAnimationFrameCountChanged>(*this);
    animationModel.animationLoopStartFrameChanged
        .connect<&AnimationEditView::onAnimationLoopStartFrameChanged>(*this);
    animationModel.animationFrameChanged
        .connect<&AnimationEditView::onAnimationFrameChanged>(*this);
    animationModel.animationModelBoundsIDChanged
        .connect<&AnimationEditView::onAnimationModelBoundsIDChanged>(*this);
    animationModel.animationCustomModelBoundsChanged
        .connect<&AnimationEditView::onAnimationCustomModelBoundsChanged>(*this);
    animationModel.animationEntityAlignmentAnchorChanged
        .connect<&AnimationEditView::onAnimationEntityAlignmentAnchorChanged>(
            *this);
    animationModel.animationRemoved
        .connect<&AnimationEditView::onAnimationRemoved>(*this);

    timeline->setOnSelectionChanged([&](Uint8 selectedFrameNumber) {
        onTimelineSelectionChanged(selectedFrameNumber);
    });
    timeline->setOnLoopStartFrameChanged([&](Uint8 newLoopStartFrame) {
        onTimelineLoopStartFrameChanged(newLoopStartFrame);
    });
    timeline->setOnSpriteMoved([&](Uint8 oldFrameNumber, Uint8 newFrameNumber) {
        onTimelineSpriteMoved(oldFrameNumber, newFrameNumber);
    });

    animationElementsWindow.setOnListItemSelected(
        [&](AnimationElementsWindow::ElementType type) {
            onElementSelected(type);
        });
}

AUI::EventResult AnimationEditView::onKeyDown(SDL_Keycode keyCode)
{
    // If the space bar was pressed, play or pause the animation.
    if (keyCode == SDLK_SPACE) {
        timeline->playOrPauseAnimation();

        return AUI::EventResult{.wasHandled{true}};
    }

    return AUI::EventResult{.wasHandled{false}};
}

void AnimationEditView::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is an animation and return early if not.
    const EditorAnimation* newActiveAnimation{
        get_if<EditorAnimation>(&newActiveItem)};
    if (!newActiveAnimation) {
        activeAnimationID = NULL_ANIMATION_ID;
        return;
    }

    activeAnimationID = newActiveAnimation->numericID;

    // Note: All sprites in an animation must have the same textureExtent and 
    //       stageOrigin, so we can calculate everything once here instead of 
    //       needing to re-calc whenever the sprite changes.

    // Set up the gizmos with the new animation's size and data.
    AM_ASSERT(newActiveAnimation->frames.size() > 0,
              "Animations must always have at least 1 frame.");
    const EditorSprite& firstSprite{newActiveAnimation->frames[0].sprite.get()};
    boundingBoxGizmo.setSpriteImageSize(firstSprite.textureExtent.w,
                                        firstSprite.textureExtent.h);
    boundingBoxGizmo.setStageOrigin(firstSprite.stageOrigin);
    boundingBoxGizmo.setBoundingBox(
        newActiveAnimation->getModelBounds(dataModel.boundingBoxModel));
    entityAlignmentAnchorGizmo.setSpriteImageSize(firstSprite.textureExtent.w,
                                                  firstSprite.textureExtent.h);
    entityAlignmentAnchorGizmo.setStageOrigin(firstSprite.stageOrigin);
    if (newActiveAnimation->entityAlignmentAnchor) {
        entityAlignmentAnchorGizmo.setPoint(
            newActiveAnimation->entityAlignmentAnchor.value());
    }

    // Use the gizmo's centered sprite extent to set the background and sprite
    // extents.
    SDL_Rect logicalSpriteExtent{
        boundingBoxGizmo.getLogicalCenteredSpriteExtent()};
    logicalSpriteExtent.x += boundingBoxGizmo.getLogicalExtent().x;
    logicalSpriteExtent.y += boundingBoxGizmo.getLogicalExtent().y;
    checkerboardImage.setLogicalExtent(logicalSpriteExtent);
    spriteImage.setLogicalExtent(logicalSpriteExtent);

    // Set up the stage graphic.
    const SDL_Rect& gizmoClippedExtent{boundingBoxGizmo.getClippedExtent()};
    SDL_Rect actualSpriteExtent{AUI::ScalingHelpers::logicalToActual(
        boundingBoxGizmo.getLogicalCenteredSpriteExtent())};
    stageGraphic.updateStage(firstSprite.textureExtent,
                             firstSprite.stageOrigin,
                             {(gizmoClippedExtent.x + actualSpriteExtent.x),
                              (gizmoClippedExtent.y + actualSpriteExtent.y)});

    // Make sure everything is visible.
    boundingBoxGizmo.setIsVisible(true);
    if (newActiveAnimation->entityAlignmentAnchor) {
        entityAlignmentAnchorGizmo.setIsVisible(true);
    }
    else {
        entityAlignmentAnchorGizmo.setIsVisible(false);
    }
    checkerboardImage.setIsVisible(true);
    stageGraphic.setIsVisible(true);
    spriteImage.setIsVisible(true);

    // Load this animation into the timeline.
    timeline->setActiveAnimation(*newActiveAnimation);
}

void AnimationEditView::onAnimationFrameCountChanged(AnimationID animationID,
                                                     Uint8 newFrameCount)
{
    if (animationID == activeAnimationID) {
        timeline->setFrameCount(newFrameCount);
    }
}

void AnimationEditView::onAnimationLoopStartFrameChanged(
    AnimationID animationID, Uint8 newLoopStartFrame)
{
    if (animationID == activeAnimationID) {
        timeline->setLoopStartFrame(newLoopStartFrame);
    }
}

void AnimationEditView::onAnimationFrameChanged(AnimationID animationID,
                                                 Uint8 frameNumber,
                                                 const EditorSprite* newSprite)
{
    if (animationID == activeAnimationID) {
        bool hasSprite{newSprite != nullptr};
        timeline->setFrame(frameNumber, hasSprite);
    }
}

void AnimationEditView::onAnimationModelBoundsIDChanged(
    AnimationID animationID, BoundingBoxID newModelBoundsID)
{
    // If the animation isn't active, do nothing.
    if (animationID != activeAnimationID) {
        return;
    }

    // If the animation is using a shared bounding box, disable the gizmo.
    if (newModelBoundsID) {
        boundingBoxGizmo.disable();
    }
    else {
        // The animation is using custom bounds, enable the gizmo.
        boundingBoxGizmo.enable();
    }

    // Whether it's enabled or not, the gizmo should show the correct bounds.
    const EditorAnimation& animation{dataModel.animationModel.getAnimation(animationID)};
    const BoundingBox& newModelBounds{
        animation.getModelBounds(dataModel.boundingBoxModel)};

    boundingBoxGizmo.setBoundingBox(newModelBounds);
}

void AnimationEditView::onAnimationCustomModelBoundsChanged(
    AnimationID animationID, const BoundingBox& newCustomModelBounds)
{
    // If the animation isn't active or isn't set to custom bounds, do nothing.
    const EditorAnimation& animation{
        dataModel.animationModel.getAnimation(animationID)};
    if ((animationID != activeAnimationID) || animation.modelBoundsID) {
        return;
    }

    // Update the gizmo.
    boundingBoxGizmo.setBoundingBox(newCustomModelBounds);
}

void AnimationEditView::onAnimationEntityAlignmentAnchorChanged(
    AnimationID animationID,
    const std::optional<Vector3>& newEntityAlignmentAnchor)
{
    // If the animation isn't active, do nothing.
    const EditorAnimation& animation{
        dataModel.animationModel.getAnimation(animationID)};
    if (animationID != activeAnimationID) {
        return;
    }

    // Update the gizmo.
    if (newEntityAlignmentAnchor) {
        entityAlignmentAnchorGizmo.setPoint(newEntityAlignmentAnchor.value());
        entityAlignmentAnchorGizmo.setIsVisible(true);
    }
    else {
        entityAlignmentAnchorGizmo.setIsVisible(false);
    }
}

void AnimationEditView::onAnimationRemoved(AnimationID animationID)
{
    // If the active animation was deleted, hide this window.
    if (animationID == activeAnimationID) {
        activeAnimationID = NULL_ANIMATION_ID;
        setIsVisible(false);
    }
}

void AnimationEditView::onGizmoBoundingBoxUpdated(
    const BoundingBox& updatedBounds)
{
    if (activeAnimationID) {
        // If the animation isn't set to use a custom model, do nothing (should 
        // never happen since the gizmo should be disabled).
        const EditorAnimation& animation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        if (animation.modelBoundsID) {
            return;
        }

        // Update the model with the gizmo's new state.
        dataModel.animationModel.setAnimationCustomModelBounds(
            activeAnimationID, updatedBounds);
    }
}

void AnimationEditView::onGizmoEntityAlignmentAnchorUpdated(
    const Vector3& updatedEntityAlignmentAnchor)
{
    if (activeAnimationID) {
        // If the animation isn't set to use an anchor, do nothing (should 
        // never happen since the gizmo should be disabled).
        const EditorAnimation& animation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        if (!(animation.entityAlignmentAnchor)) {
            return;
        }

        // Update the model with the gizmo's new state.
        dataModel.animationModel.setAnimationEntityAlignmentAnchor(
            activeAnimationID, updatedEntityAlignmentAnchor);
    }
}

void AnimationEditView::onTimelineSelectionChanged(Uint8 selectedFrameNumber)
{
    const EditorAnimation& activeAnimation{
        dataModel.animationModel.getAnimation(activeAnimationID)};

    // If the selected frame doesn't have a sprite, clear the stage and return.
    const EditorSprite* selectedSprite{
        activeAnimation.getSpriteAtFrame(selectedFrameNumber)};
    if (!selectedSprite) {
        spriteImage.setIsVisible(false);
        return;
    }

    // Load the appropriate sprite image.
    std::string imagePath{dataModel.getWorkingIndividualSpritesDir()};
    imagePath += selectedSprite->imagePath;
    spriteImage.setSimpleImage(imagePath,
                               {0, 0, selectedSprite->textureExtent.w,
                                selectedSprite->textureExtent.h},
                               Config::SPRITE_SCALING_QUALITY);

    // Update the stage origin in the gizmos.
    boundingBoxGizmo.setStageOrigin(selectedSprite->stageOrigin);
    entityAlignmentAnchorGizmo.setStageOrigin(selectedSprite->stageOrigin);

    // Update the stage graphic.
    const SDL_Rect& gizmoClippedExtent{boundingBoxGizmo.getClippedExtent()};
    SDL_Rect actualSpriteExtent{AUI::ScalingHelpers::logicalToActual(
        boundingBoxGizmo.getLogicalCenteredSpriteExtent())};
    stageGraphic.updateStage(selectedSprite->textureExtent,
                             selectedSprite->stageOrigin,
                             {(gizmoClippedExtent.x + actualSpriteExtent.x),
                              (gizmoClippedExtent.y + actualSpriteExtent.y)});

    // Note: Since all sprites in an animation are guaranteed to be the same 
    //       size, we don't need to update the gizmo bounds.
}

void AnimationEditView::onTimelineLoopStartFrameChanged(Uint8 newLoopStartFrame)
{
    // Update the animation.
    dataModel.animationModel.setAnimationLoopStartFrame(activeAnimationID,
                                                        newLoopStartFrame);
}

void AnimationEditView::onTimelineSpriteMoved(Uint8 oldFrameNumber,
                                              Uint8 newFrameNumber)
{
    // Swap the sprites (or clear if swapping with empty).
    dataModel.animationModel.swapAnimationFrames(
        activeAnimationID, oldFrameNumber, newFrameNumber);
}

void AnimationEditView::onElementSelected(
    AnimationElementsWindow::ElementType type)
{
    if (type == AnimationElementsWindow::ElementType::BoundingBox) {
        boundingBoxGizmo.enable();
        entityAlignmentAnchorGizmo.disable();
    }
    else if (type
             == AnimationElementsWindow::ElementType::EntityAlignmentAnchor) {
        entityAlignmentAnchorGizmo.enable();
        boundingBoxGizmo.disable();
    }
}

void AnimationEditView::styleText(AUI::Text& text)
{
    text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    text.setColor({255, 255, 255, 255});
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/AnimationElementsWindow.cpp`:

```cpp
#include "AnimationElementsWindow.h"
#include "MainScreen.h"
#include "DataModel.h"
#include "AnimationID.h"
#include "Paths.h"
#include "SharedConfig.h"

namespace AM
{
namespace ResourceImporter
{
AnimationElementsWindow::AnimationElementsWindow(MainScreen& inScreen,
                                                 DataModel& inDataModel)
: AUI::Window({1617, 931, 303, 121}, "AnimationElementsWindow")
, mainScreen{inScreen}
, dataModel{inDataModel}
, activeAnimationID{NULL_ANIMATION_ID}
, boundingBoxListItem{{1, 40, (logicalExtent.w - 2), 40}, "Bounding Box"}
, entityAlignmentAnchorListItem{{1, 80, (logicalExtent.w - 2), 40},
                                "Entity Alignment Anchor"}
, backgroundImage{{0, 0, logicalExtent.w, logicalExtent.h},
                  "ElementsBackground"}
, headerImage{{0, 0, 303, 40}, "ElementsHeader"}
, windowLabel{{12, 0, 282, 40}, "ElementsWindowLabel"}
, addEntityAlignmentAnchorButton{{257, 89, 22, 22}, "AddAnchorButton"}
, remEntityAlignmentAnchorButton{{257, 89, 22, 22}, "RemAnchorButton"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(backgroundImage);
    children.push_back(headerImage);
    children.push_back(windowLabel);
    children.push_back(boundingBoxListItem);
    children.push_back(entityAlignmentAnchorListItem);
    children.push_back(addEntityAlignmentAnchorButton);
    children.push_back(remEntityAlignmentAnchorButton);

    /* Window setup */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});
    headerImage.setNineSliceImage((Paths::TEXTURE_DIR + "HeaderBackground.png"),
                                  {1, 1, 1, 1});

    auto styleLabel
        = [&](AUI::Text& label, const std::string& text, int fontSize) {
        label.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), fontSize);
        label.setColor({255, 255, 255, 255});
        label.setText(text);
    };
    styleLabel(windowLabel, "Animation Elements", 21);
    windowLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);

    /* List items */
    boundingBoxListItem.setOnSelected(
        [this](AnimationElementsListItem*) {
            // Deselect the other list items and signal the new selection.
            entityAlignmentAnchorListItem.deselect();
            if (onListItemSelected) {
                onListItemSelected(ElementType::BoundingBox);
            }
        });
    entityAlignmentAnchorListItem.setOnSelected(
        [this](AnimationElementsListItem*) {
            // Deselect the other list items and signal the new selection.
            boundingBoxListItem.deselect();
            if (onListItemSelected) {
                onListItemSelected(ElementType::EntityAlignmentAnchor);
            }
        });

    /* Buttons */
    addEntityAlignmentAnchorButton.normalImage.setSimpleImage(
        Paths::TEXTURE_DIR + "Icons/Plus.png");
    addEntityAlignmentAnchorButton.hoveredImage.setSimpleImage(
        Paths::TEXTURE_DIR + "Icons/PlusHovered.png");
    addEntityAlignmentAnchorButton.pressedImage.setSimpleImage(
        Paths::TEXTURE_DIR + "Icons/Plus.png");
    addEntityAlignmentAnchorButton.text.setFont(
        (Paths::FONT_DIR + "B612-Regular.ttf"), 33);
    addEntityAlignmentAnchorButton.text.setText("");
    addEntityAlignmentAnchorButton.setOnPressed([this]() {
        // Add a default anchor to the active animation.
        if (activeAnimationID) {
            dataModel.animationModel.setAnimationEntityAlignmentAnchor(
                activeAnimationID, Vector3{0, 0, 0});
        }
    });
    remEntityAlignmentAnchorButton.normalImage.setSimpleImage(
        Paths::TEXTURE_DIR + "Icons/Minus.png");
    remEntityAlignmentAnchorButton.hoveredImage.setSimpleImage(
        Paths::TEXTURE_DIR + "Icons/MinusHovered.png");
    remEntityAlignmentAnchorButton.pressedImage.setSimpleImage(
        Paths::TEXTURE_DIR + "Icons/Minus.png");
    remEntityAlignmentAnchorButton.text.setFont(
        (Paths::FONT_DIR + "B612-Regular.ttf"), 33);
    remEntityAlignmentAnchorButton.text.setText("");
    remEntityAlignmentAnchorButton.setOnPressed([this]() {
        // Remove the anchor from the active animation.
        if (activeAnimationID) {
            dataModel.animationModel.setAnimationEntityAlignmentAnchor(
                activeAnimationID, std::nullopt);
        }
    });

    // When the active animation is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&AnimationElementsWindow::onActiveLibraryItemChanged>(*this);
    AnimationModel& animationModel{dataModel.animationModel};
    animationModel.animationRemoved
        .connect<&AnimationElementsWindow::onAnimationRemoved>(*this);
    animationModel.animationEntityAlignmentAnchorChanged.connect<
        &AnimationElementsWindow::onAnimationEntityAlignmentAnchorChanged>(
        this);
}

void AnimationElementsWindow::setOnListItemSelected(
    std::function<void(ElementType)> inOnListItemSelected)
{
    onListItemSelected = inOnListItemSelected;
}

void AnimationElementsWindow::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is an animation and return early if not.
    const EditorAnimation* newActiveAnimation{
        get_if<EditorAnimation>(&newActiveItem)};
    if (!newActiveAnimation) {
        activeAnimationID = NULL_ANIMATION_ID;
        return;
    }

    activeAnimationID = newActiveAnimation->numericID;

    // Update all of our property fields to match the new active animation's 
    // data.
    updateAnchorListItemState(newActiveAnimation->entityAlignmentAnchor);

    // Default to the bounding box being selected.
    boundingBoxListItem.select();
    entityAlignmentAnchorListItem.deselect();
}

void AnimationElementsWindow::onAnimationEntityAlignmentAnchorChanged(
    AnimationID animationID,
    const std::optional<Vector3>& newEntityAlignmentAnchor)
{
    updateAnchorListItemState(newEntityAlignmentAnchor);
}

void AnimationElementsWindow::onAnimationRemoved(AnimationID animationID)
{
    // If the active animation was deleted, hide this window.
    if (animationID == activeAnimationID) {
        activeAnimationID = NULL_ANIMATION_ID;
        setIsVisible(false);
    }
}

void AnimationElementsWindow::updateAnchorListItemState(
    const std::optional<Vector3>& entityAlignmentAnchor)
{
    // If the anchor is non-null, show the '-' icon and enable the anchor list
    // item.
    if (entityAlignmentAnchor) {
        entityAlignmentAnchorListItem.enable();
        entityAlignmentAnchorListItem.select();
        remEntityAlignmentAnchorButton.setIsVisible(true);
        addEntityAlignmentAnchorButton.setIsVisible(false);
    }
    else {
        // Anchor is null. Disable the anchor list item, show the '+' icon, 
        // and select the default list item.
        entityAlignmentAnchorListItem.disable();
        boundingBoxListItem.select();
        addEntityAlignmentAnchorButton.setIsVisible(true);
        remEntityAlignmentAnchorButton.setIsVisible(false);
    }
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/AnimationPropertiesWindow.cpp`:

```cpp
#include "AnimationPropertiesWindow.h"
#include "MainScreen.h"
#include "DataModel.h"
#include "EditorSprite.h"
#include "AnimationID.h"
#include "Paths.h"
#include "Camera.h"
#include "Transforms.h"
#include "SpriteTools.h"
#include "SharedConfig.h"
#include <string>
#include <iomanip>
#include <sstream>
#include <iostream>
#include <algorithm>

namespace AM
{
namespace ResourceImporter
{
AnimationPropertiesWindow::AnimationPropertiesWindow(MainScreen& inScreen,
    DataModel& inDataModel, LibraryWindow& inLibraryWindow)
: AUI::Window({1617, 0, 303, 931}, "AnimationPropertiesWindow")
, mainScreen{inScreen}
, nameLabel{{24, 52, 65, 28}, "NameLabel"}
, nameInput{{24, 84, 255, 38}, "NameInput"}
, frameCountLabel{{24, 166, 110, 28}, "FrameCountLabel"}
, frameCountInput{{150, 160, 129, 38}, "FrameCountInput"}
, fpsLabel{{24, 216, 110, 28}, "FpsLabel"}
, fpsInput{{150, 210, 129, 38}, "FpsInput"}
, loopStartFrameLabel{{24, 266, 110, 28}, "LoopStartFrameLabel"}
, loopStartFrameInput{{150, 260, 129, 38}, "LoopStartFrameInput"}
, boundingBoxLabel{{24, 336, 210, 27}, "BoundingBoxLabel"}
, boundingBoxNameLabel{{24, 369, 178, 21}, "BoundingBoxNameLabel"}
, boundingBoxButton{{207, 362, 72, 26}, "Assign", "BoundingBoxButton"}
, minXLabel{{24, 408, 110, 38}, "MinXLabel"}
, minXInput{{150, 402, 129, 38}, "MinXInput"}
, minYLabel{{24, 458, 110, 38}, "MinYLabel"}
, minYInput{{150, 452, 129, 38}, "MinYInput"}
, minZLabel{{24, 508, 110, 38}, "MinZLabel"}
, minZInput{{150, 502, 129, 38}, "MinZInput"}
, maxXLabel{{24, 558, 110, 38}, "MaxXLabel"}
, maxXInput{{150, 552, 129, 38}, "MaxXInput"}
, maxYLabel{{24, 608, 110, 38}, "MaxYLabel"}
, maxYInput{{150, 602, 129, 38}, "MaxYInput"}
, maxZLabel{{24, 658, 110, 38}, "MaxZLabel"}
, maxZInput{{150, 652, 129, 38}, "MaxZInput"}
, collisionEnabledLabel{{24, 702, 210, 27}, "CollisionLabel"}
, collisionEnabledInput{{257, 704, 22, 22}, "CollisionInput"}
, alignXLabel{{24, 773, 110, 38}, "AlignXLabel"}
, alignXInput{{150, 767, 129, 38}, "AlignXInput"}
, alignYLabel{{24, 823, 110, 38}, "AlignYLabel"}
, alignYInput{{150, 817, 129, 38}, "AlignYInput"}
, alignZLabel{{24, 873, 110, 38}, "AlignZLabel"}
, alignZInput{{150, 867, 129, 38}, "AlignZInput"}
, dataModel{inDataModel}
, libraryWindow{inLibraryWindow}
, activeAnimationID{NULL_ANIMATION_ID}
, committedFrameCount{0}
, committedFps{0}
, committedLoopStartFrame{0}
, committedMinX{0.0}
, committedMinY{0.0}
, committedMinZ{0.0}
, committedMaxX{0.0}
, committedMaxY{0.0}
, committedMaxZ{0.0}
, committedAlignX{0.0}
, committedAlignY{0.0}
, committedAlignZ{0.0}
, backgroundImage{{0, 0, logicalExtent.w, logicalExtent.h},
                  "PropertiesBackground"}
, headerImage{{0, 0, 303, 40}, "PropertiesHeader"}
, windowLabel{{12, 0, 282, 40}, "PropertiesWindowLabel"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(backgroundImage);
    children.push_back(headerImage);
    children.push_back(windowLabel);
    children.push_back(nameLabel);
    children.push_back(nameInput);
    children.push_back(frameCountLabel);
    children.push_back(frameCountInput);
    children.push_back(fpsLabel);
    children.push_back(fpsInput);
    children.push_back(loopStartFrameLabel);
    children.push_back(loopStartFrameInput);
    children.push_back(boundingBoxLabel);
    children.push_back(boundingBoxNameLabel);
    children.push_back(boundingBoxButton);
    children.push_back(minXLabel);
    children.push_back(minXInput);
    children.push_back(minYLabel);
    children.push_back(minYInput);
    children.push_back(minZLabel);
    children.push_back(minZInput);
    children.push_back(maxXLabel);
    children.push_back(maxXInput);
    children.push_back(maxYLabel);
    children.push_back(maxYInput);
    children.push_back(maxZLabel);
    children.push_back(maxZInput);
    children.push_back(collisionEnabledLabel);
    children.push_back(collisionEnabledInput);
    children.push_back(alignXLabel);
    children.push_back(alignXInput);
    children.push_back(alignYLabel);
    children.push_back(alignYInput);
    children.push_back(alignZLabel);
    children.push_back(alignZInput);

    /* Window setup */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});
    headerImage.setNineSliceImage((Paths::TEXTURE_DIR + "HeaderBackground.png"),
                                  {1, 1, 1, 1});

    auto styleLabel
        = [&](AUI::Text& label, const std::string& text, int fontSize) {
        label.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), fontSize);
        label.setColor({255, 255, 255, 255});
        label.setText(text);
    };
    styleLabel(windowLabel, "Animation Properties", 21);
    windowLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);

    /* Display name entry. */
    styleLabel(nameLabel, "Name", 21);
    nameLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);

    auto styleTextInput = [&](AUI::TextInput& textInput) {
        textInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
        textInput.setPadding({0, 8, 0, 8});
    };
    styleTextInput(nameInput);
    // Note: Display name is auto-generated from sprite image name and can't be 
    //       changed.
    nameInput.disable();

    /* Frame count entry. */
    styleLabel(frameCountLabel, "Frames", 21);
    frameCountLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);

    styleTextInput(frameCountInput);
    frameCountInput.setOnTextCommitted([this]() { saveFrameCount(); });

    /* FPS entry. */
    styleLabel(fpsLabel, "Fps", 21);
    fpsLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);

    styleTextInput(fpsInput);
    fpsInput.setOnTextCommitted([this]() { saveFps(); });

    /* Loop start frame entry. */
    styleLabel(loopStartFrameLabel, "Loop to", 21);
    loopStartFrameLabel.setVerticalAlignment(
        AUI::Text::VerticalAlignment::Center);

    styleTextInput(loopStartFrameInput);
    loopStartFrameInput.setOnTextCommitted([this]() { saveLoopStartFrame(); });

    /* Bounding box selection. */
    styleLabel(boundingBoxLabel, "Bounding Box", 21);
    styleLabel(boundingBoxNameLabel, "", 16);

    boundingBoxButton.text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 14);
    boundingBoxButton.setOnPressed([&]() { onBoundingBoxButtonPressed(); });

    // Bounds entry labels.
    styleLabel(minXLabel, "Min X", 21);
    styleLabel(minYLabel, "Min Y", 21);
    styleLabel(minZLabel, "Min Z", 21);
    styleLabel(maxXLabel, "Max X", 21);
    styleLabel(maxYLabel, "Max Y", 21);
    styleLabel(maxZLabel, "Max Z", 21);

    // Bounds entry text inputs.
    styleTextInput(minXInput);
    styleTextInput(minYInput);
    styleTextInput(minZInput);
    styleTextInput(maxXInput);
    styleTextInput(maxYInput);
    styleTextInput(maxZInput);
    minXInput.setOnTextCommitted([this]() { saveMinX(); });
    minYInput.setOnTextCommitted([this]() { saveMinY(); });
    minZInput.setOnTextCommitted([this]() { saveMinZ(); });
    maxXInput.setOnTextCommitted([this]() { saveMaxX(); });
    maxYInput.setOnTextCommitted([this]() { saveMaxY(); });
    maxZInput.setOnTextCommitted([this]() { saveMaxZ(); });

    /* Collision enabled entry. */
    styleLabel(collisionEnabledLabel, "Collision enabled", 21);

    collisionEnabledInput.uncheckedImage.setSimpleImage(
        Paths::TEXTURE_DIR + "Checkbox/Unchecked.png");
    collisionEnabledInput.checkedImage.setSimpleImage(Paths::TEXTURE_DIR
                                                      + "Checkbox/Checked.png");
    collisionEnabledInput.setOnChecked([this]() { saveCollisionEnabled(); });
    collisionEnabledInput.setOnUnchecked([this]() { saveCollisionEnabled(); });

    // Entity alignment anchor entry labels.
    styleLabel(alignXLabel, "Align X", 21);
    styleLabel(alignYLabel, "Align Y", 21);
    styleLabel(alignZLabel, "Align Z", 21);

    // Entity alignment anchor entry text inputs.
    styleTextInput(alignXInput);
    styleTextInput(alignYInput);
    styleTextInput(alignZInput);
    alignXInput.setOnTextCommitted([this]() { saveAlignX(); });
    alignYInput.setOnTextCommitted([this]() { saveAlignY(); });
    alignZInput.setOnTextCommitted([this]() { saveAlignZ(); });

    // When the active animation is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&AnimationPropertiesWindow::onActiveLibraryItemChanged>(*this);
    AnimationModel& animationModel{dataModel.animationModel};
    animationModel.animationRemoved
        .connect<&AnimationPropertiesWindow::onAnimationRemoved>(*this);
    animationModel.animationDisplayNameChanged
        .connect<&AnimationPropertiesWindow::onAnimationDisplayNameChanged>(
            *this);
    animationModel.animationFrameCountChanged
        .connect<&AnimationPropertiesWindow::onAnimationFrameCountChanged>(
            *this);
    animationModel.animationFpsChanged
        .connect<&AnimationPropertiesWindow::onAnimationFpsChanged>(*this);
    animationModel.animationLoopStartFrameChanged
        .connect<&AnimationPropertiesWindow::onAnimationLoopStartFrameChanged>(
            *this);
    animationModel.animationModelBoundsIDChanged
        .connect<&AnimationPropertiesWindow::onAnimationModelBoundsIDChanged>(
            *this);
    animationModel.animationCustomModelBoundsChanged.connect<
        &AnimationPropertiesWindow::onAnimationCustomModelBoundsChanged>(*this);
    animationModel.animationCollisionEnabledChanged.connect<
        &AnimationPropertiesWindow::onAnimationCollisionEnabledChanged>(*this);
    animationModel.animationEntityAlignmentAnchorChanged.connect<
        &AnimationPropertiesWindow::onAnimationEntityAlignmentAnchorChanged>(
        *this);

    // When a library item is selected, update the preview button.
    libraryWindow.selectedItemsChanged
        .connect<&AnimationPropertiesWindow::onLibrarySelectedItemsChanged>(
            *this);
}

void AnimationPropertiesWindow::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is an animation and return early if not.
    const EditorAnimation* newActiveAnimation{
        get_if<EditorAnimation>(&newActiveItem)};
    if (!newActiveAnimation) {
        activeAnimationID = NULL_ANIMATION_ID;
        return;
    }

    activeAnimationID = newActiveAnimation->numericID;

    // Update all of our property fields to match the new active animation's 
    // data.
    nameInput.setText(newActiveAnimation->displayName);
    frameCountInput.setText(std::to_string(newActiveAnimation->frameCount));
    fpsInput.setText(std::to_string(newActiveAnimation->fps));
    loopStartFrameInput.setText(
        std::to_string(newActiveAnimation->loopStartFrame));

    if (newActiveAnimation->modelBoundsID) {
        const EditorBoundingBox& boundingBox{
            dataModel.boundingBoxModel.getBoundingBox(
                newActiveAnimation->modelBoundsID)};
        boundingBoxNameLabel.setText(boundingBox.displayName);
        boundingBoxButton.text.setText("Custom");
        setBoundsFieldsEnabled(false);
    }
    else {
        boundingBoxNameLabel.setText("<Custom>");
        boundingBoxButton.text.setText("Save as");
        setBoundsFieldsEnabled(true);
    }

    const BoundingBox& animationModelBounds{
        newActiveAnimation->getModelBounds(dataModel.boundingBoxModel)};
    minXInput.setText(toRoundedString(animationModelBounds.min.x));
    minYInput.setText(toRoundedString(animationModelBounds.min.y));
    minZInput.setText(toRoundedString(animationModelBounds.min.z));
    maxXInput.setText(toRoundedString(animationModelBounds.max.x));
    maxYInput.setText(toRoundedString(animationModelBounds.max.y));
    maxZInput.setText(toRoundedString(animationModelBounds.max.z));

    if (newActiveAnimation->collisionEnabled) {
        collisionEnabledInput.setCurrentState(AUI::Checkbox::State::Checked);
    }
    else {
        collisionEnabledInput.setCurrentState(AUI::Checkbox::State::Unchecked);
    }

    const std::optional<Vector3>& animationEntityAlignmentAnchor{
        newActiveAnimation->entityAlignmentAnchor};
    if (animationEntityAlignmentAnchor) {
        alignXInput.setText(
            toRoundedString(animationEntityAlignmentAnchor.value().x));
        alignYInput.setText(
            toRoundedString(animationEntityAlignmentAnchor.value().y));
        alignZInput.setText(
            toRoundedString(animationEntityAlignmentAnchor.value().z));
        alignXInput.enable();
        alignYInput.enable();
        alignZInput.enable();
    }
    else  {
        alignXInput.disable();
        alignYInput.disable();
        alignZInput.disable();
    }
}

void AnimationPropertiesWindow::onAnimationDisplayNameChanged(
    AnimationID animationID, const std::string& newDisplayName)
{
    if (animationID == activeAnimationID) {
        nameInput.setText(newDisplayName);
    }
}

void AnimationPropertiesWindow::onAnimationFrameCountChanged(
    AnimationID animationID, Uint8 newFrameCount)
{
    if (animationID == activeAnimationID) {
        frameCountInput.setText(std::to_string(newFrameCount));
    }
}

void AnimationPropertiesWindow::onAnimationFpsChanged(AnimationID animationID,
                                                      Uint8 newFps)
{
    if (animationID == activeAnimationID) {
        fpsInput.setText(std::to_string(newFps));
    }
}

void AnimationPropertiesWindow::onAnimationLoopStartFrameChanged(
    AnimationID animationID, Uint8 newLoopStartFrame)
{
    if (animationID == activeAnimationID) {
        loopStartFrameInput.setText(std::to_string(newLoopStartFrame));
    }
}

void AnimationPropertiesWindow::onAnimationModelBoundsIDChanged(
    AnimationID animationID, BoundingBoxID newModelBoundsID)
{
    // If the animation isn't active, do nothing.
    if (animationID != activeAnimationID) {
        return;
    }

    // Whether they're enabled or not, the fields should show the correct bounds.
    const EditorAnimation& animation{
        dataModel.animationModel.getAnimation(animationID)};

    if (newModelBoundsID) {
        const EditorBoundingBox& boundingBox{
            dataModel.boundingBoxModel.getBoundingBox(newModelBoundsID)};
        boundingBoxNameLabel.setText(boundingBox.displayName);
        boundingBoxButton.text.setText("Custom");
        setBoundsFieldsEnabled(false);
    }
    else {
        boundingBoxNameLabel.setText("<Custom>");
        boundingBoxButton.text.setText("Save as");
        setBoundsFieldsEnabled(true);
    }

    const BoundingBox& newModelBounds{
        animation.getModelBounds(dataModel.boundingBoxModel)};
    minXInput.setText(toRoundedString(newModelBounds.min.x));
    minYInput.setText(toRoundedString(newModelBounds.min.y));
    minZInput.setText(toRoundedString(newModelBounds.min.z));
    maxXInput.setText(toRoundedString(newModelBounds.max.x));
    maxYInput.setText(toRoundedString(newModelBounds.max.y));
    maxZInput.setText(toRoundedString(newModelBounds.max.z));
}

void AnimationPropertiesWindow::onAnimationCustomModelBoundsChanged(
    AnimationID animationID, const BoundingBox& newCustomModelBounds)
{
    if (animationID == activeAnimationID) {
        minXInput.setText(toRoundedString(newCustomModelBounds.min.x));
        minYInput.setText(toRoundedString(newCustomModelBounds.min.y));
        minZInput.setText(toRoundedString(newCustomModelBounds.min.z));
        maxXInput.setText(toRoundedString(newCustomModelBounds.max.x));
        maxYInput.setText(toRoundedString(newCustomModelBounds.max.y));
        maxZInput.setText(toRoundedString(newCustomModelBounds.max.z));
    }
}

void AnimationPropertiesWindow::onAnimationCollisionEnabledChanged(
    AnimationID animationID, bool newCollisionEnabled)
{
    if (animationID == activeAnimationID) {
        if (newCollisionEnabled) {
            collisionEnabledInput.setCurrentState(
                AUI::Checkbox::State::Checked);
        }
        else {
            collisionEnabledInput.setCurrentState(
                AUI::Checkbox::State::Unchecked);
        }
    }
}

void AnimationPropertiesWindow::onAnimationEntityAlignmentAnchorChanged(
    AnimationID animationID,
    const std::optional<Vector3>& newEntityAlignmentAnchor)
{
    if (animationID == activeAnimationID) {
        if (newEntityAlignmentAnchor) {
            alignXInput.setText(
                toRoundedString(newEntityAlignmentAnchor.value().x));
            alignYInput.setText(
                toRoundedString(newEntityAlignmentAnchor.value().y));
            alignZInput.setText(
                toRoundedString(newEntityAlignmentAnchor.value().z));
            alignXInput.enable();
            alignYInput.enable();
            alignZInput.enable();
        }
        else {
            alignXInput.disable();
            alignYInput.disable();
            alignZInput.disable();
        }
    }
}

void AnimationPropertiesWindow::onAnimationRemoved(AnimationID animationID)
{
    // If the active animation was deleted, hide this window.
    if (animationID == activeAnimationID) {
        activeAnimationID = NULL_ANIMATION_ID;
        setIsVisible(false);
    }
}

void AnimationPropertiesWindow::onLibrarySelectedItemsChanged(
    const std::vector<LibraryListItem*>& selectedItems)
{
    // If there's no active animation, do nothing.
    if (!activeAnimationID) {
        return;
    }

    // If a new bounding box is selected, allow the user to assign it.
    if ((selectedItems.size() > 0)
        && (selectedItems[0]->type == LibraryListItem::Type::BoundingBox)
        && (selectedItems[0]->text.asString()
            != boundingBoxNameLabel.asString())) {
        boundingBoxButton.text.setText("Assign");
    }
    // If we have a shared bounding box assigned, allow the user to switch 
    // to a custom bounding box.
    else if (dataModel.animationModel.getAnimation(activeAnimationID)
                 .modelBoundsID
             != NULL_BOUNDING_BOX_ID) {
        boundingBoxButton.text.setText("Custom");
    }
    else {
        // Custom bounding box and no selection. Allow the user to save it.
        boundingBoxButton.text.setText("Save as");
    }
}

void AnimationPropertiesWindow::setBoundsFieldsEnabled(bool isEnabled)
{
    if (isEnabled) {
        minXInput.enable();
        minYInput.enable();
        minZInput.enable();
        maxXInput.enable();
        maxYInput.enable();
        maxZInput.enable();
    }
    else {
        minXInput.disable();
        minYInput.disable();
        minZInput.disable();
        maxXInput.disable();
        maxYInput.disable();
        maxZInput.disable();
    }
}

std::string AnimationPropertiesWindow::toRoundedString(float value)
{
    std::stringstream stream;
    stream << std::fixed << std::setprecision(3) << value;
    return stream.str();
}

void AnimationPropertiesWindow::saveFrameCount()
{
    // Validate the user input as a valid value.
    try {
        // Convert the input string to an int.
        int newFrameCount{std::stoi(frameCountInput.getText())};

        // Determine the lower bound.
        // Note: There must always be at least 1 frame in every animation.
        // Note: We only let this be reduced to the position of the last filled 
        //       frame. This is because we consider sprites to "belong" to the 
        //       animation that they were named for. If you want to remove the 
        //       sprite from the animation, you need to delete it.
        int lowerBound{1};
        const EditorAnimation& animation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        if (!(animation.frames.empty())) {
            lowerBound = (animation.frames.back().frameNumber + 1);
        }

        // Clamp the value to its bounds.
        // Note: There must be at least 1 frame in every animation.
        // Note: 1000 was chosen randomly. Adjust it if it's a problem.
        newFrameCount = std::clamp(newFrameCount, lowerBound, 1000);

        // Apply the new value.
        dataModel.animationModel.setAnimationFrameCount(activeAnimationID,
                                                        newFrameCount);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        frameCountInput.setText(std::to_string(committedFrameCount));
    }
}

void AnimationPropertiesWindow::saveFps()
{
    // Validate the user input as a valid value.
    try {
        // Convert the input string to an int.
        int newFps{std::stoi(fpsInput.getText())};

        // Clamp the value to its bounds.
        // Note: FPS must be at least 1.
        // Note: 1000 was chosen randomly. Adjust it if it's a problem.
        newFps = std::clamp(newFps, 1, 1000);

        // Apply the new value.
        dataModel.animationModel.setAnimationFps(activeAnimationID, newFps);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        fpsInput.setText(std::to_string(committedFps));
    }
}

void AnimationPropertiesWindow::saveLoopStartFrame()
{
    // Validate the user input as a valid value.
    try {
        // Convert the input string to an int.
        int newLoopStartFrame{std::stoi(loopStartFrameInput.getText())};

        // Clamp the value to its bounds.
        // Note: Loop start can go 1 past the last frame, to denote no loop.
        const EditorAnimation& animation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        newLoopStartFrame = std::clamp(newLoopStartFrame, 0,
                                       static_cast<int>(animation.frameCount));

        // Apply the new value.
        dataModel.animationModel.setAnimationLoopStartFrame(activeAnimationID,
                                                            newLoopStartFrame);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        loopStartFrameInput.setText(std::to_string(committedLoopStartFrame));
    }
}

void AnimationPropertiesWindow::onBoundingBoxButtonPressed()
{
    AnimationModel& animationModel{dataModel.animationModel};

    const std::string buttonText{boundingBoxButton.text.asString()};
    if (buttonText == "Assign") {
        // If a bounding box is selected, assign it to the active animation.
        // Note: This just uses the first selected graphic. Multi-select is 
        //       ignored.
        const auto& selectedListItems{libraryWindow.getSelectedListItems()};
        bool boundingBoxIsSelected{false};
        for (const LibraryListItem* selectedItem : selectedListItems) {
            if (selectedItem->type == LibraryListItem::Type::BoundingBox) {
                boundingBoxIsSelected = true;
                animationModel.setAnimationModelBoundsID(
                    activeAnimationID,
                    static_cast<BoundingBoxID>(selectedItem->ID));

                break;
            }
        }
    }
    else if (buttonText == "Custom") {
        // If the animation isn't already using a custom bounding box, set it.
        if (animationModel.getAnimation(activeAnimationID).modelBoundsID
            != NULL_BOUNDING_BOX_ID) {
            animationModel.setAnimationModelBoundsID(activeAnimationID,
                                                     NULL_BOUNDING_BOX_ID);
        }
    }
    else if (buttonText == "Save as") {
        // If the animation is using a custom bounding box, open the "Save as" 
        // menu.
        const EditorAnimation& animation{
            animationModel.getAnimation(activeAnimationID)};
        if (animation.modelBoundsID == NULL_BOUNDING_BOX_ID) {
            mainScreen.openSaveBoundingBoxDialog(
                animation.customModelBounds,
                [&](BoundingBoxID newModelBoundsID) {
                    // The save was completed, set the shared bounding box as
                    // this animation's model bounds.
                    dataModel.animationModel.setAnimationModelBoundsID(
                        activeAnimationID, newModelBoundsID);
                });
        }
    }
}

void AnimationPropertiesWindow::saveMinX()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newMinX{std::stof(minXInput.getText())};

        // Clamp the value to its bounds.
        const EditorAnimation& activeAnimation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        BoundingBox newModelBounds(
            activeAnimation.getModelBounds(dataModel.boundingBoxModel));
        newModelBounds.min.x = std::clamp(newMinX, 0.f, newModelBounds.max.x);

        // Apply the new value.
        dataModel.animationModel.setAnimationCustomModelBounds(
            activeAnimationID, newModelBounds);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        minXInput.setText(std::to_string(committedMinX));
    }
}

void AnimationPropertiesWindow::saveMinY()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newMinY{std::stof(minYInput.getText())};

        // Clamp the value to its bounds.
        const EditorAnimation& activeAnimation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        BoundingBox newModelBounds(
            activeAnimation.getModelBounds(dataModel.boundingBoxModel));
        newModelBounds.min.y = std::clamp(newMinY, 0.f, newModelBounds.max.y);

        // Apply the new value.
        dataModel.animationModel.setAnimationCustomModelBounds(
            activeAnimationID, newModelBounds);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        minXInput.setText(std::to_string(committedMinY));
    }
}

void AnimationPropertiesWindow::saveMinZ()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newMinZ{std::stof(minZInput.getText())};

        // Clamp the value to its bounds.
        const EditorAnimation& activeAnimation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        BoundingBox newModelBounds(
            activeAnimation.getModelBounds(dataModel.boundingBoxModel));
        newModelBounds.min.z = std::clamp(newMinZ, 0.f, newModelBounds.max.z);

        // Apply the new value.
        dataModel.animationModel.setAnimationCustomModelBounds(
            activeAnimationID, newModelBounds);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        minXInput.setText(std::to_string(committedMinZ));
    }
}

void AnimationPropertiesWindow::saveMaxX()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newMaxX{std::stof(maxXInput.getText())};

        // Clamp the value to its bounds.
        const EditorAnimation& activeAnimation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        AM_ASSERT(activeAnimation.frames.size() > 0,
                  "Animation must always have at least 1 frame.");
        const EditorSprite& firstSprite{activeAnimation.frames[0].sprite.get()};
        BoundingBox stageWorldExtent{SpriteTools::calcSpriteStageWorldExtent(
            firstSprite.textureExtent, firstSprite.stageOrigin)};

        BoundingBox newModelBounds(
            activeAnimation.getModelBounds(dataModel.boundingBoxModel));
        newModelBounds.max.x
            = std::clamp(newMaxX, newModelBounds.min.x, stageWorldExtent.max.x);

        // Apply the new value.
        dataModel.animationModel.setAnimationCustomModelBounds(
            activeAnimationID, newModelBounds);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        maxXInput.setText(std::to_string(committedMaxX));
    }
}

void AnimationPropertiesWindow::saveMaxY()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newMaxY{std::stof(maxYInput.getText())};

        // Clamp the value to its bounds.
        const EditorAnimation& activeAnimation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        AM_ASSERT(activeAnimation.frames.size() > 0,
                  "Animation must always have at least 1 frame.");
        const EditorSprite& firstSprite{activeAnimation.frames[0].sprite.get()};
        BoundingBox stageWorldExtent{SpriteTools::calcSpriteStageWorldExtent(
            firstSprite.textureExtent, firstSprite.stageOrigin)};

        BoundingBox newModelBounds(
            activeAnimation.getModelBounds(dataModel.boundingBoxModel));
        newModelBounds.max.y
            = std::clamp(newMaxY, newModelBounds.min.y,
                         static_cast<float>(SharedConfig::TILE_WORLD_WIDTH));

        // Apply the new value.
        dataModel.animationModel.setAnimationCustomModelBounds(
            activeAnimationID, newModelBounds);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        maxYInput.setText(std::to_string(committedMaxY));
    }
}

void AnimationPropertiesWindow::saveMaxZ()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newMaxZ{std::stof(maxZInput.getText())};

        // Clamp the value to its bounds.
        const EditorAnimation& activeAnimation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        AM_ASSERT(activeAnimation.frames.size() > 0,
                  "Animation must always have at least 1 frame.");
        const EditorSprite& firstSprite{activeAnimation.frames[0].sprite.get()};
        BoundingBox stageWorldExtent{SpriteTools::calcSpriteStageWorldExtent(
            firstSprite.textureExtent, firstSprite.stageOrigin)};

        BoundingBox newModelBounds(
            activeAnimation.getModelBounds(dataModel.boundingBoxModel));
        newModelBounds.max.z
            = std::clamp(newMaxZ, newModelBounds.min.z, stageWorldExtent.max.z);

        // Apply the new value.
        dataModel.animationModel.setAnimationCustomModelBounds(
            activeAnimationID, newModelBounds);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        maxYInput.setText(std::to_string(committedMaxY));
    }
}

void AnimationPropertiesWindow::saveCollisionEnabled()
{
    bool collisionEnabled{(collisionEnabledInput.getCurrentState()
                           == AUI::Checkbox::State::Checked)};
    dataModel.animationModel.setAnimationCollisionEnabled(activeAnimationID,
                                                    collisionEnabled);
}

void AnimationPropertiesWindow::saveAlignX()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newAlignX{std::stof(alignXInput.getText())};

        // Clamp the value to its bounds.
        const EditorAnimation& activeAnimation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        AM_ASSERT(activeAnimation.frames.size() > 0,
                  "Animation must always have at least 1 frame.");
        const EditorSprite& firstSprite{activeAnimation.frames[0].sprite.get()};
        BoundingBox stageWorldExtent{SpriteTools::calcSpriteStageWorldExtent(
            firstSprite.textureExtent, firstSprite.stageOrigin)};

        AM_ASSERT(activeAnimation.entityAlignmentAnchor,
                  "Tried to set value while entity alignment anchor was null");
        Vector3 newEntityAlignmentAnchor{
            activeAnimation.entityAlignmentAnchor.value()};
        newEntityAlignmentAnchor.x
            = std::clamp(newAlignX, 0.f, stageWorldExtent.max.x);

        // Apply the new value.
        dataModel.animationModel.setAnimationEntityAlignmentAnchor(
            activeAnimationID, newEntityAlignmentAnchor);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        alignXInput.setText(std::to_string(committedAlignX));
    }
}

void AnimationPropertiesWindow::saveAlignY()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newAlignY{std::stof(alignYInput.getText())};

        // Clamp the value to its bounds.
        const EditorAnimation& activeAnimation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        AM_ASSERT(activeAnimation.frames.size() > 0,
                  "Animation must always have at least 1 frame.");
        const EditorSprite& firstSprite{activeAnimation.frames[0].sprite.get()};
        BoundingBox stageWorldExtent{SpriteTools::calcSpriteStageWorldExtent(
            firstSprite.textureExtent, firstSprite.stageOrigin)};

        AM_ASSERT(activeAnimation.entityAlignmentAnchor,
                  "Tried to set value while entity alignment anchor was null");
        Vector3 newEntityAlignmentAnchor{
            activeAnimation.entityAlignmentAnchor.value()};
        newEntityAlignmentAnchor.y
            = std::clamp(newAlignY, 0.f, stageWorldExtent.max.y);

        // Apply the new value.
        dataModel.animationModel.setAnimationEntityAlignmentAnchor(
            activeAnimationID, newEntityAlignmentAnchor);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        alignYInput.setText(std::to_string(committedAlignY));
    }
}

void AnimationPropertiesWindow::saveAlignZ()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newAlignZ{std::stof(alignZInput.getText())};

        // Clamp the value to its bounds.
        const EditorAnimation& activeAnimation{
            dataModel.animationModel.getAnimation(activeAnimationID)};
        AM_ASSERT(activeAnimation.frames.size() > 0,
                  "Animation must always have at least 1 frame.");
        const EditorSprite& firstSprite{activeAnimation.frames[0].sprite.get()};
        BoundingBox stageWorldExtent{SpriteTools::calcSpriteStageWorldExtent(
            firstSprite.textureExtent, firstSprite.stageOrigin)};

        AM_ASSERT(activeAnimation.entityAlignmentAnchor,
                  "Tried to set value while entity alignment anchor was null");
        Vector3 newEntityAlignmentAnchor{
            activeAnimation.entityAlignmentAnchor.value()};
        newEntityAlignmentAnchor.z
            = std::clamp(newAlignZ, 0.f, stageWorldExtent.max.z);

        // Apply the new value.
        dataModel.animationModel.setAnimationEntityAlignmentAnchor(
            activeAnimationID, newEntityAlignmentAnchor);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        alignYInput.setText(std::to_string(committedAlignY));
    }
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/BoundingBoxEditView.cpp`:

```cpp
#include "BoundingBoxEditView.h"
#include "DataModel.h"
#include "LibraryWindow.h"
#include "Paths.h"
#include "AUI/Core.h"
#include "AUI/ScalingHelpers.h"

namespace AM
{
namespace ResourceImporter
{
BoundingBoxEditView::BoundingBoxEditView(DataModel& inDataModel,
                                           LibraryWindow& inLibraryWindow)
: AUI::Window({320, 58, 1297, 1022}, "BoundingBoxEditView")
, dataModel{inDataModel}
, libraryWindow{inLibraryWindow}
, activeBoundingBoxID{NULL_BOUNDING_BOX_ID}
, topText{{0, 0, logicalExtent.w, 34}, "TopText"}
, modifyText{{0, 58, 1297, 24}, "ModifyText"}
, checkerboardImage{{0, 0, 100, 100}, "BackgroundImage"}
, stageGraphic{logicalExtent}
, spriteImage{{0, 0, 256, 512}, "SpriteImage"}
, boundingBoxGizmo{{0, 52, 1297, 732}}
, descText{{24, 806, 1240, 144}, "DescText"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(topText);
    children.push_back(modifyText);
    children.push_back(checkerboardImage);
    children.push_back(stageGraphic);
    children.push_back(spriteImage);
    children.push_back(boundingBoxGizmo);
    children.push_back(descText);

    /* Text */
    topText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 26);
    topText.setColor({255, 255, 255, 255});
    topText.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Center);
    topText.setText("Bounding Box");

    styleText(descText);
    descText.setText(
        "Bounding boxes are used by Sprites and Animations for collision and "
        "to make them clickable in build mode.");

    styleText(modifyText);
    modifyText.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Center);
    modifyText.setText("To modify: open a Sprite or Animation in the Library "
                       "window, set a custom box, then choose \"Save as\".");

    /* Active sprite and checkerboard background. */
    checkerboardImage.setTiledImage(Paths::TEXTURE_DIR
                                    + "SpriteEditView/Checkerboard.png");
    checkerboardImage.setIsVisible(false);
    spriteImage.setIsVisible(false);

    /* Bounding box gizmo. */
    boundingBoxGizmo.setIsVisible(false);

    // When the active bounding box is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&BoundingBoxEditView::onActiveLibraryItemChanged>(*this);
    dataModel.boundingBoxModel.boundingBoxBoundsChanged
        .connect<&BoundingBoxEditView::onBoundingBoxBoundsChanged>(*this);
    dataModel.boundingBoxModel.boundingBoxRemoved
        .connect<&BoundingBoxEditView::onBoundingBoxRemoved>(*this);

    // When the gizmo updates the active sprite's bounds, push it to the model.
    boundingBoxGizmo.setOnBoundingBoxUpdated(
        [&](const BoundingBox& updatedBounds) {
            onGizmoBoundingBoxUpdated(updatedBounds);
        });
}

void BoundingBoxEditView::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is a bounding box and return early if not.
    const EditorBoundingBox* newActiveBoundingBox{
        get_if<EditorBoundingBox>(&newActiveItem)};
    if (!newActiveBoundingBox) {
        activeBoundingBoxID = NULL_BOUNDING_BOX_ID;
        return;
    }

    activeBoundingBoxID = newActiveBoundingBox->numericID;

    // Set up the gizmo with the default sprite's size and data.
    const SDL_Rect defaultSpriteExtent{0, 0, 256, 512};
    const SDL_Point defaultSpriteOrigin{128, 374};
    boundingBoxGizmo.setSpriteImageSize(defaultSpriteExtent.w,
                                        defaultSpriteExtent.h);
    boundingBoxGizmo.setStageOrigin(defaultSpriteOrigin);
    boundingBoxGizmo.setBoundingBox(newActiveBoundingBox->modelBounds);

    // Use the gizmo's centered sprite extent to set the background and sprite
    // extents.
    SDL_Rect logicalSpriteExtent{
        boundingBoxGizmo.getLogicalCenteredSpriteExtent()};
    logicalSpriteExtent.x += boundingBoxGizmo.getLogicalExtent().x;
    logicalSpriteExtent.y += boundingBoxGizmo.getLogicalExtent().y;
    checkerboardImage.setLogicalExtent(logicalSpriteExtent);
    spriteImage.setLogicalExtent(logicalSpriteExtent);

    // Set up the stage graphic.
    const SDL_Rect& gizmoClippedExtent{boundingBoxGizmo.getClippedExtent()};
    SDL_Rect actualSpriteExtent{AUI::ScalingHelpers::logicalToActual(
        boundingBoxGizmo.getLogicalCenteredSpriteExtent())};
    stageGraphic.updateStage(defaultSpriteExtent, defaultSpriteOrigin,
                             {(gizmoClippedExtent.x + actualSpriteExtent.x),
                              (gizmoClippedExtent.y + actualSpriteExtent.y)});

    // Make sure everything is visible.
    boundingBoxGizmo.setIsVisible(true);
    checkerboardImage.setIsVisible(true);
    stageGraphic.setIsVisible(true);
    spriteImage.setIsVisible(true);
}

void BoundingBoxEditView::onBoundingBoxBoundsChanged(
    BoundingBoxID boundingBoxID, const BoundingBox& newBounds)
{
    // If the box isn't active, do nothing.
    if (boundingBoxID != activeBoundingBoxID) {
        return;
    }

    // Update the gizmo to reflect the new bounds.
    const EditorBoundingBox& boundingBox{
        dataModel.boundingBoxModel.getBoundingBox(boundingBoxID)};
    boundingBoxGizmo.setBoundingBox(boundingBox.modelBounds);
}

void BoundingBoxEditView::onBoundingBoxRemoved(BoundingBoxID boundingBoxID)
{
    // If the active box was deleted, hide this window.
    if (boundingBoxID == activeBoundingBoxID) {
        activeBoundingBoxID = NULL_BOUNDING_BOX_ID;
        setIsVisible(false);
    }
}

void BoundingBoxEditView::onGizmoBoundingBoxUpdated(
    const BoundingBox& updatedBounds)
{
    if (activeBoundingBoxID) {
        // Update the model with the gizmo's new state.
        dataModel.boundingBoxModel.setBoundingBoxBounds(activeBoundingBoxID,
                                                        updatedBounds);
    }
}

void BoundingBoxEditView::styleText(AUI::Text& text)
{
    text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    text.setColor({255, 255, 255, 255});
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/BoundingBoxPropertiesWindow.cpp`:

```cpp
#include "BoundingBoxPropertiesWindow.h"
#include "MainScreen.h"
#include "DataModel.h"
#include "Paths.h"
#include "Camera.h"
#include "Transforms.h"
#include "SpriteTools.h"
#include "SharedConfig.h"
#include <string>
#include <iomanip>
#include <sstream>
#include <iostream>
#include <algorithm>

namespace AM
{
namespace ResourceImporter
{
BoundingBoxPropertiesWindow::BoundingBoxPropertiesWindow(
    DataModel& inDataModel, const LibraryWindow& inLibraryWindow)
: AUI::Window({1617, 0, 303, 579}, "BoundingBoxPropertiesWindow")
, nameLabel{{24, 52, 65, 28}, "NameLabel"}
, nameInput{{24, 84, 255, 38}, "NameInput"}
, minXLabel{{24, 166, 110, 38}, "MinXLabel"}
, minXInput{{150, 160, 129, 38}, "MinXInput"}
, minYLabel{{24, 216, 110, 38}, "MinYLabel"}
, minYInput{{150, 210, 129, 38}, "MinYInput"}
, minZLabel{{24, 266, 110, 38}, "MinZLabel"}
, minZInput{{150, 260, 129, 38}, "MinZInput"}
, maxXLabel{{24, 316, 110, 38}, "MaxXLabel"}
, maxXInput{{150, 310, 129, 38}, "MaxXInput"}
, maxYLabel{{24, 366, 110, 38}, "MaxYLabel"}
, maxYInput{{150, 360, 129, 38}, "MaxYInput"}
, maxZLabel{{24, 416, 110, 38}, "MaxZLabel"}
, maxZInput{{150, 410, 129, 38}, "MaxZInput"}
, dataModel{inDataModel}
, libraryWindow{inLibraryWindow}
, activeBoundingBoxID{NULL_BOUNDING_BOX_ID}
, backgroundImage{{0, 0, 303, 474}, "PropertiesBackground"}
, headerImage{{0, 0, 303, 40}, "PropertiesHeader"}
, windowLabel{{12, 0, 282, 40}, "PropertiesWindowLabel"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(backgroundImage);
    children.push_back(headerImage);
    children.push_back(windowLabel);
    children.push_back(nameLabel);
    children.push_back(nameInput);
    children.push_back(minXLabel);
    children.push_back(minXInput);
    children.push_back(minYLabel);
    children.push_back(minYInput);
    children.push_back(minZLabel);
    children.push_back(minZInput);
    children.push_back(maxXLabel);
    children.push_back(maxXInput);
    children.push_back(maxYLabel);
    children.push_back(maxYInput);
    children.push_back(maxZLabel);
    children.push_back(maxZInput);

    /* Window setup */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});
    headerImage.setNineSliceImage((Paths::TEXTURE_DIR + "HeaderBackground.png"),
                                  {1, 1, 1, 1});

    auto styleLabel
        = [&](AUI::Text& label, const std::string& text, int fontSize) {
        label.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), fontSize);
        label.setColor({255, 255, 255, 255});
        label.setText(text);
    };
    styleLabel(windowLabel, "Bounding Box Properties", 21);
    windowLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);

    /* Display name entry. */
    styleLabel(nameLabel, "Name", 21);
    nameLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);

    auto styleTextInput = [&](AUI::TextInput& textInput) {
        textInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
        textInput.setPadding({0, 8, 0, 8});
    };
    styleTextInput(nameInput);
    nameInput.disable();

    // Bounds entry labels.
    styleLabel(minXLabel, "Min X", 21);
    styleLabel(minYLabel, "Min Y", 21);
    styleLabel(minZLabel, "Min Z", 21);
    styleLabel(maxXLabel, "Max X", 21);
    styleLabel(maxYLabel, "Max Y", 21);
    styleLabel(maxZLabel, "Max Z", 21);

    // Bounds entry text inputs.
    styleTextInput(minXInput);
    styleTextInput(minYInput);
    styleTextInput(minZInput);
    styleTextInput(maxXInput);
    styleTextInput(maxYInput);
    styleTextInput(maxZInput);
    minXInput.disable();
    minYInput.disable();
    minZInput.disable();
    maxXInput.disable();
    maxYInput.disable();
    maxZInput.disable();

    // When the active sprite is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&BoundingBoxPropertiesWindow::onActiveLibraryItemChanged>(*this);
    BoundingBoxModel& boundingBoxModel{dataModel.boundingBoxModel};
    boundingBoxModel.boundingBoxDisplayNameChanged
        .connect<&BoundingBoxPropertiesWindow::onBoundingBoxDisplayNameChanged>(
            *this);
    boundingBoxModel.boundingBoxBoundsChanged
        .connect<&BoundingBoxPropertiesWindow::onBoundingBoxBoundsChanged>(
            *this);
    boundingBoxModel.boundingBoxRemoved
        .connect<&BoundingBoxPropertiesWindow::onBoundingBoxRemoved>(*this);
}

void BoundingBoxPropertiesWindow::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is a bounding box and return early if not.
    const EditorBoundingBox* newActiveBoundingBox{
        get_if<EditorBoundingBox>(&newActiveItem)};
    if (!newActiveBoundingBox) {
        activeBoundingBoxID = NULL_BOUNDING_BOX_ID;
        return;
    }

    activeBoundingBoxID = newActiveBoundingBox->numericID;

    // Update all of our property fields to match the new active bounds data.
    nameInput.setText(newActiveBoundingBox->displayName);

    const BoundingBox& modelBounds{newActiveBoundingBox->modelBounds};
    minXInput.setText(toRoundedString(modelBounds.min.x));
    minYInput.setText(toRoundedString(modelBounds.min.y));
    minZInput.setText(toRoundedString(modelBounds.min.z));
    maxXInput.setText(toRoundedString(modelBounds.max.x));
    maxYInput.setText(toRoundedString(modelBounds.max.y));
    maxZInput.setText(toRoundedString(modelBounds.max.z));
}

void BoundingBoxPropertiesWindow::onBoundingBoxRemoved(
    BoundingBoxID boundingBoxID)
{
    // If the active box was deleted, hide this window.
    if (boundingBoxID == activeBoundingBoxID) {
        activeBoundingBoxID = NULL_BOUNDING_BOX_ID;
        setIsVisible(false);
    }
}

void BoundingBoxPropertiesWindow::onBoundingBoxDisplayNameChanged(
    BoundingBoxID boundingBoxID, const std::string& newDisplayName)
{
    if (boundingBoxID == activeBoundingBoxID) {
        nameInput.setText(newDisplayName);
    }
}

void BoundingBoxPropertiesWindow::onBoundingBoxBoundsChanged(
    BoundingBoxID boundingBoxID, const BoundingBox& newBounds)
{
    if (boundingBoxID == activeBoundingBoxID) {
        const BoundingBox& newMinMaxBounds{newBounds};
        minXInput.setText(toRoundedString(newMinMaxBounds.min.x));
        minYInput.setText(toRoundedString(newMinMaxBounds.min.y));
        minZInput.setText(toRoundedString(newMinMaxBounds.min.z));
        maxXInput.setText(toRoundedString(newMinMaxBounds.max.x));
        maxYInput.setText(toRoundedString(newMinMaxBounds.max.y));
        maxZInput.setText(toRoundedString(newMinMaxBounds.max.z));
    }
}

std::string BoundingBoxPropertiesWindow::toRoundedString(float value)
{
    std::stringstream stream;
    stream << std::fixed << std::setprecision(3) << value;
    return stream.str();
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/EntityGraphicSetEditView.cpp`:

```cpp
#include "EntityGraphicSetEditView.h"
#include "MainScreen.h"
#include "DataModel.h"
#include "SpriteID.h"
#include "LibraryItemData.h"
#include "Paths.h"
#include "DisplayStrings.h"
#include "Rotation.h"
#include "AUI/Core.h"

namespace AM
{
namespace ResourceImporter
{
/** The width of a graphic container slot. */
static constexpr unsigned int SLOT_WIDTH{156};

EntityGraphicSetEditView::EntityGraphicSetEditView(
    DataModel& inDataModel,
                                       const LibraryWindow& inLibraryWindow)
: AUI::Window({320, 58, 1297, 1022}, "EntityGraphicSetEditView")
, dataModel{inDataModel}
, libraryWindow{inLibraryWindow}
, activeGraphicSetID{SDL_MAX_UINT16}
, topText{{0, 0, logicalExtent.w, 34}, "TopText"}
, modifyText{{193, 58, 1000, 24}, "ModifyText"}
, clearText{{193, 89, 1000, 24}, "ClearText"}
, graphicContainer{{25, 135, 1248, 632}, "GraphicContainer"}
, descText{{24, 807, 1240, 156}, "DescText"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(topText);
    children.push_back(modifyText);
    children.push_back(clearText);
    children.push_back(graphicContainer);
    children.push_back(descText);

    /* Text */
    topText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 26);
    topText.setColor({255, 255, 255, 255});
    topText.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Center);
    topText.setText("Entity Graphic Set");

    styleText(modifyText);
    modifyText.setText("To modify: select a sprite or animation in the Library window, then "
                       "press one of the Assign buttons.");
    styleText(clearText);
    clearText.setText("To clear: click an empty area to clear your selection, "
                      "then press one of the Assign buttons.");
    styleText(descText);
    descText.setText(
        "Entity Graphic Sets determine which graphics are shown when an entity "
        "enters its various states.\n\nThe Idle S graphic is required, the "
        "rest are optional.\n\nThe Idle S graphic's collision box will be used "
        "for all graphics in the set. This avoids jittery collision behavior "
        "while changing graphics. It's also less work--you only need to set "
        "the one graphic's collision box.");

    /* Container */
    graphicContainer.setNumColumns(8);
    graphicContainer.setCellWidth(SLOT_WIDTH);
    graphicContainer.setCellHeight(255 + 14);
    initGraphicContainer();

    // When the active graphic set is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&EntityGraphicSetEditView::onActiveLibraryItemChanged>(*this);
    dataModel.entityGraphicSetModel.entityRemoved
        .connect<&EntityGraphicSetEditView::onEntityRemoved>(*this);
    dataModel.entityGraphicSetModel.entitySlotChanged
        .connect<&EntityGraphicSetEditView::onEntitySlotChanged>(*this);
}

void EntityGraphicSetEditView::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is an entity graphic set and return early if 
    // not.
    const EditorEntityGraphicSet* newActiveGraphicSet{
        get_if<EditorEntityGraphicSet>(&newActiveItem)};
    if (!newActiveGraphicSet) {
        activeGraphicSetID = SDL_MAX_UINT16;
        graphicContainer.setIsVisible(false);
        return;
    }

    activeGraphicSetID = newActiveGraphicSet->numericID;

    // Fill the container with the graphic set's graphics.
    for (auto& [graphicType, graphicIDArr] : newActiveGraphicSet->graphicIDs) {
        for (Uint8 i{0}; i < Rotation::Direction::Count; ++i) {
            GraphicID graphicID{graphicIDArr.at(i)};

            // Get the graphic set slot widget that matches graphicType.
            std::size_t index{
                toIndex(graphicType, static_cast<Rotation::Direction>(i))};
            GraphicSetSlot& slot{
                static_cast<GraphicSetSlot&>(*graphicContainer[index])};

            // Fill in the graphic's data.
            fillSlotGraphicData(slot, graphicID);
        }
    }

    // Make sure the container is visible.
    graphicContainer.setIsVisible(true);
}

void EntityGraphicSetEditView::onEntityRemoved(EntityGraphicSetID graphicSetID)
{
    // If the active entity set was deleted, hide this window.
    if (graphicSetID == activeGraphicSetID) {
        activeGraphicSetID = SDL_MAX_UINT16;
        setIsVisible(false);
    }
}

void EntityGraphicSetEditView::onEntitySlotChanged(
    EntityGraphicSetID graphicSetID, EntityGraphicType graphicType,
    Rotation::Direction direction, GraphicID newGraphicID)
{
    // If the changed data doesn't affect us, return early.
    if (graphicSetID != activeGraphicSetID) {
        return;
    }

    // Fill in the new slot data.
    std::size_t index{toIndex(graphicType, direction)};
    GraphicSetSlot& slot{
        static_cast<GraphicSetSlot&>(*graphicContainer[index])};
    fillSlotGraphicData(slot, newGraphicID);
}

void EntityGraphicSetEditView::onAssignButtonPressed(
    EntityGraphicType graphicType, Rotation::Direction direction)
{
    // If a graphic is selected, set the given slot to it.
    // Note: This just uses the first selected graphic. Multi-select is ignored.
    const auto& selectedListItems{libraryWindow.getSelectedListItems()};
    if (selectedListItems.size() > 0) {
        for (const LibraryListItem* selectedItem : selectedListItems) {
            // If this is a sprite or animation, update the given model slot.
            if (selectedItem->type == LibraryListItem::Type::Sprite) {
                SpriteID spriteID{static_cast<SpriteID>(selectedItem->ID)};
                dataModel.entityGraphicSetModel.setEntitySlot(
                    activeGraphicSetID, graphicType, direction,
                    toGraphicID(spriteID));
                break;
            }
            else if (selectedItem->type == LibraryListItem::Type::Animation) {
                AnimationID animationID{
                    static_cast<AnimationID>(selectedItem->ID)};
                dataModel.entityGraphicSetModel.setEntitySlot(
                    activeGraphicSetID, graphicType, direction,
                    toGraphicID(animationID));
                break;
            }
        }
    }
    else {
        // No selection. Empty the slot.
        dataModel.entityGraphicSetModel.setEntitySlot(
            activeGraphicSetID, graphicType, direction, NULL_GRAPHIC_ID);
    }
}

void EntityGraphicSetEditView::styleText(AUI::Text& text)
{
    text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    text.setColor({255, 255, 255, 255});
}

void EntityGraphicSetEditView::initGraphicContainer()
{
    // Fill the container with a slot widget for each EntityGraphicType 
    // and Rotation::Direction.
    graphicContainer.clear();
    iterateEntityGraphicTypes([&](EntityGraphicType graphicType) {
        for (Uint8 j{0}; j < Rotation::Direction::Count; j++) {
            Rotation::Direction direction{static_cast<Rotation::Direction>(j)};

            // Construct the new slot widget.
            std::unique_ptr<AUI::Widget> slotPtr{
                std::make_unique<GraphicSetSlot>(SLOT_WIDTH)};
            GraphicSetSlot& slot{static_cast<GraphicSetSlot&>(*slotPtr)};

            // Set the top text.
            std::string topText{DisplayStrings::get(graphicType)};
            topText += " " + DisplayStrings::get(direction);
            slot.topText.setText(topText);

            // Fill in the graphic's data.
            fillSlotGraphicData(slot, NULL_GRAPHIC_ID);

            // Set the assignment button callback.
            slot.assignButton.setOnPressed([this, graphicType, direction]() {
                onAssignButtonPressed(graphicType, direction);
            });

            graphicContainer.push_back(std::move(slotPtr));
        }
    });
}

void EntityGraphicSetEditView::fillSlotGraphicData(GraphicSetSlot& slot,
                                                   GraphicID graphicID)
{
    // If this slot isn't empty, set the widget's data.
    if (graphicID) {
        // Set the text.
        EditorGraphicRef graphic{dataModel.getGraphic(graphicID)};
        slot.spriteNameText.setText(graphic.getDisplayName());

        // Get the graphic's first sprite.
        const EditorSprite* sprite{graphic.getFirstSprite()};
        if (!sprite) {
            // Graphic doesn't have a sprite (empty animation). Leave the 
            // image blank.
            slot.spriteImage.setIsVisible(false);
            return;
        }

        // Calc a square texture extent that shows the bottom of the sprite
        // (so we don't have to squash it).
        SDL_Rect textureExtent{sprite->textureExtent};
        textureExtent.x = 0;
        textureExtent.y = 0;
        if (textureExtent.h > textureExtent.w) {
            int diff{textureExtent.h - textureExtent.w};
            textureExtent.h -= diff;
            textureExtent.y += diff;
        }

        // Load the sprite's image into the slot.
        std::string imagePath{dataModel.getWorkingIndividualSpritesDir()};
        imagePath += sprite->imagePath;
        slot.spriteImage.setSimpleImage(imagePath, textureExtent);
        slot.spriteImage.setIsVisible(true);
    }
    else {
        // Empty slot.
        slot.spriteImage.setIsVisible(false);
        slot.spriteNameText.setText("Empty");
    }
}

std::size_t EntityGraphicSetEditView::toIndex(EntityGraphicType graphicType,
                                              Rotation::Direction direction)
{
    AM_ASSERT(graphicType != EntityGraphicType::NotSet,
              "Tried to get index of uninitialized entity graphic type.");

    return ((static_cast<std::size_t>(graphicType) - 1)
            * Rotation::Direction::Count)
           + direction;
}

template<typename Func>
void EntityGraphicSetEditView::iterateEntityGraphicTypes(Func callback)
{
    static constexpr std::size_t NotSet{
        static_cast<std::size_t>(EntityGraphicType::NotSet)};
    static constexpr std::size_t PROJECT_START{
        static_cast<std::size_t>(EntityGraphicType::PROJECT_START)};
    static constexpr std::size_t PROJECT_END{
        static_cast<std::size_t>(EntityGraphicType::PROJECT_END)};

    // Engine types
    for (std::size_t i{NotSet + 1}; i < PROJECT_START; ++i) {
        callback(static_cast<EntityGraphicType>(i));
    }

    // Project types
    for (std::size_t i{PROJECT_START + 1}; i < PROJECT_END; ++i) {
        callback(static_cast<EntityGraphicType>(i));
    }
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/EntityGraphicSetPropertiesWindow.cpp`:

```cpp
#include "EntityGraphicSetPropertiesWindow.h"
#include "MainScreen.h"
#include "MainThumbnail.h"
#include "DataModel.h"
#include "EditorFloorGraphicSet.h"
#include "SpriteID.h"
#include "Paths.h"
#include "Camera.h"
#include "Transforms.h"
#include "SharedConfig.h"
#include <string>

namespace AM
{
namespace ResourceImporter
{
EntityGraphicSetPropertiesWindow::EntityGraphicSetPropertiesWindow(DataModel& inDataModel)
: AUI::Window({1617, 0, 303, 518}, "EntityGraphicSetPropertiesWindow")
, nameLabel{{24, 52, 65, 28}, "NameLabel"}
, nameInput{{24, 84, 255, 38}, "NameInput"}
, dataModel{inDataModel}
, activeGraphicSetID{SDL_MAX_UINT16}
, backgroundImage{{0, 0, 303, 518}, "PropertiesBackground"}
, headerImage{{0, 0, 303, 40}, "PropertiesHeader"}
, windowLabel{{12, 0, 282, 40}, "PropertiesWindowLabel"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(backgroundImage);
    children.push_back(headerImage);
    children.push_back(windowLabel);
    children.push_back(nameLabel);
    children.push_back(nameInput);

    /* Window setup */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});
    headerImage.setNineSliceImage((Paths::TEXTURE_DIR + "HeaderBackground.png"),
                                  {1, 1, 1, 1});
    windowLabel.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 21);
    windowLabel.setColor({255, 255, 255, 255});
    windowLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    windowLabel.setText("Entity Properties");

    /* Display name entry. */
    nameLabel.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 21);
    nameLabel.setColor({255, 255, 255, 255});
    nameLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    nameLabel.setText("Name");

    nameInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    nameInput.setPadding({0, 8, 0, 8});
    nameInput.setOnTextCommitted([this]() { saveName(); });

    // When the active graphic set is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&EntityGraphicSetPropertiesWindow::onActiveLibraryItemChanged>(*this);
    dataModel.entityGraphicSetModel.entityRemoved
        .connect<&EntityGraphicSetPropertiesWindow::onEntityRemoved>(*this);
    dataModel.entityGraphicSetModel.entityDisplayNameChanged
        .connect<&EntityGraphicSetPropertiesWindow::onEntityDisplayNameChanged>(
            *this);
}

void EntityGraphicSetPropertiesWindow::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is an entity graphic set and return early if 
    // not.
    const EditorEntityGraphicSet* newActiveGraphicSet{
        get_if<EditorEntityGraphicSet>(&newActiveItem)};
    if (!newActiveGraphicSet) {
        activeGraphicSetID = SDL_MAX_UINT16;
        nameInput.setText("");
        return;
    }

    activeGraphicSetID = newActiveGraphicSet->numericID;

    // Update all of our property fields to match the new active graphic 
    // set's data.
    nameInput.setText(newActiveGraphicSet->displayName);
}

void EntityGraphicSetPropertiesWindow::onEntityRemoved(
    EntityGraphicSetID graphicSetID)
{
    // If the active entity set was deleted, hide this window.
    if (graphicSetID == activeGraphicSetID) {
        activeGraphicSetID = SDL_MAX_UINT16;
        setIsVisible(false);
    }
}

void EntityGraphicSetPropertiesWindow::onEntityDisplayNameChanged(
    EntityGraphicSetID graphicSetID, const std::string& newDisplayName)
{
    if (graphicSetID == activeGraphicSetID) {
        nameInput.setText(newDisplayName);
    }
}

void EntityGraphicSetPropertiesWindow::saveName()
{
    dataModel.entityGraphicSetModel.setEntityDisplayName(activeGraphicSetID,
                                                         nameInput.getText());
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/GraphicSetEditView.cpp`:

```cpp
#include "GraphicSetEditView.h"
#include "MainScreen.h"
#include "DataModel.h"
#include "SpriteID.h"
#include "LibraryItemData.h"
#include "Paths.h"
#include "AUI/Core.h"

namespace AM
{
namespace ResourceImporter
{
GraphicSetEditView::GraphicSetEditView(DataModel& inDataModel,
                                       const LibraryWindow& inLibraryWindow)
: AUI::Window({320, 58, 1297, 1022}, "GraphicSetEditView")
, dataModel{inDataModel}
, libraryWindow{inLibraryWindow}
, activeGraphicSetType{GraphicSet::Type::None}
, activeGraphicSetID{SDL_MAX_UINT16}
, topText{{0, 0, logicalExtent.w, 34}, "TopText"}
, actionText{{184, 58, 929, 50}, "ActionText"}
, graphicContainer{{249, 180, 800, 516}, "GraphicContainer"}
, descText{{24, 806, 1240, 220}, "DescText"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(topText);
    children.push_back(actionText);
    children.push_back(graphicContainer);
    children.push_back(descText);

    /* Text */
    topText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 26);
    topText.setColor({255, 255, 255, 255});
    topText.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Center);

    styleText(actionText);
    actionText.setText(
        "To modify: select a sprite or animation in the Library window, then "
        "press one of the Assign buttons.\nTo clear: click an empty area to "
        "clear your selection, then press one of the Assign buttons.");
    styleText(descText);

    /* Container */
    graphicContainer.setNumColumns(4);
    graphicContainer.setCellWidth(200);
    graphicContainer.setCellHeight(247 + 22);

    // When the active graphic set is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&GraphicSetEditView::onActiveLibraryItemChanged>(*this);
    dataModel.graphicSetModel.graphicSetRemoved
        .connect<&GraphicSetEditView::onGraphicSetRemoved>(*this);
    dataModel.graphicSetModel.graphicSetSlotChanged
        .connect<&GraphicSetEditView::onGraphicSetSlotChanged>(*this);
}

void GraphicSetEditView::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    if (holds_alternative<EditorTerrainGraphicSet>(newActiveItem)) {
        loadActiveGraphicSet(GraphicSet::Type::Terrain,
                             get<EditorTerrainGraphicSet>(newActiveItem));
    }
    else if (holds_alternative<EditorFloorGraphicSet>(newActiveItem)) {
        loadActiveGraphicSet(GraphicSet::Type::Floor,
                             get<EditorFloorGraphicSet>(newActiveItem));
    }
    else if (holds_alternative<EditorWallGraphicSet>(newActiveItem)) {
        loadActiveGraphicSet(GraphicSet::Type::Wall,
                             get<EditorWallGraphicSet>(newActiveItem));
    }
    else if (holds_alternative<EditorObjectGraphicSet>(newActiveItem)) {
        loadActiveGraphicSet(GraphicSet::Type::Object,
                             get<EditorObjectGraphicSet>(newActiveItem));
    }
    else {
        // New active item is not a graphic set. Clear this view.
        activeGraphicSetType = GraphicSet::Type::None;
        activeGraphicSetID = SDL_MAX_UINT16;
        graphicContainer.setIsVisible(false);
    }
}

void GraphicSetEditView::onGraphicSetRemoved(GraphicSet::Type type,
                                            Uint16 graphicSetID)
{
    // If the active set was deleted, hide this window.
    if ((type == activeGraphicSetType) && (graphicSetID == activeGraphicSetID)) {
        activeGraphicSetType = GraphicSet::Type::None;
        activeGraphicSetID = SDL_MAX_UINT16;
        setIsVisible(false);
    }
}

void GraphicSetEditView::onGraphicSetSlotChanged(GraphicSet::Type type,
                                                Uint16 graphicSetID,
                                                std::size_t index,
                                                GraphicID newGraphicID)
{
    // If the changed data doesn't affect us, return early.
    if ((type != activeGraphicSetType) || (graphicSetID != activeGraphicSetID)) {
        return;
    }
    if (index > graphicContainer.size()) {
        LOG_FATAL("Index out of bounds.");
    }

    // Fill in the new slot data.
    GraphicSetSlot& slot{static_cast<GraphicSetSlot&>(*graphicContainer[index])};
    fillSlotGraphicData(slot, newGraphicID);
}

template<typename T>
void GraphicSetEditView::loadActiveGraphicSet(GraphicSet::Type graphicSetType,
                                               const T& newActiveGraphicSet)
{
    activeGraphicSetType = graphicSetType;
    activeGraphicSetID = newActiveGraphicSet.numericID;

    // Fill the container with the graphic set's graphics.
    graphicContainer.clear();
    for (std::size_t i = 0; i < newActiveGraphicSet.graphicIDs.size(); ++i) {
        GraphicID graphicID{newActiveGraphicSet.graphicIDs[i]};

        // Construct the new slot widget.
        std::unique_ptr<AUI::Widget> slotPtr{
            std::make_unique<GraphicSetSlot>(200)};
        GraphicSetSlot& slot{static_cast<GraphicSetSlot&>(*slotPtr)};

        // Set the top text.
        slot.topText.setText(getSlotTopText(i));

        // Fill in the graphic's data.
        fillSlotGraphicData(slot, graphicID);

        // Set the assignment button callback.
        slot.assignButton.setOnPressed([this, i]() {
            onAssignButtonPressed(i);
        });

        graphicContainer.push_back(std::move(slotPtr));
    }

    // Make sure the container is visible.
    graphicContainer.setIsVisible(true);

    // Fill in the appropriate description texts for the active graphic set type.
    fillDescriptionTexts();
}

void GraphicSetEditView::onAssignButtonPressed(std::size_t slotIndex)
{
    // If a graphic is selected, set the given slot to it.
    // Note: This just uses the first selected graphic. Multi-select is ignored.
    const auto& selectedListItems{libraryWindow.getSelectedListItems()};
    if (selectedListItems.size() > 0) {
        for (const LibraryListItem* selectedItem : selectedListItems) {
            // If this is a sprite or animation, update the given model slot.
            if (selectedItem->type == LibraryListItem::Type::Sprite) {
                SpriteID spriteID{static_cast<SpriteID>(selectedItem->ID)};
                dataModel.graphicSetModel.setGraphicSetSlot(
                    activeGraphicSetType, activeGraphicSetID, slotIndex,
                    toGraphicID(spriteID));
                break;
            }
            else if (selectedItem->type == LibraryListItem::Type::Animation) {
                AnimationID animationID{
                    static_cast<AnimationID>(selectedItem->ID)};
                dataModel.graphicSetModel.setGraphicSetSlot(
                    activeGraphicSetType, activeGraphicSetID, slotIndex,
                    toGraphicID(animationID));
                break;
            }
        }
    }
    else {
        // No selection. Empty the slot.
        dataModel.graphicSetModel.setGraphicSetSlot(activeGraphicSetType,
                                                    activeGraphicSetID,
                                                    slotIndex, NULL_GRAPHIC_ID);
    }
}

void GraphicSetEditView::styleText(AUI::Text& text)
{
    text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    text.setColor({255, 255, 255, 255});
}

std::string GraphicSetEditView::getSlotTopText(std::size_t graphicSetIndex)
{
    switch (activeGraphicSetType) {
        case GraphicSet::Type::Terrain: {
            switch (graphicSetIndex) {
                case Terrain::Height::Flat:
                    return "Flat";
                case Terrain::Height::OneThird:
                    return "1/3 Height";
                case Terrain::Height::TwoThird:
                    return "2/3 Height";
                case Terrain::Height::Full:
                    return "Full Height";
            }
        }
        case GraphicSet::Type::Floor:
            [[fallthrough]];
        case GraphicSet::Type::Object: {
            switch (graphicSetIndex) {
                case Rotation::Direction::South:
                    return "0 (S)";
                case Rotation::Direction::SouthWest:
                    return "1 (SW)";
                case Rotation::Direction::West:
                    return "2 (W)";
                case Rotation::Direction::NorthWest:
                    return "3 (NW)";
                case Rotation::Direction::North:
                    return "4 (N)";
                case Rotation::Direction::NorthEast:
                    return "5 (NE)";
                case Rotation::Direction::East:
                    return "6 (E)";
                case Rotation::Direction::SouthEast:
                    return "7 (SE)";
                default:
                    return "";
            }
        }
        case GraphicSet::Type::Wall: {
            switch (graphicSetIndex) {
                case Wall::Type::West:
                    return "West";
                case Wall::Type::North:
                    return "North";
                case Wall::Type::NorthWestGapFill:
                    return "NW Gap Fill";
                case Wall::Type::NorthEastGapFill:
                    return "NE Gap Fill";
                default:
                    return "";
            }
        }
        default: {
            return "";
        }
    }

    return "";
}

void GraphicSetEditView::fillSlotGraphicData(GraphicSetSlot& slot,
                                              GraphicID graphicID)
{
    // If this slot isn't empty, set the widget's data.
    if (graphicID) {
        // Set the text.
        EditorGraphicRef graphic{dataModel.getGraphic(graphicID)};
        slot.spriteNameText.setText(graphic.getDisplayName());

        // Get the graphic's first sprite.
        const EditorSprite* sprite{graphic.getFirstSprite()};
        if (!sprite) {
            // Graphic doesn't have a sprite (empty animation). Leave the 
            // image blank.
            slot.spriteImage.setIsVisible(false);
            return;
        }

        // Calc a square texture extent that shows the bottom of the sprite
        // (so we don't have to squash it).
        SDL_Rect textureExtent{sprite->textureExtent};
        if (textureExtent.h > textureExtent.w) {
            int diff{textureExtent.h - textureExtent.w};
            textureExtent.h -= diff;
            textureExtent.y += diff;
        }

        // Load the sprite's image into the slot.
        std::string imagePath{dataModel.getWorkingIndividualSpritesDir()};
        imagePath += sprite->imagePath;
        slot.spriteImage.setSimpleImage(
            imagePath,
            {0, 0, sprite->textureExtent.w, sprite->textureExtent.h});
        slot.spriteImage.setIsVisible(true);
    }
    else {
        // Empty slot.
        slot.spriteImage.setIsVisible(false);
        slot.spriteNameText.setText("Empty");
    }
}

void GraphicSetEditView::fillDescriptionTexts()
{
    switch (activeGraphicSetType) {
        case GraphicSet::Type::Terrain: {
            topText.setText("Terrain Graphic Set");
            descText.setText(
                "Terrain is comprised of blocks of various heights. All block "
                "heights are relative to the height of a world-space tile "
                "(SharedConfig::TILE_WORLD_HEIGHT).\n\nAt least 1 graphic must "
                "be set, but you don't need to set every graphic. The build "
                "tool should skip missing graphics.\n\nCollision geometry is "
                "auto-generated for each piece of terrain based on its height. "
                "You don't need to bother adding bounding geometry to terrain "
                "graphic. All terrain has collision, regardless of each "
                "graphic's collisionEnabled.");
            break;
        }
        case GraphicSet::Type::Floor: {
            topText.setText("Floor Graphic Set");
            descText.setText(
                "Floors are things like grass, rugs, flooring, etc. They sit "
                "on top of the terrain and have no collision (regardless of "
                "each graphic's collisionEnabled).\n\nMake sure to draw "
                "appropriate bounding volumes on each floor graphic, as they "
                "will be used when clicking the floor in build mode.\n\nEach "
                "index is associated with a direction (in parenthesis). You "
                "can ignore it if it isn't applicable to your set of "
                "graphics.\nAt least 1 graphic must be set, but you don't need "
                "to set every graphic. The build tool should skip missing "
                "graphics.");
            break;
        }
        case GraphicSet::Type::Wall: {
            topText.setText("Wall Graphic Set");
            descText.setText(
                "With these 4 wall graphic types, the engine's modular wall "
                "system is able to form any shape of wall.\n\nWalls may have "
                "collision. You can control this using each graphic's "
                "collisionEnabled.\n\nMake sure to draw appropriate bounding "
                "volumes on each graphic, as they will be used when clicking the "
                "object in build mode.\n\nAll 4 graphics must be set.");
            break;
        }
        case GraphicSet::Type::Object: {
            topText.setText("Object Graphic Set");
            descText.setText(
                "Objects are anything that doesn't fit into the other "
                "categories.\n\nEach index is associated with a direction (in "
                "parenthesis). You can ignore it if it isn't applicable to "
                "your set of sprites.\n\nMake sure to draw appropriate "
                "bounding volumes on each graphic, as they will be used when "
                "clicking the object in build mode.\n\nObjects may have "
                "collision. You can control this using each graphic's "
                "collisionEnabled.\n\nAt least 1 graphic must be set, but you "
                "don't need to set graphics for every index. The build tool "
                "should skip missing graphics.");
            break;
        }
        default: {
            break;
        }
    }
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/GraphicSetPropertiesWindow.cpp`:

```cpp
#include "GraphicSetPropertiesWindow.h"
#include "MainScreen.h"
#include "MainThumbnail.h"
#include "DataModel.h"
#include "EditorFloorGraphicSet.h"
#include "SpriteID.h"
#include "Paths.h"
#include "Camera.h"
#include "Transforms.h"
#include "SharedConfig.h"
#include <string>

namespace AM
{
namespace ResourceImporter
{
GraphicSetPropertiesWindow::GraphicSetPropertiesWindow(DataModel& inDataModel)
: AUI::Window({1617, 0, 303, 518}, "GraphicSetPropertiesWindow")
, nameLabel{{24, 52, 65, 28}, "NameLabel"}
, nameInput{{24, 84, 255, 38}, "NameInput"}
, setDefaultGraphicBoundsButton{{24, 134, 255, 34},
                               "Set Default Graphic Bounds",
                               "SetDefaultGraphicBoundsButton"}
, dataModel{inDataModel}
, activeGraphicSetType{GraphicSet::Type::None}
, activeGraphicSetID{SDL_MAX_UINT16}
, backgroundImage{{0, 0, 303, 518}, "PropertiesBackground"}
, headerImage{{0, 0, 303, 40}, "PropertiesHeader"}
, windowLabel{{12, 0, 282, 40}, "PropertiesWindowLabel"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(backgroundImage);
    children.push_back(headerImage);
    children.push_back(windowLabel);
    children.push_back(nameLabel);
    children.push_back(nameInput);
    children.push_back(setDefaultGraphicBoundsButton);

    /* Window setup */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});
    headerImage.setNineSliceImage((Paths::TEXTURE_DIR + "HeaderBackground.png"),
                                  {1, 1, 1, 1});
    windowLabel.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 21);
    windowLabel.setColor({255, 255, 255, 255});
    windowLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    windowLabel.setText("Floor Properties");

    /* Display name entry. */
    nameLabel.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 21);
    nameLabel.setColor({255, 255, 255, 255});
    nameLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    nameLabel.setText("Name");

    nameInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    nameInput.setPadding({0, 8, 0, 8});
    nameInput.setOnTextCommitted([this]() { saveName(); });

    /* Bounds setting. */
    setDefaultGraphicBoundsButton.text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 16);
    setDefaultGraphicBoundsButton.setOnPressed(
        [&]() { onSetDefaultGraphicBoundsButtonPressed(); });

    // When the active graphic set is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&GraphicSetPropertiesWindow::onActiveLibraryItemChanged>(*this);
    dataModel.graphicSetModel.graphicSetRemoved
        .connect<&GraphicSetPropertiesWindow::onGraphicSetRemoved>(*this);
    dataModel.graphicSetModel.graphicSetDisplayNameChanged
        .connect<&GraphicSetPropertiesWindow::onGraphicSetDisplayNameChanged>(
            *this);
}

void GraphicSetPropertiesWindow::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    if (holds_alternative<EditorTerrainGraphicSet>(newActiveItem)) {
        loadActiveGraphicSet(GraphicSet::Type::Terrain,
                             get<EditorTerrainGraphicSet>(newActiveItem));
    }
    else if (holds_alternative<EditorFloorGraphicSet>(newActiveItem)) {
        loadActiveGraphicSet(GraphicSet::Type::Floor,
                             get<EditorFloorGraphicSet>(newActiveItem));
    }
    else if (holds_alternative<EditorWallGraphicSet>(newActiveItem)) {
        loadActiveGraphicSet(GraphicSet::Type::Wall,
                             get<EditorWallGraphicSet>(newActiveItem));
    }
    else if (holds_alternative<EditorObjectGraphicSet>(newActiveItem)) {
        loadActiveGraphicSet(GraphicSet::Type::Object,
                             get<EditorObjectGraphicSet>(newActiveItem));
    }
    else {
        // New active item is not a graphic set. Clear this panel.
        activeGraphicSetType = GraphicSet::Type::None;
        activeGraphicSetID = SDL_MAX_UINT16;
        nameInput.setText("");
    }
}

void GraphicSetPropertiesWindow::onGraphicSetRemoved(GraphicSet::Type type,
                                                   Uint16 graphicSetID)
{
    // If the active set was deleted, hide this window.
    if ((type == activeGraphicSetType) && (graphicSetID == activeGraphicSetID)) {
        activeGraphicSetType = GraphicSet::Type::None;
        activeGraphicSetID = SDL_MAX_UINT16;
        setIsVisible(false);
    }
}

void GraphicSetPropertiesWindow::onGraphicSetDisplayNameChanged(
    GraphicSet::Type type, Uint16 graphicSetID, const std::string& newDisplayName)
{
    if ((type == activeGraphicSetType) && (graphicSetID == activeGraphicSetID)) {
        nameInput.setText(newDisplayName);
    }
}

template<typename T>
void GraphicSetPropertiesWindow::loadActiveGraphicSet(
    GraphicSet::Type graphicSetType, const T& newActiveGraphicSet)
{
    activeGraphicSetType = graphicSetType;
    activeGraphicSetID = newActiveGraphicSet.numericID;

    // Hide any widgets that aren't used for every graphic set type.
    setDefaultGraphicBoundsButton.setIsVisible(false);

    switch (activeGraphicSetType) {
        case GraphicSet::Type::Terrain: {
            windowLabel.setText("Terrain Properties");
            break;
        }
        case GraphicSet::Type::Floor: {
            windowLabel.setText("Floor Properties");
            setDefaultGraphicBoundsButton.setIsVisible(true);
            break;
        }
        case GraphicSet::Type::Wall: {
            windowLabel.setText("Wall Properties");
            break;
        }
        case GraphicSet::Type::Object: {
            windowLabel.setText("Object Properties");
            break;
        }
    }

    // Update all of our property fields to match the new active graphic set's
    // data.
    nameInput.setText(newActiveGraphicSet.displayName);
}

void GraphicSetPropertiesWindow::onSetDefaultGraphicBoundsButtonPressed()
{
    // Note: We assume a Floor graphic set is loaded. This button shouldn't be 
    //       visible otherwise.

    static constexpr BoundingBox defaultFloorBounds{
        {0, 0, 0},
        {SharedConfig::TILE_WORLD_WIDTH, SharedConfig::TILE_WORLD_WIDTH, 0}};

    // Set the bounds of each graphic in the set to the default floor bounds.
    const EditorFloorGraphicSet& floorGraphicSet{
        dataModel.graphicSetModel.getFloor(activeGraphicSetID)};
    for (const GraphicID& graphicID : floorGraphicSet.graphicIDs) {
        // If this slot is empty, skip it.
        if (!graphicID) {
            continue;
        }
           
        if (isSpriteID(graphicID)) {
            dataModel.spriteModel.setSpriteCustomModelBounds(
                toSpriteID(graphicID), defaultFloorBounds);
        }
        else {
            // Animation ID.
            dataModel.animationModel.setAnimationCustomModelBounds(
                toAnimationID(graphicID), defaultFloorBounds);
        }
    }
}

void GraphicSetPropertiesWindow::saveName()
{
    dataModel.graphicSetModel.setGraphicSetDisplayName(
        activeGraphicSetType, activeGraphicSetID, nameInput.getText());
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/HamburgerButtonWindow.cpp`:

```cpp
#include "HamburgerButtonWindow.h"
#include "MainScreen.h"
#include "Paths.h"

namespace AM
{
namespace ResourceImporter
{
HamburgerButtonWindow::HamburgerButtonWindow(MainScreen& inScreen)
: AUI::Window({1537, 0, 116, 58}, "HamburgerButtonWindow")
, mainScreen{inScreen}
, backgroundImage{{0, 0, 58, 58}}
, hamburgerButton({0, 0, 58, 58}, "HamburgerButton")
{
    // Add our children so they're included in rendering, etc.
    children.push_back(backgroundImage);
    children.push_back(hamburgerButton);

    /* Window setup */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});

    /* Buttons. */
    hamburgerButton.normalImage.setSimpleImage(
        Paths::TEXTURE_DIR + "HamburgerButton/Normal.png", SDL_ScaleModeLinear);
    hamburgerButton.hoveredImage.setSimpleImage(
        Paths::TEXTURE_DIR + "HamburgerButton/Hovered.png",
        SDL_ScaleModeLinear);
    hamburgerButton.pressedImage.setSimpleImage(
        Paths::TEXTURE_DIR + "HamburgerButton/Pressed.png",
        SDL_ScaleModeLinear);
    hamburgerButton.text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 33);
    hamburgerButton.text.setText("");

    hamburgerButton.setOnPressed([this]() { mainScreen.openHamburgerMenu(); });
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/HamburgerMenu.cpp`:

```cpp
#include "HamburgerMenu.h"
#include "MainScreen.h"
#include "Paths.h"

namespace AM
{
namespace ResourceImporter
{
HamburgerMenu::HamburgerMenu()
: AUI::Window({1368, 13, 169, 66}, "HamburgerMenu")
, backgroundImage({0, 0, logicalExtent.w, logicalExtent.h})
, saveButton({1, 1, 167, 32}, "SaveButton")
, exportButton({1, 33, 167, 32}, "ExportButton")
{
    // Add our children so they're included in rendering, etc.
    children.push_back(backgroundImage);
    children.push_back(saveButton);
    children.push_back(exportButton);

    // Flag ourselves as focusable, so we can close when focus is lost.
    isFocusable = true;

    /* Background image. */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});

    /* Buttons. */
    styleButton(saveButton, "Save");
    styleButton(exportButton, "Export");
}

void HamburgerMenu::onFocusLost(AUI::FocusLostType focusLostType)
{
    // When we lose focus, close the menu.
    setIsVisible(false);
}

void HamburgerMenu::styleButton(AUI::Button& button, const std::string& text)
{
    button.text.setLogicalExtent({10, 0, (167 - 10), 31});
    button.hoveredImage.setSimpleImage(Paths::TEXTURE_DIR
                                       + "Highlights/Hovered.png");
    button.text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    button.text.setColor({255, 255, 255, 255});
    button.text.setText(text);
    button.text.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Left);
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/IconEditView.cpp`:

```cpp
#include "IconEditView.h"
#include "MainScreen.h"
#include "EditorIcon.h"
#include "DataModel.h"
#include "Paths.h"
#include "AUI/Core.h"
#include "AUI/ScalingHelpers.h"

namespace AM
{
namespace ResourceImporter
{
IconEditView::IconEditView(DataModel& inDataModel)
: AUI::Window({320, 58, 1297, 1022}, "IconEditView")
, dataModel{inDataModel}
, activeIconID{NULL_ICON_ID}
, topText{{0, 0, logicalExtent.w, 34}, "TopText"}
, checkerboardImage{{0, 0, 100, 100}, "BackgroundImage"}
, iconImage{{0, 0, 100, 100}, "IconImage"}
, descText{{24, 806, 1240, 100}, "DescText"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(topText);
    children.push_back(checkerboardImage);
    children.push_back(iconImage);
    children.push_back(descText);

    /* Text */
    topText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 26);
    topText.setColor({255, 255, 255, 255});
    topText.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Center);
    topText.setText("Icon");

    styleText(descText);
    descText.setText("Icons are used for items and equipment. They can also be "
                     "used by your project for things like skills.");

    /* Active icon and checkerboard background. */
    checkerboardImage.setTiledImage(Paths::TEXTURE_DIR
                                    + "SpriteEditView/Checkerboard.png");
    checkerboardImage.setIsVisible(false);
    iconImage.setIsVisible(false);

    // When the active sprite is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&IconEditView::onActiveLibraryItemChanged>(*this);
    dataModel.iconModel.iconRemoved.connect<&IconEditView::onIconRemoved>(
        *this);
}

void IconEditView::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is a icon and return early if not.
    const EditorIcon* newActiveIcon{get_if<EditorIcon>(&newActiveItem)};
    if (!newActiveIcon) {
        activeIconID = NULL_ICON_ID;
        return;
    }

    activeIconID = newActiveIcon->numericID;

    // Load the icon's image.
    std::string imagePath{dataModel.getWorkingTexturesDir()};
    imagePath += newActiveIcon->parentIconSheetPath;
    iconImage.setSimpleImage(imagePath, newActiveIcon->textureExtent);

    // Center the icon to the stage's X, but use a fixed Y.
    SDL_Rect centeredIconExtent{newActiveIcon->textureExtent};
    centeredIconExtent.x = logicalExtent.w / 2;
    centeredIconExtent.x -= (centeredIconExtent.w / 2);
    centeredIconExtent.y = AUI::ScalingHelpers::logicalToActual(212);

    // Size the icon image to the icon extent size.
    iconImage.setLogicalExtent(centeredIconExtent);

    // Set the background to the size of the icon.
    checkerboardImage.setLogicalExtent(iconImage.getLogicalExtent());

    // Set the icon and background to be visible.
    checkerboardImage.setIsVisible(true);
    iconImage.setIsVisible(true);
}

void IconEditView::onIconRemoved(IconID iconID)
{
    // If the active icon was deleted, hide this window.
    if (iconID == activeIconID) {
        activeIconID = NULL_ICON_ID;
        setIsVisible(false);
    }
}

void IconEditView::styleText(AUI::Text& text)
{
    text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    text.setColor({255, 255, 255, 255});
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/IconPropertiesWindow.cpp`:

```cpp
#include "IconPropertiesWindow.h"
#include "MainScreen.h"
#include "DataModel.h"
#include "EditorIcon.h"
#include "Paths.h"
#include <string>
#include <iostream>

namespace AM
{
namespace ResourceImporter
{
IconPropertiesWindow::IconPropertiesWindow(DataModel& inDataModel)
: AUI::Window({1617, 0, 303, 518}, "IconPropertiesWindow")
, nameLabel{{24, 52, 65, 28}, "NameLabel"}
, nameInput{{24, 84, 255, 38}, "NameInput"}
, dataModel{inDataModel}
, activeIconID{NULL_ICON_ID}
, backgroundImage{{0, 0, 303, 518}, "PropertiesBackground"}
, headerImage{{0, 0, 303, 40}, "PropertiesHeader"}
, windowLabel{{12, 0, 282, 40}, "PropertiesWindowLabel"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(backgroundImage);
    children.push_back(headerImage);
    children.push_back(windowLabel);
    children.push_back(nameLabel);
    children.push_back(nameInput);

    /* Window setup */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});
    headerImage.setNineSliceImage((Paths::TEXTURE_DIR + "HeaderBackground.png"),
                                  {1, 1, 1, 1});
    windowLabel.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 21);
    windowLabel.setColor({255, 255, 255, 255});
    windowLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    windowLabel.setText("Icon Properties");

    /* Display name entry. */
    nameLabel.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 21);
    nameLabel.setColor({255, 255, 255, 255});
    nameLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    nameLabel.setText("Name");

    nameInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    nameInput.setPadding({0, 8, 0, 8});
    nameInput.setOnTextCommitted([this]() { saveName(); });

    // When the active icon is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&IconPropertiesWindow::onActiveLibraryItemChanged>(*this);
    dataModel.iconModel.iconDisplayNameChanged
        .connect<&IconPropertiesWindow::onIconDisplayNameChanged>(*this);
    dataModel.iconModel.iconRemoved
        .connect<&IconPropertiesWindow::onIconRemoved>(*this);
}

void IconPropertiesWindow::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is an icon and return early if not.
    const EditorIcon* newActiveIcon{get_if<EditorIcon>(&newActiveItem)};
    if (newActiveIcon == nullptr) {
        activeIconID = NULL_ICON_ID;
        return;
    }

    activeIconID = newActiveIcon->numericID;

    // Update all of our property fields to match the new active icon's data.
    nameInput.setText(newActiveIcon->displayName);
}

void IconPropertiesWindow::onIconRemoved(IconID iconID)
{
    // If the active icon was deleted, hide this window.
    if (iconID == activeIconID) {
        activeIconID = NULL_ICON_ID;
        setIsVisible(false);
    }
}

void IconPropertiesWindow::onIconDisplayNameChanged(
    IconID iconID, const std::string& newDisplayName)
{
    if (iconID == activeIconID) {
        nameInput.setText(newDisplayName);
    }
}

void IconPropertiesWindow::saveName()
{
    dataModel.iconModel.setIconDisplayName(activeIconID, nameInput.getText());
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/LibraryAddMenu.cpp`:

```cpp
#include "LibraryAddMenu.h"
#include "MainScreen.h"
#include "Paths.h"

namespace AM
{
namespace ResourceImporter
{
LibraryAddMenu::LibraryAddMenu()
: AUI::Window({310, 5, 169, 227}, "LibraryAddMenu")
, backgroundImage({0, 0, logicalExtent.w, logicalExtent.h})
, addSpriteSheetButton({1, 1, 167, 32}, "AddSpriteSheetButton")
, addTerrainButton({1, 33, 167, 32}, "AddTerrainButton")
, addFloorButton({1, 65, 167, 32}, "AddFloorButton")
, addWallButton({1, 97, 167, 32}, "AddWallButton")
, addObjectButton({1, 129, 167, 32}, "AddObjectButton")
, addEntityButton({1, 161, 167, 32}, "AddEntityButton")
, addIconSheetButton({1, 193, 167, 32}, "AddIconSheetButton")
{
    // Add our children so they're included in rendering, etc.
    children.push_back(backgroundImage);
    children.push_back(addSpriteSheetButton);
    children.push_back(addTerrainButton);
    children.push_back(addFloorButton);
    children.push_back(addWallButton);
    children.push_back(addObjectButton);
    children.push_back(addEntityButton);
    children.push_back(addIconSheetButton);

    // Flag ourselves as focusable, so we can close when focus is lost.
    isFocusable = true;

    /* Background image. */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});

    /* Buttons. */
    styleButton(addSpriteSheetButton, "Sprite Sheet");
    styleButton(addTerrainButton, "Terrain");
    styleButton(addFloorButton, "Floor");
    styleButton(addWallButton, "Wall");
    styleButton(addObjectButton, "Object");
    styleButton(addEntityButton, "Entity");
    styleButton(addIconSheetButton, "Icon Sheet");
}

void LibraryAddMenu::onFocusLost(AUI::FocusLostType focusLostType)
{
    // When we lose focus, close the menu.
    setIsVisible(false);
}

void LibraryAddMenu::styleButton(AUI::Button& button, const std::string& text)
{
    button.text.setLogicalExtent({10, 0, (167 - 10), 31});
    button.hoveredImage.setSimpleImage(Paths::TEXTURE_DIR
                                       + "Highlights/Hovered.png");
    button.text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    button.text.setColor({255, 255, 255, 255});
    button.text.setText(text);
    button.text.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Left);
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/LibraryWindow.cpp`:

```cpp
#include "LibraryWindow.h"
#include "MainScreen.h"
#include "DataModel.h"
#include "Paths.h"
#include "LibraryCollapsibleContainer.h"
#include "ParentListItem.h"
#include "LibraryListItem.h"

namespace AM
{
namespace ResourceImporter
{
LibraryWindow::LibraryWindow(MainScreen& inScreen, DataModel& inDataModel)
: AUI::Window({0, 0, 320, 1080}, "LibraryWindow")
, mainScreen{inScreen}
, dataModel{inDataModel}
, backgroundImage({0, 0, 320, 1080}, "LibraryBackground")
, headerImage({0, 0, 320, 40}, "LibraryHeader")
, windowLabel({12, 0, 80, 40}, "LibraryWindowLabel")
, libraryContainer({1, 40, 318, (1080 - 40 - 1)}, "LibraryContainer")
, addButton({286, 9, 22, 22}, "AddButton")
, selectedItemsChanged{selectedItemsChangedSig}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(backgroundImage);
    children.push_back(headerImage);
    children.push_back(libraryContainer);
    children.push_back(windowLabel);
    children.push_back(addButton);

    // Flag ourselves as focusable, so we can receive keyboard events.
    isFocusable = true;

    /* Window setup */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});
    headerImage.setNineSliceImage((Paths::TEXTURE_DIR + "HeaderBackground.png"),
                                  {1, 1, 1, 1});
    windowLabel.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 21);
    windowLabel.setColor({255, 255, 255, 255});
    windowLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    windowLabel.setText("Library");

    /* Container */
    // Add the collapsible categories.
    // Note: These must be ordered to match the Category enum.
    auto spriteSheetContainer{
        std::make_unique<LibraryCollapsibleContainer>("Sprite Sheets")};
    libraryContainer.push_back(std::move(spriteSheetContainer));
    auto animationContainer{
        std::make_unique<LibraryCollapsibleContainer>("Animations")};
    libraryContainer.push_back(std::move(animationContainer));
    auto boundingBoxContainer{
        std::make_unique<LibraryCollapsibleContainer>("Bounding Boxes")};
    libraryContainer.push_back(std::move(boundingBoxContainer));
    auto terrainContainer{
        std::make_unique<LibraryCollapsibleContainer>("Terrain")};
    libraryContainer.push_back(std::move(terrainContainer));
    auto floorContainer{
        std::make_unique<LibraryCollapsibleContainer>("Floors")};
    libraryContainer.push_back(std::move(floorContainer));
    auto wallContainer{std::make_unique<LibraryCollapsibleContainer>("Walls")};
    libraryContainer.push_back(std::move(wallContainer));
    auto objectContainer{
        std::make_unique<LibraryCollapsibleContainer>("Objects")};
    libraryContainer.push_back(std::move(objectContainer));
    auto entityContainer{
        std::make_unique<LibraryCollapsibleContainer>("Entities")};
    libraryContainer.push_back(std::move(entityContainer));
    auto iconSheetContainer{
        std::make_unique<LibraryCollapsibleContainer>("Icon Sheets")};
    libraryContainer.push_back(std::move(iconSheetContainer));

    /* Add list item button */
    addButton.normalImage.setSimpleImage(Paths::TEXTURE_DIR + "Icons/Plus.png");
    addButton.hoveredImage.setSimpleImage(Paths::TEXTURE_DIR
                                          + "Icons/PlusHovered.png");
    addButton.pressedImage.setSimpleImage(Paths::TEXTURE_DIR
                                          + "Icons/Plus.png");

    addButton.text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 33);
    addButton.text.setText("");

    addButton.setOnPressed([this]() {
        // Bring up the add menu.
        mainScreen.openLibraryAddMenu();
    });

    // When an item is added or removed from the model, update this widget.
    SpriteModel& spriteModel{dataModel.spriteModel};
    spriteModel.sheetAdded.connect<&LibraryWindow::onSpriteSheetAdded>(*this);
    spriteModel.sheetRemoved.connect<&LibraryWindow::onSpriteSheetRemoved>(
        *this);
    spriteModel.spriteAdded.connect<&LibraryWindow::onSpriteAdded>(*this);
    spriteModel.spriteRemoved.connect<&LibraryWindow::onSpriteRemoved>(*this);
    AnimationModel& animationModel{dataModel.animationModel};
    animationModel.animationAdded.connect<&LibraryWindow::onAnimationAdded>(
        *this);
    animationModel.animationRemoved.connect<&LibraryWindow::onAnimationRemoved>(
        *this);
    BoundingBoxModel& boundingBoxModel{dataModel.boundingBoxModel};
    boundingBoxModel.boundingBoxAdded
        .connect<&LibraryWindow::onBoundingBoxAdded>(*this);
    boundingBoxModel.boundingBoxRemoved
        .connect<&LibraryWindow::onBoundingBoxRemoved>(*this);
    GraphicSetModel& graphicSetModel{dataModel.graphicSetModel};
    graphicSetModel.terrainAdded.connect<&LibraryWindow::onTerrainAdded>(*this);
    graphicSetModel.floorAdded.connect<&LibraryWindow::onFloorAdded>(*this);
    graphicSetModel.wallAdded.connect<&LibraryWindow::onWallAdded>(*this);
    graphicSetModel.objectAdded.connect<&LibraryWindow::onObjectAdded>(*this);
    graphicSetModel.graphicSetRemoved.connect<&LibraryWindow::onGraphicSetRemoved>(
        *this);
    EntityGraphicSetModel& entityModel{dataModel.entityGraphicSetModel};
    entityModel.entityAdded.connect<&LibraryWindow::onEntityAdded>(*this);
    entityModel.entityRemoved.connect<&LibraryWindow::onEntityRemoved>(*this);
    IconModel& iconModel{dataModel.iconModel};
    iconModel.sheetAdded.connect<&LibraryWindow::onIconSheetAdded>(*this);
    iconModel.sheetRemoved.connect<&LibraryWindow::onIconSheetRemoved>(*this);

    // When a display name is updated, update the matching thumbnail.
    spriteModel.spriteSheetDisplayNameChanged
        .connect<&LibraryWindow::onSpriteSheetDisplayNameChanged>(*this);
    spriteModel.spriteDisplayNameChanged
        .connect<&LibraryWindow::onSpriteDisplayNameChanged>(*this);
    animationModel.animationDisplayNameChanged
        .connect<&LibraryWindow::onAnimationDisplayNameChanged>(*this);
    boundingBoxModel.boundingBoxDisplayNameChanged
        .connect<&LibraryWindow::onBoundingBoxDisplayNameChanged>(*this);
    graphicSetModel.graphicSetDisplayNameChanged
        .connect<&LibraryWindow::onGraphicSetDisplayNameChanged>(*this);
    entityModel.entityDisplayNameChanged
        .connect<&LibraryWindow::onEntityDisplayNameChanged>(*this);
    iconModel.iconDisplayNameChanged
        .connect<&LibraryWindow::onIconDisplayNameChanged>(*this);
}

const std::vector<LibraryListItem*>& LibraryWindow::getSelectedListItems() const
{
    return selectedListItems;
}

void LibraryWindow::onFocusLost(AUI::FocusLostType focusLostType)
{
    // Deselect all of our selected list items.
    // Note: We need to save a copy of the vector and clear it so that the 
    //       librarySelectedItemsChanged signal is accurate.
    std::vector<LibraryListItem*> tempSelectedListItems(selectedListItems);
    selectedListItems.clear();
    for (LibraryListItem* listItem : tempSelectedListItems) {
        listItem->deselect();
    }

    // Signal that the selections were updated.
    selectedItemsChangedSig.publish(selectedListItems);
}

AUI::EventResult LibraryWindow::onKeyDown(SDL_Keycode keyCode)
{
    // If the delete key was pressed, open the confirmation dialog.
    if (keyCode == SDLK_DELETE) {
        // If there aren't any selected list items, return early.
        if (selectedListItems.size() == 0) {
            return AUI::EventResult{.wasHandled{false}};
        }
        // If any animations are selected, do nothing (animations can't be 
        // deleted, users need to delete their sprites instead).
        for (LibraryListItem* listItem : selectedListItems) {
            if (listItem->type == LibraryListItem::Type::Animation) {
                return AUI::EventResult{.wasHandled{false}};
            }
        }

        // Add the selected items to a vector so any accidental selection
        // changes don't affect the operation.
        itemsToRemove.clear();
        for (LibraryListItem* listItem : selectedListItems) {
            itemsToRemove.push_back(listItem);
        }

        // Set up our data for the confirmation dialog.
        std::string endText{(selectedListItems.size() > 1) ? " items?"
                                                           : " item?"};
        std::string bodyText{};
        bodyText
            += "Delete " + std::to_string(selectedListItems.size()) + endText;

        std::function<void(void)> onConfirmation = [&]() {
            for (LibraryListItem* listItem : itemsToRemove) {
                removeListItem(listItem);
            }
            selectedListItems.clear();
        };

        // Bring up the confirmation dialog.
        mainScreen.openConfirmationDialog(bodyText, "Delete",
                                          std::move(onConfirmation));

        return AUI::EventResult{.wasHandled{true}};
    }

    return AUI::EventResult{.wasHandled{false}};
}

void LibraryWindow::onSpriteSheetAdded(SpriteSheetID sheetID,
                                       const EditorSpriteSheet& sheet)
{
    // Construct a parent list item for this sheet.
    auto sheetListItem{std::make_unique<ParentListItem>(sheet.displayName)};
    sheetListItem->type = LibraryListItem::Type::SpriteSheet;
    sheetListItem->ID = static_cast<int>(sheetID);
    listItemMaps[LibraryListItem::Type::SpriteSheet].emplace(
        sheetID, sheetListItem.get());

    sheetListItem->setOnSelected([this](LibraryListItem* selectedListItem) {
        processSelectedListItem(selectedListItem);
    });
    sheetListItem->setOnDeselected([this](LibraryListItem* deselectedListItem) {
        processDeselectedListItem(deselectedListItem);
    });
    sheetListItem->setOnActivated(
        [this, sheetID](LibraryListItem* activatedListItem) {
            // Set this item's associated sheet as the active item.
            dataModel.setActiveSpriteSheet(sheetID);
        });

    // Add the sheet list item to the sheet container.
    auto& sheetContainer{static_cast<LibraryCollapsibleContainer&>(
        *libraryContainer[Category::SpriteSheets])};
    sheetContainer.push_back(std::move(sheetListItem));
}

void LibraryWindow::onSpriteAdded(SpriteID spriteID, const EditorSprite& sprite,
                                  SpriteSheetID parentSheetID)
{
    // Construct a new list item for this sprite.
    auto spriteListItem{std::make_unique<LibraryListItem>(sprite.displayName)};
    spriteListItem->type = LibraryListItem::Type::Sprite;
    spriteListItem->ID = spriteID;
    listItemMaps[LibraryListItem::Type::Sprite].emplace(spriteID,
                                                        spriteListItem.get());

    spriteListItem->setLeftPadding(57);

    spriteListItem->setOnSelected([this](LibraryListItem* selectedListItem) {
        processSelectedListItem(selectedListItem);
    });
    spriteListItem->setOnDeselected([this](LibraryListItem* deselectedListItem) {
        processDeselectedListItem(deselectedListItem);
    });
    spriteListItem->setOnActivated(
        [this, spriteID](LibraryListItem* activatedListItem) {
            // Set this item's associated sprite as the active item.
            dataModel.setActiveSprite(spriteID);
        });

    // Add the sprite list item to the sheet list item.
    ParentListItem* sheetListItem{static_cast<ParentListItem*>(
        listItemMaps[LibraryListItem::Type::SpriteSheet].at(parentSheetID))};
    sheetListItem->childListItemContainer.push_back(std::move(spriteListItem));
}

void LibraryWindow::onAnimationAdded(AnimationID animationID,
    const EditorAnimation& animation)
{
    // Construct a new list item for this animation.
    auto animationListItem{
        std::make_unique<LibraryListItem>(animation.displayName)};
    animationListItem->type = LibraryListItem::Type::Animation;
    animationListItem->ID = static_cast<int>(animationID);
    listItemMaps[LibraryListItem::Type::Animation].emplace(
        animationID, animationListItem.get());

    animationListItem->setLeftPadding(32);

    animationListItem->setOnSelected([this](LibraryListItem* selectedListItem) {
        processSelectedListItem(selectedListItem);
    });
    animationListItem->setOnDeselected(
        [this](LibraryListItem* deselectedListItem) {
        processDeselectedListItem(deselectedListItem);
    });
    animationListItem->setOnActivated(
        [this, animationID](LibraryListItem*) {
            // Set this list item's associated animation as the active item.
            dataModel.setActiveAnimation(animationID);
        });

    // Add the new list item to the appropriate container.
    auto& listItemContainer{static_cast<LibraryCollapsibleContainer&>(
        *libraryContainer[Category::Animations])};
    listItemContainer.push_back(std::move(animationListItem));
}

void LibraryWindow::onBoundingBoxAdded(BoundingBoxID boundingBoxID,
                                       const EditorBoundingBox& bounds)
{
    // Construct a new list item for this bounding box.
    auto boundingBoxListItem{
        std::make_unique<LibraryListItem>(bounds.displayName)};
    boundingBoxListItem->type = LibraryListItem::Type::BoundingBox;
    boundingBoxListItem->ID = static_cast<int>(boundingBoxID);
    listItemMaps[LibraryListItem::Type::BoundingBox].emplace(
        boundingBoxID, boundingBoxListItem.get());

    boundingBoxListItem->setLeftPadding(32);

    boundingBoxListItem->setOnSelected([this](LibraryListItem* selectedListItem) {
        processSelectedListItem(selectedListItem);
    });
    boundingBoxListItem->setOnDeselected(
        [this](LibraryListItem* deselectedListItem) {
        processDeselectedListItem(deselectedListItem);
    });
    boundingBoxListItem->setOnActivated(
        [this, boundingBoxID](LibraryListItem*) {
            // Set this list item's associated bounding box as the active item.
            dataModel.setActiveBoundingBox(boundingBoxID);
        });

    // Add the new list item to the appropriate container.
    auto& listItemContainer{static_cast<LibraryCollapsibleContainer&>(
        *libraryContainer[Category::BoundingBoxes])};
    listItemContainer.push_back(std::move(boundingBoxListItem));
}

void LibraryWindow::onTerrainAdded(TerrainGraphicSetID terrainID,
                                   const EditorTerrainGraphicSet& terrain)
{
    onGraphicSetAdded<EditorTerrainGraphicSet>(terrainID, terrain);
}

void LibraryWindow::onFloorAdded(FloorGraphicSetID floorID,
                                 const EditorFloorGraphicSet& floor)
{
    onGraphicSetAdded<EditorFloorGraphicSet>(floorID, floor);
}

void LibraryWindow::onWallAdded(WallGraphicSetID wallID,
                                const EditorWallGraphicSet& wall)
{
    onGraphicSetAdded<EditorWallGraphicSet>(wallID, wall);
}

void LibraryWindow::onObjectAdded(ObjectGraphicSetID objectID,
                                  const EditorObjectGraphicSet& object)
{
    onGraphicSetAdded<EditorObjectGraphicSet>(objectID, object);
}

template<typename T>
void LibraryWindow::onGraphicSetAdded(Uint16 graphicSetID, const T& graphicSet)
{
    // Get the appropriate enum values for the given graphic set type.
    GraphicSet::Type graphicSetType{};
    if constexpr (std::is_same_v<T, EditorTerrainGraphicSet>) {
        graphicSetType = GraphicSet::Type::Terrain;
    }
    else if constexpr (std::is_same_v<T, EditorFloorGraphicSet>) {
        graphicSetType = GraphicSet::Type::Floor;
    }
    else if constexpr (std::is_same_v<T, EditorWallGraphicSet>) {
        graphicSetType = GraphicSet::Type::Wall;
    }
    else if constexpr (std::is_same_v<T, EditorObjectGraphicSet>) {
        graphicSetType = GraphicSet::Type::Object;
    }
    LibraryListItem::Type listItemType{toListItemType(graphicSetType)};
    Category category{toCategory(graphicSetType)};

    // Construct a new list item for this graphic set.
    auto graphicSetListItem{
        std::make_unique<LibraryListItem>(graphicSet.displayName)};
    graphicSetListItem->type = listItemType;
    graphicSetListItem->ID = graphicSetID;
    listItemMaps[listItemType].emplace(graphicSetID, graphicSetListItem.get());

    graphicSetListItem->setLeftPadding(32);

    graphicSetListItem->setOnSelected([this](LibraryListItem* selectedListItem) {
        processSelectedListItem(selectedListItem);
    });
    graphicSetListItem->setOnActivated(
        [this, graphicSetType, graphicSetID](LibraryListItem*) {
            // Set this list item's associated graphic set as the active item.
            dataModel.setActiveGraphicSet(graphicSetType, graphicSetID);
        });

    // Add the new list item to the appropriate container.
    auto& listItemContainer{
        static_cast<LibraryCollapsibleContainer&>(*libraryContainer[category])};
    listItemContainer.push_back(std::move(graphicSetListItem));
}

void LibraryWindow::onEntityAdded(EntityGraphicSetID graphicSetID,
                                  const EditorEntityGraphicSet& entity)
{
    // Construct a new list item for this bounding box.
    auto entityListItem{std::make_unique<LibraryListItem>(entity.displayName)};
    entityListItem->type = LibraryListItem::Type::Entity;
    entityListItem->ID = static_cast<int>(graphicSetID);
    listItemMaps[LibraryListItem::Type::Entity].emplace(graphicSetID,
                                                        entityListItem.get());

    entityListItem->setLeftPadding(32);

    entityListItem->setOnSelected([this](LibraryListItem* selectedListItem) {
        processSelectedListItem(selectedListItem);
    });
    entityListItem->setOnDeselected(
        [this](LibraryListItem* deselectedListItem) {
        // Note: Deselect is handled in OnSelected and FocusLost.
        selectedItemsChangedSig.publish(selectedListItems);
    });
    entityListItem->setOnActivated([this, graphicSetID](LibraryListItem*) {
        // Set this list item's associated graphic set as the active item.
        dataModel.setActiveGraphicSet(GraphicSet::Type::Entity, graphicSetID);
    });

    // Add the new list item to the appropriate container.
    auto& listItemContainer{static_cast<LibraryCollapsibleContainer&>(
        *libraryContainer[Category::Entities])};
    listItemContainer.push_back(std::move(entityListItem));
}

void LibraryWindow::onIconSheetAdded(int sheetID, const EditorIconSheet& sheet)
{
    // Create a container for the new sheet.
    auto sheetListItem{std::make_unique<ParentListItem>(sheet.relPath)};
    sheetListItem->type = LibraryListItem::Type::IconSheet;
    sheetListItem->ID = sheetID;
    listItemMaps[LibraryListItem::Type::IconSheet].emplace(sheetID,
                                                           sheetListItem.get());

    sheetListItem->setOnSelected([this](LibraryListItem* selectedListItem) {
        processSelectedListItem(selectedListItem);
    });
    sheetListItem->setOnDeselected([this](LibraryListItem* deselectedListItem) {
        // Note: Deselect is handled in OnSelected and FocusLost.
        selectedItemsChangedSig.publish(selectedListItems);
    });

    // Add each of the new sheet's icons to its child container.
    for (IconID iconID : sheet.iconIDs) {
        addIconToSheetListItem(*sheetListItem, sheet, iconID);
    }

    // Add the sheet list item to the sheet container.
    auto& sheetContainer{static_cast<LibraryCollapsibleContainer&>(
        *libraryContainer[Category::IconSheets])};
    sheetContainer.push_back(std::move(sheetListItem));
}

void LibraryWindow::onSpriteSheetRemoved(SpriteSheetID sheetID)
{
    auto& sheetListItemMap{listItemMaps[LibraryListItem::Type::SpriteSheet]};
    auto sheetIt{sheetListItemMap.find(sheetID)};
    if (sheetIt == sheetListItemMap.end()) {
        LOG_FATAL("Failed to find sprite sheet during removal.");
    }

    // Clear any list item selections.
    for (LibraryListItem* listItem : selectedListItems) {
        listItem->deselect();
    }
    selectedListItems.clear();

    // Remove the list item from the container.
    auto& sheetContainer{static_cast<LibraryCollapsibleContainer&>(
        *libraryContainer[Category::SpriteSheets])};
    sheetContainer.erase(sheetIt->second);

    // Remove the list item from the map.
    sheetListItemMap.erase(sheetIt);
}

void LibraryWindow::onSpriteRemoved(SpriteID spriteID,
                                    SpriteSheetID parentSheetID)
{
    auto& spriteListItemMap{listItemMaps[LibraryListItem::Type::Sprite]};
    auto spriteIt{spriteListItemMap.find(spriteID)};
    if (spriteIt == spriteListItemMap.end()) {
        LOG_FATAL("Failed to find sprite during removal.");
    }

    // Clear any list item selections.
    for (LibraryListItem* listItem : selectedListItems) {
        listItem->deselect();
    }
    selectedListItems.clear();

    // Remove the sprite from the parent sheet list item.
    ParentListItem* sheetListItem{static_cast<ParentListItem*>(
        listItemMaps[LibraryListItem::Type::SpriteSheet].at(parentSheetID))};
    sheetListItem->childListItemContainer.erase(spriteIt->second);

    // Remove the list item from the map.
    spriteListItemMap.erase(spriteIt);
}

void LibraryWindow::onAnimationRemoved(AnimationID animationID)
{
    auto& animationListItemMap{listItemMaps[LibraryListItem::Type::Animation]};
    auto animationIt{animationListItemMap.find(animationID)};
    if (animationIt == animationListItemMap.end()) {
        LOG_FATAL("Failed to find animation during removal.");
    }

    // Clear any list item selections.
    for (LibraryListItem* listItem : selectedListItems) {
        listItem->deselect();
    }
    selectedListItems.clear();

    // Remove the list item from the container.
    auto& animationContainer{static_cast<LibraryCollapsibleContainer&>(
        *libraryContainer[Category::Animations])};
    animationContainer.erase(animationIt->second);

    // Remove the list item from the map.
    animationListItemMap.erase(animationIt);
}

void LibraryWindow::onBoundingBoxRemoved(BoundingBoxID boundingBoxID)
{
    auto& boundsListItemMap{listItemMaps[LibraryListItem::Type::BoundingBox]};
    auto boundsIt{boundsListItemMap.find(boundingBoxID)};
    if (boundsIt == boundsListItemMap.end()) {
        LOG_FATAL("Failed to find bounding box during removal.");
    }

    // Clear any list item selections.
    for (LibraryListItem* listItem : selectedListItems) {
        listItem->deselect();
    }
    selectedListItems.clear();

    // Remove the list item from the container.
    auto& boundsContainer{static_cast<LibraryCollapsibleContainer&>(
        *libraryContainer[Category::BoundingBoxes])};
    boundsContainer.erase(boundsIt->second);

    // Remove the list item from the map.
    boundsListItemMap.erase(boundsIt);
}

void LibraryWindow::onGraphicSetRemoved(GraphicSet::Type type, Uint16 graphicSetID)
{
    auto& listItemMap{listItemMaps[toListItemType(type)]};
    auto graphicSetIt{listItemMap.find(graphicSetID)};
    if (graphicSetIt == listItemMap.end()) {
        LOG_FATAL("Failed to find graphic set during removal.");
    }

    // Clear any list item selections.
    for (LibraryListItem* listItem : selectedListItems) {
        listItem->deselect();
    }
    selectedListItems.clear();

    // Remove the list item from the container.
    auto& graphicSetContainer{static_cast<LibraryCollapsibleContainer&>(
        *libraryContainer[toCategory(type)])};
    graphicSetContainer.erase(graphicSetIt->second);

    // Remove the list item from the map.
    listItemMap.erase(graphicSetIt);
}

void LibraryWindow::onEntityRemoved(EntityGraphicSetID graphicSetID)
{
    auto& listItemMap{listItemMaps[LibraryListItem::Type::Entity]};
    auto graphicSetIt{listItemMap.find(graphicSetID)};
    if (graphicSetIt == listItemMap.end()) {
        LOG_FATAL("Failed to find graphic set during removal.");
    }

    // Clear any list item selections.
    for (LibraryListItem* listItem : selectedListItems) {
        listItem->deselect();
    }
    selectedListItems.clear();

    // Remove the list item from the container.
    auto& graphicSetContainer{static_cast<LibraryCollapsibleContainer&>(
        *libraryContainer[LibraryWindow::Category::Entities])};
    graphicSetContainer.erase(graphicSetIt->second);

    // Remove the list item from the map.
    listItemMap.erase(graphicSetIt);
}

void LibraryWindow::onIconSheetRemoved(int sheetID)
{
    auto& sheetListItemMap{listItemMaps[LibraryListItem::Type::IconSheet]};
    auto sheetIt{sheetListItemMap.find(sheetID)};
    if (sheetIt == sheetListItemMap.end()) {
        LOG_FATAL("Failed to find icon sheet during removal.");
    }

    // Clear any list item selections.
    for (LibraryListItem* listItem : selectedListItems) {
        listItem->deselect();
    }
    selectedListItems.clear();

    // Remove the list item from the container.
    auto& sheetContainer{static_cast<LibraryCollapsibleContainer&>(
        *libraryContainer[Category::IconSheets])};
    sheetContainer.erase(sheetIt->second);

    // Remove the list item from the map.
    sheetListItemMap.erase(sheetIt);
}

void LibraryWindow::onSpriteSheetDisplayNameChanged(
    SpriteSheetID spriteSheetID, const std::string& newDisplayName)
{
    auto& spriteSheetListItemMap{
        listItemMaps[LibraryListItem::Type::SpriteSheet]};
    auto spriteSheetListItemIt{spriteSheetListItemMap.find(spriteSheetID)};
    if (spriteSheetListItemIt == spriteSheetListItemMap.end()) {
        LOG_FATAL("Failed to find a list item for the given sprite sheet.");
    }

    // Update the list item to use the sprite sheet's new display name.
    ParentListItem& spriteSheetListItem{
        static_cast<ParentListItem&>(*(spriteSheetListItemIt->second))};
    spriteSheetListItem.childListItemContainer.headerText.setText(
        newDisplayName);
}

void LibraryWindow::onSpriteDisplayNameChanged(
    SpriteID spriteID, const std::string& newDisplayName)
{
    auto& spriteListItemMap{listItemMaps[LibraryListItem::Type::Sprite]};
    auto spriteListItemIt{spriteListItemMap.find(spriteID)};
    if (spriteListItemIt == spriteListItemMap.end()) {
        LOG_FATAL("Failed to find a list item for the given sprite.");
    }

    // Update the list item to use the sprite's new display name.
    LibraryListItem& spriteListItem{*(spriteListItemIt->second)};
    spriteListItem.text.setText(newDisplayName);
}

void LibraryWindow::onAnimationDisplayNameChanged(AnimationID animationID,
    const std::string& newDisplayName)
{
    auto& animationListItemMap{listItemMaps[LibraryListItem::Type::Animation]};
    auto animationListItemIt{animationListItemMap.find(animationID)};
    if (animationListItemIt == animationListItemMap.end()) {
        LOG_FATAL("Failed to find a list item for the given animation.");
    }

    // Update the list item to use the animation's new display name.
    LibraryListItem& animationListItem{*(animationListItemIt->second)};
    animationListItem.text.setText(newDisplayName);
}

void LibraryWindow::onBoundingBoxDisplayNameChanged(
    BoundingBoxID boundingBoxID, const std::string& newDisplayName)
{
    auto& boundsListItemMap{listItemMaps[LibraryListItem::Type::BoundingBox]};
    auto boundsListItemIt{boundsListItemMap.find(boundingBoxID)};
    if (boundsListItemIt == boundsListItemMap.end()) {
        LOG_FATAL("Failed to find a list item for the given bounding box.");
    }

    // Update the list item to use the bounding box's new display name.
    LibraryListItem& boundsListItem{*(boundsListItemIt->second)};
    boundsListItem.text.setText(newDisplayName);
}

void LibraryWindow::onGraphicSetDisplayNameChanged(
    GraphicSet::Type type, Uint16 graphicSetID, const std::string& newDisplayName)
{
    LibraryListItem::Type graphicSetListItemType{toListItemType(type)};
    auto& graphicSetListItemMap{listItemMaps[graphicSetListItemType]};
    auto graphicSetListItemIt{graphicSetListItemMap.find(graphicSetID)};
    if (graphicSetListItemIt == graphicSetListItemMap.end()) {
        LOG_FATAL("Failed to find a list item for the given graphic set.");
    }

    // Update the list item to use the graphic set's new display name.
    LibraryListItem& graphicSetListItem{*(graphicSetListItemIt->second)};
    graphicSetListItem.text.setText(newDisplayName);
}

void LibraryWindow::onEntityDisplayNameChanged(
    EntityGraphicSetID graphicSetID, const std::string& newDisplayName)
{
    auto& graphicSetListItemMap{listItemMaps[LibraryListItem::Type::Entity]};
    auto graphicSetListItemIt{graphicSetListItemMap.find(graphicSetID)};
    if (graphicSetListItemIt == graphicSetListItemMap.end()) {
        LOG_FATAL("Failed to find a list item for the given graphic set.");
    }

    // Update the list item to use the graphic set's new display name.
    LibraryListItem& graphicSetListItem{*(graphicSetListItemIt->second)};
    graphicSetListItem.text.setText(newDisplayName);
}

void LibraryWindow::onIconDisplayNameChanged(IconID iconID,
                                             const std::string& newDisplayName)
{
    auto& iconListItemMap{listItemMaps[LibraryListItem::Type::Icon]};
    auto iconListItemIt{iconListItemMap.find(iconID)};
    if (iconListItemIt == iconListItemMap.end()) {
        LOG_FATAL("Failed to find a list item for the given icon.");
    }

    // Update the list item to use the icon's new display name.
    LibraryListItem& iconListItem{*(iconListItemIt->second)};
    iconListItem.text.setText(newDisplayName);
}

void LibraryWindow::addIconToSheetListItem(ParentListItem& sheetListItem,
                                           const EditorIconSheet& sheet,
                                           IconID iconID)
{
    // Construct a new list item for this icon.
    const EditorIcon& icon{dataModel.iconModel.getIcon(iconID)};
    auto iconListItem{std::make_unique<LibraryListItem>(icon.displayName)};
    iconListItem->type = LibraryListItem::Type::Icon;
    iconListItem->ID = iconID;
    listItemMaps[LibraryListItem::Type::Icon].emplace(iconID,
                                                      iconListItem.get());

    iconListItem->setLeftPadding(57);

    iconListItem->setOnSelected([this](LibraryListItem* selectedListItem) {
        processSelectedListItem(selectedListItem);
    });
    iconListItem->setOnDeselected([this](LibraryListItem* deselectedListItem) {
        // Note: Deselect is handled in OnSelected and FocusLost.
        selectedItemsChangedSig.publish(selectedListItems);
    });
    iconListItem->setOnActivated(
        [this, iconID](LibraryListItem* activatedListItem) {
            // Set this item's associated icon as the active item.
            dataModel.setActiveIcon(iconID);
        });

    // Add the icon list item to the sheet list item.
    sheetListItem.childListItemContainer.push_back(std::move(iconListItem));
}

void LibraryWindow::processSelectedListItem(LibraryListItem* selectedListItem)
{
    // Find out if the shift or ctrl keys are held.
    const Uint8* keyStates{SDL_GetKeyboardState(nullptr)};
    bool shiftIsHeld{keyStates[SDL_SCANCODE_LSHIFT]
                     || keyStates[SDL_SCANCODE_RSHIFT]};
    bool ctrlIsHeld{keyStates[SDL_SCANCODE_LCTRL]
                    || keyStates[SDL_SCANCODE_RCTRL]};

    // If we're shift or ctrl+clicking and have existing selections, check if 
    // the new selection is the same type.
    if ((shiftIsHeld || ctrlIsHeld) && !(selectedListItems.empty())
        && (selectedListItems[0]->type != selectedListItem->type)) {
        // Not the same type. Ignore this selection.
        selectedListItem->deselect();
        return;
    }

    // If this is a shift+click, select all items between the current selection 
    // and the new one.
    if (shiftIsHeld) {
        // TODO: Implement.
        selectedListItem->deselect();
        return;
    }
    else if (ctrlIsHeld) {
        // If the item is already selected, deselect it.
        auto it{std::ranges::find(selectedListItems, selectedListItem)};
        if (it != selectedListItems.end()) {
            selectedListItems.erase(it);
        }
        else {
            // Not already selected. Add the new selection to the list.
            selectedListItems.push_back(selectedListItem);
        }
    }
    else {
        // Normal click. Deselect all of our selected list items.
        for (LibraryListItem* listItem : selectedListItems) {
            listItem->deselect();
        }
        selectedListItems.clear();

        // Add the new item.
        selectedListItems.push_back(selectedListItem);
    }

    // Signal that the selections were updated.
    selectedItemsChangedSig.publish(selectedListItems);
}

void LibraryWindow::processDeselectedListItem(
    LibraryListItem* deselectedListItem)
{
    // If the item is present in selectedListItems, erase it.
    // Note: If this event originated in onFocusLost(), the list item will 
    //       already be erased.
    auto it{std::ranges::find(selectedListItems, deselectedListItem)};
    if (it != selectedListItems.end()) {
        selectedListItems.erase(it);

        // Signal that the selections were updated.
        selectedItemsChangedSig.publish(selectedListItems);
    }
}

void LibraryWindow::removeListItem(LibraryListItem* listItem)
{
    GraphicSetModel& graphicSetModel{dataModel.graphicSetModel};
    switch (listItem->type) {
        case LibraryListItem::Type::SpriteSheet: {
            dataModel.spriteModel.remSpriteSheet(listItem->ID);
            break;
        }
        case LibraryListItem::Type::Sprite: {
            dataModel.spriteModel.remSprite(listItem->ID);
            break;
        }
        case LibraryListItem::Type::IconSheet: {
            dataModel.iconModel.remIconSheet(listItem->ID);
            break;
        }
        case LibraryListItem::Type::BoundingBox: {
            dataModel.boundingBoxModel.remBoundingBox(
                static_cast<BoundingBoxID>(listItem->ID));
            break;
        }
        case LibraryListItem::Type::Terrain: {
            graphicSetModel.remTerrain(
                static_cast<TerrainGraphicSetID>(listItem->ID));
            break;
        }
        case LibraryListItem::Type::Floor: {
            graphicSetModel.remFloor(
                static_cast<FloorGraphicSetID>(listItem->ID));
            break;
        }
        case LibraryListItem::Type::Wall: {
            graphicSetModel.remWall(static_cast<WallGraphicSetID>(listItem->ID));
            break;
        }
        case LibraryListItem::Type::Object: {
            graphicSetModel.remObject(
                static_cast<ObjectGraphicSetID>(listItem->ID));
            break;
        }
        case LibraryListItem::Type::Entity: {
            dataModel.entityGraphicSetModel.remEntity(
                static_cast<EntityGraphicSetID>(listItem->ID));
            break;
        }
        default: {
            // Note: We purposely don't support deleting animations, since 
            //       they're automatically managed based on sprite filenames.
            LOG_FATAL("Unsupported list item type.");
        }
    }
}

LibraryListItem::Type
    LibraryWindow::toListItemType(GraphicSet::Type graphicSetType)
{
    switch (graphicSetType) {
        case GraphicSet::Type::Terrain: {
            return LibraryListItem::Type::Terrain;
        }
        case GraphicSet::Type::Floor: {
            return LibraryListItem::Type::Floor;
        }
        case GraphicSet::Type::Wall: {
            return LibraryListItem::Type::Wall;
        }
        case GraphicSet::Type::Object: {
            return LibraryListItem::Type::Object;
        }
        default: {
            LOG_FATAL("Invalid graphic set type.");
            break;
        }
    }

    return LibraryListItem::Type::None;
}

LibraryWindow::Category LibraryWindow::toCategory(GraphicSet::Type graphicSetType)
{
    switch (graphicSetType) {
        case GraphicSet::Type::Terrain: {
            return Category::Terrain;
        }
        case GraphicSet::Type::Floor: {
            return Category::Floors;
        }
        case GraphicSet::Type::Wall: {
            return Category::Walls;
        }
        case GraphicSet::Type::Object: {
            return Category::Objects;
        }
        default: {
            LOG_FATAL("Invalid graphic set type.");
            break;
        }
    }

    return LibraryWindow::Category::None;
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/SaveBoundingBoxDialog.cpp`:

```cpp
#include "SaveBoundingBoxDialog.h"
#include "MainScreen.h"
#include "MainThumbnail.h"
#include "DataModel.h"
#include "Paths.h"

namespace AM
{
namespace ResourceImporter
{
SaveBoundingBoxDialog::SaveBoundingBoxDialog(DataModel& inDataModel)
: AUI::Window({0, 0, 1920, 1080}, "SaveBoundingBoxDialog")
, shadowImage({0, 0, logicalExtent.w, logicalExtent.h})
, backgroundImage({719, 208, 523, 506})
, headerText({747, 228, 400, 60})
, nameLabel({747, 300, 151, 38})
, nameInput({919, 300, 180, 38})
, descriptionText({747, 355, 485, 100})
, saveButton({1099, 640, 123, 56}, "Save")
, cancelButton({958, 640, 123, 56}, "Cancel")
, dataModel{inDataModel}
, modelBoundsToSave{}
, saveCallback{}
, errorText({748, 556, 466, 60})
{
    // Add our children so they're included in rendering, etc.
    children.push_back(shadowImage);
    children.push_back(backgroundImage);
    children.push_back(headerText);
    children.push_back(nameLabel);
    children.push_back(nameInput);
    children.push_back(descriptionText);
    children.push_back(saveButton);
    children.push_back(cancelButton);
    children.push_back(errorText);

    /* Background shadow image. */
    shadowImage.setSimpleImage(Paths::TEXTURE_DIR + "Dialogs/Shadow.png");

    /* Background image. */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});

    /* Header text. */
    headerText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 32);
    headerText.setColor({255, 255, 255, 255});
    headerText.setText("Save bounding box");

    /* Name entry. */
    nameLabel.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 21);
    nameLabel.setColor({255, 255, 255, 255});
    nameLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);
    nameLabel.setText("Display Name");

    nameInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    nameInput.setPadding({0, 8, 0, 8});

    /* Description text. */
    descriptionText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    descriptionText.setColor({255, 255, 255, 255});
    descriptionText.setText("Warning: If a bounding box with the given name "
                            "exists, it will be overwritten.");

    /* Confirmation buttons. */
    // Add a callback to save the bounding box.
    saveButton.setOnPressed([this]() {
        // If the user-inputted data is valid.
        const std::string& name{nameInput.getText()};
        if (name != "") {
            // Update the model.
            BoundingBoxID boundingBoxID{
                dataModel.boundingBoxModel.addOrUpdateBoundingBox(
                    name, modelBoundsToSave)};

            // Call the callback.
            if (saveCallback) {
                saveCallback(boundingBoxID);
            }

            // Clear this dialog's text to prepare for the next usage.
            clear();

            // Remove the dialog.
            errorText.setIsVisible(false);
            setIsVisible(false);
        }
        else {
            // Data wasn't valid, display an error string.
            errorText.setText("Name field must not be empty.");
            errorText.setIsVisible(true);
        }
    });

    // Add a callback to remove the dialog on cancel.
    cancelButton.setOnPressed([&]() {
        // Clear the text inputs and labels.
        clear();

        // Remove the dialog.
        setIsVisible(false);
    });

    /* Error text. */
    errorText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 20);
    errorText.setColor({255, 255, 255, 255});
    errorText.setText("Uninitialized.");
    errorText.setIsVisible(false);
}

void SaveBoundingBoxDialog::setSaveData(
    const BoundingBox& inModelBoundsToSave,
    const std::function<void(BoundingBoxID)> inSaveCallback)
{
    modelBoundsToSave = inModelBoundsToSave;
    saveCallback = std::move(inSaveCallback);
}

void SaveBoundingBoxDialog::clear()
{
    nameInput.setText("");
    errorText.setText("");
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/SpriteEditView.cpp`:

```cpp
#include "SpriteEditView.h"
#include "MainScreen.h"
#include "EditorSprite.h"
#include "DataModel.h"
#include "SpriteID.h"
#include "Config.h"
#include "Paths.h"
#include "AUI/ScalingHelpers.h"

namespace AM
{
namespace ResourceImporter
{
SpriteEditView::SpriteEditView(DataModel& inDataModel)
: AUI::Window({320, 58, 1297, 1022}, "SpriteEditView")
, dataModel{inDataModel}
, activeSpriteID{NULL_SPRITE_ID}
, topText{{0, 0, logicalExtent.w, 34}, "TopText"}
, checkerboardImage{{0, 0, 100, 100}, "BackgroundImage"}
, stageGraphic{logicalExtent}
, spriteImage{{0, 0, 100, 100}, "SpriteImage"}
, boundingBoxGizmo{{0, 52, 1297, 732}}
, descText{{24, 806, 1240, 200}, "DescText"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(topText);
    children.push_back(checkerboardImage);
    children.push_back(stageGraphic);
    children.push_back(spriteImage);
    children.push_back(boundingBoxGizmo);
    children.push_back(descText);

    /* Text */
    topText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 26);
    topText.setColor({255, 255, 255, 255});
    topText.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Center);
    topText.setText("Sprite");

    styleText(descText);
    descText.setText(
        "Sprites are the basic building block for graphics in The Amalgam "
        "Engine.\n\nThe bounding box that you set for this sprite will be used "
        "for render sorting, mouse hit detection, and (if enabled) "
        "collision.\n\nSprites must be added to a Sprite Set to be used in the "
        "engine.\n\nSprite Sets come in various types: Terrain, Floor, Wall, "
        "Object, and Entity.");

    /* Images and graphics. */
    checkerboardImage.setTiledImage(Paths::TEXTURE_DIR
                                    + "SpriteEditView/Checkerboard.png");
    checkerboardImage.setIsVisible(false);
    stageGraphic.setIsVisible(false);
    spriteImage.setIsVisible(false);

    /* Bounding box gizmo. */
    boundingBoxGizmo.setIsVisible(false);

    // When the active sprite is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&SpriteEditView::onActiveLibraryItemChanged>(*this);
    dataModel.spriteModel.spriteModelBoundsIDChanged
        .connect<&SpriteEditView::onSpriteModelBoundsIDChanged>(*this);
    dataModel.spriteModel.spriteCustomModelBoundsChanged
        .connect<&SpriteEditView::onSpriteCustomModelBoundsChanged>(*this);
    dataModel.spriteModel.spriteStageOriginChanged
        .connect<&SpriteEditView::onSpriteStageOriginChanged>(*this);
    dataModel.spriteModel.spriteRemoved
        .connect<&SpriteEditView::onSpriteRemoved>(*this);

    // When the gizmo updates the active sprite's bounds, push it to the model.
    boundingBoxGizmo.setOnBoundingBoxUpdated(
        [&](const BoundingBox& updatedBounds) {
            onGizmoBoundingBoxUpdated(updatedBounds);
        });
}

void SpriteEditView::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is a sprite and return early if not.
    const EditorSprite* newActiveSprite{get_if<EditorSprite>(&newActiveItem)};
    if (!newActiveSprite) {
        activeSpriteID = NULL_SPRITE_ID;
        return;
    }

    activeSpriteID = newActiveSprite->numericID;

    // Load the sprite's image.
    std::string fullImagePath{dataModel.getWorkingIndividualSpritesDir()};
    fullImagePath += newActiveSprite->imagePath;
    spriteImage.setSimpleImage(fullImagePath,
                               {0, 0, newActiveSprite->textureExtent.w,
                                newActiveSprite->textureExtent.h},
                               Config::SPRITE_SCALING_QUALITY);

    // Set up the gizmo with the new sprite's size and data.
    // Note: The sprite's native size is used as the logical size.
    boundingBoxGizmo.setSpriteImageSize(newActiveSprite->textureExtent.w,
                                        newActiveSprite->textureExtent.h);
    boundingBoxGizmo.setStageOrigin(newActiveSprite->stageOrigin);
    boundingBoxGizmo.setBoundingBox(
        newActiveSprite->getModelBounds(dataModel.boundingBoxModel));

    // If the sprite is using a shared bounding box, disable the gizmo.
    if (newActiveSprite->modelBoundsID) {
        boundingBoxGizmo.disable();
    }
    else {
        // The sprite is using custom bounds, enable the gizmo.
        boundingBoxGizmo.enable();
    }

    // Use the gizmo's centered sprite extent to set the background and sprite
    // extents.
    SDL_Rect logicalSpriteExtent{
        boundingBoxGizmo.getLogicalCenteredSpriteExtent()};
    logicalSpriteExtent.x += boundingBoxGizmo.getLogicalExtent().x;
    logicalSpriteExtent.y += boundingBoxGizmo.getLogicalExtent().y;
    checkerboardImage.setLogicalExtent(logicalSpriteExtent);
    spriteImage.setLogicalExtent(logicalSpriteExtent);

    // Set up the stage graphic.
    const SDL_Rect& gizmoClippedExtent{boundingBoxGizmo.getClippedExtent()};
    SDL_Rect actualSpriteExtent{AUI::ScalingHelpers::logicalToActual(
        boundingBoxGizmo.getLogicalCenteredSpriteExtent())};
    stageGraphic.updateStage(newActiveSprite->textureExtent,
                             newActiveSprite->stageOrigin,
                             {(gizmoClippedExtent.x + actualSpriteExtent.x),
                              (gizmoClippedExtent.y + actualSpriteExtent.y)});

    // Make sure everything is visible.
    boundingBoxGizmo.setIsVisible(true);
    checkerboardImage.setIsVisible(true);
    stageGraphic.setIsVisible(true);
    spriteImage.setIsVisible(true);
}

void SpriteEditView::onSpriteModelBoundsIDChanged(
    SpriteID spriteID, BoundingBoxID newModelBoundsID)
{
    // If the sprite isn't active, do nothing.
    if (spriteID != activeSpriteID) {
        return;
    }

    // If the sprite is using a shared bounding box, disable the gizmo.
    if (newModelBoundsID) {
        boundingBoxGizmo.disable();
    }
    else {
        // The sprite is using custom bounds, enable the gizmo.
        boundingBoxGizmo.enable();
    }

    // Whether it's enabled or not, the gizmo should show the correct bounds.
    const EditorSprite& sprite{dataModel.spriteModel.getSprite(spriteID)};
    const BoundingBox& newModelBounds{
        sprite.getModelBounds(dataModel.boundingBoxModel)};

    boundingBoxGizmo.setBoundingBox(newModelBounds);
}

void SpriteEditView::onSpriteCustomModelBoundsChanged(
    SpriteID spriteID, const BoundingBox& newCustomModelBounds)
{
    // If the sprite isn't active or isn't set to custom bounds, do nothing.
    const EditorSprite& sprite{dataModel.spriteModel.getSprite(spriteID)};
    if ((spriteID != activeSpriteID) || sprite.modelBoundsID) {
        return;
    }

    // Update the gizmo.
    boundingBoxGizmo.setBoundingBox(newCustomModelBounds);
}

void SpriteEditView::onSpriteStageOriginChanged(SpriteID spriteID,
                                                const SDL_Point& newStageOrigin)
{
    // If the sprite isn't active or isn't set to custom bounds, do nothing.
    const EditorSprite& sprite{dataModel.spriteModel.getSprite(spriteID)};
    if ((spriteID != activeSpriteID) || sprite.modelBoundsID) {
        return;
    }

    // Update up the stage graphic.
    const SDL_Rect& gizmoClippedExtent{boundingBoxGizmo.getClippedExtent()};
    SDL_Rect actualSpriteExtent{AUI::ScalingHelpers::logicalToActual(
        boundingBoxGizmo.getLogicalCenteredSpriteExtent())};
    stageGraphic.updateStage(sprite.textureExtent, sprite.stageOrigin,
                             {(gizmoClippedExtent.x + actualSpriteExtent.x),
                              (gizmoClippedExtent.y + actualSpriteExtent.y)});

    // Update the gizmo.
    boundingBoxGizmo.setStageOrigin(sprite.stageOrigin);
}

void SpriteEditView::onSpriteRemoved(SpriteID spriteID)
{
    // If the active sprite was deleted, hide this window.
    if (spriteID == activeSpriteID) {
        activeSpriteID = NULL_SPRITE_ID;
        setIsVisible(false);
    }
}

void SpriteEditView::onGizmoBoundingBoxUpdated(
    const BoundingBox& updatedBounds)
{
    if (activeSpriteID != NULL_SPRITE_ID) {
        // If the sprite isn't set to use a custom model, do nothing (should
        // never happen since the gizmo should be disabled).
        const EditorSprite& sprite{
            dataModel.spriteModel.getSprite(activeSpriteID)};
        if (sprite.modelBoundsID) {
            return;
        }

        // Update the model with the gizmo's new state.
        dataModel.spriteModel.setSpriteCustomModelBounds(activeSpriteID,
                                                         updatedBounds);
    }
}

void SpriteEditView::styleText(AUI::Text& text)
{
    text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    text.setColor({255, 255, 255, 255});
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/SpritePropertiesWindow.cpp`:

```cpp
#include "SpritePropertiesWindow.h"
#include "MainScreen.h"
#include "DataModel.h"
#include "EditorSprite.h"
#include "SpriteID.h"
#include "Paths.h"
#include "Camera.h"
#include "Transforms.h"
#include "SpriteTools.h"
#include "SharedConfig.h"
#include "AUI/ScalingHelpers.h"
#include <string>
#include <iomanip>
#include <sstream>
#include <iostream>
#include <algorithm>

namespace AM
{
namespace ResourceImporter
{
SpritePropertiesWindow::SpritePropertiesWindow(MainScreen& inScreen,
                                               DataModel& inDataModel,
                                               LibraryWindow& inLibraryWindow)
: AUI::Window({1617, 0, 303, 770}, "SpritePropertiesWindow")
, mainScreen{inScreen}
, nameLabel{{24, 52, 65, 28}, "NameLabel"}
, nameInput{{24, 84, 255, 38}, "NameInput"}
, boundingBoxLabel{{24, 160, 210, 27}, "BoundingBoxLabel"}
, boundingBoxNameLabel{{24, 193, 178, 21}, "BoundingBoxNameLabel"}
, boundingBoxButton{{207, 186, 72, 26}, "Assign", "BoundingBoxButton"}
, minXLabel{{24, 232, 110, 38}, "MinXLabel"}
, minXInput{{150, 226, 129, 38}, "MinXInput"}
, minYLabel{{24, 282, 110, 38}, "MinYLabel"}
, minYInput{{150, 276, 129, 38}, "MinYInput"}
, minZLabel{{24, 332, 110, 38}, "MinZLabel"}
, minZInput{{150, 326, 129, 38}, "MinZInput"}
, maxXLabel{{24, 382, 110, 38}, "MaxXLabel"}
, maxXInput{{150, 376, 129, 38}, "MaxXInput"}
, maxYLabel{{24, 432, 110, 38}, "MaxYLabel"}
, maxYInput{{150, 426, 129, 38}, "MaxYInput"}
, maxZLabel{{24, 482, 110, 38}, "MaxZLabel"}
, maxZInput{{150, 476, 129, 38}, "MaxZInput"}
, collisionEnabledLabel{{24, 526, 210, 27}, "CollisionLabel"}
, collisionEnabledInput{{257, 528, 22, 22}, "CollisionInput"}
, stageOriginXLabel{{24, 597, 110, 38}, "StageOriginXLabel"}
, stageOriginXInput{{150, 591, 129, 38}, "StageOriginXInput"}
, stageOriginYLabel{{24, 647, 110, 38}, "StageOriginYLabel"}
, stageOriginYInput{{150, 641, 129, 38}, "StageOriginYInput"}
, premultiplyAlphaLabel{{24, 717, 210, 27}, "PremultiplyLabel"}
, premultiplyAlphaInput{{257, 719, 22, 22}, "PremultiplyInput"}
, dataModel{inDataModel}
, libraryWindow{inLibraryWindow}
, activeSpriteID{NULL_SPRITE_ID}
, committedMinX{0.0}
, committedMinY{0.0}
, committedMinZ{0.0}
, committedMaxX{0.0}
, committedMaxY{0.0}
, committedMaxZ{0.0}
, committedStageOriginX{0}
, committedStageOriginY{0}
, backgroundImage{{0, 0, logicalExtent.w, logicalExtent.h},
                  "PropertiesBackground"}
, headerImage{{0, 0, logicalExtent.w, 40}, "PropertiesHeader"}
, windowLabel{{12, 0, 282, 40}, "PropertiesWindowLabel"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(backgroundImage);
    children.push_back(headerImage);
    children.push_back(windowLabel);
    children.push_back(nameLabel);
    children.push_back(nameInput);
    children.push_back(boundingBoxLabel);
    children.push_back(boundingBoxNameLabel);
    children.push_back(boundingBoxButton);
    children.push_back(minXLabel);
    children.push_back(minXInput);
    children.push_back(minYLabel);
    children.push_back(minYInput);
    children.push_back(minZLabel);
    children.push_back(minZInput);
    children.push_back(maxXLabel);
    children.push_back(maxXInput);
    children.push_back(maxYLabel);
    children.push_back(maxYInput);
    children.push_back(maxZLabel);
    children.push_back(maxZInput);
    children.push_back(collisionEnabledLabel);
    children.push_back(collisionEnabledInput);
    children.push_back(stageOriginXLabel);
    children.push_back(stageOriginXInput);
    children.push_back(stageOriginYLabel);
    children.push_back(stageOriginYInput);
    children.push_back(premultiplyAlphaLabel);
    children.push_back(premultiplyAlphaInput);

    /* Window setup */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});
    headerImage.setNineSliceImage((Paths::TEXTURE_DIR + "HeaderBackground.png"),
                                  {1, 1, 1, 1});

    auto styleLabel
        = [&](AUI::Text& label, const std::string& text, int fontSize) {
        label.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), fontSize);
        label.setColor({255, 255, 255, 255});
        label.setText(text);
    };
    styleLabel(windowLabel, "Sprite Properties", 21);
    windowLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);

    /* Display name entry. */
    styleLabel(nameLabel, "Name", 21);
    nameLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);

    auto styleTextInput = [&](AUI::TextInput& textInput) {
        textInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
        textInput.setPadding({0, 8, 0, 8});
    };
    styleTextInput(nameInput);
    // Note: Display name is auto-generated from image name and can't be changed.
    nameInput.disable();

    /* Bounding box selection. */
    styleLabel(boundingBoxLabel, "Bounding Box", 21);
    styleLabel(boundingBoxNameLabel, "", 16);

    boundingBoxButton.text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 14);
    boundingBoxButton.setOnPressed([&]() { onBoundingBoxButtonPressed(); });

    // Bounds entry labels.
    styleLabel(minXLabel, "Min X", 21);
    styleLabel(minYLabel, "Min Y", 21);
    styleLabel(minZLabel, "Min Z", 21);
    styleLabel(maxXLabel, "Max X", 21);
    styleLabel(maxYLabel, "Max Y", 21);
    styleLabel(maxZLabel, "Max Z", 21);

    // Bounds entry text inputs.
    styleTextInput(minXInput);
    styleTextInput(minYInput);
    styleTextInput(minZInput);
    styleTextInput(maxXInput);
    styleTextInput(maxYInput);
    styleTextInput(maxZInput);
    minXInput.setOnTextCommitted([this]() { saveMinX(); });
    minYInput.setOnTextCommitted([this]() { saveMinY(); });
    minZInput.setOnTextCommitted([this]() { saveMinZ(); });
    maxXInput.setOnTextCommitted([this]() { saveMaxX(); });
    maxYInput.setOnTextCommitted([this]() { saveMaxY(); });
    maxZInput.setOnTextCommitted([this]() { saveMaxZ(); });

    /* Collision enabled entry. */
    styleLabel(collisionEnabledLabel, "Collision enabled", 21);

    collisionEnabledInput.uncheckedImage.setSimpleImage(
        Paths::TEXTURE_DIR + "Checkbox/Unchecked.png");
    collisionEnabledInput.checkedImage.setSimpleImage(Paths::TEXTURE_DIR
                                                      + "Checkbox/Checked.png");
    collisionEnabledInput.setOnChecked([this]() { saveCollisionEnabled(); });
    collisionEnabledInput.setOnUnchecked([this]() { saveCollisionEnabled(); });

    /* Stage origin entry. */
    styleLabel(stageOriginXLabel, "Stage X", 21);
    styleLabel(stageOriginYLabel, "Stage Y", 21);
    styleTextInput(stageOriginXInput);
    styleTextInput(stageOriginYInput);
    stageOriginXInput.setOnTextCommitted([this]() { saveStageOriginX(); });
    stageOriginYInput.setOnTextCommitted([this]() { saveStageOriginY(); });

    /* Premultiply alpha entry. */
    styleLabel(premultiplyAlphaLabel, "Premultiply alpha", 21);

    premultiplyAlphaInput.uncheckedImage.setSimpleImage(
        Paths::TEXTURE_DIR + "Checkbox/Unchecked.png");
    premultiplyAlphaInput.checkedImage.setSimpleImage(Paths::TEXTURE_DIR
                                                      + "Checkbox/Checked.png");
    premultiplyAlphaInput.setOnChecked([this]() { savePremultiplyAlpha(); });
    premultiplyAlphaInput.setOnUnchecked([this]() { savePremultiplyAlpha(); });

    // When the active sprite is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&SpritePropertiesWindow::onActiveLibraryItemChanged>(*this);
    SpriteModel& spriteModel{dataModel.spriteModel};
    spriteModel.spriteDisplayNameChanged
        .connect<&SpritePropertiesWindow::onSpriteDisplayNameChanged>(*this);
    spriteModel.spriteModelBoundsIDChanged
        .connect<&SpritePropertiesWindow::onSpriteModelBoundsIDChanged>(*this);
    spriteModel.spriteCustomModelBoundsChanged
        .connect<&SpritePropertiesWindow::onSpriteCustomModelBoundsChanged>(*this);
    spriteModel.spriteRemoved.connect<&SpritePropertiesWindow::onSpriteRemoved>(
        *this);
    spriteModel.spriteCollisionEnabledChanged
        .connect<&SpritePropertiesWindow::onSpriteCollisionEnabledChanged>(
            *this);
    spriteModel.spriteStageOriginChanged
        .connect<&SpritePropertiesWindow::onSpriteStageOriginChanged>(*this);
    spriteModel.spritePremultiplyAlphaChanged
        .connect<&SpritePropertiesWindow::onSpritePremultiplyAlphaChanged>(
            *this);

    // When a library item is selected, update the preview button.
    libraryWindow.selectedItemsChanged
        .connect<&SpritePropertiesWindow::onLibrarySelectedItemsChanged>(*this);
}

void SpritePropertiesWindow::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is a sprite and return early if not.
    const EditorSprite* newActiveSprite{get_if<EditorSprite>(&newActiveItem)};
    if (!newActiveSprite) {
        activeSpriteID = NULL_SPRITE_ID;
        return;
    }

    activeSpriteID = newActiveSprite->numericID;

    // Update all of our property fields to match the new active sprite's data.
    nameInput.setText(newActiveSprite->displayName);

    if (newActiveSprite->modelBoundsID) {
        const EditorBoundingBox& boundingBox{
            dataModel.boundingBoxModel.getBoundingBox(
                newActiveSprite->modelBoundsID)};
        boundingBoxNameLabel.setText(boundingBox.displayName);
        boundingBoxButton.text.setText("Custom");
        setBoundsFieldsEnabled(false);
    }
    else {
        boundingBoxNameLabel.setText("<Custom>");
        boundingBoxButton.text.setText("Save as");
        setBoundsFieldsEnabled(true);
    }

    const BoundingBox& spriteModelBounds{
        newActiveSprite->getModelBounds(dataModel.boundingBoxModel)};
    minXInput.setText(toRoundedString(spriteModelBounds.min.x));
    minYInput.setText(toRoundedString(spriteModelBounds.min.y));
    minZInput.setText(toRoundedString(spriteModelBounds.min.z));
    maxXInput.setText(toRoundedString(spriteModelBounds.max.x));
    maxYInput.setText(toRoundedString(spriteModelBounds.max.y));
    maxZInput.setText(toRoundedString(spriteModelBounds.max.z));
    stageOriginXInput.setText(std::to_string(newActiveSprite->stageOrigin.x));
    stageOriginYInput.setText(std::to_string(newActiveSprite->stageOrigin.y));

    if (newActiveSprite->collisionEnabled) {
        collisionEnabledInput.setCurrentState(AUI::Checkbox::State::Checked);
    }
    else {
        collisionEnabledInput.setCurrentState(AUI::Checkbox::State::Unchecked);
    }

    if (newActiveSprite->premultiplyAlpha) {
        premultiplyAlphaInput.setCurrentState(AUI::Checkbox::State::Checked);
    }
    else {
        premultiplyAlphaInput.setCurrentState(AUI::Checkbox::State::Unchecked);
    }
}

void SpritePropertiesWindow::onSpriteRemoved(SpriteID spriteID)
{
    // If the active sprite was deleted, hide this window.
    if (spriteID == activeSpriteID) {
        activeSpriteID = NULL_SPRITE_ID;
        setIsVisible(false);
    }
}

void SpritePropertiesWindow::onSpriteDisplayNameChanged(
    SpriteID spriteID, const std::string& newDisplayName)
{
    if (spriteID == activeSpriteID) {
        nameInput.setText(newDisplayName);
    }
}

void SpritePropertiesWindow::onSpriteModelBoundsIDChanged(
    SpriteID spriteID, BoundingBoxID newModelBoundsID)
{
    // If the sprite isn't active, do nothing.
    if (spriteID != activeSpriteID) {
        return;
    }

    // Whether they're enabled or not, the fields should show the correct bounds.
    const EditorSprite& sprite{dataModel.spriteModel.getSprite(spriteID)};

    if (newModelBoundsID) {
        const EditorBoundingBox& boundingBox{
            dataModel.boundingBoxModel.getBoundingBox(newModelBoundsID)};
        boundingBoxNameLabel.setText(boundingBox.displayName);
        boundingBoxButton.text.setText("Custom");
        setBoundsFieldsEnabled(false);
    }
    else {
        boundingBoxNameLabel.setText("<Custom>");
        boundingBoxButton.text.setText("Save as");
        setBoundsFieldsEnabled(true);
    }

    const BoundingBox& newModelBounds{
        sprite.getModelBounds(dataModel.boundingBoxModel)};
    minXInput.setText(toRoundedString(newModelBounds.min.x));
    minYInput.setText(toRoundedString(newModelBounds.min.y));
    minZInput.setText(toRoundedString(newModelBounds.min.z));
    maxXInput.setText(toRoundedString(newModelBounds.max.x));
    maxYInput.setText(toRoundedString(newModelBounds.max.y));
    maxZInput.setText(toRoundedString(newModelBounds.max.z));
}

void SpritePropertiesWindow::onSpriteCustomModelBoundsChanged(
    SpriteID spriteID, const BoundingBox& newCustomModelBounds)
{
    if (spriteID == activeSpriteID) {
        const BoundingBox& newModelBounds{newCustomModelBounds};
        minXInput.setText(toRoundedString(newModelBounds.min.x));
        minYInput.setText(toRoundedString(newModelBounds.min.y));
        minZInput.setText(toRoundedString(newModelBounds.min.z));
        maxXInput.setText(toRoundedString(newModelBounds.max.x));
        maxYInput.setText(toRoundedString(newModelBounds.max.y));
        maxZInput.setText(toRoundedString(newModelBounds.max.z));
    }
}

void SpritePropertiesWindow::onSpriteCollisionEnabledChanged(
    SpriteID spriteID, bool newCollisionEnabled)
{
    if (spriteID == activeSpriteID) {
        if (newCollisionEnabled) {
            collisionEnabledInput.setCurrentState(
                AUI::Checkbox::State::Checked);
        }
        else {
            collisionEnabledInput.setCurrentState(
                AUI::Checkbox::State::Unchecked);
        }
    }
}

void SpritePropertiesWindow::onSpriteStageOriginChanged(
    SpriteID spriteID, const SDL_Point& newStageOrigin)
{
    if (spriteID == activeSpriteID) {
        stageOriginXInput.setText(std::to_string(newStageOrigin.x));
        stageOriginYInput.setText(std::to_string(newStageOrigin.y));
    }
}

void SpritePropertiesWindow::onSpritePremultiplyAlphaChanged(
    SpriteID spriteID, bool newPremultiplyAlpha)
{
    if (spriteID == activeSpriteID) {
        if (newPremultiplyAlpha) {
            premultiplyAlphaInput.setCurrentState(
                AUI::Checkbox::State::Checked);
        }
        else {
            premultiplyAlphaInput.setCurrentState(
                AUI::Checkbox::State::Unchecked);
        }
    }
}

void SpritePropertiesWindow::onLibrarySelectedItemsChanged(
    const std::vector<LibraryListItem*>& selectedItems)
{
    // If there's no active sprite, do nothing.
    if (!activeSpriteID) {
        return;
    }

    // If a new bounding box is selected, allow the user to assign it.
    if ((selectedItems.size() > 0)
        && (selectedItems[0]->type == LibraryListItem::Type::BoundingBox)
        && (selectedItems[0]->text.asString()
            != boundingBoxNameLabel.asString())) {
        boundingBoxButton.text.setText("Assign");
    }
    // If we have a shared bounding box assigned, allow the user to switch 
    // to a custom bounding box.
    else if (dataModel.spriteModel.getSprite(activeSpriteID).modelBoundsID
             != NULL_BOUNDING_BOX_ID) {
        boundingBoxButton.text.setText("Custom");
    }
    else {
        // Custom bounding box and no selection. Allow the user to save it.
        boundingBoxButton.text.setText("Save as");
    }
}

void SpritePropertiesWindow::setBoundsFieldsEnabled(bool isEnabled)
{
    if (isEnabled) {
        minXInput.enable();
        minYInput.enable();
        minZInput.enable();
        maxXInput.enable();
        maxYInput.enable();
        maxZInput.enable();
    }
    else {
        minXInput.disable();
        minYInput.disable();
        minZInput.disable();
        maxXInput.disable();
        maxYInput.disable();
        maxZInput.disable();
    }
}

std::string SpritePropertiesWindow::toRoundedString(float value)
{
    std::stringstream stream;
    stream << std::fixed << std::setprecision(3) << value;
    return stream.str();
}

void SpritePropertiesWindow::onBoundingBoxButtonPressed()
{
    SpriteModel& spriteModel{dataModel.spriteModel};

    const std::string buttonText{boundingBoxButton.text.asString()};
    if (buttonText == "Assign") {
        // If a bounding box is selected, assign it to the active animation.
        // Note: This just uses the first selected graphic. Multi-select is 
        //       ignored.
        const auto& selectedListItems{libraryWindow.getSelectedListItems()};
        bool boundingBoxIsSelected{false};
        for (const LibraryListItem* selectedItem : selectedListItems) {
            if (selectedItem->type == LibraryListItem::Type::BoundingBox) {
                boundingBoxIsSelected = true;
                spriteModel.setSpriteModelBoundsID(
                    activeSpriteID, static_cast<BoundingBoxID>(selectedItem->ID));

                break;
            }
        }
    }
    else if (buttonText == "Custom") {
        // If the sprite isn't already using a custom bounding box, set it.
        if (spriteModel.getSprite(activeSpriteID).modelBoundsID
            != NULL_BOUNDING_BOX_ID) {
            spriteModel.setSpriteModelBoundsID(activeSpriteID,
                                               NULL_BOUNDING_BOX_ID);
        }
    }
    else if (buttonText == "Save as") {
        // If the sprite is using a custom bounding box, open the "Save as" 
        // menu.
        const EditorSprite& sprite{spriteModel.getSprite(activeSpriteID)};
        if (sprite.modelBoundsID == NULL_BOUNDING_BOX_ID) {
            mainScreen.openSaveBoundingBoxDialog(
                sprite.customModelBounds, [&](BoundingBoxID newModelBoundsID) {
                    // The save was completed, set the shared bounding box as
                    // this sprite's model bounds.
                    dataModel.spriteModel.setSpriteModelBoundsID(
                        activeSpriteID, newModelBoundsID);
                });
        }
    }
}

void SpritePropertiesWindow::saveMinX()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newMinX{std::stof(minXInput.getText())};

        // Clamp the value to its bounds.
        const EditorSprite& activeSprite{
            dataModel.spriteModel.getSprite(activeSpriteID)};
        BoundingBox newModelBounds{
            activeSprite.getModelBounds(dataModel.boundingBoxModel)};
        newModelBounds.min.x = std::clamp(newMinX, 0.f, newModelBounds.max.x);

        // Apply the new value.
        dataModel.spriteModel.setSpriteCustomModelBounds(activeSpriteID,
                                                         newModelBounds);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        minXInput.setText(std::to_string(committedMinX));
    }
}

void SpritePropertiesWindow::saveMinY()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newMinY{std::stof(minYInput.getText())};

        // Clamp the value to its bounds.
        const EditorSprite& activeSprite{
            dataModel.spriteModel.getSprite(activeSpriteID)};
        BoundingBox newModelBounds{
            activeSprite.getModelBounds(dataModel.boundingBoxModel)};
        newModelBounds.min.y = std::clamp(newMinY, 0.f, newModelBounds.max.y);

        // Apply the new value.
        dataModel.spriteModel.setSpriteCustomModelBounds(activeSpriteID,
                                                         newModelBounds);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        minXInput.setText(std::to_string(committedMinY));
    }
}

void SpritePropertiesWindow::saveMinZ()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newMinZ{std::stof(minZInput.getText())};

        // Clamp the value to its bounds.
        const EditorSprite& activeSprite{
            dataModel.spriteModel.getSprite(activeSpriteID)};
        BoundingBox newModelBounds{
            activeSprite.getModelBounds(dataModel.boundingBoxModel)};
        newModelBounds.min.z = std::clamp(newMinZ, 0.f, newModelBounds.max.z);

        // Apply the new value.
        dataModel.spriteModel.setSpriteCustomModelBounds(activeSpriteID,
                                                         newModelBounds);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        minXInput.setText(std::to_string(committedMinZ));
    }
}

void SpritePropertiesWindow::saveMaxX()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newMaxX{std::stof(maxXInput.getText())};

        // Clamp the value to its bounds.
        const EditorSprite& activeSprite{
            dataModel.spriteModel.getSprite(activeSpriteID)};
        BoundingBox newModelBounds{
            activeSprite.getModelBounds(dataModel.boundingBoxModel)};
        BoundingBox stageWorldExtent{SpriteTools::calcSpriteStageWorldExtent(
            activeSprite.textureExtent, activeSprite.stageOrigin)};
        newModelBounds.max.x
            = std::clamp(newMaxX, newModelBounds.min.x, stageWorldExtent.max.x);

        // Apply the new value.
        dataModel.spriteModel.setSpriteCustomModelBounds(activeSpriteID,
                                                         newModelBounds);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        maxXInput.setText(std::to_string(committedMaxX));
    }
}

void SpritePropertiesWindow::saveMaxY()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newMaxY{std::stof(maxYInput.getText())};

        // Clamp the value to its bounds.
        const EditorSprite& activeSprite{
            dataModel.spriteModel.getSprite(activeSpriteID)};
        BoundingBox newModelBounds{
            activeSprite.getModelBounds(dataModel.boundingBoxModel)};
        BoundingBox stageWorldExtent{SpriteTools::calcSpriteStageWorldExtent(
            activeSprite.textureExtent, activeSprite.stageOrigin)};
        newModelBounds.max.y
            = std::clamp(newMaxY, newModelBounds.min.y, stageWorldExtent.max.y);

        // Apply the new value.
        dataModel.spriteModel.setSpriteCustomModelBounds(activeSpriteID,
                                                         newModelBounds);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        maxYInput.setText(std::to_string(committedMaxY));
    }
}

void SpritePropertiesWindow::saveMaxZ()
{
    // Validate the user input as a valid float.
    try {
        // Convert the input string to a float.
        float newMaxZ{std::stof(maxZInput.getText())};

        // Clamp the value to its bounds.
        const EditorSprite& activeSprite{
            dataModel.spriteModel.getSprite(activeSpriteID)};
        BoundingBox newModelBounds{
            activeSprite.getModelBounds(dataModel.boundingBoxModel)};
        BoundingBox stageWorldExtent{SpriteTools::calcSpriteStageWorldExtent(
            activeSprite.textureExtent, activeSprite.stageOrigin)};
        newModelBounds.max.z
            = std::clamp(newMaxZ, newModelBounds.min.z, stageWorldExtent.max.z);

        // Apply the new value.
        dataModel.spriteModel.setSpriteCustomModelBounds(activeSpriteID,
                                                         newModelBounds);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        maxYInput.setText(std::to_string(committedMaxY));
    }
}

void SpritePropertiesWindow::saveCollisionEnabled()
{
    bool collisionEnabled{(collisionEnabledInput.getCurrentState()
                           == AUI::Checkbox::State::Checked)};
    dataModel.spriteModel.setSpriteCollisionEnabled(activeSpriteID,
                                                    collisionEnabled);
}

void SpritePropertiesWindow::saveStageOriginX()
{
    // Validate the user input as a valid int.
    try {
        // Convert the input string to an int.
        int newStageOriginX{std::stoi(stageOriginXInput.getText())};

        // Clamp the value to its bounds.
        const EditorSprite& activeSprite{
            dataModel.spriteModel.getSprite(activeSpriteID)};
        SDL_Point newStageOrigin{activeSprite.stageOrigin};
        newStageOrigin.x
            = std::clamp(newStageOriginX, 0, activeSprite.textureExtent.w);

        // Apply the new value.
        dataModel.spriteModel.setSpriteStageOrigin(activeSpriteID,
                                                   newStageOrigin);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        stageOriginXInput.setText(std::to_string(committedStageOriginX));
    }
}

void SpritePropertiesWindow::saveStageOriginY()
{
    // Validate the user input as a valid int.
    try {
        // Convert the input string to an int.
        int newStageOriginY{std::stoi(stageOriginYInput.getText())};

        // Clamp the value to its bounds.
        const EditorSprite& activeSprite{
            dataModel.spriteModel.getSprite(activeSpriteID)};
        SDL_Point newStageOrigin{activeSprite.stageOrigin};
        newStageOrigin.y
            = std::clamp(newStageOriginY, 0, activeSprite.textureExtent.h);

        // Apply the new value.
        dataModel.spriteModel.setSpriteStageOrigin(activeSpriteID,
                                                   newStageOrigin);
    } catch (std::exception&) {
        // Input was not valid, reset the field to what it was.
        stageOriginYInput.setText(std::to_string(committedStageOriginY));
    }
}

void SpritePropertiesWindow::savePremultiplyAlpha()
{
    bool premultiplyAlpha{(premultiplyAlphaInput.getCurrentState()
                           == AUI::Checkbox::State::Checked)};
    dataModel.spriteModel.setSpritePremultiplyAlpha(activeSpriteID,
                                                    premultiplyAlpha);
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/SpriteSheetEditView.cpp`:

```cpp
#include "SpriteSheetEditView.h"
#include "MainScreen.h"
#include "EditorSpriteSheet.h"
#include "DataModel.h"
#include "SpriteTools.h"
#include "Paths.h"
#include "AUI/ScalingHelpers.h"
#include "AUI/Core.h"
#include <SDL_image.h>
#include <algorithm>

namespace AM
{
namespace ResourceImporter
{
SpriteSheetEditView::SpriteSheetEditView(DataModel& inDataModel)
: AUI::Window({320, 58, 1297, 1022}, "SpriteSheetEditView")
, dataModel{inDataModel}
, activeSpriteSheetID{NULL_SPRITE_SHEET_ID}
, MAX_SPRITESHEET_IMAGE_EXTENT{328, 52, 644, 732}
, topText{{0, 0, logicalExtent.w, 34}, "TopText"}
, checkerboardImage{{0, 0, 100, 100}, "BackgroundImage"}
, spriteSheetImage{MAX_SPRITESHEET_IMAGE_EXTENT, "SpriteSheetScrollArea"}
, descText{{24, 806, 1240, 200}, "DescText"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(topText);
    children.push_back(checkerboardImage);
    children.push_back(spriteSheetImage);
    children.push_back(descText);

    /* Images. */
    checkerboardImage.setTiledImage(Paths::TEXTURE_DIR
                                    + "SpriteEditView/Checkerboard.png");
    checkerboardImage.setIsVisible(false);
    spriteSheetImage.setIsVisible(false);

    /* Text */
    topText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 26);
    topText.setColor({255, 255, 255, 255});
    topText.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Center);
    topText.setText("Sprite Sheet");

    styleText(descText);
    descText.setText(
        "Sprite sheets are the starting point for importing graphics into the "
        "engine. Create a sheet, then add images to auto-generate Sprite and "
        "Animation objects.\nTo edit sprites, re-add your new image using the "
        "same file name.\nTo delete sprites, delete the associated Sprite in "
        "the Library.\n\nSprite objects will be auto-generated for each image "
        "added to the sheet. If the image's file name ends in \"_<number>\", "
        "e.g. \"Run_0.png\", an Animation object will also be generated. "
        "Successive numbers will add more images to the same animation.\nAll "
        "images in a given animation must be the same size.");

    // When the active sprite sheet is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&SpriteSheetEditView::onActiveLibraryItemChanged>(*this);
    dataModel.spriteModel.sheetRemoved
        .connect<&SpriteSheetEditView::onSheetRemoved>(*this);
    dataModel.spriteModel.spriteAdded
        .connect<&SpriteSheetEditView::onSpriteAdded>(*this);
    dataModel.spriteModel.spriteRemoved
        .connect<&SpriteSheetEditView::onSpriteRemoved>(*this);
}

void SpriteSheetEditView::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is a sprite sheet and return early if not.
    const EditorSpriteSheet* newActiveSpriteSheet{
        get_if<EditorSpriteSheet>(&newActiveItem)};
    if (!newActiveSpriteSheet) {
        activeSpriteSheetID = NULL_SPRITE_SHEET_ID;
        return;
    }

    activeSpriteSheetID = newActiveSpriteSheet->numericID;

    // Refresh the generated sprite sheet image.
    refreshSpriteSheetImage(*newActiveSpriteSheet);
}

void SpriteSheetEditView::onSheetRemoved(SpriteSheetID parentSheetID)
{
    // If the active sheet was deleted, hide this window.
    if (parentSheetID == activeSpriteSheetID) {
        activeSpriteSheetID = NULL_SPRITE_SHEET_ID;
        setIsVisible(false);
    }
}

void SpriteSheetEditView::onSpriteAdded(SpriteID spriteID, const EditorSprite&,
                                        SpriteSheetID parentSheetID)
{
    // If the added sprite is in the active sheet, refresh the image.
    if (parentSheetID == activeSpriteSheetID) {
        const EditorSpriteSheet& spriteSheet{
            dataModel.spriteModel.getSpriteSheet(activeSpriteSheetID)};
        refreshSpriteSheetImage(spriteSheet);
    }
}

void SpriteSheetEditView::onSpriteRemoved(SpriteID spriteID,
                                          SpriteSheetID parentSheetID)
{
    // If the removed sprite is in the active sheet, refresh the image.
    if (parentSheetID == activeSpriteSheetID) {
        const EditorSpriteSheet& spriteSheet{
            dataModel.spriteModel.getSpriteSheet(activeSpriteSheetID)};
        refreshSpriteSheetImage(spriteSheet);
    }
}

void SpriteSheetEditView::styleText(AUI::Text& text)
{
    text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
    text.setColor({255, 255, 255, 255});
}

void SpriteSheetEditView::refreshSpriteSheetImage(
    const EditorSpriteSheet& spriteSheet)
{
    // If there aren't any sprites in the sheet, hide the image and do nothing.
    if ((spriteSheet.textureWidth == 0) || (spriteSheet.textureHeight == 0)) {
        checkerboardImage.setIsVisible(false);
        spriteSheetImage.setIsVisible(false);
        return;
    }

    // Generate the sheet's texture and load it into the Image widget.
    SDL_Texture* spriteSheetTexture{
        SpriteTools::generateSpriteSheetTexture(dataModel, spriteSheet)};
    spriteSheetImage.setSimpleImage(spriteSheetTexture, "GenSpriteSheet");

    // Calc a scaled texture extent that fits inside the max image bounds 
    // without changing the texture's aspect ratio.
    SDL_Rect imageExtent{MAX_SPRITESHEET_IMAGE_EXTENT.x,
                         MAX_SPRITESHEET_IMAGE_EXTENT.y};
    int widthDiff{spriteSheet.textureWidth - MAX_SPRITESHEET_IMAGE_EXTENT.w};
    int heightDiff{spriteSheet.textureHeight - MAX_SPRITESHEET_IMAGE_EXTENT.h};
    if ((widthDiff > 0) || (heightDiff > 0)) {
        // Texture is larger than max extent in at least one direction. Scale 
        // down to fit.
        float scaleToFit{};
        if (widthDiff > heightDiff) {
            scaleToFit
                = 1
                  - (widthDiff / static_cast<float>(spriteSheet.textureWidth));
        }
        else {
            scaleToFit = 1
                         - (heightDiff
                            / static_cast<float>(spriteSheet.textureHeight));
        }

        imageExtent.w = static_cast<int>(spriteSheet.textureWidth * scaleToFit);
        imageExtent.h
            = static_cast<int>(spriteSheet.textureHeight * scaleToFit);
    }
    else {
        // Texture is smaller than max extent in both directions. No need to 
        // scale.
        imageExtent.w = spriteSheet.textureWidth;
        imageExtent.h = spriteSheet.textureHeight;
    }

    spriteSheetImage.setLogicalExtent(imageExtent);

    // Set the background's extent to match the image.
    checkerboardImage.setLogicalExtent(spriteSheetImage.getLogicalExtent());

    // Make sure everything is visible.
    checkerboardImage.setIsVisible(true);
    spriteSheetImage.setIsVisible(true);
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/SpriteSheetPropertiesWindow.cpp`:

```cpp
#include "SpriteSheetPropertiesWindow.h"
#include "MainScreen.h"
#include "DataModel.h"
#include "EditorSpriteSheet.h"
#include "StringTools.h"
#include "Paths.h"
#include "SharedConfig.h"
#include "nfd.hpp"

namespace AM
{
namespace ResourceImporter
{
SpriteSheetPropertiesWindow::SpriteSheetPropertiesWindow(MainScreen& inScreen,
                                                         DataModel& inDataModel)
: AUI::Window({1617, 0, 303, 579}, "SpriteSheetPropertiesWindow")
, nameLabel{{24, 52, 65, 28}, "NameLabel"}
, nameInput{{24, 84, 255, 38}, "NameInput"}
, addImagesButton{{24, 134, 255, 34}, "Add Images", "AddImagesButton"}
, mainScreen{inScreen}
, dataModel{inDataModel}
, activeSpriteSheetID{NULL_SPRITE_SHEET_ID}
, backgroundImage{{0, 0, 303, 579}, "PropertiesBackground"}
, headerImage{{0, 0, 303, 40}, "PropertiesHeader"}
, windowLabel{{12, 0, 282, 40}, "PropertiesWindowLabel"}
{
    // Add our children so they're included in rendering, etc.
    children.push_back(backgroundImage);
    children.push_back(headerImage);
    children.push_back(windowLabel);
    children.push_back(nameLabel);
    children.push_back(nameInput);
    children.push_back(addImagesButton);

    /* Window setup */
    backgroundImage.setNineSliceImage(
        (Paths::TEXTURE_DIR + "WindowBackground.png"), {1, 1, 1, 1});
    headerImage.setNineSliceImage((Paths::TEXTURE_DIR + "HeaderBackground.png"),
                                  {1, 1, 1, 1});

    auto styleLabel
        = [&](AUI::Text& label, const std::string& text, int fontSize) {
        label.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), fontSize);
        label.setColor({255, 255, 255, 255});
        label.setText(text);
    };
    styleLabel(windowLabel, "Sprite Sheet Properties", 21);
    windowLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);

    /* Display name entry. */
    styleLabel(nameLabel, "Name", 21);
    nameLabel.setVerticalAlignment(AUI::Text::VerticalAlignment::Center);

    auto styleTextInput = [&](AUI::TextInput& textInput) {
        textInput.setTextFont((Paths::FONT_DIR + "B612-Regular.ttf"), 18);
        textInput.setPadding({0, 8, 0, 8});
    };
    styleTextInput(nameInput);
    nameInput.setOnTextCommitted([this]() {
        dataModel.spriteModel.setSpriteSheetDisplayName(activeSpriteSheetID,
                                                        nameInput.getText());
    });

    /* Image adding. */
    addImagesButton.text.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 16);
    addImagesButton.setOnPressed([&]() { onAddImagesButtonPressed(); });

    // When the active sprite sheet is updated, update it in this widget.
    dataModel.activeLibraryItemChanged
        .connect<&SpriteSheetPropertiesWindow::onActiveLibraryItemChanged>(
            *this);
    dataModel.spriteModel.sheetRemoved
        .connect<&SpriteSheetPropertiesWindow::onSheetRemoved>(*this);
}

void SpriteSheetPropertiesWindow::onActiveLibraryItemChanged(
    const LibraryItemData& newActiveItem)
{
    // Check if the new active item is a sprite sheet and return early if not.
    const EditorSpriteSheet* newActiveSpriteSheet{
        get_if<EditorSpriteSheet>(&newActiveItem)};
    if (!newActiveSpriteSheet) {
        activeSpriteSheetID = NULL_SPRITE_SHEET_ID;
        return;
    }

    activeSpriteSheetID = newActiveSpriteSheet->numericID;

    // Update all of our property fields to match the new active sheet's data.
    nameInput.setText(newActiveSpriteSheet->displayName);
}

void SpriteSheetPropertiesWindow::onSheetRemoved(SpriteSheetID parentSheetID)
{
    // If the active sheet was deleted, hide this window.
    if (parentSheetID == activeSpriteSheetID) {
        activeSpriteSheetID = NULL_SPRITE_SHEET_ID;
        setIsVisible(false);
    }
}

void SpriteSheetPropertiesWindow::onAddImagesButtonPressed()
{
    // Open the file select dialog and save the selected paths.
    // Note: This will block the main thread, but that's fine. Our 
    //       PeriodicUpdaters in Application are set up to skip late steps.
    NFD::UniquePathSet selectedPaths{};
    nfdfilteritem_t filterItem[1] = {{"Supported Image Types", "png, jpg"}};
    nfdresult_t result = NFD::OpenDialogMultiple(selectedPaths, filterItem, 1);

    if (result == NFD_OKAY) {
        nfdpathsetsize_t numPaths;
        NFD::PathSet::Count(selectedPaths, numPaths);

        // Check that all of the paths start with the working IndividualSprites
        // directory and pack them into a vector.
        std::vector<std::string> paths(numPaths);
        std::size_t spritesDirSize{
            dataModel.getWorkingIndividualSpritesDir().size()};
        for (nfdpathsetsize_t i{0}; i < numPaths; ++i) {
            NFD::UniquePathSetPath path{};
            NFD::PathSet::GetPath(selectedPaths, i, path);

            if (!(StringTools::pathStartsWith(
                    path.get(), dataModel.getWorkingIndividualSpritesDir()))) {
                std::string errorString{
                    "Failed to add images: Sprite images must be placed in the "
                    "IndividualSprites directory."};
                mainScreen.openErrorDialog(errorString);
                return;
            }

            // Trim the full path down to a path relative to the working 
            // IndividualSprites directory.
            paths.at(i) = path.get();
            paths.at(i) = paths.at(i).substr(spritesDirSize);
        }

        // Open the add menu to finish the process.
        mainScreen.openAddSpriteDialog(paths);
    }
    else if (result != NFD_CANCEL) {
        // The dialog operation didn't succeed and the user didn't simply press
        // cancel. Print the error.
        LOG_INFO("Error: %s", NFD::GetError());
    }
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Private/Windows/TitleWindow.cpp`:

```cpp
#include "TitleWindow.h"
#include "UserInterface.h"
#include "TitleScreen.h"
#include "DataModel.h"
#include "Paths.h"
#include "Log.h"
#include "nfd.hpp"
#include <cstring>

namespace AM
{
namespace ResourceImporter
{
TitleWindow::TitleWindow(UserInterface& inUserInterface, DataModel& inDataModel)
: AUI::Window({0, 0, 1920, 1080}, "TitleWindow")
, userInterface{inUserInterface}
, dataModel{inDataModel}
, titleText({0, 193, 1920, 75}, "TitleText")
, directionText({0, 482, 1920, 300}, "DirectionText")
, openButton({724, 548, 472, 96}, "Open", "OpenButton")
, errorText({20, 721, 1880, 300}, "ErrorText")
{
    // Add our children so they're included in rendering, etc.
    children.push_back(titleText);
    children.push_back(directionText);
    children.push_back(openButton);
    children.push_back(errorText);

    /* Title text. */
    titleText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 54);
    titleText.setColor({255, 255, 255, 255});
    titleText.setText("Amalgam Engine Resource Importer");
    titleText.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Center);

    /* Other text. */
    directionText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 28);
    directionText.setColor({255, 255, 255, 255});
    directionText.setText("Please locate your project's Resources directory:");
    directionText.setHorizontalAlignment(
        AUI::Text::HorizontalAlignment::Center);

    errorText.setFont((Paths::FONT_DIR + "B612-Regular.ttf"), 28);
    errorText.setColor({255, 255, 255, 255});
    errorText.setText("Uninitialized.");
    errorText.setHorizontalAlignment(AUI::Text::HorizontalAlignment::Center);
    errorText.setIsVisible(false);

    // Register our event handlers.
    openButton.setOnPressed(std::bind(&TitleWindow::onOpenButtonPressed, this));
}

void TitleWindow::onOpenButtonPressed()
{
    // New attempt, make sure the error text is hidden.
    errorText.setIsVisible(false);

    // Open the file select dialog and save the selected path.
    // Note: This will block the main thread, but that's fine. Our 
    //       PeriodicUpdaters in Application are set up to skip late steps.
    nfdchar_t* selectedPath{nullptr};
    nfdresult_t result = NFD::PickFolder(selectedPath);

    if (result == NFD_OKAY) {
        // Try to open the project.
        if (dataModel.open(selectedPath)) {
            userInterface.changeScreenTo(UserInterface::ScreenType::MainScreen);
        }
        else {
            // Failed to open project, display the error text.
            errorText.setText("Error: " + dataModel.getErrorString());
            errorText.setIsVisible(true);
        }

        NFD::FreePath(selectedPath);
    }
    else if (result != NFD_CANCEL) {
        // The dialog operation didn't succeed and the user didn't simply press
        // cancel. Print the error.
        LOG_INFO("Error: %s", NFD_GetError());
    }
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/MainScreen.h`:

```h
#pragma once

#include "AUI/Screen.h"
#include "AUI/Button.h"
#include "AUI/ConfirmationDialog.h"
#include "LibraryItemData.h"
#include "LibraryWindow.h"
#include "SpriteSheetEditView.h"
#include "SpriteSheetPropertiesWindow.h"
#include "BoundingBoxEditView.h"
#include "BoundingBoxPropertiesWindow.h"
#include "SpriteEditView.h"
#include "SpritePropertiesWindow.h"
#include "AnimationElementsWindow.h"
#include "AnimationEditView.h"
#include "AnimationPropertiesWindow.h"
#include "GraphicSetEditView.h"
#include "GraphicSetPropertiesWindow.h"
#include "EntityGraphicSetEditView.h"
#include "EntityGraphicSetPropertiesWindow.h"
#include "IconEditView.h"
#include "IconPropertiesWindow.h"
#include "TitleButton.h"
#include "LibraryAddMenu.h"
#include "HamburgerButtonWindow.h"
#include "HamburgerMenu.h"
#include "AddIconSheetDialog.h"
#include "AddSpriteDialog.h"
#include "SaveBoundingBoxDialog.h"

namespace AM
{
namespace ResourceImporter
{
class DataModel;

/**
 * The main screen for doing work.
 */
class MainScreen : public AUI::Screen
{
public:
    MainScreen(DataModel& inDataModel);

    /**
     * Opens a confirmation dialog with a "Confirm" button and a "Cancel" 
     * button.
     *
     * @param bodyText The main dialog text.
     * @param confirmButtonText The text on the confirm button.
     * @param onConfirmation Called when the user presses the confirm button.
     */
    void openConfirmationDialog(const std::string& bodyText,
                                const std::string& confirmButtonText,
                                std::function<void(void)> onConfirmation);

    /**
     * Opens an error dialog with a "Cancel" button.
     *
     * @param bodyText The main dialog text.
     */
    void openErrorDialog(const std::string& bodyText);

    /**
     * Opens the dialog for saving a BoundingBox to the Library.
     */
    void openSaveBoundingBoxDialog(
        const BoundingBox& modelBoundsToSave,
        std::function<void(BoundingBoxID)> saveCallback);

    /**
     * Opens the Library's "add list item" menu.
     */
    void openLibraryAddMenu();

    /**
     * Opens the hamburger menu.
     */
    void openHamburgerMenu();

    /**
     * Opens the "add sprite" dialog.
     *
     * @param spriteImageRelPaths The sprite images to add.
     */
    void openAddSpriteDialog(
        const std::vector<std::string>& spriteImageRelPaths);

    void render() override;

private:
    /**
     * Makes the appropriate windows visible based on the new item's type.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /** Used by this screen's UI. */
    DataModel& dataModel;

    /** The confirmationDialog user's callback. Set while opening the dialog. */
    std::function<void(void)> userOnConfirmation;

    //-------------------------------------------------------------------------
    // Windows
    //-------------------------------------------------------------------------
    /** The left-side window for managing sprite sheets, sprites, etc. */
    LibraryWindow libraryWindow;

    // Edit views
    /** The center stage for editing the active item. */
    SpriteSheetEditView spriteSheetEditView;
    BoundingBoxEditView boundingBoxEditView;
    SpriteEditView spriteEditView;
    AnimationElementsWindow animationElementsWindow;
    AnimationEditView animationEditView;
    GraphicSetEditView graphicSetEditView;
    EntityGraphicSetEditView entityGraphicSetEditView;
    IconEditView iconEditView;

    // Properties windows
    /** The right-side panel for viewing and editing the active item's data. */
    SpriteSheetPropertiesWindow spriteSheetPropertiesWindow;
    BoundingBoxPropertiesWindow boundingBoxPropertiesWindow;
    SpritePropertiesWindow spritePropertiesWindow;
    AnimationPropertiesWindow animationPropertiesWindow;
    GraphicSetPropertiesWindow graphicSetPropertiesWindow;
    EntityGraphicSetPropertiesWindow entityGraphicSetPropertiesWindow;
    IconPropertiesWindow iconPropertiesWindow;

    /** The menu for adding new items that opens when you press the "+". */
    LibraryAddMenu libraryAddMenu;

    /** The hamburger button at the top of the screen, next to the properties
        window. */
    HamburgerButtonWindow hamburgerButtonWindow;

    /** The menu that opens when you press the hamburger button. */
    HamburgerMenu hamburgerMenu;

    /** Confirmation dialog. Child widgets can call openConfirmationDialog()
        to use it. */
    AUI::ConfirmationDialog confirmationDialog;

    /** Dialog for adding a sprite to the active sprite sheet. */
    AddSpriteDialog addSpriteDialog;

    /** Dialog for adding an icon sheet to the IconSheetPanel. */
    AddIconSheetDialog addIconSheetDialog;

    /** Dialog for adding a BoundingBox to the Library. */
    SaveBoundingBoxDialog saveBoundingBoxDialog;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/TitleScreen.h`:

```h
#pragma once

#include "AUI/Screen.h"
#include "TitleWindow.h"

namespace AM
{
namespace ResourceImporter
{
class UserInterface;
class DataModel;

/**
 * The opening title screen that you see on app launch.
 */
class TitleScreen : public AUI::Screen
{
public:
    TitleScreen(UserInterface& inUserInterface, DataModel& inDataModel);

    void render() override;

private:
    //-------------------------------------------------------------------------
    // Windows
    //-------------------------------------------------------------------------
    TitleWindow titleWindow;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/UserInterface.h`:

```h
#pragma once

#include "OSEventHandler.h"
#include "TitleScreen.h"
#include "MainScreen.h"
#include "DataModel.h"

#include "AUI/Initializer.h"

// Forward declarations.
struct SDL_Renderer;

namespace AM
{
class AssetCache;

namespace ResourceImporter
{
/**
 * This class handles creation and management of the user interface.
 *
 * Additionally, it provides a way for the renderer to access the UI data.
 */
class UserInterface : public OSEventHandler
{
public:
    enum class ScreenType { TitleScreen, MainScreen };

    UserInterface(SDL_Renderer* inRenderer, AssetCache& inAssetCache,
                  DataModel& inDataModel);

    /**
     * Changes the currentScreen to the given screenType.
     */
    void changeScreenTo(ScreenType screenType);

    /**
     * Calls AUI::Screen::tick() on the current screen.
     *
     * @param timestepS  The amount of time that has passed since the last
     *                   tick() call, in seconds.
     */
    void tick(double timestepS);

    /**
     * Renders all UI graphics for the current screen to the current rendering
     * target.
     */
    void render();

    /**
     * Handles user input events.
     */
    bool handleOSEvent(SDL_Event& event) override;

private:
    /** AmalgamUI initializer, used to init/quit the library at the proper
        times. */
    AUI::Initializer auiInitializer;

    /** The opening title screen, seen on app launch. */
    TitleScreen titleScreen;

    /** The main screen for doing work. */
    MainScreen mainScreen;

    /** The current active UI screen. */
    AUI::Screen* currentScreen;
};

} // namespace ResourceImporter
} // namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/AnimationElementsListItem.h`:

```h
#pragma once

#include "AUI/Widget.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include <functional>

namespace AM
{
namespace ResourceImporter
{
/**
 * A selectable list item, used in the animation elements window.
 *
 * Interactions:
 *   Mouse-over to hover.
 *   Click once to "select", putting this widget into a "selected" state.
 *
 * The rendering order for this widget's children is:
 *   Background: hoveredImage, selectedImage
 *   Foreground: text
 */
class AnimationElementsListItem : public AUI::Widget
{
public:
    //-------------------------------------------------------------------------
    // Public definitions
    //-------------------------------------------------------------------------
    /**
     * Used to track this widget's visual and logical state.
     */
    enum class State { Normal, Hovered, Selected, Disabled };

    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    AnimationElementsListItem(const SDL_Rect& inLogicalExtent,
                              const std::string& inText,
                              const std::string& inDebugName
                              = "AnimationElementsListItem");

    /**
     * Enabled this list item, allowing it to respond to user input.
     */
    void enable();

    /**
     * Disables this list item, causing it to ignore user input and render with
     * grey text.
     */
    void disable();

    /**
     * Selects this widget and calls onSelected.
     *
     * If this widget is already selected or isSelectable == false, does
     * nothing.
     *
     * Note: This widget selects itself when clicked. This function just
     *       exists in case you need to do it programatically.
     */
    void select();

    /**
     * Deselects this widget and calls onDeselected.
     *
     * If this widget isn't selected, does nothing.
     *
     * Note: This widget doesn't deselect itself. The context that is
     *       managing this widget must detect when the widget should be
     *       deactivated and call this method.
     */
    void deselect();

    State getCurrentState() const;

    /**
     * Sets the left padding. Used to define the visual hierarchy in the list.
     */
    void setLeftPadding(int inLeftPadding);

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** Background image, hovered state. */
    AUI::Image hoveredImage;
    /** Background image, selected state. */
    AUI::Image selectedImage;

    /** List item text. */
    AUI::Text text;

    //-------------------------------------------------------------------------
    // Callback registration
    //-------------------------------------------------------------------------
    /**
     * @param inOnSelected A callback that expects a pointer to the widget
     *                     that was selected.
     */
    void setOnSelected(
        std::function<void(AnimationElementsListItem*)> inOnSelected);

    /**
     * @param inOnDeselected A callback that expects a pointer to the
     *                       widget that was deselected.
     */
    void setOnDeselected(
        std::function<void(AnimationElementsListItem*)> inOnDeselected);

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    AUI::EventResult onMouseDown(AUI::MouseButtonType buttonType,
                                 const SDL_Point& cursorPosition) override;

    AUI::EventResult
        onMouseDoubleClick(AUI::MouseButtonType buttonType,
                           const SDL_Point& cursorPosition) override;

    void onMouseEnter() override;

    void onMouseLeave() override;

protected:
    /**
     * Sets currentState and updates child widget visibility.
     */
    void setCurrentState(State inState);

    std::function<void(AnimationElementsListItem*)> onSelected;
    std::function<void(AnimationElementsListItem*)> onDeselected;

    /** Tracks this button's current visual and logical state. */
    State currentState;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/AnimationTimeline.h`:

```h
#pragma once

#include "TimelineHandle.h"
#include "Timer.h"
#include "AUI/Widget.h"
#include "AUI/Text.h"
#include "AUI/HorizontalGridContainer.h"
#include <string>
#include <functional>

namespace AM
{
namespace ResourceImporter
{
struct EditorAnimation;
struct EditorSprite;

/**
 * The animation timeline used by AnimationEditStage.
 * 
 * Lets users add sprites to an animation.
 */
class AnimationTimeline : public AUI::Widget
{
public:
    AnimationTimeline(const SDL_Rect& inLogicalExtent,
                      const std::string& inDebugName = "AnimationTimeline");

    void setActiveAnimation(const EditorAnimation& newActiveAnimation);

    void setFrameCount(Uint8 newFrameCount);

    void setLoopStartFrame(Uint8 newLoopStartFrame);

    void setFrame(Uint8 frameNumber, bool hasSprite);

    /**
     * If an animation isn't currently playing, plays the active animation 
     * from the start. If an animation is currently playing, pauses it.
     */
    void playOrPauseAnimation();

    /**
     * @return The currently selected frame (the one that the scrubber is 
     *         hovering over).
     */
    Uint8 getSelectedFrameNumber() const;

    //-------------------------------------------------------------------------
    // Callback registration
    //-------------------------------------------------------------------------
    /**
     * @param inOnSelectionChanged A callback that expects the new selected 
     *                             frame's number.
     */
    void setOnSelectionChanged(
        std::function<void(Uint8 selectedFrameNumber)> inOnSelectionChanged);

    /**
     * @param inOnLoopStartFrameChanged A callback that expects the new 
     *                                  loop start frame.
     */
    void setOnLoopStartFrameChanged(
        std::function<void(Uint8 newLoopStartFrame)> inOnLoopStartFrameChanged);

    /**
     * @param inOnSpriteMoved A callback that expects the old and new frame 
     *                        indices.
     */
    void setOnSpriteMoved(
        std::function<void(Uint8 oldFrameNumber, Uint8 newFrameNumber)>
            inOnSpriteMoved);

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    void onTick(double timestepS) override;

    void render(const SDL_Point& windowTopLeft) override;

private:
    /**
     * If the scrubber has been dragged far enough, selects a new frame.
     */
    void onFrameScrubberDragged(const SDL_Point& cursorPosition);

    // TODO: We're trying this to see if it's performant enough. If updating 
    //       while dragging is too slow, we can do it like SpriteDrag
    /**
     * If the handle has been dragged far enough, changes the loop value.
     */
    void onLoopHandleDragged(const SDL_Point& cursorPosition);

    /**
     * Handles a frame that contains a sprite being right-click dragged.
     */
    void onSpriteDragStarted(Uint8 frameNumber,
                             const SDL_Point& cursorPosition);

    /**
     * If a frame containing a sprite has been dragged far enough, visually 
     * moves the frame circle to the new hovered frame.
     */
    void onSpriteDragged(Uint8 frameNumber, const SDL_Point& cursorPosition);

    /**
     * If the cursor is over a frame other than originSpriteDragFrameNumber, 
     * moves the sprite into that frame.
     */
    void onSpriteDragReleased(Uint8 frameNumber,
                              const SDL_Point& cursorPosition);

    /**
     * Refreshes frameContainer to match the current active animation.
     */
    void refreshFrames();

    /**
     * Moves the frame scrubber to the given frame.
     */
    void setFrameScrubberPosition(Uint8 frameNumber);

    /**
     * Moves the loop handle to the given frame.
     */
    void setLoopHandlePosition(Uint8 frameNumber);

    /** 
     * Returns which frame the given cursor position is aligned with.
     */
    Uint8 getCursorFrame(const SDL_Point& cursorPosition);

    void styleNumberText(AUI::Text& textObject, const std::string& text);

    /** Holds the number text that goes above the frames. */
    AUI::HorizontalGridContainer numberContainer;

    /** Holds the frames that contain the animation's frames. */
    AUI::HorizontalGridContainer frameContainer;

    /** Used to select how many frames will be looped.
        Note: This needs to be behind frameScrubber since it's double-tall to 
              account for the handle (even though we don't render it). */
    TimelineHandle loopHandle;

    /** Used to move between frames. */
    TimelineHandle frameScrubber;

    /** The current selected frame. */
    Uint8 selectedFrameNumber;

    /** The animation that is currently loaded into this timeline. */
    const EditorAnimation* activeAnimation;

    /** If a sprite is being dragged, this holds the original frame number. */
    Uint8 originSpriteDragFrameNumber;

    /** If a sprite is being dragged, this holds the current frame number that 
        the sprite is being dragged over. */
    Uint8 currentSpriteDragFrameNumber;

    /** Used for properly pacing the animation during playback. */
    Timer animationTimer;

    /** Accumulates time to keep animation playback smooth. */
    double animationAccumulator;

    /** If true, we're currently playing the animation. */
    bool playingAnimation;

    /** The amber background that we render to show the loop area. */
    SDL_Rect loopBackgroundExtent;

    std::function<void(Uint8)> onSelectionChanged;

    std::function<void(Uint8)> onLoopStartFrameChanged;

    std::function<void(Uint8, Uint8)> onSpriteMoved;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/BoundingBoxGizmo.h`:

```h
#pragma once

#include "BoundingBox.h"
#include "LibraryItemData.h"
#include "AUI/Widget.h"
#include "AUI/ScreenResolution.h"
#include <array>
#include <functional>

namespace AM
{
struct Position;

namespace ResourceImporter
{
struct EditorSprite;

/**
 * A gizmo that allows the user to draw 3D bounding boxes on their 2D sprites.
 */
class BoundingBoxGizmo : public AUI::Widget
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    BoundingBoxGizmo(const SDL_Rect& inLogicalExtent);

    virtual ~BoundingBoxGizmo() = default;

    /**
     * Enabled this gizmo, allowing it to respond to user input.
     */
    void enable();

    /**
     * Disables this gizmo, causing it to ignore user input and render as 
     * semi-transparent.
     */
    void disable();

    /**
     * Sets the size of the sprite image that this gizmo is drawing over.
     * The resulting extent will be centered within this widget.
     */
    void setSpriteImageSize(int logicalSpriteWidth, int logicalSpriteHeight);

    /**
     * Sets the stage's screen-space origin offset, relative to the top left of 
     * the image.
     */
    void setStageOrigin(const SDL_Point& inLogicalStageOrigin);

    /**
     * Sets this gizmo to match newBoundingBox.
     */
    void setBoundingBox(const BoundingBox& newBoundingBox);
    
    /**
     * Returns the sprite image extent that was set by the last call to 
     * setSpriteImageSize(), centered within this widget.
     */
    const SDL_Rect& getLogicalCenteredSpriteExtent() const;

    //-------------------------------------------------------------------------
    // Callback registration
    //-------------------------------------------------------------------------
    /**
     * @param inOnBoundingBoxUpdated A callback that expects the updated 
     *                               bounding box.
     */
    void setOnBoundingBoxUpdated(
        std::function<void(const BoundingBox& updatedBounds)> inOnBoundingBoxUpdated);

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    void setLogicalExtent(const SDL_Rect& inLogicalExtent) override;

    /**
     * If the UI scaling has changed, refreshes our controls.
     */
    void arrange(const SDL_Point& startPosition,
                 const SDL_Rect& availableExtent,
                 AUI::WidgetLocator* widgetLocator) override;

    void render(const SDL_Point& windowTopLeft) override;

    AUI::EventResult onMouseDown(AUI::MouseButtonType buttonType,
                                 const SDL_Point& cursorPosition) override;

    AUI::EventResult onMouseUp(AUI::MouseButtonType buttonType,
                               const SDL_Point& cursorPosition) override;

    AUI::EventResult onMouseMove(const SDL_Point& cursorPosition) override;

private:
    /** The base transparency value for a selected gizmo. */
    static constexpr float BASE_ALPHA{255};

    /** How opaque a disabled gizmo will be. */
    static constexpr float DISABLED_ALPHA_FACTOR{0.25f};

    /** How opaque the sides of the bounding box will be. */
    static constexpr float PLANE_ALPHA_FACTOR{0.5f};

    /**
     * The list of our clickable controls.
     */
    enum class Control { None, Position, X, Y, Z };
    
    void refreshScaling();

    /**
     * Updates stageWorldExtent to match the current stageOrigin and widget 
     * size.
     */
    void updateStageExtent();

    /**
     * Refreshes this widget's graphics (controls/lines/planes) to match its
     * internal state.
     */
    void refreshGraphics();

    /**
     * Updates the maxX and maxY bounds to match the given mouse position.
     */
    void updatePositionBounds(const Position& mouseWorldPos);

    /**
     * Updates the minX bound to match the given mouse position.
     */
    void updateXBounds(const Position& mouseWorldPos);

    /**
     * Updates the minY bound to match the given mouse position.
     */
    void updateYBounds(const Position& mouseWorldPos);

    /**
     * Updates the maxZ bound to match the given mouse position.
     */
    void updateZBounds(int mouseScreenYPos);

    /**
     * Transforms the vertices in the current boundingBox from world space 
     * to screen space, scales them to the current UI scaling, and offsets 
     * them using the current offsets.
     *
     * The finished points are pushed into the given vector in the order:
     *     (minX, maxY, minZ), (maxX, maxY, minZ), (maxX, minY, minZ),
     *     (minX, maxY, maxZ), (maxX, maxY, maxZ), (maxX, minY, maxZ),
     *     (minX, minY, maxZ)
     */
    void
        calcBoundingBoxScreenPoints(std::vector<SDL_Point>& boundsScreenPoints);

    /**
     * Moves the control extents to their proper screen position.
     */
    void moveControls(std::vector<SDL_Point>& boundsScreenPoints);

    /**
     * Moves the line points to their proper screen position.
     */
    void moveLines(std::vector<SDL_Point>& boundsScreenPoints);

    /**
     * Moves the plane coords to their proper screen position.
     */
    void movePlanes(std::vector<SDL_Point>& boundsScreenPoints);

    /**
     * Renders the control rectangles.
     */
    void renderControls(const SDL_Point& windowTopLeft);

    /**
     * Renders the line polygons.
     */
    void renderLines(const SDL_Point& windowTopLeft);

    /**
     * Renders the plane polygons.
     */
    void renderPlanes(const SDL_Point& windowTopLeft);

    /** The value of AUI::Core::actualScreenSize that was used the last time
        this widget updated its layout. Used to detect when the UI scale
        changes, so we can resize our controls. */
    AUI::ScreenResolution lastUsedScreenSize;

    /** The bounding box that this gizmo is representing. */
    BoundingBox boundingBox;

    /** If false, this widget should ignore all interactions and render as 
        semi-transparent. */
    bool isEnabled;

    /** A reasonable size for the control rectangles. */
    static constexpr int LOGICAL_RECT_SIZE{12};

    /** The scaled size of the control rectangles. */
    int scaledRectSize;

    /** A reasonable width for the lines. */
    static constexpr int LOGICAL_LINE_WIDTH{4};

    /** The scaled width of the lines. */
    int scaledLineWidth;

    /** Sets the extent where the sprite image will be placed, relative to the
        top left of this widget. */
    SDL_Rect logicalSpriteImageExtent;

    /** The stage's screen-space origin offset, relative to the top left of 
        the image. */
    SDL_Point logicalStageOrigin;

    /** The stage's world-space extent.
        We limit this extent to the edges of the sprite image. */
    BoundingBox stageWorldExtent;

    // Controls (scaled extents, without parent offsets)
    /** The extent of the box position control, (maxX, maxY, minZ). */
    SDL_Rect positionControlExtent;

    /** The extent of the x-axis box length control, (minX, maxY, minZ). */
    SDL_Rect xControlExtent;

    /** The extent of the y-axis box length control, (maxX, minY, minZ). */
    SDL_Rect yControlExtent;

    /** The extent of the z-axis box length control, (maxX, maxY, maxZ). */
    SDL_Rect zControlExtent;

    // Lines
    SDL_Point lineXMinPoint;
    SDL_Point lineXMaxPoint;

    SDL_Point lineYMinPoint;
    SDL_Point lineYMaxPoint;

    SDL_Point lineZMinPoint;
    SDL_Point lineZMaxPoint;

    // Planes (each polygon takes 4 coordinates)
    std::array<Sint16, 12> planeXCoords;
    std::array<Sint16, 12> planeYCoords;

    /** Tracks which control, if any, is currently being held. */
    Control currentHeldControl;

    std::function<void(const BoundingBox&)> onBoundingBoxUpdated;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/GraphicSetSlot.h`:

```h
#pragma once

#include "AUI/Widget.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include "MainButton.h"

namespace AM
{
namespace ResourceImporter
{
/**
 * Allows the user to assign one of the graphics in a graphic set.
 */
class GraphicSetSlot : public AUI::Widget
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    /**
     * @param logicalWidth The widget's width. Only affects the text width, the 
     *                     other elements are all centered.
     */
    GraphicSetSlot(int logicalWidth);

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** Top text, says what kind of graphic goes in this slot. */
    AUI::Text topText;

    /** Checkerboard image, tiled as the background for this sprite. */
    AUI::Image checkerboardImage;

    /** The sprite that is in this slot. */
    AUI::Image spriteImage;

    /** The sprite's display name. */
    AUI::Text spriteNameText;

    /** The "ASSIGN" button, for assigning a new graphic to this slot. */
    MainButton assignButton;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/LibraryCollapsibleContainer.h`:

```h
#pragma once

#include "AUI/CollapsibleContainer.h"

namespace AM
{
namespace ResourceImporter
{
/**
 * A collapsible container used for the top-level categories in the library
 * window on the main screen.
 */
class LibraryCollapsibleContainer : public AUI::CollapsibleContainer
{
public:
    LibraryCollapsibleContainer(const std::string& inHeaderText,
                                const std::string& inDebugName
                                = "LibraryCollapsibleContainer");

    /**
     * Sets the left padding. Used to define the visual hierarchy in the list.
     */
    void setLeftPadding(int inLeftPadding);
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/LibraryListItem.h`:

```h
#pragma once

#include "AUI/Widget.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include <functional>

namespace AM
{
namespace ResourceImporter
{
/**
 * A selectable list item, used in the library window.
 *
 * Interactions:
 *   Mouse-over to hover.
 *   Click once to "select", putting this widget into a "selected" state.
 *   Double-click to "activate". Does not change internal state.
 *
 * The rendering order for this widget's children is:
 *   Background: hoveredImage, selectedImage
 *   Foreground: text
 */
class LibraryListItem : public AUI::Widget
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    LibraryListItem(const std::string& inText,
                    const std::string& inDebugName = "LibraryListItem");

    /**
     * Selects this widget and calls onSelected.
     *
     * If this widget is already selected or isSelectable == false, does
     * nothing.
     *
     * Note: This widget selects itself when clicked. This function just
     *       exists in case you need to do it programatically.
     */
    void select();

    /**
     * Deselects this widget and calls onDeselected.
     *
     * If this widget isn't selected, does nothing.
     *
     * Note: This widget doesn't deselect itself. The context that is
     *       managing this widget must detect when the widget should be
     *       deactivated and call this method.
     */
    void deselect();

    bool getIsHovered() const;
    bool getIsSelected() const;

    /**
     * Sets the left padding. Used to define the visual hierarchy in the list.
     */
    void setLeftPadding(int inLeftPadding);

    /**
     * The types of list items that we hold in the library.
     */
    enum Type {
        SpriteSheet,
        Sprite,
        Animation,
        BoundingBox,
        Terrain,
        Floor,
        Wall,
        Object,
        Entity,
        IconSheet,
        Icon,
        Count,
        None
    };
    Type type;

    /** Alongside type, associates this list item with the model data that it
        represents.
        Note: For unsigned IDs, this can be cast to Uint16 or Uint32. */
    int ID;

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** Background image, hovered state. */
    AUI::Image hoveredImage;
    /** Background image, selected state. */
    AUI::Image selectedImage;

    /** List item text. */
    AUI::Text text;

    //-------------------------------------------------------------------------
    // Callback registration
    //-------------------------------------------------------------------------
    /**
     * @param inOnSelected A callback that expects a pointer to the widget
     *                     that was selected.
     */
    void setOnSelected(std::function<void(LibraryListItem*)> inOnSelected);

    /**
     * @param inOnDeselected A callback that expects a pointer to the
     *                       widget that was deselected.
     */
    void setOnDeselected(std::function<void(LibraryListItem*)> inOnDeselected);

    /**
     * @param inOnActivated A callback that expects a pointer to the widget
     *                      that was activated.
     */
    void setOnActivated(std::function<void(LibraryListItem*)> inOnActivated);

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    AUI::EventResult onMouseDown(AUI::MouseButtonType buttonType,
                                 const SDL_Point& cursorPosition) override;

    AUI::EventResult
        onMouseDoubleClick(AUI::MouseButtonType buttonType,
                           const SDL_Point& cursorPosition) override;

    void onMouseEnter() override;

    void onMouseLeave() override;

protected:
    /** Sets isHovered and updates the visibility of hoveredImage. */
    void setIsHovered(bool inIsHovered);
    /** Sets isSelected and updates the visibility of selectedImage. */
    void setIsSelected(bool inIsSelected);

    /** Returns true if shift or ctrl are currently held. */
    bool modifierKeyIsHeld();

    std::function<void(LibraryListItem*)> onSelected;
    std::function<void(LibraryListItem*)> onDeselected;
    std::function<void(LibraryListItem*)> onActivated;

    /** Tracks whether the mouse is currently hovering over this widget. */
    bool isHovered;

    /** Tracks whether this widget is currently selected. */
    bool isSelected;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/MainButton.h`:

```h
#pragma once

#include "AUI/Screen.h"
#include "AUI/Button.h"
#include <string>

namespace AM
{
namespace ResourceImporter
{
/**
 * The usual button style used for the main screen.
 */
class MainButton : public AUI::Button
{
public:
    MainButton(const SDL_Rect& inLogicalExtent, const std::string& inText,
               const std::string& inDebugName = "MainButton");
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/MainTextInput.h`:

```h
#pragma once

#include "AUI/TextInput.h"
#include <string>

namespace AM
{
namespace ResourceImporter
{
/**
 * The text input style used for the main screen.
 */
class MainTextInput : public AUI::TextInput
{
public:
    MainTextInput(const SDL_Rect& inLogicalExtent,
                  const std::string& inDebugName = "MainTextInput");
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/MainThumbnail.h`:

```h
#pragma once

#include "AUI/Screen.h"
#include "AUI/Thumbnail.h"
#include <string>

namespace AM
{
namespace ResourceImporter
{
/**
 * The thumbnail style used for the main screen.
 */
class MainThumbnail : public AUI::Thumbnail
{
public:
    MainThumbnail(const std::string& inDebugName = "MainThumbnail");
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/ParentListItem.h`:

```h
#pragma once

#include "LibraryListItem.h"
#include "LibraryCollapsibleContainer.h"
#include <SDL_rect.h>

namespace AM
{
namespace ResourceImporter
{
/**
 * A collapsible container used for the top-level list items in the library
 * window on the main screen, such as sprite and icon sheets which contain a
 * list of sprites or items.
 *
 * Derives from LibraryListItem for hover/select functionality and library
 * list info.
 */
class ParentListItem : public LibraryListItem
{
public:
    ParentListItem(const std::string& inHeaderText,
                   const std::string& inDebugName = "ParentListItem");

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    AUI::EventResult onMouseDown(AUI::MouseButtonType buttonType,
                                 const SDL_Point& cursorPosition) override;

    AUI::EventResult
        onMouseDoubleClick(AUI::MouseButtonType buttonType,
                           const SDL_Point& cursorPosition) override;

    AUI::EventResult onMouseMove(const SDL_Point& cursorPosition) override;

    void onMouseEnter() override;

    void onMouseLeave() override;

    void measure(const SDL_Rect& availableExtent) override;

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** Holds list item children. */
    LibraryCollapsibleContainer childListItemContainer;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/PointGizmo.h`:

```h
#pragma once

#include "Vector3.h"
#include "LibraryItemData.h"
#include "AUI/Widget.h"
#include "AUI/ScreenResolution.h"
#include <array>
#include <functional>

namespace AM
{
struct Position;

namespace ResourceImporter
{
struct EditorSprite;

/**
 * A gizmo that allows the user to draw a 3D point on their 2D sprites.
 */
class PointGizmo : public AUI::Widget
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    PointGizmo(const SDL_Rect& inLogicalExtent);

    virtual ~PointGizmo() = default;

    /**
     * Enabled this gizmo, allowing it to respond to user input.
     */
    void enable();

    /**
     * Disables this gizmo, causing it to ignore user input and render as 
     * semi-transparent.
     */
    void disable();

    /**
     * Sets the size of the sprite image that this gizmo is drawing over.
     * The resulting extent will be centered within this widget.
     */
    void setSpriteImageSize(int logicalSpriteWidth, int logicalSpriteHeight);

    /**
     * Sets the stage's screen-space origin offset, relative to the top left of 
     * the image.
     */
    void setStageOrigin(const SDL_Point& inLogicalStageOrigin);

    /**
     * Sets this gizmo to match newPoint.
     */
    void setPoint(const Vector3& newPoint);
    
    /**
     * Returns the sprite image extent that was set by the last call to 
     * setSpriteImageSize(), centered within this widget.
     */
    const SDL_Rect& getLogicalCenteredSpriteExtent() const;

    //-------------------------------------------------------------------------
    // Callback registration
    //-------------------------------------------------------------------------
    /**
     * @param inOnPointUpdated A callback that expects the updated point.
     */
    void setOnPointUpdated(
        std::function<void(const Vector3& updatedPoint)> inOnPointUpdated);

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    void setLogicalExtent(const SDL_Rect& inLogicalExtent) override;

    /**
     * If the UI scaling has changed, refreshes our controls.
     */
    void arrange(const SDL_Point& startPosition,
                 const SDL_Rect& availableExtent,
                 AUI::WidgetLocator* widgetLocator) override;

    void render(const SDL_Point& windowTopLeft) override;

    AUI::EventResult onMouseDown(AUI::MouseButtonType buttonType,
                                 const SDL_Point& cursorPosition) override;

    AUI::EventResult onMouseUp(AUI::MouseButtonType buttonType,
                               const SDL_Point& cursorPosition) override;

    AUI::EventResult onMouseMove(const SDL_Point& cursorPosition) override;

private:
    /** The base transparency value for a selected gizmo. */
    static constexpr float BASE_ALPHA{255};

    /** How opaque a disabled gizmo will be. */
    static constexpr float DISABLED_ALPHA_FACTOR{0.25f};
    
    void refreshScaling();

    /**
     * Updates stageWorldExtent to match the current stageOrigin and widget 
     * size.
     */
    void updateStageExtent();

    /**
     * Refreshes this widget's graphics  to match its internal state.
     */
    void refreshGraphics();

    /**
     * Updates the point to match the given mouse position.
     */
    void updatePoint(const Position& mouseWorldPos);

    /** The value of AUI::Core::actualScreenSize that was used the last time
        this widget updated its layout. Used to detect when the UI scale
        changes, so we can resize our controls. */
    AUI::ScreenResolution lastUsedScreenSize;

    /** The point that this gizmo is representing. */
    Vector3 point;

    /** If false, this widget should ignore all interactions and render as 
        semi-transparent. */
    bool isEnabled;

    /** A reasonable size for the control rectangles. */
    static constexpr int LOGICAL_RECT_SIZE{12};

    /** The scaled size of the control rectangles. */
    int scaledRectSize;

    /** Sets the extent where the sprite image will be placed, relative to the
        top left of this widget. */
    SDL_Rect logicalSpriteImageExtent;

    /** The stage's screen-space origin offset, relative to the top left of 
        the image. */
    SDL_Point logicalStageOrigin;

    /** The stage's world-space extent.
        We limit this extent to the edges of the sprite image. */
    BoundingBox stageWorldExtent;

    // Controls (scaled extents, without parent offsets)
    /** The extent of the point position control. */
    SDL_Rect pointControlExtent;

    /** If true, the point control is currently being held. */
    bool currentlyHeld;

    std::function<void(const Vector3&)> onPointUpdated;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/StageGraphic.h`:

```h
#pragma once

#include "AUI/Widget.h"

namespace AM
{
namespace ResourceImporter
{
/**
 * Draws the stage graphic, used to show where the bounds are when editing 
 * boxes.
 */
class StageGraphic : public AUI::Widget
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    StageGraphic(const SDL_Rect& inLogicalExtent);

    /**
     * Updates the stage graphic to match the given extent and origin.
     * 
     * @param spriteTextureExtent The texture extent from the sprite data.
     * @param stageOrigin The stage origin from the sprite data.
     * @param actualSpriteImageOffset Where the sprite image will start, 
     *        relative to the top left of this widget and scaled to actual 
     *        (screen-relative) size.
     */
    void updateStage(const SDL_Rect& spriteTextureExtent,
                     const SDL_Point& stageOrigin,
                     const SDL_Point& actualSpriteImageOffset);

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    void render(const SDL_Point& windowTopLeft) override;

private:
    /** The transparency value for the stage graphic. */
    static constexpr float STAGE_ALPHA{127};

    /**
     * Transforms the vertices that make up the stage's bottom face from world
     * space to screen space, scales them to the current UI scaling, and 
     * offsets them using the current offsets.
     *
     * The finished points are pushed into the given vector in the order:
     *     (minX, minY, minZ), (maxX, minY, minZ), (maxX, maxY, minZ),
     *     (minX, maxY, minZ)
     */
    void calcStageScreenPoints(const SDL_Rect& spriteTextureExtent,
                               const SDL_Point& stageOrigin,
                               const SDL_Point& logicalSpriteImageOffset,
                               std::vector<SDL_Point>& stageScreenPoints);

    /**
     * Moves the stage graphic coords to their proper screen position.
     */
    void moveStageGraphic(std::vector<SDL_Point>& stageScreenPoints);

    /**
     * Renders the stage's bottom face.
     */
    void renderStage(const SDL_Point& windowTopLeft);

    // Stage (1 polygon, 4 coordinates)
    std::array<Sint16, 4> stageXCoords;
    std::array<Sint16, 4> stageYCoords;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/TimelineFrame.h`:

```h
#pragma once

#include "SpriteID.h"
#include "AUI/Widget.h"
#include <functional>

namespace AM
{
namespace ResourceImporter
{
/**
 * An individual frame in the animation timeline.
 *
 * Frames can be selected by clicking on them. For frames that contain sprites, 
 * you can right click and drag to move the sprite to a different frame.
 */
class TimelineFrame : public AUI::Widget
{
public:
    /** This widget's width. */
    static constexpr int LOGICAL_WIDTH{24};

    TimelineFrame();

    /** If true, this frame contains a sprite. */
    bool hasSprite;

    /** If true, this frame will draw a darker background.
        Used for every 5th frame. */
    bool drawDarkBackground;

    //-------------------------------------------------------------------------
    // Callback registration
    //-------------------------------------------------------------------------
    /**
     * @param inOnPressed A callback for when this frame is pressed.
     */
    void setOnPressed(std::function<void(void)> inOnPressed);

    /**
     * Called when this frame is right clicked while it has a sprite.
     * @param inOnSpriteDragStarted A callback that expects the cursor's current 
     *                              position.
     */
    void setOnSpriteDragStarted(
        std::function<void(const SDL_Point&)> inOnSpriteDragStarted);

    /**
     * @param inOnSpriteDragged A callback that expects the cursor's current 
     *                          position.
     */
    void setOnSpriteDragged(
        std::function<void(const SDL_Point&)> inOnSpriteDragged);

    /**
     * @param inOnSpriteDragReleased A callback that expects the cursor's 
     *                               current position.
     */
    void setOnSpriteDragReleased(
        std::function<void(const SDL_Point&)> inOnSpriteDragReleased);

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    void render(const SDL_Point& windowTopLeft) override;

    AUI::EventResult onMouseDown(AUI::MouseButtonType buttonType,
                            const SDL_Point& cursorPosition) override;

    AUI::EventResult onMouseDoubleClick(AUI::MouseButtonType buttonType,
                                   const SDL_Point& cursorPosition) override;

    AUI::EventResult onMouseUp(AUI::MouseButtonType buttonType,
                               const SDL_Point& cursorPosition) override;

    AUI::EventResult onMouseMove(const SDL_Point& cursorPosition) override;

private:
    std::function<void(void)> onPressed;
    std::function<void(const SDL_Point&)> onSpriteDragStarted;
    std::function<void(const SDL_Point&)> onSpriteDragged;
    std::function<void(const SDL_Point&)> onSpriteDragReleased;

    /** If true, the mouse is currently dragging this frame. */
    bool isDragging;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/TimelineHandle.h`:

```h
#pragma once

#include "AUI/Widget.h"
#include <functional>

namespace AUI
{
class WidgetLocator;
}

namespace AM
{
namespace ResourceImporter
{

/**
 * A handle that can be dragged around to manipulate the timeline.
 */
class TimelineHandle : public AUI::Widget
{
public:
    TimelineHandle(const SDL_Rect& inLogicalExtent);

    /**
     * Sets the color of this widget's graphics.
     */
    void setColor(const SDL_Color& inColor);

    /**
     * Sets whether the line part of the handle graphic should be rendered.
     */
    void setRenderLine(bool inRenderLine);

    //-------------------------------------------------------------------------
    // Callback registration
    //-------------------------------------------------------------------------
    /**
     * @param inOnDragged A callback that expects the cursor's current position.
     */
    void setOnDragged(std::function<void(const SDL_Point&)> inOnDragged);

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    void arrange(const SDL_Point& startPosition,
                 const SDL_Rect& availableExtent,
                 AUI::WidgetLocator* widgetLocator) override;

    void render(const SDL_Point& windowTopLeft) override;

    AUI::EventResult onMouseDown(AUI::MouseButtonType buttonType,
                            const SDL_Point& cursorPosition) override;

    AUI::EventResult onMouseDoubleClick(AUI::MouseButtonType buttonType,
                                   const SDL_Point& cursorPosition) override;

    AUI::EventResult onMouseUp(AUI::MouseButtonType buttonType,
                               const SDL_Point& cursorPosition) override;

    AUI::EventResult onMouseMove(const SDL_Point& cursorPosition) override;

private:
    std::function<void(const SDL_Point&)> onDragged;

    /** The color of this widget's graphics. */
    SDL_Color color;

    /** If true, the line part of the handle graphic should be rendered. */
    bool renderLine;

    /** If true, the mouse is currently dragging this scrubber. */
    bool isDragging;

    /** The extent of the scrubber's rect that covers the frame numbers. */
    SDL_Rect rectLogicalExtent;

    /** The rect's actual clipped extent. */
    SDL_Rect rectClippedExtent;

    /** The extent of the scrubber's line that covers the cell. */
    SDL_Rect lineLogicalExtent;

    /** The line's actual clipped extent. */
    SDL_Rect lineClippedExtent;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Widgets/TitleButton.h`:

```h
#pragma once

#include "AUI/Button.h"

namespace AM
{
namespace ResourceImporter
{
/**
 * The button style used for the title screen.
 */
class TitleButton : public AUI::Button
{
public:
    TitleButton(const SDL_Rect& inLogicalExtent, const std::string& inText,
                const std::string& inDebugName = "TitleButton");
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/AddIconSheetDialog.h`:

```h
#pragma once

#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include "MainButton.h"
#include "MainTextInput.h"

namespace AM
{
namespace ResourceImporter
{
class DataModel;

/**
 * A confirmation dialog for adding sprite sheets.
 */
class AddIconSheetDialog : public AUI::Window
{
public:
    AddIconSheetDialog(DataModel& inDataModel);

    virtual ~AddIconSheetDialog() = default;

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** Semi-transparent shadow image to obscure things that are behind the
        dialog. */
    AUI::Image shadowImage;

    /** The dialog's background image. */
    AUI::Image backgroundImage;

    /** The header text at the top of the dialog. */
    AUI::Text headerText;

    // Path entry
    // Note: The path must be relative to IconDataModel::workingTexturesDir.
    AUI::Text pathLabel;
    MainTextInput pathInput;

    // Icon width entry
    AUI::Text widthLabel;
    MainTextInput widthInput;

    // Icon height entry
    AUI::Text heightLabel;
    MainTextInput heightInput;

    // Base name entry
    AUI::Text nameLabel;
    MainTextInput nameInput;

    /** Right-side confirmation button. Adds the sheet. */
    MainButton addButton;

    /** Left-side cancel button. Closes the dialog without performing any
        action. */
    MainButton cancelButton;

private:
    /**
     * Clears the text in all of this dialog's text inputs and error text.
     */
    void clear();

    /** Used to update the model when a sheet is added. */
    DataModel& dataModel;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    /** Error text, appears if the user tries to submit an invalid input. */
    AUI::Text errorText;
};

} // namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/AddSpriteDialog.h`:

```h
#pragma once

#include "LibraryItemData.h"
#include "MainButton.h"
#include "MainTextInput.h"
#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include "AUI/Checkbox.h"

namespace AM
{
namespace ResourceImporter
{
class MainScreen;
class DataModel;

/**
 * A confirmation dialog for adding sprite sheets.
 */
class AddSpriteDialog : public AUI::Window
{
public:
    AddSpriteDialog(MainScreen& inScreen, DataModel& inDataModel);

    virtual ~AddSpriteDialog() = default;

    /**
     * Sets the sprite image paths to add to the active sprite sheet the next 
     * time the "Add" button is pressed.
     */
    void setSpriteImageRelPaths(
        const std::vector<std::string>& inSpriteImageRelPaths);

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** Semi-transparent shadow image to obscure things that are behind the
        dialog. */
    AUI::Image shadowImage;

    /** The dialog's background image. */
    AUI::Image backgroundImage;

    /** The header text at the top of the dialog. */
    AUI::Text headerText;

    // Stage origin entry
    AUI::Text stageOriginXLabel;
    MainTextInput stageOriginXInput;
    AUI::Text stageOriginYLabel;
    MainTextInput stageOriginYInput;

    // Premultiply alpha entry
    AUI::Text premultiplyAlphaLabel;
    AUI::Checkbox premultiplyAlphaInput;

    /** Right-side confirmation button. Adds the sprites. */
    MainButton addButton;

    /** Left-side cancel button. Closes the dialog without performing any
        action. */
    MainButton cancelButton;

private:
    /**
     * If the new active item is a sprite sheet, saves its ID.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * Clears the text in all of this dialog's text inputs and error text.
     */
    void clear();

    /** Used to open the error dialog when adding a sprite fails. */
    MainScreen& mainScreen;

    /** Used to update the model when a sheet is added. */
    DataModel& dataModel;

    /** The active sprite sheet's ID. */
    SpriteSheetID activeSpriteSheetID;

    /** The sprite images to add to the active sprite sheet the next time the 
        Add button is pressed. */
    std::vector<std::string> spriteImageRelPaths;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    /** Error text, appears if the user tries to submit an invalid input. */
    AUI::Text errorText;
};

} // namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/AnimationEditView.h`:

```h
#pragma once

#include "AnimationElementsWindow.h"
#include "LibraryItemData.h"
#include "StageGraphic.h"
#include "BoundingBoxGizmo.h"
#include "PointGizmo.h"
#include "AUI/Window.h"
#include "AUI/Screen.h"
#include "AUI/Text.h"
#include "AUI/Image.h"
#include "AUI/ScrollArea.h"

namespace AM
{
namespace ResourceImporter
{
class DataModel;
class LibraryWindow;
class AnimationTimeline;
class LibraryListItem;

/**
 * The center stage shown when the user loads an animation from the Library.
 * Allows the user to add sprites to the animation, set fps and frame count, 
 * and edit its bounding box.
 */
class AnimationEditView : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    AnimationEditView(DataModel& inDataModel, LibraryWindow& inLibraryWindow,
                      AnimationElementsWindow& inAnimationElementsWindow);

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    AUI::EventResult onKeyDown(SDL_Keycode keyCode) override;

private:
    /**
     * If the new active item is an animation, loads it's data onto this stage.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * If the changed animation is currently active, updates this stage to 
     * reflect the new data.
     */
    void onAnimationFrameCountChanged(AnimationID animationID,
                                      Uint8 newFrameCount);
    void onAnimationLoopStartFrameChanged(AnimationID animationID,
                                          Uint8 newLoopStartFrame);
    void onAnimationFrameChanged(AnimationID animationID, Uint8 frameNumber,
                                 const EditorSprite* newSprite);
    void onAnimationModelBoundsIDChanged(AnimationID animationID,
                                         BoundingBoxID newModelBoundsID);
    void onAnimationCustomModelBoundsChanged(
        AnimationID animationID, const BoundingBox& newCustomModelBounds);
    void onAnimationEntityAlignmentAnchorChanged(
        AnimationID animationID,
        const std::optional<Vector3>& newEntityAlignmentAnchor);

    /**
     * (If active animation was removed) Hides this view.
     */
    void onAnimationRemoved(AnimationID animationID);

    /**
     * Pushes the gizmo's updated bounding box to the model.
     */
    void onGizmoBoundingBoxUpdated(const BoundingBox& updatedBounds);

    /**
     * Pushes the gizmo's updated entity alignment anchor to the model.
     */
    void onGizmoEntityAlignmentAnchorUpdated(
        const Vector3& updatedEntityAlignmentAnchor);

    /**
     * Displays the timeline's new selected sprite.
     */
    void onTimelineSelectionChanged(Uint8 selectedFrameNumber);

    /**
     * Tells the model to update the animation.
     */
    void onTimelineLoopStartFrameChanged(Uint8 newLoopStartFrame);

    /**
     * Tells the model to move the sprite.
     */
    void onTimelineSpriteMoved(Uint8 oldFrameNumber, Uint8 newFrameNumber);

    /**
     * Enables the appropriate gizmo for the selected element.
     */
    void onElementSelected(AnimationElementsWindow::ElementType type);

    /**
     * Styles the given text.
     */
    void styleText(AUI::Text& text);

    /** Used to get the current working dir when displaying the animation. */
    DataModel& dataModel;

    /** Used to get the currently selected list item. */
    LibraryWindow& libraryWindow;

    /** Used to know when the user selects a different element. */
    AnimationElementsWindow& animationElementsWindow;

    /** The active animation's ID. */
    AnimationID activeAnimationID;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Text topText;

    /** Checkerboard image, tiled as the background for the current frame's 
        sprite. */
    AUI::Image checkerboardImage;

    /** The transparent graphic that shows the stage bounds. */
    StageGraphic stageGraphic;

    /** The sprite for the currently selected frame. */
    AUI::Image spriteImage;

    /** The gizmo for editing the animation's bounding box. */
    BoundingBoxGizmo boundingBoxGizmo;

    /** The gizmo for editing the animation's entity alignment anchor. */
    PointGizmo entityAlignmentAnchorGizmo;

    /** Holds the AnimationTimeline so it can be scrolled horizontally. */
    AUI::ScrollArea timelineScrollArea;

    /** The timeline for editing the sprites in the animation. */
    AnimationTimeline* timeline;

    AUI::Text descText;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/AnimationElementsWindow.h`:

```h
#pragma once

#include "AnimationElementsListItem.h"
#include "LibraryItemData.h"
#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include "AUI/Button.h"
#include <functional>

namespace AM
{
struct BoundingBox;

namespace ResourceImporter
{
class MainScreen;
class DataModel;

/**
 * The elements window shown when the user loads an animation from the Library.
 * Allows the user to select an element, and to add or remove elements.
 */
class AnimationElementsWindow : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public definitions
    //-------------------------------------------------------------------------
    /**
     * The types of elements items that we hold in this window.
     */
    enum ElementType {
        BoundingBox,
        EntityAlignmentAnchor,
        Count,
        None
    };

    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    AnimationElementsWindow(MainScreen& inScreen, DataModel& ineDataModel);

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    AnimationElementsListItem boundingBoxListItem;

    AnimationElementsListItem entityAlignmentAnchorListItem;

    //-------------------------------------------------------------------------
    // Callback registration
    //-------------------------------------------------------------------------
    /**
     * @param inOnListItemSelected A callback that expects an enum value of the
     *                             element type that was selected.
     */
    void setOnListItemSelected(
        std::function<void(ElementType)> inOnListItemSelected);

private:
    /**
     * If the new active item is a animation, loads it's data into this window.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * (If ID matches active animation) Updates this window with the active 
     * animation's new properties.
     */
    void onAnimationEntityAlignmentAnchorChanged(
        AnimationID animationID,
        const std::optional<Vector3>& newEntityAlignmentAnchor);

    /**
     * (If active animation was removed) Hides this window.
     */
    void onAnimationRemoved(AnimationID animationID);

    /**
     * Updates this widgets graphical state to match the given anchor state.
     */
    void updateAnchorListItemState(
        const std::optional<Vector3>& entityAlignmentAnchor);

    /** Used to open the confirmation dialog when saving a bounding box. */
    MainScreen& mainScreen;

    /** Used while setting user-inputted animation data. */
    DataModel& dataModel;

    std::function<void(ElementType selectedType)> onListItemSelected;

    /** The active animation's ID. */
    AnimationID activeAnimationID;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Image backgroundImage;

    AUI::Image headerImage;

    AUI::Text windowLabel;

    AUI::Button addEntityAlignmentAnchorButton;

    AUI::Button remEntityAlignmentAnchorButton;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/AnimationPropertiesWindow.h`:

```h
#pragma once

#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include "AUI/Checkbox.h"
#include "MainTextInput.h"
#include "MainButton.h"
#include "LibraryItemData.h"

namespace AM
{
struct BoundingBox;

namespace ResourceImporter
{
class MainScreen;
class DataModel;
class LibraryWindow;
class LibraryListItem;

/**
 * The properties window shown when the user loads an animation from the Library.
 * Allows the user to edit the active animation's properties.
 */
class AnimationPropertiesWindow : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    AnimationPropertiesWindow(MainScreen& inScreen, DataModel& ineDataModel,
                              LibraryWindow& inLibraryWindow);

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** All fields below directly match a data field in the EditorAnimation 
        class. See fields below for more info. */
    AUI::Text nameLabel;
    MainTextInput nameInput;

    AUI::Text frameCountLabel;
    MainTextInput frameCountInput;

    AUI::Text fpsLabel;
    MainTextInput fpsInput;

    AUI::Text loopStartFrameLabel;
    MainTextInput loopStartFrameInput;

    AUI::Text boundingBoxLabel;
    AUI::Text boundingBoxNameLabel;
    MainButton boundingBoxButton;

    AUI::Text minXLabel;
    MainTextInput minXInput;

    AUI::Text minYLabel;
    MainTextInput minYInput;

    AUI::Text minZLabel;
    MainTextInput minZInput;

    AUI::Text maxXLabel;
    MainTextInput maxXInput;

    AUI::Text maxYLabel;
    MainTextInput maxYInput;

    AUI::Text maxZLabel;
    MainTextInput maxZInput;

    AUI::Text collisionEnabledLabel;
    AUI::Checkbox collisionEnabledInput;

    AUI::Text alignXLabel;
    MainTextInput alignXInput;

    AUI::Text alignYLabel;
    MainTextInput alignYInput;

    AUI::Text alignZLabel;
    MainTextInput alignZInput;

private:
    /**
     * If the new active item is a animation, loads it's data into this panel.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * (If ID matches active animation) Updates this panel with the active 
     * animation's new properties.
     */
    void onAnimationDisplayNameChanged(AnimationID animationID,
                                       const std::string& newDisplayName);
    void onAnimationFrameCountChanged(AnimationID animationID,
                                      Uint8 newFrameCount);
    void onAnimationFpsChanged(AnimationID animationID,
                               Uint8 newFps);
    void onAnimationLoopStartFrameChanged(AnimationID animationID,
                                          Uint8 newLoopStartFrame);
    void onAnimationModelBoundsIDChanged(AnimationID animationID,
                                         BoundingBoxID newModelBoundsID);
    void onAnimationCustomModelBoundsChanged(
        AnimationID animationID, const BoundingBox& newCustomModelBounds);
    void onAnimationCollisionEnabledChanged(AnimationID animationID,
                                            bool newCollisionEnabled);
    void onAnimationEntityAlignmentAnchorChanged(
        AnimationID animationID,
        const std::optional<Vector3>& newEntityAlignmentAnchor);

    /**
     * (If active animation was removed) Hides this window.
     */
    void onAnimationRemoved(AnimationID animationID);

    /**
     * Updates boundingBoxButton to show whether the selection is assignable.
     */
    void onLibrarySelectedItemsChanged(
        const std::vector<LibraryListItem*>& selectedItems);

    /**
     * Enables or disables the min/max bounds fields.
     */
    void setBoundsFieldsEnabled(bool isEnabled);

    /** Used to open the confirmation dialog when saving a bounding box. */
    MainScreen& mainScreen;

    /** Used while setting user-inputted animation data. */
    DataModel& dataModel;

    /** Used to get the currently selected list item. */
    LibraryWindow& libraryWindow;

    /** The active animation's ID. */
    AnimationID activeAnimationID;

    /**
     * Converts the given float to a string with 3 decimals of precision.
     */
    std::string toRoundedString(float value);

    /** Handles the context-sensitive bounding box button behavior. */
    void onBoundingBoxButtonPressed();

    /** The below functions are all for validating and saving the user's data
        when the text is committed. */
    void saveFrameCount();
    void saveFps();
    void saveLoopStartFrame();
    void saveMinX();
    void saveMinY();
    void saveMinZ();
    void saveMaxX();
    void saveMaxY();
    void saveMaxZ();
    void saveCollisionEnabled();
    void saveAlignX();
    void saveAlignY();
    void saveAlignZ();

    /** The below floats save the committed values, so we can revert to them
        if the user inputs invalid characters. */
    int committedFrameCount;
    int committedFps;
    int committedLoopStartFrame;
    float committedMinX;
    float committedMinY;
    float committedMinZ;
    float committedMaxX;
    float committedMaxY;
    float committedMaxZ;
    float committedAlignX;
    float committedAlignY;
    float committedAlignZ;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Image backgroundImage;

    AUI::Image headerImage;

    AUI::Text windowLabel;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/BoundingBoxEditView.h`:

```h
#pragma once

#include "LibraryItemData.h"
#include "StageGraphic.h"
#include "BoundingBoxGizmo.h"
#include "MainButton.h"
#include "AUI/Window.h"
#include "AUI/Screen.h"
#include "AUI/Text.h"
#include "AUI/Image.h"

namespace AM
{
namespace ResourceImporter
{
class DataModel;
class LibraryWindow;
class LibraryListItem;

/**
 * The center stage shown when the user loads a bounding box from the Library.
 * Allows the user to edit the bounding box, for use by sprites and animations.
 */
class BoundingBoxEditView : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    BoundingBoxEditView(DataModel& inDataModel,
                         LibraryWindow& inLibraryWindow);

private:
    /**
     * If the new active item is a bounding box, loads it's data onto this stage.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * If the changed box is currently active, updates this stage to reflect 
     * the new data.
     */
    void onBoundingBoxBoundsChanged(BoundingBoxID boundingBoxID,
                                    const BoundingBox& newBounds);

    /**
     * (If active box was removed) Hides this view.
     */
    void onBoundingBoxRemoved(BoundingBoxID boundingBoxID);

    /**
     * Pushes the gizmo's updated bounding box to the model.
     */
    void onGizmoBoundingBoxUpdated(const BoundingBox& updatedBounds);

    /**
     * Styles the given text.
     */
    void styleText(AUI::Text& text);

    /** Used to get the current working dir when displaying graphics. */
    DataModel& dataModel;

    /** Used to get the currently selected list item. */
    LibraryWindow& libraryWindow;

    /** The active bounding box's ID. */
    BoundingBoxID activeBoundingBoxID;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Text topText;
    AUI::Text modifyText;

    /** Checkerboard image, tiled as the background for the loaded sprite. */
    AUI::Image checkerboardImage;

    /** The transparent graphic that shows the stage bounds. */
    StageGraphic stageGraphic;

    /** The preview image that is currently loaded onto the stage, if any. */
    AUI::Image spriteImage;

    /** The gizmo for editing the sprite's bounding box. */
    BoundingBoxGizmo boundingBoxGizmo;

    AUI::Text descText;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/BoundingBoxPropertiesWindow.h`:

```h
#pragma once

#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include "AUI/Checkbox.h"
#include "MainTextInput.h"
#include "MainButton.h"
#include "LibraryItemData.h"

namespace AM
{
struct BoundingBox;

namespace ResourceImporter
{
class DataModel;
class LibraryWindow;

/**
 * The properties window shown when the user loads a bounding box from the 
 * Library.
 * Allows the user to edit the active bounding box's properties.
 */
class BoundingBoxPropertiesWindow : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    BoundingBoxPropertiesWindow(DataModel& ineDataModel,
                                const LibraryWindow& inLibraryWindow);

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** All fields below directly match a data field in the EditorSprite class.
        See displayName, collisionEnabled, and modelBounds fields for more
        information. */
    AUI::Text nameLabel;
    MainTextInput nameInput;

    AUI::Text minXLabel;
    MainTextInput minXInput;

    AUI::Text minYLabel;
    MainTextInput minYInput;

    AUI::Text minZLabel;
    MainTextInput minZInput;

    AUI::Text maxXLabel;
    MainTextInput maxXInput;

    AUI::Text maxYLabel;
    MainTextInput maxYInput;

    AUI::Text maxZLabel;
    MainTextInput maxZInput;

private:
    /**
     * If the new active item is a bounding box, loads it's data into this panel.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * (If active bounding box was removed) Hides this window.
     */
    void onBoundingBoxRemoved(BoundingBoxID boundingBoxID);

    /**
     * (If ID matches active bounding box) Updates this panel with the active 
     * bounding box's new properties.
     */
    void onBoundingBoxDisplayNameChanged(BoundingBoxID boundingBoxID,
                                         const std::string& newDisplayName);
    void onBoundingBoxBoundsChanged(BoundingBoxID boundingBoxID,
                                    const BoundingBox& newBounds);

    /** Used while setting user-inputted sprite data. */
    DataModel& dataModel;

    /** Used to get the currently selected list item. */
    const LibraryWindow& libraryWindow;

    /** The active bounding box's ID. */
    BoundingBoxID activeBoundingBoxID;

    /**
     * Converts the given float to a string with 3 decimals of precision.
     */
    std::string toRoundedString(float value);

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Image backgroundImage;

    AUI::Image headerImage;

    AUI::Text windowLabel;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/EntityGraphicSetEditView.h`:

```h
#pragma once

#include "LibraryItemData.h"
#include "LibraryListItem.h"
#include "GraphicSets.h"
#include "GraphicSetSlot.h"
#include "AUI/Window.h"
#include "AUI/Text.h"
#include "AUI/Image.h"
#include "AUI/VerticalGridContainer.h"

namespace AM
{
namespace ResourceImporter
{
class DataModel;
class LibraryWindow;

/**
 * The center stage shown when the user loads an Entity graphic set.
 *
 * Allows the user to edit the active graphic set's graphic slots.
 *
 * Note: This is separate from GraphicSetEditView because entity graphic sets 
 *       have significant differences from the others.
 */
class EntityGraphicSetEditView : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    EntityGraphicSetEditView(DataModel& inDataModel,
                       const LibraryWindow& inLibraryWindow);

private:
    /**
     * If the new active item is an entity graphic set, loads it's data into 
     * this panel.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * (If ID matches active set) Hides this view.
     */
    void onEntityRemoved(EntityGraphicSetID graphicSetID);

    /**
     * (If ID matches active set) Sets the given graphic type to the given 
     * graphic, adding or removing slot widgets as necessary.
     */
    void onEntitySlotChanged(EntityGraphicSetID graphicSetID,
                             EntityGraphicType graphicType,
                             Rotation::Direction direction,
                             GraphicID newGraphicID);

    /**
     * Attempts to assign the currently selected library item to the 
     * given graphic type's slot.
     */
    void onAssignButtonPressed(EntityGraphicType graphicType,
                               Rotation::Direction direction);

    /**
     * Styles the given text.
     */
    void styleText(AUI::Text& text);

    /**
     * Fills graphicContainer with empty slot widgets for each EntityGraphicType.
     */
    void initGraphicContainer();

    /**
     * Fills the given slot widget with the given graphic's image and name.
     */
    void fillSlotGraphicData(GraphicSetSlot& slot, GraphicID graphicID);

    /**
     * Converts an entity graphic type and rotation into the associated 
     * graphicContainer index.
     */
    std::size_t toIndex(EntityGraphicType graphicType,
                        Rotation::Direction direction);

    /**
     * Iterates all of the engine and project entity graphic types, skipping the 
     * gaps.
     *
     * @param callback A callback of form void(EntityGraphicType).
     *
     * Note: If we ever need this elsewhere, we can move it to 
     *       EntityGraphicType.h.
     */
    template<typename Func>
    void iterateEntityGraphicTypes(Func callback);

    /** Used to get the current working dir when displaying the graphic. */
    DataModel& dataModel;

    /** Used to get the currently selected list item. */
    const LibraryWindow& libraryWindow;

    /** The active graphic set's ID. */
    EntityGraphicSetID activeGraphicSetID;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Text topText;
    AUI::Text modifyText;
    AUI::Text clearText;

    /** Holds a slot for each EntityGraphicType and Rotation::Direction, in 
        order. */
    AUI::VerticalGridContainer graphicContainer;

    AUI::Text descText;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/EntityGraphicSetPropertiesWindow.h`:

```h
#pragma once

#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include "MainTextInput.h"
#include "LibraryItemData.h"
#include "GraphicSets.h"

namespace AM
{
struct BoundingBox;

namespace ResourceImporter
{
class DataModel;

/**
 * The properties window shown when the user loads an Entity graphic set.
 *
 * Allows the user to edit the active graphic set's properties.
 *
 * Note: This is separate from GraphicSetPropertiesWindow because entity 
 *       graphic sets have significant differences from the others.
 */
class EntityGraphicSetPropertiesWindow : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    EntityGraphicSetPropertiesWindow(DataModel& inDataModel);

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** All fields below directly match a data field in the 
        EditorEntityGraphicSet class. */
    AUI::Text nameLabel;
    MainTextInput nameInput;

private:
    /**
     * If the new active item is an entity graphic set, loads it's data into 
     * this window.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * (If ID matches active set) Hides this window.
     */
    void onEntityRemoved(EntityGraphicSetID graphicSetID);

    /**
     * (If ID matches active set) Updates this panel with the active graphic 
     * set's new properties.
     */
    void onEntityDisplayNameChanged(EntityGraphicSetID graphicSetID,
                                    const std::string& newDisplayName);

    /** Used while setting user-inputted graphic set data. */
    DataModel& dataModel;

    /** The active graphic set's ID. */
    EntityGraphicSetID activeGraphicSetID;

    /** The below functions are all for validating and saving the user's data
        when the text is committed. */
    void saveName();

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Image backgroundImage;

    AUI::Image headerImage;

    AUI::Text windowLabel;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/GraphicSetEditView.h`:

```h
#pragma once

#include "LibraryItemData.h"
#include "LibraryListItem.h"
#include "GraphicSets.h"
#include "GraphicSetSlot.h"
#include "AUI/Window.h"
#include "AUI/Text.h"
#include "AUI/Image.h"
#include "AUI/VerticalGridContainer.h"

namespace AM
{
namespace ResourceImporter
{
class DataModel;
class LibraryWindow;

/**
 * The center stage shown when the user loads a Floor, Floor Covering, Wall, 
 * or Object graphic set from the Library. Entity graphic sets use 
 * EntityGraphicSetEditView.
 *
 * Allows the user to edit the active graphic set's graphic slots.
 */
class GraphicSetEditView : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    GraphicSetEditView(DataModel& inDataModel,
                       const LibraryWindow& inLibraryWindow);

private:
    /**
     * If the new active item is a graphic set, loads it's data onto this stage.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * (If type/ID matches active set) Hides this view.
     */
    void onGraphicSetRemoved(GraphicSet::Type type, Uint16 graphicSetID);

    /**
     * (If type/ID matches active set) Sets the given index to the given graphic.
     */
    void onGraphicSetSlotChanged(GraphicSet::Type type, Uint16 graphicSetID,
                                std::size_t index, GraphicID newGraphicID);

    /**
     * Loads the given graphic set's data onto this stage.
     */
    template<typename T>
    void loadActiveGraphicSet(GraphicSet::Type graphicSetType,
                             const T& newActiveGraphicSet);

    /**
     * Attempts to assign the currently selected library item to the 
     * given slot.
     */
    void onAssignButtonPressed(std::size_t slotIndex);

    /**
     * Styles the given text.
     */
    void styleText(AUI::Text& text);

    /**
     * Returns the appropriate top text for the given index.
     */
    std::string getSlotTopText(std::size_t graphicSetIndex);

    /**
     * Fills the given slot widget with the given graphic's image and name.
     */
    void fillSlotGraphicData(GraphicSetSlot& slot, GraphicID graphicID);

    /**
     * Fills the description text widgets with the appropriate strings, based
     * on the current activeGraphicSetType.
     */
    void fillDescriptionTexts();

    /** Used to get the current working dir when displaying the graphic. */
    DataModel& dataModel;

    /** Used to get the currently selected list item. */
    const LibraryWindow& libraryWindow;

    /** The active graphic set's type. */
    GraphicSet::Type activeGraphicSetType;

    /** The active graphic set's ID. */
    Uint16 activeGraphicSetID;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Text topText;
    AUI::Text actionText;

    /** Holds this graphic set's graphics. */
    AUI::VerticalGridContainer graphicContainer;

    AUI::Text descText;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/GraphicSetPropertiesWindow.h`:

```h
#pragma once

#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include "MainTextInput.h"
#include "MainButton.h"
#include "LibraryItemData.h"
#include "GraphicSets.h"

namespace AM
{
struct BoundingBox;

namespace ResourceImporter
{
class DataModel;

/**
 * The properties window shown when the user loads a Floor, Floor Covering, Wall, 
 * or Object graphic set from the Library. Entity graphic sets use 
 * EntityGraphicPropertiesWindow.
 *
 * Allows the user to edit the active graphic set's properties.
 */
class GraphicSetPropertiesWindow : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    GraphicSetPropertiesWindow(DataModel& inDataModel);

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    AUI::Text nameLabel;
    MainTextInput nameInput;

    /** Only used when a Floor graphic set is loaded. */
    MainButton setDefaultGraphicBoundsButton;

private:
    /**
     * If the new active item is a graphic set, loads it's data into this window.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * (If type/ID matches active set) Hides this window.
     */
    void onGraphicSetRemoved(GraphicSet::Type type, Uint16 graphicSetID);

    /**
     * (If type/ID matches active set) Updates this panel with the active
     * graphic set's new properties.
     */
    void onGraphicSetDisplayNameChanged(GraphicSet::Type type, Uint16 graphicSetID,
                                       const std::string& newDisplayName);

    /**
     * Loads the given graphic set's data into this panel.
     */
    template<typename T>
    void loadActiveGraphicSet(GraphicSet::Type graphicSetType,
                             const T& newActiveGraphicSet);

    /**
     * Sets the modelBounds of each sprite in this set to 
     * DEFAULT_FLOOR_SPRITE_BOUNDS.
     * Only used when a Floor graphic set is loaded.
     */
    void onSetDefaultGraphicBoundsButtonPressed();

    /** Used while setting user-inputted graphic set data. */
    DataModel& dataModel;

    /** The active graphic set's type. */
    GraphicSet::Type activeGraphicSetType;

    /** The active graphic set's ID. */
    Uint16 activeGraphicSetID;

    /** The below functions are all for validating and saving the user's data
        when the text is committed. */
    void saveName();

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Image backgroundImage;

    AUI::Image headerImage;

    AUI::Text windowLabel;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/HamburgerButtonWindow.h`:

```h
#pragma once

#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Button.h"

namespace AM
{
namespace ResourceImporter
{
class MainScreen;

/**
 * Holds the "hamburger menu" button at the top of the screen, next to the 
 * properties window.
 *
 * Facilitates file operations like saving the json, or exporting sprite 
 * sheet images.
 */
class HamburgerButtonWindow : public AUI::Window
{
public:
    HamburgerButtonWindow(MainScreen& inScreen);

private:
    /** Used to open the confirmation dialog. */
    MainScreen& mainScreen;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Image backgroundImage;

    AUI::Button hamburgerButton;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/HamburgerMenu.h`:

```h
#pragma once

#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Button.h"

namespace AM
{
namespace ResourceImporter
{

/**
 * A menu that lets the user perform file operations, like saving the json, or 
 * exporting sprite sheet images
 *
 * Opens when you press the hamburger button.
 */
class HamburgerMenu : public AUI::Window
{
public:
    HamburgerMenu();

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** The menu's background */
    AUI::Image backgroundImage;

    AUI::Button saveButton;
    AUI::Button exportButton;

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    void onFocusLost(AUI::FocusLostType focusLostType) override;

private:
    /**
     * Styles the given button and sets its text to the given text.
     */
    void styleButton(AUI::Button& button, const std::string& text);
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/IconEditView.h`:

```h
#pragma once

#include "LibraryItemData.h"
#include "AUI/Window.h"
#include "AUI/Screen.h"
#include "AUI/Text.h"
#include "AUI/Image.h"

namespace AM
{
namespace ResourceImporter
{
class DataModel;

/**
 * The center stage shown when the user loads an icon from the Library.
 */
class IconEditView : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    IconEditView(DataModel& inDataModel);

private:
    /**
     * If the new active item is a icon, loads it's data onto this stage.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * (If active icon was removed) Hides this view.
     */
    void onIconRemoved(IconID iconID);

    /**
     * Styles the given text.
     */
    void styleText(AUI::Text& text);

    /** Used to get the current working dir when displaying the icon. */
    DataModel& dataModel;

    /** The active icon's ID. */
    IconID activeIconID;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Text topText;

    /** Checkerboard image, tiled as the background for the loaded icon. */
    AUI::Image checkerboardImage;

    /** The icon that is currently loaded onto the stage. */
    AUI::Image iconImage;

    AUI::Text descText;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/IconPropertiesWindow.h`:

```h
#pragma once

#include "IconID.h"
#include "MainTextInput.h"
#include "LibraryItemData.h"
#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include "AUI/Checkbox.h"

namespace AM
{
namespace ResourceImporter
{
class DataModel;

/**
 * The properties window shown when the user loads an icon from the Library.
 * Allows the user to edit the active icon's properties.
 */
class IconPropertiesWindow : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    IconPropertiesWindow(DataModel& inDataModel);

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** All fields below directly match a data field in the EditorIcon class.
        See displayName field for more information. */
    AUI::Text nameLabel;
    MainTextInput nameInput;

private:
    /**
     * If the new active item is an icon, loads it's data into this window.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * (If active icon was removed) Hides this window.
     */
    void onIconRemoved(IconID iconID);

    /**
     * (If ID matches active icon) Updates this panel with the active icon's
     * new properties.
     */
    void onIconDisplayNameChanged(IconID iconID,
                                  const std::string& newDisplayName);

    /** Used while setting user-inputted icon data. */
    DataModel& dataModel;

    /** The active icon's ID. */
    IconID activeIconID;

    /** The below functions are all for validating and saving the user's data
        when the text is committed. */
    void saveName();

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Image backgroundImage;

    AUI::Image headerImage;

    AUI::Text windowLabel;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/LibraryAddMenu.h`:

```h
#pragma once

#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Button.h"

namespace AM
{
namespace ResourceImporter
{

/**
 * A menu that lets the user add items to the Library.
 *
 * Opens when you press the Library's "+" button.
 */
class LibraryAddMenu : public AUI::Window
{
public:
    LibraryAddMenu();

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** The menu's background */
    AUI::Image backgroundImage;

    AUI::Button addSpriteSheetButton;
    AUI::Button addTerrainButton;
    AUI::Button addFloorButton;
    AUI::Button addWallButton;
    AUI::Button addObjectButton;
    AUI::Button addEntityButton;
    AUI::Button addIconSheetButton;

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    void onFocusLost(AUI::FocusLostType focusLostType) override;

private:
    /**
     * Styles the given button and sets its text to the given text.
     */
    void styleButton(AUI::Button& button, const std::string& text);
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/LibraryWindow.h`:

```h
#pragma once

#include "LibraryListItem.h"
#include "SpriteSheetID.h"
#include "SpriteID.h"
#include "BoundingBoxID.h"
#include "AnimationID.h"
#include "GraphicSets.h"
#include "IconID.h"
#include "AUI/Window.h"
#include "AUI/Text.h"
#include "AUI/Image.h"
#include "AUI/VerticalListContainer.h"
#include "AUI/Button.h"
#include "entt/signal/sigh.hpp"
#include <unordered_map>

namespace AM
{
namespace ResourceImporter
{
class MainScreen;
class DataModel;
struct EditorSpriteSheet;
struct EditorSprite;
struct EditorAnimation;
struct EditorBoundingBox;
class ParentListItem;
struct EditorTerrainGraphicSet;
struct EditorFloorGraphicSet;
struct EditorWallGraphicSet;
struct EditorObjectGraphicSet;
struct EditorEntityGraphicSet;
struct EditorIconSheet;

/**
 * The left-side panel on the main screen. Allows the user to manage the
 * project's sprite sheets, sprite sets, etc.
 */
class LibraryWindow : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    LibraryWindow(MainScreen& inScreen, DataModel& inDataModel);

    /**
     * Returns the currently selected list items.
     */
    const std::vector<LibraryListItem*>& getSelectedListItems() const;

    //-------------------------------------------------------------------------
    // Base class overrides
    //-------------------------------------------------------------------------
    void onFocusLost(AUI::FocusLostType focusLostType) override;

    AUI::EventResult onKeyDown(SDL_Keycode keyCode) override;

private:
    /**
     * The top-level categories that we have in the library.
     * These values are used to index into libraryContainer.
     */
    enum Category {
        SpriteSheets,
        Animations,
        BoundingBoxes,
        Terrain,
        Floors,
        Walls,
        Objects,
        Entities,
        IconSheets,
        Count,
        None
    };

    /**
     * Adds the given item to the library.
     */
    void onSpriteSheetAdded(SpriteSheetID sheetID,
                            const EditorSpriteSheet& sheet);
    void onSpriteAdded(SpriteID spriteID, const EditorSprite& sprite,
                       SpriteSheetID parentSheetID);
    void onAnimationAdded(AnimationID animationID,
                          const EditorAnimation& animation);
    void onBoundingBoxAdded(BoundingBoxID boundingBoxID,
                            const EditorBoundingBox& bounds);
    void onTerrainAdded(TerrainGraphicSetID terrainID,
                        const EditorTerrainGraphicSet& terrain);
    void onFloorAdded(FloorGraphicSetID floorID,
                      const EditorFloorGraphicSet& floor);
    void onWallAdded(WallGraphicSetID wallID, const EditorWallGraphicSet& wall);
    void onObjectAdded(ObjectGraphicSetID objectID,
                       const EditorObjectGraphicSet& object);
    template<typename T>
    void onGraphicSetAdded(Uint16 graphicSetID, const T& graphicSet);
    void onEntityAdded(EntityGraphicSetID graphicSetID,
                       const EditorEntityGraphicSet& entity);
    void onIconSheetAdded(int sheetID, const EditorIconSheet& sheet);

    /**
     * Removes the given item from the library.
     */
    void onSpriteRemoved(SpriteID spriteID, SpriteSheetID parentSheetID);
    void onSpriteSheetRemoved(SpriteSheetID sheetID);
    void onAnimationRemoved(AnimationID animationID);
    void onBoundingBoxRemoved(BoundingBoxID boundingBoxID);
    void onGraphicSetRemoved(GraphicSet::Type type, Uint16 graphicSetID);
    void onEntityRemoved(EntityGraphicSetID graphicSetID);
    void onIconSheetRemoved(int sheetID);

    /**
     * Updates the display name on the associated list item.
     */
    void onSpriteSheetDisplayNameChanged(SpriteSheetID spriteSheetID,
                                         const std::string& newDisplayName);
    void onSpriteDisplayNameChanged(SpriteID spriteID,
                                    const std::string& newDisplayName);
    void onAnimationDisplayNameChanged(AnimationID animationID,
                                       const std::string& newDisplayName);
    void onBoundingBoxDisplayNameChanged(BoundingBoxID boundingBoxID,
                                         const std::string& newDisplayName);
    void onGraphicSetDisplayNameChanged(GraphicSet::Type type, Uint16 graphicSetID,
                                       const std::string& newDisplayName);
    void onEntityDisplayNameChanged(EntityGraphicSetID graphicSetID,
                                    const std::string& newDisplayName);
    void onIconDisplayNameChanged(IconID iconID,
                                  const std::string& newDisplayName);

    /**
     * Adds the given icon to the given icon sheet list item.
     */
    void addIconToSheetListItem(ParentListItem& sheetListItem,
                                const EditorIconSheet& sheet, IconID iconID);

    /**
     * If there are other currently selected list items, checks if the given
     * list item is compatible with them. If so, adds it to the vector.
     */
    void processSelectedListItem(LibraryListItem* selectedListItem);

    /**
     * If the given list item is selected, removes it from the vector.
     */
    void processDeselectedListItem(LibraryListItem* deselectedListItem);

    /**
     * Removes the given list item widget from the library and all secondary
     * data structures.
     */
    void removeListItem(LibraryListItem* listItem);

    LibraryListItem::Type toListItemType(GraphicSet::Type graphicSetType);
    Category toCategory(GraphicSet::Type graphicSetType);

    /** Used to open the confirmation dialog when removing a sheet. */
    MainScreen& mainScreen;

    /** Used to update the model when a sheet is removed. */
    DataModel& dataModel;

    /** An array of maps, indexed by list item types. Each map holds the
        list items for the associated type, with the associated IDs as keys. */
    std::array<std::unordered_map<int, LibraryListItem*>,
               LibraryListItem::Type::Count>
        listItemMaps;

    /** Holds the currently selected list items. */
    std::vector<LibraryListItem*> selectedListItems;

    /** Holds items that are staged to be removed. */
    std::vector<LibraryListItem*> itemsToRemove;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Image backgroundImage;

    AUI::Image headerImage;

    AUI::Text windowLabel;

    AUI::VerticalListContainer libraryContainer;

    AUI::Button addButton;

    //-------------------------------------------------------------------------
    // Signals
    //-------------------------------------------------------------------------
    entt::sigh<void(const std::vector<LibraryListItem*>& selectedItems)>
        selectedItemsChangedSig;

public:
    //-------------------------------------------------------------------------
    // Signal Sinks
    //-------------------------------------------------------------------------
    /** The list of selected library items has changed. */
    entt::sink<
        entt::sigh<void(const std::vector<LibraryListItem*>& selectedItems)>>
        selectedItemsChanged;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/SaveBoundingBoxDialog.h`:

```h
#pragma once

#include "BoundingBoxID.h"
#include "BoundingBox.h"
#include "MainButton.h"
#include "MainTextInput.h"
#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include <functional>

namespace AM
{
namespace ResourceImporter
{
class DataModel;

/**
 * A confirmation dialog for saving BoundingBoxes to the Library.
 *
 * Opened by using the "Save as" button in the Sprite or Animation properties 
 * panels.
 */
class SaveBoundingBoxDialog : public AUI::Window
{
public:
    SaveBoundingBoxDialog(DataModel& inDataModel);

    virtual ~SaveBoundingBoxDialog() = default;

    /**
     * Sets the model bounds that should be saved when the "Save" button is 
     * pressed, and the callback that should be called afterwards.
     */
    void setSaveData(const BoundingBox& inModelBoundsToSave,
                     const std::function<void(BoundingBoxID)> inSaveCallback);

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** Semi-transparent shadow image to obscure things that are behind the
        dialog. */
    AUI::Image shadowImage;

    /** The dialog's background image. */
    AUI::Image backgroundImage;

    /** The header text at the top of the dialog. */
    AUI::Text headerText;

    // Bounding box name entry
    AUI::Text nameLabel;
    MainTextInput nameInput;

    /** Text that warns the user about overwriting data. */
    AUI::Text descriptionText;

    /** Right-side confirmation button. Saves the bounding box. */
    MainButton saveButton;

    /** Left-side cancel button. Closes the dialog without performing any
        action. */
    MainButton cancelButton;

private:
    /**
     * Clears the text in all of this dialog's text inputs and error text.
     */
    void clear();

    /** Used to update the model when a bounding box is saved. */
    DataModel& dataModel;

    /** The model bounds to save when the "Save" button is pressed. */
    BoundingBox modelBoundsToSave;

    /** The callback that should be called after the bounding box is saved. */
    std::function<void(BoundingBoxID)> saveCallback;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    /** Error text, appears if the user tries to submit an invalid input. */
    AUI::Text errorText;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/SpriteEditView.h`:

```h
#pragma once

#include "LibraryItemData.h"
#include "StageGraphic.h"
#include "BoundingBoxGizmo.h"
#include "AUI/Window.h"
#include "AUI/Screen.h"
#include "AUI/Text.h"
#include "AUI/Image.h"

namespace AM
{
namespace ResourceImporter
{
class DataModel;

/**
 * The center stage shown when the user loads a sprite from the Library.
 * Allows the user to edit the active sprite's bounding box.
 */
class SpriteEditView : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    SpriteEditView(DataModel& inDataModel);

private:
    /**
     * If the new active item is a sprite, loads it's data onto this stage.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * If the changed sprite is currently active, updates this stage to reflect 
     * the new data.
     */
    void onSpriteModelBoundsIDChanged(SpriteID spriteID,
                                      BoundingBoxID newModelBoundsID);
    void onSpriteCustomModelBoundsChanged(
        SpriteID spriteID, const BoundingBox& newCustomModelBounds);
    void onSpriteStageOriginChanged(SpriteID spriteID,
                                    const SDL_Point& newStageOrigin);

    /**
     * (If active sprite was removed) Hides this view.
     */
    void onSpriteRemoved(SpriteID spriteID);

    /**
     * Pushes the gizmo's updated bounding box to the model.
     */
    void onGizmoBoundingBoxUpdated(const BoundingBox& updatedBounds);

    /**
     * Styles the given text.
     */
    void styleText(AUI::Text& text);

    /** Used to get the current working dir when displaying the sprite. */
    DataModel& dataModel;

    /** The active sprite's ID. */
    SpriteID activeSpriteID;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Text topText;

    /** Checkerboard image, tiled as the background for the loaded sprite. */
    AUI::Image checkerboardImage;

    /** The transparent graphic that shows the stage bounds. */
    StageGraphic stageGraphic;

    /** The sprite that is currently loaded onto the stage. */
    AUI::Image spriteImage;

    /** The gizmo for editing the sprite's bounding box. */
    BoundingBoxGizmo boundingBoxGizmo;

    AUI::Text descText;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/SpritePropertiesWindow.h`:

```h
#pragma once

#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Text.h"
#include "AUI/Checkbox.h"
#include "MainTextInput.h"
#include "MainButton.h"
#include "LibraryItemData.h"

namespace AM
{
struct BoundingBox;

namespace ResourceImporter
{
class MainScreen;
class DataModel;
class LibraryWindow;
class LibraryListItem;

/**
 * The properties window shown when the user loads a sprite from the Library.
 * Allows the user to edit the active sprite's properties.
 */
class SpritePropertiesWindow : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    SpritePropertiesWindow(MainScreen& inScreen, DataModel& ineDataModel,
                           LibraryWindow& inLibraryWindow);

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** All fields below directly match a data field in the EditorSprite class.
        See displayName, collisionEnabled, and modelBounds fields for more
        information. */
    AUI::Text nameLabel;
    MainTextInput nameInput;

    AUI::Text boundingBoxLabel;
    AUI::Text boundingBoxNameLabel;
    MainButton boundingBoxButton;

    AUI::Text minXLabel;
    MainTextInput minXInput;

    AUI::Text minYLabel;
    MainTextInput minYInput;

    AUI::Text minZLabel;
    MainTextInput minZInput;

    AUI::Text maxXLabel;
    MainTextInput maxXInput;

    AUI::Text maxYLabel;
    MainTextInput maxYInput;

    AUI::Text maxZLabel;
    MainTextInput maxZInput;

    AUI::Text collisionEnabledLabel;
    AUI::Checkbox collisionEnabledInput;

    AUI::Text stageOriginXLabel;
    MainTextInput stageOriginXInput;

    AUI::Text stageOriginYLabel;
    MainTextInput stageOriginYInput;

    AUI::Text premultiplyAlphaLabel;
    AUI::Checkbox premultiplyAlphaInput;

private:
    /**
     * If the new active item is a sprite, loads it's data into this window.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * (If active sprite was removed) Hides this window.
     */
    void onSpriteRemoved(SpriteID spriteID);

    /**
     * (If ID matches active sprite) Updates this panel with the active sprite's
     * new properties.
     */
    void onSpriteDisplayNameChanged(SpriteID spriteID,
                                    const std::string& newDisplayName);
    void onSpriteModelBoundsIDChanged(SpriteID spriteID,
                                      BoundingBoxID newModelBoundsID);
    void onSpriteCustomModelBoundsChanged(
        SpriteID spriteID, const BoundingBox& newCustomModelBounds);
    void onSpriteCollisionEnabledChanged(SpriteID spriteID,
                                         bool newCollisionEnabled);
    void onSpriteStageOriginChanged(SpriteID spriteID,
                                    const SDL_Point& newStageOrigin);
    void onSpritePremultiplyAlphaChanged(SpriteID spriteID,
                                         bool newPremultiplyAlpha);

    /**
     * Updates boundingBoxButton to show whether the selection is assignable.
     */
    void onLibrarySelectedItemsChanged(
        const std::vector<LibraryListItem*>& selectedItems);

    /**
     * Enables or disables the min/max bounds fields.
     */
    void setBoundsFieldsEnabled(bool isEnabled);

    /** Used to open the confirmation dialog when saving a bounding box. */
    MainScreen& mainScreen;

    /** Used while setting user-inputted sprite data. */
    DataModel& dataModel;

    /** Used to get the currently selected list item. */
    LibraryWindow& libraryWindow;

    /** The active sprite's ID. */
    SpriteID activeSpriteID;

    /**
     * Converts the given float to a string with 3 decimals of precision.
     */
    std::string toRoundedString(float value);

    /** Handles the context-sensitive bounding box button behavior. */
    void onBoundingBoxButtonPressed();

    /** The below functions are all for validating and saving the user's data
        when the text is committed. */
    void saveMinX();
    void saveMinY();
    void saveMinZ();
    void saveMaxX();
    void saveMaxY();
    void saveMaxZ();
    void saveCollisionEnabled();
    void saveStageOriginX();
    void saveStageOriginY();
    void savePremultiplyAlpha();

    /** The below variables save the committed values, so we can revert to them
        if the user inputs invalid characters. */
    float committedMinX;
    float committedMinY;
    float committedMinZ;
    float committedMaxX;
    float committedMaxY;
    float committedMaxZ;
    int committedStageOriginX;
    int committedStageOriginY;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Image backgroundImage;

    AUI::Image headerImage;

    AUI::Text windowLabel;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/SpriteSheetEditView.h`:

```h
#pragma once

#include "LibraryItemData.h"
#include "AUI/Window.h"
#include "AUI/Screen.h"
#include "AUI/Text.h"
#include "AUI/Image.h"

namespace AM
{
namespace ResourceImporter
{
class DataModel;

/**
 * The center stage shown when the user loads a sprite from the Library.
 * Allows the user to edit the active sprite's bounding box.
 */
class SpriteSheetEditView : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    SpriteSheetEditView(DataModel& inDataModel);

private:
    /**
     * If the new active item is a sprite sheet, loads it's data onto this stage.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * (If active sheet was removed) Hides this view.
     */
    void onSheetRemoved(SpriteSheetID parentSheetID);

    /**
     * Adds the sprite to the active sheet and refreshes the texture.
     */
    void onSpriteAdded(SpriteID spriteID, const EditorSprite& sprite,
                       SpriteSheetID parentSheetID);

    /**
     * Removes the sprite from the active sheet and refreshes the texture.
     * (If active sprite was removed) Sets activeSprite to invalid and returns
     * the stage to its default state.
     */
    void onSpriteRemoved(SpriteID spriteID, SpriteSheetID parentSheetID);

    /**
     * Styles the given text.
     */
    void styleText(AUI::Text& text);

    /**
     * Updates spriteSheetImage to match the given sprite sheet.
     */
    void refreshSpriteSheetImage(const EditorSpriteSheet& spriteSheet);

    /** Used to get the current working dir when displaying the sprite sheet. */
    DataModel& dataModel;

    /** The active sprite sheet's ID. */
    SpriteSheetID activeSpriteSheetID;

    /** The maximum extent that spriteSheetImage can take up. */
    const SDL_Rect MAX_SPRITESHEET_IMAGE_EXTENT;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Text topText;

    /** Checkerboard image, tiled as the background for the loaded sheet. */
    AUI::Image checkerboardImage;

    /** The sprite sheet that is currently loaded. */
    AUI::Image spriteSheetImage;

    AUI::Text descText;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/SpriteSheetPropertiesWindow.h`:

```h
#pragma once

#include "SpriteSheetID.h"
#include "MainTextInput.h"
#include "MainButton.h"
#include "LibraryItemData.h"
#include "AUI/Window.h"
#include "AUI/Image.h"
#include "AUI/Text.h"

namespace AM
{
struct BoundingBox;

namespace ResourceImporter
{
class MainScreen;
class DataModel;
class LibraryWindow;

/**
 * The properties window shown when the user loads a sprite from the Library.
 * Allows the user to edit the active sprite's properties.
 */
class SpriteSheetPropertiesWindow : public AUI::Window
{
public:
    //-------------------------------------------------------------------------
    // Public interface
    //-------------------------------------------------------------------------
    SpriteSheetPropertiesWindow(MainScreen& inScreen, DataModel& inDataModel);

    //-------------------------------------------------------------------------
    // Public child widgets
    //-------------------------------------------------------------------------
    /** All fields below directly match a data field in the EditorSprite class.
        See displayName, collisionEnabled, and modelBounds fields for more
        information. */
    AUI::Text nameLabel;
    MainTextInput nameInput;

    MainButton addImagesButton;

private:
    /**
     * If the new active item is a sprite, loads it's data into this window.
     */
    void onActiveLibraryItemChanged(const LibraryItemData& newActiveItem);

    /**
     * (If active sheet was removed) Hides this window.
     */
    void onSheetRemoved(SpriteSheetID parentSheetID);

    /**
     * Opens the sprite image file selector dialog.
     */
    void onAddImagesButtonPressed();

    /** Used to open the confirmation dialog when saving a bounding box. */
    MainScreen& mainScreen;

    /** Used while setting user-inputted sprite data. */
    DataModel& dataModel;

    /** The active sprite sheet's ID. */
    SpriteSheetID activeSpriteSheetID;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Image backgroundImage;

    AUI::Image headerImage;

    AUI::Text windowLabel;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/UserInterface/Public/Windows/TitleWindow.h`:

```h
#pragma once

#include "AUI/Window.h"
#include "AUI/Text.h"
#include "TitleButton.h"

namespace AM
{
namespace ResourceImporter
{
class UserInterface;
class TitleScreen;
class DataModel;

/**
 * The single window for the title screen.
 */
class TitleWindow : public AUI::Window
{
public:
    TitleWindow(UserInterface& inUserInterface, DataModel& inDataModel);

private:
    void onOpenButtonPressed();

    /** Used for switching to the main screen. */
    UserInterface& userInterface;
    /** Used for loading the user-selected file. */
    DataModel& dataModel;

    //-------------------------------------------------------------------------
    // Private child widgets
    //-------------------------------------------------------------------------
    AUI::Text titleText;

    AUI::Text directionText;

    TitleButton openButton;

    AUI::Text errorText;
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/Utility/CMakeLists.txt`:

```txt
target_sources(ResourceImporter
    PRIVATE
        Private/SpriteTools.cpp
    PUBLIC
        Public/SpriteTools.h
)

target_include_directories(ResourceImporter
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ResourceImporter/Utility/Private/SpriteTools.cpp`:

```cpp
#include "SpriteTools.h"
#include "DataModel.h"
#include "EditorSpriteSheet.h"
#include "Position.h"
#include "Transforms.h"
#include "Camera.h"
#include "Log.h"
#include "AUI/Core.h"
#include <SDL_render.h>
#include <SDL_image.h>

namespace AM
{
namespace ResourceImporter
{
BoundingBox 
SpriteTools::calcSpriteStageWorldExtent(const SDL_Rect& spriteImageExtent,
    const SDL_Point& stageOrigin)
{
    // There are 3 options for how we could've sized the stage:
    //   1. Clamp max values to stay within the image bounds (would form an 
    //      irregular shape in-world).
    //   2. Form a world-space axis-aligned box starting at the origin, make it
    //      as large as possible while never leaving the image bounds.
    //   3. Same as #2, but make it oversized so the whole image (below the 
    //      origin) is within the stage.
    // We chose to go with #3, because it lets us use the whole image, and 
    // is easier to implement than #1. The downside is that it lets you draw 
    // boxes that go outside of the image, but that's easy to avoid if you 
    // don't want to.

    // Find the screen-space position of the images bottom corners, relative 
    // to the origin.
    SDL_FPoint bottomLeft{
        static_cast<float>(-1.f * stageOrigin.x),
        static_cast<float>(spriteImageExtent.h - stageOrigin.y)};
    SDL_FPoint bottomRight{
        static_cast<float>(spriteImageExtent.w - stageOrigin.x),
        static_cast<float>(spriteImageExtent.h - stageOrigin.y)};

    // Convert the screen-space points to world space.
    Position worldBottomLeft{Transforms::screenToWorldMinimum(bottomLeft, {})};
    Position worldBottomRight{
        Transforms::screenToWorldMinimum(bottomRight, {})};

    // Calculate the stage's extent from the boundary points.
    BoundingBox stageWorldExtent{{0, 0, 0}, {0, 0, 0}};
    stageWorldExtent.max.x = worldBottomRight.x;
    stageWorldExtent.max.y = worldBottomLeft.y;
    // Z must span from the lowest point on the screen (maxX, maxY, 0), to 
    // the top of the image.
    float originToMaxY{Transforms::worldToScreen(
        {worldBottomRight.x, worldBottomLeft.y, 0}, 1.f).y};
    stageWorldExtent.max.z = Transforms::screenYToWorldZ(
        (static_cast<float>(stageOrigin.y) + originToMaxY), 1.0);

    return stageWorldExtent;
}

SDL_Texture* SpriteTools::generateSpriteSheetTexture(
    const DataModel& dataModel, const EditorSpriteSheet& spriteSheet)
{
    // Create an empty texture to hold the sprite sheet.
    // Note: We check that ARGB8888 is supported in SpriteModel.
    SDL_RendererInfo info{};
    SDL_GetRendererInfo(AUI::Core::getRenderer(), &info);
    SDL_Texture* spriteSheetTexture{
        SDL_CreateTexture(AUI::Core::getRenderer(), SDL_PIXELFORMAT_ARGB8888,
                          SDL_TEXTUREACCESS_TARGET, spriteSheet.textureWidth,
                          spriteSheet.textureHeight)};

    // Set the blend mode (default is NONE, which causes black backgrounds).
    SDL_SetTextureBlendMode(spriteSheetTexture, SDL_BLENDMODE_BLEND);

    // Set the texture as the render target.
    SDL_Texture* previousRenderTarget{
        SDL_GetRenderTarget(AUI::Core::getRenderer())};
    SDL_SetRenderTarget(AUI::Core::getRenderer(), spriteSheetTexture);

    // Copy all of the sprites into the sprite sheet texture.
    std::string fullImagePath{};
    for (SpriteID spriteID : spriteSheet.spriteIDs) {
        const EditorSprite& sprite{dataModel.spriteModel.getSprite(spriteID)};

        // Load the sprite's texture.
        fullImagePath = dataModel.getWorkingIndividualSpritesDir();
        fullImagePath += sprite.imagePath;
        SDL_Texture* spriteTexture{};
        if (sprite.premultiplyAlpha) {
            spriteTexture
                = loadAndPremultiplyTexture(fullImagePath);
        }
        else {
            spriteTexture = IMG_LoadTexture(AUI::Core::getRenderer(),
                                            fullImagePath.c_str());
        }

        if (!spriteTexture) {
            LOG_INFO("Failed to load texture: %s", fullImagePath.c_str());
            break;
        }

        // Disable blending, so the sprite's pixels are copied exactly as-is.
        SDL_SetTextureBlendMode(spriteTexture, SDL_BLENDMODE_NONE);

        // Copy the sprite into the sheet texture;
        SDL_Rect sourceRect{0, 0, sprite.textureExtent.w,
                            sprite.textureExtent.h};
        SDL_RenderCopy(AUI::Core::getRenderer(), spriteTexture, &sourceRect,
                       &(sprite.textureExtent));

        // Clean up the sprite texture.
        SDL_DestroyTexture(spriteTexture);
    }

    // Set the render target back to what it was.
    SDL_SetRenderTarget(AUI::Core::getRenderer(), previousRenderTarget);

    return spriteSheetTexture;
}

SDL_Texture*
    SpriteTools::loadAndPremultiplyTexture(const std::string& fullImagePath)
{
    // Load the image as a surface so we can manipulate it.
    SDL_Surface* spriteSurface{IMG_Load(fullImagePath.c_str())};
    if (!spriteSurface) {
        return nullptr;
    }

    // If the surface isn't ARGB8888, convert it.
    if (spriteSurface->format->format != SDL_PIXELFORMAT_ARGB8888) {
        SDL_Surface* newSurface{SDL_ConvertSurfaceFormat(
            spriteSurface, SDL_PIXELFORMAT_ARGB8888, 0)};
        SDL_FreeSurface(spriteSurface);
        spriteSurface = newSurface;
    }

    // Premultiply the alpha channel into the color channels.
    int pitch{spriteSurface->w * 4};
    if (SDL_PremultiplyAlpha(spriteSurface->w, spriteSurface->h,
                             SDL_PIXELFORMAT_ARGB8888, spriteSurface->pixels,
                             pitch, SDL_PIXELFORMAT_ARGB8888,
                             spriteSurface->pixels, pitch)
        != 0) {
        LOG_INFO("Error while premultiplying alpha: %s", SDL_GetError());
    }

    // Turn the surface into a texture and return it.
    SDL_Texture* spriteTexture{
        SDL_CreateTextureFromSurface(AUI::Core::getRenderer(), spriteSurface)};
    SDL_FreeSurface(spriteSurface);
    return spriteTexture;
}

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ResourceImporter/Utility/Public/SpriteTools.h`:

```h
#pragma once

#include "BoundingBox.h"
#include <SDL_rect.h>

struct SDL_Texture;

namespace AM
{
namespace ResourceImporter
{
class DataModel;
struct EditorSpriteSheet;

/**
 * Helper functions for working with sprite images.
 */
class SpriteTools 
{
public:
    /**
     * Calculates the world-space stage for the given sprite image.
     * The stage's origin will align with the given screen-space origin.
     *
     * Note: spriteImageExtent and stageOrigin should be the native values, 
     *       without any scaling.
     */
    static BoundingBox
        calcSpriteStageWorldExtent(const SDL_Rect& spriteImageExtent,
                                   const SDL_Point& stageOrigin);

    /**
     * Generates a sprite sheet texture containing all of the sheet's sprites, 
     * placed at their current textureExtents.
     */
    static SDL_Texture*
        generateSpriteSheetTexture(const DataModel& dataModel,
                                   const EditorSpriteSheet& spriteSheet);

private:
    /**
     * Attempts to load the image at the given path. If successful, 
     * premultiplies its alpha and returns it.
     *
     * Note: The given image must have straight-multiplied alpha. If it's 
     *       already premultiplied, this will do it again.
     *
     * @return A valid texture if successful, else nullptr (loading failed).
     */
    static SDL_Texture*
        loadAndPremultiplyTexture(const std::string& fullImagePath);
};

} // End namespace ResourceImporter
} // End namespace AM

```

`Source/ServerLib/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

message(STATUS "Configuring Amalgam Engine Server Library")

# Add our static library target.
add_library(ServerLib STATIC "")

# Provide an alias that can be used whether the target comes from 
# add_subdirectory() or find_package().
add_library(AmalgamEngine::ServerLib ALIAS ServerLib)

target_include_directories(ServerLib
    PUBLIC
        ${SDL2_INCLUDE_DIRS} ${SDL2_IMAGE_INCLUDE_DIRS} 
        ${SDL2_MIXER_INCLUDE_DIRS} ${SDL2_TTF_INCLUDE_DIRS}
        ${SDL2PP_INCLUDE_DIRS}
)

# Inherit Shared's precompiled header.
# CMake causes issues when using precompiled headers with GCC on macOS,
# so precompiled headers are disabled for that target.
if ((NOT APPLE) OR (CMAKE_CXX_COMPILER_ID MATCHES "Clang|AppleClang"))
    target_precompile_headers(ServerLib REUSE_FROM SharedLib)
endif()

target_link_libraries(ServerLib
    PUBLIC
        ${SDL2_LIBRARIES} ${SDL2_IMAGE_LIBRARIES}
        ${SDL2_MIXER_LIBRARIES} ${SDL2_TTF_LIBRARIES}
        ${SDL2PP_LIBRARIES}
        SDL2_net-static
        boost_mp11
        Bitsery::bitsery
        readerwriterqueue
        CircularBuffer
        EnTT::EnTT
        Lua
        sol2::sol2
        SQLiteCpp
        sqlite3
        QueuedEvents
        SharedLib
        Tracy::TracyClient
)

# Compile with C++23.
target_compile_features(ServerLib PRIVATE cxx_std_23)
set_target_properties(ServerLib PROPERTIES CXX_EXTENSIONS OFF)

# Enable compile warnings.
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    target_compile_options(ServerLib PUBLIC -Wall -Wextra)
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    target_compile_options(ServerLib PUBLIC /W3 /permissive-)
endif()

# Build all of the subdirectories.
add_subdirectory(Config)
add_subdirectory(Launch)
add_subdirectory(Network)
add_subdirectory(Simulation)

```

`Source/ServerLib/Config/CMakeLists.txt`:

```txt
target_sources(ServerLib
    PRIVATE
        Private/UserConfig.cpp
        Private/UserConfigInitializer.cpp
    PUBLIC
        Public/UserConfig.h
        Public/UserConfigInitializer.h
)

target_include_directories(ServerLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ServerLib/Config/Private/UserConfig.cpp`:

```cpp
#include "UserConfig.h"
#include "Paths.h"
#include "Log.h"
#include "nlohmann/json.hpp"
#include <string>
#include <fstream>

namespace AM
{
namespace Server
{

UserConfig::UserConfig()
{
    // Open the file.
    std::string fullPath{Paths::BASE_PATH};
    fullPath += "UserConfig.json";
    std::ifstream workingFile(fullPath);
    if (!(workingFile.is_open())) {
        LOG_FATAL("Failed to open UserConfig.json");
    }

    // Parse the file into a json structure.
    nlohmann::json json;
    try {
        json = nlohmann::json::parse(workingFile, nullptr, true, true);
    } catch (nlohmann::json::exception& e) {
        LOG_FATAL("Failed to parse UserConfig.json: %s", e.what());
    }

    // Initialize our members.
    try {
        init(json);
    } catch (nlohmann::json::exception& e) {
        LOG_FATAL("%s", e.what());
    }
}

UserConfig& UserConfig::get()
{
    static UserConfig userConfig;
    return userConfig;
}

void UserConfig::init([[maybe_unused]] nlohmann::json& json) {}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Config/Private/UserConfigInitializer.cpp`:

```cpp
#include "UserConfigInitializer.h"
#include "UserConfig.h"

namespace AM
{
namespace Server
{
UserConfigInitializer::UserConfigInitializer()
{
    UserConfig::get();
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Config/Public/UserConfig.h`:

```h
#pragma once

#include "nlohmann/json_fwd.hpp"

namespace AM
{
namespace Server
{
/**
 * A singleton instance that loads the user-defined configuration from
 * UserConfig.json into memory and provides an interface for accessing and
 * modifying it.
 *
 * Note: This class expects a UserConfig.json file to be present in the same
 *       directory as the application executable.
 *
 * TODO: If we eventually decide to live-refresh some of these fields, we can
 *       add signals that get emitted on change.
 *       E.g.:
 *           Public
 *               entt::sigh<void(ScreenRect)> windowSizeChanged;
 *           Private
 *               entt::sink<void(ScreenRect)> windowSizeSink;
 */
class UserConfig
{
public:
    /**
     * @pre SDL must be initialized.
     */
    UserConfig();

    /**
     * Returns the singleton instance.
     */
    static UserConfig& get();

    //-------------------------------------------------------------------------
    // Configuration Interface
    //-------------------------------------------------------------------------

private:
    /**
     * Initializes our members using the given json.
     * @throw nlohmann::json::exception if an expected field is not found.
     */
    void init(nlohmann::json& json);
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Config/Public/UserConfigInitializer.h`:

```h
#pragma once

namespace AM
{
namespace Server
{
/**
 * Minimal helper class to facilitate calling UserConfig::get() from an
 * initializer list.
 */
class UserConfigInitializer
{
public:
    UserConfigInitializer();
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Launch/CMakeLists.txt`:

```txt
target_sources(ServerLib
    PRIVATE
		Private/Application.cpp
    PUBLIC
		Public/Application.h
)

target_include_directories(ServerLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ServerLib/Launch/Private/Application.cpp`:

```cpp
#include "Application.h"
#include "SharedConfig.h"
#include "Log.h"

#include "tracy/Tracy.hpp"
#include <functional>
#include <string>
#include <iostream>

namespace AM
{
namespace Server
{
Application::Application()
: sdl{0}
, sdlNet{}
, networkEventDispatcher{}
, userConfigInitializer{}
, resourceData{}
, graphicData{resourceData.get()}
, iconData{resourceData.get()}
, itemData{}
, castableData{graphicData}
, messageProcessorContext{networkEventDispatcher}
, network{messageProcessorContext}
, simulationContext{simulation,  network,  networkEventDispatcher,
                    graphicData, iconData, itemData,
                    castableData}
, simulation{simulationContext}
, networkCaller{std::bind_front(&Network::tick, &network),
                SharedConfig::SERVER_NETWORK_TICK_TIMESTEP_S, "Network", true}
, simCaller{std::bind_front(&Simulation::tick, &simulation),
            SharedConfig::SIM_TICK_TIMESTEP_S, "Sim", false}
, exitRequested{false}
{
    // Initialize the global timer.
    Timer::getGlobalTime();

    // Enable delay reporting.
    simCaller.reportDelays(Simulation::SIM_DELAYED_TIME_S);
}

void Application::start()
{
    tracy::SetThreadName("ServerMain");

    // If any of the extensions aren't registered, exit early.
    if (!messageProcessorExtension || !simulationExtension) {
        LOG_FATAL("All extensions must be registered before calling start()");
    }

    LOG_INFO("Starting main loop.");

    // Prime the timers so they don't start at 0.
    simCaller.initTimer();
    networkCaller.initTimer();
    while (!exitRequested) {
        // Let the simulation process an iteration if it needs to.
        simCaller.update();

        // Send any queued messages, if necessary.
        networkCaller.update();

        // See if we have enough time left to sleep.
        double simTimeLeft{simCaller.getTimeTillNextCall()};
        double networkTimeLeft{networkCaller.getTimeTillNextCall()};
        if ((simTimeLeft > SLEEP_MINIMUM_TIME_S)
            && (networkTimeLeft > SLEEP_MINIMUM_TIME_S)) {
            // We have enough time to sleep for a few ms.
            // Note: We try to delay for 1ms because the OS will generally end
            //       up delaying us for 1-3ms.
            SDL_Delay(1);
        }
    }
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Launch/Public/Application.h`:

```h
#pragma once

#include "UserConfigInitializer.h"
#include "Network.h"
#include "Simulation.h"
#include "ResourceData.h"
#include "GraphicData.h"
#include "IconData.h"
#include "ItemData.h"
#include "CastableData.h"
#include "PeriodicCaller.h"
#include "IMessageProcessorExtension.h"
#include "MessageProcessorContext.h"
#include "ISimulationExtension.h"
#include "SimulationContext.h"

#include "entt/signal/dispatcher.hpp"

#include "SDL_Wrappers/SDL.h"
#include "SDL_Wrappers/SDLNet.h"

#include <atomic>
#include <thread>

namespace AM
{
namespace Server
{
/**
 * The start of all server application activity. Owns all of the application's
 * modules (Simulation, Network, etc).
 *
 * Also manages the main thread's loop, calling each module's update function
 * when appropriate.
 */
class Application
{
public:
    Application();

    /**
     * Begins the application. Assumes control of the thread until the
     * application exits.
     */
    void start();

    //-------------------------------------------------------------------------
    // Engine Extension Registration
    //-------------------------------------------------------------------------
    /**
     * Registers an extension class to be called by the MessageProcessor.
     *
     * Note: The extension class type T must derive from
     *       IMessageProcessorExtension and must implement a constructor of
     *       the form T(MessageProcessorExDependencies).
     */
    template<typename T>
    void registerMessageProcessorExtension();

    /**
     * Registers an extension class to be called by the Simulation.
     *
     * Note: The extension class type T must derive from ISimulationExtension
     *       and must implement a constructor of the form
     *       T(SimulationExDependencies).
     */
    template<typename T>
    void registerSimulationExtension();

private:
    /** The minimum "time to next call" required to trigger a main loop sleep.
        We sleep for 1ms when possible to reduce our CPU usage. We can't trust
        the scheduler to come back to us after exactly 1ms though, so we busy
        wait if something needs to be called soon.
        Higher value == more CPU usage. */
    static constexpr double SLEEP_MINIMUM_TIME_S{.003};

    //-------------------------------------------------------------------------
    // SDL Objects
    //-------------------------------------------------------------------------
    SDL sdl;

    SDLNet sdlNet;

    //-------------------------------------------------------------------------
    // Event Busses
    //-------------------------------------------------------------------------
    /** Used for Network -> Sim message events. */
    EventDispatcher networkEventDispatcher;

    //-------------------------------------------------------------------------
    // Data, Modules, Contexts
    //-------------------------------------------------------------------------
    UserConfigInitializer userConfigInitializer;

    ResourceData resourceData;
    GraphicData graphicData;
    IconData iconData;
    ItemData itemData;
    CastableData castableData;

    MessageProcessorContext messageProcessorContext;
    Network network;

    SimulationContext simulationContext;
    Simulation simulation;

    //-------------------------------------------------------------------------
    // PeriodicCallers
    //-------------------------------------------------------------------------
    /** Calls network.tick() at the network tick rate. */
    PeriodicCaller networkCaller;

    /** Calls simulation.tick() at the sim tick rate. */
    PeriodicCaller simCaller;

    //-------------------------------------------------------------------------
    // Module Extensions
    //-------------------------------------------------------------------------
    /** Contains the project's extension functions.
        Allows the project to provide code and have it be called at the 
        appropriate time.
        Note: This class guarantees that these extensions will be set and non-
              null before the loop starts running. This means we don't need to 
              null check the extension pointers in any class. */
    std::unique_ptr<IMessageProcessorExtension> messageProcessorExtension;
    std::unique_ptr<ISimulationExtension> simulationExtension;

    //-------------------------------------------------------------------------
    // Additional, used during the loop
    //-------------------------------------------------------------------------
    /** Flags when to end the application. */
    std::atomic<bool> exitRequested;
};

template<typename T>
void Application::registerMessageProcessorExtension()
{
    messageProcessorExtension = std::make_unique<T>(messageProcessorContext);
    network.setMessageProcessorExtension(messageProcessorExtension.get());
}

template<typename T>
void Application::registerSimulationExtension()
{
    simulationExtension = std::make_unique<T>(simulationContext);
    simulation.setExtension(simulationExtension.get());
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Network/CMakeLists.txt`:

```txt
target_sources(ServerLib
    PRIVATE
        Private/Client.cpp
        Private/ClientHandler.cpp
        Private/MessageProcessor.cpp
        Private/Network.cpp
    PUBLIC
        Public/Client.h
        Public/ClientMap.h
        Public/ClientConnectionEvent.h
        Public/ClientHandler.h
        Public/IMessageProcessorExtension.h
        Public/MessageProcessor.h
        Public/MessageProcessorContext.h
        Public/Network.h
)

target_include_directories(ServerLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/ServerLib/Network/Private/Client.cpp`:

```cpp
#include "Client.h"
#include "Peer.h"
#include "Log.h"
#include "ByteTools.h"
#include "ExplicitConfirmation.h"
#include "Serialize.h"
#include "NetworkStats.h"
#include "AMAssert.h"
#include <cmath>
#include <array>

namespace AM
{
namespace Server
{
BinaryBuffer Client::batchBuffer(SharedConfig::MAX_BATCH_SIZE);
// No default size since it's dynamically enlarged if too small.
BinaryBuffer Client::compressedBatchBuffer{};
BinaryBuffer Client::smallReceiveBuffer(ETHERNET_MTU);
Client::LargeBufferPool Client::bufferPool{};

Client::Client(NetworkID inNetID, std::unique_ptr<Peer> inPeer)
: netID{inNetID}
, peer{std::move(inPeer)}
, receiveTimer{}
, latestSentSimTick{0}
, tickDiffHistory{Config::TICKDIFF_TARGET}
, numFreshDiffs{0}
, latestAdjIteration{0}
{
}

bool Client::isConnected()
{
    // If we timed out, drop the connection.
    double delta{receiveTimer.getTime()};
    if (delta > Config::CLIENT_TIMEOUT_S) {
        peer = nullptr;
        LOG_INFO("Dropped connection, peer timed out. Time since last "
                 "message: %.6f seconds. Timeout: %.6f, NetID: %u",
                 delta, Config::CLIENT_TIMEOUT_S, netID);
        return false;
    }

    // Peer might've been force-disconnected by dropping the pointer above.
    // It also could have internally detected a client-initiated disconnect.
    return (peer == nullptr) ? false : peer->isConnected();
}

void Client::queueMessage(const BinaryBufferSharedPtr& message,
                          Uint32 messageTick)
{
    [[maybe_unused]] bool emplaceSucceeded{
        sendQueue.emplace(message, messageTick)};
    AM_ASSERT(emplaceSucceeded, "Queue emplace failed.");
}

NetworkResult Client::sendWaitingMessages(Uint32 currentTick)
{
    if (peer == nullptr) {
        return NetworkResult::Disconnected;
    }

    // If we have no messages to send, return early.
    std::size_t messageCount{getWaitingMessageCount()};
    if ((latestSentSimTick == 0) && (messageCount == 0)) {
        return NetworkResult::Success;
    }

    // Copy any waiting messages into the buffer.
    std::size_t currentIndex{ServerHeaderIndex::MessageHeaderStart};
    for (std::size_t i = 0; i < messageCount; ++i) {
        // Pop the message.
        QueuedMessage queuedMessage;
        [[maybe_unused]] bool dequeueSucceeded{
            sendQueue.try_dequeue(queuedMessage)};
        AM_ASSERT(dequeueSucceeded, "Expected element but dequeue failed.");

        // If the message would make the batch too large, error.
        std::size_t messageSize{queuedMessage.message->size()};
        AM_ASSERT(
            ((currentIndex + messageSize) <= SharedConfig::MAX_BATCH_SIZE),
            "Batch too large to fit into buffers. Increase MAX_BATCH_SIZE. "
            "Size: %u, Max: %u",
            (currentIndex + messageSize), SharedConfig::MAX_BATCH_SIZE);

        // Copy the message data into the batchBuffer.
        std::copy(queuedMessage.message->begin(), queuedMessage.message->end(),
                  &(batchBuffer[currentIndex]));

        // Increment the index.
        currentIndex += messageSize;

        // Track the latest tick we've sent.
        if (queuedMessage.tick != 0) {
            latestSentSimTick = queuedMessage.tick;
        }
    }

    // If we've started talking to this client and none of this batch's
    // messages confirm the latest tick, add an explicit confirmation message.
    if ((latestSentSimTick != 0) && (latestSentSimTick < (currentTick - 1))) {
        addExplicitConfirmation(currentIndex, currentTick);
    }

    // If the batch + header is too large, error.
    AM_ASSERT((currentIndex <= SharedConfig::MAX_BATCH_SIZE),
              "Batch too large to fit into buffer. Increase MAX_BATCH_SIZE. "
              "Size: %u, Max: %u",
              currentIndex, SharedConfig::MAX_BATCH_SIZE);

    // If we have a large enough payload, compress it.
    std::size_t batchSize{currentIndex - SERVER_HEADER_SIZE};
    Uint8* bufferToSend{&(batchBuffer[0])};
    bool isCompressed{false};
    if (batchSize > SharedConfig::BATCH_COMPRESSION_THRESHOLD) {
        batchSize = compressBatch(batchSize);

        isCompressed = true;

        // Use the compressed buffer.
        bufferToSend = &(compressedBatchBuffer[0]);
    }

    // Fill in the header.
    fillHeader(bufferToSend, static_cast<Uint16>(batchSize), isCompressed);

    // Record the number of sent bytes.
    std::size_t totalSize{SERVER_HEADER_SIZE + batchSize};
    NetworkStats::recordBytesSent(totalSize);

    // Send the header and batch.
    std::size_t sendIndex{0};
    NetworkResult result{NetworkResult::Success};
    while (sendIndex < totalSize) {
        // Calc how many bytes we have left to send.
        std::size_t bytesToSend{totalSize - sendIndex};

        // Only send up to ETHERNET_MTU bytes per send() call.
        if (bytesToSend > ETHERNET_MTU) {
            bytesToSend = ETHERNET_MTU;
        }

        // Send the bytes.
        result = peer->send((bufferToSend + sendIndex), bytesToSend);
        if (result == NetworkResult::Disconnected) {
            break;
        }

        sendIndex += bytesToSend;
    }

    return result;
}

bool Client::dataIsReady()
{
    // Note: ClientHandler always checks all sockets before calling this.
    return peer->isReady(false);
}

Client::ReceiveResult Client::receiveMessage()
{
    if (peer == nullptr) {
        return {NetworkResult::Disconnected};
    }

    // If we previously returned a large buffer, release it.
    if (largeReceiveBuffer && (compositionIndex == messageSize)) {
        bufferPool.release(std::move(largeReceiveBuffer));
    }

    // If we aren't currently composing a message, start receiving a new
    // message.
    Uint8* bufferToUse{nullptr};
    if (!largeReceiveBuffer) {
        // Receive the client header and message header.
        Uint8 headerBuf[CLIENT_HEADER_SIZE + MESSAGE_HEADER_SIZE];
        int bytesReceived{peer->receiveBytesWait(
            headerBuf, CLIENT_HEADER_SIZE + MESSAGE_HEADER_SIZE)};
        if (bytesReceived < 0) {
            return {NetworkResult::Disconnected};
        }

        // Process the adjustment iteration.
        Uint8 receivedAdjIteration{
            headerBuf[ClientHeaderIndex::AdjustmentIteration]};
        Uint8 expectedNextIteration{static_cast<Uint8>(latestAdjIteration + 1)};

        // If we received the next expected iteration, save it.
        if (receivedAdjIteration == expectedNextIteration) {
            latestAdjIteration = expectedNextIteration;
            numFreshDiffs = 0;
        }
        AM_ASSERT(receivedAdjIteration <= expectedNextIteration,
                  "Skipped an adjustment iteration. Logic must be flawed.");

        // Save the message type and size.
        messageType = headerBuf[CLIENT_HEADER_SIZE +
        MessageHeaderIndex::MessageType];
        messageSize = ByteTools::read16(&(headerBuf[CLIENT_HEADER_SIZE +
            MessageHeaderIndex::Size]));
        AM_ASSERT(messageSize <= CLIENT_MAX_MESSAGE_SIZE,
                  "Tried to receive too large of a message. messageSize: %u, "
                  "CLIENT_MAX_MESSAGE_SIZE: %u",
                  messageSize, CLIENT_MAX_MESSAGE_SIZE);
        if (messageSize == 0) {
            // We're receiving a "tag message" (0 bytes, type only).
            return {NetworkResult::Success, messageType};
        }

        // Init our state machine.
        compositionIndex = 0;
        if (messageSize <= CLIENT_MAX_SMALL_MESSAGE_SIZE) {
            // Small message, guaranteed to receive all at once.
            bufferToUse = smallReceiveBuffer.data();
        }
        else {
            // Large message, we may not receive it all at once. Acquire a 
            // buffer to compose in.
            largeReceiveBuffer = bufferPool.acquire();
            bufferToUse = largeReceiveBuffer->data();
        }
    }

    // Either start receiving the new message, or continue receiving the ongoing
    // large message.
    int bytesRemaining{messageSize - compositionIndex};
    int bytesReceived{
        peer->receiveBytesWait(bufferToUse + compositionIndex, bytesRemaining)};
    if (bytesReceived >= 0) {
        receiveTimer.reset();
    }
    else {
        return {NetworkResult::Disconnected};
    }

    compositionIndex += bytesReceived;

    // If the message is complete, return it.
    if (compositionIndex == messageSize) {
        NetworkStats::recordBytesReceived(CLIENT_HEADER_SIZE
                                          + MESSAGE_HEADER_SIZE + messageSize);
        return {NetworkResult::Success, messageType, {bufferToUse, messageSize}};
    }

    return {NetworkResult::MessageNotComplete};
}

void Client::recordTickDiff(Sint64 tickDiff)
{
    // Acquire a lock so a getTickAdjustment() doesn't start while we're
    // pushing.
    std::unique_lock lock(tickDiffMutex);

    // Add the new data.
    if ((tickDiff >= Config::TICKDIFF_MAX_BOUND_LOWER)
        && (tickDiff <= Config::TICKDIFF_MAX_BOUND_UPPER)) {
        tickDiffHistory.push(static_cast<Sint8>(tickDiff));
    }
    else {
        // Tickdiff out of max range, drop the connection.
        peer = nullptr;
        LOG_INFO("Dropped connection, tickDiff out of range. tickDiff: %d, "
                 "NetID: %u",
                 tickDiff, netID);
        return;
    }

    // Note: This is safe, only this thread modifies numFreshDiffs.
    if (numFreshDiffs < Config::TICKDIFF_HISTORY_LENGTH) {
        numFreshDiffs++;
    }
}

NetworkID Client::getNetID()
{
    return netID;
}

void Client::addExplicitConfirmation(std::size_t& currentIndex,
                                     Uint32 currentTick)
{
    /* Add the ExplicitConfirmation to the batch.
       Note: We add it by hand instead of using the normal functions because
             they're meant for queueing messages and this is post-queue. */

    // Write the message type.
    batchBuffer[currentIndex]
        = static_cast<Uint8>(EngineMessageType::ExplicitConfirmation);
    currentIndex++;

    // Write the message size.
    ByteTools::write16(1, &(batchBuffer[currentIndex]));
    currentIndex += 2;

    // Calc the number of ticks we've processed since the last update.
    // (the tick count increments at the end of a sim tick, so our latest
    //  sent data is from currentTick - 1).
    std::size_t confirmedTickCount{(currentTick - 1) - latestSentSimTick};
    AM_ASSERT(confirmedTickCount <= UINT8_MAX, "Count too large for Uint8.");

    // Write the explicit confirmation message.
    ExplicitConfirmation explicitConfirmation{
        static_cast<Uint8>(confirmedTickCount)};
    currentIndex += static_cast<std::size_t>(
        Serialize::toBuffer(batchBuffer.data(), batchBuffer.size(),
                            explicitConfirmation, currentIndex));

    // Update our latestSent tracking to account for the confirmed ticks.
    latestSentSimTick += static_cast<Uint32>(confirmedTickCount);
}

std::size_t Client::compressBatch(std::size_t batchSize)
{
    // If the destination buffer is too small, resize it.
    std::size_t compressBound{ByteTools::compressBound(batchSize)};
    if (compressedBatchBuffer.size() < compressBound) {
        compressedBatchBuffer.resize(compressBound);
    }

    // Compress the batch.
    std::size_t compressedBatchSize{
        static_cast<std::size_t>(ByteTools::compress(
            &(batchBuffer[ServerHeaderIndex::MessageHeaderStart]), batchSize,
            &(compressedBatchBuffer[ServerHeaderIndex::MessageHeaderStart]),
            compressedBatchBuffer.size()))};
    AM_ASSERT((compressedBatchSize <= MAX_BATCH_WIRE_SIZE),
              "Batch too large, even after compression. Size: %u",
              compressedBatchSize);

    return compressedBatchSize;
}

void Client::fillHeader(Uint8* bufferToFill, Uint16 batchSize,
                        bool isCompressed)
{
    // Fill in the header adjustment info.
    AdjustmentData tickAdjustment{getTickAdjustment()};
    bufferToFill[ServerHeaderIndex::TickAdjustment]
        = static_cast<Uint8>(tickAdjustment.adjustment);
    bufferToFill[ServerHeaderIndex::AdjustmentIteration]
        = tickAdjustment.iteration;

    // If the payload is compressed, set the high bit.
    if (isCompressed) {
        batchSize |= (1U << 15);
    }

    // Fill in the compressed batch size.
    ByteTools::write16(batchSize,
                       &(bufferToFill[ServerHeaderIndex::BatchSize]));
}

std::size_t Client::getWaitingMessageCount() const
{
    return sendQueue.size_approx();
}

Client::AdjustmentData Client::getTickAdjustment()
{
    // Copy the history so we can work on it without staying locked.
    std::unique_lock lock(tickDiffMutex);
    CircularBuffer<Sint8, Config::TICKDIFF_HISTORY_LENGTH> tickDiffHistoryCopy(
        tickDiffHistory);
    unsigned int numFreshDiffsCopy{numFreshDiffs};
    lock.unlock();

    // Run through all checks and calc any necessary adjustment.
    Sint8 adjustment{calcAdjustment(tickDiffHistoryCopy, numFreshDiffsCopy)};

    return {adjustment, latestAdjIteration};
}

Sint8 Client::calcAdjustment(
    CircularBuffer<Sint8, Config::TICKDIFF_HISTORY_LENGTH>& tickDiffHistoryCopy,
    unsigned int numFreshDiffsCopy)
{
    // If we don't have enough data, we won't make an adjustment.
    if (numFreshDiffsCopy < Config::MIN_FRESH_DIFFS) {
        return 0;
    }

    // If the latest data isn't outside the target bounds, no adjustment is
    // needed.
    if ((tickDiffHistoryCopy[0] >= Config::TICKDIFF_ACCEPTABLE_BOUND_LOWER)
        && (tickDiffHistoryCopy[0]
            <= Config::TICKDIFF_ACCEPTABLE_BOUND_UPPER)) {
        return 0;
    }

    // Calc the average diff using only fresh data.
    float averageDiff{0};
    for (unsigned int i = 0; i < numFreshDiffsCopy; ++i) {
        averageDiff += tickDiffHistoryCopy[i];
    }
    averageDiff /= numFreshDiffsCopy;

    // If the average isn't outside the target bounds, no adjustment is needed.
    int truncatedAverage{static_cast<int>(averageDiff)};
    if ((truncatedAverage >= Config::TICKDIFF_ACCEPTABLE_BOUND_LOWER)
        && (truncatedAverage <= Config::TICKDIFF_ACCEPTABLE_BOUND_UPPER)) {
        return 0;
    }

    /* Check for lag spikes.
       Note: We check for lag spikes by seeing if we're ahead of the client
             (diff < target) and moving back towards the target.
             If we aren't, then we have to assume we had a long-term latency
             gain. */
    // If we're ahead of the client.
    if (tickDiffHistoryCopy[0] < Config::TICKDIFF_TARGET) {
        // If we're moving back towards the target.
        if (tickDiffHistoryCopy[0] > tickDiffHistoryCopy[1]) {
            // It seems like a spike occurred, instead of a long-term latency
            // gain. No adjustment needed, it's going back to normal.
            return 0;
        }
    }

    printAdjustmentInfo(tickDiffHistoryCopy, numFreshDiffsCopy,
                        truncatedAverage);

    // Make an adjustment back towards the target.
    Sint64 adjustment{Config::TICKDIFF_TARGET - truncatedAverage};
    AM_ASSERT((adjustment >= SDL_MIN_SINT8), "Adjustment out of bounds.");
    AM_ASSERT((adjustment <= SDL_MAX_SINT8), "Adjustment out of bounds.");
    return static_cast<Sint8>(adjustment);
}

void Client::printAdjustmentInfo(
    [[maybe_unused]] const CircularBuffer<
        Sint8, Config::TICKDIFF_HISTORY_LENGTH>& tickDiffHistoryCopy,
    [[maybe_unused]] unsigned int numFreshDiffsCopy,
    [[maybe_unused]] int truncatedAverage)
{
    LOG_DEBUG("Calc'd adjustment. NetID: %u, adjustment: %d, iteration: %u",
              netID, (Config::TICKDIFF_TARGET - truncatedAverage),
              latestAdjIteration.load());
    LOG_DEBUG("truncatedAverage: %d, numFreshDiffs: %u. Values:",
              truncatedAverage, numFreshDiffsCopy);
#ifdef DEBUG
    std::printf("[");
    for (unsigned int i{0}; i < Config::TICKDIFF_HISTORY_LENGTH; ++i) {
        std::printf("%d, ", tickDiffHistoryCopy[i]);
    }
    std::printf("]\n");
#endif
}

} // end namespace Server
} // end namespace AM

```

`Source/ServerLib/Network/Private/ClientHandler.cpp`:

```cpp
#include "ClientHandler.h"
#include "Network.h"
#include "NetworkDefs.h"
#include "SocketSet.h"
#include "ClientConnectionEvent.h"
#include "Config.h"
#include "Log.h"
#include <shared_mutex>
#include <mutex>
#include <memory>

namespace AM
{
namespace Server
{

ClientHandler::ClientHandler(Network& inNetwork, EventDispatcher& inDispatcher,
                             MessageProcessor& inMessageProcessor)
: network{inNetwork}
, dispatcher{inDispatcher}
, messageProcessor{inMessageProcessor}
, networkIDPool{IDPool::ReservationStrategy::MarchForward, 8}
, clientCount{0}
, clientSet{std::make_shared<SocketSet>(Config::MAX_CLIENTS)}
, acceptor{Config::SERVER_PORT, clientSet}
, receiveThreadObj{}
, exitRequested{false}
, sendRequested{false}
{
    // Start the send and receive threads.
    receiveThreadObj = std::thread(&ClientHandler::serviceClients, this);
    sendThreadObj = std::thread(&ClientHandler::sendClientUpdates, this);

    // Reserve the null network ID.
    networkIDPool.reserveID();
}

ClientHandler::~ClientHandler()
{
    exitRequested = true;
    receiveThreadObj.join();

    {
        std::unique_lock lock{sendMutex};
        sendRequested = true;
    }
    sendCondVar.notify_one();
    sendThreadObj.join();
}

void ClientHandler::beginSendClientUpdates()
{
    // Wake the send thread.
    {
        std::unique_lock lock{sendMutex};
        sendRequested = true;
    }
    sendCondVar.notify_one();
}

void ClientHandler::serviceClients()
{
    tracy::SetThreadName("ServerReceive");

    ClientMap& clientMap{network.getClientMap()};

    while (!exitRequested) {
        // Check if there are any new clients to connect.
        acceptNewClients(clientMap);

        // Erase any clients who were detected to be disconnected.
        eraseDisconnectedClients(clientMap);

        // Check if there's any clients with activity, and process all their
        // messages.
        // Note: Doesn't need a lock because we only mutate the map from this
        //       thread.
        int numReceived = 0;
        if (clientMap.size() != 0) {
            numReceived = receiveAndProcessClientMessages(clientMap);
        }

        // There wasn't any activity, delay so we don't waste CPU spinning.
        if (numReceived == 0) {
            SDL_Delay(INACTIVE_DELAY_TIME_MS);
        }
    }
}

void ClientHandler::sendClientUpdates()
{
    tracy::SetThreadName("ServerSend");

    SharedLockableBase(std::shared_mutex)
        & clientMapMutex{network.getClientMapMutex()};
    ClientMap& clientMap{network.getClientMap()};

    while (!exitRequested) {
        // Wait until this thread is signaled by beginSendClientUpdates().
        std::unique_lock lock{sendMutex};
        sendCondVar.wait(lock, [this] { return sendRequested; });

        {
            ZoneScoped;

            // Acquire a read lock before running through the client map.
            std::shared_lock readLock{clientMapMutex};

            // Run through the clients, sending their waiting messages.
            Uint32 currentTick{network.getCurrentTick()};
            for (auto& pair : clientMap) {
                pair.second->sendWaitingMessages(currentTick);
            }

            sendRequested = false;
        }
    }
}

void ClientHandler::acceptNewClients(ClientMap& clientMap)
{
    ZoneScoped;

    // If we're at max capacity, reject any waiting connections.
    if (clientCount == Config::MAX_CLIENTS) {
        while (acceptor.reject()) {
            LOG_INFO("Rejected connection attempt: Already at maximum "
                     "connected clients.");
        }
        return;
    }

    // We have room for more peers. Connect to any that are waiting.
    // Note: newPeer adds itself to the socket set.
    std::unique_ptr<Peer> newPeer{acceptor.accept()};
    while (newPeer != nullptr) {
        NetworkID newID{static_cast<NetworkID>(networkIDPool.reserveID())};
        LOG_INFO("New client connected. Assigning netID: %u", newID);

        {
            // Add the peer to the Network's clientMap.
            std::unique_lock writeLock{network.getClientMapMutex()};
            if (!(clientMap
                      .try_emplace(newID, std::make_shared<Client>(
                                              newID, std::move(newPeer)))
                      .second)) {
                networkIDPool.freeID(newID);
                LOG_FATAL(
                    "Ran out of room in client map or key already existed.");
            }
        }

        clientCount++;

        // Notify the sim that a client was connected.
        dispatcher.emplace<ClientConnectionEvent>(ClientConnected{newID});

        newPeer = acceptor.accept();
    }
}

void ClientHandler::eraseDisconnectedClients(ClientMap& clientMap)
{
    ZoneScoped;

    /* Erase any disconnected clients. */
    for (auto it = clientMap.begin(); it != clientMap.end();) {
        std::shared_ptr<Client>& client{it->second};

        if (!(client->isConnected())) {
            // Save the ID since we're going to erase this client.
            NetworkID clientID{it->first};

            {
                // Need to modify the map, acquire a write lock.
                std::unique_lock writeLock{network.getClientMapMutex()};

                // Erase the disconnected client.
                networkIDPool.freeID(it->first);
                it = clientMap.erase(it);
            }

            clientCount--;

            // Notify the sim that a client was disconnected.
            LOG_INFO("Erased disconnected client with netID: %u.", clientID);
            dispatcher.emplace<ClientConnectionEvent>(
                ClientDisconnected{clientID});
        }
        else {
            ++it;
        }
    }
}

int ClientHandler::receiveAndProcessClientMessages(ClientMap& clientMap)
{
    ZoneScoped;

    // Update each client's internal socket isReady().
    clientSet->checkSockets(0);

    /* Iterate through all clients. */
    // Note: Doesn't need a lock because we only mutate the map from this
    //       thread.
    int numReceived{0};
    for (auto& pair : clientMap) {
        const std::shared_ptr<Client>& clientPtr{pair.second};

        // If there's data waiting, try to receive all messages from the
        // client.
        // Note: We can only receive one message at a time, since select() 
        //       (checkSockets) only tells us data is available, not how much.
        if (clientPtr->dataIsReady()) {
            Client::ReceiveResult result{clientPtr->receiveMessage()};
            if (result.networkResult == NetworkResult::Success) {
                numReceived++;

                // Process the message.
                processReceivedMessage(*clientPtr, result.messageType,
                                       result.messageBuffer);
            }
        }
    }

    return numReceived;
}

void ClientHandler::processReceivedMessage(Client& client, Uint8 messageType,
                                           std::span<Uint8> messageBuffer)
{
    // Process the message.
    // Note: messageTick will be > -1 if the message contained a tick number.
    Sint64 messageTick{messageProcessor.processReceivedMessage(
        client.getNetID(), messageType, messageBuffer.data(),
        messageBuffer.size())};

    // If the message carried a tick number, use it to calc a diff and give it
    // to the client.
    if (messageTick != -1) {
        // Calc the difference between the current tick and the message's tick.
        Sint64 tickDiff{messageTick
                        - static_cast<Sint64>(network.getCurrentTick())};

        // Record the diff.
        client.recordTickDiff(tickDiff);
    }
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Network/Private/MessageProcessor.cpp`:

```cpp
#include "MessageProcessor.h"
#include "MessageProcessorContext.h"
#include "QueuedEvents.h"
#include "Deserialize.h"
#include "DispatchMessage.h"
#include "IMessageProcessorExtension.h"
#include "Heartbeat.h"
#include "InputChangeRequest.h"
#include "EntityNameChangeRequest.h"
#include "GraphicStateChangeRequest.h"
#include "ChunkDataRequest.h"
#include "EntityInitRequest.h"
#include "EntityDeleteRequest.h"
#include "EntityInitScriptRequest.h"
#include "ItemDataRequest.h"
#include "ItemInitRequest.h"
#include "ItemChangeRequest.h"
#include "ItemInitScriptRequest.h"
#include "CombineItemsRequest.h"
#include "UseItemOnEntityRequest.h"
#include "DialogueChoiceRequest.h"
#include "CastRequest.h"
#include "TileAddLayer.h"
#include "TileRemoveLayer.h"
#include "TileClearLayers.h"
#include "TileExtentClearLayers.h"
#include "InventoryOperation.h"
#include "Log.h"
#include <span>

namespace AM
{
namespace Server
{
template<typename T>
void dispatchWithNetID(NetworkID netID, std::span<Uint8> messageBuffer,
                       EventDispatcher& dispatcher)
{
    // Deserialize the message.
    T message{};
    Deserialize::fromBuffer(messageBuffer.data(), messageBuffer.size(),
                            message);

    // Fill in the network ID that we assigned to this client.
    message.netID = netID;

    // Push the message into any subscribed queues.
    dispatcher.push<T>(message);
}

MessageProcessor::MessageProcessor(
    const MessageProcessorContext& inMessageProcessorContext)
: networkEventDispatcher{inMessageProcessorContext.networkEventDispatcher}
{
}

Sint64 MessageProcessor::processReceivedMessage(NetworkID netID,
                                                Uint8 messageType,
                                                Uint8* messageBuffer,
                                                std::size_t messageSize)
{
    // The tick that the received message corresponds to.
    // Will be -1 if the message doesn't correspond to any tick.
    Sint64 messageTick{-1};

    // Match the enum values to their event types.
    EngineMessageType engineMessageType{
        static_cast<EngineMessageType>(messageType)};
    switch (engineMessageType) {
        case EngineMessageType::Heartbeat: {
            messageTick = static_cast<Sint64>(
                handleHeartbeat(messageBuffer, messageSize));
            break;
        }
        case EngineMessageType::InputChangeRequest: {
            messageTick = static_cast<Sint64>(
                handleInputChangeRequest(netID, messageBuffer, messageSize));
            break;
        }
        case EngineMessageType::EntityNameChangeRequest: {
            dispatchMessage<EntityNameChangeRequest>(messageBuffer, messageSize,
                                                     networkEventDispatcher);
            break;
        }
        case EngineMessageType::GraphicStateChangeRequest: {
            dispatchMessage<GraphicStateChangeRequest>(
                messageBuffer, messageSize, networkEventDispatcher);
            break;
        }
        case EngineMessageType::ChunkDataRequest: {
            dispatchWithNetID<ChunkDataRequest>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::EntityInitRequest: {
            dispatchWithNetID<EntityInitRequest>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::EntityDeleteRequest: {
            dispatchMessage<EntityDeleteRequest>(messageBuffer, messageSize,
                                                 networkEventDispatcher);
            break;
        }
        case EngineMessageType::EntityInitScriptRequest: {
            dispatchWithNetID<EntityInitScriptRequest>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::ItemDataRequest: {
            dispatchWithNetID<ItemDataRequest>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::ItemInitRequest: {
            dispatchWithNetID<ItemInitRequest>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::ItemChangeRequest: {
            dispatchWithNetID<ItemChangeRequest>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::ItemInitScriptRequest: {
            dispatchWithNetID<ItemInitScriptRequest>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::CombineItemsRequest: {
            dispatchWithNetID<CombineItemsRequest>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::UseItemOnEntityRequest: {
            dispatchWithNetID<UseItemOnEntityRequest>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::DialogueChoiceRequest: {
            dispatchWithNetID<DialogueChoiceRequest>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::CastRequest: {
            dispatchWithNetID<CastRequest>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::TileAddLayer: {
            dispatchWithNetID<TileAddLayer>(netID, {messageBuffer, messageSize},
                                            networkEventDispatcher);
            break;
        }
        case EngineMessageType::TileRemoveLayer: {
            dispatchWithNetID<TileRemoveLayer>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::TileClearLayers: {
            dispatchWithNetID<TileClearLayers>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::TileExtentClearLayers: {
            dispatchWithNetID<TileExtentClearLayers>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        case EngineMessageType::InventoryOperation: {
            dispatchWithNetID<InventoryOperation>(
                netID, {messageBuffer, messageSize}, networkEventDispatcher);
            break;
        }
        default: {
            // If we don't have a handler for this message type, pass it to
            // the project.
            if (extension != nullptr) {
                extension->processReceivedMessage(netID, messageType,
                                                  messageBuffer, messageSize);
            }
            break;
        }
    }

    return messageTick;
}

void MessageProcessor::setExtension(IMessageProcessorExtension* inExtension)
{
    extension = inExtension;
}

Uint32 MessageProcessor::handleHeartbeat(Uint8* messageBuffer,
                                         std::size_t messageSize)
{
    // Deserialize the message.
    Heartbeat heartbeat{};
    Deserialize::fromBuffer(messageBuffer, messageSize, heartbeat);

    // Return the tick number associated with this message.
    return heartbeat.tickNum;
}

Uint32 MessageProcessor::handleInputChangeRequest(NetworkID netID,
                                                  Uint8* messageBuffer,
                                                  std::size_t messageSize)
{
    // Deserialize the message.
    InputChangeRequest inputChangeRequest{};
    Deserialize::fromBuffer(messageBuffer, messageSize, inputChangeRequest);

    // Fill in the network ID that we assigned to this client.
    inputChangeRequest.netID = netID;

    // Push the message into any subscribed queues.
    networkEventDispatcher.push<InputChangeRequest>(inputChangeRequest);

    // Return the tick number associated with this message.
    return inputChangeRequest.tickNum;
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Network/Private/Network.cpp`:

```cpp
#include "Network.h"
#include "Acceptor.h"
#include "Peer.h"
#include "Deserialize.h"
#include "Heartbeat.h"
#include "Log.h"
#include "NetworkStats.h"
#include "IMessageProcessorExtension.h"
#include <SDL_net.h>
#include <algorithm>
#include <atomic>

namespace AM
{
namespace Server
{

Network::Network(const MessageProcessorContext& inMessageProcessorContext)
: messageProcessor{inMessageProcessorContext}
, clientHandler{*this, eventDispatcher, messageProcessor}
, ticksSinceNetstatsLog{0}
, currentTickPtr{nullptr}
{
}

void Network::tick()
{
    ZoneScoped;

    // Flag the send thread to start sending all messages for this network
    // tick.
    clientHandler.beginSendClientUpdates();

    // If it's time to log our network statistics, do so.
    ticksSinceNetstatsLog++;
    if (ticksSinceNetstatsLog == TICKS_TILL_STATS_DUMP) {
        logNetworkStatistics();
        ticksSinceNetstatsLog = 0;
    }
}

void Network::send(NetworkID networkID, const BinaryBufferSharedPtr& message,
                   Uint32 messageTick)
{
    // Acquire a read lock before running through the client map.
    std::shared_lock readLock(clientMapMutex);

    // Check that the client still exists, queue the message if so.
    auto clientPair = clientMap.find(networkID);
    if (clientPair != clientMap.end()) {
        clientPair->second->queueMessage(message, messageTick);
    }
}

EventDispatcher& Network::getEventDispatcher()
{
    return eventDispatcher;
}

ClientMap& Network::getClientMap()
{
    return clientMap;
}

SharedLockableBase(std::shared_mutex) & Network::getClientMapMutex()
{
    return clientMapMutex;
}

void Network::registerCurrentTickPtr(
    const std::atomic<Uint32>* inCurrentTickPtr)
{
    currentTickPtr = inCurrentTickPtr;
}

Uint32 Network::getCurrentTick()
{
    // Note: This isn't safe since we're trying to observe changes to a raw 
    //       pointer across threads, but this should only ever be nullptr if 
    //       the main thread crashes during startup, so it's fine.
    if (currentTickPtr) {
        return *currentTickPtr;
    }
    else {
        return 0;
    }
}

void Network::setMessageProcessorExtension(
    IMessageProcessorExtension* extension)
{
    messageProcessor.setExtension(std::move(extension));
}

void Network::logNetworkStatistics()
{
    // Dump the stats from the tracker.
    NetStatsDump netStats{NetworkStats::dumpStats()};

    // Log the stats.
    float bytesSentPerSecond{netStats.bytesSent
                             / static_cast<float>(SECONDS_TILL_STATS_DUMP)};
    float bytesReceivedPerSecond{netStats.bytesReceived
                                 / static_cast<float>(SECONDS_TILL_STATS_DUMP)};
    LOG_INFO("Bytes sent per second: %.0f, Bytes received per second: %.0f",
             bytesSentPerSecond, bytesReceivedPerSecond);
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Network/Public/Client.h`:

```h
#pragma once

#include "Peer.h"
#include "NetworkID.h"
#include "BufferPool.h"
#include "Config.h"
#include "CircularBuffer.h"
#include "Timer.h"
#include "readerwriterqueue.h"
#include "tracy/Tracy.hpp"
#include <memory>
#include <array>
#include <mutex>
#include <atomic>
#include <span>

namespace AM
{
namespace Server
{
/**
 * Represents a single networked client.
 *
 * Manages sending/receiving messages, and connection state.
 */
class Client
{
public:
    Client(NetworkID inNetID, std::unique_ptr<Peer> inPeer);

    /**
     * Checks if this client has timed out, then returns its connection state.
     * @return true if the client is connected, else false.
     *
     * Note: There's 2 places where a disconnect can occur:
     *       If the client initiates a disconnect, the peer will internally set
     *       a flag.
     *       If we initiated a disconnect, peer will be set to nullptr.
     *       Both cases are detected by this method.
     */
    bool isConnected();

    /**
     * Queues a message to be sent the next time sendWaitingMessages is called.
     *
     * @param message The message to queue.
     * @param messageTick If non-0, used to update our latestSentSimTick.
     *                    Use 0 if sending messages that aren't associated
     *                    with a tick.
     */
    void queueMessage(const BinaryBufferSharedPtr& message, Uint32 messageTick);

    /**
     * Attempts to send all queued messages over the network.
     *
     * @param currentTick The sim's current tick.
     * @return An appropriate NetworkResult.
     */
    NetworkResult sendWaitingMessages(Uint32 currentTick);

    /**
     * Returns true if this socket has data waiting.
     * Only valid if clientSet->checkSockets() is called prior.
     */
    bool dataIsReady();

    struct ReceiveResult
    {
        /** The result of the receive attempt. */
        NetworkResult networkResult{NetworkResult::NotSet};
        /** The type of the received message. Will be NotSet if networkResult
            != Success.
            Note: This gets cast to EngineMessageType or ProjectMessageType. */
        Uint8 messageType{static_cast<Uint8>(EngineMessageType::NotSet)};
        /** If networkResult == Success, contains the received message. */
        std::span<Uint8> messageBuffer{};
    };
    /**
     * Blocks until a message is received from this client.
     *
     * Note: Use dataIsReady() to check for data before calling this.
     *
     * @return An appropriate ReceiveResult. If return.networkResult == Success,
     *         messageBuffer contains the received message.
     */
    ReceiveResult receiveMessage();

    /**
     * Records the given tick diff in tickDiffHistory.
     *
     * Diffs represent how late a message was received (the difference between
     * the message's contained tick number and our current tick).
     *
     * If the diff isn't in our valid range, it's discarded and the client is
     * forcibly disconnected.
     */
    void recordTickDiff(Sint64 tickDiff);

    NetworkID getNetID();

private:
    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------
    /**
     * Returns the number of messages waiting in the sendQueue.
     */
    std::size_t getWaitingMessageCount() const;

    /**
     * Adds an explicit confirmation to the current batch.
     */
    void addExplicitConfirmation(std::size_t& currentIndex, Uint32 currentTick);

    /**
     * Compresses the first batchSize bytes in the payload section of
     * batchBuffer into compressedBatchBuffer and returns the compressed
     * payload size.
     */
    std::size_t compressBatch(std::size_t batchSize);

    /**
     * Fills in the header information for the message batch currently being
     * built.
     *
     * @param bufferToFill  The buffer that should have its header filled.
     * @param batchSize  The size, in bytes, of the current batch.
     * @param isCompressed  True if the batch is compressed, else false.
     */
    void fillHeader(Uint8* bufferToFill, Uint16 batchSize, bool isCompressed);

    //--------------------------------------------------------------------------
    // Connection, Batching
    //--------------------------------------------------------------------------
    /** Our Network-given ID. */
    const NetworkID netID;

    /** Our connection and interface to the client. */
    std::unique_ptr<Peer> peer;

    //--------------------------------------------------------------------------
    // Batching/Sending
    //--------------------------------------------------------------------------
    /** Convenience struct for passing data through the sendQueue. */
    struct QueuedMessage {
        /** The message to send. */
        BinaryBufferSharedPtr message;

        /** The tick that the message corresponds to. */
        Uint32 tick;
    };
    /** Holds messages to be sent with the next call to sendWaitingMessages. */
    moodycamel::ReaderWriterQueue<QueuedMessage> sendQueue;

    /** Holds header and message data while we're putting the next batch
        together.
        If the batch does not need to be compressed, it will be sent directly
        from this buffer. */
    static BinaryBuffer batchBuffer;

    /** If a batch needs to be compressed, the compressed bytes will be written
        to and sent from this buffer.
        See SharedConfig::BATCH_COMPRESSION_THRESHOLD for more info. */
    static BinaryBuffer compressedBatchBuffer;

    //--------------------------------------------------------------------------
    // Receiving
    //--------------------------------------------------------------------------
    /** The max size that a received client message can be before we need to 
        anticipate that it will be split into multiple packets over the wire. */
    static constexpr std::size_t CLIENT_MAX_SMALL_MESSAGE_SIZE{
        ETHERNET_MTU - CLIENT_HEADER_SIZE - MESSAGE_HEADER_SIZE};

    /** Holds any small (single packet) received messages.
        For small messages, we can use a single buffer for all clients since we
        know all of the data will be immediately present. */
    static BinaryBuffer smallReceiveBuffer;

    /** A pool that holds all the buffers we've allocated for large message 
        receiving. */
    using LargeBufferPool = BufferPool<CLIENT_MAX_MESSAGE_SIZE>;
    static LargeBufferPool bufferPool;

    /** If nullptr, we're currently composing a large message into this buffer. */
    std::unique_ptr<LargeBufferPool::BufferType> largeReceiveBuffer;

    /** The type of the message that we're currently composing. */
    Uint8 messageType;

    /** The size of the message that we're currently composing.
        Note: This eventually gets cast to EngineMessageType or 
              ProjectMessageType. */
    Uint16 messageSize;

    /** If we're currently composing a large message, this is the first empty 
        index within largeReceiveBuffer. */
    Uint16 compositionIndex;

    /** Tracks how long it's been since we've received a message from this
        client. */
    Timer receiveTimer;

    //--------------------------------------------------------------------------
    // Synchronization Functions
    //--------------------------------------------------------------------------
    struct AdjustmentData {
        /** The amount of adjustment. */
        Sint8 adjustment;
        /** The adjustment iteration that we're on. */
        Uint8 iteration;
    };

    /**
     * Calculates an appropriate tick adjustment for this client to make.
     * Increments adjustmentIteration every time it's called.
     */
    AdjustmentData getTickAdjustment();

    /**
     * Run through all checks necessary to determine if we should tell the
     * client to adjust its tick.
     *
     * Note: The parameters could be obtained internally, but passing them
     * in provides a clear separation between setup and adjustment logic.
     *
     * @param tickDiffHistoryCopy  A copy of the tickDiffHistory, so that we
     *                             don't need to keep it locked.
     * @param numFreshDiffsCopy  A copy of the numFreshDiffs, so that we don't
     *                           need to keep it locked.
     * @return The calculated adjustment. 0 if no adjustment was needed.
     */
    Sint8 calcAdjustment(CircularBuffer<Sint8, Config::TICKDIFF_HISTORY_LENGTH>&
                             tickDiffHistoryCopy,
                         unsigned int numFreshDiffsCopy);

    /**
     * Prints relevant information during an adjustment. Used for debugging.
     */
    void printAdjustmentInfo(
        const CircularBuffer<Sint8, Config::TICKDIFF_HISTORY_LENGTH>&
            tickDiffHistoryCopy,
        unsigned int numFreshDiffsCopy, int truncatedAverage);

    //--------------------------------------------------------------------------
    // Synchronization Members
    //--------------------------------------------------------------------------
    /** The latest tick that we've sent an update to this client for. */
    Uint32 latestSentSimTick;

    /**
     * Holds tick diffs that have been added through recordTickDiff.
     */
    CircularBuffer<Sint8, Config::TICKDIFF_HISTORY_LENGTH> tickDiffHistory;

    /**
     * Used to prevent tickDiffHistory and numFreshData from changing while a
     * getTickAdjustment() is happening.
     */
    TracyLockable(std::mutex, tickDiffMutex);

    /**
     * The number of fresh diffs that we have in the history.
     * Allows us to avoid using stale data when calculating adjustments.
     */
    std::atomic<unsigned int> numFreshDiffs;

    /**
     * Tracks the latest tick offset adjustment iteration we've received.
     * Looped around from the client to avoid double-counting adjustments.
     */
    std::atomic<Uint8> latestAdjIteration;
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Network/Public/ClientConnectionEvent.h`:

```h
#pragma once

#include "NetworkID.h"
#include <variant>

namespace AM
{
namespace Server
{
/**
 * Used to tell the simulation that a client was connected.
 */
struct ClientConnected {
    /** The ID of the client that connected. */
    NetworkID clientID{0};
};

/**
 * Used to tell the simulation that a client was disconnected.
 */
struct ClientDisconnected {
    /** The ID of the client that disconnected. */
    NetworkID clientID{0};
};

/** Used to synchronize connect/disconnect events. Without this, we may observe 
    a disconnect for a client before processing the connect event. */
using ClientConnectionEvent
    = std::variant<ClientConnected, ClientDisconnected>;

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Network/Public/ClientHandler.h`:

```h
#pragma once

#include "ClientMap.h"
#include "Client.h"
#include "Acceptor.h"
#include "IDPool.h"
#include "tracy/Tracy.hpp"
#include <thread>
#include <queue>
#include <unordered_map>
#include <atomic>
#include <mutex>
#include <span>
#include <condition_variable>

namespace AM
{
class EventDispatcher;

namespace Server
{
class Network;
class MessageProcessor;

/**
 * Handles all asynchronous activity that the Clients require.
 *
 * Accepts new client connections, erases clients that have been detected as
 * disconnected, and receives available messages.
 *
 * Acts directly on the Network's client map.
 */
class ClientHandler
{
public:
    ClientHandler(Network& inNetwork, EventDispatcher& inDispatcher,
                  MessageProcessor& inMessageProcessor);

    ~ClientHandler();

    /**
     * Flags the send thread to begin sending all waiting messages.
     */
    void beginSendClientUpdates();

private:
    /** Extra room so that we don't run into reuse issues when almost all IDs
        are reserved.
        Note: Eventually, we should determine when old IDs are guaranteed to 
              be safe to reuse (maybe after 1 tick?). This needs to also 
              guarantee that the ID will be cleared from any clients. */
    static constexpr std::size_t ID_SAFETY_BUFFER{100};

    /**
     * How long the accept/disconnect/receive loop in serviceClients should
     * delay if no socket activity was reported on the clientSet.
     */
    static constexpr unsigned int INACTIVE_DELAY_TIME_MS{1};

    /**
     * Thread function, started from constructor.
     *
     * Accepts new client connections, erases clients that have been detected as
     * disconnected, and receives available messages.
     *
     * Acts directly on the Network's client map.
     */
    void serviceClients();

    /**
     * Thread function, started from constructor.
     * Waits for beginSendClientUpdates() to flag that a send should begin.
     *
     * Tries to send any messages in each client's queue over the network.
     * If a send fails, leaves the message at the front of the queue and moves
     * on to the next client's queue.
     * If there's no messages to send, sends a heartbeat instead, with a value
     * that confirms that we've processed tick(s) with no changes to send.
     */
    void sendClientUpdates();

    /**
     * Accepts any new clients, pushing them into the Network's client map.
     */
    void acceptNewClients(ClientMap& clientMap);

    /**
     * Erase any disconnected clients from the Network's clientMap.
     */
    void eraseDisconnectedClients(ClientMap& clientMap);

    /**
     * Receives any waiting client messages and passes them to
     * processReceivedMessage().
     *
     * @return The number of messages that were received.
     */
    int receiveAndProcessClientMessages(ClientMap& clientMap);

    /**
     * Passes received client messages to the MessageProcessor.
     *
     * When a message with a tick number is received, updates the associated
     * client's tick diff data.
     *
     * @param client  The client that we received this message from.
     * @param messageType  The type of the received message.
     * @param messageBuffer The buffer that holds the message.
     */
    void processReceivedMessage(Client& client, Uint8 messageType,
                                std::span<Uint8> messageBuffer);

    /** Used to get the client map and current tick. */
    Network& network;

    /** Used to push network events like connections/disconnections. */
    EventDispatcher& dispatcher;

    /** Used to process received messages. */
    MessageProcessor& messageProcessor;

    /** Used for generating network IDs. */
    IDPool networkIDPool;

    /** The number of clients that are currently connected. */
    unsigned int clientCount;

    /** The socket set used for all clients. Lets us do select()-like behavior,
        allowing our receive thread to not be constantly spinning. */
    std::shared_ptr<SocketSet> clientSet;

    /** The listener that we use to accept new clients. */
    Acceptor acceptor;

    /** Calls serviceClients(). */
    std::thread receiveThreadObj;
    /** Turn false to signal that the send and receive threads should end. */
    std::atomic<bool> exitRequested;

    /** Calls sendClientUpdates(). */
    std::thread sendThreadObj;
    /** Used for signaling the send thread. */
    TracyLockable(std::mutex, sendMutex);
    /** Used for signaling the send thread. */
    std::condition_variable_any sendCondVar;
    /** Used for signaling the send thread. */
    bool sendRequested;
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Network/Public/ClientMap.h`:

```h
#pragma once

#include "NetworkID.h"
#include <unordered_map>
#include <memory>

namespace AM
{
namespace Server
{
class Client;

/** A map type used to manage clients. */
using ClientMap = std::unordered_map<NetworkID, std::shared_ptr<Client>>;

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Network/Public/IMessageProcessorExtension.h`:

```h
#pragma once

#include "NetworkID.h"
#include <SDL_stdinc.h>
#include <cstddef>

namespace AM
{
namespace Server
{

/**
 * Defines an extension for the engine's Server::MessageProcessor class.
 *
 * Extensions are implemented by the project, and are given generic functions
 * ("hooks") in which they can implement relevant project logic.
 *
 * The project can register the extension class with the engine through
 * Application::registerMessageProcessorExtension().
 */
class IMessageProcessorExtension
{
public:
    // Canonical constructor (derived class must implement):
    // MessageProcessorExtension(const MessageProcessorExDependencies& deps)

    /**
     * Called when a message is received that the engine doesn't have a handler
     * for.
     *
     * @param netID  The network ID of the client that the message came from.
     * @param messageType  The type of the received message.
     * @param messageBuffer A buffer containing a serialized message, starting
     *                      at index 0.
     * @param messageSize  The length in bytes of the message in messageBuffer.
     */
    virtual void processReceivedMessage(NetworkID netID, Uint8 messageType,
                                        Uint8* messageBuffer,
                                        std::size_t messageSize)
        = 0;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Network/Public/MessageProcessor.h`:

```h
#pragma once

#include "NetworkID.h"
#include "entt/fwd.hpp"
#include <memory>

namespace AM
{
class EventDispatcher;

namespace Server
{
class IMessageProcessorExtension;
struct MessageProcessorContext;

/**
 * Processes received messages.
 *
 * If the message is relevant to the network layer, it's passed to a matching
 * function that contains all of its handling logic.
 *
 * If the message isn't relevant to the network layer, it's passed to a generic
 * function that pushes it straight down to the simulation layer.
 *
 * If the message isn't relevant to the engine at all, it's passed to the
 * project.
 */
class MessageProcessor
{
public:
    MessageProcessor(const MessageProcessorContext& inMessageProcessorContext);

    /**
     * Deserializes and handles received messages.
     *
     * See class comment.
     *
     * @param netID  The network ID of the client that the message came from.
     * @param messageType  The type of the received message.
     * @param messageBuffer A buffer containing a serialized message, starting
     *                      at index 0.
     * @param messageSize  The length in bytes of the message in messageBuffer.
     *
     * @return If the message corresponds to a particular simulation tick,
     *         returns that tick number. If not, returns -1.
     */
    Sint64 processReceivedMessage(NetworkID netID, Uint8 messageType,
                                  Uint8* messageBuffer,
                                  std::size_t messageSize);

    /**
     * See extension member comment.
     */
    void setExtension(IMessageProcessorExtension* inExtension);

private:
    //-------------------------------------------------------------------------
    // Handlers for messages relevant to the network layer.
    //-------------------------------------------------------------------------
    /**
     * Pushes nothing - Handled in network layer.
     * @return The tick number that the message contained.
     */
    Uint32 handleHeartbeat(Uint8* messageBuffer, std::size_t messageSize);

    /**
     * Pushes InputChangeRequest event.
     * @return The tick number that the message contained.
     */
    Uint32 handleInputChangeRequest(NetworkID netID, Uint8* messageBuffer,
                                    std::size_t messageSize);
    //-------------------------------------------------------------------------

    /** The network's event dispatcher. Used to send events to the subscribed
        queues. */
    EventDispatcher& networkEventDispatcher;

    /** Contains the project's message processing extension functions.
        Allows the project to provide message processing code and have it be
        called at the appropriate time. */
    IMessageProcessorExtension* extension;
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Network/Public/MessageProcessorContext.h`:

```h
#pragma once

namespace AM
{
class EventDispatcher;

namespace Server
{

/**
 * Provides the dependencies that MessageProcessor logic may use.
 */
struct MessageProcessorContext {
public:
    EventDispatcher& networkEventDispatcher;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Network/Public/Network.h`:

```h
#pragma once

#include "SharedConfig.h"
#include "NetworkID.h"
#include "ClientMap.h"
#include "MessageProcessor.h"
#include "ClientHandler.h"
#include "Serialize.h"
#include "Peer.h"
#include "ByteTools.h"
#include "QueuedEvents.h"
#include "tracy/Tracy.hpp"
#include <memory>
#include <cstddef>
#include <unordered_map>
#include <shared_mutex>

namespace AM
{
class Acceptor;

namespace Server
{
struct MessageProcessorContext;
class IMessageProcessorExtension;

/**
 * Provides a convenient interface for sending and receiving messages, and
 * other network-related functionality.
 *
 * Internally, manages client connections and orchestrates message sending
 * and receiving.
 */
class Network
{
public:
    Network(const MessageProcessorContext& inMessageProcessorContext);

    /**
     * Sends all queued messages over the network.
     *
     * Also logs network statistics periodically.
     */
    void tick();

    /**
     * Sends bytes over the network.
     * Equivalent to calling serialize() and send().
     *
     * @param networkID The client to send the message to.
     * @param messageStruct A structure that defines MESSAGE_TYPE and has an
     *                      associated serialize() function.
     * @param messageTick Optional, used in certain cases to update the
     *                    Client's latestSentSimTick.
     */
    template<typename T>
    void serializeAndSend(NetworkID networkID, const T& messageStruct,
                          Uint32 messageTick = 0);

    /**
     * Serializes and frames the given message.
     *
     * @param messageStruct A structure that defines MESSAGE_TYPE and has an
     *                      associated serialize() function.
     * @return A message that's ready to be passed to send().
     */
    template<typename T>
    BinaryBufferSharedPtr serialize(const T& messageStruct);

    /**
     * Queues a message to be sent the next time sendWaitingMessages is called.
     * @throws std::out_of_range if id is not in the clients map.
     *
     * @param networkID The client to send the message to.
     * @param message The message to send.
     * @param messageTick Optional, used when sending entity movement updates
     *                    to update the Client's latestSentSimTick.
     */
    void send(NetworkID networkID, const BinaryBufferSharedPtr& message,
              Uint32 messageTick = 0);

    /**
     * Returns the Network event dispatcher. All messages that we receive
     * from the server are pushed into this dispatcher.
     */
    EventDispatcher& getEventDispatcher();

    /** Initialize the tick timer. */
    void initTimer();

    // Returning non-const refs because they need to be modified. Be careful not
    // to attempt to re-assign the obtained ref (can't re-seat a reference once
    // bound).
    ClientMap& getClientMap();
    SharedLockableBase(std::shared_mutex) & getClientMapMutex();

    /** Used for passing us a pointer to the sim's currentTick. */
    void registerCurrentTickPtr(const std::atomic<Uint32>* inCurrentTickPtr);

    /** Convenience for network-owned objects to get the current tick. */
    Uint32 getCurrentTick();

    /**
     * See MessageProcessor::extension member comment.
     */
    void setMessageProcessorExtension(IMessageProcessorExtension* extension);

private:
    /**
     * Logs the network stats such as bytes sent/received per second.
     */
    void logNetworkStatistics();

    /** Maps IDs to their connections. Allows the game to say "send this message
        to this entity" instead of needing to track the connection objects. */
    ClientMap clientMap;

    /** Used to lock access to the clientMap. */
    TracySharedLockable(std::shared_mutex, clientMapMutex);

    /** Used to dispatch events from the network to the simulation. */
    EventDispatcher eventDispatcher;

    /** Deserializes messages, does any network-layer message handling, and
        passes messages down to the simulation. */
    MessageProcessor messageProcessor;

    /** Handles asynchronous client activity. */
    ClientHandler clientHandler;

    /** The number of seconds we'll wait before logging our network
        statistics. */
    static constexpr unsigned int SECONDS_TILL_STATS_DUMP{5};
    static constexpr unsigned int TICKS_TILL_STATS_DUMP{
        static_cast<unsigned int>(
            (1 / SharedConfig::SERVER_NETWORK_TICK_TIMESTEP_S)
            * SECONDS_TILL_STATS_DUMP)};

    /** The number of ticks since we last logged our network statistics. */
    unsigned int ticksSinceNetstatsLog;

    /** Pointer to the sim's current tick. */
    const std::atomic<Uint32>* currentTickPtr;
};

template<typename T>
void Network::serializeAndSend(NetworkID networkID, const T& messageStruct,
                               Uint32 messageTick)
{
    // Serialize and frame the message.
    BinaryBufferSharedPtr messageBuffer{serialize(messageStruct)};

    // Send the message.
    send(networkID, messageBuffer, messageTick);
}

template<typename T>
BinaryBufferSharedPtr Network::serialize(const T& messageStruct)
{
    // Allocate the buffer.
    std::size_t totalMessageSize{MESSAGE_HEADER_SIZE
                                 + Serialize::measureSize(messageStruct)};
    BinaryBufferSharedPtr messageBuffer{
        std::make_shared<BinaryBuffer>(totalMessageSize)};

    // Serialize the message struct into the buffer, leaving room for the
    // header.
    std::size_t messageSize{
        Serialize::toBuffer(messageBuffer->data(), messageBuffer->size(),
                            messageStruct, MESSAGE_HEADER_SIZE)};

    // Copy the type into the buffer.
    // TODO: Add a nice compile-time message if T doesn't have MESSAGE_TYPE.
    messageBuffer->at(MessageHeaderIndex::MessageType)
        = static_cast<Uint8>(T::MESSAGE_TYPE);

    // Copy the messageSize into the buffer.
    ByteTools::write16(static_cast<Uint16>(messageSize),
                       (messageBuffer->data() + MessageHeaderIndex::Size));

    return messageBuffer;
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/CMakeLists.txt`:

```txt
target_sources(ServerLib
    PRIVATE
        Private/AISystem.cpp
        Private/CastHelper.cpp
        Private/CastSystem.cpp
        Private/ChunkStreamingSystem.cpp
        Private/ClientAOISystem.cpp
        Private/ClientConnectionSystem.cpp
        Private/ComponentChangeSystem.cpp
        Private/ComponentSyncSystem.cpp
        Private/Database.cpp
        Private/DialogueSystem.cpp
        Private/InputSystem.cpp
        Private/InventoryHelper.cpp
        Private/InventorySystem.cpp
        Private/ItemSystem.cpp
        Private/MovementSyncSystem.cpp
        Private/MovementSystem.cpp
        Private/NceLifetimeSystem.cpp
        Private/SaveSystem.cpp
        Private/ScriptDataSystem.cpp
        Private/Simulation.cpp
        Private/TileUpdateSystem.cpp
        Private/World.cpp
        Private/Components/StoredValues.cpp
        Private/GraphicData/GraphicData.cpp
        Private/IconData/IconData.cpp
        Private/ItemData/ItemData.cpp
        Private/Lua/EngineLuaBindings.cpp
        Private/TileMap/TileMap.cpp
    PUBLIC
        Public/AILogic.h
        Public/AISystem.h
        Public/CastHelper.h
        Public/CastSystem.h
        Public/ChunkStreamingSystem.h
        Public/ClientAOISystem.h
        Public/ClientConnectionSystem.h
        Public/ComponentChangeSystem.h
        Public/ComponentSyncSystem.h
        Public/Database.h
        Public/DialogueSystem.h
        Public/EntityItemHandlerScript.h
        Public/EntityStoredValueID.h
        Public/EntityStoredValueIDMap.h
        Public/EnttGroups.h
        Public/EventSorter.h
        Public/GlobalStoredValueMap.h
        Public/InputSystem.h
        Public/InventoryHelper.h
        Public/InventorySystem.h
        Public/ISimulationExtension.h
        Public/ItemSystem.h
        Public/MovementSyncSystem.h
        Public/MovementSystem.h
        Public/NceLifetimeSystem.h
        Public/PersistedComponent.h
        Public/SaveSystem.h
        Public/ScriptDataSystem.h
        Public/Simulation.h
        Public/SimulationContext.h
        Public/SpawnStrategy.h
        Public/TileUpdateSystem.h
        Public/World.h
        Public/Components/CastState.h
        Public/Components/ClientSimData.h
        Public/Components/Dialogue.h
        Public/Components/ItemHandler.h
        Public/Components/ReplicatedComponentList.h
        Public/Components/SaveTimestamp.h
        Public/Components/StoredValues.h
        Public/GraphicData/GraphicData.h
        Public/IconData/IconData.h
        Public/ItemData/ItemData.h
        Public/Lua/DialogueLua.h
        Public/Lua/DialogueChoiceConditionLua.h
        Public/Lua/EngineLuaBindings.h
        Public/Lua/EntityInitLua.h
        Public/Lua/EntityItemHandlerLua.h
        Public/Lua/ItemInitLua.h
        Public/TileMap/TileMap.h
        Public/TypeLists/EngineObservedComponentTypes.h
        Public/TypeLists/EnginePersistedComponentTypes.h
)

target_include_directories(ServerLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/Components
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/GraphicData
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/IconData
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/ItemData
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/Lua
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/TileMap
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/Components
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/GraphicData
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/IconData
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/ItemData
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/Lua
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/TileMap
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/TypeLists
)

```

`Source/ServerLib/Simulation/Private/AISystem.cpp`:

```cpp
#include "AISystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "ProjectAITypes.h"
#include "Log.h"
#include "boost/mp11/algorithm.hpp"

namespace AM
{
namespace Server
{

AISystem::AISystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
{
}

void AISystem::processAITick()
{
    // For each AI type in the list, update all AI components of that type.
    boost::mp11::mp_for_each<ProjectAITypes>(
        [&](auto I) { 
            using AIType = decltype(I);

            auto view{world.registry.view<AIType>()};
            for (auto [entity, aiLogic] : view.each()) {
                aiLogic.tick(world, entity);
            }
        });
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Private/CastHelper.cpp`:

```cpp
#include "CastHelper.h"
#include "Simulation.h"
#include "World.h"
#include "ItemData.h"
#include "CastableData.h"
#include "Inventory.h"
#include "Castable.h"
#include "CastState.h"
#include "ValidateCast.h"
#include "CastFailed.h"
#include "CastStarted.h"
#include "Position.h"
#include "PreviousPosition.h"
#include "Collision.h"
#include "ClientSimData.h"
#include "CastCooldown.h"
#include "Cylinder.h"
#include "SharedConfig.h"

namespace AM
{
namespace Server
{

CastHelper::CastHelper(Simulation& inSimulation, const ItemData& inItemData,
                       const CastableData& inCastableData)
: onItemInteractionCompletedMap{}
, onEntityInteractionCompletedMap{}
, onSpellCompletedMap{}
, simulation{inSimulation}
, world{inSimulation.getWorld()}
, itemData{inItemData}
, castableData{inCastableData}
{
}

CastFailureType
    CastHelper::castItemInteraction(const CastItemInteractionParams& params)
{
    // Check that the item exists and actually has this interaction type.
    // Note: This implicitly checks that the entity owns the item, since it
    //       uses the slot index.
    // Note: If we ever hit a situation where the item in the requested slot
    //       doesn't match what the user clicked, we can also put the item ID
    //       in the request message to confirm.
    const auto& inventory{world.registry.get<Inventory>(params.casterEntity)};
    const Item* item{inventory.getItem(params.slotIndex, itemData)};
    if (!item) {
        return CastFailureType::InvalidItem;
    }
    else if (!(item->supportsInteraction(params.interactionType))) {
        return CastFailureType::InteractionNotSupported;
    }

    // Check that the requested interaction has an associated Castable.
    const Castable* castable{castableData.getCastable(params.interactionType)};
    if (!castable) {
        return CastFailureType::InvalidCastable;
    }

    // Perform the shared validation checks.
    CastFailureType failureType{
        performSharedChecks(*castable, params.casterEntity, params.targetEntity,
                            params.targetPosition)};
    if (failureType != CastFailureType::None) {
        return failureType;
    }

    // Add a CastState to the entity (we checked above that they aren't already 
    // casting).
    world.registry.emplace<CastState>(
        params.casterEntity,
        CastState{.castInfo{castable, params.casterEntity, item,
                            params.targetEntity, params.targetPosition,
                            params.clientID},
                  .endTick{0}});

    return CastFailureType::None;
}

CastFailureType
    CastHelper::castEntityInteraction(const CastEntityInteractionParams& params)
{
    // Check that the requested interaction has an associated Castable.
    const Castable* castable{castableData.getCastable(params.interactionType)};
    if (!castable) {
        return CastFailureType::InvalidCastable;
    }

    // Perform the shared validation checks.
    CastFailureType failureType{
        performSharedChecks(*castable, params.casterEntity, params.targetEntity,
                            params.targetPosition)};
    if (failureType != CastFailureType::None) {
        return failureType;
    }

    // We check above that the target entity is valid if one was provided, but 
    // entity interactions require a target entity. Check that it's non-null.
    if (params.targetEntity == entt::null) {
        return CastFailureType::InvalidTargetEntity;
    }

    // Add a CastState to the entity (we checked above that they aren't already 
    // casting).
    world.registry.emplace<CastState>(
        params.casterEntity,
        CastState{.castInfo{castable, params.casterEntity, nullptr,
                            params.targetEntity, params.targetPosition,
                            params.clientID},
                  .endTick{0}});

    return CastFailureType::None;
}

CastFailureType CastHelper::castSpell(const CastSpellParams& params)
{
    // Check that the requested interaction has an associated Castable.
    const Castable* castable{castableData.getCastable(params.interactionType)};
    if (!castable) {
        return CastFailureType::InvalidCastable;
    }

    // Perform the shared validation checks.
    CastFailureType failureType{
        performSharedChecks(*castable, params.casterEntity, params.targetEntity,
                            params.targetPosition)};
    if (failureType != CastFailureType::None) {
        return failureType;
    }

    // We check above that the target entity is valid if one was provided, but 
    // entity interactions require a target entity. Check that it's non-null.
    if (params.targetEntity == entt::null) {
        return CastFailureType::InvalidTargetEntity;
    }

    // Add a CastState to the entity (we checked above that they aren't already 
    // casting).
    world.registry.emplace<CastState>(
        params.casterEntity,
        CastState{.castInfo{castable, params.casterEntity, nullptr,
                            params.targetEntity, params.targetPosition,
                            params.clientID},
                  .endTick{0}});

    return CastFailureType::None;
}

void CastHelper::setOnItemInteractionCompleted(
    ItemInteractionType interactionType,
    std::function<void(const CastInfo&)> callback)
{
    onItemInteractionCompletedMap[interactionType] = callback;
}

void CastHelper::setOnEntityInteractionCompleted(
    EntityInteractionType interactionType,
    std::function<void(const CastInfo&)> callback)
{
    onEntityInteractionCompletedMap[interactionType] = callback;
}

void CastHelper::setOnSpellCompleted(
    SpellType spellType, std::function<void(const CastInfo&)> callback)
{
    onSpellCompletedMap[spellType] = callback;
}

CastFailureType CastHelper::performSharedChecks(const Castable& castable,
                                                entt::entity casterEntity,
                                                entt::entity targetEntity,
                                                const Vector3& targetPosition)
{
    entt::registry& registry{world.registry};

    // Check that the caster entity exists.
    // Note: This should only be able to fail if a non-CastSystem caller 
    //       doesn't fill the struct properly.
    if (!(registry.valid(casterEntity))) {
        return CastFailureType::InvalidCasterEntity;
    }

    // If this isn't an instant cast, check that the caster isn't moving.
    const Position& casterPosition{registry.get<Position>(casterEntity)};
    if (castable.castTime != 0) {
        // Note: Since we compare to the previous tick's position, it takes an 
        //       extra tick after movement stops before we let casts go through.
        //       We consider this to be fine.
        const PreviousPosition* previousPosition{
            registry.try_get<PreviousPosition>(casterEntity)};
        if (previousPosition && (casterPosition != *previousPosition)) {
            return CastFailureType::Movement;
        }
    }

    // Check that the caster isn't already casting.
    if (registry.all_of<CastState>(casterEntity)) {
        return CastFailureType::AlreadyCasting;
    }

    // Check that this cast isn't on cooldown, and the GCD isn't active.
    if (auto* castCooldown{registry.try_get<CastCooldown>(casterEntity)}) {
        if (castCooldown->isCastOnCooldown(castable.castableID,
                                           simulation.getCurrentTick())) {
            return CastFailureType::OnCooldown;
        }
    }

    // If a target entity was provided or the Castable requires a target entity,
    // check that it exists.
    if ((targetEntity != entt::null)
        || (castable.targetType == Castable::TargetType::Entity)) {
        if (!(registry.valid(targetEntity))) {
            return CastFailureType::InvalidTargetEntity;
        }
    }

    // If the Castable uses a target entity, validate it.
    if ((castable.targetType == Castable::TargetType::Entity)
        || ((castable.targetType == Castable::TargetType::SelfOrEntity)
            && (targetEntity != entt::null))) {
        // Check that the caster is in range of the target entity.
        // Note: We already checked that both entities exist above.
        // Note: targetEntityPos is different than the targetPosition param.
        const Position& targetEntityPos{registry.get<Position>(targetEntity)};
        float squaredRange{castable.range * castable.range};
        if (casterPosition.squaredDistanceTo(targetEntityPos) > squaredRange) {
            return CastFailureType::OutOfRange;
        }

        // Check that the target entity is in the caster's line of sight.
        if (!isInLineOfSight(casterEntity, targetEntity, casterPosition,
                             targetPosition)) {
            return CastFailureType::LineOfSight;
        }
    }
    // If the Castable uses a target circle, validate it.
    else if (castable.targetType == Castable::TargetType::Circle) {
        // Check that the target position is within the map bounds.
        Cylinder targetCylinder{castable.getTargetCylinder(targetPosition)};
        if (!(world.tileMap.getTileExtent().contains(targetCylinder))) {
            return CastFailureType::InvalidTargetPosition;
        }

        // Check that the caster is in range of the target position.
        float squaredDistance{casterPosition.squaredDistanceTo(targetPosition)};
        if (squaredDistance > castable.range) {
            return CastFailureType::OutOfRange;
        }

        // Check that the target position is in the caster's line of sight.
        if (!isInLineOfSight(casterEntity, casterPosition, targetPosition)) {
            return CastFailureType::LineOfSight;
        }
    }

    // Run the project's validation of the Castable's requirements.
    bool projectValidationSucceeded{
        validateCast(casterEntity, castable, registry)};
    if (!projectValidationSucceeded) {
        return CastFailureType::ProjectValidationFailed;
    }

    return CastFailureType::None;
};

bool CastHelper::isInLineOfSight(entt::entity casterEntity,
                                 entt::entity targetEntity,
                                 const Vector3& casterPosition,
                                 const Vector3& targetPosition)
{
    // Find the start/end points for a raycast. If the entities have a 
    // Collision, use a point at the top of it to approximate their head.
    // If not, fall back to their Position.
    Vector3 casterPoint{casterPosition};
    if (const Collision
        * casterCollision{world.registry.try_get<Collision>(casterEntity)}) {
        casterPoint = casterCollision->worldBounds.getTopCenterPoint();
    }
    Vector3 targetPoint{targetPosition};
    if (const Collision
        * targetCollision{world.registry.try_get<Collision>(targetEntity)}) {
        targetPoint = targetCollision->worldBounds.getTopCenterPoint();
    }

    // If the ray hits anything besides the target, return false. If not, 
    // return true.
    std::array<entt::entity, 1> entitiesToExclude{targetEntity};
    bool objectWasHit{world.collisionLocator.raycastAny(
        {.start{casterPoint},
         .end{targetPoint},
         .collisionMask{CollisionLayerType::TerrainWall
                        | CollisionLayerType::BlockLoS},
         .entitiesToExclude{entitiesToExclude}})};

    return !objectWasHit;
}

bool CastHelper::isInLineOfSight(entt::entity casterEntity,
                                 const Vector3& casterPosition,
                                 const Vector3& targetPosition)
{
    // Find the start/end points for a raycast. If the entity has a 
    // Collision, use a point at the top of it to approximate their head.
    // If not, fall back to their Position.
    Vector3 casterPoint{casterPosition};
    if (const Collision
        * casterCollision{world.registry.try_get<Collision>(casterEntity)}) {
        casterPoint = casterCollision->worldBounds.getTopCenterPoint();
    }

    // If the ray hits anything, return false. If not, return true.
    bool objectWasHit{world.collisionLocator.raycastAny(
        {.start{casterPoint},
         .end{targetPosition},
         .collisionMask{CollisionLayerType::TerrainWall
                        | CollisionLayerType::BlockLoS}})};
    return !objectWasHit;
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/CastSystem.cpp`:

```cpp
#include "CastSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "ItemData.h"
#include "CastableData.h"
#include "Inventory.h"
#include "Castable.h"
#include "CastState.h"
#include "CastCooldown.h"
#include "CastCooldownInit.h"
#include "ValidateCast.h"
#include "CastFailed.h"
#include "CastStarted.h"
#include "SaveTimestamp.h"
#include "EnttGroups.h"
#include "ClientSimData.h"
#include "Cylinder.h"
#include "SharedConfig.h"

namespace AM
{
namespace Server
{

CastSystem::CastSystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, itemData{inSimContext.itemData}
, castableData{inSimContext.castableData}
, playerCastCooldownObserver{}
, castRequestQueue{inSimContext.networkEventDispatcher}
, castRequestSorter{}
{
    // Observe player CastCooldown construction events.
    playerCastCooldownObserver.bind(world.registry);
    playerCastCooldownObserver.on_construct<ClientSimData>()
        .on_construct<CastCooldown>();

    // Note: When CastCooldown is loaded from the DB, it gets initialized in 
    //       World::initTimerComponents.
}

void CastSystem::sendCastCooldownInits()
{
    // If a player CastCooldown was constructed, send the initial state to that
    // player.
    // Note: This may happen when the player first logs in, or when they first 
    //       cast a Castable with a cooldown (since we don't add CastCooldown 
    //       to every entity).
    for (entt::entity entity : playerCastCooldownObserver) {
        if (!(world.registry.all_of<ClientSimData, CastCooldown>(entity))) {
            continue;
        }
        auto [client, castCooldown]
            = world.registry.get<ClientSimData, CastCooldown>(entity);

        network.serializeAndSend(client.netID, CastCooldownInit{castCooldown});
    }

    playerCastCooldownObserver.clear();
}

void CastSystem::processCasts()
{
    // Process any waiting cast requests.
    processCastRequests();

    // Update ongoing casts.
    updateCasts();
}

void CastSystem::processCastRequests()
{
    // Sort or process any waiting cast requests.
    while (CastRequest* castRequest{castRequestQueue.peek()}) {
        // If the castable doesn't exist, drop this request.
        const Castable* castable{
            castableData.getCastable(castRequest->castableID)};
        if (!castable) {
            castRequestQueue.pop();
            continue;
        }

        // If this castable is tick-synchronized, sort the request.
        if (castable->isTickSynchronized) {
            // Push the cast request into the sorter.
            SorterBase::ValidityResult result{
                castRequestSorter.push(*castRequest, castRequest->tickNum)};

            // If the cast request was late, process it immediately (it may 
            // still succeed).
            if (result != SorterBase::ValidityResult::Valid) {
                processCastRequest(*castRequest);
            }
            else {
                castRequestQueue.pop();
                continue;
            }
        }
        else {
            // Not tick-synchronized. Process it immediately.
            processCastRequest(*castRequest);
        }

        castRequestQueue.pop();
    }

    // Process all cast requests for this tick.
    std::queue<CastRequest>& queue{castRequestSorter.getCurrentQueue()};
    for (; !(queue.empty()); queue.pop()) {
        processCastRequest(queue.front());
    }

    // Advance the sorter to the next tick.
    castRequestSorter.advance();
}

void CastSystem::processCastRequest(const CastRequest& castRequest)
{
    // Find the entity ID of the client that sent this request.
    entt::entity clientEntity{world.getClientEntity(castRequest.netID)};
    if (clientEntity == entt::null) {
        // Client doesn't exist (may have disconnected), skip this request.
        return;
    }

    // Try to perform the cast.
    CastFailureType result{CastFailureType::None};
    if (auto* type{
            std::get_if<ItemInteractionType>(&castRequest.castableID)}) {
        result = world.castHelper.castItemInteraction(
            {*type, clientEntity, castRequest.slotIndex,
             castRequest.targetEntity, castRequest.targetPosition,
             castRequest.netID});
    }
    else if (auto* type{std::get_if<EntityInteractionType>(
                 &castRequest.castableID)}) {
        result = world.castHelper.castEntityInteraction(
            {*type, clientEntity, castRequest.targetEntity,
             castRequest.targetPosition, castRequest.netID});
    }
    else if (auto* type{std::get_if<SpellType>(&castRequest.castableID)}) {
        result = world.castHelper.castSpell(
            {*type, clientEntity, castRequest.targetEntity,
             castRequest.targetPosition, castRequest.netID});
    }
    else {
        LOG_ERROR("Tried to cast Castable with invalid type.");
    }

    // If the cast failed, send the failure to the caster.
    if (result != CastFailureType::None) {
        network.serializeAndSend<CastFailed>(
            castRequest.netID,
            {clientEntity, castRequest.castableID, result});
    }
}

void CastSystem::updateCasts()
{
    auto view{world.registry.view<CastState>()};
    Uint32 currentTick{simulation.getCurrentTick()};

    // Iterate each entity that is currently casting.
    for (auto [entity, castState] : view.each()) {
        // If this cast is unstarted, start it.
        if (castState.endTick == 0) {
            startCast(castState);
            continue;
        }

        // If the entity has moved, cancel the cast.
        Position& position{world.registry.get<Position>(entity)};
        if (PreviousPosition* prevPosition{
                world.registry.try_get<PreviousPosition>(entity)}) {
            if (position != *prevPosition) {
                cancelCast(castState);
                continue;
            }
        }

        // If the cast has reached its finish time, finish it.
        if (currentTick == castState.endTick) {
            // Check that the cast is still valid, cancel it if not.
            if (!castIsValid(castState.castInfo, position)) {
                cancelCast(castState);
                continue;
            }

            finishCast(castState);
            continue;
        }
    }
}

void CastSystem::startCast(CastState& castState)
{
    // Note: CastHelper ensures that castState.castInfo.casterEntity is the 
    //       same entity that owns castState.

    // If this castable has any visuals, send a CastStarted to all nearby 
    // clients.
    // Note: If it has no visuals, there's no reason for a client to replicate
    //       it. Thus, we can skip sending the message.
    CastInfo& castInfo{castState.castInfo};
    if (castInfo.castable->hasVisuals()) {
        sendCastStarted(castState);
    }

    // If this cast triggers the GCD, track it.
    // Note: If CastCooldown gets created here, its lastUpdateTick will be
    //       set to currentTick.
    // Note: CastCooldown may get created here even if it isn't used. That's 
    //       fine, the entity has at least shown the capability to cast things.
    Uint32 currentTick{simulation.getCurrentTick()};
    CastCooldown& castCooldown{world.registry.get_or_emplace<CastCooldown>(
        castInfo.casterEntity, currentTick)};
    if (castInfo.castable->triggersGCD) {
        castCooldown.gcdTicksRemaining
            = SharedConfig::CAST_GLOBAL_COOLDOWN_TICKS;
    }

    // If this is an instant cast, finish it immediately.
    if (castInfo.castable->castTime == 0) {
        finishCast(castState);
    }
    else {
        // Not an instant cast. Set its end tick.
        Uint32 castTimeTicks{static_cast<Uint32>(
            castInfo.castable->castTime / SharedConfig::SIM_TICK_TIMESTEP_S)};
        castState.endTick = currentTick + castTimeTicks;
    }
}

void CastSystem::cancelCast(CastState& castState)
{
    // If this castable has any visuals, send a CastFailed to all 
    // nearby clients.
    // Note: If it has no visuals, there's no reason for a client 
    //       to replicate it. Thus, we can skip sending the message.
    CastInfo& castInfo{castState.castInfo};
    if (castInfo.castable->hasVisuals()) {
        sendCastFailed(castState, CastFailureType::Movement);
    }

    // Reset the GCD.
    CastCooldown& castCooldown{
        world.registry.get<CastCooldown>(castInfo.casterEntity)};
    castCooldown.gcdTicksRemaining = 0;

    // Cancel the cast.
    world.registry.erase<CastState>(castInfo.casterEntity);
}

void CastSystem::finishCast(CastState& castState)
{
    // If this castable has a cooldown, track it.
    const CastInfo& castInfo{castState.castInfo};
    if (castInfo.castable->cooldownTime > 0) {
        Uint32 castTimeTicks{
            static_cast<Uint32>(castInfo.castable->cooldownTime
                                / SharedConfig::SIM_TICK_TIMESTEP_S)};

        CastCooldown& castCooldown{
            world.registry.get<CastCooldown>(castInfo.casterEntity)};
        castCooldown.cooldowns.emplace_back(castInfo.castable->castableID,
                                            castTimeTicks);
    }

    // Handle the cast.
    handleCast(castState.castInfo);
    world.registry.erase<CastState>(castState.castInfo.casterEntity);
}

void CastSystem::sendCastStarted(CastState& castState)
{
    // Serialize a CastStarted message.
    CastInfo& castInfo{castState.castInfo};
    CastStarted castStarted{.casterEntity{castInfo.casterEntity},
                            .castableID{castInfo.castable->castableID},
                            .targetEntity{castInfo.targetEntity},
                            .targetPosition{castInfo.targetPosition}};
    BinaryBufferSharedPtr message{network.serialize(castStarted)};

    // Get the list of entities that are in range of the caster entity.
    const std::vector<entt::entity>* entitiesInRange{nullptr};
    if (const auto* client
        = world.registry.try_get<ClientSimData>(castInfo.casterEntity)) {
        // Clients already have their AOI list built.
        entitiesInRange = &(client->entitiesInAOI);
    }
    else {
        const auto& casterEntityPosition{
            world.registry.get<Position>(castInfo.casterEntity)};
        entitiesInRange = &(world.entityLocator.getEntities(
            Cylinder{casterEntityPosition, SharedConfig::AOI_RADIUS,
                     SharedConfig::AOI_HALF_HEIGHT}));
    }

    // Send the update to all nearby clients.
    // Note: We skip the caster so that they don't restart a cast that they're
    //       already replicating.
    auto view{world.registry.view<Position, ClientSimData>()};
    for (entt::entity entity : *entitiesInRange) {
        if ((entity != castInfo.casterEntity) && view.contains(entity)) {
            const auto& client{view.get<ClientSimData>(entity)};
            network.send(client.netID, message);
        }
    }
}

void CastSystem::sendCastFailed(CastState& castState,
                                CastFailureType failureType)
{
    // Serialize a CastFailed message.
    CastInfo& castInfo{castState.castInfo};
    CastFailed castFailed{.casterEntity{castInfo.casterEntity},
                          .castableID{castInfo.castable->castableID},
                          .castFailureType{failureType}};
    BinaryBufferSharedPtr message{network.serialize(castFailed)};

    // Get the list of entities that are in range of the caster entity.
    const std::vector<entt::entity>* entitiesInRange{nullptr};
    if (const auto* client
        = world.registry.try_get<ClientSimData>(castInfo.casterEntity)) {
        // Clients already have their AOI list built.
        entitiesInRange = &(client->entitiesInAOI);
    }
    else {
        const auto& casterEntityPosition{
            world.registry.get<Position>(castInfo.casterEntity)};
        entitiesInRange = &(world.entityLocator.getEntities(
            Cylinder{casterEntityPosition, SharedConfig::AOI_RADIUS,
                     SharedConfig::AOI_HALF_HEIGHT}));
    }

    // Send the update to all nearby clients.
    // Note: We skip the caster since clients predict all of the same types 
    //       of failure for their own player entity.
    auto view{world.registry.view<Position, ClientSimData>()};
    for (entt::entity entity : *entitiesInRange) {
        if ((entity != castInfo.casterEntity) && view.contains(entity)) {
            const auto& client{view.get<ClientSimData>(entity)};
            network.send(client.netID, message);
        }
    }
}

void CastSystem::handleCast(const CastInfo& castInfo)
{
    // Pass this cast to the appropriate handler.
    if (auto* type{std::get_if<ItemInteractionType>(
            &(castInfo.castable->castableID))}) {
        auto& map{world.castHelper.onItemInteractionCompletedMap};
        auto it{map.find(*type)};
        if (it != map.end()) {
            it->second(castInfo);
        }
    }
    else if (auto* type{std::get_if<EntityInteractionType>(
                 &(castInfo.castable->castableID))}) {
        auto& map{world.castHelper.onEntityInteractionCompletedMap};
        auto it{map.find(*type)};
        if (it != map.end()) {
            it->second(castInfo);
        }
    }
    else if (auto* type{
                 std::get_if<SpellType>(&(castInfo.castable->castableID))}) {
        auto& map{world.castHelper.onSpellCompletedMap};
        auto it{map.find(*type)};
        if (it != map.end()) {
            it->second(castInfo);
        }
    }
}

bool CastSystem::castIsValid(const CastInfo& castInfo,
                             const Vector3& casterPosition)
{
    const Castable& castable{*(castInfo.castable)};
    Castable::TargetType targetType{castInfo.castable->targetType};
    entt::entity targetEntity{castInfo.targetEntity};
    if ((targetType == Castable::TargetType::Entity)
        || ((targetType == Castable::TargetType::SelfOrEntity)
            && (targetEntity != entt::null))) {
        // Check that the target entity is still alive.
        if (!(world.registry.valid(castInfo.targetEntity))) {
            return false;
        }

        // Check that the caster is in range of the target entity.
        const Position& targetPosition{
            world.registry.get<Position>(targetEntity)};
        float squaredRange{castable.range * castable.range};
        if (casterPosition.squaredDistanceTo(targetPosition) > squaredRange) {
            return false;
        }

        // Check that the target entity is in the caster's line of sight.
        if (!world.castHelper.isInLineOfSight(castInfo.casterEntity,
                                              targetEntity, casterPosition,
                                              targetPosition)) {
            return false;
        }
    }
    else if (targetType == Castable::TargetType::Circle) {
        // Check that the target position is within the map bounds.
        Cylinder targetCylinder{
            castable.getTargetCylinder(castInfo.targetPosition)};
        if (!(world.tileMap.getTileExtent().contains(targetCylinder))) {
            return false;
        }

        // Check that the caster is in range of the target position.
        float squaredDistance{
            casterPosition.squaredDistanceTo(castInfo.targetPosition)};
        if (squaredDistance > castable.range) {
            return false;
        }

        // Check that the target position is in the caster's line of sight.
        if (!world.castHelper.isInLineOfSight(castInfo.casterEntity,
                                              casterPosition,
                                              castInfo.targetPosition)) {
            return false;
        }
    }

    return true;
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/ChunkStreamingSystem.cpp`:

```cpp
#include "ChunkStreamingSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "ClientSimData.h"
#include "Sprite.h"
#include "Position.h"
#include "PreviousPosition.h"
#include "ChunkUpdate.h"
#include "Tile.h"
#include "ChunkWireSnapshot.h"
#include "SharedConfig.h"
#include "Log.h"
#include <SDL_rect.h>
#include "tracy/Tracy.hpp"
#include <vector>

namespace AM
{
namespace Server
{
ChunkStreamingSystem::ChunkStreamingSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, chunkDataRequestQueue{inSimContext.networkEventDispatcher}
{
}

void ChunkStreamingSystem::sendChunks()
{
    ZoneScoped;

    // Process all chunk data requests.
    ChunkDataRequest chunkDataRequest{};
    while (chunkDataRequestQueue.pop(chunkDataRequest)) {
        sendChunkUpdate(chunkDataRequest);
    }
}

void ChunkStreamingSystem::sendChunkUpdate(
    const ChunkDataRequest& chunkDataRequest)
{
    // Add the requested chunks to the message.
    ChunkUpdate chunkUpdate{};
    for (const ChunkPosition& requestedChunk :
         chunkDataRequest.requestedChunks) {
        addChunkToMessage(requestedChunk, chunkUpdate);
    }

    // Send the message.
    network.serializeAndSend(chunkDataRequest.netID, chunkUpdate);
}

void ChunkStreamingSystem::addChunkToMessage(const ChunkPosition& chunkPosition,
                                             ChunkUpdate& chunkUpdate)
{
    if (const Chunk* chunk{world.tileMap.cgetChunk(chunkPosition)}) {
        // Push the new chunk and get a ref to it.
        chunkUpdate.chunks.emplace_back();
        ChunkWireSnapshot& chunkSnapshot{chunkUpdate.chunks.back()};

        // Save the chunk's position.
        chunkSnapshot.x = chunkPosition.x;
        chunkSnapshot.y = chunkPosition.y;
        chunkSnapshot.z = chunkPosition.z;

        // Copy all of the chunk's tile layers into the snapshot.
        chunkSnapshot.tileLayers.resize(chunk->tileLayerCount);
        std::size_t tileLayersIndex{0};
        for (std::size_t tileIndex{0};
             tileIndex < SharedConfig::CHUNK_TILE_COUNT; tileIndex++) {
            // Add this tile's layer count.
            const Tile& tile{chunk->tiles[tileIndex]};
            chunkSnapshot.tileLayerCounts[tileIndex]
                = static_cast<Uint8>(tile.getAllLayers().size());

            // Add all of this tile's layers.
            for (const TileLayer& layer : tile.getAllLayers()) {
                std::size_t paletteIndex{chunkSnapshot.getPaletteIndex(
                    layer.type, layer.graphicSet.get().numericID,
                    layer.graphicValue)};
                chunkSnapshot.tileLayers[tileLayersIndex]
                    = static_cast<Uint8>(paletteIndex);
                tileLayersIndex++;

                // If this is a Floor or Object, add its tile offset.
                if ((layer.type == TileLayer::Type::Floor)
                    || (layer.type == TileLayer::Type::Object)) {
                    chunkSnapshot.tileOffsets.emplace_back(layer.tileOffset);
                }
            }
        }
    }
    else {
        // This chunk doesn't exist, we don't need to send anything.
    }
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Private/ClientAOISystem.cpp`:

```cpp
#include "ClientAOISystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "Serialize.h"
#include "ClientSimData.h"
#include "BoundingBox.h"
#include "Cylinder.h"
#include "ReplicatedComponent.h"
#include "EntityInit.h"
#include "EntityDelete.h"
#include "ReplicatedComponentList.h"
#include "SharedConfig.h"
#include "Log.h"
#include "tracy/Tracy.hpp"
#include "boost/mp11/list.hpp"
#include "boost/mp11/algorithm.hpp"
#include <algorithm>

#include "Timer.h"

namespace AM
{
namespace Server
{

/**
 * Retrieves the types in componentIndices for the given entity and pushes
 * them into componentVec.
 *
 * Note: This is a free function to reduce includes in the header.
 */
void addComponentsToVector(entt::registry& registry, entt::entity entity,
                           const std::vector<Uint8>& componentIndices,
                           std::vector<ReplicatedComponent>& componentVec)
{
    for (Uint8 componentIndex : componentIndices) {
        boost::mp11::mp_with_index<
            boost::mp11::mp_size<ReplicatedComponentTypes>>(
            componentIndex, [&](auto I) {
                using ComponentType
                    = boost::mp11::mp_at_c<ReplicatedComponentTypes, I>;
                if constexpr (std::is_empty_v<ComponentType>) {
                    // Note: Can't registry.get() empty types.
                    componentVec.push_back(ComponentType{});
                }
                else {
                    componentVec.push_back(registry.get<ComponentType>(entity));
                }
            });
    }
}

ClientAOISystem::ClientAOISystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, entitiesThatLeft{}
, entitiesThatEntered{}
{
}

void ClientAOISystem::updateAOILists()
{
    ZoneScoped;

    // Update every client entity's AOI list.
    auto view{world.registry.view<ClientSimData, Position>()};
    for (auto [entity, client, position] : view.each()) {
        // Clear our lists.
        entitiesThatLeft.clear();
        entitiesThatEntered.clear();

        // Get the list of entities that are in this entity's AOI.
        std::vector<entt::entity>& currentAOIEntities{
            world.entityLocator.getEntities(
                Cylinder{position, SharedConfig::AOI_RADIUS,
                         SharedConfig::AOI_HALF_HEIGHT})};

        // Sort the list.
        std::sort(currentAOIEntities.begin(), currentAOIEntities.end());

        // Fill entitiesThatLeft with the entities that left this entity's AOI.
        std::vector<entt::entity>& oldAOIEntities{client.entitiesInAOI};
        std::set_difference(oldAOIEntities.begin(), oldAOIEntities.end(),
                            currentAOIEntities.begin(),
                            currentAOIEntities.end(),
                            std::back_inserter(entitiesThatLeft));

        // Process the entities that left this entity's AOI.
        if (entitiesThatLeft.size() > 0) {
            processEntitiesThatLeft(client);
        }

        // Fill entitiesThatEntered with the entities that entered this entity's
        // AOI.
        std::set_difference(currentAOIEntities.begin(),
                            currentAOIEntities.end(), oldAOIEntities.begin(),
                            oldAOIEntities.end(),
                            std::back_inserter(entitiesThatEntered));

        // Process the entities that entered this entity's AOI.
        if (entitiesThatEntered.size() > 0) {
            processEntitiesThatEntered(client);
        }

        // Save the new list.
        client.entitiesInAOI = currentAOIEntities;
    }
}

void ClientAOISystem::processEntitiesThatLeft(ClientSimData& client)
{
    // Send the client an EntityDelete for each entity that left its AOI.
    for (entt::entity entityThatLeft : entitiesThatLeft) {
        network.serializeAndSend(
            client.netID,
            EntityDelete{simulation.getCurrentTick(), entityThatLeft});
    }
}

void ClientAOISystem::processEntitiesThatEntered(ClientSimData& client)
{
    entt::registry& registry{world.registry};

    // Send the client an EntityInit containing each entity that entered its
    // AOI.
    EntityInit entityInit{simulation.getCurrentTick()};
    for (entt::entity entityThatEntered : entitiesThatEntered) {
        const auto& replicatedComponentList{
            registry.get<ReplicatedComponentList>(entityThatEntered)};

        // Add the entity and all of its client-relevant components to the
        // message.
        // Note: We send the entity, even if it has no client-relevant
        // component,
        //       because there may be a build mode that cares about it.
        EntityInit::EntityData& entityData{entityInit.entityData.emplace_back(
            entityThatEntered, registry.get<Position>(entityThatEntered))};
        addComponentsToVector(registry, entityThatEntered,
                              replicatedComponentList.typeIndices,
                              entityData.components);
    }

    // Send the message.
    network.serializeAndSend(client.netID, entityInit);
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/ClientConnectionSystem.cpp`:

```cpp
#include "ClientConnectionSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "GraphicData.h"
#include "SharedConfig.h"
#include "Serialize.h"
#include "ConnectionResponse.h"
#include "Input.h"
#include "Rotation.h"
#include "Position.h"
#include "PreviousPosition.h"
#include "Name.h"
#include "Inventory.h"
#include "ClientSimData.h"
#include "IsClientEntity.h"
#include "GraphicState.h"
#include "VariantTools.h"
#include "Log.h"
#include "tracy/Tracy.hpp"

namespace AM
{
namespace Server
{
ClientConnectionSystem::ClientConnectionSystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, graphicData{inSimContext.graphicData}
, clientConnectionEventQueue{network.getEventDispatcher()}
{
}

void ClientConnectionSystem::processConnectionEvents()
{
    ZoneScoped;

    // Process all newly connected or disconnected entities.
    for (std::size_t i{0}; i < clientConnectionEventQueue.size(); ++i) {
        ClientConnectionEvent clientConnectionEvent{};
        if (!(clientConnectionEventQueue.pop(clientConnectionEvent))) {
            LOG_ERROR("Expected element but pop failed.");
        }

        std::visit(VariantTools::Overload{
                       [&](const ClientConnected& clientConnected) {
                           processConnectEvent(clientConnected);
                       },
                       [&](const ClientDisconnected& clientDisconnected) {
                           processDisconnectEvent(clientDisconnected);
                       }},
                   clientConnectionEvent);
    }
}

void ClientConnectionSystem::processConnectEvent(
    const ClientConnected& clientConnected)
{
    entt::registry& registry{world.registry};

    // Create the entity and construct its standard components.
    // Note: Be careful with holding onto references here. If components
    //       are added to the same group, the ref will be invalidated.
    entt::entity newEntity{world.createEntity(world.getSpawnPoint())};

    // TODO: When player accounts are added, a lot of this should be changed to
    //       load the persisted data from the account.
    registry.emplace<IsClientEntity>(newEntity);
    registry.emplace<Name>(
        newEntity, "Player " + std::to_string(static_cast<Uint32>(newEntity)));
    registry.emplace<Inventory>(newEntity);

    registry.emplace<ClientSimData>(newEntity, clientConnected.clientID,
                                    std::vector<entt::entity>());

    world.addMovementComponents(newEntity);

    const EntityGraphicSet& graphicSet{graphicData.getEntityGraphicSet(
        SharedConfig::DEFAULT_ENTITY_GRAPHIC_SET)};
    GraphicState graphicState{graphicSet.numericID};
    world.addGraphicsComponents(newEntity, graphicState);

    // Set the default client entity collision.
    registry.patch<CollisionBitSets>(
        newEntity, [&](CollisionBitSets& collisionBitSets) {
            collisionBitSets.setCollisionLayers(
                CollisionLayerType::ClientEntity, newEntity, registry);
            collisionBitSets.setCollisionMask(
                CollisionLayerType::TerrainWall
                | CollisionLayerType::BlockCollision);
        });

    // Add the new client entity to the network ID map.
    world.netIDMap[clientConnected.clientID] = newEntity;

    LOG_INFO("Constructed client entity with netID: %u, entityID: %u",
             clientConnected.clientID, newEntity);

    // Build and send the response.
    sendConnectionResponse(clientConnected.clientID, newEntity);
}

void ClientConnectionSystem::processDisconnectEvent(
    const ClientDisconnected& clientDisconnected)
{
    // Find the disconnected client's associated entity.
    auto disconnectedEntityIt{
        world.netIDMap.find(clientDisconnected.clientID)};
    if (disconnectedEntityIt != world.netIDMap.end()) {
        // Found the entity. Destroy it and remove it from the network ID map.
        // Note: This will cause it to be removed from the entity locator, 
        //       triggering ClientAOISystem to tell peers to delete it.
        entt::entity disconnectedEntity{disconnectedEntityIt->second};
        world.registry.destroy(disconnectedEntity);
        world.netIDMap.erase(disconnectedEntityIt);

        LOG_INFO("Removed entity with entityID: %u", disconnectedEntity);
    }
    else {
        LOG_ERROR("Failed to find entity with netID: %u while erasing.",
                  clientDisconnected.clientID);
    }
}

void ClientConnectionSystem::sendConnectionResponse(NetworkID networkID,
                                                    entt::entity newEntity)
{
    // Fill in the current tick and their entity's ID.
    ConnectionResponse connectionResponse{};
    Uint32 currentTick{simulation.getCurrentTick()};
    connectionResponse.entity = newEntity;
    connectionResponse.tickNum = currentTick;

    // Fill in the map's size.
    const ChunkExtent& mapChunkExtent{world.tileMap.getChunkExtent()};
    connectionResponse.mapXLengthChunks = mapChunkExtent.xLength;
    connectionResponse.mapYLengthChunks = mapChunkExtent.yLength;
    connectionResponse.mapZLengthChunks = mapChunkExtent.zLength;

    // Send the connection response message.
    network.serializeAndSend(networkID, connectionResponse, currentTick);
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/ComponentChangeSystem.cpp`:

```cpp
#include "ComponentChangeSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "GraphicData.h"
#include "CollisionBitSets.h"
#include "Position.h"
#include "Collision.h"
#include "Input.h"
#include "ClientSimData.h"
#include "IsClientEntity.h"
#include "ISimulationExtension.h"
#include "Transforms.h"
#include "Log.h"
#include "tracy/Tracy.hpp"

namespace AM
{
namespace Server
{
ComponentChangeSystem::ComponentChangeSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, graphicData{inSimContext.graphicData}
, extension{nullptr}
, entityNameChangeRequestQueue{inSimContext.networkEventDispatcher}
, graphicStateChangeRequestQueue{inSimContext.networkEventDispatcher}
{
    world.registry.on_update<GraphicState>()
        .connect<&ComponentChangeSystem::onGraphicStateUpdated>(this);
    world.registry.on_update<CollisionBitSets>()
        .connect<&ComponentChangeSystem::onCollisionBitSetsUpdated>(this);
}

void ComponentChangeSystem::processChangeRequests()
{
    ZoneScoped;

    entt::registry& registry{world.registry};

    // Process any waiting update requests.
    EntityNameChangeRequest nameChangeRequest{};
    while (entityNameChangeRequestQueue.pop(nameChangeRequest)) {
        // If the entity isn't valid, skip it.
        if (!(registry.valid(nameChangeRequest.entity))) {
            continue;
        }
        // If the project says the request isn't valid, skip it.
        else if (!(extension->isEntityNameChangeRequestValid(
                     nameChangeRequest))) {
            continue;
        }

        registry.replace<Name>(nameChangeRequest.entity,
                               nameChangeRequest.name);
    }

    GraphicStateChangeRequest graphicStateChangeRequest{};
    while (graphicStateChangeRequestQueue.pop(graphicStateChangeRequest)) {
        // If the entity isn't valid, skip it.
        if (!(registry.valid(graphicStateChangeRequest.entity))) {
            continue;
        }
        // If the project says the request isn't valid, skip it.
        else if (!(extension->isGraphicStateChangeRequestValid(
                     graphicStateChangeRequest))) {
            continue;
        }

        registry.replace<GraphicState>(
            graphicStateChangeRequest.entity,
            graphicStateChangeRequest.graphicState);
    }
}

void ComponentChangeSystem::setExtension(ISimulationExtension* inExtension)
{
    extension = inExtension;
}

void ComponentChangeSystem::onGraphicStateUpdated(entt::registry& registry,
                                                  entt::entity entity)
{
    // Since the graphic state was updated, we need to update the entity's
    // collision.
    auto [position, graphicState]
        = registry.get<Position, GraphicState>(entity);
    const EntityGraphicSet& graphicSet{
        graphicData.getEntityGraphicSet(graphicState.graphicSetID)};

    // Note: We assume that an entity with GraphicState always has a
    //       Collision and CollisionBitSets.
    const BoundingBox& modelBounds{graphicSet.getCollisionModelBounds()};
    const Collision& collision{
        registry.patch<Collision>(entity, [&](Collision& collision) {
            collision.modelBounds = modelBounds;
            collision.worldBounds
                = Transforms::modelToWorldEntity(modelBounds, position);
        })};

    // Update their collision in the locator.
    const CollisionBitSets& collisionBitSets{
        registry.get<CollisionBitSets>(entity)};
    world.collisionLocator.updateEntity(entity, collision.worldBounds,
                                        collisionBitSets.getCollisionLayers());
}

void ComponentChangeSystem::onCollisionBitSetsUpdated(entt::registry& registry,
                                                      entt::entity entity)
{
    // Note: We assume that an entity with a CollisionBitSets always has a 
    //       Collision.
    const auto [collision, collisionBitSets]
        = registry.get<Collision, CollisionBitSets>(entity);
    world.collisionLocator.updateEntity(entity, collision.worldBounds,
                                        collisionBitSets.getCollisionLayers());
}

} // namespace Server
} // namespace AM
```

`Source/ServerLib/Simulation/Private/ComponentSyncSystem.cpp`:

```cpp
#include "ComponentSyncSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "GraphicData.h"
#include "EngineObservedComponentTypes.h"
#include "ProjectObservedComponentTypes.h"
#include "ReplicatedComponent.h"
#include "EnttObserver.h"
#include "ClientSimData.h"
#include "Cylinder.h"
#include "Collision.h"
#include "SharedConfig.h"
#include "Log.h"
#include "boost/mp11/algorithm.hpp"
#include "boost/mp11/map.hpp"
#include "boost/mp11/bind.hpp"
#include "tracy/Tracy.hpp"

namespace AM
{
namespace Server
{

/**
 * See comment in EngineObservedComponents.h
 */
using ObservedComponentTypes
    = boost::mp11::mp_append<EngineObservedComponentTypes,
                             ProjectObservedComponentTypes>;

/** A construct and update observer for each observed component type. */
std::array<EnttObserver, boost::mp11::mp_size<ObservedComponentTypes>::value>
    updateObservers{};

/** A destruct observer for each observed component type. */
std::array<EnttObserver, boost::mp11::mp_size<ObservedComponentTypes>::value>
    destroyObservers{};

ComponentSyncSystem::ComponentSyncSystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, graphicData{inSimContext.graphicData}
{
    boost::mp11::mp_for_each<ObservedComponentTypes>([&](auto I) {
        using ComponentType = decltype(I);
        constexpr std::size_t typeIndex{
            boost::mp11::mp_find<ObservedComponentTypes,
                                 ComponentType>::value};

        // TODO: If a client is near an entity when it's constructed, it'll
        //       receive both an EntityInit and a ComponentUpdate (from the
        //       construct observer). It'd be nice if we could find a way to just
        //       send one, but until then it isn't a huge cost.
        updateObservers[typeIndex].bind(world.registry);
        updateObservers[typeIndex]
            .template on_construct<ComponentType>()
            .template on_update<ComponentType>();

        destroyObservers[typeIndex].bind(world.registry);
        destroyObservers[typeIndex].on_destroy<ComponentType>();
    });
}

void ComponentSyncSystem::sendUpdates()
{
    ZoneScoped;

    entt::registry& registry{world.registry};

    // TODO: We build a message for each updated entity, even if it doesn't 
    //       exist anymore or there aren't any clients nearby to send it to.
    //       There may be ways to optimize by making it client-by-client like 
    //       MovementSyncSystem.
    // Build a ComponentUpdate for each entity that has constructed, updated, 
    // or destroyed components.
    boost::mp11::mp_for_each<ObservedComponentTypes>([&](auto I) {
        using ComponentType = decltype(I);
        constexpr std::size_t observedTypeIndex{
            boost::mp11::mp_find<ObservedComponentTypes,
                                 ComponentType>::value};
        constexpr std::size_t replicatedTypeIndex{
            boost::mp11::mp_find<ReplicatedComponentTypes,
                                 ComponentType>::value};

        // For each entity that has a constructed or updated component of this 
        // type, push the component into the entity's message.
        for (entt::entity entity : updateObservers[observedTypeIndex]) {
            // If the entity no longer has this component (it was constructed/
            // destructed on the same tick), don't send it.
            if (!registry.all_of<ComponentType>(entity)) {
                continue;
            }

            if constexpr (std::is_empty_v<ComponentType>) {
                // Note: Can't registry.get() empty types.
                componentUpdateMap[entity].updatedComponents.push_back(
                    ComponentType{});
            }
            else {
                const auto& component{registry.get<ComponentType>(entity)};
                componentUpdateMap[entity].updatedComponents.emplace_back(
                    component);
            }
        }

        // For each entity that has a destroyed component of this type, push 
        // the component into the entity's message.
        // Note: The message uses the index from ReplicatedComponentTypes.
        for (entt::entity entity : destroyObservers[observedTypeIndex]) {
            componentUpdateMap[entity].destroyedComponents.emplace_back(
                static_cast<Uint8>(replicatedTypeIndex));
        }

        updateObservers[observedTypeIndex].clear();
        destroyObservers[observedTypeIndex].clear();
    });

    // Send each update to all nearby clients.
    auto view{registry.view<Position, ClientSimData>()};
    for (auto& [updatedEntity, componentUpdate] : componentUpdateMap) {
        // If the entity doesn't exist anymore, skip it.
        if (!(world.registry.valid(updatedEntity))) {
            continue;
        }

        // Serialize the message.
        componentUpdate.entity = updatedEntity;
        componentUpdate.tickNum = simulation.getCurrentTick();
        BinaryBufferSharedPtr message{network.serialize(componentUpdate)};

        // Get the list of entities that are in range of the updated entity.
        const std::vector<entt::entity>* entitiesInRange{nullptr};
        if (const auto* client
            = registry.try_get<ClientSimData>(updatedEntity)) {
            // Clients already have their AOI list built.
            entitiesInRange = &(client->entitiesInAOI);
        }
        else {
            const auto& updatedEntityPosition{
                world.registry.get<Position>(updatedEntity)};
            entitiesInRange = &(world.entityLocator.getEntities(
                Cylinder{updatedEntityPosition, SharedConfig::AOI_RADIUS,
                         SharedConfig::AOI_HALF_HEIGHT}));
        }

        // Send the update to all nearby clients.
        for (entt::entity entity : *entitiesInRange) {
            if (view.contains(entity)) {
                const auto& client{view.get<ClientSimData>(entity)};
                network.send(client.netID, message, componentUpdate.tickNum);
            }
        }
    }

    componentUpdateMap.clear();
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/Components/StoredValues.cpp`:

```cpp
#include "StoredValues.h"
#include "World.h"

namespace AM
{
namespace Server
{

bool StoredValues::storeValue(std::string_view stringID, Uint32 newValue,
                              World& world)
{
    // Try to get a numeric ID for the given string ID.
    EntityStoredValueID numericID{world.getEntityStoredValueID(stringID)};
    if (!numericID) {
        return false;
    }

    // If we're setting the value to 0, don't add it to the map (default values 
    // don't need to be stored).
    if (newValue == 0) {
        // If the value already exists, erase it.
        auto valueIt{valueMap.find(numericID)};
        if (valueIt != valueMap.end()) {
            valueMap.erase(valueIt);
        }

        return true;
    }

    valueMap[numericID] = newValue;
    return true;
}

Uint32 StoredValues::getStoredValue(std::string_view stringID, World& world)
{
    // Try to get the numeric ID for the given string ID.
    EntityStoredValueID numericID{world.getEntityStoredValueID(stringID)};
    if (!numericID) {
        return 0;
    }

    // If the value exists, return it.
    auto valueIt{valueMap.find(numericID)};
    if (valueIt != valueMap.end()) {
        return valueIt->second;
    }

    // Value doesn't exist. Return the default.
    return 0;
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Private/Database.cpp`:

```cpp
#include "Database.h"
#include "EnginePersistedComponentTypes.h"
#include "ProjectPersistedComponentTypes.h"
#include "Paths.h"
#include "AMAssert.h"
#include "Log.h"
#include "SQLiteCpp/VariadicBind.h"
#include "SQLiteCpp/Backup.h"

#include <sqlite3.h>

#ifdef SQLITECPP_ENABLE_ASSERT_HANDLER
namespace SQLite
{
void assertion_failed(char const* apFile, int apLine, char const* apFunc,
                      char const* apExpr, char const* apMsg)
{
    LOG_ERROR("%s: %s: error: assertion failed(%s) in %s() with message \"%s\"",
              apFile, apLine, apExpr, apFunc, apMsg);
}
} // namespace SQLite
#endif

namespace AM
{
namespace Server
{
Database::Database()
: database{":memory:", SQLite::OPEN_READWRITE | SQLite::OPEN_CREATE}
, backupDatabase{(Paths::BASE_PATH + "/Database.db3"),
                 SQLite::OPEN_READWRITE | SQLite::OPEN_CREATE}
, currentTransaction{}
, backupThreadObj{}
, exitRequested{false} 
, backupMutex{}
, backupCondVar{}
, backupRequested{false}
, insertEntityQuery{nullptr}
, deleteEntityQuery{nullptr}
, iterateEntitiesQuery{nullptr}
, insertItemQuery{nullptr}
, deleteItemQuery{nullptr}
, iterateItemsQuery{nullptr}
, insertEntityStoredValueIDMapQuery{nullptr}
, getEntityStoredValueIDMapQuery{nullptr}
, insertGlobalStoredValueMapQuery{nullptr}
, getGlobalStoredValueMapQuery{nullptr}
{
    // If any of our tables don't exist in Database.db3, initialize them.
    initTables();

    // Load the data from Database.db3 into our in-memory database.
    SQLite::Backup backup(database, backupDatabase);
    backup.executeStep(-1);

    // Note: We build these queries after initTables() because they'll 
    //       segfault if there's no DB with the expected fields.
    insertEntityQuery = std::make_unique<SQLite::Statement>(
        database,
        "INSERT INTO entities VALUES (?, ?, ?) "
        "ON CONFLICT(id) DO UPDATE SET "
        "serializedEngineComponents=excluded.serializedEngineComponents, "
        "serializedProjectComponents=excluded.serializedProjectComponents");
    deleteEntityQuery = std::make_unique<SQLite::Statement>(
        database, "DELETE FROM entities WHERE id=?");
    iterateEntitiesQuery = std::make_unique<SQLite::Statement>(
        backupDatabase, "SELECT * FROM entities");

    insertItemQuery = std::make_unique<SQLite::Statement>(
        database,
        "INSERT INTO items VALUES (?, ?, ?, ?) "
        "ON CONFLICT(id) DO UPDATE SET serializedItem=excluded.serializedItem, "
        "version=excluded.version, initScript=excluded.initScript");
    deleteItemQuery = std::make_unique<SQLite::Statement>(
        database, "DELETE FROM items WHERE id=?");
    iterateItemsQuery = std::make_unique<SQLite::Statement>(
        backupDatabase, "SELECT * FROM items");

    insertEntityStoredValueIDMapQuery = std::make_unique<SQLite::Statement>(
        database, "UPDATE entityStoredValueIDMap SET serializedMap=(?)");
    getEntityStoredValueIDMapQuery = std::make_unique<SQLite::Statement>(
        backupDatabase, "SELECT * FROM entityStoredValueIDMap");

    insertGlobalStoredValueMapQuery = std::make_unique<SQLite::Statement>(
        database, "UPDATE globalStoredValueMap SET serializedMap=(?)");
    getGlobalStoredValueMapQuery = std::make_unique<SQLite::Statement>(
        backupDatabase, "SELECT * FROM globalStoredValueMap");

    // Check for any out of date data.
    checkDataVersions();

    // Start the backup thread.
    backupThreadObj = std::thread(&Database::performBackup, this);
}

Database::~Database()
{
    exitRequested = true;

    {
        std::unique_lock lock{backupMutex};
        backupRequested = true;
    }
    backupCondVar.notify_one();
    backupThreadObj.join();
}

void Database::startTransaction()
{
    if (currentTransaction) {
        LOG_ERROR("Tried to start a transaction while one was ongoing.");
        return;
    }

    currentTransaction.emplace(database);
}

void Database::commitTransaction()
{
    if (!currentTransaction) {
        LOG_ERROR("Tried to commit a transaction when no transaction was "
                  "ongoing.");
    }

    try {
        currentTransaction.value().commit();
    } catch (std::exception& e) {
        LOG_ERROR("Failed to commit transaction: %s", e.what());
    }

    currentTransaction.reset();
}

void Database::backupToFile()
{
    if (backupRequested) {
        LOG_INFO("Tried to begin database backup while a backup was already "
                 "underway.");
        return;
    }

    // Wake the backup thread.
    {
        std::unique_lock lock{backupMutex};
        backupRequested = true;
    }
    backupCondVar.notify_one();
}

bool Database::backupIsInProgress()
{
    return backupRequested.load();
}

void Database::saveEntityData(entt::entity entity,
                              std::span<const Uint8> serializedEngineComponents,
                              std::span<const Uint8> serializedProjectComponents)
{
    try {
        insertEntityQuery->bind(1, static_cast<int>(entity));
        insertEntityQuery->bind(
            2, serializedEngineComponents.data(),
            static_cast<int>(serializedEngineComponents.size()));
        insertEntityQuery->bind(
            3, serializedProjectComponents.data(),
            static_cast<int>(serializedProjectComponents.size()));

        insertEntityQuery->exec();

        insertEntityQuery->reset();
    } catch (std::exception& e) {
        LOG_ERROR("Failed to save entity data: %s", e.what());
    }
}

void Database::deleteEntityData(entt::entity entity)
{
    try {
        deleteEntityQuery->bind(1, static_cast<int>(entity));

        deleteEntityQuery->exec();

        deleteEntityQuery->reset();
    } catch (std::exception& e) {
        LOG_ERROR("Failed to delete entity data: %s", e.what());
    }
}

void Database::saveItemData(ItemID itemID,
                            std::span<const Uint8> serializedItem,
                            ItemVersion version, std::string_view initScript)
{
    try {
        insertItemQuery->bind(1, static_cast<int>(itemID));
        insertItemQuery->bind(2, serializedItem.data(),
                              static_cast<int>(serializedItem.size()));
        insertItemQuery->bind(3, static_cast<int>(version));
        insertItemQuery->bind(4, initScript.data(),
                              static_cast<int>(initScript.size()));

        insertItemQuery->exec();

        insertItemQuery->reset();
    } catch (std::exception& e) {
        LOG_ERROR("Failed to save item data: %s", e.what());
    }
}

void Database::deleteItemData(ItemID itemID)
{
    try {
        deleteItemQuery->bind(1, static_cast<int>(itemID));

        deleteItemQuery->exec();

        deleteItemQuery->reset();
    } catch (std::exception& e) {
        LOG_ERROR("Failed to delete item data: %s", e.what());
    }
}

void Database::saveEntityStoredValueIDMap(std::span<const Uint8> serializedMap)
{
    try {
        insertEntityStoredValueIDMapQuery->bind(
            1, serializedMap.data(), static_cast<int>(serializedMap.size()));

        insertEntityStoredValueIDMapQuery->exec();

        insertEntityStoredValueIDMapQuery->reset();
    } catch (std::exception& e) {
        LOG_ERROR("Failed to save entity stored value ID map data: %s",
                  e.what());
    }
}

void Database::saveGlobalStoredValueMap(std::span<const Uint8> serializedMap)
{
    try {
        insertGlobalStoredValueMapQuery->bind(
            1, serializedMap.data(), static_cast<int>(serializedMap.size()));

        insertGlobalStoredValueMapQuery->exec();

        insertGlobalStoredValueMapQuery->reset();
    } catch (std::exception& e) {
        LOG_ERROR("Failed to save global stored value map data: %s", e.what());
    }
}

void Database::initTables()
{
    // The below commands define the schema for Database.db3.
    // Note: We only need to init the file-backed database, since the in-memory
    //       database will copy it.
    try {
        // Version numbers for all data in this database that needs to support 
        // migration.
        if (!backupDatabase.tableExists("versions")) {
            backupDatabase.exec(
                "CREATE TABLE versions (id INTEGER PRIMARY KEY, "
                "name TEXT, versionNumber INTEGER)");

            SQLite::Statement insertVersionQuery{
                backupDatabase, "INSERT INTO versions VALUES (?, ?, ?)"};

            int versionsKey{0};
            insertVersionQuery.bind(1, versionsKey++);
            insertVersionQuery.bind(2, "EngineComponents");
            insertVersionQuery.bind(3, ENGINE_COMPONENTS_VERSION);
            insertVersionQuery.exec();
            insertVersionQuery.reset();

            insertVersionQuery.bind(1, versionsKey++);
            insertVersionQuery.bind(2, "ProjectComponents");
            insertVersionQuery.bind(3, PROJECT_COMPONENTS_VERSION);
            insertVersionQuery.exec();
            insertVersionQuery.reset();
        }

        // Entity components.
        if (!backupDatabase.tableExists("entities")) {
            // The component lists need to be serialized separately, so we can 
            // migrate them separately. If we tried to serialize them together, 
            // there may be situations where both lists need to be updated at 
            // the same time, which we can't do with a split migration setup.
            backupDatabase.exec(
                "CREATE TABLE entities (id INTEGER PRIMARY KEY, "
                "serializedEngineComponents BLOB, serializedProjectComponents "
                "BLOB)");
        }

        // Items.
        if (!backupDatabase.tableExists("items")) {
            backupDatabase.exec(
                "CREATE TABLE items (id INTEGER PRIMARY KEY, "
                "serializedItem BLOB, version INTEGER, initScript TEXT)");
        }

        // Entity stored values, stored as a single serialized map.
        if (!backupDatabase.tableExists("entityStoredValueIDMap")) {
            backupDatabase.exec(
                "CREATE TABLE entityStoredValueIDMap (serializedMap BLOB)");
            // Since we're only storing 1 value in this table, we init the row
            // here so we can use UPDATEs later.
            backupDatabase.exec(
                "INSERT INTO entityStoredValueIDMap VALUES('')");
        }

        // Global stored values, stored as a single serialized map.
        if (!backupDatabase.tableExists("globalStoredValueMap")) {
            backupDatabase.exec(
                "CREATE TABLE globalStoredValueMap (serializedMap BLOB)");
            // Since we're only storing 1 value in this table, we init the row
            // here so we can use UPDATEs later.
            backupDatabase.exec("INSERT INTO globalStoredValueMap VALUES('')");
        }
    } catch (std::exception& e) {
        LOG_ERROR("Failed to init table: %s", e.what());
    }
}

void Database::checkDataVersions()
{
    // Iterate through each version row.
    SQLite::Statement getVersionQuery{database, "SELECT * FROM versions"};
    std::vector<std::string> requiredMigrations{};
    while (getVersionQuery.executeStep()) {
        const char* name{getVersionQuery.getColumn(1).getText()};
        unsigned int versionNumber{
            static_cast<unsigned int>(getVersionQuery.getColumn(2).getInt())};

        // Match the name to one of our expected names and check the version 
        // number. If it's newer than the code, fail immediately. If it's 
        // older, push the required migrations.
        if (std::strcmp(name, "EngineComponents") == 0) {
            if (versionNumber > ENGINE_COMPONENTS_VERSION) {
                LOG_FATAL("Database load error: Data version (v%u) is newer "
                          "than code (v%u) (EngineComponents).",
                          versionNumber, ENGINE_COMPONENTS_VERSION);
            }
            else if (versionNumber < ENGINE_COMPONENTS_VERSION) {
                requiredMigrations.push_back(
                    "EngineComponents v" + std::to_string(versionNumber)
                    + " -> v" + std::to_string(ENGINE_COMPONENTS_VERSION));
            }
        }
        else if (std::strcmp(name, "ProjectComponents") == 0) {
            std::string dataVersion{std::to_string(versionNumber)};
            std::string codeVersion{std::to_string(PROJECT_COMPONENTS_VERSION)};
            if (versionNumber > PROJECT_COMPONENTS_VERSION) {
                LOG_FATAL("Database load error: Data version (v%u) is newer "
                          "than code (v%u) (ProjectComponents).",
                          versionNumber, PROJECT_COMPONENTS_VERSION);
            }
            else if (versionNumber < PROJECT_COMPONENTS_VERSION) {
                requiredMigrations.push_back(
                    "ProjectComponents v" + std::to_string(versionNumber)
                    + " -> v" + std::to_string(PROJECT_COMPONENTS_VERSION));
            }
        }
    }

    // If any data is out of date, print the required migrations and exit.
    if (!(requiredMigrations.empty())) {
        std::string errorText{"Database load error: Data version is older than "
                              "code version.\nRequired migrations:"};
        for (const std::string& migrationText : requiredMigrations) {
            errorText += "\n    " + migrationText;
        }

        LOG_FATAL("%s", errorText.c_str());
    }
}

void Database::performBackup()
{
    while (!exitRequested) {
        // Wait until this thread is signaled by backupToFile().
        std::unique_lock lock{backupMutex};
        backupCondVar.wait(lock, [this] { return backupRequested.load(); });

        // Execute all backup steps at once.
        try {
            SQLite::Backup backup(backupDatabase, database);
            backup.executeStep(-1);
        } catch (std::exception& e) {
            LOG_ERROR("Failed to save database to file: %s", e.what());
        }

        backupRequested = false;
    }
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/DialogueSystem.cpp`:

```cpp
#include "DialogueSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "DialogueLua.h"
#include "DialogueChoiceConditionLua.h"
#include "DialogueResponse.h"
#include "SystemMessage.h"
#include "Dialogue.h"
#include "Log.h"
#include "AMAssert.h"

namespace AM
{
namespace Server
{
DialogueSystem::DialogueSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, dialogueLua{inSimContext.simulation.getDialogueLua()}
, dialogueChoiceConditionLua{inSimContext.simulation
                                 .getDialogueChoiceConditionLua()}
, workString{}
, dialogueChoiceRequestQueue{inSimContext.networkEventDispatcher}
{
    // Register a callback for entity Talk interactions.
    world.castHelper.setOnEntityInteractionCompleted(
        EntityInteractionType::Talk,
        [this](const CastInfo& castInfo) { processTalkInteraction(castInfo); });
}

void DialogueSystem::processDialogueInteractions()
{
    // Process any waiting dialogue choice requests.
    DialogueChoiceRequest dialogueChoiceRequest{};
    while (dialogueChoiceRequestQueue.pop(dialogueChoiceRequest)) {
        processDialogueChoice(dialogueChoiceRequest);
    }
}

void DialogueSystem::processTalkInteraction(const CastInfo& castInfo)
{
    const Dialogue* dialogue{
        world.registry.try_get<Dialogue>(castInfo.targetEntity)};
    if (!dialogue) {
        // Note: This can happen if the init script has an addTalkInteraction() 
        //       but doesn't have any topic() declarations.
        network.serializeAndSend(
            castInfo.clientID,
            SystemMessage{"Error: Tried to Talk to entity that has no "
                          "Dialogue component."});
        return;
    }
    AM_ASSERT(dialogue->topics.size() > 0,
              "Dialogue should always have at least 1 topic.");

    // Run the topic script, following any setNextTopic() and pushing dialogue 
    // events into the response.
    DialogueResponse dialogueResponse{castInfo.targetEntity, 0};
    dialogueLua.luaState["self"] = castInfo.targetEntity;
    dialogueLua.luaState["target"] = castInfo.casterEntity;
    dialogueLua.clientID = castInfo.clientID;
    dialogueLua.dialogueEvents = &(dialogueResponse.dialogueEvents);

    std::size_t topicNavigationCount{0};
    TopicPair lastTopic{&(dialogue->topics[0]), 0};
    TopicPair nextTopic{
        runTopic(*dialogue, dialogue->topics[0], castInfo.clientID)};
    while (nextTopic.topic && (topicNavigationCount < TOPIC_NAVIGATION_MAX)) {
        lastTopic = nextTopic;
        nextTopic = runTopic(*dialogue, *(nextTopic.topic), castInfo.clientID);
        topicNavigationCount++;
    }

    // Add the last topic's index and choices to the response.
    dialogueResponse.topicIndex = lastTopic.topicIndex;
    addChoicesToResponse(lastTopic.topic->choices, castInfo.casterEntity,
                         castInfo.targetEntity, castInfo.clientID,
                         dialogueResponse);

    // Send the dialogue to the client.
    network.serializeAndSend(castInfo.clientID, dialogueResponse);
}

void DialogueSystem::processDialogueChoice(
    const DialogueChoiceRequest& choiceRequest)
{
    // Find the entity ID of the client that sent this request.
    entt::entity clientEntity{world.getClientEntity(choiceRequest.netID)};
    if (clientEntity == entt::null) {
        // Client doesn't exist (may have disconnected), skip this request.
        return;
    }

    // Validate the request.
    const Dialogue* dialogue{
        validateChoiceRequest(choiceRequest, clientEntity)};
    if (!dialogue) {
        return;
    }

    // Get the choice that the request is asking to run.
    // Note: These indices were already validated in validateChoiceRequest().
    const Dialogue::Topic& choiceTopic{
        dialogue->topics[choiceRequest.topicIndex]};
    const Dialogue::Choice& choice{
        choiceTopic.choices[choiceRequest.choiceIndex]};

    // Run the choice's action script, pushing dialogue events into the response.
    DialogueResponse dialogueResponse{choiceRequest.targetEntity, 0};
    dialogueLua.luaState["self"] = choiceRequest.targetEntity;
    dialogueLua.luaState["target"] = clientEntity;
    dialogueLua.clientID = choiceRequest.netID;
    dialogueLua.dialogueEvents = &(dialogueResponse.dialogueEvents);

    TopicPair nextTopic{runChoice(*dialogue, choice, choiceTopic.name,
                                  choiceRequest.choiceIndex,
                                  choiceRequest.netID)};

    // If the choice contained a valid setNextTopic(), run the next topic script, 
    // following any setNextTopic and pushing dialogue events into the response.
    std::size_t topicNavigationCount{1};
    TopicPair lastTopic{};
    while (nextTopic.topic && (topicNavigationCount < TOPIC_NAVIGATION_MAX)) {
        lastTopic = nextTopic;
        nextTopic
            = runTopic(*dialogue, *(nextTopic.topic), choiceRequest.netID);
        topicNavigationCount++;
    }

    // If any topics were ran, add the last topic's index and choices to the 
    // response.
    if (lastTopic.topic) {
        dialogueResponse.topicIndex = lastTopic.topicIndex;
        addChoicesToResponse(lastTopic.topic->choices, clientEntity,
                             choiceRequest.targetEntity, choiceRequest.netID,
                             dialogueResponse);
    }

    // Send the dialogue to the client.
    network.serializeAndSend(choiceRequest.netID, dialogueResponse);
}

DialogueSystem::TopicPair
    DialogueSystem::runChoice(const Dialogue& dialogue,
                              const Dialogue::Choice& choice,
                              std::string_view choiceTopicName,
                              Uint8 choiceIndex, NetworkID clientID)
{
    // Run the choice's action script, pushing dialogue events into the response.
    dialogueLua.nextTopicName = "";
    auto scriptResult{dialogueLua.luaState.script(choice.actionScript,
                                                  &sol::script_pass_on_error)};

    if (!(scriptResult.valid())) {
        sol::error err = scriptResult;
        workString.clear();
        workString.append("Error in choice action script. Topic: \"");
        workString.append(choiceTopicName);
        workString.append("\", choiceIndex: ");
        workString.append(std::to_string(choiceIndex));
        workString.append(", error: ");
        workString.append(err.what());
        network.serializeAndSend(clientID, SystemMessage{workString});
        return {nullptr};
    }

    // If a setNextTopic() call occurred, check if it's valid.
    if (dialogueLua.nextTopicName != "") {
        auto topicIndexIt{
            dialogue.topicIndices.find(dialogueLua.nextTopicName)};
        if (topicIndexIt != dialogue.topicIndices.end()) {
            // setNextTopic() is valid, return the next topic.
            return {&(dialogue.topics[topicIndexIt->second]),
                    topicIndexIt->second};
        }
        else {
            workString.clear();
            workString.append("Invalid setNextTopic(). Topic name: \"");
            workString.append(dialogueLua.nextTopicName);
            workString.append("\".");
            network.serializeAndSend(clientID, SystemMessage{workString});
        }
    }

    return {nullptr};
}

DialogueSystem::TopicPair
    DialogueSystem::runTopic(const Dialogue& dialogue,
                             const Dialogue::Topic& topic, NetworkID clientID)
{
    // Run the topic script, pushing dialogue events into the response.
    dialogueLua.nextTopicName = "";
    auto scriptResult{dialogueLua.luaState.script(topic.topicScript,
                                                  &sol::script_pass_on_error)};

    if (!(scriptResult.valid())) {
        sol::error err = scriptResult;
        workString.clear();
        workString.append("Error in topic script. Topic: \"");
        workString.append(topic.name);
        workString.append("\", error: ");
        workString.append(err.what());
        network.serializeAndSend(clientID, SystemMessage{workString});
        return {nullptr};
    }

    // If a setNextTopic() call occurred, check if it's valid.
    if (dialogueLua.nextTopicName != "") {
        auto topicIndexIt{
            dialogue.topicIndices.find(dialogueLua.nextTopicName)};
        if (topicIndexIt != dialogue.topicIndices.end()) {
            // setNextTopic() is valid, return the next topic.
            return {&(dialogue.topics[topicIndexIt->second]),
                    topicIndexIt->second};
        }
        else {
            workString.clear();
            workString.append("Invalid setNextTopic(). Topic name: \"");
            workString.append(dialogueLua.nextTopicName);
            workString.append("\".");
            network.serializeAndSend(clientID, SystemMessage{workString});
        }
    }

    return {nullptr};
}

const Dialogue* DialogueSystem::validateChoiceRequest(
    const DialogueChoiceRequest& choiceRequest, entt::entity clientEntity)
{
    entt::registry& registry{world.registry};

    // Check that the dialogue is valid.
    const Dialogue* dialogue{
        registry.try_get<Dialogue>(choiceRequest.targetEntity)};
    if (!dialogue) {
        // This can happen if the init script has an addTalkInteraction() 
        // but doesn't have any topic() declarations.
        network.serializeAndSend(
            choiceRequest.netID,
            SystemMessage{"Error: Tried to Talk to entity that has no "
                          "Dialogue component."});
        return nullptr;
    }
    else if ((choiceRequest.topicIndex >= dialogue->topics.size())
             || (choiceRequest.choiceIndex
                 >= dialogue->topics[choiceRequest.topicIndex]
                        .choices.size())) {
        // This can happen if the entity is re-initialized while a client is 
        // talking to it, and some topics or choices are removed.
        network.serializeAndSend(
            choiceRequest.netID,
            SystemMessage{"Invalid dialogue request."});
        return nullptr;
    }

    // Check that the client entity can access the requested choice.
    const Dialogue::Topic& topic{dialogue->topics[choiceRequest.topicIndex]};
    const Dialogue::Choice& choice{topic.choices[choiceRequest.choiceIndex]};
    if (!(choice.conditionScript.empty())
        && !runChoiceCondition(choice, clientEntity, choiceRequest.targetEntity,
                               choiceRequest.netID, true)) {
        return nullptr;
    }

    return dialogue;
}

bool DialogueSystem::runChoiceCondition(const Dialogue::Choice& choice,
                                        entt::entity clientEntity,
                                        entt::entity targetEntity,
                                        NetworkID clientID,
                                        bool sendAccessErrorMessage)
{
    // Append "r=" to the script so the result gets saved to a variable.
    workString.clear();
    workString.append("r=");
    workString.append(choice.conditionScript);

    // Run the condition script.
    dialogueChoiceConditionLua.luaState["self"] = targetEntity;
    dialogueChoiceConditionLua.luaState["target"] = clientEntity;
    auto scriptResult{dialogueChoiceConditionLua.luaState.script(
        workString, &sol::script_pass_on_error)};

    if (!(scriptResult.valid())) {
        sol::error err = scriptResult;
        workString.clear();
        workString.append("Choice condition script error: ");
        workString.append(err.what());
        network.serializeAndSend(clientID, SystemMessage{workString});
        return false;
    }

    // Validate the result.
    const auto& conditionResult{dialogueChoiceConditionLua.luaState["r"]};
    if (!(conditionResult.is<bool>())) {
        // We always send this error, since it's a malformed script.
        network.serializeAndSend(
            clientID, SystemMessage{"Error: Choice condition script did not "
                                    "evaluate to bool type."});
        return false;
    }
    else if (!(conditionResult.get<bool>())) {
        // We only send this error when appropriate (when the player somehow 
        // selects a choice that shouldn't have been sent to them).
        if (sendAccessErrorMessage) {
            network.serializeAndSend(
                clientID, SystemMessage{"Error: Player entity does not have "
                                        "access to selected choice."});
        }
        return false;
    }

    return conditionResult.get<bool>();
}

void DialogueSystem::addChoicesToResponse(
    const std::vector<Dialogue::Choice>& choices, entt::entity clientEntity,
    entt::entity targetEntity, NetworkID clientID, DialogueResponse& response)
{
    Uint8 index{0};
    for (const Dialogue::Choice& choice : choices) {
        // If the client entity can access this choice, add it to the response.
        if (choice.conditionScript.empty()
            || runChoiceCondition(choice, clientEntity, targetEntity, clientID,
                                  false)) {
            response.choices.emplace_back(index, choice.displayText);
        }

        index++;
    }
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Private/GraphicData/GraphicData.cpp`:

```cpp
#include "GraphicData.h"

namespace AM
{
namespace Server
{
GraphicData::GraphicData(const nlohmann::json& resourceDataJson)
: GraphicDataBase(resourceDataJson)
{
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Private/IconData/IconData.cpp`:

```cpp
#include "IconData.h"

namespace AM
{
namespace Server
{
IconData::IconData(const nlohmann::json& resourceDataJson)
: IconDataBase(resourceDataJson)
{
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Private/InputSystem.cpp`:

```cpp
#include "InputSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "Network.h"
#include "Peer.h"
#include "Input.h"
#include "ClientSimData.h"
#include "Log.h"
#include "tracy/Tracy.hpp"
#include <memory>

namespace AM
{
namespace Server
{
InputSystem::InputSystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, inputChangeRequestQueue{inSimContext.networkEventDispatcher}
, inputChangeRequestSorter{}
{
}

void InputSystem::processInputMessages()
{
    ZoneScoped;

    // Sort any waiting client input requests.
    while (const InputChangeRequest
           * inputChangeRequest{inputChangeRequestQueue.peek()}) {
        // Push the request into the sorter.
        SorterBase::ValidityResult result{inputChangeRequestSorter.push(
            *inputChangeRequest, inputChangeRequest->tickNum)};

        // If we had to drop a request, handle it.
        if (result != SorterBase::ValidityResult::Valid) {
            LOG_INFO("Dropped message from %u. Tick: %u, received: %u",
                     inputChangeRequest->netID, simulation.getCurrentTick(),
                     inputChangeRequest->tickNum);
            handleDroppedMessage(inputChangeRequest->netID);
        }

        inputChangeRequestQueue.pop();
    }

    // Process all client input requests for this tick.
    std::queue<InputChangeRequest>& queue{
        inputChangeRequestSorter.getCurrentQueue()};
    Uint32 currentTick{simulation.getCurrentTick()};
    for (; !(queue.empty()); queue.pop()) {
        // Get the next request.
        InputChangeRequest& inputChangeRequest{queue.front()};

        // If the input is from an earlier tick, drop it and continue.
        if (inputChangeRequest.tickNum < currentTick) {
            LOG_INFO("Dropped message from %u. Tick: %u, received: %u",
                     inputChangeRequest.netID, currentTick,
                     inputChangeRequest.tickNum);
            handleDroppedMessage(inputChangeRequest.netID);
            inputChangeRequestQueue.pop();
            continue;
        }
        // If the message is from a later tick, we're done.
        else if (inputChangeRequest.tickNum > currentTick) {
            break;
        }

        // Update the client entity's inputs.
        entt::entity clientEntity{
            world.getClientEntity(inputChangeRequest.netID)};
        if (clientEntity != entt::null) {
            // Update the entity's Input component.
            world.registry.replace<Input>(clientEntity,
                                          inputChangeRequest.input);
        }
        else {
            // The entity was probably disconnected. Do nothing with the
            // message.
        }
    }

    // Advance the sorter to the next tick.
    inputChangeRequestSorter.advance();
}

void InputSystem::handleDroppedMessage(NetworkID clientID)
{
    // Find the entity ID of the client that sent this request.
    entt::entity clientEntity{world.getClientEntity(clientID)};
    if (clientEntity == entt::null) {
        // The entity is gone, we don't need to process this drop.
        return;
    }

    entt::registry& registry{world.registry};
    Input& entityInput{registry.get<Input>(clientEntity)};

    // Default the entity's inputs so they don't run off a cliff.
    Input defaultInput{};
    if (entityInput.inputStates != defaultInput.inputStates) {
        registry.replace<Input>(clientEntity, defaultInput);
    }
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/InventoryHelper.cpp`:

```cpp
#include "InventoryHelper.h"
#include "World.h"
#include "Network.h"
#include "ItemData.h"
#include "Inventory.h"
#include "ClientSimData.h"
#include "InventoryOperation.h"
#include "SystemMessage.h"
#include <algorithm>

namespace AM
{
namespace Server
{

InventoryHelper::InventoryHelper(World& inWorld, Network& inNetwork,
                                 const ItemData& inItemData)
: world{inWorld}
, network{inNetwork}
, itemData{inItemData}
{
}

InventoryHelper::AddResult
    InventoryHelper::addItemToEntity(ItemID itemID, Uint8 count,
                                     entt::entity entityToAddTo,
                                     bool sendFailureMessage)
{
    // Try to add the item.
    auto* item{itemData.getItem(itemID)};
    auto& inventory{world.registry.get_or_emplace<Inventory>(entityToAddTo)};
    auto* client{world.registry.try_get<ClientSimData>(entityToAddTo)};
    if (item && inventory.addItem(itemID, count, item->maxStackSize)) {
        // Success. If the target is a client entity, update it.
        if (client) {
            InventoryOperation operation{InventoryAddItem{
                entityToAddTo, itemID, count, item->maxStackSize,
                itemData.getItemVersion(itemID)}};
            network.serializeAndSend(client->netID, operation);
        }

        return AddResult::Success;
    }

    // Failure. Return an error code (and send a message, if appropriate).
    AddResult result{};
    const char* message{};
    if (item) {
        result = AddResult::InventoryFull;
        message = "Failed to add item: Inventory is full.";
    }
    else {
        result = AddResult::ItemNotFound;
        message = "Failed to add item: Item not found.";
    }

    if (sendFailureMessage && client) {
        network.serializeAndSend(client->netID, SystemMessage{message});
    }
    return result;
}

InventoryHelper::AddResult
    InventoryHelper::addItemToEntity(std::string_view itemID, Uint8 count,
                                     entt::entity entityToAddTo,
                                     bool sendFailureMessage)
{
    if (const Item * item{itemData.getItem(itemID)}) {
        return addItemToEntity(item->numericID, count, entityToAddTo);
    }

    // Failure. Return an error code (and send a message, if appropriate).
    auto* client{world.registry.try_get<ClientSimData>(entityToAddTo)};
    if (sendFailureMessage && client) {
        network.serializeAndSend(
            client->netID,
            SystemMessage{"Failed to add item: Item not found."});
    }
    return AddResult::ItemNotFound;
}

InventoryHelper::RemoveResult
    InventoryHelper::removeItemFromEntity(Uint8 slotIndex, Uint8 count,
                                          entt::entity entityToRemoveFrom,
                                          bool sendFailureMessage)
{
    // Try to remove the item.
    auto* inventory{world.registry.try_get<Inventory>(entityToRemoveFrom)};
    auto* client{world.registry.try_get<ClientSimData>(entityToRemoveFrom)};
    if (inventory && inventory->removeItem(slotIndex, count)) {
        // Success. If the target is a client entity, update it.
        if (client) {
            InventoryOperation operation{InventoryRemoveItem{slotIndex, count}};
            network.serializeAndSend(client->netID, operation);
        }

        return RemoveResult::Success;
    }

    // Failure. Return an error code (and send a message, if appropriate).
    RemoveResult result{};
    const char* message{};
    if (inventory) {
        result = RemoveResult::InvalidSlotIndex;
        message = "Failed to remove item: Invalid slot index.";
    }
    else {
        result = RemoveResult::InventoryNotFound;
        message = "Failed to remove item: Entity has no Inventory component.";
    }

    if (sendFailureMessage && client) {
        network.serializeAndSend(client->netID, SystemMessage{message});
    }
    return result;
}

InventoryHelper::RemoveResult
    InventoryHelper::removeItemFromEntity(std::string_view itemID, Uint8 count,
                                          entt::entity entityToRemoveFrom,
                                          bool sendFailureMessage)
{
    // If the entity's inventory has enough copies of the item to satisfy the
    // requested count, remove them.
    const Item* item{itemData.getItem(itemID)};
    auto* inventory{world.registry.try_get<Inventory>(entityToRemoveFrom)};
    auto* client{world.registry.try_get<ClientSimData>(entityToRemoveFrom)};
    if (item && inventory
        && (inventory->getItemCount(item->numericID) >= count)) {
        Uint8 remainingCount{count};
        for (Uint8 i{0}; i < inventory->slots.size(); ++i) {
            Inventory::ItemSlot& slot{inventory->slots[i]};

            // If this slot contains the item, remove it.
            if (slot.ID == item->numericID) {
                Uint8 amountToRemove{
                    std::clamp<Uint8>(remainingCount, 0, slot.count)};
                inventory->removeItem(i, amountToRemove);

                // If the target is a client entity, send an update.
                if (client) {
                    InventoryOperation operation{
                        InventoryRemoveItem{i, amountToRemove}};
                    network.serializeAndSend(client->netID, operation);
                }

                // If we've found enough copies, stop searching.
                remainingCount -= amountToRemove;
                if (remainingCount == 0) {
                    break;
                }
            }
        }

        return RemoveResult::Success;
    }

    // Failure. Return an error code (and send a message, if appropriate).
    RemoveResult result{};
    const char* message{};
    if (item && inventory) {
        result = RemoveResult::InsufficientItemCount; 
        message = "Failed to remove item: Insufficient amount.";
    }
    else if (inventory) {
        result = RemoveResult::InventoryNotFound; 
        message = "Failed to remove item: Entity has no Inventory component.";
    }
    else {
        result = RemoveResult::ItemNotFound; 
        message = "Failed to remove item: Item not found.";
    }

    if (sendFailureMessage && client) {
        network.serializeAndSend(client->netID, SystemMessage{message});
    }
    return result;
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/InventorySystem.cpp`:

```cpp
#include "InventorySystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "ItemData.h"
#include "ISimulationExtension.h"
#include "ClientSimData.h"
#include "Inventory.h"
#include "InventoryInit.h"
#include "SystemMessage.h"
#include "Log.h"
#include <algorithm>

namespace AM
{
namespace Server
{
InventorySystem::InventorySystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, itemData{inSimContext.itemData}
, extension{nullptr}
, playerInventoryObserver{}
, inventoryOperationQueue{inSimContext.networkEventDispatcher}
{
    // Observe player Inventory construction events.
    playerInventoryObserver.bind(world.registry);
    playerInventoryObserver.on_construct<ClientSimData>()
        .on_construct<Inventory>();
}

void InventorySystem::sendInventoryInits()
{
    // If a player Inventory was constructed, send the initial state to that
    // player.
    for (entt::entity entity : playerInventoryObserver) {
        if (world.registry.all_of<ClientSimData, Inventory>(entity)) {
            continue;
        }
        auto [client, inventory]
            = world.registry.get<ClientSimData, Inventory>(entity);

        InventoryInit inventoryInit{inventory.size};
        for (const Inventory::ItemSlot& itemSlot : inventory.slots) {
            ItemVersion version{0};
            if (itemSlot.ID) {
                version = itemData.getItemVersion(itemSlot.ID);
            }
            inventoryInit.slots.emplace_back(itemSlot.ID, itemSlot.count,
                                             version);
        }

        if (inventoryInit.slots.size() > 0) {
            network.serializeAndSend(client.netID, inventoryInit);
        }
    }

    playerInventoryObserver.clear();
}

void InventorySystem::processInventoryUpdates()
{
    // Process any waiting inventory operations.
    InventoryOperation inventoryOperation{};
    while (inventoryOperationQueue.pop(inventoryOperation)) {
        std::visit(
            [&](const auto& operation) {
                processOperation(inventoryOperation.netID, operation);
            },
            inventoryOperation.operation);
    }
}

void InventorySystem::setExtension(ISimulationExtension* inExtension)
{
    extension = inExtension;
}

void InventorySystem::processOperation(NetworkID clientID,
                                       const InventoryAddItem& inventoryAddItem)
{
    // If the entity isn't valid, skip it.
    entt::entity entityToAddTo{inventoryAddItem.entity};
    if (!(world.registry.valid(entityToAddTo))) {
        return;
    }

    // TODO: Check that the client has sufficient permission to create items.

    // Try to add the item, sending messages appropriately.
    world.inventoryHelper.addItemToEntity(
        inventoryAddItem.itemID, inventoryAddItem.count, entityToAddTo);
}

void InventorySystem::processOperation(
    NetworkID clientID, const InventoryRemoveItem& inventoryRemoveItem)
{
    // Note: "Remove item" always applies to the client's own inventory.

    // Find the client's entity ID.
    entt::entity clientEntity{world.getClientEntity(clientID)};
    if (clientEntity == entt::null) {
        // Try to remove the item, sending messages appropriately.
        world.inventoryHelper.removeItemFromEntity(
            inventoryRemoveItem.slotIndex, inventoryRemoveItem.count,
            clientEntity);
    }
}

void InventorySystem::processOperation(
    NetworkID clientID, const InventoryMoveItem& inventoryMoveItem)
{
    // Note: "Move item" always applies to the client's own inventory.

    // Find the client's entity ID.
    entt::entity clientEntity{world.getClientEntity(clientID)};
    if (clientEntity == entt::null) {
        // If the move is successful, tell the client.
        Inventory& inventory{world.registry.get<Inventory>(clientEntity)};
        if (inventory.moveItem(inventoryMoveItem.sourceSlotIndex,
                               inventoryMoveItem.destSlotIndex)) {
            network.serializeAndSend(clientID,
                                     InventoryOperation{inventoryMoveItem});
        }
    }
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/ItemData/ItemData.cpp`:

```cpp
#include "ItemData.h"
#include "StringTools.h"
#include "Log.h"
#include <algorithm>

namespace AM
{
namespace Server
{
ItemData::ItemData()
: ItemDataBase()
, itemInitScriptMap{}
, defaultInitScript{}
, workStringID{}
{
}

const Item* ItemData::createItem(const Item& referenceItem,
                                 std::string_view initScript)
{
    // If the numeric ID is taken, do nothing.
    if (itemMap.find(referenceItem.numericID) != itemMap.end()) {
        return nullptr;
    }
    // If the display name is too long, do nothing.
    else if (referenceItem.displayName.size() > Item::MAX_DISPLAY_NAME_LENGTH) {
        return nullptr;
    }

    // If no string ID was given, derive it from displayName.
    if (referenceItem.stringID == "") {
        StringTools::deriveStringID(referenceItem.displayName, workStringID);
    }
    else {
        workStringID = referenceItem.stringID;
    }

    // If the string ID is too long or taken, do nothing.
    if ((workStringID.size() > Item::MAX_STRING_ID_LENGTH)
        || (itemStringMap.find(workStringID) != itemStringMap.end())) {
        return nullptr;
    }

    // If referenceItem doesn't have a desired ID, use the next sequential ID.
    ItemID newItemID{referenceItem.numericID};
    if (newItemID == NULL_ITEM_ID) {
        newItemID = nextItemID;
    }

    // Add the item to our maps.
    // Note: When we insert into an unordered_map, references to the map's
    //       elements are guaranteed to remain valid (for itemStringMap).
    itemMap[newItemID] = referenceItem;
    Item& newItem{itemMap[newItemID]};
    newItem.stringID = workStringID;
    newItem.numericID = newItemID;
    itemStringMap[workStringID] = &newItem;
    itemVersionMap[newItemID] = 0;
    itemInitScriptMap[newItemID] = {std::string{initScript}};

    // Always update nextItemID to be 1 greater than the highest ID.
    if (newItemID >= nextItemID) {
        nextItemID = (newItemID + 1);
    }

    // Signal that an item has been created.
    itemCreatedSig.publish(newItemID);

    return &newItem;
}

const Item* ItemData::updateItem(const Item& referenceItem,
                                 std::string_view initScript)
{
    // If the item doesn't exist, do nothing.
    auto itemIt{itemMap.find(referenceItem.numericID)};
    if (itemIt == itemMap.end()) {
        return nullptr;
    }
    // If the display name is too long, do nothing.
    else if (referenceItem.displayName.size() > Item::MAX_DISPLAY_NAME_LENGTH) {
        return nullptr;
    }

    // If no string ID was given, derive it from displayName.
    if (referenceItem.stringID == "") {
        StringTools::deriveStringID(referenceItem.displayName, workStringID);
    }
    else {
        workStringID = referenceItem.stringID;
    }

    // If the string ID is too long, do nothing.
    if (workStringID.size() > Item::MAX_STRING_ID_LENGTH) {
        return nullptr;
    }

    // If the new string ID doesn't match the old one.
    Item& item{itemIt->second};
    if (workStringID != item.stringID) {
        // If the new ID is taken, do nothing.
        auto stringIt{itemStringMap.find(workStringID)};
        if (stringIt != itemStringMap.end()) {
            return nullptr;
        }
        else {
            // New ID isn't taken. Add it to the string ID map and remove the
            // old one.
            itemStringMap[workStringID] = &item;
            itemStringMap.erase(item.stringID);
        }
    }

    // Update the item.
    item = referenceItem;
    item.stringID = workStringID;
    itemInitScriptMap[item.numericID] = {std::string{initScript}};

    // Increment the version.
    itemVersionMap[item.numericID]++;

    // Signal that an item has been updated.
    itemUpdatedSig.publish(item.numericID);

    return &item;
}

const Item* ItemData::loadItem(const Item& referenceItem, ItemVersion version,
                               std::string_view initScript)
{
    // If the item was successfully loaded, add the init script to our map.
    const Item* item{ItemDataBase::loadItem(referenceItem, version)};
    if (item) {
        itemInitScriptMap[item->numericID] = {std::string{initScript}};
    }

    return item;
}

const ItemInitScript& ItemData::getItemInitScript(ItemID numericID) const
{
    // Attempt to find the given numeric ID.
    auto it{itemInitScriptMap.find(numericID)};
    if (it == itemInitScriptMap.end()) {
        LOG_ERROR("Tried to get invalid item's init script. ID: %u", numericID);
        return defaultInitScript;
    }

    return it->second;
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Private/ItemSystem.cpp`:

```cpp
#include "ItemSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "ItemData.h"
#include "Database.h"
#include "EntityItemHandlerLua.h"
#include "ISimulationExtension.h"
#include "ClientSimData.h"
#include "Inventory.h"
#include "Castable.h"
#include "ItemHandler.h"
#include "ItemUpdate.h"
#include "ItemError.h"
#include "CombineItems.h"
#include "StringTools.h"
#include "SystemMessage.h"
#include "Log.h"
#include "sol/sol.hpp"
#include <algorithm>

namespace AM
{
namespace Server
{
ItemSystem::ItemSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, itemData{inSimContext.itemData}
, entityItemHandlerLua{inSimContext.simulation.getEntityItemHandlerLua()}
, extension{nullptr}
, updatedItems{}
, itemInitRequestQueue{inSimContext.networkEventDispatcher}
, itemChangeRequestQueue{inSimContext.networkEventDispatcher}
, combineItemsRequestQueue{inSimContext.networkEventDispatcher}
, useItemOnEntityRequestQueue{inSimContext.networkEventDispatcher}
, itemDataRequestQueue{inSimContext.networkEventDispatcher}
{
    // When an item is updated, add it to updatedItems.
    itemData.itemUpdated.connect<&ItemSystem::itemUpdated>(this);

    // Register a callback for item Examine interactions.
    world.castHelper.setOnItemInteractionCompleted(
        ItemInteractionType::Examine,
        [this](const CastInfo& castInfo) { examineItem(castInfo); });
}

void ItemSystem::processUseItemInteractions()
{
    // Process any waiting messages.
    CombineItemsRequest combineItemsRequest{};
    while (combineItemsRequestQueue.pop(combineItemsRequest)) {
        combineItems(combineItemsRequest.sourceSlotIndex,
                     combineItemsRequest.targetSlotIndex,
                     combineItemsRequest.netID);
    }

    UseItemOnEntityRequest useItemOnEntityRequest{};
    while (useItemOnEntityRequestQueue.pop(useItemOnEntityRequest)) {
        useItemOnEntity(useItemOnEntityRequest.sourceSlotIndex,
                        useItemOnEntityRequest.targetEntity,
                        useItemOnEntityRequest.netID);
    }
}

void ItemSystem::processItemUpdates()
{
    // Process any waiting requests to create or change items.
    ItemInitRequest itemInitRequest{};
    while (itemInitRequestQueue.pop(itemInitRequest)) {
        handleInitRequest(itemInitRequest);
    }
    ItemChangeRequest itemChangeRequest{};
    while (itemChangeRequestQueue.pop(itemChangeRequest)) {
        handleChangeRequest(itemChangeRequest);
    }

    // If any items definitions were changed, send the new definitions to all
    // players that own that item.
    if (updatedItems.size() > 0) {
        // Remove duplicates from the vector.
        std::sort(updatedItems.begin(), updatedItems.end());
        updatedItems.erase(
            std::unique(updatedItems.begin(), updatedItems.end()),
            updatedItems.end());

        // TODO: Instead of iterating each inventory slot, find a way to 
        //       sort and efficiently search for matches.
        // If any player's inventory contains an updated item, send the new
        // definition.
        auto view{world.registry.view<ClientSimData, Inventory>()};
        for (auto [entity, client, inventory] : view.each()) {
            for (const Inventory::ItemSlot& itemSlot : inventory.slots) {
                auto it{std::find(updatedItems.begin(), updatedItems.end(),
                                  itemSlot.ID)};
                if (it != updatedItems.end()) {
                    const Item& item{*(itemData.getItem(itemSlot.ID))};
                    network.serializeAndSend(
                        client.netID,
                        ItemUpdate{item.displayName, item.stringID,
                                   item.numericID, item.iconID,
                                   item.maxStackSize,
                                   item.supportedInteractions,
                                   itemData.getItemVersion(item.numericID)});
                }
            }
        }

        updatedItems.clear();
    }

    // Send item definitions to any requestors.
    ItemDataRequest itemDataRequest{};
    while (itemDataRequestQueue.pop(itemDataRequest)) {
        handleDataRequest(itemDataRequest);
    }
}

void ItemSystem::setExtension(ISimulationExtension* inExtension)
{
    extension = inExtension;
}

void ItemSystem::itemUpdated(ItemID itemID)
{
    updatedItems.emplace_back(itemID);
}

void ItemSystem::examineItem(const CastInfo& castInfo)
{
    // Send the item's description.
    // Note: Since all items have a description, you could imagine sending it  
    //       with the initial ItemUpdate. To save data, we send it when 
    //       requested instead (we assume that people are rarely going to 
    //       examine items, compared to how often we send ItemUpdates).
    network.serializeAndSend(castInfo.clientID,
                             SystemMessage{castInfo.item->description});
}

void ItemSystem::combineItems(Uint8 sourceSlotIndex, Uint8 targetSlotIndex,
                              NetworkID clientID)
{
    // Find the client's entity ID.
    entt::entity clientEntity{world.getClientEntity(clientID)};
    if (clientEntity != entt::null) {
        // If the combination is successful, tell the client.
        auto& inventory{world.registry.get<Inventory>(clientEntity)};
        const ItemCombination* combination{inventory.combineItems(
            sourceSlotIndex, targetSlotIndex, itemData)};
        if (combination) {
            ItemID resultItemID{combination->resultItemID};
            const Item* item{itemData.getItem(resultItemID)};
            ItemVersion resultItemVersion{
                itemData.getItemVersion(resultItemID)};
            network.serializeAndSend(
                clientID,
                CombineItems{sourceSlotIndex, targetSlotIndex, resultItemID,
                             item->maxStackSize, resultItemVersion});
            network.serializeAndSend(clientID,
                                     SystemMessage{combination->description});
        }
        else {
            // No combination for the item. Give the user feedback.
            network.serializeAndSend(clientID,
                                     SystemMessage{"Nothing happens."});
        }
    }
}

void ItemSystem::useItemOnEntity(Uint8 sourceSlotIndex,
                                 entt::entity targetEntity, NetworkID clientID)
{
    // Find the client's entity ID.
    entt::entity clientEntity{world.getClientEntity(clientID)};
    if (clientEntity != entt::null) {
        // If the slot is invalid or empty, do nothing.
        Inventory& inventory{world.registry.get<Inventory>(clientEntity)};
        ItemID sourceItemID{inventory.slots[sourceSlotIndex].ID};
        if (!sourceItemID) {
            return;
        }

        // Note: We assume the item exists since it's present in an inventory.
        const Item* item{itemData.getItem(sourceItemID)};

        // If the entity has a non-empty handler, run it.
        if (const ItemHandler* itemHandler{
                world.registry.try_get<ItemHandler>( targetEntity)};
            itemHandler && !(itemHandler->handlerScript.script.empty())) {
            runEntityItemHandlerScript(clientID, clientEntity, targetEntity,
                                       item, itemHandler->handlerScript);
        }
        else {
            // No handler for the item. Give the user feedback.
            network.serializeAndSend(clientID,
                                     SystemMessage{"Nothing happens."});
        }
    }
}

void ItemSystem::handleInitRequest(const ItemInitRequest& itemInitRequest)
{
    // Check that a string ID was provided.
    ItemError::Type errorType{ItemError::NotSet};
    if (itemInitRequest.stringID == "") {
        errorType = ItemError::StringIDMissing;
    }
    // Check that the string ID isn't taken by another item.
    else if (itemData.getItem(itemInitRequest.stringID)) {
        errorType = ItemError::StringIDInUse;
    }
    // Check that the project says the request is valid.
    else if (!(extension->isItemInitRequestValid(itemInitRequest))) {
        errorType = ItemError::PermissionFailure;
    }

    // If we found an error, send it to the requesting client.
    if (errorType != ItemError::NotSet) {
        network.serializeAndSend(itemInitRequest.netID,
                                 ItemError{itemInitRequest.displayName,
                                           itemInitRequest.stringID,
                                           NULL_ITEM_ID, errorType});
        return;
    }

    // Build the new item.
    Item item{};
    item.displayName = itemInitRequest.displayName;
    item.stringID = itemInitRequest.stringID;
    item.iconID = itemInitRequest.iconID;

    // Run the init script. If there was an error, return early.
    if (!(runItemInitScript(itemInitRequest.netID, itemInitRequest.initScript,
                            item))) {
        return;
    }

    // Create the item (should always succeed since we checked the string ID).
    const Item* newItem{
        itemData.createItem(item, itemInitRequest.initScript.script)};
    AM_ASSERT(newItem != nullptr, "Failed to create item.");

    // Send the requester the new item's definition.
    network.serializeAndSend(
        itemInitRequest.netID,
        ItemUpdate{newItem->displayName, newItem->stringID, newItem->numericID,
                   newItem->iconID, newItem->maxStackSize,
                   newItem->supportedInteractions,
                   itemData.getItemVersion(newItem->numericID)});
}

void ItemSystem::handleChangeRequest(const ItemChangeRequest& itemChangeRequest)
{
    // Check that the numeric ID exists.
    ItemError::Type errorType{ItemError::NotSet};
    if (!(itemData.getItem(itemChangeRequest.itemID))) {
        errorType = ItemError::NumericIDNotFound;
    }
    // Check that a string ID was provided.
    else if (itemChangeRequest.stringID == "") {
        errorType = ItemError::StringIDMissing;
    }
    // Check that the string ID isn't taken by another item.
    else if (const Item*
                 item{itemData.getItem(itemChangeRequest.stringID)};
             item && (item->numericID != itemChangeRequest.itemID)) {
        errorType = ItemError::StringIDInUse;
    }
    // Check that the project says the request is valid.
    else if (!(extension->isItemChangeRequestValid(itemChangeRequest))) {
        errorType = ItemError::PermissionFailure;
    }

    // If we found an error, send it to the requesting client.
    if (errorType != ItemError::NotSet) {
        network.serializeAndSend(
            itemChangeRequest.netID,
            ItemError{itemChangeRequest.displayName, itemChangeRequest.stringID,
                      itemChangeRequest.itemID, errorType});
        return;
    }

    // Build the updated item.
    Item item{};
    item.displayName = itemChangeRequest.displayName;
    item.stringID = itemChangeRequest.stringID;
    item.numericID = itemChangeRequest.itemID;
    item.iconID = itemChangeRequest.iconID;

    // Run the init script. If there was an error, return early.
    if (!(runItemInitScript(itemChangeRequest.netID,
                            itemChangeRequest.initScript, item))) {
        return;
    }

    // Update the item (should always succeed since we checked the ID).
    const Item* updatedItem{
        itemData.updateItem(item, itemChangeRequest.initScript.script)};
    AM_ASSERT(updatedItem != nullptr, "Failed to update item.");

    // Send the requester the new item's definition.
    // Note: If the requester owns the item, we'll end up double-sending
    //       them this update, which isn't a big deal.
    network.serializeAndSend(
        itemChangeRequest.netID,
        ItemUpdate{updatedItem->displayName, updatedItem->stringID,
                   updatedItem->numericID, updatedItem->iconID,
                   updatedItem->maxStackSize,
                   updatedItem->supportedInteractions,
                   itemData.getItemVersion(updatedItem->numericID)});
}

void ItemSystem::handleDataRequest(const ItemDataRequest& itemDataRequest)
{
    // If the item exists, send an update.
    bool itemWasFound{false};
    std::visit(
        [&](auto& itemID) {
            if (const Item * item{itemData.getItem(itemID)}) {
                itemWasFound = true;
                network.serializeAndSend(
                    itemDataRequest.netID,
                    ItemUpdate{item->displayName, item->stringID,
                               item->numericID, item->iconID,
                               item->maxStackSize, item->supportedInteractions,
                               itemData.getItemVersion(item->numericID)});
            }
        },
        itemDataRequest.itemID);

    // If the requested item doesn't exist, send an error to the client.
    if (!itemWasFound) {
        ItemID numericID{};
        std::string stringID{};
        std::visit(
            [&](auto& itemID) {
                using T = std::decay_t<decltype(itemID)>;
                if constexpr (std::is_same_v<T, ItemID>) {
                    numericID = itemID;
                }
                else if constexpr (std::is_same_v<T, std::string>) {
                    stringID = itemID;
                }
            },
            itemDataRequest.itemID);
        network.serializeAndSend(
            itemDataRequest.netID,
            ItemError{"", stringID, numericID, ItemError::StringIDNotFound});
    }
}

bool ItemSystem::runItemInitScript(NetworkID clientID,
                                   const ItemInitScript& initScript, Item& item)
{
    // Run the given init script.
    std::string resultString{world.runItemInitScript(item, initScript.script)};

    // If there was an error while running the script, tell the user and return
    // false.
    if (!(resultString.empty())) {
        network.serializeAndSend(clientID,
                                 ItemError{item.displayName, "", item.numericID,
                                           ItemError::InitScriptFailure});
        network.serializeAndSend(clientID, SystemMessage{resultString});
        return false;
    }

    return true;
}

void ItemSystem::runEntityItemHandlerScript(
    NetworkID clientID, entt::entity clientEntity, entt::entity targetEntity,
    const Item* item, const EntityItemHandlerScript& itemHandlerScript)
{
    // Run the given handler script.
    entityItemHandlerLua.clientID = clientID;
    entityItemHandlerLua.item = item;
    entityItemHandlerLua.luaState["self"] = targetEntity;
    entityItemHandlerLua.luaState["target"] = clientEntity;
    entityItemHandlerLua.luaState["itemID"] = item->stringID;
    auto result{entityItemHandlerLua.luaState.script(
        itemHandlerScript.script, &sol::script_pass_on_error)};

    // If there was an error while running the handler script, tell the
    // user.
    if (!(result.valid())) {
        sol::error err = result;
        network.serializeAndSend(clientID, SystemMessage{err.what()});
    }
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/Lua/EngineLuaBindings.cpp`:

```cpp
#include "EngineLuaBindings.h"
#include "EntityInitLua.h"
#include "EntityItemHandlerLua.h"
#include "ItemInitLua.h"
#include "DialogueLua.h"
#include "DialogueChoiceConditionLua.h"
#include "GraphicData.h"
#include "ItemData.h"
#include "CollisionBitSets.h"
#include "World.h"
#include "Network.h"
#include "Interaction.h"
#include "ItemHandler.h"
#include "Inventory.h"
#include "StoredValues.h"
#include "SystemMessage.h"
#include "ItemProperty.h"
#include "sol/sol.hpp"
#include <time.h>

namespace AM
{
namespace Server
{

EngineLuaBindings::EngineLuaBindings(
    EntityInitLua& inEntityInitLua,
    EntityItemHandlerLua& inEntityItemHandlerLua, ItemInitLua& inItemInitLua,
    DialogueLua& inDialogueLua,
    DialogueChoiceConditionLua& inDialogueChoiceConditionLua,
    const GraphicData& inGraphicData, const ItemData& inItemData,
    World& inWorld, Network& inNetwork)
: entityInitLua{inEntityInitLua}
, entityItemHandlerLua{inEntityItemHandlerLua}
, itemInitLua{inItemInitLua}
, dialogueLua{inDialogueLua}
, dialogueChoiceConditionLua{inDialogueChoiceConditionLua}
, graphicData{inGraphicData}
, itemData{inItemData}
, world{inWorld}
, network{inNetwork}
, dialogueChoiceLua{std::make_unique<sol::state>()}
, currentDialogueTopic{nullptr}
, workString{}
{
    // Initialize the Lua environments.
    // Note: We only allow the base library, to avoid giving scripts unsafe 
    //       access to our system.
    entityInitLua.luaState.open_libraries(sol::lib::base);
    entityItemHandlerLua.luaState.open_libraries(sol::lib::base);
    itemInitLua.luaState.open_libraries(sol::lib::base);
    dialogueLua.luaState.open_libraries(sol::lib::base);
    dialogueChoiceConditionLua.luaState.open_libraries(sol::lib::base);

    // Add the GLOBAL Lua constant to the non-init environments.
    // Note: GLOBAL can be used instead of an entity ID when setting stored 
    //       values.
    Uint32 nullEntityID{entt::to_integral(entt::entity{entt::null})};
    entityItemHandlerLua.luaState["GLOBAL"] = nullEntityID;
    dialogueLua.luaState["GLOBAL"] = nullEntityID;
    dialogueChoiceConditionLua.luaState["GLOBAL"] = nullEntityID;

    // Add our bindings.
    addEntityInitBindings();
    addEntityItemHandlerBindings();
    addItemInitBindings();
    addDialogueBindings();
    addDialogueChoiceConditionBindings();
    addDialogueChoiceBindings();
}

void EngineLuaBindings::addEntityInitBindings()
{
    entityInitLua.luaState.set_function(
        "setCollisionLayers", &EngineLuaBindings::setCollisionLayers, this);
    entityInitLua.luaState.set_function(
        "setCollisionMask", &EngineLuaBindings::setCollisionMask, this);
    // Note: TerrainWall, ClientEntity, NonClientEntity are handled 
    //       automatically.
    //       Object is only useful in setCollisionMask
    entityInitLua.luaState["CLT_OBJECT"] = CollisionLayerType::Object;
    entityInitLua.luaState["CLT_BLOCK_COLLISION"]
        = CollisionLayerType::BlockCollision;
    entityInitLua.luaState["CLT_BLOCK_LOS"] = CollisionLayerType::BlockLoS;

    entityInitLua.luaState.set_function(
        "addTalkInteraction", &EngineLuaBindings::addTalkInteraction, this);
    entityInitLua.luaState.set_function(
        "setItemHandler", &EngineLuaBindings::setItemHandler, this);
    entityInitLua.luaState.set_function("topic", &EngineLuaBindings::topic,
                                        this);
}

void EngineLuaBindings::addEntityItemHandlerBindings()
{
    entityItemHandlerLua.luaState.set_function(
        "addItem",
        [&](entt::entity entityToAddTo, std::string_view itemID, Uint8 count) {
            return addItem(entityToAddTo, itemID, count);
        });
    entityItemHandlerLua.luaState.set_function(
        "removeItem", [&](entt::entity entityToRemoveFrom,
                          std::string_view itemID, Uint8 count) {
            return removeItem(entityToRemoveFrom, itemID, count);
        });
    entityItemHandlerLua.luaState.set_function(
        "getItemCount",
        [&](entt::entity entityToCount, std::string_view itemID) {
            return getItemCount(entityToCount, itemID);
        });
    entityItemHandlerLua.luaState.set_function(
        "storeUint", &EngineLuaBindings::storeUint, this);
    entityItemHandlerLua.luaState.set_function(
        "storeBool", &EngineLuaBindings::storeBool, this);
    entityItemHandlerLua.luaState.set_function(
        "storeInt", &EngineLuaBindings::storeInt, this);
    entityItemHandlerLua.luaState.set_function(
        "storeFloat", &EngineLuaBindings::storeFloat, this);
    entityItemHandlerLua.luaState.set_function(
        "storeTime", &EngineLuaBindings::storeTime, this);
    entityItemHandlerLua.luaState.set_function(
        "storeBitSet", &EngineLuaBindings::storeBitSet, this);
    entityItemHandlerLua.luaState.set_function(
        "storeBit", &EngineLuaBindings::storeBit, this);
    entityItemHandlerLua.luaState.set_function(
        "getStoredUint", &EngineLuaBindings::getStoredUint, this);
    entityItemHandlerLua.luaState.set_function(
        "getStoredBool", &EngineLuaBindings::getStoredBool, this);
    entityItemHandlerLua.luaState.set_function(
        "getStoredInt", &EngineLuaBindings::getStoredInt, this);
    entityItemHandlerLua.luaState.set_function(
        "getStoredFloat", &EngineLuaBindings::getStoredFloat, this);
    entityItemHandlerLua.luaState.set_function(
        "getStoredTime", &EngineLuaBindings::getStoredTime, this);
    entityItemHandlerLua.luaState.set_function(
        "getStoredBitSet", &EngineLuaBindings::getStoredBitSet, this);
    entityItemHandlerLua.luaState.set_function(
        "getStoredBit", &EngineLuaBindings::getStoredBit, this);
    entityItemHandlerLua.luaState.set_function(
        "getBit", &EngineLuaBindings::getBit, this);
    entityItemHandlerLua.luaState.set_function(
        "setBit", &EngineLuaBindings::setBit, this);
    entityItemHandlerLua.luaState.set_function(
        "getCurrentTime", &EngineLuaBindings::getCurrentTime, this);
    entityItemHandlerLua.luaState.set_function(
        "sendSystemMessage", [&](std::string_view message) {
            sendSystemMessage(message, entityItemHandlerLua.clientID);
        });
}

void EngineLuaBindings::addItemInitBindings()
{
    itemInitLua.luaState.set_function("setDescription",
                                      &EngineLuaBindings::setDescription, this);
    itemInitLua.luaState.set_function(
        "setMaxStackSize", &EngineLuaBindings::setMaxStackSize, this);
    itemInitLua.luaState.set_function("addCombination",
                                      &EngineLuaBindings::addCombination, this);
}

void EngineLuaBindings::addDialogueBindings()
{
    dialogueLua.luaState.set_function("say", &EngineLuaBindings::say, this);
    dialogueLua.luaState.set_function("narrate", &EngineLuaBindings::narrate,
                                      this);
    dialogueLua.luaState.set_function("setNextTopic",
                                      &EngineLuaBindings::setNextTopic, this);
    dialogueLua.luaState.set_function(
        "addItem",
        [&](entt::entity entityToAddTo, std::string_view itemID, Uint8 count) {
            return addItem(entityToAddTo, itemID, count);
        });
    dialogueLua.luaState.set_function(
        "removeItem", [&](entt::entity entityToRemoveFrom,
                          std::string_view itemID, Uint8 count) {
            return removeItem(entityToRemoveFrom, itemID, count);
        });
    dialogueLua.luaState.set_function(
        "getItemCount",
        [&](entt::entity entityToCount, std::string_view itemID) {
            return getItemCount(entityToCount, itemID);
        });
    dialogueLua.luaState.set_function("storeUint",
                                      &EngineLuaBindings::storeUint, this);
    dialogueLua.luaState.set_function("storeBool",
                                      &EngineLuaBindings::storeBool, this);
    dialogueLua.luaState.set_function("storeInt", &EngineLuaBindings::storeInt,
                                      this);
    dialogueLua.luaState.set_function("storeFloat",
                                      &EngineLuaBindings::storeFloat, this);
    dialogueLua.luaState.set_function("storeTime",
                                      &EngineLuaBindings::storeTime, this);
    dialogueLua.luaState.set_function("storeBitSet",
                                      &EngineLuaBindings::storeBitSet, this);
    dialogueLua.luaState.set_function("storeBit", &EngineLuaBindings::storeBit,
                                      this);
    dialogueLua.luaState.set_function("getStoredUint",
                                      &EngineLuaBindings::getStoredUint, this);
    dialogueLua.luaState.set_function("getStoredBool",
                                      &EngineLuaBindings::getStoredBool, this);
    dialogueLua.luaState.set_function("getStoredInt",
                                      &EngineLuaBindings::getStoredInt, this);
    dialogueLua.luaState.set_function("getStoredFloat",
                                      &EngineLuaBindings::getStoredFloat, this);
    dialogueLua.luaState.set_function("getStoredTime",
                                      &EngineLuaBindings::getStoredTime, this);
    dialogueLua.luaState.set_function(
        "getStoredBitSet", &EngineLuaBindings::getStoredBitSet, this);
    dialogueLua.luaState.set_function("getStoredBit",
                                      &EngineLuaBindings::getStoredBit, this);
    dialogueLua.luaState.set_function("getBit", &EngineLuaBindings::getBit,
                                      this);
    dialogueLua.luaState.set_function("setBit", &EngineLuaBindings::setBit,
                                      this);
    dialogueLua.luaState.set_function("getCurrentTime",
                                      &EngineLuaBindings::getCurrentTime, this);
    dialogueLua.luaState.set_function(
        "sendSystemMessage", [&](std::string_view message) {
            sendSystemMessage(message, dialogueLua.clientID);
        });
}

void EngineLuaBindings::addDialogueChoiceConditionBindings()
{
    dialogueChoiceConditionLua.luaState.set_function(
        "getItemCount",
        [&](entt::entity entityToCount, std::string_view itemID) {
            return getItemCount(entityToCount, itemID);
        });
    dialogueChoiceConditionLua.luaState.set_function(
        "getStoredUint", &EngineLuaBindings::getStoredUint, this);
    dialogueChoiceConditionLua.luaState.set_function(
        "getStoredBool", &EngineLuaBindings::getStoredBool, this);
    dialogueChoiceConditionLua.luaState.set_function(
        "getStoredInt", &EngineLuaBindings::getStoredInt, this);
    dialogueChoiceConditionLua.luaState.set_function(
        "getStoredFloat", &EngineLuaBindings::getStoredFloat, this);
    dialogueChoiceConditionLua.luaState.set_function(
        "getStoredTime", &EngineLuaBindings::getStoredTime, this);
    dialogueChoiceConditionLua.luaState.set_function(
        "getStoredBitSet", &EngineLuaBindings::getStoredBitSet, this);
    dialogueChoiceConditionLua.luaState.set_function(
        "getStoredBit", &EngineLuaBindings::getStoredBit, this);
    dialogueChoiceConditionLua.luaState.set_function(
        "getCurrentTime", &EngineLuaBindings::getCurrentTime, this);
}

void EngineLuaBindings::addDialogueChoiceBindings()
{
    dialogueChoiceLua->set_function("choice", &EngineLuaBindings::choice, this);
    dialogueChoiceLua->set_function("choiceIf", &EngineLuaBindings::choiceIf,
                                    this);
}

void EngineLuaBindings::setCollisionLayers(CollisionLayerBitSet collisionLayers)
{
    entt::entity selfEntity{entityInitLua.selfEntity};
    if (world.registry.all_of<CollisionBitSets>(selfEntity))
    {
        world.registry.patch<CollisionBitSets>(
            selfEntity, [&](CollisionBitSets& collisionBitSets) {
                collisionBitSets.setCollisionLayers(collisionLayers, selfEntity,
                                                    world.registry);
            });
    }
    else {
        throw std::runtime_error{"Failed to set collision mask: Entity does "
                                 "not have graphics components."};
    }
}

void EngineLuaBindings::setCollisionMask(CollisionLayerBitSet collisionMask)
{
    entt::entity selfEntity{entityInitLua.selfEntity};
    if (world.registry.all_of<CollisionBitSets>(selfEntity))
    {
        world.registry.patch<CollisionBitSets>(
            selfEntity, [&](CollisionBitSets& collisionBitSets) {
                collisionBitSets.setCollisionMask(collisionMask);
            });
    }
    else {
        throw std::runtime_error{"Failed to set collision mask: Entity does "
                                 "not have graphics components."};
    }
}

void EngineLuaBindings::addTalkInteraction()
{
    Interaction& interaction{
        world.registry.get_or_emplace<Interaction>(entityInitLua.selfEntity)};
    if (!(interaction.add(EntityInteractionType::Talk))) {
        throw std::runtime_error{"Failed to add Talk interaction: Already "
                                 "present or interaction limit reached."};
    }
}

void EngineLuaBindings::setItemHandler(std::string_view handlerScript)
{
    // Set the handler.
    entt::entity entity{entityInitLua.selfEntity};
    ItemHandler& itemHandler{
        world.registry.get_or_emplace<ItemHandler>(entity)};
    itemHandler.handlerScript.script = handlerScript;
}

void EngineLuaBindings::topic(std::string_view topicName,
                              std::string_view topicScript,
                              std::string_view choiceScript)
{
    entt::entity entity{entityInitLua.selfEntity};
    Dialogue& dialogue{world.registry.get_or_emplace<Dialogue>(entity)};
    if ((dialogue.topics.size() - 1) == SDL_MAX_UINT8) {
        workString.clear();
        workString.append("Failed to add topic \"");
        workString.append(topicName);
        workString.append("\": Topic limit reached (256)");
        throw std::runtime_error{workString};
    }

    // Add the new topic to the vector and the map.
    Dialogue::Topic& topic{dialogue.topics.emplace_back(
        std::string{topicName}, std::string{topicScript})};
    Uint8 topicIndex{static_cast<Uint8>(dialogue.topics.size() - 1)};
    dialogue.topicIndices.emplace(topicName, topicIndex);

    // Run the given choice script to fill the choices vector.
    currentDialogueTopic = &topic;
    auto result{
        dialogueChoiceLua->script(choiceScript, &sol::script_pass_on_error)};

    if (!(result.valid())) {
        sol::error err = result;
        workString.clear();
        workString.append("Error in choice script of topic \"");
        workString.append(topicName);
        workString.append("\": ");
        workString.append(err.what());
        throw std::runtime_error{workString};
    }
}

void EngineLuaBindings::setDescription(std::string_view description)
{
    // All items support the Examine interaction already, so we only need to 
    // add the ItemDescription property.
    Item* item{itemInitLua.selfItem};

    // Update the description.
    item->description = description;
}

void EngineLuaBindings::setMaxStackSize(Uint8 newMaxStackSize)
{
    itemInitLua.selfItem->maxStackSize = newMaxStackSize;
}

void EngineLuaBindings::addCombination(std::string_view otherItemID,
                                       std::string_view resultItemID,
                                       std::string_view description)
{
    // Try to add the given combination.
    const Item* otherItem{itemData.getItem(otherItemID)};
    const Item* resultItem{itemData.getItem(resultItemID)};
    if (otherItem && resultItem) {
        Item* item{itemInitLua.selfItem};
        item->itemCombinations.emplace_back(otherItem->numericID,
                                            resultItem->numericID,
                                            std::string{description});
    }
    else {
        workString.clear();
        workString.append("Failed to add item combination: Item(s) not found: ");
        if (!otherItem) {
            workString.append("\"");
            workString.append(otherItemID);
            workString.append("\" ");
        }
        if (!resultItem) {
            workString.append("\"");
            workString.append(resultItemID);
            workString.append("\" ");
        }
        throw std::runtime_error{workString};
    }
}

void EngineLuaBindings::say(std::string_view text)
{
    dialogueLua.dialogueEvents->emplace_back(SayEvent{std::string{text}});
}

void EngineLuaBindings::narrate(std::string_view text)
{
    dialogueLua.dialogueEvents->emplace_back(NarrateEvent{std::string{text}});
}

void EngineLuaBindings::setNextTopic(std::string_view topicName)
{
    // Note: The name's validity is checked by DialogueSystem::runChoice, after
    //       the script is ran.
    dialogueLua.nextTopicName = topicName;
}

void EngineLuaBindings::choice(std::string_view displayText,
                               std::string_view actionScript)
{
    currentDialogueTopic->choices.emplace_back("", std::string{displayText},
                                               std::string{actionScript});
}

void EngineLuaBindings::choiceIf(std::string_view conditionScript,
                                 std::string_view displayText,
                                 std::string_view actionScript)
{
    currentDialogueTopic->choices.emplace_back(std::string{conditionScript},
                                               std::string{displayText},
                                               std::string{actionScript});
}

bool EngineLuaBindings::addItem(entt::entity entityToAddTo,
                                std::string_view itemID, Uint8 count)
{
    if (!(world.registry.valid(entityToAddTo))) {
        throw std::runtime_error{"Failed to add item: Invalid entity ID."};
    }

    // Try to add the item, sending update messages appropriately.
    auto result{world.inventoryHelper.addItemToEntity(itemID, count,
                                                      entityToAddTo, false)};
    if (result == InventoryHelper::AddResult::InventoryFull) {
        throw std::runtime_error{"Failed to add item: Inventory is full."};
    }
    else if (result == InventoryHelper::AddResult::ItemNotFound) {
        workString.clear();
        workString.append("Failed to add item: Item \"");
        workString.append(itemID);
        workString.append("\" not found.");
        throw std::runtime_error{workString};
    }

    return (result == InventoryHelper::AddResult::Success);
}

bool EngineLuaBindings::removeItem(entt::entity entityToRemoveFrom,
                                   std::string_view itemID, Uint8 count)
{
    if (!(world.registry.valid(entityToRemoveFrom))) {
        throw std::runtime_error{"Failed to remove item: Invalid entity ID."};
    }

    // Try to remove the item, sending update messages appropriately.
    // Note: This will walk the whole inventory, looking for enough copies of
    //       the item to satisfy the given count.
    auto result{world.inventoryHelper.removeItemFromEntity(
        itemID, count, entityToRemoveFrom, false)};
    if (result == InventoryHelper::RemoveResult::InsufficientItemCount) {
        throw std::runtime_error{
            "Failed to remove item: Insufficient item count."};
    }
    else if (result == InventoryHelper::RemoveResult::InventoryNotFound) {
        throw std::runtime_error{"Failed to remove item: Entity has no "
                                 "Inventory component."};
    }
    else if (result == InventoryHelper::RemoveResult::ItemNotFound) {
        workString.clear();
        workString.append("Failed to remove item: Item \"");
        workString.append(itemID);
        workString.append("\" not found.");
        throw std::runtime_error{workString};
    }

    return (result == InventoryHelper::RemoveResult::Success);
}

std::size_t EngineLuaBindings::getItemCount(entt::entity entityToCount,
                                            std::string_view itemID)
{
    if (!(world.registry.valid(entityToCount))) {
        throw std::runtime_error{
            "Failed to get item count: Invalid entity ID."};
    }

    // Try to return the count for the given item.
    const Item* item{itemData.getItem(itemID)};
    auto* inventory{world.registry.try_get<Inventory>(entityToCount)};
    if (item && inventory) {
        return inventory->getItemCount(item->numericID);
    }
    else if (inventory) {
        throw std::runtime_error{"Failed to get item count: Invalid item ID."};
    }

    // Inventory doesn't exist, so the entity has 0 count of the item by default.
    return 0;
}

void EngineLuaBindings::storeUint(entt::entity entity,
                                  std::string_view stringID, Uint32 newValue)
{
    // If we were given a non-null entity, use its store.
    if (entity != entt::null) {
        if (!(world.registry.valid(entity))) {
            throw std::runtime_error{
                "Failed to store value: Invalid entity ID."};
        }

        // Try to store the value.
        StoredValues& storedValues{
            world.registry.get_or_emplace<StoredValues>(entity)};
        if (!(storedValues.storeValue(stringID, newValue, world))) {
            workString.clear();
            workString.append("Failed to store value \"");
            workString.append(stringID);
            workString.append("\": value doesn't exist and value limit is reached");
            throw std::runtime_error{workString};
        }
    }
    else {
        // We were given entt::null, use the global store.
        world.storeGlobalValue(stringID, newValue);
    }
}

void EngineLuaBindings::storeBool(entt::entity entity,
                                  std::string_view stringID, bool newValue)
{
    storeUint(entity, stringID, static_cast<Uint32>(newValue));
}

void EngineLuaBindings::storeInt(entt::entity entity, std::string_view stringID,
                                 int newValue)
{
    storeUint(entity, stringID, static_cast<Uint32>(newValue));
}

void EngineLuaBindings::storeFloat(entt::entity entity,
                                   std::string_view stringID, float newValue)
{
    static_assert(sizeof(float) == 4, "float is expected to be 4 bytes.");

    // Copy the float's bytes to a Uint32 without converting.
    Uint32 newValueUint{};
    std::memcpy(&newValueUint, &newValue, 4);
    storeUint(entity, stringID, newValueUint);
}

void EngineLuaBindings::storeTime(entt::entity entity,
                                  std::string_view stringID, Uint32 newValue)
{
    // Note: Time is only a type to make scripts more readable. It's handled 
    //       the same as Uint32.
    storeUint(entity, stringID, newValue);
}

void EngineLuaBindings::storeBitSet(entt::entity entity,
                                    std::string_view stringID, Uint32 newValue)
{
    // Note: BitSet is only a type to make scripts more readable. It's handled 
    //       the same as Uint32.
    storeUint(entity, stringID, newValue);
}

void EngineLuaBindings::storeBit(entt::entity entity, std::string_view stringID,
                                 Uint8 bitToSet, bool newValue)
{
    if (bitToSet > 31) {
        throw std::runtime_error{
            "Failed to store bit: bitToSet must be within range [0, 31]."};
    }

    // This will give us either the current value if it already exists, or 
    // 0 (a fresh bit set).
    Uint32 bitSet{getStoredUint(entity, stringID)};

    // Set the bit and store the new value.
    setBit(bitSet, bitToSet, newValue);

    storeUint(entity, stringID, bitSet);
}

Uint32 EngineLuaBindings::getStoredUint(entt::entity entity,
                                        std::string_view stringID)
{
    // If we were given a non-null entity, use its store.
    if (entity != entt::null) {
        if (!(world.registry.valid(entity))) {
            throw std::runtime_error{
                "Failed to get stored value: Invalid entity ID."};
        }

        // Try to get the value.
        if (auto* storedValues{world.registry.try_get<StoredValues>(entity)}) {
            return storedValues->getStoredValue(stringID, world);
        }
    }
    else {
        // We were given entt::null, use the global store.
        return world.getStoredValue(stringID);
    }

    return 0;
}

bool EngineLuaBindings::getStoredBool(entt::entity entity,
                                      std::string_view stringID)
{
    return static_cast<bool>(getStoredUint(entity, stringID));
}

int EngineLuaBindings::getStoredInt(entt::entity entity,
                                    std::string_view stringID)
{
    return static_cast<int>(getStoredUint(entity, stringID));
}

float EngineLuaBindings::getStoredFloat(entt::entity entity,
                                        std::string_view stringID)
{
    // Copy the stored Uint32's bytes to a float without converting.
    Uint32 storedValue{getStoredUint(entity, stringID)};
    float storedValueFloat{};
    std::memcpy(&storedValueFloat, &storedValue, 4);

    return storedValueFloat;
}

Uint32 EngineLuaBindings::getStoredTime(entt::entity entity,
                                        std::string_view stringID)
{
    // Note: Time is only a type to make scripts more readable. It's handled 
    //       the same as Uint32.
    return getStoredUint(entity, stringID);
}

Uint32 EngineLuaBindings::getStoredBitSet(entt::entity entity,
                                                   std::string_view stringID)
{
    // Note: BitSet is only a type to make scripts more readable. It's handled 
    //       the same as Uint32.
    return getStoredUint(entity, stringID);
}

bool EngineLuaBindings::getStoredBit(entt::entity entity,
                                     std::string_view stringID, Uint8 bitToGet)
{
    if (bitToGet > 31) {
        throw std::runtime_error{
            "Failed to get bit: bitToGet must be within range [0, 31]."};
    }

    // This will give us either the current value if it already exists, or 
    // 0 (a fresh bit set).
    Uint32 storedValue{getStoredUint(entity, stringID)};

    return getBit(storedValue, bitToGet);
}

void EngineLuaBindings::setBit(std::reference_wrapper<Uint32> bitSet,
                               Uint8 bitToSet, bool newValue)
{
    if (bitToSet > 31) {
        throw std::runtime_error{
            "Failed to set bit: bitToSet must be within range [0, 31]."};
    }

    Uint32 mask{static_cast<Uint32>(1) << bitToSet};
    if (newValue) {
        bitSet |= mask;
    }
    else {
        bitSet &= ~mask;
    }
}

bool EngineLuaBindings::getBit(Uint32 bitSet, Uint8 bitToGet)
{
    if (bitToGet > 31) {
        throw std::runtime_error{
            "Failed to get bit: bitToGet must be within range [0, 31]."};
    }

    return (bitSet >> bitToGet) & static_cast<Uint32>(1);
}

Uint32 EngineLuaBindings::getCurrentTime()
{
    time_t timeValue{time(nullptr)};
    return static_cast<Uint32>(timeValue);
}

void EngineLuaBindings::sendSystemMessage(std::string_view message,
                                          NetworkID clientID)
{
    network.serializeAndSend(clientID, SystemMessage{std::string{message}});
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/MovementSyncSystem.cpp`:

```cpp
#include "MovementSyncSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "MovementUpdate.h"
#include "EnttGroups.h"
#include "ClientSimData.h"
#include "MovementModifiers.h"
#include "Log.h"
#include "tracy/Tracy.hpp"
#include <algorithm>

namespace AM
{
namespace Server
{
MovementSyncSystem::MovementSyncSystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, updatedEntities{}
, entitiesToSend{}
, movementSyncObserver{}
{
    // Observe Input and MovementModifiers. Everything else can be handled 
    // client-side.
    movementSyncObserver.bind(world.registry);
    movementSyncObserver.on_update<Input>().on_update<MovementModifiers>();
}

void MovementSyncSystem::sendMovementUpdates()
{
    ZoneScoped;

    // TODO: We should measure this function and see if it's more performant to
    //       instead loop over all entities that moved on this frame and add
    //       their AOI entities to a map of update messages to be sent.

    // Push all the updated entities into a vector and sort them.
    updatedEntities.clear();
    for (entt::entity entity : movementSyncObserver) {
        updatedEntities.push_back(entity);
    }
    std::sort(updatedEntities.begin(), updatedEntities.end());
    movementSyncObserver.clear();

    // Send clients the updated movement state of any nearby entities that have
    // changed inputs, teleported, etc.
    auto clientView{world.registry.view<ClientSimData>()};
    for (auto [clientEntity, client] : clientView.each()) {
        // Collect the entities that have updated state that is relevant to
        // this client.
        collectEntitiesToSend(client);

        // If there is updated state to send, send an update message.
        if (entitiesToSend.size() > 0) {
            sendEntityUpdate(client);
        }
    }
}

void MovementSyncSystem::collectEntitiesToSend(ClientSimData& client)
{
    /* Collect the entities that need to be sent to the client. */
    // Clear the vector.
    entitiesToSend.clear();

    // Fill entitiesToSend with all of the entities that are both updated and
    // in this client's AOI.
    std::set_intersection(updatedEntities.begin(), updatedEntities.end(),
                          client.entitiesInAOI.begin(),
                          client.entitiesInAOI.end(),
                          std::back_inserter(entitiesToSend));
}

void MovementSyncSystem::sendEntityUpdate(ClientSimData& client)
{
    auto movementGroup{EnttGroups::getMovementGroup(world.registry)};
    MovementUpdate movementUpdate{};

    // Add the entities to the message.
    for (entt::entity entityToSend : entitiesToSend) {
        auto [input, position, movement, movementMods]
            = movementGroup.get<Input, Position, Movement, MovementModifiers>(
                entityToSend);
        movementUpdate.movementStates.push_back(
            {entityToSend, input, position, movement, movementMods});
    }

    // Finish filling the other fields.
    movementUpdate.tickNum = simulation.getCurrentTick();

    // Send the message.
    network.serializeAndSend(client.netID, movementUpdate,
                             movementUpdate.tickNum);
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/MovementSystem.cpp`:

```cpp
#include "MovementSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "MovementHelpers.h"
#include "EnttGroups.h"
#include "SharedConfig.h"
#include "Transforms.h"
#include "Log.h"
#include "tracy/Tracy.hpp"

namespace AM
{
namespace Server
{
MovementSystem::MovementSystem(const SimulationContext& inSimContext)
: world(inSimContext.simulation.getWorld())
, entityMover{world.registry, world.tileMap, world.entityLocator,
              world.collisionLocator}
{
}

void MovementSystem::processMovements()
{
    ZoneScoped;

    // Move all entities that have the required components.
    auto movementGroup = EnttGroups::getMovementGroup(world.registry);
    for (auto [entity, input, position, previousPosition, movement,
               movementMods, rotation, collision, collisionBitSets] :
         movementGroup.each()) {
        // Save their old position.
        previousPosition = position;

        // Move the entity.
        entityMover.moveEntity(
            {.entity{entity},
             .inputStates{input.inputStates},
             .position{position},
             .previousPosition{previousPosition},
             .movement{movement},
             .movementMods{movementMods},
             .rotation{rotation},
             .collision{collision},
             .collisionBitSets{collisionBitSets},
             .deltaSeconds{SharedConfig::SIM_TICK_TIMESTEP_S}});
    }
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/NceLifetimeSystem.cpp`:

```cpp
#include "NceLifetimeSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Database.h"
#include "Network.h"
#include "Name.h"
#include "Position.h"
#include "EntityInitScript.h"
#include "IsClientEntity.h"
#include "Collision.h"
#include "SystemMessage.h"
#include "ISimulationExtension.h"
#include "Log.h"

namespace AM
{
namespace Server
{

NceLifetimeSystem::NceLifetimeSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, extension{nullptr}
, entityReInitQueue{}
, entityInitRequestQueue{inSimContext.networkEventDispatcher}
, entityDeleteRequestQueue{inSimContext.networkEventDispatcher}
{
}

void NceLifetimeSystem::processUpdateRequests()
{
    // Process any entities that are waiting for re-initialization.
    while (!(entityReInitQueue.empty())) {
        EntityInitRequest& queuedEntityInit{entityReInitQueue.front()};
        createEntity(queuedEntityInit);
        entityReInitQueue.pop();
    }

    // If we've been requested to create an entity, create it.
    EntityInitRequest entityCreateRequest{};
    while (entityInitRequestQueue.pop(entityCreateRequest)) {
        handleInitRequest(entityCreateRequest);
    }

    // If we've been requested to delete an entity, delete it.
    EntityDeleteRequest entityDeleteRequest{};
    while (entityDeleteRequestQueue.pop(entityDeleteRequest)) {
        handleDeleteRequest(entityDeleteRequest);
    }
}

void NceLifetimeSystem::setExtension(ISimulationExtension* inExtension)
{
    extension = inExtension;
}

void NceLifetimeSystem::handleInitRequest(
    const EntityInitRequest& entityInitRequest)
{
    // If the project says the request isn't valid, do nothing.
    if (!(extension->isEntityInitRequestValid(entityInitRequest))) {
        return;
    }

    // If the message contains a valid entity ID, re-initialize the given entity.
    if (world.registry.valid(entityInitRequest.entity)) {
        // If the requested entity is a client entity, do nothing (we don't 
        // allow clients to re-init client entities).
        if (world.registry.all_of<IsClientEntity>(entityInitRequest.entity)) {
            return;
        }

        // Destroy the entity.
        // Note: This will cause it to be removed from the entity locator, 
        //       triggering ClientAOISystem to tell peers to delete it.
        //       Then, when we re-init it, ClientAOISystem will send them 
        //       the new data. This ensures that we don't leave any old 
        //       components.
        world.registry.destroy(entityInitRequest.entity);

        // Queue an init for next tick.
        entityReInitQueue.push(entityInitRequest);
    }
    else {
        // No ID, create a new entity and initialize it.
        createEntity(entityInitRequest);
    }
}

void NceLifetimeSystem::handleDeleteRequest(
    const EntityDeleteRequest& entityDeleteRequest)
{
    // If the entity isn't valid or is a client, skip it.
    entt::entity entity{entityDeleteRequest.entity};
    if (!(world.registry.valid(entity))
        || world.registry.all_of<IsClientEntity>(entity)) {
        return;
    }
    // If the project says the request isn't valid, skip it.
    else if (!(extension->isEntityDeleteRequestValid(entityDeleteRequest))) {
        return;
    }

    world.registry.destroy(entity);
}

void NceLifetimeSystem::createEntity(const EntityInitRequest& entityInitRequest)
{
    // Try to create the entity.
    entt::entity newEntity{world.createEntity(entityInitRequest.position,
                                              entityInitRequest.entity)};
    if (newEntity == entt::null) {
        network.serializeAndSend(
            entityInitRequest.netID,
            SystemMessage{"Failed to create entity: Invalid position"});
        return;
    }

    // Try to add the graphic components.
    if (!(world.addGraphicsComponents(newEntity,
                                      entityInitRequest.graphicState))) {
        network.serializeAndSend(
            entityInitRequest.netID,
            SystemMessage{"Failed to create entity: Invalid position"});
        return;
    }

    // Add the rest of its components.
    world.registry.emplace<Name>(newEntity, entityInitRequest.name);
    // Note: This new Rotation value will be sync'd properly, since 
    //       ClientAOISystem hasn't ran yet.
    world.registry.get<Rotation>(newEntity) = entityInitRequest.rotation;

    // Run the init script. If there was an error, tell the user.
    std::string resultString{
        world.runEntityInitScript(newEntity, entityInitRequest.initScript)};
    if (!(resultString.empty())) {
        network.serializeAndSend(entityInitRequest.netID,
                                 SystemMessage{resultString});
    }
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Private/SaveSystem.cpp`:

```cpp
#include "SaveSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "ItemData.h"
#include "Config.h"
#include "Database.h"
#include "PersistedComponent.h"
#include "ClientSimData.h"
#include "SaveTimestamp.h"
#include "Serialize.h"
#include "Log.h"
#include "boost/mp11/algorithm.hpp"
#include <type_traits>

namespace AM
{
namespace Server
{

/**
 * Retrieves all persisted component types that the entity possesses from 
 * TypeList and pushes them into componentVec.
 *
 * Note: This is a free function to reduce includes in the header.
 */
template<typename TypeList, typename VariantType>
void addComponentsToVector(entt::registry& registry, entt::entity entity,
                           std::vector<VariantType>& componentVec)
{
    boost::mp11::mp_for_each<TypeList>([&](auto I) {
        using ComponentType = decltype(I);

        if (registry.all_of<ComponentType>(entity)) {
            if constexpr (std::is_empty_v<ComponentType>) {
                // Note: Can't registry.get() empty types.
                componentVec.push_back(ComponentType{});
            }
            else {
                componentVec.push_back(registry.get<ComponentType>(entity));
            }
        }
    });
}

SaveSystem::SaveSystem(const SimulationContext& inSimContext)
: simulation{inSimContext.simulation}
, world{inSimContext.simulation.getWorld()}
, itemData{inSimContext.itemData}
, updatedItems{}
, saveTimer{}
, workBuffer1{}
{
    // When an item is created or updated, add it to updatedItems.
    itemData.itemCreated.connect<&SaveSystem::itemUpdated>(this);
    itemData.itemUpdated.connect<&SaveSystem::itemUpdated>(this);
}

void SaveSystem::saveIfNecessary()
{
    // If enough time has passed and a backup isn't still underway, save 
    // everything to the database.
    if ((saveTimer.getTime() >= Config::SAVE_PERIOD_S)
        && !(world.database->backupIsInProgress())) {
        LOG_INFO("Saving entities, items, and map...");

        // Save all of our data to the in-memory database.
        world.database->startTransaction();

        saveNonClientEntities();
        saveItems();
        saveStoredValues();
        // TODO: Track changed tiles and save to the database.
        world.tileMap.save("TileMap.bin");

        world.database->commitTransaction();

        // Backup the in-memory database to the file database.
        world.database->backupToFile();

        saveTimer.reset();
    }
}

void SaveSystem::itemUpdated(ItemID itemID)
{
    updatedItems.emplace_back(itemID);
}

void SaveSystem::saveNonClientEntities()
{
    // Note: If doing a full save ever starts taking too long, we can add 
    //       an observer that tracks changes to non-client entities and only 
    //       save those.

    // Queue all of our entity save queries.
    Uint32 currentTick{simulation.getCurrentTick()};
    auto view{
        world.registry.view<entt::entity>(entt::exclude_t<ClientSimData>{})};
    std::vector<EnginePersistedComponent> engineComponents{};
    std::vector<ProjectPersistedComponent> projectComponents{};
    for (entt::entity entity : view) {
        // Update the entity's SaveTimestamp.
        SaveTimestamp& saveTimestamp{
            world.registry.get_or_emplace<SaveTimestamp>(entity)};
        saveTimestamp.lastSavedTick = currentTick;

        // Save the entity's data.
        engineComponents.clear();
        projectComponents.clear();

        addComponentsToVector<EnginePersistedComponentTypes,
                              EnginePersistedComponent>(
            world.registry, entity, engineComponents);
        addComponentsToVector<ProjectPersistedComponentTypes,
                              ProjectPersistedComponent>(
            world.registry, entity, projectComponents);

        workBuffer1.clear();
        workBuffer2.clear();
        workBuffer1.resize(Serialize::measureSize(engineComponents));
        workBuffer2.resize(Serialize::measureSize(projectComponents));
        Serialize::toBuffer(workBuffer1.data(), workBuffer1.size(),
                            engineComponents);
        Serialize::toBuffer(workBuffer2.data(), workBuffer2.size(),
                            projectComponents);

        world.database->saveEntityData(entity, workBuffer1, workBuffer2);
    }
}

void SaveSystem::saveItems()
{
    // Remove duplicates from the vector.
    std::sort(updatedItems.begin(), updatedItems.end());
    updatedItems.erase(
        std::unique(updatedItems.begin(), updatedItems.end()),
        updatedItems.end());

    // Queue all of our item save queries.
    for (ItemID itemID : updatedItems) {
        const Item* updatedItem{itemData.getItem(itemID)};

        workBuffer1.clear();
        workBuffer1.resize(Serialize::measureSize(*updatedItem));
        Serialize::toBuffer(workBuffer1.data(), workBuffer1.size(),
                            *updatedItem);

        world.database->saveItemData(
            updatedItem->numericID, workBuffer1,
            itemData.getItemVersion(updatedItem->numericID),
            itemData.getItemInitScript(updatedItem->numericID).script);
    }

    updatedItems.clear();
}

void SaveSystem::saveStoredValues()
{
    // Serialize the entity stored value ID map.
    workBuffer1.clear();
    workBuffer1.resize(Serialize::measureSize(world.entityStoredValueIDMap));
    Serialize::toBuffer(workBuffer1.data(), workBuffer1.size(),
                        world.entityStoredValueIDMap);

    // Queue the save query.
    world.database->saveEntityStoredValueIDMap(workBuffer1);

    // Serialize the global stored value map.
    workBuffer1.clear();
    workBuffer1.resize(Serialize::measureSize(world.globalStoredValueMap));
    Serialize::toBuffer(workBuffer1.data(), workBuffer1.size(),
                        world.globalStoredValueMap);

    // Queue the save query.
    world.database->saveGlobalStoredValueMap(workBuffer1);
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/ScriptDataSystem.cpp`:

```cpp
#include "ScriptDataSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "Network.h"
#include "ItemData.h"
#include "EntityInitScriptResponse.h"
#include "ItemInitScriptResponse.h"
#include "Log.h"
#include <SDL_rect.h>
#include <vector>

namespace AM
{
namespace Server
{
ScriptDataSystem::ScriptDataSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, itemData{inSimContext.itemData}
, entityInitScriptRequestQueue{inSimContext.networkEventDispatcher}
, itemInitScriptRequestQueue{inSimContext.networkEventDispatcher}
{
}

void ScriptDataSystem::sendScripts()
{
    // Process all script data requests.
    EntityInitScriptRequest entityInitScriptRequest{};
    while (entityInitScriptRequestQueue.pop(entityInitScriptRequest)) {
        sendEntityInitScript(entityInitScriptRequest);
    }

    ItemInitScriptRequest itemInitScriptRequest{};
    while (itemInitScriptRequestQueue.pop(itemInitScriptRequest)) {
        sendItemInitScript(itemInitScriptRequest);
    }
}

void ScriptDataSystem::sendEntityInitScript(
    const EntityInitScriptRequest& initScriptRequest)
{
    // If the given entity has an init script, send it.
    entt::entity entity{initScriptRequest.entity};
    if (const auto* initScript{
            world.registry.try_get<EntityInitScript>(entity)}) {
        network.serializeAndSend(initScriptRequest.netID,
                                 EntityInitScriptResponse{entity, *initScript});
    }
}

void ScriptDataSystem::sendItemInitScript(
    const ItemInitScriptRequest& initScriptRequest)
{
    // If the given item is valid, send its init script.
    if (const Item* item{itemData.getItem(initScriptRequest.itemID)}) {
        network.serializeAndSend(
            initScriptRequest.netID,
            ItemInitScriptResponse{
                item->numericID, itemData.getItemInitScript(item->numericID)});
    }
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Private/Simulation.cpp`:

```cpp
#include "Simulation.h"
#include "SimulationContext.h"
#include "Network.h"
#include "ItemData.h"
#include "CastableData.h"
#include "EntityInitLua.h"
#include "EntityItemHandlerLua.h"
#include "ItemInitLua.h"
#include "DialogueLua.h"
#include "DialogueChoiceConditionLua.h"
#include "ISimulationExtension.h"
#include "Interaction.h"
#include "Inventory.h"
#include "SystemMessage.h"
#include "Log.h"
#include "Timer.h"
#include "tracy/Tracy.hpp"

#define SOL_ALL_SAFETIES_ON 1
#include "sol/sol.hpp"

namespace AM
{
namespace Server
{
Simulation::Simulation(const SimulationContext& inSimContext)
: network{inSimContext.network}
, entityInitLua{std::make_unique<EntityInitLua>()}
, entityItemHandlerLua{std::make_unique<EntityItemHandlerLua>()}
, itemInitLua{std::make_unique<ItemInitLua>()}
, dialogueLua{std::make_unique<DialogueLua>()}
, dialogueChoiceConditionLua{std::make_unique<DialogueChoiceConditionLua>()}
, world{inSimContext}
, currentTick{0}
, engineLuaBindings{*entityInitLua,
                    *entityItemHandlerLua,
                    *itemInitLua,
                    *dialogueLua,
                    *dialogueChoiceConditionLua,
                    inSimContext.graphicData,
                    inSimContext.itemData,
                    world,
                    network}
, extension{nullptr}
, clientConnectionSystem{inSimContext}
, nceLifetimeSystem{inSimContext}
, componentChangeSystem{inSimContext}
, tileUpdateSystem{inSimContext}
, inputSystem{inSimContext}
, movementSystem{inSimContext}
, aiSystem{inSimContext}
, castSystem{inSimContext}
, itemSystem{inSimContext}
, inventorySystem{inSimContext}
, dialogueSystem{inSimContext}
, clientAOISystem{inSimContext}
, movementSyncSystem{inSimContext}
, componentSyncSystem{inSimContext}
, chunkStreamingSystem{inSimContext}
, scriptDataSystem{inSimContext}
, saveSystem{inSimContext}
{
    // Register our current tick pointer with the classes that care.
    Log::registerCurrentTickPtr(&currentTick);
    network.registerCurrentTickPtr(&currentTick);
}

Simulation::~Simulation() = default;

World& Simulation::getWorld()
{
    return world;
}

EntityInitLua& Simulation::getEntityInitLua()
{
    return *entityInitLua;
}

EntityItemHandlerLua& Simulation::getEntityItemHandlerLua()
{
    return *entityItemHandlerLua;
}

ItemInitLua& Simulation::getItemInitLua()
{
    return *itemInitLua;
}

DialogueLua& Simulation::getDialogueLua()
{
    return *dialogueLua;
}

DialogueChoiceConditionLua& Simulation::getDialogueChoiceConditionLua()
{
    return *dialogueChoiceConditionLua;
}

Uint32 Simulation::getCurrentTick() const
{
    return currentTick;
}

void Simulation::tick()
{
    ZoneScoped;

    /* Run all systems. */
    // Call the project's pre-everything logic.
    extension->beforeAll();

    // Process client connections and disconnections.
    clientConnectionSystem.processConnectionEvents();

    // Process requests to create or destroy non-client-controlled entities.
    nceLifetimeSystem.processUpdateRequests();

    // Process requests to change components.
    componentChangeSystem.processChangeRequests();

    // Receive and process tile update requests.
    tileUpdateSystem.updateTiles();

    // Call the project's pre-movement logic.
    extension->afterMapAndConnectionUpdates();

    // Send updated tile state to nearby clients.
    tileUpdateSystem.sendTileUpdates();

    // Receive and process client input messages.
    inputSystem.processInputMessages();

    // Move all of our entities.
    movementSystem.processMovements();

    // Run all of our AI.
    aiSystem.processAITick();

    // Process any cast requests and ongoing casts.
    castSystem.processCasts();

    // Process any waiting "use item" interaction messages.
    itemSystem.processUseItemInteractions();

    // Process and send item definition updates.
    itemSystem.processItemUpdates();

    // Process inventory updates.
    inventorySystem.processInventoryUpdates();

    // Process Talk interactions and dialogue choice requests, updating sim 
    // state and sending responses as necessary.
    dialogueSystem.processDialogueInteractions();

    // Call the project's post-sim-update logic.
    extension->afterSimUpdate();

    // Update each client entity's "entities in my AOI" list and send Init/
    // Delete messages.
    clientAOISystem.updateAOILists();

    // Send any updated entity movement state to nearby clients.
    movementSyncSystem.sendMovementUpdates();

    // Send initial Inventory state.
    inventorySystem.sendInventoryInits();

    // Send initial CastCooldown state.
    castSystem.sendCastCooldownInits();

    // Send any remaining updated entity component state to nearby clients.
    componentSyncSystem.sendUpdates();

    // Call the project's post-movement-sync logic.
    extension->afterClientSync();

    // Respond to chunk data requests.
    chunkStreamingSystem.sendChunks();

    // Respond to script data requests.
    scriptDataSystem.sendScripts();

    // If any category of data is due for saving, save it.
    saveSystem.saveIfNecessary();

    // Call the project's post-everything logic.
    extension->afterAll();

    currentTick++;

    FrameMark;
}

void Simulation::setExtension(ISimulationExtension* inExtension)
{
    extension = inExtension;
    nceLifetimeSystem.setExtension(extension);
    componentChangeSystem.setExtension(extension);
    tileUpdateSystem.setExtension(extension);
    itemSystem.setExtension(extension);
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Private/TileMap/TileMap.cpp`:

```cpp
#include "TileMap.h"
#include "GraphicData.h"
#include "CollisionLocator.h"
#include "Sprite.h"
#include "Paths.h"
#include "Position.h"
#include "Serialize.h"
#include "Deserialize.h"
#include "ByteTools.h"
#include "TileMapSnapshot.h"
#include "Tile.h"
#include "ChunkSnapshot.h"
#include "Morton.h"
#include "SharedConfig.h"
#include "Timer.h"
#include "Log.h"
#include "AMAssert.h"

namespace AM
{
namespace Server
{
TileMap::TileMap(const GraphicData& inGraphicData,
                 CollisionLocator& inCollisionLocator)
: TileMapBase{inGraphicData, inCollisionLocator, true}
{
    // Prime a timer.
    Timer timer;

    // Deserialize the file into a snapshot.
    TileMapSnapshot mapSnapshot;
    std::string mapPath{Paths::BASE_PATH + "TileMap.bin"};
    bool loadSuccessful{Deserialize::fromFile(mapPath, mapSnapshot)};
    if (!loadSuccessful) {
        LOG_FATAL("Failed to deserialize map at path: %s", mapPath.c_str());
    }

    // Load the map snapshot.
    load(mapSnapshot);

    // Print the time taken.
    double timeTaken{timer.getTime()};
    LOG_INFO("Map loaded in %.6fs. Size: (%u, %u, %u)ch.", timeTaken,
             chunkExtent.xLength, chunkExtent.yLength, chunkExtent.zLength);
}

TileMap::~TileMap()
{
    // Save the map state to TileMap.bin.
    save("TileMap.bin");
}

void TileMap::save(const std::string& fileName)
{
    LOG_INFO("Saving map...");

    // Prime a timer.
    Timer timer{};

    /* Save this map's state into a snapshot. */
    // Save the header data.
    TileMapSnapshot mapSnapshot{};
    mapSnapshot.version = MAP_FORMAT_VERSION;
    mapSnapshot.xLengthChunks = static_cast<Uint16>(chunkExtent.xLength);
    mapSnapshot.yLengthChunks = static_cast<Uint16>(chunkExtent.yLength);
    mapSnapshot.zLengthChunks = static_cast<Uint16>(chunkExtent.zLength);

    // Save our tiles into the snapshot as chunks.
    for (auto& [chunkPosition, chunk] : chunks) {
        ChunkSnapshot& chunkSnapshot{mapSnapshot.chunks[chunkPosition]};
        saveChunkToSnapshot(chunk, chunkSnapshot);
    }

    // Serialize the map snapshot and write it to the file.
    bool saveSuccessful{
        Serialize::toFile((Paths::BASE_PATH + fileName), mapSnapshot)};
    if (saveSuccessful) {
        // Print the time taken.
        double timeTaken{timer.getTime()};
        LOG_INFO("Saved %u chunks in %.6fs.", chunkExtent.size(), timeTaken);
    }
    else {
        LOG_FATAL("Failed to serialize and save the map.");
    }
}

void TileMap::load(TileMapSnapshot& mapSnapshot)
{
    /* Load the snapshot into this map. */
    // Load the header data.
    chunkExtent = ChunkExtent::fromMapLengths(mapSnapshot.xLengthChunks,
                                              mapSnapshot.yLengthChunks,
                                              mapSnapshot.zLengthChunks);
    tileExtent = TileExtent{chunkExtent};

    // If the map is too big, exit.
    static constexpr int MAX_MAP_WIDTH_TILES{
        static_cast<int>(SharedConfig::MAX_MAP_WIDTH_TILES)};
    if ((tileExtent.xLength > MAX_MAP_WIDTH_TILES)
        || (tileExtent.yLength > MAX_MAP_WIDTH_TILES)
        || (tileExtent.zLength > MAX_MAP_WIDTH_TILES)) {
        LOG_FATAL("Failed to load map: Map width is larger than "
                  "MAX_MAP_WIDTH_TILES.");
    }

    // Allocate the collision locator grid.
    // Note: We need to do this here instead of in World() because the locator
    //       will be used below.
    collisionLocator.setGridSize(tileExtent);

    // Load all of the snapshot's chunks into our map.
    for (auto& [chunkPosition, chunkSnapshot] : mapSnapshot.chunks) {
        loadChunk(chunkSnapshot,
                  {chunkPosition.x, chunkPosition.y, chunkPosition.z});
    }
}

void TileMap::saveChunkToSnapshot(const Chunk& chunk,
                                  ChunkSnapshot& chunkSnapshot)
{
    // Copy all of the chunk's tile layers into the snapshot.
    chunkSnapshot.tileLayers.resize(chunk.tileLayerCount);
    std::size_t tileLayersIndex{0};
    for (std::size_t tileIndex{0};
         tileIndex < SharedConfig::CHUNK_TILE_COUNT; tileIndex++) {
        // Add this tile's layer count.
        const Tile& tile{chunk.tiles[tileIndex]};
        chunkSnapshot.tileLayerCounts[tileIndex]
            = static_cast<Uint8>(tile.getAllLayers().size());

        // Add all of this tile's layers.
        for (const TileLayer& layer : tile.getAllLayers()) {
            std::size_t paletteIndex{chunkSnapshot.getPaletteIndex(
                layer.type, layer.graphicSet.get().stringID,
                layer.graphicValue)};
            chunkSnapshot.tileLayers[tileLayersIndex]
                = static_cast<Uint8>(paletteIndex);
            tileLayersIndex++;

            // If this is a Floor or Object, add its tile offset.
            if ((layer.type == TileLayer::Type::Floor)
                || (layer.type == TileLayer::Type::Object)) {
                chunkSnapshot.tileOffsets.emplace_back(layer.tileOffset);
            }
        }
    }
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Private/TileUpdateSystem.cpp`:

```cpp
#include "TileUpdateSystem.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "World.h"
#include "Network.h"
#include "ISimulationExtension.h"
#include "ClientSimData.h"
#include "ChunkPosition.h"
#include "TilePosition.h"
#include "AMAssert.h"
#include "tracy/Tracy.hpp"
#include <variant>

namespace AM
{
namespace Server
{
/** Returns the extent that's in range of a given tile update.
    Note: This matches ChunkUpdateSystem's behavior, which includes all
          directly surrounding chunks in the X/Y directions, and every chunk 
          along the Z axis. */
struct InRangeExtentGetter {
    TileMap& tileMap;

    ChunkExtent operator()(const TileExtentClearLayers& tileUpdate)
    {
        const ChunkExtent& mapChunkExtent{tileMap.getChunkExtent()};
        ChunkExtent chunkExtent{tileUpdate.tileExtent};
        chunkExtent.x -= 1;
        chunkExtent.y -= 1;
        chunkExtent.z = mapChunkExtent.z;
        chunkExtent.xLength += 2;
        chunkExtent.yLength += 2;
        chunkExtent.zLength = mapChunkExtent.zLength;
        return chunkExtent.intersectWith(mapChunkExtent);
    }

    // TileAddLayer, TileRemoveLayer, TileClearLayers
    template<typename T>
    ChunkExtent operator()(const T& tileUpdate)
    {
        const ChunkExtent& mapChunkExtent{tileMap.getChunkExtent()};
        ChunkPosition centerChunk{tileUpdate.tilePosition};
        ChunkExtent chunkExtent{(centerChunk.x - 1),
                                (centerChunk.y - 1),
                                mapChunkExtent.z,
                                3,
                                3,
                                mapChunkExtent.zLength};
        return chunkExtent.intersectWith(tileMap.getChunkExtent());
    }
};

/** Sends the given tile update to the currently set client netID. */
struct UpdateSender {
    Network& network;
    NetworkID netID{};

    template<typename T>
    void operator()(const T& tileUpdate)
    {
        network.serializeAndSend<T>(netID, tileUpdate);
    }
};

TileUpdateSystem::TileUpdateSystem(const SimulationContext& inSimContext)
: world{inSimContext.simulation.getWorld()}
, network{inSimContext.network}
, extension{nullptr}
, addLayerRequestQueue{network.getEventDispatcher()}
, removeLayerRequestQueue{network.getEventDispatcher()}
, clearLayersRequestQueue{network.getEventDispatcher()}
, extentClearLayersRequestQueue{network.getEventDispatcher()}
{
}

void TileUpdateSystem::updateTiles()
{
    ZoneScoped;

    // Disable auto collision rebuild (it's more efficient to do it all after).
    world.tileMap.setAutoRebuildCollision(false);

    // Process any waiting update requests.
    TileAddLayer addLayerRequest{};
    while (addLayerRequestQueue.pop(addLayerRequest)) {
        addTileLayer(addLayerRequest);
    }

    TileRemoveLayer removeLayerRequest{};
    while (removeLayerRequestQueue.pop(removeLayerRequest)) {
        remTileLayer(removeLayerRequest);
    }

    TileClearLayers clearLayersRequest{};
    while (clearLayersRequestQueue.pop(clearLayersRequest)) {
        clearTileLayers(clearLayersRequest);
    }

    TileExtentClearLayers clearExtentLayersRequest{};
    while (extentClearLayersRequestQueue.pop(clearExtentLayersRequest)) {
        clearExtentLayers(clearExtentLayersRequest);
    }

    // Re-enable auto collision rebuild (rebuilds any dirty tiles).
    world.tileMap.setAutoRebuildCollision(true);
}

void TileUpdateSystem::sendTileUpdates()
{
    auto clientView = world.registry.view<ClientSimData>();
    const std::vector<TileMapBase::TileUpdateVariant>& tileUpdateHistory{
        world.tileMap.getTileUpdateHistory()};

    // For every tile update that occurred since we last sent updates.
    InRangeExtentGetter extentGetter{world.tileMap};
    UpdateSender updateSender{network};
    for (const auto& updateVariant : tileUpdateHistory) {
        // Find the entities that are in range of this update.
        ChunkExtent inRangeExtent{std::visit(extentGetter, updateVariant)};
        std::vector<entt::entity>& entitiesInRange{
            world.entityLocator.getEntities(inRangeExtent)};

        // Send the update to all of the in-range clients.
        for (entt::entity entity : entitiesInRange) {
            if (world.registry.all_of<ClientSimData>(entity)) {
                ClientSimData& client{clientView.get<ClientSimData>(entity)};
                updateSender.netID = client.netID;
                std::visit(updateSender, updateVariant);
            }
        }
    }

    world.tileMap.clearTileUpdateHistory();
}

void TileUpdateSystem::setExtension(ISimulationExtension* inExtension)
{
    extension = inExtension;
}

void TileUpdateSystem::addTileLayer(const TileAddLayer& addLayerRequest)
{
    // If the project says the tile isn't editable, skip this request.
    if (!(extension->isTileExtentEditable(
            addLayerRequest.netID,
            {addLayerRequest.tilePosition.x, addLayerRequest.tilePosition.y,
             addLayerRequest.tilePosition.z, 1, 1, 1}))) {
        return;
    }

    if (addLayerRequest.layerType == TileLayer::Type::Terrain) {
        world.tileMap.addTerrain(
            addLayerRequest.tilePosition, addLayerRequest.graphicSetID,
            static_cast<Terrain::Value>(addLayerRequest.graphicValue));
    }
    else if (addLayerRequest.layerType == TileLayer::Type::Floor) {
        world.tileMap.addFloor(
            addLayerRequest.tilePosition, addLayerRequest.tileOffset,
            addLayerRequest.graphicSetID,
            static_cast<Rotation::Direction>(addLayerRequest.graphicValue));
    }
    else if (addLayerRequest.layerType == TileLayer::Type::Wall) {
        world.tileMap.addWall(
            addLayerRequest.tilePosition, addLayerRequest.graphicSetID,
            static_cast<Wall::Type>(addLayerRequest.graphicValue));
    }
    else if (addLayerRequest.layerType == TileLayer::Type::Object) {
        world.tileMap.addObject(
            addLayerRequest.tilePosition, addLayerRequest.tileOffset,
            addLayerRequest.graphicSetID,
            static_cast<Rotation::Direction>(addLayerRequest.graphicValue));
    }
}

void TileUpdateSystem::remTileLayer(const TileRemoveLayer& remLayerRequest)
{
    // If the project says the tile isn't editable, skip this request.
    if (!(extension->isTileExtentEditable(
            remLayerRequest.netID,
            {remLayerRequest.tilePosition.x, remLayerRequest.tilePosition.y,
             remLayerRequest.tilePosition.z, 1, 1, 1}))) {
        return;
    }

    if (remLayerRequest.layerType == TileLayer::Type::Terrain) {
        world.tileMap.remTerrain(remLayerRequest.tilePosition);
    }
    else if (remLayerRequest.layerType == TileLayer::Type::Floor) {
        world.tileMap.remFloor(
            remLayerRequest.tilePosition, remLayerRequest.tileOffset,
            remLayerRequest.graphicSetID,
            static_cast<Rotation::Direction>(remLayerRequest.graphicValue));
    }
    else if (remLayerRequest.layerType == TileLayer::Type::Wall) {
        world.tileMap.remWall(
            remLayerRequest.tilePosition,
            static_cast<Wall::Type>(remLayerRequest.graphicValue));
    }
    else if (remLayerRequest.layerType == TileLayer::Type::Object) {
        world.tileMap.remObject(
            remLayerRequest.tilePosition, remLayerRequest.tileOffset,
            remLayerRequest.graphicSetID,
            static_cast<Rotation::Direction>(remLayerRequest.graphicValue));
    }
}

void TileUpdateSystem::clearTileLayers(
    const TileClearLayers& clearLayersRequest)
{
    // If the project says the tile isn't editable, skip this request.
    if (!(extension->isTileExtentEditable(clearLayersRequest.netID,
                                          {clearLayersRequest.tilePosition.x,
                                           clearLayersRequest.tilePosition.y,
                                           clearLayersRequest.tilePosition.z, 1,
                                           1, 1}))) {
        return;
    }

    world.tileMap.clearTileLayers(clearLayersRequest.tilePosition,
                                  clearLayersRequest.layerTypesToClear);
}

void TileUpdateSystem::clearExtentLayers(
    const TileExtentClearLayers& clearExtentLayersRequest)
{
    // If the project says the extent isn't editable, skip this request.
    if (!(extension->isTileExtentEditable(
            clearExtentLayersRequest.netID,
            clearExtentLayersRequest.tileExtent))) {
        return;
    }

    world.tileMap.clearExtentLayers(clearExtentLayersRequest.tileExtent,
                                    clearExtentLayersRequest.layerTypesToClear);
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Private/World.cpp`:

```cpp
#include "World.h"
#include "SimulationContext.h"
#include "Simulation.h"
#include "Network.h"
#include "GraphicData.h"
#include "ItemData.h"
#include "CastableData.h"
#include "EnttGroups.h"
#include "EntityInitLua.h"
#include "ItemInitLua.h"
#include "Database.h"
#include "ClientSimData.h"
#include "ReplicatedComponentList.h"
#include "ReplicatedComponent.h"
#include "PersistedComponent.h"
#include "Position.h"
#include "PreviousPosition.h"
#include "Movement.h"
#include "MovementModifiers.h"
#include "GraphicState.h"
#include "Collision.h"
#include "CollisionBitSets.h"
#include "CastCooldown.h"
#include "EntityInitScript.h"
#include "Deserialize.h"
#include "Transforms.h"
#include "SharedConfig.h"
#include "Config.h"
#include "VariantTools.h"
#include "StringTools.h"
#include "Log.h"
#include "AMAssert.h"
#include "sol/sol.hpp"
#include "boost/mp11/algorithm.hpp"
#include <type_traits>

namespace AM
{
namespace Server
{

template<typename T>
void onComponentConstructed(entt::registry& registry, entt::entity entity)
{
    // Find the component's index within the type list.
    constexpr std::size_t index{
        boost::mp11::mp_find<ReplicatedComponentTypes, T>::value};

    // Add the component to the entity's tracking vector.
    auto& replicatedComponents{
        registry.get_or_emplace<ReplicatedComponentList>(entity)};
    replicatedComponents.typeIndices.push_back(static_cast<Uint8>(index));
}

template<typename T>
void onComponentDestroyed(entt::registry& registry, entt::entity entity)
{
    // Find the component's index within the type list.
    constexpr std::size_t index{
        boost::mp11::mp_find<ReplicatedComponentTypes, T>::value};

    // If the component is in the entity's tracking vector, remove it.
    if (auto replicatedComponents
        = registry.try_get<ReplicatedComponentList>(entity)) {
        std::erase(replicatedComponents->typeIndices, index);
    }
}

World::World(const SimulationContext& inSimContext)
: registry{}
, entityLocator{registry}
, collisionLocator{}
, tileMap{inSimContext.graphicData, collisionLocator}
, entityStoredValueIDMap{}
, globalStoredValueMap{}
, inventoryHelper{*this, inSimContext.network, inSimContext.itemData}
, castHelper{inSimContext.simulation, inSimContext.itemData,
             inSimContext.castableData}
, database{std::make_unique<Database>()}
, netIDMap{}
, simulation{inSimContext.simulation}
, graphicData{inSimContext.graphicData}
, entityInitLua{inSimContext.simulation.getEntityInitLua()}
, itemInitLua{inSimContext.simulation.getItemInitLua()}
, nextStoredValueID{NULL_ENTITY_STORED_VALUE_ID + 1}
, workStringID{}
, randomDevice{}
, generator{randomDevice()}
, xDistribution{Config::SPAWN_POINT_RANDOM_MIN_X,
                Config::SPAWN_POINT_RANDOM_MAX_X}
, yDistribution{Config::SPAWN_POINT_RANDOM_MIN_Y,
                Config::SPAWN_POINT_RANDOM_MAX_Y}
, groupX{}
, groupY{}
, columnIndex{0}
, rowIndex{0}
{
    // Initialize our entt groups.
    EnttGroups::init(registry);

    // Calc our group spawn point starting position. We add padding to make 
    // sure they don't clip the North or West edges of the map.
    TileExtent tileMapExtent{tileMap.getTileExtent()};
    groupX
        = tileMapExtent.x * static_cast<float>(SharedConfig::TILE_WORLD_WIDTH)
          + Config::SPAWN_POINT_GROUP_PADDING_X;
    groupY
        = tileMapExtent.y * static_cast<float>(SharedConfig::TILE_WORLD_WIDTH)
          + Config::SPAWN_POINT_GROUP_PADDING_Y;

    // Allocate the entity locator grid.
    entityLocator.setGridSize(tileMap.getTileExtent());

    // Add listeners for each client-relevant component. When the component is
    // constructed or destroyed, the associated entity's ReplicatedComponentList
    // will be updated.
    boost::mp11::mp_for_each<ReplicatedComponentTypes>([&](auto I) {
        using ComponentType = decltype(I);
        registry.on_construct<ComponentType>()
            .template connect<&onComponentConstructed<ComponentType>>();
        registry.on_destroy<ComponentType>()
            .template connect<&onComponentDestroyed<ComponentType>>();
    });

    // When an entity is destroyed, do any necessary cleanup.
    registry.on_destroy<entt::entity>().connect<&World::onEntityDestroyed>(
        this);

    // Load our saved non-client entities.
    loadNonClientEntities();

    // Load our saved item definitions.
    loadItems(inSimContext.itemData);

    // Load our saved stored value data.
    loadStoredValues();
}

World::~World() = default;

entt::entity World::getClientEntity(NetworkID netID)
{
    // Find the entity ID associated with the given network ID.
    auto it{netIDMap.find(netID)};
    if (it == netIDMap.end()) {
        // Client doesn't exist (may have disconnected).
        return entt::null;
    }

    return it->second;
}

bool World::teleportEntity(entt::entity entity, const Vector3& newPosition)
{
    auto movementGroup{EnttGroups::getMovementGroup(registry)};

    auto [position, collision] = movementGroup.get<Position, Collision>(entity);
    position = newPosition;
    collision.worldBounds
        = Transforms::modelToWorldEntity(collision.modelBounds, position);

    // If the entity is movement-enabled, update its previous position.
    // This will make it teleport straight to the new position instead of 
    // lerping there.
    if (PreviousPosition
        * prevPosition{registry.try_get<PreviousPosition>(entity)}) {
        *prevPosition = position;
    }

    // Flag that the entity's movement state needs to be synced.
    // (movement state is auto-synced when Input is dirtied).
    registry.patch<Input>(entity, [](auto&) {});

    // TODO: Check if valid and return false if not.
    return true;
}

entt::entity World::createEntity(const Position& position,
                                 entt::entity entityHint)
{
    // Create the new entity.
    entt::entity newEntity{entt::null};
    if (entityHint != entt::null) {
        newEntity = registry.create(entityHint);
    }
    else {
        newEntity = registry.create();
    }

    // Add RelicatedComponentList so it gets updated as we add others.
    registry.emplace<ReplicatedComponentList>(newEntity);

    // Add Position (all entities have a Position).
    registry.emplace<Position>(newEntity, position);

    // Try to add the entity to the locator. If it fails, destroy the entity 
    // and return null.
    if (!(entityLocator.updateEntity(newEntity, position))) {
        registry.destroy(newEntity);
        return entt::null;
    }

    return newEntity;
}

bool World::addGraphicsComponents(entt::entity entity,
                                  const GraphicState& graphicState)
{
    // Note: We only add entities to the locator (and replicate them to clients)
    //       if they have a GraphicState. If we ever need to replicate
    //       entities that don't have GraphicState, revisit this.
    //       Similarly, if we ever need to add GraphicState without Collision,
    //       we'll need to revisit this.

    // Use the current graphic as the entity's collision bounds.
    const EntityGraphicSet& graphicSet{
        graphicData.getEntityGraphicSet(graphicState.graphicSetID)};
    const BoundingBox& modelBounds{graphicSet.getCollisionModelBounds()};
    const Position& position{registry.get<Position>(entity)};

    const Collision& collision{registry.emplace<Collision>(
        entity, modelBounds,
        Transforms::modelToWorldEntity(modelBounds, position))};
    const CollisionBitSets& collisionBitSets{
        registry.emplace<CollisionBitSets>(entity, entity, registry)};

    bool rotationAdded{false};
    if (!(registry.all_of<Rotation>(entity))) {
        registry.emplace<Rotation>(entity);
        rotationAdded = true;
    }

    // Try to add the Collision to the locator. If it fails, revert the 
    // changes and return false.
    if (!(collisionLocator.updateEntity(
            entity, collision.worldBounds,
            collisionBitSets.getCollisionLayers()))) {
        registry.erase<Collision, CollisionBitSets>(entity);
        if (rotationAdded) {
            registry.erase<Rotation>(entity);
        }
        return false;
    }

    // Add the GraphicState.
    registry.emplace<GraphicState>(entity, graphicState);

    return true;
}

void World::addMovementComponents(entt::entity entity)
{
    if (!(registry.all_of<Input>(entity))) {
        registry.emplace<Input>(entity);
    }

    if (!(registry.all_of<PreviousPosition>(entity))) {
        // Note: All entities have a Position component.
        registry.emplace<PreviousPosition>(entity,
                                           registry.get<Position>(entity));
    }

    if (!(registry.all_of<Movement>(entity))) {
        registry.emplace<Movement>(entity);
    }

    if (!(registry.all_of<MovementModifiers>(entity))) {
        registry.emplace<MovementModifiers>(entity);
    }

    // Note: We add Rotation as part of movement (instead of just graphics), 
    //       because it may be useful at some point to have a non-graphical 
    //       entity that is movement-enabled and can face a direction.
    if (!(registry.all_of<Rotation>(entity))) {
        registry.emplace<Rotation>(entity);
    }
}

std::string World::runEntityInitScript(entt::entity entity,
                                       const EntityInitScript& initScript)
{
    // Run the given script on the given entity.
    entityInitLua.selfEntity = entity;
    auto result{entityInitLua.luaState.script(initScript.script,
                                              &sol::script_pass_on_error)};

    // If the init script ran successfully, save it.
    std::string returnString{""};
    if (result.valid()) {
        registry.emplace<EntityInitScript>(entity, initScript);
    }
    else {
        // Error while running the init script. Keep the entity alive (so the
        // user can try again) and return the error.
        sol::error err = result;
        returnString = err.what();
    }

    return returnString;
}

std::string World::runItemInitScript(Item& item, std::string_view initScript)
{
    // Run the given script on the given item.
    itemInitLua.selfItem = &item;
    auto result{
        itemInitLua.luaState.script(initScript, &sol::script_pass_on_error)};

    // If the init script failed, return the error.
    std::string returnString{""};
    if (!(result.valid())) {
        // Error while running the init script. Return the error.
        sol::error err = result;
        returnString = err.what();
    }

    return returnString;
}

EntityStoredValueID World::getEntityStoredValueID(std::string_view stringID)
{
    // Derive string ID in case the user accidentally passed a display name.
    StringTools::deriveStringID(stringID, workStringID);

    // If the value already exists, return its numeric ID.
    auto storedValueIDIt{entityStoredValueIDMap.find(workStringID)};
    if (storedValueIDIt != entityStoredValueIDMap.end()) {
        return storedValueIDIt->second;
    }
    else {
        // Check if we've ran out of IDs.
        if (nextStoredValueID == SDL_MAX_UINT16) {
            return NULL_ENTITY_STORED_VALUE_ID;
        }

        // Flag doesn't exist, add it to the map.
        EntityStoredValueID newFlagID{static_cast<Uint16>(nextStoredValueID)};
        entityStoredValueIDMap.emplace(workStringID, newFlagID);
        nextStoredValueID++;

        return newFlagID;
    }
}

void World::storeGlobalValue(std::string_view stringID, Uint32 newValue)
{
    // Derive string ID in case the user accidentally passed a display name.
    StringTools::deriveStringID(stringID, workStringID);

    // If we're setting the value to 0, don't add it to the map (default values 
    // don't need to be stored).
    if (newValue == 0) {
        // If the value already exists, erase it.
        auto valueIt{globalStoredValueMap.find(workStringID)};
        if (valueIt != globalStoredValueMap.end()) {
            globalStoredValueMap.erase(valueIt);
        }

        return;
    }

    globalStoredValueMap[workStringID] = newValue;
}

Uint32 World::getStoredValue(std::string_view stringID)
{
    // Derive string ID in case the user accidentally passed a display name.
    StringTools::deriveStringID(stringID, workStringID);

    // If the value exists, return it.
    auto valueIt{globalStoredValueMap.find(workStringID)};
    if (valueIt != globalStoredValueMap.end()) {
        return valueIt->second;
    }

    // Value doesn't exist. Return the default.
    return 0;
}

Position World::getSpawnPoint()
{
    switch (Config::SPAWN_STRATEGY) {
        case SpawnStrategy::Fixed: {
            return {Config::SPAWN_POINT_FIXED_X, Config::SPAWN_POINT_FIXED_Y,
                    0.1f};
        }
        case SpawnStrategy::Random: {
            return {xDistribution(generator), yDistribution(generator), 0.1f};
        }
        case SpawnStrategy::Grouped: {
            return getGroupedSpawnPoint();
        }
        default: {
            LOG_FATAL("Invalid spawn strategy.");
            return {};
        }
    }
}

Position World::getGroupedSpawnPoint()
{
    static constexpr float TILE_WIDTH{SharedConfig::TILE_WORLD_WIDTH};

    // Calculate the next spawn point.
    Position spawnPoint{groupX, groupY, 0.1f};
    spawnPoint.x += (columnIndex * Config::SPAWN_POINT_GROUP_PADDING_X);
    spawnPoint.y += (rowIndex * Config::SPAWN_POINT_GROUP_PADDING_Y);

    // Increment our column. If it wrapped, increment our row.
    columnIndex = ((columnIndex + 1) % Config::SPAWN_POINT_GROUP_COLUMNS);
    unsigned int previousRow{rowIndex};
    if (columnIndex == 0) {
        rowIndex = ((rowIndex + 1) % Config::SPAWN_POINT_GROUP_ROWS);
    }

    // If the row wrapped, increment our group position.
    if (previousRow > rowIndex) {
        // The width of a full group of entities. We add one extra padding to 
        // make sure they don't clip the Eastern edge of the map.
        const float GROUP_WIDTH{Config::SPAWN_POINT_GROUP_PADDING_X
                                    * Config::SPAWN_POINT_GROUP_COLUMNS
                                + Config::SPAWN_POINT_GROUP_PADDING_X};

        // Increment the group X offset.
        groupX += Config::SPAWN_POINT_GROUP_OFFSET_X;

        // If the new group would go off the East edge of the map, reset the 
        // X offset and increment the Y offset.
        TileExtent tileMapExtent{tileMap.getTileExtent()};
        float tileMapMaxX{tileMapExtent.xMax() * TILE_WIDTH};
        if ((groupX + GROUP_WIDTH) > tileMapMaxX) {
            groupX = tileMapExtent.x * TILE_WIDTH
                     + Config::SPAWN_POINT_GROUP_PADDING_X;
            groupY += Config::SPAWN_POINT_GROUP_OFFSET_Y;
        }

        columnIndex = 0;
        rowIndex = 0;
    }

    return spawnPoint;
}

void World::onEntityDestroyed(entt::entity entity)
{
    // Note: Only ClientConnectionSystem should be destroying client entities, 
    //       so we don't handle netIDMap cleanup here.

    // Remove it from the locators.
    // Note: Client entities could easily be removed where we delete them, but 
    //       NCEs may be deleted at any point by project code, so we handle it
    //       here to avoid bugs. 
    entityLocator.removeEntity(entity);
    collisionLocator.removeEntity(entity);

    // If the entity is in the database, delete it (does nothing if it isn't).
    // Note: This is to delete non-client entities, since they get persisted.
    database->deleteEntityData(entity);
}

void World::loadNonClientEntities()
{
    std::vector<EnginePersistedComponent> engineComponents{};
    std::vector<ProjectPersistedComponent> projectComponents{};
    auto loadEntity = [&](entt::entity entity,
                          std::span<const Uint8> serializedEngineComponents,
                          std::span<const Uint8> serializedProjectComponents) {
        engineComponents.clear();
        projectComponents.clear();

        // Deserialize the entity's component data.
        Deserialize::fromBuffer(serializedEngineComponents.data(),
                                serializedEngineComponents.size(),
                                engineComponents);
        Deserialize::fromBuffer(serializedProjectComponents.data(),
                                serializedProjectComponents.size(),
                                projectComponents);

        // Find the Position component.
        // Note: We do this separately because we know every entity has a 
        //       Position, and we need it for createEntity() (and we want to 
        //       use createEntity() to centralize logic and avoid bugs).
        const Position* position{nullptr};
        for (const EnginePersistedComponent& componentVariant :
             engineComponents) {
            if (const Position*
                tempPosition{std::get_if<Position>(&componentVariant)}) {
                position = tempPosition;
                break;
            }
        }
        if (!position) {
            LOG_INFO("Tried to load entity with no Position. Skipping.");
            return;
        }

        // Add the entity to the registry.
        entt::entity newEntity{createEntity(*position, entity)};
        if (newEntity != entity) {
            LOG_FATAL("Created entity ID doesn't match saved entity ID. "
                      "Created: %u, saved: %u",
                      newEntity, entity);
        }

        // Load the entity's persisted components into the registry.
        // Engine components
        for (const EnginePersistedComponent& componentVariant :
             engineComponents) {
            std::visit(VariantTools::Overload(
                [&](const Position&) {
                    // Do nothing, we already added the position above.
                },
                [&](const Input&) {
                    // Note: We don't use the persisted Input state, but we 
                    //       persist it to flag that the entity is movement-
                    //       enabled.
                    addMovementComponents(newEntity);
                },
                [&](const Rotation& rotation) {
                    // Note: If movement or graphics components are added first,
                    //       this will be a replace.
                    registry.emplace_or_replace<Rotation>(newEntity, rotation);
                },
                [&](const CollisionBitSets& collisionBitSets) {
                    // Note: If graphics components are added first, this will
                    //       be a replace.
                    registry.emplace_or_replace<CollisionBitSets>(newEntity, 
                        collisionBitSets);
                },
                [&](const GraphicState& graphicState) {
                    // Note: We only persist GraphicState, but it implies 
                    //       the rest of the graphics components.
                    addGraphicsComponents(newEntity, graphicState);
                },
                [&](const auto& component) {
                    using T = std::decay_t<decltype(component)>;
                    registry.emplace<T>(newEntity, component);
                }),
                componentVariant);
        }

        // Project components
        for (const ProjectPersistedComponent& componentVariant :
             projectComponents) {
            std::visit(VariantTools::Overload(
                [&](const auto& component) {
                    using T = std::decay_t<decltype(component)>;
                    registry.emplace<T>(newEntity, component);
                }),
                componentVariant);
        }

        // Init any components with lazy-updated timers.
        initTimerComponents(newEntity);
    };

    database->iterateEntities(std::move(loadEntity));
}

void World::initTimerComponents(entt::entity entity)
{
    const SaveTimestamp* saveTimestamp{registry.try_get<SaveTimestamp>(entity)};
    if (!saveTimestamp) {
        LOG_ERROR("Entity was just loaded but has no SaveTimestamp.");
        return;
    }

    // Init CastCooldown, if present.
    if (CastCooldown* castCooldown{registry.try_get<CastCooldown>(entity)}) {
        castCooldown->initAfterLoad(saveTimestamp->lastSavedTick,
                                    simulation.getCurrentTick());
    }
}

void World::loadItems(ItemData& itemData)
{
    auto loadItem = [&](ItemID itemID, std::span<const Uint8> serializedItem,
                        ItemVersion version, std::string_view initScript) {
        // Initialize the item's non-script-provided fields.
        Item item{.numericID = itemID};
        Deserialize::fromBuffer(serializedItem.data(), serializedItem.size(),
                                item);

        // Add the item to ItemData.
        itemData.loadItem(item, version, initScript);
    };

    database->iterateItems(std::move(loadItem));
}

void World::loadStoredValues()
{
    // Load the entity stored value IDs.
    auto loadEntityMap = [&](std::span<const Uint8> serializedMap) {
        if (serializedMap.size() > 0) {
            Deserialize::fromBuffer(serializedMap.data(), serializedMap.size(),
                                    entityStoredValueIDMap);
        }
    };

    database->getEntityStoredValueIDMap(std::move(loadEntityMap));

    // Load the global stored values.
    auto loadGlobalMap = [&](std::span<const Uint8> serializedMap) {
        if (serializedMap.size() > 0) {
            Deserialize::fromBuffer(serializedMap.data(), serializedMap.size(),
                                    globalStoredValueMap);
        }
    };

    database->getGlobalStoredValueMap(std::move(loadGlobalMap));
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/AILogic.h`:

```h
#pragma once

#include "entt/fwd.hpp"

namespace AM
{
namespace Server
{
class World;

/**
 * Interface class for entity AI logic.
 */
class AILogic
{
public:
    // Note: We pass world and entity as parameters so that we don't have to 
    //       deal with a World& member during serialization.
    /**
     * Processes one iteration of AI logic.
     *
     * If the given entity doesn't possess any of the necessary components,
     * prints a warning and returns early.
     *
     * @param entity The entity that this AI is controlling.
     */
    virtual void tick(World& world, entt::entity entity) = 0;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/AISystem.h`:

```h
#pragma once

namespace AM
{
namespace Server
{
struct SimulationContext;
class World;

/**
 * Handles AI processing.
 */
class AISystem
{
public:
    AISystem(const SimulationContext& inSimContext);

    /**
     * Calls tick() on all AI components.
     */
    void processAITick();

private:
    /** Used to get AI components to process. */
    World& world;
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/CastHelper.h`:

```h
#pragma once

#include "CastInfo.h"
#include "CastFailureType.h"
#include "ItemInteractionType.h"
#include "EntityInteractionType.h"
#include "SpellType.h"
#include "NetworkID.h"
#include "entt/fwd.hpp"
#include <SDL_stdinc.h>
#include <unordered_map>
#include <functional>

namespace AM
{
class CastableData;
struct Castable;
struct Vector3;

namespace Server
{
class Simulation;
class World;
class ItemData;

/**
 * Helper class for casting Castables. Also owns the maps that contain the 
 * cast handler callbacks.
 *
 * Note: "Helper" isn't the greatest name for this, since it also is the 
 *       only way to register handler callbacks. "world.castHelper" seems 
 *       like a pretty communicative, friendly interface though.
 */
class CastHelper
{
public:
    CastHelper(Simulation& inSimulation, const ItemData& inItemData,
               const CastableData& inCastableData);

    // Note: There's a potential failure where an entity stops moving, but a 
    //       system tries to cast before MovementSystem has ran, causing the 
    //       cast to still fail. We had to solve this on the client because the
    //       UI casts were failing, but it doesn't seem very likely to occur 
    //       here (any system that casts should be post-movement).
    struct CastItemInteractionParams;
    /**
     * Casts an item interaction, using the given info.
     * 
     * @return None if the cast is successful, otherwise returns the reason for
     *         failure.
     */
    CastFailureType
        castItemInteraction(const CastItemInteractionParams& params);

    struct CastEntityInteractionParams;
    /**
     * Casts an entity interaction, using the given info.
     * 
     * @return None if the cast is successful, otherwise returns the reason for
     *         failure.
     */
    CastFailureType
        castEntityInteraction(const CastEntityInteractionParams& params);

    struct CastSpellParams;
    /**
     * Casts a spell, using the given info.
     * 
     * @return None if the cast is successful, otherwise returns the reason for
     *         failure.
     */
    CastFailureType castSpell(const CastSpellParams& params);

    // Note: These functions are just to provide a friendly interface. The 
    //       maps are public, so you could just add to them directly.
    /**
     * Registers a callback for when an item interaction of the given type is 
     * successfully cast.
     * Note: Only one callback can be set for each type.
     */
    void setOnItemInteractionCompleted(
        ItemInteractionType interactionType,
        std::function<void(const CastInfo&)> callback);

    /**
     * Registers a callback for when an entity interaction of the given type is 
     * successfully cast.
     * Note: Only one callback can be set for each type.
     */
    void setOnEntityInteractionCompleted(
        EntityInteractionType interactionType,
        std::function<void(const CastInfo&)> callback);

    /**
     * Registers a callback for when a spell of the given type is successfully 
     * cast.
     * Note: Only one callback can be set for each type.
     */
    void setOnSpellCompleted(
        SpellType spellType,
        std::function<void(const CastInfo&)> callback);

    /**
     * Returns true if the target entity is in LoS of the caster entity.
     *
     * Tries to use each entity's Collision. If it doesn't have one, falls back
     * to its Position.
     *
     * @pre casterEntity and targetEntity must exist, casterPosition and 
     *      targetPosition must be valid positions within the world.
     */
    bool isInLineOfSight(entt::entity casterEntity, entt::entity targetEntity,
                         const Vector3& casterPosition,
                         const Vector3& targetPosition);

    /**
     * Overload for position-based target types.
     *
     * @pre casterEntity must exist, casterPosition and targetPosition must be
     *      valid positions within the world.
     */
    bool isInLineOfSight(entt::entity casterEntity,
                         const Vector3& casterPosition,
                         const Vector3& targetPosition);

    // Maps that hold handler callbacks for each type of cast. Only CastSystem 
    // should call these handlers, but we just set them as public to avoid 
    // overcomplication.
    std::unordered_map<ItemInteractionType,
                       std::function<void(const CastInfo&)>>
        onItemInteractionCompletedMap;
    std::unordered_map<EntityInteractionType,
                       std::function<void(const CastInfo&)>>
        onEntityInteractionCompletedMap;
    std::unordered_map<SpellType,
                       std::function<void(const CastInfo&)>>
        onSpellCompletedMap;

private:
    /**
     * Performs generic validation that's applicable to all 3 types of 
     * Castable.
     *
     * @return None if validation passed, otherwise returns the cause of 
     *         failure.
     */
    CastFailureType performSharedChecks(const Castable& castable,
                                        entt::entity casterEntity,
                                        entt::entity targetEntity,
                                        const Vector3& targetPosition);

    /** Used to get the current tick. */
    Simulation& simulation;
    World& world;
    const ItemData& itemData;
    const CastableData& castableData;

public:
struct CastItemInteractionParams {
    /** The item interaction to cast. */
    ItemInteractionType interactionType{};
    /** The entity that is casting. */
    entt::entity casterEntity{};
    /** The slot of the item that is being used, within casterEntity's 
        inventory. */
    Uint8 slotIndex{};
    /** (Optional) The target entity. If the Castable's targetToolType is 
        Entity, this must be valid. */
    entt::entity targetEntity{entt::null};
    /** (Optional) The target position. If the Castable's targetToolType 
        is Circle, this must be valid. */
    Vector3 targetPosition{std::numeric_limits<float>::max(),
                           std::numeric_limits<float>::max(),
                           std::numeric_limits<float>::max()};
    /** (Optional) The client that requested this cast. If casterEntity is a 
        client entity, you must fill this in. Otherwise it won't be replicated 
        properly. */
    NetworkID clientID{NULL_NETWORK_ID};
};

struct CastEntityInteractionParams {
    /** The entity interaction to cast. */
    EntityInteractionType interactionType{};
    /** The entity that is casting. */
    entt::entity casterEntity{entt::null};
    /** The target entity. */
    entt::entity targetEntity{entt::null};
    /** (Optional) The target position. If the Castable's targetToolType 
        is Circle, this must be valid. */
    Vector3 targetPosition{std::numeric_limits<float>::max(),
                           std::numeric_limits<float>::max(),
                           std::numeric_limits<float>::max()};
    /** (Optional) The client that requested this cast. If casterEntity is a 
        client entity, you must fill this in. Otherwise it won't be replicated 
        properly. */
    NetworkID clientID{NULL_NETWORK_ID};
};

struct CastSpellParams {
    /** The item interaction to cast. */
    SpellType interactionType{};
    /** The entity that is casting. */
    entt::entity casterEntity{entt::null};
    /** (Optional) The target entity. If the Castable's targetToolType is 
        Entity, this must be valid. */
    entt::entity targetEntity{entt::null};
    /** (Optional) The target position. If the Castable's targetToolType 
        is Circle, this must be valid. */
    Vector3 targetPosition{std::numeric_limits<float>::max(),
                           std::numeric_limits<float>::max(),
                           std::numeric_limits<float>::max()};
    /** (Optional) The client that requested this cast. If casterEntity is a 
        client entity, you must fill this in. Otherwise it won't be replicated 
        properly. */
    NetworkID clientID{NULL_NETWORK_ID};
};
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/CastSystem.h`:

```h
#pragma once

#include "CastRequest.h"
#include "CastInfo.h"
#include "CastFailureType.h"
#include "EntityInteractionType.h"
#include "ItemInteractionType.h"
#include "SpellType.h"
#include "Vector3.h"
#include "EnttObserver.h"
#include "QueuedEvents.h"
#include "EventSorter.h"
#include "entt/fwd.hpp"
#include <unordered_map>
#include <functional>

namespace AM
{
class CastableData;
struct Castable;

namespace Server
{
struct SimulationContext;
class ItemData;
class Simulation;
class World;
class Network;
struct CastState;

/**
 * Handles cast requests and all processing of ongoing casts.
 */
class CastSystem
{
public:
    CastSystem(const SimulationContext& inSimContext);

    /**
     * Sends initial cast cooldown state to newly-logged-on clients.
     */
    void sendCastCooldownInits();

    /**
     * Processes cast requests, updates ongoing casts, cancels casts as 
     * necessary, and passes completed casts to registered handlers.
     */
    void processCasts();

private:
    /**
     * Processes all waiting cast request messages.
     */
    void processCastRequests();

    /**
     * Processes the given cast request.
     */
    void processCastRequest(const CastRequest& castRequest);

    /**
     * Updates any ongoing casts, canceling or completing them as necessary.
     */
    void updateCasts();

    /**
     * Sends a CastStarted message and sets any entity state related to the 
     * cast being started.
     */
    void startCast(CastState& castState);

    /**
     * Cancels the current cast, resetting cooldowns and sending error messages 
     * appropriately.
     */
    void cancelCast(CastState& castState);

    /**
     * Finishes the given cast.
     */
    void finishCast(CastState& castState);

    /**
     * Sends a CastStarted message to all nearby clients.
     */
    void sendCastStarted(CastState& castState);

    /**
     * Sends a CastFailed message to all nearby clients.
     */
    void sendCastFailed(CastState& castState, CastFailureType failureType);

    /**
     * Passes the given cast to the associated callback, if one is registered.
     */
    void handleCast(const CastInfo& castInfo);

    /**
     * Returns true if the caster is in range and in LoS of the target.
     *
     * Note: CastHelper validates casts before they start, so we only use this 
     *       before finishing a cast.
     */
    bool castIsValid(const CastInfo& castInfo, const Vector3& casterPosition);

    /** Used to get the current tick. */
    Simulation& simulation;
    /** Used to access entity data and castHelper. */
    World& world;
    /** Used to send CastFailed and CastStarted messages. */
    Network& network;
    const ItemData& itemData;
    const CastableData& castableData;

    /** Observes player CastCooldown component creation so we can send the 
        initial cast cooldown state to a newly-logged-on player. */
    EnttObserver playerCastCooldownObserver;

    EventQueue<CastRequest> castRequestQueue;
    EventSorter<CastRequest> castRequestSorter;
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/ChunkStreamingSystem.h`:

```h
#pragma once

#include "NetworkDefs.h"
#include "QueuedEvents.h"
#include "ChunkDataRequest.h"
#include "ChunkPosition.h"

namespace AM
{
struct ChunkUpdate;
class Tile;
struct TileSnapshot;
struct ChunkWireSnapshot;

namespace Server
{
struct SimulationContext;
class World;
class Network;

/**
 * Handles streaming chunk data to clients.
 *
 * A client may require chunks to be sent when it logs in, moves into a new
 * chunk, or teleports.
 *
 * Note: We have no validation to see if client entities are in range of the
 *       requested chunks. Maybe add that once we get a permissions system.
 */
class ChunkStreamingSystem
{
public:
    ChunkStreamingSystem(const SimulationContext& inSimContext);

    /**
     * Processes chunk update requests, sending chunk data if the request is
     * valid.
     */
    void sendChunks();

private:
    /**
     * Send a chunk update, containing the chunks from the given request.
     */
    void sendChunkUpdate(const ChunkDataRequest& chunkDataRequest);

    /**
     * Adds the given chunk to the given ChunkUpdate message.
     *
     * @param chunkPosition  The position of the chunk to add.
     * @param chunkUpdate  The message struct to add the chunk to.
     */
    void addChunkToMessage(const ChunkPosition& chunkPosition,
                           ChunkUpdate& chunkUpdate);

    /** Used for fetching entity, component, and map data. */
    World& world;
    /** Used for receiving chunk requests and sending chunks to clients. */
    Network& network;

    EventQueue<ChunkDataRequest> chunkDataRequestQueue;
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/ClientAOISystem.h`:

```h
#pragma once

#include "BinaryBuffer.h"
#include "entt/fwd.hpp"
#include <vector>

namespace AM
{
namespace Server
{
struct SimulationContext;
class Simulation;
class World;
class Network;
struct ClientSimData;

/**
 * Maintains each client entity's list of peers that are within their area of
 * interest.
 *
 * When a peer enters a client entity's AOI, this system will update the lists
 * appropriately and send an EntityInit message to the client.
 *
 * When a peer leaves a client entity's AOI, this system will update the lists
 * appropriately and send an EntityDelete message to the client.
 *
 * Note: The AOI lists also must be updated when an entity disconnects. Since
 *       it's easiest to do this while the entity is still alive, and
 *       ClientConnectionSystem maintains the lifetime of client entities, it's
 *       handled there.
 * Note: We split "init" logic (handled here) from "update" logic (handled in
 *       other systems). This is because updates sometimes require more context,
 *       e.g. movement updates are triggered when an Input is updated, but must
 *       send Input and Position components.
 *       Also, inits are built by testing each client's AOI, whereas updates are
 *       built by testing the updated entity's AOI.
 */
class ClientAOISystem
{
public:
    ClientAOISystem(const SimulationContext& inSimContext);

    /**
     * Updates the peersInAOI list in any client entities that have recently
     * moved.
     *
     * If entities have entered/left a list, updates peer lists and sends
     * messages appropriately.
     */
    void updateAOILists();

private:
    /**
     * Sends an EntityDelete message to the given client for each entity that
     * left its AOI.
     */
    void processEntitiesThatLeft(ClientSimData& client);

    /**
     * Sends an EntityInit message to the given client for each entity that
     * entered its AOI.
     */
    void processEntitiesThatEntered(ClientSimData& client);

    /** Used to get the current tick number. */
    Simulation& simulation;
    /** Used to access components. */
    World& world;
    /** Used for sending messages. */
    Network& network;

    /** Holds entities that left the AOI. Used during updateAOILists(). */
    std::vector<entt::entity> entitiesThatLeft;

    /** Holds entities that entered the AOI. Used during updateAOILists(). */
    std::vector<entt::entity> entitiesThatEntered;
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/ClientConnectionSystem.h`:

```h
#pragma once

#include "NetworkDefs.h"
#include "ClientConnectionEvent.h"
#include "QueuedEvents.h"
#include "entt/fwd.hpp"

namespace AM
{
namespace Server
{
struct SimulationContext;
class Simulation;
class World;
class Network;
class GraphicData;

/**
 * This system is in charge of processing client connect/disconnect events and
 * updating the client's entity.
 */
class ClientConnectionSystem
{
public:
    ClientConnectionSystem(const SimulationContext& inSimContext);

    /**
     * Processes new connections and disconnections, updating the sim state
     * appropriately.
     */
    void processConnectionEvents();

private:
    /**
     * Processes all newly connected clients, adding them to the sim.
     */
    void processConnectEvent(const ClientConnected& clientConnected);

    /**
     * Processes all newly disconnected clients, removing them from the sim.
     */
    void processDisconnectEvent(const ClientDisconnected& clientDisconnected);

    /**
     * Sends a connection response to the client with the given networkID.
     *
     * @param networkID  The client's network ID to send the connection response
     *                   to.
     * @param newEntity  The entity that was created for this client.
     */
    void sendConnectionResponse(NetworkID networkID, entt::entity newEntity);

    /** Used to get the current tick. */
    Simulation& simulation;
    /** Used to access components. */
    World& world;
    /** Used to send connection responses and receive connection events. */
    Network& network;

    /** Used for getting the default graphic's data when constructing client
        entities. */
    GraphicData& graphicData;

    EventQueue<ClientConnectionEvent> clientConnectionEventQueue;
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/ComponentChangeSystem.h`:

```h
#pragma once

#include "EntityNameChangeRequest.h"
#include "GraphicStateChangeRequest.h"
#include "QueuedEvents.h"

namespace AM
{
namespace Server
{
struct SimulationContext;
class World;
class Network;
class GraphicData;
class ISimulationExtension;

/**
 * Handles change requests for any random engine components that aren't already
 * handled by another system.
 */
class ComponentChangeSystem
{
public:
    ComponentChangeSystem(const SimulationContext& inSimContext);

    /**
     * Processes any waiting component change request messages.
     */
    void processChangeRequests();

    void setExtension(ISimulationExtension* inExtension);

private:
    /**
     * Updates the entity's collision (since collision is based on graphic set).
     */
    void onGraphicStateUpdated(entt::registry& registry, entt::entity entity);

    /**
     * Updates the entity's collision in CollisionLocator.
     */
    void onCollisionBitSetsUpdated(entt::registry& registry,
                                   entt::entity entity);

    /** Used for fetching component data. */
    World& world;
    /** Used for receiving updates from clients. */
    Network& network;
    /** Used to update Collision components when GraphicState is updated. */
    GraphicData& graphicData;
    /** If non-nullptr, contains the project's simulation extension functions.
        Used for checking if component change requests are valid. */
    ISimulationExtension* extension;

    EventQueue<EntityNameChangeRequest> entityNameChangeRequestQueue;
    EventQueue<GraphicStateChangeRequest> graphicStateChangeRequestQueue;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/ComponentSyncSystem.h`:

```h
#pragma once

#include "ReplicatedComponent.h"
#include "ComponentUpdate.h"
#include "entt/fwd.hpp"
#include "entt/entity/registry.hpp"
#include <unordered_map>

namespace AM
{
namespace Server
{
struct SimulationContext;
class Simulation;
class World;
class Network;
class GraphicData;

/**
 * Observes component updates based on the ObservedComponentTypes lists in
 * EngineObservedComponentTypes.h and ProjectObservedComponentTypes.h.
 *
 * When an observed component is updated, sends an update message to all nearby
 * clients.
 */
class ComponentSyncSystem
{
public:
    ComponentSyncSystem(const SimulationContext& inSimContext);

    /**
     * Sends updates for any observed components that were modified.
     */
    void sendUpdates();

private:
    /** Used to get the current tick. */
    Simulation& simulation;
    /** Used for fetching component data. */
    World& world;
    /** Used for sending updates to clients. */
    Network& network;
    /** Used to update Collision components when GraphicState is updated. */
    GraphicData& graphicData;

    // Note: Check the top of the cpp file for file-local types and variables.
    //       We keep some templated code there to reduce compile times.

    // Note: To optimize, we could store indices into a vector<ComponentUpdate>.
    //       Then we could re-use the vectors instead of re-allocating.
    /** Maps entityID -> a ComponentUpdate message containing that entity's
       data. We iterate the observers to detect changes, so this map lets us
        iteratively build the update messages component-by-component. */
    std::unordered_map<entt::entity, ComponentUpdate> componentUpdateMap;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Components/CastState.h`:

```h
#pragma once

#include "CastableID.h"
#include "CastInfo.h"
#include <SDL_stdinc.h>

namespace AM
{
namespace Server
{

/**
 * Tracks whether an entity is currently casting a Castable.
 * 
 * To optimize performance, this component will only be present on an entity if 
 * a cast is currently ongoing. It gets removed when the cast ends.
 *
 * Note: This is server-only because the client needs its own version to track 
 *       additional data.
 */
struct CastState {
    /** The current cast's info. */
    CastInfo castInfo{};

    /** The tick that this cast will finish on. If 0, this cast hasn't been 
        processed for the first time yet. */
    Uint32 endTick{};
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Components/ClientSimData.h`:

```h
#pragma once

#include "NetworkDefs.h"
#include "entt/fwd.hpp"
#include <vector>

namespace AM
{
namespace Server
{
/**
 * Holds all client-related sim data.
 *
 * If you need to tell if an entity is a client entity or not, favor checking
 * for IsClientEntity over this. IsClientEntity gets replicated to the clients,
 * so it's more expected to see.
 */
struct ClientSimData {
    /** The network ID associated with this client.
        We track this here so the sim knows where to send messages related to
        the entity.
        We also use this to remove the entity from the sim when the Client
        disconnects.*/
    NetworkID netID{0};

    /** Tracks the entities that are in range of this client's entity. */
    std::vector<entt::entity> entitiesInAOI{};
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Components/Dialogue.h`:

```h
#pragma once

#include "bitsery/ext/std_map.h"
#include <string>
#include <unordered_map>
#include <vector>

namespace AM
{
namespace Server
{
/**
 * Holds the list of topics that make up an entity's dialogue tree.
 *
 * Instead of an actual tree structure, we use a stateless look-up table.
 * When a client requests to begin a dialogue with an entity, the server sends 
 * them the first topic in that entity's topics vector. The client can then 
 * request that a choice be selected, which may result in a new topic being sent.
 */
struct Dialogue {
    /** Used as a "we should never hit this" cap on the container lengths. */
    static constexpr std::size_t MAX_CHOICE_CONDITION_SCRIPT_LENGTH{500};
    static constexpr std::size_t MAX_CHOICE_DISPLAY_TEXT_LENGTH{200};
    static constexpr std::size_t MAX_CHOICE_ACTION_SCRIPT_LENGTH{1000};
    static constexpr std::size_t MAX_TOPIC_SCRIPT_LENGTH{1500};
    static constexpr std::size_t MAX_CHOICES{50};
    static constexpr std::size_t MAX_TOPICS{100};
    static constexpr std::size_t MAX_TOPIC_NAME_LENGTH{100};

    /**
     * A choice that the player can make.
     */
    struct Choice {
        /** If non-empty, contains a condition script that must be ran against 
            the player entity to check if they may access this choice.
            Condition scripts will have "r =" prepended to them before running, 
            and must evaluate to a boolean value. */
        std::string conditionScript{};

        /** The text that will be displayed for this choice. */
        std::string displayText{};

        /** The script to run if this choice is successfully selected. */
        std::string actionScript{};
    };

    /**
     * A dialogue topic.
     */
    struct Topic {
        /** This topic's name. */
        std::string name{};

        /** The script to run when this topic is entered. */
        std::string topicScript{};

        /** The choices that will be displayed for the player to select.
            Choices are added to this vector based on their order in the choice
            script. */
        std::vector<Choice> choices{};
    };

    /** A map of topic names -> their index in the topics vector. */
    std::unordered_map<std::string, Uint8> topicIndices{};

    /** The available dialogue topics.
        Topics are added to this vector based on their order in the entity's 
        init script. The first topic will be the one sent in response to the 
        Talk interaction. The rest are only reachable using setNextTopic().
        Note: There should always be at least 1 topic present, since we only 
              construct the Dialogue component when we have a topic to add, and 
              you can't remove topics. */
    std::vector<Topic> topics{};
};

template<typename S>
void serialize(S& serializer, Dialogue::Choice& choice)
{
    serializer.text1b(choice.conditionScript,
                      Dialogue::MAX_CHOICE_CONDITION_SCRIPT_LENGTH);
    serializer.text1b(choice.displayText,
                      Dialogue::MAX_CHOICE_DISPLAY_TEXT_LENGTH);
    serializer.text1b(choice.actionScript,
                      Dialogue::MAX_CHOICE_ACTION_SCRIPT_LENGTH);
}

template<typename S>
void serialize(S& serializer, Dialogue::Topic& topic)
{
    serializer.text1b(topic.topicScript, Dialogue::MAX_TOPIC_SCRIPT_LENGTH);
    serializer.container(topic.choices, Dialogue::MAX_CHOICES);
}

template<typename S>
void serialize(S& serializer, Dialogue& dialogue)
{
    serializer.ext(dialogue.topicIndices,
                   bitsery::ext::StdMap{Dialogue::MAX_TOPICS},
                   [](S& serializer, std::string& name, Uint8& index) {
                       serializer.text1b(name, Dialogue::MAX_TOPIC_NAME_LENGTH);
                       serializer.value1b(index);
                   });
    serializer.container(dialogue.topics, Dialogue::MAX_TOPICS);
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Components/ItemHandler.h`:

```h
#pragma once

#include "ItemID.h"
#include "EntityItemHandlerScript.h"
#include <vector>
#include <string_view>

namespace AM
{
namespace Server
{
/**
 * An entity's handling logic for when an item is used on it.
 *
 * A single handler script is used for all items. Within it, you can check for 
 * specific item IDs to handle them individually, or check for the presence of 
 * specific item properties to handle them as groups.
 *
 * There's no default handler. You must add a handler in order for anything to 
 * happen when an item is used on this entity.
 */
struct ItemHandler {
    /** The handler script to run. */
    EntityItemHandlerScript handlerScript{};
};

template<typename S>
void serialize(S& serializer, ItemHandler& itemHandler)
{
    serializer.object(itemHandler.handlerScript);
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Components/ReplicatedComponentList.h`:

```h
#pragma once

#include <SDL_stdinc.h>
#include <vector>

namespace AM
{
namespace Server
{
/**
 * Tracks which client-relevant components this entity currently has attached
 * to it.
 *
 * Client-relevant components are any that we need to replicate to the client,
 * e.g. Position. If the client doesn't care about it, it won't be tracked here.
 *
 * Note: This component will be present on an entity regardless of whether it
 *       has any replicated components or not. This is because the on_destroy()
 *       listener isn't allowed to remove components, so we just always leave
 *       it.
 */
struct ReplicatedComponentList {
    /** Holds all currently attached component types that are relevant to
        the client.
        Each element refers to an index in the ReplicatedComponent variant. */
    std::vector<Uint8> typeIndices;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Components/SaveTimestamp.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{
namespace Server
{

/**
 * Tracks the tick number when this entity was last saved.
 *
 * An example of usage is our CastCooldown component. It lazily updates its 
 * timestamps, so if it gets saved on e.g. tick 500, it may have last been 
 * updated on tick 450. When we load the component, we need to update it to 
 * account for those 50 elapsed ticks. We can do that by using this timestamp.
 */
struct SaveTimestamp {
    /** The tick that this entity was last saved on. */
    Uint32 lastSavedTick{};
};

template<typename S>
void serialize(S& serializer, SaveTimestamp& saveTimestamp)
{
    serializer.value4b(saveTimestamp.lastSavedTick);
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Components/StoredValues.h`:

```h
#pragma once

#include "EntityStoredValueID.h"
#include "bitsery/ext/std_map.h"
#include <unordered_map>
#include <string_view>

namespace AM
{
namespace Server
{
class World;

/**
 * A per-entity key-value store.
 * 
 * Values are identified in scripts using their string ID (see World::
 * storedValueIDMap). We map string ID -> numeric ID for storage, to save 
 * space and avoid allocations.
 * 
 * Global values are also supported (see World::globalStoredValueMap).
 */
struct StoredValues {
    /** Used as a "we should never hit this" cap on the number of values that 
        component can hold. */
    static constexpr std::size_t MAX_STORED_VALUES{SDL_MAX_UINT16};

    /**
     * Holds the entity's stored values.
     *
     * Maps numeric ID -> value.
     */
    std::unordered_map<EntityStoredValueID, Uint32> valueMap{};

    /**
     * Adds a new value, or overwrites an existing value.
     *
     * If newValue == 0 (the default value), the value will be deleted.
     *
     * Note: Stored values are often cast to different types, but their 
     *       underlying type is always Uint32.
     *
     * @param stringID The string ID of the value to add or overwrite.
     * @param newValue The new value to use.
     * @return True if the value was successfully set, else false (value with 
     *         the given ID doesn't exist and value limit is reached).
     */
    bool storeValue(std::string_view stringID, Uint32 newValue, World& world);

    /**
     * Gets a stored value.
     *
     * Note: Stored values are often cast to different types, but their 
     *       underlying type is always Uint32.
     * 
     * @param stringID The string ID of the value to get.
     * @return The requested value. If not found, returns 0 (the default value 
     *         that the value would have if it existed).
     */
    Uint32 getStoredValue(std::string_view stringID, World& world);
};

template<typename S>
void serialize(S& serializer, StoredValues& storedValues)
{
    serializer.ext(
        storedValues.valueMap,
        bitsery::ext::StdMap{StoredValues::MAX_STORED_VALUES},
        [](S& serializer, EntityStoredValueID& numericID, Uint32& value) {
            serializer.value2b(numericID);
            serializer.value4b(value);
        });
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Database.h`:

```h
#pragma once

#include "ItemID.h"
#include "IconID.h"
#include "SQLiteCpp/SQLiteCpp.h"
#include "entt/fwd.hpp"
#include <SDL_stdinc.h>
#include <optional>
#include <memory>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <span>
#include <string_view>

namespace AM
{
namespace Server
{
class World;

/**
 * Interface for interacting with the database.
 * 
 * We use the database to persist item definitions, non-client entity data, 
 * and tile map data as blobs.
 *
 * To avoid blocking the main loop, we first copy all of our data into an 
 * in-memory database. Then, we use a separate thread to backup the in-memory 
 * database to a file. See SaveSystem.h for more info.
 *
 * Note: Client entity data is persisted in the account database, not here.
 */
class Database
{
public:
    Database();

    ~Database();

    /**
     * Begins a transaction. While a transaction is ongoing, queries will be 
     * queued until commitTransaction() is called.
     */
    void startTransaction();

    /**
     * If a transaction is ongoing, commits it. This will execute all queued 
     * queries.
     */
    void commitTransaction();

    /**
     * Backs up our in-memory database to the file database.
     */
    void backupToFile();

    /**
     * @return true if a backup is currently being performed, else false.
     */
    bool backupIsInProgress();

    //-------------------------------------------------------------------------
    // Entities
    //-------------------------------------------------------------------------
    /**
     * Adds or overwrites an entity table entry.
     *
     * @param entity The entity entry to update.
     * @param serializedEngineComponents A serialized
     * std::vector<EnginePersistedComponent>.
     * @param serializedrojectComponents A serialized 
     * std::vector<ProjectPersistedComponent>.
     */
    void saveEntityData(entt::entity entity,
                        std::span<const Uint8> serializedEngineComponents,
                        std::span<const Uint8> serializedProjectComponents);

    /**
     * Attempts to delete an entity table entry for the given entity.
     *
     * If the entity is not found in the database, does nothing.
     */
    void deleteEntityData(entt::entity entity);

    /**
     * Calls the given callback on each entity data entry.
     *
     * @param callback A callback of form void(entt::entity, 
     *                 std::span<const Uint8>, std::span<const Uint8>) that 
     *                 expects the entity's ID, a serialized 
     *                 std::vector<EnginePersistedComponent>, and a serialized 
     *                 std::vector<ProjectPersistedComponent>.
     */
    template<typename Func>
    void iterateEntities(Func callback)
    {
        while (iterateEntitiesQuery->executeStep()) {
            SQLite::Column idColumn{iterateEntitiesQuery->getColumn(0)};
            SQLite::Column engineComponentsColumn{
                iterateEntitiesQuery->getColumn(1)};
            SQLite::Column projectComponentsColumn{
                iterateEntitiesQuery->getColumn(2)};
            callback(
                static_cast<entt::entity>(idColumn.getInt()),
                std::span<const Uint8>{
                    static_cast<const Uint8*>(engineComponentsColumn.getBlob()),
                    static_cast<std::size_t>(
                        engineComponentsColumn.getBytes())},
                std::span<const Uint8>{
                    static_cast<const Uint8*>(
                        projectComponentsColumn.getBlob()),
                    static_cast<std::size_t>(
                        projectComponentsColumn.getBytes())});
        }
        iterateEntitiesQuery->reset();
    }

    //-------------------------------------------------------------------------
    // Items
    //-------------------------------------------------------------------------
    /**
     * Adds or overwrites an item table entry.
     *
     * @param itemID The item entry to update.
     */
    void saveItemData(ItemID itemID, std::span<const Uint8> serializedItem,
                      ItemVersion version, std::string_view initScript);

    /**
     * Attempts to delete an item table entry for the given item.
     *
     * If the item is not found in the database, does nothing.
     */
    void deleteItemData(ItemID itemID);

    /**
     * Calls the given callback on each item data entry.
     *
     * @param callback A callback of form void(ItemID, std::span<const Uint8>, 
     *                 ItemVersion, std::string_view) that expects the item's ID,
     *                 a serialized Item struct, and the item's version and init 
     *                 script.
     */
    template<typename Func>
    void iterateItems(Func callback)
    {
        while (iterateItemsQuery->executeStep()) {
            SQLite::Column idColumn{iterateItemsQuery->getColumn(0)};
            SQLite::Column itemColumn{iterateItemsQuery->getColumn(1)};
            SQLite::Column versionColumn{iterateItemsQuery->getColumn(2)};
            SQLite::Column initScriptColumn{iterateItemsQuery->getColumn(3)};
            callback(static_cast<ItemID>(idColumn.getInt()),
                     std::span<const Uint8>{
                         static_cast<const Uint8*>(itemColumn.getBlob()),
                         static_cast<std::size_t>(itemColumn.getBytes())},
                     static_cast<ItemVersion>(versionColumn.getInt()),
                     std::string_view{initScriptColumn.getText(),
                                      static_cast<std::size_t>(
                                          initScriptColumn.getBytes())});
        }
        iterateItemsQuery->reset();
    }

    //-------------------------------------------------------------------------
    // Stored Values
    //-------------------------------------------------------------------------
    /**
     * Adds or overwrites the entity stored value ID map entry.
     *
     * @param serializedMap A serialized World::entityStoredValueIDMap.
     */
    void saveEntityStoredValueIDMap(std::span<const Uint8> serializedMap);

    /**
     * Calls the given callback on the entity stored value ID map data entry.
     *
     * @param callback A callback of form void(std::span<const Uint8>) that 
     *                 expects a serialized EntityStoredValueIDMap.
     */
    template<typename Func>
    void getEntityStoredValueIDMap(Func callback)
    {
        getEntityStoredValueIDMapQuery->executeStep();
        SQLite::Column mapColumn{getEntityStoredValueIDMapQuery->getColumn(0)};
        callback(std::span<const Uint8>{
            static_cast<const Uint8*>(mapColumn.getBlob()),
            static_cast<std::size_t>(mapColumn.getBytes())});

        getEntityStoredValueIDMapQuery->reset();
    }

    /**
     * Adds or overwrites the global stored value map entry.
     *
     * @param serializedMap A serialized World::globalStoredValueMap.
     */
    void saveGlobalStoredValueMap(std::span<const Uint8> serializedMap);

    /**
     * Calls the given callback on the global stored value map data entry.
     *
     * @param callback A callback of form void(std::span<const Uint8>) that 
     *                 expects a serialized GlobalStoredValueMap.
     */
    template<typename Func>
    void getGlobalStoredValueMap(Func callback)
    {
        getGlobalStoredValueMapQuery->executeStep();
        SQLite::Column mapColumn{getGlobalStoredValueMapQuery->getColumn(0)};
        callback(std::span<const Uint8>{
            static_cast<const Uint8*>(mapColumn.getBlob()),
            static_cast<std::size_t>(mapColumn.getBytes())});

        getGlobalStoredValueMapQuery->reset();
    }

protected:
    /**
     * Creates our tables in Database.db3, if they don't already exist.
     */
    void initTables();

    /**
     * Compares each version number from the database to the current version 
     * numbers in code. If the data version doesn't match the code version, 
     * prints an appropriate error and exits.
     */
    void checkDataVersions();

    /**
     * Thread function.
     * Waits for backupToFile() to flag that a backup should begin.
     * 
     * Backs up the in-memory database to the file database.
     */
    void performBackup();

    /** In-memory database. Used to gather our data so we can safely work 
        with it in another thread. */
    SQLite::Database database;

    /** File-backed database. Used to persist our data to a file. */
    SQLite::Database backupDatabase;

    /** If valid, this is the current ongoing transaction. */
    std::optional<SQLite::Transaction> currentTransaction;

    /** Calls performBackup(). */
    std::thread backupThreadObj;
    /** Turn false to signal that the send and receive threads should end. */
    std::atomic<bool> exitRequested;

    /** Used for signaling the backup thread. */
    std::mutex backupMutex;
    std::condition_variable_any backupCondVar;
    // Note: This doesn't need to be atomic to work with the condition variable,
    //       but it needs to be atomic to return it from backupIsInProgress().
    std::atomic<bool> backupRequested;

    // Pre-built queries
    std::unique_ptr<SQLite::Statement> insertEntityQuery;
    std::unique_ptr<SQLite::Statement> deleteEntityQuery;
    std::unique_ptr<SQLite::Statement> iterateEntitiesQuery;
    std::unique_ptr<SQLite::Statement> insertItemQuery;
    std::unique_ptr<SQLite::Statement> deleteItemQuery;
    std::unique_ptr<SQLite::Statement> iterateItemsQuery;
    std::unique_ptr<SQLite::Statement> insertEntityStoredValueIDMapQuery;
    std::unique_ptr<SQLite::Statement> getEntityStoredValueIDMapQuery;
    std::unique_ptr<SQLite::Statement> insertGlobalStoredValueMapQuery;
    std::unique_ptr<SQLite::Statement> getGlobalStoredValueMapQuery;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/DialogueSystem.h`:

```h
#pragma once

#include "DialogueChoiceRequest.h"
#include "Dialogue.h"
#include "QueuedEvents.h"

namespace AM
{
struct DialogueResponse;
struct CastInfo;

namespace Server
{
struct SimulationContext;
class World;
class Network;
struct DialogueLua;
struct DialogueChoiceConditionLua;

/**
 * Handles entity dialogue data requests.
 * 
 * Dialogue is started when a player selects the Talk interaction on an entity.
 * We respond to the Talk interaction by sending the entity's first dialogue 
 * topic. From there, the dialogue may automatically run further topics, or 
 * the player may navigate to other topics by selecting an available choice.
 */
class DialogueSystem
{
public:
    DialogueSystem(const SimulationContext& inSimContext);

    /**
     * Processes Talk interactions and dialogue choice requests, sending 
     * dialogue data if the request is valid.
     *
     * Dialogue may also update sim state, e.g. when giving items to entities.
     */
    void processDialogueInteractions();

private:
    /** The maximum number of setNextTopic() calls that can be chained (e.g. a 
        choice action script has a call, which leads to a topic script with a 
        call, etc).
        We need to set a max, otherwise people could write infinite loops. */
    const std::size_t TOPIC_NAVIGATION_MAX{5};

    /**
     * Processes a Talk interaction, sending appropriate response messages.
     */
    void processTalkInteraction(const CastInfo& castInfo);

    /**
     * Pairs a topic with its index so we don't need re-look it up in the map.
     */
    struct TopicPair {
        const Dialogue::Topic* topic{nullptr};
        Uint8 topicIndex{0};
    };
    /**
     * Runs the given topic's topicScript.
     * @return If the script contained a valid setNextTopic(), returns the next 
     *         topic. Else, returns nullptr.
     */
    TopicPair runTopic(const Dialogue& dialogue, const Dialogue::Topic& topic,
                       NetworkID clientID);

    /**
     * Processes a dialogue choice request, sending appropriate response 
     * messages.
     */
    void processDialogueChoice(
        const DialogueChoiceRequest& choiceRequest);

    /**
     * Runs the given choice's actionScript.
     * @return If the script contained a valid setNextTopic(), returns the next
     *         topic. Else, returns nullptr.
     */
    TopicPair runChoice(const Dialogue& dialogue,
                        const Dialogue::Choice& choice,
                        std::string_view choiceTopicName, Uint8 choiceIndex,
                        NetworkID clientID);

    /**
     * Validates that the given request has valid data and that the choice's 
     * condition is satisfied by the client entity.
     *
     * @param clientEntity The entity associated with the request's netID.
     * @return If valid, returns the the target entity's Dialogue component. 
     *         Else, returns nullptr and sends an appropriate error message.
     */
    const Dialogue*
        validateChoiceRequest(const DialogueChoiceRequest& choiceRequest,
                              entt::entity clientEntity);

    /**
     * Runs the given choice's condition script.
     * @return true if the script ran successfully and evaluated to true, else 
     *         false. If the script evaluated to false and sendAccessErrorMessage
     *         == true, sends an appropriate error message.
     */
    bool runChoiceCondition(const Dialogue::Choice& choice,
                            entt::entity clientEntity,
                            entt::entity targetEntity, NetworkID clientID,
                            bool sendAccessErrorMessage);

    /**
     * Iterates the given choices, checking their conditions against clientEntity
     * and targetEntity and adding them to the given response if they pass.
     */
    void addChoicesToResponse(const std::vector<Dialogue::Choice>& choices,
                              entt::entity clientEntity,
                              entt::entity targetEntity, NetworkID clientID,
                              DialogueResponse& response);

    /** Used for validating requests and fetching dialogue data. */
    World& world;
    /** Used for receiving dialogue requests and sending dialogue to clients. */
    Network& network;
    /** Used to run topic and choice action scripts. */
    DialogueLua& dialogueLua;
    /** Used to run choice condition scripts. */
    DialogueChoiceConditionLua& dialogueChoiceConditionLua;

    /** A scratch buffer used while processing strings. */
    std::string workString;

    EventQueue<DialogueChoiceRequest> dialogueChoiceRequestQueue;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/EntityItemHandlerScript.h`:

```h
#pragma once

#include <string>

namespace AM
{
namespace Server
{
/**
 * An entity's script to run when a particular item is used on it.
 *
 * Handler scripts are written as part of an entity's init script, through the
 * addItemHandler() lua function.
 */
struct EntityItemHandlerScript {
    /** Used as a "we should never hit this" cap on the length of the script
        string. */
    static constexpr std::size_t MAX_LENGTH{10000};

    /** The item handler script. */
    std::string script{};
};

template<typename S>
void serialize(S& serializer, EntityItemHandlerScript& itemHandlerScript)
{
    serializer.text1b(itemHandlerScript.script,
                      EntityItemHandlerScript::MAX_LENGTH);
}

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/EntityStoredValueID.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/**
 * An entity stored value's numeric ID.
 * Note: Global stored values are handled separately. This file only applies 
 *       to values stored in an entity's StoredValues component.
 *
 * These IDs are created when a new string ID is first used, and are never 
 * deleted.
 * Note: If we ever care to reclaim these values, we can write a function 
 *       that iterates the StoredValues components and removes any string IDs 
 *       from World::storedValueIDMap that aren't used.
 */
using EntityStoredValueID = Uint16;

/**
 * The ID of the "null stored value", or the ID used to indicate that a  
 * value is not present.
 *
 * Note: Since the null ID is 0, you can do null checks like "if (valueID)".
 */
static constexpr EntityStoredValueID NULL_ENTITY_STORED_VALUE_ID{0};

} // End namespace AM

```

`Source/ServerLib/Simulation/Public/EntityStoredValueIDMap.h`:

```h
#pragma once

#include "EntityStoredValueID.h"
#include "HashTools.h"
#include "bitsery/ext/std_map.h"
#include <unordered_map>
#include <string>

namespace AM
{

/**
 * Maps entity stored value string IDs -> their associated numeric ID.
 * Note: Global stored values are handled separately. This file only applies 
 *       to values stored in an entity's StoredValues component.
 *
 * Entity stored values can't re-use string IDs, regardless of type. However, an 
 * entity stored value can have the same string ID as a global stored value.
 *
 * string_hash and equal_to are added for heterogeneous access (lets us use 
 * string_views directly from Lua without allocating an intermediate 
 * std::string).
 *
 * Note: One could imagine using a StoredValueInfo struct that contained both ID 
 *       and type, to introduce type safety. This ends up being fairly messy 
 *       though, and it doesn't seem to provide much value.
 */
using EntityStoredValueIDMap
    = std::unordered_map<std::string, EntityStoredValueID, string_hash,
                         std::equal_to<>>;

/** Used as a "we should never hit this" cap on the number of entity stored 
    values. */
static constexpr std::size_t MAX_ENTITY_STORED_VALUE_IDS{SDL_MAX_UINT16};

/** Used as a "we should never hit this" cap on stored value string ID length. */
static constexpr std::size_t MAX_ENTITY_STORED_VALUE_STRING_ID_LENGTH{500};

template<typename S>
void serialize(S& serializer, EntityStoredValueIDMap& entityStoredValueIDMap)
{
    serializer.ext(
        entityStoredValueIDMap,
        bitsery::ext::StdMap{MAX_ENTITY_STORED_VALUE_IDS},
        [](S& serializer, std::string& stringID, EntityStoredValueID& id) {
            serializer.text1b(stringID,
                              MAX_ENTITY_STORED_VALUE_STRING_ID_LENGTH);
            serializer.value2b(id);
        });
}

} // End namespace AM

```

`Source/ServerLib/Simulation/Public/EnttGroups.h`:

```h
#pragma once

#include "Input.h"
#include "Position.h"
#include "PreviousPosition.h"
#include "Movement.h"
#include "MovementModifiers.h"
#include "Rotation.h"
#include "Collision.h"
#include "CollisionBitSets.h"
#include "entt/entity/registry.hpp"

namespace AM
{
namespace Server
{
/**
 * A helper class for establishing and working with the entt groups that the  
 * server uses.
 * 
 * Groups can be finicky to work with. If you establish a group <Foo, Bar, Baz>
 * and later try to get group <Foo, Baz>, it'll result in a compiler error. 
 * To make them easier to work with, we provide these functions that return the 
 * most-restrictive versions of each group.
 *
 * Other less-restrictive groups may be made by hand (e.g. <Foo, Bar> in the 
 * above example), as long as they're compatible with the constraints imposed 
 * by these groups.
 */
class EnttGroups
{
public:
    /**
     * Returns the movement group, a group used moving entities.
     */
    static auto getMovementGroup(entt::registry& registry)
    {
        return registry
            .group<Input, Position, PreviousPosition, Movement,
                   MovementModifiers, Rotation, Collision, CollisionBitSets>();
    }

    /**
     * Initializes all of the entt groups that the client uses.
     */
    static void init(entt::registry& registry)
    {
        getMovementGroup(registry);
    }
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/EventSorter.h`:

```h
#pragma once

#include "NetworkDefs.h"
#include <SDL_stdinc.h>
#include <array>
#include <queue>
#include "Log.h"

namespace AM
{
namespace Server
{
/**
 * Base class so we don't have to use EventSorter<ClassName>:: to reference
 * enums and such.
 */
class SorterBase
{
public:
    /**
     * Indicates the validity of a given event's tick in relation to the
     * currentTick.
     */
    enum class ValidityResult {
        /** The given message's tick was less than the EventSorter's
            currentTick. */
        TooLow,
        /** The event's tick is valid. */
        Valid,
        /** The given event's tick was beyond the end of the buffer. */
        TooHigh
    };
};

/**
 * A specialized container that sorts events into an appropriate queue based
 * on the tick number they're associated with.
 *
 * Events need to be sorted instead of directly processing them out of the
 * queue, because we may receive them out of order from clients. E.g.,
 * if we're on tick 39 and we receive a message with tickNum = 42 from client 1,
 * and another with tickNum = 40 from client 2.
 *
 * Not thread safe, use an EventQueue first to move events across threads.
 */
template<typename T>
class EventSorter : public SorterBase
{
public:
    /**
     * The max valid positive difference between an incoming tickNum and our
     * currentTick that we'll accept. If 10, the valid range is [currentTick,
     * currentTick + 10). Effectively, how far into the future we'll buffer
     * messages for.
     */
    static constexpr Sint64 BUFFER_SIZE = 10;

    EventSorter()
    : currentTick(0)
    {
    }

    /**
     * Returns a pointer to the queue holding events for the current tick.
     */
    std::queue<T>& getCurrentQueue()
    {
        return queueBuffer[currentTick % BUFFER_SIZE];
    }

    /**
     * Advances this sorter to the next tick.
     */
    void advance()
    {
        // Advance the state.
        currentTick++;
    }

    /**
     * If tickNum is valid, buffers the message.
     *
     * @return True if tickNum was valid and the message was pushed, else false.
     */
    ValidityResult push(const T& event, Uint32 tickNum)
    {
        // Check validity of the event's tick.
        ValidityResult validity = isTickValid(tickNum);

        // If tickNum is valid, push the event.
        if (validity == ValidityResult::Valid) {
            queueBuffer[tickNum % BUFFER_SIZE].push(std::move(event));
        }

        return validity;
    }

    /** Helper for checking if a tick number is within the bounds. */
    ValidityResult isTickValid(Uint32 tickNum)
    {
        // Check if tickNum is within our lower and upper bounds.
        Uint32 upperBound = (currentTick + BUFFER_SIZE - 1);
        if (tickNum < currentTick) {
            return ValidityResult::TooLow;
        }
        else if (tickNum > upperBound) {
            return ValidityResult::TooHigh;
        }
        else {
            return ValidityResult::Valid;
        }
    }

    /**
     * Returns the EventSorter's internal currentTick.
     *
     * NOTE: Should not be used to fetch the current tick, get a ref to the
     *       Simulation's currentTick instead. This is just to see where the
     *       sorter is at.
     */
    Uint32 getCurrentTick() { return currentTick; }

private:
    /**
     * Holds the queues used for sorting and storing events.
     *
     * Holds events at an index equal to their tick number % BUFFER_SIZE.
     */
    std::array<std::queue<T>, BUFFER_SIZE> queueBuffer;

    /**
     * The current tick that we've advanced to.
     */
    Uint32 currentTick;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/GlobalStoredValueMap.h`:

```h
#pragma once

#include "HashTools.h"
#include "bitsery/ext/std_map.h"
#include <SDL_stdinc.h>
#include <unordered_map>
#include <string>

namespace AM
{

/**
 * A global key-value store.
 * Note: Entity stored values are handled separately. This file only applies 
 *       to values stored in World::globalStoredValueMap.
 *
 * Global stored values can't re-use string IDs, regardless of type. However, an 
 * entity stored value can have the same string ID as a global stored value.
 *
 * string_hash and equal_to are added for heterogeneous access (lets us use 
 * string_views directly from Lua without allocating an intermediate 
 * std::string).
 */
using GlobalStoredValueMap
    = std::unordered_map<std::string, Uint32, string_hash, std::equal_to<>>;

/** Used as a "we should never hit this" cap on the number of entity stored 
    values. */
static constexpr std::size_t MAX_GLOBAL_STORED_VALUES{SDL_MAX_UINT16};

/** Used as a "we should never hit this" cap on stored value string ID length. */
static constexpr std::size_t MAX_GLOBAL_STORED_VALUE_STRING_ID_LENGTH{500};

template<typename S>
void serialize(S& serializer, GlobalStoredValueMap& globalStoredValueMap)
{
    serializer.ext(globalStoredValueMap,
                   bitsery::ext::StdMap{MAX_GLOBAL_STORED_VALUES},
                   [](S& serializer, std::string& stringID, Uint32& value) {
                       serializer.text1b(
                           stringID, MAX_GLOBAL_STORED_VALUE_STRING_ID_LENGTH);
                       serializer.value4b(value);
                   });
}

} // End namespace AM

```

`Source/ServerLib/Simulation/Public/GraphicData/GraphicData.h`:

```h
#pragma once

#include "GraphicDataBase.h"

namespace AM
{
namespace Server
{
/**
 * See GraphicDataBase class comment.
 *
 * The server doesn't currently do any parsing beyond what GraphicDataBase
 * performs, but this class exists to maintain a pattern consistent with
 * Client::GraphicData (which does do additional parsing).
 */
class GraphicData : public GraphicDataBase
{
public:
    /**
     * Calls GraphicDataBase() constructor.
     */
    GraphicData(const nlohmann::json& resourceDataJson);
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/ISimulationExtension.h`:

```h
#pragma once

#include "OSEventHandler.h"
#include "NetworkID.h"

namespace AM
{
struct TileUpdateRequest;
struct TileExtent;
struct EntityInitRequest;
struct EntityDeleteRequest;
struct EntityNameChangeRequest;
struct GraphicStateChangeRequest;
struct ItemInitRequest;
struct ItemChangeRequest;

namespace Server
{

/**
 * Defines an extension for the engine's Server::Simulation class.
 *
 * Extensions are implemented by the project, and are given generic functions
 * ("hooks") in which they can implement relevant project logic.
 *
 * The project can register the extension class with the engine through
 * Application::registerSimulationExtension().
 */
class ISimulationExtension : public OSEventHandler
{
public:
    // Canonical constructor (derived class must implement):
    // SimulationExtension(const SimulationExDependencies& deps)

    //-------------------------------------------------------------------------
    // Simulation Tick Hooks (Call your systems in these)
    //-------------------------------------------------------------------------
    /**
     * Called before any systems are ran.
     */
    virtual void beforeAll() = 0;

    /**
     * Called after the tile map is updated and client entities are
     * added/removed.
     */
    virtual void afterMapAndConnectionUpdates() = 0;

    /**
     * Called after the general simulation update logic (movement, interactions,
     * etc.)
     */
    virtual void afterSimUpdate() = 0;

    /**
     * Called after all relevant state has been sent to the clients.
     */
    virtual void afterClientSync() = 0;

    /**
     * Called after all other systems.
     */
    virtual void afterAll() = 0;

    /**
     * See OSEventHandler for details.
     *
     * Note: Simulation will pass events to this class first. If the event is
     *       not handled, then Simulation will attempt to handle it.
     */
    bool handleOSEvent(SDL_Event& event) override = 0;

    //-------------------------------------------------------------------------
    // Simulation System Hooks (Hooks into engine systems)
    //-------------------------------------------------------------------------
    // These functions allow the project to affect various World state 
    // modifications.

    /** @return true if the given extent is editable, else false. */
    virtual bool isTileExtentEditable(NetworkID netID,
                                      const TileExtent& tileExtent) const = 0;
    /** @return true if the given request is valid, else false. */
    virtual bool isEntityInitRequestValid(
        const EntityInitRequest& entityInitRequest) const = 0;
    virtual bool isEntityDeleteRequestValid(
        const EntityDeleteRequest& entityDeleteRequest) const = 0;
    virtual bool isEntityNameChangeRequestValid(
        const EntityNameChangeRequest& nameChangeRequest) const = 0;
    virtual bool isGraphicStateChangeRequestValid(
        const GraphicStateChangeRequest& graphicStateChangeRequest)
        const = 0;
    virtual bool
        isItemInitRequestValid(const ItemInitRequest& itemInitRequest) const
        = 0;
    virtual bool isItemChangeRequestValid(
        const ItemChangeRequest& itemChangeRequest) const
        = 0;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/IconData/IconData.h`:

```h
#pragma once

#include "IconDataBase.h"

namespace AM
{
namespace Server
{
/**
 * See IconDataBase class comment.
 *
 * The server doesn't currently do any parsing beyond what IconDataBase
 * performs, but this class exists to maintain a pattern consistent with
 * Client::IconData (which does do additional parsing).
 */
class IconData : public IconDataBase
{
public:
    /**
     * Calls IconDataBase() constructor.
     */
    IconData(const nlohmann::json& resourceDataJson);
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/InputSystem.h`:

```h
#pragma once

#include "NetworkDefs.h"
#include "InputChangeRequest.h"
#include "QueuedEvents.h"
#include "EventSorter.h"

namespace AM
{
namespace Server
{
struct SimulationContext;
class Simulation;
class World;
class Network;

/**
 * Receives input messages from clients and applies them to the client's
 * entity.
 */
class InputSystem
{
public:
    InputSystem(const SimulationContext& inSimContext);

    /**
     * Processes incoming InputChangeRequest messages.
     */
    void processInputMessages();

private:
    /**
     * Processes message drop events, which occur when the server received a
     * client's input message late and had to drop it.
     *
     * We default the client's inputs (so they don't run off a cliff) and set
     * a flag so the NetworkUpdateSystem knows that a drop occurred.
     *
     * @param clientID  The ID of the client that we had to drop a message from.
     */
    void handleDroppedMessage(NetworkID clientID);

    /** Used to get the current tick. */
    Simulation& simulation;
    /** Used to access components. */
    World& world;

    EventQueue<InputChangeRequest> inputChangeRequestQueue;
    EventSorter<InputChangeRequest> inputChangeRequestSorter;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/InventoryHelper.h`:

```h
#pragma once

#include "ItemID.h"
#include "NetworkDefs.h"
#include "entt/fwd.hpp"
#include <SDL_stdinc.h>
#include <string_view>

namespace AM
{
namespace Server
{
class World;
class Network;
class ItemData;

/**
 * Helper class for manipulating inventories.
 *
 * When inventories are manipulated, the clients that own them need to be
 * updated. Normally we would observe inventory changes and auto-replicate the
 * whole component, but doing so with a large inventory would be inefficient.
 * Instead, we use these functions to both update the inventory and send the
 * necessary client updates.
 *
 * Note: It may be reasonable to replace this approach with something more
 *       automated, like:
 *         1. Each inventory maintains an operation history. Observe Inventory
              updates, send operations to inventory owner.
 *         2. Add a PreviousInventory component. Observe Inventory updates,
 *            send the diff as InventorySetSlot messages.
 *       Our current approach is more efficient than either of these though, as
 *       it doesn't need to observe anything. The tradeoff is being less
 *       convenient, but we only call these functions in a couple places.
 *       If we ever start commonly calling these functions, consider changing
 *       to one of the other approaches.
 */
class InventoryHelper
{
public:
    enum class AddResult { Success, InventoryFull, ItemNotFound };
    enum class RemoveResult {
        Success,
        InvalidSlotIndex,
        InventoryNotFound,
        ItemNotFound,
        InsufficientItemCount
    };

    InventoryHelper(World& inWorld, Network& inNetwork,
                    const ItemData& inItemData);

    /**
     * Adds the given item to the first available slot in the given entity's
     * inventory.
     *
     * If entityToAddTo is a client entity, sends an update message.
     *
     * @param sendFailureMessage If true and result != Success, a message will
     *                           be sent to entityToAddTo (if its a client 
     *                           entity) to communicate the failure.
     */
    AddResult addItemToEntity(ItemID itemID, Uint8 count,
                              entt::entity entityToAddTo,
                              bool sendFailureMessage = true);

    /**
     * Overload for string IDs.
     *
     * @param sendFailureMessage If true and result != Success, a message will
     *                           be sent to entityToAddTo (if its a client 
     *                           entity) to communicate the failure.
     */
    AddResult addItemToEntity(std::string_view itemID, Uint8 count,
                              entt::entity entityToAddTo,
                              bool sendFailureMessage = true);

    /**
     * Removes the item in the given slot in the given entity's inventory.
     *
     * If entityToAddTo is a client entity, sends an update message.
     *
     * @param sendFailureMessage If true and result != Success, a message will
     *                           be sent to entityToRemoveFrom (if its a client 
     *                           entity) to communicate the failure.
     */
    RemoveResult removeItemFromEntity(Uint8 slotIndex, Uint8 count,
                                      entt::entity entityToRemoveFrom,
                                      bool sendFailureMessage = true);

    /**
     * Removes the given count of items from the entity's inventory.
     * Note: This is different behavior from the above function, which acts on a
     *       specific index.
     *
     * If the inventory doesn't have enough items, does nothing.
     *
     * If entityToAddTo is a client entity, sends an update message.
     *
     * @param sendFailureMessage If true and result != Success, a message will
     *                           be sent to entityToRemoveFrom (if its a client 
     *                           entity) to communicate the failure.
     */
    RemoveResult removeItemFromEntity(std::string_view itemID, Uint8 count,
                                      entt::entity entityToRemoveFrom,
                                      bool sendFailureMessage = true);

private:
    World& world;

    Network& network;

    const ItemData& itemData;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/InventorySystem.h`:

```h
#pragma once

#include "InventoryOperation.h"
#include "EnttObserver.h"
#include "QueuedEvents.h"

namespace AM
{
namespace Server
{
struct SimulationContext;
class World;
class Network;
class ItemData;
class ISimulationExtension;

/**
 * Processes inventory update messages and requests needed item definitions.
 */
class InventorySystem
{
public:
    InventorySystem(const SimulationContext& inSimContext);

    /**
     * Sends initial inventory state to newly-logged-on clients.
     */
    void sendInventoryInits();

    /**
     * Processes inventory manipulation requests and sends inventory data.
     */
    void processInventoryUpdates();

    void setExtension(ISimulationExtension* inExtension);

private:
    /**
     * If the request is valid, adds the item to the specified inventory.
     */
    void processOperation(NetworkID clientID,
                          const InventoryAddItem& inventoryAddItem);

    /**
     * Removes the specified item from the requester's inventory.
     */
    void processOperation(NetworkID clientID,
                          const InventoryRemoveItem& inventoryRemoveItem);

    /**
     * Moves the specified item to the specified slot in the requestor's
     * inventory.
     */
    void processOperation(NetworkID clientID,
                          const InventoryMoveItem& inventoryMoveItem);

    /** Used for accessing inventory data. */
    World& world;
    /** Used for receiving requests and sending item and inventory data. */
    Network& network;
    /** Used for accessing item data. */
    const ItemData& itemData;
    /** If non-nullptr, contains the project's simulation extension functions.
        Used for checking if item change requests are valid. */
    ISimulationExtension* extension;

    /** Observes player Inventory component creation so we can send the initial
        inventory state to a newly-logged-on player. */
    EnttObserver playerInventoryObserver;

    EventQueue<InventoryOperation> inventoryOperationQueue;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/ItemData/ItemData.h`:

```h
#pragma once

#include "ItemDataBase.h"

namespace AM
{
namespace Server
{
/**
 * See ItemDataBase class comment.
 *
 * In addition, performs server-specific duties such as saving/loading item
 * definitions.
 */
class ItemData : public ItemDataBase
{
public:
    /**
     * Calls ItemDataBase() constructor and loads our persisted items.
     */
    ItemData();

    /**
     * Creates a new item with the given data.
     * If referenceItem.numericID == NULL_ITEM_ID, uses the next sequential ID.
     *
     * Note: If no stringID is given, it will be derived from referenceItem's 
     *       displayName.
     *
     * @param referenceItem The item to copy when creating the new item.
     * @return If an item with the given ID or displayName exists, does nothing
     *         and returns nullptr. Else, returns the new item.
     */
    const Item* createItem(const Item& referenceItem,
                           std::string_view initScript);

    /**
     * Updates the item at referenceItem.numericID to match the given item, 
     * then increments its version number.
     *
     * Note: If no stringID is given, it will be derived from referenceItem's 
     *       displayName.
     *
     * @param referenceItem The item to copy when creating the new item.
     * @return If no item with the given ID exists or referenceItem's 
     *         displayName is changed but already taken, returns nullptr. 
     *         Else, returns the updated item.
     */
    const Item* updateItem(const Item& referenceItem,
                           std::string_view initScript);

    /**
     * Overload to handle init scripts.
     * Note: Doing it this way means the signals will go out before the init 
     *       script is added to the map. If this becomes an issue, we can 
     *       move it into the base class and just have the client pass "".
     */
    const Item* loadItem(const Item& referenceItem, ItemVersion version,
                         std::string_view initScript);

    /**
     * Returns an item's init script.
     *
     * @return If no item with the given ID exists, returns {}. Else, returns 
     *         the item's init script.
     */
    const ItemInitScript& getItemInitScript(ItemID numericID) const;

private:
    // Note: We bring this into the private namespace so that outside consumers
    //       are forced to use the initScript version.
    using ItemDataBase::loadItem;

    /** Each item's init script, indexed by their numeric IDs.
        Note: We split this from the Item class to reduce size and because it 
              isn't really part of an item's definition. */
    std::unordered_map<ItemID, ItemInitScript> itemInitScriptMap;

    /** Used as a default to return if getItemInitScript() fails. */
    ItemInitScript defaultInitScript;

    /** A scratch buffer used while processing string IDs. */
    std::string workStringID{};
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/ItemSystem.h`:

```h
#pragma once

#include "ItemID.h"
#include "CombineItemsRequest.h"
#include "UseItemOnEntityRequest.h"
#include "ItemInitRequest.h"
#include "ItemChangeRequest.h"
#include "ItemDataRequest.h"
#include "NetworkID.h"
#include "QueuedEvents.h"

namespace AM
{
struct CastInfo;

namespace Server
{
struct SimulationContext;
class World;
class Network;
class ItemData;
class ISimulationExtension;
struct EntityItemHandlerLua;
struct EntityItemHandlerScript;

/**
 * Manages item definitions, handling change requests and requests for data.
 */
class ItemSystem
{
public:
    ItemSystem(const SimulationContext& inSimContext);

    /**
     * Processes the "Use On" item interactions (combine items, use item on 
     * entity).
     */
    void processUseItemInteractions();

    /**
     * Processes item definition updates and requests.
     */
    void processItemUpdates();

    void setExtension(ISimulationExtension* inExtension);

private:
    /**
     * Adds the given item to updatedItems.
     */
    void itemUpdated(ItemID itemID);

    /**
     * Sends the given item's examine text to the given client.
     */
    void examineItem(const CastInfo& castInfo);

    /**
     * Tries to combine the given items in the given player's inventory. If the
     * combination is invalid (either slot is empty, or neither items supports
     * the combination), sends an appropriate response.
     */
    void combineItems(Uint8 sourceSlotIndex, Uint8 targetSlotIndex,
                      NetworkID clientID);

    /**
     * Tries to use the item in the given player's inventory slot on the given
     * entity. If the entity doesn't support the interaction, sends an
     * appropriate response.
     */
    void useItemOnEntity(Uint8 sourceSlotIndex, entt::entity targetEntity,
                         NetworkID clientID);

    /**
     * Creates a new item with the given data. If the ID is already taken,
     * sends an ItemError.
     */
    void handleInitRequest(const ItemInitRequest& itemInitRequest);

    /**
     * Overwrites an existing item with the given data. If no existing item
     * matches the given ID, sends an ItemError.
     */
    void handleChangeRequest(const ItemChangeRequest& itemChangeRequest);

    /**
     * If the requested item exists, sends an update to the requester.
     * If not, sends an ItemError.
     */
    void handleDataRequest(const ItemDataRequest& itemDataRequest);

    /**
     * Runs the given init script on the given item.
     *
     * @return true if the script ran successfully, else false.
     *         If false, an appropriate error message will be sent.
     */
    bool runItemInitScript(NetworkID clientID, const ItemInitScript& initScript,
                           Item& item);

    /**
     * Runs the given item handler script on the given target entity.
     *
     * If the script fails, an appropriate error message will be sent.
     *
     * @param clientID The client that initiated this interaction.
     * @param clientEntity The client's entity.
     * @param targetEntity The entity that the item is being used on.
     * @param item The item that's being used.
     */
    void runEntityItemHandlerScript(
        NetworkID clientID, entt::entity clientEntity,
        entt::entity targetEntity, const Item* item,
        const EntityItemHandlerScript& itemHandlerScript);

    /** Used for accessing item and inventory data. */
    World& world;
    /** Used for receiving requests and sending item and inventory data. */
    Network& network;
    /** Used for getting item data and subscribing to updates. */
    ItemData& itemData;
    /** Used to run entity item handler scripts. */
    EntityItemHandlerLua& entityItemHandlerLua;
    /** If non-nullptr, contains the project's simulation extension functions.
        Used for checking if item item requests are valid. */
    ISimulationExtension* extension;

    /** Holds a history of items that have been updated.
        Used to know which items need to be sent to clients. */
    std::vector<ItemID> updatedItems;

    EventQueue<ItemInitRequest> itemInitRequestQueue;
    EventQueue<ItemChangeRequest> itemChangeRequestQueue;
    EventQueue<CombineItemsRequest> combineItemsRequestQueue;
    EventQueue<UseItemOnEntityRequest> useItemOnEntityRequestQueue;
    EventQueue<ItemDataRequest> itemDataRequestQueue;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Lua/DialogueChoiceConditionLua.h`:

```h
#pragma once

#include "sol/sol.hpp"
#include "entt/fwd.hpp"

namespace AM
{
namespace Server
{
/**
 * The lua environment for running dialogue choice condition scripts.
 *
 * Condition scripts are much more limited than other dialogue scripts. They 
 * only have access to getters, and will always be made into the form:
 * "r = (given script)" where r must hold a boolean type after evaluation.
 *
 * Contains additional members that are set by the script runner to pass 
 * relevant data to the environment's bound functions.
 */
struct DialogueChoiceConditionLua {
    /** Lua environment for dialogue choice condition script processing.
        Global variables:
          "user": The ID of the entity that is controlling the dialogue.
          "self": The ID of the entity that is delivering the dialogue.
          "GLOBAL": A constant used to identify the global value store. */
    sol::state luaState{};

    /** The network ID of the client that is controlling the dialogue. */
    NetworkID clientID{0};
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Lua/DialogueLua.h`:

```h
#pragma once

#include "DialogueEvent.h"
#include "NetworkID.h"
#include "sol/sol.hpp"
#include "entt/fwd.hpp"

namespace AM
{
namespace Server
{
/**
 * The lua environment for running both dialogue topic scripts and dialogue 
 * choice action scripts.
 *
 * Contains additional members that are set by the script runner to pass 
 * relevant data to the environment's bound functions.
 */
struct DialogueLua {
    /** Lua environment for dialogue topic and choice action script 
        processing.
        Global variables:
          "self": The ID of the entity that is delivering the dialogue.
          "target": The ID of the entity that is controlling the dialogue.
          "GLOBAL": A constant used to identify the global value store. */
    sol::state luaState{};

    /** The network ID of the client that is controlling the dialogue. */
    NetworkID clientID{0};

    /** (Out) The dialogue events that should be sent to the client. */
    std::vector<DialogueEvent>* dialogueEvents{};

    /** (Out) The topic specified by the latest setNextTopic().
        Will == "" if no setNextTopic() was called by the latest-ran script. */
    std::string nextTopicName{""};
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Lua/EngineLuaBindings.h`:

```h
#pragma once

#include "ItemID.h"
#include "EngineCollisionLayerType.h"
#include "Dialogue.h"
#include "NetworkID.h"
#include "entt/fwd.hpp"
#include <SDL_stdinc.h>
#include <string_view>
#include <functional>

namespace sol
{
class state;
}

namespace AM
{
namespace Server
{
struct EntityInitLua;
struct EntityItemHandlerLua;
struct ItemInitLua;
struct DialogueLua;
struct DialogueChoiceConditionLua;
class GraphicData;
class World;
class Network;
class ItemData;

/**
 * Holds any functionality that the engine wants to expose to Lua.
 *
 * Note: This is a class instead of a set of free functions, because it's more
 *       convenient for the bound functions to have access to some state.
 */
class EngineLuaBindings
{
public:
    EngineLuaBindings(EntityInitLua& inEntityInitLua,
                      EntityItemHandlerLua& inEntityItemHandlerLua,
                      ItemInitLua& inItemInitLua, DialogueLua& inDialogueLua,
                      DialogueChoiceConditionLua& inDialogueChoiceConditionLua,
                      const GraphicData& inGraphicData,
                      const ItemData& inItemData, World& inWorld,
                      Network& inNetwork);

private:
    void addEntityInitBindings();
    void addEntityItemHandlerBindings();
    void addItemInitBindings();
    void addDialogueBindings();
    void addDialogueChoiceConditionBindings();
    void addDialogueChoiceBindings();

    //-------------------------------------------------------------------------
    // Entity init
    //-------------------------------------------------------------------------
    void setCollisionLayers(CollisionLayerBitSet collisionLayers);

    void setCollisionMask(CollisionLayerBitSet collisionMask);

    /**
     * Adds the "Talk" interaction to the entity.
     * Use the topic() Lua function to add dialogue.
     */
    void addTalkInteraction();

    /**
     * Sets the given handler to be called when an item is used on the entity.
     */
    void setItemHandler(std::string_view handlerScript);

    /**
     * Adds a new topic to the entity's dialogue tree.
     */
    void topic(std::string_view topicName, std::string_view topicScript,
               std::string_view choiceScript);

    //-------------------------------------------------------------------------
    // Entity item handler
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Item init
    //-------------------------------------------------------------------------
    /**
     * Adds the description text that's shown the item is examined.
     */
    void setDescription(std::string_view description);

    /**
     * Sets the max stack size, for when the item is stacked in an inventory.
     */
    void setMaxStackSize(Uint8 newMaxStackSize);

    /**
     * Adds a combination with the given item, which will result in a new item
     * (both inputs will be consumed).
     * @param otherItemID The item to combine with.
     * @param resultitemID The resulting item.
     */
    void addCombination(std::string_view otherItemID,
                        std::string_view resultItemID,
                        std::string_view description);

    //-------------------------------------------------------------------------
    // Dialogue
    //-------------------------------------------------------------------------
    /**
     * Adds a piece of dialogue to the dialogue event list.
     */
    void say(std::string_view text);

    /**
     * Adds a piece of narration to the dialogue event list.
     */
    void narrate(std::string_view text);

    /**
     * Sets the given topic as the next topic to navigate to.
     * Does not immediately jump--the rest of the current script will finish.
     * Calling this multiple times will overwrite previous calls.
     */
    void setNextTopic(std::string_view topicName);

    //-------------------------------------------------------------------------
    // Dialogue choice condition
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Dialogue choice
    //-------------------------------------------------------------------------
    /**
     * Adds a dialogue choice.
     * @param displayText The text to display for this choice.
     * @param actionScript The actions to run if this choice is successfully 
     *                     selected.
     */
    void choice(std::string_view displayText, std::string_view actionScript);

    /**
     * Adds a conditional dialogue choice.
     * The condition will be used both when checking if the choice should be 
     * sent, and when validating an incoming request to select the choice.
     * @param conditionScript The condition to check against.
     * @param displayText The text to display for this choice.
     * @param actionScript The actions to run if this choice is successfully 
     *                     selected.
     */
    void choiceIf(std::string_view conditionScript,
                  std::string_view displayText, std::string_view actionScript);

    //-------------------------------------------------------------------------
    // Shared
    //-------------------------------------------------------------------------
    /**
     * Attempts to add the given item to the first available slot in 
     * entityToAddTo's inventory.
     * @return true if the item was successfully added, else false (inventory
     *         didn't exist, inventory was full).
     */
    bool addItem(entt::entity entityToAddTo, std::string_view itemID,
                 Uint8 count);

    /**
     * Attempts to remove the given item from the client entity's inventory.
     * @return true if the item was successfully removed, else false (inventory
     *         didn't contain the item).
     */
    bool removeItem(entt::entity entityToRemoveFrom, std::string_view itemID,
                    Uint8 count);

    /**
     * Returns the count for the given item across all slots in the given 
     * entity's inventory.
     */
    std::size_t getItemCount(entt::entity entityToCount,
                             std::string_view itemID);

    /**
     * Adds a new value, or overwrites an existing value.
     *
     * If newValue == 0 (the default value), the value will be deleted.
     * 
     * Note: There's no type safety with stored values. If you call storeInt 
     *       on a value that was previously set as a bool, it will be  
     *       overwritten without issue.
     *
     * @param entity The entity to store the value to. If == entt::null, the 
     *               the value will be stored to the global store instead.
     * @param stringID The string ID of the value to add or overwrite.
     * @param newValue The new value to use.
     */
    void storeUint(entt::entity entity, std::string_view stringID,
                   Uint32 newValue);
    void storeBool(entt::entity entity, std::string_view stringID,
                   bool newValue);
    void storeInt(entt::entity entity, std::string_view stringID, int newValue);
    void storeFloat(entt::entity entity, std::string_view stringID,
                    float newValue);
    /** @param newValue A time in seconds, since 0 UTC (Jan 1, 1970). */
    void storeTime(entt::entity entity, std::string_view stringID,
                   Uint32 newValue);
    void storeBitSet(entt::entity entity, std::string_view stringID,
                     Uint32 newValue);
    /** @param bitToSet The bit to set, within the 32-bit stored value. Must be
                        within the range [0, 31]. */
    void storeBit(entt::entity entity, std::string_view stringID,
                  Uint8 bitToSet, bool newValue);

    /**
     * Gets a stored value.
     * 
     * Note: There's no type safety with stored values. If you call getStoredInt 
     *       on a value that was previously set as a bool, it will be returned 
     *       as an int without issue.
     *
     * @param entity The entity to get the value from. If == entt::null, the 
     *               the value will be retrieved from the global store instead.
     * @param stringID The string ID of the value to get.
     * @return The requested value. If not found, returns 0 (the default value 
     *         that the flag would have if it existed).
     */
    Uint32 getStoredUint(entt::entity entity, std::string_view stringID);
    bool getStoredBool(entt::entity entity, std::string_view stringID);
    int getStoredInt(entt::entity entity, std::string_view stringID);
    float getStoredFloat(entt::entity entity, std::string_view stringID);
    /** @return A time in seconds, since 0 UTC (Jan 1, 1970). */
    Uint32 getStoredTime(entt::entity entity, std::string_view stringID);
    Uint32 getStoredBitSet(entt::entity entity, std::string_view stringID);
    /** @param bitToGet The bit to get, within the 32-bit stored value. Must be
                        within the range [0, 31]. */
    bool getStoredBit(entt::entity entity, std::string_view stringID,
                      Uint8 bitToGet);

    /**
     * Sets a bit in a bit set to the given value.
     * Note: We take bitSet as a Uint32, since Lua doesn't have a matching 
     *       concept and it's more efficient to 
     *       
     */
    void setBit(std::reference_wrapper<Uint32> bitSet, Uint8 bitToSet,
                bool newValue);

    /**
     * Gets a bit from a bit set.
     */
    bool getBit(Uint32 bitSet, Uint8 bitToGet);

    /**
     * Returns the current time in seconds since 0 UTC (Jan 1, 1970).
     * Note: We define our own function instead of using Lua's os.time because 
     *       many of the os library functions are not safe to expose to users.
     */
    Uint32 getCurrentTime();

    /**
     * Sends a system message to the client.
     */
    void sendSystemMessage(std::string_view message, NetworkID clientID);

    EntityInitLua& entityInitLua;
    EntityItemHandlerLua& entityItemHandlerLua;
    ItemInitLua& itemInitLua;
    DialogueLua& dialogueLua;
    DialogueChoiceConditionLua& dialogueChoiceConditionLua;
    const GraphicData& graphicData;
    const ItemData& itemData;
    World& world;
    Network& network;

    /** Used to run dialogue choice scripts. Only supports the choice() function.
        Since its interface never needs to be extended, and this class is the 
        only one that uses it, we can keep it private to this class. */
    std::unique_ptr<sol::state> dialogueChoiceLua;

    /** If we're in the middle of running a dialogue choice script, this holds 
        the topic from the entity's Dialogue::topics that we're currently 
        adding to. */
    Dialogue::Topic* currentDialogueTopic;

    /** A scratch buffer used while processing strings. */
    std::string workString;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Lua/EntityInitLua.h`:

```h
#pragma once

#include "sol/sol.hpp"
#include "entt/fwd.hpp"

namespace AM
{
namespace Server
{
/**
 * The lua environment for running entity init scripts.
 *
 * Contains additional members that are set by the script runner to pass 
 * relevant data to the environment's bound functions.
 */
struct EntityInitLua {
    /** Lua environment for entity init script processing. */
    sol::state luaState{};

    /** The entity that the init script is being ran on. */
    entt::entity selfEntity{};
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Lua/EntityItemHandlerLua.h`:

```h
#pragma once

#include "NetworkID.h"
#include "sol/sol.hpp"

namespace AM
{
struct Item;

namespace Server
{
/**
 * The lua environment for running entity item handler scripts.
 *
 * Contains additional members that are set by the script runner to pass 
 * relevant data to the environment's bound functions.
 */
struct EntityItemHandlerLua {
    /** Lua environment for entity item handler script processing.
        Global variables:
          "user": The ID of the entity that used the item.
                  May be a non-player entity.
          "self": The ID of the entity that the item is being used on.
          "target": The ID of the entity that used the item.
          "itemID": The string ID of the item that's being used.
          "GLOBAL": A constant used to identify the global value store. */
    sol::state luaState{};

    /** The network ID of the client that used the item. */
    NetworkID clientID{0};

    /** The item that's being used.
        Will always be non-nullptr while a script is running. */
    const Item* item{};
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Lua/ItemInitLua.h`:

```h
#pragma once

#include "sol/sol.hpp"
#include "entt/fwd.hpp"

namespace AM
{
struct Item;

namespace Server
{

/**
 * The lua environment for running item init scripts.
 *
 * Contains additional members that are set by the script runner to pass 
 * relevant data to the environment's bound functions.
 */
struct ItemInitLua {
    /** Lua environment for item init script processing. */
    sol::state luaState{};

    /** The item that the init script is being ran on.
        Will always be non-nullptr while a script is running. */
    Item* selfItem{};
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/MovementSyncSystem.h`:

```h
#pragma once

#include "EnttObserver.h"

namespace AM
{
struct Input;
struct Position;
struct EntityUpdate;

namespace Server
{
struct SimulationContext;
class Simulation;
class World;
class Network;
struct ClientSimData;

/**
 * Sends clients the movement state of any nearby entities that need to be
 * re-synced (including themselves).
 *
 * Reasons for needing to re-sync movement state include:
 *   1. The entity's inputs changed (the user pressed or released a key).
 *   2. We had to drop a movement update request message from the entity
 *      (in such a case, we zero-out their input state so they don't run off
 *      a cliff).
 *   3. The entity was teleported.
 *
 * We detect a need for movement state sync by observing the Input component.
 * If you want to sync an entity's movement state (e.g. Position) without
 * changing its inputs, you can just registry.patch() with no changes.
 */
class MovementSyncSystem
{
public:
    MovementSyncSystem(const SimulationContext& inSimContext);

    /**
     * Updates all connected clients with relevant entity movement state.
     */
    void sendMovementUpdates();

private:
    /**
     * Determines which entity's data needs to be sent to the given client and
     * adds them to entitiesToSend.
     *
     * Will add any entities that have just entered the client's AOI, and any
     * entities already within the client's AOI that have changed input state.
     */
    void collectEntitiesToSend(ClientSimData& client);

    /**
     * Adds the movement state of all entities in entitiesToSend to an
     * EntityUpdate message and sends it to the given client.
     */
    void sendEntityUpdate(ClientSimData& client);

    /** Used to get the current tick. */
    Simulation& simulation;
    /** Used to access entity component data. */
    World& world;
    /** Used to send movement update messages. */
    Network& network;

    /** Holds the entities that have an input update that needs to be synced. */
    std::vector<entt::entity> updatedEntities;

    /** Holds the entities that a particular client needs to be sent updates
        for. */
    std::vector<entt::entity> entitiesToSend;

    /** Observes updates to movement sync-relevant components so we know when 
        to sync. */
    EnttObserver movementSyncObserver;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/MovementSystem.h`:

```h
#pragma once

#include "EntityMover.h"

namespace AM
{
namespace Server
{
struct SimulationContext;
class World;

/**
 * Moves entities.
 */
class MovementSystem
{
public:
    MovementSystem(const SimulationContext& inSimContext);

    /**
     * Processes 1 tick of entity movement.
     */
    void processMovements();

private:
    World& world;

    EntityMover entityMover;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/NceLifetimeSystem.h`:

```h
#pragma once

#include "EntityInitRequest.h"
#include "EntityDeleteRequest.h"
#include "QueuedEvents.h"
#include <queue>

namespace AM
{
namespace Server
{
struct SimulationContext;
class World;
class Network;
class ISimulationExtension;

/**
 * Manages creation and destruction of non-client entities.
 *
 * Non-client entities are any entity not controlled by a client (dynamic
 * objects, NPCs, etc).
 */
class NceLifetimeSystem
{
public:
    NceLifetimeSystem(const SimulationContext& inSimContext);

    /**
     * Processes any waiting EntityInitRequest or EntityDelete messages.
     */
    void processUpdateRequests();

    void setExtension(ISimulationExtension* inExtension);

private:
    /**
     * Either creates the given entity and initializes it, or re-creates it
     * and queues an init for next tick.
     */
    void handleInitRequest(const EntityInitRequest& entityInitRequest);

    /**
     * Creates the given entity. If there was an error while running the init
     * script, sends the error to the requesting client.
     */
    void createEntity(const EntityInitRequest& entityInitRequest);

    /**
     * If the given entity is valid, deletes it.
     */
    void handleDeleteRequest(const EntityDeleteRequest& entityDeleteRequest);

    /** Used to add/remove entities. */
    World& world;
    /** Used to send error messages if entity creation fails. */
    Network& network;
    /** Contains the project's simulation extension functions.
        Used for checking if entity creation requests are valid. */
    ISimulationExtension* extension;

    /** Holds entity that need to be re-initialized on the next tick. */
    std::queue<EntityInitRequest> entityReInitQueue;

    EventQueue<EntityInitRequest> entityInitRequestQueue;
    EventQueue<EntityDeleteRequest> entityDeleteRequestQueue;
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/PersistedComponent.h`:

```h
#pragma once

#include "EnginePersistedComponentTypes.h"
#include "ProjectPersistedComponentTypes.h"
#include "boost/mp11/list.hpp"
#include "bitsery/traits/vector.h"
#include "bitsery/ext/std_variant.h"
#include <variant>
#include <vector>

namespace AM
{
// Note: Persisted components are server-only.
namespace Server
{
/**
 * A variant that holds a persisted engine component.
 *
 * Used by the server to save entity state to the database.
 */
using EnginePersistedComponent
    = boost::mp11::mp_rename<EnginePersistedComponentTypes, std::variant>;

template<typename S>
void serialize(S& serializer,
               std::vector<EnginePersistedComponent>& engineComponents)
{
    serializer.enableBitPacking([&](typename S::BPEnabledType& sbp) {
        sbp.container(
            engineComponents,
            boost::mp11::mp_size<EnginePersistedComponentTypes>::value,
            [](typename S::BPEnabledType& serializer,
               EnginePersistedComponent& component) {
                serializer.ext(component, bitsery::ext::StdVariant{});
            });
    });
}

/**
 * A variant that holds a persisted engine component.
 *
 * Used by the server to save entity state to the database.
 */
using ProjectPersistedComponent
    = boost::mp11::mp_rename<ProjectPersistedComponentTypes, std::variant>;

template<typename S>
void serialize(S& serializer,
               std::vector<ProjectPersistedComponent>& projectComponents)
{
    serializer.enableBitPacking([&](typename S::BPEnabledType& sbp) {
        sbp.container(
            projectComponents,
            boost::mp11::mp_size<ProjectPersistedComponentTypes>::value,
            [](typename S::BPEnabledType& serializer,
               ProjectPersistedComponent& component) {
                serializer.ext(component, bitsery::ext::StdVariant{});
            });
    });
}

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/SaveSystem.h`:

```h
#pragma once

#include "ItemID.h"
#include "Timer.h"
#include "BinaryBuffer.h"
#include <vector>

namespace AM
{
namespace Server
{
struct SimulationContext;
class Simulation;
class World;
class ItemData;

/**
 * Periodically saves the world's data:
 *   Tile map data is saved to TileMap.bin.
 *   Non-client entity data is saved to the database.
 *   Item data is saved to the database.
 */
class SaveSystem
{
public:
    SaveSystem(const SimulationContext& inSimContext);

    /**
     * If data is due for saving, saves it.
     *
     * Configure through Config::SAVE_PERIOD.
     */
    void saveIfNecessary();

private:
    /**
     * Adds the given item to updatedItems.
     */
    void itemUpdated(ItemID itemID);

    /**
     * Saves non-client entities to the in-memory database.
     */
    void saveNonClientEntities();

    /**
     * Saves items to the in-memory database.
     */
    void saveItems();

    /**
     * Saves World::storedValueIDMap and World::globalStoredValueMap to the 
     * in-memory database.
     */
    void saveStoredValues();

    Simulation& simulation;
    World& world;
    ItemData& itemData;

    /** Holds a history of items that have been updated.
        Used to know which items need to be saved. */
    std::vector<ItemID> updatedItems;

    /** Used to track how much time has passed since the last save. */
    Timer saveTimer;

    /** Scratch buffers used while serializing data. */
    BinaryBuffer workBuffer1;
    BinaryBuffer workBuffer2;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/ScriptDataSystem.h`:

```h
#pragma once

#include "EntityInitScriptRequest.h"
#include "ItemInitScriptRequest.h"
#include "QueuedEvents.h"

namespace AM
{
namespace Server
{
struct SimulationContext;
class World;
class Network;
class ItemData;

/**
 * Handles sending Lua scripts to clients.
 *
 * Scripts are stored on the server in various components. When a client wants
 * to edit an entity, we send them that entity's scripts so they don't have to
 * start from scratch.
 */
class ScriptDataSystem
{
public:
    ScriptDataSystem(const SimulationContext& inSimContext);

    /**
     * Processes script data requests, sending script data if the request is
     * valid.
     */
    void sendScripts();

private:
    /** Used for accessing script data. */
    World& world;
    /** Used for receiving script requests and sending scripts to clients. */
    Network& network;
    /** Used for accessing item data. */
    const ItemData& itemData;

    /**
     * Sends the requested init script.
     */
    void sendEntityInitScript(const EntityInitScriptRequest& initScriptRequest);
    void sendItemInitScript(const ItemInitScriptRequest& initScriptRequest);

    EventQueue<EntityInitScriptRequest> entityInitScriptRequestQueue;
    EventQueue<ItemInitScriptRequest> itemInitScriptRequestQueue;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/Simulation.h`:

```h
#pragma once

#include "World.h"
#include "EngineLuaBindings.h"
#include "ClientConnectionSystem.h"
#include "NceLifetimeSystem.h"
#include "ComponentChangeSystem.h"
#include "TileUpdateSystem.h"
#include "InputSystem.h"
#include "MovementSystem.h"
#include "AISystem.h"
#include "CastSystem.h"
#include "ItemSystem.h"
#include "InventorySystem.h"
#include "DialogueSystem.h"
#include "ClientAOISystem.h"
#include "MovementSyncSystem.h"
#include "ComponentSyncSystem.h"
#include "ChunkStreamingSystem.h"
#include "ScriptDataSystem.h"
#include "SaveSystem.h"
#include <SDL_stdinc.h>
#include <atomic>
#include <memory>

namespace AM
{
class CastableData;

namespace Server
{
struct SimulationContext;
class Network;
class GraphicData;
class ItemData;
struct EntityInitLua;
struct EntityItemHandlerLua;
struct ItemInitLua;
struct DialogueLua;
struct DialogueChoiceConditionLua;
class ISimulationExtension;

/**
 * Manages the simulation, including world state and system processing.
 *
 * The simulation is built on an ECS architecture:
 *   Entities exist in a registry, owned by the World class.
 *   Components that hold data are attached to each entity.
 *   Systems that act on sets of components are owned and ran by this class.
 */
class Simulation
{
public:
    /** An unreasonable amount of time for the sim tick to be late by. */
    static constexpr double SIM_DELAYED_TIME_S{.001};

    Simulation(const SimulationContext& inSimContext);

    ~Simulation();

    /**
     * Returns a reference to the simulation's world state.
     */
    World& getWorld();

    /**
     * Returns a reference to the simulation's Lua bindings.
     */
    EntityInitLua& getEntityInitLua();
    EntityItemHandlerLua& getEntityItemHandlerLua();
    ItemInitLua& getItemInitLua();
    DialogueLua& getDialogueLua();
    DialogueChoiceConditionLua& getDialogueChoiceConditionLua();

    /**
     * Returns the simulation's current tick number.
     */
    Uint32 getCurrentTick() const;

    /**
     * Updates accumulatedTime. If greater than the tick timestep, processes
     * the next sim iteration.
     */
    void tick();

    /**
     * See extension member comment.
     */
    void setExtension(ISimulationExtension* inExtension);

private:
    /** Used to receive events (through the Network's dispatcher) and to
        send messages. */
    Network& network;

    /** Lua environment for entity init script processing.
        Kept as a pointer to speed up compilation. */
    std::unique_ptr<EntityInitLua> entityInitLua;

    /** Lua environment for entity item handler script processing. */
    std::unique_ptr<EntityItemHandlerLua> entityItemHandlerLua;

    /** Lua environment for item init script processing. */
    std::unique_ptr<ItemInitLua> itemInitLua;

    /** Lua environment for dialogue topic and choice action script 
        processing. */
    std::unique_ptr<DialogueLua> dialogueLua;

    /** Lua environment for dialogue choice condition script processing. */
    std::unique_ptr<DialogueChoiceConditionLua> dialogueChoiceConditionLua;

    /** The world's state. */
    World world;

    /** The tick number that we're currently on. */
    std::atomic<Uint32> currentTick;

    /** The engine's Lua bindings. */
    EngineLuaBindings engineLuaBindings;

    /** Contains the project's simulation extension functions.
        Allows the project to provide simulation code and have it be called at
        the appropriate time. */
    ISimulationExtension* extension;

    //-------------------------------------------------------------------------
    // Systems
    //-------------------------------------------------------------------------
    ClientConnectionSystem clientConnectionSystem;
    NceLifetimeSystem nceLifetimeSystem;
    ComponentChangeSystem componentChangeSystem;
    TileUpdateSystem tileUpdateSystem;
    InputSystem inputSystem;
    MovementSystem movementSystem;
    AISystem aiSystem;
    CastSystem castSystem;
    ItemSystem itemSystem;
    InventorySystem inventorySystem;
    DialogueSystem dialogueSystem;
    ClientAOISystem clientAOISystem;
    MovementSyncSystem movementSyncSystem;
    ComponentSyncSystem componentSyncSystem;
    ChunkStreamingSystem chunkStreamingSystem;
    ScriptDataSystem scriptDataSystem;
    SaveSystem saveSystem;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/SimulationContext.h`:

```h
#pragma once

namespace AM
{
class EventDispatcher;
class CastableData;

namespace Server
{
class Simulation;
class Network;
class GraphicData;
class IconData;
class ItemData;

/**
 * Defines the dependencies that will be provided to the project's
 * SimulationExtension class.
 */
struct SimulationContext {
public:
    /** World state, current tick. */
    Simulation& simulation;

    /** Client messaging. */
    Network& network;

    /** Network -> Sim/UI message events. */
    EventDispatcher& networkEventDispatcher;

    GraphicData& graphicData;

    IconData& iconData;

    ItemData& itemData;

    CastableData& castableData;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/SpawnStrategy.h`:

```h
#pragma once

namespace AM
{
namespace Server
{

/**
 * The strategies that we can use for determining where entities should spawn.
 */
enum class SpawnStrategy {
    /** Spawn in a fixed location. */
    Fixed,
    /** Spawn in groups. */
    Grouped,
    /** Spawn in a random location. */
    Random
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/TileMap/TileMap.h`:

```h
#pragma once

#include "TileMapBase.h"

namespace AM
{
struct TileMapSnapshot;
class Tile;
struct TileSnapshot;
struct ChunkSnapshot;

namespace Server
{
class GraphicData;

/**
 * Owns and manages the world's tile map state.
 * Tiles are conceptually organized into 16x16 chunks.
 *
 * Persisted tile map data is loaded from TileMap.bin.
 *
 * Note: This class expects a TileMap.bin file to be present in the same
 *       directory as the application executable.
 */
class TileMap : public TileMapBase
{
public:
    /**
     * Attempts to parse TileMap.bin and construct the tile map.
     *
     * Errors if TileMap.bin doesn't exist or it fails to parse.
     */
    TileMap(const GraphicData& inGraphicData,
            CollisionLocator& inCollisionLocator);

    /**
     * Attempts to save the current tile map state to TileMap.bin.
     */
    ~TileMap();

    /**
     * Saves the map to a file with the given name, placed in the same
     * directory as the program binary.
     *
     * @param fileName  The file name to save to, with no path prepended.
     */
    void save(const std::string& fileName);

private:
    /**
     * Loads the given snapshot's data into this map.
     */
    void load(TileMapSnapshot& mapSnapshot);

    /**
     * Copies the given chunk's data into the given snapshot.
     */
    void saveChunkToSnapshot(const Chunk& chunk, ChunkSnapshot& chunkSnapshot);
};

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/TileUpdateSystem.h`:

```h
#pragma once

#include "TileAddLayer.h"
#include "TileRemoveLayer.h"
#include "TileClearLayers.h"
#include "TileExtentClearLayers.h"
#include "QueuedEvents.h"

namespace AM
{
namespace Server
{
struct SimulationContext;
class World;
class Network;
class ISimulationExtension;

/**
 * Processes tile update requests sent by clients. If a request is valid,
 * updates the map.
 * Also, detects changes to the tile map and sends the new map state to all
 * nearby clients.
 */
class TileUpdateSystem
{
public:
    TileUpdateSystem(const SimulationContext& inSimContext);

    /**
     * Processes tile updates and updates the world's tile map.
     */
    void updateTiles();

    /**
     * Sends any dirty tile state to all nearby clients.
     */
    void sendTileUpdates();

    void setExtension(ISimulationExtension* inExtension);

private:
    /**
     * If the given request is valid, adds the tile layer to the map.
     */
    void addTileLayer(const TileAddLayer& addLayerRequest);

    /**
     * If the given request is valid, removes the tile layer from the map.
     */
    void remTileLayer(const TileRemoveLayer& remLayerRequest);

    /**
     * If the given request is valid, clears the tile layers from the map.
     */
    void clearTileLayers(const TileClearLayers& clearLayersRequest);

    /**
     * If the given request is valid, clears the tile layers from the map.
     */
    void clearExtentLayers(
        const TileExtentClearLayers& clearExtentLayersRequest);

    /** Used to access the entity registry, locator, and the tile map. */
    World& world;
    /** Used to send tile update requests and receive tile updates. */
    Network& network;

    /** If non-nullptr, contains the project's simulation extension functions.
        Used for checking if tile updates are valid. */
    ISimulationExtension* extension;

    EventQueue<TileAddLayer> addLayerRequestQueue;
    EventQueue<TileRemoveLayer> removeLayerRequestQueue;
    EventQueue<TileClearLayers> clearLayersRequestQueue;
    EventQueue<TileExtentClearLayers> extentClearLayersRequestQueue;
};

} // namespace Server
} // namespace AM

```

`Source/ServerLib/Simulation/Public/TypeLists/EngineObservedComponentTypes.h`:

```h
#pragma once

#include "Name.h"
#include "MovementModifiers.h"
#include "GraphicState.h"
#include "CollisionBitSets.h"
#include "Interaction.h"
#include "boost/mp11/list.hpp"

namespace AM
{
// Note: Observed components are server-only.
namespace Server
{
/**
 * See EngineReplicatedComponentTypes.h for more info.
 */
using EngineObservedComponentTypes
    = boost::mp11::mp_list<Name, MovementModifiers, GraphicState,
                           CollisionBitSets, Interaction>;

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/TypeLists/EnginePersistedComponentTypes.h`:

```h
#pragma once

#include "SaveTimestamp.h"
#include "Name.h"
#include "Input.h"
#include "Position.h"
#include "Rotation.h"
#include "GraphicState.h"
#include "CollisionBitSets.h"
#include "Interaction.h"
#include "ItemHandler.h"
#include "Dialogue.h"
#include "EntityInitScript.h"
#include "StoredValues.h"
#include "CastCooldown.h"
#include "boost/mp11/list.hpp"

namespace AM
{
// Note: Persisted components are server-only.
namespace Server
{
/**
 * The version number of the engine's components and component list.
 *
 * If EnginePersistedComponentTypes is changed in any way, or the fields of any
 * component in the list are changed in a way that changes their serialization, 
 * you must increment this number and run a migration.
 */
static constexpr unsigned int ENGINE_COMPONENTS_VERSION{0};

/**
 * All of the engine's component types that should be saved to the database 
 * and loaded at startup.
 *
 * Note: If you change this list in any way, or change the fields of any included
 *       types in a way that breaks serialization, you must increment 
 *       ENGINE_COMPONENTS_VERSION and run a migration.
 * Note: Input implies PreviousPosition, Movement, Rotation, and 
 *       MovementModifiers (movement components).
 *       GraphicState implies Rotation, Collision, and CollisionBitSets 
 *       (graphics components).
 */
using EnginePersistedComponentTypes
    = boost::mp11::mp_list<SaveTimestamp, Name, Input, Position, Rotation,
                           GraphicState, CollisionBitSets, Interaction,
                           ItemHandler, Dialogue, EntityInitScript,
                           StoredValues, CastCooldown>;

} // End namespace Server
} // End namespace AM

```

`Source/ServerLib/Simulation/Public/World.h`:

```h
#pragma once

#include "TileMap.h"
#include "NetworkID.h"
#include "EntityLocator.h"
#include "CollisionLocator.h"
#include "EntityStoredValueID.h"
#include "EntityStoredValueIDMap.h"
#include "GlobalStoredValueMap.h"
#include "InventoryHelper.h"
#include "CastHelper.h"
#include "SpawnStrategy.h"
#include "entt/entity/registry.hpp"
#include <unordered_map>
#include <string_view>
#include <random>

namespace AM
{
class CastableData;
struct Position;
struct GraphicState;
struct EntityInitScript;
struct ItemInitScript;
struct Item;

namespace Server
{
struct SimulationContext;
class Simulation;
class Network;
class GraphicData;
class ItemData;
class Database;
struct EntityInitLua;
struct ItemInitLua;

/**
 * Owns and manages the persistence of all world state.
 *
 * The server's world state consists of:
 *   Map data
 *     See TileMap.h
 *   Entity data
 *     Maintained at runtime in an ECS registry.
 *     Eventually will be persisted in a database.
 *   Item data
 *     Stored as "item templates", modifiable at runtime.
 *     Eventually will be persisted in a database.
 *
 * Also provides helpers for common uses of world state.
 */
class World
{
public:
    World(const SimulationContext& inSimContext);

    ~World();

    //-------------------------------------------------------------------------
    // World State
    //-------------------------------------------------------------------------
    /** Entity data registry. */
    entt::registry registry;

    /** Spatial partitioning grid for efficiently locating entities by
        their position. */
    EntityLocator entityLocator;

    /** Spatial partitioning grid for efficiently locating entities and tile 
        layers by their collision volumes. */
    CollisionLocator collisionLocator;

    /** The tile map that makes up the world. */
    TileMap tileMap;

    /** Maps entity stored value string IDs -> their associated numeric ID. */
    EntityStoredValueIDMap entityStoredValueIDMap;

    /** Global key-value store.
        Note: Stored values are often cast to different types, but their 
              underlying type is always Uint32. */
    GlobalStoredValueMap globalStoredValueMap;

    /** Helper class for managing entity inventories. */
    InventoryHelper inventoryHelper;

    /** Helper class for casting Castables. */
    CastHelper castHelper;

    /** The database for saving and loading world data.
        Kept as a pointer to speed up compilation. */
    std::unique_ptr<Database> database;

    /** Maps network IDs to entity IDs.
        Used for interfacing with the Network.
        Note: To go the other way (entt::entity -> NetworkID), use 
              ClientSimData. */
    std::unordered_map<NetworkID, entt::entity> netIDMap;

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------
    /**
     * Returns the entity associated with the given network ID, or entt::null 
     * if the client doesn't exist.
     *
     * Use this instead of directly using netIDMap.
     *
     * Note: To go the other way (entt::entity -> NetworkID), use ClientSimData.
     */
    entt::entity getClientEntity(NetworkID netID);

    /**
     * Teleports the given entity to the given position.
     * @return true if successful, else false. If false, the entity will 
     *         remain at its original position.
     */
    bool teleportEntity(entt::entity entity, const Vector3& newPosition);

    /**
     * Creates an entity with the given position.
     *
     * @param entityHint (Optional) The entityID to use, if it's available.
     * @return The new entity's ID, or entt::null if a failure occurred 
     *         (position outside of tile map bounds).
     */
    entt::entity createEntity(const Position& position,
                              entt::entity entityHint = entt::null);

    /**
     * Adds the given graphical component to the entity.
     *
     * Since an entity's collision is based on its graphics, this also adds
     * the Collision component and adds the entity to the locator.
     *
     * @return true if successful, else false (the graphic's collision + entity
     *         position went outside of the tile map bounds).
     */
    bool addGraphicsComponents(entt::entity entity,
                               const GraphicState& graphicState);

    /**
     * Adds the components needed for movement to the given entity.
     */
    void addMovementComponents(entt::entity entity);

    /**
     * Runs the given init script on the given entity. If successful, adds it
     * as an EntityInitScript component.
     *
     * @return If the init script failed to run, returns a string
     *         describing the issue. Else, returns an empty string.
     */
    std::string runEntityInitScript(entt::entity entity,
                                    const EntityInitScript& initScript);

    /**
     * Runs the given init script on the given item. If successful, saves it
     * in item.initScript.
     *
     * @return If the init script failed to run, returns a string
     *         describing the issue. Else, returns an empty string.
     */
    std::string runItemInitScript(Item& item, std::string_view initScript);

    /**
     * Returns the numeric ID for the given entity stored value string ID.
     * If stringID is not present in the map, adds it and generates the next 
     * numeric ID.
     * 
     * @return If a flag with the given ID doesn't exist and the map is full, 
     *         returns null. Otherwise, returns the numeric ID.
     */
    EntityStoredValueID getEntityStoredValueID(std::string_view stringID);

    /**
     * Adds a new value, or overwrites an existing value.
     *
     * If newValue == 0 (the default value), the value will be deleted.
     *
     * Note: Stored values are often cast to different types, but their 
     *       underlying type is always Uint32.
     *
     * @param stringID The string ID of the value to add or overwrite.
     * @param newValue The new value to use.
     */
    void storeGlobalValue(std::string_view stringID, Uint32 newValue);

    /**
     * Gets a stored value.
     *
     * Note: Stored values are often cast to different types, but their 
     *       underlying type is always Uint32.
     * 
     * @param stringID The string ID of the value to get.
     * @return The requested value. If not found, returns 0 (the default value 
     *         that the value would have if it existed).
     */
    Uint32 getStoredValue(std::string_view stringID);

    /**
     * Returns the spawn point position.
     * To configure, see Server::Config.
     */
    Position getSpawnPoint();

private:
    /**
     * Returns the next spawn point, trying to build groups of 10.
     */
    Position getGroupedSpawnPoint();

    /**
     * Does any necessary cleanup to the given entity.
     */
    void onEntityDestroyed(entt::entity entity);

    /**
     * Loads our saved non-client entities and adds them to the registry.
     */
    void loadNonClientEntities();

    /**
     * Initializes any components that have lazy-updated timers.
     *
     * Note: We update them on load instead of on save, because we don't want 
     *       to add time to the save operation.
     * Note: If the project ever needs to do this same sort of thing, we can 
     *       either add a signal or an extension function.
     */
    void initTimerComponents(entt::entity entity);

    /**
     * Loads our saved items and adds them to itemData.
     */
    void loadItems(ItemData& itemData);

    /**
     * Loads our saved entity stored value IDs and global stored values.
     */
    void loadStoredValues();

    /** Used to get the current tick. */
    Simulation& simulation;

    /** Used to get graphics info. */
    const GraphicData& graphicData;

    /** Used to run entity init scripts. */
    EntityInitLua& entityInitLua;

    /** Used to run item init scripts. */
    ItemInitLua& itemInitLua;

    /** Tracks the next numeric entity stored value ID to use (typically 1 greater 
        than the highest ID in entityStoredValueIDMap). */
    Uint32 nextStoredValueID;

    /** A scratch buffer used while processing string IDs. */
    std::string workStringID;

    // For random spawn points.
    std::random_device randomDevice;
    std::mt19937 generator;
    std::uniform_real_distribution<float> xDistribution;
    std::uniform_real_distribution<float> yDistribution;

    // For grouped spawn points.
    float groupX;
    float groupY;
    unsigned int columnIndex;
    unsigned int rowIndex;
};

} // namespace Server
} // namespace AM

```

`Source/SharedLib/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

message(STATUS "Configuring Amalgam Engine Shared Library")

# Add our static library target.
add_library(SharedLib STATIC "")

# Provide an alias that can be used whether the target comes from 
# add_subdirectory() or find_package().
add_library(AmalgamEngine::SharedLib ALIAS SharedLib)

target_include_directories(SharedLib
    PUBLIC
        ${SDL2_INCLUDE_DIRS} ${SDL2_IMAGE_INCLUDE_DIRS}
)

target_link_libraries(SharedLib
    PUBLIC
        ${SDL2_LIBRARIES} ${SDL2_IMAGE_LIBRARIES}
        SDL2_net-static
        boost_mp11
        lz4_static
        libmorton::libmorton 
        EnTT::EnTT
        Bitsery::bitsery
        nlohmann_json::nlohmann_json
        Tracy::TracyClient

        # Only included for PCH.
        readerwriterqueue
        QueuedEvents
)

# Compile with C++23.
target_compile_features(SharedLib PRIVATE cxx_std_23)
set_target_properties(SharedLib PROPERTIES CXX_EXTENSIONS OFF)

# Enable compile warnings.
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    target_compile_options(SharedLib PUBLIC -Wall -Wextra)
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    target_compile_options(SharedLib PUBLIC /W3 /permissive-)
    # Temp: MSVC needs this to properly set __cplusplus, and we need it to 
    #       be > 2017 for the bitsery extension headers.
    target_compile_options(SharedLib PUBLIC "/Zc:__cplusplus")
endif()

# Build all of the subdirectories.
add_subdirectory(Messages)
add_subdirectory(Network)
add_subdirectory(Simulation)
add_subdirectory(Utility)

```

`Source/SharedLib/Messages/CMakeLists.txt`:

```txt
target_sources(SharedLib
    PUBLIC
        Public/CastCooldownInit.h
        Public/CastFailed.h
        Public/CastRequest.h
        Public/CastStarted.h
        Public/ChunkDataRequest.h
        Public/ChunkUpdate.h
        Public/ChunkWireSnapshot.h
        Public/CombineItemsRequest.h
        Public/ComponentUpdate.h
        Public/ConnectionRequest.h
        Public/ConnectionResponse.h
        Public/DialogueChoiceRequest.h
        Public/DialogueResponse.h
        Public/EngineMessageType.h
        Public/EntityDelete.h
        Public/EntityDeleteRequest.h
        Public/EntityInit.h
        Public/EntityInitRequest.h
        Public/EntityInitScriptRequest.h
        Public/EntityInitScriptResponse.h
        Public/ExplicitConfirmation.h
        Public/GraphicStateChangeRequest.h
        Public/Heartbeat.h
        Public/InputChangeRequest.h
        Public/InventoryAddItem.h
        Public/InventoryInit.h
        Public/InventoryMoveItem.h
        Public/InventoryOperation.h
        Public/InventoryRemoveItem.h
        Public/ItemError.h
        Public/ItemChangeRequest.h
        Public/ItemDataRequest.h
        Public/ItemError.h
        Public/ItemInitRequest.h
        Public/ItemInitScriptRequest.h
        Public/ItemInitScriptResponse.h
        Public/ItemUpdate.h
        Public/MovementState.h
        Public/MovementUpdate.h
        Public/SystemMessage.h
        Public/TileAddLayer.h
        Public/TileClearLayers.h
        Public/TileExtentClearLayers.h
        Public/TileRemoveLayer.h
        Public/UseItemOnEntityRequest.h
)

target_include_directories(SharedLib
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/SharedLib/Messages/Public/CastCooldownInit.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "CastCooldown.h"

namespace AM
{
/**
 * Sent by the server when a client needs their full list of cast cooldowns.
 * After the full list is sent, the client can update it locally as casts are 
 * completed.
 */
struct CastCooldownInit {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::CastCooldownInit};

    /**
     * The entity's full CastCooldown component.
     */
    CastCooldown castCooldown{};
};

template<typename S>
void serialize(S& serializer, CastCooldownInit& castCooldownInit)
{
    serializer.object(castCooldownInit.castCooldown);
}

} // namespace AM

```

`Source/SharedLib/Messages/Public/CastFailed.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "CastableID.h"
#include "CastFailureType.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"

namespace AM
{

/**
 * Sent by the server when a cast either fails to validate, or is canceled.
 */
struct CastFailed {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::CastFailed};

    /** The entity that was casting. */
    entt::entity casterEntity{entt::null};

    /** The castable that was being cast. */
    CastableID castableID{};

    /** The reason why the cast failed. */
    CastFailureType castFailureType{};
};

template<typename S>
void serialize(S& serializer, CastFailed& castFailed)
{
    serializer.value4b(castFailed.casterEntity);
    serializer.object(castFailed.castableID);
    serializer.value1b(castFailed.castFailureType);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/CastRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "NetworkID.h"
#include "CastableID.h"
#include "Vector3.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * Used to request that a castable be cast.
 */
struct CastRequest {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::CastRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The tick that this cast corresponds to. */
    Uint32 tickNum{0};

    /** The castable that's being cast. */
    CastableID castableID{};

    /** If castableID is an ItemInteractionType, this is the inventory slot of 
        the item that is being used. */
    Uint8 slotIndex{0};

    /** The target entity. If castableID is an EntityInteractionType, this 
        must always be present. Otherwise, this should be filled if the client 
        has a current target. */
    entt::entity targetEntity{entt::null};

    /** The target position. If the requested Castable has a targetToolType 
        that selects a position, this must be filled. */
    Vector3 targetPosition{};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it, so we
     * fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, CastRequest& castRequest)
{
    serializer.value4b(castRequest.tickNum);
    serializer.object(castRequest.castableID);
    serializer.value1b(castRequest.slotIndex);
    serializer.value4b(castRequest.targetEntity);
    serializer.object(castRequest.targetPosition);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/CastStarted.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "CastableID.h"
#include "Vector3.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"

namespace AM
{

/**
 * Sent by the server when a cast is started.
 */
struct CastStarted {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::CastStarted};

    /** The entity that is casting. */
    entt::entity casterEntity{entt::null};

    /** The castable that is being cast. */
    CastableID castableID{};

    // Note: We don't send the item ID because it doesn't seem like it'd ever 
    //       be useful (it's only useful to the server when handling the cast). 
    //       If a use case comes up for it, we can add it.

    /** The target entity. If castableID is an EntityInteractionType, this will
        always be present. Otherwise, this will be filled if the client has a 
        current target. */
    entt::entity targetEntity{entt::null};

    /** The target position. If the Castable has a targetToolType that selects 
        a position, this will be filled.*/
    Vector3 targetPosition{};
};

template<typename S>
void serialize(S& serializer, CastStarted& castStarted)
{
    serializer.value4b(castStarted.casterEntity);
    serializer.object(castStarted.castableID);
    serializer.value4b(castStarted.targetEntity);
    serializer.object(castStarted.targetPosition);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ChunkDataRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "ChunkPosition.h"
#include "ChunkUpdate.h"
#include "NetworkID.h"
#include <vector>

namespace AM
{
/**
 * Used by the client to request chunk data.
 */
struct ChunkDataRequest {
public:
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ChunkDataRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The chunks that the client is requesting. */
    std::vector<ChunkPosition> requestedChunks;

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, ChunkDataRequest& chunkDataRequest)
{
    serializer.container(chunkDataRequest.requestedChunks,
                         ChunkUpdate::MAX_CHUNKS);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ChunkUpdate.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "ChunkWireSnapshot.h"
#include <vector>

namespace AM
{
/**
 * Used by the server to stream chunks to a client.
 */
struct ChunkUpdate {
public:
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ChunkUpdate};

    /** Used as a "we should never hit this" cap on the number of chunks that
        we request at once. 9 is for the current chunk and all surrounding chunks 
        in the X/Y directions, 20 is a large number to cap how many levels the 
        map can have in the Z direction. */
    static constexpr std::size_t MAX_CHUNKS{9 * 20};

    /** The chunks that the client should load. */
    std::vector<ChunkWireSnapshot> chunks;
};

template<typename S>
void serialize(S& serializer, ChunkUpdate& chunkUpdate)
{
    serializer.container(chunkUpdate.chunks, ChunkUpdate::MAX_CHUNKS);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ChunkWireSnapshot.h`:

```h
#pragma once

#include "ChunkSnapshot.h"
#include "SharedConfig.h"
#include "Log.h"
#include <vector>
#include <array>

namespace AM
{
/**
 * Similar to ChunkSnapshot, but to save space uses the numeric ID of graphic 
 * in the palette instead of their string ID.
 *
 * Since the integer ID isn't persistable, this struct is only suitable for
 * sending chunk data to clients over the wire.
 */
struct ChunkWireSnapshot {
public:
    struct PaletteEntry {
        /** The numeric ID of the graphic set that this entry refers to. */
        Uint16 graphicSetID{0};

        /** The type of tile layer that this entry represents.
            Each layer type maps directly to a single graphic set type. */
        TileLayer::Type layerType{TileLayer::Type::None};

        /** The layer's graphic value.
            For all types except Terrain, this is simply an index into 
            graphicSet.graphics. For Terrain, this is a bit-packed value.
            For Terrain, cast this to Terrain::Value. For Walls, cast this to 
            Wall::Type. For Floors and Objects, cast this to 
            Rotation::Direction. */
        Uint8 graphicValue{0};
    };

    /** This chunk's X-axis coordinate. */
    Sint16 x{0};

    /** This chunk's Y-axis coordinate. */
    Sint16 y{0};

    /** This chunk's Z-axis coordinate. */
    Sint16 z{0};

    /** Holds an entry for each graphic used in this chunk's tiles. Part of a
        space-saving approach that lets TileSnapshot hold indices into this
        palette instead of directly holding the data. */
    std::vector<PaletteEntry> palette{};

    /** The number of layers that each tile in this chunk has, stored in row-
        major order. */
    std::array<Uint8, SharedConfig::CHUNK_TILE_COUNT> tileLayerCounts{};

    /** This vector's elements are indices into the palette, each index  
        representing a tile layer that is owned by a tile in this chunk.
        These layers are ordered by tile coordinate in morton order, and by 
        the usual bottom-to-top type order within each tile.
        To iterate, use tileLayerCounts to determine how many layers belong to 
        each tile. */
    std::vector<Uint8> tileLayers{};

    /** The tile offset for each Floor and Object tile layer in tileLayers, 
        stored in the order that they'll be encountered while iterating. */
    std::vector<TileOffset> tileOffsets{};

    /**
     * Returns the palette index for the given palette entry info.
     * If the palette doesn't have a matching entry, it will be added.
     */
    std::size_t getPaletteIndex(TileLayer::Type tileLayerType,
                                Uint16 graphicSetID, Uint8 graphicValue)
    {
        // TODO: If this gets to be a performance issue, we can look into
        //       switching palette to a map. Serialization will be more
        //       complicated, though.
        // Check if we already have this ID.
        for (std::size_t i = 0; i < palette.size(); ++i) {
            if ((palette[i].layerType == tileLayerType)
                && (palette[i].graphicSetID == graphicSetID)
                && (palette[i].graphicValue == graphicValue)) {
                // We already have the string, returns its index.
                return i;
            }
        }

        // We didn't have a matching entry, add it.
        if (palette.size() < UINT8_MAX) {
            palette.emplace_back(graphicSetID, tileLayerType, graphicValue);
        }
        else {
            // TODO: If this becomes an issue, either switch to Uint16 or
            //       find some more efficient way to grow the space.
            LOG_ERROR("Ran out of palette slots.");
            return 0;
        }
        return (palette.size() - 1);
    }
};

template<typename S>
void serialize(S& serializer, ChunkWireSnapshot::PaletteEntry& paletteEntry)
{
    serializer.value2b(paletteEntry.graphicSetID);
    serializer.value1b(paletteEntry.layerType);
    serializer.value1b(paletteEntry.graphicValue);
}

template<typename S>
void serialize(S& serializer, ChunkWireSnapshot& chunkSnapshot)
{
    serializer.value2b(chunkSnapshot.x);
    serializer.value2b(chunkSnapshot.y);
    serializer.value2b(chunkSnapshot.z);
    serializer.container(chunkSnapshot.palette,
                         ChunkSnapshot::MAX_PALETTE_ENTRIES);
    serializer.container1b(chunkSnapshot.tileLayerCounts);
    serializer.container1b(chunkSnapshot.tileLayers,
                           ChunkSnapshot::MAX_TILE_LAYERS);
    serializer.container(chunkSnapshot.tileOffsets,
                         ChunkSnapshot::MAX_TILE_LAYERS);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/CombineItems.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "ItemID.h"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * Sent by the server to tell a client that items in their inventory were
 * combined.
 */
struct CombineItems {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::CombineItems};

    /** The inventory slot of the item that is being used. */
    Uint8 sourceSlotIndex{0};

    /** The inventory slot of the target item. */
    Uint8 targetSlotIndex{0};

    /** The resulting item. */
    ItemID resultItemID{NULL_ITEM_ID};

    /** How large a stack of the resulting item can be.
        This value is available in the item's definition, but we have to send 
        it here because the client may not yet have the definition.
        When sent by the client, this field is ignored. */
    Uint8 resultItemMaxStackSize{1};

    /** The resulting item's version number. Used by the client to tell if it
        already has the latest definition for this item, or if it needs
        to request it. */
    ItemVersion resultItemVersion{0};
};

template<typename S>
void serialize(S& serializer, CombineItems& combineItems)
{
    serializer.value1b(combineItems.sourceSlotIndex);
    serializer.value1b(combineItems.targetSlotIndex);
    serializer.value2b(combineItems.resultItemID);
    serializer.value1b(combineItems.resultItemMaxStackSize);
    serializer.value2b(combineItems.resultItemVersion);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/CombineItemsRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "NetworkID.h"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * Sent by a client to request that two items in a player's inventory be
 * combined.
 */
struct CombineItemsRequest {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::CombineItemsRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    // Note: We don't include a tick number in our interaction requests, because
    //       there isn't anything that a client would want to sync the
    //       interaction with. NPC state is in the past, and the client entity's
    //       predicted state (e.g. position) wouldn't be useful to sync to.

    /** The inventory slot of the item that is being used. */
    Uint8 sourceSlotIndex{0};

    /** The inventory slot of the target item. */
    Uint8 targetSlotIndex{0};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it, so we
     * fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, CombineItemsRequest& combineItemsRequest)
{
    serializer.value1b(combineItemsRequest.sourceSlotIndex);
    serializer.value1b(combineItemsRequest.targetSlotIndex);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ComponentUpdate.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "ReplicatedComponent.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include "bitsery/ext/std_variant.h"
#include "boost/mp11/algorithm.hpp"

namespace AM
{
/**
 * Sent by the server when a nearby entity's components are updated.
 */
struct ComponentUpdate {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ComponentUpdate};

    /** The tick that this update corresponds to. */
    Uint32 tickNum{0};

    /** The entity's ID. */
    entt::entity entity{entt::null};

    /** The entity's constructed or updated components (we treat them the 
        same). */
    std::vector<ReplicatedComponent> updatedComponents{};

    /** The indices (from ReplicatedComponentTypes) of any of the entity's 
        components that were destroyed. */
    std::vector<Uint8> destroyedComponents{};
};

template<typename S>
void serialize(S& serializer, ComponentUpdate& componentUpdate)
{
    serializer.value4b(componentUpdate.tickNum);
    serializer.value4b(componentUpdate.entity);
    serializer.enableBitPacking([&](typename S::BPEnabledType& sbp) {
        sbp.container(componentUpdate.updatedComponents,
                      boost::mp11::mp_size<ReplicatedComponentTypes>::value,
                      [](typename S::BPEnabledType& serializer,
                         ReplicatedComponent& component) {
                          // Note: This calls serialize() for each type.
                          serializer.ext(component, bitsery::ext::StdVariant{});
                      });
    });
    serializer.container1b(
        componentUpdate.destroyedComponents,
        boost::mp11::mp_size<ReplicatedComponentTypes>::value);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ConnectionRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include <string>

namespace AM
{
/**
 * Contains a connection response, sent from the server to the client.
 */
struct ConnectionRequest {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ConnectionRequest};

    /** Used as a "we should never hit this" cap on the size of each name
        string. */
    static constexpr std::size_t MAX_NAME_LENGTH{50};

    // Note: This will eventually change to login credentials and will be sent
    //       to the login server instead of the simulation server.
    /** The name of this player. */
    std::string playerName{""};
};

template<typename S>
void serialize(S& serializer, ConnectionRequest& connectionResponse)
{
    serializer.text1b(connectionResponse.playerName,
                      ConnectionRequest::MAX_NAME_LENGTH);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ConnectionResponse.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "entt/entity/registry.hpp"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Contains a connection response, sent from the server to the client.
 */
struct ConnectionResponse {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ConnectionResponse};

    /** The tick that the server is telling the client to assume. */
    Uint32 tickNum{0};

    /** The sim ID that the server has assigned to this client's player entity.
     */
    entt::entity entity{entt::null};

    /** The length, in chunks, of the tile map's X axis. */
    Uint16 mapXLengthChunks{0};

    /** The length, in chunks, of the tile map's Y axis. */
    Uint16 mapYLengthChunks{0};

    /** The length, in chunks, of the tile map's Z axis. */
    Uint16 mapZLengthChunks{0};
};

template<typename S>
void serialize(S& serializer, ConnectionResponse& connectionResponse)
{
    serializer.value4b(connectionResponse.tickNum);
    serializer.value4b(connectionResponse.entity);
    serializer.value2b(connectionResponse.mapXLengthChunks);
    serializer.value2b(connectionResponse.mapYLengthChunks);
    serializer.value2b(connectionResponse.mapZLengthChunks);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/DialogueChoiceRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "NetworkID.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * Sent by a client to request that a dialogue choice be selected.
 */
struct DialogueChoiceRequest {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::DialogueChoiceRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The entity that the client is talking to. */
    entt::entity targetEntity{entt::null};

    /** The index of the desired topic within the entity's Dialogue::topics. */
    Uint8 topicIndex{0};

    /** The index of the desired choice within the topic's Topic::choices. */
    Uint8 choiceIndex{0};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /** The network ID of the client that sent this message.
        Set by the server.
        No IDs are accepted from the client because we can't trust it, so we
        fill in the ID based on which socket the message came from. */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, DialogueChoiceRequest& dialogueChoiceRequest)
{
    serializer.value4b(dialogueChoiceRequest.targetEntity);
    serializer.value1b(dialogueChoiceRequest.topicIndex);
    serializer.value1b(dialogueChoiceRequest.choiceIndex);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/DialogueResponse.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "DialogueEvent.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include "bitsery/ext/std_variant.h"
#include <SDL_stdinc.h>
#include <vector>
#include <string>

namespace AM
{

/**
 * Sent by the server in response to a Talk interaction or a dialogue choice 
 * selection.
 * 
 * Contains the response dialogue and choices that should be displayed to the 
 * client.
 */
struct DialogueResponse {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::DialogueResponse};

    /** Used as a "we should never hit this" cap on the container lengths. */
    static constexpr std::size_t MAX_DIALOGUE_EVENTS{200};
    static constexpr std::size_t MAX_CHOICES{50};
    static constexpr std::size_t MAX_CHOICE_TEXT_LENGTH{500};

    /** The entity that is talking (i.e. the entity that was interacted with). */
    entt::entity entity{entt::null};

    /** The index of this topic within the entity's Dialogue::topics. */
    Uint8 topicIndex{0};

    /** The dialogue events that comprise both the response to the previously 
        selected choice (if there was one), and the current topic. */
    std::vector<DialogueEvent> dialogueEvents{};

    struct Choice {
        /** This choice's index within the topic's Topic::Choices. */
        Uint8 index{0};
        /** The text to display for this choice. */
        std::string displayText{};
    };
    /** The available dialogue choices. */
    std::vector<Choice> choices{};
};

template<typename S>
void serialize(S& serializer, DialogueResponse::Choice& choice)
{
    serializer.value1b(choice.index);
    serializer.text1b(choice.displayText,
                      DialogueResponse::MAX_CHOICE_TEXT_LENGTH);
}

template<typename S>
void serialize(S& serializer, DialogueResponse& dialogueResponse)
{
    serializer.value4b(dialogueResponse.entity);
    serializer.value1b(dialogueResponse.topicIndex);
    serializer.container(
        dialogueResponse.dialogueEvents,
        DialogueResponse::MAX_DIALOGUE_EVENTS,
        [](S& serializer, DialogueEvent& event) {
            // Note: This calls serialize() for each type.
            serializer.ext(event, bitsery::ext::StdVariant{});
        });
    serializer.container(dialogueResponse.choices,
                         DialogueResponse::MAX_CHOICES);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/EngineMessageType.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/**
 * The types of messages that we send across the network.
 *
 * For message descriptions, see their definitions in Shared/Messages/Public.
 */
enum class EngineMessageType : Uint8 {
    /** Indicates the value hasn't been set. Used for initialization. */
    NotSet,

    // Client -> Server Messages
    Heartbeat,
    ConnectionRequest,
    InputChangeRequest,
    EntityNameChangeRequest,
    GraphicStateChangeRequest,
    ChunkDataRequest,
    EntityInitRequest,
    EntityDeleteRequest,
    EntityInitScriptRequest,
    ItemInitRequest,
    ItemChangeRequest,
    ItemDataRequest,
    ItemInitScriptRequest,
    CombineItemsRequest,
    UseItemOnEntityRequest,
    DialogueChoiceRequest,
    CastRequest,

    // Server -> Client Messages
    ExplicitConfirmation,
    ConnectionResponse,
    SystemMessage,
    EntityInit,
    EntityDelete,
    EntityInitScriptResponse,
    MovementUpdate,
    ComponentUpdate,
    ChunkUpdate,
    InventoryInit,
    CastCooldownInit,
    ItemError,
    ItemUpdate,
    ItemInitScriptResponse,
    CombineItems,
    DialogueResponse,
    CastFailed,
    CastStarted,

    // Bidirectional Messages
    TileAddLayer,
    TileRemoveLayer,
    TileClearLayers,
    TileExtentClearLayers,
    InventoryOperation,

    // We reserve values 0 - 124. The project can start at 125.
    PROJECT_START = 125
};

} // End namespace AM

```

`Source/SharedLib/Messages/Public/EntityDelete.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"

namespace AM
{
/**
 * Used to request that an entity be deleted, or to inform a client that an
 * entity was deleted.
 */
struct EntityDelete {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::EntityDelete};

    /** The tick that this update corresponds to. */
    Uint32 tickNum{0};

    /** The entity that must be deleted. */
    entt::entity entity{entt::null};
};

template<typename S>
void serialize(S& serializer, EntityDelete& entityDelete)
{
    serializer.value4b(entityDelete.tickNum);
    serializer.value4b(entityDelete.entity);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/EntityDeleteRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "NetworkID.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Sent by the client to request that an entity be deleted.
 */
struct EntityDeleteRequest {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::EntityDeleteRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The entity to delete. */
    entt::entity entity{entt::null};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, EntityDeleteRequest& entityDeleteRequest)
{
    serializer.value4b(entityDeleteRequest.entity);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/EntityInit.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "Position.h"
#include "ReplicatedComponent.h"
#include "SharedConfig.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include "bitsery/ext/std_variant.h"
#include "boost/mp11/algorithm.hpp"
#include <SDL_stdinc.h>
#include <vector>

namespace AM
{

/**
 * Sent by the server when an entity enters a client's area of interest.
 *
 * Contains all entities that entered the client's AOI on a single sim tick.
 *
 * Each client is only sent the state of entities that are in their area of
 * interest.
 */
struct EntityInit {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::EntityInit};

    /** The tick that this update corresponds to. */
    Uint32 tickNum{0};

    struct EntityData {
        /** This entity's ID. */
        entt::entity entity{entt::null};

        /** This entity's Position. */
        Position position{};

        /** This entity's optional client-relevant components. */
        std::vector<ReplicatedComponent> components{};
    };

    /** The component state of all entities that entered this client's AOI on
        this tick. */
    std::vector<EntityData> entityData{};
};

template<typename S>
void serialize(S& serializer, EntityInit::EntityData& entityData)
{
    serializer.value4b(entityData.entity);
    serializer.object(entityData.position);
    serializer.enableBitPacking([&](typename S::BPEnabledType& sbp) {
        sbp.container(entityData.components,
                      boost::mp11::mp_size<ReplicatedComponentTypes>::value,
                      [](typename S::BPEnabledType& serializer,
                         ReplicatedComponent& component) {
                          // Note: This calls serialize() for each type.
                          serializer.ext(component, bitsery::ext::StdVariant{});
                      });
    });
}

template<typename S>
void serialize(S& serializer, EntityInit& entityInit)
{
    serializer.value4b(entityInit.tickNum);
    serializer.container(entityInit.entityData, SharedConfig::MAX_ENTITIES);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/EntityInitRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "Name.h"
#include "Position.h"
#include "Rotation.h"
#include "GraphicState.h"
#include "EntityInitScript.h"
#include "NetworkID.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"

namespace AM
{
/**
 * Sent by the client to request that a new entity be created, or to
 * request that an existing entity be re-initialized with new data.
 */
struct EntityInitRequest {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::EntityInitRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** If non-null, this message is a request to re-init this entity. If null,
        this message is a request to create a new entity. */
    entt::entity entity{entt::null};

    /** The entity's components. */
    Name name{};
    Position position{};
    Rotation rotation{};
    GraphicState graphicState{};

    /** The script to run on this entity after creation. */
    EntityInitScript initScript{};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, EntityInitRequest& entityInitRequest)
{
    serializer.value4b(entityInitRequest.entity);
    serializer.object(entityInitRequest.name);
    serializer.object(entityInitRequest.position);
    serializer.object(entityInitRequest.rotation);
    serializer.object(entityInitRequest.graphicState);
    serializer.object(entityInitRequest.initScript);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/EntityInitScriptRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "NetworkID.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"

namespace AM
{

/**
 * Used to request an entity's init script from the server.
 *
 * Init scripts are only requested by clients for use in build mode. Only the
 * server actually runs the scripts.
 */
struct EntityInitScriptRequest {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::EntityInitScriptRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The ID of the entity to get the init script for. */
    entt::entity entity{entt::null};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, EntityInitScriptRequest& initScriptRequest)
{
    serializer.value4b(initScriptRequest.entity);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/EntityInitScriptResponse.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "NetworkID.h"
#include "EntityInitScript.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include <string>

namespace AM
{

/**
 * Used to send an entity's init script to a client.
 *
 * Init scripts are only requested by clients for use in build mode. Only the
 * server actually runs the scripts.
 *
 * Note: This is named "Response" to differentiate it from the EntityInitScript
 *       component. Normally we don't append "Response" to response messages.
 */
struct EntityInitScriptResponse {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::EntityInitScriptResponse};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The ID of the entity that this init script is for. */
    entt::entity entity{entt::null};

    /** This entity's init script. */
    EntityInitScript initScript{};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, EntityInitScriptResponse& initScriptResponse)
{
    serializer.value4b(initScriptResponse.entity);
    serializer.object(initScriptResponse.initScript);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/EntityNameChangeRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "Name.h"
#include "NetworkID.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Used by clients to request name changes on the server.
 */
struct EntityNameChangeRequest {
    // The enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::EntityNameChangeRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The entity to change the name of. */
    entt::entity entity{entt::null};

    /** The new name. */
    Name name{};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, EntityNameChangeRequest& entityNameChangeRequest)
{
    serializer.value4b(entityNameChangeRequest.entity);
    serializer.object(entityNameChangeRequest.name);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ExplicitConfirmation.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * An explicit confirmation that ticks have passed.
 *
 * Sent from Server -> Client when a tick passes with no entity movement
 * updates. The client needs these confirmations before it can progress
 * NPC movement forward.
 */
struct ExplicitConfirmation {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ExplicitConfirmation};

    Uint8 confirmedTickCount{0};
};

template<typename S>
void serialize(S& serializer, ExplicitConfirmation& explicitConfirmation)
{
    serializer.value1b(explicitConfirmation.confirmedTickCount);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/GraphicStateChangeRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "GraphicState.h"
#include "NetworkID.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Used by clients to request graphic state changes on the server.
 */
struct GraphicStateChangeRequest {
    // The enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::GraphicStateChangeRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The entity to change the graphic state of. */
    entt::entity entity{entt::null};

    /** The new graphic state. */
    GraphicState graphicState;

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer,
               GraphicStateChangeRequest& graphicStateChangeRequest)
{
    serializer.value4b(graphicStateChangeRequest.entity);
    serializer.object(graphicStateChangeRequest.graphicState);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/Heartbeat.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * A heartbeat is sent from either side to show that a tick was processed but
 * no data needed to be sent.
 */
struct Heartbeat {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::Heartbeat};

    /** The tick that this heartbeat was processed on. */
    Uint32 tickNum{0};
};

template<typename S>
void serialize(S& serializer, Heartbeat& heartbeat)
{
    serializer.value4b(heartbeat.tickNum);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/InputChangeRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "Input.h"
#include "NetworkID.h"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Contains a client's input state on a given tick.
 *
 * Used by clients to request input changes on the server.
 */
struct InputChangeRequest {
    // The enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::InputChangeRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The tick that these client input states correspond to. */
    Uint32 tickNum{0};

    // Note: No entity ID, because clients can only change their own inputs.

    /** The client's input state for the given tickNum. */
    Input input;

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, InputChangeRequest& inputChangeRequest)
{
    serializer.value4b(inputChangeRequest.tickNum);

    serializer.enableBitPacking(
        [&inputChangeRequest](typename S::BPEnabledType& sbp) {
            sbp.object(inputChangeRequest.input);
        });
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/InventoryAddItem.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "ItemID.h"
#include "NetworkDefs.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Sent by a client to request that an item be added to an inventory, or by the
 * server to tell a client that an item was added.
 */
struct InventoryAddItem {
    /** The entity to add the item to.
        When sent by the server, this can be ignored and assumed to be the
        client entity (clients are only sent updates for their own inventory).
     */
    entt::entity entity{entt::null};

    /** The item to add. */
    ItemID itemID{NULL_ITEM_ID};

    /** How many of the item to add. */
    Uint8 count{0};

    /** How large a stack of this item can be.
        This value is available in the item's definition, but we have to send 
        it here because the client may not yet have the definition.
        When sent by the client, this field is ignored. */
    Uint8 maxStackSize{1};

    /** The item's version number. Used by the client to tell if it
        already has the latest definition for this item, or if it needs
        to request it.
        When sent by the client, this field is ignored. */
    ItemVersion version{0};
};

template<typename S>
void serialize(S& serializer, InventoryAddItem& inventoryAddItem)
{
    serializer.value4b(inventoryAddItem.entity);
    serializer.value2b(inventoryAddItem.itemID);
    serializer.value1b(inventoryAddItem.count);
    serializer.value1b(inventoryAddItem.maxStackSize);
    serializer.value2b(inventoryAddItem.version);
}

} // namespace AM

```

`Source/SharedLib/Messages/Public/InventoryInit.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "Inventory.h"
#include "ItemID.h"
#include <SDL_stdinc.h>
#include <vector>

namespace AM
{
/**
 * Sent by the server when a client needs their full inventory.
 * After the full inventory is sent, we can send smaller update messages as 
 * items are added, moved, and removed.
 *
 * Note: This is currently only used for player inventories. If we reuse it for
 *       NPC inventories, we can add an entity ID field.
 */
struct InventoryInit {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::InventoryInit};

    struct ItemSlot {
        /** The item in this inventory slot. */
        ItemID ID{NULL_ITEM_ID};

        /** How many of the item is in this inventory slot. */
        Uint8 count{0};

        /** The item's version number. Used by the client to tell if it
            already has the latest definition for this item, or if it needs
            to request it. */
        ItemVersion version{0};
    };

    /** The number of slots in the inventory. */
    Uint8 size{Inventory::DEFAULT_INVENTORY_SIZE};

    /** The inventory's item slots. */
    std::vector<ItemSlot> slots{};
};

template<typename S>
void serialize(S& serializer, InventoryInit::ItemSlot& itemSlot)
{
    serializer.value2b(itemSlot.ID);
    serializer.value1b(itemSlot.count);
    serializer.value2b(itemSlot.version);
}

template<typename S>
void serialize(S& serializer, InventoryInit& inventoryInit)
{
    serializer.value1b(inventoryInit.size);
    serializer.container(inventoryInit.slots, Inventory::MAX_ITEMS);
}

} // namespace AM

```

`Source/SharedLib/Messages/Public/InventoryMoveItem.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "NetworkDefs.h"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Sent by a client to request that an item be moved to a different slot in
 * their inventory, or by the server to tell a client that an item was moved.
 *
 * Moving an item into an occupied slot swaps its position with the other item.
 */
struct InventoryMoveItem {
    /** The inventory slot of the item to move. */
    Uint8 sourceSlotIndex{0};

    /** The inventory slot to move the item into (destination). */
    Uint8 destSlotIndex{0};
};

template<typename S>
void serialize(S& serializer, InventoryMoveItem& inventoryMoveItem)
{
    serializer.value1b(inventoryMoveItem.sourceSlotIndex);
    serializer.value1b(inventoryMoveItem.destSlotIndex);
}

} // namespace AM

```

`Source/SharedLib/Messages/Public/InventoryOperation.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "InventoryAddItem.h"
#include "InventoryRemoveItem.h"
#include "InventoryMoveItem.h"
#include "NetworkID.h"
#include "bitsery/ext/std_variant.h"
#include <variant>

namespace AM
{
/**
 * Sent by a client to request that an inventory operation be performed, or by
 * the server to tell a client that an operation was performed.
 *
 * Note: We combine all of these into a single message so that they get
 *       sequenced correctly (since we use per-message queues, relative
 *       ordering may be lost).
 *       If this continues to be a problem, we may want to consider switching
 *       to a messaging architecture that preserves ordering.
 */
struct InventoryOperation {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::InventoryOperation};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    using OperationVariant = std::variant<InventoryAddItem, InventoryRemoveItem,
                                          InventoryMoveItem>;
    OperationVariant operation{};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, InventoryOperation& inventoryOperation)
{
    // Note: This calls serialize() for each type.
    serializer.ext(inventoryOperation.operation, bitsery::ext::StdVariant{});
}

} // namespace AM

```

`Source/SharedLib/Messages/Public/InventoryRemoveItem.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "ItemID.h"
#include "NetworkDefs.h"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Sent by a client to request that an item be removed from an inventory, or by
 * the server to tell a client that an item was removed.
 *
 * Note: This is currently only used for player inventories. If we reuse it for
 *       NPC inventories, we can add an entity ID field.
 */
struct InventoryRemoveItem {
    /** The inventory slot to remove the item from. */
    Uint8 slotIndex{0};

    /** How many of the item to delete. */
    Uint8 count{0};
};

template<typename S>
void serialize(S& serializer, InventoryRemoveItem& inventoryRemoveItem)
{
    serializer.value1b(inventoryRemoveItem.slotIndex);
    serializer.value1b(inventoryRemoveItem.count);
}

} // namespace AM

```

`Source/SharedLib/Messages/Public/ItemChangeRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "ItemID.h"
#include "IconID.h"
#include "ItemInitScript.h"
#include "Item.h"
#include "NetworkID.h"
#include <string>

namespace AM
{
/**
 * Sent by the client to request that an existing item be re-initialized with
 * new data.
 */
struct ItemChangeRequest {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ItemChangeRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The ID of the item to change. */
    ItemID itemID{NULL_ITEM_ID};

    /** The item's display name. Not guaranteed to be unique. Shown in the UI. */
    std::string displayName{"Null"};

    /** The item's unique string ID.  */
    std::string stringID{""};

    /** The ID of this item's icon. */
    IconID iconID{NULL_ICON_ID};

    /** The script to run on this item after creation. */
    ItemInitScript initScript{};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, ItemChangeRequest& itemChangeRequest)
{
    serializer.value2b(itemChangeRequest.itemID);
    serializer.text1b(itemChangeRequest.displayName,
                      Item::MAX_DISPLAY_NAME_LENGTH);
    serializer.text1b(itemChangeRequest.stringID, Item::MAX_STRING_ID_LENGTH);
    serializer.value2b(itemChangeRequest.iconID);
    serializer.object(itemChangeRequest.initScript);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ItemDataRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "ItemID.h"
#include "Item.h"
#include "NetworkDefs.h"
#include "bitsery/ext/std_variant.h"
#include <variant>
#include <string>

namespace AM
{

/**
 * Used to request an item's current state from the server.
 */
struct ItemDataRequest {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ItemDataRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The stringID or numericID of the item definition that this client is
        requesting. */
    std::variant<std::string, ItemID> itemID{};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, ItemDataRequest& itemDataRequest)
{
    serializer.ext(itemDataRequest.itemID,
                   bitsery::ext::StdVariant{
                       [](S& serializer, std::string& stringID) {
                           serializer.text1b(stringID,
                                             Item::MAX_DISPLAY_NAME_LENGTH);
                       },
                       [](S& serializer, ItemID& numericID) {
                           serializer.value2b(numericID);
                       }});
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ItemError.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "Item.h"
#include <string>
#include <SDL_stdinc.h>

namespace AM
{

/**
 * Used by the server to tell a client that an error occurred during a requested
 * item operation.
 */
struct ItemError {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ItemError};

    enum Type : Uint8 {
        NotSet,
        /** The requested item numeric ID was not found. */
        NumericIDNotFound,
        /** The requested item string ID was not found. */
        StringIDNotFound,
        /** A string ID wasn't supplied in the request message. */
        StringIDMissing,
        /** Init or change request failed because given string ID is already 
            in use. */
        StringIDInUse,
        /** The requester lacks permissions to make the requested change. */
        PermissionFailure,
        /** The given init script failed to execute. */
        InitScriptFailure,
    };

    /** The display name of the relevant item, if it has one. */
    std::string displayName{"Null"};

    /** The string ID of the relevant item, if it has one. */
    std::string stringID{"null"};

    /** The numeric ID of the relevant item, if it has one. */
    ItemID numericID{NULL_ITEM_ID};

    /** The type of error that occurred. */
    Type errorType{};
};

template<typename S>
void serialize(S& serializer, ItemError& itemError)
{
    serializer.text1b(itemError.displayName, Item::MAX_DISPLAY_NAME_LENGTH);
    serializer.text1b(itemError.stringID, Item::MAX_DISPLAY_NAME_LENGTH);
    serializer.value2b(itemError.numericID);
    serializer.value1b(itemError.errorType);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ItemInitRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "ItemID.h"
#include "IconID.h"
#include "ItemInitScript.h"
#include "Item.h"
#include "NetworkDefs.h"
#include <string>

namespace AM
{
/**
 * Sent by the client to request that a new item be created.
 */
struct ItemInitRequest {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ItemInitRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The item's display name. Not guaranteed to be unique. Shown in the UI. */
    std::string displayName{"Null"};

    /** The item's unique string ID.  */
    std::string stringID{""};

    /** The ID of this item's icon. */
    IconID iconID{NULL_ICON_ID};

    /** The script to run on this item after creation. */
    ItemInitScript initScript{};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, ItemInitRequest& itemInitRequest)
{
    serializer.text1b(itemInitRequest.displayName,
                      Item::MAX_DISPLAY_NAME_LENGTH);
    serializer.text1b(itemInitRequest.stringID, Item::MAX_STRING_ID_LENGTH);
    serializer.value2b(itemInitRequest.iconID);
    serializer.object(itemInitRequest.initScript);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ItemInitScriptRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "NetworkID.h"
#include "ItemID.h"

namespace AM
{

/**
 * Used to request an item's init script from the server.
 *
 * Init scripts are only requested by clients for use in build mode. Only the
 * server actually runs the scripts.
 */
struct ItemInitScriptRequest {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ItemInitScriptRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The ID of the item to get the init script for. */
    ItemID itemID{NULL_ITEM_ID};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, ItemInitScriptRequest& initScriptRequest)
{
    serializer.value2b(initScriptRequest.itemID);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ItemInitScriptResponse.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "NetworkID.h"
#include "ItemInitScript.h"
#include "ItemID.h"
#include <string>

namespace AM
{

/**
 * Used to send an entity's init script to a client.
 *
 * Init scripts are only requested by clients for use in build mode. Only the
 * server actually runs the scripts.
 *
 * Note: This is named "Response" to differentiate it from the ItemInitScript
 *       class. Normally we don't append "Response" to message names.
 */
struct ItemInitScriptResponse {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ItemInitScriptResponse};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The ID of the item that this init script is for. */
    ItemID itemID{NULL_ITEM_ID};

    /** This item's init script. */
    ItemInitScript initScript{};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, ItemInitScriptResponse& initScriptResponse)
{
    serializer.value2b(initScriptResponse.itemID);
    serializer.object(initScriptResponse.initScript);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/ItemUpdate.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "Item.h"
#include "SharedConfig.h"

namespace AM
{

/**
 * Used by the server to send up-to-date item definitions to the client.
 *
 * Contains only the fields from the Item class that are relevant to clients.
 */
struct ItemUpdate {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::ItemUpdate};

    // Note: See Item.h for more info on all of these.

    /** The item's display name. Not guaranteed to be unique. Shown in the UI. */
    std::string displayName{"Null"};

    /** The item's unique string ID.  */
    std::string stringID{"null"};

    /** This item's unique numeric identifier. */
    ItemID numericID{NULL_ITEM_ID};

    /** The ID of this item's icon. */
    IconID iconID{NULL_ICON_ID};

    /** How large a stack of this item can be, e.g. in an inventory slot. */
    Uint8 maxStackSize{1};

    /** The custom interactions that this item supports.
        The first interaction in this list is the default interaction.
        Built-in interactions aren't present in this vector, and will instead 
        be added by the UI. */
    std::vector<ItemInteractionType> supportedInteractions{};

    /** The item's current version number. */
    ItemVersion version{};
};

template<typename S>
void serialize(S& serializer, ItemUpdate& itemUpdate)
{
    serializer.text1b(itemUpdate.displayName, Item::MAX_DISPLAY_NAME_LENGTH);
    serializer.text1b(itemUpdate.stringID, Item::MAX_STRING_ID_LENGTH);
    serializer.value2b(itemUpdate.numericID);
    serializer.value2b(itemUpdate.iconID);
    serializer.value1b(itemUpdate.maxStackSize);
    serializer.container1b(itemUpdate.supportedInteractions,
                           SharedConfig::MAX_ITEM_CUSTOM_INTERACTIONS);
    serializer.value2b(itemUpdate.version);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/MovementState.h`:

```h
#pragma once

#include "Input.h"
#include "Position.h"
#include "Movement.h"
#include "MovementModifiers.h"
#include "entt/entity/registry.hpp"

namespace AM
{
/**
 * Contains movement state data for a single entity.
 *
 * Used for sending movement state updates to clients.
 */
struct MovementState {
    /** The entity that this state belongs to. */
    entt::entity entity{entt::null};

    Input input{};
    Position position{};
    Movement movement{};
    MovementModifiers movementMods{};

    // Note: Rotation is calculated client-side.
};

template<typename S>
void serialize(S& serializer, MovementState& movementState)
{
    serializer.value4b(movementState.entity);
    serializer.object(movementState.input);
    serializer.object(movementState.position);
    serializer.object(movementState.movement);
    serializer.object(movementState.movementMods);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/MovementUpdate.h`:

```h
#pragma once

#include "MovementState.h"
#include "EngineMessageType.h"
#include "SharedConfig.h"
#include <SDL_stdinc.h>
#include <vector>

namespace AM
{
/**
 * Sent by the server when an entity moves and must have its state updated.
 *
 * Contains all updated entity movement state for a single sim tick.
 *
 * Each client is only sent the state of entities that are in their area of
 * interest.
 */
struct MovementUpdate {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::MovementUpdate};

    /** The tick that this update corresponds to. */
    Uint32 tickNum{0};

    /** The new state of all relevant entities that updated on this tick. */
    std::vector<MovementState> movementStates{};
};

template<typename S>
void serialize(S& serializer, MovementUpdate& movementUpdate)
{
    serializer.value4b(movementUpdate.tickNum);
    serializer.container(movementUpdate.movementStates,
                         SharedConfig::MAX_ENTITIES);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/SystemMessage.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include <string>

namespace AM
{
/**
 * A message sent by the server, intended to show up in a client's chat window.
 *
 * Used for various things, such as to tell a player "You must be closer to do
 * that." when they try to interact with something.
 */
struct SystemMessage {
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::SystemMessage};

    /** Used as a "we should never hit this" cap on the length of the error
        string. */
    static constexpr std::size_t MAX_LENGTH{500};

    /** The message string to display to the user. */
    std::string messageString{};
};

template<typename S>
void serialize(S& serializer, SystemMessage& systemMessage)
{
    serializer.text1b(systemMessage.messageString, SystemMessage::MAX_LENGTH);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/TileAddLayer.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "TilePosition.h"
#include "TileOffset.h"
#include "TileLayer.h"
#include "NetworkID.h"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Sent by a client to request that a layer be added to a tile, or by the server
 * to tell a client that a layer was added.
 */
struct TileAddLayer {
public:
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::TileAddLayer};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The position of the tile to update. */
    TilePosition tilePosition{};

    /** If type == Floor or Object, this is how far the layer should be offset 
        from tilePosition.
        Note: Terrain and Walls don't use this. Terrain is always aligned to 
              the tile, and Walls always match the Terrain height. */
    TileOffset tileOffset{};

    /** The type of tile layer that should be added. */
    TileLayer::Type layerType{TileLayer::Type::None};

    /** The numeric ID of the graphic set that the new layer should use.
        If the type is Floor, the existing floor will be overwritten. */
    Uint16 graphicSetID{0};

    /** The graphic value that the new layer should use.
        For all types except Terrain, this is simply an index into 
        graphicSet.graphics. For Terrain, this is a bit-packed value.
        For Terrain, cast this to Terrain::Value. For Walls, cast this to 
        Wall::Type. For Floors and Objects, cast this to Rotation::Direction. */
    Uint8 graphicValue{0};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, TileAddLayer& tileAddLayer)
{
    serializer.object(tileAddLayer.tilePosition);
    serializer.object(tileAddLayer.tileOffset);
    serializer.value1b(tileAddLayer.layerType);
    serializer.value2b(tileAddLayer.graphicSetID);
    serializer.value1b(tileAddLayer.graphicValue);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/TileClearLayers.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "TilePosition.h"
#include "TileLayer.h"
#include "NetworkID.h"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * Sent by a client to request that layers be cleared from a tile, or by the
 * server to tell a client that layers were cleared.
 */
struct TileClearLayers {
public:
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::TileClearLayers};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The position of the tile to update. */
    TilePosition tilePosition{};

    /** The layer types that should be cleared from the specified tile. */
    std::array<bool, TileLayer::Type::Count> layerTypesToClear{};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, TileClearLayers& tileClearLayers)
{
    serializer.object(tileClearLayers.tilePosition);

    // Bit pack the input array.
    // It's an array of bools, so we can make it pretty small.
    serializer.enableBitPacking([&tileClearLayers](
                                    typename S::BPEnabledType& sbp) {
        sbp.container(tileClearLayers.layerTypesToClear,
                      [](typename S::BPEnabledType& sbp, bool& clearLayerType) {
                          sbp.boolValue(clearLayerType);
                      });
    });
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/TileExtentClearLayers.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "TileExtent.h"
#include "TileLayer.h"
#include "NetworkID.h"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Sent by a client to request that layers be cleared from all tiles in an
 * extent, or by the server to tell a client that an extent of tiles was
 * cleared.
 */
struct TileExtentClearLayers {
public:
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::TileExtentClearLayers};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The tiles to update. */
    TileExtent tileExtent{};

    /** The layer types that should be cleared from the specified tiles. */
    std::array<bool, TileLayer::Type::Count> layerTypesToClear{};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, TileExtentClearLayers& tileExtentClearLayers)
{
    serializer.object(tileExtentClearLayers.tileExtent);

    // Bit pack the input array.
    // It's an array of bools, so we can make it pretty small.
    // Note: We expect the outer context (such as EntityUpdate) to
    //       enable bit packing.
    serializer.enableBitPacking([&tileExtentClearLayers](
                                    typename S::BPEnabledType& sbp) {
        sbp.container(tileExtentClearLayers.layerTypesToClear,
                      [](typename S::BPEnabledType& sbp, bool& clearLayerType) {
                          sbp.boolValue(clearLayerType);
                      });
    });

    // Align after bit-packing to make sure the following bytes can be easily
    // processed.
    serializer.adapter().align();
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/TileRemoveLayer.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "TilePosition.h"
#include "TileOffset.h"
#include "TileLayer.h"
#include "NetworkID.h"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Sent by a client to request that a layer be removed from a tile, or by the
 * server to tell a client that a layer was removed.
 */
struct TileRemoveLayer {
public:
    // The EngineMessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::TileRemoveLayer};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    /** The position of the tile to update. */
    TilePosition tilePosition{};

    /** If type == Floor or Object, this is how far the layer is offset from 
        tilePosition.
        Note: Terrain and Walls don't use this. Terrain is always aligned to 
              the tile, and Walls always match the Terrain height. */
    TileOffset tileOffset{};

    /** The type of tile layer that should be removed. */
    TileLayer::Type layerType{TileLayer::Type::None};

    /** The numeric ID of the layer's graphic set.
        For Floors, this will always be 0.
        For Walls, this won't be used (we only need the Wall::Type). */
    Uint16 graphicSetID{0};

    /** The layer's graphic value.
        For all types except Terrain, this is simply an index into 
        graphicSet.graphics. For Terrain, this is a bit-packed value.
        For Terrain, cast this to Terrain::Value. For Walls, cast this to 
        Wall::Type. For Floors and Objects, cast this to Rotation::Direction. */
    Uint8 graphicValue{0};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it,
     * so we fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, TileRemoveLayer& tileRemoveLayer)
{
    serializer.object(tileRemoveLayer.tilePosition);
    serializer.object(tileRemoveLayer.tileOffset);
    serializer.value1b(tileRemoveLayer.layerType);
    serializer.value2b(tileRemoveLayer.graphicSetID);
    serializer.value1b(tileRemoveLayer.graphicValue);
}

} // End namespace AM

```

`Source/SharedLib/Messages/Public/UseItemOnEntityRequest.h`:

```h
#pragma once

#include "EngineMessageType.h"
#include "NetworkDefs.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * Used to request that an item be used on an entity.
 */
struct UseItemOnEntityRequest {
    // The MessageType enum value that this message corresponds to.
    // Declares this struct as a message that the Network can send and receive.
    static constexpr EngineMessageType MESSAGE_TYPE{
        EngineMessageType::UseItemOnEntityRequest};

    //--------------------------------------------------------------------------
    // Networked data
    //--------------------------------------------------------------------------
    // Note: We don't include a tick number in our interaction requests, because
    //       there isn't anything that a client would want to sync the
    //       interaction with. NPC state is in the past, and the client entity's
    //       predicted state (e.g. position) wouldn't be useful to sync to.

    /** The inventory slot of the item that is being used. */
    Uint8 sourceSlotIndex{0};

    /** The target entity. */
    entt::entity targetEntity{entt::null};

    //--------------------------------------------------------------------------
    // Local data
    //--------------------------------------------------------------------------
    /**
     * The network ID of the client that sent this message.
     * Set by the server.
     * No IDs are accepted from the client because we can't trust it, so we
     * fill in the ID based on which socket the message came from.
     */
    NetworkID netID{0};
};

template<typename S>
void serialize(S& serializer, UseItemOnEntityRequest& useItemOnRequest)
{
    serializer.value1b(useItemOnRequest.sourceSlotIndex);
    serializer.value4b(useItemOnRequest.targetEntity);
}

} // End namespace AM

```

`Source/SharedLib/Network/CMakeLists.txt`:

```txt
target_sources(SharedLib
    PRIVATE
        Private/Acceptor.cpp
        Private/Peer.cpp
        Private/SocketSet.cpp
        Private/TcpSocket.cpp
        Private/NetworkStats.cpp
    PUBLIC
        Public/Acceptor.h
        Public/BufferPool.h
        Public/DispatchMessage.h
        Public/NetworkDefs.h
        Public/NetworkID.h
        Public/Peer.h
        Public/SocketSet.h
        Public/TcpSocket.h
        Public/NetworkStats.h
)

target_include_directories(SharedLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

```

`Source/SharedLib/Network/Private/Acceptor.cpp`:

```cpp
#include "Acceptor.h"
#include "Log.h"

namespace AM
{
Acceptor::Acceptor(Uint16 port, const std::shared_ptr<SocketSet>& inClientSet)
: socket{}
, listenerSet{1}
, clientSet{inClientSet}
{
    socket.openAsListener(port);
    listenerSet.addSocket(socket);
}

Acceptor::~Acceptor() {}

std::unique_ptr<Peer> Acceptor::accept()
{
    listenerSet.checkSockets(0);

    if (socket.isReady()) {
        TcpSocket newSocket{socket.accept()};
        if (newSocket.isOpen()) {
            return std::make_unique<Peer>(std::move(newSocket), clientSet);
        }
        else {
            LOG_FATAL("Listener socket showed ready, but accept() failed.");
        }
    }

    return nullptr;
}

bool Acceptor::reject()
{
    listenerSet.checkSockets(0);

    bool peerWasWaiting{false};
    if (socket.isReady()) {
        TcpSocket newSocket{socket.accept()};
        if (newSocket.isOpen()) {
            newSocket.close();
            peerWasWaiting = true;
        }
        else {
            LOG_FATAL("Listener socket showed ready, but accept() failed.");
        }
    }

    return peerWasWaiting;
}

} // namespace AM

```

`Source/SharedLib/Network/Private/NetworkStats.cpp`:

```cpp
#include "NetworkStats.h"

namespace AM
{
// Initialize data.
std::atomic<std::size_t> NetworkStats::bytesSent = 0;
std::atomic<std::size_t> NetworkStats::bytesReceived = 0;

NetStatsDump NetworkStats::dumpStats()
{
    // Fill the dump object while resetting the tracked values.
    NetStatsDump netStatsDump;

    netStatsDump.bytesSent = bytesSent.exchange(0);
    netStatsDump.bytesReceived = bytesReceived.exchange(0);

    return netStatsDump;
}

void NetworkStats::recordBytesSent(std::size_t inBytesSent)
{
    bytesSent += inBytesSent;
}

void NetworkStats::recordBytesReceived(std::size_t inBytesReceived)
{
    bytesReceived += inBytesReceived;
}

} // End namespace AM

```

`Source/SharedLib/Network/Private/Peer.cpp`:

```cpp
#include "Peer.h"
#include "TcpSocket.h"
#include "ByteTools.h"
#include "Log.h"
#include <SDL_stdinc.h>

namespace AM
{
std::unique_ptr<Peer> Peer::initiate(const std::string& serverIP,
                                     unsigned int serverPort)
{
    TcpSocket socket{};
    if (socket.openConnectionTo(serverIP, static_cast<Uint16>(serverPort))) {
        return std::make_unique<Peer>(std::move(socket));
    }
    else {
        return nullptr;
    }
}

Peer::Peer(TcpSocket&& inSocket)
: socket{std::move(inSocket)}
// No set given, create a set of size 1 for this peer.
, set{std::make_shared<SocketSet>(1)}
, bIsConnected{false}
{
    set->addSocket(socket);

    bIsConnected = true;
}

Peer::Peer(TcpSocket&& inSocket, const std::shared_ptr<SocketSet>& inSet)
: socket{std::move(inSocket)}
, set{inSet}
, bIsConnected{false}
{
    set->addSocket(socket);

    bIsConnected = true;
}

Peer::~Peer()
{
    set->remSocket(socket);
}

bool Peer::isConnected() const
{
    return bIsConnected;
}

NetworkResult Peer::send(const BinaryBufferSharedPtr& buffer)
{
    if (!bIsConnected) {
        return NetworkResult::Disconnected;
    }

    std::size_t messageSize{buffer->size()};
    int bytesSent{socket.send(buffer->data(), static_cast<int>(messageSize))};
    if (bytesSent < 0) {
        LOG_FATAL("TCP_Send returned < 0. This should never happen, the socket"
                  "was likely misused.");
    }

    if (static_cast<std::size_t>(bytesSent) < messageSize) {
        // The peer probably disconnected (could be a different issue).
        bIsConnected = false;
        return NetworkResult::Disconnected;
    }
    else {
        return NetworkResult::Success;
    }
}

NetworkResult Peer::send(const Uint8* buffer, std::size_t numBytesToSend)
{
    if (!bIsConnected) {
        return NetworkResult::Disconnected;
    }

    int bytesSent{socket.send(buffer, static_cast<int>(numBytesToSend))};
    if (bytesSent < 0) {
        LOG_FATAL("TCP_Send returned < 0. This should never happen, the socket"
                  "was likely misused.");
    }

    if (static_cast<std::size_t>(bytesSent) < numBytesToSend) {
        // The peer probably disconnected (could be a different issue).
        bIsConnected = false;
        return NetworkResult::Disconnected;
    }
    else {
        return NetworkResult::Success;
    }
}

bool Peer::isReady(bool checkSockets)
{
    if (checkSockets) {
        // Poll to see if there's data
        set->checkSockets(0);
    }

    return socket.isReady();
}

int Peer::receiveBytes(Uint8* buffer, std::size_t numBytes)
{
    if (!bIsConnected) {
        return -1;
    }

    // Try to receive bytes.
    int bytesReceived{socket.receive(buffer, static_cast<int>(numBytes))};
    if (bytesReceived < 0) {
        // Disconnected
        bIsConnected = false;
        return -1;
    }

    return bytesReceived;
}

int Peer::receiveBytesWait(Uint8* buffer, std::size_t numBytes)
{
    if (!bIsConnected) {
        return -1;
    }

    // Loop until we've received all of the bytes.
    int bytesReceived{0};
    while (static_cast<std::size_t>(bytesReceived) < numBytes) {
        // Try to receive bytes.
        int result{
            socket.receive((buffer + bytesReceived),
                           (static_cast<int>(numBytes) - bytesReceived))};
        if (result > 0) {
            bytesReceived += result;
        }
        else {
            // Disconnected
            bIsConnected = false;
            return -1;
        }
    }

    return bytesReceived;
}

} // End namespace AM

```

`Source/SharedLib/Network/Private/SocketSet.cpp`:

```cpp
#include "SocketSet.h"
#include "TcpSocket.h"
#include "Log.h"

namespace AM
{
SocketSet::SocketSet(int maxSockets)
: numSockets(0)
{
    set = SDLNet_AllocSocketSet(maxSockets);
    if (set == nullptr) {
        LOG_FATAL("Error allocating socket set: %s", SDLNet_GetError());
    }
}

SocketSet::~SocketSet()
{
    SDLNet_FreeSocketSet(set);
    set = nullptr;
}

void SocketSet::addSocket(const TcpSocket& socket)
{
    int numAdded{SDLNet_TCP_AddSocket(set, socket.getUnderlyingSocket())};
    if (numAdded < 1) {
        LOG_FATAL("Error while adding socket: %s", SDLNet_GetError());
    }
    else {
        numSockets += numAdded;
    }
}

void SocketSet::remSocket(const TcpSocket& socket)
{
    SDLNet_TCP_DelSocket(set, socket.getUnderlyingSocket());
}

int SocketSet::checkSockets(unsigned int timeoutMs)
{
    int numReady{SDLNet_CheckSockets(set, timeoutMs)};
    if (numReady == -1) {
        LOG_FATAL("Error while checking sockets: %s", SDLNet_GetError());
        // Most of the time this is a system error, where perror might help.
        perror("SDLNet_CheckSockets");
    }

    return numReady;
}

} // End namespace AM

```

`Source/SharedLib/Network/Private/TcpSocket.cpp`:

```cpp
#include "TcpSocket.h"
#include <SDL_net.h>
#include "Log.h"

namespace AM
{
TcpSocket::TcpSocket()
: socket{nullptr}
, ip{""}
, port{0}
{
}

TcpSocket::TcpSocket(TCPsocket inSdlSocket)
: socket(inSdlSocket)
, ip{""}
, port{0}
{
}

TcpSocket::~TcpSocket()
{
    close();
}

TcpSocket::TcpSocket(TcpSocket&& otherSocket) noexcept
: socket{otherSocket.socket}
, ip{otherSocket.ip}
, port{otherSocket.port}
{
    otherSocket.socket = nullptr;
    otherSocket.ip = "";
    otherSocket.port = 0;
}

bool TcpSocket::openAsListener(Uint16 portToListenOn)
{
    // We explicitly guard against this since we use port == 0 as a flag.
    if (portToListenOn == 0) {
        LOG_FATAL("Tried to listen on port 0.");
    }

    IPaddress ipObj;
    if (SDLNet_ResolveHost(&ipObj, nullptr, portToListenOn) == -1) {
        LOG_INFO("Could not resolve host: %s", SDLNet_GetError());
        return false;
    }

    socket = SDLNet_TCP_Open(&ipObj);
    if (socket == nullptr) {
        LOG_INFO("Could not open TCP socket: %s", SDLNet_GetError());
        return false;
    }

    return true;
}

bool TcpSocket::openConnectionTo(std::string ip, Uint16 port)
{
    // We explicitly guard against this since we use port == 0 as a flag.
    if (port == 0) {
        LOG_FATAL("Tried to use port 0.");
    }

    IPaddress ipObj;
    if (SDLNet_ResolveHost(&ipObj, ip.c_str(), port) == -1) {
        LOG_INFO("Could not resolve host: %s", SDLNet_GetError());
        return false;
    }

    socket = SDLNet_TCP_Open(&ipObj);
    if (socket == nullptr) {
        LOG_INFO("Could not open TCP socket: %s", SDLNet_GetError());
        return false;
    }

    return true;
}

void TcpSocket::close()
{
    if (socket != nullptr) {
        SDLNet_TCP_Close(socket);
        socket = nullptr;
    }
}

bool TcpSocket::isOpen()
{
    return (socket != nullptr);
}

int TcpSocket::send(const void* dataBuffer, int len)
{
    return SDLNet_TCP_Send(socket, dataBuffer, len);
}

int TcpSocket::receive(void* dataBuffer, int maxLen)
{
    return SDLNet_TCP_Recv(socket, dataBuffer, maxLen);
}

bool TcpSocket::isReady()
{
    return SDLNet_SocketReady(socket);
}

TcpSocket TcpSocket::accept()
{
    TCPsocket newSocket{SDLNet_TCP_Accept(socket)};
    if (newSocket != nullptr) {
        return TcpSocket{newSocket};
    }
    else {
        return TcpSocket{};
    }
}

std::string TcpSocket::getAddress()
{
    if (ip.empty() && (port != 0)) {
        // Listener socket.
        LOG_FATAL("Tried to call getAddress on a listener socket.");
    }
    else if (port == 0) {
        // Socket was received through a listener and hasn't yet retrieved its
        // address.
        IPaddress* remoteIP{SDLNet_TCP_GetPeerAddress(socket)};
        if (remoteIP == nullptr) {
            LOG_FATAL("Failed to get peer address: %s", SDLNet_GetError());
        }
        else {
            // Successfully got the address, save it in our members.
            ip = std::to_string(remoteIP->host);
            port = remoteIP->port;
        }
    }

    return ip + std::to_string(port);
}

TCPsocket TcpSocket::getUnderlyingSocket() const
{
    return socket;
}

} // End namespace AM

```

`Source/SharedLib/Network/Public/Acceptor.h`:

```h
#ifndef ACCEPTOR_H_
#define ACCEPTOR_H_

#include "Peer.h"
#include "SocketSet.h"
#include "TcpSocket.h"
#include <SDL_net.h>
#include <memory>
#include <string>

namespace AM
{
/**
 * Owns a listener socket and provides an interface for accepting new Peers.
 */
class Acceptor
{
public:
    Acceptor(Uint16 port, const std::shared_ptr<SocketSet>& inClientSet);

    ~Acceptor();

    /**
     * If a peer is waiting to connect, opens a connection to the peer and
     * adds it to the clientSet.
     *
     * @return A pointer to a new peer, if one was waiting. Else, nullptr.
     */
    std::unique_ptr<Peer> accept();

    /**
     * If a peer is waiting to connect, opens a connection to the peer and
     * immediately closes it.
     *
     * Use this to close connections when you're at maximum capacity.
     *
     * @return true if a peer was waiting, else false.
     */
    bool reject();

private:
    /** Our listener socket. */
    TcpSocket socket;

    /** The set that we use to check if our socket has activity. */
    SocketSet listenerSet;

    /** A pointer to the set to add accepted clients to. */
    std::shared_ptr<SocketSet> clientSet;
};

} /* End namespace AM */

#endif /* End ACCEPTOR_H_ */

```

`Source/SharedLib/Network/Public/BufferPool.h`:

```h
#pragma once

#include <array>
#include <memory>
#include <vector>

namespace AM
{
/**
 * A pool of reusable data buffers.
 */
template<std::size_t BUFFER_SIZE>
class BufferPool
{
public:
    using BufferType = std::array<Uint8, BUFFER_SIZE>;

    std::unique_ptr<BufferType> acquire()
    {
        if (!(pool.empty())) {
            auto buffer{std::move(pool.back())};
            pool.pop_back();
            return buffer;
        }

        return std::make_unique<BufferType>();
    }

    void release(std::unique_ptr<BufferType> buffer)
    {
        pool.emplace_back(std::move(buffer));
    }

private:
    std::vector<std::unique_ptr<BufferType>> pool{};
};

} /* End namespace AM */

```

`Source/SharedLib/Network/Public/DispatchMessage.h`:

```h
#pragma once

#include "Deserialize.h"
#include "QueuedEvents.h"
#include <SDL_stdinc.h>
#include <memory>

namespace AM
{

/**
 * Deserializes the message in the given buffer and pushes it through the
 * given event dispatcher.
 * Used when the message type doesn't require any network-level processing.
 *
 * The event can be received in a system using EventQueue<T>.
 */
template<typename T>
static void dispatchMessage(Uint8* messageBuffer, std::size_t messageSize,
                            EventDispatcher& dispatcher)
{
    // Deserialize the message.
    T message{};
    Deserialize::fromBuffer(messageBuffer, messageSize, message);

    // Push the message into any subscribed queues.
    dispatcher.push<T>(message);
}

/**
 * Similar to pushEvent(), but allocates the event to the heap through a
 * std::shared_ptr.
 *
 * Used for large events or events with internal allocations, where the
 * cost of allocating once is lower than copying.
 *
 * The event can be received in a system using
 * EventQueue<std::shared_ptr<const T>>.
 */
template<typename T>
static void dispatchMessageSharedPtr(Uint8* messageBuffer,
                                     std::size_t messageSize,
                                     EventDispatcher& dispatcher)
{
    // Deserialize the message.
    std::shared_ptr<T> message{std::make_shared<T>()};
    Deserialize::fromBuffer(messageBuffer, messageSize, *message);

    // Push the message into any subscribed queues.
    dispatcher.push<std::shared_ptr<const T>>(message);
}

} // End namespace AM

```

`Source/SharedLib/Network/Public/NetworkDefs.h`:

```h
#pragma once

#include "BinaryBuffer.h"
#include "EngineMessageType.h"
#include <SDL_stdinc.h>
#include <memory>
#include <vector>

/**
 * This file contains shared network type definitions that should be
 * consistent between the server and client.
 */
namespace AM
{
//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
// Note: These are non-configurable constants. Configurable constants should
//       go into SharedConfig.

/** The max size that a message batch can be, after compression.
    2^15 because the BatchSize field is 16 bits long, and the high bit is
    reserved.
    SharedConfig::MAX_BATCH_SIZE will typically be smaller than this, and it 
    is an uncompressed max so this will usually not be reached. We just use it 
    for safety checks. */
static constexpr std::size_t MAX_BATCH_WIRE_SIZE{(2 << 14) - 1};

/** The max size that a client message can be (server messages are instead 
    bound by total batch size). 2^16 because the message Size field is 16 bits 
    long.
    We allow this to be a very large number, despite the performance 
    implications, because clients should only be sending large messages when 
    a dev is modifying the world, e.g. when updating a dialogue script. */
static constexpr std::size_t CLIENT_MAX_MESSAGE_SIZE{(2 << 15) - 1};

/** The maximum number of bytes we can send as a single packet. Messages 
    larger than this will likely be split into multiple packets, potentially
    leading to them not arriving at the same time. */
static constexpr std::size_t ETHERNET_MTU{1460};


//--------------------------------------------------------------------------
// Headers
//--------------------------------------------------------------------------
// TODO: Do we just want to replace these with bitsery? Their only restriction
//       is that they have to be a known length so we can receive them first.
//       It'll let us hide the bit operations in BatchSize.

/**
 * Used for indexing into the parts of a server header.
 *
 * The server sends a header, followed by a (potentially compressed) batch of
 * messages.
 */
struct ServerHeaderIndex {
    enum Index : Uint8 {
        /** Sint8, the adjustment that the server wants the client to make. */
        TickAdjustment = 0,
        /** Uint8, the iteration of tick offset adjustment that we're on. */
        AdjustmentIteration = 1,
        /** Uint16. The low 15 bits hold the size of the message batch in
            bytes (if compressed, this will be the compressed size). The high
            bit is set if the batch is compressed. */
        BatchSize = 2,
        /** The start of the first message header if one is present. */
        MessageHeaderStart = 4
    };
};
/** The size of a server header in bytes. */
static constexpr unsigned int SERVER_HEADER_SIZE{
    ServerHeaderIndex::MessageHeaderStart};

/**
 * Used for indexing into the parts of a client header.
 */
struct ClientHeaderIndex {
    enum Index : Uint8 {
        /** Uint8, the iteration of tick offset adjustment that we're on. */
        AdjustmentIteration = 0,
        /** The start of the first message header if one is present. */
        MessageHeaderStart = 1
    };
};
/** The size of a client header in bytes. */
static constexpr unsigned int CLIENT_HEADER_SIZE{
    ClientHeaderIndex::MessageHeaderStart};

/**
 * Used for indexing into the size or payload of a received message.
 */
struct MessageHeaderIndex {
    enum Index : Uint8 {
        /** Uint8, identifies the type of message. */
        MessageType = 0,
        /** Uint16, the size of the message in bytes. */
        Size = 1,
        /** The start of the message payload bytes. */
        MessageStart = 3
    };
};
static constexpr unsigned int MESSAGE_HEADER_SIZE{
    MessageHeaderIndex::MessageStart};

//--------------------------------------------------------------------------
// Enums, Structs
//--------------------------------------------------------------------------
/** All potential results for a network-layer send or receive. */
enum class NetworkResult {
    /** Indicates the value hasn't been set. Used for initialization. */
    NotSet,
    /** A message was successfully sent or received. */
    Success,
    /* A send or receive was attempted and the peer was found to be
       disconnected. */
    Disconnected,
    /* A receive was successful but the message has not yet been completed. */
    MessageNotComplete,
};

} // End namespace AM

```

`Source/SharedLib/Network/Public/NetworkID.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/** A numeric ID used to locally identify a client socket.
    Note: This is only used locally by the server, but it lives in Shared 
          because it's convenient to use it in some shared code, e.g. message 
          definitions (so that we can use one struct on both sides). */
using NetworkID = Uint16;

/**
 * The ID used to indicate that a client is not present.
 *
 * Note: Since the null ID is 0, you can do null checks like "if (networkID)".
 */
static constexpr NetworkID NULL_NETWORK_ID{0};

} // End namespace AM

```

`Source/SharedLib/Network/Public/NetworkStats.h`:

```h
#pragma once

#include <atomic>
#include <cstddef>

namespace AM
{
/** Used to pass data out to the consumer. */
struct NetStatsDump {
    std::size_t bytesSent = 0;
    std::size_t bytesReceived = 0;
};

/**
 * This class is used for tracking relevant network statistics.
 *
 * Note: This is a static class instead of being injected because it would be
 * very inconvenient to pass it from the consuming context down to the producing
 * context.
 *
 * Additionally, this class is tangential to the data flow model of the
 * program. Data enters wherever we're tracking from, and is dumped in either a
 * rendering or logging context.
 */
class NetworkStats
{
public:
    /**
     * Dumps all network stats to the returned object, resetting the current
     * values.
     */
    static NetStatsDump dumpStats();

    // Mutators
    /** Adds inBytesSent to bytesSent. */
    static void recordBytesSent(std::size_t inBytesSent);
    /** Adds inBytesReceived to bytesReceived. */
    static void recordBytesReceived(std::size_t inBytesReceived);

private:
    /** The number of bytes that have been sent since the last dump. */
    static std::atomic<std::size_t> bytesSent;

    /** The number of bytes that have been received since the last dump. */
    static std::atomic<std::size_t> bytesReceived;
};

} // End namespace AM

```

`Source/SharedLib/Network/Public/Peer.h`:

```h
#pragma once

#include "NetworkDefs.h"
#include "SocketSet.h"
#include "TcpSocket.h"
#include <memory>
#include <array>
#include <atomic>

namespace AM
{
/**
 * Represents a network peer for communication.
 *
 * This class helps us interact with sockets in the ways that we usually like
 * to. If different behavior is needed, TcpSocket/SocketSet should be used
 * directly.
 */
class Peer
{
public:
    /**
     * Initiates a TCP connection that the other side can then accept.
     * (e.g. the client connecting to the server)
     */
    static std::unique_ptr<Peer> initiate(const std::string& serverIP,
                                          unsigned int serverPort);

    /**
     * Constructor for when you only need 1 peer (client connecting to server,
     * anyone connecting to chat server.)
     * Takes ownership of the given socket and adds it as the only member of a
     * socket set.
     */
    Peer(TcpSocket&& inSocket);

    /**
     * Constructor for when you need a set of peers (server connecting to
     * clients).
     * Takes ownership of the given socket and adds it to the given set.
     */
    Peer(TcpSocket&& inSocket, const std::shared_ptr<SocketSet>& inSet);

    /**
     * Removes the socket from the set.
     */
    ~Peer();

    /**
     * Returns false if the client was at some point found to be disconnected,
     * else true.
     */
    bool isConnected() const;

    /**
     * Sends the data in the given buffer to this Peer.
     *
     * Will error if the buffer size is larger than MAX_WIRE_SIZE.
     *
     * @return Disconnected if the peer was found to be disconnected, else
     *         Success.
     */
    NetworkResult send(const BinaryBufferSharedPtr& buffer);

    /**
     * Sends the data in the given buffer to this Peer.
     *
     * Will error if numBytes is larger than MAX_WIRE_SIZE.
     *
     * @return Disconnected if the peer was found to be disconnected, else
     *         Success.
     */
    NetworkResult send(const Uint8* buffer, std::size_t numBytesToSend);

    /**
     * Returns true if this socket has data waiting.
     *
     * @param checkSockets If true, will call checkSockets() before checking
     *                     socketReady(). Set this to false if you're going to
     *                     call checkSockets() yourself.
     */
    bool isReady(bool checkSockets);

    /**
     * Tries to receive bytes over the network.
     *
     * @param buffer The buffer to fill with data, if any was received.
     * @param numBytes The number of bytes to receive.
     * @return The number of received bytes, or -1 if this peer was disconnected.
     */
    int receiveBytes(Uint8* buffer, std::size_t numBytes);

    /**
     * Returns the requested number of bytes, waiting if they're not yet
     * available.
     *
     * @param buffer  The buffer to fill with data, if any was received.
     * @param numBytes  The number of bytes to receive.
     * @return The number of received bytes, or -1 if this peer was disconnected.
     */
    int receiveBytesWait(Uint8* buffer, std::size_t numBytes);

private:
    /** The socket for this peer. Must be a unique_ptr so we can move without
        copying. */
    TcpSocket socket;

    /** The set that this peer belongs to.
        Must be a shared_ptr since we may or may not allocate it ourselves
        depending on which constructor is called. */
    std::shared_ptr<SocketSet> set;

    /** Tracks whether or not this peer is connected. Is set to false if a
        disconnect was detected when trying to send or receive. */
    std::atomic<bool> bIsConnected;
};

} /* End namespace AM */

```

`Source/SharedLib/Network/Public/SocketSet.h`:

```h
#ifndef SOCKETSET_H_
#define SOCKETSET_H_

#include <SDL_net.h>
#include <memory>

namespace AM
{
class TcpSocket;

/**
 * Represents a set of sockets.
 * Wraps SDLNet's SocketSet in an RAII object interface.
 */
class SocketSet
{
public:
    /**
     * Allocates the socket set.
     *
     * @param maxSockets  The max sockets this socket set can hold.
     */
    SocketSet(int maxSockets);

    /**
     * Deallocates the socket set.
     */
    ~SocketSet();

    // Not copyable.
    SocketSet(const SocketSet& otherSet) = delete;
    SocketSet& operator=(const SocketSet& otherSet) = delete;

    /**
     * Adds the given socket to this set.
     */
    void addSocket(const TcpSocket& socket);

    /**
     * Removes the given socket from this set.
     */
    void remSocket(const TcpSocket& socket);

    /**
     * Checks all sockets in the set for activity.
     * If a non-zero timeout is given, will wait up to that long for activity.
     *
     * @param timeoutMs  The time in milliseconds to wait for activity.
     * @return The number of sockets with activity.
     */
    int checkSockets(unsigned int timeoutMs);

private:
    SDLNet_SocketSet set;

    /** The number of sockets currently in the set. */
    int numSockets;
};

} // End namespace AM

#endif /* End SOCKETSET_H_ */

```

`Source/SharedLib/Network/Public/TcpSocket.h`:

```h
#pragma once

#include <SDL_stdinc.h>
#include <memory>
#include <string>

// Forward declaration
struct _TCPsocket;
typedef struct _TCPsocket* TCPsocket;

namespace AM
{
/**
 * Represents a single TCP socket.
 * Wraps SDLNet's TCPsocket in a C++ object interface.
 */
class TcpSocket
{
public:
    TcpSocket();

    /**
     * Takes ownership over the given SDLNet socket connection.
     *
     * @param inSdlSocket A connected socket.
     */
    TcpSocket(TCPsocket inSdlSocket);

    // Moveable.
    TcpSocket(TcpSocket&& otherSocket) noexcept;

    // Not copyable.
    TcpSocket(const TcpSocket& otherSocket) = delete;
    TcpSocket& operator=(const TcpSocket& otherSocket) = delete;

    /**
     * Closes this socket, if it's open.
     * Note: Will not remove the socket from any sets that it might belong to.
     */
    ~TcpSocket();

    /**
     * Opens this socket as a listener.
     *
     * @param portToListenOn  The port to listen on.
     * @return true if successful, else false.
     */
    bool openAsListener(Uint16 portToListenOn);

    /**
     * Opens a socket connection to the given host.
     *
     * @param ip  The IP to connect to.
     * @param port  The port to connect to.
     * @return true if successful, else false.
     */
    bool openConnectionTo(std::string ip, Uint16 port);

    /**
     * Closes this socket, if it's open.
     * Note: Will not remove this socket from any sets that it might belong to.
     */
    void close();

    /**
     * @return true if this socket has an open connection, else false.
     */
    bool isOpen();

    /**
     * @return true if this socket has been marked as active, else false.
     *
     * Note: Only call this on a socket in a set, after calling checkSockets()
     *       on that set.
     */
    bool isReady();

    /**
     * Sends len bytes from the given dataBuffer over this socket.
     * @return The number of bytes sent. If the number returned is less than
     *         len, an error occurred, such as the client disconnecting.
     */
    int send(const void* dataBuffer, int len);

    /**
     * Receives data from this socket.
     *
     * Note: This call will wait indefinitely for bytes to be available on this
     *       socket. Once bytes are available, it will immediately return them,
     *       even if the amount available is less than maxLen.
     *
     * Note: This function is not used for server (listener) sockets.
     *
     * @param dataBuffer  The buffer to use.
     * @param maxLen  The maximum number of bytes to receive.
     * @return The number of bytes received.
     *         If the number returned is <= 0, an error occurred, or the remote
     *         host has closed the connection.
     */
    int receive(void* dataBuffer, int maxLen);

    /**
     * Accepts an incoming connection on this socket.
     *
     * Note: Only call this on a server (listener) socket.
     *
     * @return A TcpSocket. If the accept was successful, socket.isOpen() will
     *         == true. The socket will be closed if an error occurs, such as
     *         failure to create a socket, failure to finish connecting, or if
     *         there is no waiting connection.
     */
    TcpSocket accept();

    /**
     * Gets the address of the peer at the other side of this socket.
     *
     * Note: Only call this on a connected socket, not a listener.
     *
     * @return An address in the form "IP:port".
     */
    std::string getAddress();

    /**
     * Returns the transport library's underlying socket type.
     */
    TCPsocket getUnderlyingSocket() const;

private:
    TCPsocket socket;

    /** This socket's IP. Empty if this is a listener socket. */
    std::string ip;

    /** This socket's port. */
    Uint16 port;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/CMakeLists.txt`:

```txt
target_sources(SharedLib
    PRIVATE
        Private/BoundingBox.cpp
        Private/CollisionLocator.cpp
        Private/CollisionLocatorRaycastStrategy.cpp
        Private/Cylinder.cpp
        Private/EntityLocator.cpp
        Private/EntityMover.cpp
        Private/MovementHelpers.cpp
        Private/Ray.cpp
        Private/ResourceData.cpp
        Private/Vector3.cpp
        Private/CastableData/Castable.cpp
        Private/CastableData/CastableData.cpp
        Private/Components/Camera.cpp
        Private/Components/CastCooldown.cpp
        Private/Components/CollisionBitSets.cpp
        Private/Components/Interaction.cpp
        Private/Components/Inventory.cpp
        Private/GraphicData/Animation.cpp
        Private/GraphicData/GraphicDataBase.cpp
        Private/GraphicData/GraphicID.cpp
        Private/GraphicData/GraphicRef.cpp
        Private/GraphicData/GraphicSets.cpp
        Private/IconData/IconDataBase.cpp
        Private/ItemData/Item.cpp
        Private/ItemData/ItemDataBase.cpp
        Private/TileMap/CellExtent.cpp
        Private/TileMap/CellPosition.cpp
        Private/TileMap/Chunk.cpp
        Private/TileMap/ChunkExtent.cpp
        Private/TileMap/ChunkPosition.cpp
        Private/TileMap/Floor.cpp
        Private/TileMap/Terrain.cpp
        Private/TileMap/Tile.cpp
        Private/TileMap/TileExtent.cpp
        Private/TileMap/TileLayer.cpp
        Private/TileMap/TileMapBase.cpp
        Private/TileMap/TilePosition.cpp
    PUBLIC
        Public/AMMath.h
        Public/BoundingBox.h
        Public/BoundingBoxID.h
        Public/CollisionLocator.h
        Public/CollisionLocatorRaycastStrategy.h
        Public/Cylinder.h
        Public/DialogueEvent.h
        Public/DiscreteExtent.h
        Public/DiscreteImpl.h
        Public/DiscretePosition.h
        Public/EngineCollisionLayerType.h
        Public/EngineEntityGraphicType.h
        Public/EngineEntityInteractionType.h
        Public/EngineItemInteractionType.h
        Public/EntityLocator.h
        Public/EntityMover.h
        Public/EnttObserver.h
        Public/MovementHelpers.h
        Public/Ray.h
        Public/ReplicatedComponent.h
        Public/ResourceData.h
        Public/Vector3.h
        Public/CastableData/AVEntity.h
        Public/CastableData/Castable.h
        Public/CastableData/CastableData.h
        Public/CastableData/CastableID.h
        Public/CastableData/CastFailureType.h
        Public/CastableData/CastInfo.h
        Public/CastableData/EngineCastableDef.h
        Public/CastableData/VisualEffect.h
        Public/Components/Camera.h
        Public/Components/CastCooldown.h
        Public/Components/Collision.h
        Public/Components/CollisionBitSets.h
        Public/Components/EntityInitScript.h
        Public/Components/GraphicState.h
        Public/Components/Input.h
        Public/Components/Interaction.h
        Public/Components/Inventory.h
        Public/Components/IsClientEntity.h
        Public/Components/Movement.h
        Public/Components/MovementModifiers.h
        Public/Components/Name.h
        Public/Components/Position.h
        Public/Components/PreviousPosition.h
        Public/Components/Rotation.h
        Public/GraphicData/Animation.h
        Public/GraphicData/AnimationID.h
        Public/GraphicData/GraphicDataBase.h
        Public/GraphicData/GraphicID.h
        Public/GraphicData/GraphicRef.h
        Public/GraphicData/GraphicSetIDs.h
        Public/GraphicData/GraphicSets.h
        Public/GraphicData/Sprite.h
        Public/GraphicData/SpriteID.h
        Public/IconData/Icon.h
        Public/IconData/IconDataBase.h
        Public/IconData/IconID.h
        Public/ItemData/Item.h
        Public/ItemData/ItemDataBase.h
        Public/ItemData/ItemID.h
        Public/ItemData/ItemInitScript.h
        Public/ItemData/ItemProperty.h
        Public/TileMap/CellExtent.h
        Public/TileMap/CellPosition.h
        Public/TileMap/Chunk.h
        Public/TileMap/ChunkExtent.h
        Public/TileMap/ChunkPosition.h
        Public/TileMap/ChunkSnapshot.h
        Public/TileMap/Floor.h
        Public/TileMap/Terrain.h
        Public/TileMap/Tile.h
        Public/TileMap/TileLayer.h
        Public/TileMap/TileLayerID.h
        Public/TileMap/TileExtent.h
        Public/TileMap/TileMapBase.h
        Public/TileMap/TileMapSnapshot.h
        Public/TileMap/TileOffset.h
        Public/TileMap/TilePosition.h
        Public/TileMap/Wall.h
        Public/TypeLists/EngineReplicatedComponentTypes.h
)

target_include_directories(SharedLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/CastableData
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/Components
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/GraphicData
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/IconData
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/ItemData
        ${CMAKE_CURRENT_SOURCE_DIR}/Private/TileMap
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/CastableData
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/Components
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/GraphicData
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/IconData
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/ItemData
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/TileMap
        ${CMAKE_CURRENT_SOURCE_DIR}/Public/TypeLists
)

```

`Source/SharedLib/Simulation/Private/BoundingBox.cpp`:

```cpp
#include "BoundingBox.h"
#include "Position.h"
#include "Cylinder.h"
#include "Ray.h"
#include "TileExtent.h"
#include "MovementHelpers.h"
#include "AMMath.h"
#include <cmath>

namespace AM
{

BoundingBox::BoundingBox()
: min{}
, max{}
{
}

bool BoundingBox::operator==(const BoundingBox& other) const
{
    return (min.x == other.min.x) && (max.x == other.max.x)
           && (min.y == other.min.y) && (max.y == other.max.y)
           && (min.z == other.min.z) && (max.z == other.max.z);
}

BoundingBox::BoundingBox(const TileExtent& tileExtent)
{
    static constexpr float TILE_WORLD_WIDTH{
        static_cast<float>(SharedConfig::TILE_WORLD_WIDTH)};
    static constexpr float TILE_WORLD_HEIGHT{
        static_cast<float>(SharedConfig::TILE_WORLD_HEIGHT)};

    min.x = tileExtent.x * TILE_WORLD_WIDTH;
    min.y = tileExtent.y * TILE_WORLD_WIDTH;
    min.z = tileExtent.z * TILE_WORLD_HEIGHT;

    max.x = (tileExtent.x + tileExtent.xLength) * TILE_WORLD_WIDTH;
    max.y = (tileExtent.y + tileExtent.yLength) * TILE_WORLD_WIDTH;
    max.z = (tileExtent.z + tileExtent.zLength) * TILE_WORLD_HEIGHT;
}

BoundingBox::BoundingBox(const Cylinder& cylinder)
: min{(cylinder.center.x - cylinder.radius),
      (cylinder.center.y - cylinder.radius),
      (cylinder.center.z - cylinder.radius)}
, max{(cylinder.center.x + cylinder.radius),
      (cylinder.center.y + cylinder.radius),
      (cylinder.center.z + cylinder.radius)}
{
}

float BoundingBox::xLength() const
{
    return (max.x - min.x);
}

float BoundingBox::yLength() const
{
    return (max.y - min.y);
}

float BoundingBox::zLength() const
{
    return (max.z - min.z);
}

Vector3 BoundingBox::getBottomCenterPoint() const
{
    return {(min.x + ((max.x - min.x) / 2.f)),
            (min.y + ((max.y - min.y) / 2.f)), min.z};
}

Vector3 BoundingBox::getTopCenterPoint() const
{
    return {(min.x + ((max.x - min.x) / 2.f)),
            (min.y + ((max.y - min.y) / 2.f)), max.z};
}

Vector3 BoundingBox::get3DCenterPoint() const
{
    return {(min.x + ((max.x - min.x) / 2.f)),
            (min.y + ((max.y - min.y) / 2.f)),
            (min.z + ((max.z - min.z) / 2.f))};
}

bool BoundingBox::isEmpty() const
{
    return ((min.x == max.x) || (min.y == max.y) || (min.z == max.z));
}

bool BoundingBox::intersects(const BoundingBox& other) const
{
    return ((min.x <= other.max.x) && (max.x >= other.min.x)
            && (min.y <= other.max.y) && (max.y >= other.min.y)
            && (min.z <= other.max.z) && (max.z >= other.min.z));
}

bool BoundingBox::intersects(const Cylinder& cylinder) const
{
    // Reference: https://stackoverflow.com/a/402010/4258629

    // If the cylinder doesn't intersect along the Z axis, return false.
    float cylinderMinZ{cylinder.center.z - cylinder.halfHeight};
    float cylinderMaxZ{cylinder.center.z + cylinder.halfHeight};
    if ((cylinderMaxZ < min.z) || (cylinderMinZ > max.z)) {
        return false;
    }

    // The cylinder intersects along the Z axis. The rest of the test now 
    // reduces to a 2D circle/rectangle intersection.

    // Get the X and Y distances between the centers.
    float centerX{min.x + ((max.x - min.x) / 2.f)};
    float centerY{min.y + ((max.y - min.y) / 2.f)};
    float circleDistanceX{std::abs(cylinder.center.x - centerX)};
    float circleDistanceY{std::abs(cylinder.center.y - centerY)};

    // If the circle is far enough away that no intersection is possible,
    // return false.
    float halfXLength{xLength() / 2.f};
    float halfYLength{yLength() / 2.f};
    if (circleDistanceX > (halfXLength + cylinder.radius)) {
        return false;
    }
    if (circleDistanceY > (halfYLength + cylinder.radius)) {
        return false;
    }

    // If the circle is close enough that an intersection is guaranteed,
    // return true.
    if (circleDistanceX <= halfXLength) {
        return true;
    }
    if (circleDistanceY <= halfYLength) {
        return true;
    }

    // Calculate the distance from the center of the circle to the corner
    // of the box.
    float xDif{circleDistanceX - halfXLength};
    float yDif{circleDistanceY - halfYLength};
    float cornerDistanceSquared{(xDif * xDif) + (yDif * yDif)};

    // If the distance is less than the radius, return true.
    return (cornerDistanceSquared <= (cylinder.radius * cylinder.radius));
}

bool BoundingBox::intersects(const TileExtent& tileExtent) const
{
    return intersects(BoundingBox(tileExtent));
}

bool BoundingBox::intersects(const Ray& ray) const
{
    Vector3 inverseRayDirection{ray.direction.reciprocal()};
    return intersects(ray.origin, inverseRayDirection, 0.f,
                      std::numeric_limits<float>::infinity())
        .didIntersect;
}

bool BoundingBox::intersects(const Vector3& start, const Vector3& end) const
{
    Vector3 inverseRayDirection{(end - start).reciprocal()};
    return intersects(start, inverseRayDirection, 0.f, 1.f).didIntersect;
}

BoundingBox::RayIntersectReturn BoundingBox::intersects(const Ray& ray,
                                                        float tMinBound,
                                                        float tMaxBound) const
{
    Vector3 inverseRayDirection{ray.direction.reciprocal()};
    return intersects(ray.origin, inverseRayDirection, tMinBound, tMaxBound);
}

BoundingBox::RayIntersectReturn
    BoundingBox::intersects(const Vector3& rayOrigin,
                            const Vector3& inverseRayDirection, float tMinBound,
                            float tMaxBound) const
{
    // Slab Algorithm Ref: 
    // https://medium.com/@bromanz/another-view-on-the-classic-ray-aabb-intersection-algorithm-for-bvh-traversal-41125138b525
    // https://technik90.blogspot.com/2018/06/the-other-pathtracer-4-optimizing-aabb.html

    Vector3 t0{(min - rayOrigin) * inverseRayDirection};
    Vector3 t1{(max - rayOrigin) * inverseRayDirection};
    
    Vector3 tEnter{Math::min(t0, t1)};
    Vector3 tExit{Math::max(t1, t0)};

    // We compare against tMinBound/tMaxBound so that, if the intersecting time
    // interval is not within [tMinBound, tMaxBound], either tMin will be 
    // brought above tMax, or tMax will be brought below tMin, causing the 
    // intersection check (tMax >= tMin) to return false.
    //
    // Example: Define tSlabMin = max(tEnter), tSlabMax = min(tExit).
    //          Let [tSlabMin, tSlabMax]   = [2, 4], 
    //              [tMinBound, tMaxBound] = [0, 1].
    //          Note that the result ([2, 4]) is outside of the bounds.
    //
    //          tLastEnter = max(tMin, tSlabMin) = max(0, 2) = 2
    //          tFirstExit = min(tMax, tSlabMax), = min(1, 4) = 1
    //
    //          We return (tFirstExit >= tLastEnter) -> return (1 >= 2) -> false.
    //
    // Note: There are also some cases where tMin/tMax get clamped to the 
    //       bounds, such as when rayOrigin is inside this box, or when the 
    //       bounds end before the exit is reached.
    float tMin{
        std::max(tMinBound, std::max(std::max(tEnter.x, tEnter.y), tEnter.z))};
    float tMax{
        std::min(tMaxBound, std::min(std::min(tExit.x, tExit.y), tExit.z))};

    return {(tMax >= tMin), tMin, tMax};
}

bool BoundingBox::contains(const BoundingBox& boundingBox) const
{
    return (min.x <= boundingBox.min.x) && (max.x >= boundingBox.max.x)
           && (min.y <= boundingBox.min.y) && (max.y >= boundingBox.max.y)
           && (min.z <= boundingBox.min.z) && (max.z >= boundingBox.max.z);
}

bool BoundingBox::contains(const Cylinder& cylinder) const
{
    BoundingBox cylinderWrapper(cylinder);
    return contains(cylinderWrapper);
}

bool BoundingBox::contains(const Vector3& worldPoint) const
{
    return (min.x <= worldPoint.x) && (max.x >= worldPoint.x)
           && (min.y <= worldPoint.y) && (max.y >= worldPoint.y)
           && (min.z <= worldPoint.z) && (max.z >= worldPoint.z);
}

BoundingBox BoundingBox::moveTo(const Vector3& newMin) const
{
    BoundingBox newBox{*this};
    Vector3 diff{newMin - newBox.min};
    newBox.min = newMin;
    newBox.max += diff;
    return newBox;
}

BoundingBox BoundingBox::moveBottomCenterTo(const Vector3& newBottomCenter) const
{
    BoundingBox newBox{*this};
    Vector3 lengths{xLength(), yLength(), zLength()};
    newBox.min.x = newBottomCenter.x - (lengths.x / 2.f);
    newBox.min.y = newBottomCenter.y - (lengths.y / 2.f);
    newBox.min.z = newBottomCenter.z;
    newBox.max = newBox.min + lengths;

    return newBox;
}

BoundingBox BoundingBox::translateBy(const Vector3& amountToMove) const
{
    BoundingBox newBox{*this};
    newBox.min += amountToMove;
    newBox.max += amountToMove;
    return newBox;
}

BoundingBox BoundingBox::unionWith(const BoundingBox& other) const
{
    BoundingBox finalBox{*this};

    finalBox.min.x = (min.x < other.min.x) ? min.x : other.min.x;
    finalBox.min.y = (min.y < other.min.y) ? min.y : other.min.y;
    finalBox.min.z = (min.z < other.min.z) ? min.z : other.min.z;

    finalBox.max.x = (max.x > other.max.x) ? max.x : other.max.x;
    finalBox.max.y = (max.y > other.max.y) ? max.y : other.max.y;
    finalBox.max.z = (max.z > other.max.z) ? max.z : other.max.z;

    return finalBox;
}

BoundingBox BoundingBox::expandBy(float amountToExpandBy) const
{
    Vector3 expandVector{amountToExpandBy, amountToExpandBy, amountToExpandBy};
    return {min - expandVector, max + expandVector};
}

void BoundingBox::print() const
{
    LOG_INFO("Min: (%.4f, %.4f, %.4f), Max: (%.4f, %.4f, %.4f)", min.x, min.y,
             min.z, max.x, max.y, max.z);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/CastableData/Castable.cpp`:

```cpp
#include "Castable.h"
#include "SharedConfig.h"

namespace AM
{

Cylinder Castable::getTargetCylinder(const Vector3& position) const
{
    static constexpr float HALF_HEIGHT{
        SharedConfig::CAST_TARGET_CYLINDER_HALF_HEIGHT};

    Cylinder targetCylinder{position, radius, HALF_HEIGHT};
    targetCylinder.center.z -= HALF_HEIGHT;

    return targetCylinder;
}

bool Castable::hasVisuals() const
{
    bool hasCastingGraphic{castingGraphicType != EntityGraphicType::NotSet};
    bool hasCastCompleteGraphic{castCompleteGraphicType
                                != EntityGraphicType::NotSet};
    bool hasVisualEffect{castCompleteVisualEffects.size() != 0};
    bool hasAVEntity{castCompleteAVEntities.size() != 0};

    return hasCastingGraphic || hasCastCompleteGraphic || hasVisualEffect
           || hasAVEntity;
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/CastableData/CastableData.cpp`:

```cpp
#include "CastableData.h"
#include "GraphicDataBase.h"
#include "EngineCastableDef.h"
#include "CastableDef.h"
#include "Log.h"

namespace AM
{

CastableData::CastableData(const GraphicDataBase& graphicData)
: itemInteractionMap{}
, entityInteractionMap{}
, spellMap{}
{
    // Init all of the engine's Castables.
    EngineCastableDef::defineCastables(
        graphicData, [&](const Castable& castable) { addCastable(castable); });

    // Init all of the project's Castables.
    CastableDef::defineCastables(
        graphicData, [&](const Castable& castable) { addCastable(castable); });

    // Note: We intentionally don't have a "null castable", because we want the 
    //       getters to return nullptr if there isn't a real castable to return.
}

const Castable* CastableData::getCastable(CastableID castableID) const
{
    // Attempt to find the Castable.
    if (auto* type{std::get_if<ItemInteractionType>(&castableID)}) {
        auto it{itemInteractionMap.find(*type)};
        if (it != itemInteractionMap.end()) {
            return &(it->second);
        }
    }
    else if (auto* type{std::get_if<EntityInteractionType>(&castableID)}) {
        auto it{entityInteractionMap.find(*type)};
        if (it != entityInteractionMap.end()) {
            return &(it->second);
        }
    }
    else if (auto* type{std::get_if<SpellType>(&castableID)}) {
        auto it{spellMap.find(*type)};
        if (it != spellMap.end()) {
            return &(it->second);
        }
    }
    else {
        LOG_ERROR("Tried to get Castable with invalid type.");
    }

    // Failed to find the requested castable.
    return nullptr;
}

void CastableData::addCastable(const Castable& castable)
{
    if (auto* type{std::get_if<ItemInteractionType>(&(castable.castableID))}) {
        if (*type == ItemInteractionType::NotSet) {
            LOG_FATAL("Tried to create castable with invalid ID.");
            return;
        }
        else if (itemInteractionMap.contains(*type)) {
            LOG_FATAL("Tried to create item interaction with ID that's already "
                      "in use: %u",
                      *type);
            return;
        }

        itemInteractionMap[*type] = castable;
    }
    else if (auto* type{
                 std::get_if<EntityInteractionType>(&(castable.castableID))}) {
        if (*type == EntityInteractionType::NotSet) {
            LOG_FATAL("Tried to create castable with invalid ID.");
            return;
        }
        else if (entityInteractionMap.contains(*type)) {
            LOG_FATAL("Tried to create entity interaction with ID that's "
                      "already in use: %u",
                      *type);
            return;
        }

        entityInteractionMap[*type] = castable;
    }
    else if (auto* type{std::get_if<SpellType>(&(castable.castableID))}) {
        if (*type == SpellType::NotSet) {
            LOG_FATAL("Tried to create castable with invalid ID.");
            return;
        }
        else if (spellMap.contains(*type)) {
            LOG_FATAL("Tried to create spell with ID that's already in use: %u",
                      *type);
            return;
        }

        spellMap[*type] = castable;
    }
    else {
        LOG_ERROR("Tried to add Castable with invalid type.");
        return;
    }
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/CollisionLocator.cpp`:

```cpp
#include "CollisionLocator.h"
#include "SharedConfig.h"
#include "Tile.h"
#include "Cylinder.h"
#include "BoundingBox.h"
#include "Collision.h"
#include "CellPosition.h"
#include "Transforms.h"
#include "AMMath.h"
#include "CollisionLocatorRaycastStrategy.h"
#include "Log.h"
#include "AMAssert.h"
#include <cmath>
#include <algorithm>

namespace AM
{
CollisionLocator::CollisionLocator()
: gridCellExtent{}
, collisionVolumes{}
, freeCollisionVolumesIndices{}
, collisionGrid{}
, entityMap{}
, tileMap{}
, terrainGrid{}
, terrainCollisionVolumes{}
, indexVector{}
, collisionReturnVector{}
, raycastReturnVector{}
{
}

void CollisionLocator::setGridSize(const TileExtent& mapTileExtent)
{
    // Set our grid extent to match the tile map.
    gridTileExtent = mapTileExtent;
    gridCellExtent
        = CellExtent(mapTileExtent, SharedConfig::COLLISION_LOCATOR_CELL_WIDTH,
                     SharedConfig::COLLISION_LOCATOR_CELL_HEIGHT);

    // Resize the grid to fit the map.
    collisionGrid.resize(gridCellExtent.size());
    terrainGrid.resize(gridTileExtent.size());

    // Init the terrain grid as empty.
    std::ranges::fill(terrainGrid, EMPTY_TERRAIN);
}

bool CollisionLocator::updateEntity(entt::entity entity,
                                    const BoundingBox& collisionVolume,
                                    CollisionLayerBitSet collisionLayers)
{
    // Find the cells that the collision volume intersects.
    CellExtent cellExtent(collisionVolume, CELL_WORLD_WIDTH, CELL_WORLD_HEIGHT);
    if (!(gridCellExtent.contains(cellExtent))) {
        LOG_ERROR("Tried to track collision that is outside of the locator's "
                  "grid: (%d, %d, %d, %d, %d, %d)ce.",
                  cellExtent.x, cellExtent.y, cellExtent.z, cellExtent.xLength,
                  cellExtent.yLength, cellExtent.zLength);
        return false;
    }

    // If we're already tracking this entity.
    auto entityIt{entityMap.find(entity)};
    Uint16 volumeIndex{};
    if (entityIt != entityMap.end()) {
        CollisionInfo& volumeInfo{collisionVolumes[entityIt->second]};
        CellExtent oldCellExtent(volumeInfo.collisionVolume, CELL_WORLD_WIDTH,
                                 CELL_WORLD_HEIGHT);

        // Update their collision volume.
        volumeIndex = entityIt->second;
        collisionVolumes[volumeIndex].collisionVolume = collisionVolume;
        collisionVolumes[volumeIndex].collisionLayers = collisionLayers;
        collisionVolumes[volumeIndex].entity = entity;

        // If the cell extent hasn't changed, exit early.
        if (cellExtent == oldCellExtent) {
            return true;
        }
        else {
            // Cell extent isn't the same. Remove the entity from the old
            // cells.
            clearCollisionVolumeFromCells(volumeIndex, oldCellExtent);
        }
    }
    else {
        // New entity. If we have a free volume vector index, use it.
        if (!(freeCollisionVolumesIndices.empty())) {
            volumeIndex = freeCollisionVolumesIndices.back();
            freeCollisionVolumesIndices.pop_back();

            collisionVolumes[volumeIndex].collisionVolume = collisionVolume;
            collisionVolumes[volumeIndex].collisionLayers = collisionLayers;
            collisionVolumes[volumeIndex].entity = entity;
        }
        else {
            // No free indices, add the volume to the back.
            collisionVolumes.emplace_back(collisionVolume, collisionLayers,
                                          entity);
            volumeIndex = static_cast<Uint16>(collisionVolumes.size() - 1);
        }

        // Add the new entity to the map.
        entityMap[entity] = volumeIndex;
    }

    // Add the entity's collision volume to the grid.
    addCollisionVolumeToCells(volumeIndex, cellExtent);

    return true;
}

void CollisionLocator::updateTile(const TilePosition& tilePosition,
                                  const Tile& tile)
{
    // If we're already tracking this tile, clear its old collision data.
    auto tileIt{tileMap.find(tilePosition)};
    if (tileIt != tileMap.end()) {
        // For each layer that was in the tile.
        // Note: Terrain layers will never be present in this loop, since
        //       they aren't added to collisionVolumes or tileMap.
        for (Uint16 volumeIndex : tileIt->second) {
            CollisionInfo& volumeInfo{collisionVolumes[volumeIndex]};

            // Clear it from the grid.
            CellExtent cellExtent(volumeInfo.collisionVolume, CELL_WORLD_WIDTH,
                                  CELL_WORLD_HEIGHT);
            clearCollisionVolumeFromCells(volumeIndex, cellExtent);

            // Mark its index as now being free.
            freeCollisionVolumesIndices.push_back(volumeIndex);
        }

        // Clear this tile's position in terrainGrid.
        terrainGrid[linearizeTileIndex(tilePosition)] = EMPTY_TERRAIN;

        // If the tile has no layers: erase it from the map, clear its terrain,
        // and return early.
        if (tile.getAllLayers().empty()) {
            tileMap.erase(tileIt);
            return;
        }
    }

    // Add the tile to tileMap, and add all of its collidable layers to
    // collisionGrid and terrainGrid.
    addTileCollisionVolumes(tilePosition, tile);
}

void CollisionLocator::removeEntity(entt::entity entity)
{
    // If we aren't already tracking this entity, do nothing.
    auto entityIt{entityMap.find(entity)};
    if (entityIt == entityMap.end()) {
        // Note: Entities may not have collision, so it's fine to not find
        //       them in this locator.
        return;
    }

    // Remove the entity from the cells that it's located in.
    const CollisionInfo& volumeInfo{collisionVolumes[entityIt->second]};
    CellExtent cellExtent(volumeInfo.collisionVolume, CELL_WORLD_WIDTH,
                          CELL_WORLD_HEIGHT);
    clearCollisionVolumeFromCells(entityIt->second, cellExtent);

    // Mark its index as now being free.
    freeCollisionVolumesIndices.push_back(entityIt->second);

    // Remove the entity from the map.
    entityMap.erase(entityIt);
}

bool CollisionLocator::raycastAny(const RaycastParams& params)
{
    RaycastStrategyIntersectAny strategy(*this);
    raycastInternal<RaycastStrategyIntersectAny>(strategy, params);
    return strategy.hasIntersected;
}

std::optional<CollisionLocator::RaycastHitInfo>
    CollisionLocator::raycastFirst(const RaycastParams& params)
{
    RaycastStrategyIntersectFirst strategy(*this);
    raycastReturnVector.clear();
    terrainCollisionVolumes.clear();
    raycastInternal<RaycastStrategyIntersectFirst>(strategy, params);

    // If we hit anything, return it.
    if (strategy.hasIntersected) {
        return strategy.firstHitInfo;
    }

    return std::nullopt;
}

std::vector<CollisionLocator::RaycastHitInfo>&
    CollisionLocator::raycastAll(const RaycastParams& params)
{
    RaycastStrategyIntersectAll strategy(*this);
    raycastReturnVector.clear();
    terrainCollisionVolumes.clear();
    raycastInternal<RaycastStrategyIntersectAll>(strategy, params);

    return raycastReturnVector;
}

std::vector<const CollisionLocator::CollisionInfo*>&
    CollisionLocator::getCollisions(const Cylinder& cylinder,
                                    CollisionLayerBitSet collisionMask)
{
    AM_ASSERT(cylinder.radius >= 0, "Cylinder can't have negative radius.");

    // Perform a broad phase.
    getCollisionsBroad(cylinder, collisionMask);

    // Erase any volumes that don't actually intersect the extent.
    std::erase_if(collisionReturnVector,
                  [this, &cylinder](const CollisionInfo* otherInfo) {
                      return !(otherInfo->collisionVolume.intersects(cylinder));
                  });

    return collisionReturnVector;
}

std::vector<const CollisionLocator::CollisionInfo*>&
    CollisionLocator::getCollisions(const BoundingBox& boundingBox,
                                    CollisionLayerBitSet collisionMask)
{
    // Perform a broad phase.
    getCollisionsBroad(boundingBox, collisionMask);

    // Erase any volumes that don't actually intersect the extent.
    std::erase_if(collisionReturnVector, [this, &boundingBox](
                                             const CollisionInfo* otherInfo) {
        return !(otherInfo->collisionVolume.intersects(boundingBox));
    });

    return collisionReturnVector;
}

std::vector<const CollisionLocator::CollisionInfo*>&
    CollisionLocator::getCollisions(const TileExtent& tileExtent,
                                    CollisionLayerBitSet collisionMask)
{
    // Perform a broad phase.
    getCollisionsBroad(tileExtent, collisionMask);

    // Erase any volumes that don't actually intersect the extent.
    BoundingBox tileExtentBox(tileExtent);
    std::erase_if(collisionReturnVector, [this, &tileExtentBox](
                                             const CollisionInfo* otherInfo) {
        return !(otherInfo->collisionVolume.intersects(tileExtentBox));
    });

    return collisionReturnVector;
}

std::vector<const CollisionLocator::CollisionInfo*>&
    CollisionLocator::getCollisions(const ChunkExtent& chunkExtent,
                                    CollisionLayerBitSet collisionMask)
{
    // Convert to TileExtent.
    return getCollisions(TileExtent(chunkExtent), collisionMask);
}

std::vector<const CollisionLocator::CollisionInfo*>&
    CollisionLocator::getCollisionsBroad(const Cylinder& cylinder,
                                         CollisionLayerBitSet collisionMask)
{
    // Calc the cell extent that is intersected by the cylinder.
    CellExtent cylinderCellExtent(cylinder, CELL_WORLD_WIDTH,
                                  CELL_WORLD_HEIGHT);

    // Clip the extent to the grid's bounds.
    cylinderCellExtent = cylinderCellExtent.intersectWith(gridCellExtent);

    TileExtent cylinderTileExtent(cylinderCellExtent,
                                  SharedConfig::COLLISION_LOCATOR_CELL_WIDTH,
                                  SharedConfig::COLLISION_LOCATOR_CELL_HEIGHT);
    return getCollisionsBroad(cylinderTileExtent, cylinderCellExtent,
                              collisionMask);
}

std::vector<const CollisionLocator::CollisionInfo*>&
    CollisionLocator::getCollisionsBroad(const BoundingBox& boundingBox,
                                         CollisionLayerBitSet collisionMask)
{
    // Convert to TileExtent.
    return getCollisionsBroad(TileExtent(boundingBox), collisionMask);
}

std::vector<const CollisionLocator::CollisionInfo*>&
    CollisionLocator::getCollisionsBroad(const TileExtent& tileExtent,
                                         CollisionLayerBitSet collisionMask)
{
    // Calc the cell extent that is intersected by the tile extent.
    CellExtent tileCellExtent(tileExtent,
                              SharedConfig::ENTITY_LOCATOR_CELL_WIDTH,
                              SharedConfig::ENTITY_LOCATOR_CELL_HEIGHT);

    // Clip the extents to the grid's bounds.
    tileCellExtent = tileCellExtent.intersectWith(gridCellExtent);
    TileExtent clippedTileExtent{tileExtent.intersectWith(gridTileExtent)};

    return getCollisionsBroad(clippedTileExtent, tileCellExtent, collisionMask);
}

std::vector<const CollisionLocator::CollisionInfo*>&
    CollisionLocator::getCollisionsBroad(const ChunkExtent& chunkExtent,
                                         CollisionLayerBitSet collisionMask)
{
    // Convert to TileExtent.
    return getCollisionsBroad(TileExtent(chunkExtent), collisionMask);
}

void CollisionLocator::addCollisionVolumeToCells(Uint16 volumeIndex,
                                                 const CellExtent& cellExtent)
{
    // Add the volume's index to all the cells that it occupies.
    // Note: We allow for duplicate collision volumes.
    for (int z{cellExtent.z}; z <= cellExtent.zMax(); ++z) {
        for (int y{cellExtent.y}; y <= cellExtent.yMax(); ++y) {
            for (int x{cellExtent.x}; x <= cellExtent.xMax(); ++x) {
                // Add the volume's index to this cell's vector.
                std::size_t linearizedIndex{linearizeCellIndex({x, y, z})};
                std::vector<Uint16>& cell{collisionGrid[linearizedIndex]};

                cell.push_back(volumeIndex);
            }
        }
    }
}

void CollisionLocator::clearCollisionVolumeFromCells(
    Uint16 volumeIndex, const CellExtent& clearExtent)
{
    // Iterate through all the cells that the volume occupies.
    for (int z{clearExtent.z}; z <= clearExtent.zMax(); ++z) {
        for (int y{clearExtent.y}; y <= clearExtent.yMax(); ++y) {
            for (int x{clearExtent.x}; x <= clearExtent.xMax(); ++x) {
                // Find and erase the volume's index from this cell.
                std::size_t linearizedIndex{linearizeCellIndex({x, y, z})};
                std::vector<Uint16>& cell{collisionGrid[linearizedIndex]};

                auto indexIt{std::find(cell.begin(), cell.end(), volumeIndex)};
                if (indexIt != cell.end()) {
                    cell.erase(indexIt);
                }
            }
        }
    }
}

void CollisionLocator::addTileCollisionVolumes(const TilePosition& tilePosition,
                                               const Tile& tile)
{
    // Add the tile to the map, or clear it if already present.
    std::vector<Uint16>& tileLayerCollisionIndices{tileMap[tilePosition]};
    tileLayerCollisionIndices.clear();

    // Add all of this tile's collidable layers to the grid.
    float terrainHeight{0};
    for (const TileLayer& layer : tile.getAllLayers()) {
        GraphicRef graphic{layer.getGraphic()};

        // Note: Tile layers are sorted, so they will always appear in this
        //       order (if present).
        // If it's terrain, add it to the terrain grid.
        BoundingBox collisionVolume{};
        CollisionLayerType::Value layerType{};
        if (layer.type == TileLayer::Type::Terrain) {
            terrainGrid[linearizeTileIndex(tilePosition)]
                = static_cast<Terrain::Value>(layer.graphicValue);

            // Generate a temporary collision volume so we can get a height
            // offset for the other layers.
            collisionVolume = Terrain::calcWorldBounds(
                tilePosition, static_cast<Terrain::Value>(layer.graphicValue));
            terrainHeight = collisionVolume.max.z;

            // Continue to the next layer, to avoid this terrain being added to
            // the collisionGrid.
            layerType = CollisionLayerType::TerrainWall;
            continue;
        }
        // If it's a floor, skip it (they never have collision).
        else if (layer.type == TileLayer::Type::Floor) {
            continue;
        }
        // If it's a wall or object, add its assigned collision.
        else if (graphic.getCollisionEnabled()) {
            collisionVolume = Transforms::modelToWorldTile(
                graphic.getModelBounds(), tilePosition);

            // If it's a wall, add the terrain height.
            if (layer.type == TileLayer::Type::Wall) {
                collisionVolume.min.z += terrainHeight;
                collisionVolume.max.z += terrainHeight;
                layerType = CollisionLayerType::TerrainWall;
            }
            else {
                layerType = CollisionLayerType::Object;
            }
        }

        // If we have a free volume vector index, use it.
        Uint16 volumeIndex{};
        if (!(freeCollisionVolumesIndices.empty())) {
            volumeIndex = freeCollisionVolumesIndices.back();
            freeCollisionVolumesIndices.pop_back();

            collisionVolumes[volumeIndex].collisionVolume = collisionVolume;
            collisionVolumes[volumeIndex].collisionLayers = layerType;
        }
        else {
            // No free indices, add the volume to the back.
            collisionVolumes.emplace_back(collisionVolume, layerType);
            volumeIndex = static_cast<Uint16>(collisionVolumes.size() - 1);
        }

        // Convert the volume to a cell extent and make sure each length is
        // non-zero (it's fine for the volume to be a plane, but if the cell
        // extent has any zero lengths, this layer won't be added to any cells).
        CellExtent cellExtent(collisionVolume, CELL_WORLD_WIDTH,
                              CELL_WORLD_HEIGHT);
        cellExtent.xLength = std::max(cellExtent.xLength, 1);
        cellExtent.yLength = std::max(cellExtent.yLength, 1);
        cellExtent.zLength = std::max(cellExtent.zLength, 1);

        // Add this layer's collision volume to the grid.
        addCollisionVolumeToCells(volumeIndex, cellExtent);

        // Add this layer's index to the map.
        tileLayerCollisionIndices.push_back(volumeIndex);
    }
}

template<typename RaycastStrategy>
void CollisionLocator::raycastInternal(RaycastStrategy& strategy,
                                       const RaycastParams& params)
{
    // DDA Algorithm Ref: https://lodev.org/cgtutor/raycasting.html
    //                    https://www.youtube.com/watch?v=NbSee-XM7WA

    // Calc the t values of how long we have to travel along the ray to fully
    // move through 1 cell in each direction.
    Vector3 rayDirection{params.end - params.start};
    Vector3 inverseRayDirection{rayDirection.reciprocal()};
    Vector3 inverseRayNormal{rayDirection.normal().reciprocal()};
    const Vector3 cellStep{Math::abs(inverseRayNormal) * CELL_WORLD_SIZE};

    // Calc the start and end cells for the walk.
    CellPosition currentCellPosition(
        TilePosition(params.start), SharedConfig::COLLISION_LOCATOR_CELL_WIDTH,
        SharedConfig::COLLISION_LOCATOR_CELL_HEIGHT);
    CellPosition endCellPosition{TilePosition(params.end),
                                 SharedConfig::COLLISION_LOCATOR_CELL_WIDTH,
                                 SharedConfig::COLLISION_LOCATOR_CELL_HEIGHT};

    // Determine whether we're walking in the positive or negative direction
    // along each axis (also start calc'ing next intersections).
    int stepDirectionX{};
    int stepDirectionY{};
    int stepDirectionZ{};
    Vector3 nextIntersection{};
    if (rayDirection.x < 0) {
        stepDirectionX = -1;
        float cellOriginX{currentCellPosition.x * CELL_WORLD_WIDTH};
        nextIntersection.x = params.start.x - cellOriginX;
    }
    else {
        stepDirectionX = 1;
        float cellEndX{(currentCellPosition.x + 1) * CELL_WORLD_WIDTH};
        nextIntersection.x = cellEndX - params.start.x;
    }
    if (rayDirection.y < 0) {
        stepDirectionY = -1;
        float cellOriginY{currentCellPosition.y * CELL_WORLD_WIDTH};
        nextIntersection.y = params.start.y - cellOriginY;
    }
    else {
        stepDirectionY = 1;
        float cellEndY{(currentCellPosition.y + 1) * CELL_WORLD_WIDTH};
        nextIntersection.y = cellEndY - params.start.y;
    }
    if (rayDirection.z < 0) {
        stepDirectionZ = -1;
        float cellOriginZ{currentCellPosition.z * CELL_WORLD_HEIGHT};
        nextIntersection.z = params.start.z - cellOriginZ;
    }
    else {
        stepDirectionZ = 1;
        float cellEndZ{(currentCellPosition.z + 1) * CELL_WORLD_HEIGHT};
        nextIntersection.z = cellEndZ - params.start.z;
    }

    // Calc the t values where the next intersection occurs in each direction.
    // Note: Dividing by CELL_WORLD_ gives us a ratio of total cell size,
    //       which we can then multiply by cellStep to get "how much of a
    //       step would we have to make along the ray to reach the next cell".
    nextIntersection /= CELL_WORLD_SIZE;
    nextIntersection *= cellStep;

    // Walk along the ray, checking each cell for a hit collision object.
    // (We iterate until we walk past the end position along some axis).
    while (true) {
        if ((((stepDirectionX > 0)
              && (currentCellPosition.x > endCellPosition.x))
             || ((stepDirectionX < 0)
                 && (currentCellPosition.x < endCellPosition.x)))) {
            break;
        }
        if ((((stepDirectionY > 0)
              && (currentCellPosition.y > endCellPosition.y))
             || ((stepDirectionY < 0)
                 && (currentCellPosition.y < endCellPosition.y)))) {
            break;
        }
        if ((((stepDirectionZ > 0)
              && (currentCellPosition.z > endCellPosition.z))
             || ((stepDirectionZ < 0)
                 && (currentCellPosition.z < endCellPosition.z)))) {
            break;
        }

        // Intersect with the objects in this cell.
        strategy.intersectObjectsInCell(
            params.start, inverseRayDirection, currentCellPosition,
            params.collisionMask, params.entitiesToExclude,
            params.ignoreInsideHits);
        if (strategy.isDone()) {
            break;
        }

        // Move towards the next closest cell.
        if ((nextIntersection.x < nextIntersection.y)
            && (nextIntersection.x < nextIntersection.z)) {
            nextIntersection.x += cellStep.x;
            currentCellPosition.x += stepDirectionX;
        }
        else if ((nextIntersection.y < nextIntersection.x)
                 && (nextIntersection.y < nextIntersection.z)) {
            nextIntersection.y += cellStep.y;
            currentCellPosition.y += stepDirectionY;
        }
        else {
            nextIntersection.z += cellStep.z;
            currentCellPosition.z += stepDirectionZ;
        }
    }
}

std::vector<const CollisionLocator::CollisionInfo*>&
    CollisionLocator::getCollisionsBroad(const TileExtent& tileExtent,
                                         const CellExtent& cellExtent,
                                         CollisionLayerBitSet collisionMask)
{
    // Generate any intersected terrain and add it to the temporary terrain
    // vector.
    // Note: We ignore modelBounds and collisionEnabled on terrain, all terrain
    //       gets generated collision.
    terrainCollisionVolumes.clear();
    for (int z{tileExtent.z}; z <= tileExtent.zMax(); ++z) {
        for (int y{tileExtent.y}; y <= tileExtent.yMax(); ++y) {
            for (int x{tileExtent.x}; x <= tileExtent.xMax(); ++x) {
                TilePosition tilePosition{x, y, z};
                std::size_t linearizedIndex{linearizeTileIndex(tilePosition)};
                Terrain::Value terrainValue{terrainGrid[linearizedIndex]};
                if (terrainValue == EMPTY_TERRAIN) {
                    continue;
                }

                BoundingBox collisionVolume{
                    Terrain::calcWorldBounds(tilePosition, terrainValue)};
                terrainCollisionVolumes.emplace_back(
                    collisionVolume, CollisionLayerType::TerrainWall);
            }
        }
    }

    // Push the temporary terrain collision volumes into the return vector.
    collisionReturnVector.clear();
    for (const CollisionInfo& collisionInfo : terrainCollisionVolumes) {
        collisionReturnVector.emplace_back(&(collisionInfo));
    }

    // Add the indices in every intersected collisionGrid cell to the scratch
    // index vector.
    indexVector.clear();
    for (int z{cellExtent.z}; z <= cellExtent.zMax(); ++z) {
        for (int y{cellExtent.y}; y <= cellExtent.yMax(); ++y) {
            for (int x{cellExtent.x}; x <= cellExtent.xMax(); ++x) {
                std::size_t linearizedIndex{linearizeCellIndex({x, y, z})};
                std::vector<Uint16>& cell{collisionGrid[linearizedIndex]};
                indexVector.insert(indexVector.end(), cell.begin(), cell.end());
            }
        }
    }

    // Sort and remove duplicates from the scratch index vector.
    std::sort(indexVector.begin(), indexVector.end());
    indexVector.erase(std::unique(indexVector.begin(), indexVector.end()),
                      indexVector.end());

    // Push the non-terrain collision volumes into the return vector.
    for (Uint16 volumeIndex : indexVector) {
        const CollisionInfo& volumeInfo{collisionVolumes[volumeIndex]};

        // Filter out any objects that don't match the mask.
        if (volumeInfo.collisionLayers & collisionMask) {
            collisionReturnVector.push_back(&volumeInfo);
        }
    }

    return collisionReturnVector;
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/CollisionLocatorRaycastStrategy.cpp`:

```cpp
#include "CollisionLocatorRaycastStrategy.h"

namespace AM
{

CollisionLocator::RaycastStrategyIntersectAny::RaycastStrategyIntersectAny(
    CollisionLocator& inCollisionLocator)
: hasIntersected{false}
, collisionLocator{inCollisionLocator}
{
}

bool CollisionLocator::RaycastStrategyIntersectAny::isDone() const
{
    return hasIntersected;
}

// Note: There's probably a good way to refactor this intersect code to share
//       more between the 3 strategies, but it wasn't immediately obvious how
//       to do so without sacrificing performance. Improvements are welcome.
void CollisionLocator::RaycastStrategyIntersectAny::intersectObjectsInCell(
    const Vector3& start, const Vector3& inverseRayDirection,
    const CellPosition& cellPosition, CollisionLayerBitSet collisionMask,
    std::span<entt::entity> entitiesToExclude, bool ignoreInsideHits)
{
    // If the line intersects any of this cell's terrain, return true.
    // Note: We ignore modelBounds and collisionEnabled on terrain, all
    //       terrain gets generated collision.
    if (CollisionLayerType::TerrainWall & collisionMask) {
        TileExtent cellTileExtent{
            CellExtent{cellPosition.x, cellPosition.y, cellPosition.z, 1, 1, 1},
            SharedConfig::COLLISION_LOCATOR_CELL_WIDTH,
            SharedConfig::COLLISION_LOCATOR_CELL_HEIGHT};
        for (int z{cellTileExtent.z}; z <= cellTileExtent.zMax(); ++z) {
            for (int y{cellTileExtent.y}; y <= cellTileExtent.yMax(); ++y) {
                for (int x{cellTileExtent.x}; x <= cellTileExtent.xMax(); ++x) {
                    TilePosition tilePosition{x, y, z};
                    std::size_t linearizedIndex{
                        collisionLocator.linearizeTileIndex(tilePosition)};
                    Terrain::Value terrainValue{
                        collisionLocator.terrainGrid[linearizedIndex]};
                    if (terrainValue == EMPTY_TERRAIN) {
                        continue;
                    }

                    // Check for inside hits.
                    BoundingBox collisionVolume{
                        Terrain::calcWorldBounds(tilePosition, terrainValue)};
                    if (ignoreInsideHits && collisionVolume.contains(start)) {
                        continue;
                    }

                    // Check if the line intersects the volume.
                    // Note: Since we want to bound to t==1, it's important for
                    //       inverseRayDirection to not be normalized.
                    if (collisionVolume
                            .intersects(start, inverseRayDirection, 0.f, 1.f)
                            .didIntersect) {
                        hasIntersected = true;
                        return;
                    }
                }
            }
        }
    }

    // If the line intersects any of this cell's objects, return true.
    std::size_t linearizedIndex{
        collisionLocator.linearizeCellIndex(cellPosition)};
    std::vector<Uint16>& cell{collisionLocator.collisionGrid[linearizedIndex]};
    for (Uint16 collisionVolumeIndex : cell) {
        const CollisionInfo& collisionInfo{
            collisionLocator.collisionVolumes[collisionVolumeIndex]};

        // Check for masking.
        bool isInMask{
            static_cast<bool>(collisionInfo.collisionLayers & collisionMask)};
        if (!isInMask) {
            continue;
        }

        // Check for exclusion.
        if ((collisionInfo.entity != entt::null)
            && (std::ranges::contains(entitiesToExclude,
                                      collisionInfo.entity))) {
            continue;
        }

        // Check for inside hits.
        const BoundingBox& collisionVolume{collisionInfo.collisionVolume};
        if (ignoreInsideHits && collisionVolume.contains(start)) {
            continue;
        }

        // Check if the line intersects the volume.
        // Note: Since we want to bound to t==1, it's important for
        //       inverseRayDirection to not be normalized.
        if (collisionVolume.intersects(start, inverseRayDirection, 0.f, 1.f)
                .didIntersect) {
            hasIntersected = true;
            return;
        }
    }
}

CollisionLocator::RaycastStrategyIntersectFirst::RaycastStrategyIntersectFirst(
    CollisionLocator& inCollisionLocator)
: hasIntersected{false}
, firstHitInfo{std::numeric_limits<float>::infinity(), nullptr}
, collisionLocator{inCollisionLocator}
{
}

bool CollisionLocator::RaycastStrategyIntersectFirst::isDone() const
{
    return hasIntersected;
}

void CollisionLocator::RaycastStrategyIntersectFirst::intersectObjectsInCell(
    const Vector3& start, const Vector3& inverseRayDirection,
    const CellPosition& cellPosition, CollisionLayerBitSet collisionMask,
    std::span<entt::entity> entitiesToExclude, bool ignoreInsideHits)
{
    // We use terrainCollisionVolumes[0] as scratch space, and [1] for the
    // earliest hit.
    collisionLocator.terrainCollisionVolumes.emplace_back(
        BoundingBox{}, CollisionLayerType::TerrainWall);
    collisionLocator.terrainCollisionVolumes.emplace_back(
        BoundingBox{}, CollisionLayerType::TerrainWall);

    // If the line intersects any of this cell's terrain, track it.
    // Note: We ignore modelBounds and collisionEnabled on terrain, all
    //       terrain gets generated collision.
    if (CollisionLayerType::TerrainWall & collisionMask) {
        TileExtent cellTileExtent{
            CellExtent{cellPosition.x, cellPosition.y, cellPosition.z, 1, 1, 1},
            SharedConfig::COLLISION_LOCATOR_CELL_WIDTH,
            SharedConfig::COLLISION_LOCATOR_CELL_HEIGHT};
        for (int z{cellTileExtent.z}; z <= cellTileExtent.zMax(); ++z) {
            for (int y{cellTileExtent.y}; y <= cellTileExtent.yMax(); ++y) {
                for (int x{cellTileExtent.x}; x <= cellTileExtent.xMax(); ++x) {
                    TilePosition tilePosition{x, y, z};
                    std::size_t linearizedIndex{
                        collisionLocator.linearizeTileIndex(tilePosition)};
                    Terrain::Value terrainValue{
                        collisionLocator.terrainGrid[linearizedIndex]};
                    if (terrainValue == EMPTY_TERRAIN) {
                        continue;
                    }

                    // Check for inside hits.
                    BoundingBox& collisionVolume{
                        collisionLocator.terrainCollisionVolumes[0]
                            .collisionVolume};
                    collisionVolume
                        = Terrain::calcWorldBounds(tilePosition, terrainValue);
                    if (ignoreInsideHits && collisionVolume.contains(start)) {
                        continue;
                    }

                    // Check if the line intersects the volume.
                    // Note: Since we want to bound to t==1, it's important for
                    //       inverseRayDirection to not be normalized.
                    auto intersectReturn{collisionVolume.intersects(
                        start, inverseRayDirection, 0.f, 1.f)};
                    if (intersectReturn.didIntersect) {
                        hasIntersected = true;

                        // If this is the earliest hit, track it.
                        if (intersectReturn.tMin < firstHitInfo.hitT) {
                            collisionLocator.terrainCollisionVolumes[1]
                                .collisionVolume
                                = collisionVolume;
                            firstHitInfo.hitT = intersectReturn.tMin;
                            firstHitInfo.collisionInfo = &(
                                collisionLocator.terrainCollisionVolumes[1]);
                        }
                    }
                }
            }
        }
    }

    // If the line intersects any of this cell's objects, track it.
    std::size_t linearizedIndex{
        collisionLocator.linearizeCellIndex(cellPosition)};
    std::vector<Uint16>& cell{collisionLocator.collisionGrid[linearizedIndex]};
    for (Uint16 collisionVolumeIndex : cell) {
        const CollisionInfo& collisionInfo{
            collisionLocator.collisionVolumes[collisionVolumeIndex]};

        // Check for masking.
        bool isInMask{
            static_cast<bool>(collisionInfo.collisionLayers & collisionMask)};
        if (!isInMask) {
            continue;
        }

        // Check for exclusion.
        if ((collisionInfo.entity != entt::null)
            && (std::ranges::contains(entitiesToExclude,
                                      collisionInfo.entity))) {
            continue;
        }

        // Check for inside hits.
        const BoundingBox& collisionVolume{collisionInfo.collisionVolume};
        if (ignoreInsideHits && collisionVolume.contains(start)) {
            continue;
        }

        // Check if the line intersects the volume.
        // Note: Since we want to bound to t==1, it's important for
        //       inverseRayDirection to not be normalized.
        auto intersectReturn{
            collisionVolume.intersects(start, inverseRayDirection, 0.f, 1.f)};
        if (intersectReturn.didIntersect) {
            hasIntersected = true;

            // If this is the earliest hit, track it.
            if (intersectReturn.tMin < firstHitInfo.hitT) {
                firstHitInfo.hitT = intersectReturn.tMin;
                firstHitInfo.collisionInfo = &collisionInfo;
            }
        }
    }
}

CollisionLocator::RaycastStrategyIntersectAll::RaycastStrategyIntersectAll(
    CollisionLocator& inCollisionLocator)
: collisionLocator{inCollisionLocator}
{
}

bool CollisionLocator::RaycastStrategyIntersectAll::isDone() const
{
    return !(collisionLocator.raycastReturnVector.empty());
}

void CollisionLocator::RaycastStrategyIntersectAll::intersectObjectsInCell(
    const Vector3& start, const Vector3& inverseRayDirection,
    const CellPosition& cellPosition, CollisionLayerBitSet collisionMask,
    std::span<entt::entity> entitiesToExclude, bool ignoreInsideHits)
{
    // We use terrainCollisionVolumes.back() as scratch space, then lock it in
    // by pushing a new element when we intersect.
    collisionLocator.terrainCollisionVolumes.emplace_back(
        BoundingBox{}, CollisionLayerType::TerrainWall);

    // If the line intersects any of this cell's terrain, track it.
    // Note: We ignore modelBounds and collisionEnabled on terrain, all
    //       terrain gets generated collision.
    if (CollisionLayerType::TerrainWall & collisionMask) {
        TileExtent cellTileExtent{
            CellExtent{cellPosition.x, cellPosition.y, cellPosition.z, 1, 1, 1},
            SharedConfig::COLLISION_LOCATOR_CELL_WIDTH,
            SharedConfig::COLLISION_LOCATOR_CELL_HEIGHT};
        for (int z{cellTileExtent.z}; z <= cellTileExtent.zMax(); ++z) {
            for (int y{cellTileExtent.y}; y <= cellTileExtent.yMax(); ++y) {
                for (int x{cellTileExtent.x}; x <= cellTileExtent.xMax(); ++x) {
                    TilePosition tilePosition{x, y, z};
                    std::size_t linearizedIndex{
                        collisionLocator.linearizeTileIndex(tilePosition)};
                    Terrain::Value terrainValue{
                        collisionLocator.terrainGrid[linearizedIndex]};
                    if (terrainValue == EMPTY_TERRAIN) {
                        continue;
                    }

                    // Check for inside hits.
                    BoundingBox& collisionVolume{
                        collisionLocator.terrainCollisionVolumes.back()
                            .collisionVolume};
                    collisionVolume
                        = Terrain::calcWorldBounds(tilePosition, terrainValue);
                    if (ignoreInsideHits && collisionVolume.contains(start)) {
                        continue;
                    }

                    // Check if the line intersects the volume.
                    // Note: Since we want to bound to t==1, it's important for
                    //       inverseRayDirection to not be normalized.
                    auto intersectReturn{collisionVolume.intersects(
                        start, inverseRayDirection, 0.f, 1.f)};
                    if (intersectReturn.didIntersect) {
                        collisionLocator.raycastReturnVector.emplace_back(
                            intersectReturn.tMin,
                            &(collisionLocator.terrainCollisionVolumes.back()));

                        // Add an element for the next iteration.
                        collisionLocator.terrainCollisionVolumes.emplace_back(
                            BoundingBox{}, CollisionLayerType::TerrainWall);
                    }
                }
            }
        }
    }

    // If the line intersects any of this cell's objects, track it.
    std::size_t linearizedIndex{
        collisionLocator.linearizeCellIndex(cellPosition)};
    std::vector<Uint16>& cell{collisionLocator.collisionGrid[linearizedIndex]};
    for (Uint16 collisionVolumeIndex : cell) {
        const CollisionInfo& collisionInfo{
            collisionLocator.collisionVolumes[collisionVolumeIndex]};

        // Check for masking.
        bool isInMask{
            static_cast<bool>(collisionInfo.collisionLayers & collisionMask)};
        if (!isInMask) {
            continue;
        }

        // Check for exclusion.
        if ((collisionInfo.entity != entt::null)
            && (std::ranges::contains(entitiesToExclude,
                                      collisionInfo.entity))) {
            continue;
        }

        // Check for inside hits.
        const BoundingBox& collisionVolume{collisionInfo.collisionVolume};
        if (ignoreInsideHits && collisionVolume.contains(start)) {
            continue;
        }

        // Check if the line intersects the volume.
        // Note: Since we want to bound to t==1, it's important for
        //       inverseRayDirection to not be normalized.
        auto intersectReturn{
            collisionVolume.intersects(start, inverseRayDirection, 0.f, 1.f)};
        if (intersectReturn.didIntersect) {
            collisionLocator.raycastReturnVector.emplace_back(
                intersectReturn.tMin, &collisionInfo);
        }
    }
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/Components/Camera.cpp`:

```cpp
#include "Camera.h"
#include "Transforms.h"
#include "SharedConfig.h"

namespace AM
{

TileExtent Camera::getTileViewExtent(const TileExtent& mapTileExtent) const
{
    TileExtent tileViewExtent(viewBounds);

    // Clip the view to the tile map's bounds.
    return tileViewExtent.intersectWith(mapTileExtent);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/Components/CastCooldown.cpp`:

```cpp
#include "CastCooldown.h"

namespace AM
{

bool CastCooldown::isCastOnCooldown(CastableID castableID, Uint32 currentTick)
{
    Uint32 tickDiff{currentTick - lastUpdateTick};

    // Update the GCD.
    if (gcdTicksRemaining > 0) {
        if (gcdTicksRemaining <= tickDiff) {
            gcdTicksRemaining = 0;
        }
        else {
            // GCD is still active. Return early.
            gcdTicksRemaining -= tickDiff;
            return true;
        }
    }

    // Update the rest of the cooldowns.
    // Note: This uses the erase-remove idiom, similar to std::remove.
    bool castableFound{false};
    auto first{cooldowns.begin()};
    for (auto it{cooldowns.begin()}; it != cooldowns.end(); ++it) {
        if (it->ticksRemaining > tickDiff) {
            // This cooldown hasn't expired. Update its time.
            it->ticksRemaining -= tickDiff;

            // If this is the desired castable, mark it as found.
            if (it->castableID == castableID) {
                castableFound = true;
            }

            // Move this cooldown in front of any expired cooldowns.
            *(first++) = std::move(*it);
        }
    }

    // Erase all of the expired cooldowns.
    cooldowns.erase(first, cooldowns.end());

    lastUpdateTick = currentTick;

    return castableFound;
}

void CastCooldown::update(Uint32 newTick)
{
    Uint32 tickDiff{newTick - lastUpdateTick};

    // Update the GCD.
    if (gcdTicksRemaining <= tickDiff) {
        gcdTicksRemaining = 0;
    }
    else {
        gcdTicksRemaining -= tickDiff;
    }

    // Update the rest of the cooldowns.
    // Note: This uses the erase-remove idiom, similar to std::remove.
    auto first{cooldowns.begin()};
    for (auto it{cooldowns.begin()}; it != cooldowns.end(); ++it) {
        if (it->ticksRemaining > tickDiff) {
            // This cooldown hasn't expired. Update its time.
            it->ticksRemaining -= tickDiff;

            // Move this cooldown in front of any expired cooldowns.
            *(first++) = std::move(*it);
        }
    }

    // Erase all of the expired cooldowns.
    cooldowns.erase(first, cooldowns.end());

    // Track that we updated to the given tick.
    lastUpdateTick = newTick;
}

void CastCooldown::initAfterLoad(Uint32 lastSavedTick, Uint32 currentTick)
{
    // Update to account for the time between the last update and when this 
    // component was saved.
    update(lastSavedTick);

    // Since we've accounted for all the time pre-save, we can now start 
    // tracking the current session.
    lastUpdateTick = currentTick;
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/Components/CollisionBitSets.cpp`:

```cpp
#include "CollisionBitSets.h"
#include "Input.h"
#include "IsClientEntity.h"
#include "entt/entity/registry.hpp"

namespace AM
{

CollisionBitSets::CollisionBitSets()
: collisionLayers{DEFAULT_COLLISION_LAYERS}
, collisionMask{DEFAULT_COLLISION_MASK}
{
}

CollisionBitSets::CollisionBitSets(entt::entity entity,
                                   entt::registry& registry)
{
    setCollisionLayers(DEFAULT_COLLISION_LAYERS, entity, registry);
    setCollisionMask(DEFAULT_COLLISION_MASK);
}

void CollisionBitSets::setCollisionLayers(
    CollisionLayerBitSet inCollisionLayers, entt::entity entity,
    entt::registry& registry)
{
    collisionLayers = inCollisionLayers;

    // Make sure none of the tile layer types are set.
    collisionLayers
        &= ~(CollisionLayerType::TerrainWall | CollisionLayerType::Object);

    // Set Client/NonClient ourselves, so it's always accurate.
    collisionLayers &= ~(CollisionLayerType::ClientEntity
                         | CollisionLayerType::NonClientEntity);
    if (registry.all_of<IsClientEntity>(entity)) {
        collisionLayers |= CollisionLayerType::ClientEntity;
    }
    else {
        collisionLayers |= CollisionLayerType::NonClientEntity;
    }

    // If the entity is movement-enabled, don't let it block collision.
    // Note: See EntityMover.h for more info.
    if (registry.all_of<Input>(entity)) {
        collisionLayers &= ~CollisionLayerType::BlockCollision;
    }
}

void CollisionBitSets::setCollisionMask(CollisionLayerBitSet inCollisionMask)
{
    // Note: All entities always collide with TerrainWall. We do this to
    //       avoid devs accidentally removing TerrainWall collision and
    //       having their NCE fall through the floor.
    collisionMask = inCollisionMask | CollisionLayerType::TerrainWall;
}

CollisionLayerBitSet CollisionBitSets::getCollisionLayers() const
{
    return collisionLayers;
}

CollisionLayerBitSet CollisionBitSets::getCollisionMask() const
{
    return collisionMask;
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/Components/Interaction.cpp`:

```cpp
#include "Interaction.h"
#include "SharedConfig.h"
#include "Log.h"
#include "AMAssert.h"
#include <algorithm>

namespace AM
{

bool Interaction::add(EntityInteractionType newInteraction)
{
    if (supportedInteractions.size()
        == SharedConfig::MAX_ENTITY_INTERACTIONS) {
        // The interaction limit has been reached.
        return false;
    }
    else if (std::ranges::find(supportedInteractions, newInteraction)
             != supportedInteractions.end()) {
        // The interaction is already present.
        return false;
    }

    supportedInteractions.emplace_back(newInteraction);
    return true;
}

bool Interaction::supports(EntityInteractionType desiredInteraction) const
{
    return (std::ranges::find(supportedInteractions, desiredInteraction)
            != supportedInteractions.end());
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/Components/Inventory.cpp`:

```cpp
#include "Inventory.h"
#include "ItemDataBase.h"

namespace AM
{

Inventory::Inventory(Uint8 inSize)
: size{inSize}
, slots(size)
{
}

bool Inventory::addItem(ItemID itemID, Uint8 count, Uint8 maxStackSize)
{
    // If there's an existing slot with the same item type and enough room, 
    // add to it.
    for (ItemSlot& slot : slots) {
        Uint16 combinedCount{static_cast<Uint16>(slot.count + count)};
        if ((slot.ID == itemID) && (combinedCount <= maxStackSize)) {
            slot.count = static_cast<Uint8>(combinedCount);
            return true;
        }
    }

    // If there's an existing empty slot, fill it with the given item.
    for (ItemSlot& slot : slots) {
        if (slot.ID == NULL_ITEM_ID) {
            slot.ID = itemID;
            slot.count = count;
            return true;
        }
    }

    return false;
}

bool Inventory::removeItem(Uint8 slotIndex, Uint8 count)
{
    // If the slot is invalid or empty, return false.
    if (!slotIndexIsValid(slotIndex) || (slots[slotIndex].count == 0)) {
        return false;
    }

    // Remove the given count of items from the slot.
    reduceItemCount(slotIndex, count);

    return true;
}

bool Inventory::moveItem(Uint8 sourceSlotIndex, Uint8 destSlotIndex)
{
    // If either slot is invalid, return false.
    if (!slotIndexIsValid(sourceSlotIndex)
        || !slotIndexIsValid(destSlotIndex)) {
        return false;
    }

    // Swap the slots.
    ItemSlot& sourceSlot{slots[sourceSlotIndex]};
    ItemSlot& destSlot{slots[destSlotIndex]};

    ItemSlot temp{destSlot};
    destSlot = sourceSlot;
    sourceSlot = temp;

    return true;
}

bool Inventory::contains(ItemID itemID) const
{
    for (const ItemSlot& slot : slots) {
        if ((slot.ID == itemID) && (slot.count > 0)) {
            return true;
        }
    }

    return false;
}

ItemID Inventory::getItemID(Uint8 slotIndex) const
{
    // If the slot is invalid or empty, return null.
    if (!slotIndexIsValid(slotIndex) || (slots[slotIndex].count == 0)) {
        return NULL_ITEM_ID;
    }

    return slots[slotIndex].ID;
}

std::size_t Inventory::getItemCount(ItemID itemID) const
{
    std::size_t count{0};
    for (const ItemSlot& slot : slots) {
        if (slot.ID == itemID) {
            count += slot.count;
        }
    }

    return count;
}

const Item* Inventory::getItem(Uint8 slotIndex,
                               const ItemDataBase& itemData) const
{
    // If the slot is invalid or empty, return nullptr.
    if (ItemID itemID{getItemID(slotIndex)}) {
        return itemData.getItem(itemID);
    }
    else {
        return nullptr;
    }
}

const ItemCombination* Inventory::combineItems(Uint8 sourceSlotIndex,
                                               Uint8 targetSlotIndex,
                                               const ItemDataBase& itemData)
{
    // If either slot is invalid or empty, do nothing.
    if (!slotIndexIsValid(sourceSlotIndex) || !slotIndexIsValid(targetSlotIndex)
        || (slots[sourceSlotIndex].count == 0)
        || (slots[targetSlotIndex].count == 0)) {
        return nullptr;
    }

    // Get the items in the given slots. If either item no longer exists, do 
    // nothing.
    ItemID sourceItemID{slots[sourceSlotIndex].ID};
    ItemID targetItemID{slots[targetSlotIndex].ID};
    const Item* sourceItem{itemData.getItem(sourceItemID)};
    const Item* targetItem{itemData.getItem(targetItemID)};
    if (!sourceItem || !targetItem) {
        return nullptr;
    }

    // Try to find a matching combination in either item's list.
    const ItemCombination* matchingCombination{nullptr};
    for (const ItemCombination& combination : sourceItem->itemCombinations) {
        if (combination.otherItemID == targetItemID) {
            matchingCombination = &combination;
            break;
        }
    }
    if (!matchingCombination) {
        for (const ItemCombination& combination :
             targetItem->itemCombinations) {
            if (combination.otherItemID == sourceItemID) {
                matchingCombination = &combination;
                break;
            }
        }
    }

    // If we found a resulting item, combine the items.
    if (matchingCombination) {
        // Decrement each item's count, erasing them if appropriate.
        reduceItemCount(sourceSlotIndex, 1);
        reduceItemCount(targetSlotIndex, 1);

        // Add the new item.
        const Item* resultItem{
            itemData.getItem(matchingCombination->resultItemID)};
        addItem(resultItem->numericID, 1, resultItem->maxStackSize);
    }

    return matchingCombination;
}

void Inventory::combineItems(Uint8 sourceSlotIndex, Uint8 targetSlotIndex,
                             ItemID resultItemID, Uint8 resultItemMaxStackSize)
{
    // If either slot is invalid or empty, return false.
    if (!slotIndexIsValid(sourceSlotIndex) || !slotIndexIsValid(targetSlotIndex)
        || (slots[sourceSlotIndex].count == 0)
        || (slots[targetSlotIndex].count == 0)) {
        return;
    }

    // Combine the items:
    // Decrement each item's count, erasing them if appropriate.
    reduceItemCount(sourceSlotIndex, 1);
    reduceItemCount(targetSlotIndex, 1);

    // Add the new item.
    addItem(resultItemID, 1, resultItemMaxStackSize);
}

void Inventory::resize(Uint8 newSize)
{
    size = newSize;
    slots.resize(newSize);
}

Uint8 Inventory::getFilledSlotCount()
{
    Uint8 count{0};
    for (ItemSlot& slot : slots) {
        if (slot.ID != NULL_ITEM_ID) {
            count++;
        }
    }

    return count;
}

bool Inventory::slotIndexIsValid(Uint8 slotIndex) const
{
    return (slotIndex < size) && (slotIndex < slots.size());
}

void Inventory::reduceItemCount(Uint8 slotIndex, Uint8 count)
{
    // Reduce the count.
    ItemSlot& itemSlot{slots[slotIndex]};
    itemSlot.count -= count;

    // If the slot is out of items, set it to empty.
    if (itemSlot.count == 0) {
        itemSlot.ID = NULL_ITEM_ID;
        itemSlot.count = 0;
    }
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/Cylinder.cpp`:

```cpp
#include "Cylinder.h"
#include "Position.h"
#include "BoundingBox.h"
#include <cmath>

namespace AM
{

bool Cylinder::intersects(const Position& position) const
{
    // If the cylinder doesn't intersect along the Z axis, return false.
    float cylinderMinZ{center.z - halfHeight};
    float cylinderMaxZ{center.z + halfHeight};
    if ((position.z < cylinderMinZ) || (position.z > cylinderMaxZ)) {
        return false;
    }

    // The point intersects along the Z axis. The rest of the test now 
    // reduces to a 2D circle/rectangle intersection.

    // Calc the X/Y components of the distance from our center to the point.
    float distanceX{std::abs(center.x - position.x)};
    float distanceY{std::abs(center.y - position.y)};

    // Calc the distance. Keep it squared to avoid a sqrt.
    float distanceSquared{(distanceX * distanceX) + (distanceY * distanceY)};

    return (distanceSquared <= (radius * radius));
}

bool Cylinder::intersects(const BoundingBox& boundingBox) const
{
    return boundingBox.intersects(*this);
}

void Cylinder::print() const
{
    LOG_INFO("(%.4f, %.4f, %.4f), %.4f, %.4f", center.x, center.y, center.z,
             radius, halfHeight);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/EntityLocator.cpp`:

```cpp
#include "EntityLocator.h"
#include "SharedConfig.h"
#include "Position.h"
#include "Cylinder.h"
#include "BoundingBox.h"
#include "Collision.h"
#include "CellPosition.h"
#include "TilePosition.h"
#include "Log.h"
#include "AMAssert.h"
#include "entt/entity/registry.hpp"
#include <cmath>
#include <algorithm>

namespace AM
{
EntityLocator::EntityLocator(entt::registry& inRegistry)
: registry{inRegistry}
, gridCellExtent{}
, entityGrid{}
, entityMap{}
, returnVector{}
{
}

void EntityLocator::setGridSize(const TileExtent& mapTileExtent)
{
    // Set our grid extent to match the tile map.
    gridCellExtent
        = CellExtent(mapTileExtent, SharedConfig::ENTITY_LOCATOR_CELL_WIDTH,
                     SharedConfig::ENTITY_LOCATOR_CELL_HEIGHT);

    // Resize the grid to fit the map.
    entityGrid.resize(linearizeCellIndex(gridCellExtent.max()) + 1);
}

bool EntityLocator::updateEntity(entt::entity entity, const Position& position)
{
    // Find the cell that the entity's position intersects.
    CellPosition cellPosition(position, CELL_WORLD_WIDTH, CELL_WORLD_HEIGHT);
    if (!(gridCellExtent.contains(cellPosition))) {
        LOG_ERROR("Tried to track entity that is outside of the locator's "
                  "grid: (%d, %d, %d)ce.",
                  cellPosition.x, cellPosition.y, cellPosition.z);
        return false;
    }

    // If we're already tracking this entity.
    auto entityIt{entityMap.find(entity)};
    if (entityIt != entityMap.end()) {
        // If the cell position hasn't changed, exit early.
        if (cellPosition == entityIt->second) {
            return true;
        }
        else {
            // Cell position isn't the same. Remove the entity from the old 
            // cell.
            clearEntityFromCell(entity, entityIt->second);
        }
    }

    // Add the entity to the cell.
    std::size_t linearizedIndex{linearizeCellIndex(cellPosition)};
    std::vector<entt::entity>& cell{entityGrid[linearizedIndex]};

    cell.push_back(entity);

    // Update the entity map.
    entityMap[entity] = cellPosition;

    return true;
}

void EntityLocator::removeEntity(entt::entity entity)
{
    // If we aren't already tracking this entity, error.
    auto entityIt{entityMap.find(entity)};
    if (entityIt == entityMap.end()) {
        // Note: Since every entity has a position, we expect them to always 
        //       be in this locator.
        LOG_ERROR("Tried to remove entity that wasn't added to this locator.");
        return;
    }

    // Remove the entity from cell that it's located in.
    clearEntityFromCell(entity, entityIt->second);

    // Remove the entity from the map.
    entityMap.erase(entityIt);
}

std::vector<entt::entity>& EntityLocator::getEntities(const Cylinder& cylinder)
{
    AM_ASSERT(cylinder.radius >= 0, "Cylinder can't have negative radius.");
    AM_ASSERT(cylinder.halfHeight >= 0,
              "Cylinder can't have negative half height.");

    // Perform a broad phase.
    getEntitiesBroad(cylinder);

    // Erase any entities whose position isn't within the cylinder.
    std::erase_if(returnVector, [this, &cylinder](entt::entity entity) {
        const Position& position{registry.get<Position>(entity)};
        return !(cylinder.intersects(position));
    });

    return returnVector;
}

std::vector<entt::entity>&
    EntityLocator::getEntities(const TileExtent& tileExtent)
{
    // Perform a broad phase.
    getEntitiesBroad(tileExtent);

    // Erase any entities that don't actually intersect the extent.
    std::erase_if(returnVector, [this, &tileExtent](entt::entity entity) {
        const Position& position{registry.get<Position>(entity)};
        return !(tileExtent.contains(position));
    });

    return returnVector;
}

std::vector<entt::entity>&
    EntityLocator::getEntities(const ChunkExtent& chunkExtent)
{
    // Convert to TileExtent.
    TileExtent tileExtent{chunkExtent};

    return getEntities(tileExtent);
}

std::vector<entt::entity>&
    EntityLocator::getEntitiesBroad(const Cylinder& cylinder)
{
    // Clear the return vector.
    returnVector.clear();

    // Calc the cell extent that is intersected by the cylinder.
    CellExtent cylinderCellExtent(cylinder, CELL_WORLD_WIDTH,
                                  CELL_WORLD_HEIGHT);

    // Clip the extent to the grid's bounds.
    cylinderCellExtent = cylinderCellExtent.intersectWith(gridCellExtent);

    // Add the entities in every intersected cell to the return vector.
    for (int z{cylinderCellExtent.z}; z <= cylinderCellExtent.zMax(); ++z) {
        for (int y{cylinderCellExtent.y}; y <= cylinderCellExtent.yMax(); ++y) {
            for (int x{cylinderCellExtent.x}; x <= cylinderCellExtent.xMax();
                 ++x) {
                // Add the entities in this cell to the return vector.
                std::size_t linearizedIndex{linearizeCellIndex({x, y, z})};
                std::vector<entt::entity>& entityVec{
                    entityGrid[linearizedIndex]};
                returnVector.insert(returnVector.end(), entityVec.begin(),
                                    entityVec.end());
            }
        }
    }

    // Note: We don't need to de-duplicate since an entity's Position will only 
    //       ever be in one cell at a time.

    return returnVector;
}

std::vector<entt::entity>&
    EntityLocator::getEntitiesBroad(const BoundingBox& boundingBox)
{
    // Convert to TileExtent.
    return getEntitiesBroad(TileExtent(boundingBox));
}

std::vector<entt::entity>&
    EntityLocator::getEntitiesBroad(const TileExtent& tileExtent)
{
    // Clear the return vector.
    returnVector.clear();

    // Calc the cell extent that is intersected by the tile extent.
    CellExtent tileCellExtent(tileExtent,
                              SharedConfig::ENTITY_LOCATOR_CELL_WIDTH,
                              SharedConfig::ENTITY_LOCATOR_CELL_HEIGHT);

    // Clip the extent to the grid's bounds.
    tileCellExtent = tileCellExtent.intersectWith(gridCellExtent);

    // Add the entities in every intersected cell to the return vector.
    for (int z{tileCellExtent.z}; z <= tileCellExtent.zMax(); ++z) {
        for (int y{tileCellExtent.y}; y <= tileCellExtent.yMax(); ++y) {
            for (int x{tileCellExtent.x}; x <= tileCellExtent.xMax(); ++x) {
                // Add the entities in this cell to the return vector.
                std::size_t linearizedIndex{linearizeCellIndex({x, y, z})};
                std::vector<entt::entity>& entityVec{
                    entityGrid[linearizedIndex]};
                returnVector.insert(returnVector.end(), entityVec.begin(),
                                    entityVec.end());
            }
        }
    }

    // Note: We don't need to de-duplicate since an entity's Position will only 
    //       ever be in one cell at a time.

    return returnVector;
}

std::vector<entt::entity>&
    EntityLocator::getEntitiesBroad(const ChunkExtent& chunkExtent)
{
    // Convert to TileExtent.
    TileExtent tileExtent{chunkExtent};

    return getEntitiesBroad(tileExtent);
}

void EntityLocator::clearEntityFromCell(entt::entity entity,
                                        const CellPosition& clearPosition)
{
    // Find and erase the entity from the cell.
    std::size_t linearizedIndex{linearizeCellIndex(clearPosition)};
    std::vector<entt::entity>& cell{entityGrid[linearizedIndex]};

    auto entityIt{std::find(cell.begin(), cell.end(), entity)};
    if (entityIt != cell.end()) {
        cell.erase(entityIt);
    }
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/EntityMover.cpp`:

```cpp
#include "EntityMover.h"
#include "TileMapBase.h"
#include "EntityLocator.h"
#include "CollisionLocator.h"
#include "Input.h"
#include "Position.h"
#include "PreviousPosition.h"
#include "Movement.h"
#include "Rotation.h"
#include "Collision.h"
#include "IsClientEntity.h"
#include "MovementHelpers.h"
#include "Transforms.h"
#include "Log.h"
#include "entt/entity/registry.hpp"

namespace AM
{
EntityMover::EntityMover(const entt::registry& inRegistry,
                         const TileMapBase& inTileMap,
                         EntityLocator& inEntityLocator,
                         CollisionLocator& inCollisionLocator)
: registry{inRegistry}
, tileMap{inTileMap}
, entityLocator{inEntityLocator}
, collisionLocator{inCollisionLocator}
{
}

void EntityMover::moveEntity(const MoveEntityParams& params)
{
    // If no inputs are pressed and they aren't falling, nothing needs to 
    // be done.
    if (params.inputStates.none() && !(params.movement.isFalling)) {
        params.movement.velocity = {0, 0, 0};
        return;
    }

    // Calculate their updated velocity.
    params.movement.velocity = MovementHelpers::calcVelocity(
        params.inputStates, params.movement, params.movementMods);

    // Resolve any collisions with the surrounding bounding boxes.
    BoundingBox resolvedBounds{resolveCollisions(
        params.collision.worldBounds, params.movement,
        params.collisionBitSets.getCollisionMask(), params.deltaSeconds)};

    // Update their bounding box and position.
    // Note: The entity's position is relative to the model bounds stage, not 
    //       the model bounds directly. Because of this, we can't just get 
    //       the X/Y position from the center of the resolved bounds.
    //       We can get the Z position directly from it, though.
    params.position += (resolvedBounds.min - params.collision.worldBounds.min);
    params.position.z = resolvedBounds.min.z;
    // Note: Since clients calc bounds from the replicated position, we need to 
    //       use the same math here (instead of using resolvedBounds directly) 
    //       or the float result may end up slightly different.
    params.collision.worldBounds = Transforms::modelToWorldEntity(
        params.collision.modelBounds, params.position);

    // Update the direction they're facing, based on their current inputs.
    params.rotation
        = MovementHelpers::calcRotation(params.rotation, params.inputStates);

    // If they did actually move, update their position in the locators.
    if (params.position != params.previousPosition) {
        entityLocator.updateEntity(params.entity, params.position);

        collisionLocator.updateEntity(
            params.entity, params.collision.worldBounds,
            params.collisionBitSets.getCollisionLayers());
    }
}

BoundingBox EntityMover::resolveCollisions(
    const BoundingBox& currentBounds, Movement& movement,
    const CollisionLayerBitSet& collisionMask, double deltaSeconds)
{
    // Calc where the bounds will end up if there are no collisions.
    BoundingBox desiredBounds{currentBounds.translateBy(
        movement.velocity * static_cast<float>(deltaSeconds))};

    // Calc an extent that encompasses the entire potential movement.
    // Note: We add epsilon so that, if a box exactly lines up with the line  
    //       where two tiles meet, both tiles will be included.
    //       See the note in TileExtent(BoundingBox) for info on why this isn't 
    //       the standard behavior.
    BoundingBox broadPhaseBounds{currentBounds.unionWith(desiredBounds)
                                     .expandBy(MovementHelpers::WORLD_EPSILON)};

    // Clip the extent to the tile map's bounds.
    TileExtent broadPhaseTileExtent(broadPhaseBounds);
    broadPhaseTileExtent
        = broadPhaseTileExtent.intersectWith(tileMap.getTileExtent());

    // Collect the volumes of all static entities and tiles that intersect 
    // the broad phase bounds.
    auto& broadPhaseMatches{
        collisionLocator.getCollisions(broadPhaseTileExtent, collisionMask)};

    // Perform the iterations of the narrow phase to resolve any collisions.
    Vector3 originalVelocity{movement.velocity};
    BoundingBox resolvedBounds{currentBounds};
    float remainingTime{1.f};
    for (int i{0}; i < NARROW_PHASE_ITERATION_COUNT; ++i) {
        NarrowPhaseResult result{narrowPhase(broadPhaseMatches, resolvedBounds,
                                             movement, deltaSeconds,
                                             remainingTime)};
        resolvedBounds = result.resolvedBounds;
        remainingTime = result.remainingTime;

        if (result.remainingTime == 0) {
            break;
        }
    }

    // If the entity is in the air, maintain their X/Y velocity. This lets 
    // them continue moving, even if they temporarily get hung up on something
    // (e.g. hitting their feet on a wall while trying to jump onto it).
    // If the entity is grounded, this won't do anything (their X/Y velocity 
    // will be overwritten on the next tick).
    movement.velocity.x = originalVelocity.x;
    movement.velocity.y = originalVelocity.y;

    // If the final resolved bounds are outside of the map bounds, reject the 
    // move.
    if (!tileMap.getTileExtent().contains(resolvedBounds)) {
        // We need to reset their velocity so they don't get stuck if they 
        // were jumping.
        movement.velocity = {};
        return currentBounds;
    }

    return resolvedBounds;
}

EntityMover::NarrowPhaseResult EntityMover::narrowPhase(
    const std::vector<const CollisionLocator::CollisionInfo*>&
        broadPhaseMatches,
    const BoundingBox& currentBounds, Movement& movement, double deltaSeconds,
    float remainingTime)
{
    // This is the real distance that we're trying to move on this frame.
    Vector3 realVelocity{movement.velocity * static_cast<float>(deltaSeconds)};

    // Find the time of the first collision.
    float collisionTime{remainingTime};
    Vector3 normalToUse{};
    for (const auto* otherVolumeInfo : broadPhaseMatches) {
        Vector3 entryDistance{};
        Vector3 exitDistance{};
        Vector3 entryTimes{-std::numeric_limits<float>::infinity(),
                           -std::numeric_limits<float>::infinity(),
                           -std::numeric_limits<float>::infinity()};
        Vector3 exitTimes{std::numeric_limits<float>::infinity(),
                          std::numeric_limits<float>::infinity(),
                          std::numeric_limits<float>::infinity()};

        const BoundingBox& currentBox{currentBounds};
        const BoundingBox& otherBox{otherVolumeInfo->collisionVolume};

        // Calc the distances required for currentBox to enter and exit 
        // otherBox along each axis, then calc the time intervals where 
        // each axis is intersecting.
        if (realVelocity.x > 0.f) {
            entryDistance.x = otherBox.min.x - currentBox.max.x;
            exitDistance.x = otherBox.max.x - currentBox.min.x;
            entryTimes.x = entryDistance.x / realVelocity.x;
            exitTimes.x = exitDistance.x / realVelocity.x;
        }
        else if (realVelocity.x < 0.f) {
            entryDistance.x = otherBox.max.x - currentBox.min.x;
            exitDistance.x = otherBox.min.x - currentBox.max.x;
            entryTimes.x = entryDistance.x / realVelocity.x;
            exitTimes.x = exitDistance.x / realVelocity.x;
        }
        // Velocity == 0. If this axis isn't intersecting, it never will.
        else if (currentBox.max.x <= otherBox.min.x
                 || currentBox.min.x >= otherBox.max.x) {
            continue;
        }
        // Else velocity == 0 and the boxes are intersecting. Entry/exit times 
        // are defaulted to (-inf, inf) to handle this case.

        if (realVelocity.y > 0.f) {
            entryDistance.y = otherBox.min.y - currentBox.max.y;
            exitDistance.y = otherBox.max.y - currentBox.min.y;
            entryTimes.y = entryDistance.y / realVelocity.y;
            exitTimes.y = exitDistance.y / realVelocity.y;
        }
        else if (realVelocity.y < 0.f) {
            entryDistance.y = otherBox.max.y - currentBox.min.y;
            exitDistance.y = otherBox.min.y - currentBox.max.y;
            entryTimes.y = entryDistance.y / realVelocity.y;
            exitTimes.y = exitDistance.y / realVelocity.y;
        }
        else if (currentBox.max.y <= otherBox.min.y
                 || currentBox.min.y >= otherBox.max.y) {
            continue;
        }

        if (realVelocity.z > 0.f) {
            entryDistance.z = otherBox.min.z - currentBox.max.z;
            exitDistance.z = otherBox.max.z - currentBox.min.z;
            entryTimes.z = entryDistance.z / realVelocity.z;
            exitTimes.z = exitDistance.z / realVelocity.z;
        }
        else if (realVelocity.z < 0.f) {
            entryDistance.z = otherBox.max.z - currentBox.min.z;
            exitDistance.z = otherBox.min.z - currentBox.max.z;
            entryTimes.z = entryDistance.z / realVelocity.z;
            exitTimes.z = exitDistance.z / realVelocity.z;
        }
        else if (currentBox.max.z <= otherBox.min.z
                 || currentBox.min.z >= otherBox.max.z) {
            continue;
        }

        // Determine if the time intervals ever overlap eachother within the 
        // range [0, remainingTime] (i.e. if the boxes ever intersect in all 3 
        // axes during our desired movement).
        float maxEntryTime{
            std::max({entryTimes.x, entryTimes.y, entryTimes.z})};
        float minExitTime{
            std::min({exitTimes.x, exitTimes.y, exitTimes.z})};

        // No-collision cases:
        //   1. If maxEntry > minExit, all axes haven't entered until after 
        //      one has already left.
        //   2. If all entry times are < 0, the boxes are either already 
        //      colliding or have passed eachother.
        //   3. If maxEntryTime > remainingTime, a collision won't happen 
        //      during this movement.
        if (maxEntryTime > minExitTime
            || (entryTimes.x < 0.f && entryTimes.y < 0.f && entryTimes.z < 0.f)
            || (entryTimes.x > remainingTime) || (entryTimes.y > remainingTime)
            || (entryTimes.z > remainingTime)) {
            continue;
        }

        // There was a collision. Find the axis of rejection by determining 
        // which axis collided last, then use the opposite sign of our velocity
        // along that axis to get a surface normal.
        Vector3 normal{};
        if ((entryTimes.x > entryTimes.y) && (entryTimes.x > entryTimes.z)) {
            normal.x = -std::copysign(1.f, realVelocity.x);
        }
        else if (entryTimes.y > entryTimes.z) {
            normal.y = -std::copysign(1.f, realVelocity.y);
        }
        else {
            normal.z = -std::copysign(1.f, realVelocity.z);
        }

        // If this collision time is the smallest so far, use it.
        if (maxEntryTime < collisionTime) {
            collisionTime = maxEntryTime;
            normalToUse = normal;
        }
    }

    // Move the bounds to resolve the collision.
    Vector3 resolvedDistance{realVelocity * collisionTime};
    BoundingBox resolvedBounds{currentBounds.translateBy(resolvedDistance)};

    // Due to float precision loss, the resolved bounds may actually be 
    // slightly clipped inside the other bounds. To resolve this, move backwards
    // by an amount equal to our epsilon.
    static constexpr Vector3 BACKOFF_AMOUNT{MovementHelpers::WORLD_EPSILON,
                                            MovementHelpers::WORLD_EPSILON,
                                            MovementHelpers::WORLD_EPSILON};
    resolvedBounds = resolvedBounds.translateBy(BACKOFF_AMOUNT * normalToUse);

    // If they collided with the ground, reset their falling state.
    if (normalToUse.z == 1.f) {
        movement.isFalling = false;
        movement.jumpCount = 0;
    }

    // Set the velocity such that they'll slide along the collided surface 
    // on the next tick.
    movement.velocity = movement.velocity.slide(normalToUse);

    return {resolvedBounds, (remainingTime - collisionTime)};
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/GraphicData/Animation.cpp`:

```cpp
#include "Animation.h"
#include "Sprite.h"
#include "SharedConfig.h"
#include "Log.h"

namespace AM
{

const Sprite* Animation::getSpriteAtTime(double animationTime) const
{ 
    // Note: ResourceImporter should guarantee that every animation has at 
    //       least one filled frame.

    // Calculate which frame should be displayed, based on the given time and 
    // the animation's looping behavior.
    std::size_t desiredFrame{};
    double frameDuration{1.0 / static_cast<double>(fps)};
    if (loopStartFrame == frameCount) {
        // Play once
        desiredFrame = static_cast<std::size_t>(
            std::round(animationTime / frameDuration));
        if (desiredFrame >= frameCount) {
            return nullptr;
        }
    }
    else {
        // Loop

        // If we haven't looped yet, calc the frame as normal.
        double playOnceTime{frameCount * frameDuration};
        if (animationTime < playOnceTime) {
            desiredFrame = static_cast<std::size_t>(
                std::floor(animationTime / frameDuration));
        }
        else {
            // We've looped. Subtract the first play and calc the loop 
            // remainder.
            int loopFrameCount{frameCount - loopStartFrame};
            double loopTime{loopFrameCount * frameDuration};
            double remainderLoopTime{
                std::fmod((animationTime - playOnceTime), loopTime)};
            desiredFrame = loopStartFrame
                           + static_cast<std::size_t>(
                               std::floor(remainderLoopTime / frameDuration));
        }
    }

    // Find the sprite closest to, but not surpassing, the desired frame.
    const Sprite* sprite{&(frames[0].sprite.get())};
    for (std::size_t i{0}; i < frames.size(); ++i) {
        // If this frame number matches, or the next frame is a higher number, 
        // return this frame's sprite.
        if ((frames[i].frameNumber == desiredFrame)
            || (((i + 1) < frames.size())
                && (frames[i + 1].frameNumber > desiredFrame))) {
            sprite = &(frames[i].sprite.get());
            break;
        }
    }

    return sprite;
}

double Animation::getLengthS() const
{
    return frameCount / static_cast<double>(fps);
}

Uint32 Animation::getLengthTicks() const
{
    double lengthS{getLengthS()};
    return static_cast<Uint32>(lengthS / SharedConfig::SIM_TICK_TIMESTEP_S);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/GraphicData/GraphicDataBase.cpp`:

```cpp
#include "GraphicDataBase.h"
#include "StringTools.h"
#include "Paths.h"
#include "Log.h"
#include "AMAssert.h"
#include "nlohmann/json.hpp"

namespace detail
{
template<size_t, class T>
constexpr T&& identity(T&& x)
{
    return std::forward<T>(x);
}

template<class T, size_t... Indices>
constexpr auto array_repeat_impl(T&& x, std::index_sequence<Indices...>)
{
    return std::array{identity<Indices>(x)...};
}

} // namespace detail

namespace
{
/**
 * Used to fill our non-default-constructible GraphicRef arrays.
 * Ref: https://stackoverflow.com/a/63821008/4258629
 */
template<size_t N, class T>
constexpr auto constructAndFillArray(T&& x)
{
    return detail::array_repeat_impl(std::forward<T>(x),
                                     std::make_index_sequence<N>());
}

/** A scratch buffer used while processing string IDs.
    Must be file-local so it can be accessed by const functions. */
std::string workStringID{};
}

namespace AM
{

GraphicDataBase::GraphicDataBase(const nlohmann::json& resourceDataJson)
: sprites{}
, animations{}
, terrainGraphicSets{}
, floorGraphicSets{}
, wallGraphicSets{}
, objectGraphicSets{}
, spriteStringMap{}
, terrainGraphicSetStringMap{}
, floorGraphicSetStringMap{}
, wallGraphicSetStringMap{}
, objectGraphicSetStringMap{}
{
    // Parse the json structure to construct our sprites and animations.
    parseJson(resourceDataJson);
}

const Sprite& GraphicDataBase::getSprite(std::string_view stringID) const
{
    // Derive string ID in case the user accidentally passed a display name.
    StringTools::deriveStringID(stringID, workStringID);

    // Attempt to find the string ID.
    auto it{spriteStringMap.find(workStringID)};
    if (it == spriteStringMap.end()) {
        LOG_ERROR("Failed to find sprite with string ID: %s",
                  workStringID.c_str());
        return sprites[0];
    }

    return *(it->second);
}

const Sprite& GraphicDataBase::getSprite(SpriteID numericID) const
{
    if (numericID >= sprites.size()) {
        LOG_ERROR("Invalid numeric ID while getting sprite: %d", numericID);
        return sprites[0];
    }

    return sprites[numericID];
}

const Animation& GraphicDataBase::getAnimation(std::string_view stringID) const
{
    // Derive string ID in case the user accidentally passed a display name.
    StringTools::deriveStringID(stringID, workStringID);

    // Attempt to find the string ID.
    auto it{animationStringMap.find(workStringID)};
    if (it == animationStringMap.end()) {
        LOG_ERROR("Failed to find animation with string ID: %s",
                  workStringID.c_str());
        return animations[0];
    }

    return *(it->second);
}

const Animation& GraphicDataBase::getAnimation(AnimationID numericID) const
{
    if (numericID >= animations.size()) {
        LOG_ERROR("Invalid numeric ID while getting animation: %d", numericID);
        return animations[0];
    }

    return animations[numericID];
}

GraphicRef GraphicDataBase::getGraphic(GraphicID numericID) const
{
    if (isAnimationID(numericID)) {
        AnimationID animationID{toAnimationID(numericID)};
        return {getAnimation(animationID)};
    }
    else {
        SpriteID spriteID{toSpriteID(numericID)};
        return {getSprite(spriteID)};
    }
}

const TerrainGraphicSet&
    GraphicDataBase::getTerrainGraphicSet(std::string_view stringID) const
{
    StringTools::deriveStringID(stringID, workStringID);
    auto it{terrainGraphicSetStringMap.find(workStringID)};
    if (it == terrainGraphicSetStringMap.end()) {
        LOG_ERROR("Failed to find graphic set with string ID: %s",
                  workStringID.c_str());
        return terrainGraphicSets[0];
    }

    return *(it->second);
}

const FloorGraphicSet&
    GraphicDataBase::getFloorGraphicSet(std::string_view stringID) const
{
    // Derive string ID in case the user accidentally passed a display name.
    StringTools::deriveStringID(stringID, workStringID);

    auto it{floorGraphicSetStringMap.find(workStringID)};
    if (it == floorGraphicSetStringMap.end()) {
        LOG_ERROR("Failed to find graphic set with string ID: %s",
                  workStringID.c_str());
        return floorGraphicSets[0];
    }

    return *(it->second);
}

const WallGraphicSet&
    GraphicDataBase::getWallGraphicSet(std::string_view stringID) const
{
    StringTools::deriveStringID(stringID, workStringID);
    auto it{wallGraphicSetStringMap.find(workStringID)};
    if (it == wallGraphicSetStringMap.end()) {
        LOG_ERROR("Failed to find graphic set with string ID: %s",
                  workStringID.c_str());
        return wallGraphicSets[0];
    }

    return *(it->second);
}

const ObjectGraphicSet&
    GraphicDataBase::getObjectGraphicSet(std::string_view stringID) const
{
    StringTools::deriveStringID(stringID, workStringID);
    auto it{objectGraphicSetStringMap.find(workStringID)};
    if (it == objectGraphicSetStringMap.end()) {
        LOG_ERROR("Failed to find graphic set with string ID: %s",
                  workStringID.c_str());
        return objectGraphicSets[0];
    }

    return *(it->second);
}

const EntityGraphicSet&
    GraphicDataBase::getEntityGraphicSet(std::string_view stringID) const
{
    StringTools::deriveStringID(stringID, workStringID);
    auto it{entityGraphicSetStringMap.find(workStringID)};
    if (it == entityGraphicSetStringMap.end()) {
        LOG_ERROR("Failed to find graphic set with string ID: %s",
                  workStringID.c_str());
        return entityGraphicSets[0];
    }

    return *(it->second);
}

const TerrainGraphicSet& GraphicDataBase::getTerrainGraphicSet(
    TerrainGraphicSetID numericID) const
{
    if (numericID >= terrainGraphicSets.size()) {
        LOG_ERROR("Invalid numeric ID while getting graphic set: %d", numericID);
        return terrainGraphicSets[0];
    }

    return terrainGraphicSets[numericID];
}

const FloorGraphicSet&
    GraphicDataBase::getFloorGraphicSet(FloorGraphicSetID numericID) const
{
    if (numericID >= floorGraphicSets.size()) {
        LOG_ERROR("Invalid numeric ID while getting graphic set: %d", numericID);
        return floorGraphicSets[0];
    }

    return floorGraphicSets[numericID];
}

const WallGraphicSet&
    GraphicDataBase::getWallGraphicSet(WallGraphicSetID numericID) const
{
    if (numericID >= wallGraphicSets.size()) {
        LOG_ERROR("Invalid numeric ID while getting graphic set: %d", numericID);
        return wallGraphicSets[0];
    }

    return wallGraphicSets[numericID];
}

const ObjectGraphicSet&
    GraphicDataBase::getObjectGraphicSet(ObjectGraphicSetID numericID) const
{
    if (numericID >= objectGraphicSets.size()) {
        LOG_ERROR("Invalid numeric ID while getting graphic set: %d", numericID);
        return objectGraphicSets[0];
    }

    return objectGraphicSets[numericID];
}

const EntityGraphicSet&
    GraphicDataBase::getEntityGraphicSet(EntityGraphicSetID numericID) const
{
    if (numericID >= entityGraphicSets.size()) {
        LOG_ERROR("Invalid numeric ID while getting graphic set: %d", numericID);
        return entityGraphicSets[0];
    }

    return entityGraphicSets[numericID];
}

const std::vector<Sprite>& GraphicDataBase::getAllSprites() const
{
    return sprites;
}

const std::vector<TerrainGraphicSet>&
    GraphicDataBase::getAllTerrainGraphicSets() const
{
    return terrainGraphicSets;
}

const std::vector<FloorGraphicSet>& GraphicDataBase::getAllFloorGraphicSets() const
{
    return floorGraphicSets;
}

const std::vector<WallGraphicSet>& GraphicDataBase::getAllWallGraphicSets() const
{
    return wallGraphicSets;
}

const std::vector<ObjectGraphicSet>&
    GraphicDataBase::getAllObjectGraphicSets() const
{
    return objectGraphicSets;
}

const std::vector<EntityGraphicSet>&
    GraphicDataBase::getAllEntityGraphicSets() const
{
    return entityGraphicSets;
}

void GraphicDataBase::parseJson(const nlohmann::json& json)
{
    // Add the null sprite, animation, and graphic sets.
    GraphicRef nullSprite{sprites.emplace_back("Null", "null", NULL_SPRITE_ID)};
    animations.emplace_back("Null", "null", NULL_ANIMATION_ID);
    terrainGraphicSets.emplace_back(
        GraphicSet{"Null", "null", NULL_TERRAIN_GRAPHIC_SET_ID},
        constructAndFillArray<Terrain::Height::Count>(nullSprite));
    floorGraphicSets.emplace_back(
        GraphicSet{"Null", "null", NULL_FLOOR_GRAPHIC_SET_ID},
        constructAndFillArray<FloorGraphicSet::VARIATION_COUNT>(nullSprite));
    wallGraphicSets.emplace_back(
        GraphicSet{"Null", "null", NULL_WALL_GRAPHIC_SET_ID},
        constructAndFillArray<Wall::Type::Count>(nullSprite));
    objectGraphicSets.emplace_back(
        GraphicSet{"Null", "null", NULL_OBJECT_GRAPHIC_SET_ID},
        constructAndFillArray<ObjectGraphicSet::VARIATION_COUNT>(nullSprite));
    entityGraphicSets.emplace_back(
        GraphicSet{"Null", "null", NULL_ENTITY_GRAPHIC_SET_ID});

    // Parse the json and catch any parsing errors.
    try {
        // Resize the vectors to fit everything in the json.
        resizeVectors(json);

        // Iterate every sprite sheet and add all of their sprites.
        for (auto& sheetJson : json.at("spriteSheets").items()) {
            for (auto& spriteJson : sheetJson.value().at("sprites").items()) {
                // Parse the sprite's data and add it to our containers.
                parseSprite(spriteJson.value());
            }
        }

        // Add every animation.
        for (auto& animationJson : json.at("animations").items()) {
            parseAnimation(animationJson.value());
        }

        // Add each type of graphic set.
        for (auto& terrainJson : json.at("terrain").items()) {
            parseTerrainGraphicSet(terrainJson.value());
        }
        for (auto& floorJson : json.at("floors").items()) {
            parseFloorGraphicSet(floorJson.value());
        }
        for (auto& wallJson : json.at("walls").items()) {
            parseWallGraphicSet(wallJson.value());
        }
        for (auto& objectJson : json.at("objects").items()) {
            parseObjectGraphicSet(objectJson.value());
        }
        for (auto& entityJson : json.at("entities").items()) {
            parseEntityGraphicSet(entityJson.value());
        }
    } catch (nlohmann::json::type_error& e) {
        LOG_FATAL(
            "Failed to parse sprites and graphic sets in ResourceData.json: %s",
            e.what());
    }

    // Add everything to the associated maps.
    for (const Sprite& sprite : sprites) {
        spriteStringMap.emplace(sprite.stringID, &sprites[sprite.numericID]);
    }
    for (const Animation& animation : animations) {
        animationStringMap.emplace(animation.stringID,
                                   &animations[animation.numericID]);
    }
    for (const TerrainGraphicSet& set : terrainGraphicSets) {
        terrainGraphicSetStringMap.emplace(
            set.stringID, &terrainGraphicSets[set.numericID]);
    }
    for (const FloorGraphicSet& set : floorGraphicSets) {
        floorGraphicSetStringMap.emplace(set.stringID,
                                        &floorGraphicSets[set.numericID]);
    }
    for (const WallGraphicSet& set : wallGraphicSets) {
        wallGraphicSetStringMap.emplace(set.stringID,
                                       &wallGraphicSets[set.numericID]);
    }
    for (const ObjectGraphicSet& set : objectGraphicSets) {
        objectGraphicSetStringMap.emplace(set.stringID,
                                         &objectGraphicSets[set.numericID]);
    }
    for (const EntityGraphicSet& set : entityGraphicSets) {
        entityGraphicSetStringMap.emplace(set.stringID,
                                          &entityGraphicSets[set.numericID]);
    }
}

void GraphicDataBase::resizeVectors(const nlohmann::json& json)
{
    // For each category of graphics, find the max ID and resize the vector.
    // Note: We have to find the max ID instead of just getting the array 
    //       size because there may be ID gaps.

    // Sprite
    GraphicRef nullSprite{sprites.at(NULL_SPRITE_ID)};
    SpriteID maxSpriteID{0};
    for (auto& sheetJson : json.at("spriteSheets").items()) {
        for (auto& spriteJson : sheetJson.value().at("sprites").items()) {
            SpriteID spriteID{spriteJson.value().at("numericID")};
            maxSpriteID = std::max(maxSpriteID, spriteID);
        }
    }
    sprites.resize(maxSpriteID + 1);

    // Animation
    AnimationID maxAnimationID{0};
    for (auto& animationJson : json.at("animations").items()) {
        AnimationID animationID{animationJson.value().at("numericID")};
        maxAnimationID = std::max(maxAnimationID, animationID);
    }
    animations.resize(maxAnimationID + 1);

    // Terrain
    // Note: We need to initialize them with constructAndFillArray() because
    //       GraphicRef has no default constructor (must always be valid).
    TerrainGraphicSetID maxTerrainID{0};
    for (auto& terrainJson : json.at("terrain").items()) {
        TerrainGraphicSetID terrainID{terrainJson.value().at("numericID")};
        maxTerrainID = std::max(maxTerrainID, terrainID);
    }
    TerrainGraphicSet terrainGraphicSet{.graphics{
        constructAndFillArray<Terrain::Height::Count>(nullSprite)}};
    terrainGraphicSets.resize(maxTerrainID + 1, terrainGraphicSet);

    // Floors
    FloorGraphicSetID maxFloorID{0};
    for (auto& floorJson : json.at("floors").items()) {
        FloorGraphicSetID floorID{floorJson.value().at("numericID")};
        maxFloorID = std::max(maxFloorID, floorID);
    }
    FloorGraphicSet floorGraphicSet{
        .graphics{constructAndFillArray<FloorGraphicSet::VARIATION_COUNT>(
            nullSprite)}};
    floorGraphicSets.resize(maxFloorID + 1, floorGraphicSet);

    // Walls
    WallGraphicSetID maxWallID{0};
    for (auto& wallJson : json.at("walls").items()) {
        WallGraphicSetID wallID{wallJson.value().at("numericID")};
        maxWallID = std::max(maxWallID, wallID);
    }
    WallGraphicSet wallGraphicSet{
        .graphics{constructAndFillArray<Wall::Type::Count>(nullSprite)}};
    wallGraphicSets.resize(maxWallID + 1, wallGraphicSet);

    // Objects
    ObjectGraphicSetID maxObjectID{0};
    for (auto& objectJson : json.at("objects").items()) {
        ObjectGraphicSetID objectID{objectJson.value().at("numericID")};
        maxObjectID = std::max(maxObjectID, objectID);
    }
    ObjectGraphicSet objectGraphicSet{
        .graphics{constructAndFillArray<ObjectGraphicSet::VARIATION_COUNT>(
            nullSprite)}};
    objectGraphicSets.resize(maxObjectID + 1, objectGraphicSet);

    // Entities
    EntityGraphicSetID maxEntityID{0};
    for (auto& entityJson : json.at("entities").items()) {
        EntityGraphicSetID entityID{entityJson.value().at("numericID")};
        maxEntityID = std::max(maxEntityID, entityID);
    }
    entityGraphicSets.resize(maxEntityID + 1);
}

void GraphicDataBase::parseSprite(const nlohmann::json& spriteJson)
{
    // Add the sprite to the sprites vector.
    SpriteID numericID{spriteJson.at("numericID")};
    Sprite& sprite{sprites.at(numericID)};

    // Add the display name and IDs.
    sprite.numericID = numericID;
    sprite.displayName = spriteJson.at("displayName").get<std::string>();
    StringTools::deriveStringID(sprite.displayName, sprite.stringID);

    // Add whether the sprite has a bounding box or not.
    sprite.collisionEnabled = spriteJson.at("collisionEnabled");

    // Add the model-space bounds.
    sprite.modelBounds.min.x = spriteJson.at("modelBounds").at("minX");
    sprite.modelBounds.max.x = spriteJson.at("modelBounds").at("maxX");
    sprite.modelBounds.min.y = spriteJson.at("modelBounds").at("minY");
    sprite.modelBounds.max.y = spriteJson.at("modelBounds").at("maxY");
    sprite.modelBounds.min.z = spriteJson.at("modelBounds").at("minZ");
    sprite.modelBounds.max.z = spriteJson.at("modelBounds").at("maxZ");
}

void GraphicDataBase::parseAnimation(const nlohmann::json& animationJson)
{
    // Add the animation to the animations vector.
    AnimationID numericID{animationJson.at("numericID")};
    Animation& animation{animations.at(numericID)};

    // Add the display name and IDs.
    animation.numericID = numericID;
    animation.displayName = animationJson.at("displayName").get<std::string>();
    StringTools::deriveStringID(animation.displayName, animation.stringID);

    // Add the frame count, fps, and loop start frame.
    animation.frameCount = animationJson.at("frameCount");
    animation.fps = animationJson.at("fps");
    animation.loopStartFrame = animationJson.at("loopStartFrame");

    // Add the frames.
    // Note: If the animation is empty, the importer will give it a single 
    //       frame with the null sprite. This gets handled the same as any 
    //       other sprite by the renderer.
    const auto& frameNumbersJson{animationJson.at("frameNumbers")};
    const auto& spriteIdsJson{animationJson.at("spriteIDs")};
    for (std::size_t i{0}; i < frameNumbersJson.size(); ++i) {
        SpriteID spriteID{spriteIdsJson.at(i).get<SpriteID>()};
        Uint8 frameNumber{frameNumbersJson.at(i).get<Uint8>()};
        const Sprite& sprite{getSprite(spriteID)};
        animation.frames.emplace_back(frameNumber, sprite);
    }

    // Add whether the animation has a bounding box or not.
    animation.collisionEnabled = animationJson.at("collisionEnabled");

    // Add the model-space bounds.
    animation.modelBounds.min.x = animationJson.at("modelBounds").at("minX");
    animation.modelBounds.max.x = animationJson.at("modelBounds").at("maxX");
    animation.modelBounds.min.y = animationJson.at("modelBounds").at("minY");
    animation.modelBounds.max.y = animationJson.at("modelBounds").at("maxY");
    animation.modelBounds.min.z = animationJson.at("modelBounds").at("minZ");
    animation.modelBounds.max.z = animationJson.at("modelBounds").at("maxZ");
}

void GraphicDataBase::parseTerrainGraphicSet(const nlohmann::json& graphicSetJson)
{
    // Add a graphic set to the appropriate vector.
    TerrainGraphicSetID numericID{graphicSetJson.at("numericID")};
    TerrainGraphicSet& graphicSet{terrainGraphicSets.at(numericID)};
    graphicSet.numericID = numericID;
    graphicSet.displayName
        = graphicSetJson.at("displayName").get<std::string>();
    StringTools::deriveStringID(graphicSet.displayName, graphicSet.stringID);
    GraphicRef nullSprite{sprites[NULL_SPRITE_ID]};
    graphicSet.graphics
        = constructAndFillArray<Terrain::Height::Count>(nullSprite);

    // Add the graphics.
    const nlohmann::json& graphicIDJsonArr{graphicSetJson.at("graphicIDs")};
    if (graphicIDJsonArr.size() != Terrain::Height::Count) {
        LOG_FATAL("Invalid count for terrain graphic set: %s.",
                  graphicSet.displayName.c_str());
    }

    std::size_t index{0};
    for (auto& graphicIDJson : graphicIDJsonArr.items()) {
        GraphicID graphicID{graphicIDJson.value().get<GraphicID>()};
        graphicSet.graphics[index] = getGraphic(graphicID);
        index++;
    }
}

void GraphicDataBase::parseFloorGraphicSet(
    const nlohmann::json& graphicSetJson)
{
    // Add a graphic set to the appropriate vector.
    FloorGraphicSetID numericID{graphicSetJson.at("numericID")};
    FloorGraphicSet& graphicSet{floorGraphicSets.at(numericID)};
    graphicSet.numericID = numericID;
    graphicSet.displayName
        = graphicSetJson.at("displayName").get<std::string>();
    StringTools::deriveStringID(graphicSet.displayName, graphicSet.stringID);
    GraphicRef nullSprite{sprites[NULL_SPRITE_ID]};
    graphicSet.graphics
        = constructAndFillArray<FloorGraphicSet::VARIATION_COUNT>(nullSprite);

    // Add the graphics.
    const nlohmann::json& graphicIDJsonArr{graphicSetJson.at("graphicIDs")};
    if (graphicIDJsonArr.size() != FloorGraphicSet::VARIATION_COUNT) {
        LOG_FATAL("Invalid count for floor graphic set: %s.",
                  graphicSet.displayName.c_str());
    }

    std::size_t index{0};
    for (auto& graphicIDJson : graphicIDJsonArr.items()) {
        GraphicID graphicID{graphicIDJson.value().get<GraphicID>()};
        graphicSet.graphics[index] = getGraphic(graphicID);
        index++;
    }
}

void GraphicDataBase::parseWallGraphicSet(const nlohmann::json& graphicSetJson)
{
    // Collect the wall graphics.
    const nlohmann::json& graphicIDJsonArr{graphicSetJson.at("graphicIDs")};
    if (graphicIDJsonArr.size() != Wall::Type::Count) {
        LOG_FATAL("Invalid count for wall graphic set: %s.",
                  graphicSetJson.at("displayName").get<std::string>().c_str());
    }

    GraphicRef westGraphic{getGraphic(graphicIDJsonArr[0].get<GraphicID>())};
    GraphicRef northGraphic{getGraphic(graphicIDJsonArr[1].get<GraphicID>())};
    GraphicRef northwestGraphic{
        getGraphic(graphicIDJsonArr[2].get<GraphicID>())};
    GraphicRef northeastGraphic{
        getGraphic(graphicIDJsonArr[3].get<GraphicID>())};

    // Save the graphic set in the appropriate vector.
    WallGraphicSetID numericID{graphicSetJson.at("numericID")};
    WallGraphicSet& graphicSet{wallGraphicSets.at(numericID)};
    graphicSet.numericID = numericID;
    graphicSet.displayName
        = graphicSetJson.at("displayName").get<std::string>();
    StringTools::deriveStringID(graphicSet.displayName, graphicSet.stringID);
    graphicSet.graphics = std::array<GraphicRef, Wall::Type::Count>{
        westGraphic, northGraphic, northwestGraphic, northeastGraphic};
}

void GraphicDataBase::parseObjectGraphicSet(
    const nlohmann::json& graphicSetJson)
{
    // Add a graphic set to the appropriate vector.
    ObjectGraphicSetID numericID{graphicSetJson.at("numericID")};
    ObjectGraphicSet& graphicSet{objectGraphicSets.at(numericID)};
    graphicSet.numericID = numericID;
    graphicSet.displayName
        = graphicSetJson.at("displayName").get<std::string>();
    StringTools::deriveStringID(graphicSet.displayName, graphicSet.stringID);
    GraphicRef nullSprite{sprites[NULL_SPRITE_ID]};
    graphicSet.graphics
        = constructAndFillArray<ObjectGraphicSet::VARIATION_COUNT>(nullSprite);

    // Add the graphics.
    const nlohmann::json& graphicIDJsonArr{graphicSetJson.at("graphicIDs")};
    if (graphicIDJsonArr.size() != ObjectGraphicSet::VARIATION_COUNT) {
        LOG_FATAL("Invalid count for object graphic set: %s.",
                  graphicSet.displayName.c_str());
    }

    std::size_t index{0};
    for (auto& graphicIDJson : graphicIDJsonArr.items()) {
        GraphicID graphicID{graphicIDJson.value().get<GraphicID>()};
        graphicSet.graphics[index] = getGraphic(graphicID);
        index++;
    }
}

void GraphicDataBase::parseEntityGraphicSet(
    const nlohmann::json& graphicSetJson)
{
    // Add a graphic set to the appropriate vector.
    EntityGraphicSetID numericID{graphicSetJson.at("numericID")};
    EntityGraphicSet& graphicSet{entityGraphicSets.at(numericID)};
    graphicSet.numericID = numericID;
    graphicSet.displayName
        = graphicSetJson.at("displayName").get<std::string>();
    StringTools::deriveStringID(graphicSet.displayName, graphicSet.stringID);

    // Add the graphics.
    const auto& graphicIDTypesJson{graphicSetJson.at("graphicIDTypes")};
    const auto& graphicIDValuesJson{graphicSetJson.at("graphicIDValues")};
    GraphicRef nullSprite{sprites[NULL_SPRITE_ID]};
    for (std::size_t i{0}; i < graphicIDTypesJson.size(); ++i) {
        if (graphicIDValuesJson.at(i).size() != Rotation::Direction::Count) {
            LOG_FATAL("Invalid count for entity graphic set: %s, index: %u.",
                      graphicSet.displayName.c_str(), i);
        }

        EntityGraphicType graphicType{
            graphicIDTypesJson.at(i).get<EntityGraphicType>()};
        const auto& graphicIDArr{graphicIDValuesJson.at(i)};

        // Init an empty array for this type.
        graphicSet.graphics.emplace(
            graphicType,
            constructAndFillArray<Rotation::Direction::Count>(nullSprite));

        // Fill the array.
        auto& graphicArr{graphicSet.graphics.at(graphicType)};
        for (int j{0}; j < Rotation::Direction::Count; ++j) {
            graphicArr[j] = getGraphic(graphicIDArr.at(j).get<GraphicID>());
        }
    }
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/GraphicData/GraphicID.cpp`:

```cpp
#include "GraphicID.h"

namespace AM
{

bool isSpriteID(GraphicID graphicID)
{
    return !((static_cast<Uint32>(graphicID) & GRAPHIC_ID_TYPE_MASK) >> 31);
}

bool isAnimationID(GraphicID graphicID)
{
    return ((static_cast<Uint32>(graphicID) & GRAPHIC_ID_TYPE_MASK) >> 31);
}

SpriteID toSpriteID(GraphicID graphicID)
{
    if (!isSpriteID(graphicID)) {
        return NULL_SPRITE_ID;
    }

    return (static_cast<SpriteID>(graphicID) & GRAPHIC_ID_VALUE_MASK);
}

AnimationID toAnimationID(GraphicID graphicID)
{
    if (!isAnimationID(graphicID)) {
        return NULL_ANIMATION_ID;
    }

    return (static_cast<AnimationID>(graphicID) & GRAPHIC_ID_VALUE_MASK);
}

GraphicID toGraphicID(SpriteID spriteID)
{
    // Sprite IDs don't need any special changes.
    return static_cast<GraphicID>(spriteID);
}

GraphicID toGraphicID(AnimationID animationID)
{
    // Set the top bit to indicate that this is an animation.
    return static_cast<GraphicID>(animationID | GRAPHIC_ID_ANIMATION_VALUE);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/GraphicData/GraphicRef.cpp`:

```cpp
#include "GraphicRef.h"
#include "VariantTools.h"
#include "Log.h"

namespace AM
{

GraphicID GraphicRef::getGraphicID() const
{
    GraphicID graphicID{NULL_GRAPHIC_ID};
    std::visit(VariantTools::Overload{
        [&](std::reference_wrapper<const Sprite> sprite) {
            graphicID = toGraphicID(sprite.get().numericID);
        },
        [&](std::reference_wrapper<const Animation> animation) {
            graphicID = toGraphicID(animation.get().numericID);
        }
    }, *this);

    return graphicID;
}

const std::string& GraphicRef::getDisplayName() const
{
    const std::string* displayName{};
    std::visit(
        [&](const auto& underlying) {
            displayName = &(underlying.get().displayName);
        },
        *this);

    return *displayName;
}

bool GraphicRef::getCollisionEnabled() const
{
    bool collisionEnabled{false};
    std::visit(
        [&](const auto& underlying) {
            collisionEnabled = underlying.get().collisionEnabled;
        },
        *this);

    return collisionEnabled;
}

const BoundingBox& GraphicRef::getModelBounds() const
{
    const BoundingBox* modelBounds{nullptr};
    std::visit(
        [&](const auto& underlying) {
            modelBounds = &(underlying.get().modelBounds);
        },
        *this);

    return *modelBounds;
}

const Sprite& GraphicRef::getFirstSprite() const
{
    const Sprite* spritePtr{nullptr};
    std::visit(VariantTools::Overload{
        [&](std::reference_wrapper<const Sprite> sprite) {
            spritePtr = &(sprite.get());
        },
        [&](std::reference_wrapper<const Animation> animation) {
            if (animation.get().frames.size() > 0) {
                spritePtr = &(animation.get().frames[0].sprite.get());
            }
        }
    }, *this);

    return *spritePtr;
}

const Sprite* GraphicRef::getSpriteAtTime(double animationTime) const
{
    const Sprite* spritePtr{nullptr};
    std::visit(VariantTools::Overload{
        [&](std::reference_wrapper<const Sprite> sprite) {
            spritePtr = &(sprite.get());
        },
        [&](std::reference_wrapper<const Animation> animation) {
            spritePtr = animation.get().getSpriteAtTime(animationTime);
        }
    }, *this);

    return spritePtr;
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/GraphicData/GraphicSets.cpp`:

```cpp
#include "GraphicSets.h"
#include "Log.h"
#include "AMAssert.h"

namespace AM
{

const Sprite& TerrainGraphicSet::getThumbnailSprite() const
{
    for (const GraphicRef& graphic : graphics) {
        if (graphic.getGraphicID() != NULL_GRAPHIC_ID) {
            return graphic.getFirstSprite();
        }
    }

    return graphics[0].getFirstSprite();
}

const Sprite& FloorGraphicSet::getThumbnailSprite() const
{
    for (const GraphicRef& graphic : graphics) {
        if (graphic.getGraphicID() != NULL_GRAPHIC_ID) {
            return graphic.getFirstSprite();
        }
    }

    return graphics[0].getFirstSprite();
}

const Sprite& WallGraphicSet::getThumbnailSprite() const
{
    return graphics[0].getFirstSprite();
}

const Sprite& ObjectGraphicSet::getThumbnailSprite() const
{
    for (const GraphicRef& graphic : graphics) {
        if (graphic.getGraphicID() != NULL_GRAPHIC_ID) {
            return graphic.getFirstSprite();
        }
    }

    return graphics[0].getFirstSprite();
}

const Sprite& EntityGraphicSet::getThumbnailSprite() const
{
    // Note: Idle South is guaranteed to be present in every entity graphic
    //       set (though it may be the null sprite).
    const auto& graphicArr{graphics.at(EntityGraphicType::Idle)};
    return graphicArr.at(Rotation::Direction::South).getFirstSprite();
}

BoundingBox EntityGraphicSet::getCollisionModelBounds() const
{
    AM_ASSERT(graphics.contains(EntityGraphicType::Idle),
              "Entity graphic set is missing Idle: %s.", displayName.c_str());

    // Note: Entity collision always comes from its Idle South graphic.
    const auto& idleGraphicArray{graphics.at(EntityGraphicType::Idle)};
    const GraphicRef& idleSouthGraphicRef{
        idleGraphicArray[Rotation::Direction::South]};
    return idleSouthGraphicRef.getModelBounds();
}

bool EntityGraphicSet::contains(EntityGraphicType type,
                                Rotation::Direction direction) const
{
    auto it{graphics.find(type)};
    if (it != graphics.end()) {
        return (it->second.at(direction).getGraphicID() != NULL_GRAPHIC_ID);
    }

    return false;
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/IconData/IconDataBase.cpp`:

```cpp
#include "IconDataBase.h"
#include "StringTools.h"
#include "Paths.h"
#include "Log.h"
#include "nlohmann/json.hpp"

namespace
{
/** A scratch buffer used while processing string IDs.
    Must be file-local so it can be accessed by const functions. */
std::string workStringID{};
}

namespace AM
{
IconDataBase::IconDataBase(const nlohmann::json& resourceDataJson)
: icons{}
, iconStringMap{}
{
    // Parse the json structure to construct our icons.
    parseJson(resourceDataJson);
}

const Icon& IconDataBase::getIcon(std::string_view stringID) const
{
    // Derive string ID in case the user accidentally passed a display name.
    StringTools::deriveStringID(stringID, workStringID);

    // Attempt to find the given string ID.
    auto it{iconStringMap.find(workStringID)};
    if (it == iconStringMap.end()) {
        LOG_ERROR("Failed to find icon with string ID: %s",
                  workStringID.c_str());
        return icons[0];
    }

    return *(it->second);
}

const Icon& IconDataBase::getIcon(IconID numericID) const
{
    if (numericID >= icons.size()) {
        LOG_ERROR("Invalid numeric ID while getting icon: %d", numericID);
        return icons[0];
    }

    return icons[numericID];
}

const std::vector<Icon>& IconDataBase::getAllIcons() const
{
    return icons;
}

void IconDataBase::parseJson(const nlohmann::json& json)
{
    // Add the null icon.
    icons.emplace_back("Null", "null", NULL_ICON_ID);

    // Parse the json and catch any parsing errors.
    try {
        // Iterate every icon sheet and add all of their icons.
        for (auto& sheetJson : json.at("iconSheets").items()) {
            for (auto& iconJson : sheetJson.value().at("icons").items()) {
                // Parse the icon's data and add it to our containers.
                parseIcon(iconJson.value());
            }
        }
    } catch (nlohmann::json::type_error& e) {
        LOG_FATAL("Failed to parse icon sheets in ResourceData.json: %s",
                  e.what());
    }

    // Add everything to the associated maps.
    for (const Icon& icon : icons) {
        iconStringMap.emplace(icon.stringID, &icons[icon.numericID]);
    }
}

void IconDataBase::parseIcon(const nlohmann::json& iconJson)
{
    // Add the icon to the icons vector.
    Icon& icon{icons.emplace_back()};

    // Add the display name and IDs.
    icon.numericID = iconJson.at("numericID");
    icon.displayName = iconJson.at("displayName").get<std::string>();
    icon.stringID = iconJson.at("stringID").get<std::string>();
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/ItemData/Item.cpp`:

```cpp
#include "Item.h"
#include <algorithm>

namespace AM
{
bool Item::addInteraction(ItemInteractionType newInteraction)
{
    if (supportedInteractions.size()
        == SharedConfig::MAX_ENTITY_INTERACTIONS) {
        // The interaction limit has been reached.
        return false;
    }
    else if (std::ranges::find(supportedInteractions, newInteraction)
             != supportedInteractions.end()) {
        // The interaction is already present.
        return false;
    }

    supportedInteractions.emplace_back(newInteraction);
    return true;
}

bool Item::supportsInteraction(ItemInteractionType desiredInteraction) const
{
    // All items support UseOn, Destroy, and Examine.
    if ((desiredInteraction == ItemInteractionType::UseOn)
        || (desiredInteraction == ItemInteractionType::Destroy)
        || (desiredInteraction == ItemInteractionType::Examine)) {
        return true;
    }

    return (std::ranges::find(supportedInteractions, desiredInteraction)
            != supportedInteractions.end());
}

std::vector<ItemInteractionType> Item::getInteractionList() const
{
    // First, fill the list with this item's supported interactions.
    std::vector<ItemInteractionType> interactionList(supportedInteractions);

    // Then, fill it with UseOn, Destroy, and Examine.
    interactionList.emplace_back(ItemInteractionType::UseOn);
    interactionList.emplace_back(ItemInteractionType::Destroy);
    interactionList.emplace_back(ItemInteractionType::Examine);

    return interactionList;
}

ItemInteractionType Item::getDefaultInteraction() const
{
    // If this item doesn't have any custom interactions, return UseOn (the
    // first built-in interaction).
    if (supportedInteractions.empty()) {
        return ItemInteractionType::UseOn;
    }
    else {
        return supportedInteractions[0];
    }
}

std::size_t Item::getInteractionCount() const
{
    return supportedInteractions.size() + BUILTIN_INTERACTION_COUNT;
}

} // namespace AM

```

`Source/SharedLib/Simulation/Private/ItemData/ItemDataBase.cpp`:

```cpp
#include "ItemDataBase.h"
#include "ItemID.h"
#include "Log.h"
#include "AMAssert.h"

namespace AM
{
ItemDataBase::ItemDataBase()
: itemMap{}
, itemStringMap{}
, itemVersionMap{}
, nextItemID{NULL_ITEM_ID + 1}
, itemCreatedSig{}
, itemUpdatedSig{}
, itemCreated{itemCreatedSig}
, itemUpdated{itemUpdatedSig}
{
    // Note: We intentionally don't have a "null item", because we want the 
    //       getters to return nullptr if there isn't a real item to return.
}

const Item* ItemDataBase::loadItem(const Item& referenceItem,
                                   ItemVersion version)
{
    // Check if the item already exists, so we can signal properly later.
    bool itemExisted{itemMap.find(referenceItem.numericID) != itemMap.end()};

    // Add or update the item in our maps.
    // Note: When we insert into an unordered_map, references to the map's
    //       elements are guaranteed to remain valid (for itemStringMap).
    itemMap[referenceItem.numericID] = referenceItem;
    Item& item{itemMap[referenceItem.numericID]};
    itemVersionMap[item.numericID] = version;
    itemStringMap[item.stringID] = &item;

    // Always update nextItemID to be 1 greater than the highest ID.
    if (item.numericID >= nextItemID) {
        nextItemID = (item.numericID + 1);
    }

    // Signal that an item has been updated or created.
    if (itemExisted) {
        itemUpdatedSig.publish(item.numericID);
    }
    else {
        itemCreatedSig.publish(item.numericID);
    }

    return &item;
}

const Item* ItemDataBase::getItem(std::string_view stringID) const
{
    // Attempt to find the string ID.
    auto it{itemStringMap.find(stringID)};
    if (it == itemStringMap.end()) {
        return nullptr;
    }

    return it->second;
}

const Item* ItemDataBase::getItem(ItemID numericID) const
{
    // Attempt to find the given numeric ID.
    auto it{itemMap.find(numericID)};
    if (it == itemMap.end()) {
        return nullptr;
    }

    return &(it->second);
}

ItemVersion ItemDataBase::getItemVersion(ItemID numericID) const
{
    // Attempt to find the given numeric ID.
    auto it{itemVersionMap.find(numericID)};
    if (it == itemVersionMap.end()) {
        LOG_ERROR("Tried to get invalid item's version. ID: %u", numericID);
        return 0;
    }

    return it->second;
}

const std::unordered_map<ItemID, Item>& ItemDataBase::getAllItems() const
{
    return itemMap;
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/MovementHelpers.cpp`:

```cpp
#include "MovementHelpers.h"
#include "Position.h"
#include "PreviousPosition.h"
#include "Movement.h"
#include "MovementModifiers.h"
#include "BoundingBox.h"
#include "SharedConfig.h"

/** The constant to multiply by when normalizing a diagonal direction vector
    to be equal magnitude to movement in cardinal directions.
    sin(45) == cos(45) == 0.70710678118 */
const float DIAGONAL_NORMALIZATION_CONSTANT{0.70710678118f};

namespace AM
{

Vector3 MovementHelpers::calcVelocity(const Input::StateArr& inputStates,
                                      Movement& movement,
                                      const MovementModifiers& movementMods)
{
    // Update the entity's velocity, depending on whether it can fly or not.
    Vector3 updatedVelocity{};
    if (movementMods.canFly) {
        updatedVelocity
            = calcVelocityCanFly(inputStates, movement, movementMods);
    }
    else {
        updatedVelocity
            = calcVelocityNoFly(inputStates, movement, movementMods);
    }

    // Apply the project's velocity mod.
    updatedVelocity += movementMods.velocityMod;

    // Clamp Z to the terminal velocity.
    updatedVelocity.z
        = std::max(updatedVelocity.z, SharedConfig::TERMINAL_VELOCITY);

    // If the entity had Z velocity prior to this update, assume they're 
    // falling. When they collide with the ground, this will be set to false 
    // by the collision logic.
    if (movement.velocity.z != 0) {
        movement.isFalling = true;
    }

    return updatedVelocity;
}

Position MovementHelpers::calcPosition(const Position& position,
                                       const Vector3& velocity,
                                       double deltaSeconds)
{
    // Update the position.
    Position newPosition{position};
    newPosition.x += static_cast<float>((deltaSeconds * velocity.x));
    newPosition.y += static_cast<float>((deltaSeconds * velocity.y));
    newPosition.z += static_cast<float>((deltaSeconds * velocity.z));

    return newPosition;
}

Rotation MovementHelpers::calcRotation(const Rotation& rotation,
                                       const Input::StateArr& inputStates)
{
    // Direction values. 0 == no movement, 1 == movement.
    int xUp{static_cast<int>(inputStates[Input::XUp])};
    int xDown{static_cast<int>(inputStates[Input::XDown])};
    int yUp{static_cast<int>(inputStates[Input::YUp])};
    int yDown{static_cast<int>(inputStates[Input::YDown])};

    // Calculate which direction the entity is facing, based on its inputs.
    // Note: Opposite inputs cancel eachother out.
    int directionInt{3 * (yDown - yUp) + xUp - xDown};
    Rotation::Direction direction{directionIntToDirection(directionInt)};

    switch (direction) {
        case Rotation::Direction::None: {
            // No inputs or canceling inputs, keep the current direction.
            return rotation;
        }
        default: {
            return {direction};
        }
    }
}

Position
    MovementHelpers::interpolatePosition(const PreviousPosition& previousPos,
                                         const Position& position, double alpha)
{
    double interpX{(position.x * alpha) + (previousPos.x * (1.0 - alpha))};
    double interpY{(position.y * alpha) + (previousPos.y * (1.0 - alpha))};
    double interpZ{(position.z * alpha) + (previousPos.z * (1.0 - alpha))};
    return {static_cast<float>(interpX), static_cast<float>(interpY),
            static_cast<float>(interpZ)};
}

Rotation::Direction MovementHelpers::directionIntToDirection(int directionInt)
{
    switch (directionInt) {
        case -4: {
            return Rotation::Direction::SouthWest;
        }
        case -3: {
            return Rotation::Direction::South;
        }
        case -2: {
            return Rotation::Direction::SouthEast;
        }
        case -1: {
            return Rotation::Direction::West;
        }
        case 0: {
            return Rotation::Direction::None;
        }
        case 1: {
            return Rotation::Direction::East;
        }
        case 2: {
            return Rotation::Direction::NorthWest;
        }
        case 3: {
            return Rotation::Direction::North;
        }
        case 4: {
            return Rotation::Direction::NorthEast;
        }
        default: {
            LOG_FATAL("Invalid direction int.");
            return Rotation::Direction::None;
        }
    }
}

Vector3
    MovementHelpers::calcVelocityCanFly(const Input::StateArr& inputStates,
                                        Movement& movement,
                                        const MovementModifiers& movementMods)
{
    Vector3 updatedVelocity{movement.velocity};

    // Direction values. 0 == no movement, 1 == movement.
    int xUp{static_cast<int>(inputStates[Input::XUp])};
    int xDown{static_cast<int>(inputStates[Input::XDown])};
    int yUp{static_cast<int>(inputStates[Input::YUp])};
    int yDown{static_cast<int>(inputStates[Input::YDown])};
    int zUp{static_cast<int>(inputStates[Input::Jump])};
    int zDown{static_cast<int>(inputStates[Input::Crouch])};

    // Calculate their direction vector, based on their inputs.
    // Note: Opposite inputs cancel eachother out.
    float xDirection{static_cast<float>(xUp - xDown)};
    float yDirection{static_cast<float>(yUp - yDown)};
    float zDirection{static_cast<float>(zUp - zDown)};

    // If they're moving diagonally, normalize their direction vector.
    if ((xDirection != 0) && (yDirection != 0)) {
        xDirection *= DIAGONAL_NORMALIZATION_CONSTANT;
        yDirection *= DIAGONAL_NORMALIZATION_CONSTANT;
    }

    // Calc the new velocities.
    updatedVelocity.x = xDirection * movementMods.runSpeed;
    updatedVelocity.y = yDirection * movementMods.runSpeed;
    updatedVelocity.z = zDirection * movementMods.runSpeed;

    // Note: Since they're flying, we don't apply gravity.

    return updatedVelocity;
}

Vector3
    MovementHelpers::calcVelocityNoFly(const Input::StateArr& inputStates,
                                       Movement& movement,
                                       const MovementModifiers& movementMods)
{
    Vector3 updatedVelocity{movement.velocity};

    /** Calc the new Z velocity. **/
    // If they're trying and able to jump, do so.
    bool didJump{false};
    if (inputStates[Input::Jump] && !(movement.jumpHeld)
        && (movement.jumpCount < movementMods.maxJumpCount)) {
        updatedVelocity.z = static_cast<float>(movementMods.jumpImpulse);
        movement.jumpCount++;
        didJump = true;
    }

    // True if the entity is jumping while already in the air.
    bool isAirJumping{movement.isFalling && didJump};
    // True if the entity is moving vertically through the air, e.g. after 
    // jumping straight up.
    bool isVerticalFalling{movement.isFalling && (updatedVelocity.x == 0)
                           && (updatedVelocity.y == 0)};

    // If they're on the ground, or just air jumped, or are falling vertically, 
    // calc their new X/Y velocity.
    // Note: The only other case is that they're falling through the air, in 
    //       which case they'll keep traveling with their current X/Y velocity.
    if (!(movement.isFalling) || isAirJumping || isVerticalFalling) {
        // Direction values. 0 == no movement, 1 == movement.
        int xUp{static_cast<int>(inputStates[Input::XUp])};
        int xDown{static_cast<int>(inputStates[Input::XDown])};
        int yUp{static_cast<int>(inputStates[Input::YUp])};
        int yDown{static_cast<int>(inputStates[Input::YDown])};

        // Calculate their direction vector, based on their inputs.
        // Note: Opposite inputs cancel eachother out.
        float xDirection{static_cast<float>(xUp - xDown)};
        float yDirection{static_cast<float>(yUp - yDown)};

        // If they're moving diagonally, normalize their direction vector.
        if ((xDirection != 0) && (yDirection != 0)) {
            xDirection *= DIAGONAL_NORMALIZATION_CONSTANT;
            yDirection *= DIAGONAL_NORMALIZATION_CONSTANT;
        }

        // Calc the new X/Y velocity.
        if (isVerticalFalling) {
            updatedVelocity.x
                = xDirection * SharedConfig::VERTICAL_FALL_MOVE_VELOCITY;
            updatedVelocity.y
                = yDirection * SharedConfig::VERTICAL_FALL_MOVE_VELOCITY;
        }
        else {
            updatedVelocity.x = xDirection * movementMods.runSpeed;
            updatedVelocity.y = yDirection * movementMods.runSpeed;
        }
    }

    // Always apply gravity.
    updatedVelocity.z -= SharedConfig::FORCE_OF_GRAVITY;

    // Update their jump held state, for use next time.
    movement.jumpHeld = inputStates[Input::Jump];

    return updatedVelocity;
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/Ray.cpp`:

```cpp
#include "Ray.h"
#include "Log.h"

namespace AM
{

Vector3 Ray::getPointAtT(float t)
{
    return {(origin.x + (direction.x * t)), (origin.y + (direction.y * t)),
            (origin.z + (direction.z * t))};
}

void Ray::print() const
{
    LOG_INFO("Origin: (%.4f, %.4f, %.4f), Direction: (%.4f, %.4f, %.4f)",
             origin.x, origin.y, origin.z, direction.x, direction.y,
             direction.z);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/ResourceData.cpp`:

```cpp
#include "ResourceData.h"
#include "Paths.h"
#include "Log.h"
#include "nlohmann/json.hpp"
#include <fstream>

namespace AM
{

ResourceData::ResourceData()
{
    // Open the file.
    std::string fullPath{Paths::BASE_PATH};
    fullPath += "ResourceData.json";
    std::ifstream workingFile(fullPath);
    if (!(workingFile.is_open())) {
        LOG_FATAL("Failed to open ResourceData.json");
    }

    // Parse the file into a json structure.
    try {
        resourceDataJson = std::make_unique<nlohmann::json>(
            nlohmann::json::parse(workingFile, nullptr, true));
    } catch (nlohmann::json::exception& e) {
        LOG_FATAL("Failed to parse ResourceData.json: %s", e.what());
    }
}

ResourceData::~ResourceData() = default;

nlohmann::json& ResourceData::get()
{
    if (!resourceDataJson) {
        LOG_FATAL("Tried to get uninitialized json object.");
    }

    return *resourceDataJson;
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/TileMap/CellExtent.cpp`:

```cpp
#include "CellExtent.h"
#include "TileExtent.h"
#include "BoundingBox.h"
#include "Cylinder.h"
#include "MovementHelpers.h"
#include "SharedConfig.h"
#include "Log.h"
#include <cmath>

namespace AM
{
CellExtent::CellExtent()
: DiscreteExtent<DiscreteImpl::CellTag>()
{
}

CellExtent::CellExtent(int inX, int inY, int inZ, int inXLength, int inYLength,
                       int inZLength)
: DiscreteExtent<DiscreteImpl::CellTag>(inX, inY, inZ, inXLength, inYLength,
                                        inZLength)
{
}

CellExtent::CellExtent(
    const DiscreteExtent<DiscreteImpl::CellTag>& cellExtent)
: DiscreteExtent<DiscreteImpl::CellTag>(cellExtent)
{
}

CellExtent::CellExtent(const TileExtent& tileExtent, std::size_t cellWidthTiles,
                       std::size_t cellHeightTiles)
{
    const float CELL_WIDTH{static_cast<float>(cellWidthTiles)};
    const float CELL_HEIGHT{static_cast<float>(cellHeightTiles)};

    // Note: We use floor instead of integer division because negative values
    //       still need to round down.
    x = static_cast<int>(std::floor(tileExtent.x / CELL_WIDTH));
    y = static_cast<int>(std::floor(tileExtent.y / CELL_WIDTH));
    z = static_cast<int>(std::floor(tileExtent.z / CELL_HEIGHT));

    int maxX{static_cast<int>(
        std::ceil((tileExtent.x + tileExtent.xLength) / CELL_WIDTH))};
    int maxY{static_cast<int>(
        std::ceil((tileExtent.y + tileExtent.yLength) / CELL_WIDTH))};
    int maxZ{static_cast<int>(
        std::ceil((tileExtent.z + tileExtent.zLength) / CELL_HEIGHT))};

    xLength = (maxX - x);
    yLength = (maxY - y);
    zLength = (maxZ - z);
}

CellExtent::CellExtent(const BoundingBox& box, float cellWidth,
                       float cellHeight)
{
    // Note: One could imagine doing the opposite logic here (if a box is 
    //       exactly touching the edge of a cell, include it in the extent).
    //       However, this would make it so that a box with the exact bounds 
    //       of a cell would convert into an extent that includes every cell 
    //       around it, which seems unexpected.

    // To account for float precision issues: add the epsilon to each min value,
    // then round down. If the box is within epsilon range of a cell in the 
    // negative direction, it won't be included in this extent.
    x = static_cast<int>(std::floor(
        (box.min.x + MovementHelpers::WORLD_EPSILON) / cellWidth));
    y = static_cast<int>(std::floor(
        (box.min.y + MovementHelpers::WORLD_EPSILON) / cellWidth));
    z = static_cast<int>(std::floor(
        (box.min.z + MovementHelpers::WORLD_EPSILON) / cellHeight));

    // Subtract the epsilon from each max value, then round up. If the box is 
    // within epsilon range of a cell in the positive direction, it won't be 
    // included in this extent.
    float maxTileX{
        std::ceil((box.max.x - MovementHelpers::WORLD_EPSILON) / cellWidth)};
    float maxTileY{
        std::ceil((box.max.y - MovementHelpers::WORLD_EPSILON) / cellWidth)};
    float maxTileZ{
        std::ceil((box.max.z - MovementHelpers::WORLD_EPSILON) / cellHeight)};
    xLength = (static_cast<int>(maxTileX) - x);
    yLength = (static_cast<int>(maxTileY) - y);
    zLength = (static_cast<int>(maxTileZ) - z);
}

CellExtent::CellExtent(const Cylinder& cylinder, float cellWidth,
                       float cellHeight)
{
    x = static_cast<int>(
        std::floor((cylinder.center.x - cylinder.radius) / cellWidth));
    y = static_cast<int>(
        std::floor((cylinder.center.y - cylinder.radius) / cellWidth));
    z = static_cast<int>(
        std::floor((cylinder.center.z - cylinder.halfHeight) / cellHeight));

    // Note: Be careful not to do this sort of thing in an initializer list 
    //       through the base class's constructor (we're subtracting other 
    //       struct members, which wouldn't yet be initialized).
    xLength = static_cast<int>(
                  std::ceil((cylinder.center.x + cylinder.radius) / cellWidth))
              - x;
    yLength = static_cast<int>(
                  std::ceil((cylinder.center.y + cylinder.radius) / cellWidth))
              - y;
    zLength = static_cast<int>(std::ceil(
                  (cylinder.center.z + cylinder.halfHeight) / cellHeight))
              - z;
}

void CellExtent::print() const
{
    LOG_INFO("(%d, %d, %d, %d, %d, %d)", x, y, z, xLength, yLength, zLength);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/TileMap/CellPosition.cpp`:

```cpp
#include "CellPosition.h"
#include "Vector3.h"
#include "TilePosition.h"
#include "SharedConfig.h"
#include "MovementHelpers.h"
#include "Log.h"

namespace AM
{
CellPosition::CellPosition()
: DiscretePosition<DiscreteImpl::CellTag>()
{
}

CellPosition::CellPosition(int inX, int inY, int inZ)
: DiscretePosition<DiscreteImpl::CellTag>(inX, inY, inZ)
{
}

CellPosition::CellPosition(
    const DiscretePosition<DiscreteImpl::CellTag>& cellPosition)
: DiscretePosition<DiscreteImpl::CellTag>(cellPosition)
{
}

CellPosition::CellPosition(const Vector3& worldPoint, float cellWidth,
                           float cellHeight)
: DiscretePosition<DiscreteImpl::CellTag>(
    static_cast<int>(std::floor(worldPoint.x / cellWidth)),
    static_cast<int>(std::floor(worldPoint.y / cellWidth)),
    static_cast<int>(std::floor(worldPoint.z / cellHeight)))
{
}

CellPosition::CellPosition(const TilePosition& tilePosition,
                           std::size_t cellWidthTiles,
                           std::size_t cellHeightTiles)
: DiscretePosition<DiscreteImpl::CellTag>(
    static_cast<int>(
        std::floor(tilePosition.x / static_cast<float>(cellWidthTiles))),
    static_cast<int>(
        std::floor(tilePosition.y / static_cast<float>(cellWidthTiles))),
    static_cast<int>(
        std::floor(tilePosition.z / static_cast<float>(cellHeightTiles))))
{
}

void CellPosition::print() const
{
    LOG_INFO("(%d, %d, %d)", x, y, z);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/TileMap/Chunk.cpp`:

```cpp
#include "Chunk.h"
#include "Morton.h"
#include "AMAssert.h"
#include <cstdint>

namespace AM
{

Tile& Chunk::getTile(Uint16 tileOffsetX, Uint16 tileOffsetY)
{
    AM_ASSERT(tileOffsetX < tiles.size(), "Invalid tile offset.");
    AM_ASSERT(tileOffsetY < tiles.size(), "Invalid tile offset.");
    return tiles[mortonEncode(tileOffsetX, tileOffsetY)];
}

const Tile& Chunk::getTile(Uint16 tileOffsetX, Uint16 tileOffsetY) const
{
    AM_ASSERT(tileOffsetX < tiles.size(), "Invalid tile offset.");
    AM_ASSERT(tileOffsetY < tiles.size(), "Invalid tile offset.");
    return tiles[mortonEncode(tileOffsetX, tileOffsetY)];
}

Uint32 Chunk::mortonEncode(Uint16 x, Uint16 y) const
{
    // If x and y fit in our lookup table, use it. Otherwise, calculate it 
    // at runtime.
    if constexpr (SharedConfig::CHUNK_WIDTH <= 16) {
        return Morton::encode16x16(static_cast<Uint8>(x),
                                        static_cast<Uint8>(y));
    }
    else {
        return Morton::encode32(x, y);
    }
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/TileMap/ChunkExtent.cpp`:

```cpp
#include "ChunkExtent.h"
#include "TileExtent.h"
#include "SharedConfig.h"

namespace AM
{
ChunkExtent::ChunkExtent()
: DiscreteExtent<DiscreteImpl::ChunkTag>()
{
}

ChunkExtent::ChunkExtent(int inX, int inY, int inZ, int inXLength,
                         int inYLength, int inZLength)
: DiscreteExtent<DiscreteImpl::ChunkTag>(inX, inY, inZ, inXLength, inYLength,
                                         inZLength)
{
}

ChunkExtent::ChunkExtent(
    const DiscreteExtent<DiscreteImpl::ChunkTag>& chunkExtent)
: DiscreteExtent<DiscreteImpl::ChunkTag>(chunkExtent)
{
}

ChunkExtent::ChunkExtent(const TileExtent& tileExtent)
: DiscreteExtent<DiscreteImpl::ChunkTag>(
    static_cast<int>(tileExtent.x / SharedConfig::CHUNK_WIDTH),
    static_cast<int>(tileExtent.y / SharedConfig::CHUNK_WIDTH),
    static_cast<int>(tileExtent.z / SharedConfig::CHUNK_WIDTH),
    static_cast<int>(tileExtent.xLength / SharedConfig::CHUNK_WIDTH),
    static_cast<int>(tileExtent.yLength / SharedConfig::CHUNK_WIDTH),
    static_cast<int>(tileExtent.zLength / SharedConfig::CHUNK_WIDTH))
{
}

void ChunkExtent::print() const
{
    LOG_INFO("(%d, %d, %d, %d, %d, %d)", x, y, z, xLength, yLength, zLength);
}

ChunkExtent ChunkExtent::fromMapLengths(Uint16 mapXLengthChunks,
                                        Uint16 mapYLengthChunks,
                                        Uint16 mapZLengthChunks)
{
    return {-(mapXLengthChunks / 2), -(mapYLengthChunks / 2), 0,
            mapXLengthChunks,        mapYLengthChunks,        mapZLengthChunks};
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/TileMap/ChunkPosition.cpp`:

```cpp
#include "ChunkPosition.h"
#include "Vector3.h"
#include "TilePosition.h"
#include "SharedConfig.h"
#include "Log.h"

namespace AM
{
ChunkPosition::ChunkPosition()
: DiscretePosition<DiscreteImpl::ChunkTag>()
{
}

ChunkPosition::ChunkPosition(int inX, int inY, int inZ)
: DiscretePosition<DiscreteImpl::ChunkTag>(inX, inY, inZ)
{
}

ChunkPosition::ChunkPosition(
    const DiscretePosition<DiscreteImpl::ChunkTag>& chunkPosition)
: DiscretePosition<DiscreteImpl::ChunkTag>(chunkPosition)
{
}

ChunkPosition::ChunkPosition(const Vector3& worldPoint)
{
    static constexpr float CHUNK_WIDTH{static_cast<float>(
        SharedConfig::TILE_WORLD_WIDTH * SharedConfig::CHUNK_WIDTH)};
    static constexpr float CHUNK_HEIGHT{
        static_cast<float>(SharedConfig::TILE_WORLD_HEIGHT)};

    x = static_cast<int>(std::floor(worldPoint.x / CHUNK_WIDTH));
    y = static_cast<int>(std::floor(worldPoint.y / CHUNK_WIDTH));
    z = static_cast<int>(std::floor(worldPoint.z / CHUNK_HEIGHT));
}

ChunkPosition::ChunkPosition(const TilePosition& tilePosition)
: DiscretePosition<DiscreteImpl::ChunkTag>(
    static_cast<int>(tilePosition.x / SharedConfig::CHUNK_WIDTH),
    static_cast<int>(tilePosition.y / SharedConfig::CHUNK_WIDTH),
    tilePosition.z)
{
}

void ChunkPosition::print() const
{
    LOG_INFO("(%d, %d, %d)", x, y, z);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/TileMap/Floor.cpp`:

```cpp
#include "Floor.h"
#include "TilePosition.h"
#include "Position.h"
#include "SharedConfig.h"
#include "AMAssert.h"

namespace AM
{
static constexpr float WIDTH{SharedConfig::TILE_WORLD_WIDTH};

/** World-space bounding boxes for each terrain height. */
static constexpr BoundingBox FLOOR_BOX{{0, 0, 0}, {WIDTH, WIDTH, 0}};

BoundingBox Floor::calcWorldBounds(const TilePosition& tilePosition)
{
    // Move the bounds to the tile's origin.
    Vector3 tileOrigin{tilePosition.getOriginPoint()};
    return FLOOR_BOX.translateBy(tileOrigin);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/TileMap/Terrain.cpp`:

```cpp
#include "Terrain.h"
#include "TilePosition.h"
#include "Position.h"
#include "SharedConfig.h"
#include "AMAssert.h"

namespace AM
{
static constexpr float WIDTH{SharedConfig::TILE_WORLD_WIDTH};
static constexpr float HEIGHT{SharedConfig::TILE_WORLD_HEIGHT};
static constexpr float ONE_THIRD_HEIGHT{HEIGHT / 3};
static constexpr float TWO_THIRD_HEIGHT{(HEIGHT / 3) * 2};

/** World-space bounding boxes for each terrain height. */
static constexpr std::array<BoundingBox, Terrain::Height::Count> TERRAIN_BOXES{
    {{{0, 0, 0}, {WIDTH, WIDTH, 0}},
     {{0, 0, 0}, {WIDTH, WIDTH, ONE_THIRD_HEIGHT}},
     {{0, 0, 0}, {WIDTH, WIDTH, TWO_THIRD_HEIGHT}},
     {{0, 0, 0}, {WIDTH, WIDTH, HEIGHT}}}};

/** World-space height offsets for each height value. */
static constexpr std::array<float, Terrain::Height::Count> HEIGHT_VALUES{
    0,
    ONE_THIRD_HEIGHT,
    TWO_THIRD_HEIGHT,
    HEIGHT
};

Terrain::Height Terrain::getHeight(Value value)
{
    Height height{static_cast<Height>(value >> 4)};
    AM_ASSERT(height < Height::Count, "Invalid terrain height.");

    return height;
}

Terrain::Height Terrain::getStartHeight(Value value)
{
    Height startHeight{static_cast<Height>(value & START_HEIGHT_MASK)};
    AM_ASSERT(startHeight < Height::Count, "Invalid terrain start height.");

    return startHeight;
}

Terrain::Height Terrain::getTotalHeight(Value value)
{
    auto [height, startHeight]{getInfo(value)};
    return static_cast<Terrain::Height>(height + startHeight);
}

Terrain::InfoReturn Terrain::getInfo(Value value)
{
    Height height{static_cast<Height>(value >> 4)};
    Height startHeight{static_cast<Height>(value & START_HEIGHT_MASK)};
    AM_ASSERT(height < Height::Count, "Invalid terrain height.");
    AM_ASSERT(startHeight < Height::Count, "Invalid terrain start height.");

    return {height, startHeight};
}

Terrain::Value Terrain::toValue(Height height, Height startHeight)
{
    return (height << 4) | startHeight;
}

float Terrain::getHeightWorldValue(Height height)
{
    return HEIGHT_VALUES[height];
}

BoundingBox Terrain::calcWorldBounds(const TilePosition& tilePosition,
                                     Value value)
{
    auto [height, startHeight]{getInfo(value)};

    // Get the appropriate bounds for the given tile height.
    BoundingBox bounds{TERRAIN_BOXES[height]};

    // Move the bounds to the tile's origin + the given start height.
    Vector3 tileOrigin{tilePosition.getOriginPoint()};
    tileOrigin.z += HEIGHT_VALUES[startHeight];

    return bounds.translateBy(tileOrigin);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/TileMap/Tile.cpp`:

```cpp
#include "Tile.h"
#include "GraphicSets.h"
#include "SharedConfig.h"
#include <algorithm>

namespace AM
{

void Tile::addLayer(const TileOffset& tileOffset, TileLayer::Type layerType,
                    const GraphicSet& graphicSet, Uint8 graphicValue)
{
    if (layers.size() == UINT8_MAX) {
        LOG_INFO("Failed to add layer: limit reached.");
        return;
    }

    // Insert the new layer, being careful to keep the vector sorted.
    TileLayer newLayer{tileOffset, layerType, graphicValue, graphicSet};
    layers.insert(
        std::lower_bound(layers.begin(), layers.end(), newLayer,
                         [](const TileLayer& layer, const TileLayer& newLayer) {
                             return layer.type < newLayer.type;
                         }),
        newLayer);
}

std::size_t Tile::removeLayers(const TileOffset& tileOffset, TileLayer::Type layerType,
                       Uint16 graphicSetID, Uint8 graphicValue)
{
    // Erase any layers with a matching type, graphic index, and graphic set.
    std::size_t numErased{0};
    for (auto it{layers.begin()}; it != layers.end();) {
        TileLayer& layer{*it};

        // If this layer matches, erase it.
        if ((layer.tileOffset == tileOffset) && (layer.type == layerType)
            && (layer.graphicValue == graphicValue)
            && (layer.graphicSet.get().numericID == graphicSetID)) {
            it = layers.erase(it);
            numErased++;
        }
        // If we've reached a type past the desired one, stop looking.
        else if (layer.type == (layerType + 1)) {
            break;
        }
        else {
            it++;
        }
    }

    return numErased;
}

std::size_t Tile::removeLayers(TileLayer::Type layerType, Uint16 graphicSetID,
                               Uint8 graphicValue)
{
    // Erase any layers with a matching type, graphic index, and graphic set.
    std::size_t numErased{0};
    for (auto it{layers.begin()}; it != layers.end();) {
        TileLayer& layer{*it};

        // If this layer matches, erase it.
        if ((layer.type == layerType) && (layer.graphicValue == graphicValue)
            && (layer.graphicSet.get().numericID == graphicSetID)) {
            it = layers.erase(it);
            numErased++;
        }
        // If we've reached a type past the desired one, stop looking.
        else if (layer.type == (layerType + 1)) {
            break;
        }
        else {
            it++;
        }
    }

    return numErased;
}

std::size_t Tile::removeLayers(TileLayer::Type layerType, Uint8 graphicValue)
{
    // Erase any layers with a matching type and graphic index.
    std::size_t numErased{0};
    for (auto it{layers.begin()}; it != layers.end();) {
        TileLayer& layer{*it};

        // If this layer matches, erase it.
        if ((layer.type == layerType) && (layer.graphicValue == graphicValue)) {
            it = layers.erase(it);
            numErased++;
        }
        // If we've reached a type past the desired one, stop looking.
        else if (layer.type == (layerType + 1)) {
            break;
        }
        else {
            it++;
        }
    }

    return numErased;
}

std::size_t Tile::clearLayers(
    const std::array<bool, TileLayer::Type::Count>& layerTypesToClear)
{
    // Erase any layers with a matching type.
    std::size_t numErased{std::erase_if(layers, [&](const TileLayer& layer) {
        return layerTypesToClear[layer.type];
    })};

    return numErased;
}

std::size_t Tile::clear()
{
    std::size_t layerCount{layers.size()};

    layers.clear();

    return layerCount;
}

std::span<TileLayer> Tile::getLayers(TileLayer::Type layerType)
{
    auto begin{layers.end()};
    auto end{layers.end()};
    for (auto it{layers.begin()}; it != layers.end(); ++it) {
        if (it->type == layerType) {
            // If this is the first match, set our iterators.
            if (begin == layers.end()) {
                begin = it;
                end = it + 1;
            }
            else {
                // Found another match, move our end iterator forward.
                end = it + 1;
            }
        }
        else if (it->type == (layerType + 1)) {
            // Reached a type past the one we were looking for, stop looking.
            break;
        }
    }

    // If we found any matches, return them.
    if (begin != layers.end()) {
        return {begin, end};
    }
    else {
        return {};
    }
}

std::span<const TileLayer> Tile::getLayers(TileLayer::Type layerType) const
{
    auto begin{layers.end()};
    auto end{layers.end()};
    for (auto it{layers.begin()}; it != layers.end(); ++it) {
        if (it->type == layerType) {
            // If this is the first match, set our iterators.
            if (begin == layers.end()) {
                begin = it;
                end = it + 1;
            }
            else {
                // Found another match, move our end iterator forward.
                end = it + 1;
            }
        }
        else if (it->type == (layerType + 1)) {
            // Reached a type past the one we were looking for, stop looking.
            break;
        }
    }

    // If we found any matches, return them.
    if (begin != layers.end()) {
        return {begin, end};
    }
    else {
        return {};
    }
}

std::vector<TileLayer>& Tile::getAllLayers()
{
    return layers;
}

const std::vector<TileLayer>& Tile::getAllLayers() const
{
    return layers;
}

TileLayer* Tile::findLayer(TileLayer::Type layerType, Uint8 graphicValue)
{
    for (TileLayer& layer : layers) {
        if ((layer.type == layerType)
            && (layer.graphicValue == graphicValue)) {
            return &layer;
        }
        else if (layer.type == (layerType + 1)) {
            // We've reached a type past the desired one, stop looking.
            return nullptr;
        }
    }

    return nullptr;
}

const TileLayer* Tile::findLayer(TileLayer::Type layerType,
                                 Uint8 graphicValue) const
{
    for (const TileLayer& layer : layers) {
        if ((layer.type == layerType)
            && (layer.graphicValue == graphicValue)) {
            return &layer;
        }
        else if (layer.type == (layerType + 1)) {
            // We've reached a type past the desired one, stop looking.
            return nullptr;
        }
    }

    return nullptr;
}

TileLayer* Tile::findLayer(TileLayer::Type layerType)
{
    for (TileLayer& layer : layers) {
        if (layer.type == layerType) {
            return &layer;
        }
        else if (layer.type == (layerType + 1)) {
            // We've reached a type past the desired one, stop looking.
            return nullptr;
        }
    }

    return nullptr;
}

const TileLayer* Tile::findLayer(TileLayer::Type layerType) const
{
    for (const TileLayer& layer : layers) {
        if (layer.type == layerType) {
            return &layer;
        }
        else if (layer.type == (layerType + 1)) {
            // We've reached a type past the desired one, stop looking.
            return nullptr;
        }
    }

    return nullptr;
}

bool Tile::isEmpty() const
{
    return layers.empty();
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/TileMap/TileExtent.cpp`:

```cpp
#include "TileExtent.h"
#include "ChunkExtent.h"
#include "CellExtent.h"
#include "BoundingBox.h"
#include "Cylinder.h"
#include "Vector3.h"
#include "MovementHelpers.h"
#include "SharedConfig.h"
#include "Log.h"

namespace AM
{
TileExtent::TileExtent()
: DiscreteExtent<DiscreteImpl::TileTag>()
{
}

TileExtent::TileExtent(int inX, int inY, int inZ, int inXLength, int inYLength,
                       int inZLength)
: DiscreteExtent<DiscreteImpl::TileTag>(inX, inY, inZ, inXLength, inYLength,
                                        inZLength)
{
}

TileExtent::TileExtent(const DiscreteExtent<DiscreteImpl::TileTag>& tileExtent)
: DiscreteExtent<DiscreteImpl::TileTag>(tileExtent)
{
}

TileExtent::TileExtent(const ChunkExtent& chunkExtent)
: DiscreteExtent<DiscreteImpl::TileTag>(
    static_cast<int>(chunkExtent.x * SharedConfig::CHUNK_WIDTH),
    static_cast<int>(chunkExtent.y * SharedConfig::CHUNK_WIDTH), chunkExtent.z,
    static_cast<int>(chunkExtent.xLength * SharedConfig::CHUNK_WIDTH),
    static_cast<int>(chunkExtent.yLength * SharedConfig::CHUNK_WIDTH),
    chunkExtent.zLength)
{
}

TileExtent::TileExtent(const CellExtent& cellExtent, std::size_t cellWidthTiles,
                       std::size_t cellHeightTiles)
: DiscreteExtent<DiscreteImpl::TileTag>(
    static_cast<int>(cellExtent.x * cellWidthTiles),
    static_cast<int>(cellExtent.y * cellWidthTiles),
    static_cast<int>(cellExtent.z * cellHeightTiles),
    static_cast<int>(cellExtent.xLength * cellWidthTiles),
    static_cast<int>(cellExtent.yLength * cellWidthTiles),
    static_cast<int>(cellExtent.zLength * cellHeightTiles))
{
}

TileExtent::TileExtent(const BoundingBox& boundingBox)
{
    static constexpr float TILE_WIDTH{
        static_cast<float>(SharedConfig::TILE_WORLD_WIDTH)};
    static constexpr float TILE_HEIGHT{
        static_cast<float>(SharedConfig::TILE_WORLD_HEIGHT)};

    // Note: One could imagine doing the opposite logic here (if a box is 
    //       exactly touching the edge of a tile, include it in the extent).
    //       However, this would make it so that a box with the exact bounds 
    //       of a tile would convert into an extent that includes every tile 
    //       around it, which seems unexpected.

    // To account for float precision issues: add the epsilon to each min value,
    // then round down. If the box is within epsilon range of a tile in the 
    // negative direction, it won't be included in this extent.
    x = static_cast<int>(std::floor(
        (boundingBox.min.x + MovementHelpers::WORLD_EPSILON) / TILE_WIDTH));
    y = static_cast<int>(std::floor(
        (boundingBox.min.y + MovementHelpers::WORLD_EPSILON) / TILE_WIDTH));
    z = static_cast<int>(std::floor(
        (boundingBox.min.z + MovementHelpers::WORLD_EPSILON) / TILE_HEIGHT));

    // Subtract the epsilon from each max value, then round up. If the
    // boundingBox is within epsilon range of a tile in the positive direction,
    // it won't be included in this extent.
    float maxTileX{std::ceil(
        (boundingBox.max.x - MovementHelpers::WORLD_EPSILON) / TILE_WIDTH)};
    float maxTileY{std::ceil(
        (boundingBox.max.y - MovementHelpers::WORLD_EPSILON) / TILE_WIDTH)};
    float maxTileZ{std::ceil(
        (boundingBox.max.z - MovementHelpers::WORLD_EPSILON) / TILE_HEIGHT)};
    xLength = (static_cast<int>(maxTileX) - x);
    yLength = (static_cast<int>(maxTileY) - y);
    zLength = (static_cast<int>(maxTileZ) - z);
}

bool TileExtent::contains(const BoundingBox& box) const
{
    BoundingBox extentBox(*this);
    return extentBox.contains(box);
}

bool TileExtent::contains(const Cylinder& cylinder) const
{
    BoundingBox extentBox(*this);
    return extentBox.contains(cylinder);
}

bool TileExtent::contains(const Vector3& worldPoint) const
{
    BoundingBox extentBox(*this);
    return extentBox.contains(worldPoint);
}

void TileExtent::print() const
{
    LOG_INFO("(%d, %d, %d, %d, %d, %d)", x, y, z, xLength, yLength, zLength);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/TileMap/TileLayer.cpp`:

```cpp
#include "TileLayer.h"
#include "GraphicSets.h"
#include "AMAssert.h"

namespace AM
{

GraphicRef TileLayer::getGraphic() const
{
    return getGraphic(type, graphicSet, graphicValue);
}

GraphicRef TileLayer::getGraphic(Type type, const GraphicSet& graphicSet,
                                 Uint8 graphicValue)
{
    // Note: We don't need to check if the slots refer to a non-null 
    //       graphic, because the null graphic is fine to return.
    if (type == Type::Terrain) {
        Terrain::Height height{Terrain::getHeight(graphicValue)};
        return static_cast<const TerrainGraphicSet&>(graphicSet)
            .graphics[height];
    }
    else if (type == Type::Floor) {
        return static_cast<const FloorGraphicSet&>(graphicSet)
            .graphics[graphicValue];
    }
    else if (type == Type::Wall) {
        return static_cast<const WallGraphicSet&>(graphicSet)
            .graphics[graphicValue];
    }
    else {
        // Type::Object
        return static_cast<const ObjectGraphicSet&>(graphicSet)
            .graphics[graphicValue];
    }
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/TileMap/TileMapBase.cpp`:

```cpp
#include "TileMapBase.h"
#include "GraphicDataBase.h"
#include "CollisionLocator.h"
#include "Paths.h"
#include "Position.h"
#include "Transforms.h"
#include "Serialize.h"
#include "Deserialize.h"
#include "ByteTools.h"
#include "TileMapSnapshot.h"
#include "ChunkWireSnapshot.h"
#include "Morton.h"
#include "SharedConfig.h"
#include "Timer.h"
#include "Log.h"
#include "AMAssert.h"

namespace AM
{
static_assert(SharedConfig::TILE_WORLD_WIDTH <= SDL_MAX_UINT8,
              "TILE_WORLD_WIDTH must fit within a Uint8 for TileOffset.");
static_assert(SharedConfig::TILE_WORLD_HEIGHT <= SDL_MAX_UINT8,
              "TILE_WORLD_HEIGHT must fit within a Uint8 for TileOffset.");

TileMapBase::TileMapBase(const GraphicDataBase& inGraphicData,
                         CollisionLocator& inCollisionLocator,
                         bool inTrackTileUpdates)
: graphicData{inGraphicData}
, collisionLocator{inCollisionLocator}
, chunkExtent{}
, tileExtent{}
, chunks{}
, autoRebuildCollision{true}
, dirtyCollisionQueue{}
, trackTileUpdates{inTrackTileUpdates}
, tileUpdateHistory{}
{
}

void TileMapBase::addTerrain(const TilePosition& tilePosition,
                             const TerrainGraphicSet& graphicSet,
                             Terrain::Value terrainValue)
{
    // If the terrain height + start height is too tall to fit in the tile, 
    // return without adding.
    auto [terrainHeight, terrainStartHeight]{Terrain::getInfo(terrainValue)};
    if ((terrainHeight + terrainStartHeight) >= Terrain::MAX_COMBINED_HEIGHT) {
        return;
    }

    Tile* tile{addTileLayer(tilePosition, {}, TileLayer::Type::Terrain,
                            graphicSet, terrainValue)};
    if (!tile) {
        // tilePosition is outside of the map bounds.
        return;
    }

    // Rebuild the affected tile's collision.
    rebuildTileCollision(*tile, tilePosition);

    // If we're tracking tile updates, add this one to the history.
    if (trackTileUpdates) {
        tileUpdateHistory.emplace_back(
            TileAddLayer{tilePosition,
                         {},
                         TileLayer::Type::Terrain,
                         static_cast<Uint16>(graphicSet.numericID),
                         static_cast<Uint8>(terrainValue)});
    }
}

void TileMapBase::addTerrain(const TilePosition& tilePosition,
                             const std::string& graphicSetID,
                             Terrain::Value terrainValue)
{
    addTerrain(tilePosition, graphicData.getTerrainGraphicSet(graphicSetID),
               terrainValue);
}

void TileMapBase::addTerrain(const TilePosition& tilePosition,
                             Uint16 graphicSetID, Terrain::Value terrainValue)
{
    addTerrain(tilePosition, graphicData.getTerrainGraphicSet(graphicSetID),
               terrainValue);
}

bool TileMapBase::remTerrain(const TilePosition& tilePosition)
{
    // Since there's only 1 terrain per tile, we can just clear it.
    return clearTileLayers(tilePosition, {TileLayer::Type::Terrain});
}

void TileMapBase::addFloor(const TilePosition& tilePosition,
                           const TileOffset& tileOffset,
                           const FloorGraphicSet& graphicSet,
                           Rotation::Direction rotation)
{
    Tile* tile{addTileLayer(tilePosition, tileOffset, TileLayer::Type::Floor,
                            graphicSet, rotation)};
    if (!tile) {
        // tilePosition is outside of the map bounds.
        return;
    }

    // Rebuild the affected tile's collision.
    rebuildTileCollision(*tile, tilePosition);

    // If we're tracking tile updates, add this one to the history.
    if (trackTileUpdates) {
        tileUpdateHistory.emplace_back(
            TileAddLayer{tilePosition, tileOffset, TileLayer::Type::Floor,
                         static_cast<Uint16>(graphicSet.numericID),
                         static_cast<Uint8>(rotation)});
    }
}

void TileMapBase::addFloor(const TilePosition& tilePosition,
                           const TileOffset& tileOffset,
                           const std::string& graphicSetID,
                           Rotation::Direction rotation)
{
    addFloor(tilePosition, tileOffset,
             graphicData.getFloorGraphicSet(graphicSetID), rotation);
}

void TileMapBase::addFloor(const TilePosition& tilePosition,
                           const TileOffset& tileOffset, Uint16 graphicSetID,
                           Rotation::Direction rotation)
{
    addFloor(tilePosition, tileOffset,
             graphicData.getFloorGraphicSet(graphicSetID), rotation);
}

bool TileMapBase::remFloor(const TilePosition& tilePosition,
                           const TileOffset& tileOffset,
                           const FloorGraphicSet& graphicSet,
                           Rotation::Direction rotation)
{
    return remFloor(tilePosition, tileOffset, graphicSet.numericID, rotation);
}

bool TileMapBase::remFloor(const TilePosition& tilePosition,
                           const TileOffset& tileOffset,
                           const std::string& graphicSetID,
                           Rotation::Direction rotation)
{
    return remFloor(tilePosition, tileOffset,
                    graphicData.getFloorGraphicSet(graphicSetID).numericID,
                    rotation);
}

bool TileMapBase::remFloor(const TilePosition& tilePosition,
                           const TileOffset& tileOffset, Uint16 graphicSetID,
                           Rotation::Direction rotation)
{
    Tile* tile{remTileLayer(tilePosition, tileOffset, TileLayer::Type::Floor,
                            graphicSetID, rotation)};
    if (!tile) {
        // Floor wasn't found.
        return false;
    }

    // If a floor was removed, rebuild the affected tile's collision.
    rebuildTileCollision(*tile, tilePosition);

    // If we're tracking tile updates, add this one to the history.
    if (trackTileUpdates) {
        tileUpdateHistory.emplace_back(
            TileRemoveLayer{tilePosition,
                            tileOffset,
                            TileLayer::Type::Floor,
                            graphicSetID,
                            static_cast<Uint8>(rotation)});
    }

    return true;
}

void TileMapBase::addWall(const TilePosition& tilePosition, const WallGraphicSet& graphicSet,
                          Wall::Type wallType)
{
    switch (wallType) {
        case Wall::Type::North: {
            addNorthWall(tilePosition, graphicSet);
            break;
        }
        case Wall::Type::West: {
            addWestWall(tilePosition, graphicSet);
            break;
        }
        default: {
            LOG_FATAL("Wall type must be North or West.");
            break;
        }
    }

    // If we're tracking tile updates, add this one to the history.
    if (trackTileUpdates) {
        tileUpdateHistory.emplace_back(
            TileAddLayer{tilePosition,
                         {},
                         TileLayer::Type::Wall,
                         static_cast<Uint16>(graphicSet.numericID),
                         static_cast<Uint8>(wallType)});
    }
}

void TileMapBase::addWall(const TilePosition& tilePosition, const std::string& graphicSetID,
                          Wall::Type wallType)
{
    addWall(tilePosition, graphicData.getWallGraphicSet(graphicSetID), wallType);
}

void TileMapBase::addWall(const TilePosition& tilePosition, Uint16 graphicSetID,
                          Wall::Type wallType)
{
    addWall(tilePosition, graphicData.getWallGraphicSet(graphicSetID), wallType);
}

bool TileMapBase::remWall(const TilePosition& tilePosition, Wall::Type wallType)
{
    bool wallWasRemoved{false};
    switch (wallType) {
        case Wall::Type::North: {
            wallWasRemoved = remNorthWall(tilePosition);
            break;
        }
        case Wall::Type::West: {
            wallWasRemoved = remWestWall(tilePosition);
            break;
        }
        default: {
            LOG_FATAL("Wall type must be North or West.");
            break;
        }
    }

    // If we're tracking tile updates, add this one to the history.
    if (trackTileUpdates && wallWasRemoved) {
        // Note: We don't care about graphic set ID when removing walls.
        tileUpdateHistory.emplace_back(
            TileRemoveLayer{tilePosition,
                            {},
                            TileLayer::Type::Wall,
                            0,
                            static_cast<Uint8>(wallType)});
    }

    return wallWasRemoved;
}

void TileMapBase::addObject(const TilePosition& tilePosition,
                            const TileOffset& tileOffset,
                            const ObjectGraphicSet& graphicSet,
                            Rotation::Direction rotation)
{
    Tile* tile{addTileLayer(tilePosition, tileOffset, TileLayer::Type::Object,
                            graphicSet, rotation)};
    if (!tile) {
        // tilePosition is outside of the map bounds.
        return;
    }

    // Rebuild the affected tile's collision.
    rebuildTileCollision(*tile, tilePosition);

    // If we're tracking tile updates, add this one to the history.
    if (trackTileUpdates) {
        tileUpdateHistory.emplace_back(
            TileAddLayer{tilePosition, tileOffset, TileLayer::Type::Object,
                         static_cast<Uint16>(graphicSet.numericID),
                         static_cast<Uint8>(rotation)});
    }
}

void TileMapBase::addObject(const TilePosition& tilePosition,
                            const TileOffset& tileOffset,
                            const std::string& graphicSetID,
                            Rotation::Direction rotation)
{
    addObject(tilePosition, tileOffset,
              graphicData.getObjectGraphicSet(graphicSetID), rotation);
}

void TileMapBase::addObject(const TilePosition& tilePosition,
                            const TileOffset& tileOffset, Uint16 graphicSetID,
                            Rotation::Direction rotation)
{
    addObject(tilePosition, tileOffset,
              graphicData.getObjectGraphicSet(graphicSetID), rotation);
}

bool TileMapBase::remObject(const TilePosition& tilePosition,
                            const TileOffset& tileOffset,
                            const ObjectGraphicSet& graphicSet,
                            Rotation::Direction rotation)
{
    return remObject(tilePosition, tileOffset, graphicSet.numericID, rotation);
}

bool TileMapBase::remObject(const TilePosition& tilePosition,
                            const TileOffset& tileOffset,
                            const std::string& graphicSetID,
                            Rotation::Direction rotation)
{
    return remObject(tilePosition, tileOffset,
                     graphicData.getObjectGraphicSet(graphicSetID).numericID,
                     rotation);
}

bool TileMapBase::remObject(const TilePosition& tilePosition,
                            const TileOffset& tileOffset, Uint16 graphicSetID,
                            Rotation::Direction rotation)
{
    Tile* tile{remTileLayer(tilePosition, tileOffset, TileLayer::Type::Object,
                            graphicSetID, rotation)};
    if (!tile) {
        // Object wasn't found.
        return false;
    }

    // Rebuild the affected tile's collision.
    rebuildTileCollision(*tile, tilePosition);

    // If we're tracking tile updates, add this one to the history.
    if (trackTileUpdates) {
        tileUpdateHistory.emplace_back(
            TileRemoveLayer{tilePosition, tileOffset, TileLayer::Type::Object,
                            graphicSetID, static_cast<Uint8>(rotation)});
    }

    return true;
}

bool TileMapBase::clearTileLayers(
    const TilePosition& tilePosition,
    const std::initializer_list<TileLayer::Type>& layerTypesToClear)
{
    return clearTileLayers(tilePosition,
                           toBoolArray(layerTypesToClear));
}

bool TileMapBase::clearTileLayers(
    const TilePosition& tilePosition,
    const std::array<bool, TileLayer::Type::Count>& layerTypesToClear)
{
    Tile* clearedTile{
        clearTileLayersInternal(tilePosition, layerTypesToClear)};

    // If a layer was cleared, rebuild the affected tile's collision.
    if (clearedTile) {
        rebuildTileCollision(*clearedTile, tilePosition);
    }

    // If we're tracking tile updates, add this one to the history.
    if (trackTileUpdates) {
        tileUpdateHistory.emplace_back(
            TileClearLayers{tilePosition, layerTypesToClear});
    }

    return (clearedTile != nullptr);
}

bool TileMapBase::clearTile(const TilePosition& tilePosition)
{
    return clearTileLayers(tilePosition,
                           {TileLayer::Type::Terrain, TileLayer::Type::Floor,
                            TileLayer::Type::Wall, TileLayer::Type::Object});
}

bool TileMapBase::clearExtentLayers(const TileExtent& extent,
    const std::initializer_list<TileLayer::Type>& layerTypesToClear)
{
    return clearExtentLayers(extent, toBoolArray(layerTypesToClear));
}

bool TileMapBase::clearExtentLayers(
    const TileExtent& extent,
    const std::array<bool, TileLayer::Type::Count>& layerTypesToClear)
{
    // Clear the given layers from each tile in the given extent.
    bool layerWasCleared{false};
    for (int z{extent.z}; z <= extent.zMax(); ++z) {
        for (int y{extent.y}; y <= extent.yMax(); ++y) {
            for (int x{extent.x}; x <= extent.xMax(); ++x) {
                TilePosition tilePosition{x, y, z};
                Tile* clearedTile{
                    clearTileLayersInternal(tilePosition, layerTypesToClear)};
                if (clearedTile) {
                    layerWasCleared = true;

                    // A layer was cleared. Rebuild the affected tile's
                    // collision.
                    rebuildTileCollision(*clearedTile, tilePosition);
                }
            }
        }
    }

    // If we're tracking tile updates, add this one to the history.
    if (trackTileUpdates) {
        tileUpdateHistory.emplace_back(
            TileExtentClearLayers{extent, layerTypesToClear});
    }

    return layerWasCleared;
}

bool TileMapBase::clearExtent(const TileExtent& extent)
{
    return clearExtentLayers(
        extent, {TileLayer::Type::Terrain, TileLayer::Type::Floor,
                 TileLayer::Type::Wall, TileLayer::Type::Object});
}

void TileMapBase::clear()
{
    chunkExtent = {};
    tileExtent = {};
    chunks.clear();
    tileUpdateHistory.clear();
}

const Chunk* TileMapBase::getChunk(const ChunkPosition& chunkPosition) const
{
    auto chunkIt{chunks.find(chunkPosition)};
    if (chunkIt != chunks.end()) {
        return &(chunkIt->second);
    }

    // The requested chunk is empty or out of bounds.
    return nullptr;
}

const Chunk* TileMapBase::cgetChunk(const ChunkPosition& chunkPosition) const
{
    return getChunk(chunkPosition);
}

const Tile* TileMapBase::getTile(const TilePosition& tilePosition) const
{
    const int CHUNK_WIDTH{static_cast<int>(SharedConfig::CHUNK_WIDTH)};

    // If the chunk doesn't exist, return early.
    ChunkPosition chunkPosition{tilePosition};
    const Chunk* chunk{getChunk(chunkPosition)};
    if (!chunk) {
        //LOG_INFO("Chunk doesn't exist");
        return nullptr;
    }

    // Get the tile's relative position within the chunk.
    int relativeTileX{tilePosition.x - (chunkPosition.x * CHUNK_WIDTH)};
    int relativeTileY{tilePosition.y - (chunkPosition.y * CHUNK_WIDTH)};
    return &(chunk->getTile(relativeTileX, relativeTileY));
}

const Tile* TileMapBase::cgetTile(const TilePosition& tilePosition) const
{
    return getTile(tilePosition);
}

const ChunkExtent& TileMapBase::getChunkExtent() const
{
    return chunkExtent;
}

const TileExtent& TileMapBase::getTileExtent() const
{
    return tileExtent;
}

void TileMapBase::setAutoRebuildCollision(bool newAutoRebuildCollision)
{
    // If we're re-enabling auto rebuild, rebuild any dirty tiles.
    if (!autoRebuildCollision && newAutoRebuildCollision) {
        rebuildDirtyTileCollision();
    }

    autoRebuildCollision = newAutoRebuildCollision;
}

void TileMapBase::rebuildDirtyTileCollision()
{
    // De-duplicate the queue.
    std::sort(dirtyCollisionQueue.begin(), dirtyCollisionQueue.end());
    auto lastIt{
        std::unique(dirtyCollisionQueue.begin(), dirtyCollisionQueue.end())};

    // Rebuild the collision of any dirty tiles.
    for (auto it{dirtyCollisionQueue.begin()}; it != lastIt; ++it) {
        if (auto tileResult{getTile(*it)}) {
            collisionLocator.updateTile(*it, tileResult->tile);
        }
    }

    dirtyCollisionQueue.clear();
}

const std::vector<TileMapBase::TileUpdateVariant>&
    TileMapBase::getTileUpdateHistory()
{
    return tileUpdateHistory;
}

void TileMapBase::clearTileUpdateHistory()
{
    tileUpdateHistory.clear();
}

void TileMapBase::loadChunk(const ChunkSnapshot& chunkSnapshot,
                            const ChunkPosition& chunkPosition)
{
    loadChunkInternal(chunkSnapshot, chunkPosition);
}

void TileMapBase::loadChunk(const ChunkWireSnapshot& chunkSnapshot,
                            const ChunkPosition& chunkPosition)
{
    loadChunkInternal(chunkSnapshot, chunkPosition);
}

std::expected<std::reference_wrapper<Chunk>, TileMapBase::ChunkError>
    TileMapBase::getChunk(const ChunkPosition& chunkPosition)
{
    if (!(chunkExtent.contains(chunkPosition))) {
        AM_ASSERT(false, "Failed to get chunk: Invalid chunk position");
        return std::unexpected{ChunkError::InvalidPosition};
    }

    // Find the requested tile's parent chunk. If it doesn't exist, return an 
    // error.
    auto chunkIt{chunks.find(chunkPosition)};
    if (chunkIt == chunks.end()) {
        return std::unexpected{ChunkError::NotFound};
    }

    return chunkIt->second;
}

std::expected<TileMapBase::ChunkTilePair, TileMapBase::ChunkError>
    TileMapBase::getTile(const TilePosition& tilePosition)
{
    ChunkPosition chunkPosition{tilePosition};
    if (auto chunkResult{getChunk(chunkPosition)}) {
        return ChunkTilePair{
            *chunkResult, getTile(*chunkResult, chunkPosition, tilePosition)};
    }
    else if (chunkResult.error() == ChunkError::InvalidPosition) {
        AM_ASSERT(false, "Failed to get tile: Invalid tile position");
        return std::unexpected{chunkResult.error()};
    }
    else {
        return std::unexpected{chunkResult.error()};
    }
}

Tile& TileMapBase::getTile(Chunk& chunk, const ChunkPosition& chunkPosition,
                           const TilePosition& tilePosition)
{
    // Calc the tile's relative position within the chunk.
    const int CHUNK_WIDTH{static_cast<int>(SharedConfig::CHUNK_WIDTH)};
    int relativeTileX{tilePosition.x - (chunkPosition.x * CHUNK_WIDTH)};
    int relativeTileY{tilePosition.y - (chunkPosition.y * CHUNK_WIDTH)};

    return chunk.getTile(relativeTileX, relativeTileY);
}

Chunk* TileMapBase::getOrCreateChunk(const ChunkPosition& chunkPosition)
{
    // Get the chunk.
    if (auto chunkResult{getChunk(chunkPosition)}) {
        // Chunk exists.
        return &(chunkResult->get());
    }
    else if (chunkResult.error() == ChunkError::NotFound) {
        // Chunk doesn't exist, create it.
        auto chunkIt{chunks.emplace(chunkPosition, Chunk{}).first};
        return &(chunkIt->second);
    }
    else if (chunkResult.error() == ChunkError::InvalidPosition) {
        AM_ASSERT(false, "Failed to get chunk: Invalid chunk position");
        return nullptr;
    }

    return nullptr;
}

TileMapBase::ChunkTilePtrPair
    TileMapBase::getOrCreateTile(const TilePosition& tilePosition)
{
    // Get the chunk.
    ChunkPosition chunkPosition{tilePosition};
    Chunk* chunk{};
    if (auto chunkResult{getChunk(chunkPosition)}) {
        // Chunk exists.
        chunk = &(chunkResult->get());
    }
    else if (chunkResult.error() == ChunkError::NotFound) {
        // Chunk doesn't exist, create it.
        auto chunkIt{chunks.emplace(chunkPosition, Chunk{}).first};
        chunk = &(chunkIt->second);
    }
    else if (chunkResult.error() == ChunkError::InvalidPosition) {
        AM_ASSERT(false, "Failed to get tile: Invalid tile position");
        return {nullptr, nullptr};
    }

    // Get the tile.
    Tile& tile{getTile(*chunk, chunkPosition, tilePosition)};

    return {chunk, &tile};
}

Tile* TileMapBase::addTileLayer(const TilePosition& tilePosition,
                                const TileOffset& tileOffset,
                                TileLayer::Type layerType,
                                const GraphicSet& graphicSet,
                                Uint8 graphicValue)
{
    // Get or create the tile, return nullptr if tilePosition is invalid.
    auto [chunk, tile] = getOrCreateTile(tilePosition);
    if (!tile) {
        return nullptr;
    }

    // Add the layer.
    addTileLayer(*chunk, *tile, tileOffset, layerType, graphicSet,
                 graphicValue);

    return tile;
}

void TileMapBase::addTileLayer(Chunk& chunk, Tile& tile,
                               const TileOffset& tileOffset,
                               TileLayer::Type layerType,
                               const GraphicSet& graphicSet, Uint8 graphicValue)
{
    // Add the layer.
    bool layerWasAdded{false};
    if (layerType == TileLayer::Type::Terrain) {
        // If there's an existing terrain, replace it.
        if (TileLayer* terrain{tile.findLayer(TileLayer::Type::Terrain)}) {
            terrain->graphicSet = graphicSet;
            terrain->graphicValue = graphicValue;
        }
        else {
            // No existing terrain, add one.
            tile.addLayer(tileOffset, TileLayer::Type::Terrain, graphicSet,
                          graphicValue);
            layerWasAdded = true;
        }
    }
    else {
        tile.addLayer(tileOffset, layerType, graphicSet, graphicValue);
        layerWasAdded = true;
    }

    // If we added a layer, increment the chunk's count.
    if (layerWasAdded) {
        chunk.tileLayerCount++;
    }
}

void TileMapBase::rebuildTileCollision(Tile& tile, const TilePosition& tilePosition)
{
    // If auto rebuild is enabled, rebuild the affected tile's collision.
    if (autoRebuildCollision) {
        collisionLocator.updateTile(tilePosition, tile);
    }
    else {
        // Not enabled. Queue the affected tile to have its collision rebuilt.
        dirtyCollisionQueue.emplace_back(tilePosition);
    }
}

void TileMapBase::addNorthWall(const TilePosition& tilePosition,
                               const WallGraphicSet& graphicSet)
{
    // If tilePosition isn't a valid position in the map, return early.
    auto [chunk, tile] = getOrCreateTile(tilePosition);
    if (!tile) {
        return;
    }

    // If the tile has a West wall, add a NE gap fill.
    if (tile->findLayer(TileLayer::Type::Wall, Wall::Type::West)) {
        addTileLayer(*chunk, *tile, {}, TileLayer::Type::Wall, graphicSet,
                     Wall::Type::NorthEastGapFill);
    }
    else {
        // No West wall. If there's an existing North wall or NW gap fill, 
        // replace it.
        bool replacedWall{false};
        for (TileLayer& layer : tile->getLayers(TileLayer::Type::Wall)) {
            if ((layer.graphicValue == Wall::Type::North)
                || (layer.graphicValue == Wall::Type::NorthWestGapFill)) {
                layer.graphicSet = graphicSet;
                layer.graphicValue = Wall::Type::North;
                replacedWall = true;
                break;
            }
        }

        // If there was no existing North wall, add one.
        if (!replacedWall) {
            addTileLayer(*chunk, *tile, {}, TileLayer::Type::Wall, graphicSet,
                         Wall::Type::North);
        }
    }

    // Rebuild the affected tile's collision.
    rebuildTileCollision(*tile, tilePosition);

    /* Add a NW gap fill, if necessary. */
    // If there's a tile to the NE that we might've formed a corner with.
    TilePosition northeastPos{tilePosition.x + 1, tilePosition.y - 1,
                              tilePosition.z};
    const Tile* northeastTile{cgetTile(northeastPos)};
    if (!northeastTile) {
        return;
    };

    // If the NorthEast tile has a West wall.
    const TileLayer* northeastWestWall{
        northeastTile->findLayer(TileLayer::Type::Wall, Wall::Type::West)};
    if (!northeastWestWall) {
        return;
    }

    // We formed a corner. Check if the tile to the East has a wall.
    // Note: We know this tile is in the map bounds cause there's a NorthEast 
    //       tile, but the chunk may not exist yet.
    TilePosition eastPos{tilePosition.x + 1, tilePosition.y,
                         tilePosition.z};
    auto [eastChunk, eastTile] = getOrCreateTile(eastPos);
    if (eastTile->getLayers(TileLayer::Type::Wall).size() == 0) {
        // The East tile has no walls. Add a NorthWestGapFill.
        addTileLayer(*eastChunk, *eastTile, {}, TileLayer::Type::Wall,
                     graphicSet, Wall::Type::NorthWestGapFill);
        rebuildTileCollision(*eastTile, eastPos);
    }
    else if (TileLayer* eastNorthWestGapFill{
                 eastTile->findLayer(TileLayer::Type::Wall,
                                     Wall::Type::NorthWestGapFill)}) {
        // The East tile has a NW gap fill. If its graphic set no longer
        // matches either surrounding wall, make it match the new wall.
        int gapFillID{eastNorthWestGapFill->graphicSet.get().numericID};
        int newNorthID{graphicSet.numericID};
        int westID{northeastWestWall->graphicSet.get().numericID};
        if ((gapFillID != newNorthID) && (gapFillID != westID)) {
            eastNorthWestGapFill->graphicSet = graphicSet;
        }
        rebuildTileCollision(*eastTile, eastPos);
    }
}

void TileMapBase::addWestWall(const TilePosition& tilePosition,
                              const WallGraphicSet& graphicSet)
{
    // If tilePosition isn't a valid position in the map, return early.
    auto [chunk, tile] = getOrCreateTile(tilePosition);
    if (!tile) {
        return;
    }

    // If there's an existing West wall, replace it.
    if (TileLayer* westWall{tile->findLayer(TileLayer::Type::Wall,
                                            Wall::Type::West)}) {
        westWall->graphicSet = graphicSet;
    }
    else {
        // No existing West wall, add one.
        addTileLayer(*chunk, *tile, {}, TileLayer::Type::Wall, graphicSet,
                     Wall::Type::West);
    }

    // If the tile has a North wall, switch it to a NorthEast gap fill.
    if (TileLayer* northWall{tile->findLayer(TileLayer::Type::Wall,
                                             Wall::Type::North)}) {
        // Note: We don't change the graphic set. Only the type changes.
        northWall->graphicValue = Wall::Type::NorthEastGapFill;
    }
    // Else if the tile has a NorthWest gap fill, remove it.
    else {
        remTileLayers(*chunk, *tile, ChunkPosition{tilePosition},
                      TileLayer::Type::Wall, Wall::Type::NorthWestGapFill);
    }

    // Rebuild the affected tile's collision.
    rebuildTileCollision(*tile, tilePosition);

    /* Add a NW gap fill, if necessary. */
    // If there's a tile to the SW that we might've formed a corner with.
    TilePosition southwestPos{tilePosition.x - 1, tilePosition.y + 1,
                              tilePosition.z};
    const Tile* southwestTile{cgetTile(southwestPos)};
    if (!southwestTile) {
        return;
    }

    // If the SouthWest tile has a North wall or a NE gap fill.
    const TileLayer* southwestNorthWall{
        southwestTile->findLayer(TileLayer::Type::Wall, Wall::Type::North)};
    const TileLayer* southwestNorthEastGapFill{southwestTile->findLayer(
        TileLayer::Type::Wall, Wall::Type::NorthEastGapFill)};
    if (!southwestNorthWall && !southwestNorthEastGapFill) {
        return;
    }

    // We formed a corner. Check if the tile to the South has a wall.
    // Note: We know this tile is in the map bounds cause there's a SouthWest 
    //       tile, but the chunk may not exist yet.
    TilePosition southPos{tilePosition.x, tilePosition.y + 1,
                          tilePosition.z};
    auto [southChunk, southTile] = getOrCreateTile(southPos);
    if (southTile->getLayers(TileLayer::Type::Wall).size() == 0) {
        // The South tile has no walls. Add a NorthWestGapFill.
        addTileLayer(*southChunk, *southTile, {}, TileLayer::Type::Wall,
                     graphicSet, Wall::Type::NorthWestGapFill);
    }
    else if (TileLayer* southNorthWestGapFill{southTile->findLayer(
                 TileLayer::Type::Wall, Wall::Type::NorthWestGapFill)}) {
        // The South tile has a NW gap fill. If its graphic set no longer
        // matches either surrounding wall, make it match the new wall.
        int gapFillID{southNorthWestGapFill->graphicSet.get().numericID};
        int newWestID{graphicSet.numericID};
        int northID{southwestNorthWall
                        ? southwestNorthWall->graphicSet.get().numericID
                        : southwestNorthEastGapFill->graphicSet.get()
                              .numericID};
        if ((gapFillID != newWestID) && (gapFillID != northID)) {
            southNorthWestGapFill->graphicSet = graphicSet;
        }
    }
    rebuildTileCollision(*southTile, southPos);
}

Tile* TileMapBase::remTileLayer(const TilePosition& tilePosition,
                                const TileOffset& tileOffset,
                                TileLayer::Type layerType, Uint16 graphicSetID,
                                Uint8 graphicValue)
{
    // Get the chunk.
    ChunkPosition chunkPosition{tilePosition};
    Chunk* chunk{};
    if (auto chunkResult{getChunk(chunkPosition)}) {
        // Chunk exists.
        chunk = &(chunkResult->get());
    }
    else {
        return nullptr;
    }

    // Get the tile.
    Tile& tile{getTile(*chunk, chunkPosition, tilePosition)};

    // Remove any matching layers.
    remTileLayer(*chunk, tile, chunkPosition, tileOffset, layerType,
                 graphicSetID, graphicValue);

    return &tile;
}

Tile* TileMapBase::remTileLayer(const TilePosition& tilePosition,
                                TileLayer::Type layerType, Uint16 graphicSetID,
                                Uint8 graphicValue)
{
    // Get the chunk.
    ChunkPosition chunkPosition{tilePosition};
    Chunk* chunk{};
    if (auto chunkResult{getChunk(chunkPosition)}) {
        // Chunk exists.
        chunk = &(chunkResult->get());
    }
    else {
        return nullptr;
    }

    // Get the tile.
    Tile& tile{getTile(*chunk, chunkPosition, tilePosition)};

    // Remove any matching layers.
    remTileLayer(*chunk, tile, chunkPosition, layerType, graphicSetID,
                 graphicValue);

    return &tile;
}

bool TileMapBase::remTileLayer(Chunk& chunk, Tile& tile,
                               const ChunkPosition& chunkPosition,
                               const TileOffset& tileOffset,
                               TileLayer::Type layerType, Uint16 graphicSetID,
                               Uint8 graphicValue)
{
    // Remove any matching layers.
    std::size_t numRemoved{
        tile.removeLayers(tileOffset, layerType, graphicSetID, graphicValue)};

    // If we removed a layer, decrement the chunk's layer count.
    if (numRemoved > 0) {
        AM_ASSERT(chunk.tileLayerCount >= numRemoved,
                  "tileLayerCount was not properly maintained.");
        chunk.tileLayerCount -= static_cast<Uint16>(numRemoved);

        // If the chunk is now completely empty, erase it.
        if (chunk.tileLayerCount == 0) {
            chunks.erase(chunkPosition);
        }

        return true;
    }

    return false;
}

bool TileMapBase::remTileLayer(Chunk& chunk, Tile& tile,
                               const ChunkPosition& chunkPosition,
                               TileLayer::Type layerType, Uint16 graphicSetID,
                               Uint8 graphicValue)
{
    // Remove any matching layers.
    std::size_t numRemoved{
        tile.removeLayers(layerType, graphicSetID, graphicValue)};

    // If we removed a layer, decrement the chunk's layer count.
    if (numRemoved > 0) {
        AM_ASSERT(chunk.tileLayerCount >= numRemoved,
                  "tileLayerCount was not properly maintained.");
        chunk.tileLayerCount -= static_cast<Uint16>(numRemoved);

        // If the chunk is now completely empty, erase it.
        if (chunk.tileLayerCount == 0) {
            chunks.erase(chunkPosition);
        }

        return true;
    }

    return false;
}

bool TileMapBase::remTileLayers(Chunk& chunk, Tile& tile,
                                const ChunkPosition& chunkPosition,
                                TileLayer::Type layerType, Uint8 graphicValue)
{
    // Remove any matching layers.
    std::size_t numRemoved{tile.removeLayers(layerType, graphicValue)};

    // If we removed a layer, decrement the chunk's layer count.
    if (numRemoved > 0) {
        AM_ASSERT(chunk.tileLayerCount >= numRemoved,
                  "tileLayerCount was not properly maintained.");
        chunk.tileLayerCount -= static_cast<Uint16>(numRemoved);

        // If the chunk is now completely empty, erase it.
        if (chunk.tileLayerCount == 0) {
            chunks.erase(chunkPosition);
        }

        return true;
    }

    return false;
}

bool TileMapBase::remNorthWall(const TilePosition& tilePosition)
{
    auto tileResult{getTile(tilePosition)};
    if (!tileResult) {
        return false;
    }
    auto [chunk, tile] = *tileResult;

    // If the tile has a North wall or NE gap fill, remove it.
    ChunkPosition chunkPosition{tilePosition};
    bool wallWasRemoved{remTileLayers(
        chunk, tile, chunkPosition, TileLayer::Type::Wall, Wall::Type::North)};
    if (!wallWasRemoved) {
        wallWasRemoved
            = remTileLayers(chunk, tile, chunkPosition, TileLayer::Type::Wall,
                            Wall::Type::NorthEastGapFill);
    }

    // If a wall was removed.
    if (wallWasRemoved) {
        // Rebuild the affected tile's collision.
        rebuildTileCollision(tile, tilePosition);

        // Check if there's a NW gap fill to the East.
        TilePosition eastTilePosition{tilePosition.x + 1, tilePosition.y,
                                      tilePosition.z};
        if (auto eastTileResult{getTile(eastTilePosition)}) {
            auto [eastChunk, eastTile] = *eastTileResult;

            // If the East tile has a gap fill for a corner that we just broke,
            // remove it.
            if (remTileLayers(
                    eastChunk, eastTile, ChunkPosition{eastTilePosition},
                    TileLayer::Type::Wall, Wall::Type::NorthWestGapFill)) {
                rebuildTileCollision(eastTile, tilePosition);
            }
        }
    }

    return wallWasRemoved;
}

bool TileMapBase::remWestWall(const TilePosition& tilePosition)
{
    auto tileResult{getTile(tilePosition)};
    if (!tileResult) {
        return false;
    }
    auto [chunk, tile] = *tileResult;

    // If the tile has a West wall, remove it.
    ChunkPosition chunkPosition{tilePosition};
    if (remTileLayers(chunk, tile, chunkPosition, TileLayer::Type::Wall,
                      Wall::Type::West)) {
        // If the tile has a NE gap fill, change it to a North.
        if (TileLayer* northEastGapFill{tile.get().findLayer(
                TileLayer::Type::Wall, Wall::Type::NorthEastGapFill)}) {
            northEastGapFill->graphicValue = Wall::Type::North;
        }

        // Rebuild the affected tile's collision.
        rebuildTileCollision(tile, tilePosition);

        // Check if there's a NW gap fill to the South
        TilePosition southTilePosition{tilePosition.x, tilePosition.y + 1,
                                       tilePosition.z};
        if (auto southTileResult{getTile(southTilePosition)}) {
            auto [southChunk, southTile] = *southTileResult;

            // If the South tile has a gap fill for a corner that we just broke,
            // remove it.
            if (remTileLayers(
                    southChunk, southTile, ChunkPosition{southTilePosition},
                    TileLayer::Type::Wall, Wall::Type::NorthWestGapFill)) {
                rebuildTileCollision(southTile, tilePosition);
            }
        }

        return true;
    }

    return false;
}

Tile* TileMapBase::clearTileLayersInternal(
    const TilePosition& tilePosition,
    const std::array<bool, TileLayer::Type::Count>& layerTypesToClear)
{
    Chunk* chunk{};
    Tile* tile{};
    if (auto tileResult{getTile(tilePosition)}) {
        // Tile exists.
        chunk = &(tileResult->chunk.get());
        tile = &(tileResult->tile.get());
    }
    else {
        return nullptr;
    }

    // If we're being asked to clear every layer, clear the whole tile.
    std::size_t numRemoved{0};
    if (layerTypesToClear[TileLayer::Type::Terrain]
        && layerTypesToClear[TileLayer::Type::Floor]
        && layerTypesToClear[TileLayer::Type::Wall]
        && layerTypesToClear[TileLayer::Type::Object]) {
        numRemoved = tile->clear();
    }
    else {
        numRemoved = tile->clearLayers(layerTypesToClear);
    }

    // If we cleared any layers, decrement the chunk's layer count.
    if (numRemoved > 0) {
        AM_ASSERT(chunk->tileLayerCount >= numRemoved,
                  "tileLayerCount was not properly maintained.");
        chunk->tileLayerCount -= static_cast<Uint16>(numRemoved);

        // If the chunk is now completely empty, erase it.
        if (chunk->tileLayerCount == 0) {
            chunks.erase(ChunkPosition{tilePosition});
        }

        return tile;
    }

    return nullptr;
}

std::array<bool, TileLayer::Type::Count> TileMapBase::toBoolArray(
    const std::initializer_list<TileLayer::Type>& layerTypesToClear)
{
    std::array<bool, TileLayer::Type::Count> boolArray{};
    for (TileLayer::Type type : layerTypesToClear) {
        AM_ASSERT(type < TileLayer::Type::Count, "Invalid tile layer type.");
        boolArray[type] = true;
    }

    return boolArray;
}

template<typename T>
void TileMapBase::loadChunkInternal(const T& chunkSnapshot,
                                    const ChunkPosition& chunkPosition)
{
    // Note: We can't use the set/add functions because they'll push updates
    //       into the history, and addWall() adds extra walls.

    // If the chunk doesn't exist, create it.
    Chunk* chunk{getOrCreateChunk(chunkPosition)};
    if (!chunk) {
        LOG_FATAL("Invalid chunk position.");
        return;
    }

    // Iterate each of the tiles in the chunk snapshot.
    std::size_t currentTileLayerStartIndex{0};
    std::size_t currentTileIndex{0};
    std::size_t currentTileOffsetIndex{0};
    for (Uint8 tileLayerCount : chunkSnapshot.tileLayerCounts) {
        Tile& tile{chunk->tiles[currentTileIndex]};
        tile.clear();
        bool rebuildCollision{false};

        // Add each of this tile's layers to the map.
        for (std::size_t i{0}; i < tileLayerCount; ++i) {
            Uint8 paletteIndex{
                chunkSnapshot.tileLayers[currentTileLayerStartIndex + i]};
            const auto& paletteEntry{chunkSnapshot.palette[paletteIndex]};

            // Get this layer's graphic set and (if Floor/Object) tile offset.
            const GraphicSet* graphicSet{nullptr};
            TileOffset tileOffset{};
            switch (paletteEntry.layerType) {
                case TileLayer::Type::Terrain: {
                    graphicSet = &(graphicData.getTerrainGraphicSet(
                        paletteEntry.graphicSetID));
                    rebuildCollision = true;
                    break;
                }
                case TileLayer::Type::Floor: {
                    graphicSet = &(graphicData.getFloorGraphicSet(
                        paletteEntry.graphicSetID));
                    tileOffset
                        = chunkSnapshot.tileOffsets[currentTileOffsetIndex++];
                    break;
                }
                case TileLayer::Type::Wall: {
                    graphicSet = &(graphicData.getWallGraphicSet(
                        paletteEntry.graphicSetID));
                    rebuildCollision = true;
                    break;
                }
                case TileLayer::Type::Object: {
                    graphicSet = &(graphicData.getObjectGraphicSet(
                        paletteEntry.graphicSetID));
                    tileOffset
                        = chunkSnapshot.tileOffsets[currentTileOffsetIndex++];
                    rebuildCollision = true;
                    break;
                }
                default: {
                    break;
                }
            }

            if (!graphicSet) {
                LOG_FATAL("Graphic set was not found for loaded tile layer.");
            }

            // Add the layer to the tile.
            addTileLayer(*chunk, tile, tileOffset, paletteEntry.layerType,
                         *graphicSet, paletteEntry.graphicValue);
        }

        // Rebuild the tile's collision if necessary.
        if (rebuildCollision) {
            Morton::Result2D xyOffsets{
                Morton::decode16x16(static_cast<Uint8>(currentTileIndex))};
            TilePosition tilePosition(chunkPosition);
            tilePosition.x += xyOffsets.x;
            tilePosition.y += xyOffsets.y;
            rebuildTileCollision(tile, tilePosition);
        }

        currentTileLayerStartIndex += tileLayerCount;
        currentTileIndex++;
    }
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/TileMap/TilePosition.cpp`:

```cpp
#include "TilePosition.h"
#include "ChunkPosition.h"
#include "Position.h"
#include "SharedConfig.h"
#include "Log.h"

namespace AM
{
TilePosition::TilePosition()
: DiscretePosition<DiscreteImpl::TileTag>()
{
}

TilePosition::TilePosition(int inX, int inY, int inZ)
: DiscretePosition<DiscreteImpl::TileTag>(inX, inY, inZ)
{
}

TilePosition::TilePosition(
    const DiscretePosition<DiscreteImpl::TileTag>& tilePosition)
: DiscretePosition<DiscreteImpl::TileTag>(tilePosition)
{
}

TilePosition::TilePosition(const Vector3& worldPoint)
{
    static constexpr float TILE_WIDTH{
        static_cast<float>(SharedConfig::TILE_WORLD_WIDTH)};
    static constexpr float TILE_HEIGHT{
        static_cast<float>(SharedConfig::TILE_WORLD_HEIGHT)};

    // Note: We may want to account for float precision loss here using an 
    //       epsilon, but it's unclear how that rounding would behave (do you 
    //       round up? round down? round either direction if within epsilon 
    //       range?) This also applies for ChunkPosition and CellPosition.
    x = static_cast<int>(std::floor(worldPoint.x / TILE_WIDTH));
    y = static_cast<int>(std::floor(worldPoint.y / TILE_WIDTH));
    z = static_cast<int>(std::floor(worldPoint.z / TILE_HEIGHT));
}

TilePosition::TilePosition(const ChunkPosition& chunkPosition)
: DiscretePosition<DiscreteImpl::TileTag>(
    static_cast<int>(chunkPosition.x * SharedConfig::CHUNK_WIDTH),
    static_cast<int>(chunkPosition.y * SharedConfig::CHUNK_WIDTH),
    chunkPosition.z)
{
}

Vector3 TilePosition::getOriginPoint() const
{
    static constexpr float TILE_WIDTH{
        static_cast<float>(SharedConfig::TILE_WORLD_WIDTH)};
    static constexpr float TILE_HEIGHT{
        static_cast<float>(SharedConfig::TILE_WORLD_HEIGHT)};

    return {x * TILE_WIDTH, y * TILE_WIDTH, z * TILE_HEIGHT};
}

Vector3 TilePosition::getCenterPoint() const
{
    static constexpr float TILE_WIDTH{
        static_cast<float>(SharedConfig::TILE_WORLD_WIDTH)};
    static constexpr float TILE_HEIGHT{
        static_cast<float>(SharedConfig::TILE_WORLD_HEIGHT)};
    static constexpr float HALF_WIDTH{TILE_WIDTH / 2.f};
    static constexpr float HALF_HEIGHT{TILE_HEIGHT / 2.f};

    return {((x * TILE_WIDTH) + HALF_WIDTH), ((y * TILE_WIDTH) + HALF_WIDTH),
            ((z * TILE_HEIGHT) + HALF_HEIGHT)};
}

Vector3 TilePosition::getCenteredBottomPoint() const
{
    static constexpr float TILE_WIDTH{
        static_cast<float>(SharedConfig::TILE_WORLD_WIDTH)};
    static constexpr float TILE_HEIGHT{
        static_cast<float>(SharedConfig::TILE_WORLD_HEIGHT)};
    static constexpr float HALF_WIDTH{TILE_WIDTH / 2.f};

    return {((x * TILE_WIDTH) + HALF_WIDTH), ((y * TILE_WIDTH) + HALF_WIDTH),
            (z * TILE_HEIGHT)};
}

void TilePosition::print() const
{
    LOG_INFO("(%d, %d, %d)", x, y, z);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Private/Vector3.cpp`:

```cpp
#include "Vector3.h"
#include "Log.h"

namespace AM
{
Vector3 Vector3::operator+(const Vector3& other) const
{
    return {(x + other.x), (y + other.y), (z + other.z)};
}

Vector3 Vector3::operator-(const Vector3& other) const
{
    return {(x - other.x), (y - other.y), (z - other.z)};
}

Vector3 Vector3::operator*(const Vector3& other) const
{
    return {(x * other.x), (y * other.y), (z * other.z)};
}

Vector3 Vector3::operator*(float scalar) const
{
    return {(x * scalar), (y * scalar), (z * scalar)};
}

Vector3 Vector3::operator/(const Vector3& other) const
{
    return {(x / other.x), (y / other.y), (z / other.z)};
}

Vector3 Vector3::operator/(float scalar) const
{
    return {(x / scalar), (y / scalar), (z / scalar)};
}

Vector3& Vector3::operator+=(const Vector3& other)
{
    x += other.x;
    y += other.y;
    z += other.z;
    return *this;
}

Vector3& Vector3::operator-=(const Vector3& other)
{
    x -= other.x;
    y -= other.y;
    z -= other.z;
    return *this;
}

Vector3& Vector3::operator*=(const Vector3& other)
{
    x *= other.x;
    y *= other.y;
    z *= other.z;
    return *this;
}

Vector3& Vector3::operator*=(float scalar)
{
    x *= scalar;
    y *= scalar;
    z *= scalar;
    return *this;
}

Vector3& Vector3::operator/=(const Vector3& other)
{
    x /= other.x;
    y /= other.y;
    z /= other.z;
    return *this;
}

Vector3& Vector3::operator/=(float scalar)
{
    x /= scalar;
    y /= scalar;
    z /= scalar;
    return *this;
}

bool Vector3::operator==(const Vector3& other) const
{
    return (x == other.x) && (y == other.y) && (z == other.z);
}

bool Vector3::operator!=(const Vector3& other) const
{
    return (x != other.x) || (y != other.y) || (z != other.z);
}

void Vector3::normalize()
{
    const float length{std::sqrt((x * x) + (y * y) + (z * z))};
    *this /= length;
}

Vector3 Vector3::normal() const
{
    const float length{std::sqrt((x * x) + (y * y) + (z * z))};
    return (*this / length);
}

Vector3 Vector3::reciprocal() const
{
    return {1.f / x, 1.f / y, 1.f / z};
}

float Vector3::dot(const Vector3& other) const
{
    return (x * other.x) + (y * other.y) + (z * other.z);
}

Vector3 Vector3::slide(const Vector3& normal) const
{
    return *this - (normal * dot(normal));
}

Vector3 Vector3::moveTowards(const Vector3& otherPoint, float distance) const
{
    float squaredDistanceToOther{squaredDistanceTo(otherPoint)};
    float squaredDistance{distance * distance};

    // If we can reach it, return otherPoint.
    if (squaredDistance >= squaredDistanceToOther) {
        return otherPoint;
    }

    // Can't reach. Calculate the intermediate point.
    Vector3 vector{otherPoint - *this};
    vector.normalize();
    vector *= distance;
    return *this + vector;
}

float Vector3::squaredDistanceTo(const Vector3& other) const
{
    Vector3 distance{std::abs(x - other.x), std::abs(y - other.y),
                     std::abs(z - other.z)};
    return {(distance.x * distance.x) + (distance.y * distance.y)
            + (distance.z * distance.z)};
}

void Vector3::print() const
{
    LOG_INFO("(%.4f, %.4f, %.4f)", x, y, z);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/AMMath.h`:

```h
#pragma once

#include "Vector3.h"
#include <cmath>

namespace AM
{
/**
 * STL-adjacent algorithms for our custom types.
 */
class Math
{
public:

/**
 * Returns a component-wise minimum of the given vectors.
 */
static Vector3 min(const Vector3& a, const Vector3& b)
{
    Vector3 res;
    res.x = std::min(a.x, b.x);
    res.y = std::min(a.y, b.y);
    res.z = std::min(a.z, b.z);
    return res;
}

/**
 * Returns a component-wise maximum of the given vectors.
 */
static Vector3 max(const Vector3& a, const Vector3& b)
{
    Vector3 res;
    res.x = std::max(a.x, b.x);
    res.y = std::max(a.y, b.y);
    res.z = std::max(a.z, b.z);
    return res;
}

/**
 * Returns a component-wise maximum of the given vectors.
 */
static Vector3 abs(const Vector3& vector)
{
    return {std::abs(vector.x), std::abs(vector.y), std::abs(vector.z)};
}

};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/BoundingBox.h`:

```h
#pragma once

#include "Vector3.h"
#include <array>

namespace AM
{
struct Position;
struct Cylinder;
struct Ray;
struct TileExtent;
struct TilePosition;

/**
 * A 3D axis-aligned box shape.
 */
struct BoundingBox {
    /** This box's minimum point */
    Vector3 min;

    /** This box's maximum point */
    Vector3 max;

    BoundingBox();

    constexpr BoundingBox(const Vector3& inMin, const Vector3& inMax)
    : min{inMin}
    , max{inMax}
    {
    }

    /**
     * Constructs a box that tightly wraps the given cylinder.
     */
    BoundingBox(const Cylinder& cylinder);

    BoundingBox(const TileExtent& tileExtent);

    bool operator==(const BoundingBox& other) const;

    float xLength() const;

    float yLength() const;

    float zLength() const;

    /**
     * Returns a point centered on this bounding box in the X and Y axis, and
     * at this box's minimum Z value.
     *
     * Note: This matches the placement of an entity's Position component, in 
     *       relation to the entity's bounding volume.
     */
    Vector3 getBottomCenterPoint() const;

    /**
     * Returns a point centered on this bounding box in the X and Y axis, and 
     * at this box's maximum Z value.
     */
    Vector3 getTopCenterPoint() const;

    /**
     * Returns a point at the center of this bounding box.
     *
     * Note: This center point is different than an entity's Position component.
     *       This one is centered in all axis, while an entity's Position is 
     *       centered in the X/Y but is at the minimum Z.
     */
    Vector3 get3DCenterPoint() const;

    /**
     * @return true if this box has no area.
     */
    bool isEmpty() const;

    /**
     * Returns true if this box intersects the given other bounding box.
     * Note: Shared edges are considered to be intersecting.
     */
    bool intersects(const BoundingBox& other) const;

    /**
     * Returns true if this box intersects the given cylinder.
     * Note: Shared edges are considered to be intersecting.
     */
    bool intersects(const Cylinder& cylinder) const;

    /**
     * Returns true if this box intersects the given tile extent.
     *
     * Note: This treats the tile extent as having infinite length along the
     *       Z axis.
     * Note: Shared edges are considered to be intersecting.
     */
    bool intersects(const TileExtent& tileExtent) const;

    /**
     * Returns true if this box intersects the given ray.
     */
    bool intersects(const Ray& ray) const;

    /**
     * Returns true if this box intersects the given line.
     */
    bool intersects(const Vector3& start, const Vector3& end) const;

    struct RayIntersectReturn
    {
        /** If true, an intersection occurred. */
        bool didIntersect{};
        /** If didIntersect == true, this is the t value where the ray first 
            intersects the box.
            If the ray origin is inside the box, this will be <= 0 and
            clamped to tMinBound. */
        float tMin{};
        /** If didIntersect == true, this is the t value where the ray last
            intersects the box.
            This will be clamped to tMaxBound. */
        float tMax{};
    };
    /**
     * Looks for an intersection between this box and the given ray, within the 
     * range [tMinBound, tMaxBound].
     *
     * Note: If you're going to constrain to a magnitude-independent range like
     *       [0, 1], remember to normalize the ray's direction before taking the 
     *       reciprocal. However, if the magnitude is important to your 
     *       calculations (e.g. if you want to compare the resultant tMin to a
     *       distance), don't normalize.
     */
    RayIntersectReturn intersects(const Ray& ray, float tMinBound,
                                  float tMaxBound) const;

    /**
     * Looks for an intersection between this box and the given ray, within the 
     * range [tMinBound, tMaxBound].
     *
     * Note: See intersects(Ray) for a note on normalization.
     */
    RayIntersectReturn intersects(const Vector3& rayOrigin,
                                  const Vector3& inverseRayDirection,
                                  float tMinBound, float tMaxBound) const;

    /**
     * Returns true if this box fully encloses the given other bounding box.
     * Note: Shared edges are considered to be contained.
     */
    bool contains(const BoundingBox& boundingBox) const;

    /**
     * Returns true if this box fully encloses the given cylinder.
     * Note: Shared edges are considered to be contained.
     */
    bool contains(const Cylinder& cylinder) const;

    /**
     * Returns true if this box contains the given world point.
     */
    bool contains(const Vector3& worldPoint) const;

    /**
     * Returns this box with its min point moved to the given point.
     */
    [[nodiscard]] BoundingBox moveTo(const Vector3& newMin) const;

    /**
     * Returns this box with its bottom center moved to the given point 
     * (centered along X/Y axis, min.z == newBottomCenter.z).
     *
     * Note: This matches the placement of an entity's Position component, in 
     *       relation to the entity's bounding volume.
     */
    [[nodiscard]] BoundingBox
        moveBottomCenterTo(const Vector3& newBottomCenter) const;

    /**
     * Returns this box with its position translated by the given amount.
     */
    [[nodiscard]] BoundingBox translateBy(const Vector3& amountToMove) const;

    /**
     * Returns the union between this box and the given other box.
     */
    [[nodiscard]] BoundingBox unionWith(const BoundingBox& other) const;

    /**
     * Returns this box with its size increased by the given amount in all 
     * directions.
     */
    [[nodiscard]] BoundingBox expandBy(float amountToExpandBy) const;

    /**
     * Prints this box's current values.
     */
    void print() const;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/BoundingBoxID.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/** A bounding box's numeric ID. */
using BoundingBoxID = Uint16;

/**
 * The ID used to indicate that a bounding box is not present.
 *
 * Note: Since the null ID is 0, you can do null checks like 
 *       "if (boundingBoxID)".
 */
static constexpr BoundingBoxID NULL_BOUNDING_BOX_ID{0};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/CastableData/AVEntity.h`:

```h
#pragma once

#include "GraphicSets.h"
#include <vector>

namespace AM
{

/**
 * Defines a client-only entity for displaying audio/visual effects.
 *
 * Since A/V entities can move in irregular ways, they don't share the 
 * MovementSystem/GraphicSystem code paths with regular entities. Instead, 
 * AVSystem handles all of their updates.
 *
 * Note: Since these entities are purely visual, they're inappropriate for 
 *       something like a spell that moves around the ground and continuously 
 *       does damage. For that, you'll need to spawn a server entity.
 */
struct AVEntity {
    enum class Behavior {
        /** Start at casterEntity, move towards targetEntity. End early if it's 
            reached. */
        MoveToEntity,
        /** Start at casterEntity, move towards targetPosition. End early if 
            it's reached. */
        MoveToPosition,
        /** Start at casterEntity, move towards targetEntity for durationS 
            seconds. */
        FollowEntityStartCaster,
        /** Start at targetEntity, move towards targetEntity for durationS 
            seconds. */
        FollowEntityStartTarget,
        /** Start at casterEntity, move towards targetPosition for durationS 
            seconds. */
        FollowDirection,
        /** Stay at targetPosition for durationS seconds. */
        StaticPosition,
        /** Stay at the current position for durationS seconds. Invalid as 
            first phase. */
        CurrentPosition
    };

    struct Phase {
        /** The graphic set to use. 
            Note: We use graphic sets instead of e.g. VisualEffect because it 
                  needs to match the direction of movement. */
        EntityGraphicSetID graphicSetID{};

        // TODO: Sounds

        /** The behavior that the entity should exhibit. */
        Behavior behavior{};

        /** How fast the entity should move. */
        float movementSpeed{};

        /** How long this phase should run before timing out.
            If -1, this phase will last until the graphic plays once. If the 
            graphic is a sprite, it will end immediately. */
        float durationS{};
    };

    /** If the first phase's behavior starts at casterEntity, this is how far 
        from the caster (towards the target) to start at. Use this to avoid 
        clipping. */
    float startDistance{0};

    /** If true, this entity will be able to move in all directions. If false, 
        it will travel along the X/Y plane, maintaining the same Z height. */
    bool canMoveVertically{true};

    /** The phases that this entity will go through before being destroyed. */
    std::vector<Phase> phases{};
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/CastableData/CastFailureType.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/**
 * All of the ways in which a Castable cast may fail.
 */
enum class CastFailureType : Uint8 {
    None,
    /** A client ID was provided, but the specified client does not exist. */
    InvalidClient,
    /** The given castable ID doesn't exist. */
    InvalidCastable,
    /** The caster entity is already casting something. */
    AlreadyCasting,
    /** The requested cast is on cooldown, or the GCD is active. */
    OnCooldown,
    /** The target entity or position is out of range of the caster. */
    OutOfRange,
    /** The target entity or position is out of the caster's line of sight. */
    LineOfSight,
    /** The target item does not exist. */
    InvalidItem,
    /** The target item or entity doesn't support the requested interaction 
        type. */
    InteractionNotSupported,
    /** The caster entity doesn't exist. */
    InvalidCasterEntity,
    /** The target entity doesn't exist. */
    InvalidTargetEntity,
    /** The target position is outside of the tile map. */
    InvalidTargetPosition,
    /** The project's validateCast() call returned false. */
    ProjectValidationFailed,
    /** The caster entity moved. */
    Movement,
};

/**
 * Returns a user-facing failure string for the given failure type.
 */
inline const char* getCastFailureString(CastFailureType failureType)
{
    // Note: We only add strings for failure types that the user can do 
    //       something about. Internal failures due to e.g. bugs shouldn't be 
    //       sent to the user.
    switch (failureType) {
        case CastFailureType::AlreadyCasting:
            return "A cast is already underway.";
        // Note: We don't add a failure message for OnCooldown because there 
        //       should already be something in the UI to show cooldowns.
        //case CastFailureType::OnCooldown:
        case CastFailureType::OutOfRange:
            return "Out of range.";
        case CastFailureType::LineOfSight: 
            return "Target not in line of sight.";
        case CastFailureType::InvalidTargetEntity:
            return "You have no target.";
        case CastFailureType::Movement:
            return "Can't do that while moving.";
        // Note: This occurs client-side when you use a cast type that doesn't 
        //       have an associated Castable object.
        case CastFailureType::InvalidCastable:
            return "Cast failed: Please set a Castable object for this cast "
                   "type.";
        default:
            break;
    }

    return "";
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/CastableData/CastInfo.h`:

```h
#pragma once

#include "Castable.h"
#include "Item.h"
#include "NetworkID.h"
#include "Vector3.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include <functional>

namespace AM
{
/**
 * All of the information necessary to perform a cast.
 */
struct CastInfo {
    /** The Castable that's being cast. Should always be non-nullptr. */
    const Castable* castable{nullptr};

    /** The ID of the entity performing the cast.
        May or may not be a client entity. */
    entt::entity casterEntity{entt::null};

    /** If this is an ItemInteraction cast, this is the item that's being 
        used. 
        Note: This field isn't filled when using this struct in Client code. 
              If needed, we can change this. See CastStarted.h. */
    const Item* item{nullptr};

    /** The ID of the target entity. If this is an EntityInteraction cast, this 
        will always be present. Otherwise, this will be filled if the client 
        has a current target. */
    entt::entity targetEntity{entt::null};

    /** The target position. This will be filled if the Castable has a 
        targetToolType that selects a position.*/
    Vector3 targetPosition{};

    /** The network ID of the client performing the cast.
        If non-null, this cast belongs to a client entity.
        Only filled by the server, not used by the client. */
    NetworkID clientID{NULL_NETWORK_ID};
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/CastableData/Castable.h`:

```h
#pragma once

#include "CastableID.h"
#include "CastableProjectData.h"
#include "CastableRequirementType.h"
#include "EntityGraphicType.h"
#include "VisualEffect.h"
#include "AVEntity.h"
#include "Cylinder.h"
#include <functional>
#include <vector>
#include <variant>

namespace AM
{

/**
 * An abstraction that groups interactions and spells into a single concept.
 *
 * Casts are defined in a few stages:
 *     1. Pre-cast
 *         Before the cast has started. Check the requirements, make sure the 
 *         entity can cast it.
 *     2. Casting
 *         The cast has begun. Set the caster to a casting graphic, send a 
 *         request to the server.
 *     3. (Predicted) Cast complete
 *         The cast has finished on the client. If the Castable is set to be 
 *         predicted, play any resulting A/V effects.
 *     4. Cast complete
 *         The cast has finished on the server. Process any world state 
 *         changes. If the Castable is set to non-predicted, play any resulting
 *         A/V effects.
 */
struct Castable {
    /** This Castable's unique ID. */
    CastableID castableID{ItemInteractionType::NotSet};

    enum class TargetType {
        /** Always targets the caster. */
        Self,
        /** Targets another entity. */
        Entity,
        /** Targets another entity if one is provided, otherwise targets
            the caster. */
        SelfOrEntity,
        /** Targets an AoE circle on the ground. */
        Circle 
    };
    /** This castable's targeting behavior. Determines what data must be 
        provided by the client in the "cast request" message. */
    TargetType targetType{};

    /** How far away the target can be. */
    float range{0};

    /** If targetToolType == Circle, this is the radius of the circle. */
    float radius{0};

    /** How long this castable takes to cast. */
    float castTime{0};

    /** How long the caster must wait to cast this castable again. */
    float cooldownTime{0};

    /** If true, casting this castable will trigger the global cooldown (see 
        SharedConfig::CAST_GLOBAL_COOLDOWN_S). */
    bool triggersGCD{true};

    /** If true, this cast will be queued by the server and processed on the 
        tick when the client cast it (clients are in the future). If false, it 
        will be processed as soon as the server receives it.
        Most castables will want this to be true. False is useful for things 
        that should be instant and don't affect the sim, e.g. Examine, Talk. */
    bool isTickSynchronized{true};

    /** Project-specific data. */
    CastableProjectData projectData{};

    struct Requirement {
        CastableRequirementType type{};
        int value{};
    };
    /** The requirements to cast this castable. */
    std::vector<Requirement> requirements{};

    /** The graphic to loop while this castable is being cast. */
    EntityGraphicType castingGraphicType{EntityGraphicType::NotSet};

    // TODO: castingSoundType

    /** The graphic to play when this castable is successfully cast. */
    EntityGraphicType castCompleteGraphicType{EntityGraphicType::NotSet};

    // TODO: castCompleteSoundType

    /** The client-only visual effects to play when this cast is successful. */
    std::vector<VisualEffect> castCompleteVisualEffects{};

    /** The client-only audio effects to play when this cast is successful. */
    //std::vector<AudioEffect> castCompleteAudioEffects{};

    /** The client-only A/V entities to spawn when this cast is successful. */
    std::vector<AVEntity> castCompleteAVEntities{};

    /**
     * Returns a target cylinder centered on the given position along the X/Y 
     * axes, and sitting on top of it along the Z axis.
     *
     * Only valid if targetToolType == Circle and radius is set.
     */
    Cylinder getTargetCylinder(const Vector3& position) const;

    /**
     * Returns true if this castable has any graphics or effects.
     */
    bool hasVisuals() const;
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/CastableData/CastableData.h`:

```h
#pragma once

#include "CastableID.h"
#include "Castable.h"
#include "ItemInteractionType.h"
#include "EntityInteractionType.h"
#include "SpellType.h"
#include <unordered_map>

namespace AM
{
class GraphicDataBase;

/**
 * Holds Castable data.
 * 
 * Castables are created at runtime by C++ code, but they're intended to be 
 * initialized once at construction time and immutable thereafter. The effect 
 * is the same as if they were being loaded from a shared file.
 */
class CastableData
{
public:
    CastableData(const GraphicDataBase& graphicData);

    /**
     * @return If no castable with the given ID exists, returns nullptr. Else,
     *         returns the requested castable.
     * Note: This returns nullptr for the null castable.
     */
    const Castable* getCastable(CastableID castableID) const;

private:
    /**
     * Adds the given castable to the appropriate map.
     */
    void addCastable(const Castable& castable);

    // Note: We use maps for these instead of arrays because the interaction 
    //       enums have big gaps (we reserve values since they get serialized 
    //       and would have to be migrated if we changed them). If there's 
    //       significant performance benefit in using an array, we can switch 
    //       and just live with the space usage.
    /** Holds item interactions, indexed by their ItemInteractionType. */
    std::unordered_map<ItemInteractionType, Castable> itemInteractionMap;

    /** Holds entity interaction, indexed by their EntityInteractionType. */
    std::unordered_map<EntityInteractionType, Castable> entityInteractionMap;

    /** Holds spells, indexed by their SpellType. */
    std::unordered_map<SpellType, Castable> spellMap;
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/CastableData/CastableID.h`:

```h
#pragma once

#include "ItemInteractionType.h"
#include "EntityInteractionType.h"
#include "SpellType.h"
#include "bitsery/ext/std_variant.h"
#include <variant>

namespace AM
{

/**
 * Identifies a castable.
 *
 * Castables fall into one of 3 types (item interaction, entity interaction, 
 * spell), and are associated with an enum value. Only one castable can be 
 * assigned to each type+value, so this ID is unique.
 */
using CastableID
    = std::variant<ItemInteractionType, EntityInteractionType, SpellType>;

template<typename S>
void serialize(S& serializer, CastableID& castableID)
{
    serializer.ext(castableID,
                   bitsery::ext::StdVariant{[](S& serializer, auto& type) {
                       serializer.value1b(type);
                   }});
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/CastableData/EngineCastableDef.h`:

```h
#pragma once

#include "CastableID.h"
#include "Castable.h"
#include "GraphicDataBase.h"
#include "SharedConfig.h"
#include <functional>

namespace AM
{

/**
 * Defines all of the engine-provided castables (item interactions, entity 
 * interactions, and spells).
 */
class EngineCastableDef {
public:
    static void
        defineCastables(const GraphicDataBase&,
                        std::function<void(const Castable&)> addCastable)
    {
        addCastable({.castableID{ItemInteractionType::Examine},
                     .triggersGCD{false},
                     .isTickSynchronized{false}});

        addCastable(
            {.castableID{EntityInteractionType::Talk},
             .range{SharedConfig::CAST_ENTITY_INTERACTION_STANDARD_RANGE},
             .triggersGCD{false},
             .isTickSynchronized{false}});
    }
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/CastableData/VisualEffect.h`:

```h
#pragma once

#include "GraphicID.h"

namespace AM
{

/**
 * Defines a single visual effect.
 *
 * Typically, this will be attached to an entity to display a temporary graphic, 
 * e.g. showing a heal graphic when an entity uses a health item.
 *
 * When the graphic is done playing, this effect is automatically destroyed.
 */
struct VisualEffect {
    /** The graphic to display. */
    GraphicID graphicID{};

    enum class LoopMode {
        PlayOnce,
        Loop
    };

    /** If the graphic is an animation, this determines whether to play the 
        animation once or to loop it. If the graphic is a sprite, this will 
        be ignored (sprites are always treated as looping). */
    LoopMode loopMode{};

    /** If loopMode == Loop, this is how long to loop for. */
    float loopTime{};
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/CollisionLocator.h`:

```h
#pragma once

#include "CollisionBitSets.h"
#include "CellExtent.h"
#include "CellPosition.h"
#include "TilePosition.h"
#include "TileExtent.h"
#include "ChunkExtent.h"
#include "Terrain.h"
#include "SharedConfig.h"
#include "entt/fwd.hpp"
#include "entt/entity/entity.hpp"
#include <vector>
#include <span>
#include <optional>

namespace AM
{
class Tile;
struct Cylinder;
struct BoundingBox;

/**
 * A spatial partitioning grid that tracks where collision volumes are located.
 *
 * Used to quickly determine which collision volumes are located within a given
 * extent of the world.
 *
 * This locator tracks both entities and tile layers, and it tracks them by
 * their bounding volume (i.e. collision). Not all entities and tile layers
 * have collision, so they may not be tracked by this locator.
 * For Position-related entity queries, see EntityLocator.h.
 *
 * Internally, collision volumes are organized into "cells", each of which has
 * a size corresponding to SharedConfig::COLLISION_LOCATOR_CELL_WIDTH. These
 * values can be tweaked to affect performance.
 */
class CollisionLocator
{
public:
    /**
     * A world object's collision information.
     */
    struct CollisionInfo {
        /** The world object's collision volume. */
        BoundingBox collisionVolume{};

        /** The collision layers that this world object appears in. */
        CollisionLayerBitSet collisionLayers{};

        /** If non-null, this object is an entity and this is its ID. */
        entt::entity entity{entt::null};
    };

    CollisionLocator();

    /**
     * Sets this locator's internal grid size to match the given extent.
     */
    void setGridSize(const TileExtent& tileExtent);

    /**
     * Adds the given entity to this locator, or updates it if it's already
     * added.
     *
     * @param entity The entity to add.
     * @param collisionVolume The entity's collision volume.
     * @param collisionLayers The layers that this entity should appear in.
     *
     * @return true if successful, else false (collision outside of locator 
     *         bounds).
     */
    bool updateEntity(entt::entity entity, const BoundingBox& collisionVolume,
                      CollisionLayerBitSet collisionLayers);

    /**
     * Adds the given tile to this locator, or updates it if it's already added.
     *
     * @param tilePosition The tile's position.
     * @param tile The tile to add.
     */
    void updateTile(const TilePosition& tilePosition, const Tile& tile);

    /**
     * Removes the given entity from this locator, if present.
     */
    void removeEntity(entt::entity entity);

    struct RaycastParams {
        const Vector3& start;
        const Vector3& end;
        CollisionLayerBitSet collisionMask{};
        std::span<entt::entity> entitiesToExclude{};
        bool ignoreInsideHits{true};
    };
    /**
     * Returns true if the given ray intersects any collision volume.
     *
     * @param collisionMask The bitmask to use when filtering world objects. If
     *                      a layer is present in the mask, objects in that
     *                      layer will be included in the results.
     * @param ignoreInsideHits If true, volumes that this raycast starts inside
     *                         of will be ignored.
     */
    bool raycastAny(const RaycastParams& params);

    struct RaycastHitInfo {
        /** The t value (along the ray) at which this object was hit. */
        float hitT{};

        /** The hit object's collision info. */
        const CollisionInfo* collisionInfo{};
    };
    /**
     * Returns the first collision volume that the given ray intersects.
     *
     * See raycastAny() for parameter info.
     * @return The info of the first hit world object (if any).
     *         The contained pointer is not stable, and may become invalid when
     *         any of this locator's functions are called.
     */
    std::optional<RaycastHitInfo> raycastFirst(const RaycastParams& params);

    /**
     * Returns all collision volumes that the given ray intersects.
     *
     * See raycastAny() for parameter info.
     * @return The info of each hit world object, in no particular order.
     *         The contained pointers are not stable, and may become invalid
     *         when any of this locator's functions are called.
     */
    std::vector<RaycastHitInfo>& raycastAll(const RaycastParams& params);

    /**
     * Returns all collision volumes that intersect the given cylinder.
     *
     * Note: Because collision boxes vary in size, results are not commutative
     *       (if a cylinder centered on volumeA intersects volumeB, the reverse
     *       may not be true).
     *
     * @param collisionMask The bitmask to use when filtering world objects. If
     *                      a layer is present in the mask, objects in that
     *                      layer will be included in the results.
     * @return Pointers to the info of each hit world object. These pointers
     *         are not stable, and may become invalid when any of this locator's
     *         functions are called.
     */
    std::vector<const CollisionInfo*>&
        getCollisions(const Cylinder& cylinder,
                      CollisionLayerBitSet collisionMask);

    /**
     * Overload for BoundingBox.
     */
    std::vector<const CollisionInfo*>&
        getCollisions(const BoundingBox& boundingBox,
                      CollisionLayerBitSet collisionMask);

    /**
     * Overload for TileExtent.
     */
    std::vector<const CollisionInfo*>&
        getCollisions(const TileExtent& tileExtent,
                      CollisionLayerBitSet collisionMask);

    /**
     * Overload for ChunkExtent.
     */
    std::vector<const CollisionInfo*>&
        getCollisions(const ChunkExtent& chunkExtent,
                      CollisionLayerBitSet collisionMask);

    /**
     * Performs a broad phase to get all collision volumes in cells intersected
     * by the given cylinder.
     *
     * Note: All volumes in the intersected cells are returned, which may
     *       include volumes that aren't actually within the radius.
     *
     * @param collisionMask The bitmask to use when filtering world objects. If
     *                      a layer is present in the mask, objects in that
     *                      layer will be included in the results.
     */
    std::vector<const CollisionInfo*>&
        getCollisionsBroad(const Cylinder& cylinder,
                           CollisionLayerBitSet collisionMask);

    /**
     * Overload for BoundingBox.
     */
    std::vector<const CollisionInfo*>&
        getCollisionsBroad(const BoundingBox& boundingBox,
                           CollisionLayerBitSet collisionMask);

    /**
     * Overload for TileExtent.
     */
    std::vector<const CollisionInfo*>&
        getCollisionsBroad(const TileExtent& tileExtent,
                           CollisionLayerBitSet collisionMask);

    /**
     * Overload for ChunkExtent.
     */
    std::vector<const CollisionInfo*>&
        getCollisionsBroad(const ChunkExtent& chunkExtent,
                           CollisionLayerBitSet collisionMask);

private:
    /** Raycast strategies. Defined here so they have access to the locator's
        private members. */
    struct RaycastStrategyIntersectAny;
    struct RaycastStrategyIntersectFirst;
    struct RaycastStrategyIntersectAll;

    /** The width of a grid cell in world units. */
    static constexpr float CELL_WORLD_WIDTH{
        SharedConfig::COLLISION_LOCATOR_CELL_WIDTH
        * SharedConfig::TILE_WORLD_WIDTH};

    /** The height of a grid cell in world units. */
    static constexpr float CELL_WORLD_HEIGHT{
        SharedConfig::COLLISION_LOCATOR_CELL_HEIGHT
        * SharedConfig::TILE_WORLD_HEIGHT};

    /** The size of a grid cell in world units. */
    static constexpr Vector3 CELL_WORLD_SIZE{CELL_WORLD_WIDTH, CELL_WORLD_WIDTH,
                                             CELL_WORLD_HEIGHT};

    /** A value to use in terrainGrid to indicate that a tile has no terrain. */
    static constexpr Terrain::Value EMPTY_TERRAIN{SDL_MAX_UINT8};

    /**
     * Adds the given index to the collisionGrid cells within the given extent.
     */
    void addCollisionVolumeToCells(Uint16 volumeIndex,
                                   const CellExtent& cellExtent);

    /**
     * Removes the given index from the collisionGrid cells within the given
     * extent.
     */
    void clearCollisionVolumeFromCells(Uint16 volumeIndex,
                                       const CellExtent& clearExtent);

    /**
     * Adds the given tile's collision volumes to the collision and terrain
     * grids.
     */
    void addTileCollisionVolumes(const TilePosition& tilePosition,
                                 const Tile& tile);

    template<typename RaycastStrategy>
    void raycastInternal(RaycastStrategy& strategy, const RaycastParams& params);

    /**
     * Performs a broad phase to get all collision volumes in cells intersected
     * by the given cellExtent.
     *
     * Note: All volumes in the intersected cells are returned, which may
     *       include volumes that aren't actually within the radius.
     *
     * @param tileExtent A tile extent matching cellExtent. Used to generate
     *                   terrain.
     * @param collisionMask The bitmask to use when filtering world objects. If
     *                      a layer is present in the mask, objects in that
     *                      layer will be included in the results.
     *
     * @pre tileExtent and cellExtent must be pre-clipped to this locator's
     *      bounds.
     */
    std::vector<const CollisionInfo*>&
        getCollisionsBroad(const TileExtent& tileExtent,
                           const CellExtent& cellExtent,
                           CollisionLayerBitSet collisionMask);

    /**
     * Returns the index in the collisionGrid vector where the cell with the
     * given coordinates can be found.
     */
    inline std::size_t
        linearizeCellIndex(const CellPosition& cellPosition) const
    {
        // Translate the given position from actual-space to positive-space.
        CellPosition positivePosition{cellPosition.x - gridCellExtent.x,
                                      cellPosition.y - gridCellExtent.y,
                                      cellPosition.z - gridCellExtent.z};

        return static_cast<std::size_t>(
            (gridCellExtent.xLength * gridCellExtent.yLength
             * positivePosition.z)
            + (gridCellExtent.xLength * positivePosition.y)
            + positivePosition.x);
    }

    /**
     * Returns the index in the terrainGrid vector where the tile with the
     * given coordinates can be found.
     */
    inline std::size_t
        linearizeTileIndex(const TilePosition& tilePosition) const
    {
        // Translate the given position from actual-space to positive-space.
        TilePosition positivePosition{tilePosition.x - gridTileExtent.x,
                                      tilePosition.y - gridTileExtent.y,
                                      tilePosition.z - gridTileExtent.z};

        return static_cast<std::size_t>(
            (gridTileExtent.xLength * gridTileExtent.yLength
             * positivePosition.z)
            + (gridTileExtent.xLength * positivePosition.y)
            + positivePosition.x);
    }

    /** The grid's extent, with tiles as the unit. */
    TileExtent gridTileExtent;

    /** The grid's extent, with cells as the unit. */
    CellExtent gridCellExtent;

    /** The collision volume and related info for each world object that this
        locator is tracking. */
    std::vector<CollisionInfo> collisionVolumes;

    /** Tracks which indices in collisionVolumes are free to use. */
    std::vector<Uint16> freeCollisionVolumesIndices;

    /** The outer vector is a 3D grid stored in row-major order, holding the
        grid's cells.
        Each element in the grid is a vector of volumes--the volumes that
        currently intersect with that cell (represented by their index in
        collisionVolumes). */
    std::vector<std::vector<Uint16>> collisionGrid;

    /** A map of entities -> the index of their collision volumes in
        collisionVolumes. */
    std::unordered_map<entt::entity, Uint16> entityMap;
    /** A map of tiles -> the indices of their layer's collision volumes in
        collisionVolumes. */
    std::unordered_map<TilePosition, std::vector<Uint16>> tileMap;

    /** A 3D grid where each element holds the terrain of the associated tile.
        Since terrain can be fully described by its 1B value, it's more
        efficient to store the value and construct the bounding box as needed
        instead of storing it in collisionGrid. */
    std::vector<Terrain::Value> terrainGrid;

    /** Holds the collision info of any Terrain tile layers that were hit during
        the last query (so that the query result has somewhere to point to). */
    std::vector<CollisionInfo> terrainCollisionVolumes;

    /** A scratch vector used for gathering results during the broad phase. */
    std::vector<Uint16> indexVector;

    /** The vector that we use to return collision results. */
    std::vector<const CollisionInfo*> collisionReturnVector;

    /** The vector that we use to return raycast results. */
    std::vector<RaycastHitInfo> raycastReturnVector;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/CollisionLocatorRaycastStrategy.h`:

```h
#pragma once

#include "CollisionLocator.h"

namespace AM
{

// Raycast strategies. Defined in the CollisionLocator namespace so they have 
// access to the locator's private members.
struct CollisionLocator::RaycastStrategyIntersectAny
{
    RaycastStrategyIntersectAny(CollisionLocator& inCollisionLocator);

    bool isDone() const;

    void intersectObjectsInCell(const Vector3& start,
                                const Vector3& inverseRayDirection,
                                const CellPosition& cellPosition,
                                CollisionLayerBitSet collisionMask,
                                std::span<entt::entity> entitiesToExclude,
                                bool ignoreInsideHits);

    bool hasIntersected;

private:
    CollisionLocator& collisionLocator;
};

struct CollisionLocator::RaycastStrategyIntersectFirst
{
    RaycastStrategyIntersectFirst(CollisionLocator& inCollisionLocator);

    bool isDone() const;

    void intersectObjectsInCell(const Vector3& start,
                                const Vector3& inverseRayDirection,
                                const CellPosition& cellPosition,
                                CollisionLayerBitSet collisionMask,
                                std::span<entt::entity> entitiesToExclude,
                                bool ignoreInsideHits);

    bool hasIntersected;

    CollisionLocator::RaycastHitInfo firstHitInfo;

private:
    CollisionLocator& collisionLocator;
};

struct CollisionLocator::RaycastStrategyIntersectAll
{
    RaycastStrategyIntersectAll(CollisionLocator& inCollisionLocator);

    bool isDone() const;

    void intersectObjectsInCell(const Vector3& start,
                                const Vector3& inverseRayDirection,
                                const CellPosition& cellPosition,
                                CollisionLayerBitSet collisionMask,
                                std::span<entt::entity> entitiesToExclude,
                                bool ignoreInsideHits);

private:
    CollisionLocator& collisionLocator;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/Components/Camera.h`:

```h
#pragma once

#include "Position.h"
#include "PreviousPosition.h"
#include "BoundingBox.h"
#include "TileExtent.h"
#include <SDL_rect.h>

namespace AM
{
/**
 * The player's camera viewport. Tracks where in the world the player is
 * currently viewing.
 */
struct Camera {
    enum MovementBehavior {
        // Camera will not move.
        Fixed,
        // Camera will center on its associated entity.
        CenterOnEntity
    };

    /** The camera's movement behavior. */
    MovementBehavior behavior{MovementBehavior::CenterOnEntity};

    /** The position that the camera is pointing at.
        Since our camera always faces the same direction, it's more useful to 
        track the target than it is to track the camera's own position. */
    Position target{};

    /** The position that the camera was previously pointing at. Used for 
        lerping in the renderer. */
    PreviousPosition prevTarget{};

    /** The area that the camera is viewing, in world space.
        This is the total viewable area, at any zoom amount. */
    BoundingBox viewBounds{};

    /** The camera's view extent in screen space, calculated during the last 
        render tick in Renderer::getLerpedCamera(). */
    SDL_FRect screenExtent{0, 0, 0, 0};

    /** The amount that this camera is zoomed in or out. 1.0 is no zoom. */
    float zoomFactor{1.0};

    /**
     * Returns the tile extent that is in view of this camera.
     *
     * @param mapTileExtent The tile map's bounds.
     */
    TileExtent getTileViewExtent(const TileExtent& mapTileExtent) const;
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/Components/CastCooldown.h`:

```h
#pragma once

#include "CastableID.h"
#include <vector>

namespace AM
{

/**
 * Tracks cooldowns for any Castables that the entity recently cast.
 *
 * This component isn't replicated on every update like others (the constant 
 * timer updates would cause tons of traffic). Instead, we only send an update 
 * when something is added to it.
 */
struct CastCooldown {
    /** Used as a "we should never hit this" cap on the number of cooldowns. */
    static constexpr std::size_t MAX_COOLDOWNS{100};

    struct Cooldown {
        // The Castable that is on cooldown.
        CastableID castableID{};

        /** The remaining ticks for this cooldown. */
        Uint32 ticksRemaining{0};
    };

    /** The latest tick when this component was updated. */
    Uint32 lastUpdateTick{};

    /** The remaining ticks for the "global cooldown", a cooldown that occurs 
        after every cast. See SharedConfig::CAST_GLOBAL_COOLDOWN_S. */
    Uint32 gcdTicksRemaining{0};

    /** The remaining ticks for each cooldown. */
    std::vector<Cooldown> cooldowns{};

    /**
     * Returns true if the global cooldown is active, or the given cast is on 
     * cooldown.
     * 
     * This function has a side effect of updating all of this component's 
     * cooldown times and removing expired cooldowns. We do this because it's 
     * efficient: we need to update the desired cooldown (if present) anyway 
     * to tell if it has expired, so doing the rest of the updates is 
     * relatively low-cost.
     */
    bool isCastOnCooldown(CastableID castableID, Uint32 currentTick);

    /**
     * Updates all cooldowns to the given tick.
     */
    void update(Uint32 newTick);

    /**
     * Initializes this component after being loaded from the database.
     *
     * Since cooldowns are lazy-updated, when they're loaded they may not have 
     * accounted for the time between when they were last updated and when they
     * were saved.
     * 
     * @param lastSavedTick The tick when the data was saved to the DB.
     * @param currentTick The current tick.
     */
    void initAfterLoad(Uint32 lastSavedTick, Uint32 currentTick);
};

template<typename S>
void serialize(S& serializer, CastCooldown::Cooldown& cooldown)
{
    serializer.object(cooldown.castableID);
    serializer.value4b(cooldown.ticksRemaining);
}

template<typename S>
void serialize(S& serializer, CastCooldown& castCooldown)
{
    serializer.value4b(castCooldown.lastUpdateTick);
    serializer.value4b(castCooldown.gcdTicksRemaining);
    serializer.container(castCooldown.cooldowns, CastCooldown::MAX_COOLDOWNS);
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/Components/Collision.h`:

```h
#pragma once

#include "BoundingBox.h"

namespace AM
{
/**
 * Represents an entity's collision bounds (a.k.a collision box, or just
 * collision).
 *
 * When an entity is constructed, we set this component's modelBounds to match 
 * the Idle South model bounds of SharedConfig::DEFAULT_ENTITY_GRAPHIC_SET. 
 * This makes it easy for project devs to define the default entity collision.
 * If the project dev wants different default collision for different entities,
 * they can handle it in a project system.
 *
 * Entities use this component to define a consistent collision box. This
 * allows us to change their animation without worrying about re-calculating
 * their collision.
 * Tiles just use their graphic's model bounds to define their collision.
 */
struct Collision {
    /** Model-space bounding box. Defines the entity's 3D volume.
        Note: When an entity's graphic set is updated, we automatically update 
              this field to match the new set's Idle South. */
    BoundingBox modelBounds{};

    /** World-space bounding box. This is modelBounds, moved to the entity's
        position in the world. */
    BoundingBox worldBounds{};
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/Components/CollisionBitSets.h`:

```h
#pragma once

#include "CollisionLayerType.h"
#include "entt/fwd.hpp"
#include "bitsery/bitsery.h"

namespace AM
{

/**
 * Tracks how an entity should be configured in CollisionLocator.
 */
struct CollisionBitSets {
public:
    /** Sets to defaults. */
    CollisionBitSets();

    /** Sets to defaults, accounting for entity state. */
    CollisionBitSets(entt::entity entity, entt::registry& registry);

    /**
     * Sets the layers that this entity will appear in.
     */
    void setCollisionLayers(CollisionLayerBitSet inCollisionLayers,
                            entt::entity entity, entt::registry& registry);

    /**
     * Sets the layers that this entity will scan for collisions during movement.
     */
    void setCollisionMask(CollisionLayerBitSet inCollisionMask);

    CollisionLayerBitSet getCollisionLayers() const;

    CollisionLayerBitSet getCollisionMask() const;

private:
    /**
     * By default, entities should block collision but not block LoS.
     */
    static constexpr CollisionLayerBitSet DEFAULT_COLLISION_LAYERS{
        CollisionLayerType::BlockCollision};

    /**
     * By default, entities should collide with terrain and wall tile layers.
     */
    static constexpr CollisionLayerBitSet DEFAULT_COLLISION_MASK{
        CollisionLayerType::TerrainWall};

    /** The layers that this entity appears in. */
    CollisionLayerBitSet collisionLayers;

    /** The layers that this entity will scan for collisions during movement. */
    CollisionLayerBitSet collisionMask;

    friend class bitsery::Access;
    template<typename S>
    void serialize(S& serializer)
    {
        serializer.value2b(collisionLayers);
        serializer.value2b(collisionMask);
    }
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/Components/EntityInitScript.h`:

```h
#pragma once

#include <string>

namespace AM
{
/**
 * An entity's initialization script. Init scripts allow builders to customize
 * an entity by adding components and interactions to it.
 *
 * Init scripts are stored on the server in this component. When a client
 * wants to edit an entity, we send them that entity's script so they don't
 * have to start from scratch.
 * When a client sends an updated init script for an entity, we:
 *   1. Destruct the entity.
 *   2. Re-create it and add back its default components.
 *   3. Run the new init script on it.
 *
 * Init scripts aren't used by client entities.
 */
struct EntityInitScript {
    /** Used as a "we should never hit this" cap on the length of the script
        string. */
    static constexpr std::size_t MAX_LENGTH{10000};

    /** The initialization script. */
    std::string script{};
};

template<typename S>
void serialize(S& serializer, EntityInitScript& initScript)
{
    serializer.text1b(initScript.script, EntityInitScript::MAX_LENGTH);
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/Components/GraphicState.h`:

```h
#pragma once

#include "GraphicSets.h"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Holds graphic-related state that is shared between the client and server.
 *
 * For client-specific graphic state, see ClientGraphicState.
 *
 * The entity's collision box and mouse hit detection area (in build mode) are 
 * derived from this state.
 */
struct GraphicState
{
    EntityGraphicSetID graphicSetID{NULL_ENTITY_GRAPHIC_SET_ID};
};

template<typename S>
void serialize(S& serializer, GraphicState& graphicState)
{
    serializer.value2b(graphicState.graphicSetID);
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/Components/Input.h`:

```h
#pragma once

#include "bitsery/ext/std_bitset.h"
#include <bitset>

namespace AM
{
/**
 * Represents an entity's current movement-related input states.
 *
 * In the server, when this component is updated, MovementSyncSystem auto-sends
 * movement state updates to all nearby clients.
 * If you want to sync an entity's movement state (e.g. Position) without
 * changing its inputs, you can just registry.patch() with no changes.
 */
struct Input {
    enum Type : Uint8 { XUp, XDown, YUp, YDown, Jump, Crouch, Count, None };

    enum State : Uint8 { Released, Pressed };

    /** Holds the current state of the inputs, indexed by Input::Type. */
    using StateArr = std::bitset<6>;
    StateArr inputStates{};
};

template<typename S>
void serialize(S& serializer, Input& input)
{
    // Bit pack the input bitset.
    serializer.enableBitPacking(
        [&input](typename S::BPEnabledType& sbp) {
            sbp.ext(input.inputStates, bitsery::ext::StdBitset{});
        });

    // Note: We shouldn't need to align after bit packing (when the context ends,
    //       it'll auto-align), but measureSize() enables bit packing for 
    //       everything, so the context never ends and aligns itself.
    serializer.adapter().align();
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/Components/Interaction.h`:

```h
#pragma once

#include "EntityInteractionType.h"
#include "SharedConfig.h"
#include <vector>

namespace AM
{

/**
 * Represents the interactions that an entity supports, i.e. the options that
 * show up when you right click them.
 *
 * Note: This component won't be present on an entity if it has no interactions.
 */
struct Interaction {
    /** The interactions that this entity supports.
        The first interaction in this list is the default interaction. */
    std::vector<EntityInteractionType> supportedInteractions{};

    /**
     * Adds the given interaction to supportedInteractions.
     * @return true if the interaction was added, else false (already present 
     *         or array was full).
     */
    bool add(EntityInteractionType newInteraction);

    /**
     * Returns true if this component supports the given interaction.
     */
    bool supports(EntityInteractionType desiredInteraction) const;
};

template<typename S>
void serialize(S& serializer, Interaction& interaction)
{
    serializer.container1b(interaction.supportedInteractions,
                           SharedConfig::MAX_ENTITY_INTERACTIONS);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/Components/Inventory.h`:

```h
#pragma once

#include "ItemID.h"
#include <SDL_stdinc.h>
#include <vector>

namespace AM
{
class ItemDataBase;
struct Item;
struct ItemCombination;

/**
 * Represents an entity's inventory of items.
 *
 * All client entities have an inventory. Non-client entities may or may not
 * have one.
 *
 * Note: This isn't auto-replicated, because it's only relevant to the server, 
 *       and to the client that owns it. Instead, the client adds an Inventory 
 *       for the player entity, and we send custom messages to replicate it.
 */
struct Inventory {
public:
    /** The absolute maximum number of items we can have in an inventory.
        We use Uint8 to hold slot indices, so 256 is our max. */
    static constexpr std::size_t MAX_ITEMS{256};

    /** The default maximum number of items we can have in an inventory. */
    static constexpr Uint8 DEFAULT_INVENTORY_SIZE{20};

    /** The number of slots in this inventory. */
    Uint8 size{0};

    struct ItemSlot {
        /** The item in this inventory slot. */
        ItemID ID{NULL_ITEM_ID};

        /** How many of the item is in this inventory slot. */
        Uint8 count{0};
    };

    /** This inventory's item slots.
        Empty slots will have ID == NULL_ITEM_ID.
        Note: Slots may be allocated, but still be empty. If you're iterating
              this vector, be sure to check for NULL_ITEM_ID. */
    std::vector<ItemSlot> slots;

    Inventory(Uint8 inSize = DEFAULT_INVENTORY_SIZE);

    /**
     * Adds the given item to this inventory.
     *
     * If a slot contains the same itemID and has room, adds to it.
     * If not, tries to add to the first empty slot.
     *
     * @return true if the item was added, else false (inventory is full).
     *
     * Note: This doesn't check if itemID is a valid item.
     * Note: On the Server, you likely don't want to call this directly. See 
     *       InventoryHelpers.h.
     */
    bool addItem(ItemID itemID, Uint8 count, Uint8 maxStackSize);

    /**
     * Removes the given count of items from the given inventory slot.
     *
     * @return true if the item was removed, else false (slot index isn't valid,
     *         count is 0).
     *
     * Note: On the Server, you likely don't want to call this directly. See 
     *       InventoryHelpers.h.
     */
    bool removeItem(Uint8 slotIndex, Uint8 count);

    /**
     * Moves the item in sourceSlot into destSlot (or swaps, if there's an
     * item already in destSlot).
     *
     * @return true if the items were moved, else false (slot index isn't
     * valid).
     */
    bool moveItem(Uint8 sourceSlotIndex, Uint8 destSlotIndex);

    /**
     * Returns true if this inventory contains at least 1 of the given item.
     */
    bool contains(ItemID itemID) const;

    /**
     * Returns the ID of the item at the given inventory slot.
     * If the given index is invalid or there's no item in the slot, returns
     * NULL_ITEM_ID.
     */
    ItemID getItemID(Uint8 slotIndex) const;

    /**
     * Returns the count for the given item across all inventory slots.
     */
    std::size_t getItemCount(ItemID itemID) const;

    /**
     * Returns the item at the given inventory slot.
     * If the given index is invalid or there's no item in the slot, returns
     * nullptr.
     */
    const Item* getItem(Uint8 slotIndex, const ItemDataBase& itemData) const;

    /**
     * Combines the items in the given slots and decrements their count
     * (emptying the slot if count == 0).
     *
     * Looks up the item's combinations to determine what the resulting item is.
     * Only for use by the server.
     *
     * @return The used combination if the items were combined, else nullptr
     *         (slot index isn't valid, either slot was empty, neither item
     *         contained the combination).
     */
    const ItemCombination* combineItems(Uint8 sourceSlotIndex,
                                        Uint8 targetSlotIndex,
                                        const ItemDataBase& itemData);

    /**
     * Overload for the client version of this operation.
     *
     * Clients don't have the combination data for any items, so this overload
     * instead takes in the resulting item's ID.
     */
    void combineItems(Uint8 sourceSlotIndex, Uint8 targetSlotIndex,
                      ItemID resultItemID, Uint8 resultItemMaxStackSize);

    /**
     * Resizes this inventory to match the given new size.
     */
    void resize(Uint8 newSize);

    /**
     * Returns the number of slots that have an item in them.
     */
    Uint8 getFilledSlotCount();

    /** Returns true if the given inventory slot index is valid, else returns
        false. */
    bool slotIndexIsValid(Uint8 slotIndex) const;

    /**
     * Reduces the item count in the given slot by the given count.
     * If the resulting count <= 0, empties the slot.
     */
    void reduceItemCount(Uint8 slotIndex, Uint8 count);
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/Components/IsClientEntity.h`:

```h
#pragma once

namespace AM
{
/**
 * A tag struct used to tell if an entity belongs to a client or not.
 *
 * Terms:
 *   "Client entities" are controlled by a client.
 *   "Non-client entities" are controlled by the server (objects, npcs, etc).
 *   "Player entity" is the client entity controlled by this client.
 *   "Non-player-controlled entity (NPC)" is any non-player entity. This may be
 *   a client entity or a non-client entity.
 */
struct IsClientEntity {
    // Note: No networked data.
};

template<typename S>
void serialize(S&, IsClientEntity&)
{
    // Note: No data to serialize.
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/Components/Movement.h`:

```h
#pragma once

#include "Vector3.h"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Holds an entity's current movement state, calculated each tick by the 
 * relevant movement system.
 *
 * X and Y-axis velocity is simulated with infinite friction while on the 
 * ground, and with no friction while in the air.
 * Z-axis velocity is simulated with a standard force of gravity.
 *
 * All non-velocity variables in this component primarily exist (along with the 
 * Input and MovementStats components) to contribute to the calculation of 
 * velocity.
 */
struct Movement {
    /** The entity's current velocity, in world units per second.
        This is managed by the engine. Project devs should instead use 
        velocityMod. */
    Vector3 velocity{};

    /** If false, the entity is currently standing on top of something.
        If true, the entity is falling through the air. */
    bool isFalling{false};

    /** The number of times the entity has jumped since last touching the 
        ground. */
    Uint8 jumpCount{0};

    /** If true, the jump input has already been processed and is being held.
        We track this separately from Input.inputStates[Input::Jump] so that we 
        can compare the previous tick's state to the current. This lets us ensure
        the input is released and re-pressed, to prevent accidental air jumps. */
    bool jumpHeld{false};
};

template<typename S>
void serialize(S& serializer, Movement& movement)
{
    serializer.object(movement.velocity);
    serializer.value1b(movement.jumpCount);

    // Note: Packing this field is necessary, otherwise it wouldn't match 
    //       MeasureSize (which always has bit packing enabled).
    serializer.enableBitPacking(
        [&movement](typename S::BPEnabledType& sbp) {
            sbp.boolValue(movement.isFalling);
            sbp.boolValue(movement.jumpHeld);
        });

    // Align after bit-packing to make sure the following bytes can be easily
    // processed.
    serializer.adapter().align();
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/Components/MovementModifiers.h`:

```h
#pragma once

#include "Vector3.h"
#include <SDL_stdinc.h>

namespace AM
{
/**
 * Holds variables that affect an entity's movement.
 * 
 * The intended use of this is for projects to calculate all of their 
 * movement-related modifiers (gear bonuses, buffs/debuffs, knockbacks, etc), 
 * then to set these variables to reflect those total values. The project also 
 * must update these values as they change.
 *
 * The project is responsible for these values. The engine will never change 
 * them, only read them.
 *
 * TODO: Add a message for modifying this
 */
struct MovementModifiers {
    /** Velocity modifiers, to apply to the entity on the next tick. */
    Vector3 velocityMod{};

    /** The distance that the entity can travel per second, in world units. */
    Uint16 runSpeed{48};

    /** The vertical impulse added to the entity when jumping, in world units 
        per second. */
    Uint16 jumpImpulse{250};

    /** The maximum number of times the entity can jump before needing to 
        touch the ground. */
    Uint8 maxJumpCount{3};

    /** If true, the entity will not be affected by gravity, and its jump and 
        crouch inputs will instead raise and lower it in the air. */
    bool canFly{false};
};

template<typename S>
void serialize(S& serializer, MovementModifiers& movementMods)
{
    serializer.object(movementMods.velocityMod);
    serializer.value2b(movementMods.runSpeed);
    serializer.value2b(movementMods.jumpImpulse);
    serializer.value1b(movementMods.maxJumpCount);

    // Note: Packing this field is necessary, otherwise it wouldn't match 
    //       MeasureSize (which always has bit packing enabled).
    serializer.enableBitPacking(
        [&movementMods](typename S::BPEnabledType& sbp) {
            sbp.boolValue(movementMods.canFly);
        });

    // Note: We shouldn't need to align after bit packing (when the context ends,
    //       it'll auto-align), but measureSize() enables bit packing for 
    //       everything, so the context never ends and aligns itself.
    serializer.adapter().align();
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/Components/Name.h`:

```h
#pragma once

#include <string>

namespace AM
{
/**
 * Represents an entity's name.
 *
 * All client/server-synchronized entities have a name. Client-only A/V 
 * entities don't have names.
 */
struct Name {
    /** The max length of a name. */
    static constexpr std::size_t MAX_LENGTH{50};

    std::string value{""};
};

template<typename S>
void serialize(S& serializer, Name& name)
{
    serializer.text1b(name.value, Name::MAX_LENGTH);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/Components/Position.h`:

```h
#pragma once

#include "Vector3.h"

namespace AM
{
/**
 * Represents a position in the world.
 *
 * All entities possess a Position component.
 *
 * Note: An entity's graphics will be aligned with its position (specifically, 
 *       the graphic's alignment anchor will be centered on the position).
 */
struct Position : Vector3 {
    Position operator=(const Vector3& vector)
    {
        x = vector.x;
        y = vector.y;
        z = vector.z;
        return *this;
    }
};

template<typename S>
void serialize(S& serializer, Position& position)
{
    serializer.value4b(position.x);
    serializer.value4b(position.y);
    serializer.value4b(position.z);
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/Components/PreviousPosition.h`:

```h
#pragma once

#include "Position.h"

namespace AM
{
/**
 * Represents an entity's previous position.
 * Used for lerping during things like movement and rendering.
 */
struct PreviousPosition : Position {
    /** Used to tell if this position has been set or not. */
    bool isInitialized{false};

    PreviousPosition& operator=(const Position& other)
    {
        x = other.x;
        y = other.y;
        z = other.z;

        return *this;
    }
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/Components/Rotation.h`:

```h
#pragma once

#include "Log.h"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * Represents an entity's rotation about the z-axis, i.e. yaw, or "the
 * direction the entity is facing".
 *
 * Due to being a sprite-based engine, rotation about other axes is not viable,
 * and rotation is locked to 8 directions.
 *
 * Note: This is specifically a rotation component that will be attached to an
 *       entity. When doing 3D math, we use other structs (Position, Ray, etc).
 */
struct Rotation {
    /**
     * The 8 directions that rotation is locked to.
     */
    enum Direction : Uint8 {
        South,
        SouthWest,
        West,
        NorthWest,
        North,
        NorthEast,
        East,
        SouthEast,
        Count,
        None, /*!< No inputs, or inputs are canceling eachother out. */
    };

    /** The current direction that the entity is facing. */
    Direction direction{Direction::South};
};

template<typename S>
void serialize(S& serializer, Rotation& rotation)
{
    serializer.value1b(rotation.direction);
}

namespace DisplayStrings
{
inline std::string get(Rotation::Direction direction)
{
    switch (direction) {
        case Rotation::Direction::South:
            return "S";
        case Rotation::Direction::SouthWest:
            return "SW";
        case Rotation::Direction::West:
            return "W";
        case Rotation::Direction::NorthWest:
            return "NW";
        case Rotation::Direction::North:
            return "N";
        case Rotation::Direction::NorthEast:
            return "NE";
        case Rotation::Direction::East:
            return "E";
        case Rotation::Direction::SouthEast:
            return "SE";
        default:
            break;
    }

    LOG_ERROR("Tried to get display string for unknown direction.");
    return "?";
}

} // namespace DisplayStrings
} // namespace AM

```

`Source/SharedLib/Simulation/Public/Cylinder.h`:

```h
#pragma once

#include "Position.h"

namespace AM
{
struct BoundingBox;

/**
 * Represents a capped cylinder.
 */
struct Cylinder {
    /** Center point. */
    Position center{};

    /** Radius along the X/Y axes. */
    float radius{0};

    /** Half height along the Z axis. */
    float halfHeight{0};

    /**
     * Returns true if this cylinder intersects the given position.
     *
     * Note: Shared edges are considered to be intersecting.
     */
    bool intersects(const Position& position) const;

    /**
     * Returns true if this cylinder intersects the given bounding box.
     *
     * Note: Shared edges are considered to be intersecting.
     */
    bool intersects(const BoundingBox& boundingBox) const;

    /**
     * Prints this cylinder's current values.
     */
    void print() const;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/DialogueEvent.h`:

```h
#pragma once

#include <string>
#include <variant>

namespace AM
{

/** Used as a "we should never hit this" cap on the text lengths. */
static constexpr std::size_t MAX_DIALOGUE_LINE_TEXT_LENGTH{500};

/**
 * Describes a piece of dialogue that was said.
 */
struct SayEvent
{
    std::string text{};
};

/**
 * Describes anything that isn't verbal: actions, settings, thoughts, feelings.
 */
struct NarrateEvent
{
    std::string text{};
};

/** A dialogue event. */
using DialogueEvent = std::variant<SayEvent, NarrateEvent>;


template<typename S>
void serialize(S& serializer, SayEvent& sayEvent)
{
    serializer.text1b(sayEvent.text, MAX_DIALOGUE_LINE_TEXT_LENGTH);
}

template<typename S>
void serialize(S& serializer, NarrateEvent& narrateEvent)
{
    serializer.text1b(narrateEvent.text, MAX_DIALOGUE_LINE_TEXT_LENGTH);
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/DiscreteExtent.h`:

```h
#pragma once

#include "DiscreteImpl.h"
#include "DiscretePosition.h"

namespace AM
{
/**
 * A rectangle that encloses discretely-positioned things (e.g. tiles, chunks).
 */
template<typename T>
struct DiscreteExtent {
    /** The X-axis coordinate of this extent's origin. */
    int x{0};

    /** The Y-axis coordinate of this extent's origin. */
    int y{0};

    /** The Z-axis coordinate of this extent's origin.
        Increasing Z is upwards. */
    int z{0};

    /** The X-axis length of this extent. */
    int xLength{0};

    /** The Y-axis length of this extent. */
    int yLength{0};

    /** The Z-axis length of this extent. */
    int zLength{0};

    DiscreteExtent()
    : x{0}
    , y{0}
    , z{0}
    , xLength{0}
    , yLength{0}
    , zLength{0}
    {
    }

    DiscreteExtent(int inX, int inY, int inZ, int inXLength, int inYLength,
                   int inZLength)
    : x{inX}
    , y{inY}
    , z{inZ}
    , xLength{inXLength}
    , yLength{inYLength}
    , zLength{inZLength}
    {
    }

    /**
     * Constructor that takes origin and extreme points to form a extent.
     */
    explicit DiscreteExtent(DiscretePosition<T> origin,
                            DiscretePosition<T> extreme)
    : x{origin.x}
    , y{origin.y}
    , z{origin.z}
    , xLength{extreme.x - origin.x}
    , yLength{extreme.y - origin.y}
    , zLength{extreme.z - origin.z}
    {
    }

    bool operator==(const DiscreteExtent<T>& other) const
    {
        return (x == other.x) && (y == other.y) && (z == other.z)
               && (xLength == other.xLength) && (yLength == other.yLength)
               && (zLength == other.zLength);
    }

    /**
     * Returns the max valid X position in this extent.
     * Note: Named differently from BoundingBox's 'maxX' member to avoid
     *       confusion (variable vs function).
     */
    int xMax() const { return (x + xLength - 1); }

    /**
     * Returns the max valid Y position in this extent.
     */
    int yMax() const { return (y + yLength - 1); }

    /**
     * Returns the max valid Z position in this extent.
     */
    int zMax() const { return (z + zLength - 1); }

    /**
     * Returns the minimum position of this extent.
     */
    DiscretePosition<T> min() const { return {x, y, z}; }

    /**
     * Returns the maximum position of this extent.
     */
    DiscretePosition<T> max() const { return {xMax(), yMax(), zMax()}; }

    /**
     * Returns the union between this extent and the given extent.
     */
    [[nodiscard]] DiscreteExtent<T>
        unionWith(const DiscreteExtent<T>& other) const
    {
        DiscreteExtent<T> finalExtent{*this};

        // Note: We can add some special fast cases for empty extents if we
        //       ever care to, but they likely wouldn't be exercised much.

        /* X union. */
        // Calc the min and max X coordinates for both ranges.
        int selfMin{x};
        int selfMax{x + xLength};
        int otherMin{other.x};
        int otherMax{other.x + other.xLength};

        // Determine which min and max are the least constrained.
        if (otherMin < selfMin) {
            selfMin = otherMin;
        }

        if (otherMax > selfMax) {
            selfMax = otherMax;
        }

        // Save the new min and length.
        finalExtent.x = selfMin;
        finalExtent.xLength = (selfMax - selfMin);

        /* Y union. */
        // Copy the logic from above, replacing X with Y.
        selfMin = y;
        selfMax = y + yLength;
        otherMin = other.y;
        otherMax = other.y + other.yLength;

        if (otherMin < selfMin) {
            selfMin = otherMin;
        }

        if (otherMax > selfMax) {
            selfMax = otherMax;
        }

        finalExtent.y = selfMin;
        finalExtent.yLength = (selfMax - selfMin);

        /* Z union. */
        // Copy the logic from above, replacing X with Z.
        selfMin = z;
        selfMax = z + zLength;
        otherMin = other.z;
        otherMax = other.z + other.zLength;

        if (otherMin < selfMin) {
            selfMin = otherMin;
        }

        if (otherMax > selfMax) {
            selfMax = otherMax;
        }

        finalExtent.z = selfMin;
        finalExtent.zLength = (selfMax - selfMin);

        return finalExtent;
    }

    /**
     * Returns the intersection between this extent and the given extent.
     */
    [[nodiscard]] DiscreteExtent<T>
        intersectWith(const DiscreteExtent<T>& other) const
    {
        DiscreteExtent<T> finalExtent{*this};

        // Note: We can add some special fast cases for empty extents if we
        //       ever care to, but they likely wouldn't be exercised much.

        /* X intersection. */
        // Calc the min and max X coordinates for both ranges.
        int selfMin{x};
        int selfMax{x + xLength};
        int otherMin{other.x};
        int otherMax{other.x + other.xLength};

        // Determine which min and max are the most constrained.
        if (otherMin > selfMin) {
            selfMin = otherMin;
        }

        if (otherMax < selfMax) {
            selfMax = otherMax;
        }

        // Save the new min and length.
        finalExtent.x = selfMin;
        finalExtent.xLength = (selfMax - selfMin);

        /* Y intersection. */
        // Copy the logic from above, replacing X with Y.
        selfMin = y;
        selfMax = y + yLength;
        otherMin = other.y;
        otherMax = other.y + other.yLength;

        if (otherMin > selfMin) {
            selfMin = otherMin;
        }

        if (otherMax < selfMax) {
            selfMax = otherMax;
        }

        finalExtent.y = selfMin;
        finalExtent.yLength = (selfMax - selfMin);

        /* Z intersection. */
        // Copy the logic from above, replacing X with Z.
        selfMin = z;
        selfMax = z + zLength;
        otherMin = other.z;
        otherMax = other.z + other.zLength;

        if (otherMin > selfMin) {
            selfMin = otherMin;
        }

        if (otherMax < selfMax) {
            selfMax = otherMax;
        }

        finalExtent.z = selfMin;
        finalExtent.zLength = (selfMax - selfMin);

        return finalExtent;
    }

    /**
     * @return true if the given position is within this extent, else false.
     */
    bool contains(const DiscretePosition<T>& position) const
    {
        return ((position.x >= x) && (position.x < (x + xLength))
                && (position.y >= y) && (position.y < (y + yLength))
                && (position.z >= z) && (position.z < (z + zLength)));
    }

    /**
     * @return true if the given extent is fully within this extent, else
     *         false.
     */
    bool contains(const DiscreteExtent<T>& extent) const
    {
        DiscretePosition<T> origin{extent.x, extent.y, extent.z};
        DiscretePosition<T> extreme{(extent.x + extent.xLength - 1),
                                    (extent.y + extent.yLength - 1),
                                    (extent.z + extent.zLength - 1)};
        return (contains(origin) && contains(extreme));
    }

    /**
     * @return true if this extent has no area.
     */
    bool isEmpty() const
    {
        return ((xLength <= 0) || (yLength <= 0) || (zLength <= 0));
    }

    /**
     * @return A count of the number of discrete elements within this extent.
     *         Can also be thought of as the volume of this extent.
     */
    std::size_t size() const { return (xLength * yLength * zLength); }
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/DiscreteImpl.h`:

```h
#pragma once

namespace AM
{
namespace DiscreteImpl
{
/**
 * A tag type to express that a DiscreteRange or DiscretePosition is using
 * tiles as its unit.
 */
struct TileTag {
};

/**
 * A tag type to express that a DiscreteRange or DiscretePosition is using
 * chunks as its unit.
 */
struct ChunkTag {
};

/**
 * A tag type to express that a DiscreteRange or DiscretePosition is using
 * spatial partitioning grid cells as its unit.
 */
struct CellTag {
};

} // namespace DiscreteImpl

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/DiscretePosition.h`:

```h
#pragma once

#include "DiscreteImpl.h"
#include <cmath>

namespace AM
{
/**
 * The position of a particular discrete unit (e.g. tiles, chunks).
 */
template<typename T>
struct DiscretePosition {
    /** The X-axis coordinate of this position. */
    int x{0};

    /** The Y-axis coordinate of this position. */
    int y{0};

    /** The Z-axis coordinate of this position. */
    int z{0};

    bool operator==(const DiscretePosition<T>& other) const
    {
        return (x == other.x) && (y == other.y) && (z == other.z);
    }

    bool operator!=(const DiscretePosition<T>& other) const
    {
        return (x != other.x) || (y != other.y) || (z != other.z);
    }

    bool operator<(const DiscretePosition<T>& other) const
    {
        if (x < other.x)
            return true;
        if (x > other.x)
            return false;

        if (y < other.y)
            return true;
        if (y > other.y)
            return false;

        if (z < other.z)
            return true;
        if (z > other.z)
            return false;

        return false;
    }

    DiscretePosition<T> operator+(const DiscretePosition<T>& other) const
    {
        return {(x + other.x), (y + other.y), (z + other.z)};
    }

    DiscretePosition<T>& operator+=(const DiscretePosition<T>& other)
    {
        x += other.x;
        y += other.y;
        z += other.z;
        return *this;
    }

    DiscretePosition<T> operator-(const DiscretePosition<T>& other) const
    {
        return {(x - other.x), (y - other.y), (z - other.z)};
    }

    DiscretePosition<T>& operator-=(const DiscretePosition<T>& other)
    {
        x -= other.x;
        y -= other.y;
        z -= other.z;
        return *this;
    }

    /**
     * If this position is within 1 unit of the given position, returns true.
     */
    bool isAdjacentTo(const DiscretePosition<T>& other) const
    {
        // Get the differences between the positions.
        int xDif{other.x - x};
        int yDif{other.y - y};
        int zDif{other.z - z};

        // Square the differences.
        xDif *= xDif;
        yDif *= yDif;
        zDif *= zDif;

        // If the absolute squared distance is within 1 unit, return true.
        return (std::abs(xDif + yDif + zDif) <= 1);
    }
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/EngineCollisionLayerType.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/** A type that can be used for collision layer bitsets.
    Must always match the underlying type of EngineCollisionLayerType::Value. */
using CollisionLayerBitSet = Uint16;

/**
 * The collision layer types that the engine provides.
 *
 * Note: Don't use this enum directly, use CollisionLayerType (it combines the 
 *       engine's and the project's collision layer types)
 */
struct EngineCollisionLayerType
{
    enum Value : Uint16 {
        /** Terrain and Wall tile layers. */
        TerrainWall = 1 << 0,
        /** Object tile layers. */
        Object = 1 << 1,
        ClientEntity = 1 << 2,
        NonClientEntity = 1 << 3,
        /** Entities that can be collided with. */
        BlockCollision = 1 << 4,
        /** Entities that block Line-of-Sight raycasts. */
        BlockLoS = 1 << 5,
    };
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/EngineEntityGraphicType.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/**
 * The entity graphic types that the engine provides.
 *
 * Note: Don't use this enum directly, use EntityGraphicType (it combines
 *       the engine's and the project's graphic types).
 */
enum class EngineEntityGraphicType : Uint8 {
    NotSet,
    /** Note: All graphic sets are expected to contain the South Idle graphic. */
    Idle,
    Run,
    Crouch,
    Jump,
    PROJECT_START
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/EngineEntityInteractionType.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/**
 * The types of entity interactions that the engine provides.
 *
 * Note: Don't use this enum directly, use EntityInteractionType (it combines
 *       the engine's and the project's interactions).
 */
enum class EngineEntityInteractionType : Uint8 {
    NotSet,
    Talk,

    // We reserve values 0 - 49. The project can start at 50.
    PROJECT_START = 50
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/EngineItemInteractionType.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/**
 * The types of item interactions that the engine provides.
 *
 * Note: Don't use this enum directly, use ItemInteractionType (it combines the
 *       engine's and the project's interactions).
 */
enum class EngineItemInteractionType : Uint8 {
    NotSet,

    // Note: All items support Examine, Destroy (handled by
    //       InventoryDeleteItem), and UseOn (handled by CombineItems and 
    //       UseItemOnEntityRequest).
    UseOn,
    Destroy,
    Examine,

    // We reserve values 0 - 49. The project can start at 50.
    PROJECT_START = 50
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/EntityLocator.h`:

```h
#pragma once

#include "CellExtent.h"
#include "CellPosition.h"
#include "TileExtent.h"
#include "ChunkExtent.h"
#include "entt/fwd.hpp"
#include <vector>
#include <unordered_map>

namespace AM
{
struct Position;
struct Cylinder;
struct BoundingBox;

/**
 * A spatial partitioning grid that tracks where entities are located.
 *
 * Used to quickly determine which entities are located within a given extent
 * of the world.
 *
 * This locator only tracks entities, and it tracks them by their Position 
 * component. This is commonly used for networking-related queries (e.g. find all
 * entities that are within a given AoI, so we can send them network updates).
 * All entities have a Position, so they will be tracked by this locator.
 * For Collision-related queries for both entities and tile layers, see 
 * CollisionLocator.h.
 *
 * Internally, entities are organized into "cells", each of which has a size
 * corresponding to SharedConfig::ENTITY_LOCATOR_CELL_WIDTH/HEIGHT. These values
 * can be tweaked to affect performance.
 */
class EntityLocator
{
public:
    EntityLocator(entt::registry& inRegistry);

    /**
     * Sets this locator's internal grid size to match the given extent.
     */
    void setGridSize(const TileExtent& tileExtent);

    /**
     * Adds the given entity to this locator at the given position, or updates 
     * it if it's already added.
     *
     * @return true if successful, else false (position outside of locator 
     *         bounds).
     */
    bool updateEntity(entt::entity entity, const Position& position);

    /**
     * Removes the given entity from this locator, if present.
     */
    void removeEntity(entt::entity entity);

    /**
     * Returns all entities whose positions intersect the given cylinder.
     *
     * Note: Because this uses position, it exhibits the commutative property
     *       (if a cylinder centered on entityA returns entityB, the reverse
     *       will also be true).
     */
    std::vector<entt::entity>& getEntities(const Cylinder& cylinder);

    /**
     * Overload for TileExtent.
     */
    std::vector<entt::entity>& getEntities(const TileExtent& tileExtent);

    /**
     * Overload for ChunkExtent.
     */
    std::vector<entt::entity>& getEntities(const ChunkExtent& chunkExtent);

    /**
     * Performs a broad phase to get all entities in cells intersected by
     * the given cylinder.
     *
     * Note: All entities in the intersected cells are returned, which may
     *       include entities that aren't actually within the radius.
     */
    std::vector<entt::entity>& getEntitiesBroad(const Cylinder& cylinder);

    /**
     * Overload for BoundingBox.
     */
    std::vector<entt::entity>&
        getEntitiesBroad(const BoundingBox& boundingBox);

    /**
     * Overload for TileExtent.
     */
    std::vector<entt::entity>& getEntitiesBroad(const TileExtent& tileExtent);

    /**
     * Overload for ChunkExtent.
     */
    std::vector<entt::entity>&
        getEntitiesBroad(const ChunkExtent& chunkExtent);

private:
    /** The width of a grid cell in world units. */
    static constexpr float CELL_WORLD_WIDTH{
        SharedConfig::ENTITY_LOCATOR_CELL_WIDTH
        * SharedConfig::TILE_WORLD_WIDTH};

    /** The height of a grid cell in world units. */
    static constexpr float CELL_WORLD_HEIGHT{
        SharedConfig::ENTITY_LOCATOR_CELL_HEIGHT
        * SharedConfig::TILE_WORLD_HEIGHT};

    /**
     * Removes the given entity from the given cell.
     *
     * Note: This leaves the entity's ID in the entityMap. Only the tracked
     *       location is cleared out.
     */
    void clearEntityFromCell(entt::entity entity,
                             const CellPosition& clearPosition);

    /**
     * Returns the index in the entityGrid vector where the cell with the given
     * coordinates can be found.
     */
    inline std::size_t
        linearizeCellIndex(const CellPosition& cellPosition) const
    {
        // Translate the given position from actual-space to positive-space.
        CellPosition positivePosition{cellPosition.x - gridCellExtent.x,
                                      cellPosition.y - gridCellExtent.y,
                                      cellPosition.z - gridCellExtent.z};

        return static_cast<std::size_t>(
            (gridCellExtent.xLength * gridCellExtent.yLength
             * positivePosition.z)
            + (gridCellExtent.xLength * positivePosition.y)
            + positivePosition.x);
    }

    /** Used for fetching entity positions during narrow phases. */
    entt::registry& registry;

    /** The grid's extent, with cells as the unit. */
    CellExtent gridCellExtent;

    /** The outer vector is a 3D grid stored in row-major order, holding the
        grid's cells.
        Each element in the grid is a vector of entities--the entities that
        currently intersect with that cell. */
    std::vector<std::vector<entt::entity>> entityGrid;

    /** A map of entity ID -> the cell that the entity is located in.
        Used to easily find the entity during removal. */
    std::unordered_map<entt::entity, CellPosition> entityMap;

    /** The vector that we use to return results. */
    std::vector<entt::entity> returnVector;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/EntityMover.h`:

```h
#pragma once

#include "Input.h"
#include "BoundingBox.h"
#include "CollisionLocator.h"
#include "entt/fwd.hpp"

namespace AM
{
class TileMapBase;
class EntityLocator;
struct Position;
struct PreviousPosition;
struct Movement;
struct MovementModifiers;
struct Rotation;
struct Collision;

/**
 * A helper class that manages the logic of moving entities, resolving 
 * collisions, etc.
 * 
 * This is a class instead of a set of free functions to avoid needing to pass 
 * dependencies on every call.
 *
 * Note: Since player movement is predicted on clients, a player colliding with 
 *       a moving NPC is always going to cause mis-predictions and rollback.
 *       To avoid this, we have a blanket rule of "a moving entity (player or 
 *       NPC) will ignore the collision of all movement-enabled entities
 *       (whether they're currently moving or not)".
 */
class EntityMover {
public:
    EntityMover(const entt::registry& inRegistry, const TileMapBase& inTileMap,
                EntityLocator& inEntityLocator,
                CollisionLocator& inCollisionLocator);

    struct MoveEntityParams
    {   
        entt::entity entity;
        const Input::StateArr& inputStates;
        Position& position;
        const PreviousPosition& previousPosition;
        Movement& movement;
        const MovementModifiers& movementMods;
        Rotation& rotation;
        Collision& collision;
        const CollisionBitSets& collisionBitSets;
        double deltaSeconds;
    };
    /**
     * Processes a tick of entity movement, updating the given components 
     * appropriately.
     */
    void moveEntity(const MoveEntityParams& params);

private:
    /**
     * The maximum number of iterations that the narrow phase of collision 
     * resolution should perform.
     */
    static constexpr int NARROW_PHASE_ITERATION_COUNT{3};

    /**
     * Resolves collisions between the given desiredBounds and other nearby
     * bounding boxes in the world.
     *
     * @param currentBounds The bounding box, at its current position.
     * @param movement The entity's movement component.
     * @param collisionMask The entity's collision mask.
     *
     * @return The desired bounding box, moved to resolve collisions.
     */
    BoundingBox resolveCollisions(const BoundingBox& currentBounds,
                                  Movement& movement,
                                  const CollisionLayerBitSet& collisionMask,
                                  double deltaSeconds);

    struct NarrowPhaseResult {
        BoundingBox resolvedBounds{};
        float remainingTime{};
    };
    /**
     * Performs a single iteration of narrow phase collision resolution between 
     * the given bounds and all volumes in broadPhaseMatches.
     */
    NarrowPhaseResult
        narrowPhase(const std::vector<const CollisionLocator::CollisionInfo*>&
                        broadPhaseMatches,
                    const BoundingBox& currentBounds, Movement& movement,
                    double deltaSeconds, float remainingTime);

    const entt::registry& registry;
    const TileMapBase& tileMap;
    EntityLocator& entityLocator;
    CollisionLocator& collisionLocator;
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/EnttObserver.h`:

```h
#pragma once

#include "entt/fwd.hpp"
#include "entt/entity/registry.hpp"

namespace AM
{
/**
 * A reactive storage that can observe changes to a single component type.
 *
 * To bind:
 *   observer.bind(registry);
 *   observer.on_construct<MyComponent>(); // on_update, on_destroy
 *
 * To view:
 *  for (entt::entity entity : observer) {
 *      // (process things here)
 *  }
 *  observer.clear();
 */
using EnttObserver = entt::reactive_mixin<entt::storage<void>>;

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/GraphicData/Animation.h`:

```h
#pragma once

#include "AnimationID.h"
#include "SpriteID.h"
#include "BoundingBox.h"
#include "Vector3.h"
#include <string>
#include <vector>
#include <functional>

namespace AM
{
struct Sprite;

/**
 * Holds the data for a single animation from ResourceData.json.
 *
 * World position should be read from an associated Position component (if
 * this animation is attached to an entity), or derived from an associated Tile.
 */
struct Animation {
    /** Unique display name, shown in the UI.  */
    std::string displayName{"Null"};

    /** The animation's unique string ID. Derived from displayName by replacing
        spaces with underscores and making everything lowercase.
        This ID will be consistent, and can be used for persistent state. */
    std::string stringID{"null"};

    /** This animation's unique numeric identifier.
        This value can be used safely at runtime, but shouldn't be used for
        persistent state since it may change when ResourceData.json is
        modified. */
    AnimationID numericID{NULL_ANIMATION_ID};

    /** How long this animation is, in frames. */
    Uint8 frameCount{0};

    /** This animation's framerate (frames per second). */
    Uint8 fps{0};

    /** When the animation completes, it will loop to this frame and continue 
        playing. If == frameCount, no frames will be looped.
        Must always be <= frameCount. */
    Uint8 loopStartFrame{0};

    struct Frame
    {
        Uint8 frameNumber{0};
        std::reference_wrapper<const Sprite> sprite;
    };
    /** The frames of this animation, ordered by ascending frameNumber.
        Only holds frames that actually contain a sprite.
        Note: There will always be at least 1 frame present. */
    std::vector<Frame> frames;

    /** If true, this animation's modelBounds will be used in collision checks.
        Floors never have collision, regardless of this setting. */
    bool collisionEnabled{false};

    /** This animation's model-space bounding volume.
        Note: Tiles use these bounds, but entities use the bounds defined by 
              their Collision component. */
    BoundingBox modelBounds{};

    /**
     * Returns the sprite that should be displayed at the given animation time.
     * @return nullptr if no sprite should be displayed.
     */
    const Sprite* getSpriteAtTime(double animationTime) const;

    /**
     * Returns the animation's length in seconds.
     */
    double getLengthS() const;

    /**
     * Returns the animation's length in ticks.
     */
    Uint32 getLengthTicks() const;
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/GraphicData/AnimationID.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/** An animation's numeric ID. */
using AnimationID = Uint16;

/**
 * The ID of the "null animation", or the ID used to indicate that an animation 
 * is not present.
 *
 * Note: Since the null ID is 0, you can do null checks like "if (animationID)".
 */
static constexpr AnimationID NULL_ANIMATION_ID{0};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/GraphicData/GraphicDataBase.h`:

```h
#pragma once

#include "Sprite.h"
#include "Animation.h"
#include "GraphicRef.h"
#include "GraphicSets.h"
#include "GraphicID.h"
#include "nlohmann/json_fwd.hpp"
#include <vector>
#include <unordered_map>
#include <string>
#include <string_view>

namespace AM
{

/**
 * Base class for Client::GraphicData and Server::GraphicData.
 * Loads the shared graphics data from ResourceData.json into memory and 
 * provides an interface for accessing it.
 *
 * The data in this class is immutable. To modify it, edit ResourceData.json
 * using the ResourceImporter.
 */
class GraphicDataBase
{
public:
    /**
     * Attempts to parse resourceDataJson and load all of the sprite data.
     *
     * Errors if resourceDataJson doesn't contain a spriteSheets section.
     */
    GraphicDataBase(const nlohmann::json& resourceDataJson);

    /**
     * Returns the sprite with the given string ID.
     * Errors in debug if the given ID doesn't exist, returns the null sprite 
     * in release.
     */
    const Sprite& getSprite(std::string_view stringID) const;

    /**
     * Returns the sprite with the given numeric ID.
     * Errors in debug if the given ID doesn't exist, returns the null sprite 
     * in release.
     */
    const Sprite& getSprite(SpriteID numericID) const;

    /**
     * Returns the animation with the given string ID.
     * Errors in debug if the given ID doesn't exist, returns the null 
     * animation in release.
     */
    const Animation& getAnimation(std::string_view stringID) const;

    /**
     * Returns the animation with the given numeric ID.
     * Errors in debug if the given ID doesn't exist, returns the null 
     * animation in release.
     */
    const Animation& getAnimation(AnimationID numericID) const;

    /**
     * Returns the graphic with the given numeric ID.
     * Errors in debug if the given ID doesn't exist, returns the null 
     * graphic in release.
     */
    GraphicRef getGraphic(GraphicID numericID) const;

    /**
     * Returns the graphic set with the given string ID.
     * Errors in debug if the given ID doesn't exist, returns the null set 
     * in release.
     */
    const TerrainGraphicSet&
        getTerrainGraphicSet(std::string_view stringID) const;
    const FloorGraphicSet& getFloorGraphicSet(std::string_view stringID) const;
    const WallGraphicSet& getWallGraphicSet(std::string_view stringID) const;
    const ObjectGraphicSet&
        getObjectGraphicSet(std::string_view stringID) const;
    const EntityGraphicSet&
        getEntityGraphicSet(std::string_view stringID) const;

    /**
     * Returns the sprite set with the given numeric ID.
     * Errors if the given ID doesn't exist, returns the null set in release.
     */
    const TerrainGraphicSet&
        getTerrainGraphicSet(TerrainGraphicSetID numericID) const;
    const FloorGraphicSet& getFloorGraphicSet(FloorGraphicSetID numericID) const;
    const WallGraphicSet& getWallGraphicSet(WallGraphicSetID numericID) const;
    const ObjectGraphicSet&
        getObjectGraphicSet(ObjectGraphicSetID numericID) const;
    const EntityGraphicSet&
        getEntityGraphicSet(EntityGraphicSetID numericID) const;

    /**
     * Returns a reference to a vector containing all the sprites.
     */
    const std::vector<Sprite>& getAllSprites() const;

    /**
     * Returns a reference to a vector containing all the graphic sets of a
     * particular type.
     */
    const std::vector<TerrainGraphicSet>& getAllTerrainGraphicSets() const;
    const std::vector<FloorGraphicSet>& getAllFloorGraphicSets() const;
    const std::vector<WallGraphicSet>& getAllWallGraphicSets() const;
    const std::vector<ObjectGraphicSet>& getAllObjectGraphicSets() const;
    const std::vector<EntityGraphicSet>& getAllEntityGraphicSets() const;

protected:
    /**
     * Parses the given json, constructing sprites and pushing them into the
     * sprites vector.
     *
     * @param json The json to parse. Must be loaded from a valid
     *             ResourceData.json.
     */
    void parseJson(const nlohmann::json& json);

    /**
     * Resizes the vectors to fit the graphics and graphic sets in the given 
     * json.
     */
    void resizeVectors(const nlohmann::json& json);

    /**
     * Parses the given sprite json and adds the resulting sprite to the
     * sprites vector.

     * @param spriteJson The json to parse. Must be a valid sprite section
     *                   from ResourceData.json.
     */
    void parseSprite(const nlohmann::json& spriteJson);

    /**
     * Parses the given animation json and adds the resulting animation to the
     * animations vector.

     * @param animationJson The json to parse. Must be a valid animation section
     *                      from ResourceData.json.
     */
    void parseAnimation(const nlohmann::json& animationJson);

    /**
     * Parses the given graphic set json and adds the resulting graphic set to
     * the appropriate vector.
     *
     * @param graphicSetJson The json to parse. Must be a valid graphic set
     *                       section from ResourceData.json, for the appropriate
     *                       set type.
     */
    void parseTerrainGraphicSet(const nlohmann::json& graphicSetJson);
    void parseFloorGraphicSet(const nlohmann::json& graphicSetJson);
    void parseWallGraphicSet(const nlohmann::json& graphicSetJson);
    void parseObjectGraphicSet(const nlohmann::json& graphicSetJson);
    void parseEntityGraphicSet(const nlohmann::json& graphicSetJson);

    /** The loaded sprites, indexed by their numeric IDs. */
    std::vector<Sprite> sprites;

    /** The loaded animations, indexed by their numeric IDs. */
    std::vector<Animation> animations;

    /** The loaded graphic sets of each type. These are indexed by the set
        type's numeric IDs. (Each sprite set type has a unique ID space.) */
    std::vector<TerrainGraphicSet> terrainGraphicSets;
    std::vector<FloorGraphicSet> floorGraphicSets;
    std::vector<WallGraphicSet> wallGraphicSets;
    std::vector<ObjectGraphicSet> objectGraphicSets;
    std::vector<EntityGraphicSet> entityGraphicSets;

    /** A map for easily looking up sprites by their string ID. */
    std::unordered_map<std::string, const Sprite*> spriteStringMap;

    /** A map for easily looking up animations by their string ID. */
    std::unordered_map<std::string, const Animation*> animationStringMap;

    /** Maps for easily looking up graphic sets by their string ID. */
    std::unordered_map<std::string, const TerrainGraphicSet*>
        terrainGraphicSetStringMap;
    std::unordered_map<std::string, const FloorGraphicSet*>
        floorGraphicSetStringMap;
    std::unordered_map<std::string, const WallGraphicSet*>
        wallGraphicSetStringMap;
    std::unordered_map<std::string, const ObjectGraphicSet*>
        objectGraphicSetStringMap;
    std::unordered_map<std::string, const EntityGraphicSet*>
        entityGraphicSetStringMap;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/GraphicData/GraphicID.h`:

```h
#pragma once

#include "SpriteID.h"
#include "AnimationID.h"
#include <SDL_stdinc.h>

namespace AM
{

/** A graphic's numeric ID.
    The top bit is the graphic's type. 0 == Sprite, 1 == Animation.
    The bottom 31 bits are the Sprite or Animation's ID. */
using GraphicID = Uint32;

/** The mask to use when getting a graphic ID's type. */
static constexpr Uint32 GRAPHIC_ID_TYPE_MASK{0x80000000};

/** The mask to use when getting a graphic ID's value. */
static constexpr Uint32 GRAPHIC_ID_VALUE_MASK{0x7FFFFFFF};

/** The value used to indicate that this graphic ID holds an animation. */
static constexpr Uint32 GRAPHIC_ID_ANIMATION_VALUE{0x80000000};

/**
 * Returns true if the given graphic ID is for a sprite. Else, returns false.
 */
bool isSpriteID(GraphicID graphicID);

/**
 * Returns true if the given graphic ID is for an animation. Else, returns false.
 */
bool isAnimationID(GraphicID graphicID);

/**
 * Converts the given graphic ID into a sprite ID.
 */
SpriteID toSpriteID(GraphicID graphicID);

/**
 * Converts the given graphic ID into a animation ID.
 */
AnimationID toAnimationID(GraphicID graphicID);

/**
 * Converts the given sprite ID into a graphic ID.
 */
GraphicID toGraphicID(SpriteID spriteID);

/**
 * Converts the given animation ID into a graphic ID.
 */
GraphicID toGraphicID(AnimationID animationID);

/**
 * The ID of the "null graphic", or the ID used to indicate that a graphic 
 * is not present.
 *
 * Note: Since the null ID is 0, you can do null checks like "if (graphicID)".
 */
static constexpr GraphicID NULL_GRAPHIC_ID{0};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/GraphicData/GraphicRef.h`:

```h
#pragma once

#include "Sprite.h"
#include "Animation.h"
#include "GraphicID.h"
#include <variant>

namespace AM
{
/**
 * Holds a reference to either a Sprite or an Animation.
 *
 * Used in situations where both are supported (graphic sets, tiles, entities).
 */
struct GraphicRef : public std::variant<std::reference_wrapper<const Sprite>,
                                        std::reference_wrapper<const Animation>>
{
    /**
     * Returns the graphic ID for the Sprite or Animation that this ref points 
     * to.
     * 
     * The top bit is this graphic's type. 0 == Sprite, 1 == Animation.
     * The bottom 31 bits are the Sprite or Animation's ID.
     */
    GraphicID getGraphicID() const;

    const std::string& getDisplayName() const;

    bool getCollisionEnabled() const;

    const BoundingBox& getModelBounds() const;

    /**
     * If this ref points to a Sprite, returns it.
     * If this ref points to an Animation, returns the first sprite in the 
     * animation.
     */
    const Sprite& getFirstSprite() const;

    /**
     * If this ref points to a Sprite, returns it.
     * If this ref points to an Animation, returns the sprite that should be 
     * displayed at the given animation time.
     * @return nullptr if no sprite should be displayed.
     */
    const Sprite* getSpriteAtTime(double animationTime) const;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/GraphicData/GraphicSetIDs.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/**
 * A graphic set's numeric ID.
 *
 * These IDs aren't super useful since we cast to Uint16 all the time for 
 * generic code, but they at least give a solid indication that each graphic 
 * set type has its own ID space.
 *
 * If we ever care to, we can replace everywhere we cast to Uint16 with a 
 * variant that contains these types.
 */
using TerrainGraphicSetID = Uint16;
using FloorGraphicSetID = Uint16;
using WallGraphicSetID = Uint16;
using ObjectGraphicSetID = Uint16;
using EntityGraphicSetID = Uint16;

/**
 * The ID of the "null graphic set", or the ID used to indicate that a graphic
 * set is not present.
 *
 * Note: Since the null ID is 0, you can do null checks like "if (graphicSetID)".
 */
static constexpr TerrainGraphicSetID NULL_TERRAIN_GRAPHIC_SET_ID{0};
static constexpr FloorGraphicSetID NULL_FLOOR_GRAPHIC_SET_ID{0};
static constexpr WallGraphicSetID NULL_WALL_GRAPHIC_SET_ID{0};
static constexpr ObjectGraphicSetID NULL_OBJECT_GRAPHIC_SET_ID{0};
static constexpr EntityGraphicSetID NULL_ENTITY_GRAPHIC_SET_ID{0};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/GraphicData/GraphicSets.h`:

```h
#pragma once

#include "GraphicSetIDs.h"
#include "GraphicRef.h"
#include "EntityGraphicType.h"
#include "Terrain.h"
#include "Wall.h"
#include "Rotation.h"
#include <SDL_stdinc.h>
#include <string>
#include <array>
#include <unordered_map>
#include <functional>
#include <optional>

namespace AM
{

/**
 * Base class for a single graphic set from ResourceData.json.
 *
 * Graphic sets are used for grouping graphic into a higher-level concept. A
 * FloorGraphicSet, for example, holds all of the available rotations of a
 * single floor covering, such as a rug.
 *
 * Terrain, Floor, Wall, and Object are only used for tiles.
 * Entity is only used for entities.
 */
struct GraphicSet {
    enum Type : Uint8 {
        Terrain,
        /** Floors are display-only, they have no collision. They're used for
            things like grass, carpets, flooring, etc. */
        Floor,
        Wall,
        Object,
        Entity,
        Count,
        None
    };

    /** Unique display name, shown in the UI.  */
    std::string displayName{"Empty"};

    /** The graphic set's unique string ID. Derived from displayName by
       replacing spaces with underscores and making everything lowercase. This
       ID will be consistent, and can be used for persistent state. */
    std::string stringID{"empty"};

    /** This graphic set's unique numeric identifier.
        Can be cast to FloorGraphicSetID, etc depending on this set's type.
        Each graphic set type has its own ID space.
        This value can be used safely at runtime, but shouldn't be used for
        persistent state since it may change when ResourceData.json is
        modified. */
    Uint16 numericID{0};
};

struct TerrainGraphicSet : public GraphicSet {
    /** The 4 heights of terrain graphic that we use for our terrain system. */
    std::array<GraphicRef, Terrain::Height::Count> graphics;

    /**
     * Returns the sprite within this set that should be used for thumbnails.
     *
     * This may be a particular sprite (e.g. Idle/South for entity sets), or
     * just the first non-null sprite.
     *
     * May return the null sprite, if the set is empty.
     */
    const Sprite& getThumbnailSprite() const;
};

struct FloorGraphicSet : public GraphicSet {
    /** The number of variations that this graphic set can hold. */
    static constexpr std::size_t VARIATION_COUNT{8};

    /** The 8 variations of this floor covering.
        If any slots weren't assigned a graphic, they will be set to the null
        sprite in this array (check for NULL_GRAPHIC_ID).
        When useful, the graphics in this array can represent the same floor
        covering, facing different directions. In such a case, you can set
        these elements equal to a Rotation::Direction. */
    std::array<GraphicRef, VARIATION_COUNT> graphics;

    /**
     * See TerrainGraphicSet::getThumbnailSprite().
     */
    const Sprite& getThumbnailSprite() const;
};

struct WallGraphicSet : public GraphicSet {
    /** The 4 types of wall graphic that we use for our modular wall system. */
    std::array<GraphicRef, Wall::Type::Count> graphics;

    /**
     * See TerrainGraphicSet::getThumbnailSprite().
     */
    const Sprite& getThumbnailSprite() const;
};

struct ObjectGraphicSet : public GraphicSet {
    /** The number of variations that this graphic set can hold. */
    static constexpr std::size_t VARIATION_COUNT{8};

    /** See FloorCoveringGraphicSet::graphics. */
    std::array<GraphicRef, VARIATION_COUNT> graphics;

    /**
     * See TerrainGraphicSet::getThumbnailSprite().
     */
    const Sprite& getThumbnailSprite() const;
};

struct EntityGraphicSet : public GraphicSet {
    /** The entity graphic types that this set contains.
        Each graphic type is associated with an array of up to 8 graphics, one
        for each possible rotation of the entity.
        The Idle graphic type will always be present. All others are optional.
        If any slots weren't assigned a graphic, they will be set to the null
        sprite in the array (check for NULL_GRAPHIC_ID). */
    std::unordered_map<EntityGraphicType,
                       std::array<GraphicRef, Rotation::Direction::Count>>
        graphics;

    /**
     * Returns the Idle South graphic's model-space collision bounds.
     *
     * We use Idle South's bounds for all collision in order to keep collision
     * behavior consistent.
     */
    BoundingBox getCollisionModelBounds() const;

    /**
     * Returns true if this set contains an array for the given type, and the
     * graphic at the given direction is non-null.
     */
    bool contains(EntityGraphicType type, Rotation::Direction direction) const;

    /**
     * See TerrainGraphicSet::getThumbnailSprite().
     */
    const Sprite& getThumbnailSprite() const;
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/GraphicData/Sprite.h`:

```h
#pragma once

#include "SpriteID.h"
#include "BoundingBox.h"
#include <string>

namespace AM
{
/**
 * Holds the data for a single sprite from ResourceData.json.
 *
 * World position should be read from an associated Position component (if
 * this sprite is attached to an entity), or derived from an associated Tile.
 */
struct Sprite {
    /** Unique display name, shown in the UI.  */
    std::string displayName{"Null"};

    /** The sprite's unique string ID. Derived from displayName by replacing
        spaces with underscores and making everything lowercase.
        This ID will be consistent, and can be used for persistent state. */
    std::string stringID{"null"};

    /** This sprite's unique numeric identifier.
        This value can be used safely at runtime, but shouldn't be used for
        persistent state since it may change when ResourceData.json is
        modified. */
    SpriteID numericID{NULL_SPRITE_ID};

    /** If true, this sprite's modelBounds will be used in collision checks.
        Floors never have collision, regardless of this setting. */
    bool collisionEnabled{false};

    /** This sprite's model-space bounding volume.
        Note: Tiles use these bounds, but entities use the bounds defined by 
              their Collision component. */
    BoundingBox modelBounds{};
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/GraphicData/SpriteID.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/** A sprite's numeric ID. */
using SpriteID = Uint32;

/**
 * The ID of the "null sprite", or the ID used to indicate that a sprite is
 * not present.
 *
 * One example of usage is in graphic sets: if an Object graphic set doesn't
 * implement some rotations, those slots are set to the null sprite.
 *
 * Note: Since the null ID is 0, you can do null checks like "if (spriteID)".
 */
static constexpr SpriteID NULL_SPRITE_ID{0};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/IconData/Icon.h`:

```h
#pragma once

#include "IconID.h"
#include <string>

namespace AM
{
/**
 * Holds the data for a single icon from ResourceData.json.
 */
struct Icon {
    /** Unique display name, shown in the UI.  */
    std::string displayName{"Null"};

    /** The icon's unique string ID. Derived from displayName by replacing
        spaces with underscores and making everything lowercase.
        This ID will be consistent, and can be used for persistent state. */
    std::string stringID{"null"};

    /** This icon's unique numeric identifier.
        This value can be used safely at runtime, but shouldn't be used for
        persistent state since it may change when ResourceData.json is
        modified. */
    IconID numericID{NULL_ICON_ID};
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/IconData/IconDataBase.h`:

```h
#pragma once

#include "Icon.h"
#include "nlohmann/json_fwd.hpp"
#include <vector>
#include <unordered_map>
#include <string_view>
#include <string>

namespace AM
{

/**
 * Base class for Client::IconData and Server::IconData.
 * Loads the shared icon data from ResourceData.json into memory and provides
 * an interface for accessing it.
 *
 * Also adds the "Null" icon, for use as a default.
 *
 * The data in this class is immutable. To modify it, edit ResourceData.json
 * using the ResourceImporter.
 */
class IconDataBase
{
public:
    /**
     * Attempts to parse resourceDataJson and load all of the icon data.
     *
     * Errors if resourceDataJson doesn't contain an iconSheets section.
     */
    IconDataBase(const nlohmann::json& resourceDataJson);

    /**
     * Returns the icon with the given string ID.
     * Errors if the given ID doesn't exist.
     */
    const Icon& getIcon(std::string_view stringID) const;

    /**
     * Returns the icon with the given numeric ID.
     * Errors if the given ID doesn't exist.
     */
    const Icon& getIcon(IconID numericID) const;

    /**
     * Returns a reference to a vector containing all the icons.
     */
    const std::vector<Icon>& getAllIcons() const;

private:
    /**
     * Parses the given json, constructing icons and pushing them into the
     * icons vector.
     *
     * @param json  The json to parse. Must be loaded from a valid
     *              ResourceData.json.
     */
    void parseJson(const nlohmann::json& json);

    /**
     * Parses the given icon json and adds the resulting icon to the
     * icons vector.

     * @param iconJson  The json to parse. Must be a valid icon section
     *                    from ResourceData.json.
     */
    void parseIcon(const nlohmann::json& iconJson);

    /** The loaded icons, indexed by their numeric IDs. */
    std::vector<Icon> icons;

    /** A map for easily looking up icons by their string ID. */
    std::unordered_map<std::string, const Icon*> iconStringMap;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/IconData/IconID.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/** An icon's numeric ID. */
using IconID = Uint16;

/**
 * The ID of the "null icon", or the ID used to indicate that an icon is
 * not present.
 *
 * Note: Since the null ID is 0, you can do null checks like "if (iconID)".
 */
static constexpr IconID NULL_ICON_ID{0};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/ItemData/Item.h`:

```h
#pragma once

#include "SharedConfig.h"
#include "ItemID.h"
#include "IconID.h"
#include "ItemInteractionType.h"
#include "ItemProperty.h"
#include "ItemCombination.h"
#include "Log.h"
#include "bitsery/ext/std_variant.h"
#include <SDL_stdinc.h>
#include <string>
#include <vector>

namespace AM
{
/**
 * A single item's definition.
 *
 * Items have "interactions", and "properties". Interactions define what users 
 * can do with the item, and properties hold data that can be used while 
 * handling interactions.
 * The engine provides some generic interactions and properties, and more can 
 * be defined by the project.
 *
 * Items are typically defined using a Lua "init script". After that, all 
 * logic is handled in C++. We use this pattern because it provides a good 
 * balance between expressiveness, developer effort, and performance.
 *
 * When an interaction occurs, an event will be pushed into a queue. A system 
 * can then use Simulation::popItemInteractionRequest() to handle the 
 * interaction.
 * Built-in interactions like "Examine", "Combine", and "Use" are handled 
 * automatically by the engine, outside of the queue system.
 * When an item is used on an entity, that entity's "item handler" Lua script 
 * will be ran.
 */
struct Item {
    /** The item's display name. Not guaranteed to be unique. Shown in the UI. */
    std::string displayName{"Null"};

    /** The item's unique string ID. This ID will be consistent, and can be 
        used for persistent state. */
    std::string stringID{"null"};

    /** The item's unique numeric identifier.
        This ID will be consistent, and can be used for persistent state. */
    ItemID numericID{NULL_ITEM_ID};

    /** The ID of this item's icon. */
    IconID iconID{NULL_ICON_ID};

    /** How large a stack of this item can be, e.g. in an inventory slot. */
    Uint8 maxStackSize{1};

    /** The item's description text. Used by the Examine interaction. */
    std::string description{};

    /** The custom interactions that this item supports.
        The first interaction in this list is the default interaction.
        Built-in interactions aren't present in this vector, and will instead 
        be added by the UI. */
    std::vector<ItemInteractionType> supportedInteractions{};

    /** The properties that are attached to this item.
        Properties hold data that gets used when handling interactions. */
    std::vector<ItemProperty> properties{};

    /** A list of the items that this item may be combined with, and the
        resulting items.
        Note: If you want to put skill requirements on your item combinations,
              you'll need to build a separate UI/workflow. */
    std::vector<ItemCombination> itemCombinations{};

    /**
     * Adds the given interaction to supportedInteractions.
     * @return true if the interaction was added, else false (already present 
     *         or array was full).
     */
    bool addInteraction(ItemInteractionType newInteraction);

    /**
     * Returns true if this item supports the given interaction.
     */
    bool supportsInteraction(ItemInteractionType desiredInteraction) const;

    /**
     * Returns the list of interactions that this item supports, in the order
     * that they should appear in the UI.
     * The list will start with any interactions from supportedInteractions,
     * followed by UseOn, Destroy, and Examine. Any empty slots will be at the
     * end and equal to NotSet.
     */
    std::vector<ItemInteractionType> getInteractionList() const;

    /**
     * Returns this item's default interaction.
     */
    ItemInteractionType getDefaultInteraction() const;

    /**
     * Returns the number of interactions that this item supports.
     * Note: This must be used because the always-present interactions (UseOn, 
     *       Destroy, Examine) aren't stored in supportedInteractions.
     */
    std::size_t getInteractionCount() const;

    /**
     * Adds the given property to this item.
     * If the property already exists, updates the value.
     *
     * @return false if this item's properties vector is full, else true.
     */
    template<typename T>
    bool addProperty(const T& newProperty)
    {
        // If this item already has the given property, just replace the value.
        for (ItemProperty& property : properties) {
            if (std::holds_alternative<T>(property)) {
                property = newProperty;
                return true;
            }
        }

        // New property, add it.
        if (properties.size() < MAX_PROPERTIES) {
            properties.emplace_back(newProperty);
            return true;
        }
        else {
            LOG_ERROR("Tried to add property to full item.");
            return false;
        }
    }

    /**
     * If this item contains a property of the given type, returns it.
     * Else, returns nullptr.
     */
    template<typename T>
    const T* getProperty() const
    {
        // Note: We use a vector and iterate through it every time because
        //       it reduces wire size (vs a map) and we expect each item to
        //       only have a few properties.

        // If this item contains the given property type, return it.
        for (const ItemProperty& property : properties) {
            if (const T* ptr{std::get_if<T>(&property)}) {
                return ptr;
            }
        }

        return nullptr;
    }

    /** The max length of a display name. */
    static constexpr std::size_t MAX_DISPLAY_NAME_LENGTH{50};

    /** The max length of a string ID. */
    static constexpr std::size_t MAX_STRING_ID_LENGTH{20};

    /** The max length of an item's description text. */
    static constexpr std::size_t MAX_DESCRIPTION_LENGTH{500};

    /** The number of built-in interactions that every item supports: UseOn,
        Destroy, and Examine. */
    static constexpr std::size_t BUILTIN_INTERACTION_COUNT{3};

    /** The total number of interactions that an item can support, including
        the built-ins. */
    static constexpr std::size_t MAX_INTERACTIONS{
        SharedConfig::MAX_ITEM_CUSTOM_INTERACTIONS + BUILTIN_INTERACTION_COUNT};

    /** The maximum number of properties that an item can support. */
    static constexpr std::size_t MAX_PROPERTIES{50};

    /** The maximum number of combinations that an item can support. */
    static constexpr std::size_t MAX_COMBINATIONS{50};
};

template<typename S>
void serialize(S& serializer, Item& item)
{
    // Note: We only serialize items for persistance. For replication, we use 
    //       ItemUpdate.

    serializer.text1b(item.displayName, Item::MAX_DISPLAY_NAME_LENGTH);
    serializer.text1b(item.stringID, Item::MAX_STRING_ID_LENGTH);
    serializer.value2b(item.numericID);
    serializer.value2b(item.iconID);
    serializer.value1b(item.maxStackSize);
    serializer.text1b(item.description, Item::MAX_DESCRIPTION_LENGTH);
    serializer.container1b(item.supportedInteractions,
                           SharedConfig::MAX_ITEM_CUSTOM_INTERACTIONS);
    serializer.container(item.properties, Item::MAX_PROPERTIES,
                         [](S& serializer, ItemProperty& property) {
                             // Note: This calls serialize() for each type.
                             serializer.ext(property,
                                            bitsery::ext::StdVariant{});
                         });
    serializer.container(item.itemCombinations, Item::MAX_COMBINATIONS);
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/ItemData/ItemCombination.h`:

```h
#pragma once

#include "ItemID.h"
#include <string>

namespace AM
{

/**
 * Defines a combination between two items.
 *
 * Occurs when a user "Use"s an item, then selects a target item.
 */
struct ItemCombination {
    /** The max length of the description text. */
    static constexpr std::size_t MAX_DESCRIPTION_LENGTH{500};

    /** The item to combine with. */
    ItemID otherItemID{NULL_ITEM_ID};

    /** The resulting item. */
    ItemID resultItemID{NULL_ITEM_ID};

    /** The descriptive text to send to the client when this combination
        succeeds. */
    std::string description{};
};

template<typename S>
void serialize(S& serializer, ItemCombination& itemCombination)
{
    serializer.value2b(itemCombination.otherItemID);
    serializer.value2b(itemCombination.resultItemID);
    serializer.text1b(itemCombination.description,
                      ItemCombination::MAX_DESCRIPTION_LENGTH);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/ItemData/ItemDataBase.h`:

```h
#pragma once

#include "Item.h"
#include "ItemInitScript.h"
#include "HashTools.h"
#include "entt/signal/sigh.hpp"
#include <SDL_stdinc.h>
#include <vector>
#include <unordered_map>
#include <string>
#include <string_view>

namespace AM
{

/**
 * Base class for Client::ItemData and Server::ItemData.
 * Holds item data.
 *
 * You can think of the items in this class as "templates". To actually place
 * them in the world, you must copy one of these templates into something like
 * an entity's Inventory.
 *
 * Also adds the "Null" item. The null item can't be overwritten or edited, but
 * it can be accessed through getItem() to get a default item to use.
 *
 * Note: Once created, items can't be deleted. You can, however, repurpose an
 *       ID by updating that item's definition.
 */
class ItemDataBase
{
public:
    /**
     * Requests the item data from the database.
     */
    ItemDataBase();

    virtual ~ItemDataBase() = default;

    /**
     * Creates a new item or updates an existing one. The resulting item will 
     * exactly match referenceItem, with a version matching the given version.
     *
     * Note: Unlike createItem() and updateItem(), this copies referenceItem's 
     *       IDs and version number with no modification. Only use this when 
     *       loading from the database/cache, or when a client is loading a 
     *       server-given item definition.
     * 
     * @param referenceItem The item to copy when creating the new item.
     * @param version The item's current version number.
     * @return The new item.
     */
    const Item* loadItem(const Item& referenceItem, ItemVersion version);

    /**
     * @return If no item with the given ID exists, returns nullptr. Else,
     *         returns the requested item.
     * Note: The null item doesn't technically exist, but we return a useful
     *       default for it.
     */
    const Item* getItem(std::string_view stringID) const;

    /**
     * @return If no item with the given ID exists, returns nullptr. Else,
     *         returns the requested item.
     * Note: The null item doesn't technically exist, but we return a useful
     *       default for it.
     */
    const Item* getItem(ItemID numericID) const;

    /**
     * Returns an item's version number.
     * Version numbers increase incrementally each time an item's definition
     * is changed.
     *
     * @return If no item with the given ID exists, returns 0. Else, returns
     *         the item's version number.
     */
    ItemVersion getItemVersion(ItemID numericID) const;

    /**
     * Returns a reference to the map containing all the items.
     */
    const std::unordered_map<ItemID, Item>& getAllItems() const;

protected:
    // Note: We use unordered_map instead of vector for items/itemVersions
    //       so that we don't have to allocate/copy the whole vector when
    //       a new item is added.
    /** The loaded items, indexed by their numeric IDs. */
    std::unordered_map<ItemID, Item> itemMap;

    /** A map for easily looking up items by their string ID. */
    std::unordered_map<std::string, Item*, string_hash, std::equal_to<>>
        itemStringMap;

    /** Each item's version number, indexed by their numeric IDs. Each time an
        item's definition is changed, its version gets incremented.
        Note: We split this from the Item class because it's often used
              separately (e.g. sending ID + version for Inventory). */
    std::unordered_map<ItemID, ItemVersion> itemVersionMap;

    /** Tracks the next numeric item ID to use (typically 1 greater than the
        highest ID in our maps). */
    ItemID nextItemID{};

    entt::sigh<void(ItemID)> itemCreatedSig;
    entt::sigh<void(ItemID)> itemUpdatedSig;

public:
    /** An item has been created. */
    entt::sink<entt::sigh<void(ItemID)>> itemCreated;

    /** An item has been updated. */
    entt::sink<entt::sigh<void(ItemID)>> itemUpdated;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/ItemData/ItemID.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{

/** An item's numeric ID.
    Note: Once created, items can't be deleted. You can, however, repurpose an
          ID by updating that item's definition. */
using ItemID = Uint16;

/**
 * The ID of the "null item", or the ID used to indicate that an item is
 * not present.
 *
 * Note: Since the null ID is 0, you can do null checks like "if (itemID)".
 */
static constexpr ItemID NULL_ITEM_ID{0};

/** An item's version.
    Each time an item's definition is changed, its version gets incremented.
    Used by clients to tell if they have the latest item definition, or if they
    need to request it.*/
using ItemVersion = Uint16;

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/ItemData/ItemInitScript.h`:

```h
#pragma once

#include <string>

namespace AM
{
/**
 * An item's initialization script. Init scripts allow builders to customize
 * an item by adding properties and interactions to it.
 *
 * Init scripts are stored on the server. When a client wants to edit an item,
 * we send them that item's script so they don't have to start from scratch.
 * When a client sends an updated init script for an item, we:
 *   1. Reset the item to a default state.
 *   2. Run the new init script on it.
 */
struct ItemInitScript {
    /** Used as a "we should never hit this" cap on the length of the script
        string. */
    static constexpr std::size_t MAX_LENGTH{10000};

    /** The initialization script. */
    std::string script{};
};

template<typename S>
void serialize(S& serializer, ItemInitScript& initScript)
{
    serializer.text1b(initScript.script, ItemInitScript::MAX_LENGTH);
}

} // namespace AM

```

`Source/SharedLib/Simulation/Public/ItemData/ItemProperty.h`:

```h
#pragma once

#include "ProjectItemPropertyTypes.h"
#include "boost/mp11/list.hpp"
#include "boost/mp11/algorithm.hpp"
#include <variant>

namespace AM
{

/**
 * A variant that holds the proterties that may be attached to an item.
 *
 * Note: Since the engine doesn't have any properties to provide, we can just 
 *       alias the project list. This lets us avoid migration issues without 
 *       having to persist the property lists separately (like we do for 
 *       entity components).
 */
using ItemProperty
    = boost::mp11::mp_rename<ProjectItemPropertyTypes, std::variant>;

// Since all members of a variant are the size of the largest member, we enforce
// a size constraint.
static_assert(sizeof(ItemProperty) <= 64,
              "An item property struct is too large. Please reduce its size to "
              "<= 64B or allocate its fields dynamically.");

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/MovementHelpers.h`:

```h
#pragma once

#include "Input.h"
#include "Position.h"
#include "Vector3.h"
#include "Rotation.h"
#include "SharedConfig.h"

namespace AM
{
struct Position;
struct PreviousPosition;
struct Movement;
struct MovementModifiers;
struct Collision;
class TileMapBase;
class EntityLocator;

/**
 * Shared static functions for moving entities.
 */
class MovementHelpers
{
public:
    /**
     * Calculates an updated velocity based on the given data.

     * @param inputStates The current input state.
     * @param[out] movement The current movement state (may update velocity 
     *                      and jumpCount).
     * @param movementMods The current movement mod state.
     *
     * @return The updated velocity.
     */
    static Vector3 calcVelocity(const Input::StateArr& inputStates,
                                Movement& movement,
                                const MovementModifiers& movementMods);

    /**
     * Calculates an updated position based on the given data.
     *
     * @param position The current position.
     * @param velocity The current velocity.
     * @param deltaSeconds The number of seconds that have passed since the
     *                     last update.
     *
     * @return The updated position.
     */
    static Position calcPosition(const Position& position,
                                 const Vector3& velocity, double deltaSeconds);

    /**
     * Calculates a rotation based on the given input state.
     * If there are no inputs or they cancel out, the given rotation will be
     * returned.
     *
     * @param rotation The current rotation.
     * @param inputStates The current input state.
     */
    static Rotation calcRotation(const Rotation& rotation,
                                 const Input::StateArr& inputStates);

    /**
     * Returns a position interpolated between previousPos and position.
     */
    static Position interpolatePosition(const PreviousPosition& previousPos,
                                        const Position& position, double alpha);

    /** An epsilon that can be used when comparing float world positions to 
        integer values, to account for float precision loss.
        Calculated by finding the float precision at the furthest position of 
        the largest map that we support.
        Reference: https://blog.demofox.org/2017/11/21/floating-point-precision/
        Note: The division by 2 is because we center the map on the origin. */
    static constexpr float MAX_WORLD_VALUE{SharedConfig::MAX_MAP_WIDTH_TILES
                                           * SharedConfig::TILE_WORLD_WIDTH
                                           / 2.f};
    static constexpr float WORLD_EPSILON{MAX_WORLD_VALUE
                                         / static_cast<float>(1 << 23)};

private:
    /**
     * Returns the appropriate direction for the given direction int.
     * @param directionInt An integer representation of a direction, derived
     *                     from the formula (3 * (yDown - yUp) + xUp - xDown).
     */
    static Rotation::Direction directionIntToDirection(int directionInt);

    /**
     * Performs the first step of velocity calculations, assuming the entity 
     * can fly.
     */
    static Vector3 calcVelocityCanFly(const Input::StateArr& inputStates,
                                      Movement& movement,
                                      const MovementModifiers& movementMods);

    /**
     * Performs the first step of velocity calculations, assuming the entity 
     * cannot fly.
     */
    static Vector3 calcVelocityNoFly(const Input::StateArr& inputStates,
                                     Movement& movement,
                                     const MovementModifiers& movementMods);
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/Ray.h`:

```h
#pragma once

#include "Vector3.h"
#include <array>
#include <cmath>

namespace AM
{
/**
 * Represents a world-space ray.
 *
 * A ray is a single point in space with a direction. It extends infinitely far
 * in that single direction (as opposed to a line, which extends in both
 * directions).
 */
struct Ray {
    /** Origin point. */
    Vector3 origin{};

    /** Direction vector. */
    Vector3 direction{};

    /**
     * Returns the point along this ray at the given t.
     */
    Vector3 getPointAtT(float t);

    /**
     * Prints this ray's current values.
     */
    void print() const;
};

} // namespace AM

```

`Source/SharedLib/Simulation/Public/ReplicatedComponent.h`:

```h
#pragma once

#include "EngineReplicatedComponentTypes.h"
#include "ProjectReplicatedComponentTypes.h"
#include "boost/mp11/list.hpp"
#include "boost/mp11/algorithm.hpp"
#include <variant>

namespace AM
{

/**
 * See comment in EngineReplicatedComponentTypes.h
 */
using ReplicatedComponentTypes
    = boost::mp11::mp_append<EngineReplicatedComponentTypes,
                             ProjectReplicatedComponentTypes>;
// Note: This limit is only to prevent data sizes from getting larger. If we 
//       let there be more than 256 components, every component's index would 
//       start taking 2B instead of 1B.
static_assert(boost::mp11::mp_size<ReplicatedComponentTypes>::value
                  <= (SDL_MAX_UINT8 + 1),
              "Too many types in ReplicatedComponentTypes. Max is 256.");

/**
 * A variant that holds a client-relevant component.
 *
 * Used by the server to send components to the client (so it can replicate
 * them).
 */
using ReplicatedComponent
    = boost::mp11::mp_rename<ReplicatedComponentTypes, std::variant>;

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/ResourceData.h`:

```h
#pragma once

#include <memory>
#include "nlohmann/json_fwd.hpp"

namespace AM
{

/**
 * Parses ResourceData.json into an in-memory object so we can pass it to
 * GraphicData, IconData, etc.
 *
 * Note: This class expects a ResourceData.json file to be present in the same
 *       directory as the application executable.
 */
class ResourceData
{
public:
    /**
     * Parses ResourceData.json. Errors if it fails to parse.
     */
    ResourceData();

    ~ResourceData();

    /**
     * Returns the parsed json object.
     */
    nlohmann::json& get();

private:
    // Note: We use a pointer so we can forward declare.
    std::unique_ptr<nlohmann::json> resourceDataJson;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/CellExtent.h`:

```h
#pragma once

#include "DiscreteExtent.h"

namespace AM
{
struct TileExtent;
struct BoundingBox;
struct Cylinder;

/**
 * A strong type alias, describing an extent of spatial partitioning grid
 * cells.
 */
struct CellExtent : public DiscreteExtent<DiscreteImpl::CellTag> {
    CellExtent();

    CellExtent(int inX, int inY, int inZ, int inXLength, int inYLength,
               int inZLength);

    CellExtent(const DiscreteExtent<DiscreteImpl::CellTag>& cellExtent);

    /**
     * Constructs the smallest cell extent that contains the given tile extent.
     *
     * @param cellWidthTiles The width of a cell, in tiles.
     * @param cellHeightTiles The height of a cell, in tiles.
     */
    explicit CellExtent(const TileExtent& tileExtent,
                        std::size_t cellWidthTiles,
                        std::size_t cellHeightTiles);

    /**
     * Constructs the smallest cell extent that contains the given bounding box.
     *
     * @param cellWidth The width of a cell, in world units.
     * @param cellHeight The height of a cell, in world units.
     */
    explicit CellExtent(const BoundingBox& boundingBox, float cellWidth,
                        float cellHeight);

    /**
     * Constructs the smallest cell extent that contains the given cylinder.
     *
     * @param cellWidth The width of a cell, in world units.
     * @param cellHeight The height of a cell, in world units.
     */
    explicit CellExtent(const Cylinder& cylinder, float cellWidth,
                        float cellHeight);

    /**
     * Prints this extent's current values.
     */
    void print() const;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/CellPosition.h`:

```h
#pragma once

#include "DiscretePosition.h"
#include "HashTools.h"

namespace AM
{
struct Vector3;
struct TilePosition;

/**
 * A strong type alias, describing the position of a particular spatial
 * partitioning grid cell.
 */
struct CellPosition : public DiscretePosition<DiscreteImpl::CellTag> {
    CellPosition();

    CellPosition(int inX, int inY, int inZ);

    CellPosition(const DiscretePosition<DiscreteImpl::CellTag>& cellPosition);

    /**
     * Calculates the position of the cell that contains the given point.
     *
     * @param cellWidth The width of a cell, in world units.
     * @param cellHeight The height of a cell, in world units.
     */
    explicit CellPosition(const Vector3& worldPoint, float cellWidth,
                          float cellHeight);

    /**
     * Calculates the position of the cell that contains the given tile 
     * position.
     *
     * @param cellWidthTiles The width of a cell, in tiles.
     * @param cellHeightTiles The height of a cell, in tiles.
     */
    explicit CellPosition(const TilePosition& tilePosition,
                          std::size_t cellWidthTiles,
                          std::size_t cellHeightTiles);

    /**
     * Prints this position's current values.
     */
    void print() const;
};

} // namespace AM

// std::hash() specialization.
namespace std
{
template<>
struct hash<AM::CellPosition> {
    typedef AM::CellPosition argument_type;
    typedef std::size_t result_type;
    result_type operator()(const argument_type& position) const
    {
        std::size_t seed{0};
        AM::hash_combine(seed, position.x);
        AM::hash_combine(seed, position.y);
        AM::hash_combine(seed, position.z);
        return seed;
    }
};
} // namespace std

```

`Source/SharedLib/Simulation/Public/TileMap/Chunk.h`:

```h
#pragma once

#include "Tile.h"
#include "SharedConfig.h"
#include <SDL_stdinc.h>
#include <array>

namespace AM
{
struct Sprite;

/**
 * A 32x32-unit tile in the tile map.
 *
 * A tile consists of layers of sprites, which can be floors, walls, etc.
 *
 * Tiles contain no logic. If something on a tile requires logic, e.g. a tree
 * growing over time, it must have a system act upon it.
 */
class Chunk
{
public:
    /** The number of tiles in the tiles array that are non-empty.
        Used to tell when this chunk is empty and can be deleted. */
    Uint16 tileLayerCount{0};

    /** The tiles that make up this chunk, stored in morton order. */
    std::array<Tile, SharedConfig::CHUNK_TILE_COUNT> tiles{};

    /**
     * Returns the tile at the given tile coordinate offset (with respect to 
     * this chunk's origin).
     */
    Tile& getTile(Uint16 tileOffsetX, Uint16 tileOffsetY);
    const Tile& getTile(Uint16 tileOffsetX, Uint16 tileOffsetY) const;

private:
    /**
     * Returns a morton code for the given x and y.
     * We use morton codes to lay out our tiles in a more cache-friendly way 
     * since we're likely to be accessing neighbors at the same time.
     */
    Uint32 mortonEncode(Uint16 x, Uint16 y) const;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/ChunkExtent.h`:

```h
#pragma once

#include "DiscreteExtent.h"
#include <SDL_stdinc.h>

namespace AM
{
struct TileExtent;

/**
 * A strong type alias, describing an extent of map chunks.
 */
struct ChunkExtent : public DiscreteExtent<DiscreteImpl::ChunkTag> {
    ChunkExtent();

    ChunkExtent(int inX, int inY, int inZ, int inXLength, int inYLength,
                int inZLength);

    ChunkExtent(const DiscreteExtent<DiscreteImpl::ChunkTag>& chunkExtent);

    explicit ChunkExtent(const TileExtent& tileExtent);

    /**
     * Prints this extent's current values.
     */
    void print() const;

    /**
     * Builds a ChunkExtent from the given tile map lengths, centering it 
     * around (0, 0) in the x and y directions, and starting at 0 in the z 
     * direction.
     */
    static ChunkExtent fromMapLengths(Uint16 mapXLengthChunks,
                                      Uint16 mapYLengthChunks,
                                      Uint16 mapZLengthChunks);
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/ChunkPosition.h`:

```h
#pragma once

#include "DiscretePosition.h"
#include "HashTools.h"

namespace AM
{
struct Vector3;
struct TilePosition;

/**
 * A strong type alias, describing the position of a particular map chunk.
 */
struct ChunkPosition : public DiscretePosition<DiscreteImpl::ChunkTag> {
    ChunkPosition();

    ChunkPosition(int inX, int inY, int inZ);

    ChunkPosition(const DiscretePosition<DiscreteImpl::ChunkTag>& chunkPosition);

    /**
     * Calculates the position of the chunk that contains the given point.
     */
    explicit ChunkPosition(const Vector3& worldPoint);

    explicit ChunkPosition(const TilePosition& tilePosition);

    /**
     * Prints this position's current values.
     */
    void print() const;
};

template<typename S>
void serialize(S& serializer, ChunkPosition& chunkPosition)
{
    serializer.value4b(chunkPosition.x);
    serializer.value4b(chunkPosition.y);
    serializer.value4b(chunkPosition.z);
}

} // namespace AM

// std::hash() specialization.
namespace std
{
template<>
struct hash<AM::ChunkPosition> {
    typedef AM::ChunkPosition argument_type;
    typedef std::size_t result_type;
    result_type operator()(const argument_type& position) const
    {
        std::size_t seed{0};
        AM::hash_combine(seed, position.x);
        AM::hash_combine(seed, position.y);
        AM::hash_combine(seed, position.z);
        return seed;
    }
};
} // namespace std

```

`Source/SharedLib/Simulation/Public/TileMap/ChunkSnapshot.h`:

```h
#pragma once

#include "TileLayer.h"
#include "SharedConfig.h"
#include "Log.h"
#include <vector>
#include <array>
#include <string>

namespace AM
{

/**
 * Holds chunk data in a persistable form (palette IDs instead of pointers).
 *
 * Used in saving/loading the tile map.
 */
struct ChunkSnapshot {
    struct PaletteEntry {
        /** The string ID of the graphic set that this entry refers to. */
        std::string graphicSetID{""};

        /** The type of tile layer that this entry represents.
            Each layer type maps directly to a single graphic set type. */
        TileLayer::Type layerType{TileLayer::Type::None};

        /** The layer's graphic value.
            For all types except Terrain, this is simply an index into 
            graphicSet.graphics. For Terrain, this is a bit-packed value.
            For Terrain, cast this to Terrain::Value. For Walls, cast this to 
            Wall::Type. For Floors and Objects, cast this to 
            Rotation::Direction. */
        Uint8 graphicValue{0};
    };

    /** Used as a "we should never hit this" cap on the number of entries in a
        palette. */
    static constexpr std::size_t MAX_PALETTE_ENTRIES{1000};

    /** Used as a "we should never hit this" cap on the size of each ID string
        in the palette. */
    static constexpr std::size_t MAX_ID_LENGTH{50};

    /** Used as a "we should never hit this" cap on the number of tile layers 
        that a single chunk can contain. */
    static constexpr std::size_t MAX_TILE_LAYERS{256 * 10};

    /** Holds an entry for each graphic used in this chunk's tiles. Part of a
        space-saving approach that lets TileSnapshot hold indices into this
        palette instead of directly holding the data. */
    std::vector<PaletteEntry> palette{};

    /** The number of layers that each tile in this chunk has, stored in row-
        major order. */
    std::array<Uint8, SharedConfig::CHUNK_TILE_COUNT> tileLayerCounts{};

    /** This vector's elements are indices into the palette, each index  
        representing a tile layer that is owned by a tile in this chunk.
        These layers are ordered by tile coordinate in morton order, and by 
        the usual bottom-to-top type order within each tile.
        To iterate, use tileLayerCounts to determine how many layers belong to 
        each tile. */
    std::vector<Uint8> tileLayers{};

    /** The tile offset for each Floor and Object tile layer in tileLayers, 
        stored in the order that they'll be encountered while iterating. */
    std::vector<TileOffset> tileOffsets{};

    /**
     * Returns the palette index for the given palette entry info.
     * If the palette doesn't have a matching entry, it will be added.
     */
    std::size_t getPaletteIndex(TileLayer::Type tileLayerType,
                                const std::string& graphicSetID,
                                Uint8 graphicValue)
    {
        // TODO: If this gets to be a performance issue, we can look into
        //       switching palette to a map. Serialization will be more
        //       complicated, though.
        // Check if we already have this ID.
        for (std::size_t i = 0; i < palette.size(); ++i) {
            if ((palette[i].layerType == tileLayerType)
                && (palette[i].graphicSetID == graphicSetID)
                && (palette[i].graphicValue == graphicValue)) {
                // We already have the string, returns its index.
                return i;
            }
        }

        // We didn't have a matching entry, add it.
        if (palette.size() < UINT8_MAX) {
            palette.emplace_back(graphicSetID, tileLayerType, graphicValue);
        }
        else {
            // TODO: If this becomes an issue, either switch to Uint16 or
            //       find some more efficient way to grow the space.
            LOG_ERROR("Ran out of palette slots.");
            return 0;
        }
        return (palette.size() - 1);
    }
};

template<typename S>
void serialize(S& serializer, ChunkSnapshot::PaletteEntry& paletteEntry)
{
    serializer.text1b(paletteEntry.graphicSetID, ChunkSnapshot::MAX_ID_LENGTH);
    serializer.value1b(paletteEntry.layerType);
    serializer.value1b(paletteEntry.graphicValue);
}

template<typename S>
void serialize(S& serializer, ChunkSnapshot& chunkSnapshot)
{
    serializer.container(chunkSnapshot.palette,
                         ChunkSnapshot::MAX_PALETTE_ENTRIES);
    serializer.container1b(chunkSnapshot.tileLayerCounts);
    serializer.container1b(chunkSnapshot.tileLayers,
                           ChunkSnapshot::MAX_TILE_LAYERS);
    serializer.container(chunkSnapshot.tileOffsets,
                         ChunkSnapshot::MAX_TILE_LAYERS);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/Floor.h`:

```h
#pragma once

#include "BoundingBox.h"

namespace AM
{
struct TilePosition;

/**
 * Definitions and helper functions for working with Floor tile layers.
 */
struct Floor {
    /**
     * Returns a bounding volume for a floor, translated to world space and 
     * offset to the given tile coords.
     */
    static BoundingBox calcWorldBounds(const TilePosition& tilePosition);
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/Terrain.h`:

```h
#pragma once

#include "BoundingBox.h"
#include <SDL_stdinc.h>

namespace AM
{
struct TilePosition;

/**
 * Definitions and helper functions for working with Terrain tile layers.
 */
struct Terrain {
    /**
     * A terrain value is made up of 2 parts:
     *   Block Height (4b)
     *     How tall the terrain block is, relative to our tile height.
     *   Start Height (4b)
     *     How high the terrain block should be placed within the tile.
     *
     * The start height field allows us to conserve space. One could imagine 
     * using Terrain::tileOffset instead, but packing it into graphicValue 
     * saves us from sending an extra 3B for every piece of terrain.
     *
     * Note: Terrain must never extend beyond the bounds of its tile.
     */
    using Value = Uint8;

    /**
     * A Z-axis height value, relative to SharedConfig::TILE_WORLD_HEIGHT.
     *
     * Since we only have one terrain shape, this is enough information to 
     * describe which graphic to use for a given piece of terrain.
     *
     * Note: When a tile's terrain height changes, all of the other tile 
     *       layers are adjusted to match. This keeps walls, floors, etc from 
     *       getting trapped under the new terrain geometry, but anything that  
     *       was meant to stay the same must be manually re-adjusted.
     */
    enum Height : Uint8 {
        Flat,
        OneThird,
        TwoThird,
        Full,
        Count
    };

    /** Bitmask for getting the height of the terrain. */
    static constexpr Uint8 HEIGHT_MASK{0b11110000};
    /** Bitmask for getting the starting height of the terrain. */
    static constexpr Uint8 START_HEIGHT_MASK{0b00001111};

    /** The maximum value that height + startHeight can equal.
        Any higher value would push the terrain above the tile bounds. */
    static constexpr Uint8 MAX_COMBINED_HEIGHT{4};

    /**
     * Returns the height field from the given terrain value.
     */
    static Height getHeight(Value value);

    /**
     * Returns the start height field from the given terrain value.
     */
    static Height getStartHeight(Value value);

    /**
     * Returns the height of the top face of the given terrain value.
     * This is equal to height + start height.
     */
    static Height getTotalHeight(Value value);

    struct InfoReturn
    {
        /** The terrain's height. */
        Height height{};
        /** The terrain's starting height. */
        Height startHeight{};
    };
    /**
     * Returns the separate terrain info fields that are bitpacked in the 
     * given value.
     */
    static InfoReturn getInfo(Value value);

    /**
     * Builds a Value out of the given terrain height and start height.
     */
    static Value toValue(Height height, Height startHeight);

    /**
     * Returns the given height value in Z-axis world units.
     */
    static float getHeightWorldValue(Height height);

    /**
     * Returns a bounding volume matching the given terrain value, translated to
     * world space and offset to the given tile coords.
     */
    static BoundingBox calcWorldBounds(const TilePosition& tilePosition,
                                       Value value);
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/Tile.h`:

```h
#pragma once

#include "BoundingBox.h"
#include "TileLayer.h"
#include "TilePosition.h"
#include <vector>
#include <span>

namespace AM
{
struct Sprite;

/**
 * A tile in the tile map.
 *
 * Tiles consist of layers of sprites, which can be floors, walls, etc.
 *
 * Tiles contain no logic. If something on a tile requires logic, e.g. a tree
 * growing over time, it must have a system act upon it.
 *
 * Tiles can have the following layer counts:
 *   1 floor
 *   Any number of floor coverings
 *   2 walls
 *   Any number of objects
 * All layers are optional and may not be present in a given tile.
 */
class Tile
{
public:
    /**
     * Adds the given layer to this tile.
     */
    void addLayer(const TileOffset& tileOffset, TileLayer::Type layerType,
                  const GraphicSet& graphicSet, Uint8 graphicValue);

    /**
     * Removes any layers with a matching offset, type, graphic index, and
     * graphic set.
     *
     * @return true if the tile had any matching layers to remove, else false.
     */
    std::size_t removeLayers(const TileOffset& tileOffset,
                             TileLayer::Type layerType, Uint16 graphicSetID,
                             Uint8 graphicValue);

    /**
     * Removes any layers with a matching type, graphic index, and graphic set.
     *
     * @return true if the tile had any matching layers to remove, else false.
     */
    std::size_t removeLayers(TileLayer::Type layerType, Uint16 graphicSetID,
                             Uint8 graphicValue);

    /**
     * Removes any layers with a matching type and graphic index, regardless 
     * of their graphic set or offset.
     *
     * @return The number of matching layers that were removed.
     */
    std::size_t removeLayers(TileLayer::Type layerType, Uint8 graphicValue);

    /**
     * Clears all layers of the given types from this tile.
     *
     * @return The number of matching layers that were cleared.
     */
    std::size_t clearLayers(
        const std::array<bool, TileLayer::Type::Count>& layerTypesToRemove);

    /**
     * Clears all of this tile's layers.
     *
     * @return The number of layers that were cleared.
     */
    std::size_t clear();

    /**
     * @return This tile's layers of the given type, if it has any.
     * Note: This span will be invalidated if you add, remove, or clear any 
     *       of this tile's layers.
     */
    std::span<TileLayer> getLayers(TileLayer::Type layerType);
    std::span<const TileLayer> getLayers(TileLayer::Type layerType) const;

    /**
     * @return All of this tile's layers.
     */
    std::vector<TileLayer>& getAllLayers();
    const std::vector<TileLayer>& getAllLayers() const;

    /**
     * Returns a pointer to the first matching layer in this tile. If one isn't 
     * found, returns nullptr.
     */
    TileLayer* findLayer(TileLayer::Type layerType, Uint8 graphicValue);
    const TileLayer* findLayer(TileLayer::Type layerType,
                               Uint8 graphicValue) const;
    TileLayer* findLayer(TileLayer::Type layerType);
    const TileLayer* findLayer(TileLayer::Type layerType) const;

    /** Returns true if this tile has no layers, else false. */
    bool isEmpty() const;

private:
    // TODO: Maybe eventually switch to an alternative vector type that
    //       has a smaller footprint but only supports forward iterators.
    /** The graphic layers that are on this tile, sorted by their 
        TileLayer::Type in increasing order. */
    std::vector<TileLayer> layers{};
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/TileExtent.h`:

```h
#pragma once

#include "DiscreteExtent.h"

namespace AM
{
struct ChunkExtent;
struct CellExtent;
struct BoundingBox;
struct Cylinder;
struct Vector3;

/**
 * A strong type alias, describing an extent of map tiles.
 */
struct TileExtent : public DiscreteExtent<DiscreteImpl::TileTag> {
    TileExtent();

    TileExtent(int inX, int inY, int inZ, int inXLength, int inYLength,
               int inZLength);

    TileExtent(const DiscreteExtent<DiscreteImpl::TileTag>& tileExtent);

    explicit TileExtent(const ChunkExtent& chunkExtent);

    /**
     * @param cellWidthTiles The width of a cell, in tiles.
     * @param cellHeightTiles The height of a cell, in tiles.
     */
    explicit TileExtent(const CellExtent& cellExtent,
                        std::size_t cellWidthTiles,
                        std::size_t cellHeightTiles);

    /**
     * Constructs the smallest tile extent that contains the given bounding box.
     *
     * If the box is exactly on the edge of a tile, that tile will not be 
     * included in this extent.
     */
    explicit TileExtent(const BoundingBox& boundingBox);

    using DiscreteExtent<DiscreteImpl::TileTag>::contains;
    /**
     * @return true if the given box is fully within this extent, else
     *         false.
     */
    bool contains(const BoundingBox& box) const;

    /**
     * @return true if the given cylinder is fully within this extent, else
     *         false.
     */
    bool contains(const Cylinder& cylinder) const;

    /**
     * @return true if the given world point is within this extent.
     */
    bool contains(const Vector3& point) const;

    /**
     * Prints this extent's current values.
     */
    void print() const;
};

template<typename S>
void serialize(S& serializer, TileExtent& tileExtent)
{
    serializer.value4b(tileExtent.x);
    serializer.value4b(tileExtent.y);
    serializer.value4b(tileExtent.z);
    serializer.value4b(tileExtent.xLength);
    serializer.value4b(tileExtent.yLength);
    serializer.value4b(tileExtent.zLength);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/TileLayer.h`:

```h
#pragma once

#include "GraphicRef.h"
#include "TileOffset.h"
#include <span>
#include <functional>

namespace AM
{

struct GraphicSet;

/**
 * A single graphic layer of a tile.
 */
struct TileLayer {
    /** The types of layers that our tiles support. */
    enum Type : Uint8 {
        Terrain,
        /** Floors are display-only, they have no collision. They're used for 
            things like grass, carpets, flooring, etc. */
        Floor,
        Wall,
        Object,
        Count,
        None
    };

    /** If type == Floor or Object, this is how far this layer is offset from 
        its tile position.
        Note: Terrain and Walls don't use this. Terrain is always aligned to 
              the tile, and Walls always match the Terrain height. */
    TileOffset tileOffset{};

    /** This layer's type.
        This must always be set to a valid type (not None). */
    Type type{};

    /** A value that describes this layer's graphic.
        For all types except Terrain, this is simply an index into 
        graphicSet.graphics. For Terrain, this is a bit-packed value.
        For Terrain, cast this to Terrain::Value. For Walls, cast this to 
        Wall::Type. For Floors and Objects, cast this to Rotation::Direction.
        Note: It'd be more intuitive to put this after graphicSet, but alignment
              would cause this struct to be larger if we did so. */
    Uint8 graphicValue{0};

    /** A polymorphic reference to this layer's graphic set.
        Each layer type maps directly to a single graphic set type, e.g. Floor 
        layers -> FloorGraphicSet. */
    std::reference_wrapper<const GraphicSet> graphicSet;

    /**
     * Casts graphicSet to the appropriate type and returns 
     * graphicSet.graphics[graphicIndex].
     */
    GraphicRef getGraphic() const;
    static GraphicRef getGraphic(Type type, const GraphicSet& graphicSet,
                                 Uint8 graphicValue);
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/TileLayerID.h`:

```h
#pragma once

#include "TilePosition.h"
#include "TileLayer.h"
#include "GraphicSetIDs.h"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * The minimum information needed to uniquely identify a tile layer.
 *
 * Technically, multiple layers may have the same information, but they'll be 
 * exactly the same so differentiation isn't useful.
 */
struct TileLayerID {
    /** The position of the tile that contains the layer. */
    TilePosition tilePosition{};

    /** If type == Floor or Object, this is how far the layer is offset from 
        tilePosition.
        Note: Terrain and Walls don't use this. Terrain is always aligned to 
              the tile, and Walls always match the Terrain height. */
    TileOffset tileOffset{};

    /** The tile layer's type. */
    TileLayer::Type type{TileLayer::Type::None};

    /** The numeric ID of the layer's graphic set. */
    Uint16 graphicSetID{0};

    /** A value that describes this layer's graphic.
        For all types except Terrain, this is simply an index into 
        graphicSet.graphics. For Terrain, this is a bit-packed value.
        For Terrain, cast this to Terrain::Value. For Walls, cast this to 
        Wall::Type. For Floors and Objects, cast this to Rotation::Direction. */
    Uint8 graphicValue{0};

    bool operator==(const TileLayerID& other) const
    {
        return (tilePosition == other.tilePosition)
               && (tileOffset == other.tileOffset) && (type == other.type)
               && (graphicSetID == other.graphicSetID)
               && (graphicValue == other.graphicValue);
    }
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/TileMapBase.h`:

```h
#pragma once

#include "GraphicDataBase.h"
#include "Tile.h"
#include "GraphicSets.h"
#include "Rotation.h"
#include "Wall.h"
#include "Chunk.h"
#include "ChunkExtent.h"
#include "ChunkPosition.h"
#include "TilePosition.h"
#include "TileExtent.h"
#include "TileAddLayer.h"
#include "TileRemoveLayer.h"
#include "TileClearLayers.h"
#include "TileExtentClearLayers.h"
#include "TileLayer.h"
#include "Morton.h"
#include "AMAssert.h"
#include <vector>
#include <unordered_map>
#include <variant>
#include <type_traits>
#include <expected>

namespace AM
{
class CollisionLocator;
struct TileMapSnapshot;
struct ChunkSnapshot;
struct ChunkWireSnapshot;

/**
 * Owns and manages the world's tile map state.
 * Tiles are conceptually organized into 16x16 chunks.
 *
 * Persisted tile map data is loaded from TileMap.bin.
 *
 * When updating tiles, all of the following are handled by this class:
 *   1. If adding layers and the tile's parent chunk doesn't already exist, 
 *      creates it.
 *   2. Updates the tile's layers as requested.
 *   3. Rebuilds the tile's collision if necessary.
 *   4. Updates the parent chunk's nonEmptyTileCount if necessary.
 *   5. If removing layers and the parent chunk is now empty, erases it.
 *   6. Adds an entry to the tile update history, so update messages get sent
 *      to clients.
 */
class TileMapBase
{
public:
    /**
     * Attempts to parse TileMap.bin and construct the tile map.
     *
     * Errors if TileMap.bin doesn't exist or it fails to parse.
     *
     * @param inTrackTileUpdates  If true, tile updates will be pushed into
     *                            tileUpdateHistory.
     */
    TileMapBase(const GraphicDataBase& inGraphicData,
                CollisionLocator& inCollisionLocator, bool inTrackTileUpdates);

    /**
     * Adds the given terrain to the given tile.
     */
    void addTerrain(const TilePosition& tilePosition,
                    const TerrainGraphicSet& graphicSet,
                    Terrain::Value terrainValue);
    void addTerrain(const TilePosition& tilePosition,
                    const std::string& graphicSetID,
                    Terrain::Value terrainValue);
    void addTerrain(const TilePosition& tilePosition, Uint16 graphicSetID,
                    Terrain::Value terrainValue);

    /**
     * Removes the terrain from the given tile.
     * @return true if the tile had terrain to remove, else false.
     */
    bool remTerrain(const TilePosition& tilePosition);

    /**
     * Adds the given floor to the given tile.
     */
    void addFloor(const TilePosition& tilePosition,
                  const TileOffset& tileOffset,
                  const FloorGraphicSet& graphicSet,
                  Rotation::Direction rotation);
    void addFloor(const TilePosition& tilePosition,
                  const TileOffset& tileOffset,
                  const std::string& graphicSetID,
                  Rotation::Direction rotation);
    void addFloor(const TilePosition& tilePosition,
                  const TileOffset& tileOffset, Uint16 graphicSetID,
                  Rotation::Direction rotation);

    /**
     * Removes the given object from the given tile.
     * @return true if the tile had an object to remove, else false.
     */
    bool remFloor(const TilePosition& tilePosition,
                  const TileOffset& tileOffset,
                  const FloorGraphicSet& graphicSet,
                  Rotation::Direction rotation);
    bool remFloor(const TilePosition& tilePosition,
                  const TileOffset& tileOffset, const std::string& graphicSetID,
                  Rotation::Direction rotation);
    bool remFloor(const TilePosition& tilePosition,
                  const TileOffset& tileOffset, Uint16 graphicSetID,
                  Rotation::Direction rotation);

    /**
     * Adds the given wall to the given tile.
     * Note: wallType must be North or West. Gap fills will be added
     *       automatically.
     */
    void addWall(const TilePosition& tilePosition,
                 const WallGraphicSet& graphicSet, Wall::Type wallType);
    void addWall(const TilePosition& tilePosition,
                 const std::string& graphicSetID, Wall::Type wallType);
    void addWall(const TilePosition& tilePosition, Uint16 graphicSetID,
                 Wall::Type wallType);

    /**
     * Removes the given wall from the given tile.
     * Note: wallType must be North or West. Gap fills will be removed
     *       automatically.
     * @return true if the tile had a wall to remove, else false.
     */
    bool remWall(const TilePosition& tilePosition, Wall::Type wallType);

    /**
     * Adds the given object to the given tile.
     */
    void addObject(const TilePosition& tilePosition,
                   const TileOffset& tileOffset,
                   const ObjectGraphicSet& graphicSet,
                   Rotation::Direction rotation);
    void addObject(const TilePosition& tilePosition,
                   const TileOffset& tileOffset,
                   const std::string& graphicSetID,
                   Rotation::Direction rotation);
    void addObject(const TilePosition& tilePosition,
                   const TileOffset& tileOffset, Uint16 graphicSetID,
                   Rotation::Direction rotation);

    /**
     * Removes the given object from the given tile.
     * @return true if the tile had an object to remove, else false.
     */
    bool remObject(const TilePosition& tilePosition,
                   const TileOffset& tileOffset,
                   const ObjectGraphicSet& graphicSet,
                   Rotation::Direction rotation);
    bool remObject(const TilePosition& tilePosition,
                   const TileOffset& tileOffset,
                   const std::string& graphicSetID,
                   Rotation::Direction rotation);
    bool remObject(const TilePosition& tilePosition,
                   const TileOffset& tileOffset, Uint16 graphicSetID,
                   Rotation::Direction rotation);

    /**
     * Clears the given layer types from the given tile.
     *
     * @param layerTypesToClear The layer types to clear.
     * @return true if any layers were cleared. false if the tile was empty.
     */
    bool clearTileLayers(
        const TilePosition& tilePosition,
        const std::initializer_list<TileLayer::Type>& layerTypesToClear);

    /**
     * Override for clearing based on an array of bools. If a given index
     * is true, the associated TileLayer::Type will be cleared.
     * You probably don't want to use this, it's mostly useful for messaging.
     */
    bool clearTileLayers(
        const TilePosition& tilePosition,
        const std::array<bool, TileLayer::Type::Count>& layerTypesToClear);

    /**
     * Clears all layers from the given tile.
     * @return true if any layers were cleared. false if the tile was empty.
     */
    bool clearTile(const TilePosition& tilePosition);

    /**
     * Clears the given layer types from all tiles within the given extent.
     *
     * @param layerTypesToClear The layer types to clear in each tile.
     * @return true if any layers were cleared. false if all tiles were empty.
     */
    bool clearExtentLayers(
        const TileExtent& extent,
        const std::initializer_list<TileLayer::Type>& layerTypesToClear);

    /**
     * Override for clearing based on an array of bools. If a given index
     * is true, the associated TileLayer::Type will be cleared.
     * You probably don't want to use this, it's mostly useful for messaging.
     */
    bool clearExtentLayers(
        const TileExtent& extent,
        const std::array<bool, TileLayer::Type::Count>& layerTypesToClear);

    /**
     * Clears all layers from all tiles within the given extent.
     * @return true if any layers were cleared. false if all tiles were empty.
     */
    bool clearExtent(const TileExtent& extent);

    /**
     * Clears all tile map state, leaving an empty map.
     */
    void clear();

    /**
     * Returns a const pointer to the chunk at the given coordinates, or nullptr 
     * if the chunk doesn't exist (out of bounds, empty).
     * Note: Make sure to nullptr check these! Chunks are commonly empty. 
     */
    const Chunk* getChunk(const ChunkPosition& chunkPosition) const;
    /** This lets us call getChunk on a non-const TileMap& without casting. */
    const Chunk* cgetChunk(const ChunkPosition& chunkPosition) const;

    /**
     * Returns a const pointer to the tile at the given coordinates, or nullptr 
     * if the tile doesn't exist (out of bounds, parent chunk is empty).
     * Note: Make sure to nullptr check these! Chunks are commonly empty. 
     */
    const Tile* getTile(const TilePosition& tilePosition) const;
    const Tile* cgetTile(const TilePosition& tilePosition) const;

    /**
     * Returns the map extent, with chunks as the unit.
     */
    const ChunkExtent& getChunkExtent() const;

    /**
     * Returns the map extent, with tiles as the unit.
     */
    const TileExtent& getTileExtent() const;

    /**
     * If true, when a tile is updated, its collision will be rebuilt.
     *
     * If false, the user must manually call rebuildDirtyTileCollision() after 
     * finishing all of their tile updates.
     *
     * When set from false to true, rebuildDirtyTileCollision() is called.
     */
    void setAutoRebuildCollision(bool newAutoRebuildCollision);

    /**
     * Rebuilds the collision of any tiles that have been updated since the 
     * last time this was called (while autoRebuildCollision is disabled).
     *
     * You normally don't need to call this manually, since it's called when 
     * autoRebuildCollision is re-enabled.
     */
    void rebuildDirtyTileCollision();

    using TileUpdateVariant
        = std::variant<TileAddLayer, TileRemoveLayer, TileClearLayers,
                       TileExtentClearLayers>;
    /**
     * Returns a vector containing all operations that have been performed on
     * this tile map since the last time the vector was cleared.
     */
    const std::vector<TileUpdateVariant>& getTileUpdateHistory();

    /**
     * Clears the tile update history vector.
     */
    void clearTileUpdateHistory();

    /**
     * Adds the tile layers from the given chunk snapshot to the map.
     */
    void loadChunk(const ChunkSnapshot& chunkSnapshot,
                   const ChunkPosition& chunkPosition);
    void loadChunk(const ChunkWireSnapshot& chunkSnapshot,
                   const ChunkPosition& chunkPosition);

protected:
    enum class ChunkError {
        /** The given position was outside of the map bounds. */
        InvalidPosition,
        /** The requested chunk (or the parent chunk of the requested tile) 
            does not exist. */
        NotFound
    };

    /**
     * Returns a reference to the chunk at the given coordinates, or an 
     * appropriate error.
     */
    std::expected<std::reference_wrapper<Chunk>, ChunkError>
        getChunk(const ChunkPosition& chunkPosition);

    struct ChunkTilePair
    {
        /** The tile's parent chunk. */
        std::reference_wrapper<Chunk> chunk;
        std::reference_wrapper<Tile> tile;
    };
    /**
     * Returns a reference to the tile at the given coordinates, or an 
     * appropriate error.
     */
    std::expected<ChunkTilePair, ChunkError>
        getTile(const TilePosition& tilePosition);

    /**
     * Returns a reference to the tile at the given coordinates.
     * Note: The given chunk must contain the tile at the given position.
     */
    Tile& getTile(Chunk& chunk, const ChunkPosition& chunkPosition,
                  const TilePosition& tilePosition);

    /**
     * Returns a pointer to the chunk at the given coordinates, creating the 
     * chunk if it doesn't already exist.
     * If chunkPosition is outside of the map bounds, returns nullptr.
     */
    Chunk* getOrCreateChunk(const ChunkPosition& chunkPosition);

    struct ChunkTilePtrPair
    {
        /** The tile's parent chunk. */
        Chunk* chunk{nullptr};
        Tile* tile{nullptr};
    };
    /**
     * Returns a pointer to the chunk and tile at the given coordinates, creating
     * the parent chunk if it doesn't already exist.
     * If tilePosition is outside of the map bounds, returns {nullptr, nullptr}.
     */
    ChunkTilePtrPair getOrCreateTile(const TilePosition& tilePosition);

    /**
     * Adds the given layer to the specified tile.
     * @return The tile that was added, or nullptr (tilePosition was outside of 
     *         the map bounds).
     */
    Tile* addTileLayer(const TilePosition& tilePosition,
                       const TileOffset& tileOffset, TileLayer::Type layerType,
                       const GraphicSet& graphicSet, Uint8 graphicValue);

    /**
     * Adds the given layer to the given tile.
     */
    void addTileLayer(Chunk& chunk, Tile& tile, const TileOffset& tileOffset,
                      TileLayer::Type layerType, const GraphicSet& graphicSet,
                      Uint8 graphicValue);

    /**
     * If auto rebuild is enabled, rebuilds the given tile's collision.
     * Otherwise, queues the collision to be rebuilt.
     */
    void rebuildTileCollision(Tile& tile, const TilePosition& tilePosition);

    /**
     * Adds a North wall to the given tile and adds gap fills if necessary.
     */
    void addNorthWall(const TilePosition& tilePosition,
                      const WallGraphicSet& graphicSet);

    /**
     * Adds a West wall to the given tile and adds gap fills if necessary.
     */
    void addWestWall(const TilePosition& tilePosition,
                     const WallGraphicSet& graphicSet);

    /**
     * Removes any layers with a matching offset, type, graphic index, and
     * graphic set from the specified tile.
     * @return The tile that was removed from, or nullptr (tilePosition was 
     *         outside of the map bounds, layer didn't exist).
     */
    Tile* remTileLayer(const TilePosition& tilePosition,
                       const TileOffset& tileOffset, TileLayer::Type layerType,
                       Uint16 graphicSetID, Uint8 graphicValue);

    /**
     * Removes any layers with a matching, type, graphic index, and graphic set
     * from the specified tile.
     * @return The tile that was removed from, or nullptr (tilePosition was 
     *         outside of the map bounds, layer didn't exist).
     */
    Tile* remTileLayer(const TilePosition& tilePosition,
                       TileLayer::Type layerType, Uint16 graphicSetID,
                       Uint8 graphicValue);

    /**
     * Removes any layers with a matching offset, type, graphic index, and
     * graphic set from the given tile.
     * @return true if the tile had any matching layers to remove, else false.
     */
    bool remTileLayer(Chunk& chunk, Tile& tile,
                      const ChunkPosition& chunkPosition,
                      const TileOffset& tileOffset, TileLayer::Type layerType,
                      Uint16 graphicSetID, Uint8 graphicValue);

    /**
     * Removes any layers with a matching type, graphic index, and graphic set
     * from the given tile.
     * @return true if the tile had any matching layers to remove, else false.
     */
    bool remTileLayer(Chunk& chunk, Tile& tile,
                      const ChunkPosition& chunkPosition,
                      TileLayer::Type layerType, Uint16 graphicSetID,
                      Uint8 graphicValue);

    /**
     * Removes any layers with a matching type and graphic index, regardless 
     * of their graphic set or offset.
     * @return true if the tile had any matching layers to remove, else false.
     */
    bool remTileLayers(Chunk& chunk, Tile& tile,
                       const ChunkPosition& chunkPosition,
                       TileLayer::Type layerType, Uint8 graphicValue);

    /**
     * Removes the North wall from the given tile. If a corner was broken,
     * modifies the other wall pieces appropriately.
     */
    bool remNorthWall(const TilePosition& tilePosition);

    /**
     * Removes the West wall from the given tile. If a corner was broken,
     * modifies the other wall pieces appropriately.
     */
    bool remWestWall(const TilePosition& tilePosition);

    /**
     * Clears the given layer types from the given tile.
     * @return If any layers were cleared, returns the tile. Else, nullptr 
     *         (tilePosition is outside of map bounds).
     */
    Tile* clearTileLayersInternal(
        const TilePosition& tilePosition,
        const std::array<bool, TileLayer::Type::Count>& layerTypesToClear);

    /**
     * Adds the tile layers from the given chunk snapshot to the map.
     */
    template<typename T>
    void loadChunkInternal(const T& chunkSnapshot,
                           const ChunkPosition& chunkPosition);

    /**
     * Returns a bool array of layer types to clear, based on the given
     * list of type enums.
     * We do things this way because it's more convenient for the caller to 
     * pass a list of type enums than an array of bools.
     */
    std::array<bool, TileLayer::Type::Count> toBoolArray(
        const std::initializer_list<TileLayer::Type>& layerTypesToClear);

    /** The version of the map format. Kept as just a 16-bit int for now, we
        can see later if we care to make it more complicated. */
    static constexpr Uint16 MAP_FORMAT_VERSION{1};

    /** Used to get graphics while constructing tiles. */
    const GraphicDataBase& graphicData;

    /** Used when rebuilding tile collision. */
    CollisionLocator& collisionLocator;

    /** The map's extent, with chunks as the unit. */
    ChunkExtent chunkExtent;

    /** The map's extent, with tiles as the unit. */
    TileExtent tileExtent;

    /** The chunks that make up this tile map. */
    std::unordered_map<ChunkPosition, Chunk> chunks;

private:
    /**
     * If true, collision will be rebuilt every time a tile is modified.
     * If false, the user must manually call rebuildDirtyTileCollision().
     */
    bool autoRebuildCollision;

    /** A queue of tiles that need their collision rebuilt. */
    std::vector<TilePosition> dirtyCollisionQueue;

    /** If true, all tile updates will be pushed into tileUpdateHistory. */
    bool trackTileUpdates;

    /** Holds a history of tile operations that have been performed on this map.
        TileUpdateSystem uses this history to send updates to clients, then
        clears it. */
    std::vector<TileUpdateVariant> tileUpdateHistory;
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/TileMapSnapshot.h`:

```h
#pragma once

#include "ChunkPosition.h"
#include "ChunkSnapshot.h"
#include "bitsery/ext/std_map.h"
#include <unordered_map>

namespace AM
{
/**
 * Holds tile map data in a persistable form.
 *
 * Used in saving/loading the tile map.
 *
 * This struct is fairly similar to the normal representation of the tile map,
 * see ChunkSnapshot and TileSnapshot for more obvious differences.
 */
struct TileMapSnapshot {
    /** Used as a "we should never hit this" cap on the number of chunks in a
        map. Currently set to 64*64*10. */
    static constexpr std::size_t MAX_CHUNKS{40960};

    /** The version of the map format. Kept as just a 16-bit int for now, we
        can see later if we care to make it more complicated. */
    Uint16 version{0};

    // Note: The map's origin is currently always assumed to be (0, 0). Add
    //       x/y fields here if we ever support negative origins.

    /** The length, in chunks, of the map's X axis. */
    Uint16 xLengthChunks{0};

    /** The length, in chunks, of the map's Y axis. */
    Uint16 yLengthChunks{0};

    /** The length, in chunks, of the map's Z axis. */
    Uint16 zLengthChunks{0};

    /** The chunks that make up this map. */
    std::unordered_map<ChunkPosition, ChunkSnapshot> chunks;
};

template<typename S>
void serialize(S& serializer, TileMapSnapshot& tileMapSnapshot)
{
    serializer.value2b(tileMapSnapshot.version);
    serializer.value2b(tileMapSnapshot.xLengthChunks);
    serializer.value2b(tileMapSnapshot.yLengthChunks);
    serializer.value2b(tileMapSnapshot.zLengthChunks);
    serializer.ext(tileMapSnapshot.chunks,
                   bitsery::ext::StdMap{TileMapSnapshot::MAX_CHUNKS},
                   [](S& serializer, ChunkPosition& chunkPosition,
                      ChunkSnapshot& chunkSnapshot) {
                       serializer.object(chunkPosition);
                       serializer.object(chunkSnapshot);
                   });
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/TileOffset.h`:

```h
#pragma once

#include "Terrain.h"
#include <SDL_stdinc.h>

namespace AM
{

/**
 * An integer offset, relative to a tile coordinate.
 *
 * Among other uses, Floor and Object tile layers use this offset to support 
 * them being placed anywhere within a tile. Terrain and Walls can't be offset 
 * (Terrain is always aligned to the tile, Walls are always aligned to the top
 * face of the terrain).
 *
 * This offset will never be greater than the size of a tile.
 *
 * Note: Since world units are normally floats, this offset has limited 
 *       resolution. This is fine in our use cases.
 */
struct TileOffset {
    /** The X-axis world unit offset. Max == SharedConfig::TILE_WORLD_WIDTH */
    Uint8 x{0};

    /** The Y-axis world unit offset. Max == SharedConfig::TILE_WORLD_WIDTH */
    Uint8 y{0};

    /** The Z-axis world unit offset. Max == SharedConfig::TILE_WORLD_HEIGHT */
    Uint8 z{0};

    bool operator==(const TileOffset& other) const
    {
        return (x == other.x) && (y == other.y) && (z == other.z);
    }

    bool operator!=(const TileOffset& other) const
    {
        return (x != other.x) || (y != other.y) || (z != other.z);
    }
};

template<typename S>
void serialize(S& serializer, TileOffset& tileOffset)
{
    serializer.value1b(tileOffset.x);
    serializer.value1b(tileOffset.y);
    serializer.value1b(tileOffset.z);
}

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TileMap/TilePosition.h`:

```h
#pragma once

#include "DiscretePosition.h"
#include "HashTools.h"

namespace AM
{
struct Vector3;
struct ChunkPosition;

/**
 * A strong type alias, describing the position of a particular map tile.
 */
struct TilePosition : public DiscretePosition<DiscreteImpl::TileTag> {
    TilePosition();

    TilePosition(int inX, int inY, int inZ);

    TilePosition(const DiscretePosition<DiscreteImpl::TileTag>& tilePosition);

    /**
     * Calculates the position of the tile that contains the given point.
     */
    explicit TilePosition(const Vector3& worldPoint);

    explicit TilePosition(const ChunkPosition& chunkPosition);

    /** Returns the world point at this tile's origin (the least extreme 
        point along all axes). */
    Vector3 getOriginPoint() const;

    /** Returns the world point at the 3D center of this tile. */
    Vector3 getCenterPoint() const;

    /** Returns the world point centered in the X and Y axis, but at the 
        lowest Z position of this tile. */
    Vector3 getCenteredBottomPoint() const;

    /**
     * Prints this position's current values.
     */
    void print() const;
};

template<typename S>
void serialize(S& serializer, TilePosition& tilePosition)
{
    serializer.value4b(tilePosition.x);
    serializer.value4b(tilePosition.y);
    serializer.value4b(tilePosition.z);
}

} // namespace AM

// std::hash() specialization.
namespace std
{
template<>
struct hash<AM::TilePosition> {
    typedef AM::TilePosition argument_type;
    typedef std::size_t result_type;
    result_type operator()(const argument_type& position) const
    {
        std::size_t seed{0};
        AM::hash_combine(seed, position.x);
        AM::hash_combine(seed, position.y);
        AM::hash_combine(seed, position.z);
        return seed;
    }
};
} // namespace std

```

`Source/SharedLib/Simulation/Public/TileMap/Wall.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{
struct Wall {
    /**
     * The types of wall graphics that we use for our modular wall system.
     */
    enum Type : Uint8 {
        /** A West wall. */
        West,
        /** A North wall. */
        North,
        /** A column used to fill SouthEast-pointing corners. Gets placed on the
            tile southeast of the north and west walls that form the corner. */
        NorthWestGapFill,
        /** A 3/4 North wall used to fill NorthWest-pointing corners. Gets
           placed on the same tile as a west wall to form the corner. */
        NorthEastGapFill,
        /** The number of different wall types that we have. */
        Count,
        /** Used to tell if a tile layer doesn't contain a wall. */
        None
    };
};

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/TypeLists/EngineReplicatedComponentTypes.h`:

```h
#pragma once

#include "IsClientEntity.h"
#include "Name.h"
#include "Input.h"
#include "Movement.h"
#include "MovementModifiers.h"
#include "Rotation.h"
#include "GraphicState.h"
#include "CollisionBitSets.h"
#include "Interaction.h"
#include "boost/mp11/list.hpp"

namespace AM
{

/**
 * A list of the components that the server sends to the client.
 *
 * When a client comes in range of an entity, an init message will be sent that
 * includes the components in this list (if the entity possesses any of them).
 * All client-relevant components must be added to this list, since there's 
 * no other way to send a component during this "init" event.
 * 
 * If you want a component to additionally be sent whenever it's patch()'d, 
 * replace()'d, and destroy()'d, add it to EngineObservedComponentTypes. 
 * If you do choose to observe a component, it still must be added to this list.
 * We enforce this because it always makes sense to init a component if you're 
 * going to observe it.
 * Alternatively, you can handle updates with your own system/messages to gain 
 * some performance (we do this for intense components like Movement and 
 * Rotation).
 *
 * Note: We handle Position separately because every entity is guaranteed to
 *       have one and it's more efficient to do so.
 * Note: We need Rotation, otherwise entities will face the wrong way on init.
 */
using EngineReplicatedComponentTypes
    = boost::mp11::mp_list<IsClientEntity, Name, Input, Movement,
                           MovementModifiers, Rotation, GraphicState,
                           CollisionBitSets, Interaction>;

} // End namespace AM

```

`Source/SharedLib/Simulation/Public/Vector3.h`:

```h
#pragma once

#include <cmath>

namespace AM
{
/**
 * A 3D vector, usually in world space.
 *
 * When representing a point in world space, we often use the Position class.
 * May also represent a direction.
 */
struct Vector3 {
    float x{0};
    float y{0};
    float z{0};

    Vector3 operator+(const Vector3& other) const;

    Vector3 operator-(const Vector3& other) const;

    Vector3 operator*(const Vector3& other) const;

    Vector3 operator*(float scalar) const;

    Vector3 operator/(const Vector3& other) const;

    Vector3 operator/(float scalar) const;

    Vector3& operator+=(const Vector3& other);

    Vector3& operator-=(const Vector3& other);

    Vector3& operator*=(const Vector3& other);

    Vector3& operator*=(float scalar);

    Vector3& operator/=(const Vector3& other);

    Vector3& operator/=(float scalar);

    bool operator==(const Vector3& other) const;

    bool operator!=(const Vector3& other) const;

    /**
     * Normalizes this vector.
     */
    void normalize();

    /**
     * Returns a normalized version of this vector.
     */
    [[nodiscard]] Vector3 normal() const;

    /**
     * Returns the per-component reciprocal of this vector (i.e. 
     * {1/x, 1/y, 1/z}).
     */
    [[nodiscard]] Vector3 reciprocal() const;

    /**
     * Returns the dot product of this vector and the given vector.
     */
    [[nodiscard]] float dot(const Vector3& other) const;

    /**
     * Returns a new vector slid along a plane defined by the given normal.
     * (i.e. returns the component of this vector that lies along the plane)
     */
    [[nodiscard]] Vector3 slide(const Vector3& normal) const;

    /**
     * Assuming this Vector3 is a point, returns a new point moved towards  
     * otherPoint by the given distance.
     * If the distance is sufficient to reach otherPoint, returns otherPoint.
     */
    [[nodiscard]] Vector3 moveTowards(const Vector3& otherPoint,
                                      float distance) const;

    /**
     * Returns the squared distance between this vector and the given
     * vector.
     * We keep it squared to avoid an expensive sqrt. You can use this by
     * squaring the distance you're comparing it to.
     */
    float squaredDistanceTo(const Vector3& other) const;

    /**
     * Prints this box's current values.
     */
    void print() const;
};

template<typename S>
void serialize(S& serializer, Vector3& vector)
{
    serializer.value4b(vector.x);
    serializer.value4b(vector.y);
    serializer.value4b(vector.z);
}

} // namespace AM

```

`Source/SharedLib/Utility/CMakeLists.txt`:

```txt
target_sources(SharedLib
    PRIVATE
        Private/AssetCache.cpp
        Private/ByteTools.cpp
        Private/IDPool.cpp
        Private/Log.cpp
        Private/Morton.cpp
        Private/Paths.cpp
        Private/PeriodicCaller.cpp
        Private/SDL.cpp
        Private/SDLHelpers.cpp
        Private/SDLNet.cpp
        Private/SDLRenderer.cpp
        Private/SDLWindow.cpp
        Private/StringTools.cpp
        Private/Timer.cpp
        Private/Transforms.cpp
    PUBLIC
        Public/AMAssert.h
        Public/AssetCache.h
        Public/BinaryBuffer.h
        Public/ByteTools.h
        Public/ConstexprTools.h
        Public/Deserialize.h
        Public/HashTools.h
        Public/IDPool.h
        Public/OSEventHandler.h
        Public/Log.h
        Public/Morton.h
        Public/Paths.h
        Public/PeriodicCaller.h
        Public/SDLHelpers.h
        Public/Serialize.h
        Public/SerializeBuffer.h
        Public/StringTools.h
        Public/Timer.h
        Public/Transforms.h
        Public/VariantTools.h
        Public/SDL_Wrappers/SDL.h
        Public/SDL_Wrappers/SDLNet.h
        Public/SDL_Wrappers/SDLRenderer.h
        Public/SDL_Wrappers/SDLWindow.h
)

target_include_directories(SharedLib
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/Public
)

# Build our precompiled header.
# CMake causes issues when using precompiled headers with GCC on macOS,
# so precompiled headers are disabled for that target.
if ((NOT APPLE) OR (CMAKE_CXX_COMPILER_ID MATCHES "Clang|AppleClang"))
    target_precompile_headers(SharedLib PRIVATE Private/pch.h)
endif()

```

`Source/SharedLib/Utility/Private/AssetCache.cpp`:

```cpp
#include "AssetCache.h"
#include "Log.h"

namespace AM
{
AssetCache::AssetCache(SDL_Renderer* inSdlRenderer)
: sdlRenderer{inSdlRenderer}
{
}

std::shared_ptr<SDL_Texture>
    AssetCache::requestTexture(const std::string& resourceID,
                               SDL_ScaleMode scaleMode)
{
    // If the texture is already in the cache, return it.
    auto it{textureCache.find(resourceID)};
    if (it != textureCache.end()) {
        return it->second;
    }

    // The ID wasn't found in the cache, assume it's a path to an image and 
    // try to load it.
    SDL_Texture* rawTexture{IMG_LoadTexture(sdlRenderer, resourceID.c_str())};
    if (!rawTexture) {
        LOG_ERROR("Failed to load texture: %s", resourceID.c_str());
        return nullptr;
    }

    // Wrap the texture in a shared_ptr.
    std::shared_ptr<SDL_Texture> texture{
        rawTexture, [](SDL_Texture* p) { SDL_DestroyTexture(p); }};

    // Set the texture's filtering/scaling quality.
    SDL_SetTextureScaleMode(texture.get(), scaleMode);

    // Save the texture in the cache.
    textureCache[resourceID] = texture;

    return texture;
}

std::shared_ptr<SDL_Texture>
    AssetCache::addTexture(SDL_Texture* rawTexture,
                           const std::string& resourceID)
{
    // Wrap the texture in a shared_ptr.
    std::shared_ptr<SDL_Texture> texture{
        rawTexture, [](SDL_Texture* p) { SDL_DestroyTexture(p); }};

    // Save the texture in the cache.
    textureCache[resourceID] = texture;

    return texture;
}

bool AssetCache::discardTexture(const std::string& imagePath)
{
    // If the cache contains the given texture, discard it.
    auto it{textureCache.find(imagePath)};
    if (it != textureCache.end()) {
        textureCache.erase(it);
        return true;
    }
    else {
        return false;
    }
}

} // End namespace AM

```

`Source/SharedLib/Utility/Private/ByteTools.cpp`:

```cpp
#include "ByteTools.h"
#include "Log.h"
#include "AMAssert.h"
#include <SDL_endian.h>
#include "lz4.h"

// If the system has data access alignment restrictions, our casting may fail.
#if defined(sparc) || defined(mips) || defined(__arm__)
#error                                                                         \
    "ByteTools does not yet support systems with data access alignment restrictions."
#endif

// Uint8 should simply be an alias for unsigned char, but it isn't required
// to be by the standard. This check makes sure there's isn't any extra weird
// stuff in the Uint8 implementation on this platform.
// See: https://stackoverflow.com/a/26746305/4258629
static_assert(std::is_same<Uint8, unsigned char>::value,
              "We require Uint8 to be implemented as unsigned char.");

namespace AM
{
Uint16 ByteTools::read16(const Uint8* buffer)
{
    return SDL_SwapLE16(*reinterpret_cast<const Uint16*>(buffer));
}

Uint32 ByteTools::read32(const Uint8* buffer)
{
    return SDL_SwapLE32(*reinterpret_cast<const Uint32*>(buffer));
}

void ByteTools::write16(Uint16 value, Uint8* buffer)
{
    // Note: SwapLE16 does nothing on little endian systems.
    *reinterpret_cast<Uint16*>(buffer) = SDL_SwapLE16(value);
}

void ByteTools::write32(Uint32 value, Uint8* buffer)
{
    *reinterpret_cast<Uint32*>(buffer) = SDL_SwapLE32(value);
}

std::size_t ByteTools::compressBound(std::size_t sourceLength)
{
    return LZ4_compressBound(static_cast<int>(sourceLength));
}

std::size_t ByteTools::compress(const Uint8* sourceBuffer,
                                std::size_t sourceLength, Uint8* destBuffer,
                                std::size_t destLength)
{
    // Check that destBuffer is large enough for efficient compression.
    AM_ASSERT((destLength >= compressBound(sourceLength)),
              "Please increase destLength to at least %uB.",
              compressBound(sourceLength));

    // Compress the data.
    int compressedLength{LZ4_compress_default(
        reinterpret_cast<const char*>(sourceBuffer),
        reinterpret_cast<char*>(destBuffer), static_cast<int>(sourceLength),
        static_cast<int>(destLength))};

    // Check for errors.
    if (compressedLength <= 0) {
        LOG_FATAL("Error during compression.");
    }

    return compressedLength;
}

std::size_t ByteTools::decompress(const Uint8* sourceBuffer,
                                  std::size_t sourceLength, Uint8* destBuffer,
                                  std::size_t destLength)
{
    // Decompress the data.
    int decompressedLength{LZ4_decompress_safe(
        reinterpret_cast<const char*>(sourceBuffer),
        reinterpret_cast<char*>(destBuffer), static_cast<int>(sourceLength),
        static_cast<int>(destLength))};

    // Check for errors.
    if (decompressedLength < 0) {
        LOG_FATAL("Error during decompression.");
    }

    return decompressedLength;
}

} // End namespace AM

```

`Source/SharedLib/Utility/Private/IDPool.cpp`:

```cpp
#include "IDPool.h"
#include "Log.h"
#include <algorithm>

namespace AM
{
IDPool::IDPool(ReservationStrategy inStrategy, std::size_t initialPoolSize)
: strategy{inStrategy}
, reservedIDCount{0}
, nextMarchID{0}
, nextLowestID{0}
, IDs(initialPoolSize)
{
    // Make sure the initial size is > 0, otherwise our resizes will never 
    // grow.
    if (initialPoolSize == 0) {
        IDs.resize(1);
    }
}

unsigned int IDPool::reserveID()
{
    if (strategy == ReservationStrategy::MarchForward) {
        // Reserve nextMarchID.
        unsigned int returnID{nextMarchID};
        IDs[nextMarchID] = true;
        reservedIDCount++;

        // Find and set the next march ID.
        setNextMarchID();

        return returnID;
    }
    else if (strategy == ReservationStrategy::ReuseLowest) {
        // Reserve nextLowestID.
        unsigned int returnID{nextLowestID};
        IDs[nextLowestID] = true;
        reservedIDCount++;

        // Find and set the next lowest ID.
        setNextLowestID();

        return returnID;
    }

    LOG_FATAL("Couldn't find a free ID when one should exist.");
    return 0;
}

void IDPool::markIDAsReserved(unsigned int ID)
{
    // If the ID isn't allocated, resize.
    if (ID >= IDs.size()) {
        IDs.resize(ID + 1);
    }

    IDs[ID] = true;
    reservedIDCount++;

    // If we're marching and this ID is the highest, find the next march ID.
    if ((strategy == ReservationStrategy::MarchForward)
        && (ID >= nextMarchID)) {
        setNextMarchID();
    }
    // Else if we're reusing lowest and this is the lowest ID, find the next 
    // free ID.
    else if ((strategy == ReservationStrategy::ReuseLowest)
        && (ID == nextLowestID)) {
        setNextLowestID();
    }
}

void IDPool::freeID(unsigned int ID)
{
    if (ID > IDs.size()) {
        LOG_FATAL("ID out of bounds: %u", ID);
    }

    // If the ID is reserved, free it.
    if (IDs[ID]) {
        IDs[ID] = false;
        reservedIDCount--;

        // If we're reusing lowest and this is the lowest ID, set it.
        if ((strategy == ReservationStrategy::ReuseLowest)
            && (ID < nextLowestID)) {
            nextLowestID = ID;
        }
    }
    else {
        LOG_FATAL("Tried to free an unused ID: %u", ID);
    }
}

void IDPool::freeAllIDs()
{
    std::fill(IDs.begin(), IDs.end(), false);
}

void IDPool::setNextMarchID()
{
    // If we're out of IDs, double our capacity.
    if (reservedIDCount == IDs.size()) {
        IDs.resize(IDs.size() * 2);
    }

    // March to the next ID, wrapping and searching if necessary.
    // Note: We add 1 to nextMarchID to avoid choosing the same one.
    for (std::size_t i{0}; i < (IDs.size() - 1); ++i) {
        std::size_t index{(nextMarchID + 1 + i) % IDs.size()};
        if (!IDs[index]) {
            nextMarchID = static_cast<unsigned int>(index);
            return;
        }
    }
}

void IDPool::setNextLowestID()
{
    // If we're out of IDs, double our capacity.
    if (reservedIDCount == IDs.size()) {
        IDs.resize(IDs.size() * 2);
    }

    // Find the next available ID.
    // Note: We add 1 to nextLowestID to avoid choosing the same one.
    for (std::size_t i{nextLowestID + 1}; i < IDs.size(); ++i) {
        if (!IDs[i]) {
            nextLowestID = static_cast<unsigned int>(i);
            return;
        }
    }
}

} // namespace AM

```

`Source/SharedLib/Utility/Private/Log.cpp`:

```cpp
#include "Log.h"
#include <cstdio>
#include <cstdarg>

namespace AM
{
const std::atomic<Uint32>* Log::currentTickPtr = nullptr;
std::atomic<bool> Log::tickPtrIsRegistered = false;
FILE* logFilePtr = nullptr;

void Log::registerCurrentTickPtr(const std::atomic<Uint32>* inCurrentTickPtr)
{
    currentTickPtr = inCurrentTickPtr;
    tickPtrIsRegistered = true;
}

void Log::info(const char* expression, ...)
{
    // If the app hasn't registered a tick count, default to 0.
    Uint32 currentTick = 0;
    if (tickPtrIsRegistered) {
        currentTick = *currentTickPtr;
    }

    // Get the va_list into arg.
    std::va_list arg;
    va_start(arg, expression);

    // If enabled, write to file.
    if (logFilePtr != nullptr) {
        // Copy the va_list since it's undefined to use it twice.
        std::va_list argCopy;
        va_copy(argCopy, arg);

        std::fprintf(logFilePtr, "Tick %u: ", currentTick);
        std::vfprintf(logFilePtr, expression, argCopy);
        std::fprintf(logFilePtr, "\n");
        std::fflush(logFilePtr);

        va_end(argCopy);
    }

    // Write to stdout.
    std::printf("Tick %u: ", currentTick);
    std::vprintf(expression, arg);
    std::printf("\n");
    std::fflush(stdout);

    va_end(arg);
}

void Log::error(const char* fileName, int line, const char* expression, ...)
{
    // If the app hasn't registered a tick count, default to 0.
    Uint32 currentTick = 0;
    if (currentTickPtr != nullptr) {
        currentTick = *currentTickPtr;
    }

    // Get the va_list into arg.
    std::va_list arg;
    va_start(arg, expression);

    // If enabled, write to file.
    if (logFilePtr != nullptr) {
        // Copy the va_list since it's undefined to use it twice.
        std::va_list argCopy;
        va_copy(argCopy, arg);

        std::fprintf(logFilePtr,
                     "Error at file: %s, line: %d, during tick: %u\n", fileName,
                     line, currentTick);
        std::vfprintf(logFilePtr, expression, argCopy);
        std::fprintf(logFilePtr, "\n");
        std::fflush(logFilePtr);

        va_end(argCopy);
    }

    // Write to stdout.
    std::printf("Error at file: %s, line: %d, during tick: %u\n", fileName,
                line, currentTick);
    std::vprintf(expression, arg);
    std::printf("\n");
    std::fflush(stdout);

    va_end(arg);
}

void Log::enableFileLogging(const std::string& fileName)
{
    // Open the log file.
    logFilePtr = fopen(fileName.c_str(), "w");
    if (logFilePtr == nullptr) {
        std::printf("Failed to open log file for writing.\n");
    }
}

} // namespace AM

```

`Source/SharedLib/Utility/Private/Morton.cpp`:

```cpp
#include "Morton.h"
#include "libmorton/morton.h"
#include <cstdint>

namespace AM
{
/** A lookup table of morton code values, for up to a 16x16 value space. 
    Note: If you're trying to understand the ordering, look at the wiki page.
          This initializer visually has the X and Y axis flipped. */
static constexpr std::array<std::array<Uint8, 16>, 16> zValues16x16{
    {{0, 2, 8, 10, 32, 34, 40, 42, 128, 130, 136, 138, 160, 162, 168, 170},
     {1, 3, 9, 11, 33, 35, 41, 43, 129, 131, 137, 139, 161, 163, 169, 171},
     {4, 6, 12, 14, 36, 38, 44, 46, 132, 134, 140, 142, 164, 166, 172, 174},
     {5, 7, 13, 15, 37, 39, 45, 47, 133, 135, 141, 143, 165, 167, 173, 175},
     {16, 18, 24, 26, 48, 50, 56, 58, 144, 146, 152, 154, 176, 178, 184, 186},
     {17, 19, 25, 27, 49, 51, 57, 59, 145, 147, 153, 155, 177, 179, 185, 187},
     {20, 22, 28, 30, 52, 54, 60, 62, 148, 150, 156, 158, 180, 182, 188, 190},
     {21, 23, 29, 31, 53, 55, 61, 63, 149, 151, 157, 159, 181, 183, 189, 191},
     {64, 66, 72, 74, 96, 98, 104, 106, 192, 194, 200, 202, 224, 226, 232, 234},
     {65, 67, 73, 75, 97, 99, 105, 107, 193, 195, 201, 203, 225, 227, 233, 235},
     {68, 70, 76, 78, 100, 102, 108, 110, 196, 198, 204, 206, 228, 230, 236,
      238},
     {69, 71, 77, 79, 101, 103, 109, 111, 197, 199, 205, 207, 229, 231, 237,
      239},
     {80, 82, 88, 90, 112, 114, 120, 122, 208, 210, 216, 218, 240, 242, 248,
      250},
     {81, 83, 89, 91, 113, 115, 121, 123, 209, 211, 217, 219, 241, 243, 249,
      251},
     {84, 86, 92, 94, 116, 118, 124, 126, 212, 214, 220, 222, 244, 246, 252,
      254},
     {85, 87, 93, 95, 117, 119, 125, 127, 213, 215, 221, 223, 245, 247, 253,
      255}}};

/** A reverse lookup table of x/y values given a morton code, for up to a 
    16x16 value space. */
static constexpr std::array<Morton::Result2D<Uint8>, 256> xyValues16x16{
    {{0, 0},   {1, 0},   {0, 1},   {1, 1},   {2, 0},   {3, 0},   {2, 1},
     {3, 1},   {0, 2},   {1, 2},   {0, 3},   {1, 3},   {2, 2},   {3, 2},
     {2, 3},   {3, 3},   {4, 0},   {5, 0},   {4, 1},   {5, 1},   {6, 0},
     {7, 0},   {6, 1},   {7, 1},   {4, 2},   {5, 2},   {4, 3},   {5, 3},
     {6, 2},   {7, 2},   {6, 3},   {7, 3},   {0, 4},   {1, 4},   {0, 5},
     {1, 5},   {2, 4},   {3, 4},   {2, 5},   {3, 5},   {0, 6},   {1, 6},
     {0, 7},   {1, 7},   {2, 6},   {3, 6},   {2, 7},   {3, 7},   {4, 4},
     {5, 4},   {4, 5},   {5, 5},   {6, 4},   {7, 4},   {6, 5},   {7, 5},
     {4, 6},   {5, 6},   {4, 7},   {5, 7},   {6, 6},   {7, 6},   {6, 7},
     {7, 7},   {8, 0},   {9, 0},   {8, 1},   {9, 1},   {10, 0},  {11, 0},
     {10, 1},  {11, 1},  {8, 2},   {9, 2},   {8, 3},   {9, 3},   {10, 2},
     {11, 2},  {10, 3},  {11, 3},  {12, 0},  {13, 0},  {12, 1},  {13, 1},
     {14, 0},  {15, 0},  {14, 1},  {15, 1},  {12, 2},  {13, 2},  {12, 3},
     {13, 3},  {14, 2},  {15, 2},  {14, 3},  {15, 3},  {8, 4},   {9, 4},
     {8, 5},   {9, 5},   {10, 4},  {11, 4},  {10, 5},  {11, 5},  {8, 6},
     {9, 6},   {8, 7},   {9, 7},   {10, 6},  {11, 6},  {10, 7},  {11, 7},
     {12, 4},  {13, 4},  {12, 5},  {13, 5},  {14, 4},  {15, 4},  {14, 5},
     {15, 5},  {12, 6},  {13, 6},  {12, 7},  {13, 7},  {14, 6},  {15, 6},
     {14, 7},  {15, 7},  {0, 8},   {1, 8},   {0, 9},   {1, 9},   {2, 8},
     {3, 8},   {2, 9},   {3, 9},   {0, 10},  {1, 10},  {0, 11},  {1, 11},
     {2, 10},  {3, 10},  {2, 11},  {3, 11},  {4, 8},   {5, 8},   {4, 9},
     {5, 9},   {6, 8},   {7, 8},   {6, 9},   {7, 9},   {4, 10},  {5, 10},
     {4, 11},  {5, 11},  {6, 10},  {7, 10},  {6, 11},  {7, 11},  {0, 12},
     {1, 12},  {0, 13},  {1, 13},  {2, 12},  {3, 12},  {2, 13},  {3, 13},
     {0, 14},  {1, 14},  {0, 15},  {1, 15},  {2, 14},  {3, 14},  {2, 15},
     {3, 15},  {4, 12},  {5, 12},  {4, 13},  {5, 13},  {6, 12},  {7, 12},
     {6, 13},  {7, 13},  {4, 14},  {5, 14},  {4, 15},  {5, 15},  {6, 14},
     {7, 14},  {6, 15},  {7, 15},  {8, 8},   {9, 8},   {8, 9},   {9, 9},
     {10, 8},  {11, 8},  {10, 9},  {11, 9},  {8, 10},  {9, 10},  {8, 11},
     {9, 11},  {10, 10}, {11, 10}, {10, 11}, {11, 11}, {12, 8},  {13, 8},
     {12, 9},  {13, 9},  {14, 8},  {15, 8},  {14, 9},  {15, 9},  {12, 10},
     {13, 10}, {12, 11}, {13, 11}, {14, 10}, {15, 10}, {14, 11}, {15, 11},
     {8, 12},  {9, 12},  {8, 13},  {9, 13},  {10, 12}, {11, 12}, {10, 13},
     {11, 13}, {8, 14},  {9, 14},  {8, 15},  {9, 15},  {10, 14}, {11, 14},
     {10, 15}, {11, 15}, {12, 12}, {13, 12}, {12, 13}, {13, 13}, {14, 12},
     {15, 12}, {14, 13}, {15, 13}, {12, 14}, {13, 14}, {12, 15}, {13, 15},
     {14, 14}, {15, 14}, {14, 15}, {15, 15}}};

static constexpr Uint64 magicbit2D_masks64[6]
    = {0x00000000FFFFFFFF, 0x0000FFFF0000FFFF, 0x00FF00FF00FF00FF,
       0x0F0F0F0F0F0F0F0F, 0x3333333333333333, 0x5555555555555555};

Uint8 Morton::encode16x16(Uint8 x, Uint8 y)
{
    return static_cast<Uint8>(zValues16x16[x][y]);
}

Morton::Result2D<Uint8> Morton::decode16x16(Uint8 code)
{
    return xyValues16x16[code];
}

Uint32 Morton::encode32(Uint16 x, Uint16 y)
{
    return libmorton::morton2D_32_encode(x, y);
}

Uint64 Morton::encode64(Uint32 x, Uint32 y)
{
    return libmorton::morton2D_64_encode(x, y);
}

Morton::Result2D<Uint16> Morton::decode32(Uint32 code)
{
    uint_fast16_t x{};
    uint_fast16_t y{};
    libmorton::morton2D_32_decode(code, x, y);

    return {static_cast<Uint16>(x), static_cast<Uint16>(y)};
}

Morton::Result2D<Uint32> Morton::decode64(Uint64 code)
{
    uint_fast32_t x{};
    uint_fast32_t y{};
    libmorton::morton2D_64_decode(code, x, y);

    return {static_cast<Uint32>(x), static_cast<Uint32>(y)};
}

} // End namespace AM

```

`Source/SharedLib/Utility/Private/Paths.cpp`:

```cpp
#include "Paths.h"
#include <SDL_filesystem.h>

namespace AM
{
// Note: It would be nice if we could trivially free this after making it a
//       string, but it isn't a big deal.
const char* BASE_PATH_INTERNAL = SDL_GetBasePath();

const std::string Paths::BASE_PATH = std::string{BASE_PATH_INTERNAL};

const std::string Paths::FONT_DIR
    = std::string{Paths::BASE_PATH} + "Assets/Fonts/";

const std::string Paths::TEXTURE_DIR
    = std::string{Paths::BASE_PATH} + "Assets/Textures/";

} // End namespace AM

```

`Source/SharedLib/Utility/Private/PeriodicCaller.cpp`:

```cpp
#include "PeriodicCaller.h"
#include "Log.h"

namespace AM
{
PeriodicCaller::PeriodicCaller(std::function<void(void)> inGivenFunctNoTimestep,
                               double inTimestepS, std::string_view inDebugName,
                               bool inSkipLateSteps)
: givenFunctNoTimestep{std::move(inGivenFunctNoTimestep)}
, timestepS{inTimestepS}
, debugName{inDebugName}
, skipLateSteps{inSkipLateSteps}
, timer{}
, accumulatedTime{0.0}
, delayedTimeS{-1}
{
}

PeriodicCaller::PeriodicCaller(std::function<void(double)> inGivenFunctTimestep,
                               double inTimestepS, std::string_view inDebugName,
                               bool inSkipLateSteps)
: givenFunctTimestep{std::move(inGivenFunctTimestep)}
, timestepS{inTimestepS}
, debugName{inDebugName}
, skipLateSteps{inSkipLateSteps}
, timer{}
, accumulatedTime{0.0}
, delayedTimeS{-1}
{
}

void PeriodicCaller::initTimer()
{
    timer.reset();
}

void PeriodicCaller::update()
{
    // Accumulate the time passed since the last update().
    accumulatedTime += timer.getTimeAndReset();

    // Process as many time steps as have accumulated.
    while (accumulatedTime >= timestepS) {
        double updateStartTime{timer.getTime()};

        // Call whichever function we were given on construction.
        if (givenFunctNoTimestep != nullptr) {
            givenFunctNoTimestep();
        }
        else if (givenFunctTimestep != nullptr) {
            givenFunctTimestep(timestepS);
        }

        // Check our execution time.
        double executionTime{timer.getTime()};
        if ((executionTime - updateStartTime) > timestepS) {
            LOG_INFO("%s overran its update timestep. executionTime: %.5fs",
                     debugName.c_str(), executionTime);
        }

        // Deduct this time step from the accumulator and check for delays.
        accumulatedTime -= timestepS;
        if (accumulatedTime >= timestepS) {
            // Update was delayed for longer than timestepS.
            LOG_INFO(
                "Detected a request for multiple %s update calls in the same "
                "frame. Update was delayed by: %.5fs.",
                debugName.c_str(), accumulatedTime);

            // If we're skipping late steps, reset to a fresh state.
            if (skipLateSteps) {
                accumulatedTime = 0;
                break;
            }
        }
        else if ((delayedTimeS > 0) && (accumulatedTime >= delayedTimeS)) {
            // Update was delayed for longer than delayedTimeS.
            LOG_INFO("%s update missed its ideal call time. Update was delayed "
                     "by %.5fs.",
                     debugName.c_str(), accumulatedTime);
        }
    }
}

double PeriodicCaller::getTimeTillNextCall()
{
    // Get the time since accumulatedTime was last updated.
    double timeSinceLastCall{timer.getTime()};

    // Return the amount of time until our next call.
    return (timestepS - (accumulatedTime + timeSinceLastCall));
}

double PeriodicCaller::getProgress()
{
    // Get the time since accumulatedTime was last updated.
    double timeSinceLastCall{timer.getTime()};

    // Return how far we are into this timestep.
    return ((accumulatedTime + timeSinceLastCall) / timestepS);
}

void PeriodicCaller::reportDelays(double inDelayedTimeS)
{
    delayedTimeS = inDelayedTimeS;
}

} // namespace AM

```

`Source/SharedLib/Utility/Private/SDL.cpp`:

```cpp
#include "SDL_Wrappers/SDL.h"
#include "Log.h"
#include <SDL.h>

namespace AM
{

SDL::SDL(Uint32 flags)
{
    if (SDL_Init(flags) != 0) {
        LOG_INFO("SDL_Init error: %s", SDL_GetError());
        std::abort();
    }
}

SDL::~SDL()
{
    SDL_Quit();
}

} // End namespace AM

```

`Source/SharedLib/Utility/Private/SDLHelpers.cpp`:

```cpp
#include "SDLHelpers.h"
#include "Ray.h"
#include "Log.h"
#include <SDL_render.h>
#include <SDL_image.h>
#include <SDL_video.h>
#include <cmath>

namespace AM
{
SDL_FPoint SDLHelpers::pointToFPoint(const SDL_Point& point)
{
    return {static_cast<float>(point.x), static_cast<float>(point.y)};
}

SDL_Point SDLHelpers::truncateFPoint(const SDL_FPoint& point)
{
    return {static_cast<int>(point.x), static_cast<int>(point.y)};
}

SDL_Point SDLHelpers::roundFPoint(const SDL_FPoint& point)
{
    return {static_cast<int>(std::round(point.x)),
            static_cast<int>(std::round(point.y))};
}

SDL_FRect SDLHelpers::rectToFRect(const SDL_Rect& rect)
{
    return {static_cast<float>(rect.x), static_cast<float>(rect.y),
            static_cast<float>(rect.w), static_cast<float>(rect.h)};
}

SDL_Rect SDLHelpers::truncateFRect(const SDL_FRect& rect)
{
    return {static_cast<int>(rect.x), static_cast<int>(rect.y),
            static_cast<int>(rect.w), static_cast<int>(rect.h)};
}

SDL_Rect SDLHelpers::roundFRect(const SDL_FRect& rect)
{
    return {static_cast<int>(std::round(rect.x)),
            static_cast<int>(std::round(rect.y)),
            static_cast<int>(std::round(rect.w)),
            static_cast<int>(std::round(rect.h))};
}

bool SDLHelpers::savePng(const std::string& filePath, SDL_Renderer* renderer,
                         SDL_Texture* texture)
{
    // Save the old render target and set the given texture as our new target.
    SDL_Texture* oldRenderTarget{SDL_GetRenderTarget(renderer)};
    SDL_SetRenderTarget(renderer, texture);

    // Get the texture's dimensions.
    int width{};
    int height{};
    SDL_QueryTexture(texture, NULL, NULL, &width, &height);

    // Copy the texture into a surface.
    SDL_Surface* surface{SDL_CreateRGBSurface(
        0, width, height, 32, 0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF)};
    SDL_RenderReadPixels(renderer, NULL, surface->format->format,
                         surface->pixels, surface->pitch);

    // Save the surface to a file.
    int result{IMG_SavePNG(surface, filePath.c_str())};
    SDL_FreeSurface(surface);

    SDL_SetRenderTarget(renderer, oldRenderTarget);
    return (result == 0);
}

void SDLHelpers::setWindowFullscreen(SDL_Window* window, Uint32 newMode)
{
    if (!SDL_SetWindowFullscreen(window, newMode)) {
        LOG_INFO("Failed to set fullscreen mode: %s", SDL_GetError());
    }
}

} // namespace AM

```

`Source/SharedLib/Utility/Private/SDLNet.cpp`:

```cpp
#include "SDL_Wrappers/SDLNet.h"
#include "SDL_net.h"

namespace AM
{
SDLNet::SDLNet()
{
    SDLNet_Init();
}

SDLNet::~SDLNet()
{
    SDLNet_Quit();
}

} // end namespace AM

```

`Source/SharedLib/Utility/Private/SDLRenderer.cpp`:

```cpp
#include "SDL_Wrappers/SDLRenderer.h"
#include "Log.h"
#include <SDL_render.h>

namespace AM
{

SDLRenderer::SDLRenderer(SDL_Window* window, int index, Uint32 flags)
: renderer{SDL_CreateRenderer(window, index, flags)}
{
    if (!renderer) {
        LOG_INFO("SDL_Renderer init error: %s", SDL_GetError());
        std::abort();
    }
}

SDLRenderer::~SDLRenderer()
{
    if (renderer) {
        SDL_DestroyRenderer(renderer);
    }
}

SDL_Renderer* SDLRenderer::get()
{
    return renderer;
}

} // End namespace AM

```

`Source/SharedLib/Utility/Private/SDLWindow.cpp`:

```cpp
#include "SDL_Wrappers/SDLWindow.h"
#include "Log.h"
#include <SDL_video.h>

namespace AM
{

SDLWindow::SDLWindow(const std::string& title, int x, int y, int w, int h,
                     Uint32 flags)
: window{SDL_CreateWindow(title.c_str(), x, y, w, h, flags)}
{
    if (!window) {
        LOG_INFO("SDL_Window init error: %s", SDL_GetError());
        std::abort();
    }
}

SDLWindow::~SDLWindow()
{
    if (window) {
        SDL_DestroyWindow(window);
    }
}

SDL_Window* SDLWindow::get()
{
    return window;
}

} // End namespace AM

```

`Source/SharedLib/Utility/Private/StringTools.cpp`:

```cpp
#include "StringTools.h"
#include <algorithm>

namespace AM
{

void StringTools::deriveStringID(std::string_view displayName,
                                 std::string& dest)
{
    // Derive a string ID from the given display name.
    dest.resize(displayName.size());
    std::transform(displayName.begin(), displayName.end(), dest.begin(),
                   [](unsigned char c) -> unsigned char {
                       // Replace spaces with underscores.
                       if (c == ' ') {
                           return '_';
                       }
                       // Make the string all lowercase.
                       return std::tolower(c);
                   });
}

std::string_view StringTools::getFileName(std::string_view filePath)
{
    return filePath.substr(filePath.find_last_of("/\\") + 1);
}

std::string_view StringTools::getFileNameNoExtension(std::string_view filePath)
{
    std::string_view fileName{getFileName(filePath)};
    return fileName.substr(0, fileName.find_last_of('.'));
}

bool StringTools::pathStartsWith(std::string_view pathA, std::string_view pathB)
{
    // If pathB is longer than pathA, pathA can't possibly start with it.
    if (pathB.size() > pathA.size()) {
        return false;
    }

    // Compare char-by-char.
    for (int index{0}; index < static_cast<int>(pathB.size()); ++index) {
        char charA{pathA.at(index)};
        char charB{pathB.at(index)};

        // Normalize slashes to '/';
        if (charA == '\\') {
            charA = '/';
        }
        if (charB == '\\') {
            charB = '/';
        }

        if (charA != charB) {
            return false;
        }
    }

    return true;
}

} // End namespace AM

```

`Source/SharedLib/Utility/Private/Timer.cpp`:

```cpp
#include "Timer.h"
#include "SDL.h"

namespace AM
{
Timer::Timer()
: period{1.0 / SDL_GetPerformanceFrequency()}
, savedTimestamp{SDL_GetPerformanceCounter()}
{
}

double Timer::getTime()
{
    Uint64 currentTicks{SDL_GetPerformanceCounter()};
    Uint64 deltaTicks{currentTicks - savedTimestamp};

    return deltaTicks * period;
}

void Timer::reset()
{
    savedTimestamp = SDL_GetPerformanceCounter();
}

double Timer::getTimeAndReset()
{
    Uint64 currentTicks{SDL_GetPerformanceCounter()};
    Uint64 deltaTicks{currentTicks - savedTimestamp};

    savedTimestamp = currentTicks;

    return deltaTicks * period;
}

double Timer::getGlobalTime()
{
    static Timer timer{};
    return timer.getTime();
}

} // namespace AM

```

`Source/SharedLib/Utility/Private/Transforms.cpp`:

```cpp
#include "Transforms.h"
#include "Position.h"
#include "Camera.h"
#include "BoundingBox.h"
#include "Sprite.h"
#include "SharedConfig.h"
#include "AMAssert.h"
#include "Log.h"
#include <cmath>

namespace AM
{
SDL_FPoint Transforms::worldToScreen(const Vector3& point, float zoomFactor)
{
    // Convert cartesian world point to isometric screen point.
    float screenX{(point.x - point.y)
                  * (TILE_FACE_WIDTH_WORLD_TO_SCREEN / 2.f)};
    float screenY{(point.x + point.y)
                  * (TILE_FACE_HEIGHT_WORLD_TO_SCREEN / 2.f)};

    // The Z coordinate contribution is independent of X/Y and only affects the
    // screen's Y axis. Scale and apply it.
    screenY -= (point.z * TILE_SIDE_HEIGHT_WORLD_TO_SCREEN);

    // Apply the camera zoom.
    screenX *= zoomFactor;
    screenY *= zoomFactor;

    return {screenX, screenY};
}

float Transforms::worldZToScreenY(float zCoord, float zoomFactor)
{
    return zCoord * zoomFactor * TILE_SIDE_HEIGHT_WORLD_TO_SCREEN;
}

Vector3 Transforms::screenToWorldMinimum(const SDL_FPoint& screenPoint,
                                         const Camera& camera)
{
    // Offset the screen point to include the camera position.
    SDL_FPoint absolutePoint{};
    absolutePoint.x = screenPoint.x + camera.screenExtent.x;
    absolutePoint.y = screenPoint.y + camera.screenExtent.y;

    // Remove the camera zoom.
    float x{absolutePoint.x / camera.zoomFactor};
    float y{absolutePoint.y / camera.zoomFactor};

    // Calc the world point.
    float worldX{((2.f * y) + x) * TILE_FACE_WIDTH_SCREEN_TO_WORLD};
    float worldY{((2.f * y) - x) * TILE_FACE_HEIGHT_SCREEN_TO_WORLD / 2.f};

    return {worldX, worldY, 0};
}

std::optional<Vector3>
    Transforms::screenToWorldTarget(const SDL_FPoint& screenPoint,
                                    const Camera& camera)
{
    // Find the t where a ray cast from screenPoint intersects the camera 
    // target's Z plane.
    if (std::optional<Ray> rayOpt{screenToWorldRay(screenPoint, camera)}) {
        Ray& ray{rayOpt.value()};
        BoundingBox zPlane{{-1'000'000.f, -1'000'000.f, -0.1f},
                           {1'000'000.f, 1'000'000.f, camera.target.z}};
        auto [didIntersect, tMin, _]
            = zPlane.intersects(ray, 0, std::numeric_limits<float>::infinity());
        AM_ASSERT(didIntersect, "Screen ray failed to intersect Z plane.");

        // Return the intersected point.
        return ray.getPointAtT(tMin);
    }

    return std::nullopt;
}

std::optional<Ray> Transforms::screenToWorldRay(const SDL_FPoint& screenPoint,
                                                const Camera& camera)
{
    // Ref: https://gamedev.stackexchange.com/a/206067/124282

    // Find where screenPoint intersects the world at Z == 0.
    Vector3 minimum{screenToWorldMinimum(screenPoint, camera)};

    // Cast a ray up from the minimum point towards the camera.
    // Find the furthest point where the ray intersects the camera's bounds
    // (tMin will be invalid since our point is inside the bounds).
    Ray rayToCamera{minimum,
                    {TILE_SIDE_HEIGHT_WORLD_TO_SCREEN,
                     TILE_SIDE_HEIGHT_WORLD_TO_SCREEN,
                     TILE_FACE_HEIGHT_WORLD_TO_SCREEN}};
    rayToCamera.direction.normalize();
    auto [didIntersect, _, tMax] = camera.viewBounds.intersects(
        rayToCamera, 0, std::numeric_limits<float>::infinity());
    if (!didIntersect) {
        // rayToCamera failed to intersect the camera's view bounds.
        return std::nullopt;
    }

    Vector3 viewBoundsIntersection{rayToCamera.getPointAtT(tMax)};

    // Return a ray that starts at the intersected position and points towards 
    // the minimum.
    return Ray{viewBoundsIntersection, -rayToCamera.direction.x,
               -rayToCamera.direction.y, -rayToCamera.direction.z};
}

float Transforms::screenYToWorldZ(float yCoord, float zoomFactor)
{
    return (yCoord / zoomFactor) * TILE_SIDE_HEIGHT_SCREEN_TO_WORLD;
}

BoundingBox Transforms::modelToWorldTile(const BoundingBox& modelBounds,
                                         const TilePosition& tilePosition)
{
    static constexpr float TILE_WORLD_WIDTH{SharedConfig::TILE_WORLD_WIDTH};
    static constexpr float TILE_WORLD_HEIGHT{SharedConfig::TILE_WORLD_HEIGHT};

    // Offset the model-space bounding box to align it with the tile
    Vector3 offset{tilePosition.x * TILE_WORLD_WIDTH,
                   tilePosition.y * TILE_WORLD_WIDTH,
                   tilePosition.z * TILE_WORLD_HEIGHT};

    return modelBounds.translateBy(offset);
}

BoundingBox Transforms::modelToWorldEntity(const BoundingBox& modelBounds,
                                           const Position& position)
{
    // Entities should have their IdleSouth bounding box's bottom center
    // aligned with their Position.
    BoundingBox newBounds{modelBounds};
    newBounds = newBounds.moveBottomCenterTo(position);

    return newBounds;
}

} // End namespace AM

```

`Source/SharedLib/Utility/Private/pch.h`:

```h
#pragma once

// STL
#include <vector>
#include <array>
#include <memory>
#include <string>
#include <cstddef>
#include <chrono>
#include <functional>
#include <variant>
#include <algorithm>
#include <filesystem>
#include <unordered_map>

// Libs
#include <SDL_stdinc.h>
#include "readerwriterqueue.h"
#include "nlohmann/json.hpp"

// Ours
#include "QueuedEvents.h"
#include "Log.h"
#include "NetworkDefs.h"
#include "SharedConfig.h"

```

`Source/SharedLib/Utility/Public/AMAssert.h`:

```h
#pragma once

#include "Log.h"

/**
 * Assert macro. Use this in place of assert().
 */
#ifdef NDEBUG
#define AM_ASSERT(condition, ...)                                              \
    do {                                                                       \
    } while (false)
#else
#define AM_ASSERT(condition, ...)                                              \
    do {                                                                       \
        if (!(condition)) {                                                    \
            LOG_ERROR(__VA_ARGS__);                                            \
        }                                                                      \
    } while (false)
#endif

```

`Source/SharedLib/Utility/Public/AssetCache.h`:

```h
#pragma once

#include <SDL_render.h>
#include <SDL_image.h>

#include <memory>
#include <string>
#include <unordered_map>

namespace AM
{
// I don't like obfuscating the shared_ptr, but this alias is useful in case
// we decide to change the type.
using TextureHandle = std::shared_ptr<SDL_Texture>;

/**
 * Facilitates loading and managing the lifetime of assets.
 */
class AssetCache
{
public:
    /**
     * @param inSdlRenderer  The renderer to load textures with.
     */
    AssetCache(SDL_Renderer* inSdlRenderer);

    /**
     * If a texture with the given resource ID is in the cache, returns it.
     * If not and the resource ID is a valid file path to an image, adds the 
     * image to the cache and returns it.
     *
     * @param resourceID An abstract resource ID (for textures added using 
     *                   addTexture()), or the full path to an image file.
     * @param scaleMode The filtering/scaling mode that this texture should use.
     * @return A valid texture if one was found, else nullptr.
     */
    std::shared_ptr<SDL_Texture> requestTexture(const std::string& resourceID,
                                                SDL_ScaleMode scaleMode);

    /**
     * Adds the given texture to the cache, using the given ID.
     * If a texture already exists with the given ID, it will be overwritten.
     *
     * Note: The texture will be copied, so the given pointer does not need 
     *       to remain valid.
     * @return A managed copy of the given texture.
     */
    std::shared_ptr<SDL_Texture> addTexture(SDL_Texture* rawTexture,
                                            const std::string& resourceID);

    /**
     * Removes the texture associated with the given path from the cache.
     *
     * @param imagePath  The original image file's full path.
     * @return true if the texture was found and removed, else false.
     */
    bool discardTexture(const std::string& imagePath);

private:
    SDL_Renderer* sdlRenderer;

    std::unordered_map<std::string, TextureHandle> textureCache;
};

} // End namespace AM

```

`Source/SharedLib/Utility/Public/BinaryBuffer.h`:

```h
#pragma once

#include <SDL_stdinc.h>
#include <vector>
#include <memory>

namespace AM
{
/** Dynamically allocated, portable buffers for bytes. */
using BinaryBuffer = std::vector<Uint8>;
using BinaryBufferPtr = std::unique_ptr<BinaryBuffer>;
using BinaryBufferSharedPtr = std::shared_ptr<BinaryBuffer>;

} // End namespace AM

```

`Source/SharedLib/Utility/Public/ByteTools.h`:

```h
#pragma once

#include <SDL_stdinc.h>

/**
 * Static functions for writing to and reading from byte buffers.
 *
 * Amalgam uses little endian ordering for network and file data.
 */
namespace AM
{
class ByteTools
{
public:
    //-------------------------------------------------------------------------
    // Byte Reading/Writing
    //-------------------------------------------------------------------------
    /**
     * Returns the 16 byte value at the given buffer address.
     */
    static Uint16 read16(const Uint8* buffer);

    /**
     * Returns the 32 byte value at the given buffer address.
     */
    static Uint32 read32(const Uint8* buffer);

    /**
     * Writes the given 16 byte value to the given buffer address.
     */
    static void write16(Uint16 value, Uint8* buffer);

    /**
     * Writes the given 32 byte value to the given buffer address.
     */
    static void write32(Uint32 value, Uint8* buffer);

    //-------------------------------------------------------------------------
    // Compression
    //-------------------------------------------------------------------------
    /**
     * Returns the size that a destination buffer should be for the efficient
     * compression of source data of the given length.
     *
     * Our compression may work if the buffer is smaller than this value, but
     * it may fail and will at least run more slowly.
     */
    static std::size_t compressBound(std::size_t sourceLength);

    /**
     * Compresses data.
     *
     * @param sourceBuffer  A buffer containing the data to compress.
     * @param sourceLength  The length of the source data.
     * @param destBuffer  The buffer to write the compressed data to.
     * @param destLength  The length of the destination buffer. See
     *                    compressBound() for more info.
     * @return The length of the compressed data.
     */
    static std::size_t compress(const Uint8* sourceBuffer,
                                std::size_t sourceLength, Uint8* destBuffer,
                                std::size_t destLength);

    /**
     * Decompresses data.
     *
     * @param sourceBuffer  A buffer containing the data to decompress.
     * @param sourceLength  The length of the source data.
     * @param destBuffer  The buffer to write the decompressed data to. Must be
     *                    long enough to hold the original data.
     * @param destLength  The length of the destination buffer.
     * @return The length of the decompressed data.
     */
    static std::size_t decompress(const Uint8* sourceBuffer,
                                  std::size_t sourceLength, Uint8* destBuffer,
                                  std::size_t destLength);
};

} // End namespace AM

```

`Source/SharedLib/Utility/Public/ConstexprTools.h`:

```h
#pragma once

namespace AM
{

/**
 * Common helper functions for constexpr use.
 *
 * Note: This shouldn't be necessary since a lot of std algorithms are
 *       constexpr in gcc, but they aren't constexpr in msvc yet.
 */
class ConstexprTools
{
public:
    /**
     * Computes the smallest integer value not less than the given value.
     *
     * Reference: https://stackoverflow.com/a/66146159/4258629
     */
    static constexpr int ceilInt(float value)
    {
        const int truncated{static_cast<int>(value)};
        return (value > truncated) ? (truncated + 1) : truncated;
    }

    /**
     * Computes the largest integer value not greater than the given value.
     *
     * Reference: https://stackoverflow.com/a/66146159/4258629
     */
    static constexpr int floorInt(float value)
    {
        const int truncated{static_cast<int>(value)};
        return (value < truncated) ? (truncated - 1) : truncated;
    }
};

} // End namespace AM

```

`Source/SharedLib/Utility/Public/Deserialize.h`:

```h
#pragma once

#include "Log.h"
#include <SDL_stdinc.h>
#include "bitsery/bitsery.h"
#include "bitsery/adapter/buffer.h"
#include "bitsery/adapter/stream.h"
#include "bitsery/traits/vector.h"
#include "bitsery/traits/array.h"
#include "bitsery/traits/string.h"
#include "bitsery/ext/std_variant.h"
#include <fstream>

namespace AM
{
class Deserialize
{
public:
    using InputAdapter = bitsery::InputBufferAdapter<const Uint8*>;

    /**
     * Deserializes the contents of the given buffer into the given object.
     *
     * Errors if deserialization fails.
     *
     * @param inputBuffer  A buffer containing the serialized bytes to
     *                     deserialize.
     * @param serializedSize  The size, in bytes, of the serialized object.
     * @param outputObject  The object to store the deserialized data in.
     * @param startIndex  Optional, how far into the buffer to start reading
     *                    bytes from.
     */
    template<typename T>
    static bool fromBuffer(const Uint8* inputBuffer, std::size_t serializedSize,
                           T& outputObject, std::size_t startIndex = 0)
    {
        // Deserialize the buffer contents into outputObject.
        std::pair<bitsery::ReaderError, bool> result
            = bitsery::quickDeserialization<InputAdapter>(
                {inputBuffer + startIndex, serializedSize}, outputObject);

        // If there was an error, print it and fail.
        if (!result.second) {
            std::string errorString{getErrorString(result.first)};

            LOG_ERROR("%s", errorString.c_str());
            return false;
        }
        else {
            return true;
        }
    }

    /**
     * Deserializes the contents of the given file into the given object.
     *
     * Errors if the file cannot be opened or deserialization fails.
     *
     * @param filePath  The file to read from.
     * @param outputObject  The object to store the deserialized data in.
     * @return false if the file could not be opened or deserialization
     *         failed, else true.
     */
    template<typename T>
    static bool fromFile(const std::string& filePath, T& outputObject)
    {
        // Open the file.
        std::ifstream file(filePath, std::ios::binary);
        if (!(file.is_open())) {
            LOG_ERROR("Failed to open file: %s", filePath.c_str());
            return false;
        }

        // Deserialize the file contents into outputObject.
        std::pair<bitsery::ReaderError, bool> result
            = bitsery::quickDeserialization<bitsery::InputStreamAdapter>(
                file, outputObject);

        // If there was an error, print it and fail.
        if (!result.second) {
            std::string errorString{getErrorString(result.first)};

            LOG_ERROR("%s", errorString.c_str());
            return false;
        }
        else {
            return true;
        }
    }

private:
    static std::string getErrorString(bitsery::ReaderError error)
    {
        std::string errorString{"Deserialization failed: "};
        switch (error) {
            case bitsery::ReaderError::DataOverflow:
                errorString += "data overflow.";
                break;
            case bitsery::ReaderError::InvalidData:
                errorString += "invalid data.";
                break;
            case bitsery::ReaderError::InvalidPointer:
                errorString += "invalid pointer.";
                break;
            case bitsery::ReaderError::ReadingError:
                errorString += "reading error.";
                break;
            default:
                break;
        }

        return errorString;
    }
};

} // End namespace AM

```

`Source/SharedLib/Utility/Public/HashTools.h`:

```h
#pragma once

#include <functional>
#include <string_view>
#include <string>

/**
 * Helper functions for hashing custom types.
 */
namespace AM
{

/**
 * Hashes the given value and adds it to the given seed.
 *
 * Based on boost::hash_combine().
 *
 * Reference:
 * https://stackoverflow.com/questions/37007307/fast-hash-function-for-stdvector
 */
template<class T>
inline void hash_combine(std::size_t& seed, T const& value)
{
    seed ^= std::hash<T>()(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

/**
 * A hashing functor that we use to enable heterogenous access, e.g.:
 *   std::unordered_map<std::string, int, string_hash, std::equal_to<>> map;
 *   map.find(std::string_view{"Hi"});
 * (notice that the key type is std::string, but we pass in a std::string_view).
 *
 * Reference: https://www.cppstories.com/2021/heterogeneous-access-cpp20/
 */
struct string_hash {
    using is_transparent = void;
    [[nodiscard]] size_t operator()(const char* txt) const
    {
        return std::hash<std::string_view>{}(txt);
    }
    [[nodiscard]] size_t operator()(std::string_view txt) const
    {
        return std::hash<std::string_view>{}(txt);
    }
    [[nodiscard]] size_t operator()(const std::string& txt) const
    {
        return std::hash<std::string>{}(txt);
    }
};

} // End namespace AM

```

`Source/SharedLib/Utility/Public/IDPool.h`:

```h
#pragma once

#include <vector>

namespace AM
{

/**
 * Provides unique identifiers.
 *
 * Note: Re-use of IDs is an issue (e.g. if client 0 disconnects and another
 *       client connects and is given ID 0, there may be old messages in the
 *       queues that refer to ID 0 that will be incorrectly applied to the new
 *       client).
 *       The current solution is to reserve more IDs than we need and always
 *       march forward, so that we don't immediately re-use the same ID.
 *       An alternative solution is to make the top ~n bits of our ID a
 *       "version", which gets incremented when the ID is freed. This is
 *       effectively the same as having extra IDs, though. The only reason to
 *       switch would be if we didn't want a static, pre-allocated pool size.
 */
class IDPool
{
public:
    /** The strategy to use when reserving IDs. */
    enum class ReservationStrategy {
         /** Marches forward, e.g. if 0-10 were reserved and freed, 11 will 
             still be the next reserved ID. After we reserve the last ID, we 
             wrap back around. This aims to remove situations where an ID was 
             reserved, freed, and re-reserved while old data exists in the 
             system. */
        MarchForward,
        ReuseLowest
    };

    /**
     * @param inStrategy The reservation strategy to use.
     * @param initialPoolSize The initial size of this ID pool. Must be > 0.
     *                        If the pool runs out of IDs, it will automatically
     *                        grow.
     */
    IDPool(ReservationStrategy inStrategy, std::size_t initialPoolSize);

    /**
     * Reserves and returns the next empty ID.
     *
     * Marches forward, e.g. if 0-10 were reserved and freed, 11 will still be
     * the next reserved ID. After we reserve the last ID, we wrap back around.
     * This, along with SAFETY_BUFFER, aims to remove situations where an ID
     * was reserved, freed, and re-reserved while old data exists in the
     * system.
     */
    unsigned int reserveID();

    /**
     * Marks the given ID as reserved.
     */
    void markIDAsReserved(unsigned int ID);

    /**
     * Frees an ID for reuse.
     */
    void freeID(unsigned int ID);

    /**
     * Frees all IDs for reuse.
     */
    void freeAllIDs();

private:
    // Note: It'd be more ideal if we didn't allocate for new IDs until the ID 
    //       was actually needed. Our logic seems simpler if we do this "pre-
    //       find the next ID" approach, though.
    /**
     * Starting at nextMarchID, finds the next free ID, wrapping and searching 
     * if necessary.
     * @post nextMarchID is set to the next free ID to use. If no IDs are 
     *       available, the IDs vector will be resized to allocate more.
     */
    void setNextMarchID();

    /**
     * Starting at nextLowestID, searches for the next free ID.
     * @post nextLowestID is set to the next free ID to use. If no IDs are 
     *       available, the IDs vector will be resized to allocate more.
     */
    void setNextLowestID();

    /** The strategy to use when reserving IDs. */
    ReservationStrategy strategy;

    /** The number of currently reserved IDs. */
    std::size_t reservedIDCount;

    /** The next ID to use for the MarchForward strategy. */
    unsigned int nextMarchID;

    /** The lowest ID that is free for use, for the ReuseLowest strategy. */
    unsigned int nextLowestID;

    /** If ID 'x' is available, IDs[x] will be true. Else, it will be false. */
    std::vector<bool> IDs;
};

} // namespace AM

```

`Source/SharedLib/Utility/Public/Log.h`:

```h
#pragma once

#include <SDL_stdinc.h>
#include <atomic>
#include <cstdlib>
#include <string>

/**
 * Use these macros instead of calling the functions directly.
 */
#define LOG_INFO(...)                                                          \
    do {                                                                       \
        AM::Log::info(__VA_ARGS__);                                            \
    } while (false)

#ifdef NDEBUG
#define LOG_DEBUG(...)                                                         \
    do {                                                                       \
    } while (false)

#define LOG_ERROR(...)                                                         \
    do {                                                                       \
        AM::Log::error(__FILE__, __LINE__, __VA_ARGS__);                       \
    } while (false)
#else
#define LOG_DEBUG(...)                                                         \
    do {                                                                       \
        AM::Log::info(__VA_ARGS__);                                            \
    } while (false)

#define LOG_ERROR(...)                                                         \
    do {                                                                       \
        AM::Log::error(__FILE__, __LINE__, __VA_ARGS__);                       \
        std::abort();                                                          \
    } while (false)
#endif

#define LOG_FATAL(...)                                                         \
    do {                                                                       \
        AM::Log::error(__FILE__, __LINE__, __VA_ARGS__);                       \
        std::abort();                                                          \
    } while (false)

namespace AM
{
/**
 * Facilitates logging info and errors to stdout or a log file.
 *
 * Our logging system has 4 levels:
 *   LOG_INFO: Print the given string in release and debug.
 *   LOG_DEBUG: Print the given string in debug.
 *   LOG_ERROR: Print file name, line number, and the given string. In debug
 *              this will also std::abort().
 *   LOG_FATAL: Print file name, line number, and the given string. In debug
 *              and release this will also std::abort().
 *
 * Use LOG_INFO for general printing, LOG_DEBUG for debug info, LOG_ERROR for 
 * recoverable errors (make sure you write appropriate recovery logic), and 
 * LOG_FATAL for unrecoverable errors.
 * Generally, we'll start error cases as LOG_FATAL, then switch them to
 * LOG_ERROR if there's some expected failure that we can't yet fix.
 */
class Log
{
public:
    static void
        registerCurrentTickPtr(const std::atomic<Uint32>* inCurrentTickPtr);

    /**
     * Prints the given info to stdout (and a file, if enableFileLogging() was
     * called.), then flushes the buffer.
     */
    static void info(const char* expression, ...);

    /**
     * Prints the given info to stdout (and a file, if enableFileLogging() was
     * called.), then flushes the buffer.
     */
    static void error(const char* fileName, int line, const char* expression,
                      ...);

    /**
     * Opens a file with the given file name and enables file logging.
     */
    static void enableFileLogging(const std::string& fileName);

private:
    /**
     * Should be passed the sim's tick through registerCurrentTickPtr.
     * Used to print a timestamp that's more relevant than wall time.
     */
    static const std::atomic<Uint32>* currentTickPtr;

    /** Used to safely test if currentTickPtr is ready to use. */
    static std::atomic<bool> tickPtrIsRegistered;
};

} /* End namespace AM */

```

`Source/SharedLib/Utility/Public/Morton.h`:

```h
#pragma once

#include <SDL_stdinc.h>

/**
 * Functions for calculating morton codes.
 * 
 * Note: We exclude the 3D morton codes because they aren't useful to us 
 *       (they waste a lot of space if your extent isn't a cube, and our Z 
 *       is almost always going to be a lot smaller than X/Y).
 *       If we ever care to use them, we can add them and change the naming 
 *       convention (e.g. encode2D32/decode2D32).
 */
namespace AM
{
class Morton
{
public:
    template<typename T>
    struct Result2D
    {
        T x{};
        T y{};
    };

    /**
     * Returns a morton code for values in the range [0, 15] using a lookup 
     * table.
     */
    static Uint8 encode16x16(Uint8 x, Uint8 y);

    /**
     * Returns the x, y values for a given morton code in the 16x16 value space.
     */
    static Result2D<Uint8> decode16x16(Uint8 code);

    /**
     * Returns a 32-bit morton code for values of up to 16 bits.
     */
    static Uint32 encode32(Uint16 x, Uint16 y);
    /**
     * Returns a 64-bit morton code for values of up to 32 bits.
     */
    static Uint64 encode64(Uint32 x, Uint32 y);

    /**
     * Returns 16-bit values for a morton code of up to 32 bits.
     */
    static Result2D<Uint16> decode32(Uint32 code);
    /**
     * Returns 32-bit values for a morton code of up to 64 bits.
     */
    static Result2D<Uint32> decode64(Uint64 code);
};

} // End namespace AM

```

`Source/SharedLib/Utility/Public/OSEventHandler.h`:

```h
#pragma once

#include <SDL_events.h>

namespace AM
{
/**
 * Simple interface to facilitate event handling and propagation.
 *
 * Specifically meant for OS events, provided by SDL2. Intra-app events have
 * other data flow paths.
 */
class OSEventHandler
{
public:
    virtual ~OSEventHandler(){};

    /**
     * Handles the given event.
     *
     * Since synchronous feedback is required, it's advised that an implementor
     * limit work done in this function. If significant time must be spent,
     * consider only doing as much work as is necessary to determine if the
     * event will be handled, and defer processing until later.
     *
     * @return true if the event has been handled and should stop propagating,
     *         else false.
     */
    virtual bool handleOSEvent(SDL_Event& event) = 0;
};

} // End namespace AM

```

`Source/SharedLib/Utility/Public/Paths.h`:

```h
#pragma once

#include <string>

namespace AM
{
/**
 * Used for accessing files in expected directories.
 *
 * The Client and ResourceImporter expect a particular asset directory
 * structure, starting at the binary's location:
 * .
 * └── Assets
 *     ├── Fonts
 *     └── Textures
 */
class Paths
{
public:
    /** The path that the application was ran from.
        Note: Use this instead of SDL_GetBasePath() to easily avoid leaking
              memory. */
    static const std::string BASE_PATH;

    /** The expected path to the root of the Fonts directory. */
    static const std::string FONT_DIR;

    /** The expected path to the root of the Textures directory. */
    static const std::string TEXTURE_DIR;
};

} // End namespace AM

```

`Source/SharedLib/Utility/Public/PeriodicCaller.h`:

```h
#pragma once

#include "Timer.h"
#include <functional>
#include <string>
#include <string_view>
#include <utility>

namespace AM
{
/**
 * A convenience class for calling a function at a particular time step.
 *
 * Useful for time-critical logic that can't afford the delays incurred by
 * using thread sleep/wake mechanisms.
 *
 * Must be fed by calling update() regularly.
 */
class PeriodicCaller
{
public:
    /**
     * See associated members for descriptions.
     */
    PeriodicCaller(std::function<void(void)> inGivenFunctNoTimestep,
                   double inTimestepS, std::string_view inDebugName,
                   bool inSkipLateSteps);

    /**
     * Overload for functions that take a timestep argument.
     * The given function will be passed the timestep in seconds.
     */
    PeriodicCaller(std::function<void(double)> inGivenFunctTimestep,
                   double inTimestepS, std::string_view inDebugName,
                   bool inSkipLateSteps);

    /**
     * Initializes the timer to the current time.
     * The timer is initialized in the constructor, but this function is
     * useful if you'd like to get all of your callers relatively synchronized.
     */
    void initTimer();

    /**
     * Updates the accumulatedTime. If enough time has passed, calls givenFunct.
     * Note: We explicitly don't forward parameters because this function is
     *       going to be called a ton. Allowing parameters would lead to a
     *       potential performance gotcha if a parameter takes time to acquire.
     */
    void update();

    /**
     * Returns how much time in seconds is left until the next call of
     * givenFunct.
     */
    double getTimeTillNextCall();

    /**
     * Returns how far we are temporally into our wait for the next call.
     * e.g. .1 if we're 10% of the way to the next call.
     */
    double getProgress();

    /**
     * Enables reporting of updates that are late by delayedTimeS or more
     * seconds.
     */
    void reportDelays(double inDelayedTimeS);

private:
    /** The function to call every timestepS seconds, if given a callback with
        no arguments. */
    const std::function<void(void)> givenFunctNoTimestep;

    /** The function to call every timestepS seconds, if given a callback that
        takes an argument of the time passed. */
    const std::function<void(double)> givenFunctTimestep;

    /** The amount of time between calls of givenFunct, in seconds. */
    const double timestepS;

    /** A name used to identify this caller for debug purposes, in case you
        only have a reference to this object and not the function owner. */
    const std::string debugName;

    /**
     * Determines behavior of update() when it detects that multiple time steps
     * have passed since the last time it was called.
     * If true, will only call givenFunct once (and log a warning).
     * If false, will call givenFunct for each time step (and log warnings).
     */
    const bool skipLateSteps;

    /** Used to time when we should call givenFunct. */
    Timer timer;

    /** The accumulated time since we last called givenFunct. */
    double accumulatedTime;

    /** An unreasonable amount of time for the update to be late by.
        If <= 0, no delay reporting will occur. */
    double delayedTimeS;
};

} // namespace AM

```

`Source/SharedLib/Utility/Public/SDLHelpers.h`:

```h
#pragma once

#include <string>
#include <SDL_rect.h>

struct SDL_Renderer;
struct SDL_Texture;
struct SDL_Window;

namespace AM
{
struct Ray;

/**
 * Static functions for working with SDL types.
 */
class SDLHelpers
{
public:
    /**
     * Converts the given SDL_Point to an SDL_FPoint.
     */
    static SDL_FPoint pointToFPoint(const SDL_Point& point);

    /**
     * Converts the given SDL_FPoint to an SDL_Point, rounding each value
     * towards zero.
     */
    static SDL_Point truncateFPoint(const SDL_FPoint& point);

    /**
     * Converts the given SDL_FPoint to an SDL_Point, rounding each value to
     * the nearest whole number.
     */
    static SDL_Point roundFPoint(const SDL_FPoint& point);

    /**
     * Converts the given SDL_Rect to an SDL_FRect.
     */
    static SDL_FRect rectToFRect(const SDL_Rect& rect);

    /**
     * Converts the given SDL_FRect to an SDL_Rect, rounding each value towards
     * zero.
     */
    static SDL_Rect truncateFRect(const SDL_FRect& rect);

    /**
     * Converts the given SDL_FRect to an SDL_Rect, rounding each value to
     * the nearest whole number.
     */
    static SDL_Rect roundFRect(const SDL_FRect& rect);

    /**
     * Saves the given texture to a png file at the given path.
     * If the file already exists, it will be overwritten.
     *
     * @return true if successful, else false.
     */
    static bool savePng(const std::string& filePath, SDL_Renderer* renderer,
                        SDL_Texture* texture);

    /**
     * Sets the fullscreen mode of the given window to the given mode.
     *
     * On failure, prints the error.
     */
    static void setWindowFullscreen(SDL_Window* window, Uint32 newMode);
};

} // namespace AM

```

`Source/SharedLib/Utility/Public/SDL_Wrappers/SDL.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{
/**
 * RAII wrapper for SDL.
 */
class SDL
{
public:
    /**
     * Initializes SDL with the given parameters.
     *
     * On init failure, prints the error and aborts.
     */
	SDL(Uint32 flags);

    ~SDL();
};

} // namespace AM

```

`Source/SharedLib/Utility/Public/SDL_Wrappers/SDLNet.h`:

```h
#pragma once

namespace AM
{
/**
 * RAII wrapper for SDL_Net.
 *
 * SDLNet_Init must be called after SDL is initialized, but before any SDLNet
 * functions are called.
 */
class SDLNet
{
public:
    SDLNet();

    ~SDLNet();
};

} // End namespace AM

```

`Source/SharedLib/Utility/Public/SDL_Wrappers/SDLRenderer.h`:

```h
#pragma once

#include <SDL_stdinc.h>

struct SDL_Window;
struct SDL_Renderer;

namespace AM
{
/**
 * RAII wrapper for SDL_Renderer.
 */
class SDLRenderer
{
public:
    /**
     * Initializes this window with the given parameters.
     *
     * On init failure, prints the error and aborts.
     */
	SDLRenderer(SDL_Window* window, int index, Uint32 flags);

    ~SDLRenderer();

    /**
     * Returns a pointer to the underlying renderer.
     */
    SDL_Renderer* get();

private:
    SDL_Renderer* renderer;
};

} // namespace AM

```

`Source/SharedLib/Utility/Public/SDL_Wrappers/SDLWindow.h`:

```h
#pragma once

#include <SDL_stdinc.h>
#include <string>

struct SDL_Window;

namespace AM
{
/**
 * RAII wrapper for SDL_Window.
 */
class SDLWindow
{
public:
    /**
     * Initializes this window with the given parameters.
     *
     * On init failure, prints the error and aborts.
     */
    SDLWindow(const std::string& title, int x, int y, int w, int h,
              Uint32 flags);

	~SDLWindow();

    /**
     * Returns a pointer to the underlying window.
     */
    SDL_Window* get();

private:
    SDL_Window* window;
};

} // namespace AM

```

`Source/SharedLib/Utility/Public/Serialize.h`:

```h
#pragma once

#include "SerializeBuffer.h"
#include "Log.h"
#include <SDL_stdinc.h>
#include "bitsery/bitsery.h"
#include "bitsery/adapter/buffer.h"
#include "bitsery/adapter/stream.h"
#include "bitsery/adapter/measure_size.h"
#include "bitsery/traits/vector.h"
#include "bitsery/traits/array.h"
#include "bitsery/traits/string.h"
#include "bitsery/ext/std_variant.h"
#include <fstream>

namespace AM
{
class Serialize
{
public:
    using OutputAdapter = bitsery::OutputBufferAdapter<SerializeBuffer>;

    /**
     * Serializes the given object, writing the serialized bytes into the given
     * outputBuffer.
     *
     * Relies on the serialization implementation to complain if an invalid
     * type is passed in.
     *
     * @param outputBuffer  The buffer to store the serialized object data in.
     * @param bufferSize  The size of the output buffer.
     * @param objectToSerialize  The object to serialize. Must be serializable.
     * @param startIndex  Optional, how far into the buffer to start writing the
     *                    serialized bytes.
     * @return The number of bytes written into outputBuffer.
     */
    template<typename T>
    static std::size_t toBuffer(Uint8* outputBuffer, std::size_t bufferSize,
                                T& objectToSerialize,
                                std::size_t startIndex = 0)
    {
        // Note: In Debug, Bitsery will assert if the serialized object size
        //       is larger than bufferSize.

        // Create the adapter manually so we can change the write offset.
        SerializeBuffer buffer{outputBuffer, bufferSize};
        OutputAdapter adapter{buffer};
        adapter.currentWritePos(startIndex);

        // Serialize and return.
        // Note: The return value will include the offset, so subtract it back
        //       out.
        return (bitsery::quickSerialization<OutputAdapter>(std::move(adapter),
                                                           objectToSerialize)
                - startIndex);
    }

    /**
     * Serializes the given object, writing the serialized bytes into the
     * given file.
     *
     * @param filePath  The file to write to.
     * @param objectToSerialize  The object to serialize. Must be serializable.
     * @return false if the file failed to open, else true.
     */
    template<typename T>
    static bool toFile(const std::string& filePath, T& objectToSerialize)
    {
        // Open or create the file.
        std::ofstream file(filePath, std::ios::binary);
        if (!(file.is_open())) {
            LOG_ERROR("Failed to open file: %s", filePath.c_str());
            return false;
        }

        // Initialize the stream serializer.
        bitsery::Serializer<bitsery::OutputBufferedStreamAdapter> serializer{
            file};
        serializer.object(objectToSerialize);

        // Serialize the object.
        serializer.adapter().flush();

        return true;
    }

    /**
     * Measures what the serialized size of the given object will be.
     * @return The serialized size of the object, in bytes.
     */
    template<typename T>
    static std::size_t measureSize(T& objectToSerialize)
    {
        return bitsery::quickSerialization(bitsery::MeasureSize{},
                                           objectToSerialize);
    }
};

} // End namespace AM

```

`Source/SharedLib/Utility/Public/SerializeBuffer.h`:

```h
#pragma once

#include <SDL_stdinc.h>
#include "bitsery/adapter/buffer.h"

namespace AM
{
/**
 * A struct that wraps a Uint8*, allowing us to use it as a buffer type for
 * serialization.
 *
 * Only used internally during serialization. Don't re-use this elsewhere.
 *
 * Note: Deserialization works fine with a raw Uint8*, but serialization
 *       requires that we define this type.
 */
struct SerializeBuffer {
    Uint8* buffer{nullptr};
    std::size_t size{0};

    Uint8* begin() const { return buffer; }

    Uint8* end() const { return (buffer + size); }
};

} // End namespace AM

/**
 * Required by Bitsery to use SerializeBuffer as a proper container.
 */
template<>
struct bitsery::traits::ContainerTraits<AM::SerializeBuffer> {
    using TValue = Uint8;
    static constexpr bool isResizable = false;
    static constexpr bool isContiguous = true;

    static void resize(AM::SerializeBuffer&, std::size_t) {}

    static std::size_t size(const AM::SerializeBuffer& buffer)
    {
        return buffer.size;
    }
};

/**
 * Required by Bitsery to use the above container as a buffer.
 */
template<>
struct bitsery::traits::BufferAdapterTraits<AM::SerializeBuffer> {
    using TIterator = Uint8*;
    using TConstIterator = const Uint8*;
    using TValue = Uint8;
};

```

`Source/SharedLib/Utility/Public/StringTools.h`:

```h
#pragma once

#include <string_view>
#include <string>

/**
 * Static functions for working with strings.
 */
namespace AM
{
class StringTools
{
public:
    /**
     * Derives a string ID from a display name by making it all lowercase and
     * replacing spaces with underscores.
     *
     * Note: This uses an out param instead of returning the string because it's
     *       used in performance-sensitive situations where we need to re-use 
     *       a pre-allocated string.
     */
    static void deriveStringID(std::string_view displayName, std::string& dest);

    /**
     * Returns the name of the file at the given path, including extension.
     */
    static std::string_view getFileName(std::string_view filePath);

    /**
     * Returns the name of the file at the given path, with no extension.
     */
    static std::string_view getFileNameNoExtension(std::string_view filePath);

    /**
     * Returns true if pathA starts with the characters in pathB, ignoring 
     * differences in slash type used ('/' vs '\').
     */
    static bool pathStartsWith(std::string_view pathA, std::string_view pathB);
};

} // End namespace AM

```

`Source/SharedLib/Utility/Public/Timer.h`:

```h
#pragma once

#include <SDL_stdinc.h>

namespace AM
{
/**
 * Uses the SDL high resolution timer to produce time deltas.
 */
class Timer
{
public:
    Timer();

    /**
     * Returns the amount of time that this timer has been running.
     *
     * @return The amount of time in seconds since the saved time was last
     *         updated.
     */
    double getTime();

    /**
     * Resets this timer to 0.
     */
    void reset();

    /**
     * Returns the amount of time that this timer has been running, then
     * resets it to 0.
     */
    double getTimeAndReset();

    /**
     * Returns a monotonic amount of time since this function was first called 
     * (usually during app startup).
     */
    static double getGlobalTime();

private:
    /** How fast the processor is running. SDL sets this once on init and 
        never changes it.  */
    double period;

    /** The saved time in integer ticks from SDL_GetPerformanceCounter(). */
    Uint64 savedTimestamp;
};

} // namespace AM

```

`Source/SharedLib/Utility/Public/Transforms.h`:

```h
#pragma once

#include "TilePosition.h"
#include "Vector3.h"
#include "BoundingBox.h"
#include "Ray.h"
#include "SharedConfig.h"
#include <SDL_rect.h>
#include <optional>

namespace AM
{
struct Sprite;
struct Camera;
struct Position;

/**
 * Static functions for transforming between world, screen, and model space.
 */
class Transforms
{
public:
    /**
     * Converts a point in world space to a point in screen space.
     *
     * @param zoomFactor The camera's zoom factor.
     */
    static SDL_FPoint worldToScreen(const Vector3& point, float zoomFactor);

    /**
     * Converts a Z coordinate in world space to a Y coordinate in screen space.
     *
     * @param zoomFactor The camera's zoom factor.
     */
    static float worldZToScreenY(float zCoord, float zoomFactor);

    /**
     * Converts a point in screen space to a point in world space, with 
     * Z == 0.
     * Note: Since this is just a simple conversion, we don't do any bounds 
     *       checking. It's on you to make sure the returned value is valid.
     */
    static Vector3 screenToWorldMinimum(const SDL_FPoint& screenPoint,
                                        const Camera& camera);

    /**
     * Converts a point in screen space to a point in world space, with 
     * Z == camera.target.z.
     * @return If screenPoint doesn't intersect the camera's view bounds, 
     *         returns null.
     */
    static std::optional<Vector3>
        screenToWorldTarget(const SDL_FPoint& screenPoint,
                            const Camera& camera);

    /**
     * Converts a point in screen space to a ray in world space.
     * @return If successful, returns a ray starting at the closest intersection
     *         between screenPoint and the camera's view bounds, pointing in 
     *         the normalized direction that the camera is facing.
     *         If screenPoint doesn't intersect the camera's view bounds, 
     *         returns null.
     *
     * Note: This can return null if the camera is zoomed out. We don't change
     *       the camera position or expand the view bounds when zooming (zoom 
     *       is just done by scaling), so you can end up seeing outside of the 
     *       camera's view bounds.
     */
    static std::optional<Ray> screenToWorldRay(const SDL_FPoint& screenPoint,
                                               const Camera& camera);

    /**
     * Converts a Y coordinate in screen space to a Z coordinate in world space.
     *
     * @param zoomFactor The camera's zoom factor.
     */
    static float screenYToWorldZ(float yCoord, float zoomFactor);

    /**
     * Places the given model-space bounding volume at the given tile position.
     */
    static BoundingBox modelToWorldTile(const BoundingBox& modelBounds,
                                        const TilePosition& tilePosition);

    /**
     * Centers the given model-space bounding volume on the given position.
     */
    static BoundingBox modelToWorldEntity(const BoundingBox& modelBounds,
                                          const Position& position);

    //-------------------------------------------------------------------------
    // Constants
    //-------------------------------------------------------------------------
    /** The scaling factor to use when going from world tiles to screen tiles. */
    static constexpr float TILE_FACE_WIDTH_WORLD_TO_SCREEN{
        static_cast<float>(SharedConfig::TILE_FACE_SCREEN_WIDTH)
        / SharedConfig::TILE_WORLD_WIDTH};
    static constexpr float TILE_FACE_HEIGHT_WORLD_TO_SCREEN{
        static_cast<float>(SharedConfig::TILE_FACE_SCREEN_HEIGHT)
        / SharedConfig::TILE_WORLD_WIDTH};
    static constexpr float TILE_SIDE_HEIGHT_WORLD_TO_SCREEN{
        static_cast<float>(SharedConfig::TILE_SIDE_SCREEN_HEIGHT)
        / SharedConfig::TILE_WORLD_HEIGHT};

    /** The scaling factor to use when going from screen tiles to world tiles. */
    static constexpr float TILE_FACE_WIDTH_SCREEN_TO_WORLD{
        static_cast<float>(SharedConfig::TILE_WORLD_WIDTH)
        / SharedConfig::TILE_FACE_SCREEN_WIDTH};
    static constexpr float TILE_FACE_HEIGHT_SCREEN_TO_WORLD{
        static_cast<float>(SharedConfig::TILE_WORLD_WIDTH)
        / SharedConfig::TILE_FACE_SCREEN_HEIGHT};
    static constexpr float TILE_SIDE_HEIGHT_SCREEN_TO_WORLD{
        static_cast<float>(SharedConfig::TILE_WORLD_HEIGHT)
        / SharedConfig::TILE_SIDE_SCREEN_HEIGHT};
};

} // End namespace AM

```

`Source/SharedLib/Utility/Public/VariantTools.h`:

```h
#pragma once

namespace AM
{

/**
 * Common helper functions for std::variant use.
 */
namespace VariantTools
{

template<typename... Ts>
struct Overload : Ts... {
    using Ts::operator()...;
};

template<class... Ts>
Overload(Ts...) -> Overload<Ts...>;

}

} // End namespace AM

```

`Source/Tests/CMakeLists.txt`:

```txt
# Configure tests.
add_subdirectory(TestSandboxes)

#add_subdirectory(UnitTests)

```

`Source/Tests/TestSandboxes/CMakeLists.txt`:

```txt
# Build test apps.
#add_subdirectory(Graphics)

add_subdirectory(Network)

```

`Source/Tests/TestSandboxes/Graphics/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.5)

message(STATUS "Configuring Graphics Test Apps")

# Latency test client
add_executable(FrameTimeTest
    Private/FrameTimeTestMain.cpp
)

target_include_directories(FrameTimeTest
    PRIVATE
        ${SDL2_INCLUDE_DIRS}
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
)

target_link_libraries(FrameTimeTest
    PRIVATE
        ${SDL2_LIBRARIES}
        Shared
)

target_compile_features(FrameTimeTest PRIVATE cxx_std_23)
set_target_properties(FrameTimeTest PROPERTIES CXX_EXTENSIONS OFF)

```

`Source/Tests/TestSandboxes/Graphics/Private/FrameTimeTestMain.cpp`:

```cpp
/*
 * This program was copied from:
 * https://discourse.libsdl.org/t/sdl2-0-6-stuttering-problem/23220/2
 *
 * Instructions:
 * The graph shows full frame time (green) and SDL_RenderPresent time (red).
 * The horizontal blue line is the 1/60 millisecond mark. You’d expect the green
 * line to be near that if vsync is enabled and the refresh rate is at 60 Hz.
 * Additionally, in its big version (toggle by pressing B), the graph shows
 * event time (pink), update time (white), clear time (yellow), draw time (light
 * blue). Red, pink, white, yellow, and light blue are stacked on top of each
 * other and add up to the green line.
 *
 * Other controls:
 *
 * Space: Toggle pause
 * 1: Toggle frame graph line
 * 2: Toggle event graph line
 * 3: Toggle update graph line
 * 4: Toggle clear graph line
 * 5: Toggle draw graph line
 * 6: Toggle swap graph line
 * i: Toggle interpolation of square (like your sample code does)
 * r: Add random delay after updating square position
 * p: Toggle between millisecond and microsecond counters
 * b: Toggle graph size
 * Escape: Quit
 *
 * Try setting the environment variable SDL_RENDER_VSYNC to 1 to force vsync on.
 * You can also try the other renderers with the environment variable
 * SDL_RENDER_DRIVER. Possible values are: opengl, opengles, opengles2,
 * direct3d, direct3d11, software. (Depends on the platform and if SDL was built
 * with that renderer enabled.)
 */

#include <iostream>
#include <string>
#include <deque>
#include <cmath>
#include <algorithm>
#include <vector>

#include "Ignore.h"

#include <SDL.h>

#define FRAMETIME_COUNT 200

class Player
{
public:
    Player();

    void update(const double tick_rate);
    void draw(SDL_Renderer* renderer, const double alpha, int width,
              int height);

    double x, y, px, py, vx, vy, ax, ay;
};

struct FrameTime {
    double full, event, update, clear, draw, swap;
};

class Window
{
public:
    Window();

    void init();
    void quit();

    void run();
    void drawgraph();
    void settitle();

    void clear();
    void swap();

    SDL_Window* handle;
    SDL_Renderer* renderer;
    int width, height;
    bool pause;
    bool interpolate;
    bool highprecision;
    bool randomdelay;
    bool biggraph;
    bool showfullline;
    bool showeventline;
    bool showupdateline;
    bool showclearline;
    bool showdrawline;
    bool showswapline;
    Player player;

    std::deque<FrameTime> frametime;
    std::vector<SDL_Point> full_line;
    std::vector<SDL_Point> event_line;
    std::vector<SDL_Point> update_line;
    std::vector<SDL_Point> clear_line;
    std::vector<SDL_Point> draw_line;
    std::vector<SDL_Point> swap_line;
};

static Uint32 xstate = 905309021;
static Uint32 xorshift()
{
    xstate ^= xstate << 13;
    xstate ^= xstate >> 17;
    xstate ^= xstate << 5;
    return xstate;
}

Player::Player()
: x(0.1)
, y(0.9)
, vx(0.35)
, vy(0)
, ax(0)
, ay(-0.5)
{
}

void Player::update(const double tick_rate)
{
    px = x;
    py = y;

    vx += ax * tick_rate;
    vy += ay * tick_rate;

    x += vx * tick_rate;
    y += vy * tick_rate;

    if (x < 0 || x > 1) {
        x = x < 0 ? -x : x - (x - 1);
        vx = -vx;
    }
    if (y < 0 || y > 1) {
        y = y < 0 ? -y : y - (y - 1);
        vy = -vy;
    }
}

void Player::draw(SDL_Renderer* renderer, const double alpha, int width,
                  int height)
{
    const double interp_x = x * alpha + px * (1.0 - alpha);
    const double interp_y = 1 - (y * alpha + py * (1.0 - alpha));
    const int int_x = static_cast<int>(floor(interp_x * (width - 20) + 0.5));
    const int int_y = static_cast<int>(floor(interp_y * (height - 20) + 0.5));
    const SDL_Rect draw_rect = {int_x, int_y, 20, 20};

    SDL_SetRenderDrawColor(renderer, 255, 255, 0, 255);
    SDL_RenderFillRect(renderer, &draw_rect);
}

Window::Window()
: handle(0)
, renderer(0)
, pause(false)
, interpolate(true)
, highprecision(false)
, randomdelay(false)
, biggraph(false)
, showfullline(true)
, showeventline(true)
, showupdateline(true)
, showclearline(true)
, showdrawline(true)
, showswapline(true)
, full_line(FRAMETIME_COUNT)
, event_line(FRAMETIME_COUNT)
, update_line(FRAMETIME_COUNT)
, clear_line(FRAMETIME_COUNT)
, draw_line(FRAMETIME_COUNT)
, swap_line(FRAMETIME_COUNT)
{
}

void Window::init()
{
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS) < 0)
        throw "Could not init SDL";

    handle = SDL_CreateWindow("Loading...", SDL_WINDOWPOS_CENTERED,
                              SDL_WINDOWPOS_CENTERED, 800, 500,
                              SDL_WINDOW_RESIZABLE);
    if (!handle)
        throw "Could not create window";

    renderer = SDL_CreateRenderer(handle, -1, 0);
    if (!renderer)
        throw "Could not create renderer";

    SDL_GetWindowSize(handle, &width, &height);
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);

    //    SDL_SetWindowFullscreen(handle, SDL_WINDOW_FULLSCREEN);

    settitle();

    clear();
    swap();
}

void Window::quit()
{
    if (renderer)
        SDL_DestroyRenderer(renderer);
    if (handle)
        SDL_DestroyWindow(handle);
    if (SDL_WasInit(SDL_INIT_EVERYTHING))
        SDL_Quit();
}

void Window::drawgraph()
{
    double graph_x_step = width / (double) (FRAMETIME_COUNT - 1);
    int graph_height
        = biggraph ? height : (int) floor(std::max(height * 0.15, 10.));
    int graph_top_y = height - graph_height;
    int graph_mid_y = height - graph_height / 2;

    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 100);
    SDL_Rect bg = {0, graph_top_y, width, graph_height};
    SDL_RenderFillRect(renderer, &bg);
    SDL_SetRenderDrawColor(renderer, 180, 180, 180, 200);
    SDL_RenderDrawLine(renderer, 0, graph_top_y, width, graph_top_y);
    SDL_SetRenderDrawColor(renderer, 100, 100, 220, 200);
    SDL_RenderDrawLine(renderer, 0, graph_mid_y, width, graph_mid_y);

#define TRANSFORM_X(I) ((int) floor((I) *graph_x_step + 0.5))
#define TRANSFORM_Y(S)                                                         \
    (height - 1 - (int) floor(((S) / (1. / 60. * 2)) * graph_height + 0.5))

    size_t samplecount = frametime.size();
    if (samplecount < 2)
        return;

    for (size_t i = 0; i < samplecount; i++) {
        FrameTime& times = frametime.at(i);

        full_line[i].x = TRANSFORM_X(i);
        event_line[i].x = full_line[i].x;
        update_line[i].x = full_line[i].x;
        clear_line[i].x = full_line[i].x;
        draw_line[i].x = full_line[i].x;
        swap_line[i].x = full_line[i].x;

        full_line[i].y = TRANSFORM_Y(times.full);

        double s = times.swap;
        swap_line[i].y = TRANSFORM_Y(s);
        s += times.draw;
        draw_line[i].y = TRANSFORM_Y(s);
        if (swap_line[i].y == draw_line[i].y)
            draw_line[i].y--;
        s += times.clear;
        clear_line[i].y = TRANSFORM_Y(s);
        if (draw_line[i].y == clear_line[i].y)
            clear_line[i].y--;
        s += times.update;
        update_line[i].y = TRANSFORM_Y(s);
        if (clear_line[i].y == update_line[i].y)
            update_line[i].y--;
        s += times.event;
        event_line[i].y = TRANSFORM_Y(s);
        if (update_line[i].y == event_line[i].y)
            event_line[i].y--;
    }

    if (biggraph) {
        if (showeventline) {
            SDL_SetRenderDrawColor(renderer, 255, 102, 255, 200);
            SDL_RenderDrawLines(renderer, event_line.data(), (int) samplecount);
        }
        if (showupdateline) {
            SDL_SetRenderDrawColor(renderer, 255, 255, 255, 200);
            SDL_RenderDrawLines(renderer, update_line.data(),
                                (int) samplecount);
        }
        if (showclearline) {
            SDL_SetRenderDrawColor(renderer, 255, 255, 0, 200);
            SDL_RenderDrawLines(renderer, clear_line.data(), (int) samplecount);
        }
        if (showdrawline) {
            SDL_SetRenderDrawColor(renderer, 200, 200, 255, 200);
            SDL_RenderDrawLines(renderer, draw_line.data(), (int) samplecount);
        }
    }

    if (showswapline) {
        SDL_SetRenderDrawColor(renderer, 255, 0, 0, 200);
        SDL_RenderDrawLines(renderer, swap_line.data(), (int) samplecount);
    }
    if (showfullline) {
        SDL_SetRenderDrawColor(renderer, 0, 255, 0, 200);
        SDL_RenderDrawLines(renderer, full_line.data(), (int) samplecount);
    }
}

void Window::clear()
{
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0);
    SDL_RenderClear(renderer);
}

void Window::swap()
{
    SDL_RenderPresent(renderer);
}

void Window::settitle()
{
    static std::string title(128, 0);

    SDL_RendererInfo info;
    SDL_GetRendererInfo(renderer, &info);
    title.assign(info.name);
    title.append(interpolate ? ", interpolating position"
                             : ", not interpolating");
    title.append(highprecision ? ", microsec counter" : ", millisec counter");
    if (randomdelay)
        title.append(", random delay");

    SDL_SetWindowTitle(handle, title.c_str());
}

static double Timer(bool highprecision)
{
    if (highprecision) {
        static double period = 1. / SDL_GetPerformanceFrequency();
        return SDL_GetPerformanceCounter() * period;
    }
    return SDL_GetTicks() / 1000.0;
}

void Window::run()
{
    SDL_Event e;
    FrameTime ft;

    int run = 1;

    double time_last_event = Timer(highprecision);
    double accumulator = 0.0;
    double tick_rate = 1.0 / 60.0;

    while (run) {
        double time_frame_start = Timer(highprecision);

        while (SDL_PollEvent(&e)) {
            if (e.type == SDL_QUIT) {
                run = 0;
            }
            else if (e.type == SDL_KEYUP) {
                Uint32 sym = e.key.keysym.sym;
                if (sym == SDLK_ESCAPE) {
                    run = 0;
                }
                else if (sym == SDLK_SPACE) {
                    pause = !pause;
                }
                else if (sym == SDLK_1) {
                    showfullline = !showfullline;
                }
                else if (sym == SDLK_2) {
                    showeventline = !showeventline;
                }
                else if (sym == SDLK_3) {
                    showupdateline = !showupdateline;
                }
                else if (sym == SDLK_4) {
                    showclearline = !showclearline;
                }
                else if (sym == SDLK_5) {
                    showdrawline = !showdrawline;
                }
                else if (sym == SDLK_6) {
                    showswapline = !showswapline;
                }
                else if (sym == SDLK_i) {
                    interpolate = !interpolate;
                    settitle();
                }
                else if (sym == SDLK_p) {
                    highprecision = !highprecision;
                    double difference
                        = Timer(highprecision) - Timer(!highprecision);
                    time_frame_start += difference;
                    time_last_event += difference;
                    settitle();
                }
                else if (sym == SDLK_r) {
                    randomdelay = !randomdelay;
                    settitle();
                }
                else if (sym == SDLK_b) {
                    biggraph = !biggraph;
                }
            }
            else if (e.type == SDL_WINDOWEVENT) {
                if (e.window.event == SDL_WINDOWEVENT_RESIZED
                    || e.window.event == SDL_WINDOWEVENT_SIZE_CHANGED) {
                    width = e.window.data1;
                    height = e.window.data2;
                }
            }
        }

        const double time_event = Timer(highprecision);
        double last_frame_time = time_event - time_last_event;
        time_last_event = time_event;

        if (!pause) {
            if (last_frame_time > 0.25)
                last_frame_time = 0.25;

            accumulator += last_frame_time;

            while (accumulator >= tick_rate) {
                player.update(tick_rate);
                accumulator -= tick_rate;
            }
        }

        const double alpha = accumulator / tick_rate;

        if (randomdelay) {
            double delay_end
                = Timer(highprecision) + (xorshift() % 16 + 5) / 1000.;
            while (delay_end >= Timer(highprecision)) {
            }
        }

        const double time_update = Timer(highprecision);

        clear();

        const double time_clear = Timer(highprecision);

        player.draw(renderer, interpolate ? alpha : 1, width, height);
        drawgraph();

        const double time_draw = Timer(highprecision);

        swap();

        const double time_swap = Timer(highprecision);

        if (pause)
            continue;

        ft.full = time_swap - time_frame_start;
        ft.event = time_event - time_frame_start;
        ft.update = time_update - time_event;
        ft.clear = time_clear - time_update;
        ft.draw = time_draw - time_clear;
        ft.swap = time_swap - time_draw;

        if (frametime.size() >= FRAMETIME_COUNT)
            frametime.pop_front();
        frametime.push_back(ft);
    }
}

int main(int argc, char* argv[])
{
    AM::ignore(argc);
    AM::ignore(argv);

    Uint64 t = SDL_GetPerformanceCounter();
    xstate = (Uint32) (t | (t >> 32));

    Window window;

    try {
        window.init();
        window.run();
    } catch (const char* msg) {
        std::cout << msg << std::endl;
    } catch (...) {
        std::cout << "Unexpected exception" << std::endl;
    }

    window.quit();

    return 0;
}

```

`Source/Tests/TestSandboxes/Network/CMakeLists.txt`:

```txt
# Build test apps.
#add_subdirectory(ClockTest)

#add_subdirectory(DriftTest)

#add_subdirectory(LatencyTest)

add_subdirectory(LoadTest)

```

`Source/Tests/TestSandboxes/Network/ClockTest/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.5)

message(STATUS "Configuring Clock Test")

# Clock test client
add_executable(ClockTestClient
    Private/ClockTestClientMain.cpp
)
target_include_directories(ClockTestClient
    PRIVATE
        ${SDL2_INCLUDE_DIRS}
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
)
target_link_libraries(ClockTestClient
    PRIVATE
        ${SDL2_LIBRARIES}
        SDL2_net-static
        SharedLib
)
target_compile_features(ClockTestClient PRIVATE cxx_std_23)
set_target_properties(ClockTestClient PROPERTIES CXX_EXTENSIONS OFF)

# Clock test server
add_executable(ClockTestServer
    Private/ClockTestServerMain.cpp
)
target_include_directories(ClockTestServer
    PRIVATE
        ${SDL2_INCLUDE_DIRS}
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
)
target_link_libraries(ClockTestServer
    PRIVATE
        ${SDL2_LIBRARIES}
        SDL2_net-static
        SharedLib
)
target_compile_features(ClockTestServer PRIVATE cxx_std_23)
set_target_properties(ClockTestServer PROPERTIES CXX_EXTENSIONS OFF)

```

`Source/Tests/TestSandboxes/Network/ClockTest/Private/ClockTestClientMain.cpp`:

```cpp
#include "SDL.h"
#include "SDL_net.h"
#include <string>
#include <vector>
#include <array>
#include <atomic>
#include <cstdio>
#include "Timer.h"
#include "Log.h"
#include "Ignore.h"

// const std::string SERVER_IP = "127.0.0.1";
const std::string SERVER_IP = "45.79.37.63";
static constexpr unsigned int SERVER_PORT = 41499;

using namespace AM;

int main(int argc, char* argv[])
{
    // SDL2 needs this signature for main, but we don't use the parameters.
    ignore(argc);
    ignore(argv);

    if (SDL_Init(0) == -1) {
        LOG_INFO("SDL_Init: %s", SDLNet_GetError());
        return 1;
    }
    if (SDLNet_Init() == -1) {
        LOG_INFO("SDLNet_Init: %s", SDLNet_GetError());
        return 2;
    }

    LOG_INFO("Connecting to server.");

    IPaddress ip;
    if (SDLNet_ResolveHost(&ip, SERVER_IP.c_str(), SERVER_PORT)) {
        LOG_INFO("Could not resolve host.");
        return 3;
    }

    TCPsocket serverSocket = SDLNet_TCP_Open(&ip);
    if (!serverSocket) {
        LOG_INFO("Could not open serverSocket.");
        return 4;
    }
    LOG_INFO("Connected.");

    /* Wait for 5s to let the connection settle. */
    Timer timer;
    while (timer.getTime() < 5) {
        SDL_Delay(1);
    }

    /* Send the start byte, wait for the desired time, then send the end byte.
     */
    // Send the start byte.
    std::array<Uint8, 1> sendBuf = {5};
    int bytesSent = SDLNet_TCP_Send(serverSocket, &sendBuf, 1);
    if (bytesSent < 1) {
        LOG_INFO("Failed to send all bytes.");
        return 5;
    }

    // Wait for the desired time.
    timer.reset();
    while (timer.getTime() < 1200) {
        SDL_Delay(1);
    }

    // Send the end byte.
    sendBuf[0] = 6;
    bytesSent = SDLNet_TCP_Send(serverSocket, &sendBuf, 1);
    if (bytesSent < 1) {
        LOG_INFO("Failed to send all bytes.");
        return 5;
    }
    LOG_INFO("Sent end byte. Time passed: ~%.8f", timer.getTimeAndReset());

    return 0;
}

```

`Source/Tests/TestSandboxes/Network/ClockTest/Private/ClockTestServerMain.cpp`:

```cpp
#include "SDL.h"
#include "SDL_net.h"
#include <array>
#include <atomic>
#include <thread>
#include "Timer.h"
#include "Log.h"
#include "Ignore.h"
#include <iostream>

static constexpr int SERVER_PORT = 41499;

using namespace AM;

int main(int argc, char* argv[])
{
    // SDL2 needs this signature for main, but we don't use the parameters.
    ignore(argc);
    ignore(argv);

    if (SDL_Init(0) == -1) {
        LOG_INFO("SDL_Init: %s", SDLNet_GetError());
        return 1;
    }
    if (SDLNet_Init() == -1) {
        LOG_INFO("SDLNet_Init: %s", SDLNet_GetError());
        return 2;
    }

    /* Set up the listener. */
    IPaddress ip;
    TCPsocket serverSocket = nullptr;
    if (SDLNet_ResolveHost(&ip, NULL, SERVER_PORT)) {
        LOG_INFO("%s", SDLNet_GetError());
    }

    serverSocket = SDLNet_TCP_Open(&ip);
    if (!serverSocket) {
        LOG_INFO("%s", SDLNet_GetError());
    }

    TCPsocket clientSocket = nullptr;
    SDLNet_SocketSet clientSet = SDLNet_AllocSocketSet(1);

    Timer timer;
    LOG_INFO("Server started.");

    LOG_INFO("Waiting for client connection.");
    while (clientSocket == nullptr) {
        clientSocket = SDLNet_TCP_Accept(serverSocket);

        // If we got a connection, add the socket to the set.
        if (clientSocket != nullptr) {
            int numAdded = SDLNet_TCP_AddSocket(clientSet, clientSocket);
            if (numAdded < 1) {
                LOG_INFO("Error while adding socket: %s", SDLNet_GetError());
            }
        }
    }

    // Wait for the start byte.
    LOG_INFO("Received client connection. Waiting for start byte.");
    std::array<Uint8, 1> recBuffer = {};
    bool waitingForStart = true;
    while (waitingForStart) {
        int numReady = SDLNet_CheckSockets(clientSet, 0);
        if (numReady == 1) {
            // Receive the waiting data.
            int result = SDLNet_TCP_Recv(clientSocket, &recBuffer, 1);
            if (result <= 0) {
                LOG_FATAL("Detected disconnect.");
            }
            else if (recBuffer[0] != 5) {
                LOG_FATAL("Wrong start byte received.");
            }
            else {
                // Got the start byte, start timing and proceed.
                timer.reset();
                waitingForStart = false;
                LOG_INFO("Received start byte.");
            }
        }
    }

    // Wait for the end byte.
    bool waitingForEnd = true;
    while (waitingForEnd) {
        int numReady = SDLNet_CheckSockets(clientSet, 0);
        if (numReady == 1) {
            // Receive the waiting data.
            int result = SDLNet_TCP_Recv(clientSocket, &recBuffer, 1);
            if (result <= 0) {
                LOG_FATAL("Detected disconnect.");
            }
            else if (recBuffer[0] != 6) {
                LOG_FATAL("Wrong end byte received.");
            }
            else {
                LOG_INFO("Received end byte. Time passed: %.8f",
                         timer.getTime());
                waitingForEnd = false;
            }
        }
    }

    return 0;
}

```

`Source/Tests/TestSandboxes/Network/DriftTest/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.5)

message(STATUS "Configuring Drift Test")

# Drift test client
add_executable(DriftTestClient
    Private/DriftTestClientMain.cpp
)
target_include_directories(DriftTestClient
    PRIVATE
        ${SDL2_INCLUDE_DIRS}
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
)
target_link_libraries(DriftTestClient
    PRIVATE
        ${SDL2_LIBRARIES}
        SDL2_net-static
        SharedLib
)
target_compile_features(DriftTestClient PRIVATE cxx_std_23)
set_target_properties(DriftTestClient PROPERTIES CXX_EXTENSIONS OFF)

# Drift test server
add_executable(DriftTestServer
    Private/DriftTestServerMain.cpp
)
target_include_directories(DriftTestServer
    PRIVATE
        ${SDL2_INCLUDE_DIRS}
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
)
target_link_libraries(DriftTestServer
    PRIVATE
        ${SDL2_LIBRARIES}
        SDL2_net-static
        SharedLib
)
target_compile_features(DriftTestServer PRIVATE cxx_std_23)
set_target_properties(DriftTestServer PROPERTIES CXX_EXTENSIONS OFF)

```

`Source/Tests/TestSandboxes/Network/DriftTest/Private/DriftTestClientMain.cpp`:

```cpp
#include "SDL.h"
#include "SDL_net.h"
#include <string>
#include <vector>
#include <array>
#include <atomic>
#include <cstdio>
#include "Timer.h"
#include "Log.h"
#include "Ignore.h"

const std::string SERVER_IP = "127.0.0.1";
// const std::string SERVER_IP = "45.79.37.63";
static constexpr unsigned int SERVER_PORT = 41499;

static constexpr double TEST_GAME_TICK_INTERVAL_S = 1 / 30.0;
/** An unreasonable amount of time for the game tick to be late by. */
static constexpr double TEST_GAME_DELAYED_TIME_S = .001;
static constexpr unsigned int NUM_BYTES = 55;

using namespace AM;

/** Waits for the server to send its current tick. */
bool waitForServer(TCPsocket& serverSocket, std::atomic<Uint32>& currentTick)
{
    std::array<Uint8, sizeof(Uint32)> tickBuf = {};

    bool messageReceived = false;
    while (!messageReceived) {
        int result = SDLNet_TCP_Recv(serverSocket, &tickBuf, sizeof(Uint32));
        if (result < 0) {
            // Disconnected
            LOG_INFO("Detected disconnect.");
            return false;
        }
        else if (result != sizeof(Uint32)) {
            LOG_INFO("Didn't receive current tick properly.");
            return false;
        }
        else {
            // +5 to put us in a reference frame ahead of the server.
            currentTick = _SDLNet_Read32(&tickBuf) + 5;
            Debug::info("Current tick received: %u", currentTick.load());
            return true;
        }
    }

    return false;
}

int main(int argc, char* argv[])
{
    // SDL2 needs this signature for main, but we don't use the parameters.
    ignore(argc);
    ignore(argv);

    if (SDL_Init(0) == -1) {
        LOG_INFO("SDL_Init: %s", SDLNet_GetError());
        return 1;
    }
    if (SDLNet_Init() == -1) {
        LOG_INFO("SDLNet_Init: %s", SDLNet_GetError());
        return 2;
    }

    LOG_INFO("Connecting to server.");

    IPaddress ip;
    if (SDLNet_ResolveHost(&ip, SERVER_IP.c_str(), SERVER_PORT)) {
        LOG_INFO("Could not resolve host.");
        return 3;
    }

    TCPsocket serverSocket = SDLNet_TCP_Open(&ip);
    if (!serverSocket) {
        LOG_INFO("Could not open serverSocket.");
        return 4;
    }
    LOG_INFO("Connected.");

    /* Prepare the simulation variables. */
    // The aggregated time since we last processed a tick.
    double accumulatedTime = 0;
    // The number of the tick that we're currently on.
    std::atomic<Uint32> currentTick = 0;
    Debug::registerCurrentTickPtr(&currentTick);

    /* Prepare the data */
    // The data to send. The first 4 bytes will be replaced with the current
    // tick while running, the rest is filler.
    std::array<Uint8, NUM_BYTES> dataBuffer = {};
    for (unsigned int i = 0; i < NUM_BYTES; ++i) {
        dataBuffer[i] = NUM_BYTES % UINT8_MAX;
    }

    /* Wait to receive the server's current tick. */
    bool result = waitForServer(serverSocket, currentTick);
    if (!result) {
        LOG_FATAL("Failed to get server's current tick.");
    }

    // Prime a timer.
    Timer timer;
    while (true) {
        // Calc the time delta.
        double deltaSeconds = timer.getTimeAndReset();

        /* Process as many game ticks as have accumulated. */
        accumulatedTime += deltaSeconds;
        while (accumulatedTime >= TEST_GAME_TICK_INTERVAL_S) {
            /* Send our message. */
            _SDLNet_Write32(currentTick, &dataBuffer);
            int bytesSent
                = SDLNet_TCP_Send(serverSocket, &dataBuffer, NUM_BYTES);
            if (bytesSent < static_cast<int>(NUM_BYTES)) {
                LOG_INFO("Failed to send all bytes.");
                return 5;
            }

            /* Prepare for the next tick. */
            accumulatedTime -= TEST_GAME_TICK_INTERVAL_S;
            if (accumulatedTime >= TEST_GAME_TICK_INTERVAL_S) {
                LOG_INFO("Detected a request for multiple game ticks in the "
                         "same frame. Game tick "
                         "must have been massively delayed. Game tick was "
                         "delayed by: %.8fs.",
                         accumulatedTime);
            }
            else if (accumulatedTime >= TEST_GAME_DELAYED_TIME_S) {
                // Game missed its ideal call time, could be our issue or
                // general system slowness.
                LOG_INFO("Detected a delayed game tick. Game tick was delayed "
                         "by: %.8fs.",
                         accumulatedTime);
            }

            currentTick++;
        }
    }

    return 0;
}

```

`Source/Tests/TestSandboxes/Network/DriftTest/Private/DriftTestServerMain.cpp`:

```cpp
#include "SDL.h"
#include "SDL_net.h"
#include <array>
#include <atomic>
#include <thread>
#include "Timer.h"
#include "Log.h"
#include "Ignore.h"
#include <iostream>

static constexpr int SERVER_PORT = 41499;

static constexpr double TEST_GAME_TICK_INTERVAL_S = 1 / 30.0;
/** An unreasonable amount of time for the game tick to be late by. */
static constexpr double TEST_GAME_DELAYED_TIME_S = .001;
static constexpr unsigned int NUM_BYTES = 55;

using namespace AM;

/** Exits if the user types exit. */
int inputThread(std::atomic<bool>* exitRequested)
{
    while (!(*exitRequested)) {
        std::string userInput = "";
        std::getline(std::cin, userInput);
        if (userInput == "exit") {
            *exitRequested = true;
        }
    }

    return 0;
}

/** Checks for new client connections, sends our current tick to new clients. */
void updateConnection(TCPsocket& serverSocket, TCPsocket& clientSocket,
                      SDLNet_SocketSet& clientSet, Uint32 currentTick)
{
    // Check for a connection.
    if (clientSocket == nullptr) {
        clientSocket = SDLNet_TCP_Accept(serverSocket);

        // If we got a connection, add the socket to the set.
        if (clientSocket != nullptr) {
            int numAdded = SDLNet_TCP_AddSocket(clientSet, clientSocket);
            if (numAdded < 1) {
                LOG_INFO("Error while adding socket: %s", SDLNet_GetError());
            }
            else {
                // Connected, send our current tick.
                // +1 because we'll have finished the tick by the time the
                // client gets this.
                Uint32 tickToSend = currentTick + 1;
                std::array<Uint8, sizeof(Uint32)> sendBuffer = {};
                _SDLNet_Write32(tickToSend, &sendBuffer);

                int bytesSent = SDLNet_TCP_Send(clientSocket, &sendBuffer,
                                                sizeof(Uint32));
                if (bytesSent < static_cast<int>(sizeof(Uint32))) {
                    LOG_FATAL("Failed to send current tick.");
                }

                LOG_INFO("Connected new client and sent current tick.");
            }
        }
    }
}

std::array<Uint8, NUM_BYTES> recBuffer = {};
// The number of bytes that we've received from the current message.
unsigned int bytesReceived = 0;
/** Receives the message from the client and compares the given tick number to
 * our current. */
bool receiveAndHandle(SDLNet_SocketSet& clientSet, TCPsocket& clientSocket,
                      std::atomic<Uint32>& currentTick)
{
    int numReady = SDLNet_CheckSockets(clientSet, 0);
    if (numReady == 1) {
        // Receive the waiting data.
        int result = SDLNet_TCP_Recv(clientSocket, &(recBuffer[bytesReceived]),
                                     (NUM_BYTES - bytesReceived));
        if (result <= 0) {
            LOG_INFO("Detected disconnect.");
            return false;
        }

        bytesReceived += result;

        // If we finished receiving the message, compare it to currentTick and
        // print the diff.
        if (bytesReceived == NUM_BYTES) {
            Sint64 clientTick = static_cast<Sint64>(_SDLNet_Read32(&recBuffer));
            Sint64 serverTick = static_cast<Sint64>(currentTick);

            LOG_INFO("Client tick: %d, Server tick: %d, Diff: %d", clientTick,
                     serverTick, (clientTick - serverTick));

            bytesReceived = 0;
        }
    }

    return true;
}

int main(int argc, char* argv[])
{
    // SDL2 needs this signature for main, but we don't use the parameters.
    ignore(argc);
    ignore(argv);

    if (SDL_Init(0) == -1) {
        LOG_INFO("SDL_Init: %s", SDLNet_GetError());
        return 1;
    }
    if (SDLNet_Init() == -1) {
        LOG_INFO("SDLNet_Init: %s", SDLNet_GetError());
        return 2;
    }

    /* Set up the listener. */
    IPaddress ip;
    TCPsocket serverSocket = nullptr;
    if (SDLNet_ResolveHost(&ip, NULL, SERVER_PORT)) {
        LOG_INFO("%s", SDLNet_GetError());
    }

    serverSocket = SDLNet_TCP_Open(&ip);
    if (!serverSocket) {
        LOG_INFO("%s", SDLNet_GetError());
    }

    TCPsocket clientSocket = nullptr;
    SDLNet_SocketSet clientSet = SDLNet_AllocSocketSet(1);

    /* Prepare the simulation variables. */
    // The aggregated time since we last processed a tick.
    double accumulatedTime = 0;
    // The number of the tick that we're currently on.
    std::atomic<Uint32> currentTick = 0;
    Debug::registerCurrentTickPtr(&currentTick);

    /* Spin up a thread to check for command line input. */
    std::atomic<bool> exitRequested = false;
    std::thread inputThreadObj(inputThread, &exitRequested);

    LOG_INFO("Server started.");

    // Prime a timer.
    Timer timer;
    while (!exitRequested) {
        // Connect or disconnect the client.
        updateConnection(serverSocket, clientSocket, clientSet, currentTick);

        // Calc the time delta.
        double deltaSeconds = timer.getTimeAndReset();

        /* Process as many game ticks as have accumulated. */
        accumulatedTime += deltaSeconds;
        while (accumulatedTime >= TEST_GAME_TICK_INTERVAL_S) {
            /* Prepare for the next tick. */
            accumulatedTime -= TEST_GAME_TICK_INTERVAL_S;
            if (accumulatedTime >= TEST_GAME_TICK_INTERVAL_S) {
                LOG_INFO("Detected a request for multiple game ticks in the "
                         "same frame. Game tick "
                         "must have been massively delayed. Game tick was "
                         "delayed by: %.8fs.",
                         accumulatedTime);
            }
            else if (accumulatedTime >= TEST_GAME_DELAYED_TIME_S) {
                // Game missed its ideal call time, could be our issue or
                // general system slowness.
                LOG_INFO("Detected a delayed game tick. Game tick was delayed "
                         "by: %.8fs.",
                         accumulatedTime);
            }

            currentTick++;
        }

        if (clientSocket != nullptr) {
            /* Try to receive. */
            bool result
                = receiveAndHandle(clientSet, clientSocket, currentTick);
            if (!result) {
                LOG_FATAL("Disconnect or other error during receive.");
            }
        }
    }

    inputThreadObj.join();

    return 0;
}

```

`Source/Tests/TestSandboxes/Network/LatencyTest/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.5)

message(STATUS "Configuring Latency Test")

# Latency test client
add_executable(LatencyTestClient
    Private/LatencyTestClientMain.cpp
)
target_include_directories(LatencyTestClient
    PRIVATE
        ${SDL2_INCLUDE_DIRS}
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
)
target_link_libraries(LatencyTestClient
    PRIVATE
        ${SDL2_LIBRARIES}
        SDL2_net-static
        SharedLib
)
target_compile_features(LatencyTestClient PRIVATE cxx_std_23)
set_target_properties(LatencyTestClient PROPERTIES CXX_EXTENSIONS OFF)

# Latency test server
add_executable(LatencyTestServer
    Private/LatencyTestServerMain.cpp
)
target_include_directories(LatencyTestServer
    PRIVATE
        ${SDL2_INCLUDE_DIRS}
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
)
target_link_libraries(LatencyTestServer
    PRIVATE
        ${SDL2_LIBRARIES}
        SDL2_net-static
        SharedLib
)
target_compile_features(LatencyTestServer PRIVATE cxx_std_23)
set_target_properties(LatencyTestServer PROPERTIES CXX_EXTENSIONS OFF)

```

`Source/Tests/TestSandboxes/Network/LatencyTest/Private/LatencyTestClientMain.cpp`:

```cpp
#include "SDL.h"
#include "SDL_net.h"
#include <iostream>
#include <string>
#include <vector>
#include <array>
#include <cstdio>
#include "Timer.h"
#include "Ignore.h"

// const std::string SERVER_IP = "127.0.0.1";
const std::string SERVER_IP = "45.79.37.63";
static constexpr unsigned int SERVER_PORT = 41499;
static constexpr unsigned int NUM_BYTES = 16;

using namespace AM;

int main(int argc, char* argv[])
{
    // SDL2 needs this signature for main, but we don't use the parameters.
    ignore(argc);
    ignore(argv);

    int iterationsToRun = 0;
    if (argc != 2) {
        std::cout << "Usage: ./LatencyTestClient <number>" << std::endl;
        return 0;
    }
    else {
        iterationsToRun = std::stoi(argv[1]);
    }

    if (SDL_Init(0) == -1) {
        std::cout << "SDLNet_Init: " << SDLNet_GetError() << std::endl;
        return 1;
    }
    if (SDLNet_Init() == -1) {
        std::cout << "SDLNet_Init: " << SDLNet_GetError() << std::endl;
        return 2;
    }

    std::cout << "Connecting to server." << std::endl;

    IPaddress ip;
    if (SDLNet_ResolveHost(&ip, SERVER_IP.c_str(), SERVER_PORT)) {
        std::cout << "Could not resolve host." << std::endl;
        return 3;
    }

    TCPsocket socket = SDLNet_TCP_Open(&ip);
    if (!socket) {
        std::cout << "Could not open socket." << std::endl;
        return 4;
    }

    int iterationCount = 0;
    std::vector<float> resultArray(iterationsToRun, 0);

    std::array<Uint8, NUM_BYTES> messageBuffer = {};

    // Prime a timer.
    std::cout << "Running tests" << std::endl;
    Timer rttTimer;
    while (iterationCount < iterationsToRun) {
        // Send
        int bytesSent = SDLNet_TCP_Send(socket, &messageBuffer, NUM_BYTES);
        if (bytesSent < static_cast<int>(NUM_BYTES)) {
            std::cout << "Failed to send all bytes." << std::endl;
            return 5;
        }

        // Receive
        int result = SDLNet_TCP_Recv(socket, &messageBuffer, NUM_BYTES);
        if (result == NUM_BYTES) {
            float rtt = rttTimer.getTimeAndReset();
            resultArray[iterationCount] = rtt;
            iterationCount++;
        }
        else if (result <= 0) {
            // Disconnected
            std::cout << "Detected disconnect." << std::endl;
            return 7;
        }
        else {
            std::cout << "Didn't get all expected bytes." << std::endl;
            return 8;
        }
    }

    /* Done getting data. Display it. */
    float max = 0;
    float min = 1000000;
    float average = 0;

    for (int i = 0; i < iterationsToRun; ++i) {
        average += resultArray[i];

        if (resultArray[i] < min) {
            min = resultArray[i];
        }
        if (resultArray[i] > min) {
            max = resultArray[i];
        }
    }
    average /= iterationsToRun;

    std::cout << "## Latency calcs ##" << std::endl;
    printf("Min: %.6f", min);
    std::cout << std::endl;

    printf("Max: %.6f", max);
    std::cout << std::endl;

    printf("Average: %.6f", average);
    std::cout << std::endl;

    return 0;
}

```

`Source/Tests/TestSandboxes/Network/LatencyTest/Private/LatencyTestServerMain.cpp`:

```cpp
#include "SDL.h"
#include "SDL_net.h"
#include <iostream>
#include <array>
#include <atomic>
#include <thread>
#include "Ignore.h"

static constexpr int SERVER_PORT = 41499;
static constexpr unsigned int NUM_BYTES = 16;

using namespace AM;

int inputThread(std::atomic<bool>* exitRequested)
{
    while (!(*exitRequested)) {
        std::string userInput = "";
        std::getline(std::cin, userInput);
        if (userInput == "exit") {
            *exitRequested = true;
        }
    }

    return 0;
}

int main(int argc, char* argv[])
{
    // SDL2 needs this signature for main, but we don't use the parameters.
    ignore(argc);
    ignore(argv);

    if (SDL_Init(0) == -1) {
        std::cout << "SDLNet_Init: " << SDLNet_GetError() << std::endl;
        return 1;
    }
    if (SDLNet_Init() == -1) {
        std::cout << "SDLNet_Init: " << SDLNet_GetError() << std::endl;
        return 2;
    }

    /* Set up the listener. */
    IPaddress ip;
    TCPsocket serverSocket = nullptr;
    if (SDLNet_ResolveHost(&ip, NULL, SERVER_PORT)) {
        std::cerr << SDLNet_GetError() << std::endl;
    }

    serverSocket = SDLNet_TCP_Open(&ip);
    if (!serverSocket) {
        std::cerr << SDLNet_GetError() << std::endl;
    }

    TCPsocket clientSocket = nullptr;
    SDLNet_SocketSet clientSet = SDLNet_AllocSocketSet(1);
    std::array<Uint8, NUM_BYTES> messageBuffer = {};

    // Spin up a thread to check for command line input.
    std::atomic<bool> exitRequested = false;
    std::thread inputThreadObj(inputThread, &exitRequested);

    std::cout << "Server started." << std::endl;
    while (!exitRequested) {
        // If we don't have a connection, try to get one.
        if (clientSocket == nullptr) {
            SDL_Delay(1);
            clientSocket = SDLNet_TCP_Accept(serverSocket);

            // If we got a connection, add the socket to the set.
            if (clientSocket != nullptr) {
                int numAdded = SDLNet_TCP_AddSocket(clientSet, clientSocket);
                if (numAdded < 1) {
                    std::cout
                        << "Error while adding socket: " << SDLNet_GetError()
                        << std::endl;
                }
                else {
                    std::cout << "Connected new client." << std::endl;
                }
            }
        }
        else {
            // Wait for a message.
            int result
                = SDLNet_TCP_Recv(clientSocket, &messageBuffer, NUM_BYTES);
            if (result == NUM_BYTES) {
                // Got a message, loop it back.
                int bytesSent
                    = SDLNet_TCP_Send(clientSocket, &messageBuffer, NUM_BYTES);
                if (bytesSent < static_cast<int>(NUM_BYTES)) {
                    std::cout
                        << "Failed to send all bytes. Cleaning up connection."
                        << std::endl;
                    SDLNet_TCP_DelSocket(clientSet, clientSocket);
                    SDLNet_TCP_Close(clientSocket);
                    clientSocket = nullptr;
                }
            }
            else if (result <= 0) {
                // Disconnected
                std::cout << "Detected disconnect. Cleaning up connection."
                          << std::endl;
                SDLNet_TCP_DelSocket(clientSet, clientSocket);
                SDLNet_TCP_Close(clientSocket);
                clientSocket = nullptr;
            }
            else {
                std::cout
                    << "Didn't get all expected bytes. Cleaning up connection."
                    << std::endl;
                SDLNet_TCP_DelSocket(clientSet, clientSocket);
                SDLNet_TCP_Close(clientSocket);
                clientSocket = nullptr;
            }
        }
    }

    inputThreadObj.join();

    return 0;
}

```

`Source/Tests/TestSandboxes/Network/LoadTest/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.5)

message(STATUS "Configuring Amalgam Engine Load Test Client")

# Load test client
add_executable(LoadTestClient
    Private/LoadTestClientMain.cpp
    Private/NetworkSimulation.cpp
    Public/NetworkSimulation.h
    Private/SimulatedClient.cpp
    Public/SimulatedClient.h
    Private/WorldSimulation.cpp
    Public/WorldSimulation.h
    
    # Client objects
    ${PROJECT_SOURCE_DIR}/Source/EngineSupplementExamples/Client/Config/Public/Config.h
    ${PROJECT_SOURCE_DIR}/Source/ClientLib/Config/Private/UserConfig.cpp
    ${PROJECT_SOURCE_DIR}/Source/ClientLib/Config/Public/UserConfig.h
    ${PROJECT_SOURCE_DIR}/Source/ClientLib/Network/Public/ConnectionError.h
    ${PROJECT_SOURCE_DIR}/Source/ClientLib/Network/Private/MessageProcessor.cpp
    ${PROJECT_SOURCE_DIR}/Source/ClientLib/Network/Public/MessageProcessor.h
    ${PROJECT_SOURCE_DIR}/Source/ClientLib/Network/Public/IMessageProcessorExtension.h
)

target_include_directories(LoadTestClient
    PRIVATE
        ${SDL2_INCLUDE_DIRS}
        ${SDL2PP_INCLUDE_DIRS}
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
        ${CMAKE_CURRENT_SOURCE_DIR}/Public

        # Client objects
        ${PROJECT_SOURCE_DIR}/Source/EngineSupplementExamples/Client/Config/Public
        ${PROJECT_SOURCE_DIR}/Source/ClientLib/Config/Public
        ${PROJECT_SOURCE_DIR}/Source/ClientLib/Network/Public
)

# Inherit Shared's precompiled header.
# CMake causes issues when using precompiled headers with GCC on macOS,
# so precompiled headers are disabled for that target.
if ((NOT APPLE) OR (CMAKE_CXX_COMPILER_ID MATCHES "Clang|AppleClang"))
    target_precompile_headers(LoadTestClient REUSE_FROM SharedLib)
endif()

target_link_libraries(LoadTestClient
    PRIVATE
        ${SDL2_LIBRARIES}
        ${SDL2PP_LIBRARIES}
        SDL2_net-static
        readerwriterqueue
        EnTT::EnTT
        QueuedEvents
        SharedLib
)

# Compile with C++23.
target_compile_features(LoadTestClient PRIVATE cxx_std_23)
set_target_properties(LoadTestClient PROPERTIES CXX_EXTENSIONS OFF)

# Enable compile warnings.
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    target_compile_options(LoadTestClient PUBLIC -Wall -Wextra)
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    target_compile_options(LoadTestClient PUBLIC /W3 /permissive-)
endif()

# Copy UserConfig.json to the build directory.
file(COPY ${CMAKE_SOURCE_DIR}/Resources/Client/Common/UserConfig.json
     DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/)

# On Windows, copy the SDL2 DLL into the build folder so we can run our executable.
if (CMAKE_SYSTEM_NAME STREQUAL "Windows")
    file(COPY ${SDL2_DIR}/lib/x64/SDL2.dll DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/)
endif()

```

`Source/Tests/TestSandboxes/Network/LoadTest/Private/LoadTestClientMain.cpp`:

```cpp
#include <SDL.h>
#include <SDL_net.h>

#include "SDL_Wrappers/SDL.h"

#include "Timer.h"
#include "Log.h"

#include "SimulatedClient.h"
#include "UserConfig.h"

#include <exception>
#include <atomic>
#include <vector>
#include <memory>
#include <string>
#include <thread>

using namespace AM;
using namespace AM::LTC;

void printUsage()
{
    std::printf(
        "Usage: LoadTestClientMain.exe <NumClients> <InputsPerSecond> "
        "<ConnectionWaitTime>\n"
        "  NumClients: How many clients to simulate.\n"
        "  InputsPerSecond: How many times each client should change movement "
        "direction per second.\n"
        "  ConnectionWaitTime: How long, in milliseconds, to wait between"
        " client connections.\n");
}

void connectClients(unsigned int numClients, unsigned int connectionWaitTimeMs,
                    std::vector<std::unique_ptr<SimulatedClient>>* clients)
{
    LOG_INFO("Connecting %u clients with a %ums wait time.", numClients,
             connectionWaitTimeMs);

    // Open all of the connections.
    for (unsigned int i{0}; i < numClients; ++i) {
        (*clients)[i]->connect();

        // Sleep for our wait time.
        std::this_thread::sleep_for(
            std::chrono::milliseconds(connectionWaitTimeMs));
    }

    LOG_INFO("%u clients connected.", numClients);
}

int main(int argc, char** argv)
try {
    if (argc > 4) {
        std::printf("Too many arguments.\n");
        printUsage();
        return 1;
    }
    else if (argc < 4) {
        std::printf("Too few arguments.\n");
        printUsage();
        return 1;
    }

    // Set up the SDL constructs.
    SDL sdl(0);

    // Initialize the user config.
    Client::UserConfig::get();

    // Set up file logging.
    // TODO: This currently will do weird stuff if you have 2 instances of this
    //       app open.
    //    Log::enableFileLogging("LoadTestClient.log");

    // Check for a NumClients argument.
    unsigned int numClients{};
    if (argc > 1) {
        char* end;
        int input{static_cast<int>(std::strtol(argv[1], &end, 10))};
        if ((*end != '\0') || (input < 1)) {
            // Input didn't parse into an integer, or value was less than 1.
            std::printf("Invalid input: %s\n", argv[1]);
            printUsage();
            return 1;
        }
        else {
            numClients = static_cast<unsigned int>(input);
        }
    }

    // Check for a InputRate argument.
    unsigned int inputsPerSecond{};
    if (argc > 2) {
        char* end;
        int input{static_cast<int>(std::strtol(argv[2], &end, 10))};
        if ((*end != '\0')) {
            // Input didn't parse into a valid integer.
            std::printf("Invalid input: %s\n", argv[2]);
            printUsage();
            return 1;
        }
        else {
            inputsPerSecond = static_cast<unsigned int>(input);
        }
    }

    // Check for a ConnectionWaitTime argument.
    unsigned int connectionWaitTimeMs{};
    if (argc > 3) {
        char* end;
        int input{static_cast<int>(std::strtol(argv[3], &end, 10))};
        if ((*end != '\0')) {
            // Input didn't parse into a valid integer.
            std::printf("Invalid input: %s\n", argv[3]);
            printUsage();
            return 1;
        }
        else {
            connectionWaitTimeMs = static_cast<unsigned int>(input);
        }
    }

    // Init SDL_net once for all clients to use.
    SDLNet_Init();

    // Construct the clients.
    LOG_INFO("Client entities will move at %u inputs per second.",
             inputsPerSecond);
    std::vector<std::unique_ptr<SimulatedClient>> clients(numClients);
    for (std::size_t i{0}; i < clients.size(); ++i) {
        clients[i] = std::make_unique<SimulatedClient>(inputsPerSecond);
    }

    // Start the client connections thread.
    std::thread connectionThreadObj(connectClients, numClients,
                                    connectionWaitTimeMs, &clients);

    // Start the main loop.
    std::atomic<bool> exitRequested{false};
    while (!exitRequested) {
        // Check for attempts to exit.
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) {
                exitRequested = true;
            }
        }

        // Process the simulated clients.
        for (auto& client : clients) {
            // Note: These are both safe to do, whether the client is connected
            //       or not.
            client->receiveAndProcess();
            client->tick();
        }
    }

    connectionThreadObj.join();

    return 0;
}  catch (std::exception& e) {
    LOG_INFO("%s", e.what());
    return 1;
}

```

`Source/Tests/TestSandboxes/Network/LoadTest/Private/NetworkSimulation.cpp`:

```cpp
#include "NetworkSimulation.h"
#include "MessageProcessorContext.h"
#include "Heartbeat.h"
#include "ConnectionError.h"
#include "Config.h"
#include "UserConfig.h"
#include "AMAssert.h"
#include <SDL_net.h>

namespace AM
{
namespace LTC
{
NetworkSimulation::NetworkSimulation()
: server{nullptr}
, serverConnected{false}
, eventDispatcher{}
, messageProcessor{Client::MessageProcessorContext{eventDispatcher}}
, tickAdjustment{0}
, adjustmentIteration{0}
, isApplyingTickAdjustment{false}
, messagesSentSinceTick{0}
, currentTickPtr{nullptr}
, headerRecBuffer(SERVER_HEADER_SIZE)
, batchRecBuffer(SharedConfig::MAX_BATCH_SIZE)
, decompressedBatchRecBuffer(SharedConfig::MAX_BATCH_SIZE)
{
}

void NetworkSimulation::connect()
{
    if (server != nullptr) {
        LOG_INFO("Attempted to connect while connected.");
        return;
    }

    // Try to connect.
    Client::ServerAddress serverAddress{
        Client::UserConfig::get().getServerAddress()};
    server = Peer::initiate(serverAddress.IP, serverAddress.port);
    if (server != nullptr) {
        // Note: The server sends us a ConnectionResponse when we connect the
        //       socket. Eventually, we'll instead send a ConnectionRequest to
        //       the login server here.

        serverConnected = true;
    }
    else {
        eventDispatcher.emplace<Client::ConnectionError>(
            Client::ConnectionError::Type::Failed);
        return;
    }
}

void NetworkSimulation::disconnect()
{
    server = nullptr;
    serverConnected = false;
    adjustmentIteration = 0;
    isApplyingTickAdjustment = false;
    messagesSentSinceTick = 0;
}

void NetworkSimulation::tick()
{
    // If the server connection isn't established, do nothing (we don't want 
    // to try to read the server var while connect() is potentially running 
    // on another thread).
    if (!serverConnected) {
        return;
    }

    // Receive any waiting messages for this client.
    receiveAndProcess();

    // Send a heartbeat if we need to.
    if (*currentTickPtr != 0) {
        sendHeartbeatIfNecessary();
    }
}

void NetworkSimulation::receiveAndProcess()
{
    // If the server connection isn't established, do nothing (we don't want 
    // to try to read the server var while connect() is potentially running 
    // on another thread).
    if (!serverConnected) {
        return;
    }

    // If there's no data waiting, return early.
    if (!(server->isReady(true))) {
        return;
    }

    // Receive message batches from the server.
    while (server->isReady(true)) {
        int receivedBytes{
            server->receiveBytes(headerRecBuffer.data(), SERVER_HEADER_SIZE)};
        if (receivedBytes < 0) {
            LOG_INFO("Found server to be disconnected while trying to "
                     "receive header.");
            eventDispatcher.emplace<Client::ConnectionError>(
                Client::ConnectionError::Type::Disconnected);
            break;
        }

        processBatch();
    }
}

EventDispatcher& NetworkSimulation::getEventDispatcher()
{
    return eventDispatcher;
}

Uint32 NetworkSimulation::getLastReceivedTick()
{
    return messageProcessor.getLastReceivedTick();
}

int NetworkSimulation::transferTickAdjustment()
{
    if (isApplyingTickAdjustment) {
        int currentAdjustment = tickAdjustment;
        if (currentAdjustment < 0) {
            // The sim can only freeze for 1 tick at a time, transfer 1 from
            // tickAdjustment.
            tickAdjustment += 1;
            return -1;
        }
        else if (currentAdjustment > 0) {
            // The sim can process multiple iterations to catch up, transfer
            // all of tickAdjustment.
            tickAdjustment -= currentAdjustment;
            return currentAdjustment;
        }
        else {
            // We finished applying the adjustment, increment the iteration.
            adjustmentIteration++;
            isApplyingTickAdjustment = false;
            return 0;
        }
    }
    else {
        return 0;
    }
}

void NetworkSimulation::registerCurrentTickPtr(
    const std::atomic<Uint32>* inCurrentTickPtr)
{
    currentTickPtr = inCurrentTickPtr;
}

void NetworkSimulation::send(const BinaryBufferSharedPtr& message)
{
    if ((server == nullptr) || !(server->isConnected())) {
        // Note: Receive thread is responsible for emitting ConnectionError.
        LOG_INFO("Tried to send while server is disconnected.");
        return;
    }

    // Send the message.
    NetworkResult result{server->send(message)};
    if (result == NetworkResult::Success) {
        messagesSentSinceTick++;
    }
    else {
        // Note: Receive thread is responsible for emitting ConnectionError.
        LOG_INFO("Message send failed.");
    }
}

void NetworkSimulation::sendHeartbeatIfNecessary()
{
    // If we haven't sent any relevant messages since the last tick.
    if (messagesSentSinceTick == 0) {
        // Send the heartbeat message.
        serializeAndSend<Heartbeat>({*currentTickPtr});
    }

    messagesSentSinceTick = 0;
}

void NetworkSimulation::processBatch()
{
    // Check if we need to adjust the tick offset.
    adjustIfNeeded(headerRecBuffer[ServerHeaderIndex::TickAdjustment],
                   headerRecBuffer[ServerHeaderIndex::AdjustmentIteration]);

    /* Process the BatchSize header field. */
    // Read the high bit of batchSize to tell whether the batch is compressed
    // or not. If the high bit is set, the batch is compressed.
    Uint16 batchSize{
        ByteTools::read16(&(headerRecBuffer[ServerHeaderIndex::BatchSize]))};
    bool batchIsCompressed{(batchSize & (1U << 15)) != 0};

    // Reset the high bit of batchSize to get the real size.
    batchSize &= ~(1U << 15);

    /* Process the batch, if it contains any data. */
    if (batchSize > 0) {
        // Receive the expected bytes.
        int bytesReceived{
            server->receiveBytesWait(&(batchRecBuffer[0]), batchSize)};
        if (bytesReceived < 0) {
            LOG_INFO("Failed to receive expected bytes.");
        }

        // If the payload is compressed, decompress it.
        Uint8* bufferToUse{&(batchRecBuffer[0])};
        if (batchIsCompressed) {
            batchSize = static_cast<Uint16>(
                ByteTools::decompress(&(batchRecBuffer[0]), batchSize,
                                      &(decompressedBatchRecBuffer[0]),
                                      SharedConfig::MAX_BATCH_SIZE));

            bufferToUse = &(decompressedBatchRecBuffer[0]);
        }

        // Process the messages.
        std::size_t bufferIndex{0};
        while (bufferIndex < batchSize) {
            Uint8 messageType{
                bufferToUse[bufferIndex + MessageHeaderIndex::MessageType]};
            Uint16 messageSize{ByteTools::read16(
                &(bufferToUse[bufferIndex + MessageHeaderIndex::Size]))};

            messageProcessor.processReceivedMessage(
                messageType,
                &(bufferToUse[bufferIndex + MessageHeaderIndex::MessageStart]),
                messageSize);

            bufferIndex += MESSAGE_HEADER_SIZE + messageSize;
            AM_ASSERT((bufferIndex <= batchSize),
                      "Buffer index is wrong. %u, %u", bufferIndex, batchSize);
        }

        AM_ASSERT((bufferIndex == batchSize),
                  "Didn't process correct number of bytes. %u, %u", bufferIndex,
                  batchSize);
    }
}

void NetworkSimulation::adjustIfNeeded(Sint8 receivedTickAdj, Uint8 receivedAdjIteration)
{
    if (receivedTickAdj != 0) {
        Uint8 currentAdjIteration{adjustmentIteration};

        // If it's the current iteration and we aren't already applying it.
        if ((receivedAdjIteration == currentAdjIteration)
            && !isApplyingTickAdjustment) {
            // Set the adjustment to be applied.
            tickAdjustment += receivedTickAdj;
            isApplyingTickAdjustment = true;
            //LOG_INFO("Received tick adjustment: %d, iteration: %u",
            //         receivedTickAdj, receivedAdjIteration);
        }
        else if (receivedAdjIteration > currentAdjIteration) {
            if (isApplyingTickAdjustment) {
                LOG_FATAL("Received future adjustment iteration while applying "
                          "the last. current: %u, received: %u",
                          currentAdjIteration, receivedAdjIteration);
            }
            else {
                LOG_FATAL("Out of sequence adjustment iteration. current: %u, "
                          "received: %u",
                          currentAdjIteration, receivedAdjIteration);
            }
        }
    }
}

} // End namespace LTC
} // namespace AM

```

`Source/Tests/TestSandboxes/Network/LoadTest/Private/SimulatedClient.cpp`:

```cpp
#include "SimulatedClient.h"
#include "SharedConfig.h"
#include <functional>

namespace AM
{
namespace LTC
{
SimulatedClient::SimulatedClient(unsigned int inInputsPerSecond)
: networkCaller(std::bind_front(&NetworkSimulation::tick, &networkSim),
                SharedConfig::CLIENT_NETWORK_TICK_TIMESTEP_S, "Network", true)
, worldSim(networkSim, inInputsPerSecond)
, simCaller(std::bind_front(&WorldSimulation::tick, &worldSim),
            SharedConfig::SIM_TICK_TIMESTEP_S, "Sim", false)
, isConnected(false)
{
}

void SimulatedClient::connect()
{
    // Connect to the server.
    worldSim.connect();

    // Start the tick timer at the current time.
    simCaller.initTimer();
    networkCaller.initTimer();

    isConnected = true;
}

void SimulatedClient::receiveAndProcess()
{
    // Note: This is safe to call, even if connect() is running on another 
    //       thread (it has an internal check).
    networkSim.receiveAndProcess();
}

void SimulatedClient::tick()
{
    // Process the network.
    networkCaller.update();

    // If we're connected, process the world sim.
    if (isConnected) {
        simCaller.update();
    }
}

} // End namespace LTC
} // End namespace AM

```

`Source/Tests/TestSandboxes/Network/LoadTest/Private/WorldSimulation.cpp`:

```cpp
#include "WorldSimulation.h"
#include "NetworkSimulation.h"
#include "Config.h"
#include "Serialize.h"
#include "InputChangeRequest.h"
#include "Peer.h"
#include "Log.h"
#include <memory>
#include <algorithm>

namespace AM
{
namespace LTC
{

WorldSimulation::WorldSimulation(NetworkSimulation& inNetwork,
                                 unsigned int inInputsPerSecond)
: network{inNetwork}
, connectionResponseQueue{network.getEventDispatcher()}
, connectionErrorQueue{network.getEventDispatcher()}
, clientEntity{entt::null}
, currentTick{0}
, inputsPerSecond{inInputsPerSecond}
, ticksTillInput{0}
, isMovingRight{false}
{
    network.registerCurrentTickPtr(&currentTick);
}

void WorldSimulation::connect()
{
    network.connect();

    // Wait for the player's ID from the server.
    ConnectionResponse connectionResponse{};
    if (!(connectionResponseQueue.waitPop(connectionResponse,
                                          CONNECTION_RESPONSE_WAIT_US))) {
        LOG_FATAL("Server did not respond.");
    }

    // Get our info from the connection response.
    clientEntity = connectionResponse.entity;
    LOG_INFO("Received connection response. ID: %u, tick: %u", clientEntity,
             connectionResponse.tickNum);

    // Aim our tick for some reasonable point ahead of the server.
    // The server will adjust us after the first message anyway.
    currentTick
        = connectionResponse.tickNum + Client::Config::INITIAL_TICK_OFFSET;
}

void WorldSimulation::tick()
{
    // First, make sure we still have a connection.
    Client::ConnectionError connectionError;
    if (connectionErrorQueue.pop(connectionError)) {
        LOG_FATAL("Lost connection to server.");
    }

    Uint32 targetTick{currentTick + 1};

    // Apply any adjustments that we received from the server.
    targetTick += network.transferTickAdjustment();

    // Process ticks until we match what the server wants.
    // This may cause us to not process any ticks, or to process multiple
    // ticks.
    while (currentTick < targetTick) {
        if (inputsPerSecond > 0) {
            // If it's time to move, send an input message.
            if (ticksTillInput == 0) {
                sendNextInput();
                ticksTillInput
                    = (SharedConfig::SIM_TICKS_PER_SECOND / inputsPerSecond);
            }
            ticksTillInput--;
        }

        currentTick++;
    }
}

void WorldSimulation::sendNextInput()
{
    // Construct the next input.
    InputChangeRequest inputChangeRequest{};
    inputChangeRequest.tickNum = currentTick;

    if (isMovingRight) {
        inputChangeRequest.input.inputStates[Input::XUp] = Input::Pressed;
        isMovingRight = false;
    }
    else {
        inputChangeRequest.input.inputStates[Input::XDown] = Input::Pressed;
        isMovingRight = true;
    }

    // Send the client input message.
    network.serializeAndSend<InputChangeRequest>(inputChangeRequest);
}

} // End namespace LTC
} // End namespace AM

```

`Source/Tests/TestSandboxes/Network/LoadTest/Public/NetworkSimulation.h`:

```h
#pragma once

#include "NetworkDefs.h"
#include "MessageProcessor.h"
#include "QueuedEvents.h"
#include "Serialize.h"
#include "Peer.h"
#include "Deserialize.h"
#include "ByteTools.h"
#include "Log.h"
#include <SDL_stdinc.h>
#include <atomic>

namespace AM
{
namespace LTC
{
/**
 * Represents the Network for a single simulated client.
 *
 * We can't use the actual Client::Network class because it would spin up a 
 * thread for each client.
 */
class NetworkSimulation 
{
public:
    NetworkSimulation();

    /**
     * Attempts to connect to the server.
     */
    void connect();

    /**
     * Cleans up our server connection.
     */
    void disconnect();

    /**
     * Updates accumulatedTime. If greater than the tick timestep and no
     * messages have been sent since the last heartbeat, sends a message.
     */
    void tick();

    /**
     * Sends bytes over the network.
     * Errors if the server is disconnected.
     *
     * @param messageStruct  A structure that defines MESSAGE_TYPE and has an
     *                       associated serialize() function.
     */
    template<typename T>
    void serializeAndSend(const T& messageStruct);

    /**
     * Attempts to receive messages from the server.
     */
    void receiveAndProcess();

    /**
     * Returns the Network event dispatcher. All messages that we receive
     * from the server are pushed into this dispatcher.
     */
    EventDispatcher& getEventDispatcher();

    /**
     * Returns the latest tick that we've received an update message for.
     */
    Uint32 getLastReceivedTick();

    /**
     * Returns the amount that the sim tick should be adjusted by.
     *
     * The server adds to our tickAdjustment when we're too far ahead or behind
     * it.
     *
     * @return 1 if there's a negative tickAdjustment (the sim can only freeze 1
     *         tick at a time), else 0 or a negative amount equal to the current
     *         tickAdjustment.
     */
    int transferTickAdjustment();

    /**
     * Used for passing us a pointer to the Simulation's currentTick.
     */
    void registerCurrentTickPtr(const std::atomic<Uint32>* inCurrentTickPtr);

private:
    /**
     * How long the receive loop in connectAndReceive should delay if no
     * socket activity was reported on the socket.
     */
    static constexpr unsigned int INACTIVE_DELAY_TIME_MS{1};

    /**
     * Sends bytes over the network.
     * Errors if the server is disconnected.
     */
    void send(const BinaryBufferSharedPtr& message);

    /**
     * If we haven't sent any messages since the last network tick, sends a
     * heartbeat.
     */
    void sendHeartbeatIfNecessary();

    /**
     * Processes the received header and following batch.
     * If any messages are expected, receives the messages.
     */
    void processBatch();

    /**
     * Checks if we need to process the received adjustment, does so if
     * necessary.
     * @param receivedTickAdj  The received tick adjustment.
     * @param receivedAdjIteration  The adjustment iteration for the received
     *                              adjustment.
     */
    void adjustIfNeeded(Sint8 receivedTickAdj, Uint8 receivedAdjIteration);

    std::shared_ptr<Peer> server;

    /** If true, the server connection has been established. */
    std::atomic<bool> serverConnected;

    /** Used to dispatch events from the network to the simulation. */
    EventDispatcher eventDispatcher;

    /** Deserializes messages, does any network-layer message handling, and
        pushes messages into the eventDispatcher. */
    Client::MessageProcessor messageProcessor;

    /** The adjustment that the server has told us to apply to the tick. */
    std::atomic<int> tickAdjustment;

    /** Tracks what iteration of tick offset adjustments we're on.
        Used to make sure that we don't double-count adjustments. */
    std::atomic<Uint8> adjustmentIteration;

    /** True when we're waiting for the sim to finish applying an adjustment. */
    std::atomic<bool> isApplyingTickAdjustment;

    /** Tracks if we've sent a message since the last network tick.
        Used to determine if we need to heartbeat. */
    unsigned int messagesSentSinceTick;

    /** Pointer to the game's current tick. */
    const std::atomic<Uint32>* currentTickPtr;

    /** Holds a received server header while we process it. */
    BinaryBuffer headerRecBuffer;
    /** Holds a received message batch while we pass its messages to
        MessageProcessor. */
    BinaryBuffer batchRecBuffer;
    /** If a batch is compressed, it's decompressed into this buffer before
        processing. */
    BinaryBuffer decompressedBatchRecBuffer;
};

template<typename T>
void NetworkSimulation::serializeAndSend(const T& messageStruct)
{
    // Check that the message isn't too big.
    // Note: We don't compress messages on this side, so we know the final
    //       message size at this point.
    std::size_t totalMessageSize{CLIENT_HEADER_SIZE + MESSAGE_HEADER_SIZE
                                 + Serialize::measureSize(messageStruct)};
    if (totalMessageSize > CLIENT_MAX_MESSAGE_SIZE) {
        LOG_INFO("Tried to send a too-large message. Size: %u, max: %u",
                  totalMessageSize, CLIENT_MAX_MESSAGE_SIZE);
        return;
    }

    // Serialize the message struct into a buffer, leaving room for the
    // headers.
    BinaryBufferSharedPtr messageBuffer{
        std::make_shared<BinaryBuffer>(totalMessageSize)};
    std::size_t messageSize{Serialize::toBuffer(
        messageBuffer->data(), messageBuffer->size(), messageStruct,
        (CLIENT_HEADER_SIZE + MESSAGE_HEADER_SIZE))};

    // Copy the adjustment iteration into the client header.
    messageBuffer->at(ClientHeaderIndex::AdjustmentIteration)
        = adjustmentIteration;

    // Copy the message type into the message header.
    // TODO: Add a nice compile-time message if T doesn't define MESSAGE_TYPE.
    messageBuffer->at(CLIENT_HEADER_SIZE + MessageHeaderIndex::MessageType)
        = static_cast<Uint8>(T::MESSAGE_TYPE);

    // Copy the message size into the message header.
    ByteTools::write16(static_cast<Uint16>(messageSize),
                       (messageBuffer->data() + CLIENT_HEADER_SIZE
                        + MessageHeaderIndex::Size));

    // Send the message.
    send(messageBuffer);
}

} // End namespace LTC
} // End namespace AM

```

`Source/Tests/TestSandboxes/Network/LoadTest/Public/SimulatedClient.h`:

```h
#pragma once

#include "NetworkSimulation.h"
#include "WorldSimulation.h"
#include "PeriodicCaller.h"
#include <atomic>

namespace AM
{
namespace LTC
{
/**
 * Represents a single simulated client.
 * Maintains only as much state as is necessary to keep the connection going
 * and send inputs.
 */
class SimulatedClient
{
public:
    SimulatedClient(unsigned int inInputsPerSecond);

    /**
     * Calls worldSim.connect().
     */
    void connect();

    /**
     * Calls networkSim.receiveAndProcess().
     */
    void receiveAndProcess();

    /**
     * Calls the sim and network ticks.
     */
    void tick();

private:
    NetworkSimulation networkSim;
    PeriodicCaller networkCaller;

    WorldSimulation worldSim;
    PeriodicCaller simCaller;

    /** If true, this client is connected to the server and we've processed the 
        ConnectionResponse. */
    std::atomic<bool> isConnected;
};

} // End namespace LTC
} // End namespace AM

```

`Source/Tests/TestSandboxes/Network/LoadTest/Public/WorldSimulation.h`:

```h
#pragma once

#include "SharedConfig.h"
#include "QueuedEvents.h"
#include "ConnectionResponse.h"
#include "ConnectionError.h"
#include "entt/entity/registry.hpp"
#include <SDL_stdinc.h>
#include <atomic>

namespace AM
{
struct InputChangeRequest;

namespace LTC
{
class NetworkSimulation;

/**
 * Represents the Simulation for a single simulated client.
 *
 * This is a minimal form of the sim, just maintaining tick timing and sending
 * inputs once in a while.
 */
class WorldSimulation
{
public:
    WorldSimulation(NetworkSimulation& network, unsigned int inInputsPerSecond);

    /**
     * Requests to connect to the game server, waits for a ConnectionResponse.
     */
    void connect();

    /**
     * Processes one tick of the "sim", checking if we need to send inputs or
     * not.
     */
    void tick();

private:
    /**
     * Sends the next input message.
     * The simulated clients currently just move back and forth.
     */
    void sendNextInput();

    /** How long the sim should wait for the server to send a connection
        response, in microseconds. */
    static constexpr int CONNECTION_RESPONSE_WAIT_US{1 * 1000 * 1000};

    NetworkSimulation& network;

    /** Connection responses, received from the server. */
    EventQueue<ConnectionResponse> connectionResponseQueue;

    /** Connection error events, received from the Network. */
    EventQueue<Client::ConnectionError> connectionErrorQueue;

    /** The entity ID that we were given by the server. */
    entt::entity clientEntity;

    /**
     * The number of the tick that we're currently on.
     * Initialized based on the number that the server tells us it's on.
     */
    std::atomic<Uint32> currentTick;

    /** How many times we should send a new input, per second. */
    const unsigned int inputsPerSecond;

    /** How many ticks are left until we need to send another input message. */
    unsigned int ticksTillInput;

    /** Tracks which direction this simulated client is moving.
        Used for constructing the next input message. */
    bool isMovingRight;
};

} // End namespace LTC
} // End namespace AM

```

`Source/Tests/UnitTests/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.5)

message(STATUS "Configuring Amalgam Engine Unit Tests")

# Temp: Set to new behavior to avoid warning.
cmake_policy(SET CMP0135 NEW)

# Configure Catch2.
if(NOT TARGET Catch2::Catch2)
    message(STATUS "Downloading dependency if not present: Catch2")

    SET(CATCH_BUILD_TESTING OFF CACHE BOOL "Build SelfTest project")
    SET(CATCH_INSTALL_DOCS OFF CACHE BOOL "Install documentation alongside library")
    include(FetchContent)
    FetchContent_Declare(Catch2Download
        URL https://github.com/catchorg/Catch2/archive/refs/tags/v3.3.1.tar.gz
        URL_HASH MD5=5cdc99f93e0b709936eb5af973df2a5c
    )
    FetchContent_MakeAvailable(Catch2Download)
endif()

# Add the executable.
add_executable(UnitTests
    Private/TestBoundingBox.cpp
    Private/TestEntityLocator.cpp
    Private/TestMain.cpp
)

# Include our source dir.
target_include_directories(UnitTests
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
    PUBLIC
        ${PROJECT_SOURCE_DIR}/Source/ServerLib/Network/Public
)

# Link our dependencies.
target_link_libraries(UnitTests
    PRIVATE
        SharedLib
        Catch2::Catch2
)

# Compile with C++23.
target_compile_features(UnitTests PRIVATE cxx_std_23)
set_target_properties(UnitTests PROPERTIES CXX_EXTENSIONS OFF)

# Enable compile warnings.
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    target_compile_options(UnitTests PUBLIC -Wall -Wextra)
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    target_compile_options(UnitTests PUBLIC /W3 /permissive-)
endif()

# If debug, enable debug printing.
if (CMAKE_BUILD_TYPE STREQUAL "Debug")
    target_compile_options(UnitTests PUBLIC -DENABLE_DEBUG_INFO)
endif (CMAKE_BUILD_TYPE STREQUAL "Debug")

```

`Source/Tests/UnitTests/Private/TestBoundingBox.cpp`:

```cpp
#include "catch2/catch_all.hpp"
#include "Position.h"
#include "BoundingBox.h"
#include "TileExtent.h"
#include "Log.h"

using namespace AM;

TEST_CASE("TestBoundingBox")
{
    SECTION("Intersects cylinder")
    {
        // Centered on the origin.
        Position position{0, 0, 0};
        unsigned int radius{256};

        // Fully inside the cylinder.
        BoundingBox box1{1, 6, 3, 8, 0, 1};
        REQUIRE(box1.intersects(position, radius));

        // Corner inside the cylinder, center outside.
        BoundingBox box2{0, 10, 255, 265, 0, 1};
        REQUIRE(box2.intersects(position, radius));

        // Center inside the cylinder, corner outside.
        BoundingBox box3{0, 10, 250, 260, 0, 1};
        REQUIRE(box3.intersects(position, radius));

        // Edge shared with cylinder.
        BoundingBox box4{256, 266, 0, 10, 0, 1};
        REQUIRE(box4.intersects(position, radius));

        // Fully outside the cylinder.
        BoundingBox box5{300, 310, 300, 310, 0, 1};
        REQUIRE(!(box5.intersects(position, radius)));
    }

    SECTION("Intersects tile extent")
    {
        TileExtent tileExtent{0, 0, 1, 1};

        // Fully inside the extent.
        BoundingBox box1{10, 15, 10, 15, 0, 1};
        REQUIRE(box1.intersects(tileExtent));

        // Partially inside the extent.
        BoundingBox box2{30, 35, 30, 35, 0, 1};
        REQUIRE(box2.intersects(tileExtent));

        // Edge shared with extent.
        BoundingBox box3{32, 37, 30, 35, 0, 1};
        REQUIRE(box3.intersects(tileExtent));

        // Fully outside the extent.
        BoundingBox box4{33, 38, 30, 35, 0, 1};
        REQUIRE(!(box4.intersects(tileExtent)));
    }

    SECTION("As tile extent")
    {
        const float TILE_WIDTH{SharedConfig::TILE_WORLD_WIDTH};

        BoundingBox box{(TILE_WIDTH * 1.25),
                        (TILE_WIDTH * 4),
                        (TILE_WIDTH * 0.75),
                        (TILE_WIDTH * 4),
                        0,
                        TILE_WIDTH};
        TileExtent tileExtent{box.asTileExtent()};

        REQUIRE(tileExtent.x == 1);
        REQUIRE(tileExtent.xLength == 3);
        REQUIRE(tileExtent.y == 0);
        REQUIRE(tileExtent.yLength == 4);
    }

    SECTION("Get 3d center")
    {
        BoundingBox box{300, 310, 300, 310, 0, 10};
        Position center{box.get3dCenter()};

        REQUIRE(center.x == 305);
        REQUIRE(center.y == 305);
        REQUIRE(center.z == 5);
    }
}

```

`Source/Tests/UnitTests/Private/TestEntityLocator.cpp`:

```cpp
#include "catch2/catch_all.hpp"
#include "EntityLocator.h"
#include "entt/entity/registry.hpp"
#include "Position.h"
#include "BoundingBox.h"
#include "Collision.h"
#include "Transforms.h"
#include "Log.h"
#include <vector>

using namespace AM;

TEST_CASE("TestEntityLocator")
{
    entt::registry registry;
    EntityLocator entityLocator{registry};

    // Calc the cell world width, since it's private in the EntityLocator.
    const float CELL_WORLD_WIDTH{SharedConfig::CELL_WIDTH
                                 * SharedConfig::TILE_WORLD_WIDTH};

    // Set grid size.
    const unsigned int GRID_X_LENGTH{32};
    const unsigned int GRID_Y_LENGTH{16};
    entityLocator.setGridSize(GRID_X_LENGTH, GRID_Y_LENGTH);

    // Model-space bounding box.
    const float TILE_WORLD_WIDTH{SharedConfig::TILE_WORLD_WIDTH};
    const float HALF_TILE{TILE_WORLD_WIDTH / 2.f};
    BoundingBox modelBounds{0, HALF_TILE, 0, HALF_TILE, 0, HALF_TILE};

    // Define the cylinder.
    Position cylinderCenter{CELL_WORLD_WIDTH, CELL_WORLD_WIDTH, 0};
    float HALF_CELL{CELL_WORLD_WIDTH / 2.f};
    unsigned int radius{static_cast<unsigned int>(HALF_CELL)};

    SECTION("Set entity location")
    {
        entt::entity entity{registry.create()};

        // Intersecting 2 tiles at the edge of the map.
        Position position{((28 * TILE_WORLD_WIDTH) + (HALF_TILE / 2.f)),
                          HALF_TILE, 0};
        BoundingBox boundingBox{
            Transforms::modelToWorldCentered(modelBounds, position)};
        entityLocator.setEntityLocation(entity, boundingBox);
    }

    SECTION("Coarse cylinder - Single intersected cell")
    {
        entt::entity entity{registry.create()};

        // Touching 1 intersected cell outside the cylinder.
        Position position{HALF_TILE, HALF_TILE, 0};
        BoundingBox boundingBox{
            Transforms::modelToWorldCentered(modelBounds, position)};
        entityLocator.setEntityLocation(entity, boundingBox);

        std::vector<entt::entity>* returnVector{
            &(entityLocator.getEntitiesCoarse(cylinderCenter, radius))};

        REQUIRE(returnVector->size() == 1);
        REQUIRE(returnVector->at(0) == entity);

        // Touching 1 intersected cell inside the cylinder.
        position = {(CELL_WORLD_WIDTH + TILE_WORLD_WIDTH),
                    (CELL_WORLD_WIDTH + TILE_WORLD_WIDTH), 0};
        boundingBox = Transforms::modelToWorldCentered(modelBounds, position);
        entityLocator.setEntityLocation(entity, boundingBox);

        returnVector
            = &(entityLocator.getEntitiesCoarse(cylinderCenter, radius));

        REQUIRE(returnVector->size() == 1);
        REQUIRE(returnVector->at(0) == entity);
    }

    SECTION("Coarse cylinder - Touching multiple intersected cells")
    {
        entt::entity entity{registry.create()};

        // Touching 2 intersected cells outside the cylinder.
        Position position{HALF_TILE, CELL_WORLD_WIDTH, 0};
        BoundingBox boundingBox{
            Transforms::modelToWorldCentered(modelBounds, position)};
        entityLocator.setEntityLocation(entity, boundingBox);

        std::vector<entt::entity>* returnVector{
            &(entityLocator.getEntitiesCoarse(cylinderCenter, radius))};

        REQUIRE(returnVector->size() == 1);
        REQUIRE(returnVector->at(0) == entity);

        // Touching 2 intersected cells inside the cylinder.
        position = {(CELL_WORLD_WIDTH + HALF_TILE), CELL_WORLD_WIDTH, 0};
        boundingBox = Transforms::modelToWorldCentered(modelBounds, position);
        entityLocator.setEntityLocation(entity, boundingBox);

        returnVector
            = &(entityLocator.getEntitiesCoarse(cylinderCenter, radius));

        REQUIRE(returnVector->size() == 1);
        REQUIRE(returnVector->at(0) == entity);
    }

    SECTION("Coarse cylinder - Half touching intersected cell")
    {
        entt::entity entity{registry.create()};

        // On the border of an intersected cell.
        Position position{(CELL_WORLD_WIDTH * 2), HALF_TILE, 0};
        BoundingBox boundingBox{
            Transforms::modelToWorldCentered(modelBounds, position)};
        entityLocator.setEntityLocation(entity, boundingBox);

        std::vector<entt::entity> returnVector{
            entityLocator.getEntitiesCoarse(cylinderCenter, radius)};

        REQUIRE(returnVector.size() == 1);
        REQUIRE(returnVector.at(0) == entity);
    }

    SECTION("Coarse cylinder - Outside")
    {
        entt::entity entity{registry.create()};

        // Not touching any intersected cells.
        Position position{(CELL_WORLD_WIDTH * 3), HALF_TILE, 0};
        BoundingBox boundingBox{
            Transforms::modelToWorldCentered(modelBounds, position)};
        entityLocator.setEntityLocation(entity, boundingBox);

        std::vector<entt::entity> returnVector{
            entityLocator.getEntitiesCoarse(cylinderCenter, radius)};

        REQUIRE(returnVector.size() == 0);
    }

    SECTION("Coarse cylinder - 2 out, 2 in")
    {
        // Outside any intersected cells.
        entt::entity entity{registry.create()};
        Position position{(CELL_WORLD_WIDTH * 3), HALF_TILE, 0};
        BoundingBox boundingBox{
            Transforms::modelToWorldCentered(modelBounds, position)};
        entityLocator.setEntityLocation(entity, boundingBox);

        // Outside any intersected cells.
        entt::entity entity2{registry.create()};
        position = {CELL_WORLD_WIDTH, (CELL_WORLD_WIDTH * 3), 0};
        boundingBox = Transforms::modelToWorldCentered(modelBounds, position);
        entityLocator.setEntityLocation(entity2, boundingBox);

        // Inside intersected cell, outside cylinder.
        entt::entity entity3{registry.create()};
        position = {TILE_WORLD_WIDTH, TILE_WORLD_WIDTH, 0};
        boundingBox = Transforms::modelToWorldCentered(modelBounds, position);
        entityLocator.setEntityLocation(entity3, boundingBox);

        // Inside cylinder.
        entt::entity entity4{registry.create()};
        position = {CELL_WORLD_WIDTH, CELL_WORLD_WIDTH, 0};
        boundingBox = Transforms::modelToWorldCentered(modelBounds, position);
        entityLocator.setEntityLocation(entity4, boundingBox);

        std::vector<entt::entity> returnVector{
            entityLocator.getEntitiesCoarse(cylinderCenter, radius)};

        REQUIRE(returnVector.size() == 2);
        REQUIRE(((returnVector.at(0) == entity3)
                 || (returnVector.at(0) == entity4)));
        REQUIRE(((returnVector.at(1) == entity3)
                 || (returnVector.at(1) == entity4)));
    }

    SECTION("Fine cylinder - Single cell inside")
    {
        entt::entity entity{registry.create()};

        // Single cell inside the cylinder.
        Position& position{registry.emplace<Position>(
            entity, (CELL_WORLD_WIDTH - TILE_WORLD_WIDTH),
            (CELL_WORLD_WIDTH - TILE_WORLD_WIDTH), 0.f)};
        BoundingBox boundingBox{
            Transforms::modelToWorldCentered(modelBounds, position)};
        registry.emplace<Collision>(entity, Collision{{}, boundingBox});
        entityLocator.setEntityLocation(entity, boundingBox);

        std::vector<entt::entity> returnVector{
            entityLocator.getEntitiesFine(cylinderCenter, radius)};

        REQUIRE(returnVector.size() == 1);
        REQUIRE(returnVector.at(0) == entity);
    }

    SECTION("Fine cylinder - Touching multiple cells")
    {
        entt::entity entity{registry.create()};

        // Touching 4 cells inside the cylinder.
        Position& position{registry.emplace<Position>(entity, CELL_WORLD_WIDTH,
                                                      CELL_WORLD_WIDTH, 0.f)};
        BoundingBox boundingBox{
            Transforms::modelToWorldCentered(modelBounds, position)};
        registry.emplace<Collision>(entity, Collision{{}, boundingBox});
        entityLocator.setEntityLocation(entity, boundingBox);

        std::vector<entt::entity> returnVector{
            entityLocator.getEntitiesFine(cylinderCenter, radius)};

        REQUIRE(returnVector.size() == 1);
        REQUIRE(returnVector.at(0) == entity);
    }

    SECTION("Fine cylinder - On border")
    {
        entt::entity entity{registry.create()};

        // On the border of the cylinder.
        // Note: This is right on the edge (same value), which still counts
        //       as being inside.
        Position& position{registry.emplace<Position>(
            entity, (CELL_WORLD_WIDTH + HALF_CELL + (HALF_TILE / 2)),
            CELL_WORLD_WIDTH, 0.f)};
        BoundingBox boundingBox{
            Transforms::modelToWorldCentered(modelBounds, position)};
        registry.emplace<Collision>(entity, Collision{{}, boundingBox});
        entityLocator.setEntityLocation(entity, boundingBox);

        std::vector<entt::entity> returnVector{
            entityLocator.getEntitiesFine(cylinderCenter, radius)};

        REQUIRE(returnVector.size() == 1);
        REQUIRE(returnVector.at(0) == entity);
    }

    SECTION("Fine cylinder - Outside")
    {
        entt::entity entity{registry.create()};

        // Inside an intersected cell, but outside the cylinder.
        Position& position{
            registry.emplace<Position>(entity, HALF_TILE, HALF_TILE, 0.f)};
        BoundingBox boundingBox{
            Transforms::modelToWorldCentered(modelBounds, position)};
        registry.emplace<Collision>(entity, Collision{{}, boundingBox});
        entityLocator.setEntityLocation(entity, boundingBox);

        std::vector<entt::entity> returnVector{
            entityLocator.getEntitiesFine(cylinderCenter, radius)};

        REQUIRE(returnVector.size() == 0);
    }

    SECTION("Fine cylinder - 2 out, 2 in")
    {
        // Inside an intersected cell, but outside the cylinder.
        entt::entity entity{registry.create()};
        Position& position{
            registry.emplace<Position>(entity, HALF_TILE, HALF_TILE, 0.f)};
        BoundingBox boundingBox{
            Transforms::modelToWorldCentered(modelBounds, position)};
        registry.emplace<Collision>(entity, Collision{{}, boundingBox});
        entityLocator.setEntityLocation(entity, boundingBox);

        // Outside any intersected cells.
        entt::entity entity2{registry.create()};
        Position& position2{registry.emplace<Position>(
            entity2, (CELL_WORLD_WIDTH * 3), HALF_TILE, 0.f)};
        BoundingBox boundingBox2{
            Transforms::modelToWorldCentered(modelBounds, position2)};
        registry.emplace<Collision>(entity2, Collision{{}, boundingBox2});
        entityLocator.setEntityLocation(entity2, boundingBox2);

        // Inside the cylinder, touching a single intersected cell.
        entt::entity entity3{registry.create()};
        Position& position3{
            registry.emplace<Position>(entity3, (CELL_WORLD_WIDTH + HALF_TILE),
                                       (CELL_WORLD_WIDTH + HALF_TILE), 0.f)};
        BoundingBox boundingBox3{
            Transforms::modelToWorldCentered(modelBounds, position3)};
        registry.emplace<Collision>(entity3, Collision{{}, boundingBox3});
        entityLocator.setEntityLocation(entity3, boundingBox3);

        // Inside the cylinder, touching 2 intersected cells.
        entt::entity entity4{registry.create()};
        Position& position4{registry.emplace<Position>(
            entity4, (CELL_WORLD_WIDTH + HALF_TILE), CELL_WORLD_WIDTH, 0.f)};
        BoundingBox boundingBox4{
            Transforms::modelToWorldCentered(modelBounds, position4)};
        registry.emplace<Collision>(entity4, Collision{{}, boundingBox4});
        entityLocator.setEntityLocation(entity4, boundingBox4);

        std::vector<entt::entity> returnVector{
            entityLocator.getEntitiesFine(cylinderCenter, radius)};

        REQUIRE(returnVector.size() == 2);
        REQUIRE(((returnVector.at(0) == entity3)
                 || (returnVector.at(0) == entity4)));
        REQUIRE(((returnVector.at(1) == entity3)
                 || (returnVector.at(1) == entity4)));
    }

    SECTION("Course tile extent - Touching multiple cells")
    {
        // In the first cell
        entt::entity entity{registry.create()};
        Position& position{
            registry.emplace<Position>(entity, HALF_TILE, HALF_TILE, 0.f)};
        BoundingBox boundingBox{
            Transforms::modelToWorldCentered(modelBounds, position)};
        registry.emplace<Collision>(entity, Collision{{}, boundingBox});
        entityLocator.setEntityLocation(entity, boundingBox);

        // In the second cell
        entt::entity entity2{registry.create()};
        Position& position2{registry.emplace<Position>(
            entity2, (CELL_WORLD_WIDTH + HALF_TILE), HALF_TILE, 0.f)};
        BoundingBox boundingBox2{
            Transforms::modelToWorldCentered(modelBounds, position2)};
        registry.emplace<Collision>(entity2, Collision{{}, boundingBox2});
        entityLocator.setEntityLocation(entity2, boundingBox2);

        TileExtent tileExtent{(SharedConfig::CELL_WIDTH / 2), 0,
                              SharedConfig::CELL_WIDTH, 1};
        std::vector<entt::entity>* returnVector{
            &(entityLocator.getEntitiesCoarse(tileExtent))};

        REQUIRE(returnVector->size() == 2);
        REQUIRE(returnVector->at(0) == entity);
        REQUIRE(returnVector->at(1) == entity2);
    }
}

```

`Source/Tests/UnitTests/Private/TestMain.cpp`:

```cpp
#include "catch2/catch_all.hpp"

int main(int argc, char* argv[])
{
    /* Run Tests */
    int result = Catch::Session().run(argc, argv);

    return result;
}

```

`Source/Tools/CMakeLists.txt`:

```txt
# Configure tools.
# Note: This doesn't have a real implementation yet, just some example code.
#       It's expected to not compile without changes.
#add_subdirectory(EngineDatabaseMigrator)

```

`Source/Tools/EngineDatabaseMigrator/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

message(STATUS "Configuring EngineDatabaseMigrator")

add_executable(EngineDatabaseMigrator
    Private/EngineDatabaseMigratorMain.cpp
    Private/MigrateEngineComponents.cpp
    Private/MigrateEngineComponents.h
    Private/MigrationRunner.cpp
    Private/MigrationRunner.h
)

target_include_directories(EngineDatabaseMigrator
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Private
)

target_link_libraries(EngineDatabaseMigrator
    PRIVATE
        AmalgamEngine::SharedLib
        AmalgamEngine::ServerLib
        SQLiteCpp
        sqlite3
)

# Compile with C++23.
target_compile_features(EngineDatabaseMigrator PRIVATE cxx_std_23)
set_target_properties(EngineDatabaseMigrator PROPERTIES CXX_EXTENSIONS OFF)

# Enable compile warnings.
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    target_compile_options(EngineDatabaseMigrator PUBLIC -Wall -Wextra)
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    target_compile_options(EngineDatabaseMigrator PUBLIC /W3 /permissive-)
endif()

```

`Source/Tools/EngineDatabaseMigrator/Private/EngineDatabaseMigratorMain.cpp`:

```cpp
#include "MigrationRunner.h"
#include "MigrateEngineComponents.h"
#include "EnginePersistedComponentTypes.h"
#include "Log.h"

#include "SQLiteCpp/SQLiteCpp.h"
#include <SDL_stdinc.h>
#include <iostream>

#ifdef SQLITECPP_ENABLE_ASSERT_HANDLER
namespace SQLite
{
void assertion_failed(char const* apFile, int apLine, char const* apFunc,
                      char const* apExpr, char const* apMsg)
{
    LOG_ERROR("%s: %s: error: assertion failed(%s) in %s() with message \"%s\"",
              apFile, apLine, apExpr, apFunc, apMsg);
}
} // namespace SQLite
#endif

using namespace AM;
// Note: Database migrations are only relevant to the server, so we shouldn't 
//       hit any clashes with the Client namespace.
using namespace AM::Server;
using namespace AM::DM;

/**
 * Migration info for each piece of database data that the engine controls.
 */
std::vector<MigrationInfo> engineMigrationInfo{
    {"EngineComponents", ENGINE_COMPONENTS_VERSION,
     MigrateEngineComponents::migrate}};

int main(int argc, char** argv)
{
    if (argc != 2) {
        std::printf("Too few arguments.\n");
        std::printf("Usage: EngineDatabaseMigrator.exe <DatabasePath>\n"
                    "  Updates all engine-controlled data in the given "
                    "Database.db3 file to the latest version.\n");
        std::fflush(stdout);
        return 1;
    }

    // Open the given database file.
    std::unique_ptr<SQLite::Database> database{};
    try {
        database = std::make_unique<SQLite::Database>(argv[1],
                                                      SQLite::OPEN_READWRITE);
    } catch (std::exception&) {
        std::printf("Invalid database file: %s.\nMust be Amalgam Engine's "
                    "Database.db3\n",
                    argv[1]);
        return 1;
    }

    // Perform any necessary migrations.
    MigrationRunner::migrate(*database, engineMigrationInfo);

    return 0;
}

```

`Source/Tools/EngineDatabaseMigrator/Private/MigrateEngineComponents.cpp`:

```cpp
#include "MigrateEngineComponents.h"
#include "EnginePersistedComponentTypes.h"
#include "Serialize.h"
#include "Deserialize.h"
#include "VariantTools.h"
#include "SQLiteCpp/SQLiteCpp.h"
#include "Log.h"
#include "entt/fwd.hpp"

// Note: This is all just example code used in testing. The test involved 
//       adding a "MyNewComponent" struct to the middle of the component type 
//       list.
//       If we end up doing this a lot, we should make some helper functions 
//       to make this process easier.
namespace AM
{
using EnginePersistedComponentTypesV0
    = boost::mp11::mp_list<Name, Position, Rotation, GraphicState, Interaction,
                           Server::ItemHandlers, Server::Dialogue,
                           EntityInitScript, Server::StoredValues>;
using EnginePersistedComponentV0
    = boost::mp11::mp_rename<EnginePersistedComponentTypesV0, std::variant>;
template<typename S>
void serialize(S& serializer,
               std::vector<EnginePersistedComponentV0>& engineComponents)
{
    serializer.enableBitPacking([&](typename S::BPEnabledType& sbp) {
        sbp.container(
            engineComponents,
            boost::mp11::mp_size<EnginePersistedComponentTypesV0>::value,
            [](typename S::BPEnabledType& serializer,
               EnginePersistedComponentV0& component) {
                serializer.ext(component, bitsery::ext::StdVariant{});
            });
    });
}

namespace DM
{
MigrationStatus MigrateEngineComponents::migrate(SQLite::Database& database,
                                                 unsigned int currentVersion,
                                                 unsigned int desiredVersion)
{
    try {
        for (unsigned int i{currentVersion}; i < desiredVersion; ++i) {
            switch (i) {
                case 0: {
                    migrateV0ToV1(database);
                    break;
                }
                default: {
                    return MigrationStatus::ImplementationMissing;
                }
            }
        }
    } catch (SQLite::Exception& e) {
        LOG_INFO("Database error: %s", e.what());
        return MigrationStatus::DatabaseError;
    }

    return MigrationStatus::Success;
}

void MigrateEngineComponents::migrateV0ToV1(SQLite::Database& database)
{
    // Changes from V0 -> V1:
    //   EngineComponents
    //     Added MyNewComponent

    // Scratch buffers.
    std::vector<EnginePersistedComponentV0> engineComponentsV0{};
    std::vector<Server::EnginePersistedComponent> engineComponents{};
    std::vector<Uint8> workBuffer{};

    // Queries.
    SQLite::Statement iterateEntitiesQuery{database, "SELECT * FROM entities"};
    SQLite::Statement updateEntityQuery{
        database, "UPDATE entities SET engineComponents=? WHERE id=?"};
    SQLite::Statement updateVersionQuery{
        database,
        "UPDATE versions SET versionNumber=? WHERE name='EngineComponents'"};

    // Iterate all entities, updating their engine components.
    while (iterateEntitiesQuery.executeStep()) {
        SQLite::Column idColumn{iterateEntitiesQuery.getColumn(0)};
        SQLite::Column engineComponentDataColumn{
            iterateEntitiesQuery.getColumn(1)};

        // Deserialize the entity's component data as V0.
        engineComponentsV0.clear();
        Deserialize::fromBuffer(
            static_cast<const Uint8*>(engineComponentDataColumn.getBlob()),
            static_cast<std::size_t>(engineComponentDataColumn.getBytes()),
            engineComponentsV0);

        // Copy the data to the new format.
        engineComponents.clear();
        for (auto& engineComponentV0 : engineComponentsV0) {
            // V1 has all of V0's components, so we don't need to do anything 
            // special. Just get it in the new variant format.
            std::visit(VariantTools::Overload(
                [&](const auto& component) {
                    engineComponents.push_back(component);
                }),
                engineComponentV0);
        }

        // Serialize the updated data.
        workBuffer.clear();
        workBuffer.resize(Serialize::measureSize(engineComponents));
        Serialize::toBuffer(workBuffer.data(), workBuffer.size(),
                            engineComponents);

        // Update the database.
        updateEntityQuery.bind(1, workBuffer.data(),
                               static_cast<int>(workBuffer.size()));
        updateEntityQuery.bind(2, idColumn.getInt());
        updateEntityQuery.exec();
        updateEntityQuery.reset();
    }

    // Update successful, set the new version number.
    int newVersionNumber{1};
    updateVersionQuery.bind(1, newVersionNumber);
    updateVersionQuery.exec();
}

} // End namespace DM
} // End namespace AM

```

`Source/Tools/EngineDatabaseMigrator/Private/MigrateEngineComponents.h`:

```h
#pragma once

#include "MigrationRunner.h"

namespace SQLite
{
class Database;
}

namespace AM
{
namespace DM
{

class MigrateEngineComponents
{
public:
    /**
     * Migrates any engine entity components in the given database from 
     * currentVersion to desiredVersion.
     */
    static MigrationStatus migrate(SQLite::Database& database,
                                   unsigned int currentVersion,
                                   unsigned int desiredVersion);

private:
    static void migrateV0ToV1(SQLite::Database& database);
};

} // End namespace DM
} // End namespace AM

```

`Source/Tools/EngineDatabaseMigrator/Private/MigrationRunner.cpp`:

```cpp
#include "MigrationRunner.h"
#include "SQLiteCpp/SQLiteCpp.h"
#include "Log.h"

namespace AM
{
namespace DM
{

void MigrationRunner::migrate(SQLite::Database& database,
                              std::vector<MigrationInfo>& migrationInfoVec)
{
    std::printf("Checking database for required migrations...\n");

    // Iterate through each version row.
    SQLite::Statement getVersionQuery{database, "SELECT * FROM versions"};
    while (getVersionQuery.executeStep()) {
        const char* name{getVersionQuery.getColumn(1).getText()};
        unsigned int versionNumber{
            static_cast<unsigned int>(getVersionQuery.getColumn(2).getInt())};

        // Match the name to one of our expected names and check the version 
        // number. If it's newer than the code, fail immediately. If it's 
        // older, perform the required migrations.
        for (const auto& migrationInfo : migrationInfoVec) {
            if (migrationInfo.name == name) {
                if (versionNumber > migrationInfo.codeVersion) {
                    LOG_FATAL("Migration error: %s version in database (v%u) "
                              "is newer than code (v%u).",
                              migrationInfo.name.c_str(), versionNumber,
                              migrationInfo.codeVersion);
                }
                else if (versionNumber < migrationInfo.codeVersion) {
                    MigrationStatus status{migrationInfo.migrationFunction(
                        database, versionNumber, migrationInfo.codeVersion)};
                    if (status == MigrationStatus::Success) {
                        std::printf("%s migrated to v%u.\n",
                                    migrationInfo.name.c_str(),
                                    migrationInfo.codeVersion);
                    }
                    else if (status == MigrationStatus::ImplementationMissing) {
                        LOG_FATAL("Migration error: Implementation is missing "
                                  "for %s v%u -> v%u.",
                                  migrationInfo.name.c_str(), versionNumber,
                                  migrationInfo.codeVersion);
                    }
                    else {
                        LOG_FATAL("Error while performing migration.");
                    }
                }
                else {
                    LOG_INFO("%s is up to date.", migrationInfo.name.c_str());
                }

                break;
            }
        }
    }

    std::printf("Migration complete.\n");
}

} // End namespace DM
} // End namespace AM

```

`Source/Tools/EngineDatabaseMigrator/Private/MigrationRunner.h`:

```h
#pragma once

#include <functional>
#include <vector>
#include <string>

namespace SQLite
{
class Database;
}

namespace AM
{
namespace DM
{

enum class MigrationStatus
{
    Success,
    /** A migration function is missing. */
    ImplementationMissing,
    /** An error occured while performing a database query. */
    DatabaseError
};

struct MigrationInfo
{
    /** The name of this piece of data. Should match the "name" column in the 
        "versions" table. */
    std::string name{};

    /** The latest version for this piece of data.
        Should be filled with a constant so it gets auto-updated. */
    unsigned int codeVersion{};

    /** The function to call to perform a migration on this piece of data. */
    std::function<MigrationStatus(SQLite::Database& database,
                                  unsigned int currentVersion,
                                  unsigned int desiredVersion)>
        migrationFunction;
};

/**
 * Runs the migration process, checking for out of date data and calling the 
 * appropriate migration functions.
 */
class MigrationRunner
{
public:
    /**
     * Performs any necessary migrations on the given database, using the given 
     * migration info.
     */
    static void migrate(SQLite::Database& database,
                        std::vector<MigrationInfo>& migrationInfoVec);
};

} // End namespace DM
} // End namespace AM

```