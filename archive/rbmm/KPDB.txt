Project Path: arc_rbmm_KPDB_c_wwvc_d

Source Tree:

```txt
arc_rbmm_KPDB_c_wwvc_d
├── OpenPdb.cpp
├── README.md
├── kpdb.vcxproj
├── kpdb.vcxproj.filters
├── kpdb.vcxproj.user
├── load.cpp
├── module.cpp
├── module.h
├── pdb.cpp
├── pdb.h
├── pdb_util.h
├── stdafx.cpp
├── stdafx.h
├── x64.asm
├── x64.obj
└── x86.asm

```

`OpenPdb.cpp`:

```cpp
#include "STDAFX.H"

_NT_BEGIN

NTSTATUS OpenPdb(PHANDLE phFile, PCWSTR FilePath)
{
	UNICODE_STRING ObjectName;
	OBJECT_ATTRIBUTES oa = { sizeof(oa), 0, &ObjectName};
	RtlInitUnicodeString(&ObjectName, FilePath);
	IO_STATUS_BLOCK iosb;
	return NtOpenFile(phFile, FILE_GENERIC_READ, &oa, &iosb, FILE_SHARE_VALID_FLAGS, FILE_SYNCHRONOUS_IO_NONALERT);
}

NTSTATUS OpenPdb(PHANDLE phFile, PCSTR PdbFileName, PCWSTR NtSymbolPath, PGUID Signature, ULONG Age)
{
	NTSTATUS status;

	PWSTR FilePath = 0, psz = 0;
	ULONG cb = 0, len = (ULONG)strlen(PdbFileName) + 1;

	if (strchr(PdbFileName, '\\'))
	{
		while (0 <= (status = RtlUTF8ToUnicodeN(psz, cb, &cb, PdbFileName, len)))
		{
			if (psz)
			{
				return OpenPdb(phFile, FilePath);
			}

			static const WCHAR global[] = L"\\GLOBAL??\\";

			FilePath = (PWSTR)memcpy(alloca(cb + sizeof(global)), global, sizeof(global));
			psz = FilePath + _countof(global) - 1;
		}

		return status;
	}

	int s = 0;

	while (0 <= (status = RtlUTF8ToUnicodeN(psz, cb, &cb, PdbFileName, len)) &&
		0 < (s = _snwprintf(FilePath, s, L"%ws\\%*ws\\%08X%04X%04X%02X%02X%02X%02X%02X%02X%02X%02X%x\\",
			NtSymbolPath, (int)(cb / sizeof(WCHAR)) - 1, psz ? psz : L"",
			Signature->Data1, Signature->Data2, Signature->Data3,
			Signature->Data4[0], Signature->Data4[1], Signature->Data4[2], Signature->Data4[3],
			Signature->Data4[4], Signature->Data4[5], Signature->Data4[6], Signature->Data4[7],
			Age)))
	{
		if (psz)
		{
			return OpenPdb(phFile, FilePath);
		}

		psz = (FilePath = (PWSTR)alloca(cb + s * sizeof(WCHAR))) + s;
	}

	return 0 > status ? status : STATUS_INTERNAL_ERROR;	
}

struct PdbFileHeader;

#include "pdb_util.h"

NTSTATUS ParsePDB(PdbFileHeader* header, SIZE_T ViewSize, PGUID signature, DWORD age, SymStore* pss);

NTSTATUS SymStore::GetSymbols(PCWSTR PdbPath)
{
	HANDLE hFile;
	NTSTATUS status = OpenPdb(&hFile, PdbPath);

	return 0 > status ? status : GetSymbols(hFile, 0, 0);
}

NTSTATUS SymStore::GetSymbols(HANDLE hFile, PGUID signature, DWORD age)
{
	HANDLE hSection;

	NTSTATUS status = NtCreateSection(&hSection, SECTION_MAP_READ, 0, 0, PAGE_READONLY, SEC_COMMIT, hFile);

	NtClose(hFile);

	if (0 > status) return status;

	PVOID BaseAddress = 0;
	SIZE_T ViewSize = 0;

	status = ZwMapViewOfSection(hSection, NtCurrentProcess(), &BaseAddress, 0, 0, 0, &ViewSize, ViewUnmap, 0, PAGE_READONLY);

	NtClose(hSection);

	if (0 > status) return status;

	status = ParsePDB((PdbFileHeader*)BaseAddress, ViewSize, signature, age, this);

	ZwUnmapViewOfSection(NtCurrentProcess(), BaseAddress);

	return status;
}

NTSTATUS SymStore::GetSymbols(HMODULE hmod, PCWSTR NtSymbolPath)
{
	DWORD cb;
	BOOLEAN bMappedAsImage = !((DWORD_PTR)hmod & (PAGE_SIZE - 1));
	PIMAGE_DEBUG_DIRECTORY pidd = (PIMAGE_DEBUG_DIRECTORY)RtlImageDirectoryEntryToData(hmod, bMappedAsImage, IMAGE_DIRECTORY_ENTRY_DEBUG, &cb);

	if (!pidd || !cb || (cb % sizeof IMAGE_DEBUG_DIRECTORY)) return STATUS_NOT_FOUND;

	do 
	{
		struct CV_INFO_PDB 
		{
			DWORD CvSignature;
			GUID Signature;
			DWORD Age;
			char PdbFileName[];
		};

		if (pidd->Type == IMAGE_DEBUG_TYPE_CODEVIEW && pidd->SizeOfData > sizeof(CV_INFO_PDB))
		{
			if (DWORD PointerToRawData = bMappedAsImage ? pidd->AddressOfRawData : pidd->PointerToRawData)
			{
				CV_INFO_PDB* lpcvh = (CV_INFO_PDB*)RtlOffsetToPointer(PAGE_ALIGN(hmod), PointerToRawData);

				if (lpcvh->CvSignature == 'SDSR')
				{
					HANDLE hFile;
					NTSTATUS status = OpenPdb(&hFile, lpcvh->PdbFileName, 
						NtSymbolPath, &lpcvh->Signature, lpcvh->Age);

					return 0 > status ? status : GetSymbols(hFile, &lpcvh->Signature, lpcvh->Age);
				}
			}
		}

	} while (pidd++, cb -= sizeof(IMAGE_DEBUG_DIRECTORY));

	return STATUS_NOT_FOUND;
}

_NT_END
```

`README.md`:

```md
# KPDB
 
	// ULONG h = HashString("ntoskrnl.exe");
	// LoadNtModule(1, &h);
	ULONG h[] = { HashString("ntoskrnl.exe"), HashString("***.sys") };
	LoadNtModule(_countof(h), h);
	DumpStack(__FUNCTION__);
	if (PCUNICODE_STRING CmpLogPath = (PCUNICODE_STRING)CModule::GetVaFromName("ntoskrnl.exe", "CmpLogPath"))
	{
		DbgPrint("%hs = \"%wZ\"\r\n", "CmpLogPath", CmpLogPath);
	}
...

CModule::Cleanup();
```

`kpdb.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7862A871-e1d0-D97B-67B1-2EDA057B83A8}</ProjectGuid>
    <RootNamespace>kpdb</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <UserRootDir>$(SolutionDir)..\MSBuild\v4.0</UserRootDir>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <Optimization>MaxSpeed</Optimization>
      <DisableSpecificWarnings>4996</DisableSpecificWarnings>
      <AdditionalOptions>/kernel %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableUAC>false</EnableUAC>
      <EntryPointSymbol>ep</EntryPointSymbol>
      <AdditionalOptions>/EMITPOGOPHASEINFO /EMITVOLATILEMETADATA:NO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="module.h" />
    <ClInclude Include="pdb.h" />
    <ClInclude Include="pdb_util.h" />
    <ClInclude Include="stdafx.h" />
    <ClCompile Include="load.cpp" />
    <ClCompile Include="module.cpp" />
    <ClCompile Include="OpenPdb.cpp" />
    <ClCompile Include="pdb.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader>Create</PrecompiledHeader>
    </ClCompile>
    <CustomBuild Include="x64.asm">
      <FileType>Document</FileType>
      <Command>ml64 /c /Cp %(Identity)</Command>
      <Outputs>%(Filename).obj</Outputs>
      <ExcludedFromBuild Condition="'$(PlatformTarget)'!='x64' or !exists('%(Identity)')">true</ExcludedFromBuild>
    </CustomBuild>
    <CustomBuild Include="x86.asm">
      <FileType>Document</FileType>
      <Command>ml /c /Cp %(Identity)</Command>
      <Outputs>%(Filename).obj</Outputs>
      <ExcludedFromBuild Condition="'$(PlatformTarget)'!='x86' or !exists('%(Identity)')">true</ExcludedFromBuild>
    </CustomBuild>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`kpdb.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="load.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="module.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="OpenPdb.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pdb.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="module.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pdb.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pdb_util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="x64.asm">
      <Filter>Source Files</Filter>
    </CustomBuild>
    <CustomBuild Include="x86.asm">
      <Filter>Source Files</Filter>
    </CustomBuild>
  </ItemGroup>
</Project>
```

`kpdb.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`load.cpp`:

```cpp
#include "stdafx.h"

_NT_BEGIN

#include "module.h"

ULONG* __fastcall findDWORD(SIZE_T, const ULONG*, ULONG);

ULONG HashString(PCSTR lpsz, ULONG hash /*= 0*/)
{
	while (char c = *lpsz++) hash = hash * 33 + (c | 0x20);
	return hash;
}

void LoadNtModule(ULONG n, const ULONG ph[])
{
	ULONG cb = 0x10000;
	NTSTATUS status;
	do 
	{
		status = STATUS_INSUFF_SERVER_RESOURCES;
		if (PRTL_PROCESS_MODULES buf = (PRTL_PROCESS_MODULES)ExAllocatePool(PagedPool, cb += PAGE_SIZE))
		{
			if (0 <= (status = NtQuerySystemInformation(SystemModuleInformation, buf, cb, &cb)))
			{
				if (ULONG NumberOfModules = buf->NumberOfModules)
				{
					PRTL_PROCESS_MODULE_INFORMATION Modules = buf->Modules;
					do 
					{
						PCSTR name = Modules->FullPathName + Modules->OffsetToFileName;
						ULONG hash = HashString(name);

						// DbgPrint("%08X %hs\r\n", hash, name);

						if (findDWORD(n, ph, hash))
						{
							CModule::Create(hash, name, Modules->ImageBase, Modules->ImageSize);
						}
					} while (Modules++, --NumberOfModules);
				}
			}

			ExFreePool(buf);
		}
	} while (status == STATUS_INFO_LENGTH_MISMATCH);
}

void DumpStack(PCSTR txt)
{
	PVOID pv[32];
	if (ULONG n = RtlWalkFrameChain(pv, _countof(pv), 0))
	{
		DbgPrint(">>> ************* %s\n", txt);

		do 
		{
			PVOID p = pv[--n];
			ULONG d;
			PCSTR name;

			if (PCSTR psz = CModule::GetNameFromVa(p, &d, &name))
			{
				DbgPrint(">> %p %s!%s + %x\n", p, name, psz, d);
			}
			else
			{
				DbgPrint(">> %p\n", p);
			}
		} while (n);

		DbgPrint("<<<< ************* %s\n", txt);
	}
}

_NT_END
```

`module.cpp`:

```cpp
#include "stdafx.h"

_NT_BEGIN

#include "module.h"
#include "pdb_util.h"

LIST_ENTRY CModule::s_head = { &s_head, &s_head };

CModule* CModule::ByHash(ULONG hash)
{
	CModule* p = 0;
	PLIST_ENTRY entry = &s_head;

	while ((entry = entry->Flink) != &s_head)
	{
		p = static_cast<CModule*>(entry);

		if (p->_hash== hash)
		{
			return p;
		}
	}

	return 0;
}

PVOID CModule::GetVaFromName(PCSTR pszModule, PCSTR Name)
{
	if (CModule* p = ByName(pszModule))
	{
		return p->GetVaFromName(Name);
	}

	return 0;
}

PVOID CModule::GetVaFromName(PCSTR Name)
{
	if (ULONG n = _nSymbols)
	{
		RVAOFS* Symbols = _Symbols;

		do 
		{
			if (!strcmp(Name, RtlOffsetToPointer(this, Symbols->ofs)))
			{
				return (PBYTE)_ImageBase + Symbols->rva;
			}
		} while (Symbols++, --n);
	}

	return 0;
}

PCSTR CModule::GetNameFromVa(PVOID pv, PULONG pdisp, PCSTR* ppname)
{
	PLIST_ENTRY entry = &s_head;
	
	while ((entry = entry->Flink) != &s_head)
	{
		CModule* p = static_cast<CModule*>(entry);

		ULONG_PTR rva = (ULONG_PTR)pv - (ULONG_PTR)p->_ImageBase;
		
		if (rva < p->_size)
		{
			return p->GetNameFromRva((ULONG)rva, pdisp, ppname);
		}
	}

	return 0;
}

PCSTR CModule::GetNameFromRva(ULONG rva, PULONG pdisp, PCSTR* ppname)
{
	*ppname = _name;
	ULONG a = 0, b = _nSymbols, o, s_rva;

	if (!b)
	{
		*pdisp = rva;
		return "MZ";
	}

	RVAOFS* Symbols = _Symbols;

	do 
	{
		if (rva == (s_rva = Symbols[o = (a + b) >> 1].rva))
		{
			*pdisp = 0;
__0:
			return RtlOffsetToPointer(this, Symbols[o].ofs);
		}

		rva < s_rva ? b = o : a = o + 1;

	} while (a < b);

	if (rva < s_rva)
	{
		if (!o)
		{
			return 0;
		}
		s_rva = Symbols[--o].rva;
	}

	*pdisp = (ULONG)rva - s_rva;

	goto __0;
}

NTSTATUS CModule::Create(ULONG hash, PCSTR name, PVOID ImageBase, ULONG size)
{
	DbgPrint("%hs(%08x, %hs, %p, %08x) %p\r\n", __FUNCTION__, hash, name, ImageBase, size);
	
	// if (ImageBase == &__ImageBase) return 0; // load pdb for self ?!

	struct Z : SymStore 
	{
		CModule* _pModule = 0;
		CV_INFO_PDB* _lpcvh = 0;

		virtual NTSTATUS OnOpenPdb(NTSTATUS status, CV_INFO_PDB* lpcvh)
		{
			_lpcvh = lpcvh;
			return status;
		}

		virtual void Symbols(_In_ RVAOFS* pSymbols, _In_ ULONG nSymbols, _In_ PSTR names)
		{
			ULONG n = nSymbols, cbNames = 0;

			RVAOFS* p = pSymbols;
			do 
			{
				cbNames += (ULONG)strlen(names + p++->ofs) + 1;
			} while (--n);

			if (CModule* pDll = new(nSymbols, cbNames) CModule)
			{
				_pModule = pDll;

				p = pDll->_Symbols;
				PSTR names_copy = (PSTR)&p[nSymbols];
				cbNames = RtlPointerToOffset(pDll, names_copy);
				do 
				{
					p->rva = pSymbols->rva;
					p++->ofs = cbNames;
					ULONG ofs = pSymbols++->ofs;
					PCSTR name = names + ofs;
					ULONG len = (ULONG)strlen(name) + 1;
					memcpy(names_copy, name, len);
					names_copy += len, cbNames += len;

				} while (--nSymbols);
			}
		}

		static BOOL SpecialSymbol(_In_ PCSTR name)
		{
			// __IMPO
			// __DELA
			if (name[0] == '_' && name[1] == '_')
			{
				if ((name[2] == 'I' && name[3] == 'M' && name[4] == 'P' && name[5] == 'O') &&
					(name[2] == 'D' && name[3] == 'E' && name[4] == 'L' && name[5] == 'A'))
				{
					return TRUE;
				}
			}

			// WPP_

			return name[0] == 'W' && name[1] == 'P' && name[2] == 'P' && name[3] == '_';
		}

		virtual BOOL IncludeSymbol(_In_ PCSTR name)
		{
			return (name[0] != '?' || name[1] != '?') && __super::IncludeSymbol(name) && !SpecialSymbol(name);
		}

	} ss;

	NTSTATUS status = ss.GetSymbols((HMODULE)ImageBase, L"\\systemroot\\symbols");

	if (0 <= status)
	{
		if (CModule* pModule = ss._pModule)
		{
			pModule->Init(hash, name, ImageBase, size);
			return STATUS_SUCCESS;
		}

		return STATUS_UNSUCCESSFUL;
	}

	return status;
}

void CModule::Cleanup()
{
	PLIST_ENTRY entry = s_head.Flink;

	while (entry != &s_head)
	{
		CModule* p = static_cast<CModule*>(entry);
		
		entry = entry->Flink;

		delete p;
	}
}

_NT_END


```

`module.h`:

```h
#pragma once

#include "pdb_util.h"

void LoadNtModule(ULONG n, const ULONG ph[]);
void DumpStack(PCSTR txt);
ULONG HashString(PCSTR lpsz, ULONG hash = 0);

class CModule : LIST_ENTRY
{
	PVOID _ImageBase;
	ULONG _size;
	ULONG _hash;
	ULONG _nSymbols;
	char _name[32];
	RVAOFS _Symbols[];
	//CHAR Names[];
	void Init(ULONG hash, PCSTR name, PVOID ImageBase, ULONG size)
	{
		_hash = hash, _size = size, _ImageBase = ImageBase;
		strcpy_s(_name, _countof(_name), name);
		DbgPrint("++CModule<%p>(%s) %p\n", this, name, ImageBase);
	}

	static LIST_ENTRY s_head;

	CModule()
	{
		InsertHeadList(&s_head, this);
	}

	~CModule()
	{
		DbgPrint("--CModule<%p>(%s) %p\n", this, _name, _ImageBase);
	}

	PCSTR GetNameFromRva(ULONG rva, PULONG pdisp, PCSTR* ppname);
public:

	void* operator new(size_t s, ULONG nSymbols, ULONG cbNames)
	{
		if (PVOID pv = ::operator new(s + nSymbols * sizeof(RVAOFS) + cbNames, NonPagedPoolNx))
		{
			reinterpret_cast<CModule*>(pv)->_nSymbols = nSymbols;
			return pv;
		}
		return 0;
	}

	void operator delete(void* pv)
	{
		ExFreePool(pv);
	}

	static NTSTATUS Create(ULONG hash, PCSTR name, PVOID ImageBase, ULONG size);
	static PVOID GetVaFromName(PCSTR pszModule, PCSTR Name);
	static PCSTR GetNameFromVa(PVOID pv, PULONG pdisp, PCSTR* ppname);

	PVOID GetVaFromName(PCSTR Name);
	static CModule* ByName(PCSTR pszModule)
	{
		return ByHash(HashString(pszModule));
	}

	static CModule* ByHash(ULONG hash);

	static void Cleanup();
};
```

`pdb.cpp`:

```cpp
#include "STDAFX.H"

_NT_BEGIN

#include "PDB.h"

class PdbReader
{
	DbiHeader* _pdh;
	PIMAGE_SECTION_HEADER _pish;
	OMAP* _pvOmapFromSrc;
	PVOID _BaseAddress, _PdbBase;
	PLONG _StreamSizes;
	PULONG _StreamPages;
	PUSHORT _pFileInfo;
	ULONG _pageSize, _pagesUsed, _nStreams, _nSections, _nOmapFromSrc;
	BOOLEAN _bUnmap, _Is64Bit;

	PULONG GetStreamPages(ULONG iStream)
	{
		if (iStream < _nStreams)
		{
			ULONG pageSize = _pageSize;
			PLONG StreamSizes = _StreamSizes;
			PULONG StreamPages = _StreamPages;

			do 
			{
				if (ULONG StreamSize = *StreamSizes++)
				{
					StreamPages += (StreamSize + pageSize - 1) / pageSize;
				}
			} while (--iStream);

			return StreamPages;
		}

		return 0;
	}

	BOOL Read(ULONG StreamPages[], ULONG ofs, PBYTE pb, ULONG cb)
	{
		PVOID PdbBase = _PdbBase;
		ULONG cbCopy, pagesUsed = _pagesUsed, Page, PageSize = _pageSize;

		StreamPages += ofs / PageSize;

		if (ofs %= PageSize)
		{
			if ((Page = *StreamPages++) >= pagesUsed) 
			{
				return FALSE;
			}

			memcpy(pb, RtlOffsetToPointer(PdbBase, Page * PageSize) + ofs, cbCopy = min(PageSize - ofs, cb));

			pb += cbCopy, cb -= cbCopy;
		}

		if (cb)
		{
			do 
			{
				if ((Page = *StreamPages++) >= pagesUsed) 
				{
					return FALSE;
				}

				memcpy(pb, RtlOffsetToPointer(PdbBase, Page * PageSize), cbCopy = min(PageSize, cb));

			} while (pb += cbCopy, cb -= cbCopy);
		}

		return TRUE;
	}

	BOOL ValidatePdbHeader(PGUID signature = 0)
	{
		PdbHeader psh;
		return _StreamSizes[PDB_STREAM_PDB] > sizeof(PdbHeader) && 
			Read(PDB_STREAM_PDB, 0, &psh, sizeof(psh)) && 
			psh.impv == PDBImpv && 
			(!signature || psh.signature == *signature);
	}

public:

	BOOL Read(DWORD iStream, DWORD ofs, PVOID pb, DWORD cb)
	{
		PULONG StreamPages = GetStreamPages(iStream);
		return StreamPages ? Read(StreamPages, ofs, (PBYTE)pb, cb) : FALSE;
	}

	NTSTATUS getStream(ULONG iStream, void** ppv, PULONG pcb, LONG minSize = 1, ULONG mult = 1)
	{
		if (iStream >= _nStreams)
		{
			return STATUS_NOT_FOUND;
		}

		LONG cb = _StreamSizes[iStream];

		if (minSize > cb || cb % mult)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		if (PVOID pv = new(PagedPool) CHAR[cb])
		{
			if (Read(iStream, 0, pv, cb))
			{
				*ppv = pv;
				*pcb = cb;
				return STATUS_SUCCESS;
			}

			delete [] pv;

			return STATUS_INVALID_IMAGE_FORMAT;
		}

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	void FreeStream(PVOID pv)
	{
		delete [] pv;
	}

	ULONG rva(ULONG segment, ULONG offset)
	{
		if (segment > _nSections || offset >= _pish[--segment].Misc.VirtualSize)
		{
			return 0;
		}

		offset += _pish[segment].VirtualAddress;

		if (OMAP* pvOmapFromSrc = _pvOmapFromSrc)
		{
			ULONG a = 0, o, r, b = _nOmapFromSrc;
			OMAP *s = 0, *q;

			if (offset < pvOmapFromSrc->rva)
			{
				return 0;
			}

			do 
			{
				o = (a + b) >> 1;

				q = pvOmapFromSrc + o;
				r = q->rva;

				if (r == offset)
				{
					return q->rvaTo;
				}

				if (r < offset)
				{
					s = q;
					a = o + 1;
				}
				else
				{
					b = o;
				}

			} while (a < b);

			return (offset - s->rva) + s->rvaTo;
		}

		return offset;
	}

	NTSTATUS Init(PdbFileHeader* header, SIZE_T ViewSize, PGUID signature, ULONG Age)
	{
		ULONG pageSize = header->pageSize, pagesUsed = header->pagesUsed;

		if (ViewSize < pageSize * pagesUsed)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		ULONG directoryRoot = header->directoryRoot, directorySize = header->directorySize;

		if (directorySize < sizeof(ULONG))
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		ULONG directoryEnd = ((((directorySize + pageSize - 1) / pageSize) * sizeof(ULONG) + pageSize - 1) / pageSize) + directoryRoot;

		if (directoryEnd <= directoryRoot || directoryEnd > pagesUsed)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		PULONG pd = (PULONG)ExAllocatePool(PagedPool, directorySize);
		if (!pd)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		_BaseAddress = pd, _PdbBase = header, _pageSize = pageSize, _pagesUsed = pagesUsed;

		if (!Read((PULONG)RtlOffsetToPointer(header, directoryRoot * pageSize), 0, (PBYTE)pd, directorySize))
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		ULONG nStreams = *pd++;
		_nStreams = nStreams;
		_StreamSizes = (PLONG)pd, _StreamPages = pd + _nStreams;

		if (nStreams <= PDB_STREAM_DBI || directorySize < (1 + nStreams) * sizeof(ULONG))
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		ULONG i = nStreams, k = 0;
		do 
		{
			k += (*pd++ + pageSize - 1) / pageSize;
		} while (--i);

		if (
			directorySize < (1 + nStreams + k) * sizeof(ULONG)
			||
			!ValidatePdbHeader(signature))
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		ULONG size;
		DbiHeader* pdh;

		NTSTATUS status;

		if (0 > (status = getStream(PDB_STREAM_DBI, (void**)&pdh, &size, sizeof(DbiHeader))))
		{
			return status;
		}

		_pdh = pdh;

		if (pdh->ver != DBIImpv)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		if (signature && pdh->age != Age)
		{
			return STATUS_REVISION_MISMATCH;
		}

		switch (pdh->machine)
		{
		case 0:
		case IMAGE_FILE_MACHINE_I386:
			_Is64Bit = FALSE;
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			_Is64Bit = TRUE;
			break;
		default: return STATUS_NOT_SUPPORTED;
		}
		ULONG a = sizeof(DbiHeader), b = a + pdh->gpmodiSize;

		if (a > b || b > size)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		ULONG secconSize = pdh->secconSize;

		a = b, b = a + secconSize;

		if (a > b || b > size)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		a = b, b = a + pdh->secmapSize;

		if (a > b || b > size)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		a = b, b = a + pdh->filinfSize;

		if (a > b || b > size)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		_pFileInfo = (PUSHORT)RtlOffsetToPointer(pdh, a);

		a = b, b = a + pdh->tsmapSize;

		if (a > b || b > size)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		a = b, b = a + pdh->ecinfoSize;

		if (a > b || b > size)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		a = b, b = a + pdh->dbghdrSize;

		if (a > b || b > size)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		if (sizeof(DbiDbgHdr) > pdh->dbghdrSize)
		{
			return STATUS_INVALID_IMAGE_FORMAT;
		}

		DbiDbgHdr* pdbgHdr = (DbiDbgHdr*)RtlOffsetToPointer(pdh, a);

		SHORT snOmapFromSrc = pdbgHdr->snOmapFromSrc, snSectionHdr = pdbgHdr->snSectionHdr;

		if (0 < snOmapFromSrc)
		{
			if (0 > (status = getStream(snOmapFromSrc, (void**)&_pvOmapFromSrc, &size, 1, sizeof(OMAP))))
			{
				return status;
			}

			_nOmapFromSrc = size / sizeof(OMAP);
			snSectionHdr = pdbgHdr->snSectionHdrOrig;
		}

		if (0 <= (status = getStream(snSectionHdr, (void**)&_pish, &size, 1, sizeof(IMAGE_SECTION_HEADER))))
		{
			_nSections = size / sizeof(IMAGE_SECTION_HEADER);
		}

		return status;
	}

	DWORD getStreamSize(ULONG iStream)
	{
		return iStream < _nStreams ? _StreamSizes[iStream] : 0;
	}

	USHORT getPublicSymbolsStreamIndex()
	{
		return _pdh->symrecStream;
	}

	DbiModuleInfo* getModuleInfo(ULONG& gpmodiSize)
	{
		gpmodiSize = _pdh->gpmodiSize;
		return (DbiModuleInfo*)(_pdh + 1);
	}

	PUSHORT getFileInfo(ULONG& filinfSize)
	{
		filinfSize = _pdh->filinfSize;
		return _pFileInfo;
	}

	~PdbReader()
	{
		if (PVOID pv = _BaseAddress)
		{
			ExFreePool(pv);
		}
	}
};

#include "pdb_util.h"

size_t __fastcall strnlen(_In_ size_t numberOfElements, _In_ const char *str);

template<typename T>
BOOL IsValidSymbol(T* ps, ULONG cb)
{
	if (FIELD_OFFSET(T, name) < cb)
	{
		ULONG len = sizeof(USHORT) + static_cast<SYM_HEADER*>(ps)->len;
		if (FIELD_OFFSET(T, name) < len && len <= cb)
		{
			len -= FIELD_OFFSET(T, name);
			if (strnlen(len, ps->name) < len)
			{
				return TRUE;
			}
		}
	}

	return FALSE;
}

C_ASSERT(sizeof(SYM_HEADER) == 4);
C_ASSERT(FIELD_OFFSET(PUBSYM32, pubsymflags) == 4);

DbiModuleInfo** getModules(_In_ PdbReader* pdb, _Out_ PULONG pn)
{
	*pn = 0;

	ULONG size, nModules, cb;
	PUSHORT pFileInfo = pdb->getFileInfo(size);
	union {
		PBYTE pb;
		DbiModuleInfo* module;
	};

	if (!pFileInfo || !(nModules = *pFileInfo) || !(module = pdb->getModuleInfo(size)))
	{
		return 0;
	}

	if (size < sizeof(DbiModuleInfo) + 2)
	{
		return 0;
	}

	PCSTR end = RtlOffsetToPointer(module, size - 2);

	if (end[0] || end[1])
	{
		return 0;
	}

	if (DbiModuleInfo** ppm = new(PagedPool) DbiModuleInfo*[nModules])
	{
		DbiModuleInfo** _ppm = ppm;
		*pn = nModules;
		do 
		{
			*ppm++ = module;
			PCSTR objectName = module->buf + strlen(module->buf) + 1;

			cb = (RtlPointerToOffset(module, objectName + strlen(objectName)) + __alignof(DbiModuleInfo)) & ~(__alignof(DbiModuleInfo) - 1);

			size -= cb, pb += cb;

		} while (--nModules && size > sizeof(DbiModuleInfo) + 1);

		if (!nModules && !size)
		{
			return _ppm;
		}

		*pn = 0;
		delete [] _ppm;
	}

	return 0;
}

struct MI 
{
	USHORT imod = MAXUSHORT;
	PBYTE _pb = 0;
	ULONG _cb;

	~MI()
	{
		if (PVOID pv = _pb)
		{
			delete [] pv;
		}
	}

	ULONG rva(DbiModuleInfo* pm, PdbReader* pdb, ULONG ibSym, PCSTR name)
	{
		USHORT s = pm->stream;
		if (s != MAXUSHORT)
		{
			union {
				PVOID pv;
				PBYTE pb;
				SYM_HEADER* ph;
				PROCSYM32* ps;
			};
			ULONG cb;
			if (s == imod)
			{
				cb = _cb, pb = _pb;
			}
			else
			{
				if (0 > pdb->getStream(s, &pv, &cb))
				{
					return 0;
				}
				if (_pb)
				{
					delete [] _pb;
					_pb = 0;
				}
				_pb = pb;
				_cb = cb;
				imod = s;
			}

			if (ibSym < cb) // Offset of actual symbol in $$Symbols
			{
				pb += ibSym, cb -= ibSym;

				if (IsValidSymbol(ps, cb))
				{
					switch (ph->type)
					{
					case S_GPROC32:
					case S_LPROC32:
					case S_GPROC32_ID:
					case S_LPROC32_ID:
					case S_LPROC32_DPC:
					case S_LPROC32_DPC_ID:
						if (!strcmp(ps->name, name))
						{
							return pdb->rva(ps->seg, ps->off);
						}
					}
				}
			}
		}

		return 0;
	}
};

int __cdecl compare(RVAOFS& a, RVAOFS& b)
{
	ULONG a_rva = a.rva, b_rva = b.rva;
	if (a_rva < b_rva) return -1;
	if (a_rva > b_rva) return +1;
	return 0;
}

struct MD 
{
	ULONG n;
	DbiModuleInfo** pmm;

	MD(PdbReader* pdb) : pmm(getModules(pdb, &n))
	{
	}

	~MD()
	{
		if (PVOID pv = pmm)
		{
			delete [] pv;
		}
	}

	DbiModuleInfo* operator[](ULONG i)
	{
		return i < n ? pmm[i] : 0;
	}
};

BOOL IsRvaExist(ULONG rva, RVAOFS *pSymbols, ULONG b)
{
	if (!b || pSymbols->rva > rva)
	{
		return 0;
	}

	ULONG a = 0, o, r;

	do 
	{
		if ((r = pSymbols[o = (a + b) >> 1].rva) == rva)
		{
			return TRUE;
		}

		r < rva ? a = o + 1 : b = o;

	} while (a < b);

	return FALSE;
}

ULONG LoadSymbols(PdbReader* pdb,
				  PVOID stream, 
				  ULONG size, 
				  MD& md, 
				  RVAOFS* pSymbolsBase,
				  ULONG nSymbols,
				  BOOL bSecondLoop)
{
	union {
		PVOID pv;
		PBYTE pb;
		SYM_HEADER* psh;
		PUBSYM32* pbs;
		PROCSYM32* pps;
		REFSYM2* pls;
	};

	pv = stream;

	DWORD n = 0, len;

	PSTR name = 0;
	MI mi;

	RVAOFS* pSymbols = pSymbolsBase + nSymbols;

	do 
	{
		len = psh->len + sizeof(WORD);

		if (size < len) 
		{
			return 0;
		}

		ULONG rva = 0;

		switch (psh->type)
		{
		case S_DATAREF:
		case S_PROCREF:
		case S_LPROCREF:
			if (bSecondLoop && IsValidSymbol(pls, size))
			{
				if (DbiModuleInfo* pm = md[pls->imod - 1])
				{
					name = pls->name;
					if (!*name)
					{
						continue;
					}
					if (rva = mi.rva(pm, pdb, pls->ibSym, pls->name))
					{
						if (!IsRvaExist(rva, pSymbolsBase, nSymbols))
						{
							break;
						}
					}
				}
			}
			continue;

		case S_PUB32:
			if (!bSecondLoop && IsValidSymbol(pbs, size))
			{
				name = pbs->name;
				if (!*name)
				{
					continue;
				}
				if (rva = pdb->rva(pbs->seg, pbs->off))
				{
					break;
				}
			}
			continue;
		default:
			continue;
		}

		pSymbols->rva = rva;
		pSymbols++->ofs = RtlPointerToOffset(stream, name);
		n++;

	} while (pb += len, size -= len);

	return n;
}

BOOL SymStore::IncludeSymbol(_In_ PCSTR name)
{
	switch (*name)
	{
	case '_':
		//__imp_ not include
		if (name[1] == '_' && name[2] == 'i' && name[3] == 'm' && name[4] == 'p' && name[5] == '_')
		{
			//__imp_load_ include
			if (name[6] == 'l' && name[7] == 'o' && name[8] == 'a' && name[9] == 'd' && name[10] == '_')
			{
				break;
			}
			return FALSE;
		}
		break;
	case '?':
		// ??_C@_ `string` - not include
		if (name[1] == '?' && name[2] == '_' && name[3] == 'C' && name[4] == '@' && name[5] == '_')
		{
			return FALSE;
		}
		break;
	}

	return TRUE;
}

ULONG GetMaxSymCount(PVOID stream, ULONG size, SymStore* pss)
{
	union {
		PVOID pv;
		PBYTE pb;
		SYM_HEADER* psh;
		PUBSYM32* pbs;
		REFSYM2* pls;
	};

	pv = stream;

	ULONG n = 0, len;

	PSTR name = 0;

	do 
	{
		len = psh->len + sizeof(WORD);

		if (size < len) 
		{
			return 0;
		}

		switch (psh->type)
		{
		case S_DATAREF:
		case S_PROCREF:
		case S_LPROCREF:
			if (IsValidSymbol(pls, size))
			{
				name = pls->name;
				break;
			}
			continue;

		case S_PUB32:
			if (IsValidSymbol(pbs, size))
			{
				name = pbs->name;
				break;
			}
			continue;
		default:
			continue;
		}

		if (pss->IncludeSymbol(name))
		{
			n++;
		}
		else
		{
			*name = 0;
		}

	} while (pb += len, size -= len);

	return n;
}

NTSTATUS LoadPublicSymbols(PdbReader* pdb, PVOID stream, ULONG size, SymStore* pss)
{
	if (ULONG n = GetMaxSymCount(stream, size, pss))
	{
		if (RVAOFS* pSymbols = new(PagedPool) RVAOFS[n])
		{
			MD md(pdb);

			if (n = LoadSymbols(pdb, stream, size, md, pSymbols, 0, FALSE))
			{
				qsort(pSymbols, n, sizeof(RVAOFS), (QSORTFN)compare);
			}

			if (n += LoadSymbols(pdb, stream, size, md, pSymbols, n, TRUE))
			{
				qsort(pSymbols, n, sizeof(RVAOFS), (QSORTFN)compare);

				pss->Symbols(pSymbols, n, (PSTR)stream);
			}

			delete [] pSymbols;

			return STATUS_SUCCESS;
		}

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	return STATUS_NOT_FOUND;
}

NTSTATUS ParsePDB(PdbFileHeader* header, SIZE_T ViewSize, PGUID signature, DWORD age, SymStore* pss)
{
	PdbReader pdb{};

	ULONG size;
	PVOID pv;
	NTSTATUS status = pdb.Init(header, ViewSize, signature, age);

	if (0 <= status)
	{
		status = STATUS_NOT_FOUND;

		USHORT symrecStream = pdb.getPublicSymbolsStreamIndex();

		if (symrecStream != MAXUSHORT)
		{
			if (0 <= (status = pdb.getStream(symrecStream, &pv, &size)))
			{
				status = LoadPublicSymbols(&pdb, pv, size, pss);
				pdb.FreeStream(pv);
			}
		}
	}

	return status; 
}

_NT_END
```

`pdb.h`:

```h
#pragma once

// PDB Stream IDs
#define PDB_STREAM_ROOT   0
#define PDB_STREAM_PDB    1
#define PDB_STREAM_TPI    2
#define PDB_STREAM_DBI    3
#define PDB_STREAM_FPO    5

// =================================================================
// PDB INTERFACE VERSIONS
// =================================================================

#define PDBIntv         20001102

// =================================================================
// PDB IMPLEMENTATION VERSIONS
// =================================================================

#define PDBImpv         20000404

// =================================================================
// DBI IMPLEMENTATION VERSIONS
// =================================================================

#define DBIImpv         19990903

struct PdbFileHeader
{
	CHAR	magic[32]; // PDB_SIGNATURE_200
	ULONG	pageSize;   // 0x0400, 0x0800, 0x1000
	ULONG	freePageMap;
	ULONG	pagesUsed;   // file size / dPageSize
	ULONG	directorySize;  // in bytes, -1 = free stream
	ULONG	zero;
	ULONG	directoryRoot; // pages containing PDB_ROOT
};

struct PdbHeader
{
	DWORD impv;
	DWORD timeDateStamp;
	DWORD age;
	GUID  signature;
};

struct DbiSecCon
{
	USHORT section;
	USHORT pad1;
	ULONG offset;
	ULONG size;
	ULONG flags;
	USHORT module;
	USHORT pad2;
	ULONG dataCrc;
	ULONG relocCrc;
};

struct DbiModuleInfo 
{            
	ULONG opened;                 //  0..3
	DbiSecCon seccon;
	USHORT flags;                  // 32..33
	USHORT stream;                 // 34..35
	ULONG cbSyms;                 // 36..39
	ULONG cbOldLines;             // 40..43
	ULONG cbLines;                // 44..57
	USHORT files;                  // 48..49
	USHORT pad1;                   // 50..51
	ULONG offsets;
	ULONG niSource;
	ULONG niCompiler;
	char buf[]; //moduleName + objectName;
};

struct DbiHeader
{
	ULONG sig;                        // 0..3
	ULONG ver;                        // 4..7
	ULONG age;                        // 8..11
	USHORT gssymStream;                // 12..13
	USHORT vers;                       // 14..15
	USHORT pssymStream;                // 16..17
	USHORT pdbver;                     // 18..19
	USHORT symrecStream;               // 20..21
	USHORT pdbver2;                    // 22..23
	ULONG gpmodiSize;                 // 24..27
	ULONG secconSize;                 // 28..31
	ULONG secmapSize;                 // 32..35
	ULONG filinfSize;                 // 36..39
	ULONG tsmapSize;                  // 40..43
	ULONG mfcIndex;                   // 44..47
	ULONG dbghdrSize;                 // 48..51
	ULONG ecinfoSize;                 // 52..55
	USHORT flags;                      // 56..57
	USHORT machine;                    // 58..59
	ULONG reserved;                   // 60..63
};

struct DbiDbgHdr
{
	USHORT snFPO;                 // 0..1
	USHORT snException;           // 2..3 (deprecated)
	USHORT snFixup;               // 4..5
	USHORT snOmapToSrc;           // 6..7
	USHORT snOmapFromSrc;         // 8..9
	USHORT snSectionHdr;          // 10..11
	USHORT snTokenRidMap;         // 12..13
	USHORT snXdata;               // 14..15
	USHORT snPdata;               // 16..17
	USHORT snNewFPO;              // 18..19
	USHORT snSectionHdrOrig;      // 20..21
};

//  Symbol definitions

enum SYM_ENUM_e : unsigned short {
	S_COMPILE       =  0x0001,  // Compile flags symbol
	S_REGISTER_16t  =  0x0002,  // Register variable
	S_CONSTANT_16t  =  0x0003,  // constant symbol
	S_UDT_16t       =  0x0004,  // User defined type
	S_SSEARCH       =  0x0005,  // Start Search
	S_END           =  0x0006,  // Block, procedure, "with" or thunk end
	S_SKIP          =  0x0007,  // Reserve symbol space in $$Symbols table
	S_CVRESERVE     =  0x0008,  // Reserved symbol for CV internal use
	S_OBJNAME_ST    =  0x0009,  // path to object file name
	S_ENDARG        =  0x000a,  // end of argument/return list
	S_COBOLUDT_16t  =  0x000b,  // special UDT for cobol that does not symbol pack
	S_MANYREG_16t   =  0x000c,  // multiple register variable
	S_RETURN        =  0x000d,  // return description symbol
	S_ENTRYTHIS     =  0x000e,  // description of this pointer on entry

	S_BPREL16       =  0x0100,  // BP-relative
	S_LDATA16       =  0x0101,  // Module-local symbol
	S_GDATA16       =  0x0102,  // Global data symbol
	S_PUB16         =  0x0103,  // a public symbol
	S_LPROC16       =  0x0104,  // Local procedure start
	S_GPROC16       =  0x0105,  // Global procedure start
	S_THUNK16       =  0x0106,  // Thunk Start
	S_BLOCK16       =  0x0107,  // block start
	S_WITH16        =  0x0108,  // with start
	S_LABEL16       =  0x0109,  // code label
	S_CEXMODEL16    =  0x010a,  // change execution model
	S_VFTABLE16     =  0x010b,  // address of virtual function table
	S_REGREL16      =  0x010c,  // register relative address

	S_BPREL32_16t   =  0x0200,  // BP-relative
	S_LDATA32_16t   =  0x0201,  // Module-local symbol
	S_GDATA32_16t   =  0x0202,  // Global data symbol
	S_PUB32_16t     =  0x0203,  // a public symbol (CV internal reserved)
	S_LPROC32_16t   =  0x0204,  // Local procedure start
	S_GPROC32_16t   =  0x0205,  // Global procedure start
	S_THUNK32_ST    =  0x0206,  // Thunk Start
	S_BLOCK32_ST    =  0x0207,  // block start
	S_WITH32_ST     =  0x0208,  // with start
	S_LABEL32_ST    =  0x0209,  // code label
	S_CEXMODEL32    =  0x020a,  // change execution model
	S_VFTABLE32_16t =  0x020b,  // address of virtual function table
	S_REGREL32_16t  =  0x020c,  // register relative address
	S_LTHREAD32_16t =  0x020d,  // local thread storage
	S_GTHREAD32_16t =  0x020e,  // global thread storage
	S_SLINK32       =  0x020f,  // static link for MIPS EH implementation

	S_LPROCMIPS_16t =  0x0300,  // Local procedure start
	S_GPROCMIPS_16t =  0x0301,  // Global procedure start

	// if these ref symbols have names following then the names are in ST format
	S_PROCREF_ST    =  0x0400,  // Reference to a procedure
	S_DATAREF_ST    =  0x0401,  // Reference to data
	S_ALIGN         =  0x0402,  // Used for page alignment of symbols

	S_LPROCREF_ST   =  0x0403,  // Local Reference to a procedure
	S_OEM           =  0x0404,  // OEM defined symbol

	// sym records with 32-bit types embedded instead of 16-bit
	// all have 0x1000 bit set for easy identification
	// only do the 32-bit target versions since we don't really
	// care about 16-bit ones anymore.
	S_TI16_MAX          =  0x1000,

	S_REGISTER_ST   =  0x1001,  // Register variable
	S_CONSTANT_ST   =  0x1002,  // constant symbol
	S_UDT_ST        =  0x1003,  // User defined type
	S_COBOLUDT_ST   =  0x1004,  // special UDT for cobol that does not symbol pack
	S_MANYREG_ST    =  0x1005,  // multiple register variable
	S_BPREL32_ST    =  0x1006,  // BP-relative
	S_LDATA32_ST    =  0x1007,  // Module-local symbol
	S_GDATA32_ST    =  0x1008,  // Global data symbol
	S_PUB32_ST      =  0x1009,  // a public symbol (CV internal reserved)
	S_LPROC32_ST    =  0x100a,  // Local procedure start
	S_GPROC32_ST    =  0x100b,  // Global procedure start
	S_VFTABLE32     =  0x100c,  // address of virtual function table
	S_REGREL32_ST   =  0x100d,  // register relative address
	S_LTHREAD32_ST  =  0x100e,  // local thread storage
	S_GTHREAD32_ST  =  0x100f,  // global thread storage

	S_LPROCMIPS_ST  =  0x1010,  // Local procedure start
	S_GPROCMIPS_ST  =  0x1011,  // Global procedure start

	S_FRAMEPROC     =  0x1012,  // extra frame and proc information
	S_COMPILE2_ST   =  0x1013,  // extended compile flags and info

	// new symbols necessary for 16-bit enumerates of IA64 registers
	// and IA64 specific symbols

	S_MANYREG2_ST   =  0x1014,  // multiple register variable
	S_LPROCIA64_ST  =  0x1015,  // Local procedure start (IA64)
	S_GPROCIA64_ST  =  0x1016,  // Global procedure start (IA64)

	// Local symbols for IL
	S_LOCALSLOT_ST  =  0x1017,  // local IL sym with field for local slot index
	S_PARAMSLOT_ST  =  0x1018,  // local IL sym with field for parameter slot index

	S_ANNOTATION    =  0x1019,  // Annotation string literals

	// symbols to support managed code debugging
	S_GMANPROC_ST   =  0x101a,  // Global proc
	S_LMANPROC_ST   =  0x101b,  // Local proc
	S_RESERVED1     =  0x101c,  // reserved
	S_RESERVED2     =  0x101d,  // reserved
	S_RESERVED3     =  0x101e,  // reserved
	S_RESERVED4     =  0x101f,  // reserved
	S_LMANDATA_ST   =  0x1020,
	S_GMANDATA_ST   =  0x1021,
	S_MANFRAMEREL_ST=  0x1022,
	S_MANREGISTER_ST=  0x1023,
	S_MANSLOT_ST    =  0x1024,
	S_MANMANYREG_ST =  0x1025,
	S_MANREGREL_ST  =  0x1026,
	S_MANMANYREG2_ST=  0x1027,
	S_MANTYPREF     =  0x1028,  // Index for type referenced by name from metadata
	S_UNAMESPACE_ST =  0x1029,  // Using namespace

	// Symbols w/ SZ name fields. All name fields contain utf8 encoded strings.
	S_ST_MAX        =  0x1100,  // starting point for SZ name symbols

	S_OBJNAME       =  0x1101,  // path to object file name
	S_THUNK32       =  0x1102,  // Thunk Start
	S_BLOCK32       =  0x1103,  // block start
	S_WITH32        =  0x1104,  // with start
	S_LABEL32       =  0x1105,  // code label
	S_REGISTER      =  0x1106,  // Register variable
	S_CONSTANT      =  0x1107,  // constant symbol
	S_UDT           =  0x1108,  // User defined type
	S_COBOLUDT      =  0x1109,  // special UDT for cobol that does not symbol pack
	S_MANYREG       =  0x110a,  // multiple register variable
	S_BPREL32       =  0x110b,  // BP-relative
	S_LDATA32       =  0x110c,  // Module-local symbol
	S_GDATA32       =  0x110d,  // Global data symbol
	S_PUB32         =  0x110e,  // a public symbol (CV internal reserved)
	S_LPROC32       =  0x110f,  // Local procedure start
	S_GPROC32       =  0x1110,  // Global procedure start
	S_REGREL32      =  0x1111,  // register relative address
	S_LTHREAD32     =  0x1112,  // local thread storage
	S_GTHREAD32     =  0x1113,  // global thread storage

	S_LPROCMIPS     =  0x1114,  // Local procedure start
	S_GPROCMIPS     =  0x1115,  // Global procedure start
	S_COMPILE2      =  0x1116,  // extended compile flags and info
	S_MANYREG2      =  0x1117,  // multiple register variable
	S_LPROCIA64     =  0x1118,  // Local procedure start (IA64)
	S_GPROCIA64     =  0x1119,  // Global procedure start (IA64)
	S_LOCALSLOT     =  0x111a,  // local IL sym with field for local slot index
	S_SLOT          = S_LOCALSLOT,  // alias for LOCALSLOT
	S_PARAMSLOT     =  0x111b,  // local IL sym with field for parameter slot index

	// symbols to support managed code debugging
	S_LMANDATA      =  0x111c,
	S_GMANDATA      =  0x111d,
	S_MANFRAMEREL   =  0x111e,
	S_MANREGISTER   =  0x111f,
	S_MANSLOT       =  0x1120,
	S_MANMANYREG    =  0x1121,
	S_MANREGREL     =  0x1122,
	S_MANMANYREG2   =  0x1123,
	S_UNAMESPACE    =  0x1124,  // Using namespace

	// ref symbols with name fields
	S_PROCREF       =  0x1125,  // Reference to a procedure
	S_DATAREF       =  0x1126,  // Reference to data
	S_LPROCREF      =  0x1127,  // Local Reference to a procedure
	S_ANNOTATIONREF =  0x1128,  // Reference to an S_ANNOTATION symbol
	S_TOKENREF      =  0x1129,  // Reference to one of the many MANPROCSYM's

	// continuation of managed symbols
	S_GMANPROC      =  0x112a,  // Global proc
	S_LMANPROC      =  0x112b,  // Local proc

	// short, light-weight thunks
	S_TRAMPOLINE    =  0x112c,  // trampoline thunks
	S_MANCONSTANT   =  0x112d,  // constants with metadata type info

	// native attributed local/parms
	S_ATTR_FRAMEREL =  0x112e,  // relative to virtual frame ptr
	S_ATTR_REGISTER =  0x112f,  // stored in a register
	S_ATTR_REGREL   =  0x1130,  // relative to register (alternate frame ptr)
	S_ATTR_MANYREG  =  0x1131,  // stored in >1 register

	// Separated code (from the compiler) support
	S_SEPCODE       =  0x1132,

	S_LOCAL_2005    =  0x1133,  // defines a local symbol in optimized code
	S_DEFRANGE_2005 =  0x1134,  // defines a single range of addresses in which symbol can be evaluated
	S_DEFRANGE2_2005 =  0x1135,  // defines ranges of addresses in which symbol can be evaluated

	S_SECTION       =  0x1136,  // A COFF section in a PE executable
	S_COFFGROUP     =  0x1137,  // A COFF group
	S_EXPORT        =  0x1138,  // A export

	S_CALLSITEINFO  =  0x1139,  // Indirect call site information
	S_FRAMECOOKIE   =  0x113a,  // Security cookie information

	S_DISCARDED     =  0x113b,  // Discarded by LINK /OPT:REF (experimental, see richards)

	S_COMPILE3      =  0x113c,  // Replacement for S_COMPILE2
	S_ENVBLOCK      =  0x113d,  // Environment block split off from S_COMPILE2

	S_LOCAL         =  0x113e,  // defines a local symbol in optimized code
	S_DEFRANGE      =  0x113f,  // defines a single range of addresses in which symbol can be evaluated
	S_DEFRANGE_SUBFIELD =  0x1140,           // ranges for a subfield

	S_DEFRANGE_REGISTER =  0x1141,           // ranges for en-registered symbol
	S_DEFRANGE_FRAMEPOINTER_REL =  0x1142,   // range for stack symbol.
	S_DEFRANGE_SUBFIELD_REGISTER =  0x1143,  // ranges for en-registered field of symbol
	S_DEFRANGE_FRAMEPOINTER_REL_FULL_SCOPE =  0x1144, // range for stack symbol span valid full scope of function body, gap might apply.
	S_DEFRANGE_REGISTER_REL =  0x1145, // range for symbol address as register + offset.

	// S_PROC symbols that reference ID instead of type
	S_LPROC32_ID     =  0x1146,
	S_GPROC32_ID     =  0x1147,
	S_LPROCMIPS_ID   =  0x1148,
	S_GPROCMIPS_ID   =  0x1149,
	S_LPROCIA64_ID   =  0x114a,
	S_GPROCIA64_ID   =  0x114b,

	S_BUILDINFO      = 0x114c, // build information.
	S_INLINESITE     = 0x114d, // inlined function callsite.
	S_INLINESITE_END = 0x114e,
	S_PROC_ID_END    = 0x114f,

	S_DEFRANGE_HLSL  = 0x1150,
	S_GDATA_HLSL     = 0x1151,
	S_LDATA_HLSL     = 0x1152,

	S_FILESTATIC     = 0x1153,

	S_LOCAL_DPC_GROUPSHARED = 0x1154, // DPC groupshared variable
	S_LPROC32_DPC = 0x1155, // DPC local procedure start
	S_LPROC32_DPC_ID =  0x1156,
	S_DEFRANGE_DPC_PTR_TAG =  0x1157, // DPC pointer tag definition range
	S_DPC_SYM_TAG_MAP = 0x1158, // DPC pointer tag value to symbol record map

	S_ARMSWITCHTABLE  = 0x1159,
	S_CALLEES = 0x115a,
	S_CALLERS = 0x115b,
	S_POGODATA = 0x115c,
	S_INLINESITE2 = 0x115d,      // extended inline site information

	S_HEAPALLOCSITE = 0x115e,    // heap allocation site

	S_MOD_TYPEREF = 0x115f,      // only generated at link time

	S_REF_MINIPDB = 0x1160,      // only generated at link time for mini PDB
	S_PDBMAP      = 0x1161,      // only generated at link time for mini PDB

	S_GDATA_HLSL32 = 0x1162,
	S_LDATA_HLSL32 = 0x1163,

	S_GDATA_HLSL32_EX = 0x1164,
	S_LDATA_HLSL32_EX = 0x1165,

	S_RECTYPE_MAX,               // one greater than last
	S_RECTYPE_LAST  = S_RECTYPE_MAX - 1,
	S_RECTYPE_PAD   = S_RECTYPE_MAX + 0x100 // Used *only* to verify symbol record types so that current PDB code can potentially read
	// future PDBs (assuming no format change, etc).

};

struct SYM_HEADER 
{
	WORD len;
	SYM_ENUM_e type;
};

union CV_PUBSYMFLAGS
{
	/*000*/ DWORD grfFlags; // CV_PUBSYMFLAGS_e
	/*000*/ struct {
		/*000.0*/   DWORD fCode     :  1;
		/*000.1*/   DWORD fFunction :  1;
		/*000.2*/   DWORD fManaged  :  1;
		/*000.3*/   DWORD fMSIL     :  1;
		/*000.4*/   DWORD reserved  : 28;
	};
};

struct REFSYM2 : SYM_HEADER {// S_PROCREF, S_DATAREF, or S_LPROCREF
	unsigned long   sumName;    // SUC of the name
	unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
	unsigned short  imod;       // Module containing the actual symbol
	char   name[];    // hidden name made a first class member
};

struct PUBSYM32 : public SYM_HEADER
{
	/*004*/ CV_PUBSYMFLAGS pubsymflags;
	/*008*/ DWORD          off;
	/*00C*/ WORD           seg;
	/*00E*/ CHAR           name[];
};

typedef unsigned long CV_typ_t;
typedef unsigned long CV_uoff32_t;

// enum describing function return method

typedef struct CV_PROCFLAGS {
	union {
		unsigned char   bAll;
		unsigned char   grfAll;
		struct {
			unsigned char CV_PFLAG_NOFPO     :1; // frame pointer present
			unsigned char CV_PFLAG_INT       :1; // interrupt return
			unsigned char CV_PFLAG_FAR       :1; // far return
			unsigned char CV_PFLAG_NEVER     :1; // function does not return
			unsigned char CV_PFLAG_NOTREACHED:1; // label isn't fallen into
			unsigned char CV_PFLAG_CUST_CALL :1; // custom calling convention
			unsigned char CV_PFLAG_NOINLINE  :1; // function marked as noinline
			unsigned char CV_PFLAG_OPTDBGINFO:1; // function has debug information for optimized code
		};
	};
} CV_PROCFLAGS;

struct PROCSYM32 : SYM_HEADER {     // S_GPROC32, S_LPROC32, S_GPROC32_ID, S_LPROC32_ID, S_LPROC32_DPC or S_LPROC32_DPC_ID
	unsigned long   pParent;    // pointer to the parent
	unsigned long   pEnd;       // pointer to this blocks end
	unsigned long   pNext;      // pointer to next symbol
	unsigned long   len;        // Proc length
	unsigned long   DbgStart;   // Debug start offset
	unsigned long   DbgEnd;     // Debug end offset
	CV_typ_t        typind;     // Type index or ID
	CV_uoff32_t     off;
	unsigned short  seg;
	CV_PROCFLAGS    flags;      // Proc flags
	char   name[];    // Length-prefixed name
};

struct OMAP {
	ULONG  rva;
	ULONG  rvaTo;
};

#ifndef _CV_INFO_PDB_DEFINED_
#define _CV_INFO_PDB_DEFINED_

struct CV_INFO_PDB 
{
	DWORD CvSignature;
	GUID Signature;
	DWORD Age;
	char PdbFileName[];
};

#endif

```

`pdb_util.h`:

```h
#pragma once

#ifndef _CV_INFO_PDB_DEFINED_
#define _CV_INFO_PDB_DEFINED_

struct CV_INFO_PDB 
{
	DWORD CvSignature;
	GUID Signature;
	DWORD Age;
	char PdbFileName[];
};

#endif

struct RVAOFS
{
	ULONG rva, ofs;
};

struct __declspec(novtable) SymStore 
{
	NTSTATUS GetSymbols(HMODULE hmod, PCWSTR NtSymbolPath);

	NTSTATUS GetSymbols(PCWSTR PdbPath);

	virtual void Symbols(_In_ RVAOFS* pSymbols, _In_ ULONG nSymbols, _In_ PSTR names) = 0;

	virtual NTSTATUS OnOpenPdb(NTSTATUS status, CV_INFO_PDB* /*lpcvh*/)
	{
		return status;
	}

	virtual BOOL IncludeSymbol(_In_ PCSTR name);

private:

	NTSTATUS GetSymbols(HANDLE hFile, PGUID signature, DWORD age);
};
```

`stdafx.cpp`:

```cpp
#include "stdafx.h"

#pragma warning(disable : 4996)

void* __cdecl operator new[](size_t ByteSize, NT::POOL_TYPE PoolType)
{
	return NT::ExAllocatePool(PoolType, ByteSize);
}

void* __cdecl operator new(size_t ByteSize, NT::POOL_TYPE PoolType)
{
	return NT::ExAllocatePool(PoolType, ByteSize);
}

void __cdecl operator delete(void* Buffer)
{
	NT::ExFreePool(Buffer);
}

void __cdecl operator delete[](void* Buffer)
{
	NT::ExFreePool(Buffer);
}


```

`stdafx.h`:

```h
#define _NTDRIVER_
#define NOWINBASEINTERLOCK
#define _NTOS_
#define SECURITY_KERNEL
#include "../inc/stdafx.h"

void* __cdecl operator new[](size_t ByteSize, NT::POOL_TYPE PoolType);
void* __cdecl operator new(size_t ByteSize, NT::POOL_TYPE PoolType);

```

`x64.asm`:

```asm
_TEXT segment 'CODE'

?strnlen@NT@@YA_K_KPEBD@Z proc
	xor eax,eax
	jecxz @@2
	push rdi
	mov rdi,rdx
	repne scasb
	jne @@1
	dec rdi
@@1:
	sub rdi,rdx
	mov rax,rdi
	pop rdi
@@2:
	ret
?strnlen@NT@@YA_K_KPEBD@Z endp

?findDWORD@NT@@YAPEAK_KPEBKK@Z proc
	jrcxz @retz
	xchg rdi,rdx
	mov rax,r8
	repne scasd
	lea rax, [rdi-4]
	cmovne rax, rcx
	mov rdi,rdx
	ret
?findDWORD@NT@@YAPEAK_KPEBKK@Z endp

@retz proc
	xor eax,eax
	ret
@retz endp

_TEXT ENDS
END
```

`x86.asm`:

```asm
.686

_TEXT segment

?strnlen@NT@@YIIIPBD@Z proc
	xor eax,eax
	jecxz @@2
	push edi
	mov edi,edx
	repne scasb
	jne @@1
	dec edi
@@1:
	sub edi,edx
	mov eax,edi
	pop edi
@@2:
	ret
?strnlen@NT@@YIIIPBD@Z endp

@retz4 proc
	xor eax,eax
	ret 4
@retz4 endp

?findDWORD@NT@@YIPAKKPBKK@Z proc
	jecxz @retz4
	xchg edi,edx
	mov eax,[esp + 4]
	repne scasd
	lea eax,[edi-4]
	cmovne eax,ecx
	mov edi,edx
	ret 4
?findDWORD@NT@@YIPAKKPBKK@Z endp

_TEXT ends
end
```