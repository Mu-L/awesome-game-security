Project Path: arc_MrDiamond64_Scythe-AntiCheat_dec4hb6r

Source Tree:

```txt
arc_MrDiamond64_Scythe-AntiCheat_dec4hb6r
├── LICENSE
├── README.md
├── animation_controllers
│   ├── checks.json
│   └── detect_actions.json
├── animations
│   └── onJoin.json
├── entities
│   └── player.json
├── functions
│   ├── credits.mcfunction
│   ├── op.mcfunction
│   └── version.mcfunction
├── manifest.json
├── pack_icon.png
└── scripts
    ├── assets
    │   ├── ban.js
    │   └── ui.js
    ├── checks
    │   ├── Check.js
    │   ├── combat
    │   │   ├── Autoclicker
    │   │   │   └── AutoclickerA.js
    │   │   ├── Fastuse
    │   │   │   └── FastuseA.js
    │   │   ├── Killaura
    │   │   │   ├── KillauraA.js
    │   │   │   ├── KillauraB.js
    │   │   │   └── KillauraC.js
    │   │   └── Reach
    │   │       ├── ReachA.js
    │   │       └── ReachC.js
    │   ├── exploit
    │   │   ├── BadPackets
    │   │   │   ├── BadPackets1.js
    │   │   │   ├── BadPackets2.js
    │   │   │   ├── BadPackets3.js
    │   │   │   ├── BadPackets4.js
    │   │   │   └── BadPackets5.js
    │   │   ├── Instabreak
    │   │   │   └── InstabreakA.js
    │   │   └── Namespoof
    │   │       ├── NamespoofA.js
    │   │       └── NamespoofB.js
    │   ├── inventory
    │   │   ├── AutoOffhand
    │   │   │   └── AutoOffhandA.js
    │   │   └── InventoryMods
    │   │       └── InventoryModsA.js
    │   ├── legacy
    │   │   ├── CrasherA.js
    │   │   ├── InventoryModsB.js
    │   │   ├── NoslowA.js
    │   │   └── README.md
    │   ├── misc
    │   │   └── Spammer
    │   │       ├── SpammerA.js
    │   │       ├── SpammerB.js
    │   │       ├── SpammerC.js
    │   │       └── SpammerD.js
    │   ├── movement
    │   │   └── Invalidsprint
    │   │       ├── InvalidsprintA.js
    │   │       ├── InvalidsprintB.js
    │   │       ├── InvalidsprintC.js
    │   │       ├── InvalidsprintD.js
    │   │       ├── InvalidsprintE.js
    │   │       └── InvalidsprintF.js
    │   ├── registry.js
    │   └── world
    │       ├── Autotool
    │       │   └── AutotoolA.js
    │       ├── Nuker
    │       │   └── NukerA.js
    │       └── Scaffold
    │           ├── ScaffoldA.js
    │           ├── ScaffoldB.js
    │           ├── ScaffoldC.js
    │           ├── ScaffoldD.js
    │           └── ScaffoldE.js
    ├── commands
    │   ├── handler.js
    │   ├── moderation
    │   │   ├── ban.js
    │   │   ├── deop.js
    │   │   ├── globalmute.js
    │   │   ├── kick.js
    │   │   ├── mute.js
    │   │   ├── notify.js
    │   │   ├── op.js
    │   │   ├── resetwarns.js
    │   │   ├── stats.js
    │   │   ├── unban.js
    │   │   └── unmute.js
    │   ├── other
    │   │   ├── credits.js
    │   │   ├── help.js
    │   │   ├── report.js
    │   │   └── version.js
    │   ├── settings
    │   │   ├── module.js
    │   │   ├── modules.js
    │   │   └── resetconfig.js
    │   └── utility
    │       ├── cloneinv.js
    │       ├── ecwipe.js
    │       ├── fly.js
    │       ├── freeze.js
    │       ├── fullreport.js
    │       ├── gma.js
    │       ├── gmc.js
    │       ├── gms.js
    │       ├── gmsp.js
    │       ├── invsee.js
    │       ├── tag.js
    │       ├── ui.js
    │       └── vanish.js
    ├── data
    │   └── config.js
    ├── extensions
    │   ├── Entity.js
    │   └── Player.js
    ├── index.d.ts
    ├── loader.js
    ├── main.js
    ├── modules
    │   ├── AntiArmorStandCluster.js
    │   ├── AntiSpam.js
    │   ├── ChatExtensions.js
    │   ├── Module.js
    │   ├── OreAlerts.js
    │   ├── WelcomeMessage.js
    │   ├── WorldBorder.js
    │   └── registry.js
    ├── package.json
    └── util.js

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
<div align="center">
  <b>Scythe Anticheat - The best anticheat designed for Minecraft Bedrock realms/worlds/servers.</b>

  <img src="https://raw.githubusercontent.com/MrDiamond64/image-assets/main/scythe%20pog%20anticheat.png" width="600" alt="Scythe Anticheat"/>
</div>
<div align="center">
  <img src="https://img.shields.io/github/downloads/Scythe-Anticheat/Scythe-AntiCheat/total?style=for-the-badge" alt="Downloads"/>
  <img src="https://img.shields.io/github/issues/Scythe-Anticheat/Scythe-AntiCheat?label=ISSUES%20OPEN&style=for-the-badge" alt="Issues Open"/>
  <img src="https://img.shields.io/github/commit-activity/m/Scythe-Anticheat/Scythe-AntiCheat?style=for-the-badge" alt="Commits Per Week"/>
  <img src="https://img.shields.io/github/last-commit/Scythe-Anticheat/Scythe-AntiCheat?style=for-the-badge" alt="Last Commit"/>
</div>

# Introduction
Scythe Anticheat is a Minecraft Bedrock anticheat for vanilla Realms and Servers. It utilizes the Scripting API to observe player behavior and check if such behaviors are possible in the vanilla game. Scythe is designed to be plug-and-play, so you just need to apply the pack to your world, upload it to your realm or server, and it should be up and ready.

# How To Setup
To install this anticheat to your realm, you will need to download the .mcpack to your device, apply it to your realm/server (make sure that Scythe is at the top of the behavior packs list), and enable Beta APIs in world settings. Once you have done that, the anticheat should be fully up and running!

# Custom Commands
To assist with server moderation, Scythe comes pre-included with a variety of commands. The most important ones are `!help`, `!notify`, `!stats`.

By default, cheat alert notifications are not shown. To be able to see these notifications, run the command `!notify`. Running the command again toggles your notify state, so you will no longer be shown cheat notifications.

The `!stats` command allows you to get an overview of a player's history with Scythe. Information such as their current device, any flagged checks, and whether they have Scythe-Op status are shown. You can rountinely check player history to see what kind of hacks they are using on your realm or server.

For a full list of commands, you can run the `!help` command. This output a list of all Scythe commands, organized by category, which you can use. Along with the command names, the syntax of the command and a description is included to better allow you to understand how each command functions. For a more technical overview of a command, you can run `!help` with a command name as an argument.

> [!NOTE]
> To be able to utilize most of these custom commands, you must have Scythe-Op. You can run `/function op` to gain the proper permissions to use the commands.


# Hacks detected by Scythe Anticheat
  AutoClicker -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A) => Checks for high CPS.<br/>

  AutoOffhand -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A) => Checks if a player equips an item in their offhand while doing another action.<br/>

  AutoTool -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A) => Checks if a player switches their slot right after they start breaking a block.<br/>

  BadPackets -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) => Checks for invalid player head rotations.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) => Checks if chat messages have abnormal message lengths.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) => Checks for self-hurt.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4) => Checks for newline or carriage return characters in messages.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5) => Checks if the player has an invalid max render distance.<br/>

  FastUse -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A) => Checks for using/throwing items at a very fast rate.

  InstaBreak -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A) => Checks if a player breaks an unbreakable block whilst in survival.<br/>

  InvalidSprint -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A) => Checks for sprinting while having the blindness effect.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(C) => Checks for sprinting while sneaking.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(E) => Checks for sprinting while riding an entity.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(F) => Checks if a player sprints while they do not have enough hunger.<br/>

  Killaura -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A) => Checks for attacking while doing another action.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(B) => Checks for no swing. (Instantly detects toolbox killaura)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(C) => Checks for multi-aura.<br/>

  Namespoof -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A) => Checks if a player's name is longer than 16 characters.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(B) => Checks for invalid characters in the player's name.<br/>

  Nuker -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A) => Checks if a player breaks more than 3 blocks in a single tick.

  Reach -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A) => Checks if a player hits an entity farther than normally possible.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(B) => Checks if a player breaks a block farther than normally possible.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(C) => Checks if a player places a block farther than normally possible.<br/>

  Spammer -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A) => Checks if a player sends a message while moving.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(B) => Checks if a player sends a message while swinging their hand.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(C) => Checks if a player sends a message while using an item.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(D) => Checks if a player sends a message while having a chest opened.<br/>

  Scaffold -><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A) => Check for tower-like behavior.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(B) => Checks for a flat X/Y rotations (e.g. 10, 20, 30).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(C) => Checks if a player places a block under them whilst looking upwards.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(D) => Checks for downwards scaffold.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(E) => Checks for placing blocks onto air or liquid tiles.<br/>

# FAQ
Q1: Does the AntiCheat auto-ban?<br/>
A1: Yes. Currently only the BadPackets[1], BadPackets[2], BadPackets[3], BadPackets[4], and BadPackets[5] checks automatically ban.

Q2: Is it customizable?<br/>
A2: Yes you can edit the config.js file to disable or change the settings of certain checks. A guide can be found [here](https://github.com/Scythe-Anticheat/Scythe-AntiCheat/wiki/How-to-Setup) (Outdated)
```

`animation_controllers/checks.json`:

```json
{
	"format_version": "1.10.0",
	"animation_controllers": {
		"controller.animation.sprint": {
			"states": {
				"default": {
					"transitions": [{
						"sprint": "query.is_sprinting"
					}],
					"on_entry": [
						"/tag @s remove sprint",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aSPRINT§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				},
				"sprint": {
					"transitions": [{
						"default": "!query.is_sprinting"
					}],
					"on_entry": [
						"/tag @s add sprint",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aSPRINT§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}"
					]
				}
			}
		}
	}
}
```

`animation_controllers/detect_actions.json`:

```json
{
	"format_version": "1.10.0",
	"animation_controllers": {
		"controller.animation.jump": {
			"states": {
				"default": {
					"transitions": [{
						"jump": "query.is_jumping"
					}],
					"on_entry": [
						// "/tag @s remove jump",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aJUMP§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				},
				"jump": {
					"transitions": [{
						"default": "!query.is_jumping"
					}],
					"on_entry": [
						// "/tag @s add jump",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aJUMP§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}"
					]
				}
			}
		},
		"controller.animation.glide": {
			"states": {
				"default": {
					"transitions": [{
						"glide": "query.is_gliding"
					}],
					"on_entry": [
						// "/tag @s remove gliding",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aGLIDE§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				},
				"glide": {
					"transitions": [{
						"default": "!query.is_gliding"
					}],
					"on_entry": [
						// "/tag @s add gliding",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aGLIDE§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}"
					]
				}
			}
		},
		"controller.animation.levitate": {
			"states": {
				"default": {
					"transitions": [{
						"levitate": "query.is_levitating"
					}],
					"on_entry": [
						// "/tag @s remove levitating",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aLEVITATE§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				},
				"levitate": {
					"transitions": [{
						"default": "!query.is_levitating"
					}],
					"on_entry": [
						// "/tag @s add levitating",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aLEVITATE§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}"
					]
				}
			}
		},
		"controller.animation.ground": {
			"states": {
				"default": {
					"transitions": [{
						"ground": "query.is_on_ground"
					}],
					"on_entry": [
						// "/tag @s remove ground",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aGROUND§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				},
				"ground": {
					"transitions": [{
						"default": "!query.is_on_ground"
					}],
					"on_entry": [
						// "/tag @s add ground",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aGROUND§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}"
					]
				}
			}
		},
		"controller.animation.death": {
			"states": {
				"default": {
					"transitions": [{
						"dead": "!query.is_alive"
					}],
					"on_entry": [
						// "/tag @s remove dead",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aDEATH§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				},
				"dead": {
					"transitions": [{
						"default": "query.is_alive"
					}],
					"on_entry": [
						// "/tag @s add dead",
						// "/tag @s remove right",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aDEATH§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}"
					]
				}
			}
		},
		"controller.animation.ride": {
			"states": {
				"default": {
					"transitions": [{
						"ride": "query.is_riding"
					}],
					"on_entry": [
						"/tag @s remove riding",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aRIDE§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				},
				"ride": {
					"transitions": [{
						"default": "!query.is_riding"
					}],
					"on_entry": [
						"/tag @s add riding",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aRIDE§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}"
						// "/tag @s remove moving"
					]
				}
			}
		},
		"controller.animation.left": {
			"states": {
				"default": {
					"transitions": [{
						"left": "variable.attack_time"
					}],
					"on_entry": [
						"/tag @s remove left",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aLEFT§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				},
				"left": {
					"transitions": [{
						"default": "!variable.attack_time"
					}],
					"on_entry": [
						"/tag @s add left",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aLEFT§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}"
					]
				}
			}
		},
		"controller.animation.right": {
			"states": {
				"default": {
					"transitions": [{
						// Fishing rods are extremely buggy with the is_using_item query. If you were to right click twice extremely fast,
						// it would not properly add/remove the 'right' tag from you.
						// And unlike other items that you can use, fishing rods don't slow you down or prohibit you from sprinting.
						"right": "query.is_using_item && query.get_equipped_item_name != 'fishing_rod'"
					}],
					"on_entry": [
						// "/tag @s remove right",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aRIGHT§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop,ticks=\"},{\"score\":{\"name\":\"@s\",\"objective\":\"right\"}},{\"text\":\")\"}]}"
						// "/scoreboard players set @s right 0"
					]
				},
				"right": {
					"transitions": [{
						"default": "!query.is_using_item"
					}],
					"on_entry": [
						// "/tag @s add right",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aRIGHT§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start,ticks=0)\"}]}"
					]
				}
			}
		},
		"controller.animation.sneak": {
			"states": {
				"default": {
					"transitions": [{
						"sneak": "query.is_sneaking"
					}],
					"on_entry": [
						// "/tag @s remove sneak",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aSNEAK§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				},
				"sneak": {
					"transitions": [{
						"default": "!query.is_sneaking"
					}],
					"on_entry": [
						// "/tag @s add sneak",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aSNEAK§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}"
					]
				}
			}
		},
		"controller.animation.move": {
			"states": {
				"default": {
					"transitions": [{
						"move": "query.is_moving"
					}],
					"on_entry": [
						// "/tag @s remove moving",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aMOVE§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				},
				"move": {
					"transitions": [{
						"default": "!query.is_moving"
					}],
					"on_entry": [
						// "/tag @s add moving",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aMOVE§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}",
						"/scriptevent scythe:startMove"
					]
				}
			}
		},
		"controller.animation.swim": {
			"states": {
				"default": {
					"transitions": [{
						"swim": "query.is_swimming"
					}],
					"on_entry": [
						// "/tag @s remove swimming",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aSWIM§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				},
				"swim": {
					"transitions": [{
						"default": "!query.is_swimming"
					}],
					"on_entry": [
						// "/tag @s add swimming",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aSWIM§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}"
					]
				}
			}
		},
		"controller.animation.sleep": {
			"states": {
				"default": {
					"transitions": [{
						"sleeping": "query.is_sleeping"
					}],
					"on_entry": [
						// "/tag @s remove sleeping",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aSLEEP§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				},
				"sleeping": {
					"transitions": [{
						"default": "!query.is_sleeping"
					}],
					"on_entry": [
						// "/tag @s add sleeping",
						"/tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aSLEEP§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}"
					]
				}
			}
		}
	}
}
```

`animations/onJoin.json`:

```json
{
	"format_version": "1.10.0",
	"animations": {
		"animation.onJoin": {
			"timeline": {
				// This animation triggers before the player fully loads into the world. This means that commands cannot be used on them.
				// We wait 9 seconds to make sure they fully load into the game before we run all our commands.
				"9.0": [
					// Create scoreboard objectives needed for the anticheat
					"/scoreboard objectives add gametestapi dummy",
					// Set the scoreboard objective to the proper values
					"/scoreboard players add @s gametestapi 0",
					// Alert the user if Gametest Framework is not enabled
					// The playerSpawn event in 'main.js' will set the gametestapi scoreboard value to be 1. If it is set to 0, then we know that Beta APIs are not enabled
					"/tellraw @s[tag=op,scores={gametestapi=..0}] {\"rawtext\":[{\"text\":\"§r§6[§aScythe§6]§r Beta APIs are not enabled! Please go to your world settings and enable it to ensure all Scythe features work properly.\"}]}"
				]
			},
			"animation_length": 9.9,
			"loop": false
		}
	}
}
```

`entities/player.json`:

```json
{
	"format_version": "1.21.0",
	"minecraft:entity": {
		"description": {
			"identifier": "minecraft:player",
			"is_spawnable": false,
			"is_summonable": false,
			"is_experimental": false,
			"scripts": {
				"animate": [
					"onJoin",
					"glide",
					"levitate",
					"ground",
					"death",
					"ride",
					"left",
					"right",
					"sneak",
					"jump",
					"move",
					"sprint",
					"swim",
					"sleep"
				]
			},
			"animations": {
				"onJoin": "animation.onJoin",
				"glide": "controller.animation.glide",
				"levitate": "controller.animation.levitate",
				"ground": "controller.animation.ground",
				"death": "controller.animation.death",
				"ride": "controller.animation.ride",
				"left": "controller.animation.left",
				"right": "controller.animation.right",
				"sneak": "controller.animation.sneak",
				"jump": "controller.animation.jump",
				"move": "controller.animation.move",
				"sprint": "controller.animation.sprint",
				"swim": "controller.animation.swim",
				"sleep": "controller.animation.sleep"
			}
		},
		"component_groups": {
			"minecraft:add_raid_omen": {
				"minecraft:spell_effects": {
					"add_effects": [{
						"effect": "raid_omen",
						"duration": 30,
						"display_on_screen_animation": true
					}],
					"remove_effects": "bad_omen"
				},
				"minecraft:timer": {
					"time": [
						0,
						0
					],
					"looping": false,
					"time_down_event": {
						"event": "minecraft:clear_add_raid_omen",
						"target": "self"
					}
				}
			},
			"minecraft:clear_raid_omen_spell_effect": {
				"minecraft:spell_effects": {}
			},
			"minecraft:raid_trigger": {
				"minecraft:raid_trigger": {
					"triggered_event": {
						"event": "minecraft:remove_raid_trigger",
						"target": "self"
					}
				}
			},
			"scythe:kick": {
				// This kick method was added after Mojang patched the previous method of using the minecraft:instant_despawn component group
				// Fortunately a new kick method was discovered by Tutinoko9900#1841 which we use here
				// https://discord.com/channels/879970475483217940/933913999765024818/1022005158865031188
				"minecraft:explode": {
					"fuse_length": 0,
					"fuse_lit": true,
					"power": 0,
					"causes_fire": false,
					"breaks_blocks": false
				}
			},
			"scythe:freeze": {
				"minecraft:movement": {
					"value": 0
				},
				"minecraft:pushable": {
					"is_pushable": false,
					"is_pushable_by_piston": false
				}
			},
			"scythe:unfreeze": {
				"minecraft:movement": {
					"value": 0.1
				},
				"minecraft:pushable": {
					"is_pushable": false,
					"is_pushable_by_piston": true
				}
			}
		},
		"components": {
			"minecraft:experience_reward": {
				"on_death": "Math.Min(query.player_level * 7, 100)"
			},
			"minecraft:type_family": {
				"family": [
					"player"
				]
			},
			"minecraft:is_hidden_when_invisible": {},
			"minecraft:loot": {
				"table": "loot_tables/empty.json"
			},
			"minecraft:collision_box": {
				"width": 0.6,
				"height": 1.8
			},
			"minecraft:can_climb": {},
			"minecraft:movement": {
				"value": 0.1
			},
			"minecraft:hurt_on_condition": {
				"damage_conditions": [{
					"filters": {
						"test": "in_lava",
						"subject": "self",
						"operator": "==",
						"value": true
					},
					"cause": "lava",
					"damage_per_tick": 4
				}]
			},
			"minecraft:attack": {
				"damage": 1
			},
			"minecraft:exhaustion_values": {
				"heal": 6,
				"jump": 0.05,
				"sprint_jump": 0.2,
				"mine": 0.005,
				"attack": 0.1,
				"damage": 0.1,
				"walk": 0.0,
				"sprint": 0.1,
				"swim": 0.01
			},
			"minecraft:player.saturation": {
				"value": 5,
				"max": 20
			},
			"minecraft:player.exhaustion": {
				"value": 0,
				"max": 20
			},
			"minecraft:player.level": {
				"value": 0,
				"max": 24791
			},
			"minecraft:player.experience": {
				"value": 0,
				"max": 1
			},
			"minecraft:breathable": {
				"total_supply": 15,
				"suffocate_time": -1,
				"inhale_time": 3.75,
				"generates_bubbles": false
			},
			"minecraft:nameable": {
				"always_show": true,
				"allow_name_tag_renaming": false
			},
			"minecraft:physics": {
				"push_towards_closest_space": true
			},
			"minecraft:pushable": {
				"is_pushable": false,
				"is_pushable_by_piston": true
			},
			"minecraft:insomnia": {
				"days_until_insomnia": 3
			},
			"minecraft:damage_sensor": {
				"triggers": [
					{
						// Make players with the mayfly ability (people who use the '!fly' command) not receive fall damage
						"cause": "all",
						"on_damage": {
							"filters": {
								"all_of": [{
										"test": "has_tag",
										"operator": "==",
										"subject": "self",
										"value": "flying"
									},
									{
										"test": "has_ability",
										"operator": "==",
										"subject": "self",
										"value": "mayfly"
									}
								]
							}
						},
						"deals_damage": false
					},
					// Prevent frozen players from being able to attack or be attacked by other entities
					{
						"cause": "all",
						"on_damage": {
							"filters": {
								"any_of": [{
										"test": "has_tag",
										"operator": "==",
										"subject": "self",
										"value": "freeze"
									},
									{
										"test": "has_tag",
										"operator": "==",
										"subject": "other",
										"value": "freeze"
									}
								]
							}
						},
						"deals_damage": false
					}
				]
			},
			"minecraft:rideable": {
				"seat_count": 2,
				"family_types": [
					"parrot_tame"
				],
				"pull_in_entities": true,
				"seats": [{
						"position": [0.4, -0.2, -0.1],
						"min_rider_count": 0,
						"max_rider_count": 0,
						"lock_rider_rotation": 0
					},
					{
						"position": [-0.4, -0.2, -0.1],
						"min_rider_count": 1,
						"max_rider_count": 2,
						"lock_rider_rotation": 0
					}
				]
			},
			"minecraft:conditional_bandwidth_optimization": {},
			"minecraft:block_climber": {},
			"minecraft:environment_sensor": {
				"triggers": [{
						"filters": {
							"all_of": [{
									"test": "has_mob_effect",
									"subject": "self",
									"value": "bad_omen"
								},
								{
									"test": "is_in_village",
									"subject": "self",
									"value": true
								}
							]
						},
						"event": "minecraft:gain_raid_omen"
					},
					{
						"filters": {
							"all_of": [{
								"test": "has_container_open",
								"operator": "==",
								"subject": "self",
								"value": true
							},
							{
								"test": "has_tag",
								"operator": "!=",
								"subject": "self",
								"value": "hasGUIopen"
							}]
						},
						"event": "scythe:openedGui"
					},
					{
						"filters": {
							"all_of": [{
								"test": "has_container_open",
								"operator": "==",
								"subject": "self",
								"value": false
							},
							{
								"test": "has_tag",
								"operator": "==",
								"subject": "self",
								"value": "hasGUIopen"
							}]
						},
						"event": "scythe:closedGui"
					}
				]
			}
		},
		"events": {
			"scythe:openedGui": {
				"queue_command": {
					"command": [
						"tag @s add hasGUIopen",
						"tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aOpenChest§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=start)\"}]}"
					]
				}
			},
			"scythe:closedGui": {
				"queue_command": {
					"command": [
						"tag @s remove hasGUIopen",
						"tellraw @a[tag=actionlogger] {\"rawtext\":[{\"text\":\"§߈§r§6[§aScythe§6]§r §breceived §aOpenChest§r action from: §g\"},{\"selector\":\"@s\"},{\"text\":\" §7(type=stop)\"}]}"
					]
				}
			},
			"scythe:kick": {
				"add": {
					"component_groups": [
						"scythe:kick"
					]
				}
			},
			"scythe:freeze": {
				"add": {
					"component_groups": [
						"scythe:freeze"
					]
				},
				"remove": {
					"component_groups": [
						"scythe:unfreeze"
					]
				}
			},
			"scythe:unfreeze": {
				"add": {
					"component_groups": [
						"scythe:unfreeze"
					]
				},
				"remove": {
					"component_groups": [
						"scythe:freeze"
					]
				}
			},
			"minecraft:gain_raid_omen": {
				"add": {
					"component_groups": [
						"minecraft:add_raid_omen"
					]
				}
			},
			"minecraft:clear_add_raid_omen": {
				"remove": {
					"component_groups": [
						"minecraft:add_raid_omen"
					]
				},
				"add": {
					"component_groups": [
						"minecraft:clear_raid_omen_spell_effect"
					]
				}
			},
			"minecraft:trigger_raid": {
				"add": {
					"component_groups": [
						"minecraft:raid_trigger"
					]
				}
			},
			"minecraft:remove_raid_trigger": {
				"remove": {
					"component_groups": [
						"minecraft:raid_trigger"
					]
				}
			}
		}
	}
}
```

`functions/credits.mcfunction`:

```mcfunction
# please don't delete this file.
tellraw @s {"rawtext":[{"text":"§l§a                 Scythe Anticheat"}]}
tellraw @s {"rawtext":[{"text":"§l§6----------------------------------------------------------"}]}
tellraw @s {"rawtext":[{"text":"§lScythe Anticheat is an anticheat for Minecraft Bedrock Edition."}]}
tellraw @s {"rawtext":[{"text":"§lDeveloped and maintained by MrDiamond64."}]}
tellraw @s {"rawtext":[{"text":"§lGithub: https://github.com/Scythe-Anticheat/Scythe-AntiCheat"}]}
tellraw @s {"rawtext":[{"text":"\n"}]}
tellraw @s {"rawtext":[{"text":"§l§a               Major Contributors"}]}
tellraw @s {"rawtext":[{"text":"§l§6----------------------------------------------------------"}]}
tellraw @s {"rawtext":[{"text":"Visual1mpact#1435 - Porting function-based commands to Gametest commands and finding many bugs."}]}
```

`functions/op.mcfunction`:

```mcfunction
# if the player is already op
tellraw @s[tag=op] {"rawtext":[{"text":"§r§6[§aScythe§6]§r You already have Scythe-Op. If you would like to Scythe-Op another player, run \"!op <player name>\"."}]}

tellraw @s[tag=!op] {"rawtext":[{"text":"§r§6[§aScythe§6]§r §7You now have Scythe-Op."}]}
execute @s[tag=!op] ~~~ tellraw @a[tag=op] {"rawtext":[{"text":"§r§6[§aScythe§6]§r "},{"selector":"@s"},{"text":" is now Scythe-Opped."}]}
tag @s[type=player,tag=!op] add op
```

`functions/version.mcfunction`:

```mcfunction
tellraw @s {"rawtext":[{"text":"§r§6[§aScythe§6]§r Scythe is currently on version 4.0.0-beta."}]}

```

`manifest.json`:

```json
{
	"format_version": 2,
	"header": {
		"name": "Scythe Anticheat v4.0.0",
		"description": "The best minecraft bedrock anticheat, designed for realms and servers.",
		"uuid": "c68ba0c1-b9e4-46ad-b6c8-88bbd28f1fa5",
		"version": [4, 0, 0],
		"min_engine_version": [1, 19, 0]
	},
	"metadata": {
		"authors": ["MrDiamond64"],
		"url": "https://github.com/Scythe-Anticheat/Scythe-AntiCheat"
	},
	"modules": [{
		"type": "data",
		"uuid": "d059cc96-9272-4a33-90c8-f572bcc7fa56",
		"version": [1, 0, 0]
	},
	{
		"description": "Scythe Anticheat Beta API Features",
		"language": "javascript",
		"type": "script",
		"uuid": "ab31620b-f498-4355-9bea-498922f5940e",
		"version": [0, 0, 1],
		"entry": "scripts/loader.js"
	}],
	"dependencies": [{
		"module_name": "@minecraft/server",
		"version": "beta"
	},
	{
		"module_name": "@minecraft/server-ui",
		"version": "beta"
	}]
}

```

`scripts/assets/ban.js`:

```js
// @ts-check
import config from "../data/config.js";
import { world, Player } from "@minecraft/server";
import { msToTime, tellAllStaff } from "../util.js";

/**
 * @param {Player} player - The player that should be kicked from the game
 * @remarks Show the player the ban message if they are banned and not part of the unban queue
 */
export function banMessage(player) {
    // validate that required params are defined
    if(!(player instanceof Player)) throw TypeError(`Error: player is not an instance of Player.`);

    // @ts-expect-error
    if(config.flagWhitelist.includes(player.name) && player.hasTag("op")) return;

    // @ts-expect-error
    const unbanQueue = JSON.parse(world.getDynamicProperty("unbanQueue"));

    const playerName = player.name.toLowerCase();
    if(Object.hasOwn(unbanQueue, playerName)) {
        player.setDynamicProperty("banInfo", undefined);

        tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has been found in the unban queue and has been unbanned.`);

        delete unbanQueue[playerName];
        world.setDynamicProperty("unbanQueue", JSON.stringify(unbanQueue));
        return;
    }

    // @ts-expect-error
    const { by, reason, time } = JSON.parse(player.getDynamicProperty("banInfo"));

    let friendlyTime;

    // Check if the ban data includes an unban time
    if(time) {
        if(time < Date.now()) {
           tellAllStaff(`§r§6[§aScythe§6]§r ${player.name}'s ban has expired and has now been unbanned.`);

            player.setDynamicProperty("banInfo", undefined);
            return;
        }

        const timeUntilUnban = time - Date.now();

        const { w, d, h, m, s } = msToTime(timeUntilUnban);
        friendlyTime = `${w} weeks, ${d} days, ${h} hours, ${m} minutes, ${s} seconds`;
    }

    tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} was kicked for being banned. Ban Reason: ${reason ?? "You are banned!"}.`);

    player.kick(null, `§r\n§l§cYOU ARE BANNED!\n§eBanned By:§r ${by ?? "N/A"}\n§bReason:§r ${reason ?? "N/A"}\n§aBan Length:§r ${friendlyTime || "Permanent"}`);
}
```

`scripts/assets/ui.js`:

```js
import { world, ItemTypes, ItemStack, GameMode } from "@minecraft/server";
import { ModalFormData, ActionFormData } from "@minecraft/server-ui";

import { flag, parseTime, capitalizeFirstLetter, tellAllStaff } from "../util.js";
import { getStatsMsg } from "../commands/moderation/stats.js";
import { toggleGlobalMute } from "../commands/moderation/globalmute.js";
import { getInvseeMsg } from "../commands/utility/invsee.js";

import config from "../data/config.js";

// Commonly used icons
const icons = {
    back: "textures/ui/arrow_left.png",
    anvil: "textures/ui/anvil_icon.png",
    member: "textures/ui/permissions_member_star.png",
    op: "textures/ui/op.png",
    info: "textures/ui/infobulb.png",
    mute_off: "textures/ui/mute_off.png",
    mute_on: "textures/ui/mute_on.png",
    debug: "textures/ui/debug_glyph_color.png",
    arrow: "textures/ui/arrow.png"
};

const moduleList = Object.keys(config.modules).concat(Object.keys(config.misc_modules));
const modules = [];

// Get a list of all modules without the sub-check
for(const fullModule of moduleList) {
    if(fullModule.startsWith("example")) continue;

    // We want the list to only contain the module name without the sub-check (e.g. A, B, or C), and to do this we need to remove the last letter from the check name.
    // However misc modules do not contain a type, so to check if the module has types, we check if the last letter is a capital.
    const lastLetter = fullModule[fullModule.length - 1];
    const module = lastLetter === lastLetter.toUpperCase() ? fullModule.slice(0, -1) : fullModule;

    if(modules.includes(module)) continue;
    modules.push(module);
}

const punishments = {
    none: 0,
    mute: 1,
    kick: 2,
    ban: 3
};

const punishmentSettings = ["punishment","punishmentLength","minVlbeforePunishment"];

// This is the function that will be called when the player wants to open the GUI
// All other GUI functions will be called from here
export function mainGui(player) {
    player.playSound("mob.chicken.plop");

    const menu = new ActionFormData()
		.title("Scythe Anticheat UI")
		.body(`Hello ${player.name},\n\nPlease select an option below.`)
		.button("Ban Menu", icons.anvil)
		.button("Configure Settings", "textures/ui/gear.png")
		.button(`Manage Players\n§8§o${world.getPlayers().length} player(s) online`, "textures/ui/FriendsDiversity.png")
        .button("Server Management", "textures/ui/servers.png")
		.button("Exit", "textures/ui/redX1.png");

	if(config.debug) menu.button("⭐ Debug", icons.debug);

    menu.show(player).then((response) => {
        switch(response.selection) {
            case 0:
                banMenu(player);
                break;
            case 1:
                settingsMenu(player);
                break;
            case 2:
                playerSettingsMenu(player);
                break;
            case 3:
                serverManagementMenu(player);
                break;
            case 5:
                debugSettingsMenu(player);
        }
    });
}

// ====================== //
//        Ban Menu        //
// ====================== //
function banMenu(player) {
    player.playSound("mob.chicken.plop");

    const menu = new ActionFormData()
        .title("Ban Menu")
        .body("Please select an option.")
        .button("Kick Player", icons.anvil)
        .button("Ban Player", icons.anvil)
        .button("Unban Player", icons.anvil)
        .button("Back", icons.back);

    menu.show(player).then((response) => {
        switch(response.selection) {
            case 0:
            case 1:
                banMenuSelect(player, response.selection);
                break;

            case 2:
                unbanPlayerMenu(player);
                break;

            default:
                mainGui(player);
        }
    });
}

function banMenuSelect(player, selection) {
    player.playSound("mob.chicken.plop");
    const allPlayers = world.getPlayers();

    const menu = createSelectPlayerMenu("Ban Menu", allPlayers, player);

    menu.show(player).then((response) => {
        // Check if the form was cancelled. Response.selection is checked if its undefined to prevent typing errors
        if(response.selection === undefined || allPlayers.length <= response.selection) return banMenu(player);

        if(selection === 0) kickPlayerMenu(player, allPlayers[response.selection]);
            else banPlayerMenu(player, allPlayers[response.selection]);
    });
}

function kickPlayerMenu(player, target, lastMenu = 0) {
    if(!config.commands.kick.enabled) return player.sendMessage("§r§6[§aScythe§6]§r Kicking players is disabled in config.js.");
    player.playSound("mob.chicken.plop");

    const menu = new ModalFormData()
        .title("Kick Player Menu - " + target.name)
        .textField("Kick Reason:", "§o§7No Reason Provided")
        .toggle("Silent", { defaultValue: false });

    menu.show(player).then((response) => {
        if(response.canceled) {
            switch (lastMenu) {
                case 0:
                    banMenuSelect(player, lastMenu);
                    break;
                case 1:
                    playerSettingsMenuSelected(player, target);
            }
            return;
        }

        const formValues = response.formValues ?? [];

        // @ts-expect-error
        const reason = formValues[0].replace(/"|\\/g, "");
        const isSilent = formValues[1];

        target.kick(player, reason, isSilent);
    });
}

function banPlayerMenu(player, target, lastMenu = 0) {
    if(!config.commands.ban.enabled) return player.sendMessage("§r§6[§aScythe§6]§r Banning players is disabled in config.js.");

    player.playSound("mob.chicken.plop");

    const menu = new ModalFormData()
        .title("Ban Player Menu - " + target.name)
        .textField("Ban Reason:", "§o§7No Reason Provided")
        .slider("Ban Length (in days)", 1, 365, { valueStep: 1 })
        .toggle("Permanant Ban", { defaultValue: false });

    menu.show(player).then((response) => {
        if(response.canceled) {
            switch(lastMenu) {
                case 0:
                    banMenuSelect(player, lastMenu);
                    break;

                case 1:
                    playerSettingsMenuSelected(player, target);
                    break;
            }
            return;
        }

        const formValues = response.formValues ?? [];

        // @ts-expect-error
        const reason = formValues[0].replace(/"|\\/g, "");
        const banLength = parseTime(`${formValues[1]}d`);
        const permBan = formValues[2];

        target.ban(
            player,
            reason,
            (banLength && !permBan) ? banLength : null
        );
    });
}

function unbanPlayerMenu(player) {
    if(!config.commands.unban.enabled) return player.sendMessage("§r§6[§aScythe§6]§r Unbanning players is disabled in config.js.");

    // @ts-expect-error
    const unbanQueue = JSON.parse(world.getDynamicProperty("unbanQueue")); // Returns Object

    if(Object.keys(unbanQueue).length > 100) {
        return player.sendMessage("§r§6[§aScythe§6]§r The unban queue has reached the limit of 100 members.");
    }

    player.playSound("mob.chicken.plop");

    const menu = new ModalFormData()
        .title("Unban Player Menu")
        .textField("Player to unban:", "§o§7Enter player name")
        .textField("Unban Reason:", "§o§7No Reason Provided");

    menu.show(player).then((response) => {
        if(response.canceled) return banMenu(player);

        const formValues = response.formValues ?? [];

        // @ts-expect-error
        const playerToUnban = formValues[0].toLowerCase(); // String

        if(playerToUnban.length > 16) {
            return player.sendMessage("§r§6[§aScythe§6]§r That player name is too long. It must be less than or equal to 16 characters long.");
        }

        // @ts-expect-error
        const reason = formValues[1].replace(/"|\\/g, "") ?? "No Reason Provided";

        unbanQueue[playerToUnban] = [player.name, reason];
        world.setDynamicProperty("unbanQueue", JSON.stringify(unbanQueue));

        tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has added ${playerToUnban} into the unban queue. Reason: ${reason}`);
    });
}

// ====================== //
//     Settings Menu      //
// ====================== //
function settingsMenu(player) {
    player.playSound("mob.chicken.plop");

    const menu = new ActionFormData()
        .title("Configure Settings")
        .body("Please select a check to edit.\n\n§cWARNING: The Scythe config is an advanced feature and you should only be editing it if you know what you are doing. If you improperly change certain settings, you can easily break stuff.");

    for(const subModule of modules) {
        menu.button(capitalizeFirstLetter(subModule));
    }

    menu.button("Back", icons.back);

    menu.show(player).then((response) => {
        if(!modules[response.selection ?? -1]) return mainGui(player);

        settingsCheckSelectMenu(player, response.selection);
    });
}

function settingsCheckSelectMenu(player, selection) {
    player.playSound("mob.chicken.plop");
    const subCheck = modules[selection];

    const menu = new ActionFormData()
        .title(`Configure Settings - ${capitalizeFirstLetter(subCheck)}`)
        .body("Please select a sub-check to edit.");

    const checks = [];
    for(const module of moduleList) {
        if(!module.startsWith(subCheck)) continue;
        checks.push(module);

        const checkData = config.modules[module] ?? config.misc_modules[module];
        menu.button(`${capitalizeFirstLetter(subCheck)}/${module[module.length - 1]}\n${checkData.enabled ? "§8[§aENABLED§8]" : "§8[§4DISABLED§8]"}`);
    }

    // If there are only one sub-check, then it's completely unnecessary to show a list of sub-checks
    if(checks.length === 1) return editSettingMenu(player, checks[0]);

    menu.button("Back", icons.back);

    menu.show(player).then((response) => {
        const selection = response.selection ?? - 1;

        if(!checks[selection]) return settingsMenu(player);

        editSettingMenu(player, checks[selection]);
    });
}

function editSettingMenu(player, check) {
    player.playSound("mob.chicken.plop");
    const checkData = config.modules[check] ?? config.misc_modules[check];

    let optionsMap = [];

    const menu = new ModalFormData()
        .title(`Configure Settings - ${capitalizeFirstLetter(check)}`);

    for(const key of Object.keys(checkData)) {
        if(punishmentSettings.includes(key)) continue;

        // Friendly setting name. Changes "multi_protection" to "Multi Protection"
        const settingName = capitalizeFirstLetter(key).replace(/_./g, (match) => " " + match[1].toUpperCase());

        switch(typeof checkData[key]) {
            case "number":
                menu.slider(settingName, 0, 100, { defaultValue: checkData[key], valueStep: Number.isInteger(checkData[key]) ? 1 : 0.01 });
                optionsMap.push(key);
                break;
            case "boolean":
                menu.toggle(settingName, { defaultValue: checkData[key] });
                optionsMap.push(key);
                break;
            case "string":
                menu.textField(settingName, "Enter text here", { defaultValue: checkData[key] });
                optionsMap.push(key);
                break;
        }
    }

    // Check if the module supports punishments
    if(checkData.punishment) {
        const punishmentValues = Object.keys(punishments);

        menu.dropdown("Punishment", punishmentValues, { defaultValueIndex: punishmentValues.indexOf(checkData.punishment) });
        menu.textField("Punishment Length", "Enter a length (ex: 12d, 1d, 1m, 30s)", { defaultValue: checkData["punishmentLength"] });
        menu.slider("Minimum Violations Before Punishment", 0, 20, { defaultValue: checkData["minVlbeforePunishment"], valueStep: 1 });

        optionsMap = optionsMap.concat(punishmentSettings);
    }

    menu.show(player).then((response) => {
        if(response.canceled) return;

        const formValues = response.formValues ?? [];

        for(const id in optionsMap) {
            const name = optionsMap[id];

            // @ts-expect-error
            checkData[name] = name === "punishment" ? Object.keys(punishments)[formValues[id]] : formValues[id];
        }

        // Save config
        world.setDynamicProperty("config", JSON.stringify(config));

        player.sendMessage(`§r§6[§aScythe§6]§r Successfully updated the settings for ${check}.\n§r§6[§aScythe§6]§r New Data:\n${JSON.stringify(checkData, null, 2)}`);
    });
}

// ====================== //
//       Player Menu      //
// ====================== //
function playerSettingsMenu(player) {
    player.playSound("mob.chicken.plop");

    const allPlayers = world.getPlayers();
    const menu = createSelectPlayerMenu("Player Menu", allPlayers, player);

    menu.show(player).then((response) => {
        if(response.selection === undefined || allPlayers.length <= response.selection) return mainGui(player);

        playerSettingsMenuSelected(player, allPlayers[response.selection]);
    });
}

export function playerSettingsMenuSelected(player, target) {
    player.playSound("mob.chicken.plop");

    const menu = new ActionFormData()
        .title("Player Menu - " + target.name)
        .body(
            `Player Info:\n\n` +
            `Name: ${target.name}\n` +
            `Unique ID: ${target.id}\n` +
            `Dimension: ${capitalizeFirstLetter((target.dimension.id).replace("minecraft:", ""))}\n` +
            `Coordinates: ${Math.trunc(target.location.x)}, ${Math.trunc(target.location.y)}, ${Math.trunc(target.location.z)}\n` +
            `Gamemode: ${target.getGameMode()}\n` +
            `Platform: ${target.clientSystemInfo.platformType}\n` +
            `Scythe Opped: ${target.hasTag("op") ? "§atrue" : "false"}\n` +
            `§rMuted: ${target.isMuted() ? "§ctrue" : "§afalse"}\n` +
            `§rFrozen: ${target.getDynamicProperty("frozen") ? "§ctrue" : "§afalse"}\n` +
            `§rVanished: ${target.getDynamicProperty("vanished") ?? false}\n` +
            `Flying: ${target.isFlying}`
        )
        .button("View Inventory", "textures/blocks/chest_front.png")
        .button("Kick Player", icons.anvil)
        .button("Ban Player", icons.anvil)
        .button("View Anticheat Logs", icons.info)
        .button("Clear Enderchest", "textures/blocks/ender_chest_front.png")
        .button(target.hasTag("flying") ? "Disable Fly" : "Enable Fly", "textures/ui/levitation_effect.png")
        .button(target.getDynamicProperty("frozen") ? "Unfreeze Player" : "Freeze Player", "textures/ui/icon_winter.png");

    target.isMuted() ? menu.button("Unmute Player", icons.mute_off) : menu.button("Mute Player", icons.mute_on);
    target.hasTag("op") ? menu.button("Remove Player as Scythe-Op", icons.member) :  menu.button("Set Player as Scythe-Op", icons.op);

    menu
        .button("Teleport", icons.arrow)
        .button("Switch Gamemode", icons.op)
        .button("Back", icons.back);

    menu.show(player).then((response) => {
        switch (response.selection) {
            case 0:
                if(!config.commands.invsee.enabled) {
                    return player.sendMessage("§r§6[§aScythe§6]§r Invsee is disabled in config.js.");
                }

                player.sendMessage(getInvseeMsg(target));
                break;

            case 1:
                kickPlayerMenu(player, target, 1);
                break;

            case 2:
                banPlayerMenu(player, target, 1);
                break;

            case 3:
                if(!config.commands.stats.enabled) {
                    return player.sendMessage("§r§6[§aScythe§6]§r Player Stats is disabled in config.js.");
                }

                player.sendMessage(getStatsMsg(target));
                break;

            case 4:
                if(!config.commands.ecwipe.enabled) {
                    return player.sendMessage("§r§6[§aScythe§6]§r Enderchest wiping is disabled in config.js.");
                }

                target.wipeEnderchest(player);
                break;

            case 5:
                if(!config.commands.fly.enabled) {
                    return player.sendMessage("§r§6[§aScythe§6]§r Toggling Fly is disabled in config.js.");
                }

                target.hasTag("flying") ? target.disableFly(player) : target.enableFly(player);
                break;

            case 6:
                if(!config.commands.freeze.enabled) {
                    return player.sendMessage("§r§6[§aScythe§6]§r Freezing players is disabled in config.js.");
                }

                player.getDynamicProperty("frozen") ? target.unfreeze(player) : target.freeze(player);
                break;

            case 7:
                if(!config.commands.mute.enabled) {
                    return player.sendMessage("§r§6[§aScythe§6]§r Muting players is disabled in config.js.");
                }

                target.isMuted() ? target.unmute(player) : target.mute(player);
                break;

            case 8:
                if(!config.commands.op.enabled) {
                    return player.sendMessage("§r§6[§aScythe§6]§r Scythe-Opping players is disabled in config.js.");
                }

                target.hasTag("op") ? target.removeOp(player) : target.addOp(player);
                break;

            case 9:
                playerSettingsMenuSelectedTeleport(player, target);
                break;

            case 10:
                playerSettingsMenuSelectedGamemode(player, target);
                break;

            default:
                playerSettingsMenu(player);
        }
    });
}

function playerSettingsMenuSelectedTeleport(player, target) {
    player.playSound("mob.chicken.plop");

    const menu = new ActionFormData()
        .title("Teleport Menu")
        .body(`Managing ${target.name}.`)
        .button("Teleport To", icons.arrow)
        .button("Teleport Here", "textures/ui/arrow_down.png")
        .button("Back", icons.back);

    menu.show(player).then((response) => {
        switch(response.selection) {
            case 0:
                player.teleport(target.location, {
                    checkForBlocks: false,
                    dimension: target.dimension
                });
                break;

            case 1:
                target.teleport(player.location, {
                    checkForBlocks: false,
                    dimension: player.dimension
                });
                break;

            default:
                playerSettingsMenuSelected(player, target);
        }
    });
}

function playerSettingsMenuSelectedGamemode(player, target) {
    player.playSound("mob.chicken.plop");

    const menu = new ActionFormData()
        .title("Gamemode Menu")
        .body(`Switching ${target.name}'s gamemode.`)
        .button("Gamemode Survival", icons.member)
        .button("Gamemode Creative", icons.op)
        .button("Gamemode Adventure", "textures/ui/permissions_visitor_hand.png")
        .button("Gamemode Spectator", "textures/ui/invisibility_effect.png")
        .button("Default Gamemode", "textures/ui/recap_glyph_desaturated.png")
        .button("Back", icons.back);

    menu.show(player).then((response) => {
        if(response.selection === 5 || response.canceled) return playerSettingsMenuSelected(player, target);

        switch(response.selection) {
            case 3:
                target.setGameMode(GameMode.Spectator);
                break;

            case 4:
                target.runCommand("gamemode 5");
                break;

            // Handles changing to survival, creative, and adventure
            default:
                target.runCommand(`gamemode ${response.selection}`);
        }
    });
}
// ====================== //
//   Server Management    //
// ====================== //
function serverManagementMenu(player) {
    player.playSound("mob.chicken.plop");

    // @ts-expect-error
    const globalmute = JSON.parse(world.getDynamicProperty("globalmute"));

    const menu = new ActionFormData()
        .title("Server Management Menu")
        .body(`Hello ${player.name},\n\nPlease select an option below.`)
        .button("Full Report", icons.info);

    globalmute.muted ? menu.button("Disable Global Mute", icons.mute_off) : menu.button("Enable Global Mute", icons.mute_on);

    menu.button("Back", icons.back);
    menu.show(player).then((response) => {
        switch(response.selection) {
            case 0: {
                const players = world.getPlayers();

                for(const pl of players) {
                    player.sendMessage(getStatsMsg(pl));
                }
                break;
            }

            case 1:
                toggleGlobalMute(player);
                break;

            case 2:
                mainGui(player);
        }
    });
}

// ====================== //
//       Debug Menu       //
// ====================== //
function debugSettingsMenu(player) {
    player.playSound("mob.chicken.plop");

    const menu = new ActionFormData()
        .title("Debug Settings Menu")
        .body(`Hello ${player.name},\n\nPlease select an option below.`)
        .button("Disable Debug Intents", icons.debug)
        .button("Randomize Inventory", icons.debug)
        .button("Test Flag", icons.debug)
        .button("Enable All Modules", icons.debug)
        .button("Reset Config", icons.debug)
        .button("Force Watchdog Stack Overflow", icons.debug)
        .button("Force Watchdog Hang", icons.debug)
        .button("Force Watchdog Memory Crash", icons.debug)
        .button("Back", icons.back);
    menu.show(player).then((response) => {
        switch(response.selection) {
            case 0:
                config.debug = false;
                mainGui(player);
                break;

            case 1: {
                const container = player.getComponent("inventory").container;
                const allItems = ItemTypes.getAll();

                /**
                 * @type {Array<String>}
                 */
                const totalItems = [];
                for(let i = 0; i < 36; i++) {
                    if(container.getItem(i)?.nameTag === config.commands.ui.ui_item_name) continue;

                    const randomItem = allItems[~~(Math.random() * allItems.length)];

                    if(totalItems.includes(randomItem.id)) {
                        i--;
                        continue;
                    }
                    totalItems.push(randomItem.id);

                    container.setItem(i, new ItemStack(randomItem, 1));
                }
                break;
            }

            case 2:
                debugSettingsFlag(player);
                break;

            case 3:
                for(const module of Object.values(config.modules)) {
                    module.enabled = true;
                }

                world.setDynamicProperty("config", JSON.stringify(config));

                player.sendMessage("§r§6[§aScythe§6]§r All Scythe modules have been enabled.");
                break;

            case 4:
                world.setDynamicProperty("config", undefined);
                player.sendMessage("§r§6[§aScythe§6]§r The scythe config has been reset. Run '/reload' to apply the changes.");
                break;

            case 5: {
                const loop = () => loop();
                loop();
                break;
            }

            case 6:
                // eslint-disable-next-line no-constant-condition
                while(true) {}

            case 7:
                config.array = [config];
                // eslint-disable-next-line no-constant-condition
                while(true) {
                    config.array.push(config);
                }

            default:
                mainGui(player);
        }
    });
}

function debugSettingsFlag(player) {
    player.playSound("mob.chicken.plop");

    const menu = new ModalFormData()
        .title("Debug Menu - Test Flag")
        .textField("Check", "Example", { defaultValue: "Example" })
        .textField("Check type", "A", { defaultValue: "A" })
        .textField("Hack type", "Combat", { defaultValue: "Combat" })
        .textField("Debug", "")
        .toggle("Should TP", { defaultValue: false })
        .toggle("Clear slot", { defaultValue: false })
        .slider("Slot", 0, 36, { defaultValue: 0, valueStep: 0 });

    menu.show(player).then((response) => {
        const formValues = response.formValues;
        if(!formValues) return debugSettingsMenu(player);

        // @ts-expect-error
        flag(player, formValues[0], formValues[1], formValues[2], formValues[3], formValues[4], formValues[5] ? formValues[6] : undefined);
    });
}

// ====================== //
//         Extra          //
// ====================== //
const playerIcons = [
    "textures/ui/icon_alex.png",
    "textures/ui/icon_steve.png",
];

function createSelectPlayerMenu(title, players, self) {
    const menu = new ActionFormData()
        .title(title)
        .body("Please select a player to manage.");

    for(const player of players) {
        let playerName = player.name;

        if(player.id === self.id) playerName += " §1[YOU]";
        if(player.hasTag("op")) playerName += " §1[OP]";

        // Using bitwise operators to remove decimals is much faster than using Math.trunc()
        // https://stackoverflow.com/a/38714503
        menu.button(playerName, playerIcons[~~(Math.random() * playerIcons.length)]);
    }

    menu.button("Back", icons.back);

    return menu;
}
```

`scripts/checks/Check.js`:

```js
import { system } from "@minecraft/server";
import { flag } from "../util.js";
import config from "../data/config.js";

class Check {
	/**
	 * @class
	 * @param {Object} data
	 * @param {String} data.check - The name of the check
	 * @param {String} data.subcheck - Which type of check (ex. A, B, C)
	 * @param {String} data.type - What kind of cheat does this check detect (ex. Movement, Exploit)
	 * @throws
	 */
	constructor({ check, subcheck, type }) {
		this.check = check;
		this.subcheck = subcheck;
		this.type = type;

		const moduleConfig = config.modules[this.check.toLowerCase() + this.subcheck];
		if(!moduleConfig) throw Error(`No config data was found for ${this.check}[${this.subcheck}]`);

		Object.defineProperty(moduleConfig, "_enabled", {
			// We dont want the command or UI interfaces to show the '_enabled' field
			enumerable: false,
			writable: true,
			value: moduleConfig.enabled
		});

		const self = this;
		Object.defineProperty(moduleConfig, "enabled", {
			enumerable: true,
			get: function() {
				return this._enabled;
			},
			set: function(value) {
				if(config.debug) console.log(`${this._enabled} --> ${value}`);
				// Module was enabled
				if(!this._enabled && value) self.enable?.();

				// Module was disabled
				if(this._enabled && !value) self.disable?.();

				this._enabled = value;
			}
		});

		this.config = moduleConfig;
	}

	/**
	 * @param {import("@minecraft/server").Player} player - The player that should be flagged
	 * @param {String} [debug] - Debug information about what caused the flag
	 * @param {Boolean} [resetPos] - Should the player's position be reset to the last known good position
	 */
	flag(player, debug, resetPos = false) {
		flag(player, this.check, this.subcheck, this.type, debug, resetPos);
	}

	// Incase we are in a before event then we will need to wait one tick before we can run the flag function
	delayedFlag(...args) {
		system.run(() => this.flag(...args));
	}
}

export default Check;
```

`scripts/checks/combat/Autoclicker/AutoclickerA.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world, Player } from "@minecraft/server";

class AutoclickerA extends Check {
	/**
	 * @class
	 * @description Check for attacking too many entities in a period of time
	 */
	constructor() {
		super({
			check: "Autoclicker",
			subcheck: "A",
			type: "Combat"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		/**
		 * There's surely a better way to do this...
		 * We want the afterEntityHitEntity function have a this value of the AutoclickerA class
		 * Doing something like 'world.afterEvents.entityHitEntity.subscribe(this.afterEntityHitEntity)' will result in a this value of null
		 * We could use .bind() in order to set the this value to the AutoClickerA class, but the callback signature would be different so we wont be able to unsubscribe from it in the disable function
		 * To get around this, we use .bind() and store the callback in the callbacks object, and use the references to those callbacks in the disable function
		 */
		this.callbacks = {
			afterEntityHitEntity: world.afterEvents.entityHitEntity.subscribe(this.afterEntityHitEntity.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.entityHitEntity.unsubscribe(this.callbacks.afterEntityHitEntity);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").EntityHitEntityAfterEvent} data
	 */
	afterEntityHitEntity(data) {
		const { damagingEntity: player } = data;
		/*
		Propeling yourself towards a group of entities using a Riptide Trident will result in the trident attacking all the entities in the same tick
		The AutoclickerA check will increment your clicks by the amount of entities in the group, which could result in a false flag if there are lots of entities in the group
		To prevent this, we don't increment the player's clicks if the player is are holding a trident
		*/
		if(!(player instanceof Player) || player.heldItem === "minecraft:trident") return;

		player.clicks++;

		// Check if the data collection period has ended
		const now = Date.now();
		if(now - player.firstAttack <= this.config.checkCPSAfter) return;

		const cps = player.clicks / ((now - player.firstAttack) / 1000);
		if(cps > this.config.maxCPS) this.flag(player, `cps=${cps}`);

		// TODO: Potentially save this data inside the AutoclickerA class instead of in the player class?
		player.firstAttack = now;
		player.clicks = 0;
	}
}

export default new AutoclickerA();
```

`scripts/checks/combat/Fastuse/FastuseA.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world, Player } from "@minecraft/server";

class FastuseA extends Check {
	/**
	 * @class
	 * @description Check if a player uses an item too fast
	 */
	constructor() {
		super({
			check: "Fastuse",
			subcheck: "A",
			type: "Combat"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforeItemUse: world.beforeEvents.itemUse.subscribe(this.beforeItemUse.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.itemUse.unsubscribe(this.callbacks.beforeItemUse);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").ItemUseBeforeEvent} data
	 */
	beforeItemUse(data) {
		const { source } = data;
		if(!(source instanceof Player)) return;

		const now = Date.now();

		const throwDelay = now - source.lastThrow;
		if(throwDelay > this.config.min_use_delay && throwDelay < this.config.max_use_delay) {
			// When using items such as fishing rods or throwing snowballs, there is about a 200ms delay before the item can be used again or thrown
			// Placing blocks has a delay that is around 100ms, which can trip this detection
			// TODO: Figure out how to differentiate placing blocks and using items (maybe through the playerswing event?)
			// this.delayedFlag(player, `lastThrowTime=${throwDelay}`);
			data.cancel = true;
		}

		source.lastThrow = now;
	}
}

export default new FastuseA();
```

`scripts/checks/combat/Killaura/KillauraA.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world, Player } from "@minecraft/server";

class KillauraA extends Check {
	/**
	 * @class
	 * @description Check if a player attacks an entity while doing another action
	 */
	constructor() {
		super({
			check: "Killaura",
			subcheck: "A",
			type: "Combat"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			afterEntityHitEntity: world.afterEvents.entityHitEntity.subscribe(this.afterEntityHitEntity.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.entityHitEntity.unsubscribe(this.callbacks.afterEntityHitEntity);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").EntityHitEntityAfterEvent} data
	 */
	afterEntityHitEntity(data) {
		const { damagingEntity: player } = data;
		if(!(player instanceof Player)) return;

		// Checks if a player attacks while using an item
		if(player.isUsingItem && Date.now() - player.itemUsedAt > this.config.min_item_use_time) {
            this.flag(player, `state=usingItem,itemUsedFor=${Date.now() - player.itemUsedAt}`);
        }

		// Checks if a player attacks while sleeping
		if(player.isSleeping) {
			this.flag(player, `state=sleeping`);
		}

		// Checks if a player attacks while having a GUI (such as a chest) open
		if(player.hasTag("hasGUIopen")) {
			this.flag(player, `state=guiOpen`);
		}
	}
}

export default new KillauraA();
```

`scripts/checks/combat/Killaura/KillauraB.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world, system, Player } from "@minecraft/server";

class KillauraB extends Check {
	/**
	 * @class
	 * @description Check if a player attacks without swinging their hand
	 */
	constructor() {
		super({
			check: "Killaura",
			subcheck: "B",
			type: "Combat"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			afterEntityHitEntity: world.afterEvents.entityHitEntity.subscribe(this.afterEntityHitEntity.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.entityHitEntity.unsubscribe(this.callbacks.afterEntityHitEntity);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").EntityHitEntityAfterEvent} data
	 */
	afterEntityHitEntity(data) {
		const { damagingEntity: player } = data;
		// Mining fatigue increases how long the arm swing animation lasts, and if its in middle of an animation the playerSwingStart event will not trigger for attacks
		if(!(player instanceof Player) || player.heldItem === "minecraft:trident" || player.getEffect("mining_fatigue")) return;

		/*
		The playerSwingStart event fires after the entityHitEntity event is fired, so we have to implement some sort of delay
		When a player attacks, we wait 40 ticks (or two seconds) to compensate for the playerSwingStart event firing after entityHitEntity, and then check if the player has swung in the last 5 seconds
		If they have not swung, then we know they are using a no swing cheat and we can detect them
		*/
		system.runTimeout(() => {
			const swingDelay = Date.now() - player.lastLeftClick;
	
			if(swingDelay > this.config.max_swing_delay) {
				this.flag(player, `swingDelay=${swingDelay}`);
			}
		}, this.config.wait_ticks);
	}
}

export default new KillauraB();
```

`scripts/checks/combat/Killaura/KillauraC.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world, Player } from "@minecraft/server";

class KillauraC extends Check {
	/**
	 * @class
	 * @description Check if a player attacks multiple different entities in a single tick
	 */
	constructor() {
		super({
			check: "Killaura",
			subcheck: "C",
			type: "Combat"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			afterEntityHitEntity: world.afterEvents.entityHitEntity.subscribe(this.afterEntityHitEntity.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.entityHitEntity.unsubscribe(this.callbacks.afterEntityHitEntity);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").EntityHitEntityAfterEvent} data
	 */
	afterEntityHitEntity(data) {
		const { damagingEntity: player, hitEntity: entity } = data;
		/*
		Propeling yourself towards a group of entities using a Riptide Trident will result in the trident attacking all the entities in the same tick
		The KillauraC check will see that the player attacked multiple entities at once, and falsely flag the player. To prevent this, we dont run the check if the player is holding a trident
		*/
		if(!(player instanceof Player) || player.heldItem === "minecraft:trident") return;

		// It is possible to attack the same entity more than one time in a single tick, so to avoid false positives we only count how many different entities were attacked
		player.entitiesHit.add(entity.id);

		if(player.entitiesHit.size >= this.config.entities) {
			this.flag(player, `entitiesHit=${player.entitiesHit.size}`);
		}
	}

	/**
	 * @param {Player} player
	 */
	tick(player) {
		player.entitiesHit.clear();
	}
}

export default new KillauraC();
```

`scripts/checks/combat/Reach/ReachA.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world, GameMode, Player } from "@minecraft/server";

class ReachA extends Check {
	/**
	 * @class
	 * @description Check for attacking players farther away than possible
	 */
	constructor() {
		super({
			check: "Reach",
			subcheck: "A",
			type: "Combat"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			afterEntityHitEntity: world.afterEvents.entityHitEntity.subscribe(this.afterEntityHitEntity.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.entityHitEntity.unsubscribe(this.callbacks.afterEntityHitEntity);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").EntityHitEntityAfterEvent} data
	 */
	afterEntityHitEntity(data) {
		const { damagingEntity: player, hitEntity: entity } = data;
		/*
		This reach detection is rather annoying, as the vanilla client can attack an entity if their collision box is in range
		however this reach calculation doesn't account for the collision box but rather the entity's center
		This causes false positives when attacking entities with large collision boxes such as Ender Dragons
		To prevent any sort of false positives, we only check reach when the player attacks another player
		*/
		if(!(player instanceof Player) || !(entity instanceof Player) || player.getGameMode() === GameMode.Creative || this.config.excluded_items.includes(player.heldItem)) return;

		// Calculate reach from the player's head location
		const headLocation = player.getHeadLocation();

		// Use the Euclidean Distance Formula to determine the distance between two 3-dimensional objects
		const distance = Math.sqrt(
			(entity.location.x - headLocation.x)**2 +
			(entity.location.y - headLocation.y)**2 +
			(entity.location.z - headLocation.z)**2
		);

		if(distance > this.config.reach) {
			this.flag(player, `distance=${distance},item=${player.heldItem}`);
		}
	}
}

export default new ReachA();
```

`scripts/checks/combat/Reach/ReachC.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class ReachC extends Check {
	/**
	 * @class
	 * @description Check for placing blocks farther away than possible
	 */
	constructor() {
		super({
			check: "Reach",
			subcheck: "C",
			// Technically this isn't a combat cheat, however the check has to be beside with the other Reach checks
			// Having two reach checks in different folders would be pretty messy
			type: "Combat"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforePlayerPlaceBlock: world.beforeEvents.playerPlaceBlock.subscribe(this.beforePlayerPlaceBlock.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.playerPlaceBlock.unsubscribe(this.callbacks.beforePlayerPlaceBlock);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerPlaceBlockBeforeEvent} data
	 */
	beforePlayerPlaceBlock(data) {
		const { block, player } = data;

		// Use the Euclidean Distance Formula to determine the distance between two 3-dimensional objects
		const distance = Math.sqrt(
			(block.location.x - player.location.x)**2 +
			(block.location.y - player.location.y)**2 +
			(block.location.z - player.location.z)**2
		);

		const maxPlaceDistance = player.getMaxBlockPlaceDistance();
		if(distance > maxPlaceDistance) {
			this.delayedFlag(player, `distance=${distance},gamemode=${player.getGameMode()},inputMode=${player.inputInfo.lastInputModeUsed}`);
			data.cancel = true;
		}
	}
}

export default new ReachC();
```

`scripts/checks/exploit/BadPackets/BadPackets1.js`:

```js
// @ts-check
import Check from "../../Check.js";

class BadPackets1 extends Check {
	/**
	 * @class
	 * @description Check for invalid pitch/yaw
	 */
	constructor() {
		super({
			check: "BadPackets",
			subcheck: "1",
			type: "Exploit"
		});
	}

	/**
	 * @param {import("@minecraft/server").Player} player
	 */
	tick(player) {
		/*
		A player's pitch has a range of -90 to 90, and the player's yaw has a range of -180 to 180
		There are some cheats and crash methods that make the player exceed these vanilla limits, which we can detect

		In a vanilla game, it is possible to to exceed this limit by using Full Desktop Gameplay and using the arrow keys to move your camera
		This will result in the player's pitch going beyond these limits, with a magnitude that is proportional to the rotation speed
		The Scripting API does not allow us to determine if this option is enabled, so there is no way to fix this false positive

		This check has a long history in Scythe. It was originally added somewhere in August 2020 ~ 2021, before the anticheat was public, as a function-based check
		In July 2022, this check was ported to use the Scripting API, however there was a bug where using boats would make the player's viewing angles exceed the limit by an absurd value
		It was reintroduced as a Scripting API after it was confirmed that the issue is no longer present
		*/

		const rotation = player.getRotation();
		if(Math.abs(rotation.x) > 90 || Math.abs(rotation.y) > 180) {
			this.flag(player, `xRot=${rotation.x},yRot=${rotation.y}`, true);
		}
	}
}

export default new BadPackets1();
```

`scripts/checks/exploit/BadPackets/BadPackets2.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

const MAX_MESSAGE_LENGTH = 512;

class BadPackets2 extends Check {
	/**
	 * @class
	 * @description Check if a message is either blank or exceeds Minecraft's maximum chat length
	 */
	constructor() {
		super({
			check: "BadPackets",
			subcheck: "2",
			type: "Exploit"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforeChatSend: world.beforeEvents.chatSend.subscribe(this.beforeChatSend.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.chatSend.unsubscribe(this.callbacks.beforeChatSend);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").ChatSendBeforeEvent} msg
	 */
	beforeChatSend(msg) {
		const { sender, message } = msg;

		if(message.length === 0 || message.length > MAX_MESSAGE_LENGTH) {
			this.delayedFlag(sender, `length=${message.length}`);
			msg.cancel = true;
		}
	}
}

export default new BadPackets2();
```

`scripts/checks/exploit/BadPackets/BadPackets3.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world, Player } from "@minecraft/server";

class BadPackets3 extends Check {
	/**
	 * @class
	 * @description Check for attacking self
	 */
	constructor() {
		super({
			check: "BadPackets",
			subcheck: "3",
			type: "Exploit"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			afterEntityHitEntity: world.afterEvents.entityHitEntity.subscribe(this.afterEntityHitEntity.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.entityHitEntity.unsubscribe(this.callbacks.afterEntityHitEntity);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").EntityHitEntityAfterEvent} data
	 */
	afterEntityHitEntity(data) {
		const { hitEntity, damagingEntity } = data;
		if(!(hitEntity instanceof Player)) return;

        // Some cheats may attack the current player to bypass some movement cheats
        if(hitEntity.id === damagingEntity.id) this.flag(hitEntity);
	}
}

export default new BadPackets3();
```

`scripts/checks/exploit/BadPackets/BadPackets4.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class BadPackets4 extends Check {
	/**
	 * @class
	 * @description Check for newlines or carriage returns in messages
	 */
	constructor() {
		super({
			check: "BadPackets",
			subcheck: "4",
			type: "Exploit"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforeChatSend: world.beforeEvents.chatSend.subscribe(this.beforeChatSend.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.chatSend.unsubscribe(this.callbacks.beforeChatSend);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").ChatSendBeforeEvent} msg
	 */
	beforeChatSend(msg) {
		const { sender, message } = msg;

		if(message.match(/\n|\r/)) {
			this.delayedFlag(sender);
			msg.cancel = true;
		}
	}
}

export default new BadPackets4();
```

`scripts/checks/exploit/BadPackets/BadPackets5.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class BadPackets5 extends Check {
	/**
	 * @class
	 * @description Check for invalid data in the login skindata packet
	 */
	constructor() {
		super({
			check: "BadPackets",
			subcheck: "5",
			type: "Exploit"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			afterPlayerSpawn: world.afterEvents.playerSpawn.subscribe(this.afterPlayerSpawn.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.playerSpawn.unsubscribe(this.callbacks.afterPlayerSpawn);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerSpawnAfterEvent} data
	 */
	afterPlayerSpawn(data) {
		const { initialSpawn, player } = data;
		if(!initialSpawn) return;

		/*
		Check if the player's max render distance is not inside bounds. Vanilla clients would have this value set to 6-96 according to https://minecraftbedrock-archive.fandom.com/wiki/Render_Distance
		The article is slightly outdated as it is possible for really low-end devices to have a max render distance of 5
		*/
		const renderDistance = player.clientSystemInfo.maxRenderDistance;
		if(renderDistance < 5 || renderDistance > 96) {
			this.flag(player, `maxRenderDistance=${renderDistance}`);
		}
	}
}

export default new BadPackets5();
```

`scripts/checks/exploit/Instabreak/InstabreakA.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world, GameMode } from "@minecraft/server";

/**
 * Before 1.16.210, breaking blocks by the client involved the PlayerAction Packet which did not validate whether a player was actually able to break a block
 * This meant that a malicious client could break every single block instantly, even blocks such as bedrock
 * To prevent this, Mojang implemented Server Authoritative Breaking (SAB), which according to the BDS documentation, "the server will compute block mining operations in sync with the client so it can verify that the client should be able to break blocks when it thinks it can"
 * When Server Authoritative Block Breaking is enabled, the client would instead use the PlayerAuthInput Packet to let the server know that it is breaking a block.
 * This packet is also responsible for validating whether a player's movement is valid by Server Authoritative Movement
 * 
 * Since the server validates how long a player has been breaking a block for, this should mean that instabreak exploits should not affect BDS and this check is completely redundant
 * However it was discovered in the wild that a group of players were able to bypass SAB and destroy bedrock and end portal frames
 * As a remedy, this check was implemented to make sure players who are not in creative cannot break blocks that are unbreakable
 */
class InstabreakA extends Check {
	/**
	 * @class
	 * @description Check for breaking unbreakable blocks while not in Creative
	 */
	constructor() {
		super({
			check: "Instabreak",
			subcheck: "A",
			type: "Exploit"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		world.beforeEvents.playerBreakBlock.subscribe(this.beforePlayerBreakBlock.bind(this));
	}

	disable() {
		world.beforeEvents.playerBreakBlock.unsubscribe(this.beforePlayerBreakBlock);
	}

	/**
	 * @param {import("@minecraft/server").PlayerBreakBlockBeforeEvent} data
	 */
	beforePlayerBreakBlock(data) {
		const { player, block } = data;
		if(player.getGameMode() === GameMode.Creative) return;

		if(this.config.unbreakable_blocks.includes(block.typeId)) {
			this.delayedFlag(player, `block=${block.typeId}`);
			data.cancel = true;
		}
	}
}

export default new InstabreakA();
```

`scripts/checks/exploit/Namespoof/NamespoofA.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class NamespoofA extends Check {
	/**
	 * @class
	 * @description Check if a player's name is too long or short
	 */
	constructor() {
		super({
			check: "Namespoof",
			subcheck: "A",
			type: "Exploit"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			afterPlayerSpawn: world.afterEvents.playerSpawn.subscribe(this.afterPlayerSpawn.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.playerSpawn.unsubscribe(this.callbacks.afterPlayerSpawn);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerSpawnAfterEvent} data
	 */
	afterPlayerSpawn(data) {
		const { initialSpawn, player } = data;
		if(!initialSpawn) return;

		// When a sub-client joins a world their name has a suffix of (x), with x being a number between 1-3.
		// To prevent any false positives with this, we make sure to omit that suffix from being calculated in the length checks
		const maxLength = this.config.maxNameLength + ((/\([1-3]\)$/).test(player.name) ? 3 : 0);

		if(player.name.length < this.config.minNameLength || player.name.length > maxLength) {
			const extraLength = player.name.length - this.config.maxNameLength;
			player.nameTag = player.name.slice(0, -extraLength) + "...";

			this.flag(player, `length=${player.name.length}`);
		}
	}
}

export default new NamespoofA();
```

`scripts/checks/exploit/Namespoof/NamespoofB.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class NamespoofB extends Check {
	/**
	 * @class
	 * @description Check for invalid characters in a player's name
	 */
	constructor() {
		super({
			check: "Namespoof",
			subcheck: "B",
			type: "Exploit"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			afterPlayerSpawn: world.afterEvents.playerSpawn.subscribe(this.afterPlayerSpawn.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.playerSpawn.unsubscribe(this.callbacks.afterPlayerSpawn);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerSpawnAfterEvent} data
	 */
	afterPlayerSpawn(data) {
		const { initialSpawn, player } = data;
		if(!initialSpawn) return;

		if(RegExp(this.config.regex).test(player.name)) {
			this.flag(player);
		}
	}
}

export default new NamespoofB();
```

`scripts/checks/inventory/AutoOffhand/AutoOffhandA.js`:

```js
// @ts-check
import Check from "../../Check.js";

class AutoOffhandA extends Check {
	/**
	 * @class
	 * @description Check for moving items into the offhand while doing another action
	 */
	constructor() {
		super({
			check: "AutoOffhand",
			subcheck: "A",
			type: "Inventory"
		});
	}

	/**
	 * @param {import("@minecraft/server").Player} player
	 */
	tick(player) {
		// Check if the player is using sending movement inputs
		if(player.isUsingInputKeys()) {
			this.flag(player, `state=moving`, true);
		}

		if(player.isUsingItem) {
			this.flag(player, `state=usingItem`);
		}

		// Check if the player is currently swinging their hand
		if(player.hasTag("left")) {
			this.flag(player, `state=swungHand`);
		}
	}
}

export default new AutoOffhandA();
```

`scripts/checks/inventory/InventoryMods/InventoryModsA.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world, Player } from "@minecraft/server";

/**
 * This module is disabled due to false flags
 * To determine if a player has a GUI open, such as a chest, we have an environmental sensor in the player.json file that checks if the player has a container open
 * When a player opens a container, an event will fire which will give the player the 'hasGUIopen' tag
 * This process is rather slow, as it could take up to 500ms from when the player first opened the chest to giving the tag
 * Between that time, the player could close the GUI and use an item, causing a false flag
 */
class InventoryModsA extends Check {
	/**
	 * @class
	 * @description Check for using an item while having a GUI open
	 */
	constructor() {
		super({
			check: "InventoryMods",
			subcheck: "A",
			type: "Inventory"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforeItemUse: world.beforeEvents.itemUse.subscribe(this.beforeItemUse.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.itemUse.unsubscribe(this.callbacks.beforeItemUse);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").ItemUseBeforeEvent} data
	 */
	beforeItemUse(data) {
		const { source } = data;
		if(!(source instanceof Player)) return;

		if(source.hasTag("hasGUIopen")) {
			this.delayedFlag(source);
			data.cancel = true;
		}
	}
}

export default new InventoryModsA();
```

`scripts/checks/legacy/CrasherA.js`:

```js
// @ts-check
import Check from "../Check.js";

class CrasherA extends Check {
	/**
	 * @class
	 * @description Check for invalid player positions
	 */
	constructor() {
		super({
			check: "Crasher",
			subcheck: "A",
			type: "Exploit"
		});
	}

	/**
	 * @param {import("@minecraft/server").Player} player
	 */
	tick(player) {
		/*
		Horion's old crasher would teleport the player to the position 4,294.967,295 in each coordinate plane
		This would result in the server crashing as it does not support such large player positions
		The vanilla game has a border at 30,000,000 which cannot be passed normally, even with commands like /tp
		If the player goes beyond that coordinate value, then we know an exploit, most likely Crasher, is being used

		It is possible for this check to false flag. On an anarchy realm that used Scythe, some players were spawning in End Gateway blocks with NBTs
		set to teleport the player beyond 30,000,000. These players were placing these end gateway blocks onto players in order to get them to flag
		Scythe's CrasherA check and get them banned. This is not a concern for realms with all IllegalItems checks enabled, however for anarchy
		realms it may be neccessary to change the max position value to 4,294.967,295 to avoid that ban exploit
		*/
		if(
			Math.abs(player.location.x) > 30000000 ||
			Math.abs(player.location.y) > 30000000 ||
			Math.abs(player.location.z) > 30000000
		) this.flag(player, `xPos=${player.location.x},yPos=${player.location.y},zPos=${player.location.z}`, true);
	}
}

export default new CrasherA();
```

`scripts/checks/legacy/InventoryModsB.js`:

```js
// @ts-check
import Check from "../Check.js";

/**
 * This check could detect Inventory Move cheats by seeing if the player was interacting with the inventory and moving items into their cursor
 * Server Authoritative Movement, at least since 1.21.130, now checks if the player moves while having so inventory move cheats are completely patched
 */
class InventoryModsB extends Check {
	/**
	 * @class
	 * @description Check for changing the current cursor slot while moving
	 */
	constructor() {
		super({
			check: "InventoryMods",
			subcheck: "B",
			type: "Inventory"
		});
	}

	/**
	 * @param {import("@minecraft/server").Player} player
	 */
	tick(player) {
		const cursorItem = player.getComponent("cursor_inventory")?.item;

		if(player.lastCursorItem?.typeId !== cursorItem?.typeId && player.isUsingInputKeys()) {
			this.flag(player, `oldItem=${player.lastCursorItem?.typeId},newItem=${cursorItem?.typeId}`, true);
		}

		player.lastCursorItem = cursorItem;
	}
}

export default new InventoryModsB();
```

`scripts/checks/legacy/NoslowA.js`:

```js
// @ts-check
import Check from "../Check.js";
import { Player } from "@minecraft/server";

/**
 * The hack NoSlowDown allows a player to not be slowed down when using an item
 * When this check was created (and for most of its lifespan), Server Authoritative Movement did not trigger if you are going too fast while using an item
 * meaning this was one of the few movement checks we could detect without SAM 'normalizing' player velocities in the eye of the Scripting API
 * 
 * As of 1.21.130 when it was tested again, Server Authoritative Movement now has checks against moving too fast while using an item
 * so this means that Scythe's check for Noslow is useless
 */
class NoslowA extends Check {
	/**
	 * @class
	 * @description Check for too high player speeds when using an item
	 */
	constructor() {
		super({
			check: "Noslow",
			subcheck: "A",
			type: "Movement"
		});
	}

	/**
	 * @param {Player} player
	 */
	tick(player) {
		if(
			!player.isOnGround ||
			// TODO: Try to remove the isJumping check to patch bypasses
			player.isJumping ||
			player.isGliding ||
			player.heldItem === "minecraft:trident" ||
			// Fishing rods do not slow down the player when used
			player.heldItem === "minecraft:fishing_rod" ||
			!player.isUsingItem ||
			!player.isUsingInputKeys() ||
			player.getEffect("speed") ||
			player.hasTag("riding")
		) return;

		// Make sure the player has been using the item for at least 10 ticks
		const now = Date.now();
		if(now - player.itemUsedAt <= 500) return;

		// Find the magnitude of the velocity vector
		const velocity = player.getVelocity();
		const playerSpeed = Math.sqrt(velocity.x**2 + velocity.z**2);

		// Check if player speed is within the range of the flag
		if(playerSpeed <= this.config.speed && playerSpeed >= this.config.maxSpeed) return;

		// Get the block below the player
		const blockBelow = player.dimension.getBlock({x: player.location.x, y: player.location.y - 1, z: player.location.z});

		// Make sure there are no entities below the player to fix false positives with boats
		const nearbyEntities = player.dimension.getEntitiesAtBlockLocation(player.location);

		if(blockBelow && !nearbyEntities.find(entity => entity instanceof Player) && !blockBelow.typeId.includes("ice")) {
			this.flag(player, `speed=${playerSpeed.toFixed(2)},heldItem=${player.heldItem},blockBelow=${blockBelow.typeId},timeUsingItem=${now - player.itemUsedAt}`, true);
		}
	}
}

export default new NoslowA();
```

`scripts/checks/legacy/README.md`:

```md
# Legacy Checks
Checks that have been completely patched out by Mojang are moved into this folder and is no longer used by Scythe. They are left here for learning purposes, and as an easy way to retrieve them incase the hack gets unpatched by Mojang.
```

`scripts/checks/misc/Spammer/SpammerA.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class SpammerA extends Check {
	/**
	 * @class
	 * @description Check for sending messages while moving
	 */
	constructor() {
		super({
			check: "Spammer",
			subcheck: "A",
			type: "Misc"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforeChatSend: world.beforeEvents.chatSend.subscribe(this.beforeChatSend.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.chatSend.unsubscribe(this.callbacks.beforeChatSend);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").ChatSendBeforeEvent} msg
	 */
	beforeChatSend(msg) {
		const { sender } = msg;

		if(sender.isUsingInputKeys()) {
			this.delayedFlag(sender, undefined, true);
			msg.cancel = true;
		}
	}
}

export default new SpammerA();
```

`scripts/checks/misc/Spammer/SpammerB.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class SpammerB extends Check {
	/**
	 * @class
	 * @description Check for sending messages while attacking
	 */
	constructor() {
		super({
			check: "Spammer",
			subcheck: "B",
			type: "Misc"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforeChatSend: world.beforeEvents.chatSend.subscribe(this.beforeChatSend.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.chatSend.unsubscribe(this.callbacks.beforeChatSend);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").ChatSendBeforeEvent} msg
	 */
	beforeChatSend(msg) {
		const { sender } = msg;

		// Mining fatigue can make the arm swing animation last longer than normal so we ignore players with that effect
		if(sender.hasTag("left") && !sender.getEffect("mining_fatigue")) {
			this.delayedFlag(sender);
			msg.cancel = true;
		}
	}
}

export default new SpammerB();
```

`scripts/checks/misc/Spammer/SpammerC.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class SpammerC extends Check {
	/**
	 * @class
	 * @description Check for sending messages while using an item
	 */
	constructor() {
		super({
			check: "Spammer",
			subcheck: "C",
			type: "Misc"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforeChatSend: world.beforeEvents.chatSend.subscribe(this.beforeChatSend.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.chatSend.unsubscribe(this.callbacks.beforeChatSend);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").ChatSendBeforeEvent} msg
	 */
	beforeChatSend(msg) {
		const { sender } = msg;

		if(sender.isUsingItem) {
			this.delayedFlag(sender);
			msg.cancel = true;
		}
	}
}

export default new SpammerC();
```

`scripts/checks/misc/Spammer/SpammerD.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class SpammerD extends Check {
	/**
	 * @class
	 * @description Check for sending messages while having a GUI open
	 */
	constructor() {
		super({
			check: "Spammer",
			subcheck: "D",
			type: "Misc"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforeChatSend: world.beforeEvents.chatSend.subscribe(this.beforeChatSend.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.chatSend.unsubscribe(this.callbacks.beforeChatSend);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").ChatSendBeforeEvent} msg
	 */
	beforeChatSend(msg) {
		const { sender } = msg;

		if(sender.hasTag("hasGUIopen")) {
			this.delayedFlag(sender);
			msg.cancel = true;
		}
	}
}

export default new SpammerD();
```

`scripts/checks/movement/Invalidsprint/InvalidsprintA.js`:

```js
// @ts-check
import Check from "../../Check.js";

class InvalidsprintA extends Check {
	/**
	 * @class
	 * @description Check for sprinting while having the blindness effect
	 */
	constructor() {
		super({
			check: "Invalidsprint",
			subcheck: "A",
			type: "Movement"
		});
	}

	/**
	 * @param {import("@minecraft/server").Player} player
	 */
	tick(player) {
		if(player.getEffect("blindness")) this.flag(player, undefined, true);
	}
}

export default new InvalidsprintA();
```

`scripts/checks/movement/Invalidsprint/InvalidsprintB.js`:

```js
// @ts-check
import Check from "../../Check.js";

class InvalidsprintB extends Check {
	/**
	 * @class
	 * @description Check for sprinting while using an item
	 */
	constructor() {
		super({
			check: "Invalidsprint",
			subcheck: "B",
			type: "Movement"
		});
	}

	/**
	 * @param {import("@minecraft/server").Player} player
	 */
	tick(player) {
		if(!player.isUsingItem || player.heldItem === "minecraft:trident") return;

		// This module is disabled due to false flags
		// When the player is about to finish eating food, the game makes the player sprint right before the player finishes eating
		const now = Date.now();
		if(now - player.itemUsedAt >= 200) this.flag(player, `itemUsedFor=${now - player.itemUsedAt}`, true);
	}
}

export default new InvalidsprintB();
```

`scripts/checks/movement/Invalidsprint/InvalidsprintC.js`:

```js
// @ts-check
import Check from "../../Check.js";

class InvalidsprintC extends Check {
	/**
	 * @class
	 * @description Check for sprinting while sneaking
	 */
	constructor() {
		super({
			check: "Invalidsprint",
			subcheck: "C",
			type: "Movement"
		});
	}

	/**
	 * @param {import("@minecraft/server").Player} player
	 */
	tick(player) {
		// It is possible to sprint when flying in the air
		if(player.isSneaking && !player.isFlying) this.flag(player, undefined, true);
	}
}

export default new InvalidsprintC();
```

`scripts/checks/movement/Invalidsprint/InvalidsprintD.js`:

```js
// @ts-check
import Check from "../../Check.js";

class InvalidsprintD extends Check {
	/**
	 * @class
	 * @description Check for sprinting while using an elytra
	 */
	constructor() {
		super({
			check: "Invalidsprint",
			subcheck: "D",
			type: "Movement"
		});
	}

	/**
	 * @param {import("@minecraft/server").Player} player
	 */
	tick(player) {
		if(player.isGliding) this.flag(player, undefined, true);
	}
}

export default new InvalidsprintD();
```

`scripts/checks/movement/Invalidsprint/InvalidsprintE.js`:

```js
// @ts-check
import Check from "../../Check.js";

class InvalidsprintE extends Check {
	/**
	 * @class
	 * @description Check for sprinting while riding an entity
	 */
	constructor() {
		super({
			check: "Invalidsprint",
			subcheck: "E",
			type: "Movement"
		});
	}

	/**
	 * @param {import("@minecraft/server").Player} player
	 */
	tick(player) {
		if(!player.isUsingInputKeys() || !player.hasTag("riding")) return;

		// Make sure the player hasn't moved within the last four ticks (4 * 50)
		const now = Date.now();
		if(now - player.movedAt > 200) this.flag(player, `movedFor=${now - player.movedAt}`);
	}
}

export default new InvalidsprintE();
```

`scripts/checks/movement/Invalidsprint/InvalidsprintF.js`:

```js
// @ts-check
import Check from "../../Check.js";

const MIN_HUNGER_FOR_SPINT = 6;

class InvalidsprintF extends Check {
	/**
	 * @class
	 * @description Check for sprinting while not having sufficient hunger
	 */
	constructor() {
		super({
			check: "Invalidsprint",
			subcheck: "F",
			type: "Movement"
		});
	}

	/**
	 * @param {import("@minecraft/server").Player} player
	 */
	tick(player) {
		const hunger = player.getComponent("player.hunger");
        if(!hunger) return;

        if(hunger.currentValue <= MIN_HUNGER_FOR_SPINT) this.flag(player, `hunger=${hunger.currentValue}`, true);
	}
}

export default new InvalidsprintF();
```

`scripts/checks/registry.js`:

```js
export default {
	autoclickerA: (await import("./combat/Autoclicker/AutoclickerA.js")).default,

	fastuseA: (await import("./combat/Fastuse/FastuseA.js")).default,

	killauraA: (await import("./combat/Killaura/KillauraA.js")).default,
	killauraB: (await import("./combat/Killaura/KillauraB.js")).default,
	killauraC: (await import("./combat/Killaura/KillauraC.js")).default,

	reachA: (await import("./combat/Reach/ReachA.js")).default,
	reachC: (await import("./combat/Reach/ReachC.js")).default,

	badpackets1: (await import("./exploit/BadPackets/BadPackets1.js")).default,
	badpackets2: (await import("./exploit/BadPackets/BadPackets2.js")).default,
	badpackets3: (await import("./exploit/BadPackets/BadPackets3.js")).default,
	badpackets4: (await import("./exploit/BadPackets/BadPackets4.js")).default,
	badpackets5: (await import("./exploit/BadPackets/BadPackets5.js")).default,

	instabreakA: (await import("./exploit/Instabreak/InstabreakA.js")).default,

	namespoofA: (await import("./exploit/Namespoof/NamespoofA.js")).default,
	namespoofB: (await import("./exploit/Namespoof/NamespoofB.js")).default,

	autooffhandA: (await import("./inventory/AutoOffhand/AutoOffhandA.js")).default,

	inventorymodsA: (await import("./inventory/InventoryMods/InventoryModsA.js")).default,

	spammerA: (await import("./misc/Spammer/SpammerA.js")).default,
	spammerB: (await import("./misc/Spammer/SpammerB.js")).default,
	spammerC: (await import("./misc/Spammer/SpammerC.js")).default,
	spammerD: (await import("./misc/Spammer/SpammerD.js")).default,

	invalidsprintA: (await import("./movement/Invalidsprint/InvalidsprintA.js")).default,
	invalidsprintB: (await import("./movement/Invalidsprint/InvalidsprintB.js")).default,
	invalidsprintC: (await import("./movement/Invalidsprint/InvalidsprintC.js")).default,
	invalidsprintD: (await import("./movement/Invalidsprint/InvalidsprintD.js")).default,
	invalidsprintE: (await import("./movement/Invalidsprint/InvalidsprintE.js")).default,
	invalidsprintF: (await import("./movement/Invalidsprint/InvalidsprintF.js")).default,

	autotoolA: (await import("./world/Autotool/AutotoolA.js")).default,

	nukerA: (await import("./world/Nuker/NukerA.js")).default,

	scaffoldA: (await import("./world/Scaffold/ScaffoldA.js")).default,
	scaffoldB: (await import("./world/Scaffold/ScaffoldB.js")).default,
	scaffoldC: (await import("./world/Scaffold/ScaffoldC.js")).default,
	scaffoldD: (await import("./world/Scaffold/ScaffoldD.js")).default,
	scaffoldE: (await import("./world/Scaffold/ScaffoldE.js")).default,
};
```

`scripts/checks/world/Autotool/AutotoolA.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world, Player } from "@minecraft/server";

/**
 * Most implementations of autotool in hack clients wait for the player to start breaking a block and immedietly switch the currently held item to one that best fits with the block
 * Changing your current slot right after you start breaking a block isn't possible as a human, so to detect Autotool we can check if the player changes their current slot 90ms after they start breaking a block
 *
 * If you are breaking a block and you switch your current selected slot client should stop breaking the block with the exception of pressing the number keys on a Keyboard
 * We could check if the currently slot when you start breaking a block and finish breaking the block differs to potentially detect more Autotools
 */
class AutotoolA extends Check {
	/**
	 * @class
	 * @description Check for changing current slot right after breaking a block
	 */
	constructor() {
		super({
			check: "Autotool",
			subcheck: "A",
			type: "World"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			afterEntityHitBlock: world.afterEvents.entityHitBlock.subscribe(this.afterEntityHitBlock.bind(this)),
			afterPlayerChangeSlot: world.afterEvents.playerHotbarSelectedSlotChange.subscribe(this.afterPlayerChangeSlot.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.entityHitBlock.unsubscribe(this.callbacks.afterEntityHitBlock);
		world.afterEvents.playerHotbarSelectedSlotChange.unsubscribe(this.callbacks.afterPlayerChangeSlot);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").EntityHitBlockAfterEvent} data
	 */
	afterEntityHitBlock(data) {
		const { damagingEntity: source } = data;
		if(!(source instanceof Player)) return;

		source.startBreakTime = Date.now();
	}

	/**
	 * @param {import("@minecraft/server").PlayerHotbarSelectedSlotChangeAfterEvent} data
	 */
	afterPlayerChangeSlot(data) {
		const { player, previousSlotSelected, newSlotSelected } = data;

		// Delay between starting to break a block and switching inventory slot
		const switchDelay = Date.now() - player.startBreakTime;
		if(switchDelay < this.config.startBreakDelay) {
			this.flag(player, `oldSlot=${previousSlotSelected},newSlot=${newSlotSelected},switchDelay=${switchDelay}`);
		}
	}

}

export default new AutotoolA();
```

`scripts/checks/world/Nuker/NukerA.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class NukerA extends Check {
	/**
	 * @class
	 * @description Check for breaking too many blocks in a single tick
	 */
	constructor() {
		super({
			check: "Nuker",
			subcheck: "A",
			type: "World"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforePlayerBreakBlock: world.beforeEvents.playerBreakBlock.subscribe(this.beforePlayerBreakBlock.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.playerBreakBlock.unsubscribe(this.callbacks.beforePlayerBreakBlock);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerBreakBlockBeforeEvent} data
	 */
	beforePlayerBreakBlock(data) {
		const { player } = data;

        // player.blocksBroken gets reset in the tick event
		if(++player.blocksBroken > this.config.maxBlocks) {
			this.delayedFlag(player, `blocksBroken=${player.blocksBroken}`);
			data.cancel = true;
		}
	}

	/**
	 * @param {import("@minecraft/server").Player} player
	 */
	tick(player) {
		player.blocksBroken = 0;
	}
}

export default new NukerA();
```

`scripts/checks/world/Scaffold/ScaffoldA.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class ScaffoldA extends Check {
	/**
	 * @class
	 * @description Check for Tower-like behavior
	 */
	constructor() {
		super({
			check: "Scaffold",
			subcheck: "A",
			type: "World"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforePlayerPlaceBlock: world.beforeEvents.playerPlaceBlock.subscribe(this.beforePlayerPlaceBlock.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.playerPlaceBlock.unsubscribe(this.callbacks.beforePlayerPlaceBlock);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerPlaceBlockBeforeEvent} data
	 */
	beforePlayerPlaceBlock(data) {
		const { player, block } = data;

		const blockId = block?.typeId;
		if(
			player.isFlying ||
			player.isJumping ||
			player.isFalling ||
			player.getEffect("jump_boost") ||
			// Fence and wall blocks have a bigger Y hitbox
			blockId.includes("fence") || blockId.includes("wall") ||
			// Standing on a shulker box and opening it pushes the player upwards
			blockId.includes("_shulker_box")
		) return;

		// Get the block underneath the player
		const blockUnder = player.dimension.getBlock({x: Math.trunc(player.location.x), y: Math.trunc(player.location.y) - 1, z: Math.trunc(player.location.z)});

		// Check if the block that was placed is underneath the player
		// TODO: This check fails when either the X or Z coordinates are in the negatives, look into
		if(!blockUnder || block.location.x !== blockUnder.location.x || block.location.y !== blockUnder.location.y || block.location.z !== blockUnder.location.z) return;

		/*
		The tower module in hack clients allows a player to quickly build up
		When building up in a vanilla game, you place blocks while the decimal portion of the Y value is less than 35
		Tower modules in hack clients place blocks while the decimal portion of the Y value is greater than that value
		*/
		const yDecimal = Math.abs(player.location.y % 1);

		if(yDecimal > this.config.max_y_pos_diff) {
			this.delayedFlag(player, `yPosDiff=${yDecimal},block=${block.typeId}`, true);
			data.cancel = true;
		}
	}
}

export default new ScaffoldA();
```

`scripts/checks/world/Scaffold/ScaffoldB.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class ScaffoldB extends Check {
	/**
	 * @class
	 * @description Check for flat X/Y rotations
	 * @author 4urxra
	 */
	constructor() {
		super({
			check: "Scaffold",
			subcheck: "B",
			type: "World"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforePlayerPlaceBlock: world.beforeEvents.playerPlaceBlock.subscribe(this.beforePlayerPlaceBlock.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.playerPlaceBlock.unsubscribe(this.callbacks.beforePlayerPlaceBlock);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerPlaceBlockBeforeEvent} data
	 */
	beforePlayerPlaceBlock(data) {
		const { player } = data;

		/*
		A way to detect scaffold is to check if the player is in view of the block they placed.
		Hack client owners know this, so an option to make the player aim at the placed block was added to these clients
		The problem however is some hack clients poorly implemented this bypass by setting the player's rotation to a flat XY value, which is nearly impossible in vanilla gameplay

		This check was donated to me by the developer of Isolate Anticheat
		*/
		const rotation = player.getRotation();
		if((Number.isInteger(rotation.x) && rotation.x !== 0) || (Number.isInteger(rotation.y) && rotation.y !== 0)) {
			this.delayedFlag(player, `xRot=${rotation.x},yRot=${rotation.y}`, true);
			data.cancel = true;
		}
	}
}

export default new ScaffoldB();
```

`scripts/checks/world/Scaffold/ScaffoldC.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class ScaffoldC extends Check {
	/**
	 * @class
	 * @description Check if a player places a block under them while looking upwards
	 */
	constructor() {
		super({
			check: "Scaffold",
			subcheck: "C",
			type: "World"
		});

		if(this.config.enabled) this.enable();
	}


	enable() {
		this.callbacks = {
			// Normally we want to use before events whenever possible, however the before event doesn't return whether or not the block permutation that has been placed is solid
			afterPlayerPlaceBlock: world.afterEvents.playerPlaceBlock.subscribe(this.afterPlayerPlaceBlock.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.playerPlaceBlock.unsubscribe(this.callbacks.afterPlayerPlaceBlock);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerPlaceBlockAfterEvent} data
	 */
	afterPlayerPlaceBlock(data) {
		const { player, block } = data;
		if(player.isSwimming || !block.isSolid || player.hasTag("riding")) return;

		// Make sure the players's y location is greater than the block placed's y location.
		const rotation = player.getRotation();
		if(Math.trunc(player.location.y) > block.location.y && rotation.x < this.config.min_x_rot) {
			this.delayedFlag(player, `xRot=${rotation.x},yPosPlayer=${player.location.y},yPosBlock=${block.location.y}`);
			block.setType("air");
		}
	}
}

export default new ScaffoldC();
```

`scripts/checks/world/Scaffold/ScaffoldD.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class ScaffoldD extends Check {
	/**
	 * @class
	 * @description Check if a player places a block under the block they are standing on (Downwards scaffold)
	 */
	constructor() {
		super({
			check: "Scaffold",
			subcheck: "D",
			type: "World"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforePlayerPlaceBlock: world.beforeEvents.playerPlaceBlock.subscribe(this.beforePlayerPlaceBlock.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.playerPlaceBlock.unsubscribe(this.callbacks.beforePlayerPlaceBlock);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerPlaceBlockBeforeEvent} data
	 */
	beforePlayerPlaceBlock(data) {
		const { player, block } = data;

		// Get block underneath the player
		const blockUnder = player.dimension.getBlock({x: Math.trunc(player.location.x), y: Math.trunc(player.location.y) - 1, z: Math.trunc(player.location.z)});

		if(
			blockUnder?.isSolid &&
			Math.trunc(player.location.x) === block.location.x &&
			Math.trunc(player.location.y) - 2 === block.location.y &&
			Math.trunc(player.location.z) === block.location.z
		) {
			this.delayedFlag(player, `playerYpos=${player.location.y},blockXpos=${block.location.x},blockYpos=${block.location.y},blockZpos=${block.location.z}`);
			data.cancel = true;
		}
	}
}

export default new ScaffoldD();
```

`scripts/checks/world/Scaffold/ScaffoldE.js`:

```js
// @ts-check
import Check from "../../Check.js";
import { world } from "@minecraft/server";

class ScaffoldE extends Check {
	/**
	 * @class
	 * @description Check if a player places a block without a valid adjacent block
	 */
	constructor() {
		super({
			check: "Scaffold",
			subcheck: "E",
			type: "World"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforePlayerPlaceBlock: world.beforeEvents.playerPlaceBlock.subscribe(this.beforePlayerPlaceBlock.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.playerPlaceBlock.unsubscribe(this.callbacks.beforePlayerPlaceBlock);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerPlaceBlockBeforeEvent} data
	 */
	beforePlayerPlaceBlock(data) {
		const { player, block, permutationToPlace } = data;

		const surroundingBlocks = [
			block.above(),
			block.below(),
			block.north(),
			block.east(),
			block.south(),
			block.west()
		];

		const validBlockPlace = surroundingBlocks.some(adjacentBlock =>
			// Check if adjacent block is valid
			adjacentBlock &&
			// Check if there is a nearby block that isn't air
			!adjacentBlock.isAir &&
			// Check if there is a nearby block that isn't a liquid
			// Lilypads are the only block that can be placed onto water, so we should account for that
			(!adjacentBlock.isLiquid || permutationToPlace.type.id == "minecraft:waterlily")
		);

		if(!validBlockPlace) {
			this.delayedFlag(player, `block=${permutationToPlace.type.id}`);
			data.cancel = true;
		}
	}
}

export default new ScaffoldE();
```

`scripts/commands/handler.js`:

```js
// @ts-check
import { world, system, ChatSendBeforeEvent } from "@minecraft/server";
import config from "../data/config.js";

const prefix = config.commands.prefix ?? "!";
export const commands = {};

// A map of command aliases and the command they belong to
const aliasMap = {};

/**
 * @name registerCommand
 * @param {object} data - Command data
 * @param {string} data.name - Command name
 * @param {string} data.description - Command description
 * @param {string} [data.usage] - Command usage
 * @param {number} [data.minArgCount] - How many arguments the command expects to have
 * @param {string[]} [data.aliases] - Alternative command names that can be used
 * @param {string} data.category - The category that the command belongs to
 * @param {function} data.execute - The function that should be ran
 */
export function registerCommand(data) {
    const { name, execute, aliases = [] } = data;

    if(typeof name !== "string") throw TypeError(`data.name is type of ${typeof name}. Expected "string"`);
    if(typeof execute !== "function") throw TypeError(`data.execute is type of ${typeof execute}. Expected "function"`);

    if(commands[name]) throw Error(`Command "${name}" has already been registered`);

    if(!config.commands[name]) throw Error(`No valid config found for ${name}`);

    // To make it easy for the handler function to determine if a command name is an alias, we map all command aliases to the command they belong to
    for(const alias of aliases) {
        if(aliasMap[alias]) throw Error(`Command "${name}" has the alias "${alias}" when it's being used by another command.`);

        aliasMap[alias] = name;
    }

    commands[name] = data;
}

/**
 * @name commandHandler
 * @param {ChatSendBeforeEvent} msg - Message data
 */
export function commandHandler(msg) {
    // Validate that required parameters are defined
    if(!(msg instanceof ChatSendBeforeEvent)) throw TypeError("msg is not an instance of ChatSendBeforeEvent.");

    const { message, sender: player } = msg;

    // Check if the message starts with the Scythe prefix
    if(!message.startsWith(prefix)) return;

    // Converts '!ban "test player" 14d hacker' to ['!ban','test player','14d','hacker']
    const args = message.slice(prefix.length).match(/(".*?"|\S+)/g)?.map((match) => match.replace(/"/g, ''));
    if(!args) return;

    const command = args.shift()?.toLowerCase().trim();

    if(config.debug) console.warn(`${player.name} used the command: ${prefix}${command} ${args.join(" ")}`);

    try {
        let commandData;
        let commandName;

        if(typeof config.commands[command] === "object") {
            commandName = command;
            commandData = config.commands[command];
        } else if (aliasMap[command]) {
            commandName = aliasMap[command];
            commandData = config.commands[commandName];
        } else {
            // Command does not exist
            if(config.commands.sendInvalidCommandMsg) {
                player.sendMessage(`§r§6[§aScythe§6]§c The command "${command}" was not found. Please make sure it exists.`);
                msg.cancel = true;
            }

            return;
        }

        msg.cancel = true;

        if(!commands[commandName]) throw Error(`Command "${commandName}" was found in config.js but the command was not registered.`);

        if(commandData.requiredTags.length >= 1 && commandData.requiredTags.some((tag) => !player.hasTag(tag))) {
            player.sendMessage("§r§6[§aScythe§6]§r You need to be Scythe-Opped to use this command. To gain Scythe-op please run: /function op");
            return;
        }

        if(!commandData.enabled) {
            player.sendMessage("§r§6[§aScythe§6]§r This command has been disabled. Please contact your server administrator for assistance.");
            return;
        }

        if(args.length < commands[commandName].minArgCount) {
            player.sendMessage(`§r§6[§aScythe§6]§r Invalid command usage.\n${prefix}${command} ${commands[commandName].usage}`);
            return;
        }

        // The old msg object becomes invalid after the next tick, so if we want to be able to pass it into commands we need to recreate it
        const newMsg = {
            message: message,
            player: world.getPlayers({
                name: player.name
            })[0]
        };

        system.run(async () => {
            try {
               await commands[commandName].execute(newMsg, args, commandName);
            } catch (error) {
                reportError(error, newMsg.player, newMsg.message);
            }
        });
    } catch (error) {
        reportError(error, player, message);
    }
}

/**
 * @param {Error} error
 * @param {import("@minecraft/server").Player} player
 * @param {string} message
 */
function reportError(error, player, message) {
    console.error(`${error} ${error.stack}`);
    player.sendMessage(`§r§6[§aScythe§6]§r There was an error while trying to run this command. Please forward this message to https://discord.gg/9m9TbgJ973.\n-------------------------\nCommand: ${message}\n${error}\n${error.stack || "\n"}-------------------------`);
}
```

`scripts/commands/moderation/ban.js`:

```js
// @ts-check
import { parseTime, findPlayerByName } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "ban",
    description: "Ban the specified user from joining the world",
    usage: "<player> [time] [reason]",
    minArgCount: 1,
    aliases: ["b"],
    category: "moderation",
    execute: (message, args) => {
        const { player } = message;

        // Find the player requested
        const target = findPlayerByName(args[0]);
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

        // Make sure they do not ban themselves
        if(target.id === player.id) return player.sendMessage("§r§6[§aScythe§6]§r You cannot ban yourself.");

        // Don't allow staff to ban other staff members
        if(target.hasTag("op")) return player.sendMessage("§r§6[§aScythe§6]§r You cannot ban other staff members.");

        // Check if ban length is provided
        const time = args[1] ? parseTime(args[1]) : undefined;
        if(time) args.splice(1, 1);

        const reason = args.slice(1).join(" ");

        target.ban(player, reason, time);
    }
});
```

`scripts/commands/moderation/deop.js`:

```js
// @ts-check
import { findPlayerByName } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "deop",
    description: "Remove Scythe-OP from a specific player",
    usage: "<player>",
    minArgCount: 1,
    category: "moderation",
    execute: (message, args) => {
        const { player } = message;

        // Find the player requested
        const target = findPlayerByName(args[0]);
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

        if(!target.hasTag("op")) return player.sendMessage("§r§6[§aScythe§6]§r This player does not have scythe-op.");

        target.removeOp(player);
    }
});
```

`scripts/commands/moderation/globalmute.js`:

```js
// @ts-check
import { world } from "@minecraft/server";
import { tellAllStaff } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
	name: "globalmute",
	description: "Prevent any players from sending messages in chat. Useful incase your world gets hit by a spam attack",
	aliases: ["gm"],
    category: "moderation",
	execute: (message) => {
		toggleGlobalMute(message.player);
	}
});

export function toggleGlobalMute(initiator) {
	// @ts-expect-error
	const muteData = JSON.parse(world.getDynamicProperty("globalmute"));

	if(muteData.muted) {
		world.setDynamicProperty("globalmute", JSON.stringify({
			muted: false,
			muter: ""
		}));

		tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has disabled global mute.`);
	} else {
		world.setDynamicProperty("globalmute", JSON.stringify({
			muted: true,
			muter: initiator.name
		}));

		tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has enabled global mute. This action can be reverted by running the !globalmute command.`);
	}
}
```

`scripts/commands/moderation/kick.js`:

```js
// @ts-check
import { findPlayerByName } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "kick",
    description: "Kick out a player from the world",
    usage: "<player> [-s | --silent] [reason]",
    minArgCount: 1,
    aliases: ["k"],
    category: "moderation",
    execute: (message, args) => {
        const { player } = message;

        // Find the player requested
        const target = findPlayerByName(args[0]);
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

        // Make sure they do not kick themselves
        if(target.id === player.id) return player.sendMessage("§r§6[§aScythe§6]§r You cannot kick yourself.");

        const isSilent = args[1] === "-s" || args[1] === "--silent";
        if(isSilent) args.splice(1, 1);

        const reason = args.slice(1).join(" ");

        target.kick(player, reason, isSilent);
    }
});
```

`scripts/commands/moderation/mute.js`:

```js
// @ts-check
import { findPlayerByName } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "mute",
    description: "Remove a player's ability to send chat messages",
    usage: "<player> [reason]",
    minArgCount: 1,
    aliases: ["m"],
    category: "moderation",
    execute: (message, args) => {
        const { player } = message;

        // Find the player requested
        const target = findPlayerByName(args[0]);
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

        // Make sure they don't mute themselves
        if(target.id === player.id) return player.sendMessage("§r§6[§aScythe§6]§r You cannot mute yourself.");

        const reason = args.slice(1).join(" ");

        target.mute(player, reason);
    }
});
```

`scripts/commands/moderation/notify.js`:

```js
// @ts-check
import { tellAllStaff } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "notify",
    description: "Recieve alerts when a player gets flagged by Scythe Anticheat",
    category: "moderation",
    execute: (message) => {
        const { player } = message;

        if(player.hasTag("notify")) {
            player.removeTag("notify");

            player.sendMessage("§r§6[§aScythe§6]§r You will now no longer receive cheat notifications.");
            tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has §4disabled§r cheat notifications.`);
        } else {
            player.addTag("notify");

            player.sendMessage("§r§6[§aScythe§6]§r You will now receive cheat notifications.");
            tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has §aenabled§r cheat notifications.`);
        }
    }
});
```

`scripts/commands/moderation/op.js`:

```js
// @ts-check
import { findPlayerByName } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "op",
    description: "Give a specific player Scythe-OP",
    usage: "<player>",
    minArgCount: 1,
    aliases: ["staff"],
    category: "moderation",
    execute: (message, args) => {
        const { player } = message;

        // Find the player requested
        const target = findPlayerByName(args[0]);
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

        if(target.hasTag("op")) return player.sendMessage("§r§6[§aScythe§6]§r This player already has scythe-op.");

        target.addOp(player);
    }
});
```

`scripts/commands/moderation/resetwarns.js`:

```js
// @ts-check
import { world } from "@minecraft/server";
import { findPlayerByName, tellAllStaff } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "resetwarns",
    description: "Reset a player's violation history",
    usage: "<player>",
    minArgCount: 1,
    aliases: ["rw"],
    category: "moderation",
    execute: (message, args) => {
        const { player } = message;

        // Find the player requested
        const target = findPlayerByName(args[0]);
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

        for(const objective of world.scoreboard.getObjectives()) {
            const { id } = objective;

            if(!id.endsWith("vl")) continue;

            target.setScore(id, 0);
        }

        tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has reset ${target.name}'s warns.`);
    }
});
```

`scripts/commands/moderation/stats.js`:

```js
// @ts-check
import { world } from "@minecraft/server";
import { capitalizeFirstLetter, findPlayerByName } from "../../util.js";
import { registerCommand } from "../handler.js";

const logo = "§r§6[§aScythe§6]§r";

registerCommand({
	name: "stats",
	description: "Show all checks a player was flagged for",
	usage: "<player>",
	minArgCount: 1,
	aliases: ["info", "lookup"],
    category: "moderation",
	execute: (message, args) => {
		const { player } = message;

		// Find the player requested
		const target = findPlayerByName(args[0]);
		if(!target) return player.sendMessage(`${logo} Couldn't find that player.`);

		player.sendMessage(getStatsMsg(target));
	}
});

export function getStatsMsg(target) {
	let statsMsg = `${logo} Showing all Scythe logs for ${target.name}:\n${logo} ==== BASIC INFO ====\n${logo} Unique ID: ${target.id}\n${logo} Gamemode: ${target.getGameMode()}\n${logo} Dimension: ${capitalizeFirstLetter(target.dimension.id.replace("minecraft:", ""))}\n${logo} Position: ${Math.trunc(target.location.x)}, ${Math.trunc(target.location.y)}, ${Math.trunc(target.location.z)}\n${logo} Platform: ${target.clientSystemInfo.platformType}\n${logo} ==== VIOLATIONS ====\n`;

	let totalViolations = 0;
	for(const objective of world.scoreboard.getObjectives()) {
		const { id } = objective;

		if(!id.endsWith("vl")) continue;

		const score = objective.getScore(target);
		if(!score) continue;

		totalViolations += score;

		statsMsg += `${logo} ${capitalizeFirstLetter(id).replace("vl", "")} violations: §c${score}\n`;
	}

	statsMsg += `\n${logo} Total violations: ${totalViolations === 0 ? "§a0" : `§c${totalViolations}`}\n${logo} ==== USER FLAGS ====\n${logo} Scythe OP: ${target.hasTag("op") ? "§atrue" : "false"}\n${logo} Vanished: ${target.getDynamicProperty("vanished") ?? false}\n${logo} Frozen: ${target.getDynamicProperty("frozen") ? "§ctrue" : "§afalse"}\n${logo} Muted: ${target.isMuted() ? "§ctrue" : "§afalse"}\n${logo} Flying: ${target.isFlying}\n${logo} ==== END OF STATS ====`;

	return statsMsg;
}
```

`scripts/commands/moderation/unban.js`:

```js
// @ts-check
import { world } from "@minecraft/server";
import { tellAllStaff } from "../../util.js";
import { registerCommand } from "../handler.js";

const logo = "§r§6[§aScythe§6]§r";

registerCommand({
	name: "unban",
	description: "Manage the unban queue",
	usage: "<add | list | remove> [player name]",
	minArgCount: 1,
	aliases: ["ub","pardon"],
	category: "moderation",
	execute: (message, args) => {
		const { player } = message;

		// @ts-expect-error
		const unbanQueue = JSON.parse(world.getDynamicProperty("unbanQueue")); // Object
		switch(args[0]) {
			case "add": {
				if(!args[1]) {
					return player.sendMessage("§r§6[§aScythe§6]§r You must enter a username to unban.");
				}

				const member = args[1].replace(/\\/g, "").toLowerCase(); // String

				if(member.length > 16) {
					return player.sendMessage("§r§6[§aScythe§6]§r That player name is too long. It must be less than or equal to 16 characters long.");
				}

				if(unbanQueue[member]) {
					return player.sendMessage(`§r§6[§aScythe§6]§r ${member} is already queued for an unban.`);
				}

				if(Object.keys(unbanQueue).length > 100) {
					return player.sendMessage("§r§6[§aScythe§6]§r The unban queue has reached the limit of 100 members.");
				}

				const reason = args.slice(2).join(" ") || "No reason specified";

				unbanQueue[member] = [player.name, reason];
				world.setDynamicProperty("unbanQueue", JSON.stringify(unbanQueue));

				tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has added ${member} to the unban queue. Reason: ${reason}`);
				break;
			}

			case "list": {
				let msg = `${logo} Unban Queue:`;

				let count = 1;
				for(const playerName of Object.keys(unbanQueue)) {
					const info = unbanQueue[playerName];

					msg += `\n\n${logo} ${count}. ${playerName}\n${logo} Unbanned by: ${info[0]}\n${logo} Reason: ${info[1]}`;
					count++;
				}

				player.sendMessage(msg);
				break;
			}

			case "remove": {
				if(!args[1]) {
					return player.sendMessage("§r§6[§aScythe§6]§r You must enter a username.");
				}

				const member = args[1].replace(/\\/g, "").toLowerCase(); // String

				const reason = args.slice(2).join(" ") || "No reason specified";

				if(!unbanQueue[member]) {
					return player.sendMessage(`§r§6[§aScythe§6]§r ${member} is not in the unban queue.`);
				}

				delete unbanQueue[member];
				world.setDynamicProperty("unbanQueue", JSON.stringify(unbanQueue));

				tellAllStaff(`${logo} ${player.name} has removed ${member} from the unban queue. Reason: ${reason}`);
				break;
			}

			default:
				player.sendMessage(`§r§6[§aScythe§6]§r Unknown subcommand "${args[0]}".`);
		}
	}
});
```

`scripts/commands/moderation/unmute.js`:

```js
// @ts-check
import { findPlayerByName } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "unmute",
    description: "Unmute a player and let them speak in chat again",
    usage: "<player> [reason]",
    minArgCount: 1,
    aliases: ["um"],
    category: "moderation",
    execute: (message, args) => {
        const { player } = message;

        // Find the player requested
        const target = findPlayerByName(args[0]);
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

        const reason = args.slice(1).join(" ");

        target.unmute(player, reason);
    }
});
```

`scripts/commands/other/credits.js`:

```js
// @ts-check
import { registerCommand } from "../handler.js";

registerCommand({
    name: "credits",
    description: "Show credits for the anticheat",
    category: "other",
    execute: (message) => {
        message.player.runCommand("function credits");
    }
});
```

`scripts/commands/other/help.js`:

```js
// @ts-check
import config from "../../data/config.js";
import { capitalizeFirstLetter } from "../../util.js";
import { registerCommand, commands } from "../handler.js";

const prefix = config.commands.prefix;

const commandData = {
	filledCache: false,
	moderation: [],
	settings: [],
	utility: [],
	other: []
};

const friendlyCategoryNames = {
	moderation: "Moderation Commands",
	settings: "Settings Commands",
	utility: "Tools and Utilities",
	other: "Other Commands"
};

registerCommand({
	name: "help",
	description: "Shows this help page",
	usage: "[commandName]",
	aliases: ["support", "commands", "man"],
    category: "other",
	execute: (message, args) => {
		const { player } = message;

		// Looping over every single command every time is obviously bad for performance, so we cache all the generated command data
		if(!commandData.filledCache) generateCommandData();

		// If no command was passed in then send the user all avaliable commands
		if(!args.length) return player.sendMessage(getHelpMessage());

		// Give help for a command
		const name = args[0].toLowerCase();
		if(!Object.hasOwn(commands, name)) return player.sendMessage(`§r§6[§aScythe§6]§r The command '${name}' was not found.`);

		const { description, usage, minArgCount, category, aliases } = commands[name];

		let commandInfo = `§r§6[§aScythe§6]§r Info for command: ${name}\n§r§6[§aScythe§6]§r Description: ${description}\n`;

		if(usage) commandInfo += `§r§6[§aScythe§6]§r Usage: ${prefix}${name} ${usage}\n`;
		if(minArgCount) commandInfo += `§r§6[§aScythe§6]§r Minimium Argument Count: ${minArgCount}\n`;
		if(aliases) commandInfo += `§r§6[§aScythe§6]§r Aliases: ${aliases.join(", ")}\n`;

		commandInfo += `§r§6[§aScythe§6]§r Category: ${capitalizeFirstLetter(category)}\n§r§6[§aScythe§6]§r Enabled: ${config.commands[name].enabled ? "§atrue" : "§4false"}`;

		player.sendMessage(commandInfo);
	}
});

function generateCommandData() {
	for(const command of Object.values(commands)) {
		if(!commandData[command.category]) throw Error(`Unknown command category "${command.category}".`);

		commandData[command.category].push(command);
	}

	commandData.filledCache = true;
}

function getHelpMessage() {
	let message = "§l§aScythe Anticheat Command Help\n";

	// Loop through all command categories
	for(const category of Object.keys(friendlyCategoryNames)) {
		message += `\n§l§a${friendlyCategoryNames[category]}\n`;

		// Loop through all commands that exist for the category
		for(const command of commandData[category]) {
			message += `§r§3${prefix}${command.name} ${command.usage ?? ""}§r - ${command.description}\n`;
		}
	}

	message += "\nNeed extra help? Ask your question in the support server: https://discord.gg/9m9TbgJ973.\n";

	return message;
}
```

`scripts/commands/other/report.js`:

```js
// @ts-check
import { findPlayerByName, tellAllStaff } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "report",
    description: "Send a player report to all currently online staff members",
    usage: "<player> <reason>",
    minArgCount: 2,
    category: "other",
    execute: (message, args) => {
        const { player } = message;

        // Find the player requested
        const target = findPlayerByName(args[0]);
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

        // Make sure they don't report themselves
        if(target.id === player.id) return player.sendMessage("§r§6[§aScythe§6]§r You cannot report yourself.");

        // Prevent report spam
        if(player.reports.has(target.id)) return player.sendMessage("§r§6[§aScythe§6]§r You have already reported this player.");
        player.reports.add(target.id);

        const reason = args.slice(1).join(" ");
        if(reason.length < 5) return player.sendMessage("§r§6[§aScythe§6]§r The reason for your report must be at least 5 characters long.");

        player.sendMessage(`§r§6[§aScythe§6]§r You have reported ${target.name} for ${reason}.`);

        tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has reported ${target.name} for ${reason}`);
    }
});
```

`scripts/commands/other/version.js`:

```js
// @ts-check
import config from "../../data/config.js";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "version",
    description: "Get the current version of Scythe",
    aliases: ["ver","about"],
    category: "other",
    execute: (message) => {
        const { player } = message;

        player.runCommand("function version");
        player.sendMessage(`§r§6[§aScythe§6]§r Config revision: ${config.version}`);
    }
});
```

`scripts/commands/settings/module.js`:

```js
// @ts-check
import config from "../../data/config.js";
import { world } from "@minecraft/server";
import { registerCommand } from "../handler.js";

// These two commands are functionally identical so they have been combined into one file
registerCommand({
	name: "module",
	description: "Change the data of Scythe modules",
	usage: "<module name> <setting> [value]",
	category: "settings",
	execute: execute
});

registerCommand({
	name: "misc_module",
	description: "Change the data of optional Scythe modules",
	usage: "<module name> <setting> [value]",
	aliases: ["mm"],
	category: "settings",
	execute: execute
});

function execute(message, args, commandName) {
	const { player } = message;
	const [ module, name ] = args;
	const value = args.slice(2).join(" ");

	const category = commandName === "module" ? "modules" : "misc_modules";

	if(!module) return player.sendMessage(`§r§6[§aScythe§6]§r Module list: ${Object.keys(config[category]).join(", ")}`);
	if(!Object.hasOwn(config[category], module)) return player.sendMessage(`§r§6[§aScythe§6]§r No such module as ${module} exists. Please select a module from this list: ${Object.keys(config[category]).join(", ")}`);

	const moduleData = config[category][module];

	if(!name) return player.sendMessage(`§r§6[§aScythe§6]§r ${module}'s configuration data:\n${JSON.stringify(moduleData, null, 2)}`);

	if(!Object.hasOwn(moduleData, name)) return player.sendMessage(`§r§6[§aScythe§6]§r ${module} does not have a property called ${name}. Please select a property from this list: ${Object.keys(moduleData).join(", ")}`);

	if(value === "") return player.sendMessage(`§r§6[§aScythe§6]§r You need enter a value for this setting.`);

	let newValue;
	switch(moduleData[name]?.constructor.name) {
		case "Boolean":
			newValue = value === "true";
			break;

		case "Number":
			newValue = Number(value);
			break;

		case "String":
			newValue = value;
			break;

		case "Array":
			newValue = JSON.parse(value.replace(/'/g, '"'));
			break;

		default:
			throw Error(`Unimplemented case ${moduleData[name]?.constructor.name}`);
	}

	moduleData[name] = newValue;

	// Save config
	world.setDynamicProperty("config", JSON.stringify(config));

	player.sendMessage(`§r§6[§aScythe§6]§r ${module}'s data has been updated. New data:\n${JSON.stringify(moduleData, null, 2)}`);
}
```

`scripts/commands/settings/modules.js`:

```js
// @ts-check
import { registerCommand } from "../handler.js";
import config from "../../data/config.js";

const enabled = "§8[§aENABLED§8]";
const disabled = "§8[§4DISABLED§8]";

registerCommand({
	name: "modules",
    description: "Shows all modules and if they are enabled or not",
    category: "settings",
	execute: (message) => {
		let msg = "==== MODULES ====\n";

		for(const module of Object.keys(config.modules)) {
			msg += `§r§6[§aScythe§6]§r ${module} ${config.modules[module].enabled ? enabled : disabled}\n`;
		}

		msg += "§r==== MISC MODULES =====\n";

		for(const misc_module of Object.keys(config.misc_modules)) {
			msg += `§r§6[§aScythe§6]§r ${misc_module} ${config.misc_modules[misc_module].enabled ? enabled : disabled}\n`;
		}

		message.player.sendMessage(msg);
	}
});
```

`scripts/commands/settings/resetconfig.js`:

```js
// @ts-check
import { world } from "@minecraft/server";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "resetconfig",
    description: "Reset the saved config and instead rely on the config.js file",
    category: "settings",
    execute: (message) => {
        world.setDynamicProperty("config", undefined);

        message.player.sendMessage("§r§6[§aScythe§6]§r The scythe config has been reset to defaults. Run '/reload' to apply the changes.");
    }
});
```

`scripts/commands/utility/cloneinv.js`:

```js
import { EquipmentSlot } from "@minecraft/server";
import { findPlayerByName, tellAllStaff } from "../../util.js";
import { registerCommand } from "../handler.js";

/*
The clone inventory command was originally added as a way to debug anti-32k bypasses
If a player was able to get a 32k item that was able to bypass Scythe, a moderator could copy the player's inventory (which includes NBT data) and investigate how exactly the bypass worked

Now this command remains as a utility feature as a more indepth version of the inventory see command
*/
registerCommand({
	name: "cloneinv",
    description: "Copy all the items in a player's inventory to your inventory",
	usage: "<player>",
	minArgCount: 1,
	aliases: ["invclone", "invc"],
    category: "utility",
	execute: (message, args) => {
		const { player } = message;

		// Find the player requested
		const target = findPlayerByName(args[0]);

		if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

		const playerInv = player.getComponent("inventory").container;
		const playerArmor = player.getComponent("equippable");

		const targetInv = target.getComponent("inventory").container;
		const targetArmor = player.getComponent("equippable");

		for(const equipment of Object.keys(EquipmentSlot)) {
			playerArmor.setEquipment(equipment, targetArmor.getEquipment(equipment));
		}

		for(let i = 0; i < targetInv.size; i++) {
			playerInv.setItem(i, targetInv.getItem(i));
		}

		player.sendMessage(`§r§6[§aScythe§6]§r You have cloned ${target.name}'s inventory.`);

		tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has cloned ${target.name}'s inventory.`);
	}
});
```

`scripts/commands/utility/ecwipe.js`:

```js
import { findPlayerByName } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "ecwipe",
    description: "Remove all items in a player's ender chest",
    usage: "<player>",
    minArgCount: 1,
    aliases: ["ecw", "clearec"],
    category: "utility",
    execute: (message, args) => {
        const { player } = message;

        // Find the player requested
        const target = findPlayerByName(args[0]);
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

        target.wipeEnderchest(player);
    }
});
```

`scripts/commands/utility/fly.js`:

```js
// @ts-check
import { GameMode } from "@minecraft/server";
import { findPlayerByName } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
	name: "fly",
	description: "Toggle the ability to fly in survival or adventure mode",
	usage: "[player]",
	category: "utility",
	execute: (message, args) => {
		const { player } = message;

		// Find the player requested
		const target = args.length ? findPlayerByName(args[0]) : player;
		if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

		if(player.getGameMode() === GameMode.Creative) return player.sendMessage("§r§6[§aScythe§6]§r No need! This player is in creative which allows flying by default.");

		target.hasTag("flying") ? target.disableFly(player) : target.enableFly(player);
	}
});
```

`scripts/commands/utility/freeze.js`:

```js
// @ts-check
import { findPlayerByName } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
	name: "freeze",
	description: "Toggle a player's ability to move",
	usage: "<player>",
	minArgCount: 1,
	category: "utility",
	execute: (message, args) => {
		const { player } = message;

		// Find the player requested
		const target = findPlayerByName(args[0]);
		if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

		target.getDynamicProperty("frozen") ? target.unfreeze(player) : target.freeze(player);
	}
});

```

`scripts/commands/utility/fullreport.js`:

```js
import { world } from "@minecraft/server";
import { registerCommand } from "../handler.js";
import { getStatsMsg } from "../moderation/stats.js";

registerCommand({
    name: "fullreport",
    description: "Shows the violation history of all players online in the world",
    aliases: ["fr"],
    category: "utility",
    execute: (message) => {
        const players = world.getPlayers();
        for(let i = 0; i < players.length; i++) {
            message.player.sendMessage(getStatsMsg(players[i]));
        }
    }
});
```

`scripts/commands/utility/gma.js`:

```js
import { GameMode } from "@minecraft/server";
import { findPlayerByName, tellAllStaff } from "../../util.js";
import { registerCommand } from "../handler.js";
import config from "../../data/config.js";

registerCommand({
    name: "gma",
    description: "Change your or another player's gamemode to adventure",
	usage: "[player]",
    category: "utility",
    execute: (message, args) => {
        const { player } = message;

		if(args[0] && !config.commands.gma.canChangeOtherPeopleGamemode) player.sendMessage("§r§6[§aScythe§6]§r You cannot change other people's gamemodes.");

        // Find the player requested
        const target = args.length ? findPlayerByName(args[0]) : player;
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

		target.setGameMode(GameMode.Adventure);

		tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has changed ${player.id === target.id ? "their" : `${target.name}'s`} gamemode to adventure.`);
    }
});
```

`scripts/commands/utility/gmc.js`:

```js
import { GameMode } from "@minecraft/server";
import { findPlayerByName, tellAllStaff } from "../../util.js";
import { registerCommand } from "../handler.js";
import config from "../../data/config.js";

registerCommand({
    name: "gmc",
    description: "Change your or another player's gamemode to creative",
	usage: "[player]",
    category: "utility",
    execute: (message, args) => {
        const { player } = message;

		if(args[0] && !config.commands.gmc.canChangeOtherPeopleGamemode) player.sendMessage("§r§6[§aScythe§6]§r You cannot change other people's gamemodes.");

        // Find the player requested
        const target = args.length ? findPlayerByName(args[0]) : player;
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

		target.setGameMode(GameMode.Creative);

		tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has changed ${player.id === target.id ? "their" : `${target.name}'s`} gamemode to creative.`);
    }
});
```

`scripts/commands/utility/gms.js`:

```js
import { GameMode } from "@minecraft/server";
import { findPlayerByName, tellAllStaff } from "../../util.js";
import { registerCommand } from "../handler.js";
import config from "../../data/config.js";

registerCommand({
    name: "gms",
    description: "Change your or another player's gamemode to survival",
	usage: "[player]",
    category: "utility",
    execute: (message, args) => {
        const { player } = message;

		if(args[0] && !config.commands.gms.canChangeOtherPeopleGamemode) player.sendMessage("§r§6[§aScythe§6]§r You cannot change other people's gamemodes.");

        // Find the player requested
        const target = args.length ? findPlayerByName(args[0]) : player;
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

		target.setGameMode(GameMode.Survival);

		tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has changed ${player.id === target.id ? "their" : `${target.name}'s`} gamemode to survival.`);
    }
});
```

`scripts/commands/utility/gmsp.js`:

```js
import { GameMode } from "@minecraft/server";
import { findPlayerByName, tellAllStaff } from "../../util.js";
import { registerCommand } from "../handler.js";
import config from "../../data/config.js";

registerCommand({
    name: "gmsp",
    description: "Change your or another player's gamemode to spectator",
	usage: "[player]",
    category: "utility",
    execute: (message, args) => {
        const { player } = message;

		if(args[0] && !config.commands.gmsp.canChangeOtherPeopleGamemode) player.sendMessage("§r§6[§aScythe§6]§r You cannot change other people's gamemodes.");

        // Find the player requested
        const target = args.length ? findPlayerByName(args[0]) : player;
        if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

		target.setGameMode(GameMode.Spectator);

		tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has changed ${player.id === target.id ? "their" : `${target.name}'s`} gamemode to spectator.`);
    }
});
```

`scripts/commands/utility/invsee.js`:

```js
// @ts-check
import config from "../../data/config.js";

import { capitalizeFirstLetter, findPlayerByName } from "../../util.js";
import { registerCommand } from "../handler.js";

const equipmentList = {
	"Head": "Helmet",
	"Chest": "Chestplate",
	"Legs": "Leggings",
	"Feet": "Boots",
	"Offhand": "Offhand"
};

registerCommand({
	name: "invsee",
    description: "Shows the inventory of any player",
	usage: "<player>",
	minArgCount: 1,
	aliases: ["inv"],
    category: "utility",
	execute: (message, args) => {
		const { player } = message;

		// Find the player requested
		const target = findPlayerByName(args[0]);
		if(!target) return player.sendMessage("§r§6[§aScythe§6]§r Couldn't find that player.");

		player.sendMessage(getInvseeMsg(target));
	}
});

/**
 * @name getInvseeMsg
 * @param {import("@minecraft/server").Player} target
 * @returns {string} msg - A list of all the items in the players inventory
 */
export function getInvseeMsg(target) {
	const container = target.getComponent("inventory")?.container;

	let inventory = `§r§6[§aScythe§6]§r ${target.name}'s inventory:\n\n`;

	// This function loops through every enchantment on the item and then adds it to the inventory string. It is used if show_enchantments is enabled in the config
	const loopEnchants = (allEnchantments = []) => {
		for(const enchantment of allEnchantments) {
			const id = enchantment.type.id;
			const level = enchantment.level;

			const enchantmentName = capitalizeFirstLetter(id);

			inventory += `    | ${enchantmentName} ${level}\n`;
		}
	};

	// Loop through every armor slot
	let foundItem = false;
	if(config.commands.invsee.show_armor) {
		const armor = target.getComponent("equippable");

		for(const equipment of Object.keys(equipmentList)) {
			// @ts-expect-error
			const item = armor?.getEquipment(equipment);
			if(!item) continue;

			foundItem = true;

			inventory += `§r§6[§aScythe§6]§r ${equipmentList[equipment]}: ${item.typeId} x${item.amount}\n`;

			if(config.commands.invsee.show_enchantments) {
				loopEnchants(item.getComponent("enchantable")?.getEnchantments());
			}
		}

		if(foundItem) inventory += `\n`;
	}

	// Loop through every item in the player's inventory
	for(let i = 0; i < 36; i++) {
		if(!container) break;

		const item = container.getItem(i);
		if(!item) continue;

		foundItem = true;

		inventory += `§r§6[§aScythe§6]§r Slot ${i}: ${item.typeId} x${item.amount}\n`;

		if(config.commands.invsee.show_enchantments) {
			loopEnchants(item.getComponent("enchantable")?.getEnchantments());
		}
	}

	if(!foundItem) return `§r§6[§aScythe§6]§r ${target.name}'s inventory is empty.`;

	return inventory.replace(/\n+$/, "");
}
```

`scripts/commands/utility/tag.js`:

```js
import { findPlayerByName, tellAllStaff } from "../../util.js";
import { registerCommand } from "../handler.js";
import config from "../../data/config.js";

registerCommand({
    name: "tag",
    description: "Edit the rank that is shown beside the player's name in chat messages",
    usage: "[player] <tag | reset>",
    minArgCount: 1,
    aliases: ["rank"],
    category: "utility",
    execute: (message, args) => {
        const { player } = message;

        // Find the player requested
        let target = findPlayerByName(args[0]);

        if(!target) target = player;
            else args.shift();

        if(!args[0]) return player.sendMessage("§r§6[§aScythe§6]§r You need to provide a tag to add.");

        // Reset user nametag
        if(args[0] === "reset") {
            // Remove old tags
            target.setDynamicProperty("tag", undefined);

            target.nameTag = target.name;
            return tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has reset ${target.name}'s nametag.`);
        }

        const tag = args.join(" ");
        const { mainColor, borderColor, playerNameColor } = config.commands.tag;

        const nametag = `${borderColor}[§r${mainColor}${tag}${borderColor}]§r ${playerNameColor}${target.name}`;

        target.nameTag = nametag;

        // Apply new tag
        target.setDynamicProperty("tag", tag);

        tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has changed ${target.name}'s nametag to ${nametag}.`);
    }
});
```

`scripts/commands/utility/ui.js`:

```js
// @ts-check
import { ItemStack, EnchantmentType } from "@minecraft/server";
import config from "../../data/config.js";
import { registerCommand } from "../handler.js";

registerCommand({
	name: "ui",
	description: "Access the Scythe UI for world and player management",
	aliases: ["gui"],
	category: "utility",
	execute: (message) => {
		const { player } = message;

		// Get the player's inventory component
		const container = player.getComponent("inventory").container;

		// Check if the player's inventory is full
		if(container.emptySlotsCount === 0) {
			return player.sendMessage("§r§6[§aScythe§6]§r Your inventory is full! Try removing some items and try again.");
		}

		// Make sure they don't have the UI item in their current slot
		const currentItem = container.getItem(player.selectedSlotIndex);
		if(currentItem?.typeId === config.commands.ui.ui_item && currentItem?.nameTag === config.commands.ui.ui_item_name) {
			return player.sendMessage("§r§6[§aScythe§6]§r You already have the UI item in your inventory.");
		}

		// Create the item that opens the UI
		const item = new ItemStack(config.commands.ui.ui_item, 1);
		item.nameTag = config.commands.ui.ui_item_name;

		// Enchant the item with Unbreaking 3
		item.getComponent("enchantable")?.addEnchantment({ type: new EnchantmentType("unbreaking"), level: 3 });

		container.addItem(item);

		player.sendMessage("§r§6[§aScythe§6]§r The UI item has been added to your inventory.");
	}
});
```

`scripts/commands/utility/vanish.js`:

```js
import { GameMode } from "@minecraft/server";
import { tellAllStaff } from "../../util.js";
import { registerCommand } from "../handler.js";

registerCommand({
    name: "vanish",
    description: "Make yourself invisible to investigate players",
    aliases: ["v"],
    category: "utility",
    execute: (message) => {
        const { player } = message;

        if(player.getDynamicProperty("vanished")) {
            player.setDynamicProperty("vanished", false);

            player.setGameMode(player.getDynamicProperty("previousGamemode"));
            player.setDynamicProperty("previousGamemode", undefined);

            player.sendMessage("§r§6[§aScythe§6]§r You are now no longer vanished.");
            tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} is no longer vanished.`);
        } else {
            player.setDynamicProperty("vanished", true);

            // Store the player's previous gamemode so we can return them back when they exit out of vanish
            player.setDynamicProperty("previousGamemode", player.getGameMode());
            player.setGameMode(GameMode.Spectator);

            player.sendMessage("§r§6[§aScythe§6]§r You are now vanished.");
            tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} is now vanished.`);
        }
    }
});
```

`scripts/data/config.js`:

```js
export default
{
	/*
	This value should not be changed unless you know what you are doing.
	It is used to make Scythe be able to work with older versions of the config

	Internally we still call it the config version, however it should be referred to as the config revision.
	*/
	"version": "27",
	"debug": true,
	"flagWhitelist": [],
	/*
	By enabling this toggle, you can prevent anybody with Scythe-Op from getting flagged from the anticheat
	Although this may be a useful feature, it can be exploited by hackers to completely disable the anticheat for themselves.
	It is a much better idea to add "exclude_scythe_op" for each individual check instead of globally
	*/
	"disableFlagsFromScytheOp": false,
	"logAlertsToConsole": true,
	"commands": {
		"prefix": "!",
		"sendInvalidCommandMsg": false,
		"ban": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"help": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"op": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"deop": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"credits": {
			"enabled": true,
			"requiredTags": []
		},
		"misc_module": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"module": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"modules": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"ecwipe": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"freeze": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"stats": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"fullreport": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"kick": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"mute": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"unmute": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"fly": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"invsee": {
			"enabled": true,
			"show_enchantments": true,
			"show_armor": true,
			"requiredTags": ["op"]
		},
		"cloneinv": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"notify": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"tag": {
			"enabled": true,
			// The color of the tag name, inside the brackets
			// Players can still choose their own tag color by adding a color code in the !tag command
			"mainColor": "§a",
			// The color of the tag name, aka the brackets
			"borderColor": "§8",
			// Color of player name. Leave blank for none.
			"playerNameColor": "§r",
			// If players should have a default tag when they join. Leave blank to disable this.
			"defaultTag": "",
			"requiredTags": ["op"]
		},
		"vanish": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"report": {
			"enabled": true,
			"requiredTags": []
		},
		"unban": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"ui": {
			"enabled": true,
			"ui_item_name": "§r§l§aRight click to Open the UI",
			"ui_item": "minecraft:wooden_axe",
			// Players without this tag will not be able to use the Scythe UI
			"requiredTags": ["op"]
		},
		"resetwarns": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"version": {
			"enabled": true,
			"requiredTags": ["op"]
		},
		"globalmute": {
			"enabled": true,
			// If this is enabled then all players can see who disabled the chat
			"showModeratorName": false,
			"requiredTags": ["op"]
		},
		"gma": {
			"enabled": true,
			"canChangeOtherPeopleGamemode": true,
			"requiredTags": ["op"]
		},
		"gmc": {
			"enabled": true,
			"canChangeOtherPeopleGamemode": true,
			"requiredTags": ["op"]
		},
		"gms": {
			"enabled": true,
			"canChangeOtherPeopleGamemode": true,
			"requiredTags": ["op"]
		},
		"gmsp": {
			"enabled": true,
			"canChangeOtherPeopleGamemode": true,
			"requiredTags": ["op"]
		},
		"resetconfig": {
			"enabled": true,
			"requiredTags": ["op"]
		}
	},
	"modules": {
		"exampleA": {
			// If the check should be enabled or not.
			"enabled": true,
			// If players with scythe-op can bypass this check (Optional)
			"exclude_scythe_op": false,
			// The punishment. Can either be "none", "mute", "kick", "ban" or "freeze"
			"punishment": "none",
			// PunishmentLength can be either a length ('7d', '2w 1h') or how long the ban should be in milliseconds
			// To permamently ban a user the string should be empty.
			"punishmentLength": "",
			// How much violations the player must first have to start punishing them
			"minVlbeforePunishment": 1
		},
		"autoclickerA": {
			"enabled": true,
			"maxCPS": 12,
			"checkCPSAfter": 1000,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"autooffhandA": {
			"enabled": true,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"autotoolA": {
			"enabled": true,
			"startBreakDelay": 90,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"badpackets1": {
			"enabled": true,
			"punishment": "ban",
			"punishmentLength": "",
			"minVlbeforePunishment": 1
		},
		"badpackets2": {
			"enabled": true,
			"punishment": "ban",
			"punishmentLength": "",
			"minVlbeforePunishment": 1
		},
		"badpackets3": {
			"enabled": true,
			"punishment": "ban",
			"punishmentLength": "",
			"minVlbeforePunishment": 1
		},
		"badpackets4": {
			"enabled": true,
			"punishment": "ban",
			"punishmentLength": "",
			"minVlbeforePunishment": 1
		},
		"badpackets5": {
			"enabled": true,
			"exclude_scythe_op": true,
			"punishment": "ban",
			"punishmentLength": "",
			"minVlbeforePunishment": 1
		},
		"fastuseA": {
			"enabled": true,
			"min_use_delay": 10,
			"max_use_delay": 130,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"flyA": {
			"enabled": false,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		/*
		"flyB": {
			"enabled": true,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		*/
		// This should only be enabled if your realm/server is being targetted by advanced hacking groups
		"instabreakA": {
			"enabled": false,
			"unbreakable_blocks": [
				"minecraft:bedrock",
				"minecraft:end_portal",
				"minecraft:end_portal_gateway",
				"minecraft:barrier",
				"minecraft:command_block",
				"minecraft:chain_command_block",
				"minecraft:repeating_command_block",
				"minecraft:end_gateway",
				"minecraft:light_block"
			],
			"punishment": "kick",
			"minVlbeforePunishment": 1
		},
		"invalidsprintA": {
			"enabled": true,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"invalidsprintB": {
			"enabled": false,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"invalidsprintC": {
			"enabled": true,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"invalidsprintD": {
			"enabled": false,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"invalidsprintE": {
			"enabled": true,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"invalidsprintF": {
			"enabled": true,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"inventorymodsA": {
			"enabled": false,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"killauraA": {
			"enabled": true,
			// Minimum time the player should be using the item for a flag
			"min_item_use_time": 150,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"killauraB": {
			"enabled": true,
			// Wait two seconds before checking if the player has swinged
			"wait_ticks": 40,
			"max_swing_delay": 5000,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"killauraC": {
			"enabled": true,
			// It is only possible to attack one entity per tick, but incase of lag someone may be able to attack two entites at once.
			"entities": 3,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"namespoofA": {
			"enabled": true,
			"minNameLength": 3,
			"maxNameLength": 16,
			"punishment": "kick",
			"minVlbeforePunishment": 1
		},
		"namespoofB": {
			"enabled": true,
			// This should be a string
			"regex": "/[^A-Za-z0-9_\\-() ]/",
			"punishment": "kick",
			"minVlbeforePunishment": 1
		},
		"nukerA": {
			"enabled": false,
			"maxBlocks": 3,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"reachA": {
			"enabled": true,
			"reach": 6,
			"excluded_items": [
				"minecraft:trident",
				"minecraft:mace"
			],
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"reachB": {
			"enabled": false,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"reachC": {
			"enabled": true,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"spammerA": {
			"enabled": true,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"spammerB": {
			"enabled": true,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"spammerC": {
			"enabled": true,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"spammerD": {
			"enabled": true,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"scaffoldA": {
			"enabled": true,
			"max_y_pos_diff": 0.35,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"scaffoldB": {
			"enabled": true,
			"punishment": "none",
			"minVlbeforePunishment": 0
		},
		"scaffoldC": {
			"enabled": true,
			// Checks if the player's x rotation is higher than this
			"min_x_rot": 5,
			"punishment": "none",
			"minVLbeforePunishment": 0
		},
		"scaffoldD": {
			"enabled": true,
			"punishment": "none",
			"minVLbeforePunishment": 0,
		},
		"scaffoldE": {
			"enabled": true,
			"punishment": "none",
			"minVLbeforePunishment": 0,
		}
	},
	"misc_modules": {
		"antiArmorStandCluster": {
			"enabled": true,
			"radius": 5,
			"max_armor_stand_count": 50
		},
		"antiSpam": {
			"enabled": false,
			// How fast players can send messages in milliseconds
			"messageRatelimit": 500
		},
		"chatExtensions": {
			"enabled": true,
			// If tags from the !tag command should be handled
			// Disable this if you have conflicts with other addons that modify Player#nameTag
			"customTags": true,
			// Remove non-ASCII characters from chat messages to prevent certain exploits
			// Leave this disabled if your server speaks in an language other than English
			"filterUnicodeChat": false
		},
		"oreAlerts": {
			"enabled": false,
			"blocks": [
				"minecraft:diamond_ore",
				"minecraft:deepslate_diamond_ore",
				"minecraft:ancient_debris"
			]
		},
		"welcomeMessage": {
			"enabled": false,
			// You can use [@player] to mention the player name
			"message": "Welcome [@player] to our server!"
		},
		"worldborder": {
			"enabled": false,
			"max_x": 10000,
			"max_z": 10000
		}
	}
};

```

`scripts/extensions/Entity.js`:

```js
// @ts-check
// Add new methods to Scripting API classes
import { Entity, world } from "@minecraft/server";

/**
 * @remarks Returns the closest player to the calling entity
 * @returns {import("@minecraft/server").Player} score - The player
 */
Entity.prototype.getClosestPlayer = function() {
    const nearestPlayer = this.dimension.getPlayers({
        closest: 1,
        location: this.location
    })[0];

    return nearestPlayer;
};

/**
 * @remarks Gets the scoreboard objective value for a player
 * @param {string} objective - The name of the scoreboard objective
 * @param {number} [defaultValue] - Default value to return if unable to get scoreboard score
 * @returns {number} score - The scoreboard objective value
 */
Entity.prototype.getScore = function(objective, defaultValue = 0) {
    try {
       return world.scoreboard.getObjective(objective)?.getScore(this) ?? defaultValue;
    } catch {
        return defaultValue;
    }
};

/**
 * @remarks Sets the scoreboard objective value for a player
 * @param {string} objectiveName - The scoreboard objective
 * @param {number} value - The new value of the scoreboard objective
 */
Entity.prototype.setScore = function(objectiveName, value) {
    const objective = world.scoreboard.getObjective(objectiveName);
    if(!objective) throw Error(`Objective "${objectiveName}" does not exist`);

    objective.setScore(this, value);
};
```

`scripts/extensions/Player.js`:

```js
// @ts-check
// Add new methods to Scripting API classes
import { Player, InputPermissionCategory, GameMode, InputMode } from "@minecraft/server";
import { tellAllStaff } from "../util.js";
import { banMessage } from "../assets/ban.js";

// In older versions of Scythe, we would only add these properties if the necessary module was enabled in the playerJoin event
// However this would bring along a problem where if a world is loaded without the module enabled,
// and an admin were to enable the module, Scythe would break due to the required properties not being initialized
Player.prototype.blocksBroken = 0;
Player.prototype.firstAttack = 0;
Player.prototype.clicks = 0;
Player.prototype.lastThrow = 0;
Player.prototype.lastLeftClick = Date.now();
Player.prototype.entitiesHit = new Set();
Player.prototype.lastMessageSent = 0;
Player.prototype.reports = new Set();
Player.prototype.lastSprintState = false;
Player.prototype.isUsingItem = false;

/**
 * @remarks Add Scythe-OP status to a player
 * @param {Player} [initiator] - The player that initiated the request
 */
Player.prototype.addOp = function(initiator) {
    if(initiator) tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has given ${this.name} scythe-op status.`);

    this.addTag("op");
    this.sendMessage("§r§6[§aScythe§6]§r §7You are now scythe-op.");
};

/**
 * @remarks Remove Scythe-OP status from a player
 * @param {Player} [initiator] - The player that initiated the request
 */
Player.prototype.removeOp = function(initiator) {
    if(initiator) tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has removed ${this.name}'s scythe-op status.`);

    this.removeTag("op");
};

/**
 * @remarks Ban a player from the world
 * @param {Player | null} [initiator] - The player that initiated the ban
 * @param {String} [reason] - The reason for the ban
 * @param {Number | null} [time] - How long in milliseconds the player should be banned for
 */
Player.prototype.ban = function(initiator, reason = "No reason specified", time = null) {
    if(initiator) tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has banned ${this.name} for ${reason}`);

    this.setDynamicProperty("banInfo", JSON.stringify({
        by: initiator ? initiator.name : "Scythe Anticheat",
        reason,
        time: typeof time === "number" ? Date.now() + time : null
    }));

    // Show the ban message to the player
    banMessage(this);
};

/**
 * @remarks Give the player the mayfly ability so they can fly outside of Creative
 * @param {Player} [initiator] - The player that initiated the request
 */
Player.prototype.enableFly = function(initiator) {
    if(initiator) tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has given ${initiator.id === this.id ? "themselves" : `${this.name}'s`} fly mode.`);

    this.addTag("flying");

	this.runCommand("ability @s mayfly true");
	this.sendMessage("§r§6[§aScythe§6]§r You are now in fly mode.");
};

/**
 * @remarks Remove the mayflay ability from the player
 * @param {Player} [initiator] - The player that initiated the request
 */
Player.prototype.disableFly = function(initiator) {
    if(initiator) tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has removed ${initiator.id === this.id ? "their" : `${this.name}'s`} fly mode.`);

	this.removeTag("flying");

	this.runCommand("ability @s mayfly false");
	this.sendMessage("§r§6[§aScythe§6]§r You are now no longer in fly mode.");
};

/**
 * @remarks Return all the information about the player for debugging purposes
 * @returns {any} - Debug data
 */
Player.prototype.getDebugData = function() {
    const playerData = {
        name: this.name,
        dimension: this.dimension.id,
        location: this.location,
        headLocation: this.getHeadLocation(),
        velocity: this.getVelocity(),
        rotation: this.getRotation(),
        tags: this.getTags(),
        heldItem: this.heldItem,
        selectedSlotIndex: this.selectedSlotIndex,
        platform: this.clientSystemInfo.platformType,
        scythe: {
            blocksBroken: this.blocksBroken,
            entitiesHit: this.entitiesHit,
            clicks: this.clicks,
            firstAttack: this.firstAttack,
            startBreakTime: this.startBreakTime,
            lastThrow: this.lastThrow,
            lastMessageSent: this.lastMessageSent,
            lastGoodPosition: this.lastGoodPosition,
            movedAt: this.movedAt
        }
    };

    // Copy all methods such as 'isMoving', 'isGliding', 'isFlying', 'isEmoting', etc to player data
    for(const property in this) {
        if(!property.startsWith("is")) continue;

        // @ts-expect-error
        playerData[property] = this[property];
    }

    return playerData;
};

/**
 * @remarks Determine how far the player can place blocks according to their gamemode and input method
 * @returns {number} - How far the player can break blocks
 */
Player.prototype.getMaxBlockPlaceDistance = function() {
    // Regardless of what input method you are using, the block place reach is capped if you are on survival
    if(this.getGameMode() === GameMode.Survival) return 5;

    const inputMode = this.inputInfo.lastInputModeUsed;

    /*
	When in Creative, the place block reach changes depending on the device:
		- Desktop: Reach limit remains the same
		- Mobile: Reach limit increases to ~11 blocks, depending on angle
		- Console: Reach liit can vary around 5-6.5 blocks, depending on device
    */
    switch(inputMode) {
        case InputMode.KeyboardAndMouse:
            return 5;

        case InputMode.Touch:
            return 11.5;

        case InputMode.Gamepad:
            // Xbox consoles have a reach limit of ~5 blocks, meanwhile Switch consoles have a reach limit of ~6.5 blocks
            // We can't differentiate between the two platforms so the Switch reach limit is used
            return 6.5;

        case InputMode.MotionController:
            // Unknown
            return 12;
    }
};

/**
 * @remarks Make the player unable to move
 * @param {Player} [initiator] - The player that initiated the request
 */
Player.prototype.freeze = function(initiator) {
    if(initiator) {
        tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has frozen ${this.name}.`);

        this.sendMessage("§r§6[§aScythe§6]§r You have been frozen by a staff member.");
    }

    this.setDynamicProperty("frozen", true);

    // To prohibit the player from being able to attack entities
    this.addEffect("weakness", 99999, { amplifier: 255, showParticles: false });
    this.triggerEvent("scythe:freeze");
    this.inputPermissions.setPermissionCategory(InputPermissionCategory.Movement, false);
};

/**
 * @remarks Restore the player's ability to move
 * @param {Player} [initiator] - The player that initiated the request
 */
Player.prototype.unfreeze = function(initiator) {
    if(initiator) {
        tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has unfrozen ${this.name}.`);

        this.sendMessage("§r§6[§aScythe§6]§r You have been unfrozen.");
    }

    this.setDynamicProperty("frozen", false);

    this.removeEffect("weakness");
    this.triggerEvent("scythe:unfreeze");
    this.inputPermissions.setPermissionCategory(InputPermissionCategory.Movement, true);
};

/**
 * @remarks Kick the calling player from the game
 * @param {Player | null} [initiator] - The player that initiated the kick
 * @param {String} [reason] - The reason for the kick
 * @param {Boolean} [silent] - If the player should be shown a vague disconnect message instead of a kick message
 */
Player.prototype.kick = function(initiator, reason = "No reason specified", silent = false) {
    if(initiator) tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has kicked ${this.name} for ${reason}.`);

    silent ? this.triggerEvent("scythe:kick") : this.runCommand(`kick @s ${reason}`);
};

/**
 * @remarks Returns whether or not the player is muted
 * @returns {Boolean} - If the player is muted
 */
Player.prototype.isMuted = function() {
    return !!this.getDynamicProperty("muted");
};

/**
 * @remarks Prevent a player from being able to send chat messages
 * @param {Player | null} [initiator] - The player that muted the player
 * @param {String} [reason] - The reason for the mute
 */
Player.prototype.mute = function(initiator, reason = "No reason specified") {
    if(initiator) {
        tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has muted ${this.name} for ${reason}.`);

        this.sendMessage(`§r§6[§aScythe§6]§r You have been muted for ${reason}.`);
    }

    // Mark the player as muted
    this.setDynamicProperty("muted", true);

    // Remove the player's chat ability
    this.runCommand("ability @s mute true");
};

/**
 * @remarks Restore's a player ability to send chat messages
 * @param {Player | null} [initiator] - The player that unmuted the player
 * @param {String} [reason] - The reason for the unmute
 */
Player.prototype.unmute = function(initiator, reason = "No reason specified") {
    if(initiator) {
        tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has unmuted ${this.name} for ${reason}.`);

        this.sendMessage(`§r§6[§aScythe§6]§r You have been unmuted.`);
    }

    // Unmark the player as muted
    this.setDynamicProperty("muted", false);

    // Restore the player's chat ability
    this.runCommand("ability @s mute false");
};

/**
 * @remarks Checks if the player is either pressing one of the movement keys (WASD) or is moving the joystick
 * @returns {Boolean} - Whether or not the player is using the input keys
 */
Player.prototype.isUsingInputKeys = function() {
    /*
    This is a good method to determine if a player is intentionally moving as it does not include movement from factors such as knockback, flowing water, pistons, etc
    The only problem is that this data comes directly from the MoveVector field from the PlayerAuthInput packet, meaning it could be easily spoofed by a hack client
    I'm not sure if Server Authoritative Movement triggers if the movement vector does not check out, so it might be necessary to implement checks for spoofed move vectors
    */
    const moveVector = this.inputInfo.getMovementVector();
    return moveVector.x !== 0 || moveVector.y !== 0;
};

/**
 * @remarks Wipe the ender chest of a player
 * @param {Player} [initiator] - The player that initiated the request
 */
Player.prototype.wipeEnderchest = function(initiator) {
    if(initiator) tellAllStaff(`§r§6[§aScythe§6]§r ${initiator.name} has cleared ${this.name}'s enderchest.`);

    for(let i = 0; i < 27; i++) {
        this.runCommand(`replaceitem entity @s slot.enderchest ${i} air`);
    }
};
```

`scripts/index.d.ts`:

```ts
import { Player, Entity, ItemStack, Vector2, Vector3, GameMode } from "@minecraft/server";

declare module "@minecraft/server" {
	interface Player {
		// Booleans
		lastSprintState: boolean
		isUsingItem: boolean

		// Strings
		heldItem: string

		// Numbers
		blocksBroken: number
		clicks: number
		firstAttack: number
		lastLeftClick: number
		lastMessageSent: number
		lastThrow: number
		startBreakTime: number
		movedAt: number
		itemUsedAt: number

		// Arrays
		entitiesHit: Set<String>
		reports: Set<String>
		
		// Objects
		lastCursorItem?: ItemStack
		lastOffhandItem?: ItemStack
		lastGoodPosition: Vector3

		// Custom functions
		addOp(initiator?: Player): void
		removeOp(initiator?: Player): void

		ban(initiator?: Player | null, reason?: String, time?: Number | null): void

		enableFly(initiator?: Player): void
		disableFly(initiator?: Player): void

		getDebugData(): any

		getMaxBlockPlaceDistance(): number

		freeze(initiator?: Player): void
		unfreeze(initiator?: Player): void

		kick(initiator?: Player | null, reason?: String, silent?: Boolean): void

		isMuted(): boolean
		mute(initiator?: Player | null, reason?: String): void
		unmute(initiator?: Player | null, reason?: String): void

		isUsingInputKeys(): boolean

		wipeEnderchest(initiator?: Player): void
	}

	interface Entity {
		// Custom functions
		getClosestPlayer(): Player
		getScore(objective: String, defaultValue?: number): number
		setScore(objectiveName: String, value: number): void
	}
}
```

`scripts/loader.js`:

```js
// This is the initial file that runs. It is used to load everything for Scythe
import config from "./data/config.js";
import { system, world } from "@minecraft/server";

const latestConfigVer = "27";

// Set dynamic properties
system.run(() => {
	if(!world.getDynamicProperty("globalmute")) {
		const data = { muted: false, muter: "" };

		world.setDynamicProperty("globalmute", JSON.stringify(data));
	}

	if(!world.getDynamicProperty("unbanQueue")) {
		/*
			The data in the object should have the following format:

			Key: <player username>
			Value: [<unbanner>, <reason>]

			The data is stored in an array to conserve storage as dynamic property strings have a limit of 32767 characters
		*/
		world.setDynamicProperty("unbanQueue", "{}");
	}

	const dpConfig = world.getDynamicProperty("config"); // Object
	if(dpConfig) {
		// @ts-expect-error
		const parsedConfig = JSON.parse(dpConfig);

		for(const i of Object.keys(parsedConfig)) {
			config[i] = parsedConfig[i];
		}

		console.log("Loaded Scythe config from Dynamic Properties");
	}

	// Update config to support the latest Scythe version
	/* eslint-disable no-fallthrough */
	switch(config.version) {
		case "3.0.0":
			config.modules.badpackets4 = {
				enabled: true,
				punishment: "ban",
				punishmentLength: "",
				minVlbeforePunishment: 1
			};

			config.modules.inventorymodsB = {
				enabled: true,
				punishment: "none",
				minVlbeforePunishment: 1
			};

		case "3.1.1":
			config.modules.autooffhandA = {
				enabled: true,
				punishment: "none",
				minVlbeforePunishment: 0
			};

			config.modules.autooffhandB = {
				enabled: true,
				punishment: "none",
				minVlbeforePunishment: 0
			};

			config.modules.autooffhandC = {
				enabled: true,
				punishment: "none",
				minVlbeforePunishment: 0
			};

		case "6":
			// @ts-expect-error
			config.modules.badpackets5 = {
				enabled: true,
				punishment: "ban",
				punishmentLength: "",
				minVlbeforePunishment: 1
			};
		
		case "7":
			config.modules.reachB = {
				enabled: false,
				punishment: "none",
				minVlbeforePunishment: 1
			};

			config.modules.reachC = {
				enabled: false,
				punishment: "none",
				minVlbeforePunishment: 1
			};
		
		case "8":
			config.modules.badpackets5.exclude_scythe_op = true;

		case "9":
			delete config.modules.reachB.reach;
			delete config.modules.reachC.reach;

		case "10":
			config.misc_modules.antiSpam = {
				enabled: config.modules.spammerE.enabled,
				messageRatelimit: config.modules.spammerE.messageRatelimit
			};

			delete config.modules.spammerE;
		
		case "11":
			delete config.modules.reachA.excluded_entities;

		case "12":
			for(const command of Object.values(config.customcommands)) {
				// @ts-expect-error
				delete command.aliases;
			}
		
		case "13":
			config.modules.badpackets1 = {
				enabled: true,
				punishment: "ban",
				punishmentLength: "",
				minVlbeforePunishment: 1
			};
		
		case "14":
			delete config.misc_modules.itemSpawnRateLimit;

		case "15":
			delete config.autoban;

		case "16":
			config.modules.invalidsprintF = {
				enabled: true,
				punishment: "none",
				minVlbeforePunishment: 0
			};

		case "17":
			config.modules.invalidsprintB = {
				enabled: false,
				punishment: "none",
				minVlbeforePunishment: 0
			};

			config.modules.invalidsprintC = {
				enabled: true,
				punishment: "none",
				minVlbeforePunishment: 0
			};

			config.modules.invalidsprintD = {
				enabled: false,
				punishment: "none",
				minVlbeforePunishment: 0
			};

			config.modules.invalidsprintE = {
				enabled: true,
				punishment: "none",
				minVlbeforePunishment: 0
			};

			delete config.customcommands.invalidsprint;

		case "18":
			config.modules.inventorymodsA = {
				enabled: false,
				punishment: "none",
				minVlbeforePunishment: 0
			};
		
		case "19":
			// Convert the previous time in ticks to milliseconds
			config.modules.killauraA.min_item_use_time = config.modules.killauraA.rightTicks * 50;
			delete config.modules.killauraA.rightTicks;

		case "20":
			delete config.misc_modules.antiGamemode;

		case "21":
			delete config.modules.badpackets2.maxLength;

		case "22":
			delete config.modules.noslowA;
			delete config.modules.inventorymodsB;

		case "23":
			delete config.modules.killauraD;
			delete config.modules.killauraE;

		case "24":
			delete config.modules.autooffhandB;
			delete config.modules.autooffhandC;

		case "25":
			config.commands = config.customcommands;

			delete config.customcommands;

		case "26":
			config.misc_modules.chatExtensions = {
				enabled: true,
				customTags: true,
				filterUnicodeChat: config.misc_modules.filterUnicodeChat.enabled
			};

			delete config.misc_modules.filterUnicodeChat;

		case latestConfigVer:
			break;

		default:
			console.error(`Unknown config revision ${config.version}. It is probably best we revert to the default config.`);
			world.setDynamicProperty("config", undefined);
	}

	config.version = latestConfigVer;

	// Once we have loaded the config, load the anticheat core
	import("./main.js");

	import("./checks/registry.js");
	import("./modules/registry.js");

	console.log("Scythe has successfully loaded!");
});

// Load class extensions
import "./extensions/Entity.js";
import "./extensions/Player.js";

// Register all commands
import "./commands/moderation/kick.js";
import "./commands/other/help.js";
import "./commands/moderation/notify.js";
import "./commands/moderation/op.js";
import "./commands/moderation/ban.js";
import "./commands/moderation/mute.js";
import "./commands/moderation/unmute.js";
import "./commands/other/credits.js";
import "./commands/settings/module.js";
import "./commands/settings/modules.js";
import "./commands/utility/tag.js";
import "./commands/utility/ecwipe.js";
import "./commands/utility/freeze.js";
import "./commands/moderation/stats.js";
import "./commands/utility/fullreport.js";
import "./commands/utility/vanish.js";
import "./commands/utility/fly.js";
import "./commands/utility/invsee.js";
import "./commands/utility/cloneinv.js";
import "./commands/other/report.js";
import "./commands/moderation/unban.js";
import "./commands/utility/ui.js";
import "./commands/moderation/resetwarns.js";
import "./commands/other/version.js";
import "./commands/moderation/deop.js";
import "./commands/moderation/globalmute.js";
import "./commands/utility/gma.js";
import "./commands/utility/gmc.js";
import "./commands/utility/gms.js";
import "./commands/utility/gmsp.js";
import "./commands/settings/resetconfig.js";
```

`scripts/main.js`:

```js
// @ts-check
import config from "./data/config.js";
import checks from "./checks/registry.js";
import modules from "./modules/registry.js";
import { world, system, Player, EquipmentSlot, GameMode } from "@minecraft/server";
import { tellAllStaff } from "./util.js";
import { banMessage } from "./assets/ban.js";
import { mainGui, playerSettingsMenuSelected } from "./assets/ui.js";
import { commandHandler } from "./commands/handler.js";

world.beforeEvents.chatSend.subscribe((msg) => {
	const { sender: player } = msg;

	if(player.isMuted()) {
		player.sendMessage("§r§6[§aScythe§6]§r Your message was not sent as you are currently muted.");
		msg.cancel = true;
	}

	commandHandler(msg);

	// @ts-expect-error
	const globalmute = JSON.parse(world.getDynamicProperty("globalmute"));
	if(!msg.cancel && globalmute.muted && !player.hasTag("op")) {
		player.sendMessage(`§r§6[§aScythe§6]§r Your message was not sent as the chat is disabled by ${config.commands.globalmute.showModeratorName ? globalmute.muter : "a server admin"}.`);
		msg.cancel = true;
	}
});

system.runInterval(() => {
	// Run as each player
	const players = world.getPlayers();
	// Oddly enough, this method of looping over all online player's is slightly more efficient than `for(const player of players)`
	for(let i = 0; i < players.length; i++) {
		const player = players[i];

		try {
			// Get the item in the player's offhand
			const offhandItem = player.getComponent("equippable")?.getEquipment(EquipmentSlot.Offhand);

			if(config.modules.nukerA.enabled && player.blocksBroken >= 1) checks.nukerA.tick(player);
			if(config.modules.killauraC.enabled && player.entitiesHit.size >= 1) checks.killauraC.tick(player);

			if(config.modules.badpackets1.enabled) checks.badpackets1.tick(player);

			// Check if the player just started sprinting
			if(!player.lastSprintState && player.isSprinting) {
				if(config.modules.invalidsprintA.enabled) checks.invalidsprintA.tick(player);
				if(config.modules.invalidsprintB.enabled) checks.invalidsprintB.tick(player);
				if(config.modules.invalidsprintC.enabled) checks.invalidsprintC.tick(player);
				if(config.modules.invalidsprintD.enabled) checks.invalidsprintD.tick(player);
				if(config.modules.invalidsprintE.enabled) checks.invalidsprintE.tick(player);
				if(config.modules.invalidsprintF.enabled) checks.invalidsprintF.tick(player);
			}

			// Check if an item was equipped to the offhand
			if(!player.lastOffhandItem && offhandItem) {
				if(config.modules.autooffhandA.enabled) checks.autooffhandA.tick(player);
			}

			/*
			The Minecraft world has an invisible barrier at Y level -104 that is impossible to pass through
			Using TP hacks or glitches, it is possible to go beyond that barrier, so we bring the player back to -104 if they go beyond it
			*/
			if(player.location.y < -104) player.tryTeleport({ x: player.location.x, y: -104, z: player.location.z });

			if(config.misc_modules.worldborder.enabled) modules.WorldBorder.tick(player);

			if(player.getDynamicProperty("vanished")) player.onScreenDisplay.setActionBar("§aYOU ARE VANISHED!");

			player.lastOffhandItem = offhandItem;

			// Store the players last good position
			// When a movement-related check flags the player, they will be teleported to this position
			// xRot and yRot being 0 means the player position was modified from player.teleport, which we should ignore
			const rotation = player.getRotation();
			if(rotation.x !== 0 && rotation.y !== 0) player.lastGoodPosition = player.location;

			player.lastSprintState = player.isSprinting;
		} catch (/** @type {any} */ error) {
			console.error(error.stack);
			if(player.hasTag("errorlogger")) tellAllStaff(`§r§6[§aScythe§6]§r There was an error while running the tick event. Please forward this message to https://discord.gg/9m9TbgJ973.\n-------------------------\n${error}\n${error.stack || "\n"}-------------------------`, ["errorlogger"]);
		}
	}
}, 1);

world.beforeEvents.playerBreakBlock.subscribe((data) => {
	const { player, block } = data;

	if(config.debug) console.warn(`${player.name} has broken the block ${block.typeId}`);
});

world.afterEvents.playerSpawn.subscribe(({ initialSpawn, player }) => {
	if(!initialSpawn) return;

	// Check if the player is banned, and if so show them the ban message
	if(player.getDynamicProperty("banInfo")) banMessage(player);

	// Declare all needed variables
	player.lastGoodPosition = player.location;

	// Remove tags from previous session
	player.removeTag("hasGUIopen");
	player.removeTag("left");

	// This is used in the onJoin.json animation to check if Beta APIs are enabled
	player.setScore("gametestapi", 1);

	// @ts-expect-error
	const globalmute = JSON.parse(world.getDynamicProperty("globalmute"));
	if(globalmute.muted && player.hasTag("op")) player.sendMessage(`§r§6[§aScythe§6]§r NOTE: Chat has been currently disabled by ${globalmute.muter}. Chat can be re-enabled by running the !globalmute command.`);

	// If enabled from previous login then activate
	if(player.hasTag("flying") && player.getGameMode() !== GameMode.Creative) player.runCommand("ability @s mayfly true");
	if(player.isMuted()) player.runCommand("ability @s mute true");
	if(player.getDynamicProperty("frozen")) player.triggerEvent("scythe:freeze");
});

world.afterEvents.entityHitEntity.subscribe(({ hitEntity: entity, damagingEntity: player }) => {
	// Hitting an end crystal causes an error when trying to get the entity location, so we make sure the entity is valid to fix that
	if(!(player instanceof Player) || !entity.isValid) return;

	tellAllStaff(`§߈§r§6[§aScythe§6]§r §breceived §aATTACK§r action from: §g${player.name} §7(isSprinting=${player.isSprinting})`, ["actionlogger"]);

	// Check if the player was hit with the UI item, and if so open the UI for that player
	if(config.commands.ui.enabled && entity instanceof Player && !config.commands.ui.requiredTags.some(tag => !player.hasTag(tag))) {
		const container = player.getComponent("inventory")?.container;
		if(!container) return; // This should not happen

		const item = container.getItem(player.selectedSlotIndex);
		if(item?.typeId === config.commands.ui.ui_item && item.nameTag === config.commands.ui.ui_item_name) {
			playerSettingsMenuSelected(player, entity);
		}
	}
});

world.beforeEvents.itemUse.subscribe((itemUse) => {
	const { source: player } = itemUse;
	if(!(player instanceof Player)) return;

	// Patch bypasses for the freeze system
	if(player.getDynamicProperty("frozen")) itemUse.cancel = true;
});

world.afterEvents.itemUse.subscribe(({ itemStack: item, source: player }) => {
	// itemUse can be triggered from entities
	if(!(player instanceof Player)) return;

	// If the player is holding the UI axe and has the proper permissions, then open the UI
	if(
		config.commands.ui.enabled &&
		item.typeId === config.commands.ui.ui_item &&
		item.nameTag === config.commands.ui.ui_item_name &&
		!config.commands.ui.requiredTags.some(tag => !player.hasTag(tag))
	) {
		mainGui(player);
	}
});

world.afterEvents.playerInventoryItemChange.subscribe(({ itemStack, player, slot }) => {
	// Check if the item in the player's current selected slot has changed
	if(slot === player.selectedSlotIndex) {
		player.heldItem = itemStack?.typeId ?? "minecraft:air";
	}
});

world.afterEvents.itemStartUse.subscribe(({ source: player }) => {
	player.isUsingItem = true;
	player.itemUsedAt = Date.now();
});

world.afterEvents.itemStopUse.subscribe(({ source: player }) => {
	player.isUsingItem = false;
});

world.afterEvents.playerHotbarSelectedSlotChange.subscribe(({ player, itemStack }) => {
	// Update the player's stored held item after changing their selected slot
	player.heldItem = itemStack?.typeId ?? "minecraft:air";
});

world.afterEvents.playerSwingStart.subscribe(({ player }) => {
	player.lastLeftClick = Date.now();
});

system.afterEvents.scriptEventReceive.subscribe(({ sourceEntity: player, id }) => {
	if(!(player instanceof Player) || !id.startsWith("scythe:")) return;

	const splitId = id.split(":");
	switch(splitId[1]) {
		case "startMove":
			player.movedAt = Date.now();
			break;

		// Backup command to reset the config in emergency cases
		case "resetconfig":
			// Nice try...
			if(!player.hasTag("op")) break;

			world.setDynamicProperty("config", undefined);
			player.sendMessage("§r§6[§aScythe§6]§r The scythe config has been reset. Run '/reload' to apply the changes.");
			break;
	}
});

system.beforeEvents.watchdogTerminate.subscribe((watchdogTerminate) => {
	// Prevent malicious users from purposely lagging out scripts in order to force the world to crash from the Scripting API's Watchdog
	watchdogTerminate.cancel = true;

	tellAllStaff(`§r§6[§aScythe§6]§r A ${watchdogTerminate.terminateReason} watch dog exception has been detected and has been automatically cancelled.`);
});

// When using /reload, the variables defined in playerSpawn event do not persist so we reapply them
system.run(() => {
	const players = world.getPlayers();
	for(const player of players) {
		player.lastGoodPosition = player.location;
		player.heldItem = player.getComponent("inventory")?.container?.getItem(player.selectedSlotIndex)?.typeId ?? "minecraft:air";
	}
});
```

`scripts/modules/AntiArmorStandCluster.js`:

```js
// @ts-check
import Module from "./Module.js";
import { tellAllStaff } from "../util.js";
import { world } from "@minecraft/server";

class AntiArmorStandCluster extends Module {
	/**
	 * @class
	 * @description Prevent lag machines that involve a tight cluster of armor stands
	 */
	constructor() {
		super({
			name: "antiArmorStandCluster"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			afterEntitySpawn: world.afterEvents.entitySpawn.subscribe(this.afterEntitySpawn.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.entitySpawn.unsubscribe(this.callbacks.afterEntitySpawn);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").EntitySpawnAfterEvent} data
	 */
	afterEntitySpawn({ entity }) {
		if(entity.typeId !== "minecraft:armor_stand") return;

		// Get all nearby armor stand entities
		const entities = entity.dimension.getEntities({
			location: entity.location,
			maxDistance: this.config.radius,
			type: "armor_stand"
		});

		if(entities.length < this.config.max_armor_stand_count) return;

		tellAllStaff(`§r§6[§aScythe§6]§r Potential lag machine detected at X: ${Math.trunc(entity.location.x)}, Y: ${Math.trunc(entity.location.y)}, Z: ${Math.trunc(entity.location.z)}. There are ${entities.length}/${this.config.max_armor_stand_count} armor stands in this area.`, ["notify"]);

		for(const entityLoop of entities) {
			entityLoop.remove();
		}
	}
}

export default new AntiArmorStandCluster();
```

`scripts/modules/AntiSpam.js`:

```js
// @ts-check
import Module from "./Module.js";
import { tellAllStaff } from "../util.js";
import { world } from "@minecraft/server";

class AntiSpam extends Module {
	/**
	 * @class
	 * @description Prevent players from flooding the chat by sending too many messages
	 */
	constructor() {
		super({
			name: "antiSpam"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforeChatSend: world.beforeEvents.chatSend.subscribe(this.beforeChatSend.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.chatSend.unsubscribe(this.callbacks.beforeChatSend);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").ChatSendBeforeEvent} msg
	 */
	beforeChatSend(msg) {
		const { sender, message } = msg;
		if(sender.hasTag("op")) return;

		const now = Date.now();
		const messageDelay = now - sender.lastMessageSent;

		if(messageDelay < this.config.messageRatelimit) {
			tellAllStaff(`§o§7<${sender.name}> ${message}\n§r§6[§aScythe§6]§r ${sender.name}'s message has been blocked due to spam. (delay=${messageDelay})`, ["notify"]);

			sender.sendMessage("§r§6[§aScythe§6]§r Stop spamming! You are sending messages too fast.");
			msg.cancel = true;
		}

		sender.lastMessageSent = now;
	}
}

export default new AntiSpam();
```

`scripts/modules/ChatExtensions.js`:

```js
// @ts-check
import Module from "./Module.js";
import config from "../data/config.js";
import { world } from "@minecraft/server";

class ChatExtensions extends Module {
	/**
	 * @class
	 * @description Additional features to game chat
	 */
	constructor() {
		super({
			name: "chatExtensions"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			afterPlayerSpawn: world.afterEvents.playerSpawn.subscribe(this.afterPlayerSpawn.bind(this)),
			beforeChatSend: world.beforeEvents.chatSend.subscribe(this.beforeChatSend.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.playerSpawn.unsubscribe(this.callbacks.afterPlayerSpawn);
		world.beforeEvents.chatSend.unsubscribe(this.callbacks.beforeChatSend);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerSpawnAfterEvent} data
	 */
	afterPlayerSpawn({ initialSpawn, player }) {
		if(!initialSpawn || !this.config.customTags) return;

		const { mainColor, borderColor, playerNameColor, defaultTag } = config.commands.tag;

		let tag = player.getDynamicProperty("tag");

		// Add default tag if enabled
		if(!tag && defaultTag) tag = defaultTag;

		if(tag) player.nameTag = `${borderColor}[§r${mainColor}${tag}${borderColor}]§r ${playerNameColor}${player.nameTag}`;
	}

	/**
	 * @param {import("@minecraft/server").ChatSendBeforeEvent} msg
	 */
	beforeChatSend(msg) {
		if(msg.cancel) return;

		const { sender, message } = msg;
		if(sender.name === sender.nameTag && !this.config.filterUnicodeChat) return;

		// Adds user custom tags to their messages and filter any non-ASCII characters
		const playerTag = (this.config.customTags && sender.name !== sender.nameTag) ? `${sender.nameTag}§7:§r` : `<${sender.nameTag}>`;
		const newMsg = this.config.filterUnicodeChat ? message.replace(/[^\x00-\xFF]/g, "") : message;

		world.sendMessage(`${playerTag} ${newMsg}`);
		msg.cancel = true;
	}
}

export default new ChatExtensions();
```

`scripts/modules/Module.js`:

```js
import config from "../data/config.js";

class Module {
	/**
	 * @class
	 * @param {Object} data
	 * @param {String} data.name - The name of the module
	 * @throws
	 */
	constructor({ name }) {
		this.name = name;

		const moduleConfig = config.misc_modules[this.name];
		if(!moduleConfig) throw Error(`No config data was found for module ${this.name}`);

		Object.defineProperty(moduleConfig, "_enabled", {
			// We dont want the command or UI interfaces to show the '_enabled' field
			enumerable: false,
			writable: true,
			value: moduleConfig.enabled
		});

		const self = this;
		Object.defineProperty(moduleConfig, "enabled", {
			enumerable: true,
			get: function() {
				return this._enabled;
			},
			set: function(value) {
				if(config.debug) console.log(`${this._enabled} --> ${value}`);
				// Module was enabled
				if(!this._enabled && value) self.enable?.();

				// Module was disabled
				if(this._enabled && !value) self.disable?.();

				this._enabled = value;
			}
		});

		this.config = moduleConfig;
	}
}

export default Module;
```

`scripts/modules/OreAlerts.js`:

```js
// @ts-check
import Module from "./Module.js";
import { tellAllStaff } from "../util.js";
import { world } from "@minecraft/server";

class OreAlerts extends Module {
	/**
	 * @class
	 * @description Prevent players from flooding the chat by sending too many messages
	 */
	constructor() {
		super({
			name: "oreAlerts"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			beforePlayerBreakBlock: world.beforeEvents.playerBreakBlock.subscribe(this.beforePlayerBreakBlock.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.beforeEvents.playerBreakBlock.unsubscribe(this.callbacks.beforePlayerBreakBlock);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerBreakBlockBeforeEvent} msg
	 */
	beforePlayerBreakBlock({ player, block }) {
		if(player.hasTag("op")) return;

		if(this.config.blocks.includes(block.typeId)) {
			tellAllStaff(`§r§6[§aScythe§6]§r [Ore Alerts] ${player.name} has broken 1x ${block.typeId}`, ["notify"]);
		}
	}
}

export default new OreAlerts();
```

`scripts/modules/WelcomeMessage.js`:

```js
// @ts-check
import Module from "./Module.js";
import { world } from "@minecraft/server";

class WelcomeMessage extends Module {
	/**
	 * @class
	 * @description Send a welcome message to players that join the game
	 */
	constructor() {
		super({
			name: "welcomeMessage"
		});

		if(this.config.enabled) this.enable();
	}

	enable() {
		this.callbacks = {
			afterPlayerSpawn: world.afterEvents.playerSpawn.subscribe(this.afterPlayerSpawn.bind(this))
		};
	}

	disable() {
		if(!this.callbacks) return;

		world.afterEvents.playerSpawn.unsubscribe(this.callbacks.afterPlayerSpawn);
		delete this.callbacks;
	}

	/**
	 * @param {import("@minecraft/server").PlayerSpawnAfterEvent} data
	 */
	afterPlayerSpawn({ initialSpawn, player }) {
		if(!initialSpawn) return;

        // If the welcome message has '[@player]' in it, replace it with the player's name
        const message = this.config.message.replace(/\[@player]/g, player.name);
        player.sendMessage(message);
	}
}

export default new WelcomeMessage();
```

`scripts/modules/WorldBorder.js`:

```js
// @ts-check
import Module from "./Module.js";

class WorldBorder extends Module {
	/**
	 * @class
	 * @description Prevent players from exceeding a portion of the map
	 */
	constructor() {
		super({
			name: "worldborder"
		});
	}

	/**
	 * @param {import("@minecraft/server").Player} player
	 */
	tick(player) {
		if(player.hasTag("op")) return;

		if(Math.abs(player.location.x) > this.config.max_x || Math.abs(player.location.z) > this.config.max_z) {
			player.tryTeleport({
				x: player.location.x - (player.location.x >= 0 ? 1 : -1),
				y: player.location.y,
				z: player.location.z - (player.location.z >= 0 ? 1 : -1)
			}, {
				checkForBlocks: false
			});

			player.sendMessage("§r§6[§aScythe§6]§r You have reached the world border.");
		}
	}
}

export default new WorldBorder();
```

`scripts/modules/registry.js`:

```js
export default {
	AntiArmorStandCluster: (await import("./AntiArmorStandCluster.js")).default,
	AntiSpam: (await import("./AntiSpam.js")).default,
	ChatExtensions: (await import("./ChatExtensions.js")).default,
	OreAlerts: (await import("./OreAlerts.js")).default,
	WelcomeMessage: (await import("./WelcomeMessage.js")).default,
	WorldBorder: (await import("./WorldBorder.js")).default
};
```

`scripts/package.json`:

```json
{
  "name": "scythe-anticheat",
  "version": "4.0.0",
  "description": "Scythe Anticheat - The best anticheat designed for Minecraft Bedrock realms/worlds/servers",
  "main": "main.js",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Scythe-Anticheat/Scythe-AntiCheat.git"
  },
  "keywords": [
    "minecraft",
    "mcpe",
    "anticheat",
    "minecraft-anti-cheat",
    "mcfunction",
    "minecraft-bedrock",
    "mcfunctions",
    "minecraft-bedrock-anticheat",
    "minecraft-anticheat",
    "gametest",
    "mcpe-anticheat",
    "mc-anticheat",
    "mcbe-anticheat",
    "minecraft-bedrock-anti-cheat"
  ],
  "author": "MrDiamond64",
  "license": "GPL-3.0",
  "bugs": {
    "url": "https://github.com/Scythe-Anticheat/Scythe-AntiCheat/issues"
  },
  "homepage": "https://github.com/Scythe-Anticheat/Scythe-AntiCheat#readme",
  "devDependencies": {
    "@minecraft/server": "2.5.0-beta.1.21.130-stable",
    "@minecraft/server-ui": "2.1.0-beta.1.21.130-stable",
    "eslint": "^8.57.0"
  }
}

```

`scripts/util.js`:

```js
// @ts-check
import config from "./data/config.js";
import { world, Player } from "@minecraft/server";

/**
 * @name flag
 * @description Sends a notification to staff members, and punish the player for cheating
 * @param {Player} player - The player object
 * @param {string} check - What check ran the function
 * @param {string} checkType - What sub-check ran the function (ex. A, B, C)
 * @param {string} hackType - What the hack is considered as (ex. movement, combat, exploit)
 * @param {string} [debug] - Debug info
 * @param {boolean} [shouldTP] - Whether to reset the player's position
 * @example flag(player, "Spammer", "B", "Combat");
 */
export function flag(player, check, checkType, hackType, debug, shouldTP = false) {
    // validate that required params are defined
    if(!(player instanceof Player)) throw TypeError(`Error: player is not an instance of Player.`);
    if(typeof check !== "string") throw TypeError(`Error: check is type of ${typeof check}. Expected "string"`);
    if(typeof checkType !== "string") throw TypeError(`Error: checkType is type of ${typeof checkType}. Expected "string"`);
    if(typeof hackType !== "string") throw TypeError(`Error: hackType is type of ${typeof hackType}. Expected "string"`);
    if(typeof debug !== "string" && debug !== undefined) throw TypeError(`Error: debug is type of ${typeof debug}. Expected "string" or "undefined"`);
    if(typeof shouldTP !== "boolean") throw TypeError(`Error: shouldTP is type of ${typeof shouldTP}. Expected "boolean"`);

    // @ts-expect-error
    const checkData = config.modules[check.toLowerCase() + checkType];
    if(!checkData) throw Error(`No valid check data was found for ${check}/${checkType}.`);

    if((config.disableFlagsFromScytheOp || checkData.exclude_scythe_op) && player.hasTag("op")) return;

    if(debug && debug.length > 256) {
        /*
        Back when the NBT exploit was still a major thing, Scythe had a check called IllegalItemsF that would log if an item had a name greater than 32 characters
        This check would return the item name as part of the debug data to fix any false positives if there was a vanilla item with a longer name
        The problem is that a malicious NBT could set an item's name to include thousands of characters which would lag and potentially crash any staff members who viewed the Scythe alert
        To solve this, a character limit of 256 was imposed to stop this type of attack
        
        While exploits such as NBTs are no longer a concern, this is good pratice for any other currently present modules that could be abused in a similiar fashion
        */
        const extraLength = debug.length - 256;
        debug = debug.slice(0, 256) + ` (+${extraLength} additional characters)`;
    }

    // If debug is enabled then log everything we know about the player
    if(config.debug) {
        const data = {
            timestamp: Date.now(),
            time: new Date().toISOString(),
            check: `${check}/${checkType}`,
            debug: `${debug}§r`,
            shouldTP,
            playerData: player.getDebugData()
        };

        console.warn(JSON.stringify(data));
    }

    if(shouldTP) player.tryTeleport(player.lastGoodPosition, { dimension: player.dimension, rotation: { x: 0, y: 0 }, keepVelocity: false });

    const scoreboardObjective = check.toLowerCase() + "vl";

    // Create the violation scoreboard objective if it does not yet exist
    if(!world.scoreboard.getObjective(scoreboardObjective)) world.scoreboard.addObjective(scoreboardObjective, scoreboardObjective);

    let currentVl = player.getScore(scoreboardObjective);
    player.setScore(scoreboardObjective, ++currentVl);

    tellAllStaff(`§r§6[§aScythe§6]§r ${player.name}§r §1has failed §7(${hackType}) §4${check}/${checkType}${debug ? ` §7(${debug}§r§7)§4`: ""}. VL= ${currentVl}`, ["notify"]);

    // Handle punishments
    const { punishment } = checkData;

    if(currentVl < checkData.minVlbeforePunishment) return;

    switch(punishment) {
        case "kick": {
            tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has been automatically kicked by Scythe Anticheat for Unfair Advantage. Check: ${check}/${checkType}`, ["notify"]);

            player.kick(null, `§r§6[§aScythe§6]§r You have been kicked for hacking. Check: ${check}/${checkType}`);
            break;
        }

        case "ban": {
            const punishmentLength = checkData.punishmentLength?.toLowerCase();
            let banLength;

            if(punishmentLength) {
                banLength = isNaN(punishmentLength) ? parseTime(punishmentLength) : Number(punishmentLength);
            }

            player.ban(
                null,
                `Scythe Anticheat detected Unfair Advantage! Check: ${check}/${checkType}`,
                typeof banLength === "number" ? banLength : null
            );

            tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has been banned by Scythe Anticheat for Unfair Advantage. Check: ${check}/${checkType}`);
            break;
        }

        case "mute": {
            player.mute();
            player.sendMessage(`§r§6[§aScythe§6]§r You have been muted by Scythe Anticheat for Unfair Advantage. Check: ${check}/${checkType}`);

            tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has automatically been muted by Scythe Anticheat for Unfair Advantage. Check: ${check}/${checkType}.`);
            break;
        }

        case "freeze": {
            player.freeze();
            player.sendMessage("§r§6[§aScythe§6]§r You have been frozen by Scythe Anticheat for Unfair Advantage.");

            tellAllStaff(`§r§6[§aScythe§6]§r ${player.name} has automatically been frozen by Scythe Anticheat for Unfair Advantage. Check: ${check}/${checkType}.`);
            break;
        }

        case "none":
            break;

        default:
            throw Error(`Unknown punishment type "${punishment}".`);
    }
}

/**
 * @name parseTime
 * @param {string} str - The time value to convert to milliseconds
 * @example parseTime("24d"); // returns 2073600000
 * @remarks Parses a time string into milliseconds.
 * @returns {number | null} str - The converted string
 */
export function parseTime(str) {
    // validate that required params are defined
    if(typeof str !== "string") throw TypeError(`Error: str is type of ${typeof str}. Expected "string"`);

    // parse time values like 12h, 1d, 10m into milliseconds
    const time = str.match(/^(\d+)([smhdwy])$/);

    if(time) {
        const [, num, unit] = time;

        const ms = {
            s: 1000,
            m: 60000,
            h: 3600000,
            d: 86400000,
            w: 604800000,
            y: 31536000000
        }[unit];

        // @ts-expect-error
        return ms * Number(num);
    }

    return time;
}

/**
 * @name msToTime
 * @description Convert milliseconds into weeks, days, hours, minutes, and seconds
 * @param {number} ms - The string to convert
 * @example str(88200000); // Returns { d: 1, h: 0, m: 30, s: 0 }
 * @returns {{w: Number, d: Number, h: Number, m: Number, s: Number}} time
 */
export function msToTime(ms) {
    return {
        w: Math.floor(ms / (1000 * 60 * 60 * 24 * 7)),
        d: Math.floor((ms % (1000 * 60 * 60 * 24 * 7)) / (1000 * 60 * 60 * 24)),
        h: Math.floor((ms % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)),
        m: Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60)),
        s: Math.floor((ms % (1000 * 60)) / 1000)
    };
}

/**
 * @name capitalizeFirstLetter
 * @param {string} string - The string to modify
 * @remarks Capitalize the first character of a string
 * @returns {string} string - The updated string
 */
export function capitalizeFirstLetter(string) {
	return string[0].toUpperCase() + string.slice(1);
}

/**
 * @name findPlayerByName
 * @remarks Finds a player object by a player name
 * @param {string} name - The player to look for
 * @returns {Player | undefined} [player] - The player found
 */
export function findPlayerByName(name) {
    // Remove characters that may been added when the player's name was autofilled
	const searchName = name.toLowerCase().replace(/\\|@/g, "");

    /**
     * We want to first try and see if there is an exact match for the player name.
     * If there are no exact matches, we check if the name searched is a substring of a player name and return that
     */
    let partialMatch;

    const players = world.getPlayers();
    for(let i = 0; i < players.length; i++) {
        const player = players[i];

        const lowercaseName = player.name.toLowerCase();
        if(searchName === lowercaseName) return player;

        if(lowercaseName.includes(searchName)) partialMatch = player;
	}

    return partialMatch;
}

/**
 * @name tellAllStaff
 * @description Send a message to all Scythe-Opped players
 * @param {string} message - The message to send
 * @param {string[]} tags - What tags does a player require to get this message
 */
export function tellAllStaff(message, tags = ["op"]) {
    if(config.logAlertsToConsole && !tags.includes("actionlogger")) console.log(message.replace(/§./g, ""));

    const players = world.getPlayers({ tags });
    for(const player of players) {
        player.sendMessage(message);
    }
}

/**
 * @name getBlocksBetween
 * @remarks Find every possible coordinate between two sets of Vector3
 * @param {{ x: Number; y: Number; z: Number; }} pos1 - First set of coordinates
 * @param {{ x: Number; y: Number; z: Number; }} pos2 - Second set of coordinates
 * @returns {object[]} coordinates - Each possible coordinate
 */
export function getBlocksBetween(pos1, pos2) {
    const { x: minX, y: minY, z: minZ } = pos1;
    const { x: maxX, y: maxY, z: maxZ } = pos2;

    const coordinates = [];

    for(let x = minX; x <= maxX; x++) {
        for(let y = minY; y <= maxY; y++) {
            for(let z = minZ; z <= maxZ; z++) {
                coordinates.push({x, y, z});
            }
        }
    }

    return coordinates;
}
```